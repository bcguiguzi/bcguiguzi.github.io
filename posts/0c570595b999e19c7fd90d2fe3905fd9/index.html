<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>puzzle（0412）日历拼图 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="puzzle（0412）日历拼图" />
<meta property="og:description" content="目录
一，规则
二，每日拼图
2022年2月
2022年3月
竖条下滑问题
2022年4月
2022年5月
2022年6月
三，术语
四，启发式搜索策略
1，数独
2，策略一
3，策略二
4，策略三
5，策略四
6，策略五
7，策略六
五，数字化
1，读取图片并二值化
2，边缘检测
3，轮廓检测
4，求解格子尺寸、坐标
5，计算有效轮廓数量
6，坐标微调
7，手动删减轮廓
8，解析空出来的3个格子
8，连通性计算
9，完整代码
六，以解生解
1，大拇指
2，可视化
3，U型
4，新解
5，日期汇总
6，完整代码V1
7，BUG修复
8，日期优化（完整代码V2）
9，BUG修复、新增检查（完整代码V3）
七，说明
八，直接求解
1，可视化V2版
2，直接求解
一，规则 每天根据月、日、星期去掉3个格子，剩下的格子刚好全部覆盖。
日历拼图有两千多组合，如果所有组合都能拼的话，那真的太神奇了。
二，每日拼图 2022年2月 根据下面的数字化的方法，2022年2月1日-2月28日的答案分别是：
2月1日周二
1 0 1 8 2 2 0
1 1 1 8 8 2 0
0 3 3 9 8 2 2" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0c570595b999e19c7fd90d2fe3905fd9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-18T22:07:30+08:00" />
<meta property="article:modified_time" content="2023-10-18T22:07:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">puzzle（0412）日历拼图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%EF%BC%8C%E8%A7%84%E5%88%99-toc" style="margin-left:0px;"><a href="#%E4%B8%80%EF%BC%8C%E8%A7%84%E5%88%99" rel="nofollow">一，规则</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E6%AF%8F%E6%97%A5%E6%8B%BC%E5%9B%BE-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8C%E6%AF%8F%E6%97%A5%E6%8B%BC%E5%9B%BE" rel="nofollow">二，每日拼图</a></p> 
<p id="2022%E5%B9%B42%E6%9C%88-toc" style="margin-left:40px;"><a href="#2022%E5%B9%B42%E6%9C%88" rel="nofollow">2022年2月</a></p> 
<p id="2022%E5%B9%B43%E6%9C%88-toc" style="margin-left:40px;"><a href="#2022%E5%B9%B43%E6%9C%88" rel="nofollow">2022年3月</a></p> 
<p id="%E7%AB%96%E6%9D%A1%E4%B8%8B%E6%BB%91%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#%E7%AB%96%E6%9D%A1%E4%B8%8B%E6%BB%91%E9%97%AE%E9%A2%98" rel="nofollow">竖条下滑问题</a></p> 
<p id="2022%E5%B9%B44%E6%9C%88-toc" style="margin-left:40px;"><a href="#2022%E5%B9%B44%E6%9C%88" rel="nofollow">2022年4月</a></p> 
<p id="2022%E5%B9%B45%E6%9C%88-toc" style="margin-left:40px;"><a href="#2022%E5%B9%B45%E6%9C%88" rel="nofollow">2022年5月</a></p> 
<p id="6%E6%9C%88-toc" style="margin-left:40px;"><a href="#6%E6%9C%88" rel="nofollow">2022年6月</a></p> 
<p id="%E4%BA%8C%EF%BC%8C%E6%9C%AF%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%EF%BC%8C%E6%9C%AF%E8%AF%AD" rel="nofollow">三，术语</a></p> 
<p id="%E4%B8%89%EF%BC%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5-toc" style="margin-left:0px;"><a href="#%E4%B8%89%EF%BC%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5" rel="nofollow">四，启发式搜索策略</a></p> 
<p id="1%EF%BC%8C%E6%95%B0%E7%8B%AC-toc" style="margin-left:40px;"><a href="#1%EF%BC%8C%E6%95%B0%E7%8B%AC" rel="nofollow">1，数独</a></p> 
<p id="2%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%80-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%80" rel="nofollow">2，策略一</a></p> 
<p id="3%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%BA%8C-toc" style="margin-left:40px;"><a href="#3%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%BA%8C" rel="nofollow">3，策略二</a></p> 
<p id="4%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%89-toc" style="margin-left:40px;"><a href="#4%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%89" rel="nofollow">4，策略三</a></p> 
<p id="5%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E5%9B%9B-toc" style="margin-left:40px;"><a href="#5%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E5%9B%9B" rel="nofollow">5，策略四</a></p> 
<p id="6%EF%BC%8C%E7%AD%96%E7%95%A5%E4%BA%94-toc" style="margin-left:40px;"><a href="#6%EF%BC%8C%E7%AD%96%E7%95%A5%E4%BA%94" rel="nofollow">6，策略五</a></p> 
<p id="7%EF%BC%8C%E7%AD%96%E7%95%A5%E5%85%AD-toc" style="margin-left:40px;"><a href="#7%EF%BC%8C%E7%AD%96%E7%95%A5%E5%85%AD" rel="nofollow">7，策略六</a></p> 
<p id="%E4%BA%94%EF%BC%8C%E6%95%B0%E5%AD%97%E5%8C%96-toc" style="margin-left:0px;"><a href="#%E4%BA%94%EF%BC%8C%E6%95%B0%E5%AD%97%E5%8C%96" rel="nofollow">五，数字化</a></p> 
<p id="1%EF%BC%8C%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E4%BA%8C%E5%80%BC%E5%8C%96-toc" style="margin-left:40px;"><a href="#1%EF%BC%8C%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E4%BA%8C%E5%80%BC%E5%8C%96" rel="nofollow">1，读取图片并二值化</a></p> 
<p id="2%EF%BC%8C%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B" rel="nofollow">2，边缘检测</a></p> 
<p id="%C2%A03%EF%BC%8C%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B-toc" style="margin-left:40px;"><a href="#%C2%A03%EF%BC%8C%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B" rel="nofollow">3，轮廓检测</a></p> 
<p id="4%EF%BC%8C%E6%B1%82%E8%A7%A3%E6%A0%BC%E5%AD%90%E5%B0%BA%E5%AF%B8%E3%80%81%E5%9D%90%E6%A0%87-toc" style="margin-left:40px;"><a href="#4%EF%BC%8C%E6%B1%82%E8%A7%A3%E6%A0%BC%E5%AD%90%E5%B0%BA%E5%AF%B8%E3%80%81%E5%9D%90%E6%A0%87" rel="nofollow">4，求解格子尺寸、坐标</a></p> 
<p id="5%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%89%E6%95%88%E8%BD%AE%E5%BB%93%E6%95%B0%E9%87%8F-toc" style="margin-left:40px;"><a href="#5%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%89%E6%95%88%E8%BD%AE%E5%BB%93%E6%95%B0%E9%87%8F" rel="nofollow">5，计算有效轮廓数量</a></p> 
<p id="6%EF%BC%8C%E5%9D%90%E6%A0%87%E5%BE%AE%E8%B0%83-toc" style="margin-left:40px;"><a href="#6%EF%BC%8C%E5%9D%90%E6%A0%87%E5%BE%AE%E8%B0%83" rel="nofollow">6，坐标微调</a></p> 
<p id="7%EF%BC%8C%E6%89%8B%E5%8A%A8%E5%88%A0%E5%87%8F%E8%BD%AE%E5%BB%93-toc" style="margin-left:40px;"><a href="#7%EF%BC%8C%E6%89%8B%E5%8A%A8%E5%88%A0%E5%87%8F%E8%BD%AE%E5%BB%93" rel="nofollow">7，手动删减轮廓</a></p> 
<p id="8%EF%BC%8C%E8%A7%A3%E6%9E%90%E7%A9%BA%E5%87%BA%E6%9D%A5%E7%9A%843%E4%B8%AA%E6%A0%BC%E5%AD%90-toc" style="margin-left:40px;"><a href="#8%EF%BC%8C%E8%A7%A3%E6%9E%90%E7%A9%BA%E5%87%BA%E6%9D%A5%E7%9A%843%E4%B8%AA%E6%A0%BC%E5%AD%90" rel="nofollow">8，解析空出来的3个格子</a></p> 
<p id="8%EF%BC%8C%E8%BF%9E%E9%80%9A%E6%80%A7%E8%AE%A1%E7%AE%97-toc" style="margin-left:40px;"><a href="#8%EF%BC%8C%E8%BF%9E%E9%80%9A%E6%80%A7%E8%AE%A1%E7%AE%97" rel="nofollow">8，连通性计算</a></p> 
<p id="9%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#9%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">9，完整代码</a></p> 
<p id="%E5%85%AD%EF%BC%8C%E4%BB%A5%E8%A7%A3%E7%94%9F%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E5%85%AD%EF%BC%8C%E4%BB%A5%E8%A7%A3%E7%94%9F%E8%A7%A3" rel="nofollow">六，以解生解</a></p> 
<p id="1%EF%BC%8C%E5%A4%A7%E6%8B%87%E6%8C%87-toc" style="margin-left:40px;"><a href="#1%EF%BC%8C%E5%A4%A7%E6%8B%87%E6%8C%87" rel="nofollow">1，大拇指</a></p> 
<p id="2%EF%BC%8C%E5%8F%AF%E8%A7%86%E5%8C%96-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E5%8F%AF%E8%A7%86%E5%8C%96" rel="nofollow">2，可视化</a></p> 
<p id="3%EF%BC%8CU%E5%9E%8B-toc" style="margin-left:40px;"><a href="#3%EF%BC%8CU%E5%9E%8B" rel="nofollow">3，U型</a></p> 
<p id="4%EF%BC%8C%E6%96%B0%E8%A7%A3-toc" style="margin-left:40px;"><a href="#4%EF%BC%8C%E6%96%B0%E8%A7%A3" rel="nofollow">4，新解</a></p> 
<p id="5%EF%BC%8C%E6%97%A5%E6%9C%9F%E6%B1%87%E6%80%BB-toc" style="margin-left:40px;"><a href="#5%EF%BC%8C%E6%97%A5%E6%9C%9F%E6%B1%87%E6%80%BB" rel="nofollow">5，日期汇总</a></p> 
<p id="6%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#6%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">6，完整代码V1</a></p> 
<p id="7%EF%BC%8CBUG%E4%BF%AE%E5%A4%8D%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V2%EF%BC%89-toc" style="margin-left:40px;"><a href="#7%EF%BC%8CBUG%E4%BF%AE%E5%A4%8D%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V2%EF%BC%89" rel="nofollow">7，BUG修复</a></p> 
<p id="8%EF%BC%8C%E6%97%A5%E6%9C%9F%E4%BC%98%E5%8C%96%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V2%EF%BC%89-toc" style="margin-left:40px;"><a href="#8%EF%BC%8C%E6%97%A5%E6%9C%9F%E4%BC%98%E5%8C%96%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V2%EF%BC%89" rel="nofollow">8，日期优化（完整代码V2）</a></p> 
<p id="9%EF%BC%8CBUG%E4%BF%AE%E5%A4%8D%E3%80%81%E6%96%B0%E5%A2%9E%E6%A3%80%E6%9F%A5%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V3%EF%BC%89-toc" style="margin-left:40px;"><a href="#9%EF%BC%8CBUG%E4%BF%AE%E5%A4%8D%E3%80%81%E6%96%B0%E5%A2%9E%E6%A3%80%E6%9F%A5%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V3%EF%BC%89" rel="nofollow">9，BUG修复、新增检查（完整代码V3）</a></p> 
<p id="%E4%B8%83%EF%BC%8C%E5%85%A8%E6%96%87%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%E4%B8%83%EF%BC%8C%E5%85%A8%E6%96%87%E8%AF%B4%E6%98%8E" rel="nofollow">七，说明</a></p> 
<p id="%E5%85%AB%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E5%85%AB%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3" rel="nofollow">八，直接求解</a></p> 
<p id="1%EF%BC%8C%E5%8F%AF%E8%A7%86%E5%8C%96V2%E7%89%88-toc" style="margin-left:40px;"><a href="#1%EF%BC%8C%E5%8F%AF%E8%A7%86%E5%8C%96V2%E7%89%88" rel="nofollow">1，可视化V2版</a></p> 
<p id="2%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3-toc" style="margin-left:40px;"><a href="#2%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3" rel="nofollow">2，直接求解</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%EF%BC%8C%E8%A7%84%E5%88%99">一，规则</h2> 
<p>每天根据月、日、星期去掉3个格子，剩下的格子刚好全部覆盖。</p> 
<p>日历拼图有两千多组合，如果所有组合都能拼的话，那真的太神奇了。</p> 
<h2 id="%E4%BA%8C%EF%BC%8C%E6%AF%8F%E6%97%A5%E6%8B%BC%E5%9B%BE">二，每日拼图</h2> 
<h3 id="2022%E5%B9%B42%E6%9C%88">2022年2月</h3> 
<p>根据下面的数字化的方法，2022年2月1日-2月28日的答案分别是：</p> 
<p>2月1日周二<br>   1  0  1  8  2  2  0<br>   1  1  1  8  8  2  0<br>   0  3  3  9  8  2  2<br>  10  3  3  9  9  9  5<br>  10  4  3  5  5  5  5<br>  10  4  4  4  6  6  6<br>  10  4  7  7  7  0  6<br>   0  0  0  0  7  7  6<br> 2月2日周三<br>   1  0  1  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  0  9  8  2  3  3<br>   4  9  9  8  2  5  5<br>   4  9  6  8 10  5  5<br>   4  4  6  8 10  7  5<br>   6  6  6 10 10  7  0<br>   0  0  0  0  7  7  7<br> 2月3日周四<br>   1  0  1  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  4  0  2  2  3  3<br>   8  4  4  4  5  5  5<br>   8  6  9  9  9  5  7<br>   8  6  9 10 10  5  7<br>   8  6  6  6 10 10  7<br>   0  0  0  0  0  7  7<br> 2月4日周五<br>  10 0 10  7  1  1  0<br>  10  10 10  7  7  1  0<br>   2  2  2  0 7  1  1<br>   2  4  8  8  8  3  3<br>   2  4  8  3  3  3  9<br>   4  4  4  6  5  5  9<br>   6  6  6  6  5  5  9<br>   0  0  0  0  5  0  9<br> 2月5日周六<br>   1  0  2  2  3  3  0<br>   1  1  2  4  4  3  0<br>   8  1  2  4  0  3  3<br>   8  1  2  4  4 10  5<br>   8  6  9 10 10 10  5<br>   8  6  9  9  5  5  5<br>   6  6  6  9  7  7  7<br>   0  0  0  0  7  7  0<br> 2月6日周日<br>   1  0  1  3  3  8  0<br>   1  1  1  3  8  8  0<br>   2  2  3  3  8  0  5<br>   9  2  4  4  5  5  5<br>   9  2 10  4  4  4  5<br>   9  2 10  6  6  6  7<br>   9 10 10  0  6  6  7<br>   0  0  0  0  7  7  7<br> 2月7日周一<br>   1  0  1  2  2  2  0<br>   1  1  1  2  3  3  0<br>   8  8  8  2  4  3  0<br>   8 10 10  4  4  3  9<br>  10 10  5  4  4  3  9<br>   5  5  5  6  6  7  9<br>   5  6  6  6  0  7  9<br>   0  0  0  0  7  7  7<br> 2月8日周二<br>   1  0  1  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  4  4  2  2  3  3<br>   0  4  8  5  5  5  5<br>   6  4  8  8  8  7  5<br>   6  9  9  9  9  7  7<br>   6  6  6 10 10  0  7<br>   0  0  0  0 10 10  7<br> 2月9日周三<br>   1  0  1  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  4  4  8  2  3  3<br>   4  0  6  8  2  5  5<br>   4  9  6  8 10  5  5<br>   9  9  6  8 10  7  5<br>   9  6  6 10 10  7  0<br>   0  0  0  0  7  7  7<br> 2月10日周四<br>   1  0  1  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  4  4  2  2  3  3<br>   5  4  0  6  6  6  8<br>   5  4  6  6  8  8  8<br>   5  5  5  7  7  7  7<br>   9  9  9  9 10 10  7<br>   0  0  0  0  0 10 10<br> 2月11日周五<br>   1  0  1  8  2  2  0<br>   1  1  1  8  8  2  0<br>   9  3  3  3  8  2  2<br>   9  7  3  0  4  4  4<br>   9  7  3  6  6  5  4<br>   9  7  6  6  6  5  4<br>   7  7 10 10 10  5  5<br>   0  0  0  0 10  0  5</p> 
<p>2月12日周六<br>   1  0  1  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  4  4  2  2  3  3<br>   8  4  5  5  0  6  6<br>   8  4  9  5  5  5  6<br>   8  9  9  7  7  7  6<br>   8  9 10 10 10  7  6<br>   0  0  0  0 10  7  0<br> 2月13日周日<br>   1  0  1  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  4  4  4  2  3  3<br>   8  9  9  4  2  0  5<br>   8 10  9  9  5  5  5<br>   8 10  6  6  6  7  5<br>   8 10 10  0  6  7  7<br>   0  0  0  0  6  7  7<br> 2月14日周一<br>   1  0  1  4  2  2  0<br>   1  1  1  4  7  2  0<br>   3  4  4  4  7  2  2<br>   3  3  3  3  7  5  0<br>   8  6  6  6  7  5  5<br>   8  6  6 10 10  9  5<br>   8  8 10 10 0 9  5<br>   0  0  0  0  9  9  9<br> 2月15日周二<br>   7  0  1  8  8  8  0<br>   7  1  1  2  9  8  0<br>   7  1  1  2  9  9  3<br>   7  4  2  2  2  9  3<br>   0  4 10 10  3  3  3<br>   4  4 10 5  5  5  5<br>   4 10 10 5  6  0  6<br>   0  0  0  0  6  6  6<br> 2月16日周三<br>   1  0  1  5  2  3  0<br>   1  1  1  5  2  3  0<br>   4  5  5  5  2  3  3<br>   4  4  4  6  2  7  3<br>   4  0  9  6  6  7  7<br>   9  9  9  6  6 10  7<br>   9  8  8  8  8 10 0<br>   0  0  0  0  8 10 10</p> 
<p>2月17日周四<br>   1  0  2  2  2  3  0<br>   1  1  6  6  2  3  0<br>   4  1  6  5  2  3  3<br>   4  6  6  5  5  5  7<br>   4  4  0  5 10  8  7<br>   9  4  9 10 10  8  7<br>   9  9  9 10 10  8  7<br>   0  0  0  0  0  8  8<br> 2月18日周五<br>   1  0  2  2  2  3  0<br>   1  2  2  3  3  3  0<br>   1  1  1  4  4  4  4<br>   5  5  5  5  8  8  6<br>   5  7  9  0  8  6  6<br>   7  7  9  8  8  6  6<br>   7  9  9  9 10 10 10<br>   0  0  0  0 10  0 10<br> 2月19日周六<br>   1  0  1  10  10  10  0<br>   1  1  1  2  2  10  0<br>   3  4  4  2  2  10  6<br>   3  5  4  2  6  6  6<br>   3  5  4  4  0  7  6<br>   3  5  5  8  7  7  9<br>   8  8  8  8  7  9  9<br>   0  0  0  0  7  9  0<br> 2月20日周日<br>   1  0  1  2  2  2  0<br>   1  1  1  3  2  7  0<br>   3  3  3  3  2  7  7<br>   4  5  5  5  6  6  7<br>   4  5  8  6  6  0  7<br>   4  5  8  10  10  9  9<br>   4  8  8  0  10  9  9<br>   0  0  0  0  10  10  9<br> 2月21日周一<br>   1  0  1  2  2  2  0<br>   1  1  1  4  2  3  0<br>   4  4  4  4  2  3  3<br>   5  6  6  6  7  7  3<br>   5  6  8  8  8  7  0<br>   5  6  8  9  9  7  7<br>   5  9  9  9  0 10 10<br>   0  0  0  0 10 10 10<br> 2月22日周二<br>   1  0  2  2  3  3  0<br>   1  1  1  2  4  3  0<br>   1  5  5  2  4  3  3<br>   5  5  6  6  4  4  4<br>   9  9  6  6  6  8  7<br>   0  9  8  8  8  8  7<br>   9  9 10 10 10  0  7<br>   0  0  0  0 10 10  7<br> 2月23日周三<br>   1  0  1  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  4  4  4  2  3  3<br>   5  5  5  5  2  6  6<br>   7  7  7  5  9  6  6<br>   7  0  8  8  9 10  6<br>   7  8  8  9  9 10  0<br>   0  0  0  0 10 10 10<br> 2月24日周四<br>   1  0  1  2  2  2  0<br>   1  1  1  5  3  2  0<br>   4  5  5  5  3  3  7<br>   4  5  6  6  6  3  7<br>   4  9  6  6  7  7  7<br>   4  9  0  8  8  8  8<br>   9  9  9 10 10 10  8<br>   0  0  0  0  0 10 10<br> 2月25日周五<br>   2  0  1  1  1  1  0<br>   2  2  2  3  3  3  0<br>   2  5  5  3  4  4  4<br>   5  5  6  6  6  6  4<br>   7  8  8  9  9  6  4<br>   7  7  8 0  9  9  9<br>   7  7  8  8 10 10 10<br>   0  0  0  0 10  0 10<br> 2月26日周六<br>   1  0  1  2  2  2  0<br>   1  1  1  3  2  4  0<br>   5  6  6  3  2  4  4<br>   5  7  6  3  3  3  4<br>   5  7  6  6  8  8  4<br>   5  7  7  9  0  8  8<br>   9  9  9  9 10 10 10<br>   0  0  0  0 10 10  0<br> 2月27日周日<br>   1  0  1  5  5  2  0<br>   1  1  1  5  2  2  0<br>   3  4  5  5  2  2  7<br>   3  4  4  6  7  7  7<br>   3  9  4  6  6  6  6<br>   3  9  4  8  8  0 10<br>   9  9  9  0  8  8 10<br>   0  0  0  0 10 10 10<br> 2月28日周一<br>   1  0  1  2  2  2  0<br>   1  1  1  5  2  3  0<br>   4  5  5  5  2  3  3<br>   4  5  6  6  7  7  3<br>   4  4  4  6  6  7  3<br>   8  9  9  9  9  7  0<br>   8  8  8  8  0 10 10<br>   0  0  0  0 10 10 10</p> 
<p></p> 
<p></p> 
<p>拼的时候经常会出现，还有一块拼不上，而空出来的格子组成的是另一个块的形状的情况，如：</p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/21/fa/k6fVaUWa_o.png" width="306">  <img alt="" height="292" src="https://images2.imgbox.com/36/48/cI7ZsFTy_o.png" width="355"></p> 
<p> <img alt="" height="295" src="https://images2.imgbox.com/52/8b/0pCP3dHU_o.png" width="341"></p> 
<p></p> 
<p>2月22日周二</p> 
<p>拼的时候再次出现这种情况：</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/86/44/3qpTvfna_o.png" width="432"></p> 
<p>稍微调整就能得到：</p> 
<p><img alt="" height="484" src="https://images2.imgbox.com/7d/9c/kbeYTcMA_o.png" width="458"></p> 
<h3 id="2022%E5%B9%B43%E6%9C%88">2022年3月</h3> 
<p>2022年3月1日-3月31日的答案分别是：</p> 
<p>3月1日周二<br>   1  1  0  2  2  2  0<br>   1  1  2  2  3  3  0<br>   0  1  6  4  4  3  5<br>   6  6  6  7  4  3  5<br>   6  8  9  7  4  3  5<br>   8  8  9  7  7  7  5<br>   8  9  9  9 10  0 10<br>   0  0  0  0 10 10 10<br> 3月2日周三<br>   1  2  0  3  4  4  0<br>   1  2  2  3  3  4  0<br>   1  0  2  3  3  4  4<br>   1  1  2  5  5  5  5<br>   6  7  7  7  8  8  8<br>   6  7  9  9  8 10  8<br>   6  6  6  9  9 10  0<br>   0  0  0  0 10 10 10<br> 3月3日周四<br>   1  2  0  2  5  5  0<br>   1  2  2  2  5  3  0<br>   1  4  0  5  5  3  3<br>   1  4  4  4  4  7  3<br>   6  6  6  7  7  7  9<br>   6  8  8  8  9  9  9<br>   6  8  8 10 10 10  9<br>   0  0  0  0  0 10 10<br> 3月4日周五<br>   1  1  0  10  10  10  0<br>   3  1  1  1  2  10  0<br>   3  3  3  0  2  10  7<br>   3  4  6  6  2  2  7<br>   4  4  6  5  5  5  7<br>   4  6  6  5  5  7  7<br>   8  8  8  8  9  9  9<br>   0  0  0  0  9  0  9<br> 3月5日周六<br>   1  2  0  2  3  3  0<br>   1  2  2  2  3  3  0<br>   1  4  4  4  0  3  9<br>   1  5  4  6  6  6  9<br>   7  5  4  6  8  8  9<br>   7  5  5  6  8  9  9<br>   7  7  5 8 8 10 10<br>   0  0  0  0 10 10  0<br> 3月6日周日<br>   1  2  0  2  3  3  0<br>   1  2  2  2  3  3  0<br>   1  1  4  4  3  0  7<br>   5  1  4  6  7  7  7<br>   5  8  4  6  6  6  7<br>   5  8  4 10 10  6 9<br>   5  8  8 0 10 10 9<br>   0  0  0  0 9 9 9<br> 3月7日周一<br>   1  1  0  2  2  2  0<br>   1  1  2  2  3  3  0<br>   1  5  4  4  4  3  0<br>   5  5  4  6  4  3  3<br>   5  6  6  6  7  7  7<br>   8  9  9  9  9 10  7<br>   8  8  8  8  0 10  7<br>   0  0  0  0 10 10 10<br> 3月8日周二<br>   1  1  0  2  3  3  0<br>   1  1  1  2  2  3  0<br>   4  4  4  4  2  3  3<br>   0  5  5  5  6  6  6<br>   7  5  8  8  8  8  6<br>   7  7  7  9  9  8  6<br>   7  9  9  9 10  0 10<br>   0  0  0  0 10 10 10</p> 
<p>3月9日周三<br>   1  1  0  2  2  3  0<br>   1  2  2  2  3  3  0<br>   1  1  7  7  3  3  4<br>   5  0  7  6  6  6  4<br>   5  7  7  6  8  8  4<br>   5  9  9  6  8 10  4<br>   5  5  9  9  8 10  0<br>   0  0  0  0 10 10 10<br> 3月10日周四<br>   1  1  0  2  2  2  0<br>   3  1  1  2  5  5  0<br>   3  3  3  2  5  9  4<br>   3  6  0  5  5  9  4<br>   6  6  7  7  7  9  4<br>   6  8  7  8  9  9  4<br>   6  8  8  8 10 10 10<br>   0  0  0  0  0 10 10<br> 3月11日周五<br>   1  1  0  2  3  3  0<br>   4  1  1  2  2  3  0<br>   4  4  4  2  2  3  3<br>   4  7  5  0  6  6  6<br>   7  7  5  5  5  5  6<br>   7  8  9  9  9  9  6<br>   7  8  8  8 10 10 10<br>   0  0  0  0 10  0 10<br> 3月12日周六<br>   1  2  0  2  3  3  0<br>   1  2  2  2  5  3  0<br>   1  4  5  5  5  3  3<br>   1  4  4  6  0  8  8<br>   7  4  4  6  8  8 10<br>   7  7  7  6  6  6 10<br>   7  9  9  9  9 10 10<br>   0  0  0  0  9 10  0<br> 3月13日周日<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  1  4  4  4  3  3<br>   5  5  5  5  4  0  7<br>   5  6  6  6  6  7  7<br>   8  8  9  9  9  7 10<br>   8  8  8  0  9  9 10<br>   0  0  0  0 10 10 10<br> 3月14日周一<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  1  1  4  4  3  3<br>   5  6  6  4  9  7  0<br>   5  6  8  9  9  7  7<br>   5  6  8  9  9 10  7<br>   5  6  8  8  0 10  7<br>   0  0  0  0 10 10 10<br> 3月15日周二<br>   1  1  0  2  3  3  0<br>   1  1  1  2  3  4  0<br>   5  5  5  2  3  4  4<br>   5  7  5  2  3  6  4<br>   0  7  9  6  6  6  8<br>   7  7  9  6  8  8  8<br>   9  9  9 10 10  0  8<br>   0  0  0  0 10 10 10<br> 3月16日周三<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  1  1  4  4  3  3<br>   5  5  8  4  6  7  7<br>   5  0  8  9  6  7  7<br>   5  8  8  9  6 10  7<br>   5  8  9  9  6 10  0<br>   0  0  0  0 10 10 10<br> 3月17日周四<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  1  7  5  4  3  3<br>   6  7  7  5  4  4  4<br>   6  7  0  5  5  8  8<br>   6  9  9  9  5 10  8<br>   6  9  9 10 10 10  8<br>   0  0  0  0  0 10  8</p> 
<p>3月18日周六<br>   1  2  0  6  3  3  0<br>   1  2  2  6  4  3  0<br>   1  5  2  6  4  3  3<br>   1  5  6  6  4  4  4<br>   7  5  5  0  8  8  8<br>   7  7  7  9  9  8  8<br>   7  9  9  9 10 10 10<br>   0  0  0  0 10  0 10<br> 3月19日周六<br>   1  2  0  2  3  3  0<br>   1  2  2  2  5  3  0<br>   1  4  5  5  5  3  3<br>   1  4  4  6  5  7  7<br>   8  8  4  6  0  7  7<br>   8  9  4  6  6  6  7<br>   8  9  9  9  9 10 10<br>   0  0  0  0 10 10  0<br> 3月20日周日<br>   1  2  0  2  3  3  0<br>   1  2  2  2  5  3  0<br>   1  4  4  5  5  3  3<br>   1  4  10 5  8  8  8<br>   7  4  10 8  8  0 6<br>   7  4 10 10 6 6 6<br>   7  7  7  0 9 9 6<br>   0  0  0  0 9 9 9<br> 3月21日周一<br>   1  2  0  2  3  3  0<br>   1  2  2  2  5  3  0<br>   1  4  4  5  5  3  3<br>   1  1  4  5  7  7  7<br>   6  6  4  7  7  8  0<br>   6  6  6  8  8  8 10<br>   9  9  9  9  0  8 10<br>   0  0  0  0 10 10 10<br> 3月22日周二<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  1  1  4  4  3  3<br>   5  5  5  4  8  8  6<br>   5  9  7  8  8  8  6<br>   0  9  7  7  7  7  6<br>   9  9  9 10 10  0  6<br>   0  0  0  0 10 10 10<br> 3月23日周三<br>   1  2  0  3  4  4  0<br>   1  2  2  3  3  4  0<br>   1  1  2  3  3  4  4<br>   5  5  5  5  6  6  6<br>   5  7  7  7  7  9  6<br>   8  0  8  9  9  9  6<br>   8  8  8 10 10  9  0<br>   0  0  0  0 10 10 10<br> 3月24日周四<br>   1  2  0  2  3  3  0<br>   1  2  2  2  5  3  0<br>   1  4  4  4  5  3  3<br>   1  4  5  5  5  7  7<br>   6  6  6  6  7  7  9<br>   8  8  0  6  9  9  9<br>   8  8  8 10 10 10  9<br>   0  0  0  0  0 10 10<br> 3月25日周五<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  7  5  5  4  3  3<br>   1  7  5  6  4  4  4<br>   7  7  5  6  6  6  6<br>   7  9  9  0 10  8  8<br>   9  9 10 10 10  8  8<br>   0  0  0  0 10  0  8<br> 3月26日周六<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  1  4  4  4  3  3<br>   5  5  5  5  4  6  6<br>   7  8  8  9  9  9  6<br>   7  7  8  8  0  9  6<br>   7  7 10 10 10  9  6<br>   0  0  0  0 10 10  0<br> 3月27日周日<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  1  6  7  4  3  3<br>   5  6  6  7  4  4  4<br>   5  6  7  7  7  8  8<br>   5  6 10 10  9  0  8<br>   5 10 10  0  9  9  8<br>   0  0  0  0  9  9  8<br> 3月28日周一<br>   1  2  0  3  3  3  0<br>   1  2  2  2  2  3  0<br>   1  1  4  5  5  3  7<br>   6  1  4  5  7  7  7<br>   6  6  4  5  5  9  7<br>   8  6  4  9  9  9  0<br>   8  8  8  9  0 10 10<br>   0  0  0  0 10 10 10<br> 3月29日周二<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  5  5  5  4  3  3<br>   1  7  6  5  4  4  4<br>   7  7  6  6  6  6  9<br>   7  8  8  8  9  9  9<br>   0  8  8 10 10  0  9<br>   0  0  0  0 10 10 10<br> 3月30日周三<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  5  5  6  4  3  3<br>   1  5  6  6  4  4  4<br>   7  5  6  8  8  8  8<br>   7  7  7  9  9  9  8<br>   7  0  9  9 10 10  0<br>   0  0  0  0 10 10 10</p> 
<p>3月31日周四<br>   1  2  0  2  3  3  0<br>   1  2  2  2  4  3  0<br>   1  4  4  4  4  3  3<br>   1  5  5  5  6  6  6<br>   7  7  8  5  6  6  9<br>   7  8  8  5  9  9  9<br>   7  8  0 10 10 10  9<br>   0  0  0  0  0 10 10</p> 
<p></p> 
<h3 id="%E7%AB%96%E6%9D%A1%E4%B8%8B%E6%BB%91%E9%97%AE%E9%A2%98">竖条下滑问题</h3> 
<p>因为是平放在桌面上拼的，所以经常忘了竖条下面不能放空格，然后每次我都会重新拼。</p> 
<p>2月5日周六</p> 
<p><img alt="" height="495" src="https://images2.imgbox.com/51/4d/SQAr5KJb_o.png" width="433"></p> 
<p> <img alt="" height="538" src="https://images2.imgbox.com/65/f9/UHAs0lzN_o.png" width="470"></p> 
<p></p> 
<p>3月9日周三</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/bc/8d/P3Q7znTf_o.png" width="423"></p> 
<p><img alt="" height="498" src="https://images2.imgbox.com/9f/c6/MClhSCtD_o.png" width="444"></p> 
<p>4月2日周六</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/00/36/j93W91yy_o.png" width="382"></p> 
<p><img alt="" height="420" src="https://images2.imgbox.com/87/7b/sBd4TuNk_o.png" width="364"></p> 
<p></p> 
<p></p> 
<h3 id="2022%E5%B9%B44%E6%9C%88">2022年4月</h3> 
<p>4月1日周五<br>   1  1  2  0  3  3  0<br>   1  1  2  2  2  3  0<br>   0  1  2  5  5  3  3<br>   4  5  5  5  6  6  6<br>   4  8  9  9  9  9  6<br>   4  8  8 10 10 10  6<br>   4  4  8 10  7  7  7<br>   0  0  0  0  7  0  7<br> 4月2日周六<br>   1  1  2  0  2  3  0<br>   1  1  2  2  2  3  0<br>   1  0  4  4  3  3  3<br>   4  4  4  5  8  8  8<br>   6  6  6  5  5  5  8<br>   6  9  9  9  9  5 10<br>   6  7  7  7  7 10 10<br>   0  0  0  0  7 10  0<br> 4月3日周日<br>   1  1  1  0  2  2  0<br>   8  1  3  3  3  2  0<br>   8  1  0  3  3  2  2<br>   8  4  4  4  5  6  6<br>   8  4  9  9  5  5  6<br>   7  4  7  9  9  5  6<br>   7  7  7  0 10  5  6<br>   0  0  0  0 10 10 10</p> 
<p>4月4日周一<br>   6  6  1  0  1  2  0<br>  7  6  1  1  1  2  0<br>   7  6  6 0  2  2  2<br>   7  7  7  4  4  8  9<br>   3  4  4  4  8  8  9<br>   3  3  3  3  8  9  9<br>  10 10 10 10  0  5  5<br>   0  0  0  0  5  5  5<br> 4月5日周二<br>   8  1  1  0  2  2  0<br>   8  3  1  1  1  2  0<br>   8  3  3  3  0  2  2<br>   8  3 10 10  4  4  5<br>   9 10 10  4  4  4  5<br>   9  9  9  6  5  5  5<br>   6  6  6  6  7  0  7<br>   0  0  0  0  7  7  7<br> 4月6日周三<br>   1  1  1  0  3  3  0<br>   1  2  2  3  3  3  0<br>   1  4  2  2  2  0  5<br>   8  4  4  4  5  5  5<br>   8  9  9  4  6  6  5<br>   8  8  9  9  6  7  7<br>  10 10 10 10  6  7  0<br>   0  0  0  0  6  7  7</p> 
<p>4月7日周四<br>   1  1  2  0  2  4  0<br>   3  1  2  2  2  4  0<br>   3  1  1  4  4  4  0<br>   3  3  5  5  5  8  8<br>   6  3  5  5  8  8  7<br>   6  6  6  9  9  9  7<br>   6 10 10 10 10  9  7<br>   0  0  0  0  0  7  7<br> 4月8日周五<br>   1  1  2  0  2  4  0<br>   1  1  2  2  2  4  0<br>   1  5  5  3  4  4  4<br>   0  5  7  3  3  3  3<br>   5  5  7  6  8  8  8<br>   7  7  7  6  6  9  8<br>  10 10 10 10  6  9  9<br>   0  0  0  0  6  0  9</p> 
<p>4月9日周六<br>   1  1  2  0  2  4  0<br>   1  3  2  2  2  4  0<br>   1  3  3  3  4  4  4<br>   1  0  8  3  6  6  6<br>   5  8  8  6  6  9  9<br>   5  8 10 10 10 10  9<br>   5  5  5  7  7  7  9<br>   0  0  0  0  7  7  0</p> 
<p>4月10日周日<br>   1  1  2  0  2  4  0<br>   1  3  2  2  2  4  0<br>   1  3  3  3  4  4  4<br>   1  6  0  3  5  5  5<br>   6  6  8  8  8  8  5<br>   6  7  7  7  9  9  5<br>   6  7  7  0 10  9  9<br>   0  0  0  0 10 10 10</p> 
<p>4月11日周一<br>   1  1  2  0  3  3  0<br>   1  1  2  2  2  3  0<br>   7  1  2 10  10  3  3<br>   7  7  4 0 10 10 10<br>   5  7  4  4  4  4  8<br>   5  9  9  9  6  6  8<br>   5  5  5  9  0  6  8<br>   0  0  0  0  6  6  8<br> 4月12日周二<br>   1  1  2  0  3  3  0<br>   1  1  2  2  2  3  0<br>   4  1  2  5  5  3  3<br>   4  5  5  5  0  8  8<br>   4  4  4  6  8  8  9<br>   6  6  6  6  9  9  9<br>  10 10 10 10  7  0  7<br>   0  0  0  0  7  7  7<br> 4月13日周三<br>   1  1  2  0  2  3  0<br>   8  1  2  2  2  3  0<br>   8  1  1  5  4  3  3<br>   8  5  5  5  4  0  3<br>   8 10 10  5  4  4  4<br>  10 10  9  6  6  6  6<br>   9  9  9  6  7  7  0<br>   0  0  0  0  7  7  7</p> 
<p>4月14日周四<br>   1  1  1  0  2  2  0<br>   1  3  3  3  4  2  0<br>   1  7  3  8  4  2  2<br>   5  7  3  8  4  4  0<br>   5  7  7  8  6  4  6<br>   5  9  9  8  6  6  6<br>   5  5  9  9 10 10 10<br>   0  0  0  0 10 10  10<br> 4月15日周五<br>   1  1  8  0  2  2  0<br>   1  3  8  8  4  2  0<br>   1  3  3  8  4  2  2<br>   1  6  3  9  4  4  4<br>   0  6  3  9  5  5  5<br>   6  6  6  9  9  5  5<br>  10 10 10 10  7  7  7<br>   0  0  0  0  7  0  7</p> 
<p>4月16日周六<br>   1  1  2  0  2  4  0<br>   1  3  2  2  2  4  0<br>   1  3  3  3  4  4  4<br>   1  5  5  3  8  8  8<br>   6  0  5  5  5  9  8<br>   6 10 10 10 10  9  9<br>   6  6  6  7  7  7  9<br>   0  0  0  0  7  7  0</p> 
<p>4月17日周日<br>   8  1  2  0  2  3  0<br>   8  1  2  2  2  3  0<br>   8  1  9  9  3  3  3<br>   8  1  1  9  9  5  5<br>   4 10  0  5  5  5  6<br>   4 10 10 10  6  6  6<br>   4  4  4  0  6  7  7<br>   0  0  0  0  7  7  7<br> 4月18日周一<br>   1  1  2  0  2  3  0<br>  10  1  2  2  2  3  0<br>  10  1  1  3  3  3  4<br>  10  10  7  4  4  4  4<br>   5 10  7 0  9  8  8<br>   5  5  7  9  9  6  8<br>   5  5  7  9  0  6  8<br>   0  0  0  0  6  6  6</p> 
<p>4月19日周二<br>   1  1  2  0  2  4  0<br>   1  3  2  2  2  4  0<br>   1  3  3  3  4  4  4<br>   1  5  5  3  8  8  8<br>   6  5  5  5  0  7  8<br>   6  9  9  9  9  7  7<br>   6  6  6 10 10  0  7<br>   0  0  0  0 10 10  7</p> 
<p>4月20日周三<br>   1  1  2  0  2 10  0<br>   1  7  2  2  2  10  0<br>   1  7  7  7 10 10 10<br>   1  8  9  9  9  9  5<br>   3  8  8  6  6 0  5<br>   3  3  8  6  4  5  5<br>   3  3  6  6  4  5  0<br>   0  0  0  0  4  4  4<br> 4月21日周四<br>   7  1  2  0  2  3  0<br>   7  1  2  2  2  3  0<br>   7  1  1  1  4  3  3<br>   7  4  4  4  4 10  3<br>   8  8  9  5  5  10 0<br>   8  9  9  5 10 10 10<br>   8  9  5  5  6  6  6<br>   0  0  0  0  0  6  6</p> 
<p>4月22日周五<br>   1  2  2  0  3  3  0<br>   1  2  2  2  4  3  0<br>   1  1  5  5  4  3  3<br>   7  1  5  6  4  4  4<br>   7  7  5  6  6  6  8<br>   0  7  5  6  8  8  8<br>   9  9  9  9 10 10 10<br>   0  0  0  0 10  0 10</p> 
<p>4月23日周六<br>   8  1  2  0  2  3  0<br>   8  1  2  2  2  3  0<br>   8  1  1  1  3  3  3<br>   8  5  7  4  9  9  9<br>   5  5  7  4  4  4  9<br>   5  0  7  6  6  4 10<br>   5  7  7  6  6 10 10<br>   0  0  0  0  6 10  0</p> 
<p>4月24日周日<br>   1  2  3  0  3  4  0<br>   1  2  3  3  3  4  0<br>   1  2  2  2  4  4  4<br>   1  1  5  5  5  8  8<br>   9  9  9  9  5  5  8<br>   6  6  0  7  7 10  8<br>   6  6  6  0  7 10 10<br>   0  0  0  0  7  7 10</p> 
<p>4月25日周一<br>   8  1  1  0  2  2  0<br>   8  8  1  1  1  2  0<br>   9  8  3  3  3  2  2<br>   9  6  3  3  4  4  4<br>   9  6  5  5  4 10 10<br>   9  6  5  0  4  7 10<br>   6  6  5  5  0  7 10<br>   0  0  0  0  7  7  7</p> 
<p>4月26日周二<br>   1  1  2  0  3  3  0<br>   1  1  2  2  2  3  0<br>   4  1  2  5  5  3  3<br>   4  5  5  5  8  9  9<br>   4  4  4  6  8  8  9<br>   6  6  6  6  0  8  9<br>  10 10 10 10  7  0  7<br>   0  0  0  0  7  7  7</p> 
<p>4月27日周三<br>   8  8  1  0  1  2  0<br>   9  8  1  1  1  2  0<br>   9  8 10 10  2  2  2<br>   9 10 10  4  3  3  3<br>   9  4  4  4  6  6  3<br>   5  4  6  6  6  0  3<br>   5  5  5  5  7  7  0<br>   0  0  0  0  7  7  7</p> 
<p>4月28日周四<br>   1  1  2  0  2  5  0<br>   3  1  2  2  2  5  0<br>   3  1  1  4  5  5  5<br>   3  3  3  4  4  4  4<br>   8  8 10  9  9  9  9<br>   8 10 10  6  6  6  0<br>   8 10  6  6  7  7  7<br>   0  0  0  0  0  7  7</p> 
<p>4月29日周五<br>   1  1  1  0  2  2  0<br>   1  3  3  3  3  2  0<br>   1  9  9  8  3  2  2<br>   9  9  4  8  5  5  5<br>   4  4  4  8 10  5  5<br>   6  6  4  8 10 10 10<br>   0  6  6  6  7  7  7<br>   0  0  0  0  7  0  7<br> 4月30日周六<br>   1  1  2  0  2  5  0<br>   1  1  2  2  2  5  0<br>   1  3  3  4  5  5  5<br>   8  6  3  4  4  4  4<br>   8  6  3  3  9  9  9<br>   8  6  6  6  7  7  9<br>   8  0  7  7  7 10 10<br>   0  0  0  0 10 10  0</p> 
<h3 id="2022%E5%B9%B45%E6%9C%88">2022年5月</h3> 
<p>5月1日周日<br>   1  1  1  2  0  2  0<br>   1  1  8  2  2  2  0<br>   0  4  8  9  9  3  3<br>   4  4  8 10  9  9  3<br>   4  7  8 10  5  5  3<br>   4  7 10 10  6  5  3<br>   7  7  7  0  6  5  5<br>   0  0  0  0  6  6  6</p> 
<p>5月2日周一<br>   1  1  2  3  0  3  0<br>   1  1  2  3  3  3  0<br>   1  0  2  2  2  6  6<br>   4  4  5  6  6  6  8<br>   9  4  5  5  5  5  8<br>   9  4  4 10 10  7  8<br>   9  9 10 10  0  7  8<br>   0  0  0  0  7  7  7<br> 5月3日周二<br>   1  1  1  2  0  2  0<br>   1  4  4  2  2  2  0<br>   1  4  0  3  8  8  5<br>   4  4  6  3  8  5  5<br>   6  6  6  3  8  5  9<br>   7  7  6  3  3  5  9<br>   7  7  7 10 10  0  9<br>   0  0  0  0 10 10  9</p> 
<p> 5月4日周三<br>   8  8  8  8  0  1  0<br>   2  2  3  3  3  1  0<br>   2  4  3  0  3  1  1<br>   2  4  4  4 10  9  1<br>   2  6  5  4 10  9  9<br>   6  6  5 10 10  7  9<br>   6  6  5  5  5  7  0<br>   0  0  0  0  7  7  7<br> 5月5日周四<br>   8  1  1  2  0  2  0<br>   8  3  1  2  2  2  0<br>   8  3  1  1  0  4  4<br>   8  3  3  3  9  4  4<br>   5  5  9  9  9  4  7<br>   6  5  5  5  7  7  7<br>   6  6  6  6 10 10  7<br>   0  0  0  0  0 10 10</p> 
<p>5月6日周五<br>   1  1  1  2  0  2  0<br>   1  3  3  2  2  2  0<br>   1  4  3  3  3  0  5<br>   8  4  4  4  5  5  5<br>   8  9  9  4  6  6  5<br>   8 10  9  9  6  7  7<br>   8 10 10 10  6  7  7<br>   0  0  0  0  6  0  7</p> 
<p>5月7日周六<br>   1  1  1  1  0  2  0<br>   1  9  8  2  2  2  0<br>   9  9  8  3  3  2  0<br>   9  4  8  3  5  5  5<br>  10  4  8  3  3  6  5<br>  10  4  4  6  6  6  5<br>  10 10  4  6  7  7  7<br>   0  0  0  0  7  7  0</p> 
<p>5月8日周日<br>   1  1  1  1  0  2  0<br>   1  3  3  3  5  2  0<br>   4  4  3  5  5  2  2<br>   0  4  3  5  5  8  2<br>   6  4  4  8  8  8 10<br>   6  9  9  9  9 10 10<br>   6  6  6  0  7 10  7<br>   0  0  0  0  7  7  7</p> 
<p>5月9日周一<br>   1  2  2  3  0  3  0<br>   1  1  2  3  3  3  0<br>   1  1  2  2  5  5  5<br>   8  0  4  5  5 10  9<br>   8  8  4 10 10 10  9<br>   6  8  4  4  4  7  9<br>   6  6  6  6  0  7  9<br>   0  0  0  0  7  7  7</p> 
<p>5月10日周二<br>   1  1  1  2  0  2  0<br>   1  3  3  2  2  2  0<br>   1  3  8  8  8  8  4<br>   3  3  0  5  4  4  4<br>   5  5  5  5 10  9  4<br>   6  6 10 10 10  9  9<br>   6  6  6  7  7  0  9<br>   0  0  0  0  7  7  7</p> 
<p>5月11日周三<br>   1  1  1  2  0  2  0<br>   1  1  3  2  2  2  0<br>   8  8  3  3  3  4  4<br>   5  8  8  0  3  6  4<br>   5  9  9  9  6  6  4<br>   5  5  5  9  6  7  4<br>  10 10 10 10  6  7  0<br>   0  0  0  0  7  7  7</p> 
<p>5月12日周四<br>   1  1  2  3  0  3  0<br>   1  1  2  3  3  3  0<br>   8  1  2  2  4  4  4<br>   8  8  8  2  0  4  9<br>   5  5  5 10 10  4  9<br>   5  6 10 10  7  7  9<br>   5  6  6  6  6  7  9<br>   0  0  0  0  0  7  7</p> 
<p>5月13日周五<br>   8  8  8  8  0  1  0<br>   9  9  2  2  2  1  0<br>  10  9  9  2  3  1  1<br>  10 10 10  2  3  0  1<br>   4  4  6  6  3  3  3<br>   4  4  6  5  5  5  5<br>   4  6  6  5  7  7  7<br>   0  0  0  0  7  0  7</p> 
<p>5月14日周六<br>   1  1  1  2  0  2  0<br>   1  3  3  2  2  2  0<br>   1  3  3  8  8  4  4<br>   9  3 10 10  8  4  0<br>   9 10 10  5  8  4  7<br>   9  5  5  5  6  4  7<br>   9  5  6  6  6  7  7<br>   0  0  0  0  6  7  0</p> 
<p>5月15日周日<br>   8  8  8  1  0  1  0<br>   2  9  8  1  1  1  0<br>   2  9  9 10 10 10 10<br>   2  2  9  3  3  3  3<br>   0  2  4  3  5  5  5<br>   6  6  4  4  4  7  5<br>   6  6  6  0  4  7  5<br>   0  0  0  0  7  7  7<br> 5月16日周一<br>   1  1  1  2  0  2  0<br>   1  3  3  2  2  2  0<br>   1  8  3  4  4  5  5<br>   8  8  3  4  4  5  9<br>   8  0  3  4  5  5  9<br>  10 10 10  6  6  7  9<br>  10  6  6  6  0  7  9<br>   0  0  0  0  7  7  7</p> 
<p>5月17日周二<br>   1  1  1  2  0  2  0<br>   1  8  8  2  2  2  0<br>   1  3  8  8  9  9  9<br>  10  3  3  3  3  5  9<br>  10  4  0  5  5  5  6<br>  10  4  4  5  6  6  6<br>  10  4  4  7  7  0  6<br>   0  0  0  0  7  7  7</p> 
<p>5月18日周三<br>   1  1  1  2  0  2  0<br>   8  8  1  2  2  2  0<br>   9  8  1  3  3  4  4<br>   9  8 10  3  3  3  4<br>   9 10 10  0  6  6  4<br>   9 10  5  5  6  7  4<br>   5  5  5  6  6  7  0<br>   0  0  0  0  7  7  7<br> 5月19日周四<br>   1  1  1  2  0  2  0<br>   8  1  4  2  2  2  0<br>   8  1  4  3  3  3  3<br>   8  4  4  3  5  5  5<br>   8  4 10 10  0  5  5<br>   9 10 10  6  7  7  7<br>   9  9  9  6  6  6  7<br>   0  0  0  0  0  6  7<br> 5月20日周五<br>   8  1  1  1  0  2  0<br>   8  1  4  4  2  2  0<br>   8  1  4  5  2  3  3<br>   8  4  4  5  2  3  3<br>   9  9  5  5  5  0  3<br>  10  9  9  6  6  6  6<br>  10 10 10  6  7  7  7<br>   0  0  0  0  7  0  7</p> 
<p>5月21日周六<br>   1  1  1  2  0  6  0<br>   1  2  2  2  3  6  0<br>   1  2  3  3  3  6  6<br>   7  7  7  4  3  4  6<br>   8  8  7  4  4  4 0<br>  10  8  8  9  9  9  9<br>  10 10 10 10  5  5  5<br>   0  0  0  0  5  5  0</p> 
<p>5月22日周日<br>   8  1  9  9  0  2  0<br>   8  1 10  9  9  2  0<br>   8  1 10 10 10  2  2<br>   8  1  1  3  3  3  2<br>   5  5  4  3  3  6  6<br>   0  5  4  4  4  6  7<br>   5  5  4  0  6  6  7<br>   0  0  0  0  7  7  7</p> 
<p>5月23日周一<br>   8  1  1  2  0  2  0<br>   8  8  1  2  2  2  0<br>   3  8  1  1  4  4  4<br>   3 10 10 10  4  4  9<br>   3  3  3 10  6  6  9<br>   5  0  6  6  6  7  9<br>   5  5  5  5  0  7  9<br>   0  0  0  0  7  7  7</p> 
<p>5月24日周二<br>   8  1  1  2  0  2  0<br>   8  3  1  2  2  2  0<br>   8  3  1  1  9  9 10<br>   8  3  3  3  9 10 10<br>   4  4  4  4  9 10  6<br>   5  5  0  4  6  6  6<br>   5  5  5  7  7  0  6<br>   0  0  0  0  7  7  7</p> 
<p>5月25日周三<br>   1  1  1  2  0  2  0<br>   1  1  3  2  2  2  0<br>   8  8  3  3  3  4  4<br>   5  8  8  9  3  6  4<br>   5  9  9  9  6  6  4<br>   5  5  5  0  6  7  4<br>  10 10 10 10  6  7  0<br>   0  0  0  0  7  7  7</p> 
<p>5月26日周四<br>   8  1  1  2  0  2  0<br>   8  8  1  2  2  2  0<br>   3  8  1  1  5  4  4<br>   3  9  9  9  5  4  4<br>   3  9  5  5  5  4 10<br>   3  3  6  6  0  7 10<br>   6  6  6  7  7  7 10<br>   0  0  0  0  0  7 10</p> 
<p>5月27日周五<br>   1  1  1  2  0  5  0<br>   1  2  2  2  3  5  0<br>   1  2  4  3  3  5  8<br>   4  4  4  3  5  5  8<br>   9  9  4  3 10 10  8<br>   9  6  6 10 10  0  8<br>   9  6  6  6  7  7  7<br>   0  0  0  0  7  0  7</p> 
<p>5月28日周六<br>   1  1  1  2  0  2  0<br>   1  3  3  2  2  2  0<br>   1  9  3  8  8  8  8<br>   9  9  3  6 10 10 10<br>   9  5  3  6  4  4 10<br>   5  5  6  6  6  4  0<br>   5  5  7  7  7  4  4<br>   0  0  0  0  7  7  0</p> 
<p>5月29日周日<br>   1  1  1  2  0  2  0<br>   3  1  4  2  2  2  0<br>   3  1  4  4  5  5  5<br>   3  3  4  4  5  6  6<br>   8  3  9  9  5  6 10<br>   8  8  9  7  7  6 10<br>   0  8  9  0  7  6 10<br>   0  0  0  0  7  7 10</p> 
<p>5月30日周一<br>   8  1  1  2  0  2  0<br>   8  3  1  2  2  2  0<br>   8  3  1  1  9  9  9<br>   8  3  3  3  5 10  9<br>   4  5  5  5  5 10 10<br>   4  4  4  6  6  6 10<br>   4  0  6  6  0  7  7<br>   0  0  0  0  7  7  7</p> 
<p>5月31日周二<br>   1  1  1  2  0  2  0<br>   1  1  3  2  2  2  0<br>   4  4  3  3  3  8  8<br>   7  4  3  8  8  8  5<br>   7  4  4  5  5  5  5<br>   7  9  9  9 10 10  6<br>   7  9 0 10 10  0  6<br>   0  0  0  0  6  6  6</p> 
<h3 id="6%E6%9C%88">2022年6月</h3> 
<p>6月1日周三<br>   1  2  2  3  3  0  0<br>   1  1  2  3  3  3  0<br>   0  1  2  2  4  4  4<br>   8  1  5  5  5  5  4<br>   8  9  9 10 10  5  4<br>   8  9 10 10  7  6  6<br>   8  9  7  7  7  6  0<br>   0  0  0  0  7  6  6</p> 
<p>6月2日周四<br>   1  1  2  2  2  0  0<br>   1  1  4  3  2  2  0<br>   1  0  4  3  3  3  5<br>   4  4  4  3  5  5  5<br>   6  6  8  8  5  9  7<br>   6  8  8  9  9  9  7<br>   6  6 10 10 10 10  7<br>   0  0  0  0  0  7  7</p> 
<p>6月3日周五<br>   1  2  3  3  3  0  0<br>   1  2  2  2  3  3  0<br>   1  2  0  7  7  9  8<br>   1  1  5  7  9  9  8<br>   4  5  5  7  9  6  8<br>   4  5  5  6  6  6  8<br>   4  4  4  6 10 10 10<br>   0  0  0  0 10 0 10</p> 
<p>6月4日周六<br>   8  1  2  2  2  0  0<br>   8  1  2  4  4  3  0<br>   8  1  2  0  4  3  3<br>   8  1  1  4  4  5  3<br>   9  9 10  5  5  5  3<br>   9 10 10  5  7  6  6<br>   9 10  7  7  7  6  6<br>   0  0  0  0  7  6  0</p> 
<h2 id="%E4%BA%8C%EF%BC%8C%E6%9C%AF%E8%AF%AD">三，术语</h2> 
<p>可行的匹配：把某个块放在某个位置之后，如果接下来还有解，那就是可行的匹配。</p> 
<p>平坦区域：接近矩形的区域，没有十分明显的局部特征。</p> 
<p></p> 
<h2 id="%E4%B8%89%EF%BC%8C%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5">四，启发式搜索策略</h2> 
<h3 id="1%EF%BC%8C%E6%95%B0%E7%8B%AC">1，数独</h3> 
<p>我构造了一个数独来显化这种启发式策略：</p> 
<p><img alt="" height="353" src="https://images2.imgbox.com/14/f6/wm0wMguy_o.png" width="347"></p> 
<p>对于这个数独，没有任何疑问，首先看行填2，其次看列填5，然后看宫填9。</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/be/32/a2F1hHAK_o.png" width="344"></p> 
<p> 现在我们来总结一下这个思维的本质。</p> 
<p>有些人可能会这么描述：“<strong>先把确定的填了，再看不确定的</strong>”，或者“<strong>先把简单的填了，再看难的</strong>”。</p> 
<p>这些说法没错，但是不够精确。</p> 
<p>在一开始，单独看3个格子中的任意一个的话，E2有3种情况（看宫），分别是259，F2有2种情况（看列），分别是25，F3有1种情况（看行），是2</p> 
<p>那么，在这个<span style="color:#fe2c24;"><strong>深度优先搜索</strong></span>问题中，我们的策略是，<strong>先把元素进行排序，情况少的元素往前排，即先搜索情况比较少的元素</strong>。这是深度优先搜索的常见优化技巧。</p> 
<h3 id="2%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%80">2，策略一</h3> 
<p><span style="color:#fe2c24;"><strong>如果对于结构比较复杂的局部区域，有某种拼法是比较精巧的，那这就很可能是某个正确答案的一部分</strong></span>。</p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/d5/3e/ufwwMR6O_o.png" width="301">  <img alt="" height="326" src="https://images2.imgbox.com/44/e0/I0w6fMdU_o.png" width="298"></p> 
<p>这样一条模糊的策略，是否正确？本质是啥？</p> 
<p>首先，<strong><span style="color:#0d0016;">结构比较复杂的局部区域是问题的一种特征，精巧的覆盖是解的一种特征</span></strong>。</p> 
<p>问题的特征告诉我们，这个位置的可能的情况比较少，而平坦位置的可能情况比较多。</p> 
<p>解的特征告诉我们，有相对较高的概率这个一个可行的匹配，如果确实是一个可行匹配，那么在此匹配前提下的解是相对较多的。</p> 
<p>也就是说，这其实暗含了下面列的很多条策略，没想到吧O(∩_∩)O哈哈~</p> 
<h3 id="3%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%BA%8C">3，策略二</h3> 
<p><span style="color:#fe2c24;"><strong>先从结构比较复杂的局部区域开始拼，平坦的区域靠后拼</strong></span>。</p> 
<p>此时我们和上面的数独对比，可以感受到，他们的核心逻辑是完成相同的。</p> 
<p>通常情况下，被排除的3个格子、右上角、右下角都是结构比较复杂的局部区域。</p> 
<h3 id="4%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E4%B8%89">4，策略三</h3> 
<p>我们在拼的时候经常需要评估，一个匹配的优劣程度。<span style="color:#fe2c24;"><strong>在面临选择时，我们优先选择直觉上更优的匹配</strong></span>。</p> 
<p>直觉有点玄乎，但是我们可以看到我在上面给出的三月的解法有很多都是这样的：</p> 
<p><img alt="" height="475" src="https://images2.imgbox.com/db/83/6k52aspN_o.png" width="423"></p> 
<p>可以说这就是很优的匹配。</p> 
<p>PS：如果我一早就想通了这个策略，3月至少有20天这2个块就可以这么放。</p> 
<p>对于4月，我相信这是一个不错的匹配：</p> 
<p><img alt="" height="576" src="https://images2.imgbox.com/f8/9e/bTMpmfxC_o.png" width="508"></p> 
<p></p> 
<p></p> 
<p></p> 
<h3 id="5%EF%BC%8C%E6%8B%BC%E5%9B%BE%E7%9A%84%E7%AD%96%E7%95%A5%E5%9B%9B">5，策略四</h3> 
<p><span style="color:#fe2c24;"><strong>先从复杂的块开始拼，简单的块靠后</strong></span>。</p> 
<p>这个和策略二很相似，策略二其实是，复杂的局部区域有更少的可能性，策略四其实是，复杂的块有更少的可能性。</p> 
<p>以下图为例感受一下简单块的可能性之多：</p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/f1/6e/HPdOMN1y_o.png" width="449"></p> 
<p> 即使到了最后一步，仍然有2种放法。</p> 
<p>而如果留到最后的是复杂的块，就很可能是0-1种放法。</p> 
<p>根据块的复杂程度，我简单分成三个梯度，复杂，中等，简单。</p> 
<p>3个复杂的：</p> 
<p><img alt="" height="199" src="https://images2.imgbox.com/bd/e7/txgoHLMD_o.png" width="235"></p> 
<p>5个中等的：</p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/2e/2b/P0IbOeEt_o.png" width="224"></p> 
<p>2个简单的：</p> 
<p><img alt="" height="195" src="https://images2.imgbox.com/ac/b9/3SP7vK6f_o.png" width="211"></p> 
<p></p> 
<h3 id="6%EF%BC%8C%E7%AD%96%E7%95%A5%E4%BA%94">6，策略五</h3> 
<p>首先我们分析一下这个拼图的平直程度。</p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/f7/50/REfxS35a_o.png" width="357"></p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/8d/ae/o5AsubXU_o.png" width="370"></p> 
<p>例子太多，我不一一列举。</p> 
<p>我直接给出我总结出的规律，在同类puzzle中，<span style="color:#fe2c24;"><strong>日历拼图的平直程度是非常高的</strong></span>。</p> 
<p> 为什么会这样呢？我认为主要是块本身的属性造成的。</p> 
<p>我把日历拼图的10个块，在<a class="link-info" href="https://blog.csdn.net/nameofcsdn/article/details/115694448" title="方格游戏">方格游戏</a>中的17个格子中标示出来（去掉小于4个格子的只有17个）</p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/08/ed/So5sMOAZ_o.png" width="239"></p> 
<p>1、3、4、7、11、14、16号这7个是没有的，而其中的1、3、4、7、14显然符合我在上面策略四中提到的“<strong>复杂的块</strong>”这个特征。</p> 
<p>从某种程度上说，这个复杂其实说的就是不平直的程度。</p> 
<p><span style="color:#fe2c24;"><strong>日历拼图和方格游戏是两个极端</strong></span>。<span style="color:#4da8ee;">日历拼图为了每个组合都有解，选的主要是平直度较高的块，方格游戏其实不是覆盖问题，而是依赖角点进行区域拓宽的一种博弈游戏，所以选的主要是平直度较低的块</span>。</p> 
<p>上面的策略四是根据块的复杂性（平直度）进行排序，而这里的策略五只针对平直度低的块，以3月29日周二为例：</p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/ad/64/o4tuOHyb_o.png" width="363"></p> 
<p>周二这个格子和L型的块是一个很差的匹配。</p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/6e/c5/UFiB7Ayl_o.png" width="400"></p> 
<p>而这是一个非常好的匹配，这个块和边界完美贴合，和周二的匹配也非常好。</p> 
<p>综上，策略五就是，<span style="color:#fe2c24;"><strong>月日周排除的三个格子，尤其是离边界还有一个距离的格子（如上周二），要放在块的折口处，但是不能放L型块的折口处，从而维持整个局面的平直性</strong></span>。</p> 
<h3 id="7%EF%BC%8C%E7%AD%96%E7%95%A5%E5%85%AD">7，策略六</h3> 
<p>策略六是替换策略。</p> 
<p>以2月4日周五为例，我拼成了这样：</p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/d9/db/m2UHITf9_o.png" width="469"></p> 
<p>乍一看无解，实际上答案已经出来了：</p> 
<p><img alt="" height="541" src="https://images2.imgbox.com/14/cf/mBNzjP5K_o.png" width="478"></p> 
<p></p> 
<p>一般来说，最简单的替换是这2组：</p> 
<p><img alt="" height="510" src="https://images2.imgbox.com/41/60/ppxWE2sX_o.png" width="321"></p> 
<p></p> 
<p></p> 
<h2 id="%E4%BA%94%EF%BC%8C%E6%95%B0%E5%AD%97%E5%8C%96">五，数字化</h2> 
<p>利用边缘检测和其他图像处理技术，把一张包含答案的图片，转化成数字。</p> 
<h3 id="1%EF%BC%8C%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E4%BA%8C%E5%80%BC%E5%8C%96">1，读取图片并二值化</h3> 
<pre><code class="language-cpp">Mat GetImage(int i)
{
	Mat img = imread("D:/p/img (" + to_string(i) + ").png", 0);
	resize(img, img, Size(0, 0), 0.5, 0.5);
	Mat src;
	threshold(img, src, 200, 255, THRESH_TRUNC);
	threshold(src, src, 100, 255, THRESH_TOZERO);
	return src;
}</code></pre> 
<h3 id="2%EF%BC%8C%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B">2，边缘检测</h3> 
<pre><code class="language-cpp">	Mat src = GetImage(i);
	Canny(src, src, 200, 100, 3);
	cv::imshow("src" + to_string(i), src);</code></pre> 
<p><img alt="" height="385" src="https://images2.imgbox.com/76/b1/bY6vLWcI_o.png" width="327"><img alt="" height="403" src="https://images2.imgbox.com/3e/d5/Ly8fRYIT_o.png" width="317"></p> 
<p></p> 
<h3 id="%C2%A03%EF%BC%8C%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B">3，轮廓检测</h3> 
<pre><code class="language-cpp">    std::vector&lt;std::vector&lt;Point&gt;&gt; contours;
	std::vector&lt;Vec4i&gt; hierarchy;
	findContours(src, contours, hierarchy, RETR_LIST, CHAIN_APPROX_NONE, Point(0, 0));
	cout &lt;&lt; contours.size() &lt;&lt; endl;
	sort(contours.begin(), contours.end(), cmp&lt; Point&gt;);
	for (int i = 0; i &lt; contours.size(); i++)cout &lt;&lt; contours[i].size() &lt;&lt; " ";</code></pre> 
<p>把轮廓按照点数排序，点最多的轮廓就是我们需要的轮廓。</p> 
<h3 id="4%EF%BC%8C%E6%B1%82%E8%A7%A3%E6%A0%BC%E5%AD%90%E5%B0%BA%E5%AF%B8%E3%80%81%E5%9D%90%E6%A0%87">4，求解格子尺寸、坐标</h3> 
<pre><code class="language-cpp">int GetSize(const vector&lt;std::vector&lt;Point&gt;&gt;&amp; contours, int &amp;xmin ,int &amp;ymin)
{
	xmin = 1234567, ymin = 1234567;
	int xmax = 0, ymax = 0;
	for (int i = 0; i &lt; 5 &amp;&amp; i &lt; contours.size(); i++) {
		for (auto&amp; pi : contours[i]) {
			if (xmin &gt; pi.x)xmin = pi.x;
			if (ymin &gt; pi.y)ymin = pi.y;
			if (xmax &lt; pi.x)xmax = pi.x;
			if (ymax &lt; pi.y)ymax = pi.y;
		}
	}
	int dx = xmax - xmin, dy = ymax - ymin;
	dx /= 7, dy /= 8;
	cout &lt;&lt; endl &lt;&lt; dx &lt;&lt; endl &lt;&lt; dy;
	return dx;
}</code></pre> 
<p>其中for循环控制的是取前多少个轮廓，否则很容易受到最外面的轮廓的影响。</p> 
<p>xmin和ymin记录了左上角的格子坐标。</p> 
<h3 id="5%EF%BC%8C%E8%AE%A1%E7%AE%97%E6%9C%89%E6%95%88%E8%BD%AE%E5%BB%93%E6%95%B0%E9%87%8F">5，计算有效轮廓数量</h3> 
<p>为了更有效的计算格子尺寸，需要更智能的选择轮廓数量。</p> 
<pre><code class="language-cpp">void GetContoursNum(Mat src, const vector&lt;std::vector&lt;Point&gt;&gt;&amp; contours)
{
	bool xmin=false, xmax = false, ymin = false, ymax = false;
	contoursNum = 0;
	for (contoursNum = 0; contoursNum &lt; contours.size(); contoursNum++) {
		for (auto &amp;pi : contours[contoursNum]) {
			if (src.cols / 7 &gt; pi.x)xmin = true;
			if (src.rows / 8 &gt; pi.y)ymin = true;
			if (src.cols / 7*6 &lt; pi.x)xmax = true;
			if (src.rows / 8*7 &lt; pi.y)ymax = true;
		}
		if (xmin &amp;&amp; ymin &amp;&amp; xmax &amp;&amp; ymax)break;
	}
	contoursNum++;
}</code></pre> 
<p>这对于一些场景有帮助，但是对于最外面的干扰轮廓很清晰的情况，还是无法避免。</p> 
<p></p> 
<h3 id="6%EF%BC%8C%E5%9D%90%E6%A0%87%E5%BE%AE%E8%B0%83">6，坐标微调</h3> 
<p>计算的坐标还是容易受最外面的轮廓的影响，所以我们把坐标进行微调。</p> 
<p>试了几个方法都不太好，先不做这个了，留一个接口，如果需要的话可以手动调。</p> 
<pre><code class="language-cpp">void GetPos()
{
	xmin += 0, ymin += 0; // 手动调整
	return;
}</code></pre> 
<h3 id="7%EF%BC%8C%E6%89%8B%E5%8A%A8%E5%88%A0%E5%87%8F%E8%BD%AE%E5%BB%93">7，手动删减轮廓</h3> 
<p>最外面的轮廓干扰太大，所以最后我干脆提供一个手动删掉几个轮廓的接口。</p> 
<pre><code class="language-cpp">void RemoveContours(vector&lt;std::vector&lt;Point&gt;&gt;&amp; contours)
{
	int id[] = { 2,3 }; // 手动调整
	for (int i = sizeof(id) / sizeof(int); i &gt;= 0; i--) {
		if (id[i] &lt; contours.size())contours.erase(contours.begin() + id[i]);
	}
}</code></pre> 
<p>手动调坐标不太好操作，而且不精确，但根据显示的图很容易找出最外面的1-2个轮廓（如果有的话），这样就可以直接手动填写要删除的轮廓id重新运行。</p> 
<h3 id="8%EF%BC%8C%E8%A7%A3%E6%9E%90%E7%A9%BA%E5%87%BA%E6%9D%A5%E7%9A%843%E4%B8%AA%E6%A0%BC%E5%AD%90">8，解析空出来的3个格子</h3> 
<pre><code class="language-cpp">void GetInvalidPos(int size, Mat src)
{
	int x[8][7];
	int m, d, w, k = 0;
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		x[i][j] = 0;
		if (i &lt; 2 &amp;&amp; j == 6)continue;
		if (i == 7 &amp;&amp; j &lt; 4)continue;
		int r = ymin + size * i;
		int c = xmin + size * j;
		for (int row = r + size / 4; row &lt; r + size / 4 * 3; row++) {
			for (int col = c + size / 4; col &lt; c + size / 4 * 3; col++) {
				x[i][j] += int(src.at&lt;uchar&gt;(row, col));
			}
		}
		if (x[i][j] &gt; 100) {
			if (k == 0) {
				m = i * 6 + j + 1; // 1-12
			} else if (k == 1) {
				d = (i - 2) * 7 + j + 1; // 1-31
			} else {
				w = (i - 6) * 3 + j - 3; // 0-6
			}
			k++;
		}
	}
	string s[] = { "日","一","二" ,"三" ,"四" ,"五" ,"六" };
	cout &lt;&lt; m &lt;&lt; "月" &lt;&lt; d &lt;&lt; "日周" &lt;&lt; s[w];
}</code></pre> 
<h3 id="8%EF%BC%8C%E8%BF%9E%E9%80%9A%E6%80%A7%E8%AE%A1%E7%AE%97">8，连通性计算</h3> 
<pre><code class="language-cpp">void connect(Mat src)
{

	//for (int i = 0; i &lt; src.rows; i++)for (int j = 0; j &lt; src.cols; j++) {
	//	if (i%size_ == ymin % size_ || j % size_ == xmin % size_) {
	//		src.at&lt;uchar&gt;(i,j) = 200;
	//	}
	//}
	//imshow("src", src);

	bool up[8][7];
	for (int i = 1; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		up[i][j] = true;
		if (!valid(i,j))continue;
		if (!valid(i-1, j))continue;
		int s = 0;
		//src.at&lt;uchar&gt;(ymin + size_ * i - size_ / 4, xmin + size_ * j + size_ / 4) = 200;
		//src.at&lt;uchar&gt;(ymin + size_ * i + size_ / 4, xmin + size_ * j + size_ / 4 * 3) = 200;
		for (int r = ymin + size_ * i - size_ / 4; r &lt; ymin + size_ * i + size_ / 4; r++) {
			for (int c = xmin + size_ * j + size_ / 4; c &lt; xmin + size_ * j + size_ / 4 * 3; c++) {
				if (int(src.at&lt;uchar&gt;(r, c)) &gt; 10)s++;
			}
		}
		if (s &gt; 5)up[i][j] = false;
	}
	//imshow("src", src);
	bool left[8][7];
	for (int i = 0; i &lt; 8; i++)for (int j = 1; j &lt; 7; j++) {
		left[i][j] = true;
		if (!valid(i, j))continue;
		if (!valid(i, j-1))continue;
		int s = 0;
		for (int r = ymin + size_ * i + size_ / 4; r &lt; ymin + size_ * i + size_ / 4*3; r++) {
			for (int c = xmin + size_ * j - size_ / 4; c &lt; xmin + size_ * j + size_ / 4; c++) {
				if (int(src.at&lt;uchar&gt;(r, c)) &gt; 10)s++;
			}
		}
		if (s &gt; 10)left[i][j] = false;
	}
	return;
}</code></pre> 
<p>计算每2个格子间的交接处有没有边缘检测出的点，判断2个格子是否连通。</p> 
<p>再用并查集把连通的格子连起来。</p> 
<pre><code class="language-cpp">bool valid2(int i, int j)
{
	if (!valid(i,j))return false;
	if (i == mi &amp;&amp; j == mj)return false;
	if (i == di &amp;&amp; j == dj)return false;
	if (i == wi &amp;&amp; j == wj)return false;
	return true;
}
int fa[8 * 7]; // id=i*7+j
int find(int x)	//找祖先
{
	if (fa[x] == x)return x;
	return fa[x] = find(fa[x]);
}
void split()
{
	for (int i = 0; i &lt; 56; i++)fa[i] = i;
	for (int i = 1; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		if (!valid2(i, j))continue;
		if (!valid2(i - 1, j))continue;
		if (up[i][j])fa[find(i * 7 + j)] = find((i - 1) * 7 + j);
	}
	for (int i = 0; i &lt; 8; i++)for (int j = 1; j &lt; 7; j++) {
		if (!valid2(i, j))continue;
		if (!valid2(i, j-1))continue;
		if (left_[i][j])fa[find(i * 7 + j)] = find(i * 7 + j - 1);
	}
	map&lt;int, int&gt;m;
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		if (!valid2(i, j))continue;
		m[find(i * 7 + j)]++;
	}
	int k = 0;
	map&lt;int, int&gt;m2;
	for (auto &amp;mi : m)m2[mi.first] = ++k;
	int block[8][7];
	for (int i = 0; i &lt; 8; i++) {
		for (int j = 0; j &lt; 7; j++) {
			if (!valid2(i, j))block[i][j] = 0;
			else block[i][j] = m2[find(i * 7 + j)];
			cout &lt;&lt;setw(3)&lt;&lt; block[i][j];
		}
		cout &lt;&lt; endl;
	}
	return;
}</code></pre> 
<h3 id="9%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">9，完整代码</h3> 
<pre><code class="language-cpp">

#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;opencv2/opencv.hpp&gt;
#include&lt;opencv2/highgui.hpp&gt;
#include&lt;opencv2/core/mat.hpp&gt;
using namespace std;
using namespace cv;


#pragma comment(lib,"../x64/vc14/lib/opencv_world452.lib")
#pragma comment(lib,"../x64/vc14/lib/opencv_world452d.lib")



int xmin, ymin, size_;
int contoursNum;
bool up[8][7];
bool left_[8][7];
int mi, mj, di, dj, wi, wj;

template&lt;typename T&gt;
bool cmp(vector&lt;T&gt; x, vector&lt;T&gt; y)
{
	return x.size() &gt; y.size();
}

Mat GetImage(int i)
{
	Mat img = imread("D:/p/img (" + to_string(i) + ").jpg", 0);
	resize(img, img, Size(0, 0), 0.3, 0.3);
	Mat src;
	threshold(img, src, 200, 255, THRESH_TRUNC);
	threshold(src, src, 100, 255, THRESH_TOZERO);
	return src;
}
void RemoveContours(vector&lt;std::vector&lt;Point&gt;&gt;&amp; contours)
{
	int id[] = { 100 }; // 手动调整
	for (int i = sizeof(id) / sizeof(int) -1; i &gt;= 0; i--) {
		if (id[i] &lt; contours.size())contours.erase(contours.begin() + id[i]);
	}
}
void GetContoursNum(Mat src, const vector&lt;std::vector&lt;Point&gt;&gt;&amp; contours)
{
	bool xmin = false, xmax = false, ymin = false, ymax = false;
	contoursNum = 0;
	for (contoursNum = 0; contoursNum &lt; contours.size(); contoursNum++) {
		for (auto&amp; pi : contours[contoursNum]) {
			if (src.cols / 7 &gt; pi.x)xmin = true;
			if (src.rows / 8 &gt; pi.y)ymin = true;
			if (src.cols / 7 * 6 &lt; pi.x)xmax = true;
			if (src.rows / 8 * 7 &lt; pi.y)ymax = true;
		}
		if (xmin &amp;&amp; ymin &amp;&amp; xmax &amp;&amp; ymax)break;
	}
	contoursNum++;
}
void GetSize(const vector&lt;std::vector&lt;Point&gt;&gt;&amp; contours)
{
	xmin = 1234567, ymin = 1234567;
	int xmax = 0, ymax = 0;
	for (int i = 0; i &lt; contoursNum &amp;&amp; i &lt; contours.size(); i++) {
		for (auto&amp; pi : contours[i]) {
			if (xmin &gt; pi.x)xmin = pi.x;
			if (ymin &gt; pi.y)ymin = pi.y;
			if (xmax &lt; pi.x)xmax = pi.x;
			if (ymax &lt; pi.y)ymax = pi.y;
		}
	}
	int dx = xmax - xmin, dy = ymax - ymin;
	dx /= 7, dy /= 8;
	//cout &lt;&lt; endl &lt;&lt; dx &lt;&lt; endl &lt;&lt; dy;
	size_ = dx;
}

void GetPos()
{
	xmin += 0, ymin += 0; // 手动调整
	return;
}

bool valid(int i, int j)
{
	if (i &lt; 2 &amp;&amp; j == 6)return false;
	if (i == 7 &amp;&amp; j &lt; 4)return false;
	return true;
}

void GetInvalidPos(Mat src)
{
	int x[8][7];
	int m, d, w, k = 0;
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		x[i][j] = 0;
		if (!valid(i, j))continue;
		int r = ymin + size_ * i;
		int c = xmin + size_ * j;
		for (int row = r + size_ / 4; row &lt; r + size_ / 4 * 3; row++) {
			for (int col = c + size_ / 4; col &lt; c + size_ / 4 * 3; col++) {
				x[i][j] += int(src.at&lt;uchar&gt;(row, col));
			}
		}
		if (x[i][j] &gt; 2000) {
			if (k == 0) {
				mi = i, mj = j;
				m = i * 6 + j + 1; // 1-12
			}
			else if (k == 1) {
				di = i, dj = j;
				d = (i - 2) * 7 + j + 1; // 1-31
			}
			else {
				wi = i, wj = j;
				w = (i - 6) * 3 + j - 3; // 0-6
			}
			k++;
		}
	}
	if (w &lt; 0 || w&gt;7) {
		cout &lt;&lt; "error,w=" &lt;&lt; w &lt;&lt; endl;
		w = 0;
	}
	string s[] = { "日","一","二" ,"三" ,"四" ,"五" ,"六" };
	cout &lt;&lt; m &lt;&lt; "月" &lt;&lt; d &lt;&lt; "日周" &lt;&lt; s[w] &lt;&lt; endl;
}

void connect(Mat src)
{

	//for (int i = 0; i &lt; src.rows; i++)for (int j = 0; j &lt; src.cols; j++) {
	//	if (i%size_ == ymin % size_ || j % size_ == xmin % size_) {
	//		src.at&lt;uchar&gt;(i,j) = 200;
	//	}
	//}
	//imshow("src", src);


	for (int i = 1; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		up[i][j] = true;
		if (!valid(i, j))continue;
		if (!valid(i - 1, j))continue;
		int s = 0;
		//src.at&lt;uchar&gt;(ymin + size_ * i - size_ / 4, xmin + size_ * j + size_ / 4) = 200;
		//src.at&lt;uchar&gt;(ymin + size_ * i + size_ / 4, xmin + size_ * j + size_ / 4 * 3) = 200;
		for (int r = ymin + size_ * i - size_ / 4; r &lt; ymin + size_ * i + size_ / 4; r++) {
			for (int c = xmin + size_ * j + size_ / 4; c &lt; xmin + size_ * j + size_ / 4 * 3; c++) {
				if (int(src.at&lt;uchar&gt;(r, c)) &gt; 10)s++;
			}
		}
		if (s &gt; 5)up[i][j] = false;
	}
	//imshow("src", src);

	for (int i = 0; i &lt; 8; i++)for (int j = 1; j &lt; 7; j++) {
		left_[i][j] = true;
		if (!valid(i, j))continue;
		if (!valid(i, j - 1))continue;
		int s = 0;
		for (int r = ymin + size_ * i + size_ / 4; r &lt; ymin + size_ * i + size_ / 4 * 3; r++) {
			for (int c = xmin + size_ * j - size_ / 4; c &lt; xmin + size_ * j + size_ / 4; c++) {
				if (int(src.at&lt;uchar&gt;(r, c)) &gt; 10)s++;
			}
		}
		if (s &gt; 10)left_[i][j] = false;
	}
	return;
}

bool valid2(int i, int j)
{
	if (!valid(i, j))return false;
	if (i == mi &amp;&amp; j == mj)return false;
	if (i == di &amp;&amp; j == dj)return false;
	if (i == wi &amp;&amp; j == wj)return false;
	return true;
}
int fa[8 * 7]; // id=i*7+j
int find(int x)	//找祖先
{
	if (fa[x] == x)return x;
	return fa[x] = find(fa[x]);
}
void split()
{
	for (int i = 0; i &lt; 56; i++)fa[i] = i;
	for (int i = 1; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		if (!valid2(i, j))continue;
		if (!valid2(i - 1, j))continue;
		if (up[i][j])fa[find(i * 7 + j)] = find((i - 1) * 7 + j);
	}
	for (int i = 0; i &lt; 8; i++)for (int j = 1; j &lt; 7; j++) {
		if (!valid2(i, j))continue;
		if (!valid2(i, j - 1))continue;
		if (left_[i][j])fa[find(i * 7 + j)] = find(i * 7 + j - 1);
	}
	map&lt;int, int&gt;m;
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		if (!valid2(i, j))continue;
		m[find(i * 7 + j)]++;
	}
	using P = pair&lt;int, int&gt;;
	vector&lt;P&gt;v;
	for (auto&amp; mi : m)v.push_back(mi);
	sort(v.begin(), v.end(), [](P p1, P p2) { return p1.second &gt; p2.second; });
	int k = 0;
	map&lt;int, int&gt;m2;
	for (auto&amp; vi : v)m2[vi.first] = ++k;
	int block[8][7];
	int pix = 50;
	Mat img = Mat(Size(pix * 7, pix * 8), CV_8UC1);
	for (int i = 0; i &lt; 8; i++) {
		for (int j = 0; j &lt; 7; j++) {
			if (!valid2(i, j))block[i][j] = 0;
			else block[i][j] = m2[find(i * 7 + j)];
			cout &lt;&lt; setw(3) &lt;&lt; block[i][j];
			for (int r = pix * i; r &lt; pix * (i + 1); r++) {
				for (int c = pix * j; c &lt; pix * (j + 1); c++) {
					img.at&lt;uchar&gt;(r, c) = 25 * block[i][j];
				}
			}
			if (!valid2(i, j)) {
				for (int x = 0; x &lt; pix; x++) {
					img.at&lt;uchar&gt;(pix * i + x, pix * j + x) = 255;
					img.at&lt;uchar&gt;(pix * i + x, pix * j + pix - x -1) = 255;
				}
			}
		}
		cout &lt;&lt; endl;
	}
	static int kid = 0;
	imshow("ans"+to_string(kid++),img);
	return;
}

void f(int i)
{
	Mat src = GetImage(i);
	Canny(src, src, 200, 100, 3);
	//cv::imshow("src" + to_string(i), src);

	std::vector&lt;std::vector&lt;Point&gt;&gt; contours;
	std::vector&lt;Vec4i&gt; hierarchy;
	findContours(src, contours, hierarchy, RETR_LIST, CHAIN_APPROX_NONE, Point(0, 0));
	//cout &lt;&lt; contours.size() &lt;&lt; endl;
	sort(contours.begin(), contours.end(), cmp&lt; Point&gt;);
	RemoveContours(contours);
	//for (int i = 0; i &lt; contours.size(); i++)cout &lt;&lt; contours[i].size() &lt;&lt; " ";
	GetContoursNum(src, contours);

	Mat img(Size(src.cols, src.rows), src.type());
	img = 0;
	for (int i = 0; i &lt; contoursNum &amp;&amp; i &lt; contours.size(); i++) {
		cv::drawContours(img, contours, i, cv::Scalar::all(255));
		//cv::imshow("contours" + to_string(i), img);
	}

	GetSize(contours);
	GetPos();
	GetInvalidPos(src);
	connect(src);
	split();
}

int main()
{
	for (int i = 7; i &lt;= 11; i++)
	{
		f(i);
	}
	cv::waitKey(0);
	return 0;
}</code></pre> 
<p>运行效果：</p> 
<p><img alt="" height="325" src="https://images2.imgbox.com/c7/6b/Dkv6cbKq_o.png" width="642"></p> 
<p>可以看到数字化完全正确，为了方便校验做出来的灰度图也一致。</p> 
<p>在10张照片里面有一张运行有点问题：</p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/86/73/4NE0wOgQ_o.png" width="653"></p> 
<p>有2个块连起来了，这种情况只能手动微改一下了。</p> 
<p></p> 
<h2 id="%E5%85%AD%EF%BC%8C%E4%BB%A5%E8%A7%A3%E7%94%9F%E8%A7%A3">六，以解生解</h2> 
<p>每完成一个月的解法，就可以按照大拇指和U型分别生成解，把找到的新解存下来以作备用。</p> 
<h3 id="1%EF%BC%8C%E5%A4%A7%E6%8B%87%E6%8C%87">1，大拇指</h3> 
<p><img alt="" height="324" src="https://images2.imgbox.com/b3/39/EsTXg37Q_o.png" width="300"></p> 
<p>把形似大拇指的这个块，通过翻转，可以生成不同的解。</p> 
<p>（1）识别大拇指 </p> 
<pre><code class="language-cpp">//#include "data.h"

#include&lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

#define OUT(x) cout &lt;&lt; endl &lt;&lt; #x &lt;&lt; " = "; Print(x);
template&lt;typename T&gt;
inline void Print(T x)
{
	cout &lt;&lt; x &lt;&lt; " ";
}
template&lt;typename T&gt;
inline void Read(T&amp; x)
{
	while (!(cin &gt;&gt; x)) { // only cin type T, ignore other info
		cin.clear();
		cin.ignore();
	}
}

const float theNan = 0.123456; //float默认只有6位
void Print(float x)
{
	if (std::isnan(x)) cout &lt;&lt; theNan &lt;&lt; " ";
	else cout &lt;&lt; x &lt;&lt; " ";
}
void Read(float&amp; x)
{
	Read&lt;float&gt;(x);
	if (x == theNan) x = NAN;
}

int main()
{
	int x[8][7];
	while (true)
	{
		for (int i = 0; i &lt; 8; i++)
		{
			for (int j = 0; j &lt; 7; j++)
			{
				Read(x[i][j]);
			}
		}
		for (int k = 1; k &lt; 10; k++)
		{
			int xmin = 10, ymin = 10, xmax = 0, ymax = 0;
			for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)
			{
				if (x[i][j] != k)continue;
				xmin = min(xmin, i);
				ymin = min(ymin, j);
				xmax = max(xmax, i);
				ymax = max(ymax, j);
			}
			if ((xmax - xmin + 1) * (ymax - ymin + 1) != 6)continue;
			bool flag = true;
			int n = 0;
			for (int i = xmin; i &lt;= xmax &amp;&amp; flag; i++)for (int j = ymin; j &lt;= ymax &amp;&amp; flag; j++)
			{
				if (x[i][j] == k)continue;
				if (x[i][j])flag = false;
				n++;
			}
			if (!flag || n &gt; 1)continue;
			if (x[xmin][ymin] &amp;&amp; x[xmin][ymax] &amp;&amp; x[xmax][ymin] &amp;&amp; x[xmax][ymax])continue;
			cout &lt;&lt; "                                  "&lt;&lt;k &lt;&lt; endl;
		}
	}
	return 0;
}</code></pre> 
<p>（2）进行翻转</p> 
<p>除了当前解，还可以生成3个不同的解</p> 
<pre><code class="language-cpp">            for (int i = 0; i &lt; 3; i++) {
				int tmp = x[xmin][ymin];
				x[xmin][ymin] = x[xmin][ymax];
				x[xmin][ymax] = x[xmax][ymin];
				x[xmax][ymin] = x[xmax][ymax];
				x[xmax][ymax] = tmp;

			}</code></pre> 
<p>（3）校验是否合法</p> 
<pre><code class="language-cpp">int x[8][7];
int m, d, w;
string s[] = { "日","一","二" ,"三" ,"四" ,"五" ,"六" };
bool valid(int i, int j)
{
	if (i &lt; 2 &amp;&amp; j == 6)return false;
	if (i == 7 &amp;&amp; j &lt; 4)return false;
	return true;
}
bool check()
{
	int k = 0;
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		if (!valid(i, j))continue;
		if (x[i][j] == 0) {
			if (k == 0) {
				if (i &gt; 1)
					return false;
				m = i * 6 + j + 1; // 1-12
			}
			else if (k == 1) {
				if (i &lt;= 1)
					return false;
				if (i * 7 + j &gt;= 45)
					return false;
				d = (i - 2) * 7 + j + 1; // 1-31
			}
			else {
				if (i * 7 + j &lt; 45)
					return false;
				w = (i - 6) * 3 + j - 3; // 0-6
			}
			k++;
		}
	}
}</code></pre> 
<p></p> 
<h3 id="2%EF%BC%8C%E5%8F%AF%E8%A7%86%E5%8C%96">2，可视化</h3> 
<p>为了方便查看，单独把显示图像的函数提取出来。</p> 
<pre><code class="language-cpp">int x[8][7];

void show()
{
	int pix = 50;
	Mat img = Mat(Size(pix * 7, pix * 8), CV_8UC1);
	for (int i = 0; i &lt; 8; i++) {
		for (int j = 0; j &lt; 7; j++) {
			for (int r = pix * i; r &lt; pix * (i + 1); r++) {
				for (int c = pix * j; c &lt; pix * (j + 1); c++) {
					img.at&lt;uchar&gt;(r, c) = 25 * x[i][j];
				}
			}
			if (x[i][j]==0) {
				for (int x = 0; x &lt; pix; x++) {
					img.at&lt;uchar&gt;(pix * i + x, pix * j + x) = 255;
					img.at&lt;uchar&gt;(pix * i + x, pix * j + pix - x - 1) = 255;
				}
			}
		}
		cout &lt;&lt; endl;
	}
	static int kid = 0;
	imshow("ans" + to_string(kid++), img);
}

int main()
{
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)Read(x[i][j]);
	show();
	cv::waitKey(0);
	return 0;
}</code></pre> 
<h3 id="3%EF%BC%8CU%E5%9E%8B">3，U型</h3> 
<p>和大拇指类似，U型也可以用来生成解。</p> 
<p>代码几乎是一样的，微改一下即可：</p> 
<pre><code class="language-cpp">int main()
{
	freopen("D:/out.txt", "w", stdout);
	while (true)
	{
		for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)Read(x[i][j]);
		for (int k = 1; k &lt; 10; k++)
		{
			int xmin = 10, ymin = 10, xmax = 0, ymax = 0;
			for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)
			{
				if (x[i][j] != k)continue;
				xmin = min(xmin, i);
				ymin = min(ymin, j);
				xmax = max(xmax, i);
				ymax = max(ymax, j);
			}
			if ((xmax - xmin + 1) * (ymax - ymin + 1) != 6)continue;
			bool flag = true;
			int n = 0;
			for (int i = xmin; i &lt;= xmax &amp;&amp; flag; i++)for (int j = ymin; j &lt;= ymax &amp;&amp; flag; j++)
			{
				if (x[i][j] == k)continue;
				if (x[i][j])flag = false;
				n++;
			}
			if (!flag || n &gt; 1)continue;
			if (!(x[xmin][ymin] &amp;&amp; x[xmin][ymax] &amp;&amp; x[xmax][ymin] &amp;&amp; x[xmax][ymax]))continue;
			//cout &lt;&lt; "                                  "&lt;&lt;k &lt;&lt; endl;
			int tmp = x[(xmin + xmax) / 2][(ymin + ymax) / 2];
			x[(xmin + xmax) / 2][(ymin + ymax) / 2] = x[xmin + 1][ymin + 1], x[xmin + 1][ymin + 1] = tmp;
			if (check()) {
				cout &lt;&lt; m &lt;&lt; "月" &lt;&lt; d &lt;&lt; "日周" &lt;&lt; s[w] &lt;&lt; endl;
				for (int i = 0; i &lt; 8; i++) {
					for (int j = 0; j &lt; 7; j++) {
						cout &lt;&lt; setw(3) &lt;&lt; x[i][j];
					}
					cout &lt;&lt; endl;
				}
			}
			break;
		}
	}
	return 0;
}</code></pre> 
<h3 id="4%EF%BC%8C%E6%96%B0%E8%A7%A3">4，新解</h3> 
<p>由于产生的新解太多，所以挪到本地磁盘了。</p> 
<h3 id="5%EF%BC%8C%E6%97%A5%E6%9C%9F%E6%B1%87%E6%80%BB">5，日期汇总</h3> 
<p>为了自动去重，建立日期汇总，每次有一个解产生时，都把日期加进来。以本地文件为准。</p> 
<h3 id="6%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">6，完整代码V1</h3> 
<pre><code class="language-cpp">//#include "data.h"

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;string&gt;
using namespace std;

#define OUT(x) cout &lt;&lt; endl &lt;&lt; #x &lt;&lt; " = "; Print(x);
template&lt;typename T&gt;
inline void Print(T x)
{
	cout &lt;&lt; x &lt;&lt; " ";
}
template&lt;typename T&gt;
inline void Read(T&amp; x)
{
	while (!(cin &gt;&gt; x)) { // only cin type T, ignore other info
		cin.clear();
		cin.ignore();
	}
}

const float theNan = 0.123456; //float默认只有6位
void Print(float x)
{
	if (std::isnan(x)) cout &lt;&lt; theNan &lt;&lt; " ";
	else cout &lt;&lt; x &lt;&lt; " ";
}
void Read(float&amp; x)
{
	Read&lt;float&gt;(x);
	if (x == theNan) x = NAN;
}

int x[8][7];
int m, d, w;
string s[] = { "日","一","二" ,"三" ,"四" ,"五" ,"六" };
bool valid(int i, int j)
{
	if (i &lt; 2 &amp;&amp; j == 6)return false;
	if (i == 7 &amp;&amp; j &lt; 4)return false;
	return true;
}
bool check()
{
	int k = 0;
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		if (!valid(i, j))continue;
		if (x[i][j] == 0) {
			if (k == 0) {
				if (i &gt; 1)
					return false;
				m = i * 6 + j + 1; // 1-12
			}
			else if (k == 1) {
				if (i &lt;= 1)
					return false;
				if (i * 7 + j &gt;= 45)
					return false;
				d = (i - 2) * 7 + j + 1; // 1-31
			}
			else {
				if (i * 7 + j &lt; 45)
					return false;
				w = (i - 6) * 3 + j - 3; // 0-6
			}
			k++;
		}
	}
}

int main()
{
	freopen("D:/p/date.txt", "r", stdin);
	string s1;
	map&lt;string, int&gt;sm;
	while (cin &gt;&gt; s1)sm[s1] = 1;
	freopen("CON", "r", stdin);
	while (true)
	{
		for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)Read(x[i][j]);
		for (int k = 1; k &lt; 10; k++)
		{
			int xmin = 10, ymin = 10, xmax = 0, ymax = 0;
			for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)
			{
				if (x[i][j] != k)continue;
				xmin = min(xmin, i);
				ymin = min(ymin, j);
				xmax = max(xmax, i);
				ymax = max(ymax, j);
			}
			if ((xmax - xmin + 1) * (ymax - ymin + 1) != 6)continue;
			bool flag = true;
			int n = 0;
			for (int i = xmin; i &lt;= xmax &amp;&amp; flag; i++)for (int j = ymin; j &lt;= ymax &amp;&amp; flag; j++)
			{
				if (x[i][j] == k)continue;
				if (x[i][j])flag = false;
				n++;
			}
			if (!flag || n &gt; 1)continue;
			if (!(x[xmin][ymin] &amp;&amp; x[xmin][ymax] &amp;&amp; x[xmax][ymin] &amp;&amp; x[xmax][ymax])) {
				for (int i = 0; i &lt; 4; i++) {
					int tmp = x[xmin][ymin];
					x[xmin][ymin] = x[xmin][ymax];
					x[xmin][ymax] = x[xmax][ymin];
					x[xmax][ymin] = x[xmax][ymax];
					x[xmax][ymax] = tmp;
					
					if (check()) {
						string ts = to_string(m) + "月" + to_string(d) + "日周" + s[w];
						if (sm[ts])continue;
						sm[ts] = 1;
						cout &lt;&lt; ts &lt;&lt; endl;
						for (int i = 0; i &lt; 8; i++) {
							for (int j = 0; j &lt; 7; j++) {
								cout &lt;&lt; setw(3) &lt;&lt; x[i][j];
							}
							cout &lt;&lt; endl;
						}
					}
				}
			}
			else {
				int tmp = x[(xmin + xmax) / 2][(ymin + ymax) / 2];
				x[(xmin + xmax) / 2][(ymin + ymax) / 2] = x[xmin + 1][ymin + 1], x[xmin + 1][ymin + 1] = tmp;
				if (check()) {
					string ts = to_string(m) + "月" + to_string(d) + "日周" + s[w];
					if (sm[ts])continue;
					sm[ts] = 1;
					cout &lt;&lt; ts &lt;&lt; endl;
					for (int i = 0; i &lt; 8; i++) {
						for (int j = 0; j &lt; 7; j++) {
							cout &lt;&lt; setw(3) &lt;&lt; x[i][j];
						}
						cout &lt;&lt; endl;
					}
				}
			}
		}
	}
	return 0;
}</code></pre> 
<h3 id="7%EF%BC%8CBUG%E4%BF%AE%E5%A4%8D%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V2%EF%BC%89">7，BUG修复</h3> 
<p>如果同时存在大拇指和U型新解，那么上面的代码只能产生一部分新解。</p> 
<p>由于这个代码已经运行一个月，目前一共已经得到400种不同的解法，所以解决方法最好还要能修复之前缺失的新解。</p> 
<p>所以我把控制台输入改成从文件输入，把历史所有解当做输入，清算有没有漏的。</p> 
<p>再修复一个BUG，之前的代码遗漏了数字为10的块也可以以解生解。</p> 
<p>代码略，参见下一节。</p> 
<h3 id="8%EF%BC%8C%E6%97%A5%E6%9C%9F%E4%BC%98%E5%8C%96%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V2%EF%BC%89">8，日期优化（完整代码V2）</h3> 
<p>记录日期的文件除了被程序读取使用外，还被我肉眼读，因为我经常手动以解生解，需要查看哪些日期还没有解。</p> 
<p>日期逐渐多了之后，不太好看了，所以我优化了数据结构，以“-1月1日”表示1月1日的从周一到周日的七个组合都有解了。</p> 
<p>代码只需要把读取日期记录文件的地方略改即可。</p> 
<p>完整代码：</p> 
<pre><code class="language-cpp">#include "data.h"

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;string&gt;
using namespace std;

#define OUT(x) cout &lt;&lt; endl &lt;&lt; #x &lt;&lt; " = "; Print(x);
template&lt;typename T&gt;
inline void Print(T x)
{
	cout &lt;&lt; x &lt;&lt; " ";
}
template&lt;typename T&gt;
inline void Read(T&amp; x)
{
	while (!(cin &gt;&gt; x)) { // only cin type T, ignore other info
		cin.clear();
		cin.ignore();
	}
}

const float theNan = 0.123456; //float默认只有6位
void Print(float x)
{
	if (std::isnan(x)) cout &lt;&lt; theNan &lt;&lt; " ";
	else cout &lt;&lt; x &lt;&lt; " ";
}
void Read(float&amp; x)
{
	Read&lt;float&gt;(x);
	if (x == theNan) x = NAN;
}

int x[8][7];
int m, d, w;
string s[] = { "日","一","二" ,"三" ,"四" ,"五" ,"六" };
bool valid(int i, int j)
{
	if (i &lt; 2 &amp;&amp; j == 6)return false;
	if (i == 7 &amp;&amp; j &lt; 4)return false;
	return true;
}
bool check()
{
	int k = 0;
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		if (!valid(i, j))continue;
		if (x[i][j] == 0) {
			if (k == 0) {
				if (i &gt; 1)
					return false;
				m = i * 6 + j + 1; // 1-12
			}
			else if (k == 1) {
				if (i &lt;= 1)
					return false;
				if (i * 7 + j &gt;= 45)
					return false;
				d = (i - 2) * 7 + j + 1; // 1-31
			}
			else {
				if (i * 7 + j &lt; 45)
					return false;
				w = (i - 6) * 3 + j - 3; // 0-6
			}
			k++;
		}
	}
	if (m == 2 &amp;&amp; d &gt; 29)return false;
	if ((m == 4 || m == 6 || m == 9 || m == 11) &amp;&amp; d &gt; 30)return false;
	return true;
}

void go()
{
	freopen("D:/p/date.txt", "r", stdin);
	string s1;
	map&lt;string, int&gt;sm;
	while (cin &gt;&gt; s1) {
		sm[s1] = 1;
		if (s1[0] == '-') {
			s1 = s1.substr(1, s1.length() - 1);
			for (int i = 0; i &lt; 7; i++)sm[s1 + "周" + s[i]] = 1;
		}
	}
	freopen("D:/p/ans.txt", "r", stdin);
	while (true)
	{
		int a, b;
		Read(a); Read(b);
		for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)Read(x[i][j]);
		for (int k = 1; k &lt;= 10; k++)
		{
			int xmin = 10, ymin = 10, xmax = 0, ymax = 0;
			for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)
			{
				if (x[i][j] != k)continue;
				xmin = min(xmin, i);
				ymin = min(ymin, j);
				xmax = max(xmax, i);
				ymax = max(ymax, j);
			}
			if ((xmax - xmin + 1) * (ymax - ymin + 1) != 6)continue;
			bool flag = true;
			int n = 0;
			for (int i = xmin; i &lt;= xmax &amp;&amp; flag; i++)for (int j = ymin; j &lt;= ymax &amp;&amp; flag; j++)
			{
				if (x[i][j] == k)continue;
				if (x[i][j])flag = false;
				n++;
			}
			if (!flag || n &gt; 1)continue;
			if (!(x[xmin][ymin] &amp;&amp; x[xmin][ymax] &amp;&amp; x[xmax][ymin] &amp;&amp; x[xmax][ymax])) {
				for (int i = 0; i &lt; 4; i++) {
					int tmp = x[xmin][ymin];
					x[xmin][ymin] = x[xmin][ymax];
					x[xmin][ymax] = x[xmax][ymin];
					x[xmax][ymin] = x[xmax][ymax];
					x[xmax][ymax] = tmp;
					if (check()) {
						string ts = to_string(m) + "月" + to_string(d) + "日周" + s[w];
						if (sm[ts])continue;
						sm[ts] = 1;
						cout &lt;&lt; ts &lt;&lt; endl;
						for (int i = 0; i &lt; 8; i++) {
							for (int j = 0; j &lt; 7; j++) {
								cout &lt;&lt; setw(3) &lt;&lt; x[i][j];
							}
							cout &lt;&lt; endl;
						}
					}
				}
			}
			else {
				int tmp = x[(xmin + xmax) / 2][(ymin + ymax) / 2];
				x[(xmin + xmax) / 2][(ymin + ymax) / 2] = x[xmin + 1][ymin + 1], x[xmin + 1][ymin + 1] = tmp;
				if (check()) {
					string ts = to_string(m) + "月" + to_string(d) + "日周" + s[w];
					if (sm[ts])continue;
					sm[ts] = 1;
					cout &lt;&lt; ts &lt;&lt; endl;
					for (int i = 0; i &lt; 8; i++) {
						for (int j = 0; j &lt; 7; j++) {
							cout &lt;&lt; setw(3) &lt;&lt; x[i][j];
						}
						cout &lt;&lt; endl;
					}
				}
			}
		}
	}
}

int main()
{
	go();
	return 0;
}</code></pre> 
<h3 id="9%EF%BC%8CBUG%E4%BF%AE%E5%A4%8D%E3%80%81%E6%96%B0%E5%A2%9E%E6%A3%80%E6%9F%A5%EF%BC%88%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81V3%EF%BC%89">9，BUG修复、新增检查（完整代码V3）</h3> 
<p>经过了前面的BUG修复之后，仍然存在以解生解不全的问题。</p> 
<p>所以我又把2种以解生解的模式做了拆分，<span style="color:#fe2c24;"><strong>先做U型再做大拇指，分开成2次编译运行，先只调用go后只调用go1</strong></span>，这样才能确保生成所有的解。</p> 
<p>然后新增了go2和go3，需要检查的时候调用即可。</p> 
<p>完整代码：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

#define OUT(x) cout &lt;&lt; endl &lt;&lt; #x &lt;&lt; " = "; Print(x);
template&lt;typename T&gt;
inline void Print(T x)
{
	cout &lt;&lt; x &lt;&lt; " ";
}
template&lt;typename T&gt;
inline void Read(T&amp; x)
{
	while (!(cin &gt;&gt; x)) { // only cin type T, ignore other info
		cin.clear();
		cin.ignore();
	}
}

const float theNan = 0.123456; //float默认只有6位
void Print(float x)
{
	if (std::isnan(x)) cout &lt;&lt; theNan &lt;&lt; " ";
	else cout &lt;&lt; x &lt;&lt; " ";
}
void Read(float&amp; x)
{
	Read&lt;float&gt;(x);
	if (x == theNan) x = NAN;
}
template&lt;typename T1, typename T2&gt;
inline void Print(const std::pair&lt;T1, T2&gt;&amp; p)
{
	Print(p.first);
	Print(p.second);
}
template&lt;typename T1, typename T2&gt;
inline void Print(const map&lt;T1, T2&gt;&amp; aMap)
{
	cout &lt;&lt; " size = " &lt;&lt; aMap.size() &lt;&lt; endl;
	for (auto&amp; it : aMap) {
		Print(it);
		cout &lt;&lt; endl;
	}
}
template&lt;typename T&gt;
inline void Print(const vector&lt;T&gt;&amp; vec)
{
	cout &lt;&lt; " size = " &lt;&lt; vec.size() &lt;&lt; endl;
	for (auto&amp; it : vec) {
		Print(it);
	}
}
template&lt;typename T1, typename T2&gt;
inline void Read(std::pair&lt;T1, T2&gt;&amp; p)
{
	Read(p.first);
	Read(p.second);
}
template&lt;typename Tkey, typename Tvalue&gt;
void Read(std::map&lt;Tkey, Tvalue&gt;&amp; aMap)
{
	int num;
	Read(num);
	std::pair&lt;Tkey, Tvalue&gt; p;
	while (num--) {
		Read(p);
		aMap[p.first] = p.second;
	}
}
template&lt;typename T&gt;
inline void Read(vector&lt;T&gt;&amp; vec)
{
	int num;
	Read(num);
	vec.resize(num); // 慎用
	for (int i = 0; i &lt; num; i++) {
		Read(vec[i]);
	}
}

int x[8][7];
int m, d, w;
string s[] = { "日","一","二" ,"三" ,"四" ,"五" ,"六" };
bool valid(int i, int j)
{
	if (i &lt; 2 &amp;&amp; j == 6)return false;
	if (i == 7 &amp;&amp; j &lt; 4)return false;
	return true;
}
bool check()
{
	int k = 0;
	for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++) {
		if (!valid(i, j))continue;
		if (x[i][j] == 0) {
			if (k == 0) {
				if (i &gt; 1)
					return false;
				m = i * 6 + j + 1; // 1-12
			}
			else if (k == 1) {
				if (i &lt;= 1)
					return false;
				if (i * 7 + j &gt;= 45)
					return false;
				d = (i - 2) * 7 + j + 1; // 1-31
			}
			else {
				if (i * 7 + j &lt; 45)
					return false;
				w = (i - 6) * 3 + j - 3; // 0-6
			}
			k++;
		}
	}
	if (m == 2 &amp;&amp; d &gt; 29)return false;
	if ((m == 4 || m == 6 || m == 9 || m == 11) &amp;&amp; d &gt; 30)return false;
	return true;
}

void go() //以解生解
{
	freopen("D:/p/date.txt", "r", stdin);
	string s1;
	map&lt;string, int&gt;sm;
	while (cin &gt;&gt; s1) {
		sm[s1] = 1;
		if (s1[0] == '-') {
			s1 = s1.substr(1, s1.length() - 1);
			for (int i = 0; i &lt; 7; i++)sm[s1 + "周" + s[i]] = 1;
		}
	}
	freopen("D:/p/ans.txt", "r", stdin);
	while (true)
	{
		int a, b;
		Read(a); Read(b);
		for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)Read(x[i][j]);
		for (int k = 1; k &lt;= 10; k++)
		{
			int xmin = 10, ymin = 10, xmax = 0, ymax = 0;
			for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)
			{
				if (x[i][j] != k)continue;
				xmin = min(xmin, i);
				ymin = min(ymin, j);
				xmax = max(xmax, i);
				ymax = max(ymax, j);
			}
			if ((xmax - xmin + 1) * (ymax - ymin + 1) != 6)continue;
			bool flag = true;
			int n = 0;
			for (int i = xmin; i &lt;= xmax &amp;&amp; flag; i++)for (int j = ymin; j &lt;= ymax &amp;&amp; flag; j++)
			{
				if (x[i][j] == k)continue;
				if (x[i][j])flag = false;
				n++;
			}
			if (!flag || n &gt; 1)continue;
			if (x[xmin][ymin] &amp;&amp; x[xmin][ymax] &amp;&amp; x[xmax][ymin] &amp;&amp; x[xmax][ymax]) // U型
			{ 
				int tmp = x[(xmin + xmax) / 2][(ymin + ymax) / 2];
				x[(xmin + xmax) / 2][(ymin + ymax) / 2] = x[xmin + 1][ymin + 1], x[xmin + 1][ymin + 1] = tmp;
				if (check()) {
					string ts = to_string(m) + "月" + to_string(d) + "日周" + s[w];
					if (sm[ts])continue;
					sm[ts] = 1;
					cout &lt;&lt; ts &lt;&lt; endl;
					for (int i = 0; i &lt; 8; i++) {
						for (int j = 0; j &lt; 7; j++) {
							cout &lt;&lt; setw(3) &lt;&lt; x[i][j];
						}
						cout &lt;&lt; endl;
					}
				}
			}
		}
	}
}
void go1() //以解生解
{
	freopen("D:/p/date.txt", "r", stdin);
	string s1;
	map&lt;string, int&gt;sm;
	while (cin &gt;&gt; s1) {
		sm[s1] = 1;
		if (s1[0] == '-') {
			s1 = s1.substr(1, s1.length() - 1);
			for (int i = 0; i &lt; 7; i++)sm[s1 + "周" + s[i]] = 1;
		}
	}
	freopen("D:/p/ans.txt", "r", stdin);
	while (true)
	{
		int a, b;
		Read(a); Read(b);
		for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)Read(x[i][j]);
		for (int k = 1; k &lt;= 10; k++)
		{
			int xmin = 10, ymin = 10, xmax = 0, ymax = 0;
			for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)
			{
				if (x[i][j] != k)continue;
				xmin = min(xmin, i);
				ymin = min(ymin, j);
				xmax = max(xmax, i);
				ymax = max(ymax, j);
			}
			if ((xmax - xmin + 1) * (ymax - ymin + 1) != 6)continue;
			bool flag = true;
			int n = 0;
			for (int i = xmin; i &lt;= xmax &amp;&amp; flag; i++)for (int j = ymin; j &lt;= ymax &amp;&amp; flag; j++)
			{
				if (x[i][j] == k)continue;
				if (x[i][j])flag = false;
				n++;
			}
			if (!flag || n &gt; 1)continue;
			if (!(x[xmin][ymin] &amp;&amp; x[xmin][ymax] &amp;&amp; x[xmax][ymin] &amp;&amp; x[xmax][ymax])) //大拇指
			{
				for (int i = 0; i &lt; 4; i++) {
					int tmp = x[xmin][ymin];
					x[xmin][ymin] = x[xmin][ymax];
					x[xmin][ymax] = x[xmax][ymin];
					x[xmax][ymin] = x[xmax][ymax];
					x[xmax][ymax] = tmp;
					if (check()) {
						string ts = to_string(m) + "月" + to_string(d) + "日周" + s[w];
						if (sm[ts])continue;
						sm[ts] = 1;
						cout &lt;&lt; ts &lt;&lt; endl;
						for (int i = 0; i &lt; 8; i++) {
							for (int j = 0; j &lt; 7; j++) {
								cout &lt;&lt; setw(3) &lt;&lt; x[i][j];
							}
							cout &lt;&lt; endl;
						}
					}
				}
			}
		}
	}
}

void go2()//检查日期记录有没有漏的
{
	string s1;
	map&lt;string, int&gt;sm;
	freopen("D:/p/date.txt", "r", stdin);
	while (cin &gt;&gt; s1) {
		sm[s1] = 1;
		if (s1[0] == '-') {
			s1 = s1.substr(1, s1.length() - 1);
			for (int i = 0; i &lt; 7; i++)sm[s1 + "周" + s[i]] = 1;
		}
	}
	cin.clear();
	freopen("CON", "r", stdin);
	freopen("D/p/out.txt", "w", stdout);
	while (cin &gt;&gt; s1)
	{
		for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)Read(x[i][j]);
		if (sm[s1] == 0)cout &lt;&lt; s1 &lt;&lt; endl;
	}
}
void go3()//检查有没有重复日期的解
{
	string s1;
	map&lt;string, int&gt;sm;
	freopen("D/p/out.txt", "w", stdout);
	while (cin &gt;&gt; s1)
	{
		for (int i = 0; i &lt; 8; i++)for (int j = 0; j &lt; 7; j++)Read(x[i][j]);
		if (sm[s1] == 1)cout &lt;&lt; s1 &lt;&lt; endl;
		sm[s1] = 1;
	}
}



int main()
{
    //go();
	go1();
	return 0;
}</code></pre> 
<h2 id="%E4%B8%83%EF%BC%8C%E5%85%A8%E6%96%87%E8%AF%B4%E6%98%8E">七，说明</h2> 
<p><span style="color:#956fe7;">1，每天可以在本文搜索一下，如果已经有解了就不用再拼了。否则，新拼出一个解时，把照片放到本地，等每隔一段时间再统一数字化。</span></p> 
<p><span style="color:#956fe7;">2，数字化时，通过批量命名把所有图片改成img*.jpg，然后运行第五章第9节的完整代码，把图片转化成数字。</span></p> 
<p><span style="color:#956fe7;">3，把数字化的结果更新到（本地）结果汇总中，把其中的日期，更新到（本地）日期汇总中。</span></p> 
<p><span style="color:#956fe7;">4，运行第六章第7节的完整代码V2，产生新解，跳到第3步，循环，直到再也没有新解。</span></p> 
<p>5，如果想查看一个数字化的解，可以运行上面第六章第2节的代码，也可以运行下面的可视化V2版。</p> 
<h2 id="%E5%85%AB%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3">八，直接求解</h2> 
<h3 id="1%EF%BC%8C%E5%8F%AF%E8%A7%86%E5%8C%96V2%E7%89%88">1，可视化V2版</h3> 
<p>对显示答案做了微调，把月日周对应的3个格子用真实的内容显示出来。</p> 
<pre><code class="language-cpp">int x[8][7];

void show()
{
	int pix = 50;
	Mat img = imread("D:/base.jpg",0);
	resize(img, img, Size(pix * 7, pix * 8), 0, 0);
	for (int i = 0; i &lt; 8; i++) {
		for (int j = 0; j &lt; 7; j++) {
			if(x[i][j])for (int r = pix * i; r &lt; pix * (i + 1); r++) {
				for (int c = pix * j; c &lt; pix * (j + 1); c++) {
					img.at&lt;uchar&gt;(r, c) = 25 * x[i][j];
				}
			}
		}
		cout &lt;&lt; endl;
	}
	static int kid = 0;
	imshow("ans" + to_string(kid++), img);
}</code></pre> 
<p>其中D:/base.jpg就是没有块的图：</p> 
<p><img alt="" height="531" src="https://images2.imgbox.com/fc/39/bEt5CeuD_o.jpg" width="468"></p> 
<p>运行效果：</p> 
<p><img alt="" height="511" src="https://images2.imgbox.com/86/bb/Le6prWVW_o.png" width="415"></p> 
<p></p> 
<h3 id="2%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3">2，直接求解</h3> 
<p>利用<a class="link-info" href="" rel="nofollow" title="拼接覆盖问题">拼接覆盖问题</a>通用求解代码，直接把12*31*7的所有组合全部求出来。</p> 
<pre><code class="language-cpp">int r,c,blockNum; //自定义行列数,块数
map&lt;Grid, int&gt; ng,mg;  //ng是自定义挖掉的格子，mg是有效格子
vector&lt;Block&gt;blocks;//自定义每个块的所有形态在最小位置包含的格子

vector&lt;Grid&gt; rotate(vector&lt;Grid&gt;&amp; g)
{
	int maxRow = 0, t;
	for (auto&amp; gi : g)maxRow = max(maxRow, gi.r);
	for (auto&amp; gi : g)t = gi.c, gi.c = maxRow - gi.r, gi.r = t;
	return g;
}
vector&lt;Grid&gt; reverse(vector&lt;Grid&gt; &amp;g)
{
	for (auto&amp; gi : g)gi.r ^= gi.c ^= gi.r ^= gi.c;
	return g;
}

void init1(int m,int d,int w)
{
	r = 8, c = 7, blockNum = 10;
	ng.clear(), mg.clear();
	ng[Grid{ 0,6 }] = ng[Grid{ 1,6 }] = ng[Grid{ 7,0 }] = ng[Grid{ 7,1 }] = ng[Grid{ 7,2 }] = ng[Grid{ 7,3 }] = 1;
	m--, d--, w %= 7;
	ng[Grid{ m / 6,m % 6 }] = ng[Grid{ d / 7 + 2,d % 7 }] = 1;
	ng[Grid{ w / 4 + 6,w % 4 + 3 + (w &gt; 3) }] = 1;
}
void init2()
{
	vector&lt;Grid&gt;v = { {0,0},{0,1},{1,1},{1,2},{1,3} };
	blocks[0] = Block{ { v,rotate(v),rotate(v),rotate(v), reverse(v),rotate(v),rotate(v),rotate(v)}, r, c, mg };
	v = { {0,0},{0,1},{0,2},{1,0},{1,1} };
	blocks[1] = Block{ { v,rotate(v),rotate(v),rotate(v), reverse(v),rotate(v),rotate(v),rotate(v)}, r, c, mg };
	v = { {0,0},{0,1},{0,2},{1,0} };
	blocks[2] = Block{ { v,rotate(v),rotate(v),rotate(v), reverse(v),rotate(v),rotate(v),rotate(v)}, r, c, mg };
	v = { {0,0},{0,1},{0,2},{0,3}, {1,0} };
	blocks[3] = Block{ { v,rotate(v),rotate(v),rotate(v), reverse(v),rotate(v),rotate(v),rotate(v)}, r, c, mg };
	v = { {0,0},{0,1},{0,2},{1,0},{2,0} };
	blocks[4] = Block{ {v,rotate(v),rotate(v),rotate(v)},r,c, mg };
	v = { {0,0},{0,1},{0,2},{1,1},{2,1} };
	blocks[5] = Block{ {v,rotate(v),rotate(v),rotate(v)},r,c, mg };
	v = { {0,0},{0,1},{0,2},{0,3} };
	blocks[6] = Block{ {v,rotate(v)},r,c, mg };
	v = { {0,0},{0,1},{1,1},{1,2} };
	blocks[7] = Block{ { v,rotate(v), reverse(v),rotate(v)}, r, c, mg };
	v = { {0,0},{0,1},{0,2},{1,0} ,{1,2} };
	blocks[8] = Block{ {v,rotate(v),rotate(v),rotate(v)},r,c, mg };
	v = { {0,0},{0,1},{1,1},{2,1},{2,2} };
	blocks[9] = Block{ {v,rotate(v),reverse(v),rotate(v)},r,c, mg };
}

void solve(int m, int d, int w)
{
	init1(m, d, w);
	int id = 0;
	for (int i = 0; i &lt; r; i++)for (int j = 0; j &lt; c; j++) {
		if (ng[Grid{ i, j }] == 0)mg[Grid{ i, j }] = ++id;
	}
	blocks.resize(blockNum);
	init2();
	vector&lt;vector&lt;Grid&gt;&gt; grids = Cover(blocks, mg);
	vector&lt;vector&lt;int&gt;&gt;v(r);
	for (int i = 0; i &lt; r; i++)v[i].resize(c);
	for (int i = 0; i &lt; grids.size(); i++) {
		for (auto&amp; g : grids[i])v[g.r][g.c] = i + 1;
	}
	for (int i = 0; i &lt; r; i++) {
		for (int j = 0; j &lt; v[i].size(); j++)cout &lt;&lt; v[i][j] &lt;&lt; " ";
		cout &lt;&lt; endl;
	}
}

int main()
{
	ios::sync_with_stdio(false);
	clock_t start, endd;
	start = clock();
	freopen("D:ans.txt", "w", stdout);
	for (int m = 1; m &lt;= 12; m++)for (int d = 1; d &lt;= 31; d++)for (int w = 1; w &lt;= 7; w++) {
		solve(m, d, w);
		cout &lt;&lt; endl;
	}
	endd = clock();
	double endtime = (double)(endd - start) / CLOCKS_PER_SEC;
	cout &lt;&lt; "Total time:" &lt;&lt; endtime &lt;&lt; endl; //s为单位
	return 0;
}</code></pre> 
<p>输出：</p> 
<p>0 3 3 3 9 9 0 <br> 2 2 3 8 9 9 0 <br> 0 2 3 8 8 9 10 <br> 5 2 2 7 8 10 10 <br> 5 7 7 7 8 10 4 <br> 5 5 5 6 1 1 4 <br> 6 6 6 6 0 1 4 <br> 0 0 0 0 1 1 4 </p> 
<p>0 3 3 4 4 4 0 <br> 2 2 3 3 4 6 0 <br> 0 2 5 5 4 6 7 <br> 8 2 2 5 10 6 7 <br> 8 8 9 5 10 6 7 <br> 8 8 9 10 10 7 7 <br> 9 9 9 10 1 0 1 <br> 0 0 0 0 1 1 1 </p> 
<p>0 5 5 5 6 6 0 <br> 4 4 5 9 10 6 0 <br> 0 4 5 9 10 6 3 <br> 4 4 8 9 10 10 3 <br> 7 8 8 9 9 10 3 <br> 7 8 8 2 1 1 3 <br> 7 7 7 2 2 1 0 <br> 0 0 0 0 2 1 1 </p> 
<p>0 2 2 3 3 3 0 <br> 1 1 2 2 3 8 0 <br> 0 1 5 5 3 8 8 <br> 4 1 1 5 10 8 8 <br> 4 6 5 5 10 10 7 <br> 4 6 9 9 9 10 7 <br> 4 6 6 6 9 10 7 <br> 0 0 0 0 0 7 7 </p> 
<p>0 3 3 4 4 4 0 <br> 2 2 3 3 4 6 0 <br> 0 2 5 5 4 6 8 <br> 7 2 2 5 10 6 8 <br> 7 7 9 5 10 6 8 <br> 7 7 9 10 10 8 8 <br> 9 9 9 10 1 1 1 <br> 0 0 0 0 1 0 1 </p> 
<p>0 2 2 3 3 3 0 <br> 1 1 2 2 3 8 0 <br> 0 1 5 5 3 8 10 <br> 4 1 1 5 8 8 10 <br> 4 6 5 5 9 9 10 <br> 4 6 9 9 9 10 10 <br> 4 6 6 6 7 7 7 <br> 0 0 0 0 7 7 0 </p> 
<p>0 2 2 3 3 3 0 <br> 1 1 2 2 3 9 0 <br> 0 1 6 6 3 9 9 <br> 4 1 1 6 7 9 9 <br> 4 5 5 6 7 10 8 <br> 4 5 7 7 7 10 8 <br> 4 5 5 0 10 10 8 <br> 0 0 0 0 10 8 8 </p> 
<p>0 2 2 10 10 10 0 <br> 2 2 8 8 8 10 0 <br> 3 0 8 9 9 10 7 <br> 3 9 9 9 7 7 7 <br> 3 5 6 6 7 4 4 <br> 3 5 6 6 1 1 4 <br> 5 5 5 6 0 1 4 <br> 0 0 0 0 1 1 4 </p> 
<p>0 2 2 5 5 5 0 <br> 2 2 5 5 10 7 0 <br> 3 0 10 10 10 7 9 <br> 3 3 3 8 10 7 9 <br> 4 4 3 8 7 7 9 <br> 4 6 6 8 8 8 9 <br> 4 6 6 6 1 0 1 <br> 0 0 0 0 1 1 1 </p> 
<p>0 4 4 4 6 6 0 <br> 5 5 4 9 10 6 0 <br> 5 0 4 9 10 6 3 <br> 5 5 8 9 10 10 3 <br> 7 8 8 9 9 10 3 <br> 7 8 8 2 1 1 3 <br> 7 7 7 2 2 1 0 <br> 0 0 0 0 2 1 1 </p> 
<p>0 3 3 4 4 6 0 <br> 2 2 3 3 4 6 0 <br> 2 0 9 8 4 6 6 <br> 2 2 9 8 8 8 6 <br> 10 10 9 8 5 5 5 <br> 10 10 9 9 1 1 5 <br> 10 7 7 7 7 1 5 <br> 0 0 0 0 0 1 1 </p> 
<p>0 2 2 5 5 5 0 <br> 2 2 5 5 10 7 0 <br> 3 0 10 10 10 7 9 <br> 3 3 3 8 10 7 9 <br> 4 4 3 8 7 7 9 <br> 4 6 6 8 8 8 9 <br> 4 6 6 6 1 1 1 <br> 0 0 0 0 1 0 1 </p> 
<p>0 3 3 3 3 8 0 <br> 1 1 8 8 8 8 0 <br> 1 0 10 10 9 9 9 <br> 1 1 4 10 10 10 9 <br> 4 4 4 6 6 6 9 <br> 4 2 2 6 5 7 7 <br> 2 2 5 5 5 7 7 <br> 0 0 0 0 5 7 0 </p> 
<p>0 3 3 5 5 5 0 <br> 1 1 3 5 9 10 0 <br> 1 0 3 3 9 10 10 <br> 1 1 4 6 9 10 10 <br> 2 4 4 6 9 7 8 <br> 2 4 6 6 6 7 8 <br> 2 2 2 0 7 7 8 <br> 0 0 0 0 7 8 8 </p> 
<p>......省略2千多个解</p> 
<p>4 2 2 2 1 1 0 <br> 4 2 5 2 1 0 0 <br> 4 4 5 1 1 6 3 <br> 9 4 5 5 5 6 3 <br> 9 9 9 8 8 6 3 <br> 9 10 10 8 6 6 3 <br> 10 10 0 8 7 7 7 <br> 0 0 0 0 7 7 0 </p> 
<p>4 2 2 2 1 1 0 <br> 4 2 7 2 1 0 0 <br> 4 7 7 1 1 5 3 <br> 4 7 5 5 5 5 3 <br> 10 7 9 9 3 3 3 <br> 10 9 9 8 8 8 6 <br> 10 10 0 0 8 6 6 <br> 0 0 0 0 8 6 6 </p> 
<p>Total time:12.741<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/45d93521f37b1c5616c1e3972ad1e5f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数字信号处理----绪论</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/20f57857d3bb18deed1c8cfeb2384db7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python：给你们安排一波VIP音乐，看我是如何不充会员也能下载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>