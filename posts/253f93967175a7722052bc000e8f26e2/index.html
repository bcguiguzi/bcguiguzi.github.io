<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Solidity Uniswap V2 Router contract addLiquidity - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Solidity Uniswap V2 Router contract addLiquidity" />
<meta property="og:description" content="router 合约是一种高级合约，是大多数用户应用程序的入口点。通过该合约，可以更轻松地创建交易对、添加和删除流动性、计算交换中的价格变化以及执行交换。Router 适用于通过工厂合约部署的所有交易对，是一种通用合约。
GitHub - XuHugo/solidityproject: DApp go go go ！！！
它也是一个非常大的合约，我们可能不会实现它的所有功能，因为其中大部分都是交换功能的变形。让我们看看路由器的构造函数：路由器可以部署pair，因此它需要知道工厂合约的地址。
contract ZuniswapV2Router { error InsufficientAAmount(); error InsufficientBAmount(); error SafeTransferFailed(); IZuniswapV2Factory factory; constructor(address factoryAddress) { factory = IZuniswapV2Factory(factoryAddress); } ... 今天，我们只实现流动性管理的一部分，让我们从 addLiquidity 开始：
function addLiquidity( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to ) public returns ( uint256 amountA, uint256 amountB, uint256 liquidity ) ... 与pair合约中的mint函数相比，该函数有很多参数！
1、tokenA 和 tokenB 用于查找（或创建）我们希望增加流动性的货币对。
2、amountADesired 和 amountBDesired 是我们希望存入货币对的金额。这些是上限。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/253f93967175a7722052bc000e8f26e2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T10:27:31+08:00" />
<meta property="article:modified_time" content="2024-03-14T10:27:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Solidity Uniswap V2 Router contract addLiquidity</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;">        router 合约是一种高级合约，是大多数用户应用程序的入口点。通过该合约，可以更轻松地创建交易对、添加和删除流动性、计算交换中的价格变化以及执行交换。Router 适用于通过工厂合约部署的所有交易对，是一种通用合约。</p> 
<p style="margin-left:0;"><a href="https://github.com/XuHugo/solidityproject/" title="GitHub - XuHugo/solidityproject: DApp go go go ！！！">GitHub - XuHugo/solidityproject: DApp go go go ！！！</a></p> 
<p style="margin-left:0;">        它也是一个非常大的合约，我们可能不会实现它的所有功能，因为其中大部分都是交换功能的变形。让我们看看路由器的构造函数：路由器可以部署pair，因此它需要知道工厂合约的地址。</p> 
<pre><code class="hljs">contract ZuniswapV2Router {

    error InsufficientAAmount();

    error InsufficientBAmount();

    error SafeTransferFailed();



    IZuniswapV2Factory factory;



    constructor(address factoryAddress) {

        factory = IZuniswapV2Factory(factoryAddress);

    }

    ...</code></pre> 
<p style="margin-left:0;">        今天，我们只实现流动性管理的一部分，让我们从 addLiquidity 开始：</p> 
<pre><code class="hljs">function addLiquidity(

    address tokenA,

    address tokenB,

    uint256 amountADesired,

    uint256 amountBDesired,

    uint256 amountAMin,

    uint256 amountBMin,

    address to

)

    public

    returns (

        uint256 amountA,

        uint256 amountB,

        uint256 liquidity

    )

    ...</code></pre> 
<p style="margin-left:0;">        与pair合约中的mint函数相比，该函数有很多参数！</p> 
<p style="margin-left:0;">        1、tokenA 和 tokenB 用于查找（或创建）我们希望增加流动性的货币对。</p> 
<p style="margin-left:0;">        2、amountADesired 和 amountBDesired 是我们希望存入货币对的金额。这些是上限。</p> 
<p style="margin-left:0;">        3、amountAMin 和 amountBMin 是我们希望存入的最小金额。还记得当我们存入不平衡的流动性时，pair合约总是发行较少的 LP-Token吗？。因此，最小参数允许我们控制准备损失多少流动性。</p> 
<p style="margin-left:0;">        4、to 地址是接收 LP-Token的地址。</p> 
<pre><code class="hljs">...

if (factory.pairs(tokenA, tokenB) == address(0)) {

    factory.createPair(tokenA, tokenB);

}

...</code></pre> 
<p style="margin-left:0;">        如果指定的ERC20 Token没有pair合约，它将由router 合约创建。 factory.pairs方法是pairs映射，由于映射是嵌套的，Solidity 为该辅助方法设置了两个参数。</p> 
<pre><code class="hljs">...

(amountA, amountB) = _calculateLiquidity(

    tokenA,

    tokenB,

    amountADesired,

    amountBDesired,

    amountAMin,

    amountBMin

);

...</code></pre> 
<p style="margin-left:0;">        下一步，我们将计算将存入的金额。稍后我们将回到这个函数。</p> 
<pre><code class="hljs">...

address pairAddress = ZuniswapV2Library.pairFor(

    address(factory),

    tokenA,

    tokenB

);

_safeTransferFrom(tokenA, msg.sender, pairAddress, amountA);

_safeTransferFrom(tokenB, msg.sender, pairAddress, amountB);

liquidity = IZuniswapV2Pair(pairAddress).mint(to);

...</code></pre> 
<p style="margin-left:0;">        计算完流动性金额后，我们就可以从用户处转移token，并铸造 LP-token作为交换。除了 pairFor 函数之外，这些代码中的大部分你都应该很熟悉了，我们将在实现 _calculateLiquidity 之后立即实现它。此外，请注意该合约并不希望用户手动转移代币，而是使用 ERC20 transferFrom 函数从用户余额中转移代币。</p> 
<pre><code class="hljs">function _calculateLiquidity(

    address tokenA,

    address tokenB,

    uint256 amountADesired,

    uint256 amountBDesired,

    uint256 amountAMin,

    uint256 amountBMin

) internal returns (uint256 amountA, uint256 amountB) {

    (uint256 reserveA, uint256 reserveB) = ZuniswapV2Library.getReserves(

        address(factory),

        tokenA,

        tokenB

    );



    ...</code></pre> 
<p style="margin-left:0;">        在这个函数中，我们要找到满足我们所需和最低金额的流动性金额。由于从我们在用户界面选择流动性金额到我们的交易被处理之间存在延迟，实际reserve比率可能会发生变化，这将导致我们损失一些 LP-token（作为对存入不平衡流动性的惩罚）。通过选择所需的最小金额，我们可以最大限度地减少这种损失。</p> 
<p style="margin-left:0;">        该功能的第一步是通过使用库合约获取池储备，我们下次就会实现这一点。得到了reserve，我们就可以计算出最佳流动性金额</p> 
<pre><code class="hljs">...

if (reserveA == 0 &amp;&amp; reserveB == 0) {

    (amountA, amountB) = (amountADesired, amountBDesired);

...</code></pre> 
<p style="margin-left:0;">        如果储备金是空的，那么这是一对新的货币对，这意味着我们的流动性将决定储备金比率，这意味着我们不会因为提供不平衡的流动性而受到惩罚。因此，我们可以存入所需的全额资金。</p> 
<pre><code class="hljs">...

} else {

    uint256 amountBOptimal = ZuniswapV2Library.quote(

        amountADesired,

        reserveA,

        reserveB

    );

    if (amountBOptimal &lt;= amountBDesired) {

        if (amountBOptimal &lt;= amountBMin) revert InsufficientBAmount();

        (amountA, amountB) = (amountADesired, amountBOptimal);

...</code></pre> 
<p style="margin-left:0;">        否则，我们需要找到最优数量，我们从找到最优tokenB数量开始。报价是库合约中的另一个函数：通过输入金额和配对储备金，计算输出金额，即tokenA 的价格乘以token B 的输入金额。</p> 
<p style="margin-left:0;">        如果amountBOptimal 小于或等于我们的期望金额，并且高于我们的最小金额，则使用该金额。期望金额和最小金额之间的差额可以防止滑点。</p> 
<p style="margin-left:0;">        但是，如果最优金额BOptimal 大于我们的期望金额，则不能使用，我们需要找到另一个最优金额 A。</p> 
<pre><code class="hljs">...

} else {

    uint256 amountAOptimal = ZuniswapV2Library.quote(

        amountBDesired,

        reserveB,

        reserveA

    );

    assert(amountAOptimal &lt;= amountADesired);



    if (amountAOptimal &lt;= amountAMin) revert InsufficientAAmount();

    (amountA, amountB) = (amountAOptimal, amountBDesired);

}</code></pre> 
<p style="margin-left:0;">        使用相同的逻辑，我们可以找到 amountAOptimal：它也必须在我们的最小期望范围内。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/be05690e327c65815903fab4e829ad38/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Lucene查询语法，适用于 ELk Kibana 查询</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/884af25901715a2c4ffbeec9d9b7d7b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pip安装报错：ERROR: Could not build wheels for psutil</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>