<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Winform和ASP.NET、Web API详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Winform和ASP.NET、Web API详解" />
<meta property="og:description" content="Winform和ASP.NET、Web API 一、winform基础 1.1 基础学习 1、 winform应用程序是一种智能客户端技术，我们可以使用winform应用程序帮助我们获得信息或者传输信息等。
2、属性
Name:在后台要获得前台的控件对象，需要使用Name属性。
visible:指示一个控件是否可见。
Enabled:指示一个控件是否可用。
3、
事件:发生一件事情。
注册事件:双击控件注册的都是控件默认被选中的那个事件。
触发事件:
4、
在Main函数当中创建的窗体对象，我们称之为这个窗体应用程序的主窗体。
也就意味着，当你将主窗体关闭后，整个应用程序都关闭了。
5、TextBox控件
Wordwrap:指示文本框是否换行。
Passwordchar:让文本框显示一个单一的字符
scollBars:是否显示滚动条
事件:Textchanged当文本框中的内容发生改变的时候触发这个事件。
6、跑马灯练习
abcde
bcdea
cdeab
private void timer1_Tick(object sender, EventArgs e) { //abcde label1.Text = label1.Text.Substring(1) &#43; label1.Text.Substring(0, 1); } 7、Timer
在指定的时间间隔内做一件指定的事情
8、单选和多选
RadioButton
CheckBox
默认情况下，在一个窗体中，所有的单选按钮只允许选中一个，可以使用groupbox进行分组
9、MDI窗体的设计：MDI(Multiple Document Interface)多文档界面，与此对应就有单文档界面 (SDI)
首先确定一个父窗体，将IsMdiContainer设置为true创建子窗体，并且设置他们的父窗体 private void 显示子窗体ToolStripMenuItem_Click(object sender, EventArgs e) { //显示子窗体 Form2 form2 = new Form2(); form2.MdiParent = this; form2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/daff2625cf07e435ecb23d5a4039ca13/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-28T11:09:37+08:00" />
<meta property="article:modified_time" content="2022-10-28T11:09:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Winform和ASP.NET、Web API详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="WinformASPNETWeb_API_0"></a>Winform和ASP.NET、Web API</h2> 
<h3><a id="winform_2"></a>一、winform基础</h3> 
<h4><a id="11__4"></a>1.1 基础学习</h4> 
<p>1、 winform应用程序是一种智能客户端技术，我们可以使用winform应用程序帮助我们获得信息或者传输信息等。</p> 
<p>2、属性</p> 
<p>Name:在后台要获得前台的控件对象，需要使用Name属性。</p> 
<p>visible:指示一个控件是否可见。</p> 
<p>Enabled:指示一个控件是否可用。</p> 
<p>3、</p> 
<p>事件:发生一件事情。</p> 
<p>注册事件:双击控件注册的都是控件默认被选中的那个事件。</p> 
<p>触发事件:<br> 4、<br> 在Main函数当中创建的窗体对象，我们称之为这个窗体应用程序的主窗体。</p> 
<p>也就意味着，当你将主窗体关闭后，整个应用程序都关闭了。</p> 
<p>5、TextBox控件</p> 
<p>Wordwrap:指示文本框是否换行。</p> 
<p>Passwordchar:让文本框显示一个单一的字符</p> 
<p>scollBars:是否显示滚动条</p> 
<p>事件:Textchanged当文本框中的内容发生改变的时候触发这个事件。</p> 
<p>6、跑马灯练习</p> 
<p>abcde</p> 
<p>bcdea</p> 
<p>cdeab</p> 
<pre><code>private void timer1_Tick(object sender, EventArgs e)
        {
            //abcde
            label1.Text = label1.Text.Substring(1) + label1.Text.Substring(0, 1);
        }
</code></pre> 
<p>7、Timer</p> 
<p>在指定的时间间隔内做一件指定的事情</p> 
<p>8、单选和多选</p> 
<p>RadioButton</p> 
<p>CheckBox</p> 
<p>默认情况下，在一个窗体中，所有的单选按钮只允许选中一个，可以使用groupbox进行分组</p> 
<p>9、MDI窗体的设计：MDI(Multiple Document Interface)多文档界面，与此对应就有单文档界面 (<a href="https://baike.baidu.com/item/SDI?fromModule=lemma_inlink" rel="nofollow">SDI</a>)</p> 
<ol><li>首先确定一个父窗体，将IsMdiContainer设置为true</li><li>创建子窗体，并且设置他们的父窗体</li></ol> 
<pre><code>private void 显示子窗体ToolStripMenuItem_Click(object sender, EventArgs e)
        {
            //显示子窗体
            Form2 form2 = new Form2();
            form2.MdiParent = this;
            form2.Show();
            Form3 form3 = new Form3();
            form3.MdiParent = this;
            form3.Show();
            Form4 form4 = new Form4();
            form4.MdiParent = this;
            form4.Show();
        }

        private void 横向排列ToolStripMenuItem_Click(object sender, EventArgs e)
        {
            LayoutMdi(MdiLayout.TileHorizontal);
        }

        private void 纵向排列ToolStripMenuItem_Click(object sender, EventArgs e)
        {
            LayoutMdi(MdiLayout.TileVertical);
        }
</code></pre> 
<p><img src="https://images2.imgbox.com/6b/bf/VbiAirzQ_o.png" alt="image-20221008165357562"></p> 
<ol start="10"><li> <p>PictureBox</p> <p>（1）主要逻辑代码</p> <pre><code>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace WindowsFormsTransPicture
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        /// &lt;summary&gt;
        /// 点击更换上一张图片
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void button1_Click(object sender, EventArgs e)
        {
            i--;
            if (i&lt;0)
            {
                i = picturePaths.Length-1;
            }
            pictureBox1.Image = Image.FromFile(picturePaths[i]);
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            //设置图片显示模式，不设置可能会看不到  Zoom:缩放
            pictureBox1.SizeMode = PictureBoxSizeMode.Zoom;
            pictureBox1.Image = Image.FromFile(@"C:\Users\kevin\Desktop\Picture\Alan Olav Walker.jpg");
        }
        int i = 0;
        //获得指定文件夹下的所有文件的全路径
        string[] picturePaths = Directory.GetFiles(@"C:\Users\kevin\Desktop\Picture");
        /// &lt;summary&gt;
        /// 点击更换下一张图片
        /// &lt;/summary&gt;
        /// &lt;param name="sender"&gt;&lt;/param&gt;
        /// &lt;param name="e"&gt;&lt;/param&gt;
        private void button2_Click(object sender, EventArgs e)
        {
            i++;
            if (i == picturePaths.Length)
            {
                i = 0;
            }
            pictureBox1.Image = Image.FromFile(picturePaths[i]);
        }
    }
}
</code></pre> <p>（2）实现</p> <p><img src="https://images2.imgbox.com/b8/93/AQsd1iIP_o.png" alt="image-20221008174638191"></p> </li><li> <p>对话框</p> <p>系统自带的一些对话框类:</p> 
  <ul><li> <p>OpenFileDialog 打开文件对话框</p> <pre><code>private void btnOpenFile_Click(object sender, EventArgs e)
        {
            var fileContent = string.Empty;
            var filePath = string.Empty;

            using (OpenFileDialog openFileDialog = new OpenFileDialog())
            {
                openFileDialog.InitialDirectory = "D:\\";
                openFileDialog.Filter = "txt files (*.txt)|*.txt|All files (*.*)|*.*";
                openFileDialog.FilterIndex = 2;
                openFileDialog.RestoreDirectory = true;

                if (openFileDialog.ShowDialog() == DialogResult.OK)
                {
                    //获取需要打开的文件路径
                    filePath = openFileDialog.FileName;

                    //读取文件内容
                    var fileStream = openFileDialog.OpenFile();

                    using (StreamReader reader = new StreamReader(fileStream))
                    {
                        fileContent = reader.ReadToEnd();
                    }
                }
            }

            MessageBox.Show(fileContent, "当前路径下文件内容: " + filePath, MessageBoxButtons.OK);
        }
</code></pre> </li><li> <p>SaveFileDialog 保存文件对话框</p> <pre><code>private void btnSaveFile_Click(object sender, EventArgs e)
        {
            Stream myStream;
            SaveFileDialog saveFileDialog1 = new SaveFileDialog();

            saveFileDialog1.Filter = "txt files (*.txt)|*.txt|All files (*.*)|*.*";
            saveFileDialog1.FilterIndex = 2;
            saveFileDialog1.RestoreDirectory = true;

            if (saveFileDialog1.ShowDialog() == DialogResult.OK)
            {
                if ((myStream = saveFileDialog1.OpenFile()) != null)
                {
                    // Code to write the stream goes here.
                    myStream.Close();
                }
            }
        }
</code></pre> </li><li> <p>FolderBrowserDialog 目录选择对话框</p> <pre><code>        private void btnInputSrc_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog fdlg = new FolderBrowserDialog();
            if (fdlg.ShowDialog() == DialogResult.OK)
                InputSrc.Text = fdlg.SelectedPath;
        }

        private void bntOutputSrc_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog fdlg = new FolderBrowserDialog();
            if (fdlg.ShowDialog() == DialogResult.OK)
                OutputSrc.Text = fdlg.SelectedPath;
        }
</code></pre> </li></ul> <p><img src="https://images2.imgbox.com/6e/e2/GuWBd1Ka_o.png" alt="image-20221014151354860"></p> 
  <ul><li> <p>ColorDialog颜色选择对话框</p> </li><li> <p>FontDialog 字体选择对括框</p> </li></ul> </li><li> <p>图标下载：https://www.iconfont.cn</p> </li><li> <p>选取文件，选取目录</p> <pre><code>            //选取目录
            //string debugPath = null;
            //FolderBrowserDialog fbd = new FolderBrowserDialog();
            //fbd.ShowDialog();
            //debugPath = fbd.SelectedPath;

            //选取文件
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.ShowDialog();
            string xmlPath = ofd.FileName;    //路径
            //string fileName = Path.GetFileName(xmlPath);//文件名
</code></pre> </li></ol> 
<h4><a id="12__273"></a>1.2 练习</h4> 
<h5><a id="121__275"></a>1.2.1 学生信息编辑</h5> 
<p>练习：实现一个学生的信息的编辑器</p> 
<p>-学号，姓名，性别，手机号</p> 
<p>-将数据保存到文件</p> 
<p>-启动时从文件读取</p> 
<ol><li> <p>界面布局</p> 
  <ul><li>添加需要的控件</li><li>修改显示文本Text</li><li>手工对齐</li><li>修改控件名Name</li></ul> <p><img src="https://images2.imgbox.com/59/1a/NZCBxAKk_o.png" alt="image-20221014112358664"></p> </li><li> <p>保存功能</p> <p>点击保存时，将界面的数据保存到文件中</p> 
  <ul><li> <p>添加NewtonSoft.json支持</p> <p><img src="https://images2.imgbox.com/c7/51/Ep9bvulc_o.png" alt="image-20221014112906938"></p> </li><li> <p>添加学生类</p> <pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace StudentInfoEdit
{
    internal class Student
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Sex { get; set; }
        public string Phone { get; set; }

        public Student()
        {
        }

        public Student(int id, string name, string sex, string phone)
        {
            Id = id;
            Name = name;
            Sex = sex;
            Phone = phone;
        }
    }
}
</code></pre> </li><li> <p>添加按钮事件处理，将数据保存为Json，存到文件中</p> <pre><code>private void saveButton_Click(object sender, EventArgs e)
        {
            Student student = new Student();
            student.Id = Convert.ToInt32(idField.Text.Trim());
            student.Name = nameField.Text.Trim();
            student.Sex = sexField.Text.Trim();
            student.Phone = phoneField.Text.Trim();

            //Json 支持
            string jsonStr = JsonConvert.SerializeObject(student,Formatting.Indented);
            ReadWriteTextFile.Write(@"D:\C#学习\WinForm\student.txt", jsonStr,Encoding.UTF8);
            MessageBox.Show("操作成功");
        }
</code></pre> </li></ul> </li><li> <p>加载功能</p> <p>当程序启动时，自动读取student.txt中的数据</p> 
  <ul><li> <p>在构造方法中加载</p> <pre><code> public Form1()
        {
            InitializeComponent();
            
            //加载数据方法
            LoadData();
            
            //设置下拉列表的值
            //sexField.Items.Add("男");
            //sexField.Items.Add("女");
        }
</code></pre> </li><li> <p>读取文件，转成json</p> <pre><code>private void LoadData()
        {
            //读取文件
            var sutdentInfo = ReadWriteTextFile.Read(@"D:\C#学习\WinForm\student.txt", Encoding.UTF8);
            //转成Student
            Student student = JsonConvert.DeserializeObject&lt;Student&gt;(sutdentInfo);
            //MessageBox.Show(student.Name);

            //将数据显示在界面上
            idField.Text = student.Id.ToString();
            nameField.Text = student.Name.ToString();
            phoneField.Text = student.Phone.ToString();

            //if (student.Sex.ToString().Equals("false"))
            //{
            //    student.Sex = "男";
            //}
            sexField.Text = student.Sex.ToString();
        }
</code></pre> </li><li> <p>将数据显示到界面</p> <p><img src="https://images2.imgbox.com/7e/8d/DlsBQoA2_o.png" alt="image-20221014122320944"></p> </li></ul> </li></ol> 
<h5><a id="122__401"></a>1.2.2 文件处理</h5> 
<p>需求：根据22-A-01-001-0001-002列查询的重复语句有多少条，并将条数总数打印出来</p> 
<ol><li> <p>进行Winform页面设计</p> <p><img src="https://images2.imgbox.com/b3/1f/B6rhN1bX_o.png" alt="image-20221020163648132"></p> </li><li> <p>进行代码设计</p> <p>（1）KeyValueModel类</p> <pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace WinFormsModel
{
    public class KeyValueModel&lt;K,V&gt;
    {
        public K Key { get; set; }

        public V Value { get; set; }
    }
}
</code></pre> <p>（2）Form1.cs类</p> <pre><code>using System.Diagnostics;
using System.Text;

namespace WinFormsModel
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void btnInputSrc_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog fdlg = new FolderBrowserDialog();
            if (fdlg.ShowDialog() == DialogResult.OK)
                InputSrc.Text = fdlg.SelectedPath;
        }

        private void btnOutputSrc_Click(object sender, EventArgs e)
        {
            FolderBrowserDialog fdlg = new FolderBrowserDialog();
            if (fdlg.ShowDialog() == DialogResult.OK)
                OutputSrc.Text = fdlg.SelectedPath;
        }
        /// &lt;summary&gt;
        /// 打开目录
        /// &lt;/summary&gt;
        /// &lt;param name="folderPath"&gt;目录路径&lt;/param&gt;
        private static void OpenFolder(string folderPath)
        {
            if (string.IsNullOrEmpty(folderPath)) return;

            Process process = new Process();
            ProcessStartInfo psi = new ProcessStartInfo("Explorer.exe");
            psi.Arguments = folderPath;
            process.StartInfo = psi;

            try
            {
                process.Start();
            }
            catch
            {
                throw;
            }
            finally
            {
                process?.Close();

            }
        }
        private void ReadINI()
        {
            string confi = Application.StartupPath + "\\conf.txt";
            if (File.Exists(confi))
            {
                StreamReader sr = new StreamReader(confi, System.Text.Encoding.UTF8);
                string st = sr.ReadLine();
                InputSrc.Text = st;
                st = sr.ReadLine();
                OutputSrc.Text = st;

                sr.Close();
            }
        }

        private void WriteINI()
        {
            string confi = Application.StartupPath + "\\conf.txt";

            StreamWriter sr = new StreamWriter(confi, false, System.Text.Encoding.UTF8);
            sr.WriteLine(InputSrc.Text);
            sr.WriteLine(OutputSrc.Text);

            sr.Close();

        }

        private void Form1_Load(object sender, EventArgs e)
        {
            ReadINI();
        }

        private void btnCheck_Click(object sender, EventArgs e)
        {
            if (Directory.Exists(InputSrc.Text) &amp;&amp; Directory.Exists(OutputSrc.Text))
            {
                WriteINI();
                string input = InputSrc.Text;
                string output = OutputSrc.Text;

                //得到所有的tsv文件
                var files = Directory.GetFiles(input, "*.tsv", SearchOption.AllDirectories);

                //定义一个字典，利用字典的键不能重复判断有没有重复的句子编号
                var dic = new Dictionary&lt;string, int&gt;();

                //定义一个重复句子集合
                var repeatlist = new List&lt;string&gt;();

                //定义一个repeatKV接收重复的句子编号
                var repeatKV = new List&lt;KeyValueModel&lt;string, int&gt;&gt;();
                foreach (string file in files)
                {
                    //读取文件内容
                    var tsvcontents =File.ReadAllLines(file);
                    //遍历每一行内容
                    for (int i = 1; i &lt; tsvcontents.Length; i++)
                    {
                        //以tab键进行分隔，得到一个内容数组
                        var sub = tsvcontents[i].Split('\t');
                        //取出编号
                        //if (sub[4] != null)
                        //{
                        //    alllist.Add(sub[4]);
                        //}
                        //如果有重复的键，则将键加入dic字典
                        if (dic.ContainsKey(sub[4]) == false) 
                        {
                            dic.Add(sub[4], i);
                        }
                        else
                        {
                            repeatKV.Add(new KeyValueModel&lt;string, int&gt;
                            {
                                Key = sub[4],
                                Value = i
                            });
                        }
                    }
                }
                var res = from kv in repeatKV
                          group kv by kv.Key into k     //按照Key属性进行分组
                          select new { count = k.Count()+1, key = k.Key };  //k.Key：表示按照哪个属性分的组

                var content = string.Empty;
                foreach (var k in res)
                {
                    content = k.key + "\t" + k.count + "\r\n";
                    repeatlist.Add(content);
                    rtbmsg.AppendText(content);
                }

                //var eyValueModels = IsRepeat(repeatlist);
                var basePath = Path.Combine(output, "重复编号.txt");
                //File.WriteAllLines(basePath, repeatlist, Encoding.UTF8);  //不使用异步 + Encoding.UTF8写入生成的编码格式：UTF8-BOM
                File.WriteAllLines(basePath, repeatlist);  //不使用异步写入生成的编码格式：UTF8
                //File.WriteAllLinesAsync(basePath, repeatlist);   //使用异步写入生成的编码格式：UTF8
                //File.WriteAllLinesAsync(basePath, repeatlist, Encoding.UTF8);   //使用异步 + Encoding.UTF8写入生成的编码格式：UTF8-BOM
                OpenFolder(output);
            }
        }
    }
}
</code></pre> </li><li> <p>tsv文件内容（部分）</p> <pre><code>								ja	en	mn
22	A	01	22-A-01-001-0001-002	地震...
22	A	01	22-A-01-001-0001-002	地震...
....
此处省略一万条
....
22	A	01	22-A-01-001-0001-002	地震...
22	A	01	22-A-01-001-0001-006	地震...
22	A	01	22-A-01-001-0001-007	地震...
</code></pre> </li><li> <p>运行测试</p> <p><img src="https://images2.imgbox.com/d8/4e/a7w5mv5g_o.png" alt="image-20221020164536815"></p> </li></ol> 
<h4><a id="13__609"></a>1.3 问题总结</h4> 
<p><strong>\r\n和\n的区别：</strong></p> 
<p>一、含义不同：</p> 
<p>\r是回车符，\n是换行符。在C语言中，除了表示除法和注释符号，换行和转义字符都是使用反斜杠的，所以这里的斜杠应该指的是反斜杠。\r\n是回车加换行，\n是换行。要注意的是\r是回车，操作在当前行，而\n则是跳到下一行。</p> 
<p>二、用法不同：</p> 
<p>（1）Unix 系统里，每行结尾只有“&lt;换行&gt;”，即“\n”</p> 
<p>（2）Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“ \r\n”</p> 
<p>（3）Mac系统里，每行结尾是“&lt;回车&gt;”，即“\n”</p> 
<p>一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</p> 
<p><strong>关于写文件的时候生成的文件格式问题：</strong></p> 
<pre><code>File.WriteAllLines(basePath,list);  //不使用异步写入生成的编码格式：UTF8
File.WriteAllLinesAsync(basePath,list);   //使用异步写入生成的编码格式：UTF8
File.WriteAllLines(basePath,list, Encoding.UTF8);  //不使用异步 + Encoding.UTF8写入生成的编码格式：UTF8-BOM
File.WriteAllLinesAsync(basePath,list, Encoding.UTF8);   //使用异步 + Encoding.UTF8写入生成的编码格式：UTF8-BOM
</code></pre> 
<h3><a id="ASPNET_636"></a>二、ASP.NET</h3> 
<blockquote> 
 <p>准备</p> 
</blockquote> 
<p>推荐直接安装VS2022正式版，.NET环境全部自带，最省事儿!</p> 
<p>1、 Visual Studio 2022正式版<br> 下载地址: https://visualstudio.microsoft.com/zh-hans/vs/</p> 
<p>3个版本，目前都是英文版的<br> 社区版 vs_Community.exe</p> 
<p>专业版 vs_professional</p> 
<p>企业版 vs_community<br> 社区版不需要激活码</p> 
<p>专业版激活码:<br> TD244-P4NB7-YQ6XK-Y8MMM-YWV2J</p> 
<p>企业版激活码:<br> VHF9H-NXBBB-638P6-6JHCY-88JWH<br> tips:在线安装时，如果下载不了安装文件，则是需要设置dns为8.8.8.8 114.114.114.114</p> 
<p>2、 VS2022是带了.NET6的SDK，但运行时有依赖，建议单独下载Hosting Bundle并安装<br> 下载地址: https://dotnet.microsoft.com/download/dotnet/6.0<br> dotnet-hosting-6.0.0-win.exe</p> 
<p>3、不建议使用2019了，，只有MAC是VS2019</p> 
<h4><a id="21_ASPNET_666"></a>2.1 ASP.NET</h4> 
<p>ASP.NET 是一个使用 HTML、CSS、JavaScript 和服务器脚本创建网页和网站的开发框架。</p> 
<p>ASP.NET 是新一代 ASP 。它与经典 ASP 是不兼容的，但 ASP.NET 可能包括经典 ASP。</p> 
<p>ASP.NET 页面是经过编译的，这使得它们的运行速度比经典 ASP 快。</p> 
<p>ASP.NET 具有更好的语言支持，有一大套的用户控件和基于 XML 的组件，并集成了用户身份验证。</p> 
<p>ASP.NET 页面的扩展名是 .aspx ，通常是用 VB (Visual Basic) 或者 C# (C sharp) 编写。</p> 
<p>在 ASP.NET 中的控件可以用不同的语言（包括 C++ 和 Java）编写。</p> 
<p>当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取文件，编译和执行脚本文件，并将结果以普通的 HTML 页面返回给浏览器。</p> 
<p>ASP.NET 支持三种不同的开发模式：<br> Web Pages（Web 页面）、MVC（Model View Controller 模型-视图-控制器）、Web Forms（Web 窗体）：</p> 
<table><thead><tr><th>Web Pages 单页面模式</th><th></th><th>MVC 模型-视图-控制器</th><th></th><th>Web Forms 事件驱动模式</th></tr></thead><tbody><tr><td>最简单的 ASP.NET 模式。 与 PHP 和经典 ASP 相似。 内置了数据库、视频、图形、社交媒体等模板和帮助器。</td><td></td><td>MVC 将 Web 应用程序分成 3 个不同的组成部分： 模型负责数据 视图负责显示 控制器负责输入</td><td></td><td>传统的 ASP.NET 事件驱动开发模式： 带有服务器控件、服务器事件和服务器代码的网页。</td></tr></tbody></table> 
<h4><a id="22_Web_PagesRazor_689"></a>2.2 Web Pages和Razor的简单了解</h4> 
<p><strong>Web Pages：</strong></p> 
<p>Web Pages 是三种创建 ASP.NET 网站和 Web 应用程序的编程模式中的一种。</p> 
<p>其他两种编程模式是 Web Forms 和 MVC（Model View Controller 模型-视图-控制器）。</p> 
<p>Web Pages 是开发 ASP.NET 网页最简单的开发模式。它提供了一种简单的方式来将 HTML、CSS、JavaScript 和服务器脚本结合起来：</p> 
<ul><li>容易学习，容易理解，容易使用</li><li>围绕着单一的网页创建</li><li>与 PHP 和经典 ASP 相似</li><li>Visual Basic 或者 C# 的服务器脚本</li><li>全 HTML、CSS 和 JavaScript 控制</li></ul> 
<p>Web Pages 内置了数据库、视频、图形、社交媒体和其他更多的 Web Helpers，因此很容易扩展。</p> 
<pre><code>&lt;!DOCTYPE html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Web Pages Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Hello Web Pages&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>现在向实例中添加一些 Razor 代码：</p> 
<pre><code>&lt;!DOCTYPE html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Web Pages Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Hello Web Pages&lt;/h1&gt;
&lt;p&gt;The time is @DateTime.Now&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>该页面中包含普通的 HTML 标记，除此之外，还添加了一个 @ 标识的 Razor 代码。</p> 
<p>Razor 代码能够在服务器上实时地完成多有的动作，并将结果显示出来。（您可以指定格式化选项，否则只会显示默认项。）</p> 
<p><strong>什么是 Razor ？</strong></p> 
<ul><li>Razor 是一种将基于服务器的代码添加到网页中的标记语法</li><li>Razor 具有传统 ASP.NET 标记的功能，但更容易使用并且更容易学习</li><li>Razor 是一种服务器端标记语法，与 ASP 和 PHP 很像</li><li>Razor 支持 C# 和 Visual Basic 编程语言</li></ul> 
<p><strong>主要的 Razor C# 语法规则</strong></p> 
<ul><li> <p>Razor 代码块包含在 @{ … } 中</p> </li><li> <p>内联表达式（变量和函数）以 @ 开头</p> </li><li> <p>代码语句用分号结束</p> </li><li> <p>变量使用 var 关键字声明</p> <p>（1）变量是用来存储数据的。</p> <p>（2）一个变量的名称必须以字母字符开头，并且不能包含空格或者保留字符。</p> <p>（3）一个变量可以是一个指定的类型，表示它所存储的数据类型。string 变量存储字符串值（“Welcome to RUNOOB.COM”），integer 变量存储数字值（103），date 变量存储日期值，等等。</p> <p>（4）变量使用 var 关键字声明，或通过使用类型（如果您想声明类型）声明都可以，但是 ASP.NET 通常能自动确定数据类型。var关键字一般声明为局部变量，全局变量不能用var声明。</p> <pre><code>// 使用 var 关键字:
var greeting = "Welcome to China";
var counter = 103;
var today = DateTime.Today;

// 使用数据类型:
string greeting = "Welcome to China";
int counter = 103;
DateTime today = DateTime.Today;
</code></pre> </li><li> <p>字符串用引号括起来</p> </li><li> <p>C# 代码区分大小写</p> </li><li> <p>C# 文件的扩展名是 .cshtml</p> </li></ul> 
<pre><code>&lt;!-- Single statement block --&gt;
@{ var myMessage = "Hello World"; }

&lt;!-- Inline expression or variable --&gt;
&lt;p&gt;The value of myMessage is: @myMessage&lt;/p&gt;

&lt;!-- Multi-statement block --&gt;
@{
var greeting = "Welcome to our site!";
var weekDay = DateTime.Now.DayOfWeek;
var greetingMessage = greeting + " Today is: " + weekDay;
}
&lt;p&gt;The greeting is: @greetingMessage&lt;/p&gt;

输出：
The value of myMessage is: Hello World

The greeting is: Welcome to our site! Here in Huston it is: Saturday
</code></pre> 
<h4><a id="23_ASPNET_MVC_806"></a>2.3 ASP.NET MVC</h4> 
<h5><a id="231_MVC_808"></a>2.3.1 MVC基础</h5> 
<p>复杂网站–使用MVC</p> 
<p>MVC 是三种 ASP.NET 编程模式中的一种。</p> 
<p>MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式：</p> 
<ul><li>Model（模型）表示应用程序核心（比如数据库记录列表）。</li><li>View（视图）显示数据（数据库记录）。</li><li>Controller（控制器）处理输入（写入数据库记录）。</li></ul> 
<p>MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。</p> 
<hr> 
<table><thead><tr><th><img src="https://images2.imgbox.com/ff/f1/DgkfJRMz_o.jpg" alt="MVC"></th><th>MVC 模式定义 Web 应用程序 带有三个逻辑层：业务层（模型逻辑）显示层（视图逻辑）输入控制（控制器逻辑</th></tr></thead></table> 
<p>**Model（模型）**是应用程序中用于处理应用程序数据逻辑的部分。<br> 通常模型对象负责在数据库中存取数据。</p> 
<p>**View（视图）**是应用程序中处理数据显示的部分。<br> 通常视图是依据模型数据创建的。</p> 
<p>**Controller（控制器）**是应用程序中处理用户交互的部分。<br> 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p> 
<p>MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。</p> 
<p>MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。</p> 
<p><strong>添加数据库控制器</strong></p> 
<p>数据库控制器可以通过以下几个简单的步骤来创建：</p> 
<ul><li> <p>在 Solution Explorer（解决方案资源管理器）中，右击 <strong>Controllers</strong> 文件夹，选择 <strong>Add</strong> 和 <strong>Controller</strong>。</p> <p><img src="https://images2.imgbox.com/67/53/pSQmGpYR_o.png" alt="image-20221009162113948"></p> </li><li> <p>选择模板：<strong>Controller with read/write actions and views, using Entity Framework</strong></p> <p><img src="https://images2.imgbox.com/6d/29/OrXPl790_o.png" alt="image-20221009162143959"></p> </li><li> <p>选择模型类：<strong>MovieDB (MvcDemo.Models)</strong></p> </li><li> <p>选择 data context 类：<strong>MovieDBContext (MvcDemo.Models)</strong></p> </li><li> <p>选择视图 <strong>Razor (CSHTML)</strong></p> </li><li> <p>设置控制器名称为 <strong>MoviesController</strong>。</p> <p><img src="https://images2.imgbox.com/38/51/GaMLeIN2_o.png" alt="image-20221009162309708"></p> </li><li> <p>点击 <strong>Add</strong></p> </li></ul> 
<p>Visual Web Developer 将创建以下文件：</p> 
<ul><li><strong>Controllers</strong> 文件夹中的 <strong>MoviesController.cs</strong> 文件</li><li><strong>Views</strong> 文件夹中的 <strong>Movies</strong> 文件夹</li></ul> 
<p><img src="https://images2.imgbox.com/fe/1d/xNfRuOKj_o.png" alt="image-20221009162849514"></p> 
<hr> 
<p><strong>添加数据库视图</strong></p> 
<p>在 Movies 文件夹中，会自动创建以下文件：</p> 
<ul><li>Create.cshtml</li><li>Delete.cshtml</li><li>Details.cshtml</li><li>Edit.cshtml</li><li>Index.cshtml</li></ul> 
<p><strong>MVC项目:</strong></p> 
<ul><li> <p>M(模型model)–用来传递数据</p> </li><li> <p>C(控制器Controller)–HTTP请求到了MEB服务器使用控制器来处理这些请求（处理请求，数据处理，生成响应)</p> </li></ul> 
<p>​ 作用：</p> 
<p>​ (1)在构造函数中注入服务</p> 
<p>​ (2)执行动作方法</p> 
<p>​ (3)向视图传递数据，HTML、PDF、EXCEL、JOSN</p> 
<p>​ (4)将结果附带状态码返回给客户端（例如：200 OK）</p> 
<p><img src="https://images2.imgbox.com/19/17/Vo8NRST5_o.png" alt="image-20221009172802099"></p> 
<ul><li> <p>V (View) --Razor视图(.cshtml文件)</p> <p>（1）视图搜索方式：</p> <pre><code>/Views/Home/xxx.cshtml
/Views/Shared/xxx.cshtml
/Pages/Shared/xxx.cshtml
</code></pre> <p><img src="https://images2.imgbox.com/1c/7d/bKyKnixm_o.png" alt="image-20221009174316956"></p> <p>启动项目打开该页面</p> <p><img src="https://images2.imgbox.com/9b/c7/Qaf1urhX_o.png" alt="image-20221009174345379"></p> </li></ul> 
<p>Areas:什么情况下会用到，一个项目有多个系统，或者一个分前段（客户）后端（网站管理)</p> 
<p><img src="https://images2.imgbox.com/0c/e4/59hNEnMj_o.png" alt="image-20221009154639721"></p> 
<p><strong>ControllerBase基类:</strong></p> 
<p>(1）不支持视图</p> 
<p>(2)后面WebAPI也是用这个基类</p> 
<p>(3) htppContext(请求和响应，包括有关的链接信息、包括一些中间件以及和身份验证和授权User对象)</p> 
<p>(4) Request(HTTP请求，请求头，查询字符串，内容类型)</p> 
<p>(5)Response()</p> 
<p><strong>Controller类：</strong></p> 
<p>(1）数据传递–ViewData(键值对的字典–只能在当前请求里面保存数据)/ViewBag是对vViewData的包装好处编写人性化/TempData(跨请求保存数据，生命周期长一点)<br> (2)处理视图的方法:<br> View ()返回和动作方法同名的视图</p> 
<p><strong>过滤器Filter:</strong><br> 作用–向多个控制器和动作方法添加一些功能的时候，可以使用或者自定义的过滤器。</p> 
<p>(1）标注在控制器–对整个控制器产生作用</p> 
<p>(2)标注在动作方法上面–对这个动作方法起作用</p> 
<p>(3）通过服务的形式配置–全局作用</p> 
<p>并行编程在多核CPU</p> 
<p><img src="https://images2.imgbox.com/93/91/Ss6BiWzE_o.png" alt="image-20221010100917244"></p> 
<p>并发编程：榨干CPU，充分利用CPU资源</p> 
<p><img src="https://images2.imgbox.com/e3/42/6ig1dlNd_o.png" alt="image-20221010100712442"></p> 
<p>Thread—》ThreadPool线程池—》Task任务(async await)</p> 
<p>异步编程:提高服务器吞吐量(I/0)</p> 
<p><img src="https://images2.imgbox.com/45/b9/0GhZ4TVC_o.png" alt="image-20221010101211183"></p> 
<pre><code>//async:1、使标注的方法变成异步方法 2、使调用方法时前面加的await生效 3、异步编程返回值:  无返回值：Task   有返回值：Task&lt;返回值类型&gt;
        public async Task&lt;IActionResult&gt; Index()
        {
            //创建角色
            await roleManager.CreateAsync(new IdentityRole(AdminRole));
            //创建管理员用户
            IdentityUser user = new IdentityUser { UserName = UserEmail ,Email = UserEmail,EmailConfirmed = true};  //EmailConfirmed = true：Email用户验证为true，就可以登录了，否则登录不了
            await userManager.CreateAsync(user,UserEmail);
            //把用户添加到角色
            await userManager.AddToRoleAsync(user,AdminRole);

            //return View();
            //Redirect:重定向跳转页面，也就是直接跳转到指定页面   "/"：表示首页
            return Redirect("/");
        }
</code></pre> 
<h5><a id="232__986"></a>2.3.2 程序包管理控制台迁移数据库报错</h5> 
<pre><code>PM&gt; add-migration CreateIdentitySchema
Build started...
Build succeeded.
//第一个错
The Entity Framework tools version '6.0.4' is older than that of the runtime '6.0.9'. Update the tools for the latest features and bug fixes. See https://aka.ms/AAc1fbw for more information.

System.TypeLoadException: Method 'Create' in type 'MySql.Data.EntityFrameworkCore.Query.Internal.MySQLSqlTranslatingExpressionVisitorFactory' from assembly 'MySql.Data.EntityFrameworkCore, Version=8.0.22.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d' does not have an implementation.
...
//第二个错
Method 'Create' in type 'MySql.Data.EntityFrameworkCore.Query.Internal.MySQLSqlTranslatingExpressionVisitorFactory' from assembly 'MySql.Data.EntityFrameworkCore, Version=8.0.22.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d' does not have an implementation.
</code></pre> 
<p>第一个错的意思是：实体<a href="https://so.csdn.net/so/search?q=%E6%A1%86%E6%9E%B6&amp;spm=1001.2101.3001.7020">框架</a>工具版本“6.0.4”比运行时版本“6.0.9”更旧。更新工具以获得最新的特性和bug修复。</p> 
<p>接下来以管理员身份打开<a href="https://so.csdn.net/so/search?q=CMD&amp;spm=1001.2101.3001.7020">CMD</a> 运行以下命令：</p> 
<pre><code class="prism language-powershell">dotnet tool update <span class="token operator">--</span>global dotnet-ef
</code></pre> 
<p><img src="https://images2.imgbox.com/42/01/TuSt3a1N_o.png" alt="image-20221010104451928"></p> 
<p>重启visual studio即可</p> 
<p>如果以上操作还是不行的话，则是因为你导入的包的版本不一致，需要全部更新为6.0.9，如下</p> 
<p><img src="https://images2.imgbox.com/93/56/MJMHNrKD_o.png" alt="image-20221010105812811"></p> 
<p><strong>连接MySQL</strong><br> 1、通过NuGet添加相关的包：</p> 
<p>Pomelo.EntityFrameworkCore.MySql</p> 
<p><img src="https://images2.imgbox.com/8a/b8/YuwAFjRu_o.png" alt="image-20221010132235781"></p> 
<p>注：<br> 网上很多资料都是关于引用 MySql.Data.EntityFrameworkCore 连接MySql的，但MySql.Data.EntityFrameworkCore目前好像已经弃用了。引用 MySql.Data.EntityFrameworkCore后，会报以下错误，所以不要安装这个包，安装了的话需要移除，只需要使用上面那个就行了：</p> 
<pre><code>MySql.Data.EntityFrameworkCore.Query.Internal.MySQLSqlTranslatingExpressionVisitorFactory' from assembly 'MySql.Data.EntityFrameworkCore, Version=8.0.22.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d' does not have an implementation
</code></pre> 
<p>2、新增MySql数据库连接配置</p> 
<p>在 在appsettings.json 新增数据库连接</p> 
<pre><code>{
  //新增数据库连接
  "ConnectionStrings": {
    "DefaultConnection": "Server=127.0.0.1;UserId=root;Password=123456;Database=webmvc"
  },
  //下面这些是原来的不用管
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

</code></pre> 
<p>3、在Program.cs中注册服务</p> 
<pre><code>// 注册服务
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(builder =&gt; builder.UseMySql(connectionString, new MySqlServerVersion(new Version(8, 0, 11))));
</code></pre> 
<p>下面是我的Program.cs代码，有需要的话可以借鉴（此处创建的是一个MVC项目）：</p> 
<pre><code>using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using WebMvcMysql.Data;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");

//builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
//    options.UseSqlServer(connectionString));
builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(builder =&gt; builder.UseMySql(connectionString, new MySqlServerVersion(new Version(8, 0, 11))));

builder.Services.AddDatabaseDeveloperPageExceptionFilter();

builder.Services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt; options.SignIn.RequireConfirmedAccount = true)
    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();
builder.Services.AddRazorPages();


var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseMigrationsEndPoint();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
app.MapRazorPages();

app.Run();
</code></pre> 
<p>注： 这里必须指定 ServerVersion，否则无法编译通过，会报第二个错误<br> 4、调试运行，访问页面成功</p> 
<p><img src="https://images2.imgbox.com/20/bb/hEuWRKWX_o.png" alt="image-20221010122613317"></p> 
<p>到这来，连接MySQL 已完成</p> 
<h5><a id="233_MVC_1121"></a>2.3.3 创建MVC实战项目</h5> 
<ol><li> <p>创建项目</p> <p><img src="https://images2.imgbox.com/e3/3c/BxUsrH1j_o.png" alt="image-20221010133905952"></p> </li><li> <p>连接mysql数据库</p> <p>1）通过NuGet添加相关的包：</p> <p>Pomelo.EntityFrameworkCore.MySql</p> <p><img src="https://images2.imgbox.com/30/8c/brFyrmTK_o.png" alt="image-20221010132235781"></p> <p>注：<br> 网上很多资料都是关于引用 MySql.Data.EntityFrameworkCore 连接MySql的，但MySql.Data.EntityFrameworkCore目前好像已经弃用了。引用 MySql.Data.EntityFrameworkCore后，会报以下错误，所以不要安装这个包，安装了的话需要移除，只需要使用上面那个就行了：</p> <pre><code>MySql.Data.EntityFrameworkCore.Query.Internal.MySQLSqlTranslatingExpressionVisitorFactory' from assembly 'MySql.Data.EntityFrameworkCore, Version=8.0.22.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d' does not have an implementation
</code></pre> <p>2）新增MySql数据库连接配置</p> <p>在appsettings.json 新增数据库连接</p> <pre><code>{
  //新增数据库连接
  "ConnectionStrings": {
    "DefaultConnection": "Server=127.0.0.1;UserId=root;Password=123456;Database=webmvc"
  },
  //下面这些是原来的不用管
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

</code></pre> <p>3）在Program.cs中注册服务</p> <pre><code>// 注册服务
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(builder =&gt; builder.UseMySql(connectionString, new MySqlServerVersion(new Version(8, 0, 11))));
</code></pre> <p>下面是我的Program.cs代码，有需要的话可以借鉴（此处创建的是一个MVC项目）：</p> <pre><code>using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using WebMvcMysql.Data;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");

//builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
//    options.UseSqlServer(connectionString));
builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(builder =&gt; builder.UseMySql(connectionString, new MySqlServerVersion(new Version(8, 0, 11))));

builder.Services.AddDatabaseDeveloperPageExceptionFilter();

builder.Services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt; options.SignIn.RequireConfirmedAccount = true)
    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;();
builder.Services.AddRazorPages();


var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseMigrationsEndPoint();
}
else
{
    app.UseExceptionHandler("/Home/Error");
    // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthentication();
app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
app.MapRazorPages();

app.Run();
</code></pre> <p>注： 这里必须指定 ServerVersion，否则无法编译通过，会报第二个错误</p> <p>4）删除系统生成的迁移文件夹，因为系统默认连接的是SQL Server，否则直接执行Update-Database或者进行下面的迁移会报错</p> <p><img src="https://images2.imgbox.com/5c/d3/6MkqQuYG_o.png" alt="image-20221010152815050"></p> <p>5)在程序包管理控制台执行命令即可生成以mysql数据库的迁移文件夹，有问题参照 2.3.2</p> <pre><code>add-migration CreateIdentitySchema
</code></pre> <p><img src="https://images2.imgbox.com/fa/8f/lfzzXj0V_o.png" alt="image-20221010153500339"></p> </li><li> <p>启动项目，点击注册</p> <p><img src="https://images2.imgbox.com/47/8c/tM3zYXsP_o.png" alt=""></p> </li><li> <p>点击进行迁移</p> <p><img src="https://images2.imgbox.com/5d/2c/BcGiiVsW_o.png" alt="image-20221010150732016"></p> </li><li> <p>刷新页面，并点击最后的蓝色字体进行邮箱确认，否则会登录不进系统</p> <p><img src="https://images2.imgbox.com/72/85/5CXmhSKD_o.png" alt="image-20221010150807931"></p> </li><li> <p>迁移成功之后便会在数据库中自动生成下面这些表</p> <p><img src="https://images2.imgbox.com/c0/54/o2G48O4n_o.png" alt="image-20221010151033463"></p> </li><li> <p>数据库表分析</p> <p><img src="https://images2.imgbox.com/03/5f/SKzxSMZo_o.png" alt="image-20221010152259692"></p> </li><li> <p>登录系统</p> <p><img src="https://images2.imgbox.com/43/fd/9WttJjOl_o.png" alt="image-20221010152325081"></p> </li><li> <p>访问权限设置</p> <pre><code>        //在方法名上方添加：[Authorize(Roles ="admin")]，表示对方法访问进行授权限制访问（过滤器）
        //需要对应的角色才能登录Index页面
        [Authorize(Roles ="admin")]
        public IActionResult Index()
        {
            return View();
        }
</code></pre> <p><img src="https://images2.imgbox.com/92/7c/SOGYGuGi_o.png" alt="image-20221010154239230"></p> </li><li> <p>再次登录系统被拒</p> <p><img src="https://images2.imgbox.com/b2/de/tMeQ1sJY_o.png" alt="image-20221010154323458"></p> </li><li> <p>Route过滤器自定义路由</p> <pre><code>[Route("error")] //使用过滤器自定义路由
        public IActionResult Error()
        {
            return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
        }
</code></pre> <p><img src="https://images2.imgbox.com/7a/50/gq48vMNN_o.png" alt="image-20221010163357383"></p> </li></ol> 
<h5><a id="234_CRUD_1293"></a>2.3.4 CRUD快速创建</h5> 
<ol><li> <p>新建Product类</p> <pre><code>namespace WebMvcMysql.Models
{
    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public decimal Price { get; set; }  //价格
        public short Stock { get; set; }  //库存
        public string? ImageUrl { get; set; }  //图片路径
        public IFormFile? FormFile { get; set; }  //图片
    }
}
</code></pre> </li><li> <p>将其添加到</p> <pre><code>using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using WebMvcMysql.Models;

namespace WebMvcMysql.Data
{
    public class ApplicationDbContext : IdentityDbContext
    {
        public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options)
            : base(options)
        {

        }
        //需要在此增加，否则不能生成对应的数据库表
        public DbSet&lt;Product&gt; Products { get; set; }
    }
}
</code></pre> <p>执行命令：add-migration addproduct</p> <p><img src="https://images2.imgbox.com/c6/be/qOTfSdsJ_o.png" alt="image-20221010164722782"></p> <p>报错，具体就是说数据库中没有对应的类型，不能形成映射，所以这个类型不需要映射</p> <pre><code>The property 'Product.FormFile' is of an interface type ('IFormFile'). If it is a navigation, manually configure the relationship for this property by casting it to a mapped entity type. Otherwise, ignore the property using the [NotMapped] attribute or 'Ignore' in 'OnModelCreating'.
</code></pre> <p>修改实体类</p> <pre><code>using System.ComponentModel.DataAnnotations.Schema;

namespace WebMvcMysql.Models
{
    public class Product
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public decimal Price { get; set; }  //价格
        public short Stock { get; set; }  //库存
        public string? ImageUrl { get; set; }  //图片路径
        [NotMapped]  //不映射的注解
        public IFormFile? FormFile { get; set; }  //图片
    }
}
</code></pre> </li><li> <p>继续</p> <pre><code>add-migration addproduct  //执行迁移命令
</code></pre> <pre><code>update-database  //更新数据库命令，不执行此语句数据库中不会有对应的表
</code></pre> <p><img src="https://images2.imgbox.com/53/25/ACgvzfiJ_o.png" alt="image-20221010165519503"></p> <p><img src="https://images2.imgbox.com/b2/20/msM98SkD_o.png" alt="image-20221010165711584"></p> </li><li> <p>CRUD</p> </li></ol> 
<ul><li>Index：显示页面</li><li>Edit：编辑页面</li><li>Create：创建页面</li><li>Delete：删除页面</li><li>Details：明细页面，只能看不能改</li></ul> 
<ol><li> <p>添加数据库控制器：</p> <p>1）生成方式一（不建议使用，使用下面的生成方式二去生成）：</p> </li></ol> 
<p><img src="https://images2.imgbox.com/7d/0a/gLsxe7rU_o.png" alt="image-20221010170518804"></p> 
<p>自动生成</p> 
<p><img src="https://images2.imgbox.com/e9/11/xoMSKeFU_o.png" alt="image-20221010170554529"></p> 
<p>2）生成方式二：</p> 
<p><img src="https://images2.imgbox.com/8c/40/Jq4zSAVZ_o.png" alt="image-20221010170826269"></p> 
<p>出现如下不用管，重新继续操作一遍就可以了</p> 
<p><img src="https://images2.imgbox.com/cf/09/H9WItmIg_o.png" alt="image-20221010170957844"></p> 
<p>自动生成如下</p> 
<p><img src="https://images2.imgbox.com/e3/80/5BZnu3KC_o.png" alt="image-20221010171210814"></p> 
<ol start="2"><li> <p>启动项目访问页面，https://localhost:7134/products/index</p> <p>格式：https://localhost:7134/控制器名称/页面名称</p> <p><img src="https://images2.imgbox.com/51/66/McZrg082_o.png" alt="image-20221010172511478"></p> </li><li> <p>添加Products，点击即可访问</p> <p><img src="https://images2.imgbox.com/e7/72/D5jtTkOG_o.png" alt="image-20221010173133623"></p> <p><img src="https://images2.imgbox.com/7f/a9/kbeFzkzV_o.png" alt="image-20221010173204678"></p> </li></ol> 
<h4><a id="24_Razor_Pages_1420"></a>2.4 Razor Pages</h4> 
<h5><a id="241__1422"></a>2.4.1 了解网络开发</h5> 
<p>1、遵守HTTP<br> 2、https://www.baidu.com/—180.101.49.11(域名–localhost) :443(端口号)(https加密，http明文)5000,5001，资源路径<br> 3、get请求(一般用于资源请求，可以带参数)，POST请求（注册，登陆)<br> 4、需要的基础知识HTNL5/CSS3/JavaScript(TypeScript),C#基础进阶、EFCore，Bootstarp</p> 
<h5><a id="242_HTTPS_1429"></a>2.4.2 HTTPS安全跳转设置</h5> 
<ol><li> <p>https：</p> <p><img src="https://images2.imgbox.com/a1/cf/RC1qLIHH_o.png" alt="image-20221011163530406"></p> </li><li> <p>http</p> <p><img src="https://images2.imgbox.com/2f/98/d7z4BGgr_o.png" alt="image-20221011163622815"></p> </li><li> <p>项目链接分析</p> </li></ol> 
<p><img src="https://images2.imgbox.com/b0/d6/avfAAf4t_o.png" alt="image-20221011163434245"></p> 
<ol start="4"><li> <p>在Program.cs中编写代码</p> <pre><code>var builder = WebApplication.CreateBuilder(args); //创建默认web主机
var app = builder.Build();  //创建

//判断是否是开发环境，可以去launchSettings.json文件中查看environmentVariables
//if (!app.Environment.IsDevelopment())
//{
//    app.UseHsts();  //添加安全访问中间件
//}
app.UseHttpsRedirection(); //自动跳转到HTTPS，用HTTPS链接去访问

app.MapGet("/", () =&gt; "Hello World!");

app.Run();  //运行，阻塞调用
</code></pre> </li><li> <p>启动项目进行测试，默认是开发环境</p> <p><img src="https://images2.imgbox.com/e2/7c/xLAozL7T_o.png" alt="image-20221011164757404"></p> </li><li> <p>launchSettings.json</p> <pre><code>{
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:8836",
      "sslPort": 44311
    }
  },
  "profiles": {
    "RazorPages.web": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7036;http://localhost:5036",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
        //"ASPNETCORE_ENVIRONMENT": "Production"  //部署上线后设置为Production
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
</code></pre> <p><img src="https://images2.imgbox.com/6c/f6/L6cuQJ8A_o.png" alt="image-20221011165452242"></p> </li></ol> 
<h5><a id="243_Startup_1501"></a>2.4.3 Startup类设置和传递静态文件</h5> 
<ol><li> <p>添加类</p> <p><img src="https://images2.imgbox.com/00/63/Z40kQIJz_o.png" alt="image-20221011170000320"></p> </li><li> <p>修改类</p> <pre><code>using Microsoft.AspNetCore.Builder;

namespace RazorPages.web
{
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {

        }
        public void Configure(IApplicationBuilder app,IWebHostEnvironment env)
        {
            //判断是否是开发环境，可以去launchSettings.json文件中查看environmentVariables
            if (!env.IsDevelopment())
            {
                app.UseHsts();  //添加安全访问中间件
            }
            app.UseRouting();  //启动终结点路由（做选择）

            app.UseHttpsRedirection(); //自动跳转到HTTPS，用HTTPS链接去访问

            app.UseEndpoints(endpoints =&gt;
            {
                endpoints.MapGet("/", () =&gt; "Hello World!");
            });
            
        }
    }
}
</code></pre> </li><li> <p>启动项目：在Program.cs写入以下代码</p> <pre><code>//var builder = WebApplication.CreateBuilder(args); //创建默认web主机
//var app = builder.Build();  //创建

判断是否是开发环境，可以去launchSettings.json文件中查看environmentVariables
//if (!app.Environment.IsDevelopment())
//{
//    app.UseHsts();  //添加安全访问中间件
//}
//app.UseHttpsRedirection(); //自动跳转到HTTPS，用HTTPS链接去访问

//app.MapGet("/", () =&gt; "Hello World!");

//app.Run();  //运行，阻塞调用


using RazorPages.web;

//启动项目的方法
Host.CreateDefaultBuilder(args)
    .ConfigureWebHostDefaults(webBuilder =&gt;
    {
        webBuilder.UseStartup&lt;Startup&gt;();
    }).Build().Run();

</code></pre> </li><li> <p>传递静态文件，新建文件夹命名为wwwroot</p> <p><img src="https://images2.imgbox.com/5a/82/YAJt4Imf_o.png" alt="image-20221011171651944"></p> </li><li> <p>新建一个index.html文件在wwwroot文件夹下</p> <p><img src="https://images2.imgbox.com/92/d8/d69XFL6C_o.png" alt="image-20221011171845397"></p> </li><li> <p>编辑index.html文件</p> <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;!--引入bootstrap的CSS样式--&gt;
    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rTTiRUKnSWaDu2FjhzWFl8/JuUZMlplyWE/djenb2LoKqkgLGfEGfSrL7XDLoB1M" crossorigin="anonymous"&gt;
    &lt;title&gt;小舒的网页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;这是一个静态页面&lt;/h1&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> </li><li> <p>在Startup文件中添加如下代码</p> <p><img src="https://images2.imgbox.com/56/ab/9wk7kHfu_o.png" alt="image-20221011172733415"></p> </li><li> <p>启动项目访问页面</p> <p><img src="https://images2.imgbox.com/9f/88/BI7N9vAG_o.png" alt="image-20221011172759117"></p> </li><li> <p>设置默认路由</p> <pre><code>app.UseDefaultFiles(); //index.html,default.html
</code></pre> <pre><code>using Microsoft.AspNetCore.Builder;

namespace RazorPages.web
{
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {

        }
        public void Configure(IApplicationBuilder app,IWebHostEnvironment env)
        {
            //判断是否是开发环境，可以去launchSettings.json文件中查看environmentVariables
            if (!env.IsDevelopment())
            {
                app.UseHsts();  //添加安全访问中间件
            }
            app.UseRouting();  //启动终结点路由（做选择）

            app.UseHttpsRedirection(); //自动跳转到HTTPS，用HTTPS链接去访问
            
            app.UseDefaultFiles(); //index.html,default.html

            app.UseStaticFiles();  //添加启动静态文件页面

            app.UseEndpoints(endpoints =&gt;
            {   
                //页面访问路由，可自定义
                endpoints.MapGet("/xiaoshu", () =&gt; "Hello World!");
            });
            
        }
    }
}
</code></pre> </li></ol> 
<h5><a id="244_RazorCHTML_1648"></a>2.4.4 创建Razor动态页面（C#+HTML）</h5> 
<ol><li> <p>准备，文件夹名称必须是Pages，否则会找不到</p> <p><img src="https://images2.imgbox.com/53/5e/krZzCBhV_o.png" alt="image-20221011182531699"></p> </li><li> <p>在Startup文件中修改页面访问路由</p> <p><img src="https://images2.imgbox.com/53/92/2j7U2fsB_o.png" alt="image-20221011180924714"></p> </li><li> <p>编辑Razor页面</p> <pre><code>@page
@model RazorPages.web.Pages.IndexModel
@{
    //这里可以写C#代码，还可以写http请求的时候执行的方法，比如OnGet（get请求时执行），OnPost（post请求时执行）
   Model.Name="我是动态页面";
}
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;!--引入bootstrap的CSS样式--&gt;
    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rTTiRUKnSWaDu2FjhzWFl8/JuUZMlplyWE/djenb2LoKqkgLGfEGfSrL7XDLoB1M" crossorigin="anonymous"&gt;
    &lt;title&gt;Razor的网页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;@Model.Name&lt;/h1&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> <pre><code>using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;

namespace RazorPages.web.Pages
{
    public class IndexModel : PageModel
    {
        public string? Name { get; set; }
        public void OnGet()
        {
            
        }
    }
}
</code></pre> </li><li> <p>启动项目</p> <p><img src="https://images2.imgbox.com/d6/03/29LuBGw7_o.png" alt="image-20221011182637766"></p> </li></ol> 
<h4><a id="25__Log4net_1704"></a>2.5 日志组件 Log4net</h4> 
<h5><a id="251__Log4net_1706"></a>2.5.1 日志组件 Log4net</h5> 
<p>Nlog：http://t.csdn.cn/581eS</p> 
<p>Log4net：http://t.csdn.cn/1zAsR</p> 
<ol><li> <p>Nuget引入程序包</p> 
  <ul><li>microsoft.extensions.logging.log4net.aspnetcore</li><li>log4net</li></ul> <p><img src="https://images2.imgbox.com/23/cf/NIUvoXNV_o.png" alt="image-20221012133354774"></p> </li><li> <p>准备好配置文件 log4net.config</p> <pre><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;log4net&gt;
	&lt;!-- Define some output appenders --&gt;

	&lt;!--Type 表示用那种类型记录日志--&gt;
	&lt;appender name="rollingAppender" type="log4net.Appender.RollingFileAppender"&gt;
		&lt;!--表示用文本来记录日志--&gt;

		&lt;file value="log\log.txt" /&gt;
		&lt;!--&lt;file value="E:\Log4\log.txt" /&gt;--&gt;

		&lt;!--追加日志内容--&gt;
		&lt;!--&lt;appendToFile value="false" /&gt;--&gt;
		&lt;appendToFile value="true" /&gt;

		&lt;!--防止多线程时不能写Log,官方说线程非安全--&gt;
		&lt;lockingModel type="log4net.Appender.FileAppender+MinimalLock" /&gt;
		&lt;!--最小锁--&gt;

		&lt;!--配置Unicode编码--&gt;
		&lt;Encoding value="UTF-8" /&gt;

		&lt;!--是否只写到一个文件里--&gt;
		&lt;param name="StaticLogFileName" value="false" /&gt;

		&lt;!--当备份文件时,为文件名加的后缀,这里可以作为每一天的日志分别存储不同的文件--&gt;
		&lt;datePattern value="yyyyMMdd&amp;quot;.txt&amp;quot;" /&gt;

		&lt;!--可以为:Once|Size|Date|Composite--&gt;
		&lt;!--Composite为Size和Date的组合--&gt;
		&lt;!--&lt;rollingStyle value="Composite" /&gt;--&gt;
		&lt;rollingStyle value="Size" /&gt;

		&lt;!--日志最大个数,都是最新的--&gt;
		&lt;!--rollingStyle节点为Size时,只能有value个日志文件--&gt;
		&lt;!--rollingStyle节点为Composite时,每天有value个日志--&gt;
		&lt;maxSizeRollBackups value="2" /&gt;

		&lt;!--可用的单位:KB|MB|GB--&gt;
		&lt;maximumFileSize value="2MB" /&gt;

		&lt;!--置为true,当前最新日志文件名永远为file节中的名字--&gt;
		&lt;staticLogFileName value="true" /&gt;

		&lt;!--过滤器--&gt;

		&lt;!--阻止所有事件被记录--&gt;
		&lt;!--&lt;filter type="log4net.Filter.DenyAllFilter"&gt; &lt;/filter&gt;--&gt;

		&lt;!--只有指定等级的日志事件才被记录--&gt;
		&lt;!--&lt;filter type="log4net.Filter.LevelMatchFilter"&gt;
        &lt;param value="FATAL" /&gt;
      &lt;/filter&gt;--&gt;

		&lt;!--日志等级在指定范围内的事件才被记录--&gt;
		&lt;!--&lt;filter type="log4net.Filter.LevelRangeFilter"&gt;
        &lt;param name="LevelMin" value="ERROR" /&gt;
        &lt;param name="LevelMax" value="FATAL" /&gt;
      &lt;/filter&gt;--&gt;


		&lt;layout type="log4net.Layout.PatternLayout"&gt;
			&lt;!--日志输出格式：时间  日志类型  日志内容--&gt;
			&lt;conversionPattern value="%date [%thread] %-5level %logger - %message%newline"/&gt;
		&lt;/layout&gt;
	&lt;/appender&gt;

	&lt;!-- levels: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG  &gt; ALL --&gt;
	&lt;root&gt;
		&lt;priority value="ALL"/&gt;
		&lt;level value="ALL"/&gt;
		&lt;appender-ref ref="rollingAppender" /&gt;
	&lt;/root&gt;
&lt;/log4net&gt;
</code></pre> </li><li> <p>配置读取配置文件生效</p> <pre><code>//Nuget引入：
//1、Log4Net
//2、microsoft.extensions.logging.log4net.aspnetcore
builder.Logging.AddLog4Net("CfgFile/log4net.config");
</code></pre> <p><img src="https://images2.imgbox.com/59/3b/HhZJmDNt_o.png" alt="image-20221012134213135"></p> </li><li> <p>注入得到log4net实例开始写日志</p> </li></ol> 
<ul><li> <p>创建一个日志控制器Log4netController</p> <pre><code>using Microsoft.AspNetCore.Mvc;

namespace WebMvc.Controllers
{
    public class Log4netController : Controller
    {
        private readonly ILogger&lt;Log4netController&gt; _Logger;
        private readonly ILoggerFactory _LoggerFactory;
        public Log4netController(ILogger&lt;Log4netController&gt; logger,ILoggerFactory loggerFactory)
        {
            this._Logger = logger;
            this._Logger.LogInformation($"{this.GetType().Name}被构造了 ---&gt; _Logger");

            this._LoggerFactory = loggerFactory;
            ILogger &lt; Log4netController &gt;  _Logger2 =this._LoggerFactory.CreateLogger&lt;Log4netController&gt;();
            _Logger2.LogInformation($"{this.GetType().Name}被构造了  ---&gt; _Logger2");
        }
        public IActionResult Index()
        {
            ILogger&lt;Log4netController&gt; _Logger3 = this._LoggerFactory.CreateLogger&lt;Log4netController&gt;();
            _Logger3.LogInformation($"Index被执行了");
            this._Logger.LogInformation($"Index被执行了");
            return View();
        }
    }
}
</code></pre> </li><li> <p>创建一个Razor视图</p> <pre><code>@{
    ViewData["Title"] = "Index";
}
&lt;h1&gt;Index&lt;/h1&gt;
</code></pre> <p><img src="https://images2.imgbox.com/7f/15/Gk31GsP3_o.png" alt="image-20221012141818935"></p> </li><li> <p>访问页面，项目链接+控制器名字+index页面</p> <p><img src="https://images2.imgbox.com/19/f1/TT1K1lvJ_o.png" alt="image-20221012142005046"></p> </li><li> <p>生成日志</p> <p><img src="https://images2.imgbox.com/4e/3d/VDxVRWdY_o.png" alt="image-20221012142147507"></p> </li><li> <p>项目路径下生成日志文件</p> <p><img src="https://images2.imgbox.com/c9/56/h7FLbNTa_o.png" alt="image-20221012142221532"></p> </li></ul> 
<h5><a id="252_Log4netMysql_1865"></a>2.5.2 Log4net写Mysql（未实现）</h5> 
<p><strong>分析：可能是数据库没有连接上，日志一般不写入数据库，我也不深究了，这里仅仅是提供一个思路，在下面的webapi项目中我使用配置文件成功连接上了数据库，有兴趣的可以在下面的内容中学习并结合这里的知识去试一下！</strong></p> 
<p>Log4net写Mysql：http://t.csdn.cn/xhWIK，有需要的自己看链接文章即可</p> 
<ol><li> <p>引入nuget程序包Mysql.Data</p> <p><img src="https://images2.imgbox.com/2d/bd/xRfXMZxP_o.png" alt="image-20221012143931056"></p> </li><li> <p>在配置文件 log4net.config添加支持Mysql数据库的配置</p> <pre><code>&lt;!--name表示appender的name，随便取   type表示用什么类型记录日志    ADONetAppender代表用数据库记录--&gt;
	&lt;appender name="AdoNetAppender_Mysql" type="log4net.Appender.ADONetAppender"&gt;
		&lt;param name="ConnectionType" value="MySql.Data.MySqlClient.MySqlConnection, MySql.Data" /&gt;
		&lt;!--指定的数据库连接字符串--&gt;
		&lt;!--&lt;param name="ConnectionString" value="Server=127.0.0.1;port=3306;UserID=root;password=123456;database=webmvc;charset=utf8;Allow User Variables=True"/&gt;--&gt;
		&lt;param name="ConnectionString" value="Server=127.0.0.1;port=3306;UserID=root;password=123456;database=webmvc;charset=utf8mb4;Allow User Variables=True"/&gt;
		&lt;param name="CommandText" value="insert into log(datetime,thread,level,ogger,message,exception) values(@datetime, @thread , @level, @logger, @message,@exception)" /&gt;

		&lt;param name="Parameter"&gt;
			&lt;param name="ParameterName" value="@datetime" /&gt;
			&lt;param name="DbType" value="DateTime" /&gt;
			&lt;param name="Layout" type="log4net.Layout.PatternLayout"&gt;
				&lt;param name="ConversionPattern" value="%d{yyyy'-'MM'-'dd HH':'mm':'ss'.'fff}" /&gt;
			&lt;/param&gt;
		&lt;/param&gt;

		&lt;param name="Parameter"&gt;
			&lt;param name="ParameterName" value="@thread" /&gt;
			&lt;param name="DbType" value="longtext" /&gt;
			&lt;!--&lt;param name="Size" value="255" /&gt;--&gt;
			&lt;param name="Layout" type="log4net.Layout.PatternLayout"&gt;
				&lt;param name="ConversionPattern" value="%t" /&gt;
			&lt;/param&gt;
		&lt;/param&gt;
		&lt;param name="Parameter"&gt;
			&lt;param name="ParameterName" value="@level" /&gt;
			&lt;param name="DbType" value="longtext" /&gt;
			&lt;!--&lt;param name="Size" value="50" /&gt;--&gt;
			&lt;param name="Layout" type="log4net.Layout.PatternLayout"&gt;
				&lt;param name="ConversionPattern" value="%p" /&gt;
			&lt;/param&gt;
		&lt;/param&gt;
		&lt;param name="Parameter"&gt;
			&lt;param name="ParameterName" value="@logger" /&gt;
			&lt;param name="DbType" value="longtext" /&gt;
			&lt;!--&lt;param name="Size" value="255" /&gt;--&gt;
			&lt;param name="Layout" type="log4net.Layout.PatternLayout"&gt;
				&lt;param name="ConversionPattern" value="%c" /&gt;
			&lt;/param&gt;
		&lt;/param&gt;
		&lt;param name="Parameter"&gt;
			&lt;param name="ParameterName" value="@message" /&gt;
			&lt;param name="DbType" value="longtext" /&gt;
			&lt;!--&lt;param name="Size" value="10000" /&gt;--&gt;
			&lt;param name="Layout" type="log4net.Layout.PatternLayout"&gt;
				&lt;param name="ConversionPattern" value="%m" /&gt;
			&lt;/param&gt;
		&lt;/param&gt;
		&lt;param name="Parameter"&gt;
			&lt;param name="ParameterName" value="@exception" /&gt;
			&lt;param name="DbType" value="longtext" /&gt;
			&lt;!--&lt;param name="Size" value="10000" /&gt;--&gt;
			&lt;param name="Layout" type="log4net.Layout.PatternLayout"&gt;
				&lt;param name="ConversionPattern" value="%m" /&gt;
			&lt;/param&gt;
		&lt;/param&gt;

	&lt;/appender&gt;
</code></pre> <p>在最后的root中使配置内容生效</p> <pre><code>	&lt;!-- levels: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG  &gt; ALL --&gt;
	&lt;root&gt;
		&lt;priority value="ALL"/&gt;
		&lt;level value="ALL"/&gt;
		&lt;appender-ref ref="rollingAppender" /&gt;
		//使配置内容生效
		&lt;appender-ref ref="AdoNetAppender_Mysql" /&gt;
	&lt;/root&gt;
</code></pre> <p><img src="https://images2.imgbox.com/2f/26/InYg9QIE_o.png" alt="image-20221012145616897"></p> </li></ol> 
<h3><a id="Web_API_1953"></a>三、Web API</h3> 
<h4><a id="31_WebApi_1955"></a>3.1 两种不同的WebApi项目创建</h4> 
<h5><a id="311_WebApi_1957"></a>3.1.1 如何创建WebApi项目（一）</h5> 
<ol><li> <p>选择创建web 应用程序</p> <p><img src="https://images2.imgbox.com/5a/87/aMh3ZvTL_o.png" alt="image-20221017151841194"></p> </li><li> <p>命名</p> <p><img src="https://images2.imgbox.com/ee/59/TfZFlIcD_o.png" alt="image-20221017152024009"></p> </li><li> <p>选择Web API，点击创建即可</p> <p><img src="https://images2.imgbox.com/a1/e5/0lAknknT_o.png" alt="image-20221017152229955"></p> </li><li> <p>生成如下页面</p> <p><img src="https://images2.imgbox.com/62/c9/uswnHcVH_o.png" alt="image-20221019170509414"></p> </li><li> <p>点击运行得到如下页面</p> <p><img src="https://images2.imgbox.com/dc/6f/7ZIpjcbo_o.png" alt="image-20221019171625334"></p> </li></ol> 
<h5><a id="312_WebApi_1979"></a>3.1.2 如何创建WebApi项目（二）</h5> 
<ol><li> <p>直接选择webapi</p> <p><img src="https://images2.imgbox.com/af/b8/g3pZDG3k_o.png" alt="image-20221019170748686"></p> </li><li> <p>命名</p> <p><img src="https://images2.imgbox.com/2d/06/450wHYEg_o.png" alt="image-20221019170850232"></p> </li><li> <p>下一步创建即可</p> <p><img src="https://images2.imgbox.com/aa/2d/0pqnjoxG_o.png" alt="image-20221019170909384"></p> </li><li> <p>生成如下页面</p> <p><img src="https://images2.imgbox.com/8a/ac/dRGn3tPG_o.png" alt="image-20221019171338077"></p> </li><li> <p>点击运行得到如下页面</p> <p><img src="https://images2.imgbox.com/63/b5/Xkz3NJMF_o.png" alt="image-20221019171840766"></p> </li><li> <p>将上面标记的链接在浏览器打开，得到如下页面内容</p> <p><img src="https://images2.imgbox.com/62/64/TylzTvHb_o.png" alt="image-20221019171959431"></p> </li></ol> 
<h5><a id="313_WebApi_2005"></a>3.1.3 两种WebApi项目的区别</h5> 
<p><strong>第一种项目包含模型、视图、控制器等，类似于MVC项目（与MVC项目的区别是：MVC项目是带Razor视图的），其Controller类继承的是Controller类</strong></p> 
<p><img src="https://images2.imgbox.com/a4/04/XlTDq9Mr_o.png" alt="image-20221020190151220"></p> 
<p><strong>第二种项目只能写Web Api，因为其Controller类继承的是ControllerBase基类，所以只支持写WebApi项目</strong></p> 
<p><img src="https://images2.imgbox.com/58/c4/2tLbmCnP_o.png" alt="image-20221020190534637"></p> 
<p><strong>小知识：</strong></p> 
<ol><li> <p>Controller类继承于ControllerBase，是其子类，在Controller类中提供了一些操作View（视图）的方法</p> <p><img src="https://images2.imgbox.com/2b/f2/wcMLLGJ0_o.png" alt="image-20221020190847253"></p> </li><li> <p>ControllerBase类中没有支持View的方法，所以只能写Web Api</p> <p><img src="https://images2.imgbox.com/82/2f/KrGMHn1z_o.png" alt="image-20221020191000519"></p> </li></ol> 
<h4><a id="32_Restful_2025"></a>3.2 Restful、参数传递和返回值</h4> 
<ol><li> <p>WebAPI是一种用来开发系统间接口、设备接口API的技术，基于Http协议，请求和返回格式结果默认是json格式<br> 比 WCF 更简单、更通用，比 WebService更节省流量、更简洁。</p> </li><li> <p>WebAPI和普通ASP.Net MVC的区别:<br> WebAPl是开发接口的技术，用户不会直接和WebAPI打交道，因此WebAPI也不会生成界面</p> </li><li> <p>特点:<br> a. webapi的Action方法返回值直接返回对象，专注于数据</p> </li></ol> 
<p>​ b. webapi更符合Restful的风格</p> 
<p>​ c．有利于独立于lIS部署(selfhost、winform、windows service、控制台)</p> 
<p>​ d. Action可以直接声明为async</p> 
<ol start="4"><li>Restful风格(接口设计按照Http谓词语义设计)</li></ol> 
<p>​ 基于“Http谓词语义”进行通讯协议的设计，带来的好处：</p> 
<p>​ i.可以为不同类型做不同的权限控制;</p> 
<p>​ ii.不再需要“Delete”. “AddNew”这样的Action名字，根据请求的类型就可以判断．</p> 
<p>​ iii.返回报文的格式也确定，不用再约定返回状态码，充分利用Http状态码</p> 
<p>​ iv.有利于系统优化，浏览器可以自动缓存Get请求</p> 
<p>​ v. Get没有副作用，是幂等的（1的任何次方都是1），可以重试</p> 
<ol start="5"><li>Web API入门+&lt;&gt;RESTED（一个谷歌插件，可自行下载）</li></ol> 
<p>a．提交方式</p> 
<p>b. 报文头 参数接收</p> 
<p>c. 报文体 [FormBody]参数接收</p> 
<p>d. 默认路由规则=》api/{controller}/{action}/{id}</p> 
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Web.Http;

namespace WebAPITest
{
  public static class WebApiConfig
  {
      public static void Register(HttpConfiguration config)
      {
          // Web API 配置和服务

          // Web API 路由
          config.MapHttpAttributeRoutes();

          config.Routes.MapHttpRoute(
              name: "DefaultApi",
              routeTemplate: "api/{controller}/{id}",        //这是自动生成的！
              //routeTemplate: "api/{controller}/{action}/{id}",//实际开发中使用最多的就是这个，action：方法名
              defaults: new { id = RouteParameter.Optional }
          );
      }
  }
}
</code></pre> 
<p><img src="https://images2.imgbox.com/59/12/IuN4iZ79_o.png" alt="image-20221012185105148"></p> 
<ol start="6"><li> <p>Web API的参数，接收参数的方法大概以下几种：</p> <pre><code>FromBody  // application/json
FromForm  //前端的默认消息类型
FromHeader //从请求头里获取
FromQuery //从参数里获取
FromRoute //从路由中获取
FromServices//这个Jwt篇讲解
</code></pre> </li></ol> 
<p>a. GET</p> 
<pre><code>      // 示例：GET api/values
      [HttpGet]
      public IEnumerable&lt;string&gt; Get()
      {
          return new string[] { "value1", "value2" };
      }

      // 示例：GET api/values/5
      [HttpGet]
      public string Get(int id)
      {
          return "value";
      }
</code></pre> 
<ul><li>public string Login([FromUri]LoginModel model)</li></ul> 
<pre><code>    public class Login
    {
        public string Name { get; set; }
        public string Pwd { get; set; }
    }
</code></pre> 
<pre><code>        //GET api/values/login?name=张三&amp;pwd=123456
        [HttpGet]
        public IEnumerable&lt;string&gt; Login([FromUri] Login login)
        {
            return new string[] { login.Name,login.Pwd};
        }
</code></pre> 
<p><img src="https://images2.imgbox.com/77/ce/KykFFuPP_o.png" alt="image-20221017161332540"></p> 
<p>b. POST</p> 
<pre><code>      // 示例：POST api/values
      [HttpPost]
      public string Post([FromBody] string value)
      {
          return "添加成功";
      }
</code></pre> 
<ul><li>接收参数是name=zhangsan&amp;pwd=5</li></ul> 
<p>​ i. public string AddNew2(LoginModel model)</p> 
<p>​ ii. public string AddNew2([FromBody]LoginModel model)</p> 
<pre><code>        //POST api/values/LoginPost1
        [HttpPost]
        public void LoginPost1(Login login)
        {
            
        }
        [HttpPost]
        public void LoginPost2([FromBody] Login login)
        {

        }
</code></pre> 
<p><img src="https://images2.imgbox.com/64/f2/Q3Vne1mg_o.png" alt="image-20221017162633980"></p> 
<ul><li> <p>提交的数据是ContentType=" application/json”方式提交</p> <p>i. 即参数设置成报文体{userName:“admin3”,password:“123”)</p> <p>ii. 参数也可以用模型对象</p> </li></ul> 
<p>c.PUT</p> 
<pre><code>      // 示例：PUT api/values/5
      [HttpPut]
      public string Put(int id, [FromBody] string value)
      {
          return "修改成功" + id;
      } 
</code></pre> 
<p>d.DELETE</p> 
<pre><code>      // 示例：DELETE api/values/5
      [HttpDelete]
      public string Delete(int id)
      {
          return "删除成功";
      }
</code></pre> 
<p>e．通过自定义路由规则来捕获参数(get、post都适用)</p> 
<p>i. WebAPI可以通过[Route]和[RoutePrefix]来自定义路由</p> 
<p>ii. [RoutePrefix]作用于Controller例:[RoutePrefix( "api/Person”)]</p> 
<p>iii. [Route]作用于Action 例 : [Route(“GetByld2”)]<br> iv．例如:</p> 
<ol><li> <p>[Route(“Login/{phoneNum}/{password}”)] 自定义路由</p> </li><li> <p>[HttpPost]</p> </li><li> <p>public string Login(string phoneNum, string password)</p> </li><li> <p>可以通过/Login/33/44访问</p> <pre><code>//示例：可以通过https://localhost:44386/Login/22/33访问  
[Route("Login/{phoneNum}/{password}")]
[HttpPost]
public string Login(string phoneNum,string password){
    return phoneNum + password;
}
</code></pre> <p><img src="https://images2.imgbox.com/3a/eb/pwJWsxz1_o.png" alt="image-20221012182907451"></p> </li></ol> 
<p><strong>状态码：</strong></p> 
<p>2开头：成功（例：200，有返回结果；204，无返回结果）</p> 
<p>3开头：都是错</p> 
<p>4开头：服务器报错</p> 
<p>5开头：代码报错</p> 
<p>Status code</p> 
<p>http status code是reponse的一部分,它提供了这些信息:请求是否成功,失败的原因</p> 
<p>web api能涉及到的status codes主要是这些:</p> 
<p>200: OK</p> 
<p>201: Created,创建了新的资源</p> 
<p>204:无内容No Content,例如删除成功</p> 
<p>400: Bad Request,指的是客户端的请求错误</p> 
<p>401:未授权Unauthorized</p> 
<p>403:禁止操作Forbidden.验证成功,但是没法访问相应的资源404: Not Found</p> 
<p>409:有冲突Conflict.</p> 
<p>500: Internal Server Error,服务器发生了错误</p> 
<ol start="7"><li>Web API的返回值</li></ol> 
<p>a.普通类型（默认GET请求）</p> 
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Web.Http;

namespace WebAPITest
{
  public static class WebApiConfig
  {
      public static void Register(HttpConfiguration config)
      {
          // Web API 配置和服务

          // Web API 路由
          config.MapHttpAttributeRoutes();

          config.Routes.MapHttpRoute(
              name: "DefaultApi",
              //routeTemplate: "api/{controller}/{id}",        //这是自动生成的！
              //自定义默认路由
              routeTemplate: "api/{controller}/{action}/{id}", //实际开发中使用最多的就是这个，action：方法名
              defaults: new { id = RouteParameter.Optional }
          );
      }
  }
}
</code></pre> 
<pre><code>      //普通类型
      public string GetString()
      {
          return "";
      }
</code></pre> 
<p><img src="https://images2.imgbox.com/a4/49/J6cze6fz_o.png" alt="image-20221012185840671"></p> 
<p>b. void，这样客户端会得到204的状态码，尽量别这样干（没拿到结果的成功)</p> 
<p>c. lHttpActionResult类型</p> 
<p>i.可以调用ApiController 中的Ok)、NotFound()、Json(new {a=1,b=2})、Content()、Redirect()等方法。</p> 
<pre><code>        //IIHttpActionResult类型
        public IHttpActionResult GetHttpActionResult()
        {
            return Json(new {a=1,b=2,c=3});
        }
</code></pre> 
<p>d. HttpResponseMessage</p> 
<p>i、可以做更精细化的返回内容控制，比如返回二进制文件、设置返回报文头</p> 
<p>ii．例如:</p> 
<pre><code>[HttpPost]
public HttpResponseMessage Test()
{
  HttpContent httpContent = new StringContent("hello");
  return new HttpResponseMessage { Content= httpContent ,StatusCode= HttpStatusCode.OK};
}
</code></pre> 
<ol start="8"><li> <p>Web API的异常处理</p> <p>a. ASP.Net Web API错误处理:对于Action 中的异常，默认就是返回500状态码，报文体是Json格式这样也是最好的</p> <p>b.对于“ld不存在”、“年龄不合法”等这类的错误既可以通过自动以状态码的方式返回(不太够用)，也可以自定义下面这种类型作为返回值(然后在文档中约定:О代表成功、1代表用户名不能为空、2代表金额超限)</p> <pre><code>        //Web Api 的异常处理
        //a.默认就是返回500状态码，报文体是Json格式
        public string GetError(int id)
        {
            if (id == 0)
            {
                throw new Exception("这是一个错误");
            }
            else
            {
                return "我是" + id;
            }
        }
        //b.业务报错处理,对于“ld不存在”、“年龄不合法”等这类的错误既可以通过自动以状态码的方式返回(不太够用)，也可以自定义下面这种类型作为返回值(然后在文档中约定:О代表成功、1代表用户名不能为空、2代表金额超限)
        public class ApiResult&lt;T&gt;
        {
            public int Code { get; set; }
            public string Message { get; set; }
            public T Value { get; set; }
        }
        public ApiResult&lt;string&gt; GetApiResult(int id)
        {
            if (id == 0)
            {
                return new ApiResult&lt;string&gt; { Message = "出错了" };
            }
            else
            {
                return new ApiResult&lt;string&gt; { Message = "对了" };
            }
        }
        //c.未处理异常的处理IExceptionFilter、WebApiConfig中config.Filter.Add(new ExceptionFilter());
        public string GetExceptionFilter(int id)
        {
            int a = id / 0;
            return "等于" + a;
        }
</code></pre> </li><li> <p>将报错信息写入错误文本</p> <p>（1）自定义类</p> <pre><code>using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using System.Web.Http.Filters;

namespace WebAPITest
{
    //自定义类继承异常过滤器,在WebApiConfig中实现
    public class ExceptionFilter : IExceptionFilter
    {
        public bool AllowMultiple =&gt; false;

        public async Task ExecuteExceptionFilterAsync(HttpActionExecutedContext actionExecutedContext, CancellationToken cancellationToken)
        {
            //throw new NotImplementedException();
            using (StreamWriter writer = File.AppendText("E:/error.txt"))
            {
                await writer.WriteLineAsync(actionExecutedContext.Exception.ToString());
            }
        }
    }
}
</code></pre> <p>（2）在WebApiConfig类中实现</p> <pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Web.Http;

namespace WebAPITest
{
    public static class WebApiConfig
    {
        public static void Register(HttpConfiguration config)
        {
            // Web API 配置和服务

            // Web API 路由
            config.MapHttpAttributeRoutes();

            config.Routes.MapHttpRoute(
                name: "DefaultApi",
                //routeTemplate: "api/{controller}/{id}",  //默认路由匹配规则
                routeTemplate: "api/{controller}/{action}/{id}",   //自定义路由匹配规则：实际开发中使用最多的就是这个，action：方法名
                defaults: new { id = RouteParameter.Optional }
            );
            //异常处理
            config.Filters.Add(new ExceptionFilter());
        }
    }
}
</code></pre> <p><img src="https://images2.imgbox.com/73/a4/jowzP14U_o.png" alt="image-20221017173420820"></p> </li><li> <p>Web API的多版本管理<br> a.旧版接口做一个代码分支，除了进行 bug修改外，旧版本接口不再做改动;新接口代码继续演化升级.在客户端请求的时候带着要请求的接口版本号，在服务器端选择合适的版本代码进行处理。<br> b.技术处理方法<br> i.(最推荐）不同版本用不同的域名: v1.api.tgh.com 、 v2.api.tgh.com 、 v3…<br> ii.在url、报文头等中带不同的版本信息，用Nginx等做反向代理服务器，然后将http://api.tgh.com/api/v1/User/1和http://api.tgh.com/api/v2/User/1转到不同的服务器处理<br> iii.多个版本的Controller共处在一个项目中，然后使用[RoutePrefix]或者llttpControllerSelector根据报文头、路径等选择不同的Controller 执行</p> </li></ol> 
<h4><a id="33_ASPNETWeb_API_2464"></a>3.3 基于ASP.NET的Web API</h4> 
<p><strong>Web API连接mysql数据库</strong></p> 
<p>HUI前端框架：http://www.h-ui.net/</p> 
<ol><li> <p>启动 Visual Studio ，在开始页里选择“新建项目”。或者从“文件”菜单里，选择“新建项目”。选择ASP .NET Web 应用程序</p> <p><img src="https://images2.imgbox.com/88/09/29lRbLej_o.png" alt="image-20221018110753911"></p> </li><li> <p>输入项目名称</p> <p><img src="https://images2.imgbox.com/90/e5/X4IIYoYb_o.png" alt="image-20221018111005978"></p> </li><li> <p>选择web api创建即可</p> <p><img src="https://images2.imgbox.com/1f/3f/79qjw9kL_o.png" alt="image-20221018111058406"></p> </li><li> <p>得到如下页面</p> <p><img src="https://images2.imgbox.com/4c/bf/DGiVCBMS_o.png" alt="image-20221018111145244"></p> </li><li> <p>在Model文件夹下新建Users类</p> <p><img src="https://images2.imgbox.com/93/c6/HKdZtROM_o.png" alt="image-20221018111406388"></p> <pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;

namespace WebApiMysql.Models
{
    public class Users

    {
        public int UserID { get; set; }

        public string UserName { get; set; }

        public string UserEmail { get; set; }

    }
}
</code></pre> </li><li> <p>然后就可以添加控制器了，控制器就是控制层，在“Controllers”下有一个“HomeController.cs”的文件，它是一个传统的 ASP.NET MVC 控制器。它只是负责处理站点的HTML页，跟Web API没有直接关系。这里需要手动添加一个API控制器</p> <p><img src="https://images2.imgbox.com/74/70/iH1KXYwi_o.png" alt="image-20221018112149897"></p> <p><img src="https://images2.imgbox.com/89/db/WqQGCUYw_o.png" alt="image-20221018111816926"></p> </li><li> <p>给控制器命名</p> <p><img src="https://images2.imgbox.com/8e/a9/Xeo3PE2i_o.png" alt="image-20221018111844268"></p> </li><li> <p>向控制器中加入以下代码</p> <pre><code>public class UsersController : ApiController
    {
        //MySqlConnection对象是一个数据库连接对象，主要功能是建立与物理数据库的连接；简单来说，就是连接到本机数据库的一个对象
        private static MySqlConnection getMySqlConnection()
        {
            MySqlConnection mysql = new MySqlConnection(ConfigurationManager.ConnectionStrings["MySqlConnection"].ConnectionString);
            return mysql;
        }
        //MySqlCommand对象是一个数据命令对象，主要功能是向数据库发送增删改查操作的语句
        public static MySqlCommand getSqlCommand(String sql, MySqlConnection mysql)
        {
            MySqlCommand mySqlCommand = new MySqlCommand(sql, mysql);

            return mySqlCommand;
        }
        // GET api/users/Get
        /// &lt;summary&gt;
        /// 查找所有用户
        /// &lt;/summary&gt;
        /// &lt;returns&gt;返回查找到的所有用户集&lt;/returns&gt;
        /// &lt;exception cref="HttpResponseException"&gt;&lt;/exception&gt;
        [HttpGet]
        public IEnumerable&lt;Users&gt; Get()
        {
            List&lt;Users&gt; listUser = new List&lt;Users&gt;();
            MySqlConnection mysql = getMySqlConnection();
            MySqlCommand mySqlCommand = getSqlCommand("select * from user", mysql);
            mysql.Open();
            //用MySqlDataReader对象读取数据
            MySqlDataReader reader = mySqlCommand.ExecuteReader();
            try
            {
                while (reader.Read())
                {
                    if (reader.HasRows)
                    {
                        Users user = new Users();
                        user.UserID = reader.GetInt32("UserID");
                        user.UserName = reader.GetString("username");
                        user.UserEmail = reader.GetString("useremail");
                        listUser.Add(user);
                    }
                }
            }
            catch
            {
                throw new HttpResponseException(HttpStatusCode.NotFound);
            }
            finally
            {
                mysql.Close();
            }
            return listUser;
        }
        // GET api/Users/GetUserByID/2
        /// &lt;summary&gt;
        /// 根据id查询用户
        /// &lt;/summary&gt;
        /// &lt;param name="id"&gt;用户id&lt;/param&gt;
        /// &lt;returns&gt;返回一个用户&lt;/returns&gt;
        /// &lt;exception cref="HttpResponseException"&gt;&lt;/exception&gt;
        [HttpGet]
        public Users GetUserByID(int id)
        {
            Users user = new Users();
            MySqlConnection mysql = getMySqlConnection();
            MySqlCommand mySqlCommand = getSqlCommand("select * from USER where UserID=" + id, mysql);
            mysql.Open();
            MySqlDataReader reader = mySqlCommand.ExecuteReader();
            try
            {
                while (reader.Read())
                {
                    if (reader.HasRows)
                    {
                        user.UserID = reader.GetInt32(0);
                        user.UserName = reader.GetString(1);
                        user.UserEmail = reader.GetString(2);
                    }
                }
                reader.Close();
            }
            catch
            {
                throw new HttpResponseException(HttpStatusCode.NotFound);
            }
            finally
            {
                mysql.Close();
            }

            return user;
        }
        //GET api/Users/GetUserByName/?username=xx
        /// &lt;summary&gt;
        /// 根据用户名查找用户
        /// &lt;/summary&gt;
        /// &lt;param name="userName"&gt;用户名&lt;/param&gt;
        /// &lt;returns&gt;返回一个查找结果集&lt;/returns&gt;
        /// &lt;exception cref="HttpResponseException"&gt;&lt;/exception&gt;
        [HttpGet]
        public IEnumerable&lt;Users&gt; GetUserByName(string userName)
        {
            List&lt;Users&gt; listuser = new List&lt;Users&gt;();
            MySqlConnection mysql = getMySqlConnection();
            MySqlCommand mySqlCommand = getSqlCommand("select * from USER where username like'%" + userName + "%'", mysql);
            mysql.Open();
            MySqlDataReader reader = mySqlCommand.ExecuteReader();
            try
            {
                while (reader.Read())
                {
                    if (reader.HasRows)
                    {
                        Users user = new Users();
                        user.UserID = reader.GetInt32("UserID");
                        user.UserName = reader.GetString("USERNAME");
                        user.UserEmail = reader.GetString("USEREMAIL");
                        listuser.Add(user);
                    }

                }
                reader.Close();
            }
            catch
            {
                throw new HttpResponseException(HttpStatusCode.NotFound);
            }
            finally
            {
                mysql.Close();
            }
            return listuser;
        }
        // POST api/Users/AddUser
        public void Post([FromBody] string value)
        {
        }
        // PUT api/Users/
        public void Put(int id, [FromBody] string value)
        {
        }
        // DELETE api/Users/
        public void Delete(int id)
        {
        }
    }
</code></pre> <p>此处会报错，跟着下面的步骤走就能解决（一键导包：Alt + Enter）：</p> <p>（1）Users报错，导包即可</p> <p><img src="https://images2.imgbox.com/85/3e/PlZ78Gml_o.png" alt="image-20221018112413917"></p> <p>（2）MySqlConnection报错，安装Mysql.Data包</p> <p><img src="https://images2.imgbox.com/5e/e7/wLhZJsQZ_o.png" alt="image-20221018112710755"></p> <p><img src="https://images2.imgbox.com/58/29/9s4tyNaR_o.png" alt="image-20221018112911007"></p> <p><img src="https://images2.imgbox.com/c3/7d/PZLa9dc2_o.png" alt="image-20221018113311935"></p> <p>（3）ConfigurationManager报错，这里也是导包就行</p> <p><img src="https://images2.imgbox.com/be/bb/3zFFFIKQ_o.png" alt="image-20221018113455502"></p> </li><li> <p>UsersController处代码，主要补充了Get方法的逻辑。数据从mysql数据库中获取。例中MySql对应user表中数据如下</p> <p><img src="https://images2.imgbox.com/9a/c4/jKQC8ImM_o.png" alt="image-20221018113904237"></p> <p>获取数据共写了三个get方法，第一个是获取所有user数据，第二个根据Users 的ID获取对应Users，第三个根据UserName获取Users。为了能够通过MySql获取数据，需要在Web.config的节点中添加 ；name为connectionString对应名称，connectionString中为连接mysql的配置；代码中通过ConfigurationManager.ConnectionStrings[“name”].ConnectionString获取mysql配置。</p> <p><img src="https://images2.imgbox.com/79/79/Kd20O0y1_o.png" alt="image-20221018114112901"></p> <pre><code>	&lt;connectionStrings&gt;
		&lt;!--mysql数据库连接配置--&gt;
		&lt;add name="MySqlConnection" providerName="System.Data.SqlClient" connectionString="server=127.0.0.1;database=webapi;port=3306;Userid=root;Password=123456"/&gt;
	&lt;/connectionStrings&gt;
</code></pre> </li><li> <p>完成代码编写后，启动项目即可对进行代码测试。这里使用的是一个谷歌插件RESTED，可自行下载</p> <p><img src="https://images2.imgbox.com/ec/3b/2trHolIE_o.png" alt="image-20221018114320091"></p> <p>使用Web api进行访问</p> <p><img src="https://images2.imgbox.com/d5/51/zCAIqksQ_o.png" alt="image-20221018114548276"></p> <p>即可查询</p> <p><img src="https://images2.imgbox.com/17/6f/LrCUOGz9_o.png" alt="image-20221018114742194"></p> </li></ol> 
<h4><a id="34_SwaggerWeb_API_2718"></a>3.4 基于Swagger的Web API</h4> 
<h5><a id="341_Swagger_2720"></a>3.4.1 Swagger简单配置</h5> 
<p><strong>文档注释配置</strong></p> 
<ol><li> <p>配置前</p> <p><img src="https://images2.imgbox.com/9c/21/BYcMRCqM_o.png" alt="image-20221019181254434"></p> </li><li> <p>开启生成包含API文档的文件功能</p> <p>方法一：</p> <p><img src="https://images2.imgbox.com/78/5f/PzVFSw7W_o.png" alt="image-20221019183145597"></p> <p>方法二：</p> <p><img src="https://images2.imgbox.com/93/30/hDfur8bN_o.png" alt="image-20221019183415148"></p> </li><li> <p>在Program类中增加如下代码</p> <pre><code>builder.Services.AddSwaggerGen(options =&gt;
{
    //注释
    var xmlFileName = $"{Assembly.GetExecutingAssembly().GetName().Name}.xml";
    //第二个参数为是否显示控制器注释，我选择true
    options.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory,xmlFileName),true);
});
</code></pre> <p><img src="https://images2.imgbox.com/e9/b1/8MwLtkpR_o.png" alt="image-20221019184532171"></p> </li><li> <p>在Controller类中增加文档注释（其他类中增加了也可以看到）</p> <p><img src="https://images2.imgbox.com/a2/6a/StSugjxb_o.png" alt="image-20221019184634218"></p> </li><li> <p>启动项目即可看到文档注释</p> <p>控制器类注释：</p> <p><img src="https://images2.imgbox.com/61/0a/Yb9fXYtA_o.png" alt="image-20221019184722119"></p> <p>实体类注释：</p> <p><img src="https://images2.imgbox.com/72/f5/Obbyk3bz_o.png" alt="image-20221019185523512"></p> </li><li> <p>注意</p> <p><img src="https://images2.imgbox.com/5a/87/wE0K84ZR_o.png" alt="image-20221019190030582"></p> <p>需要修改为如下才会显示：</p> <p><img src="https://images2.imgbox.com/60/b9/2u9ePh2w_o.png" alt="image-20221019190214416"></p> </li></ol> 
<p><strong>返回数据的时间格式化</strong></p> 
<ol><li> <p>安装包microsoft.aspnetcore.mvc.newtonsoftjson</p> <p><img src="https://images2.imgbox.com/1d/99/9PWvPMZ6_o.png" alt="image-20221019183604727"></p> </li><li> <p>格式化之前：</p> <p><img src="https://images2.imgbox.com/81/ed/U9Noop2V_o.png" alt="image-20221019183914526"></p> <p>进行格式化：</p> <p>（1）在Program类中增加如下代码</p> <pre><code>builder.Services.AddControllers().AddNewtonsoftJson(options =&gt;
{
    options.SerializerSettings.DateFormatString = "yyyy-MM-dd HH:mm:ss";
});
</code></pre> <p><img src="https://images2.imgbox.com/9e/07/RP6HVAz1_o.png" alt="image-20221019184017524"></p> <p>（2）格式化后</p> <p><img src="https://images2.imgbox.com/65/1a/e3AQkw02_o.png" alt="image-20221019184138893"></p> </li></ol> 
<p>​ <strong>Api版本管理</strong></p> 
<ol><li> <p>下图中可以构建不同的版本</p> <p><img src="https://images2.imgbox.com/49/3b/5y1l5s7Q_o.png" alt="image-20221020100210839"></p> </li><li> <p>在Program类中添加如下代码</p> <pre><code>//生成多个文档显示
    typeof(ApiVersions).GetEnumNames().ToList().ForEach(version =&gt;
    {
        //添加文档介绍
        options.SwaggerDoc(version, new Microsoft.OpenApi.Models.OpenApiInfo
        {
            Title = $"项目名",
            Version = version,
            Description = $"项目名:{version}版本"
        });
    });
</code></pre> <p><img src="https://images2.imgbox.com/94/05/JXvEbinI_o.png" alt="image-20221020101344513"></p> <pre><code>app.UseSwaggerUI(options =&gt;
    {
        //options.SwaggerEndpoint($"/swagger/V1/swagger.json",$"版本选择：V1");
        //如果只有一个版本也要和上方保持一致
        typeof(ApiVersions).GetEnumNames().ToList().ForEach(version =&gt;
        {
            //切换版本操作
            //参数一时使用的哪个json文件，参数二就是个名{字
            options.SwaggerEndpoint($"/swagger/{version}/swagger.json", $"版本选择：{version}");
        });
    });
</code></pre> <p><img src="https://images2.imgbox.com/fb/2f/2QnomRR3_o.png" alt="image-20221020102008942"></p> </li><li> <p>最后在控制器方法上表明它是属于哪个版本的特性</p> <pre><code>[ApiExplorerSettings(GroupName ="V1")]  //如果不加，则默认两个版本都有；加上就是某个版本独有
</code></pre> <p><img src="https://images2.imgbox.com/9f/c7/9gJLk9xR_o.png" alt="image-20221020102939452"></p> <p><img src="https://images2.imgbox.com/1a/d0/eHgxd2hh_o.png" alt="image-20221020103102113"></p> </li><li> <p>切换回单版本</p> <p>修改一下代码就行：</p> <pre><code>    //单版本显示
    options.SwaggerDoc("V1", new Microsoft.OpenApi.Models.OpenApiInfo
    {
        Title = $"项目名",
        Version = "V1",
        Description = $"项目名:V1版本"
    });

    //生成多个版本显示，获取枚举类中的每个枚举的名字
    //typeof(ApiVersions).GetEnumNames().ToList().ForEach(version =&gt;
    //{
    //    //添加文档介绍
    //    options.SwaggerDoc(version, new Microsoft.OpenApi.Models.OpenApiInfo
    //    {
    //        Title = $"项目名",
    //        Version = version,
    //        Description = $"项目名:{version}版本"
    //    });
    //});
    
    //单版本显示
    options.SwaggerEndpoint($"/swagger/V1/swagger.json",$"版本选择：V1");

    //生成多个版本显示，如果只有一个版本要和上方保持一致
    //typeof(ApiVersions).GetEnumNames().ToList().ForEach(version =&gt;
    //{
    //    //切换版本操作
    //    //参数一时使用的哪个json文件，参数二就是个名字
    //    options.SwaggerEndpoint($"/swagger/{version}/swagger.json", $"版本选择：{version}");
    //});
</code></pre> <p><img src="https://images2.imgbox.com/f5/a1/ZL168AlA_o.png" alt="image-20221020103555321"></p> </li></ol> 
<h5><a id="342__2890"></a>3.4.2 入口文件和配置文件</h5> 
<p><strong>Program类（入口文件）</strong></p> 
<p>从上到下，依次执行</p> 
<p>从 C# 9 开始，无需在应用程序项目中的Program显式包含 <code>Main</code> 方法。</p> 
<p>IOC容器：</p> 
<pre><code>new object();

var x = new object();

x.xxx;
</code></pre> 
<p>有了IOC就不需要new对象了，直接提前进行注入</p> 
<p>依赖注入：</p> 
<pre><code>        /// &lt;summary&gt;
        /// 构造函数
        /// &lt;/summary&gt;
        /// &lt;param name="logger"&gt;&lt;/param&gt;
        public WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger)
        {
            _logger = logger;
        }
</code></pre> 
<p>直接给构造函数传一个需要的参数，由IOC容器去创建，我直接使用就行了</p> 
<p>入口文件中注册服务就是使用的这种思想！</p> 
<p><strong>使用配置文件</strong></p> 
<p>appsettings.json</p> 
<pre><code>{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "a": "1",
  "User": {
    "UserName": "张三",
    "Age": 18
  }
}
</code></pre> 
<p>在Program类中编写如下代码</p> 
<pre><code>var Logging = builder.Configuration["Logging"];   //获取一级目录
var AllowedHosts = builder.Configuration["AllowedHosts"];   //获取AllowedHosts的值
var Default = builder.Configuration["Logging:LogLevel:Default"];  //获取Logging:LogLevel:Default的值
var a = builder.Configuration["a"]; //获取a的值
var inta = builder.Configuration.GetValue&lt;int&gt;("a"); //获取a的值并转换为int类型
//获取并序列化为某某类型   Configuration.GetSection("xxx").Get&lt;某某类型&gt;();
var user = builder.Configuration.GetSection("User").Get&lt;User&gt;();
</code></pre> 
<p><img src="https://images2.imgbox.com/d6/5e/9b0HNX73_o.png" alt="image-20221020155549226"></p> 
<p>新建User类</p> 
<pre><code>public class User
    {
        public string UserName { get; set; }
        public int Age { get; set; }
    }
</code></pre> 
<p>在控制器类中进行注入</p> 
<p><img src="https://images2.imgbox.com/83/ec/Rq4ZC2jz_o.png" alt="image-20221020155850124"></p> 
<h5><a id="343__2976"></a>3.4.3 三层架构</h5> 
<p>三层架构就是为了符合“高内聚，低耦合”思想，把各个功能模块划分为表示层（UI）、业务逻辑层（BLL）和数据访问层（DAL）三层架构，各层之间采用接口相互访问，并通过对象模型的实体类（Model）作为数据传递的载体，不同的对象模型的实体类一般对应于数据库的不同表，实体类的属性与数据库表的字段名一致。</p> 
<p><img src="https://images2.imgbox.com/17/c0/usaGlR37_o.png" alt="image-20221020172956016"></p> 
<p>根据以上依赖模型依次添加项目引用（这里做一个示范）：</p> 
<p><img src="https://images2.imgbox.com/9c/b7/OjHaPHEx_o.png" alt="image-20221020173300656"></p> 
<p><img src="https://images2.imgbox.com/c9/e7/YPLozF4S_o.png" alt="image-20221020173328704"></p> 
<h5><a id="345_Web_Api__2988"></a>3.4.5 Web Api 实战</h5> 
<h6><a id="3451_Web_Apimysql_2990"></a>3.4.5.1 Web Api连接mysql数据库</h6> 
<ol><li> <p>建一个web api项目，项目开始之前需要导入的包，不导入包可能迁移不会成功（必须导入！！！）</p> <p><img src="https://images2.imgbox.com/80/3d/vy4drNMR_o.png" alt="image-20221021183316746"></p> </li><li> <p>根据DB First方法（详见本人博客：http://t.csdn.cn/SWVoM 11.3.2）连接数据库（如有问题可私信博主，有时间可提供帮助）</p> <p><img src="https://images2.imgbox.com/de/0c/yQ6VWpa8_o.png" alt="image-20221021110405939"></p> </li><li> <p>需要用到的ApplicationDbContext类和实体类</p> <pre><code>using Microsoft.EntityFrameworkCore;

namespace Models
{
    /// &lt;summary&gt;
    /// 数据库上下文类
    /// &lt;/summary&gt;
    public class ApplicationDbContext : DbContext
    {
        //主要是框架在用，有时候用户也可能用到
        public ApplicationDbContext()
        {

        }
        //DbContextOptions:选项模式，实现参数动态化
        public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options) : base(options)
        {

        }
        /// &lt;summary&gt;
        /// 数据表
        /// &lt;/summary&gt;
        public DbSet&lt;User&gt; user { get; set; }  //这个属性叫什么名字，数据库中的表就叫什么名字
        public DbSet&lt;WeatherForecast&gt; weatherForecast { get; set; }  //这个属性叫什么名字，数据库中的表就叫什么名字
    }
}
</code></pre> <pre><code>namespace Models
{
    public class User
    {
        public int Id { get; set; }
        public string UserName { get; set; }
        public int Age { get; set; }
    }
}
</code></pre> <pre><code>namespace Models
{
    public class WeatherForecast
    {
        public int Id { get; set; }
        /// &lt;summary&gt;
        /// 时间
        /// &lt;/summary&gt;
        public DateTime Date { get; set; }
        /// &lt;summary&gt;
        /// 摄氏度
        /// &lt;/summary&gt;
        public int TemperatureC { get; set; }
        /// &lt;summary&gt;
        /// 华氏度
        /// &lt;/summary&gt;
        public int TemperatureF =&gt; 32 + (int)(TemperatureC / 0.5556);
        /// &lt;summary&gt;
        /// 总结
        /// &lt;/summary&gt;
        public string? Summary { get; set; }
    }
}
</code></pre> </li><li> <p>迁移生成数据库表之后，在数据库中增加字段信息以便后续查询</p> <p><img src="https://images2.imgbox.com/28/a7/x852doz7_o.png" alt="image-20221021110518416"></p> </li><li> <p>新建一个DbTestController webapi控制器</p> <pre><code>using Microsoft.AspNetCore.Mvc;
using Models;

// For more information on enabling Web API for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860

namespace WebApiStudy.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class DbTestController : ControllerBase
    {
        //Db就相当于一个数据库，可以通过  Db.user 获取数据库中的表
        private ApplicationDbContext Db { get;}
        /// &lt;summary&gt;
        /// 生成一个构造函数，创建一个数据库对象db，ApplicationDbContext就是一个数据库对象创建一个数据库对象db，ApplicationDbContext就是一个数据库对象
        /// &lt;/summary&gt;
        /// &lt;param name="db"&gt;&lt;/param&gt;
        public DbTestController(ApplicationDbContext db)
        {
            Db = db;
        }

        //查询单个用户
        [HttpGet]
        public List&lt;User&gt; GetUsers()
        {
            var query = Db.user.Where(s =&gt; s.Id &gt; 0)
                    .Where(s =&gt; s.UserName == "小雨").ToList();
            return query;
        }
    }
}
</code></pre> </li><li> <p>启动项目执行查询，根据以下步骤即可查询到数据库中对应的内容</p> <p><img src="https://images2.imgbox.com/34/24/9aAmacrp_o.png" alt="image-20221021111350967"></p> <p><img src="https://images2.imgbox.com/b5/29/aoRN6Qid_o.png" alt="image-20221021111408732"></p> <p><img src="https://images2.imgbox.com/b3/28/TdUX6sdR_o.png" alt="image-20221021111433286"></p> <p><img src="https://images2.imgbox.com/81/5d/VNkAFRR1_o.png" alt="image-20221021111531271"></p> </li><li> <p>根据Request URL也可以进行查询，下面提供两种访问方式</p> <p><img src="https://images2.imgbox.com/db/19/EhPOpSqL_o.png" alt="image-20221021112426870"></p> <p><img src="https://images2.imgbox.com/44/c3/F53qGvZM_o.png" alt="image-20221021112527262"></p> <p><img src="https://images2.imgbox.com/cd/01/E45tZDxK_o.png" alt="image-20221021112610823"></p> </li></ol> 
<h6><a id="3452_Web_Api_CRUD_3128"></a>3.4.5.2 Web Api CRUD实现</h6> 
<ol><li> <p>编写响应实体类</p> <pre><code>namespace WebApiStudy.Models
{
    public class ResultModel
    {
        //返回结果
        public bool result { get; set; }
        //错误信息
        public string message { get; set; }

        public ResultModel(bool result, string message)
        {
            this.result = result;
            this.message = message;
        }
    }
}
</code></pre> </li><li> <p>编写DbTestController类的web api</p> <pre><code>using Microsoft.AspNetCore.Mvc;
using Models;
using WebApiStudy.Models;

// For more information on enabling Web API for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860

namespace WebApiStudy.Controllers
{
    [Route("api/[controller]")]   //可以自定义路由
    [ApiController]
    public class DbTestController : ControllerBase
    {
        //Db就相当于一个数据库，Db = webapistudy，可以通过  Db.user 获取数据库中的表
        private ApplicationDbContext Db { get;}
        /// &lt;summary&gt;
        /// 生成一个构造函数，创建一个数据库对象db，ApplicationDbContext就是一个数据库对象
        /// &lt;/summary&gt;
        /// &lt;param name="db"&gt;&lt;/param&gt;
        public DbTestController(ApplicationDbContext db)
        {
            Db = db;
        }

        //查询指定的单个用户  api/DbTest/GetUser
        /// &lt;summary&gt;
        /// 查询名字为小雨的用户信息
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]  //可以自定义路由
        [HttpGet]
        public List&lt;User&gt; GetUser()
        {
            var user = Db.user.Where(s =&gt; s.Id &gt; 0)
                    .Where(s =&gt; s.UserName == "小雨").ToList();
            return user;
        }
        
        /// &lt;summary&gt;
        /// 查询所有用户
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]  //可以自定义路由
        [HttpGet]
        public List&lt;User&gt; GetAllUser()
        {
            var user = Db.user.Where(s =&gt; s.Id &gt; 0)
                    .Where(s =&gt; s.UserName!=null).ToList();
            return user;
        }

        // HttpPost api/DbTest/GetUserByID/1
        /// &lt;summary&gt;
        /// 根据id查询用户
        /// &lt;/summary&gt;
        /// &lt;param name="id"&gt;用户id&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]/{id}")]   //可以自定义路由
        [HttpPost]
        public IQueryable&lt;User&gt; GetUserByID(int id)
        {
            var user = Db.user.Where(s =&gt; s.Id == id);
            return user;
        }
        
        // HttpPost api/DbTest/GetUserByName/name
        /// &lt;summary&gt;
        /// 根据Name查询用户
        /// &lt;/summary&gt;
        /// &lt;param name="name"&gt;用户名字&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]/{name}")]   //可以自定义路由
        [HttpPost]
        public IQueryable&lt;User&gt; GetUserByName(string name)
        {
            var user = Db.user.Where(s =&gt; s.UserName == name);
            return user;
        }
        
        /// &lt;summary&gt;
        /// 修改用户年龄
        /// &lt;/summary&gt;
        /// &lt;param name="name"&gt;输入用户名&lt;/param&gt;
        /// &lt;param name="age"&gt;修改用户年龄&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]/{name}")]   //可以自定义路由
        [HttpPatch]
        public ResultModel EditUser(string name,int age)
        {
            if (name != null)
            {
                var user = Db.user.Where(s =&gt; s.Id &gt; 0)
                    .Where(s =&gt; s.UserName.Contains(name)).Select(s =&gt; new User { UserName = s.UserName, Id = s.Id, Age = age }).ToList().FirstOrDefault();
                if (user != null)
                {
                    Db.user.Update(user);
                    Db.SaveChanges();
                    return new ResultModel(true, "修改成功");
                }
                else
                {
                    return new ResultModel(false, "修改失败，没有找到对应的用户");
                }
            }
            return new ResultModel(false, "修改失败，输入的用户名为空");
        }
        
        /// &lt;summary&gt;
        /// 添加用户
        /// &lt;/summary&gt;
        /// &lt;param name="name"&gt;&lt;/param&gt;
        /// &lt;param name="age"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]   //可以自定义路由
        [HttpPost]
        public ResultModel AddUser(string name, int age)
        {
            Db.user.AddRange(new User
            {
                UserName = name,
                Age = age
            });
            Db.SaveChanges();
            return new ResultModel(true, "添加成功");
        }
        
        /// &lt;summary&gt;
        /// 根据id删除用户
        /// &lt;/summary&gt;
        /// &lt;param name="id"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]   //可以自定义路由
        [HttpPost]
        public ResultModel DeleteUser(int id)
        {
            var user = Db.user.Where(s =&gt; s.Id == id).ToList().FirstOrDefault();
            if (user == null)
            {
               return new ResultModel(false, "删除失败，没有找到对应的用户");
            }
            else
            {
                Db.user.Remove(user);
                Db.SaveChanges();
                return new ResultModel(true, "删除成功");
            }
        }
    }
}
</code></pre> </li><li> <p>启动项目即可访问对应的Api</p> <p><img src="https://images2.imgbox.com/1c/87/dIw8EGEB_o.png" alt="image-20221021160453901"></p> </li><li> <p>升级版</p> <pre><code>using Microsoft.AspNetCore.Mvc;
using Models;
using WebApiStudy.Models;

// For more information on enabling Web API for empty projects, visit https://go.microsoft.com/fwlink/?LinkID=397860

namespace WebApiStudy.Controllers
{
    [Route("api/[controller]")]   //可以自定义路由
    [ApiController]
    public class DbTestController : ControllerBase
    {
        //Db就相当于一个数据库，Db = webapistudy，可以通过  Db.user 获取数据库中的表
        private ApplicationDbContext Db { get;}
        /// &lt;summary&gt;
        /// 生成一个构造函数，创建一个数据库对象db，ApplicationDbContext就是一个数据库对象
        /// &lt;/summary&gt;
        /// &lt;param name="db"&gt;&lt;/param&gt;
        public DbTestController(ApplicationDbContext db)
        {
            Db = db;
        }

        //查询指定的单个用户  api/DbTest/GetUser
        /// &lt;summary&gt;
        /// 查询名字为小雨的用户信息
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]  //可以自定义路由
        [HttpGet]
        public List&lt;User&gt; GetUser()
        {
            var user = Db.user.Where(s =&gt; s.Id &gt; 0)
                    .Where(s =&gt; s.UserName == "小雨").ToList();
            return user;
        }
        /// &lt;summary&gt;
        /// 查询所有用户
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]  //可以自定义路由
        [HttpGet]
        public List&lt;User&gt; GetAllUser()
        {
            var user = Db.user.Where(s =&gt; s.Id &gt; 0)
                    .Where(s =&gt; s.UserName!=null).ToList();
            return user;
        }

        /// &lt;summary&gt;
        /// 根据id查询用户
        /// &lt;/summary&gt;
        /// &lt;param name="id"&gt;用户id&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        //[Route("[action]/{id}")]   //可以自定义路由         HttpPost api/DbTest/GetUserByID/1
        [Route("[action]")]   //可以自定义路由                HttpPost api/DbTest/GetUserByID?id=1
        [HttpGet]
        public List&lt;User&gt; GetUserByID_Get(int id)
        {
            var user = Db.user.Where(s =&gt; s.Id == id).ToList();
            return user;
        }
        /// &lt;summary&gt;
        /// 根据id查询用户
        /// &lt;/summary&gt;
        /// &lt;param name="id"&gt;用户id&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        //[Route("[action]/{id}")]   //可以自定义路由         HttpPost api/DbTest/GetUserByID/1
        [Route("[action]")]   //可以自定义路由                HttpPost api/DbTest/GetUserByID?id=1
        [HttpPost]
        public List&lt;User&gt; GetUserByID_Post(int id)
        {
            var user = Db.user.Where(s =&gt; s.Id == id).ToList();
            return user;
        }
        // HttpPost api/DbTest/GetUserByName/xiaoming
        /// &lt;summary&gt;
        /// 根据Name查询用户
        /// &lt;/summary&gt;
        /// &lt;param name="name"&gt;用户名字&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]/{name}")]   //可以自定义路由
        [HttpPost]
        public IQueryable&lt;User&gt; GetUserByName(string name)
        {
            var user = Db.user.Where(s =&gt; s.UserName == name);
            return user;
        }

        /// &lt;summary&gt;
        /// 修改用户年龄
        /// &lt;/summary&gt;
        /// &lt;param name="name"&gt;输入用户名&lt;/param&gt;
        /// &lt;param name="age"&gt;修改用户年龄&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]/{name}")]   //可以自定义路由
        [HttpPatch]
        public ResultModel EditUser(string name,int age)
        {
            if (name != null)
            {
                var user = Db.user.Where(s =&gt; s.Id &gt; 0)
                    .Where(s =&gt; s.UserName.Contains(name)).Select(s =&gt; new User { UserName = s.UserName, Id = s.Id, Age = age }).ToList().FirstOrDefault();
                if (user != null)
                {
                    Db.user.Update(user);
                    Db.SaveChanges();
                    return new ResultModel(true, "修改成功");
                }
                else
                {
                    return new ResultModel(false, "修改失败，没有找到对应的用户");
                }
            }
            return new ResultModel(false, "修改失败，输入的用户名为空");
        }

        /// &lt;summary&gt;
        /// 添加用户
        /// &lt;/summary&gt;
        /// &lt;param name="name"&gt;&lt;/param&gt;
        /// &lt;param name="age"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]   //可以自定义路由
        [HttpPost]
        public ResultModel AddUser1(string name, int age)
        {
            Db.user.AddRange(new User
            {
                UserName = name,
                Age = age
            });
            Db.SaveChanges();
            return new ResultModel(true, "添加成功");
        }
        /// &lt;summary&gt;
        /// 添加用户
        /// &lt;/summary&gt;
        /// &lt;param name="name"&gt;&lt;/param&gt;
        /// &lt;param name="age"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]   //可以自定义路由
        [HttpPost]
        public ResultModel AddUser2(User user)
        {
            Db.user.AddRange(new User
            {
                UserName = user.UserName,
                Age = user.Age
            });
            Db.SaveChanges();
            return new ResultModel(true, "添加成功");
        }
        /// &lt;summary&gt;
        /// 根据id删除用户
        /// &lt;/summary&gt;
        /// &lt;param name="id"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]   //可以自定义路由
        [HttpDelete]
        public ResultModel DeleteUserByID(int id)
        {
            var user = Db.user.Where(s =&gt; s.Id == id).ToList().FirstOrDefault();
            if (user == null)
            {
               return new ResultModel(false, "删除失败，没有找到对应的用户");
            }
            else
            {
                Db.user.Remove(user);
                Db.SaveChanges();
                return new ResultModel(true, "删除成功");
            }
        }
    }
}
</code></pre> </li><li> <p>启动项目即可访问对应的API</p> <p><img src="https://images2.imgbox.com/6e/48/JliJcIb4_o.png" alt="image-20221021175636562"></p> </li></ol> 
<h6><a id="3453__3493"></a>3.4.5.3 小结</h6> 
<p><strong>post和get请求的区别：</strong></p> 
<p>一、功能不同</p> 
<p>1、get是从服务器上获取数据。</p> 
<p>2、post是向服务器传送数据。</p> 
<p>二、过程不同</p> 
<p>1、get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。</p> 
<p>2、post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。</p> 
<p>三、获取值不同</p> 
<p>1、对于get方式，服务器端用Request.QueryString获取变量的值。</p> 
<p>2、对于post方式，服务器端用Request.Form获取提交的数据。</p> 
<p>四、传送数据量不同</p> 
<p>1、get传送的数据量较小，不能大于2KB。</p> 
<p>2、post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。</p> 
<p>五、安全性不同</p> 
<p>1、get安全性非常低。</p> 
<p>2、post安全性较高。</p> 
<h5><a id="346__3527"></a>3.4.6 依赖注入的生命周期</h5> 
<blockquote> 
 <p>开发中用的较多的是Transient、AddScoped</p> 
</blockquote> 
<p>Transient<br> 瞬态<br> 瞬态模式，服务在每次请求时被创建你今天相了十次亲，每个都是不同的人</p> 
<p>AddScoped<br> 区域模式<br> 作用域模式，服务在每次请求时被创建，整个请求过程中都贯穿使用这个创建的服务<br> 你今天出去相了十次亲,今天这十个都是同一个人</p> 
<p>AddSingleton<br> 单例模式<br> 单例模式，服务在第一次请求时被创建，其后的每次请求都沿用这个已创建的服务。<br> 你每天都相亲十次，永远都是那同一个人</p> 
<h5><a id="347_FluentValidation_3545"></a>3.4.7 数据校验（FluentValidation）</h5> 
<p>官网：https://fluentvalidation.net/</p> 
<ol><li> <p>Nuget安装</p> <pre><code>FluentValidation.AspNetCore
</code></pre> </li><li> <p>在Program中进行依赖注入</p> <pre><code>//在Program中进行依赖注入,注册服务
builder.Services.AddFluentValidation(options =&gt;
{
    options.RegisterValidatorsFromAssembly(Assembly.GetExecutingAssembly());
});
</code></pre> </li><li> <p>使用AddUser2方法进行验证</p> <pre><code> /// &lt;summary&gt;
        /// 添加用户
        /// &lt;/summary&gt;
        /// &lt;param name="name"&gt;&lt;/param&gt;
        /// &lt;param name="age"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [Route("[action]")]   //可以自定义路由
        [HttpPost]
        public ResultModel AddUser2(User user)
        {
            Db.user.AddRange(new User
            {
                UserName = user.UserName,
                Age = user.Age
            });
            Db.SaveChanges();
            return new ResultModel(true, "添加成功");
        }
</code></pre> </li><li> <p>FluentValidation符合开发的单一职责标准</p> <p>使用方式：创建一个类UserValidator，继承AbstractValidator 泛型类，T为需要验证的实体类，甚至可以操作数据库，只需要构造函数中，然后进行数据的查询和对比</p> <p>Must()自定义验证规则，使用RuleFor对每个字段单独做校验</p> <pre><code>//例子：
public class WeChatInfoInsertDtovalidator : AbstractValidator&lt;WeChatInfoInsertDto&gt; {
        //可以直接在这个构造函数注入数据库上下文
        public WeChatInfoInsertDtovalidator() {
            //对每个字段进行单独校验
            RuleFor(it =&gt; it.Appid)
            .NotNull().withMessage("AppId不能为空")
            .Must(v =&gt; v.contains(" ")).withMessage("AppId不能包含空格");
            RuleFor(it =&gt; it.AppSecret)
            .NotNull().withMessage("Appseret不能为空格")
            .Must(v =&gt; v.contains(" ")).withMessage("Appseret不能包含空格");
            RuleFor(it =&gt; it.code)
            .NotNull().withMessage("编号不能为空")
            .Must(v =&gt; v.Contains("")).withMessage("编号不能包含空格");
        }
    }
</code></pre> <pre><code>using FluentValidation;
using Models;

namespace WebApiStudy.Validators
{
    public class UserValidator : AbstractValidator&lt;User&gt;
    {
        public UserValidator()
        {
            RuleFor(it =&gt; it.UserName)
                .NotNull()
                .Must(v=&gt; v.Contains("xxx"))
                .WithMessage("必须包含xxx");
        }
    }
}
</code></pre> </li><li> <p>启动项目，重新进行AddUser2方法api调用</p> <p>Request body</p> <pre><code>{
  "id": 0,
  "userName": "string",
  "age": 0
}
</code></pre> <p>Response body</p> <pre><code>{
  "errors": {
    "UserName": [
      "必须包含xxx"
    ]
  },
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "One or more validation errors occurred.",
  "status": 400,
  "traceId": "00-53e12fe3d84c5c1acb1335a1fb805364-6dc373e559739a8e-00"
}
</code></pre> </li></ol> 
<h5><a id="348__3660"></a>3.4.8 跨域</h5> 
<ol><li> <p>配置跨域</p> <pre><code>#region 配置跨域
builder.Services.AddCors(c =&gt;
{
    c.AddPolicy("Cors", policy =&gt;
    {
        policy.AllowAnyOrigin()
              .AllowAnyHeader()   //Ensures that the policy allows any header
              .AllowAnyMethod();
    });
});
#endregion
</code></pre> </li><li> <p>使用跨域（注意命名需要一致：Core）</p> <pre><code>app.UseCors("Cors");
</code></pre> <p><img src="https://images2.imgbox.com/5e/c8/M0VjscFi_o.png" alt="image-20221024104753962"></p> </li></ol> 
<h5><a id="349_JWT_3686"></a>3.4.9 JWT认证</h5> 
<p>参考学习博文：http://t.csdn.cn/PZGZi</p> 
<h6><a id="3491_JWT_3690"></a>3.4.9.1 什么是JWT</h6> 
<p>在介绍JWT之前，我们先来回顾一下利用token进行用户身份验证的流程：</p> 
<ol><li>客户端使用用户名和密码请求登录</li><li>服务端收到请求，验证用户名和密码</li><li>验证成功后，服务端会签发一个token，再把这个token返回给客户端</li><li>客户端收到token后可以把它存储起来，比如放到cookie中</li><li>客户端每次向服务端请求资源时需要携带服务端签发的token，可以在cookie或者header中携带</li><li>服务端收到请求，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端返回请求数据</li></ol> 
<p>这种基于token的认证方式相比传统的session认证方式更节约服务器资源，并且对移动端和分布式更加友好。其优点如下：</p> 
<ul><li> <p>支持跨域访问：cookie是无法跨域的，而token由于没有用到cookie(前提是将token放到请求头中)，所以跨域后不会存在信息丢失问题</p> </li><li> <p>无状态：token机制在服务端不需要存储session信息，因为token自身包含了所有登录用户的信息，所以可以减轻服务端压力</p> </li><li> <p>更适用CDN：可以通过内容分发网络请求服务端的所有资料</p> </li><li> <p>更适用于移动端：当客户端是非浏览器平台时，cookie是不被支持的，此时采用token认证方式会简单很多</p> </li><li> <p>无需考虑CSRF：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御</p> </li></ul> 
<p>而JWT就是上述流程当中token的一种具体实现方式，其全称是JSON Web Token，官网地址：https://jwt.io/</p> 
<p>通俗地说，JWT的本质就是一个字符串，它是将用户信息保存到一个Json字符串中，然后进行编码后得到一个JWT token，并且这个JWT</p> 
<p>token带有签名信息，接收后可以校验是否被篡改，所以可以用于在各方之间安全地将信息作为Json对象传输。</p> 
<p>JWT的认证流程如下：</p> 
<ol><li> <p>首先，前端通过Web表单将自己的用户名和密码发送到后端的接口，这个过程一般是一个POST请求。建议的方式是通过SSL加密的传输(HTTPS)，从而避免敏感信息被嗅探</p> </li><li> <p>后端核对用户名和密码成功后，将包含用户信息的数据作为JWT的Payload，将其与JWT Header分别进行Base64编码拼接后签名，形成一个JWT Token，形成的JWT Token就是一个如同lll.zzz.xxx的字符串</p> </li><li> <p>后端将JWT Token字符串作为登录成功的结果返回给前端。前端可以将返回的结果保存在浏览器中，退出登录时删除保存的JWT Token即可<br> 前端在每次请求时将JWT Token放入HTTP请求头中的Authorization属性中(解决XSS和XSRF问题)</p> </li><li> <p>后端检查前端传过来的JWT Token，验证其有效性，比如检查签名是否正确、是否过期、token的接收方是否是自己等等</p> </li><li> <p>验证通过后，后端解析出JWT Token中包含的用户信息，进行其他逻辑操作(一般是根据用户信息得到权限等)，返回结果</p> </li></ol> 
<p><img src="https://images2.imgbox.com/39/df/SPB41yel_o.png" alt="image-20221024111031908"></p> 
<h6><a id="3492JWT_3740"></a>3.4.9.2.为什么要用JWT</h6> 
<p><strong>1、传统Session认证的弊端</strong><br> 我们知道HTTP本身是一种无状态的协议，这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，认证通过后HTTP协议</p> 
<p>不会记录下认证后的状态，那么下一次请求时，用户还要再一次进行认证，因为根据HTTP协议，我们并不知道是哪个用户发出的请求，</p> 
<p>所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在用户首次登录成功后，在服务器存储一份用户登录的信息，这份登录信</p> 
<p>息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了，</p> 
<p>这是传统的基于session认证的过程</p> 
<p><img src="https://images2.imgbox.com/17/ae/Tvhuw5hK_o.png" alt="image-20221024111058340"></p> 
<p>然而，传统的session认证有如下的问题：</p> 
<ul><li> <p>每个用户的登录信息都会保存到服务器的session中，随着用户的增多，服务器开销会明显增大</p> </li><li> <p>由于session是存在与服务器的物理内存中，所以在分布式系统中，这种方式将会失效。虽然可以将session统一保存到Redis中，但是这样做无疑增加了系统的复杂性，对于不需要redis的应用也会白白多引入一个缓存中间件</p> </li><li> <p>对于非浏览器的客户端、手机移动端等不适用，因为session依赖于cookie，而移动端经常没有cookie</p> </li><li> <p>因为session认证本质基于cookie，所以如果cookie被截获，用户很容易收到跨站请求伪造攻击。并且如果浏览器禁用了cookie，这种方式也会失效</p> </li><li> <p>前后端分离系统中更加不适用，后端部署复杂，前端发送的请求往往经过多个中间件到达后端，cookie中关于session的信息会转发多次</p> </li><li> <p>由于基于Cookie，而cookie无法跨域，所以session的认证也无法跨域，对单点登录不适用</p> </li></ul> 
<p><strong>2、JWT认证的优势</strong><br> 对比传统的session认证方式，JWT的优势是：</p> 
<ul><li> <p>简洁：JWT Token数据量小，传输速度也很快</p> </li><li> <p>因为JWT Token是以JSON加密形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持</p> </li><li> <p>不需要在服务端保存会话信息，也就是说不依赖于cookie和session，所以没有了传统session认证的弊端，特别适用于分布式微服务</p> </li><li> <p>单点登录友好：使用Session进行身份认证的话，由于cookie无法跨域，难以实现单点登录。但是，使用token进行认证的话， token可以被保存在客户端的任意位置的内存中，不一定是cookie，所以不依赖cookie，不会存在这些问题</p> </li><li> <p>适合移动端应用：使用Session进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到Cookie（需要 Cookie 保存 SessionId），所以不适合移动端</p> </li></ul> 
<blockquote> 
 <p>因为这些优势，目前无论单体应用还是分布式应用，都更加推荐用JWT token的方式进行用户认证</p> 
</blockquote> 
<p><strong>3、JWT结构</strong></p> 
<p>JWT由3部分组成：标头(Header)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的3部分分别进行Base64编码后用.进</p> 
<p>行连接形成最终传输的字符串</p> 
<p>JWTString = Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)</p> 
<p>JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+“.”+base64UrlEncode(payload),secret)</p> 
<p><img src="https://images2.imgbox.com/b9/5f/iCN19wCj_o.png" alt="image-20221024112054230"></p> 
<p>1.Header<br> JWT头是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存</p> 
<p>{<!-- --><br> “alg”: “HS256”,<br> “typ”: “JWT”<br> }<br> 2.Payload<br> 有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择</p> 
<p>iss：发行人<br> exp：到期时间<br> sub：主题<br> aud：用户<br> nbf：在此之前不可用<br> iat：发布时间<br> jti：JWT ID用于标识该JWT<br> 除以上默认字段外，我们还可以自定义私有字段，一般会把包含用户信息的数据放到payload中，如下例：</p> 
<p>{<!-- --><br> “sub”: “1234567890”,<br> “name”: “Helen”,<br> “admin”: true<br> }<br> 请注意，默认情况下JWT是未加密的，因为只是采用base64算法，拿到JWT字符串后可以转换回原本的JSON数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到JWT中，以防止信息泄露。JWT只是适合在网络中传输一些非敏感的信息</p> 
<p>3.Signature<br> 签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名</p> 
<p>HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)<br> HMACSHA256(base64UrlEncode(header)+“.”+base64UrlEncode(payload),secret)</p> 
<p>在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用.分隔，就构成整个JWT对象</p> 
<p><img src="https://images2.imgbox.com/11/3c/MiRTCuhv_o.png" alt="image-20221024112122240"></p> 
<p>注意JWT每部分的作用，在服务端接收到客户端发送过来的JWT token之后：</p> 
<p>header和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据<br> signature由于使用了不可逆的加密算法，无法解码出原文，它的作用是校验token有没有被篡改。服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的是否一致。注意secretKey只能保存在服务端，而且对于不同的加密算法其含义有所不同，一般对于MD5类型的摘要加密算法，secretKey实际上代表的是盐值</p> 
<p><strong>4、JWT的种类</strong><br> 其实JWT(JSON Web Token)指的是一种规范，这种规范允许我们使用JWT在两个组织之间传递安全可靠的信息，JWT的具体实现可以分为以下几种：</p> 
<p>nonsecure JWT：未经过签名，不安全的JWT<br> JWS：经过签名的JWT<br> JWE：payload部分经过加密的JWT</p> 
<p>1.nonsecure JWT<br> 未经过签名，不安全的JWT。其header部分没有指定签名算法</p> 
<p>{<!-- --><br> “alg”: “none”,<br> “typ”: “JWT”<br> }<br> 并且也没有Signature部分</p> 
<p>2.JWS<br> JWS ，也就是JWT Signature，其结构就是在之前nonsecure JWT的基础上，在头部声明签名算法，并在最后添加上签名。创建签名，是保证jwt不能被他人随意篡改。我们通常使用的JWT一般都是JWS</p> 
<p>为了完成签名，除了用到header信息和payload信息外，还需要算法的密钥，也就是secretKey。加密的算法一般有2类：</p> 
<p>对称加密：secretKey指加密密钥，可以生成签名与验签<br> 非对称加密：secretKey指私钥，只用来生成签名，不能用来验签(验签用的是公钥)<br> JWT的密钥或者密钥对，一般统一称为JSON Web Key，也就是JWK</p> 
<p>到目前为止，jwt的签名算法有三种：</p> 
<p>HMAC【哈希消息验证码(对称)】：HS256/HS384/HS512<br> RSASSA【RSA签名算法(非对称)】（RS256/RS384/RS512）<br> ECDSA【椭圆曲线数据签名算法(非对称)】（ES256/ES384/ES512）</p> 
<h6><a id="3493_CJWT_3870"></a>3.4.9.3 C#中使用JWT</h6> 
<p>参考学习链接：https://gitee.com/laozhangIsPhi/Blog.Core，使用其中JwtHelper类进行修改了一下，有需要可自行使用</p> 
<ol><li>JwtHelper类创建</li></ol> 
<pre><code>using Microsoft.IdentityModel.Tokens;
using Newtonsoft.Json;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

namespace WebApiStudy.Common
{
    public class JwtHelper
    {

        /// &lt;summary&gt;
        /// 颁发JWT字符串
        /// &lt;/summary&gt;
        /// &lt;param name="model"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static string IssueJwt(TokenModelJwt tokenModel)
        {
            //var claims = new Claim[] //old
            var claims = new List&lt;Claim&gt;
                {
                 /*
                 * 特别重要：
                   1、这里将用户的部分信息，比如 uid 存到了Claim 中，如果你想知道如何在其他地方将这个 uid从 Token 中取出来，请看下边的SerializeJwt() 方法，或者在整个解决方案，搜索这个方法，看哪里使用了！
                   2、你也可以研究下 HttpContext.User.Claims ，具体的你可以看看 Policys/PermissionHandler.cs 类中是如何使用的。
                 */
                new Claim("UserId",tokenModel.UserId.ToString()),
                new Claim("UserName",tokenModel.UserName),
                
                //new Claim(ClaimTypes.Role,tokenModel.Role),//为了解决一个用户多个角色(比如：Admin,System)，用下边的方法
               };

            // 可以将一个用户的多个角色全部赋予；

            if (!string.IsNullOrWhiteSpace(tokenModel.Role))
            {
                claims.AddRange(tokenModel.Role.Split(',').Select(s =&gt; new Claim(ClaimTypes.Role, s)));
                claims.Add(new Claim("Role", tokenModel.Role));
            }

            //秘钥 (SymmetricSecurityKey 对安全性的要求，密钥的长度太短会报出异常)
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(tokenModel.Secret));
            var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

            var jwt = new JwtSecurityToken(
                issuer: tokenModel.Issuer,
                audience: tokenModel.Audience,
                expires: DateTime.Now.AddSeconds(tokenModel.Expires),
                signingCredentials: creds,
                claims: claims
                );

            var jwtHandler = new JwtSecurityTokenHandler();
            var token = jwtHandler.WriteToken(jwt);

            return token;
        }

        /// &lt;summary&gt;
        /// 不检查有效性并解析
        /// &lt;/summary&gt;
        /// &lt;param name="jwtStr"&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        public static TokenModelJwt SerializeJwt(string jwtStr)
        {
            //不校验，直接解析token
            var jwtToken = new JwtSecurityTokenHandler().ReadJwtToken(jwtStr);
            var tokenJwt = JsonConvert.DeserializeObject&lt;TokenModelJwt&gt;(jwtToken.Payload.SerializeToJson());

            return tokenJwt;
        }

        /// &lt;summary&gt;
        /// 令牌
        /// &lt;/summary&gt;
        public class TokenModelJwt
        {
            public int UserId { get; set; }
            public string UserName { get; set; }
            public string Issuer { get; set; }
            public string Audience { get; set; }
            public string Secret { get; set; }
            public int Expires { get; set; }
            public string Role { get; set; }
        }
    }
}

</code></pre> 
<p>报错解决：</p> 
<p><img src="https://images2.imgbox.com/ff/a7/f2b4xwNd_o.png" alt="image-20221024121018081"></p> 
<p><img src="https://images2.imgbox.com/e8/36/rg7uF40R_o.png" alt="image-20221024121213488"></p> 
<p><img src="https://images2.imgbox.com/b9/88/8lqSw6vY_o.png" alt="image-20221024122425371"></p> 
<ol start="2"><li> <p>在配置文件中写上我们需要的配置文件</p> <pre><code>"Jwt": {
    "Secret": "sghkadhkabhahjbdskanladhnjsfbdsknadnkjsb", //不要太短，建议16位+
    "Issuer": "xiaoshu",
    "Audience": "xiaoshu"
  }
</code></pre> <p><img src="https://images2.imgbox.com/bb/d8/hS1XYYtu_o.png" alt="image-20221024132403830"></p> </li><li> <p>新建一个JwtController控制器</p> <pre><code>using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using WebApiStudy.Common;
using static WebApiStudy.Common.JwtHelper;

namespace WebApiStudy.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class JwtController : ControllerBase
    {
        //需要读取配置文件，创建一个构造器
        public JwtController(IConfiguration configuration)
        {
            Configuration = configuration;
        }
        private IConfiguration Configuration { get; }
        [HttpPost]
        public string CreateToken()
        {
            var tokenModel = Configuration.GetSection("Jwt").Get&lt;TokenModelJwt&gt;();
            tokenModel.UserName = "张三";
            tokenModel.UserId = 1;
            tokenModel.Role = "Admin";

            return JwtHelper.CreateJwt(tokenModel);
        }
    }
}
</code></pre> </li><li> <p>启动项目，获取jwt字符串</p> <p><img src="https://images2.imgbox.com/76/d4/QIYRqomK_o.png" alt="image-20221024134556153"></p> </li><li> <p>在Program中添加jwt配置代码，然后运行项目</p> <pre><code>#region jwt配置
    options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme()
    {
        Description = "在下框中输入请求头中需要添加的Jwt授权Token：Bearer Token",
        Name = "Authorization",
        In = ParameterLocation.Header,
        Type = SecuritySchemeType.ApiKey,
        BearerFormat =  "Jwt",
        Scheme = "Bearer"
    });
    options.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type = ReferenceType.SecurityScheme,
                    Id = "Bearer"
                }
            },new string[] { }
        }
    });
    #endregion
</code></pre> <p><img src="https://images2.imgbox.com/b3/01/No3sepPn_o.png" alt="image-20221024140052906"></p> </li><li> <p>然后在program中再加上Jwt的验证（注册服务）</p> <pre><code>#region jwt验证中间件
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt;
    {
        var tokenModel = builder.Configuration.GetSection("Jwt").Get&lt;TokenModelJwt&gt;();
        var secretByte = Encoding.UTF8.GetBytes(tokenModel.Secret);
        options.TokenValidationParameters = new TokenValidationParameters()
        {
            ValidateIssuer = true,
            ValidIssuer = tokenModel.Issuer,

            ValidateAudience = true,
            ValidAudience = tokenModel.Audience,

            ValidateLifetime = true,

            IssuerSigningKey = new SymmetricSecurityKey(secretByte)
        };
        options.Events = new JwtBearerEvents
        {
            OnChallenge = context =&gt;
            {
                return Task.FromResult(0);
            },
            OnForbidden = context =&gt;
            {
                return Task.FromResult(0);
            }
        };
    });
#endregion
</code></pre> <p>安装以下包：</p> <p><img src="https://images2.imgbox.com/44/36/JEUvAboe_o.png" alt="image-20221024140543670"></p> <p>在最后加上</p> <pre><code>//jwt身份验证中间件
app.UseAuthentication();
</code></pre> <p><img src="https://images2.imgbox.com/60/15/pUxLgkZr_o.png" alt="image-20221024143331645"></p> </li><li> <p>在JwtController控制器中新增一个方法来测试是否授权成功</p> <pre><code>/// &lt;summary&gt;
        /// 解析token
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [HttpGet]
        [Authorize]
        public IActionResult DeToken()  //[FromHeader]：从请求头中获取数据
        {
            return Ok();
        }
</code></pre> </li><li> <p>启动项目，先获取jwt字符串</p> <p><img src="https://images2.imgbox.com/75/d1/aJaRSmmZ_o.png" alt="image-20221024144025035"></p> </li><li> <p>进行jwt认证</p> <p><img src="https://images2.imgbox.com/13/9d/ndFbwBVs_o.png" alt="image-20221024144148265"></p> <p>输入格式：Bearer+（空格）+jwt字符串，点击授权即可，然后关闭状态栏</p> <p><img src="https://images2.imgbox.com/73/af/JQse540R_o.png" alt="image-20221024144357606"></p> <p><img src="https://images2.imgbox.com/f1/23/7tYDQHF4_o.png" alt="image-20221024144436397"></p> </li><li> <p>测试是否授权成功</p> <p><img src="https://images2.imgbox.com/49/5b/susnMboW_o.png" alt="image-20221024145243771"></p> </li><li> <p>解析token并返回数据</p> <pre><code>/// &lt;summary&gt;
        /// 解析token并返回数据
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [HttpGet]
        [Authorize]
        public IActionResult GetJwtToken([FromHeader] string Authorization)  //[FromHeader]：从请求头中获取数据
        {
            //Bearer :Bearer后面接了一个空格
            var token = JwtHelper.SerializeJwt(Authorization.Replace("Bearer ", ""));  
            return Ok(token);
        }
</code></pre> </li><li> <p>启动项目重新进行授权并返回数据</p> </li></ol> 
<p><img src="https://images2.imgbox.com/77/92/6sZlkbLv_o.png" alt="image-20221024151404255"></p> 
<ol start="13"><li> <p>如果修改角色</p> <pre><code>/// &lt;summary&gt;
        /// 解析token并返回数据
        /// &lt;/summary&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        [HttpGet]
        [Authorize(Roles ="xiaoshu")]
        public IActionResult GetJwtToken([FromHeader] string Authorization)  //[FromHeader]：从请求头中获取数据
        {
            var token = JwtHelper.SerializeJwt(Authorization.Replace("Bearer ", ""));
            return Ok(token);
        }
</code></pre> <p>则会报错403：角色权限不符合</p> <p><img src="https://images2.imgbox.com/73/d7/eGcpAVcM_o.png" alt="image-20221024151831140"></p> </li></ol> 
<h5><a id="3410__4179"></a>3.4.10 前端数据接收规范</h5> 
<ol><li> <p>新建一个用户数据接收的类（不能用实体类去接收，因为它涉及到数据库的一些操作不能随意更改）</p> <pre><code>namespace WebApiStudy
{
    /// &lt;summary&gt;
    /// 接收前端数据的类，可指定接收什么样的
    /// &lt;/summary&gt;
    public class LoginDto
    {
        public string Code { get; set; }
        public string Password { get; set; }
    }
}
</code></pre> </li><li> <p>在JwtController中增加一个参数，用于接收前端传的参数</p> <pre><code>        [HttpPost]
        public string CreateToken(LoginDto dto)
        {
            var tokenModel = Configuration.GetSection("Jwt").Get&lt;TokenModelJwt&gt;();
            tokenModel.UserName = "张三";
            tokenModel.UserId = 1;
            tokenModel.Role = "Admin";

            return JwtHelper.CreateJwt(tokenModel);
        }
</code></pre> </li><li> <p>启动项目，即可看到规定需要传入哪些值</p> <p><img src="https://images2.imgbox.com/0f/a8/T4b7iLYT_o.png" alt="image-20221024154813510"></p> </li></ol> 
<h5><a id="3411__4216"></a>3.4.11 简单使用缓存</h5> 
<ol><li> <p>依赖注入</p> <pre><code>//进行缓存的依赖注入
builder.Services.AddMemoryCache();
</code></pre> <p><img src="https://images2.imgbox.com/d0/96/jhzEK017_o.png" alt="image-20221024161057106"></p> </li><li> <p>新建一个缓存控制器</p> <pre><code>using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Caching.Memory;

namespace WebApiStudy.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class MemoryCacheController : ControllerBase
    {
        private readonly IMemoryCache cache;

        //通过构造函数的方法获取
        public MemoryCacheController(IMemoryCache cache)
        {
            this.cache = cache;
        }
        [HttpPost]
        public string Set(string Name)
        {
            var key = Guid.NewGuid().ToString();
            cache.Set(key, Name,TimeSpan.FromSeconds(100));  //TimeSpan.FromSeconds(100):缓存有效期
            return key;
        }
        [HttpGet]
        public string Get(string key)
        {
            return cache.Get(key).ToString();
        }
    }
}
</code></pre> </li><li> <p>通过Name生成一个GUID</p> <p><img src="https://images2.imgbox.com/3b/78/jxy9ADzn_o.png" alt="image-20221024161731151"></p> </li><li> <p>从缓存中通过GUID获取Name</p> <p><img src="https://images2.imgbox.com/bf/c3/lnZANnxb_o.png" alt="image-20221024161812659"></p> </li><li> <p>当缓存有效期过期时</p> <p><img src="https://images2.imgbox.com/2f/f7/Inxi7RWF_o.png" alt="image-20221024162321270"></p> </li></ol> 
<h5><a id="3412__4275"></a>3.4.12 文件上传</h5> 
<ol><li> <p>编写一个控制器</p> <pre><code>using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

namespace WebApiStudy.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class FileController : ControllerBase
    {
        [HttpPost]
        public bool Upload(IFormFile file)
        {
            var filename = file.FileName;
            var path = @"D:\C#学习\Test\";
            using (var stream = new FileStream(path + filename, FileMode.Create))
            {
                file.CopyTo(stream);
            }
            return true;
        }
    }
}
</code></pre> </li><li> <p>执行进行复制文件操作</p> <p><img src="https://images2.imgbox.com/e1/fc/bsd1sNsl_o.png" alt="image-20221024163752797"></p> </li></ol> 
<h5><a id="3413_AutoMapper_4308"></a>3.4.13 AutoMapper的简单使用</h5> 
<p>功能：对象与对象之间的映射</p> 
<ol><li> <p>安装automapper.extensions.microsoft.dependencyinjection</p> <p><img src="https://images2.imgbox.com/00/a0/sfqhVfH0_o.png" alt="image-20221024170004352"></p> </li><li> <p>准备工作</p> <p>创建一个User映射类</p> <pre><code>namespace WebApiStudy.Dto
{
    /// &lt;summary&gt;
    /// User映射类
    /// &lt;/summary&gt;
    public class UserDto
    {
        public int Id { get; set; }
    }
}
</code></pre> <p>创建一个MapperProfile类</p> <pre><code>using AutoMapper;
using Models;
using WebApiStudy.Dto;

namespace WebApiStudy.Profiles
{
    public class MapperProfile:Profile
    {
        public MapperProfile()
        {
            CreateMap&lt;User, UserDto&gt;();
        }
    }
}
</code></pre> <p>在program中进行依赖注入</p> <pre><code>//进行AutoMapper依赖注入
builder.Services.AddAutoMapper(typeof(WebApiStudy.Profiles.MapperProfile));
</code></pre> <p>新建MapperController控制器</p> <pre><code>using AutoMapper;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Models;
using WebApiStudy.Dto;

namespace WebApiStudy.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class MapperController : ControllerBase
    {
        public MapperController(IMapper mapper)
        {
            Mapper = mapper;
        }

        public IMapper Mapper { get; }
        [HttpPost]
        public UserDto Test(User user)
        {
            //User, UserDto:第一个参数是源，第二个参数是目标
            return Mapper.Map&lt;User, UserDto&gt;(user);
        }
    }
}
</code></pre> </li><li> <p>进行测试并查看返回结果</p> <p><img src="https://images2.imgbox.com/4b/8f/isKFTWvx_o.png" alt="image-20221024171849363"></p> <p><img src="https://images2.imgbox.com/30/d8/2wPnQH4k_o.png" alt="image-20221024171906081"></p> </li><li> <p>复杂映射</p> <pre><code>using AutoMapper;
using Models;
using WebApiStudy.Dto;

namespace WebApiStudy.Profiles
{
    public class MapperProfile:Profile
    {
        public MapperProfile()
        {
            //CreateMap&lt;User, UserDto&gt;();
            //复杂映射
            //CreateMap&lt;User, UserDto&gt;().ForMember(dest=&gt; dest.Id,opt=&gt;opt.MapFrom(user =&gt; user.Id+"名字"));
            CreateMap&lt;User, UserDto&gt;().ForMember(dest=&gt; dest.Id,opt=&gt;opt.MapFrom(user =&gt; user.Id+1));
        }
    }
}
</code></pre> </li></ol> 
<h5><a id="3414_ISS_4418"></a>3.4.14 ISS发布</h5> 
<p>excel导入导出学习链接：https://www.cnblogs.com/codelove/p/15117226.html</p> 
<p>ISS发布学习链接：【Net 6 WebApi简单入门-哔哩哔哩】 https://b23.tv/KthBIg9</p> 
<h5><a id="3415__4424"></a>3.4.15 问题小结</h5> 
<p>关于构造函数中的参数创建属性还是字段的探讨：</p> 
<p><img src="https://images2.imgbox.com/17/f3/j5idBWdt_o.png" alt="image-20221024174957317"></p> 
<ol><li> <p>创建属性</p> <pre><code> public JwtController(IConfiguration configuration)
        {
            Configuration = configuration;
        }
        private IConfiguration Configuration { get; }
</code></pre> </li><li> <p>创建字段</p> <pre><code>private readonly IConfiguration configuration;

        //需要读取配置文件，创建一个构造器
        public JwtController(IConfiguration configuration)
        {
            this.configuration = configuration;
        }
</code></pre> </li><li> <p>总结：</p> 
  <ul><li> <p>两种方法创建的都是一个IConfiguration对象：configuration，并且都是只读的</p> </li><li> <p>区别：</p> <p>（1）属性是项目一启动就开辟空间（在内存中指向一个地址），没有赋值的时候为null；如果不赋值，编译不会报错，但是运行会报值空异常</p> <p>（2）字段是需要调用构造函数的时候才会去给它开辟空间顺便就赋值了，不调用的时候为null</p> </li></ul> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/271a0ae5ee5c4ae6d731c8e1b05ab69f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是 CDP 和 LLDP？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89510d46faf405f9c9fefd3bb69b5630/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Win11】重装系统教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>