<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android中BroadcastReceiver的两种注册方式（静态和动态）详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android中BroadcastReceiver的两种注册方式（静态和动态）详解" />
<meta property="og:description" content="今天我们一起来探讨下安卓中BroadcastReceiver组件以及详细分析下它的两种注册方式。
BroadcastReceiver也就是“广播接收者”的意思，顾名思义，它就是用来接收来自系统和应用中的广播。在Android系统中，广播体现在方方面面，例如当开机完成后系统会产生一条广播，接收到这条广播就能实现开机启动服务的功能；当网络状态改变时系统会产生一条广播，接收到这条广播就能及时地做出提示和保存数据等操作；当电池电量改变时，系统会产生一条广播，接收到这条广播就能在电量低时告知用户及时保存进度等等。Android中的广播机制设计的非常出色，很多事情原本需要开发者亲自操作的，现在只需等待广播告知自己就可以了，大大减少了开发的工作量和开发周期。而作为应用开发者，就需要数练掌握Android系统提供的一个开发利器，那就是BroadcastReceiver。
在我们详细分析创建BroadcastReceiver的两种注册方式前，我们先罗列本次分析的大纲： （1）对静态和动态两种注册方式进行概念阐述以及演示实现步骤
（2）简述两种BroadcastReceiver的类型（为后续注册方式的对比做准备）
（3）在默认广播类型下设置优先级和无优先级情况下两种注册方式的比较
（4）在有序广播类型下两种注册方式的比较
（5）通过接受打电话的广播，在程序（Activity）运行时和终止运行时，对两种注册方式的比较
（6）总结两种方式的特点
第一步：静态和动态注册方式基本概念以及实现步骤 构建Intent，使用sendBroadcast方法发出广播定义一个广播接收器，该广播接收器继承BroadcastReceiver，并且覆盖onReceive()方法来响应事件注册该广播接收器，我们可以在代码中注册（动态注册），也可以AndroidManifest.xml配置文件中注册（静态注册）。
动态注册： 效果如下图：
这里就不演示点击按钮布局的实现了，MainActivity.java中实现代码如下：
import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.Gravity;import android.view.View;import android.widget.Toast;public class MainActivity extends AppCompatActivity {DynamicReceiver dynamicReceiver;@Overrideprotected void onCreate(Bundle savedInstanceState) {super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);//实例化IntentFilter对象IntentFilter filter = new IntentFilter();filter.addAction(&#34;panhouye&#34;);dynamicReceiver = new DynamicReceiver();//注册广播接收registerReceiver(dynamicReceiver,filter);}//按钮点击事件public void send2(View v){Intent intent = new Intent();intent." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/39f52737e97ca8fda7de3829dfa4a4ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-12T21:37:25+08:00" />
<meta property="article:modified_time" content="2016-12-12T21:37:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android中BroadcastReceiver的两种注册方式（静态和动态）详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今天我们一起来探讨下安卓中BroadcastReceiver组件以及详细分析下它的两种注册方式。</p> 
<p>BroadcastReceiver也就是“广播接收者”的意思，顾名思义，它就是用来接收来自系统和应用中的广播。在Android系统中，广播体现在方方面面，例如当开机完成后系统会产生一条广播，接收到这条广播就能实现开机启动服务的功能；当网络状态改变时系统会产生一条广播，接收到这条广播就能及时地做出提示和保存数据等操作；当电池电量改变时，系统会产生一条广播，接收到这条广播就能在电量低时告知用户及时保存进度等等。Android中的广播机制设计的非常出色，很多事情原本需要开发者亲自操作的，现在只需等待广播告知自己就可以了，大大减少了开发的工作量和开发周期。而作为应用开发者，就需要数练掌握Android系统提供的一个开发利器，那就是BroadcastReceiver。</p> 
<h5>在我们详细分析创建BroadcastReceiver的两种注册方式前，我们先罗列本次分析的大纲：</h5> 
<p>（1）对静态和动态两种注册方式进行概念阐述以及演示实现步骤</p> 
<p>（2）简述两种BroadcastReceiver的类型（为后续注册方式的对比做准备）</p> 
<p>（3）在默认广播类型下设置优先级和无优先级情况下两种注册方式的比较</p> 
<p>（4）在有序广播类型下两种注册方式的比较</p> 
<p>（5）通过接受打电话的广播，在程序（Activity）运行时和终止运行时，对两种注册方式的比较</p> 
<p>（6）总结两种方式的特点</p> 
<h4>第一步：静态和动态注册方式基本概念以及实现步骤</h4> 
<p><span style="font-size:14px">构建<span style="font-family:Calibri">Intent</span>，使用<span style="font-family:Calibri">sendBroadcast</span>方法发出广播定义一个广播接收器，该广播接收器继承<span style="font-family:Calibri">BroadcastReceiver</span>，并且覆盖<span style="font-family:Calibri">onReceive()</span>方法来响应事件注册该广播接收器，我们可以在代码中注册（<strong><span style="color:red">动态注册</span></strong>），也可以<span style="font-family:Calibri">AndroidManifest.xml</span>配置文件中注册（<strong><span style="color:red">静态注册</span></strong>）。</span></p> 
<h5>动态注册：</h5> 
<p>效果如下图：</p> 
<p><img alt="" src="https://images2.imgbox.com/ec/66/dO7SpD7i_o.gif"></p> 
<p>这里就不演示点击按钮布局的实现了，MainActivity.java中实现代码如下：</p> 
<pre><code class="language-java">import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.Gravity;
import android.view.View;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {
    DynamicReceiver dynamicReceiver;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
		//实例化IntentFilter对象
        IntentFilter filter = new IntentFilter();
        filter.addAction("panhouye");
        dynamicReceiver = new DynamicReceiver();
		//注册广播接收
        registerReceiver(dynamicReceiver,filter);
    }
	//按钮点击事件
    public void send2(View v){
        Intent intent = new Intent();
        intent.setAction("panhouye");
        intent.putExtra("sele","潘侯爷");
        sendBroadcast(intent);
    }
	/*动态注册需在Acticity生命周期onPause通过
	 *unregisterReceiver()方法移除广播接收器，
	 * 优化内存空间，避免内存溢出
	 */
    @Override
    protected void onPause() {
        super.onPause();
        unregisterReceiver(new MyReceiver());
    }
	//通过继承 BroadcastReceiver建立动态广播接收器
    class DynamicReceiver extends BroadcastReceiver{
        @Override
        public void onReceive(Context context, Intent intent) {
			//通过土司验证接收到广播
            Toast t = Toast.makeText(context,"动态广播："+ intent.getStringExtra("sele"), Toast.LENGTH_SHORT);
            t.setGravity(Gravity.TOP,0,0);//方便录屏，将土司设置在屏幕顶端
            t.show();
        }
    }
}</code></pre> 
<p><br> 建立方法代码中做了详细注释，有不明白的地方请留言讨论。</p> 
<h5>静态注册：</h5> 
<p>效果如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/26/27/9NM9amAh_o.gif"></p> 
<h5>静态注册建立第一步，新建BroadcastReceiver，见下图：</h5> 
<p><img alt="" src="https://images2.imgbox.com/ae/17/MyzsY7lO_o.png"></p> 
<h5>通过以上步骤，生成MyReceiver.java文件：</h5> 
<pre><code class="language-java">import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.view.Gravity;
import android.widget.Toast;

public class MyReceiver extends BroadcastReceiver {
    public MyReceiver() {
    }
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast t = Toast.makeText(context,"静态广播："+intent.getStringExtra("info"), Toast.LENGTH_SHORT);
        t.setGravity(Gravity.TOP,0,0);
        t.show();
    }
}</code></pre> 
<h5><br> 生成MyReceiver.java的同时，修改AndroidMainfest.xml配置文件中的代码：</h5> 
<pre><code class="language-java">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.administrator.day19"&gt;
&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;
    &lt;application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"&gt;
        &lt;activity android:name=".MainActivity"&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.intent.action.MAIN" /&gt;

                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
		//生成的receiver配置文件
        &lt;receiver
            android:name=".MyReceiver"
            android:enabled="true"
            android:exported="true"&gt;
            &lt;intent-filter&gt;
			//自定义Action
                &lt;action android:name="MLY" /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</code></pre> 
<h5><br> 最后在MainActivity.java文件中添加按钮点击事件，如下：</h5> 
<pre><code class="language-java">import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.Gravity;
import android.view.View;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {
    DynamicReceiver dynamicReceiver;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
    //静态广播点击
    public void send(View v){
        Intent intent = new Intent();
        intent.setAction("MLY");
        intent.putExtra("info","panhouye");
        sendBroadcast(intent);
    }
}</code></pre> 
<p><br> 至此，两种注册方式的实现代码演示完毕，欢迎探讨。</p> 
<h4>第二步：为方便后续分析，这里插入BroadcastReceiver的两种常用类型</h4> 
<p><strong><span style="font-size:14px">（1</span><span style="font-size:14px">）</span><span style="font-size:14px">Normalbroadcasts</span><span style="font-size:14px">：默认广播</span></strong></p> 
<p><span style="font-family:Calibri; font-size:14px">         </span>发送一个默认广播使用Context.sendBroadcast(）方法，普通广播对于多个接收者来说是完全异步的，通常每个接收者都无需等待即可以接收到广播，接收者相互之间不会有影响。对于这种广播，接收者无法终止广播，即无法阻止其他接收者的接收动作。</p> 
<p><span style="font-size:14px"><strong>（2）orderedbroadcasts：有序广播</strong></span></p> 
<p>    发送一个有序广播使用Context.sendorderedBroadcast(）方法，有序广播比较特殊，它每次只发送到优先级较高的接收者那里，然后由优先级高的接受者再传播到优先级低的接收者那里，优先级高的接收者有能力终止这个广播。</p> 
<p><span style="font-size:14px">发送有序广播：<span style="font-family:Calibri">sendorderedBroadCast()</span></span></p> 
<p>在注册广播中的&lt;intent-filter&gt;中使用android:priority属性。这个属性的范围在-1000到1000，数值越大，优先级越高。在广播接收器中使用setResultExtras方法将一个Bundle对象设置为结果集对象，传递到下一个接收者那里，这样优先级低的接收者可以用getResuttExtras获取到最新的经过处理的信息集合。使用sendorderedBroadcast方法发送有序广播时，需要一个权限参数，如果为null则表示不要求接收者声明指定的权限，如果不为null则表示接收者若要接收此广播，需声明指定权限。这样做是从安全角度考虑的，例如系统的短信就是有序广播的形式，一个应用可能是具有拦截垃圾短信的功能，当短信到来时它可以先接受到短信广播，必要时终止广播传递，这样的软件就必须声明接收短信的权限。</p> 
<h4>第三步：在默认广播下两种注册方式的比较</h4> 
<h5>（1）两种注册方式均不设置优先级</h5> 
<p>这里将动态与静态两种注册的广播触发集中在一个按钮上，显示效果如下（未设置优先级的情况下，先动态后静态）：</p> 
<p><img alt="" src="https://images2.imgbox.com/d1/1d/N9hK7f2C_o.gif"></p> 
<p>这里同样不演示按钮布局文件，以及静态注册涉及AndroidMainfest.xml和MyReceiver.java文件。直接展示MainActicity.java的实现代码：</p> 
<pre><code class="language-java">import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.Gravity;
import android.view.View;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {
    DynamicReceiver dynamicReceiver;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        IntentFilter filter = new IntentFilter();
        filter.addAction("panhouye");
        dynamicReceiver = new DynamicReceiver();
        registerReceiver(dynamicReceiver,filter);
    }
    //静态广播点击
    public void send(View v){
        Intent intent = new Intent();
		//设置与动态相同的Action，方便同时触发静态与动态
        intent.setAction("panhouye");
        intent.putExtra("info","潘侯爷");
        sendBroadcast(intent);//默认广播
    }
    @Override
    protected void onPause() {
        super.onPause();
        unregisterReceiver(new MyReceiver());
    }
    class DynamicReceiver extends BroadcastReceiver{
        @Override
        public void onReceive(Context context, Intent intent) {
            Toast t = Toast.makeText(context,"动态广播："+ intent.getStringExtra("info"), Toast.LENGTH_SHORT);
            t.setGravity(Gravity.TOP,0,0);
            t.show();
        }
    }
}</code></pre> 
<h5><br> （2）将动态优先级设置为最低-1000，静态优先级设置为最高1000</h5> 
<p>显示效果如下（动态仍先于静态被接收到）：</p> 
<p><img alt="" src="https://images2.imgbox.com/e3/5d/127w5ZKZ_o.gif"></p> 
<p> </p> 
<h6>MainActivity中动态优先级设置如下：</h6> 
<pre><code class="language-java">protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        IntentFilter filter = new IntentFilter();
        filter.addAction("panhouye");
		filter.setPriority(-1000);//设置动态优先级
        dynamicReceiver = new DynamicReceiver();
        registerReceiver(dynamicReceiver,filter);
    }</code></pre> 
<h6>AndroidMainfest.xml中静态优先级设置如下：</h6> 
<pre><code class="language-java">&lt;receiver
    android:name=".MyReceiver"
    android:enabled="true"
    android:exported="true"&gt;
	//设置静态优先级
    &lt;intent-filter android:priority="1000"&gt;
          &lt;action android:name="panhouye" /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;</code></pre> 
<h4>第四步：在有序广播下两种注册方式比较</h4> 
<p>静态广播1（优先级为200），静态广播2（优先级为300），静态广播3（优先级为400），静态广播优先级为（-100），动态广播优先级为0。显示效果如下：</p> 
<p><br> <img alt="" src="https://images2.imgbox.com/c8/ac/UOKhNB2W_o.gif"></p> 
<p>出现顺序由优先级决定，由高到低分别为静态3-静态2-静态1-动-静态。（这里参照前文代码）<br> </p> 
<h4><br> 第五步：接受打电话的广播，比较程序运行中与结束运行时，两种注册方式的比较</h4> 
<p>本次比较采用比对Log的方式对两种注册方式进行比较，在MainActivity.java中会插入Activity全部生命周期用于检测Log分析。</p> 
<h5>AndroidMainfest.xml配置文件代码如下：</h5> 
<pre><code class="language-java">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.administrator.test19"&gt;
    //添加拨打电话权限
&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS"/&gt;
    &lt;application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"&gt;
        &lt;activity android:name=".MainActivity"&gt;
            &lt;intent-filter&gt;
                &lt;action android:name="android.intent.action.MAIN" /&gt;

                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
        &lt;receiver
            android:name=".StaticReceiver"
            android:enabled="true"
            android:exported="true"&gt;
            &lt;intent-filter&gt;
                //设置打电话对应的action
                &lt;action android:name="android.intent.action.NEW_OUTGOING_CALL" /&gt;
            &lt;/intent-filter&gt;
        &lt;/receiver&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</code></pre> 
<h5><br> MainActivity.java中实现代码<strong>（<span style="color:#ff00">动态注册将解除注册放在onDestory方法内是因为在真机测试过程中拨打电话，需要返回主页面，而此操作会造成Activity处于onStop状态，若放在onPause中，将无法在程序运行时启用动态注册接受广播。真实环境下建议在onpause下解除注册，尽早释放内存，避免内存溢出</span>）：</strong></h5> 
<pre><code class="language-java">import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {
    DynamicReceiver dynamicReceiver;//声明动态注册广播接收
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        IntentFilter filter = new IntentFilter();
        filter.addAction("android.intent.action.NEW_OUTGOING_CALL");
        dynamicReceiver = new DynamicReceiver();
        registerReceiver(dynamicReceiver,filter);
        Log.i("Tag","Activity-onCreate");
    }
    @Override
    protected void onStart() {
        super.onStart();
        Log.i("Tag","Activity-onStart");
    }
    @Override
    protected void onResume() {
        super.onResume();
        Log.i("Tag","Activity-onResume");
    }
    @Override
    protected void onPause() {
        super.onPause();
        Log.i("Tag","Activity-onPause");
    }
    @Override
    protected void onStop() {
        super.onPause();
        Log.i("Tag","Activity-onStop");
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
        Log.i("Tag","Activity-onDestroy");
        unregisterReceiver(dynamicReceiver);
    }
    class DynamicReceiver extends BroadcastReceiver{
        @Override
        public void onReceive(Context context, Intent intent) {
            Log.i("Tag","动态注册广播接收到您正在拨打电话"+getResultData());
        }
    }
}</code></pre> 
<h5><br> StaticReceiver.java中实现代码：</h5> 
<pre><code class="language-java">import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
public class StaticReceiver extends BroadcastReceiver {
    public StaticReceiver() {
    }
    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i("Tag","静态注册广播接收到您正在拨打电话"+getResultData());
    }
}</code></pre> 
<h4><br> <span style="color:#ff0000">（1）在未退出Activity时，拨打电话，Log如下：</span></h4> 
<p><img alt="" src="https://images2.imgbox.com/9c/78/JqOe2u5U_o.png"><br> <br> 由Log可知在未退出Activity是，两种方式均可接受到广播。</p> 
<h4><span style="color:#ff0000">（2）在退出Activity时，拨打电话，Log如下<span style="color:#ff0000">（即便不解除注册，动态仍无法接受到广播）：</span></span></h4> 
<p><img alt="" src="https://images2.imgbox.com/28/3d/NG8JC5Ch_o.png"></p> 
<p>在退出程序（Activity）时，只有静态注册方式可以接受到广播。</p> 
<h4>第六步：总结两种注册方式特点</h4> 
<p><span style="font-size:14px">广播接收器注册一共有两种形式：静态注册和动态注册．</span></p> 
<p><span style="font-size:14px">两者及其接收广播的区别：</span></p> 
<p><span style="font-size:14px">（<span style="font-family:Calibri">1</span>）动态注册广播不是常驻型广播，也就是说广播跟随<span style="font-family:Calibri">Activity</span>的生命周期。注意在<span style="font-family:Calibri">Activity</span>结束前，移除广播接收器。</span></p> 
<p><span style="font-size:14px">静态注册是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</span></p> 
<p><span style="font-size:14px">（<span style="font-family:Calibri">2</span>）当广播为有序广播时：优先级高的先接收（不分静态和动态）。同优先级的广播接收器，动态优先于静态</span></p> 
<p><span style="font-size:14px">（<span style="font-family:Calibri">3</span>）同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后注册的。</span></p> 
<p><span style="font-size:14px">（<span style="font-family:Calibri">4</span>）当广播为默认广播时：无视优先级，动态广播接收器优先于静态广播接收器。同优先级的同类广播接收器，静态：先扫描的优先于后扫描的，动态：先注册的优先于后册的。</span></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d98efc0640d2e1b5d51d1bb008938f5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">unity引擎简介——（1）Unity3D游戏开发流程与规范</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1485b8361628372b2d54e847adf85462/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">spring boot: Whitelabel Error Page的解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>