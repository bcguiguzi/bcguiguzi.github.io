<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CMakelist专题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CMakelist专题" />
<meta property="og:description" content="目录 参考文献内置变量常用API构建子cmakelist引入第三方库 参考文献 参考1
参考2
参考3官网qnx交叉编译
内置变量 CMAKE_CURRENT_LIST_FILE: 当前处理的 CMakeLists.txt 文件的完整路径。CMAKE_CURRENT_LIST_DIR: 当前处理的 CMakeLists.txt 文件所在的目录路径。CMAKE_CURRENT_FUNCTION: 当前调用的函数名。PROJECT_NAME: 项目名称，由 project() 命令设置。CMAKE_MODULE_PATH: 模块查找路径，由 set(CMAKE_MODULE_PATH ...) 命令设置。CMAKE_PREFIX_PATH: 前缀路径，由 set(CMAKE_PREFIX_PATH ...) 命令设置，指定项目依赖库的安装路径。CMAKE_BUILD_TYPE: 构建类型，可选项为 Debug 或 Release，由 set(CMAKE_BUILD_TYPE ...) 命令设置。CMAKE_INSTALL_PREFIX: 安装路径，由 set(CMAKE_INSTALL_PREFIX ...) 命令设置，指定项目安装路径。 常用API set 设置参数，包含一般/缓存/环境变量。 PARENT_SCOPE
【不加：子目录修改父目录变量效果只能作用域子目录，父目录读取该变量值不变；父目录读不到子目录的变量值】 list 针对列表操作，比如针对文件列表/参数列表/编译列表的增加删除这些。file 针对文件操作，如收集文件列表，读写文件等。string 针对字符串的操作，如大小写，查找，正则表达式匹配等。message 打印消息,可以跟踪测试修改。message(“${aa}”)mark_as_advanced(COMPILER_BIN_PATH) 没有$变量!!标记已命名的缓冲变量为advanced，advanced变量不会在cmake图形界面中显示除非advanced选项开启foreach 循环target_compile_options()：指定目标的编译选项target_link_libraries：将已知库链接到一个目标上(add_executable()或add_library()之类的命令创建)target_include_directories：指定目标包含的头文件路径。 上面3个带有PUBLIC，PRIVATE，INTERFACEPRIVATE：私有的，ab为2个a库，a私有依赖b；prj【a(私有b)】project看不到b的h文件，b只给aPUBLIC：就是指定搜索头文件路径是可见的，这意味着对于调用这个库的prj只需要 include_directories: 添加包含头文件路径。全局包含，向下传递；即如果某个目录的 CMakeLists.txt 中使用了该指令，当前cmakelist及其下所有子cmakelist的目标默认也包含了该目录。add_library：添加h和c文件，生成（静态/动态）库so或者.a文件，默认a库。如果只添加c文件，那么也会添加当前文件夹下的h文件。
动态库libhello.so：add_library( hello SHARED ${libhello_src})
静态库libhello_static.a：ADD_LIBRARY (hello_static STATIC ${LIBHELLO_SRC}
注意： target不能重复，但如果静态库也想是libhello.a，那么就要设置属性get_target_property()；已有同名库时（比如生成静态库libhello.a发现有同名动态库libhello.so那么会删除先前的同名库，可以同上设置属性来避免） add_executable：生成执行文件。add_subdirectory：添加一个子目录并构建该子目录，用于多个Cmakelist构建；aux_source_directory：查找指定目录下的所有源文件(只能找到c)，然后将结果存进指定变量名get_filename_component：获取完整文件名路径的特定部分。add_dependencies：被依赖的项目总是最先构建，这样就不会出现找不到库而报错；add_custom_command ：用户自定义命令target_sources：新的构建子cmakelist方式，更优秀。
编译器相关设置set_source_files_properties：指定源文件一些具体编辑器里的属性，给源文件设置一些属性。set_target_properties：给可执行文件或者库，不能是虚构的变量等设置属性。使用get_property()或get_target_property()命令提取它。结合add_library看例子 希望 “hello_static” 在输出时，不是&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f296e546d6526a0b2f2bd1049215f9b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-23T19:58:02+08:00" />
<meta property="article:modified_time" content="2023-09-23T19:58:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CMakelist专题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">参考文献</a></li><li><a href="#_5" rel="nofollow">内置变量</a></li><li><a href="#API_15" rel="nofollow">常用API</a></li><li><a href="#cmakelist_58" rel="nofollow">构建子cmakelist</a></li><li><a href="#_61" rel="nofollow">引入第三方库</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>参考文献</h2> 
<p><a href="https://zhuanlan.zhihu.com/p/258118287" rel="nofollow">参考1</a><br> <a href="https://zhuanlan.zhihu.com/p/180059502" rel="nofollow">参考2</a><br> <a href="https://cmake.org/cmake/help/v3.6/manual/cmake-toolchains.7.html#cross-compiling-for-qnx" rel="nofollow">参考3官网qnx交叉编译</a></p> 
<h2><a id="_5"></a>内置变量</h2> 
<ul><li><strong>CMAKE_CURRENT_LIST_FILE</strong>: 当前处理的 CMakeLists.txt 文件的完整路径。</li><li><strong>CMAKE_CURRENT_LIST_DIR</strong>: 当前处理的 CMakeLists.txt 文件所在的目录路径。</li><li><strong>CMAKE_CURRENT_FUNCTION</strong>: 当前调用的函数名。</li><li><strong>PROJECT_NAME</strong>: 项目名称，由 <code>project()</code> 命令设置。</li><li><strong>CMAKE_MODULE_PATH</strong>: 模块查找路径，由 <code>set(CMAKE_MODULE_PATH ...)</code> 命令设置。</li><li><strong>CMAKE_PREFIX_PATH</strong>: 前缀路径，由 <code>set(CMAKE_PREFIX_PATH ...)</code> 命令设置，指定项目依赖库的安装路径。</li><li><strong>CMAKE_BUILD_TYPE</strong>: 构建类型，可选项为 Debug 或 Release，由 <code>set(CMAKE_BUILD_TYPE ...)</code> 命令设置。</li><li><strong>CMAKE_INSTALL_PREFIX</strong>: 安装路径，由 <code>set(CMAKE_INSTALL_PREFIX ...)</code> 命令设置，指定项目安装路径。</li></ul> 
<h2><a id="API_15"></a>常用API</h2> 
<ul><li><strong><a href="https://blog.csdn.net/sinat_31608641/article/details/123101969?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165820297616782425183928%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165820297616782425183928&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-123101969-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=cmake%20SET&amp;spm=1018.2226.3001.4187">set</a></strong> 设置参数，包含一般/缓存/环境变量。 
  <ul><li>PARENT_SCOPE<br> 【不加：子目录修改父目录变量效果只能作用域子目录，父目录读取该变量值不变；父目录读不到子目录的变量值】</li></ul> </li><li><strong><a href="https://blog.csdn.net/m0_47448477/article/details/124971222?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165820352116781818787133%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165820352116781818787133&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124971222-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=cmake%20list&amp;spm=1018.2226.3001.4187">list</a></strong> 针对列表操作，比如针对文件列表/参数列表/编译列表的增加删除这些。</li><li><strong><a href="https://blog.csdn.net/m0_47448477/article/details/124971222?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165820352116781818787133%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165820352116781818787133&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124971222-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=cmake%20list&amp;spm=1018.2226.3001.4187">file</a></strong> 针对文件操作，如收集文件列表，读写文件等。</li><li><strong><a href="https://blog.csdn.net/m0_57845572/article/details/118520561?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165819531716781432929259%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165819531716781432929259&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-118520561-null-null.185%5Ev2%5Econtrol&amp;utm_term=string&amp;spm=1018.2226.3001.4450">string</a></strong> 针对字符串的操作，如大小写，查找，正则表达式匹配等。</li><li><strong>message</strong> 打印消息,可以跟踪测试修改。message(“${aa}”)</li><li><strong>mark_as_advanced</strong>(COMPILER_BIN_PATH) 没有$变量!!标记已命名的缓冲变量为advanced，advanced变量不会在cmake图形界面中显示除非advanced选项开启</li><li><strong><a href="https://blog.csdn.net/sinat_31608641/article/details/123171163?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165820263016781685353460%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165820263016781685353460&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-123171163-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=foreach%20cmake&amp;spm=1018.2226.3001.4187">foreach</a></strong> 循环</li><li><strong>target_compile_options</strong>()：指定目标的编译选项</li><li><strong><a href="https://blog.csdn.net/sinat_31608641/article/details/121736503">target_link_libraries</a></strong>：将已知库链接到一个目标上(add_executable()或add_library()之类的命令创建)</li><li><strong><a href="https://blog.csdn.net/tabactivity/article/details/121010400?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168448344616800225554221%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168448344616800225554221&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121010400-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=target_link_libraries%E7%9A%84%E7%94%A8%E6%B3%95&amp;spm=1018.2226.3001.4187">target_include_directories</a></strong>：指定目标包含的头文件路径。 
  <ul><li><a href="https://blog.csdn.net/tabactivity/article/details/121010400?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168448344616800225554221%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168448344616800225554221&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121010400-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=target_link_libraries%E7%9A%84%E7%94%A8%E6%B3%95&amp;spm=1018.2226.3001.4187">上面3个带有PUBLIC，PRIVATE，INTERFACE</a></li><li>PRIVATE：私有的，ab为2个a库，a私有依赖b；prj【a(私有b)】project看不到b的h文件，b只给a</li><li>PUBLIC：就是指定搜索头文件路径是可见的，这意味着对于调用这个库的prj只需要</li></ul> </li><li><strong><a href="https://blog.csdn.net/fengbingchun/article/details/128053704">include_directories</a></strong>: 添加包含头文件路径。全局包含，向下传递；即如果某个目录的 CMakeLists.txt 中使用了该指令，当前cmakelist及其下所有子cmakelist的目标默认也包含了该目录。</li><li><strong>add_library</strong>：添加h和c文件，生成（静态/动态）库so或者.a文件，默认a库。如果只添加c文件，那么也会添加当前文件夹下的h文件。<br> 动态库libhello.so：add_library( hello SHARED ${libhello_src})<br> 静态库libhello_static.a：ADD_LIBRARY (hello_static STATIC ${LIBHELLO_SRC}<br> 注意： 
  <ul><li>target不能重复，但如果静态库也想是libhello.a，那么就要设置属性get_target_property()；</li><li>已有同名库时（比如生成静态库libhello.a发现有同名动态库libhello.so那么会删除先前的同名库，可以同上设置属性来避免）</li></ul> </li><li><strong>add_executable</strong>：生成执行文件。</li><li><strong><a href="https://blog.csdn.net/u013250861/article/details/127936469?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-127936469-blog-117400413.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-127936469-blog-117400413.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=5">add_subdirectory</a></strong>：添加一个子目录并构建该子目录，用于多个Cmakelist构建；</li><li><strong><a href="http://events.jianshu.io/p/4d25780d6070" rel="nofollow">aux_source_directory</a></strong>：查找指定目录下的所有源文件(只能找到c)，然后将结果存进指定变量名</li><li><strong><a href="https://blog.csdn.net/m0_57845572/article/details/118520591?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165819516116782390553878%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=165819516116782390553878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-3-118520591-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=get_filename_component%20name&amp;spm=1018.2226.3001.4187">get_filename_component</a></strong>：获取完整文件名路径的特定部分。</li><li><strong><a href="https://blog.csdn.net/BeanGuohui/article/details/120217097?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=add_dependencies&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-120217097.nonecase&amp;spm=1018.2226.3001.4187">add_dependencies</a></strong>：被依赖的项目总是最先构建，这样就不会出现找不到库而报错；</li><li><strong><a href="https://blog.csdn.net/qq_38410730/article/details/102797448?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165820435116781818733229%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165820435116781818733229&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-102797448-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=add_custom_command&amp;spm=1018.2226.3001.4187">add_custom_command</a></strong> ：用户自定义命令</li><li><strong><a href="https://blog.csdn.net/guaaaaaaa/article/details/125601766?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165845424416782350819162%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165845424416782350819162&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-125601766-null-null.142%5Ev33%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=target_sources&amp;spm=1018.2226.3001.4187">target_sources</a></strong>：新的构建子cmakelist方式，更优秀。<br> 编译器相关设置</li><li><strong><a href="https://blog.csdn.net/aihe1907/article/details/101198761?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165820404316782395329731%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165820404316782395329731&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-101198761-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=%20set_source_files_properties&amp;spm=1018.2226.3001.4187">set_source_files_properties</a></strong>：指定源文件一些具体编辑器里的属性，给源文件设置一些属性。</li><li><strong><a href="https://blog.csdn.net/sinat_31608641/article/details/121712590?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165820429416781667869072%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165820429416781667869072&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-121712590-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=set_target_properties&amp;spm=1018.2226.3001.4187">set_target_properties</a></strong>：给可执行文件或者库，不能是虚构的变量等设置属性。使用get_property()或get_target_property()命令提取它。结合add_library看例子 
  <ul><li>希望 “hello_static” 在输出时，不是"hello_static"，而是以"hello"的名字显示<br> SET_TARGET_PROPERTIES (hello_static PROPERTIES OUTPUT_NAME “hello”)<br> GET_TARGET_PROPERTY (OUTPUT_VALUE hello_static OUTPUT_NAME) 最终结果是OUTPUT_NAME</li><li>生成同名库避免删除以前的库，使用SET_TARGET_PROPERTIES定义 CLEAN_DIRECT_OUTPUT属性。<br> SET_TARGET_PROPERTIES (hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1)<br> SET_TARGET_PROPERTIES (hello PROPERTIES CLEAN_DIRECT_OUTPUT 1)</li><li>按照规则，动态库是应该包含一个版本号的， VERSION指代动态库版本，SOVERSION指代API版本。<br> SET_TARGET_PROPERTIES (hello PROPERTIES VERSION 1.2 SOVERSION 1)</li></ul> </li><li><strong><a href="https://blog.csdn.net/zhizhengguan/article/details/118397540?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165820423216781647527649%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=165820423216781647527649&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-4-118397540-null-null.142%5Ev32%5Epc_rank_34,185%5Ev2%5Econtrol&amp;utm_term=get_target_property&amp;spm=1018.2226.3001.4187">get_target_property</a></strong>： 获取可执行文件或者库中的属性值，并用一个变量接收。</li><li><a href="https://blog.csdn.net/wanglei_11/article/details/127697273">set_property</a>：也是给文件、可执行文件设置属性。</li></ul> 
<h2><a id="cmakelist_58"></a>构建子cmakelist</h2> 
<ul><li>在顶层CmakeList中，使用<strong>add_subdirectory</strong>，这个文件内一般会包含add_library或<strong>add_executable</strong></li><li>用各目录的函数在cmakelsit怎么写，看<strong>加入三方静态库</strong></li></ul> 
<h2><a id="_61"></a>引入第三方库</h2> 
<ul><li> <p><strong>find_package(LibaryName）</strong>：用于查找包（通常是使用三方库），并返回关于包的细节（使用包所依赖的头文件、库文件、编译选项、链接选项等），是一个.cmake文件</p> 
  <ul><li>find_package(OpenCV REQUIRED)<br> REQUIRED表示一定要找到这个库，找不到这个库，编译就直接结束，不再往下进行</li><li>如果前面使用了find_package查找到了opencv库【if(OpenCV_FOUND)判断】，那么就可以使用 
    <ul><li>引入头文件目录：include_directories(${OpenCV_INCLUDE_DIRS})</li><li>链接库文件 ：target_link_libraries(main ${OpenCV_LIBRARIES})</li></ul> </li></ul> </li><li> <p><strong>加入三方静态库</strong><br> 无论是加入外部三方库，还是各目录互相调用，都是要加以下两句：</p> 
  <ul><li><code>target_link_libraries(${PROJECT_NAME} "${CMAKE_CURRENT_LIST_DIR}/../../lib/rf_control.a")</code></li><li><code>target_include_directories( ${PROJECT_NAME} PRIVATE "${CMAKE_CURRENT_LIST_DIR}/../../inc/rf_control"）</code></li></ul> </li></ul> 
<blockquote> 
 <ul><li>使用外部三方库，除了本身的程序需要链接到静态库，还需要知道改库的接口函数，也就是要include头文件。其中 “PRIVATE“ 还是“”public“都没影响。</li><li>当构建子目录时， 需要注意 “PRIVATE“ 和 “PUBLIC”的含义，当子目录add_library生成静态库时，如果试用PUBLIC，target_include_directories( 库 PUBLIC 头文件路径 ）， 那么该路径对于别的目录是可见的，其他目录调用该库时只要link静态库即可。如果使用PRIVATE或者不写target_include_directories，那么需要在调用处的cmaklist做target_include_directories。</li><li>因此,构建子目录建议生成库后要么都使用PUBLIC添加头文件路径，要么都不写。</li></ul> 
</blockquote> 
<ul><li><strong>c文件中，引用头文件为什么有路径"/"：</strong><br> 构建子目录时，在生成库时<code>target_include_directories( 库 PRIVATE 头文件路径 ）</code>或者不做该操作，那么该目录对于别的目录不可见，是添加这个头文件的c文件，和这个头文件的相对路径<code>#include "../aa.h"</code>；<br> 如果使用 PUBLIC，那么直接<code>#include "aa.h"</code>；</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fbab7bdf44bc47b19450fad7ef0e5873/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QNX交叉编译</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b785c37956c146093830c0c34fa70e36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">cmd基础命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>