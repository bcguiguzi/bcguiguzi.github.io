<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端实现下载文件的各种方式 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端实现下载文件的各种方式" />
<meta property="og:description" content="前端涉及到的文件下载还是很多应用场景的，那么前端文件下载有多少种方式呢？每种方式有什么优缺点呢？下面就来一一介绍。
1. a 标签 通过a标签的download属性来实现文件下载，这种方式是最简单的，也是我们比较常用的方式，先来看示例代码：
&lt;a href=&#34;http://www.baidu.com&#34; download=&#34;baidu.html&#34;&gt;下载&lt;/a&gt; 就上面的这个示例，我们点击下载，发现是跳转到了百度的首页，并没有真的下载文件。
因为a标签下载只能下载同源的文件，如果是跨域的文件，这里包括图片、音视频等媒体文件，都是预览，也无法下载。
上面的代码是直接通过书写a标签来实现文件下载，我们也可以通过js来实现，代码如下：
const a = document.createElement(&#39;a&#39;) a.href = &#39;http://www.baidu.com&#39; a.download = &#39;baidu.html&#39; a.click() 效果和上面的一样，都是跳转到百度的首页，没有下载文件。
这里的重点是a标签的download属性，这个属性是HTML5新增的。
它的作用是指定下载的文件名，如果不指定，那么下载的文件名就会根据请求内容的Content-Disposition来确定，如果没有Content-Disposition，那么就会使用请求的URL的最后一部分作为文件名。
2. window.open 上面使用a标签的案例也可以通过window.open来实现，效果是一样的，代码如下：
window.open(&#39;http://www.baidu.com&#39;, &#39;_blank&#39;) 这里的_blank是指定打开的方式，如果不指定，那么就会在当前页面打开，这里指定_blank，就是在新的页面打开。
同样a标签的download属性也是可以使用的，代码如下：
window.open(&#39;http://www.baidu.com&#39;, &#39;_blank&#39;, &#39;download=baidu.html&#39;) 当然这种方式也是有缺陷的，对比于a标签，这种方式不能下载.html、.htm、.xml、.xhtml等文件，因为这些文件会被当成html文件来处理，所以会直接在当前页面打开。
同样也不能下载跨域的文件，毕竟是window.open，不是window.download（window.download是假想）。
3. location.href 这种方式和window.open(url)是一样的，代码如下：
location.href = &#39;http://www.baidu.com&#39; 这种方式拥有window.open的所有缺陷，所以不推荐使用，这里只当作了解，所以不做过多的讲解。
4. location.?其他属性 这里的其他指代的都是能跳转页面的属性，比如location.assign、location.replace、location.reload等，这些属性都是可以实现文件下载的，代码如下：
location.assign(&#39;http://www.baidu.com&#39;) location.replace(&#39;http://www.baidu.com&#39;) location.reload(&#39;http://www.baidu.com&#39;) 这里的location.reload是有点特殊的，它的作用是重新加载当前页面，但是它也可以接受一个参数，这个参数就是要跳转的页面，所以也可以实现文件下载。
当然同location.href一样，这些方式的缺点都一样，同时还有属于每个属性自身的特性，这里只当拓展知识，不做过多的讲解。
5. XMLHttpRequest 这种方式就是我们常说的ajax下载，包括axios、fetch等都是相同的，代码如下：
const xhr = new XMLHttpRequest() xhr.open(&#39;GET&#39;, &#39;http://www.baidu.com&#39;) xhr.send() xhr.onload = function () { const blob = new Blob([xhr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/776dde2720c01ddbb65789417861fbf5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-16T08:46:40+08:00" />
<meta property="article:modified_time" content="2023-08-16T08:46:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端实现下载文件的各种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前端涉及到的文件下载还是很多应用场景的，那么前端文件下载有多少种方式呢？每种方式有什么优缺点呢？下面就来一一介绍。</p> 
<h3>1. a 标签</h3> 
<p>通过<code>a</code>标签的<code>download</code>属性来实现文件下载，这种方式是最简单的，也是我们比较常用的方式，先来看示例代码：</p> 
<pre><code class="language-html">&lt;a href="http://www.baidu.com" download="baidu.html"&gt;下载&lt;/a&gt;</code></pre> 
<p>就上面的这个示例，我们点击下载，发现是跳转到了百度的首页，并没有真的下载文件。</p> 
<p>因为<code>a</code>标签下载只能下载同源的文件，如果是跨域的文件，这里包括图片、音视频等媒体文件，都是预览，也无法下载。</p> 
<p>上面的代码是直接通过书写<code>a</code>标签来实现文件下载，我们也可以通过<code>js</code>来实现，代码如下：</p> 
<pre><code class="language-javascript">const a = document.createElement('a')
a.href = 'http://www.baidu.com'
a.download = 'baidu.html'
a.click()
</code></pre> 
<p>效果和上面的一样，都是跳转到百度的首页，没有下载文件。</p> 
<p>这里的重点是<code>a</code>标签的<code>download</code>属性，这个属性是<code>HTML5</code>新增的。</p> 
<p>它的作用是指定下载的文件名，如果不指定，那么下载的文件名就会根据请求内容的<code>Content-Disposition</code>来确定，如果没有<code>Content-Disposition</code>，那么就会使用请求的<code>URL</code>的最后一部分作为文件名。</p> 
<h3>2. window.open</h3> 
<p>上面使用<code>a</code>标签的案例也可以通过<code>window.open</code>来实现，效果是一样的，代码如下：</p> 
<pre><code class="language-javascript">window.open('http://www.baidu.com', '_blank')
</code></pre> 
<p>这里的<code>_blank</code>是指定打开的方式，如果不指定，那么就会在当前页面打开，这里指定<code>_blank</code>，就是在新的页面打开。</p> 
<p>同样<code>a</code>标签的<code>download</code>属性也是可以使用的，代码如下：</p> 
<pre><code class="language-javascript">window.open('http://www.baidu.com', '_blank', 'download=baidu.html')
</code></pre> 
<p>当然这种方式也是有缺陷的，对比于<code>a</code>标签，这种方式不能下载<code>.html</code>、<code>.htm</code>、<code>.xml</code>、<code>.xhtml</code>等文件，因为这些文件会被当成<code>html</code>文件来处理，所以会直接在当前页面打开。</p> 
<p>同样也不能下载跨域的文件，毕竟是<code>window.open</code>，不是<code>window.download</code>（<code>window.download</code>是假想）。</p> 
<h3>3. location.href</h3> 
<p>这种方式和<code>window.open(url)</code>是一样的，代码如下：</p> 
<pre><code class="language-javascript">location.href = 'http://www.baidu.com'
</code></pre> 
<p>这种方式拥有<code>window.open</code>的所有缺陷，所以不推荐使用，这里只当作了解，所以不做过多的讲解。</p> 
<h3>4. location.?其他属性</h3> 
<p>这里的其他指代的都是能跳转页面的属性，比如<code>location.assign</code>、<code>location.replace</code>、<code>location.reload</code>等，这些属性都是可以实现文件下载的，代码如下：</p> 
<pre><code class="language-javascript">location.assign('http://www.baidu.com')
location.replace('http://www.baidu.com')
location.reload('http://www.baidu.com')</code></pre> 
<p>这里的<code>location.reload</code>是有点特殊的，它的作用是重新加载当前页面，但是它也可以接受一个参数，这个参数就是要跳转的页面，所以也可以实现文件下载。</p> 
<p>当然同<code>location.href</code>一样，这些方式的缺点都一样，同时还有属于每个属性自身的特性，这里只当拓展知识，不做过多的讲解。</p> 
<h3>5. XMLHttpRequest</h3> 
<p>这种方式就是我们常说的<code>ajax</code>下载，包括<code>axios</code>、<code>fetch</code>等都是相同的，代码如下：</p> 
<pre><code class="language-javascript">const xhr = new XMLHttpRequest()
xhr.open('GET', 'http://www.baidu.com')
xhr.send()

xhr.onload = function () {
  const blob = new Blob([xhr.response], { type: 'text/html' })
  const a = document.createElement('a')
  a.href = URL.createObjectURL(blob)
  a.download = 'baidu.html'
  a.click()
}</code></pre> 
<p>这里就不讲和<code>XMLHttpRequest</code>相关的知识了，只讲和文件下载相关的部分。</p> 
<p>这里主要的逻辑是当我们的请求成功后，我们会拿到响应体的<code>response</code>，这个<code>response</code>就是我们要下载的内容，然后我们把它转换成<code>blob</code>对象，然后通过<code>URL.createObjectURL</code>来创建一个<code>url</code>，然后通过<code>a</code>标签的<code>download</code>属性来实现文件下载。</p> 
<p>这里的知识点就有两个，一个是<code>blob</code>对象，一个是<code>URL.createObjectURL</code>。</p> 
<h4>5.1 blob</h4> 
<p>下面是<code>blob</code>对象的定义，来自MDN[2]：</p> 
<blockquote> 
 <p><code>Blob</code>对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <code>ReadableStream</code> 来用于数据操作。</p> 
 <p><code>Blob</code>表示的不一定是<code>JavaScript</code>原生格式的数据。<code>File</code> 接口基于 <code>Blob</code>，继承了<code>blob</code>的功能并将其扩展以支持用户系统上的文件。</p> 
</blockquote> 
<p><code>blob</code>对象是<code>html5</code>新增的对象，它的作用是用来存储二进制数据的，比如图片、视频、音频等，它的使用方法如下：</p> 
<pre><code class="language-javascript">/**
 * @param {Array} array 二进制数据
 * @param {Object} options 配置项
 * @param {String} options.type 文件类型，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。
 * @param {String} options.endings 用于指定包含行结束符\n的字符串如何被写入。默认为transparent，表示不会修改行结束符。还可以指定为native，表示会将\n转换为\r\n。
 */
const blob = new Blob([], { type: '' })

</code></pre> 
<p>这里主要关注的是<code>type</code>属性，默认情况下，<code>blob</code>对象是没有<code>type</code>属性的，那么这个<code>Blob</code>就是一个无类型的<code>Blob</code>，文件不会损毁，但是无法被正常识别。</p> 
<h4>5.2 URL.createObjectURL</h4> 
<p>下面来自MDN[3]：</p> 
<blockquote> 
 <p>URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的 URL 对象表示指定的 File 对象或 Blob 对象。</p> 
</blockquote> 
<p>这个方法是用来创建一个<code>url</code>的，它的作用是把一个<code>blob</code>对象转换成一个<code>url</code>，这个<code>url</code>可以用来下载文件，也可以用来预览文件，代码如下：</p> 
<pre><code class="language-javascript">const url = URL.createObjectURL(blob)</code></pre> 
<p>这里需要注意的是，这个<code>url</code>的生命周期和创建它的窗口中的<code>document</code>绑定，也就是说，当我们的<code>document</code>被销毁后，这个<code>url</code>就会失效，所以我们需要在合适的时机销毁它，代码如下：</p> 
<pre><code class="language-javascript">URL.revokeObjectURL(url)
</code></pre> 
<hr> 
<p>回到我们刚才下载的问题，我们是通过<code>blob</code>对象来解决，但是我们的<code>type</code>属性是写死的，如果在文件类型是确定的情况下是没问题的，但是如果这个接口就是下载文件的接口，文件可能是各种类型的，我们应该怎么处理？</p> 
<p>这里的没有正确答案，第一个可以和接口提供者进行协商，协商方案是不确定的，第二就是通过<code>response</code>的<code>header</code>来获取文件的<code>type</code>，也是我们要讲的：</p> 
<pre><code class="language-javascript">const type = response.headers['content-type']

const blob = new Blob([response.data], { type })</code></pre> 
<p>这里我们通过<code>response</code>的<code>header</code>来获取<code>type</code>，然后再创建<code>blob</code>对象，这样就可以正确的下载文件了。</p> 
<p>其实<code>content-type</code>也可能是<code>application/octet-stream</code>，这个时候我们就需要通过<code>file-type</code>来获取文件的<code>type</code>了。</p> 
<p>下面的代码是通过<code>file-type</code>来获取文件的<code>type</code>：</p> 
<pre><code class="language-javascript">import {fileTypeFromStream} from 'file-type';

const type = await fileTypeFromStream(response.body);
const blob = new Blob([response.data], { type })
</code></pre> 
<h3>6. FileSaver.js插件</h3> 
<h4>6.1 简介</h4> 
<p>FileSaver.js 是在<a href="https://so.csdn.net/so/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&amp;spm=1001.2101.3001.7020" title="客户端">客户端</a>保存文件的解决方案，非常适合在客户端生成文件的 Web 应用程序</p> 
<h4><a name="t1"></a><a id="_3"></a>6.2 基本使用</h4> 
<p>以下内容基于官方文档，<a href="https://gitcode.net/mirrors/eligrey/FileSaver.js" rel="nofollow" title="官方文档传送门">官方文档传送门</a></p> 
<p><strong>注意：存在文件保存的大小限制，具体大小看官方文档</strong></p> 
<p><strong>6.2.1 安装</strong></p> 
<pre><code>npm install file-saver --save
</code></pre> 
<p><strong>6.2.2 语法</strong></p> 
<pre><code>import FileSaver from 'file-saver';

FileSaver saveAs(Blob/File/Url,fileType)
// 参数1：支持的类型：blob（二进制）、File（文件）、Url（url链接）
// 参数2：文件类型
</code></pre> 
<p><a href="https://tool.oschina.net/commons" rel="nofollow" title="HTTP Content-type对照表">HTTP Content-type对照表</a></p> 
<p><strong>6.2.3 保存文本</strong></p> 
<pre><code>// 保存文本
saveText() {
    // 创建二进制文件
    let blob = new Blob(['保存一个文本'],{type: 'text/plain;charset=utf-8'});
    FileSaver.saveAs(blob,'a.txt');
}
</code></pre> 
<p>结果：<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/6c/17/F07p5MZB_o.png"></p> 
<p><strong>6.2.4 保存url</strong></p> 
<pre><code> saveUrl() {
     FileSaver.saveAs('https://ppt.1ppt.com/uploads/soft/2202/1-2202231A334.zip', 'a.zip');
 }
</code></pre> 
<p>碰到了几个问题，知道如何解决的麻烦说一下.<br> 1、对于图片、视频这样可以在浏览器打开的文件，不会下载，而是在浏览器新窗口里打开<br> 这个问题应该可以通过：使用saveAs方法时设置文件类型；或者将文件转成二进制流，下载二进制流（未尝试）</p> 
<p><strong>6.2.5 保存canvas</strong></p> 
<pre><code>var canvas = document.getElementById("my-canvas");
canvas.toBlob(function(blob) {
    saveAs(blob, "pretty image.png");
});
</code></pre> 
<p>这个没有试过</p> 
<p><strong>6.2.6 保存文件</strong></p> 
<pre><code> saveFile() {
      let file = new File(['保存一个文件'],'a.txt',{type: 'text/plain;charset=utf-8'});
      FileSaver.saveAs(file);
 }
</code></pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/25/e7/psN4sYQZ_o.png"></p> 
<h3>7. 总结</h3> 
<p>上面的方案这么多，其实最终还是落到<code>a</code>标签上，所以不管是通过浏览器的内置行为进行下载，还是通过<code>ajax</code>进行下载，文件下载的最终还是浏览器的行为。</p> 
<p style="text-align:center;">---END---</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c30c7c055387c6a00f51f06df29d69d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">谈谈 Java 日志</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8f29f81b2aa514ceafc3a7c152ceccc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">dmesg实时打印内核</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>