<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>正则表达式regular expression详述 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="正则表达式regular expression详述" />
<meta property="og:description" content="正则表达式是regular expression，看来英文比中文要好理解多了，就是检查表达式符 不符合规定！！正则表达式有一个功能十分强大而又十分复杂的对象RegExp，在Javascript1.2 版本以 上提供。 下面我们看看有关正则表达式的介绍： 正则表达式对象用来规范一个规范的表达式(也就是表达式符不符合特定的要求，比如是不是Email 地址格式等)，它具有用来检查给出的字符串是否符合规则的属性和方法。 除此之外，你用RegExp构造器建立的个别正则表达式对象的属性，就已经预先定义好了正则表达式 对象的静态属性，你可以随时使用它们。 核心对象： 在Javascript 1.2, NES 3.0以上版本提供。 在Javascript 1.3以后版本增加了toSource方法。 建立方法： 文字格式或RegExp构造器函数。 文字建立格式使用以下格式： /pattern/flags即/模式/标记 构造器函数方法使用方法如下： new RegExp(&#34;pattern&#34;[, &#34;flags&#34;])即new RegExp(&#34;模式&#34;[,&#34;标记&#34;]) 参数： pattern(模式) 表示正则表达式的文本 flags(标记) 如果指定此项，flags可以是下面值之一： g: global match(全定匹配) i: ignore case(忽略大小写) gi: both global match and ignore case(匹配所有可能的值，也忽略大小写) 注意：文本格式中的参数不要使用引号标记，而构造器函数的参数则要使用引号标记。所以下面的 表达式建立同样的正则表达式： /ab&#43;c/i new RegExp(&#34;ab&#43;c&#34;, &#34;i&#34;) 描述： 当使用构造函数的时候，必须使用正常的字符串避开规则(在字符串中加入前导字符/ )是必须的。 例如，下面的两条语句是等价的： re = new RegExp(&#34;//w&#43;&#34;) re = //w&#43;/ 下面的提供了在正则表达式中能够使用的完整对特殊字符的一个完整的列表和描述。 表1.3：正则表达式中的特殊字符： 字符/ 意义：对于字符，通常表示按字面意义，指出接着的字符为特殊字符，/不作解释。 例如：/b/匹配字符&#39;b&#39;,通过在b 前面加一个反斜杠/，也就是//b/，则该字符变成特殊字符，表示 匹配一个单词的分界线。 或者： 对于几个字符，通常说明是特殊的，指出紧接着的字符不是特殊的，而应该按字面解释。 例如：*是一个特殊字符，匹配任意个字符(包括0个字符)；例如：/a*/意味匹配0个或多个a。 为了匹配字面上的*，在a前面加一个反斜杠；例如：/a/*/匹配&#39;a*&#39;。 字符^ 意义：表示匹配的字符必须在最前边。 例如：/^A/不匹配&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/cff49a86ed520bdd8314e68036756828/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2004-08-21T14:35:00+08:00" />
<meta property="article:modified_time" content="2004-08-21T14:35:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">正则表达式regular expression详述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>正则表达式是regular expression，看来英文比中文要好理解多了，就是检查表达式符 <br>不符合规定！！正则表达式有一个功能十分强大而又十分复杂的对象RegExp，在Javascript1.2 版本以 <br>上提供。 <br>下面我们看看有关正则表达式的介绍： <br>正则表达式对象用来规范一个规范的表达式(也就是表达式符不符合特定的要求，比如是不是Email <br>地址格式等)，它具有用来检查给出的字符串是否符合规则的属性和方法。 <br>除此之外，你用RegExp构造器建立的个别正则表达式对象的属性，就已经预先定义好了正则表达式 <br>对象的静态属性，你可以随时使用它们。 <br>核心对象： <br>在Javascript 1.2, NES 3.0以上版本提供。 <br>在Javascript 1.3以后版本增加了toSource方法。 <br>建立方法： <br>文字格式或RegExp构造器函数。 <br>文字建立格式使用以下格式： <br>/pattern/flags即/模式/标记 </p> 
<p>构造器函数方法使用方法如下： <br>new RegExp("pattern"[, "flags"])即new RegExp("模式"[,"标记"]) </p> 
<p>参数： <br>pattern(模式) <br>表示正则表达式的文本 </p> 
<p>flags(标记) <br>如果指定此项，flags可以是下面值之一： <br>g: global match(全定匹配) <br>i: ignore case(忽略大小写) <br>gi: both global match and ignore case(匹配所有可能的值，也忽略大小写) </p> 
<p>注意：文本格式中的参数不要使用引号标记，而构造器函数的参数则要使用引号标记。所以下面的 <br>表达式建立同样的正则表达式： <br>/ab+c/i <br>　　new RegExp("ab+c", "i") </p> 
<p>描述： <br>当使用构造函数的时候，必须使用正常的字符串避开规则(在字符串中加入前导字符/ )是必须的。 <br>例如，下面的两条语句是等价的： <br>re = new RegExp("//w+") <br>re = //w+/ </p> 
<p>下面的提供了在正则表达式中能够使用的完整对特殊字符的一个完整的列表和描述。 </p> 
<p>表1.3：正则表达式中的特殊字符： </p> 
<p>字符/ <br>意义：对于字符，通常表示按字面意义，指出接着的字符为特殊字符，/不作解释。 <br>例如：/b/匹配字符'b',通过在b 前面加一个反斜杠/，也就是//b/，则该字符变成特殊字符，表示 <br>匹配一个单词的分界线。 <br>或者：  <br>对于几个字符，通常说明是特殊的，指出紧接着的字符不是特殊的，而应该按字面解释。 <br>例如：*是一个特殊字符，匹配任意个字符(包括0个字符)；例如：/a*/意味匹配0个或多个a。 <br>为了匹配字面上的*，在a前面加一个反斜杠；例如：/a/*/匹配'a*'。 </p> 
<p>字符^ <br>意义：表示匹配的字符必须在最前边。 <br>例如：/^A/不匹配"an A,"中的'A'，但匹配"An A."中最前面的'A'。 </p> 
<p>字符$ <br>意义：与^类似，匹配最末的字符。 <br>例如：/t$/不匹配"eater"中的't'，但匹配"eat"中的't'。 </p> 
<p>字符* <br>意义：匹配*前面的字符0次或n次。 <br>例如:/bo*/匹配"A ghost booooed"中的'boooo'或"A bird warbled"中的'b'，但不匹配"A goat g <br>runted"中的任何字符。 </p> 
<p>字符+ <br>意义：匹配+号前面的字符1次或n次。等价于{1,}。 <br>例如：/a+/匹配"candy"中的'a'和"caaaaaaandy."中的所有'a'。 </p> 
<p>字符? <br>意义：匹配?前面的字符0次或1次。 <br>例如：/e?le?/匹配"angel"中的'el'和"angle."中的'le'。 </p> 
<p>字符. <br>意义：(小数点)匹配除换行符外的所有单个的字符。 <br>例如：/.n/匹配"nay, an apple is on the tree"中的'an'和'on'，但不匹配'nay'。 </p> 
<p><br>字符(x) <br>意义：匹配'x'并记录匹配的值。 <br>例如：/(foo)/匹配和记录"foo bar."中的'foo'。匹配子串能被结果数组中的素[1], ..., [n] 返 <br>回，或被RegExp对象的属性$1, ..., $9返回。 </p> 
<p>字符x|y <br>意义：匹配'x'或者'y'。 <br>例如：/green|red/匹配"green apple"中的'green'和"red apple."中的'red'。 </p> 
<p>字符{n} <br>意义：这里的n是一个正整数。匹配前面的n个字符。 <br>例如：/a{2}/不匹配"candy,"中的'a'，但匹配"caandy," 中的所有'a'和"caaandy."中前面的两个 <br>'a'。 </p> 
<p>字符{n,} <br>意义：这里的n是一个正整数。匹配至少n个前面的字符。 <br>例如：/a{2,}不匹配"candy"中的'a'，但匹配"caandy"中的所有'a'和"caaaaaaandy."中的所有'a' </p> 
<p>字符{n,m} <br>意义：这里的n和m都是正整数。匹配至少n个最多m个前面的字符。 <br>例如：/a{1,3}/不匹配"cndy"中的任何字符，但匹配 "candy,"中的'a'，"caandy," 中的前面两个 <br>'a'和"caaaaaaandy"中前面的三个'a'，注意：即使"caaaaaaandy" 中有很多个'a'，但只匹配前面的三 <br>个'a'即"aaa"。 </p> 
<p>字符[xyz] <br>意义：一字符列表，匹配列出中的任一字符。你可以通过连字符-指出一个字符范围。 <br>例如：[abcd]跟[a-c]一样。它们匹配"brisket"中的'b'和"ache"中的'c'。 </p> 
<p>字符[^xyz] <br>意义：一字符补集，也就是说，它匹配除了列出的字符外的所有东西。 你可以使用连字符-指出一 <br>字符范围。 <br>例如：[^abc]和[^a-c]等价，它们最早匹配"brisket"中的'r'和"chop."中的'h'。 </p> 
<p>字符[/b] <br>意义：匹配一个空格(不要与/b混淆) </p> 
<p>字符/b <br>意义：匹配一个单词的分界线，比如一个空格(不要与[/b]混淆) <br>例如：//bn/w/匹配"noonday"中的'no'，//wy/b/匹配"possibly yesterday."中的'ly'。 </p> 
<p>字符/B <br>意义：匹配一个单词的非分界线 <br>例如：//w/Bn/匹配"noonday"中的'on'，/y/B/w/匹配"possibly yesterday."中的'ye'。 </p> 
<p>字符/cX <br>意义：这里的X是一个控制字符。匹配一个字符串的控制字符。 <br>例如：//cM/匹配一个字符串中的control-M。 </p> 
<p>字符/d <br>意义：匹配一个数字，等价于[0-9]。 <br>例如：//d/或/[0-9]/匹配"B2 is the suite number."中的'2'。 </p> 
<p>字符/D <br>意义：匹配任何的非数字，等价于[^0-9]。 <br>例如：//D/或/[^0-9]/匹配"B2 is the suite number."中的'B'。 </p> 
<p>字符/f <br>意义：匹配一个表单符 </p> 
<p>字符/n <br>意义：匹配一个换行符 </p> 
<p>字符/r <br>意义：匹配一个回车符 </p> 
<p>字符/s <br>意义：匹配一个单个white空格符，包括空格，tab，form feed，换行符，等价于[ /f/n/r/t/v]。 <br>例如：//s/w*/匹配"foo bar."中的' bar'。 </p> 
<p>字符/S <br>意义：匹配除white空格符以外的一个单个的字符，等价于[^ /f/n/r/t/v]。 <br>例如：//S//w*匹配"foo bar."中的'foo'。 </p> 
<p>字符/t <br>意义：匹配一个制表符 </p> 
<p>字符/v <br>意义：匹配一个顶头制表符 </p> 
<p>字符/w <br>意义：匹配所有的数字和字母以及下划线，等价于[A-Za-z0-9_]。 <br>例如：//w/匹配"apple,"中的'a'，"$5.28,"中的'5'和"3D."中的'3'。 </p> 
<p>字符/W  <br>意义：匹配除数字、字母外及下划线外的其它字符，等价于[^A-Za-z0-9_]。 <br>例如：//W/或者/[^$A-Za-z0-9_]/匹配"50%."中的'%'。 </p> 
<p>字符/n <br>意义：这里的n是一个正整数。匹配一个正则表达式的最后一个子串的n的值(计数左圆括号)。 </p> 
<p>例如：/apple(,)/sorange/1/匹配"apple, orange, cherry, peach."中的'apple, orange'，下面 <br>有一个更加完整的例子。 <br>注意：如果左圆括号中的数字比/n指定的数字还小，则/n取下一行的八进制escape作为描述。 </p> 
<p>字符/ooctal和/xhex <br>意义：这里的/ooctal是一个八进制的escape值，而/xhex是一个十六进制的escape值，允许在一个 <br>正则表达式中嵌入ASCII码。 </p> 
<p><br>当表达式被检查的时候，文字符号提供了编辑正则表达式的方法。利用文字符号可以使到正则表达 <br>式保持为常数。例如，如果你在一个循环中使用文字符号来构造一个正则表达式，正则表达式不需进行 <br>反复编译。 <br>正则表达式对象构造器，例如，new RegExp("ab+c")，提供正则表达式的运行时编译。当你知道正 <br>则表达式的模式会变化的时候，应该使用构造函数，或者你不知道正则表达式的模式，而它们是从另外 <br>的源获得的时候，比如由用户输入时。一旦你定义好了正则表达式，该正则表达式可在任何地方使用， <br>并且可以改变，你可以使用编译方法来编译一个新的正则表达式以便重新使用。 <br>一个分离预先定义的RegExp对象可以在每个窗口中使用；也就是说，每个分离的Javascript线程运 <br>行以获得自己的RegExp对象。因为每个脚本在一个线程中是不可中断的，这就确保了不同的脚本不会覆 <br>盖RegExp对象的值。 <br>预定义的RegExp对象包含的静态属性：input, multiline, lastMatch,lastParen, leftContext,  <br>rightContext, 以及从$1到$9。input和multiline属性能被预设。其它静态属性的值是在执行个别正则 <br>表达式对象的exec和test方法后，且在执行字符串的match和replace方法后设置的。 </p> 
<p>属性 <br>注意RegExp对象的几个属性既有长名字又有短名字(象Perl)。这些名字都是指向相同的值。Perl是 <br>一种编程语言，而Javascript模仿了它的正则表达式。 </p> 
<p>属性$1, ..., $9 <br>取得匹配的子串，如果有的话 </p> 
<p>属性$_ <br>参考input </p> 
<p>属性$* <br>参考multiline </p> 
<p>属性$&amp; <br>参考lastMatch </p> 
<p>属性$+ <br>参考lastParen </p> 
<p>属性$` <br>参考leftContext </p> 
<p>属性$' <br>参考rightContext </p> 
<p>属性constructor <br>指定用来建立对象原型函 </p> 
<p>属性global <br>决定是否测试正则表达式是否不能匹配所有的字符串，或者只是与最先的冲突。 </p> 
<p>属性ignoreCase <br>决定试图匹配字符串的时候是否忽略大小写 </p> 
<p>属性input <br>当正则表达式被匹配的时候，为相反的字符串。 </p> 
<p>属性lastIndex <br>决定下一次匹配从那里开始 </p> 
<p>属性lastMatch <br>最后一个匹配的字符 </p> 
<p>属性lastParen <br>子串匹配的时候，最后一个parenthesized，如果有的话。 </p> 
<p>属性leftContext <br>最近一次匹配前的子串。 </p> 
<p>属性multiline <br>是否在串的多行中搜索。 </p> 
<p>属性prototype <br>允许附加属性到所有的对象 </p> 
<p>属性rightContext <br>最近一次匹配后的的子串。 </p> 
<p>属性source <br>模式文本 </p> 
<p> </p> 
<p> </p> 
<p>方法 <br>compile方法 <br>编译一个正则表达式对象 </p> 
<p>exec方法 <br>运行正则表达式匹配 </p> 
<p>test方法 <br>测试正则达式匹配 </p> 
<p>toSource方法 <br>返回一个对象的文字描述指定的对象；你可以使用这个值来建立一个新的对象。不考虑Object.toS <br>ource方法。 </p> 
<p>toString方法 <br>返回一个字符串描述指定的对象，不考虑Object.toString对象。 </p> 
<p>valueOf方法 <br>返回指定对角的原始值。不考虑Object.valueOf方法。 </p> 
<p>　另外，这个对象继承了对象的watch和unwatch方法 </p> 
<p> </p> 
<p>　　例子： <br>　　例１、下述示例脚本使用replace方法来转换串中的单词。在替换的文本中，脚本使用全局 RegExp <br>对象的$1和$2属性的值。注意，在作为第二个参数传递给replace方法的时候，RegExp对象的$属性的名 <br>称。 <br>&lt;script LANGUAGE="Javascript1.2"&gt; <br>re = /(/w+)/s(/w+)/; <br>str = "John Smith"; <br>newstr=str.replace(re,"$2, $1"); <br>document.write(newstr) <br>&lt;/script&gt; <br>显示结果："Smith, John".  </p> 
<p>　　例２、下述示例脚本中，RegExp.input由Change事件处理句柄设置。在getInfo函数中，exec 方法 <br>使用RegExp.input的值作为它的参数，注意RegExp预置了$属性。 </p> 
<p><br>&lt;script LANGUAGE="Javascript1.2"&gt; <br>function getInfo(abc) <br>{ <br>re = /(/w+)/s(/d+)/; <br>re.exec(abc.value); <br>window.alert(RegExp.$1 + ", your age is " + RegExp.$2); <br>} <br>&lt;/script&gt; </p> 
<p>　　请输入你的姓和年龄，输入完后按回车键。 <br>　　&lt;FORM&gt;&lt;INPUT TYPE="TEXT" NAME="NameAge" onChange="getInfo(this);"&gt;&lt;/FORM&gt; <br>　　&lt;/HTML&gt; </p> 
<p><br>$1, ..., $9属性 <br>用圆括号括着的匹配子串，如果有的话。 <br>是RegExp的属性 <br>静态，只读 </p> 
<p>在Javascript 1.2, NES 3.0以上版本提供 <br>描述：因为input是静态属性，不是个别正则表达式对象的属性。你可以使用RegExp.input 访问该 <br>属性。 </p> 
<p>能加上圆括号的子串的数量不受限制，但正则表达式对象只能保留最后9 条。如果你要访问所有的 <br>圆括号内的匹配字串，你可以使用返回的数组。 </p> 
<p>这些属性能用在RegExp.replace方法替换后的字符串(输出结果)。当使用这种方式的时候，不用预 <br>先考虑RegExp对象。下面给出例子。当正则表达式中没有包含圆括号的时候，该脚本解释成$n的字面意 <br>义。(这里的n是一个正整数)。 </p> 
<p><br>例如： <br>下例脚本使用replace 方法来交换串中单词的位置。在替换后的文本字串中，脚本使用正则表达式 <br>RegExp对象的$1和$2属性的值。注意：当它们向replace方法传递参数的时候，这里没有考虑 $ 属性的 <br>RegExp对象的名称。 <br>&lt;script LANGUAGE="Javascript1.2"&gt; <br>re = /(/w+)/s(/w+)/; <br>str = "John Smith"; <br>newstr=str.replace(re,"$2, $1"); <br>document.write(newstr) <br>&lt;/script&gt; <br>显示的输出结果为：Smith, John。 <br>  <br>正则表达式详述（二）  </p> 
<p>以下这些不是正则表达式的新增对象请参阅对应的Javascript对象的属性 $_属性 参考input $*属性 <br>参考multiline $&amp;属性 参考lastMatch $+属性 参考lastParen $`属性 <br>参考leftContext $'属性 参考rightContext compile方法 在脚本运行期间编译正则表达式对象 <br>属于RegExp的方法 在Javascript 1.2, NES 3.0以上版本提供 语法： <br>regexp.compile(pattern[, flags]) 以数： regexp 正则表达式的名称，可以是变量名或文字串。  <br>pattern 正则表达式的定义文本。 flags 如果指定的话，可以是下面其中的一个： "g": 匹配所有可能的字串 <br>"i": 忽略大小写 "gi": 匹配所有可能的字串及忽略大小写 描述： <br>使用compile方法来编译一个正则表达式 created with the RegExp constructor function。这样 <br>就强制正则表达式只编译一次，而不是每次遇到正则表达式的时候都编译一次。当你确认正则表达式能 <br>保持不变的时候可使用compile 方法来编译它(在获得它的匹配模式后)，这样就可以在脚本中重复多次使用它。 <br>你亦可以使用compile 方法来改变在运行期间改变正则表达式。例如，假如正则表达式发生变化， <br>你可以使用compile方法来重新编译该对象来提高使用效率。 <br>使用该方法将改变正则表达式的source, global和ignoreCasesource属性的值。 constructor  <br>指出建立对象原型的function。注意这个属性的值由函数本身提供，而不是一个字串包含RegExp的name.Property提供。  <br>在Javascript 1.1, NES 2.0以上版本提供 ECMA版本ECMA-262 描述：参考Object.constructor. <br>exec方法 在指定的字符串运行匹配搜索。返回一个结果数组。 是RegExp的方法  <br>在Javascript 1.2, NES 3.0以上版本提供 语法： regexp.exec([str])regexp([str]) <br>参数： regexp，正则表达式的名称，可以是一个变量名或文字定义串。  <br>str，要匹配正则表达式的字符串，如果省略，将使用RegExp.input的值。  <br>描述：就如在语法描述中的一样，正则表达工的exec方法能够被直接调用(使用regexp.exec(str))或者间接调用(使用regexp(str))。 <br>假如你只是运行以找出是否匹配，可以使用String搜索方法。 <br>假如匹配成功，exec方法返回一个数组并且更新正则表达式对象属性的值和预先定义的正则表达式对象、RegExp。如果匹配失败，exec方法返回null。 <br>请看下例： &lt;script LANGUAGE="Javascript1.2"&gt; //匹配一个b接着一个或多个d，再接着一个b <br>//忽略大小写 myRe=/d(b+)(d)/ig; myArray = myRe.exec("cdbBdbsbz"); <br>&lt;/script&gt; 下面是该脚本的返回值：对象 属性/Index 描述 例子  <br>myArray </p> 
<p>myArray的内容 ["dbBd", "bB", "d"]  <br>index <br>基于0的匹配index 1  <br>input <br>原始字符串 cdbBdbsbz  <br>[0] <br>最后匹配的字符 dbBd  <br>[1], ...[n] <br>用圆括号括住的匹配字符串，如果有的话。不限制括号的个数。 [1] = bB <br>[2] = d  <br>myRe <br>lastIndex <br>开始下次匹配操作的index值 5  <br>ignoreCase <br>指出"i"是否使用以忽略大小写 true  <br>global <br>指出是否使用"g"标记来进行匹配所有可能的字串 true  <br>source <br>定义模式的文本字符串 d(b+)(d)  <br>RegExp <br>lastMatch$&amp; <br>最后匹配的字符 dbBd  <br>leftContext$/Q <br>最新匹配前面的子串 c  <br>rightContext$' <br>最新匹配后面的子串 bsbz  <br>$1, ...$9 <br>圆括号内的匹配子串，如果有的话。圆括号的个数不受限制，但RegExp只能保留最后9个 $1 = bB  <br>$2 = d  <br>lastParen $+ <br>最后一个加上圆括号的匹配子串，如果有的话 d  </p> 
<p>假如你的正则表达式使用了"g"标记，你可以多次使用exec 方法来连续匹配相同的串。当你这样做 <br>的时候，新的匹配将从由正则表达式的lastIndex 属性值确定的子串中开始。例如，假定你使用下面的脚本： <br>&lt;script LANGUAGE="Javascript1.2"&gt; myRe=/ab*/g;str = "abbcdefabh" <br>myArray = myRe.exec(str); <br>document.writeln("Found "+myArray[0]+". Next match starts at "+myRe.lastIndex) <br>mySecondArray = myRe.exec(str); <br>document.writeln("Found "+mySecondArray[0]+". Next match starts at "+myRe.lastIndex) <br>&lt;/script&gt; 这个脚本显示如下结果： Found abb. Next match starts at 3 <br>Found ab. Next match starts at 9 例子： <br>在下面的例子中，用户输入一个名字，脚本根据输入执行匹配操作。接着检查数组看是否和其它用户的名字匹配。 <br>本脚本假定已注册的用户的姓已经存进了数组A中，或许从一个数据库中取得。 &lt;HTML&gt; <br>&lt;script LANGUAGE="Javascript1.2"&gt; A = ["zhao","qian","sun","li","liang"] <br>function lookup() { firstName = //w+/i(); if (!firstName) <br>window.alert (RegExp.input + "非法输入"); else { count=0; <br>for (i=0;i 输入你的姓然后按回车键。 <br>&lt;FORM&gt;&lt;INPUT TYPE:"TEXT" NAME="FirstName" onChange="lookup(this);"&gt;&lt;/FORM&gt; <br>&lt;/HTML&gt; global属性 正则表达式中是否使用了"g"标记。 RegExp属性，只读 <br>在Javascript 1.2, NES 3.0以上版本提供 描述： global是一个个别正则表达式对象的属性 <br>如果使用了"g"标记，global的值为true；否则为 false。"g"标记指定正则表达式测试所有可能的匹配。 <br>你不能直接改变该属性的值，但可以调用compile方法来改变它。 ignoreCase 检查正则表达式是否使用了"i"标记 <br>RegExp属性，只读 在Javascript 1.2, NES 3.0以上版本提供 描述： <br>ignoreCase是个别正则表达式对象的一个属性。 <br>如果使用了"i"标记，则返回true，否则返回false。"i"标记指示在进行匹配的时候忽略大小写。 <br>你不能直接改变该属性的值，但可以通过调用compile方法来改变它 input 指出正则表达式要测试那个字串。$_是这个属性的另一个名字。 <br>RegExp的属性，静态 在Javascript 1.2, NES 3.0以上版本提供  <br>描述：因为input是静态的，不是某个个别的正则表达式对象的属性。你也可以使用 RegExp.input来表示。 <br>如果没有给正则表达式的exec或test方法提供字符串，并且RegExp.input中有值，则使用它的值来调用该方法。 <br>脚本或浏览器能够预置input属性。如果被预置了值且调用exec或 test方法的时候没有提供字符串 <br>则调用exec或test的时候使用input的值。input可以被浏览器以下面的方式设置： <br>当text表单域处理句柄被调用的时候，input被设置为该text输入的字串。 <br>当textarea表单域处理句柄被调用的时候，input被设置为textarea域内输入的字串。注意multili <br>ne亦被设置成true从而能匹配多行文本。 当select表单域处理句柄被调用的时候，input被设置成selected text的值。 <br>当链接对象的处理句柄被调用的时候，input被设置成&lt;A HREF=...&gt;和&lt;/A&gt;之间的字符串。 <br>事件理现句柄处理完毕后，input属性的值被清除。 lastIndex 可读/可写的一个整数属性，指出下一次匹配从哪里开始。 <br>RegExp的属性 在Javascript 1.2, NES 3.0以上版本提供  <br>描述：lastIndex 是个别的正则表达式对象的属性。 这个属性只有当正则表达式的"g"标记被使用以进行全串匹配的时候才被设置。实行以下规则： <br>如果lastIndex大小字符串的长度，regexp.test和regexp.exec失败，且lastIndex被设为0。 <br>如果lastIndex等于字串的长度且正则表达式匹配空字符串，则正则表达式从lastIndex的位置开始匹配。 <br>如果lastIndex等于字符串的长度且正则表达式不匹配空字符串，则正则表达式不匹配input，且lastIndex被置为0。 <br>否则，lastIndex被设置成最近一次匹配的下一点。 例如，按下面的顺序执行脚本： re = /(hi)?/g 匹配空字符串  <br>re("hi") 返回["hi", "hi"]，lastIndex置为2  <br>re("hi") 返回[""]，一个空数组，它的下标为0的元素就是匹配字符串。在这种情况下，返回空 <br>串是因为lastIndex等于2(且仍然是2)，并且"hi"的长度也是2。 lastMatch 最后一次匹配字符串，$&amp;是同样的意思。 <br>RegExp的属性，静态，只读 在Javascript 1.2, NES 3.0以上版本提供  <br>描述：因为lastMatch是静态的，所以它不是个别指定正则表达式的属性。你也可以使用RegExp.lastMatch。 lastParen <br>最后一次加上括号的匹配字符串，如果有的话。$+是同样的意思。 RegExp属性，静态，只读 <br>在Javascript 1.2, NES 3.0以上版本提供  <br>描述：因为lastParen是静态的，它不是某个个别正则式的属性，你可以使用RegExp.lastParen 表达同样的意思。 <br>leftContext 最近一次匹配前面的子串，$`具有相同的意思。 RegExp的属性，静态，只读 <br>在Javascript 1.2, NES 3.0以上版本提供  <br>描述：因为leftContext是静态的，不是某一个正则表达式的属性，所以可以使用RegExp.leftContext来表达想同的意思。 <br>multiline 反映是否匹配多行文本，$*是相同的意思。 RegExp的属性，静态 <br>在Javascript 1.2, NES 3.0以上版本提供  <br>描述：因为multiline是静态的，而不是某个个别正则表达式的属性，所以能够用RegExp.multiline表达相同的意思。 <br>如果允许匹配多行文本，则multiline为true，如果搜索必须在换行时停止，则为false。 <br>脚本或浏览器能够设置multiline属性。当一个textarea的事件处理句柄被调用的时候，multiline <br>被置为true。在事件处理句柄处理完毕后，multiline属性值被清除。也就是说，如果你设置了multili <br>ne为true，则执行任何的事件处理句柄后，multiline被置为false。 prototype  <br>描绘类的原型。你可以根据要求使用prototype来增加类的属性或方法。为了获得prototypes 的资 <br>料，请参阅RegExp的function.prototype.Property属性。 从Javascript 1.1, NES 2.0版本开始提供 <br>ECMA版本ECMA-262 rightContext 最后一次匹配的右边的字符串，$'是同样的效果。 <br>RegExp的属性，静态，只读 从 Javascript 1.2, NES 3.0以上版本开始提供  <br>描述：因为rightContext是静态的，不是某个个别正则表达工的属性，可以使用RegExp.rightContext来达到相同的效果。 <br>source 一个只读属性，包含正则表达式定义的模式，不包侨forward slashes和"g"或"i"标记。 RegExp的属性，只读 <br>从Javascript 1.2, NES 3.0以上版本开始提供  <br>描述：source是个别正则表达式对象的属性，你不能直接改变它的值，但可以通过调用compile 方法来改变它。 test <br>执行指定字符串的正则表达式匹配搜索，返回true或false。 RegExp的方法 <br>从Javascript 1.2, NES 3.0以上版本开始提供 语法：regexp.test([str]) <br>参数：regexp，正则表达式的名称，可以是变量名或正则表达式定义文字串 <br>str，要匹配的字符串，如果省略，将使用RegExp.input的值为作参数 <br>描述：当你需要知道一个字符串能否匹配某个正则表达工，可以使用test方法(与String.search方 <br>法类似)； 为了获得更多的信息(但速度将变慢)，可以使用exec方法(与String.match方法类似)。 例子：下面的例子显示test是否成功的提示： <br>function testinput(re, str){ <br>if (re.test(str)) midstring = " contains "; <br>else midstring = " does not contain "; <br>document.write (str + midstring + re.source); } toSource  <br>返回一个字符串象征对象的源码 RegExp的方法 从Javascript 1.3以上版本开始提供 语法：toSource() <br>参数：没有 描述：toSource方法返回下述的值： 对于内置的RegExp对象，toSource返回下面的字符象征源码不可用： <br>function Boolean(){ [native code] } <br>在RegExp场合中, toSource返回象征源码的字符串，通常这个方法是由Javascript内部自动调用而不是不代码中显式调用。 <br>更多请看Object.toSource toString 返回描绘指定对象的字符串。 RegExp的方法 <br>从Javascript 1.1, NES 2.0开始提供 ECMA版本ECMA-262 语法：toString() 参数：无 <br>描述：RegExp对象不考虑Object对象的toString方法；它不继承Object.toString，对于RegExp 对 <br>象，toString方法返回一个代表该对象的字符串。 例如：下面的例子显示象征RegExp对象的字符串 <br>myExp = new RegExp("a+b+c"); alert(myExp.toString()) <br>displays "/a+b+c/" 更多请看：Object.toString valueOf 返回一个RegExp对象的原始值 <br>RegExp的方法 从Javascript 1.1版本开始提供 ECMA版本：ECMA-262 语法：valueOf() <br>参数：无 描述：RegExp的valueOf方法以字符串形式返回RegExp对象的原始值，这个值与RegExp.toString相等。 <br>该方法通常由Javascript内部自动调用而不是显式调用 例子： myExp = new RegExp("a+b+c"); <br>alert(myExp.valueOf()) displays "/a+b+c/" <br></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5d2a0440a1eeaa960944c271a0c8ee5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">超全的英语短句汇集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1bad77ffd2c17edc94d6e86cbc41764f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">什么是Web Service ?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>