<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习算法背后的数学原理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习算法背后的数学原理" />
<meta property="og:description" content="不同的机器学习算法是如何从数据中学习并预测未知数据的呢?
​ 机器学习算法的设计让它们从经验中学习，当它们获取越来越多的数据时，性能也会越来越高。每种算法都有自己学习和预测数据的思路。在本文中，我们将介绍一些机器学习算法的功能，以及在这些算法中实现的有助于它们学习的一些数学方程。
机器学习算法的类型 机器学习算法大致可以分为以下四类:
**监督学习：**用于预测的目标是已知的情况。这些算法生成一个函数，该函数将输入映射到输出变量。回归和分类算法都属于这一类。在回归中，输出变量是连续的，而在分类中，输出变量包含两个或更多的离散值。监督学习算法包括线性回归，逻辑回归，随机森林，支持向量机，决策树，朴素贝叶斯，神经网络。
**无监督学习：**目标或输出变量是未知的情况。这些算法通常对数据进行分析并生成数据簇。关联、聚类和维数约简算法属于这一类。K-means聚类、PCA(主成分分析)、Apriori算法等也都是非监督学习算法。
**半监督学习：**它是监督和非监督学习方法的结合。它使用已知数据来训练自己，然后标记未知数据。
**强化学习：**机器从“试错”过程中学习的方法。机器从过去的决策经验中学习，并利用它的学习来预测未来决策的结果。强化学习算法的例子有Q-Learning, Temporal Difference等。
线性回归 ​ 线性回归是通过拟合数据点上的最佳直线来预测连续变量的结果。最佳拟合线定义了因变量和自变量之间的关系。该算法试图找到最适合预测目标变量值的直线。通过使数据点与回归线之间的差的平方和最小达到最佳拟合线。
线性回归(来源:onlinestatbook) Equation: Y = c &#43; m₁X₁ &#43; m₂X₂ &#43; …… &#43;mnXn
Y → Dependent Variable or Target Variable
m → Slope
c → Intercept
X → Independent Variables
逻辑回归 ​ 逻辑回归是一种基于自变量估计分类变量结果的分类算法。它通过将数据拟合到logistic函数来预测某一事件发生的概率。通过最大化似然函数，对logistic函数中自变量的系数进行优化。优化决策边界，使成本函数最小。利用梯度下降法可以使代价函数最小化。
逻辑回归的s型曲线 Logistic回归的成本函数 logistic回归方程 朴素贝叶斯算法 ​ 朴素贝叶斯是一种基于贝叶斯定理的分类算法。该算法假设自变量之间不存在相关性。也就是说，一个类中某个特性的出现与同一类中另一个特性的出现是没有关系的。我们针对类为所有预测器创建一个频率表(目标变量的不同值)，并计算所有预测器的可能性。利用朴素贝叶斯方程，计算所有类别的后验概率。朴素贝叶斯分类器的结果将是所有类概率中概率最高的类。
决策树 ​ 决策树主要用于分类问题，但它们也可以用于回归。在该算法中，我们根据有效性划分数据集的属性，将数据集划分为两个或多个同构集。选择将分割数据集的属性的方法之一是计算熵和信息增益。熵反映了变量中杂质的数量。信息增益是父节点的熵减去子节点的熵之和。选择提供最大信息增益的属性进行分割。我们也可以使用基尼指数作为杂质标准来分割数据集。为了防止过度分割，我们优化了max_features、min_samples_split、max_depth等决策树的超参数。
信息熵, c → No. of classes 基尼系数 随机森林 ​ 随机森林由多个决策树组成，作为一个集合来运行。在随机森林中，每棵决策树预测一个类结果，投票最多的类结果成为随机森林的预测项。为了做出准确的预测，决策树之间的相关性应该最小。有两种方法可以确保这一点，即使用Bagging和特性选择。Bagging是一种从数据集中选择随机观察样本的技术。特征选择允许决策树仅在特征的随机子集上建模。这就防止决策树使用相同的特性进行预测的情况。
随机森林(来源:victorzhou) k-NN (k - Nearest Neighbors) ​ 该算法也可用于回归和分类。该算法通过计算数据点与所有数据点的距离来找到k个数据点的最近邻。数据点被分配给k个邻居中点数最多的类(投票过程)。在回归的情况下，它计算k个最近邻居的平均值。距离度量可以使用欧几里得距离，曼哈顿距离，闵可夫斯基距离等。为了消除距离相等的可能，k的值必须是一个奇数。由于每个数据点与其他数据点的距离都需要计算，因此该算法的计算时间开销较大。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0204dd4d0c5f973f7f3d1932684ef9f1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-06T09:29:04+08:00" />
<meta property="article:modified_time" content="2020-09-06T09:29:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习算法背后的数学原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>不同的机器学习算法是如何从数据中学习并预测未知数据的呢?</p> 
<p><img src="https://images2.imgbox.com/12/fd/lLLxTz9y_o.jpg" alt=""></p> 
<p>​ 机器学习算法的设计让它们从经验中学习，当它们获取越来越多的数据时，性能也会越来越高。每种算法都有自己学习和预测数据的思路。在本文中，我们将介绍一些机器学习算法的功能，以及在这些算法中实现的有助于它们学习的一些数学方程。</p> 
<h4><a id="_10"></a>机器学习算法的类型</h4> 
<p>机器学习算法大致可以分为以下四类:</p> 
<p>**监督学习：**用于预测的目标是已知的情况。这些算法生成一个函数，该函数将输入映射到输出变量。回归和分类算法都属于这一类。在回归中，输出变量是连续的，而在分类中，输出变量包含两个或更多的离散值。监督学习算法包括线性回归，逻辑回归，随机森林，支持向量机，决策树，朴素贝叶斯，神经网络。</p> 
<p>**无监督学习：**目标或输出变量是未知的情况。这些算法通常对数据进行分析并生成数据簇。关联、聚类和维数约简算法属于这一类。K-means聚类、PCA(主成分分析)、Apriori算法等也都是非监督学习算法。</p> 
<p>**半监督学习：**它是监督和非监督学习方法的结合。它使用已知数据来训练自己，然后标记未知数据。</p> 
<p>**强化学习：**机器从“试错”过程中学习的方法。机器从过去的决策经验中学习，并利用它的学习来预测未来决策的结果。强化学习算法的例子有Q-Learning, Temporal Difference等。</p> 
<h4><a id="_22"></a>线性回归</h4> 
<p>​ 线性回归是通过拟合数据点上的最佳直线来预测连续变量的结果。最佳拟合线定义了因变量和自变量之间的关系。该算法试图找到最适合预测目标变量值的直线。通过使数据点与回归线之间的差的平方和最小达到最佳拟合线。</p> 
<p><img src="https://images2.imgbox.com/96/9c/aIqFt21Q_o.jpg" alt=""></p> 
<center>
  线性回归(来源:onlinestatbook) 
</center> 
<blockquote> 
 <p><strong>Equation:</strong> Y = c + m₁X₁ + m₂X₂ + …… +mnXn</p> 
 <p>Y → Dependent Variable or Target Variable</p> 
 <p>m → Slope</p> 
 <p>c → Intercept</p> 
 <p>X → Independent Variables</p> 
</blockquote> 
<h4><a id="_44"></a>逻辑回归</h4> 
<p>​ 逻辑回归是一种基于自变量估计分类变量结果的分类算法。它通过将数据拟合到logistic函数来预测某一事件发生的概率。通过最大化似然函数，对logistic函数中自变量的系数进行优化。优化决策边界，使成本函数最小。利用梯度下降法可以使代价函数最小化。</p> 
<p><img src="https://images2.imgbox.com/fb/e2/oZDUPEVp_o.png" alt=""></p> 
<center>
  逻辑回归的s型曲线 
</center> 
<p><img src="https://images2.imgbox.com/c5/49/mQcMgOpw_o.png" alt=""></p> 
<center>
  Logistic回归的成本函数 
</center> 
<p><img src="https://images2.imgbox.com/b8/27/xbysiGSM_o.png" alt=""></p> 
<center>
  logistic回归方程 
</center> 
<h4><a id="_65"></a>朴素贝叶斯算法</h4> 
<p>​ 朴素贝叶斯是一种基于贝叶斯定理的分类算法。该算法假设自变量之间不存在相关性。也就是说，一个类中某个特性的出现与同一类中另一个特性的出现是没有关系的。我们针对类为所有预测器创建一个频率表(目标变量的不同值)，并计算所有预测器的可能性。利用朴素贝叶斯方程，计算所有类别的后验概率。朴素贝叶斯分类器的结果将是所有类概率中概率最高的类。</p> 
<p><img src="https://images2.imgbox.com/41/a2/v64shsKH_o.png" alt=""></p> 
<h4><a id="_71"></a>决策树</h4> 
<p>​ 决策树主要用于分类问题，但它们也可以用于回归。在该算法中，我们根据有效性划分数据集的属性，将数据集划分为两个或多个同构集。选择将分割数据集的属性的方法之一是计算熵和信息增益。熵反映了变量中杂质的数量。信息增益是父节点的熵减去子节点的熵之和。选择提供最大信息增益的属性进行分割。我们也可以使用基尼指数作为杂质标准来分割数据集。为了防止过度分割，我们优化了max_features、min_samples_split、max_depth等决策树的超参数。</p> 
<p><img src="https://images2.imgbox.com/fe/d2/fZyk4LLM_o.png" alt=""></p> 
<center>
  信息熵, c → No. of classes 
</center> 
<p><img src="https://images2.imgbox.com/59/a1/cbWfTucP_o.png" alt=""></p> 
<center>
  基尼系数 
</center> 
<h4><a id="_87"></a>随机森林</h4> 
<p>​ 随机森林由多个决策树组成，作为一个集合来运行。在随机森林中，每棵决策树预测一个类结果，投票最多的类结果成为随机森林的预测项。为了做出准确的预测，决策树之间的相关性应该最小。有两种方法可以确保这一点，即使用Bagging和特性选择。Bagging是一种从数据集中选择随机观察样本的技术。特征选择允许决策树仅在特征的随机子集上建模。这就防止决策树使用相同的特性进行预测的情况。</p> 
<p><img src="https://images2.imgbox.com/87/ec/fo8zeUgM_o.png" alt=""></p> 
<center>
  随机森林(来源:victorzhou) 
</center> 
<h4><a id="kNN_k__Nearest_Neighbors_99"></a>k-NN (k - Nearest Neighbors)</h4> 
<p>​ 该算法也可用于回归和分类。该算法通过计算数据点与所有数据点的距离来找到k个数据点的最近邻。数据点被分配给k个邻居中点数最多的类(投票过程)。在回归的情况下，它计算k个最近邻居的平均值。距离度量可以使用欧几里得距离，曼哈顿距离，闵可夫斯基距离等。为了消除距离相等的可能，k的值必须是一个奇数。由于每个数据点与其他数据点的距离都需要计算，因此该算法的计算时间开销较大。</p> 
<p><img src="https://images2.imgbox.com/26/d6/DvPENAHB_o.png" alt=""></p> 
<center>
  距离度量 
</center> 
<p><img src="https://images2.imgbox.com/41/1c/3pXZpvd9_o.png" alt=""></p> 
<center>
  knn(来源:tutorialspoint) 
</center> 
<h4><a id="KMeans_116"></a>K-Means</h4> 
<p>​ K-Means是一种无监督学习算法，用于形成数据簇。形成的集群应该使集群内的数据点尽可能相似，集群之间的差异尽可能明显。它随机选择K个位置，每个位置作为一个簇的质心。数据点被分配到最近的簇。在分配数据点之后，计算每个聚类的质心，再次将数据点分配到最近的聚类中。此过程将重复进行，直到在每次连续迭代中数据点保持在同一簇中，或簇的中心不改变为止。我们还可以指示算法在进行一定次数的迭代后停止计算。</p> 
<p><img src="https://images2.imgbox.com/aa/83/H0ehSJ6j_o.png" alt=""></p> 
<center>
  K-Means聚类(来源:Stanford) 
</center> 
<h4><a id="Apriori_128"></a>Apriori算法</h4> 
<p>​ Apriori算法是一种基于关联规则的数据库频繁项集识别算法。频繁项集是支持度大于阈值的项集。关联规则可以被认为是一种IF-THEN关系。它通常用于市场篮子分析中，发现不同商品之间的关联。支持、置信度和提升是帮助确定关联的三个措施。</p> 
<p><img src="https://images2.imgbox.com/dc/2c/ypYaFQ7c_o.png" alt=""></p> 
<center>
  支持(A和B是不同的项) 
</center> 
<p><img src="https://images2.imgbox.com/fe/58/xTfhyU8U_o.png" alt=""></p> 
<center>
  置信度 
</center> 
<p><img src="https://images2.imgbox.com/6a/e9/xGPqY69m_o.png" alt=""></p> 
<center>
  提升 
</center> 
<p>​ 支持指某些项目集一起出现的频率。</p> 
<p>​ 置信度计算项目集在其中一个项目出现的概率。</p> 
<p>​ 提升表示关联规则的强度。支持是用户定义的阈值。</p> 
<p><img src="https://images2.imgbox.com/e5/78/j4TzSUSo_o.jpg" alt=""></p> 
<h4><a id="XGBoost_159"></a>XGBoost</h4> 
<p>​ XGBoost是一种基于决策树的梯度增强算法(集成的另一种类型)。XGBoost涉及一组较弱的学习者，它们结合在一起可以做出准确的预测。Boosting是一个序列集成，每个模型都是在修正之前模型错误分类的基础上构建的。换句话说，它接收到前一个模型的错误，并试图通过学习这些错误来改进模型。</p> 
<p><img src="https://images2.imgbox.com/8c/1e/zfATeMBy_o.png" alt=""></p> 
<h4><a id="SVM_166"></a>支持向量机(SVM)</h4> 
<p>​ SVM也是一种监督学习算法，可用于分类和回归问题。支持向量机试图在N维空间(N指特征的数量)中找到一个最优超平面来帮助分类。它利用铰链损失函数，通过最大化类观测值之间的裕度距离来寻找最优超平面。超平面的维数取决于输入特征的数量。如果特征个数为N，则超平面的维数为N-1。</p> 
<p><img src="https://images2.imgbox.com/7f/3f/aVK3Ynh2_o.png" alt=""></p> 
<center>
  支持向量机(来源:alteryx) 
</center> 
<p><img src="https://images2.imgbox.com/1d/9e/lBZxKI7j_o.png" alt=""></p> 
<center>
  铰链损耗函数:t→目标变量，w→模型参数，x→输入变量(来源:维基百科) 
</center> 
<p>​ 感谢您阅读本文。</p> 
<p>作者：Prathamesh Thakar</p> 
<p><strong>deephub翻译组：孟翔杰</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2d0a6354b6de1407be73955cf4872f02/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">思科基础命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c882f844d50f1d699e0ee97d675b0056/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu18.04分区方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>