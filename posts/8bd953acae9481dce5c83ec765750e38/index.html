<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;笔试题汇总（6） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;笔试题汇总（6）" />
<meta property="og:description" content="1.引言本文的写作目的并不在于提供C/C&#43;&#43;程序员求职面试指导，而旨在从技术上分 析面试题的内涵。文中的大多数面试题来自各大论坛，部分试题解答也参考了网友的意见。 许多面试题看似简单，却需要深厚的基本功才能给出完美的解答。企业要求面试者写一个最 简单的strcpy 函数都可看出面试者在技术上究竟达到了怎样的程度，我们能真正写好一个 strcpy 函数吗？我们都觉得自己能，可是我们写出的strcpy 很可能只能拿到10 分中的2 分。 读者可从本文看到strcpy 函数从2 分到10 分解答的例子，看看自己属于什么样的层次。此 外，还有一些面试题考查面试者敏捷的思维能力。分析这些面试题，本身包含很强的 趣味性；而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。 2. 找错题试题1 ： void test1(){ char string[10]; char* str1 = &#34;0123456789&#34;; strcpy( string, str1 );} 试题2：void test2(){ char string[10], str1[10]; int i; for(i=0; i&lt;10; i&#43;&#43;) { str1[i] = &#39;a&#39;; } strcpy( string, str1 );} 试题3 ： void test3(char* str1){ char string[10]; if( strlen( str1 ) &lt;= 10 ) { strcpy( string, str1 ); }} 解答： 试题1 字符串str1 需要11 个字节才能存放下（包括末尾的’/0’），而string 只有10 个字节 的空间，strcpy 会导致数组越界； 对试题2，如果面试者指出字符数组str1 不能在数组 内结束可以给3 分；如果面试者指出strcpy(string, str1)调用使得从str1 内存起复制到string 内存起所复制的字节数具有不确定性可以给7 分，在此基础上指出库函数strcpy 工作方式 的给10 分； 对试题3，if(strlen(str1) &lt;= 10)应改为if(strlen(str1) &lt; 10)，因为strlen 的 结果未统计’/0’所占用的1 个字节。剖析： 考查对基本功的掌握： (1)字符串以’/0’ 结尾； (2)对数组越界把握的敏感度； (3)库函数strcpy 的工作方式，如果编写一个 标准strcpy 函数的总分值为10，下面给出几个不同得分的答案： 2 分void strcpy( char *strDest, char *strSrc ){ while( (*strDest&#43;&#43; = * strSrc&#43;&#43;) !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8bd953acae9481dce5c83ec765750e38/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-04-10T00:47:00+08:00" />
<meta property="article:modified_time" content="2011-04-10T00:47:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;笔试题汇总（6）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.引言本文的写作目的并不在于提供C/C++程序员求职面试指导，而旨在从技术上分 <br>析面试题的内涵。文中的大多数面试题来自各大论坛，部分试题解答也参考了网友的意见。 <br>许多面试题看似简单，却需要深厚的基本功才能给出完美的解答。企业要求面试者写一个最 <br>简单的strcpy 函数都可看出面试者在技术上究竟达到了怎样的程度，我们能真正写好一个 <br>strcpy 函数吗？我们都觉得自己能，可是我们写出的strcpy 很可能只能拿到10 分中的2 分。 <br>读者可从本文看到strcpy 函数从2 分到10 分解答的例子，看看自己属于什么样的层次。此 <br>外，还有一些面试题考查面试者敏捷的思维能力。分析这些面试题，本身包含很强的 <br>趣味性；而作为一名研发人员，通过对这些面试题的深入剖析则可进一步增强自身的内功。 <br>2. 找错题试题1 ： void test1(){ char string[10]; char* str1 = "0123456789"; <br>strcpy( string, str1 );} 试题2：void test2(){ char string[10], str1[10]; int i; for(i=0; <br>i&lt;10; i++) { str1[i] = 'a'; } strcpy( string, str1 );} 试题3 ： void test3(char* <br>str1){ char string[10]; if( strlen( str1 ) &lt;= 10 ) { strcpy( string, str1 ); }} 解答： <br>试题1 字符串str1 需要11 个字节才能存放下（包括末尾的’/0’），而string 只有10 个字节 <br>的空间，strcpy 会导致数组越界； 对试题2，如果面试者指出字符数组str1 不能在数组 <br>内结束可以给3 分；如果面试者指出strcpy(string, str1)调用使得从str1 内存起复制到string <br>内存起所复制的字节数具有不确定性可以给7 分，在此基础上指出库函数strcpy 工作方式 <br>的给10 分； 对试题3，if(strlen(str1) &lt;= 10)应改为if(strlen(str1) &lt; 10)，因为strlen 的 <br>结果未统计’/0’所占用的1 个字节。剖析： 考查对基本功的掌握： (1)字符串以’/0’ <br>结尾； (2)对数组越界把握的敏感度； (3)库函数strcpy 的工作方式，如果编写一个 <br>标准strcpy 函数的总分值为10，下面给出几个不同得分的答案： 2 分void strcpy( char <br>*strDest, char *strSrc ){ while( (*strDest++ = * strSrc++) != '/0’ );} 4 分void <br>strcpy( char *strDest, const char *strSrc ) //将源字符串加const，表明其为输入参数，加2 <br>分{ while( (*strDest++ = * strSrc++) != '/0’ );} 7 分void strcpy(char *strDest, const <br>char *strSrc) { //对源地址和目的地址加非0 断言，加3 分assert( (strDest != NULL) &amp;&amp; <br>(strSrc != NULL) ); while( (*strDest++ = * strSrc++) != '/0’ );} 10 分//为了实现链式操 <br>作， 将目的地址返回， 加3 分！ char * strcpy( char *strDest, const char *strSrc ) <br>{ assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); char *address = strDest; <br>while( (*strDest++ = * strSrc++) != '/0’ ); return address;} 从2 分到10 分的几个 <br>答案我们可以清楚的看到，小小的strcpy 竟然暗藏着这么多玄机，真不是盖的！需要多么 <br>扎实的基本功才能写一个完美的strcpy 啊！ (4)对strlen 的掌握，它没有包括字符串末 <br>尾的'/0'。读者看了不同分值的strcpy 版本，应该也可以写出一个10 分的strlen 函数了， <br>完美的版本为： int strlen( const char *str ) //输入参数const{ assert( strt != NULL ); //断 <br>言字符串地址非0 int len; while( (*str++) != '/0' ) { len++; } return len;} <br>试题4：void GetMemory( char *p ){ p = (char *) malloc( 100 );}void Test( void ) { char <br>*str = NULL; GetMemory( str ); strcpy( str, "hello world" ); printf( str );} 试题5： <br>char *GetMemory( void ){ char p[] = "hello world"; return p; }void Test( void ){ char <br>*str = NULL; str = GetMemory(); printf( str ); } 试题6：void GetMemory( char **p, <br>int num ){ *p = (char *) malloc( num );}void Test( void ){ char *str = NULL; <br>GetMemory( &amp;str, 100 ); strcpy( str, "hello" ); printf( str ); } 试题7 ： void <br>Test( void ){ char *str = (char *) malloc( 100 ); strcpy( str, "hello" ); free( str ); ... // <br>省略的其它语句} 解答： 试题4 传入中GetMemory( char *p )函数的形参为字符串 <br>指针， 在函数内部修改形参并不能真正的改变传入形参的值， 执行完char *str = <br>NULL;GetMemory( str ); 后的str 仍然为NULL； 试题5 中char p[] = "hello world"; <br>return p; 的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是 <br>许多程序员常犯的错误，其根源在于不理解变量的生存期。试题6 的GetMemory 避免 <br>了试题4 的问题，传入GetMemory 的参数为字符串指针的指针，但是在GetMemory 中执 <br>行申请内存及赋值语句*p = (char *) malloc( num ); 后未判断内存是否申请成功，应加 <br>上：if ( *p == NULL ){ ...//进行申请内存失败处理} 试题7 存在与试题6 同样的问题， <br>在执行char *str = (char *) malloc(100); 后未进行内存是否申请成功的判断；另外，在 <br>free(str)后未置str 为空，导致可能变成一个“野”指针，应加上：str = NULL; 试题6 的 <br>Test 函数中也未对malloc 的内存进行释放。剖析： 试题4～7 考查面试者对内存 <br>操作的理解程度，基本功扎实的面试者一般都能正确的回答其中50~60 的错误。但是要完 <br>全解答正确，却也绝非易事。对内存操作的考查主要集中在： （1）指针的理解； <br>（2）变量的生存期及作用范围； （3）良好的动态内存申请和释放习惯。再看看 <br>下面的一段程序有什么错误：swap( int* p1,int* p2 ){ int *p; *p = *p1; *p1 = *p2; *p2 = <br>*p;} 在swap 函数中，p 是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。 <br>在VC++中DEBUG 运行时提示错误“Access Violation”。该程序应该改为：swap( int* p1,int* <br>p2 ){ int p; p = *p1; *p1 = *p2; *p2 = p;} <br>1.引言 <br>本文的写作目的并不在于提供C/C++程序员求职面试指导，而旨在从技术上分析面试 <br>题的内涵。文中的大多数面试题来自各大论坛，部分试题解答也参考了网友的意见。 <br>许多面试题看似简单，却需要深厚的基本功才能给出完美的解答。企业要求面试者写一 <br>个最简单的strcpy 函数都可看出面试者在技术上究竟达到了怎样的程度，我们能真正写好 <br>一个strcpy 函数吗？我们都觉得自己能，可是我们写出的strcpy 很可能只能拿到10 分中的 <br>2 分。读者可从本文看到strcpy 函数从2 分到10 分解答的例子，看看自己属于什么样的层 <br>次。此外，还有一些面试题考查面试者敏捷的思维能力。 <br>分析这些面试题，本身包含很强的趣味性；而作为一名研发人员，通过对这些面试题的 <br>深入剖析则可进一步增强自身的内功。 <br>2.找错题 <br>试题1： <br>void test1() <br>{ <br>char string[10]; <br>char* str1 = "0123456789"; <br>strcpy( string, str1 ); <br>} <br>试题2： <br>void test2() <br>{ <br>char string[10], str1[10]; <br>int i; <br>for(i=0; i&lt;10; i++) <br>{ <br>str1[i] = 'a'; <br>} <br>strcpy( string, str1 ); <br>} <br>试题3： <br>void test3(char* str1) <br>{ <br>char string[10]; <br>if( strlen( str1 ) &lt;= 10 ) <br>{ <br>strcpy( string, str1 ); <br>} <br>} <br>解答： <br>试题1 字符串str1 需要11 个字节才能存放下（包括末尾的’/0’），而string 只有10 个 <br>字节的空间，strcpy 会导致数组越界； <br>对试题2，如果面试者指出字符数组str1 不能在数组内结束可以给3 分；如果面试者指 <br>出strcpy(string, str1)调用使得从str1 内存起复制到string 内存起所复制的字节数具有不确 <br>定性可以给7 分，在此基础上指出库函数strcpy 工作方式的给10 分； <br>对试题3，if(strlen(str1) &lt;= 10)应改为if(strlen(str1) &lt; 10)，因为strlen 的结果未统计’/0’ <br>所占用的1 个字节。 <br>剖析： <br>考查对基本功的掌握： <br>(1)字符串以’/0’结尾； <br>(2)对数组越界把握的敏感度； <br>(3)库函数strcpy 的工作方式，如果编写一个标准strcpy 函数的总分值为10，下面给出 <br>几个不同得分的答案： <br>2 分 <br>void strcpy( char *strDest, char *strSrc ) <br>{ <br>while( (*strDest++ = * strSrc++) != '/0’ ); <br>} <br>4 分 <br>void strcpy( char *strDest, const char *strSrc ) <br>//将源字符串加const，表明其为输入参数，加2 分 <br>{ <br>while( (*strDest++ = * strSrc++) != '/0’ ); <br>} <br>7 分 <br>void strcpy(char *strDest, const char *strSrc) <br>{ <br>//对源地址和目的地址加非0 断言，加3 分 <br>assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); <br>while( (*strDest++ = * strSrc++) != '/0’ ); <br>} <br>10 分 <br>//为了实现链式操作，将目的地址返回，加3 分！ <br>char * strcpy( char *strDest, const char *strSrc ) <br>{ <br>assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); <br>char *address = strDest; <br>while( (*strDest++ = * strSrc++) != '/0’ ); <br>return address; <br>} <br>从2 分到10 分的几个答案我们可以清楚的看到，小小的strcpy 竟然暗藏着这么多玄机， <br>真不是盖的！需要多么扎实的基本功才能写一个完美的strcpy 啊！ <br>(4)对strlen 的掌握，它没有包括字符串末尾的'/0'。 <br>读者看了不同分值的strcpy 版本，应该也可以写出一个10 分的strlen 函数了，完美的 <br>版本为： int strlen( const char *str ) //输入参数const <br>{ <br>assert( strt != NULL ); //断言字符串地址非0 <br>int len; <br>while( (*str++) != '/0' ) <br>{ <br>len++; <br>} <br>return len; <br>} <br>试题4： <br>void GetMemory( char *p ) <br>{ <br>p = (char *) malloc( 100 ); <br>} <br>void Test( void ) <br>{ <br>char *str = NULL; <br>GetMemory( str ); <br>strcpy( str, "hello world" ); <br>printf( str ); <br>} <br>试题5： <br>char *GetMemory( void ) <br>{ <br>char p[] = "hello world"; <br>return p; <br>} <br>void Test( void ) <br>{ <br>char *str = NULL; <br>str = GetMemory(); <br>printf( str ); <br>} <br>试题6： <br>void GetMemory( char **p, int num ) <br>{ <br>*p = (char *) malloc( num ); <br>} <br>void Test( void ) <br>{ <br>char *str = NULL; <br>GetMemory( &amp;str, 100 ); <br>strcpy( str, "hello" ); <br>printf( str ); <br>} <br>试题7： <br>void Test( void ) <br>{ <br>char *str = (char *) malloc( 100 ); <br>strcpy( str, "hello" ); <br>free( str ); <br>... //省略的其它语句 <br>} <br>解答： <br>试题4 传入中GetMemory( char *p )函数的形参为字符串指针，在函数内部修改形参并 <br>不能真正的改变传入形参的值，执行完 <br>char *str = NULL; <br>GetMemory( str ); <br>后的str 仍然为NULL； <br>试题5 中 <br>char p[] = "hello world"; <br>return p; <br>的p[]数组为函数内的局部自动变量，在函数返回后，内存已经被释放。这是许多程序 <br>员常犯的错误，其根源在于不理解变量的生存期。 <br>试题6 的GetMemory 避免了试题4 的问题，传入GetMemory 的参数为字符串指针的 <br>指针，但是在GetMemory 中执行申请内存及赋值语句 <br>*p = (char *) malloc( num ); <br>后未判断内存是否申请成功，应加上： <br>if ( *p == NULL ) <br>{ <br>...//进行申请内存失败处理 <br>} <br>试题7 存在与试题6 同样的问题，在执行 <br>char *str = (char *) malloc(100); <br>后未进行内存是否申请成功的判断；另外，在free(str)后未置str 为空，导致可能变成 <br>一个“野”指针，应加上： <br>str = NULL; <br>试题6 的Test 函数中也未对malloc 的内存进行释放。 <br>剖析： <br>试题4～7 考查面试者对内存操作的理解程度，基本功扎实的面试者一般都能正确的回 <br>答其中50~60 的错误。但是要完全解答正确，却也绝非易事。 <br>对内存操作的考查主要集中在： <br>（1）指针的理解； <br>（2）变量的生存期及作用范围； <br>（3）良好的动态内存申请和释放习惯。 <br>再看看下面的一段程序有什么错误： <br>swap( int* p1,int* p2 ) <br>{ <br>int *p; <br>*p = *p1; <br>*p1 = *p2; <br>*p2 = *p; <br>} <br>在swap 函数中，p 是一个“野”指针，有可能指向系统区，导致程序运行的崩溃。在VC++ <br>中DEBUG 运行时提示错误“Access Violation”。该程序应该改为： <br>swap( int* p1,int* p2 ) <br>{ <br>int p; <br>p = *p1; <br>*p1 = *p2; <br>*p2 = p; <br>} <br>3.内功题 <br>试题1：分别给出BOOL，int，float，指针变量与“零值”比较的if 语句（假设变量名 <br>为var） <br>解答： <br>BOOL 型变量：if(!var) <br>int 型变量： if(var==0) <br>float 型变量： <br>const float EPSINON = 0.00001; <br>if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON) <br>指针变量： if(var==NULL) <br>剖析： <br>考查对0 值判断的“内功”，BOOL 型变量的0 判断完全可以写成if(var==0)，而int 型变 <br>量也可以写成if(!var)，指针变量的判断也可以写成if(!var)，上述写法虽然程序都能正确运 <br>行，但是未能清晰地表达程序的意思。 <br>一般的，如果想让if 判断一 <br>个变量的“真”、“假”，应直接使用 <br>if(var)、if(!var)，表明其为“逻辑”判断；如果用if 判断一个数值型变量(short、int、long 等)， <br>应该用if(var==0)，表明是与0 进行“数值”上的比较；而判断指针则适宜用if(var==NULL)， <br>这是一种很好的编程习惯。 <br>浮点型变量并不精确，所以不可将float 变量用“==”或“！=”与数字比较，应该设法转化 <br>成“&gt;=”或“&lt;=”形式。如果写成if (x == 0.0)，则判为错，得0 分。 <br>试题2：以下为Windows NT 下的32 位C++程序，请计算sizeof 的值 <br>void Func ( char str[100] ) <br>{ <br>sizeof( str ) = ? <br>} <br>void *p = malloc( 100 ); <br>sizeof ( p ) = ? <br>解答： <br>sizeof( str ) = 4 <br>sizeof ( p ) = 4 <br>剖析： <br>Func ( char str[100] )函数中数组名作为函数形参时，在函数体内，数组名失去了本身 <br>的内涵，仅仅只是一个指针；在失去其内涵的同时，它还失去了其常量特性，可以作自增、 <br>自减等操作，可以被修改。 <br>数组名的本质如下： <br>（1）数组名指代一种数据结构，这种数据结构就是数组； <br>例如： <br>char str[10]; <br>cout &lt;&lt; sizeof(str) &lt;&lt; endl; <br>输出结果为10，str 指代数据结构char[10]。 <br>（2）数组名可以转换为指向其指代实体的指针，而且是一个指针常量，不能作自增、 <br>自减等操作，不能被修改； <br>char str[10]; <br>str++; //编译出错，提示str 不是左值 <br>（3）数组名作为函数形参时，沦为普通指针。 <br>Windows NT 32 位平台下，指针的长度（占用内存的大小）为4 字节，故sizeof( str ) 、 <br>sizeof ( p ) 都为4。 <br>试题3：写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。另外，当你写 <br>下面的代码时会发生什么事？ <br>least = MIN(*p++, b); <br>解答： <br>#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B)) <br>MIN(*p++, b)会产生宏的副作用 <br>剖析： <br>这个面试题主要考查面试者对宏定义的使用，宏定义可以实现类似于函数的功能，但是 <br>它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对“参数”进 <br>行的是一对一的替换。 <br>程序员对宏定义的使用要非常小心，特别要注意两个问题： <br>（1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解 <br>答： <br>#define MIN(A,B) (A) &lt;= (B) ? (A) : (B) <br>#define MIN(A,B) (A &lt;= B ? A : B ) <br>都应判0 分； <br>（2）防止宏的副作用。 <br>宏定义#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是： <br>((*p++) &lt;= (b) ? (*p++) : (*p++)) <br>这个表达式会产生副作用，指针p 会作三次++自增操作。 <br>除此之外，另一个应该判0 分的解答是： <br>#define MIN(A,B) ((A) &lt;= (B) ? (A) : (B)); <br>这个解答在宏定义的后面加“;”，显示编写者对宏的概念模糊不清，只能被无情地判0 <br>分并被面试官淘汰。 <br>试题4：为什么标准头文件都有类似以下的结构？ <br>#ifndef __INCvxWorksh <br>#define __INCvxWorksh <br>#ifdef __cplusplus <br>extern "C" { <br>#endif <br>/*...*/ <br>#ifdef __cplusplus <br>} <br>#endif <br>#endif /* __INCvxWorksh */ <br>解答： <br>头文件中的编译宏 <br>#ifndef __INCvxWorksh <br>#define __INCvxWorksh <br>#endif <br>的作用是防止被重复引用。 <br>作为一种面向对象的语言，C++支持函数重载，而过程式语言C 则不支持。函数被C++ <br>编译后在symbol 库中的名字与C 语言的不同。例如，假设某个函数的原型为： <br>void foo(int x, int y); <br>该函数被C 编译器编译后在symbol 库中的名字为_foo，而C++编译器则会产生像 <br>_foo_int_int 之类的名字。_foo_int_int 这样的名字包含了函数名和函数参数数量及类型信 <br>息，C++就是考这种机制来实现函数重载的。 <br>为了实现C 和C++的混合编程，C++提供了C 连接交换指定符号extern "C"来解决名 <br>字匹配问题，函数声明前加上extern "C"后，则编译器就会按照C 语言的方式将该函数编译 <br>为_foo，这样C 语言中就可以调用C++的函数了。 <br>试题5：编写一个函数，作用是把一个char 组成的字符串循环右移n 个。比如原来是 <br>“abcdefghi”如果n=2，移位后应该是“hiabcdefgh” <br>函数头是这样的： <br>//pStr 是指向以'/0'结尾的字符串的指针 <br>//steps 是要求移动的n <br>void LoopMove ( char * pStr, int steps ) <br>{ <br>//请填充... <br>} <br>解答： <br>正确解答1： <br>void LoopMove ( char *pStr, int steps ) <br>{ <br>int n = strlen( pStr ) - steps; <br>char tmp[MAX_LEN]; <br>strcpy ( tmp, pStr + n ); <br>strcpy ( tmp + steps, pStr); <br>*( tmp + strlen ( pStr ) ) = '/0'; <br>strcpy( pStr, tmp ); <br>} <br>正确解答2： <br>void LoopMove ( char *pStr, int steps ) <br>{ <br>int n = strlen( pStr ) - steps; <br>char tmp[MAX_LEN]; <br>memcpy( tmp, pStr + n, steps ); <br>memcpy(pStr + steps, pStr, n ); <br>memcpy(pStr, tmp, steps ); <br>} <br>剖析： <br>这个试题主要考查面试者对标准库函数的熟练程度，在需要的时候引用库函数可以很大 <br>程度上简化程序编写的工作量。 <br>最频繁被使用的库函数包括： <br>（1） strcpy <br>（2） memcpy <br>（3） memset <br>试题6：已知WAV 文件格式如下表，打开一个WAV 文件，以适当的数据结构组织 <br>WAV 文件头并解析WAV 格式的各项信息。 <br>WAVE 文件格式说明表 <br>偏移地 <br>址 <br>字节 <br>数 <br>数据类 <br>型 <br>内容 <br>文件头 <br>00H 4 Char "RIFF"标志 <br>04H 4 int32 文件长度 <br>08H 4 Char "WAVE"标志 <br>0CH 4 Char "fmt"标志 <br>10H 4 过渡字节（不定） <br>14H 2 int16 格式类别 <br>16H 2 int16 通道数 <br>18H 2 int16 <br>采样率（每秒样本数），表示每个通道的播放速 <br>度 <br>1CH 4 int32 波形音频数据传送速率 <br>20H 2 int16 数据块的调整数（按字节算的） <br>22H 2 每样本的数据位数 <br>24H 4 Char 数据标记符＂data＂ <br>28H 4 int32 语音数据的长度 <br>解答： <br>将WAV 文件格式定义为结构体WAVEFORMAT： <br>typedef struct tagWaveFormat <br>{ <br>char cRiffFlag[4]; <br>UIN32 nFileLen; <br>char cWaveFlag[4]; <br>char cFmtFlag[4]; <br>char cTransition[4]; <br>UIN16 nFormatTag ; <br>UIN16 nChannels; <br>UIN16 nSamplesPerSec; <br>UIN32 nAvgBytesperSec; <br>UIN16 nBlockAlign; <br>UIN16 nBitNumPerSample; <br>char cDataFlag[4]; <br>UIN16 nAudioLength; <br>} WAVEFORMAT; <br>假设WAV 文件内容读出后存放在指针buffer 开始的内存单元内，则分析文件格式的代 <br>码很简单，为： <br>WAVEFORMAT waveFormat; <br>memcpy( &amp;waveFormat, buffer,sizeof( WAVEFORMAT ) ); <br>直接通过访问waveFormat 的成员，就可以获得特定WAV 文件的各项格式信息。 <br>剖析： <br>试题6 考查面试者组织数据结构的能力，有经验的程序设计者将属于一个整体的数据 <br>成员组织为一个结构体，利用指针类型转换，可以将memcpy、memset 等函数直接用于结 <br>构体地址，进行结构体的整体操作。透过这个题可以看出面试者的程序设计经验是否丰富。 <br>试题7：编写类String 的构造函数、析构函数和赋值函数，已知类String 的原型为： <br>class String <br>{ <br>public: <br>String(const char *str = NULL); // 普通构造函数 <br>String(const String &amp;other); // 拷贝构造函数 <br>~ String(void); // 析构函数 <br>String &amp; operate =(const String &amp;other); // 赋值函数 <br>private: <br>char *m_data; // 用于保存字符串 <br>}; <br>解答： <br>//普通构造函数 <br>String::String(const char *str) <br>{ <br>if(str==NULL) <br>{ <br>m_data = new char[1]; // 得分点：对空字符串自动申请存放结束标志'/0'的 <br>空 <br>//加分点：对m_data 加NULL 判断 <br>*m_data = '/0'; <br>} <br>else <br>{ <br>int length = strlen(str); <br>m_data = new char[length+1]; // 若能加NULL 判断则更好 <br>strcpy(m_data, str); <br>} <br>} <br>// String 的析构函数 <br>String::~String(void) <br>{ <br>delete [] m_data; // 或delete m_data; <br>} <br>//拷贝构造函数 <br>String::String(const String &amp;other) // 得分点：输入参数为const 型 <br>{ <br>int length = strlen(other.m_data); <br>m_data = new char[length+1]; //加分点：对m_data 加NULL 判断 <br>strcpy(m_data, other.m_data); <br>} <br>//赋值函数 <br>String &amp; String::operate =(const String &amp;other) // 得分点：输入参数为const <br>型 <br>{ <br>if(this == &amp;other) //得分点：检查自赋值 <br>return *this; <br>delete [] m_data; //得分点：释放原有的内存资源 <br>int length = strlen( other.m_data ); <br>m_data = new char[length+1]; //加分点：对m_data 加NULL 判断 <br>strcpy( m_data, other.m_data ); <br>return *this; //得分点：返回本对象的引用 <br>} <br>剖析： <br>能够准确无误地编写出String 类的构造函数、拷贝构造函数、赋值函数和析构函数的 <br>面试者至少已经具备了C++基本功的60%以上！ <br>在这个类中包括了指针类成员变量m_data，当类中包括指针类成员变量时，一定要重 <br>载其拷贝构造函数、赋值函数和析构函数，这既是对C++程序员的基本要求，也是《Effective <br>C++》中特别强调的条款。 <br>仔细学习这个类，特别注意加注释的得分点和加分点的意义，这样就具备了60%以上 <br>的C++基本功！ <br>试题8：请说出static 和const 关键字尽可能多的作用 <br>解答： <br>static 关键字至少有下列n 个作用： <br>（1）函数体内static 变量的作用范围为该函数体，不同于auto 变量，该变量的内存只 <br>被分配一次，因此其值在下次调用时仍维持上次的值； <br>（2）在模块内的static 全局变量可以被模块内所用函数访问，但不能被模块外其它函 <br>数访问； <br>（3）在模块内的static 函数只可被这一模块内的其它函数调用，这个函数的使用范围 <br>被限制在声明它的模块内； <br>（4）在类中的static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝； <br>（5）在类中的static 成员函数属于整个类所拥有，这个函数不接收this 指针，因而只 <br>能访问类的static 成员变量。 <br>const 关键字至少有下列n <br>个作用： <br>（1）欲阻止一个变量被改变，可以使用const 关键字。在定义该const 变量时，通常 <br>需要对它进行初始化，因为以后就没有机会再去改变它了； <br>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const， <br>或二者同时指定为const； <br>（3）在一个函数声明中，const 可以修饰形参，表明它是一个输入参数，在函数内部 <br>不能改变其值； <br>（4）对于类的成员函数，若指定其为const 类型，则表明其是一个常函数，不能修改 <br>类的成员变量； <br>（5）对于类的成员函数，有时候必须指定其返回值为const 类型，以使得其返回值不 <br>为“左值”。例如： <br>const classA operator*(const classA&amp; a1,const classA&amp; a2); <br>operator*的返回结果必须是一个const 对象。如果不是，这样的变态代码也不会编译出 <br>错： <br>classA a, b, c; <br>(a * b) = c; // 对a*b 的结果赋值 <br>操作(a * b) = c 显然不符合编程者的初衷，也没有任何意义。 <br>剖析： <br>惊讶吗？小小的static 和const 居然有这么多功能，我们能回答几个？如果只能回答1~2 <br>个，那还真得闭关再好好修炼修炼。 <br>这个题可以考查面试者对程序设计知识的掌握程度是初级、中级还是比较深入，没有一 <br>定的知识广度和深度，不可能对这个问题给出全面的解答。大多数人只能回答出static 和 <br>const 关键字的部分功能。 <br>4.技巧题 <br>试题1：请写一个C 函数，若处理器是Big_endian 的，则返回0；若是Little_endian <br>的，则返回1 <br>解答： <br>int checkCPU() <br>{ <br>{ <br>union w <br>{ <br>int a; <br>char b; <br>} c; <br>c.a = 1; <br>return (c.b == 1); <br>} <br>} <br>剖析： <br>嵌入式系统开发者应该对Little-endian 和Big-endian 模式非常了解。采用Little-endian <br>模式的CPU 对操作数的存放方式是从低字节到高字节，而Big-endian 模式对操作数的存放 <br>方式是从高字节到低字节。例如，16bit 宽的数0x1234 在Little-endian 模式CPU 内存中的 <br>存放方式（假设从地址0x4000 开始存放）为： <br>内存地址存放内容 <br>0x4000 0x34 <br>0x4001 0x12 <br>而在Big-endian 模式CPU 内存中的存放方式则为： <br>内存地址存放内容 <br>0x4000 0x12 <br>0x4001 0x34 <br>32bit 宽的数0x12345678 在Little-endian 模式CPU 内存中的存放方式（假设从地址 <br>0x4000 开始存放）为： <br>内存地址存放内容 <br>0x4000 0x78 <br>0x4001 0x56 <br>0x4002 0x34 <br>0x4003 0x12 <br>而在Big-endian 模式CPU 内存中的存放方式则为： <br>内存地址存放内容 <br>0x4000 0x12 <br>0x4001 0x34 <br>0x4002 0x56 <br>0x4003 0x78 <br>联合体union 的存放顺序是所有成员都从低地址开始存放，面试者的解答利用该特性， <br>轻松地获得了CPU 对内存采用Little-endian 还是Big-endian 模式读写。如果谁能当场给出 <br>这个解答，那简直就是一个天才的程序员。 <br>试题2：写一个函数返回1+2+3+…+n 的值（假定结果不会超过长整型变量的范围） <br>解答： <br>int Sum( int n ) <br>{ <br>return ( (long)1 + n) * n / 2; //或return (1l + n) * n / 2; <br>} <br>剖析： <br>对于这个题，只能说，也许最简单的答案就是最好的答案。下面的解答，或者基于下面 <br>的解答思路去优化，不管怎么“折腾”，其效率也不可能与直接return ( 1 l + n ) * n / 2 相比！ <br>int Sum( int n ) <br>{ <br>long sum = 0; <br>for( int i=1; i&lt;=n; i++ ) <br>{ <br>sum += i; <br>} <br>return sum; <br>} <br>所以程序员们需要敏感地将数学等知识用在程序设计中。 <br>Trackback: <a href="http://tb.blog.csdn.net/TrackBack.aspx?PostId=1238902" rel="nofollow">http://tb.blog.csdn.net/TrackBack.aspx?PostId=1238902</a> <br>[收藏到我的网摘] zhaoyawei 发表于2006 年09 月18 日17:52:00 <br>相关文章： <br>• 声明函数指针并实现回调2001-02-10 jeffreyren <br>• 函数指针2006-04-22 kingswood <br>• 声明与函数、函数指针2006-03-14 norbe <br>• c++语言程序设计-----学习笔记(3) 2005-02-07 youki1234 <br>• 函数指针point of function 2004-09-08 leisureful <br>特别推荐： <br>• linux,C++人才哪去了. <br>趋势科技—网络安全软件及服务领域的全球领导者趋势中国研发中心诚聘英才c <br>• 浙江支付宝,中国的硅谷.开发者的天堂 <br>支付宝招聘英才员工将拥有具竞争力的薪金及众多的培训机会c <br>• 青牛软件招聘软件工程师 <br>青牛（北京）技术有限公司（简称青牛软件）是中国领c <br>• 上海日资软件企业招聘 <br>上海交大海外AIC 学院为你打通高薪之路--25 万年c <br>• 主机完全DIY,域名免费试用 <br>时代互联100M 主机216 元/年c <br># Crazyazreal 发表于2006-09-21 00:46:00 IP: 218.13.199.* <br>看完！发现自己能完成50%，嘿``继续努力！楼主多发这类文章啊！支持！ <br># 程先发表于2006-09-23 13:22:00 IP: 218.65.61.* <br>//为了实现链式操作，将目的地址返回，加3 分！ <br>char * strcpy( char *strDest, const char *strSrc ) <br>{ <br>assert( (strDest != NULL) &amp;&amp; (strSrc != NULL) ); <br>char *address = strDest; <br>while( (*strDest++ = * strSrc++) != '/0’ ); <br>return address; <br>} <br>这个给10 分有失偏颇，主管定的？后面就没继续看了，扯的! <br># lz 发表于2006-09-25 11:39:00 IP: 60.208.111.* <br>应该是主管定的，因为，也完全不这样折腾的哈。 <br>可以return，也可以就那么调用一哈嘛...... <br># sophisticated 发表于2006-09-28 09:34:00 IP: 221.250.216.* <br>void LoopMove ( char *pStr, int steps ) <br>{ <br>int n = strlen( pStr ) - steps; <br>char tmp[MAX_LEN]; <br>strcpy ( tmp, pStr + n ); <br>strcpy ( tmp + steps, pStr); <br>*( tmp + strlen ( pStr ) ) = '/0'; <br>strcpy( pStr, tmp ); <br>} <br>------------------------------------------- <br>steps &gt; strlen( pStr ) 时会有什么后果？ <br># sophisticated 发表于2006-09-28 09:48:00 IP: 221.250.216.* <br>void LoopMove ( char *pStr, int steps ) <br>{ <br>int n = strlen( pStr ) - steps; <br>char tmp[MAX_LEN]; <br>strcpy ( tmp, pStr + n ); <br>strcpy ( tmp + steps, pStr); <br>*( tmp + strlen ( pStr ) ) = '/0'; <br>strcpy( pStr, tmp ); <br>1. 下面这段代码的输出是多少(在32位机上). <br>char *p; <br>char *q[20]; <br>char *m[20][20]; <br>int (*n)[10]; <br>struct MyStruct <br>{ <br>char dda; <br>double dda1; <br>int type ; <br>}； <br>MyStruct k; <br>printf("%d %d %d %d",sizeof(p),sizeof(q),sizeof(m),sizeof(n),sizeof(k)); <br>2. <br>(1) <br>char a[2][2][3]={<!-- -->{<!-- -->{1,6,3},{5,4,15}},{<!-- -->{3,5,33},{23,12,7}} }; <br>for(int i=0;i&lt;12;i++) <br>printf("%d ",_______); <br>在空格处填上合适的语句，顺序打印出a 中的数字 <br>(2) <br>char **p, a[16][8]; <br>问：p=a是否会导致程序在以后出现问题？为什么？ <br>3.用递归方式,非递归方式写函数将一个字符串反转. <br>函数原型如下:char *reverse(char *str); <br>4.strcpy函数和memcpy函数有什么区别?它们各自使用时应该注意什么问题? <br>5.写一个函数将一个链表逆序. <br>一个单链表，不知道长度，写一个函数快速找到中间节点的位置. <br>写一个函数找出一个单向链表的倒数第n个节点的指针.(把能想到的最好算法写出). <br>6.用递归算法判断数组a[N]是否为一个递增数组。 <br>7. <br>有一个文件(名为a.txt)如下,每行有4项,第一项是他们的名次,写一个c程序,将五个人的名 <br>字打印出来.并按名次排序后将5行数据仍然保存到a.txt中.使文件按名次排列每行. <br>2,07010188,0711,李镇豪, <br>1,07010154,0421,陈亦良, <br>3,07010194,0312,凌瑞松, <br>4,07010209,0351,罗安祥, <br>5,07010237,0961,黄世传, <br>8.写一个函数,判断一个unsigned char 字符有几位是1. <br>写一个函数判断计算机的字节存储顺序是升序(little-endian)还是降序(big-endian). <br>9.微软的笔试题. <br>Implement a string class in C++ with basic functionality like comparison, <br>concatenation, input and output. Please also provide some test cases and using <br>scenarios (sample code of using this class). <br>Please do not use MFC, STL and other libraries in your implementation. <br>10.有个数组a[100]存放了100个数,这100个数取自1-99,且只有两个相同的数,剩下的98 <br>个数不同,写一个搜索算法找出相同的那个数的值.(注意空间效率时间效率尽可能要低). <br>这十道题还是能够看出自己的水平如何的.如果你能不假思索地做出这10道题,估计去国外 <br>大公司是没有问题了,呵呵. <br>答案我在整理中,以后陆续发布................. <br>下面有些题也不错,可以参考. <br>１．下面的代码输出是什么，为什么？ <br>void foo(void) <br>{ <br>unsigned int a = 6; <br>int b = -20; <br>(a+b&gt;6)?puts("&gt;6"):puts("&lt;=6");//puts 为打印函数 <br>} <br>输出&gt;6． <br>就是考察隐式转换．int 型变量转化成unsigned int, b 成了正数． <br>2. b)运行下面的函数会有什么结果？为什么？ <br>void foo(void) <br>{ <br>char string[10],str1[10]; <br>int i; <br>for(i=0;i&lt;10;i++) <br>{ <br>str1[i] = 'a'; <br>} <br>strcpy(string, str1); <br>printf("%s",string); <br>} <br>首先搞清strcpy 函数的实现方法， <br>char * strcpy(char * strDest,const char * strSrc) <br>{ <br>if ((strDest == NULL) || (strSrc == NULL)) <br>throw "Invalid argument(s)"; <br>char * strDestCopy = strDest; <br>while ((*strDest++ = *strSrc++) != '/0'); <br>return strDestCopy; <br>} <br>由于str1 末尾没有'/0’结束标志，所以strcpy 不知道拷贝到何时结束． <br>printf 函数，对于输出char* 类型，顺序打印字符串中的字符直到遇到空字符（＇＼０＇） <br>或已打印了由精度指定的字符数为止． <br>下面是微软的两道笔试题.... <br>3. Implement a string class in C++ with basic functionality like comparison, concatenation, <br>input and output. Please also provide some test cases and using scenarios (sample code <br>of using this class). <br>Please do not use MFC, STL and other libraries in your implementation. <br>我的实现方案如下,这道题真地对c++的主要特性都进行了较好地考察. <br>String.h: <br>#ifndef STRING_H <br>#define STRING_H <br>#include 
  
  <br>using namespace std; 
  <br>class String{ 
  <br>public: 
  <br>String(); 
  <br>String(int n,char c); 
  <br>String(const char* source); 
  <br>String(const String&amp; s); 
  <br>//String&amp; operator=(char* s); 
  <br>String&amp; operator=(const String&amp; s); 
  <br>~String(); 
  <br>char&amp; operator[](int i){return a[i];} 
  <br>const char&amp; operator[](int i) const {return a[i];}//对常量的索引. 
  <br>String&amp; operator+=(const String&amp; s); 
  <br>int length(); 
  <br>friend istream&amp; operator&gt;&gt;(istream&amp; is, String&amp; s);//搞清为什么将&gt;&gt;设置为友元函数的 
  <br>原因. 
  <br>//friend bool operator&lt; (const String&amp; left,const String&amp; right); 
  <br>friend bool operator&gt; (const String&amp; left, const String&amp; right);//下面三个运算符都没必要 
  <br>设成友元函数,这里是为了简单. 
  <br>friend bool operator== (const String&amp; left, const String&amp; right); 
  <br>friend bool operator!= (const String&amp; left, const String&amp; right); 
  <br>private: 
  <br>char* a; 
  <br>int size; 
  <br>}; 
  <br>#endif 
  <br>String.cpp: 
  <br>#include "String.h" 
  <br>#include 
   
   <br>#include 
    
    <br>String::String(){ 
    <br>a = new char[1]; 
    <br>a[0] = '/0'; 
    <br>size = 0; 
    <br>} 
    <br>String::String(int n,char c){ 
    <br>a = new char[n + 1]; 
    <br>memset(a,c,n); 
    <br>a[n] = '/0'; 
    <br>size = n; 
    <br>} 
    <br>String::String(const char* source){ 
    <br>if(source == NULL){ 
    <br>a = new char[1]; 
    <br>a[0] = '/0'; 
    <br>size = 0; 
    <br>} 
    <br>else 
    <br>{ size = strlen(source); 
    <br>a = new char[size + 1]; 
    <br>strcpy(a,source); 
    <br>} 
    <br>} 
    <br>String::String(const String&amp; s){ 
    <br>size = strlen(s.a);//可以访问私有变量. 
    <br>a = new char[size + 1]; 
    <br>//if(a == NULL) 
    <br>strcpy(a,s.a); 
    <br>} 
    <br>String&amp; String::operator=(const String&amp; s){ 
    <br>if(this == &amp;s) 
    <br>return *this; 
    <br>else 
    <br>{ 
    <br>delete[] a; 
    <br>size = strlen(s.a); 
    <br>a = new char[size + 1]; 
    <br>strcpy(a,s.a); 
    <br>return *this; 
    <br>} 
    <br>} 
    <br>String::~String(){ 
    <br>delete[] a;// 
    <br>} 
    <br>String&amp; String::operator+=(const String&amp; s){ 
    <br>int j = strlen(a); 
    <br>int size = j + strlen(s.a); 
    <br>char* tmp = new char[size+1]; 
    <br>strcpy(tmp,a); 
    <br>strcpy(tmp+j,s.a); 
    <br>delete[] a; 
    <br>a = tmp; 
    <br>return *this; 
    <br>} 
    <br>int String::length(){ 
    <br>return strlen(a); 
    <br>} 
    <br>main.cpp: 
    <br>#include 
     
     <br>#include "String.h" 
     <br>using namespace std; 
     <br>bool operator==(const String&amp; left, const String&amp; right) 
     <br>{ 
     <br>int a = strcmp(left.a,right.a); 
     <br>if(a == 0) 
     <br>return true; 
     <br>else 
     <br>return false; 
     <br>} 
     <br>bool operator!=(const String&amp; left, const String&amp; right) 
     <br>{ 
     <br>return !(left == right); 
     <br>} 
     <br>ostream&amp; operator&lt;&lt;(ostream&amp; os,String&amp; s){ 
     <br>int length = s.length(); 
     <br>for(int i = 0;i &lt; length;i++) 
     <br>//os &lt;&lt; s.a[i];这么不行,私有变量. 
     <br>os &lt;&lt; s[i]; 
     <br>return os; 
     <br>} 
     <br>String operator+(const String&amp; a,const String&amp; b){ 
     <br>String temp; 
     <br>temp = a; 
     <br>temp += b; 
     <br>return temp; 
     <br>} 
     <br>bool operator&lt;(const String&amp; left,const String&amp; right){ 
     <br>int j = 0; 
     <br>while((left[j] != '/0') &amp;&amp; (right[j] != '/0')){ 
     <br>if(left[j] &lt; right[j]) 
     <br>return true; 
     <br>else 
     <br>{ 
     <br>if(left[j] == right[j]){ 
     <br>j++; 
     <br>continue; 
     <br>} 
     <br>else 
     <br>return false; 
     <br>} 
     <br>} 
     <br>if((left[j] == '/0') &amp;&amp; (right[j] != '/0')) 
     <br>return true; 
     <br>else 
     <br>return false; 
     <br>} 
     <br>bool operator&gt;(const String&amp; left, const String&amp; right) 
     <br>{ int a = strcmp(left.a,right.a); 
     <br>if(a &gt; 0) 
     <br>return true; 
     <br>else 
     <br>return false; 
     <br>} 
     <br>istream&amp; operator&gt;&gt;(istream&amp; is, String&amp; s){ 
     <br>delete[] s.a; 
     <br>s.a = new char[20]; 
     <br>int m = 20; 
     <br>char c; 
     <br>int i = 0; 
     <br>while (is.get(c) &amp;&amp; isspace(c)); 
     <br>if (is) { 
     <br>do {s.a[i] = c; 
     <br>i++; 
     <br>/*if(i &gt;= 20){ 
     <br>cout &lt;&lt; "Input too much characters!" &lt;&lt; endl; 
     <br>exit(-1); 
     <br>}*/ 
     <br>if(i == m - 1 ){ 
     <br>s.a[i] = '/0'; 
     <br>char* b = new char[m]; 
     <br>strcpy(b,s.a); 
     <br>m = m * 2; 
     <br>s.a = new char[m]; 
     <br>strcpy(s.a,b); 
     <br>delete[] b; 
     <br>} 
     <br>} 
     <br>while (is.get(c) &amp;&amp; !isspace(c)); 
     <br>//如果读到空白,将其放回. 
     <br>if (is) 
     <br>is.unget(); 
     <br>} 
     <br>s.size = i; 
     <br>s.a[i] = '/0'; 
     <br>return is; 
     <br>} 
     <br>int main(){ 
     <br>String a = "abcd"; 
     <br>String b = "www"; 
     <br>//String c(6,b);这么写不对. 
     <br>String c(6,'l'); 
     <br>String d; 
     <br>String e = a;//abcd 
     <br>String f; 
     <br>cin &gt;&gt; f;//需要输入... 
     <br>String g; 
     <br>g = a + b;//abcdwww 
     <br>if(a &lt; b) 
     <br>cout &lt;&lt; "a &lt; b" &lt;&lt; endl; 
     <br>else 
     <br>cout &lt;&lt; "a &gt;= b" &lt;&lt; endl; 
     <br>if(e == a) 
     <br>cout &lt;&lt; "e == a" &lt;&lt; endl; 
     <br>else 
     <br>cout &lt;&lt; "e != a" &lt;&lt; endl; 
     <br>b += a; 
     <br>cout &lt;&lt; a &lt;&lt; endl; 
     <br>cout &lt;&lt; b &lt;&lt; endl; 
     <br>cout &lt;&lt; c &lt;&lt; endl; 
     <br>cout &lt;&lt; d &lt;&lt; endl; 
     <br>cout &lt;&lt; e &lt;&lt; endl; 
     <br>cout &lt;&lt; f &lt;&lt; endl; 
     <br>cout &lt;&lt; g &lt;&lt; endl; 
     <br>cout &lt;&lt; g[0] &lt;&lt; endl; 
     <br>return 0; 
     <br>} 
     <br>4. Implement a single-direction linked list sorting algorithm. Please first define the data 
     <br>structure of linked list and then implement the sorting algorithm. 
     <br>5.编写一个函数，返回两个字符串的最大公串！例如，“adbccadebbca”和“edabccadece”, 
     <br>返回“ccade” 
     <br>联想笔试题 
     <br>1．设计函数int atoi(char *s)。 
     <br>int atoi(const char *nptr); 
     <br>函数说明 
     <br>atoi()会扫描参数nptr 字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换， 
     <br>而再遇到非数字或字符串结束时('/0')才结束转换，并将结果返回。 
     <br>返回值返回转换后的整型数。 
     <br>#include 
      
      <br>#include 
       
       <br>int myAtoi(const char* s){ 
       <br>int result = 0; 
       <br>int flag = 1; 
       <br>int i = 0; 
       <br>while(isspace(s[i])) 
       <br>i++; 
       <br>if(s[i] == '-'){ 
       <br>flag = -1; 
       <br>i++; 
       <br>} 
       <br>if(s[i] == '+') 
       <br>i++; 
       <br>while(s[i] != '/0'){ 
       <br>if((s[i] &gt; '9') || (s[i] &lt; '0')) 
       <br>break; 
       <br>int j = s[i] - '0'; 
       <br>result = 10 * result + j; 
       <br>i++; 
       <br>} 
       <br>result = result * flag; 
       <br>return result; 
       <br>} 
       <br>int main(){ 
       <br>char* a = " -1234def"; 
       <br>char* b = "+1234"; 
       <br>int i = myAtoi(a); 
       <br>int j = myAtoi(b); 
       <br>printf("%d /n",i); 
       <br>printf("%d",j); 
       <br>return 0; 
       <br>} 
       <br>2．int i=(j=4,k=8,l=16,m=32); printf(“%d”, i); 输出是多少？ 
       <br>3．解释局部变量、全局变量和静态变量的含义。 
       <br>4．解释堆和栈的区别。 
       <br>5．论述含参数的宏与函数的优缺点。 
       <br>普天C++笔试题 
       <br>1．实现双向链表删除一个节点P，在节点P 后插入一个节点，写出这两个函数。 
       <br>2．写一个函数，将其中的/t 都转换成4 个空格。 
       <br>3．Windows 程序的入口是哪里？写出Windows 消息机制的流程。 
       <br>4．如何定义和实现一个类的成员函数为回调函数？ 
       <br>5．C++里面是不是所有的动作都是main()引起的？如果不是，请举例。 
       <br>6．C++里面如何声明const void f(void)函数为C 程序中的库函数？ 
       <br>7．下列哪两个是等同的 
       <br>int b; 
       <br>A const int* a = &amp;b; 
       <br>B const* int a = &amp;b; 
       <br>C const int* const a = &amp;b; 
       <br>D int const* const a = &amp;b; 
       <br>8．内联函数在编译时是否做参数类型检查？ 
       <br>void g(base &amp; b){ 
       <br>b.play; 
       <br>} 
       <br>void main(){ 
       <br>son s; 
       <br>g(s); 
       <br>return; 
       <br>} 
       <br>华为笔试题 
       <br>1．请你分别画出OSI 的七层网络结构图和TCP/IP 的五层结构图。 
       <br>2．请你详细地解释一下IP 协议的定义，在哪个层上面？主要有什么作用？TCP 与UDP 
       <br>呢？ 
       <br>3．请问交换机和路由器各自的实现原理是什么？分别在哪个层次上面实现的？ 
       <br>4．请问C++的类和C 里面的struct 有什么区别？ 
       <br>5．请讲一讲析构函数和虚函数的用法和作用。 
       <br>6．全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道 
       <br>的？ 
       <br>7．8086 是多少位的系统？在数据总线上是怎么实现的？ 
       <br>Sony 笔试题 
       <br>1．完成下列程序 
       <br>* 
       <br>*.*. 
       <br>*..*..*.. 
       <br>*...*...*...*... 
       <br>*....*....*....*....*.... 
       <br>*.....*.....*.....*.....*.....*..... 
       <br>*......*......*......*......*......*......*...... 
       <br>*.......*.......*.......*.......*.......*.......*.......*....... 
       <br>#include 
        
        <br>#define N 8 
        <br>int main() 
        <br>{ 
        <br>int i; 
        <br>int j; 
        <br>int k; 
        <br>--------------------------------------------------------- 
        <br>| | 
        <br>| | 
        <br>| | 
        <br>--------------------------------------------------------- 
        <br>return 0; 
        <br>} 
        <br>2．完成程序，实现对数组的降序排序 
        <br>#include 
         
         <br>void sort( ); 
         <br>int main() 
         <br>{ 
         <br>int array[]={45，56，76，234，1，34，23，2，3}； //数字任//意给出 
         <br>sort( ); 
         <br>return 0; 
         <br>} 
         <br>void sort( ) 
         <br>{ 
         <br>____________________________________ 
         <br>| | 
         <br>| | 
         <br>|-----------------------------------------------------| 
         <br>} 
         <br>3．费波那其数列，1，1，2，3，5……编写程序求第十项。可以用递归，也可以用其 
         <br>他方法，但要说明你选择的理由。 
         <br>#include 
          
          <br>int Pheponatch(int); 
          <br>int main() 
          <br>{ 
          <br>printf("The 10th is %d",Pheponatch(10)); 
          <br>return 0; 
          <br>} 
          <br>int Pheponatch(int N) 
          <br>{ 
          <br>-------------------------------- 
          <br>| | 
          <br>| | 
          <br>-------------------------------- 
          <br>} 
          <br>4．下列程序运行时会崩溃，请找出错误并改正，并且说明原因。 
          <br>#include 
           
           <br>#include 
            
            <br>typedef struct{ 
            <br>TNode* left; 
            <br>TNode* right; 
            <br>int value; 
            <br>} TNode; 
            <br>TNode* root=NULL; 
            <br>void append(int N); 
            <br>int main() 
            <br>{ 
            <br>append(63); 
            <br>append(45); 
            <br>append(32); 
            <br>append(77); 
            <br>append(96); 
            <br>append(21); 
            <br>append(17); // Again, 数字任意给出 
            <br>} 
            <br>void append(int N) 
            <br>{ 
            <br>TNode* NewNode=(TNode *)malloc(sizeof(TNode)); 
            <br>NewNode-&gt;value=N; 
            <br>if(root==NULL) 
            <br>{ 
            <br>root=NewNode; 
            <br>return; 
            <br>} 
            <br>else 
            <br>{ 
            <br>TNode* temp; 
            <br>temp=root; 
            <br>while((N&gt;=temp.value &amp;&amp; temp.left!=NULL) || (N 
             
             <br>)) 
             <br>{ 
             <br>while(N&gt;=temp.value &amp;&amp; temp.left!=NULL) 
             <br>temp=temp.left; 
             <br>while(N 
              
              <br>temp=temp.right; 
              <br>} 
              <br>if(N&gt;=temp.value) 
              <br>temp.left=NewNode; 
              <br>else 
              <br>temp.right=NewNode; 
              <br>return; 
              <br>} 
              <br>} 
              <br>MSRA Interview Written Exam（December 2003，Time：2.5 Hours） 
              <br>1 写出下列算法的时间复杂度。 
              <br>(1)冒泡排序； 
              <br>(2)选择排序； 
              <br>(3)插入排序； 
              <br>(4)快速排序； 
              <br>(5)堆排序； 
              <br>(6)归并排序； 
              <br>2 写出下列程序在X86 上的运行结果。 
              <br>struct mybitfields 
              <br>{ 
              <br>unsigned short a : 4; 
              <br>unsigned short b : 5; 
              <br>unsigned short c : 7; 
              <br>}test 
              <br>void main(void) 
              <br>{ 
              <br>int i; 
              <br>test.a=2; 
              <br>test.b=3; 
              <br>test.c=0; 
              <br>i=*((short *)&amp;test); 
              <br>printf("%d/n",i); 
              <br>} 
              <br>3 写出下列程序的运行结果。 
              <br>unsigned int i=3; 
              <br>cout&lt; 
              <i></i>4 写出下列程序所有可能的运行结果。 
              <br>int a; 
              <br>int b; 
              <br>int c; 
              <br>void F1() 
              <br>{ 
              <br>b=a*2; 
              <br>a=b; 
              <br>} 
              <br>void F2() 
              <br>{ 
              <br>c=a+1; 
              <br>a=c; 
              <br>} 
              <br>main() 
              <br>{ 
              <br>a=5; 
              <br>//Start F1,F2 in parallel 
              <br>F1(); F2(); 
              <br>printf("a=%d/n",a); 
              <br>} 
              <br>5 考察了一个CharPrev()函数的作用。 
              <br>6 对16 Bits colors 的处理，要求： 
              <br>（1）Byte 转换为RGB 时，保留高5、6bits； 
              <br>（2）RGB 转换为Byte 时，第2、3 位置零。 
              <br>7 一个链表的操作，注意代码的健壮和安全性。要求： 
              <br>（1）增加一个元素； 
              <br>（2）获得头元素； 
              <br>（3）弹出头元素（获得值并删除）。 
              <br>8 一个给定的数值由左边开始升位到右边第N 位，如 
              <br>0010&lt;&lt;1 == 0100 
              <br>或者 
              <br>0001 0011&lt;&lt;4 == 0011 0000 
              <br>请用C 或者C++或者其他X86 上能运行的程序实现。 
              <br>附加题（只有在完成以上题目后，才获准回答） 
              <br>In C++, what does "explicit" mean? what does "protected" mean? 
              <br>1。在C++中有没有纯虚构造函数？ 
              <br>2。在c++的一个类中声明一个static 成员变量有没有用？ 
              <br>3。在C++的一个类中声明一个静态成员函数有没有用？ 
              <br>4。如何实现一个非阻塞的socket? 
              <br>5。setsockopt, ioctl 都可以对socket 的属性进行设置，他们有什么不同？ 
              <br>6。解释一下进程和线程的区别？ 
              <br>7。解释一下多播（组播）和广播的含义？ 
              <br>8。多播采用的协议是什么？ 
              <br>9。在c++中纯虚析构函数的作用是什么？请举例说明。 
              <br>10。编程，请实现一个c 语言中类似atoi 的函数功能（输入可能包含非数字和空格） 
              <br>1。分析下面的程序： 
              <br>void GetMemory(char **p,int num) 
              <br>{ 
              <br>*p=(char *)malloc(num); 
              <br>} 
              <br>int main() 
              <br>{ 
              <br>char *str=NULL; 
              <br>GetMemory(&amp;str,100); 
              <br>strcpy(str,"hello"); 
              <br>free(str); 
              <br>if(str!=NULL) 
              <br>{ 
              <br>strcpy(str,"world"); 
              <br>} 
              <br>printf("/n str is %s",str); 
              <br>getchar(); 
              <br>} 
              <br>问输出结果是什么？ 
              <br>答案：输出str is world。 
              <br>free 只是释放的str 指向的内存空间,它本身的值还是存在的. 
              <br>所以free 之后，有一个好的习惯就是将str=NULL. 
              <br>此时str 指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储 
              <br>空间是可能被重新分配给其他变量的, 
              <br>尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出w 
              <br>orld 来。 
              <br>这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。 
              <br>当你malloc 一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些）， 
              <br>然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的 
              <br>地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继 
              <br>续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。 
              <br>2。运行的结果为什么等于15 
              <br>#include "stdio.h" 
              <br>#include "string.h" 
              <br>void main() 
              <br>{ 
              <br>char aa[10]; 
              <br>printf("%d",strlen(aa)); 
              <br>} 
              <br>答案：sizeof()和初不初始化，没有关系；strlen()和初始化有关。 
              <br>3。给定结构struct A 
              <br>{ 
              <br>char t:4; 
              <br>char k:4; 
              <br>unsigned short i:8; 
              <br>unsigned long m; 
              <br>};问sizeof(A) = ? 
              <br>答案：给定结构 
              <br>struct A 
              <br>{ 
              <br>char t:4; //4 位 
              <br>char k:4; //4 位 
              <br>unsigned short i:8; //8 位这里要偏移2 字节保证4 字节对齐 
              <br>unsigned long m; //4 个字节 
              <br>}; // 共8 字节 
              <br>4。分析一下 
              <br>#include 
               
               <br>#include 
                
                <br>#include 
                 
                 <br>#include 
                  
                  <br>#include 
                   
                   <br>#include 
                    
                    <br>typedef struct AA 
                    <br>{ 
                    <br>int b1:5; 
                    <br>int b2:2; 
                    <br>}AA; 
                    <br>void main() 
                    <br>{ 
                    <br>AA aa; 
                    <br>char cc[100]; 
                    <br>strcpy(cc,"0123456789abcdefghijklmnopqrstuvwxyz"); 
                    <br>memcpy(&amp;aa,cc,sizeof(AA)); 
                    <br>cout &lt;&lt; aa.b1 &lt; 
                     
                     <br>cout &lt;&lt; aa.b2 &lt; 
                      
                      <br>} 
                      <br>答案： -16 和１ 
                      <br>首先sizeof(AA)的大小为4,b1 和b2 分别占5bit 和2bit. 
                      <br>经过strcpy 和memcpy 后,aa 的4 个字节所存放的值是: 
                      <br>0,1,2,3 的ASC 码，即00110000,00110001,00110010,00110011 
                      <br>所以，最后一步：显示的是这４个字节的前５位，和之后的２位 
                      <br>分别为：10000,和01 
                      <br>因为int 是有正负之分所以是-16 和１ 
                      <br>5。求函数返回值，输入x=9999; 
                      <br>int func （ x ） 
                      <br>{ 
                      <br>int countx = 0; 
                      <br>while ( x ) 
                      <br>{ 
                      <br>countx ++; 
                      <br>x = x&amp;(x-1); 
                      <br>} 
                      <br>return countx; 
                      <br>} 
                      <br>结果呢？ 
                      <br>答案：知道了这是统计9999 的二进制数值中有多少个1 的函数，且有 
                      <br>9999＝9×1024＋512＋256＋15 
                      <br>9×1024 中含有1 的个数为2； 
                      <br>512 中含有1 的个数为1； 
                      <br>256 中含有1 的个数为1； 
                      <br>15 中含有1 的个数为4； 
                      <br>故共有1 的个数为8，结果为8。 
                      <br>1000 - 1 = 0111，正好是原数取反。这就是原理。 
                      <br>用这种方法来求1 的个数是很效率很高的。 
                      <br>不必去一个一个地移位。循环次数最少。 
                      <br>6。int a,b,c 请写函数实现C=a+b ,不可以改变数据类型,如将c 改为long int,关键是如何 
                      <br>处理溢出问题 
                      <br>答案：bool add (int a, int b,int *c) 
                      <br>{ 
                      <br>*c=a+b; 
                      <br>return (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp;(*c 
                      a || *c&gt;b))); <br>} <br>7。分析： <br>struct bit <br>{ int a:3; <br>int b:2; <br>int c:3; <br>}; <br>int main() <br>{ <br>bit s; <br>char *c=(char*)&amp;s; <br>cout&lt; 
                       
                         &lt; 
                         
                         <br>*c=0x99; 
                         <br>cout &lt;&lt; s.a &lt; 
                         
                           &lt; 
                          
                            &lt; 
                           
                             &lt; 
                            
                              &lt; 
                              
                              <br>int a=-1; 
                              <br>printf("%x",a); 
                              <br>return 0; 
                              <br>} 
                              <br>输出为什么是？ 
                              <br>答案：4 
                              <br>1 
                              <br>-1 
                              <br>-4 
                              <br>ffffffff 
                              <br>因为0x99 在内存中表示为100 11 001 , a = 001, b = 11, c = 100（在vc 环境中，一 
                              <br>般是由右到左进行分配的） 
                              <br>当c 为有符合数时, c = 100, 最高1 为表示c 为负数，负数在计算机用补码表示，所以c 
                              <br>= -4;同理 
                              <br>b = -1; 
                              <br>当c 为有符合数时, c = 100,即c = 4,同理b = 3 
                              <br>8。改错： 
                              <br>#include 
                               
                               <br>int main(void) { 
                               <br>int **p; 
                               <br>int arr[100]; 
                               <br>p = &amp;arr; 
                               <br>return 0; 
                               <br>} 
                               <br>答案：搞错了,是指针类型不同, 
                               <br>int **p; //二级指针 
                               <br>&amp;arr; //得到的是指向第一维为100 的数组的指针 
                               <br>应该这样写#include 
                                
                                <br>int main(void) { 
                                <br>int **p, *q; 
                                <br>int arr[100]; 
                                <br>q = arr; 
                                <br>p = &amp;q; 
                                <br>return 0; 
                                <br>9。下面这个程序执行后会有什么错误或者效果: 
                                <br>#define MAX 255 
                                <br>int main() 
                                <br>{ 
                                <br>unsigned char A[MAX],i; //i 被定义为unsigned char 
                                <br>for (i=0;i&lt;=MAX;i++) 
                                <br>A[i]=i; 
                                <br>} 
                                <br>答案：死循环加数组越界访问（C/C++不进行数组越界检查） 
                                <br>MAX=255 
                                <br>数组A 的下标范围为:0..MAX-1,这是其一.. 
                                <br>其二.当i 循环到255 时,循环内执行: 
                                <br>A[255]=255; 
                                <br>这句本身没有问题..但是返回for (i=0;i&lt;=MAX;i++)语句时, 
                                <br>由于unsigned char 的取值范围在(0..255),i++以后i 又为0 了..无限循环下去. 
                                <br>11。struct name1{ 
                                <br>char str; 
                                <br>short x; 
                                <br>int num; 
                                <br>} 
                                <br>struct name2{ 
                                <br>char str; 
                                <br>int num; 
                                <br>short x; 
                                <br>} 
                                <br>sizeof(struct name1)=？？,sizeof(struct name2)=？？ 
                                <br>答案：sizeof(struct name1)=8,sizeof(struct name2)=12 
                                <br>在第二个结构中，为保证num 按四个字节对齐，char 后必须留出3 字节的空间；同时为保 
                                <br>证整个结构的自然对齐（这里是4 字节对齐），在x 后还要补齐2 个字节，这样就是12 字 
                                <br>节。 
                                <br>1.写出判断ABCD四个表达式的是否正确, 若正确, 写出经过表达式中a的值(3分) 
                                <br>int a = 4; 
                                <br>(A)a += (a++); (B) a += (++a) ;(C) (a++) += a;(D) (++a) += (a++); 
                                <br>a = ? 
                                <br>答：C错误，左侧不是一个有效变量，不能赋值，可改为(++a) += a; 
                                <br>改后答案依次为9,10,10,11 
                                <br>2.某32 位系统下, C++程序，请计算sizeof 的值(5 分). 
                                <br>char str[] = “www.ibegroup.com” 
                                <br>char *p = str ; 
                                <br>int n = 10; 
                                <br>请计算 
                                <br>sizeof (str ) = ？（1）//数组分配的内存是连续的 
                                <br>sizeof ( p ) = ？（2）//指针内存不连续，指针的大小为4 
                                <br>sizeof ( n ) = ？（3）/整形 
                                <br>void Foo ( char str[100]){ 
                                <br>请计算 
                                <br>sizeof( str ) = ？（4）//数组作为参数传递时，传递的是数组的首地址，即指向第一个元素 
                                <br>的指针 
                                <br>} 
                                <br>void *p = malloc( 100 ); 
                                <br>请计算 
                                <br>sizeof ( p ) = ？（5） 
                                <br>答：（1）17 （2）4 （3） 4 （4）4 （5）4 
                                <br>4. 回答下面的问题(6 分) 
                                <br>(1). 
                                <br>Void GetMemory(char **p, int num){ 
                                <br>*p = (char *)malloc(num); 
                                <br>} 
                                <br>void Test(void){ 
                                <br>char *str = NULL; 
                                <br>GetMemory(&amp;str, 100); 
                                <br>strcpy(str, "hello"); 
                                <br>printf(str); 
                                <br>} 
                                <br>请问运行Test 函数会有什么样的结果？ 
                                <br>答：输出“hello” 
                                <br>(2). 
                                <br>void Test(void){ 
                                <br>char *str = (char *) malloc(100); 
                                <br>strcpy(str, “hello”); 
                                <br>free(str); 
                                <br>if(str != NULL){ 
                                <br>strcpy(str, “world”); 
                                <br>printf(str); 
                                <br>} 
                                <br>} 
                                <br>请问运行Test 函数会有什么样的结果？ 
                                <br>答：输出“world”，因为free(str)后并未改变str 所指的内存内容。 
                                <br>(3). 
                                <br>char *GetMemory(void){ 
                                <br>char p[] = "hello world"; 
                                <br>return p; 
                                <br>} 
                                <br>void Test(void){ 
                                <br>char *str = NULL; 
                                <br>str = GetMemory(); 
                                <br>printf(str); 
                                <br>} 
                                <br>请问运行Test 函数会有什么样的结果？ 
                                <br>答：无效的指针，输出不确定 
                                <br>5. 编写strcat 函数(6 分) 
                                <br>已知strcat 函数的原型是char *strcat (char *strDest, const char *strSrc); 
                                <br>其中strDest 是目的字符串，strSrc 是源字符串。 
                                <br>（1）不调用C++/C 的字符串库函数，请编写函数strcat 
                                <br>答： 
                                <br>VC 源码： 
                                <br>char * __cdecl strcat (char * dst, const char * src) 
                                <br>{ 
                                <br>char * cp = dst; 
                                <br>while( *cp ) 
                                <br>cp++; /* find end of dst */ 
                                <br>while( *cp++ = *src++ ) ; /* Copy src to end of dst */ 
                                <br>return( dst ); /* return dst */ 
                                <br>} 
                                <br>（2）strcat 能把strSrc 的内容连接到strDest，为什么还要char * 类型的返回值？ 
                                <br>答：方便赋值给其他变量 
                                <br>6.MFC 中CString 是类型安全类么？ 
                                <br>答：不是，其它数据类型转换到CString 可以使用CString 的成员函数Format 来转换 
                                <br>7.C++中为什么用模板类。 
                                <br>答：(1)可用来创建动态增长和减小的数据结构 
                                <br>（2）它是类型无关的，因此具有很高的可复用性。 
                                <br>（3）它在编译时而不是运行时检查数据类型，保证了类型安全 
                                <br>（4）它是平台无关的，可移植性 
                                <br>（5）可用于基本数据类型 
                                <br>8.CSingleLock 是干什么的。 
                                <br>答：同步多个线程对一个数据类的同时访问 
                                <br>9.NEWTEXTMETRIC 是什么。 
                                <br>答：物理字体结构，用来设置字体的高宽大小 
                                <br>10.程序什么时候应该使用线程，什么时候单线程效率高。 
                                <br>答：1．耗时的操作使用线程，提高应用程序响应 
                                <br>2．并行操作时使用线程，如C/S 架构的服务器端并发线程响应用户的请求。 
                                <br>3．多CPU 系统中，使用线程提高CPU 利用率 
                                <br>4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立 
                                <br>的运行部分，这样的程序会利于理解和修改。 
                                <br>其他情况都使用单线程。 
                                <br>11.Windows 是内核级线程么。 
                                <br>答：见下一题 
                                <br>12.Linux 有内核级线程么。 
                                <br>答：线程通常被定义为一个进程中代码的不同执行路线。从实现方式上划分，线程有两种类 
                                <br>型：“用户级线程”和“内核级线程”。用户线程指不需要内核支持而在用户程序中实现的线程， 
                                <br>其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来 
                                <br>控制用户线程。这种线程甚至在象DOS 这样的操作系统中也可实现，但线程的调度需要 
                                <br>用户程序完成，这有些类似Windows 3.x 的协作式多任务。另外一种则需要内核的参与， 
                                <br>由内核完成线程的调度。其依赖于操作系统核心，由内核的内部需求进行创建和撤销，这两 
                                <br>种模型各有其好处和缺点。用户线程不需要额外的内核开支，并且用户态线程的实现方式可 
                                <br>以被定制或修改以适应特殊应用的要求，但是当一个线程因I/O 而处于等待状态时，整个 
                                <br>进程就会被调度程序切换为等待状态，其他线程得不到运行的机会；而内核线程则没有各个 
                                <br>限制，有利于发挥多处理器的并发优势，但却占用了更多的系统开支。 
                                <br>Windows NT 和OS/2 支持内核线程。Linux 支持内核级的多线程 
                                <br>13.C++中什么数据分配在栈或堆中，New 分配数据是在近堆还是远堆中？ 
                                <br>答：栈: 存放局部变量，函数调用参数,函数返回值，函数返回地址。由系统管理 
                                <br>堆: 程序运行时动态申请，new 和malloc 申请的内存就在堆上 
                                <br>近堆还是远堆不是很清楚。 
                                <br>14.使用线程是如何防止出现大的波峰。 
                                <br>答：意思是如何防止同时产生大量的线程，方法是使用线程池，线程池具有可以同时提高调 
                                <br>度效率和限制资源使用的好处，线程池中的线程达到最大数时，其他线程就会排队等候。 
                                <br>15 函数模板与类模板有什么区别？ 
                                <br>答：函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须 
                                <br>由程序员在程序中显式地指定。 
                                <br>16 一般数据库若出现日志满了，会出现什么情况，是否还能使用？ 
                                <br>答：只能执行查询等读操作，不能执行更改，备份等写操作，原因是任何写操作都要记录日 
                                <br>志。也就是说基本上处于不能使用的状态。 
                                <br>17 SQL Server 是否支持行级锁，有什么好处？ 
                                <br>答：支持，设立封锁机制主要是为了对并发操作进行控制，对干扰进行封锁，保证数据的一 
                                <br>致性和准确性，行级封锁确保在用户取得被更新的行到该行进行更新这段时间内不被其它用 
                                <br>户所修改。因而行级锁即可保证数据的一致性又能提高数据操作的迸发性。 
                                <br>18 如果数据库满了会出现什么情况，是否还能使用？ 
                                <br>答：见16 
                                <br>19 关于内存对齐的问题以及sizof()的输出 
                                <br>答：编译器自动对齐的原因：为了提高程序的性能，数据结构（尤其是栈）应该尽可能地在 
                                <br>自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而， 
                                <br>对齐的内存访问仅需要一次访问。 
                                <br>20 int i=10, j=10, k=3; k*=i+j; k 最后的值是？ 
                                <br>答：60，此题考察优先级，实际写成： k*=(i+j);，赋值运算符优先级最低 
                                <br>21.对数据库的一张表进行操作,同时要对另一张表进行操作,如何实现? 
                                <br>答：将操作多个表的操作放入到事务中进行处理 
                                <br>22.TCP/IP 建立连接的过程?(3-way shake) 
                                <br>答：在TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立一个连接。 
                                <br>第一次握手：建立连接时，客户端发送syn 包(syn=j)到服务器，并进入SYN_SEND 状 
                                <br>态，等待服务器确认； 
                                <br>第二次握手：服务器收到syn 包，必须确认客户的SYN（ack=j+1），同时自己也发送一个 
                                <br>SYN 包（syn=k），即SYN+ACK 包，此时服务器进入SYN_RECV 状态； 
                                <br>第三次握手：客户端收到服务器的SYN＋ACK 包，向服务器发送确认包ACK(ack=k+1)， 
                                <br>此包发送完毕，客户端和服务器进入ESTABLISHED 状态，完成三次握手。 
                                <br>23.ICMP 是什么协议,处于哪一层? 
                                <br>答：Internet 控制报文协议，处于网络层（IP 层） 
                                <br>24.触发器怎么工作的? 
                                <br>答：触发器主要是通过事件进行触发而被执行的，当对某一表进行诸如UPDATE、INSERT、 
                                <br>DELETE 这些操作时，数据库就会自动执行触发器所定义的SQL 语句，从而确保对数据 
                                <br>的处理必须符合由这些SQL 语句所定义的规则。 
                                <br>25.winsock 建立连接的主要实现步骤? 
                                <br>答：服务器端：socker()建立套接字，绑定（bind）并监听（listen），用accept（）等待客 
                                <br>户端连接。 
                                <br>客户端：socker()建立套接字，连接（connect）服务器，连接上后使用send()和recv（）， 
                                <br>在套接字上写读数据，直至数据交换完毕，closesocket()关闭套接字。 
                                <br>服务器端：accept（）发现有客户端连接，建立一个新的套接字，自身重新开始等待连接。 
                                <br>该新产生的套接字使用send()和recv（）写读数据，直至数据交换完毕，closesocket()关 
                                <br>闭套接字。 
                                <br>26.动态连接库的两种方式? 
                                <br>答：调用一个DLL 中的函数有两种方法： 
                                <br>1．载入时动态链接（load-time dynamic linking），模块非常明确调用某个导出函数，使得 
                                <br>他们就像本地函数一样。这需要链接时链接那些函数所在DLL 的导入库，导入库向系统提 
                                <br>供了载入DLL 时所需的信息及DLL 函数定位。 
                                <br>2 ． 运行时动态链接（ run-time dynamic linking ）， 运行时可以通过LoadLibrary 或 
                                <br>LoadLibraryEx 函数载入DLL。DLL 载入后，模块可以通过调用GetProcAddress 获取DLL 
                                <br>函数的出口地址，然后就可以通过返回的函数指针调用DLL 函数了。如此即可避免导入库 
                                <br>文件了。 
                                <br>27.IP 组播有那些好处?答： Internet 上产生的许多新的应用，特别是高带宽的多媒体应用， 
                                <br>带来了带宽的急剧消耗和网络拥挤问题。组播是一种允许一个或多个发送者（组播源）发送 
                                <br>单一的数据包到多个接收者（一次的，同时的）的网络技术。组播可以大大的节省网络带宽， 
                                <br>因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包。所以说组 
                                <br>播技术的核心就是针对如何节约网络资源的前提下保证服务质量。 
                                <br>一、#include “filename.h”和#include 
                                
                                  的区别 
                                 <br>#include “filename.h”是指编译器将从当前工作目录上开始查找此文件 
                                 <br>#include 
                                 
                                   是指编译器将从标准库目录中开始查找此文件 
                                  <br>二、头文件的作用 
                                  <br>加强安全检测 
                                  <br>通过头文件可能方便地调用库功能，而不必关心其实现方式 
                                  <br>三、* , &amp;修饰符的位置 
                                  <br>对于*和&amp;修饰符，为了避免误解，最好将修饰符紧靠变量名 
                                  <br>四、if语句 
                                  <br>不要将布尔变量与任何值进行比较，那会很容易出错的。 
                                  <br>整形变量必须要有类型相同的值进行比较 
                                  <br>浮点变量最好少比点，就算要比也要有值进行限制 
                                  <br>指针变量要和NULL 进行比较，不要和布尔型和整形比较 
                                  <br>五、const和#define的比较 
                                  <br>const 有数据类型，#define 没有数据类型 
                                  <br>个别编译器中const 可以进行调试，#define 不可以进行调试 
                                  <br>在类中定义常量有两种方式 
                                  <br>1、在类在声明常量，但不赋值，在构造函数初始化表中进行赋值； 
                                  <br>2、用枚举代替const 常量。 
                                  <br>六、C++函数中值的传递方式 
                                  <br>有三种方式：值传递(Pass by value)、指针传递(Pass by pointer)、引用传递(Pass by 
                                  <br>reference) 
                                  <br>void fun(char c) //pass by value 
                                  <br>void fun(char *str) //pass by pointer 
                                  <br>void fun(char &amp;str) //pass by reference 
                                  <br>如果输入参数是以值传递的话，最好使用引用传递代替，因为引用传递省去了临 
                                  <br>时对象的构造和析构 
                                  <br>函数的类型不能省略，就算没有也要加个void 
                                  <br>七、函数体中的指针或引用常量不能被返回 
                                  <br>Char *func(void) 
                                  <br>{ 
                                  <br>char str[]=”Hello Word”; 
                                  <br>//这个是不能被返回的，因为str 是个指定变量，不是一般的值，函数结束后会被 
                                  <br>注销掉 
                                  <br>return str; 
                                  <br>} 
                                  <br>函数体内的指针变量并不会随着函数的消亡而自动释放 
                                  <br>八、一个内存拷贝函数的实现体 
                                  <br>void *memcpy(void *pvTo,const void *pvFrom,size_t size) 
                                  <br>{ 
                                  <br>assert((pvTo!=NULL)&amp;&amp;(pvFrom!=NULL)); 
                                  <br>byte *pbTo=(byte*)pvTo; //防止地址被改变 
                                  <br>byte *pbFrom=(byte*)pvFrom; 
                                  <br>while (size-- &gt;0) 
                                  <br>pbTo++ = pbForm++; 
                                  <br>return pvTo; 
                                  <br>} 
                                  <br>九、内存的分配方式 
                                  <br>分配方式有三种，请记住，说不定那天去面试的时候就会有人问你这问题 
                                  <br>1、静态存储区，是在程序编译时就已经分配好的，在整个运行期间都存在，如 
                                  <br>全局变量、常量。 
                                  <br>2、栈上分配，函数内的局部变量就是从这分配的，但分配的内存容易有限。 
                                  <br>3、堆上分配，也称动态分配，如我们用new,malloc 分配内存，用delete,free 来 
                                  <br>释放的内存。 
                                  <br>十、内存分配的注意事项 
                                  <br>用new 或malloc 分配内存时，必须要对此指针赋初值。 
                                  <br>用delete 或free 释放内存后，必须要将指针指向NULL 
                                  <br>不能修改指向常量的指针数据 
                                  <br>十一、内容复制与比较 
                                  <br>//数组…… 
                                  <br>char a[]=”Hello Word!”; 
                                  <br>char b[10]; 
                                  <br>strcpy(b,a); 
                                  <br>if (strcmp(a,b)==0) 
                                  <br>{} 
                                  <br>//指针…… 
                                  <br>char a[]=”Hello Word!”; 
                                  <br>char *p; 
                                  <br>p=new char[strlen(a)+1]; 
                                  <br>strcpy(p,a); 
                                  <br>if (strcmp(p,a)==0) 
                                  <br>{} 
                                  <br>十二、sizeof的问题 
                                  <br>记住一点，C++无法知道指针所指对象的大小，指针的大小永远为4 字节 
                                  <br>char a[]=”Hello World!” 
                                  <br>char *p=a; 
                                  <br>cout&lt; 
                                  
                                    &lt; 
                                   cout&lt; 
                                   
                                     &lt; 
                                    而且，在函数中，数组参数退化为指针，所以下面的内容永远输出为4 
                                    <br>void fun(char a[1000]) 
                                    <br>{ 
                                    <br>cout&lt; 
                                    
                                      &lt; 
                                     } 
                                     <br>十三、关于指针 
                                     <br>1、指针创建时必须被初始化 
                                     <br>2、指针在free 或delete 后必须置为NULL 
                                     <br>3、指针的长度都为4 字节 
                                     <br>４、释放内存时，如果是数组指针，必须要释放掉所有的内存，如 
                                     <br>char *p=new char[100]; 
                                     <br>strcpy(p,”Hello World”); 
                                     <br>delete []p; //注意前面的［］号 
                                     <br>p=NULL; 
                                     <br>５、数组指针的内容不能超过数组指针的最大容易。 
                                     <br>如: 
                                     <br>char *p=new char[5]; 
                                     <br>strcpy(p,”Hello World”); //报错目标容易不够大 
                                     <br>delete []p; //注意前面的［］号 
                                     <br>p=NULL; 
                                     <br>十四、关于malloc/free 和new /delete 
                                     <br> malloc/free 是C/C+的内存分配符，new /delete 是C++的内存分配符。 
                                     <br> 注意：malloc/free 是库函数，new/delete 是运算符 
                                     <br> malloc/free 不能执行构造函数与析构函数，而new/delete 可以 
                                     <br> new/delete 不能在C 上运行，所以malloc/free 不能被淘汰 
                                     <br> 两者都必须要成对使用 
                                     <br> C++中可以使用_set_new_hander 函数来定义内存分配异常的处理 
                                     <br>十五、Ｃ++的特性 
                                     <br>Ｃ++新增加有重载(overload)，内联（inline），Const，Virtual 四种机制 
                                     <br>重载和内联：即可用于全局函数，也可用于类的成员函数； 
                                     <br>Const 和Virtual：只可用于类的成员函数； 
                                     <br>重载：在同一类中，函数名相同的函数。由不同的参数决定调用那个函数。函数 
                                     <br>可要不可要Virtual 关键字。和全局函数同名的函数不叫重载。如果在类中调用 
                                     <br>同名的全局函数，必须用全局引用符号::引用。 
                                     <br>覆盖是指派生类函数覆盖基类函数 
                                     <br>函数名相同； 
                                     <br>参数相同； 
                                     <br>基类函数必须有Virtual 关键字； 
                                     <br>不同的范围(派生类和基类)。 
                                     <br>隐藏是指派生类屏蔽了基类的同名函数相同 
                                     <br>1、函数名相同，但参数不同，此时不论基类有无Virtual 关键字，基类函数 
                                     <br>将被隐藏。 
                                     <br>2、函数名相同，参数也相同，但基类无Virtual 关键字(有就是覆盖)，基类 
                                     <br>函数将被隐藏。 
                                     <br>内联：inline 关键字必须与定义体放在一起，而不是单单放在声明中。 
                                     <br>Const：const 是constant 的缩写，“恒定不变”的意思。被const 修饰的东西都 
                                     <br>受到强制保护，可以预防意外的变动，能提高程序的健壮性。 
                                     <br>1、参数做输入用的指针型参数，加上const 可防止被意外改动。 
                                     <br>2、按值引用的用户类型做输入参数时，最好将按值传递的改为引用传递， 
                                     <br>并加上const 关键字，目的是为了提高效率。数据类型为内部类型的就没 
                                     <br>必要做这件事情；如： 
                                     <br>将void Func(A a) 改为void Func(const A &amp;a)。 
                                     <br>而void func(int a)就没必要改成void func(const int &amp;a); 
                                     <br>3、给返回值为指针类型的函数加上const，会使函数返回值不能被修改，赋 
                                     <br>给的变量也只能是const 型变量。如：函数const char*GetString(void); char 
                                     <br>*str=GetString()将会出错。而const char *str=GetString()将是正确的。 
                                     <br>4、Const 成员函数是指此函数体内只能调用Const 成员变量，提高程序的键 
                                     <br>壮性。如声明函数int GetCount(void) const;此函数体内就只能调用Const 
                                     <br>成员变量。 
                                     <br>Virtual：虚函数：派生类可以覆盖掉的函数，纯虚函数：只是个空函数，没有函 
                                     <br>数实现体； 
                                     <br>十六、extern“C”有什么作用？ 
                                     <br>Extern “C”是由Ｃ＋＋提供的一个连接交换指定符号，用于告诉Ｃ＋＋这段 
                                     <br>代码是Ｃ函数。这是因为C++编译后库中函数名会变得很长，与C 生成的不一 
                                     <br>致，造成Ｃ＋＋不能直接调用C 函数，加上extren “c”后，C++就能直接调用C 
                                     <br>函数了。 
                                     <br>Extern “C”主要使用正规DLL 函数的引用和导出和在C++包含C 函数或C 
                                     <br>头文件时使用。使用时在前面加上extern “c” 关键字即可。 
                                     <br>十七、构造函数与析构函数 
                                     <br>派生类的构造函数应在初始化表里调用基类的构造函数； 
                                     <br>派生类和基类的析构函数应加Virtual 关键字。 
                                     <br>不要小看构造函数和析构函数，其实编起来还是不容易。 
                                     <br>#include 
                                      
                                      <br>class Base 
                                      <br>{ 
                                      <br>public: 
                                      <br>virtual ~Base() { cout&lt;&lt; "~Base" &lt;&lt; endl ; } 
                                      <br>}; 
                                      <br>class Derived : public Base 
                                      <br>{ 
                                      <br>public: 
                                      <br>virtual ~Derived() { cout&lt;&lt; "~Derived" &lt;&lt; endl ; } 
                                      <br>}; 
                                      <br>void main(void) 
                                      <br>{ 
                                      <br>Base * pB = new Derived; // upcast 
                                      <br>delete pB; 
                                      <br>} 
                                      <br>输出结果为： 
                                      <br>~Derived 
                                      <br>~Base 
                                      <br>如果析构函数不为虚，那么输出结果为 
                                      <br>~Base 
                                      <br>1．已知strcpy 函数的原型是： 
                                      <br>char *strcpy(char *strDest, const char *strSrc); 
                                      <br>其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数strcp 
                                      <br>y 
                                      <br>答案： 
                                      <br>char *strcpy(char *strDest, const char *strSrc) 
                                      <br>{ 
                                      <br>if ( strDest == NULL || strSrc == NULL) 
                                      <br>return NULL ; 
                                      <br>if ( strDest == strSrc) 
                                      <br>return strDest ; 
                                      <br>char *tempptr = strDest ; 
                                      <br>while( (*strDest++ = *strSrc++) != '’) 
                                      <br>; 
                                      <br>return tempptr ; 
                                      <br>} 
                                      <br>2．已知类String 的原型为： 
                                      <br>class String 
                                      <br>{ 
                                      <br>public: 
                                      <br>String(const char *str = NULL); // 普通构造函数 
                                      <br>String(const String &amp;other); // 拷贝构造函数 
                                      <br>~ String(void); // 析构函数 
                                      <br>String &amp; operate =(const String &amp;other); // 赋值函数 
                                      <br>private: 
                                      <br>char *m_data; // 用于保存字符串 
                                      <br>}; 
                                      <br>请编写String 的上述4 个函数。 
                                      <br>答案： 
                                      <br>String::String(const char *str) 
                                      <br>{ 
                                      <br>if ( str == NULL ) //strlen 在参数为NULL 时会抛异常才会有这步判断 
                                      <br>{ 
                                      <br>m_data = new char[1] ; 
                                      <br>m_data[0] = '' ; 
                                      <br>} 
                                      <br>else 
                                      <br>{ 
                                      <br>m_data = new char[strlen(str) + 1]; 
                                      <br>strcpy(m_data,str); 
                                      <br>} 
                                      <br>} 
                                      <br>String::String(const String &amp;other) 
                                      <br>{ 
                                      <br>m_data = new char[strlen(other.m_data) + 1]; 
                                      <br>strcpy(m_data,other.m_data); 
                                      <br>} 
                                      <br>String &amp; String::operator =(const String &amp;other) 
                                      <br>{ 
                                      <br>if ( this == &amp;other) 
                                      <br>return *this ; 
                                      <br>delete []m_data; 
                                      <br>m_data = new char[strlen(other.m_data) + 1]; 
                                      <br>strcpy(m_data,other.m_data); 
                                      <br>return *this ; 
                                      <br>} 
                                      <br>String::~ String(void) 
                                      <br>{ 
                                      <br>delete []m_data ; 
                                      <br>} 
                                      <br>3.简答 
                                      <br>3.1 头文件中的ifndef/define/endif 干什么用？ 
                                      <br>答：防止该头文件被重复引用。 
                                      <br>3.2＃i nclude 和＃i nclude “filename.h” 有什么区别？ 
                                      <br>答：对于＃i nclude ，编译器从标准库路径开始搜索filename.h 
                                      <br>对于＃i nclude “filename.h”，编译器从用户的工作路径开始搜索filename.h 
                                      <br>4. static 有什么用途？（请至少说明两种） 
                                      <br>1.限制变量的作用域 
                                      <br>2.设置变量的存储域 
                                      <br>7. 引用与指针有什么区别？ 
                                      <br>1) 引用必须被初始化，指针不必。 
                                      <br>2) 引用初始化以后不能被改变，指针可以改变所指的对象。 
                                      <br>2) 不存在指向空值的引用，但是存在指向空值的指针。 
                                      <br>8. 描述实时系统的基本特性 
                                      <br>在特定时间内完成特定的任务，实时性与可靠性 
                                      <br>9. 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？ 
                                      <br>全局变量储存在静态数据库，局部变量在堆栈 
                                      <br>10. 什么是平衡二叉树？ 
                                      <br>左右子树都是平衡二叉树且左右子树的深度差值的绝对值不大于1 
                                      <br>11. 堆栈溢出一般是由什么原因导致的？ 
                                      <br>没有回收垃圾资源 
                                      <br>12. 什么函数不能声明为虚函数？ 
                                      <br>constructor 
                                      <br>13. 冒泡排序算法的时间复杂度是什么？ 
                                      <br>O(n^2) 
                                      <br>14. 写出float x 与“零值”比较的if 语句。 
                                      <br>if(x&gt;0.000001&amp;&amp;x&lt;-0.000001) 
                                      <br>16. Internet 采用哪种网络协议？该协议的主要层次结构？ 
                                      <br>tcp/ip 应用层/传输层/网络层/数据链路层/物理层 
                                      <br>17. Internet 物理地址和IP 地址转换采用什么协议？ 
                                      <br>ARP (Address Resolution Protocol)（地址解析協議） 
                                      <br>18.IP 地址的编码分为哪俩部分？ 
                                      <br>IP 地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些 
                                      <br>是网络位哪些是主机位。 
                                      <br>2.用户输入M,N 值，从1 至N 开始顺序循环数数，每数到M 输出该数值，直至全部输出。 
                                      <br>写出C 程序。 
                                      <br>循环链表，用取余操作做 
                                      <br>3.不能做switch()的参数类型是： 
                                      <br>switch 的参数不能为实型。 
                                      <br>華為 
                                      <br>1、局部变量能否和全局变量重名？ 
                                      <br>答：能，局部会屏蔽全局。要用全局变量，需要使用"::" 
                                      <br>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会 
                                      <br>用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如 
                                      <br>在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内 
                                      <br>2、如何引用一个已经定义过的全局变量？ 
                                      <br>答：extern 
                                      <br>可以用引用头文件的方式，也可以用extern 关键字，如果用引用头文件方式来引用某个在 
                                      <br>头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern 
                                      <br>方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错 
                                      <br>3、全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？ 
                                      <br>答：可以，在不同的C 文件中以static 形式来声明同名全局变量。 
                                      <br>可以在不同的C 文件中声明同名的全局变量，前提是其中只能有一个C 文件中对此变量赋 
                                      <br>初值，此时连接不会出错 
                                      <br>4、语句for( ；1 ；)有什么问题？它是什么意思？ 
                                      <br>答：和while(1)相同。 
                                      <br>5、do……while 和while……do 有什么区别？ 
                                      <br>答：前一个循环一遍再判断，后一个判断以后再循环 
                                      <br>6、请写出下列代码的输出内容 
                                      <br>#include 
                                       
                                       <br>main() 
                                       <br>{ 
                                       <br>int a,b,c,d; 
                                       <br>a=10; 
                                       <br>b=a++; 
                                       <br>c=++a; 
                                       <br>d=10*a++; 
                                       <br>printf("b，c，d：%d，%d，%d"，b，c，d）; 
                                       <br>return 0; 
                                       <br>} 
                                       <br>答：10，12，120 
                                       <br>1、static 全局变量与普通的全局变量有什么区别？static 局部变量和普通局部变量有什么区 
                                       <br>别？static 函数与普通函数有什么区别？ 
                                       <br>全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是 
                                       <br>静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这 
                                       <br>两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组 
                                       <br>成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域， 
                                       <br>即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态 
                                       <br>全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在 
                                       <br>其它源文件中引起错误。 
                                       <br>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的 
                                       <br>生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。 
                                       <br>static 函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为 
                                       <br>内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用 
                                       <br>的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 
                                       <br>static 全局变量与普通的全局变量有什么区别：static 全局变量只初使化一次，防止在其他 
                                       <br>文件单元中被引用; 
                                       <br>static 局部变量和普通局部变量有什么区别：static 局部变量只被初始化一次，下一次依据 
                                       <br>上一次结果值； 
                                       <br>static 函数与普通函数有什么区别：static 函数在内存中只有一份，普通函数在每个被调用 
                                       <br>中维持一份拷贝 
                                       <br>2、程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存 
                                       <br>在于（ 堆）中。 
                                       <br>3、设有以下说明和定义： 
                                       <br>typedef union {long i; int k[5]; char c;} DATE; 
                                       <br>struct data { int cat; DATE cow; double dog;} too; 
                                       <br>DATE max; 
                                       <br>则语句printf("%d",sizeof(struct date)+sizeof(max));的执行结果是：___52____ 
                                       <br>答：DATE 是一个union, 变量公用空间. 里面最大的变量类型是int[5], 占用20 个字节. 所 
                                       <br>以它的大小是20 
                                       <br>data 是一个struct, 每个变量分开占用空间. 依次为int4 + DATE20 + double8 = 32. 
                                       <br>所以结果是20 + 32 = 52. 
                                       <br>当然...在某些16 位编辑器下, int 可能是2 字节,那么结果是int2 + DATE10 + double8 = 20 
                                       <br>4、队列和栈有什么区别？ 
                                       <br>队列先进先出，栈后进先出 
                                       <br>5、写出下列代码的输出内容 
                                       <br>#include 
                                        
                                        <br>int inc(int a) 
                                        <br>{ 
                                        <br>return(++a); 
                                        <br>} 
                                        <br>int multi(int*a,int*b,int*c) 
                                        <br>{ 
                                        <br>return(*c=*a**b); 
                                        <br>} 
                                        <br>typedef int(FUNC1)(int in); 
                                        <br>typedef int(FUNC2) (int*,int*,int*); 
                                        <br>void show(FUNC2 fun,int arg1, int*arg2) 
                                        <br>{ 
                                        <br>INCp=&amp;inc; 
                                        <br>int temp =p(arg1); 
                                        <br>fun(&amp;temp,&amp;arg1, arg2); 
                                        <br>printf("%d/n",*arg2); 
                                        <br>} 
                                        <br>main() 
                                        <br>{ 
                                        <br>int a; 
                                        <br>show(multi,10,&amp;a); 
                                        <br>return 0; 
                                        <br>} 
                                        <br>答：110 
                                        <br>7、请找出下面代码中的所以错误 
                                        <br>说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba” 
                                        <br>1、#include"string.h" 
                                        <br>2、main() 
                                        <br>3、{ 
                                        <br>4、char*src="hello,world"; 
                                        <br>5、char* dest=NULL; 
                                        <br>6、int len=strlen(src); 
                                        <br>7、dest=(char*)malloc(len); 
                                        <br>8、char* d=dest; 
                                        <br>9、char* s=src[len]; 
                                        <br>10、while(len--!=0) 
                                        <br>11、d++=s--; 
                                        <br>12、printf("%s",dest); 
                                        <br>13、return 0; 
                                        <br>14、} 
                                        <br>答： 
                                        <br>方法1： 
                                        <br>int main(){ 
                                        <br>char* src = "hello,world"; 
                                        <br>int len = strlen(src); 
                                        <br>char* dest = (char*)malloc(len+1);//要为/0 分配一个空间 
                                        <br>char* d = dest; 
                                        <br>char* s = &amp;src[len-1];//指向最后一个字符 
                                        <br>while( len-- != 0 ) 
                                        <br>*d++=*s--; 
                                        <br>*d = 0;//尾部要加/0 
                                        <br>printf("%s/n",dest); 
                                        <br>free(dest);// 使用完，应当释放空间，以免造成内存汇泄露 
                                        <br>return 0; 
                                        <br>} 
                                        <br>方法2： 
                                        <br>#include 
                                         
                                         <br>#include 
                                          
                                          <br>main() 
                                          <br>{ 
                                          <br>char str[]="hello,world"; 
                                          <br>int len=strlen(str); 
                                          <br>char t; 
                                          <br>for(int i=0; i 
                                          { 
                                          <br>t=str[i]; 
                                          <br>str[i]=str[len-i-1]; str[len-i-1]=t; 
                                          <br>} 
                                          <br>printf("%s",str); 
                                          <br>return 0; 
                                          <br>} 
                                          <br>1.-1,2,7,28,,126 请问28 和126 中间那个数是什么？为什么？ 
                                          <br>第一题的答案应该是4^3-1=63 
                                          <br>规律是n^3-1(当n 为偶数0，2，4) 
                                          <br>n^3+1(当n 为奇数1，3，5) 
                                          <br>答案：63 
                                          <br>2.用两个栈实现一个队列的功能？要求给出算法和思路！ 
                                          <br>设2 个栈为A,B, 一开始均为空. 
                                          <br>入队: 
                                          <br>将新元素push 入栈A; 
                                          <br>出队: 
                                          <br>(1)判断栈B 是否为空； 
                                          <br>(2)如果不为空，则将栈A 中所有元素依次pop 出并push 到栈B； 
                                          <br>(3)将栈B 的栈顶元素pop 出； 
                                          <br>这样实现的队列入队和出队的平摊复杂度都还是O(1), 比上面的几种方法要好。3.在c 语言 
                                          <br>库函数中将一个字符转换成整型的函数是atool()吗，这个函数的原型是什么？ 
                                          <br>函数名: atol 
                                          <br>功能: 把字符串转换成长整型数 
                                          <br>用法: long atol(const char *nptr); 
                                          <br>程序例: 
                                          <br>#include 
                                           
                                           <br>#include 
                                            
                                            <br>int main(void) 
                                            <br>{ 
                                            <br>long l; 
                                            <br>char *str = "98765432"; 
                                            <br>l = atol(lstr); 
                                            <br>printf("string = %s integer = %ld/n", str, l); 
                                            <br>return(0); 
                                            <br>} 
                                            <br>2.对于一个频繁使用的短小函数,在C 语言中应用什么实现,在C++中应用什么实现? 
                                            <br>c 用宏定义，c++用inline 
                                            <br>3.直接链接两个信令点的一组链路称作什么? 
                                            <br>PPP 点到点连接 
                                            <br>4.接入网用的是什么接口? 
                                            <br>5.voip 都用了那些协议? 
                                            <br>6.软件测试都有那些种类? 
                                            <br>黑盒：针对系统功能的测试白合：测试函数功能，各函数接口 
                                            <br>7.确定模块的功能和模块的接口是在软件设计的那个队段完成的? 
                                            <br>概要设计阶段 
                                            <br>8.enum string 
                                            <br>{ 
                                            <br>x1, 
                                            <br>x2, 
                                            <br>x3=10, 
                                            <br>x4, 
                                            <br>x5, 
                                            <br>}x; 
                                            <br>问x= 0x801005，0x8010f4 ; 
                                            <br>9.unsigned char *p1; 
                                            <br>unsigned long *p2; 
                                            <br>p1=(unsigned char *)0x801000; 
                                            <br>p2=(unsigned long *)0x810000; 
                                            <br>请问p1+5= ; 
                                            <br>p2+5= ; 
                                            <br>三.选择题: 
                                            <br>1.Ethternet 链接到Internet 用到以下那个协议? 
                                            <br>A.HDLC;B.ARP;C.UDP;D.TCP;E.ID 
                                            <br>2.属于网络层协议的是: 
                                            <br>A.TCP;B.IP;C.ICMP;D.X.25 
                                            <br>3.Windows 消息调度机制是: 
                                            <br>A.指令队列;B.指令堆栈;C.消息队列;D.消息堆栈; 
                                            <br>4.unsigned short hash(unsigned short key) 
                                            <br>{ 
                                            <br>return (key&gt;&gt;)%256 
                                            <br>} 
                                            <br>请问hash(16),hash(256)的值分别是: 
                                            <br>A.1.16;B.8.32;C.4.16;D.1.32 
                                            <br>四.找错题: 
                                            <br>1.请问下面程序有什么错误? 
                                            <br>int a[60][250][1000],i,j,k; 
                                            <br>for(k=0;k&lt;=1000;k++) 
                                            <br>for(j=0;j&lt;250;j++) 
                                            <br>for(i=0;i&lt;60;i++) 
                                            <br>a[i][j][k]=0; 
                                            <br>把循环语句内外换一下 
                                            <br>2.#define Max_CB 500 
                                            <br>void LmiQueryCSmd(Struct MSgCB * pmsg) 
                                            <br>{ 
                                            <br>unsigned char ucCmdNum; 
                                            <br>...... 
                                            <br>for(ucCmdNum=0;ucCmdNum 
                                             
                                             <br>{ 
                                             <br>......; 
                                             <br>} 
                                             <br>死循环 
                                             <br>3.以下是求一个数的平方的程序,请找出错误: 
                                             <br>#define SQUARE(a)((a)*(a)) 
                                             <br>int a=5; 
                                             <br>int b; 
                                             <br>b=SQUARE(a++); 
                                             <br>4.typedef unsigned char BYTE 
                                             <br>int examply_fun(BYTE gt_len; BYTE *gt_code) 
                                             <br>{ 
                                             <br>BYTE *gt_buf; 
                                             <br>gt_buf=(BYTE *)MALLOC(Max_GT_Length); 
                                             <br>...... 
                                             <br>if(gt_len&gt;Max_GT_Length) 
                                             <br>{ 
                                             <br>return GT_Length_ERROR; 
                                             <br>} 
                                             <br>....... 
                                             <br>} 
                                             <br>五.问答题: 
                                             <br>1.IP Phone 的原理是什么? 
                                             <br>IPV6 
                                             <br>2.TCP/IP 通信建立的过程怎样，端口有什么作用？ 
                                             <br>三次握手，确定是哪个应用程序使用该协议 
                                             <br>3.1 号信令和7 号信令有什么区别，我国某前广泛使用的是那一种？ 
                                             <br>4.列举5 种以上的电话新业务？ 
                                             <br>微软亚洲技术中心的面试题！！！ 
                                             <br>1．进程和线程的差别。 
                                             <br>线程是指进程内的一个执行单元,也是进程内的可调度实体. 
                                             <br>与进程的区别: 
                                             <br>(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 
                                             <br>(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 
                                             <br>(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于 
                                             <br>进程的资源. 
                                             <br>(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销 
                                             <br>明显大于创建或撤消线程时的开销。 
                                             <br>2.测试方法 
                                             <br>人工测试：个人复查、抽查和会审 
                                             <br>机器测试：黑盒测试和白盒测试 
                                             <br>2．Heap 与stack 的差别。 
                                             <br>Heap 是堆，stack 是栈。 
                                             <br>Stack 的空间由操作系统自动分配/释放，Heap 上的空间手动分配/释放。 
                                             <br>Stack 空间有限，Heap 是很大的自由存储区 
                                             <br>C 中的malloc 函数分配的内存空间即在堆上,C++中对应的是new 操作符。 
                                             <br>程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传 
                                             <br>递也在栈上进行 
                                             <br>3．Windows 下的内存是如何管理的？ 
                                             <br>4．介绍.Net 和.Net 的安全性。 
                                             <br>5．客户端如何访问.Net 组件实现Web Service？ 
                                             <br>6．C/C++编译器中虚表是如何完成的？ 
                                             <br>7．谈谈COM 的线程模型。然后讨论进程内/外组件的差别。 
                                             <br>8．谈谈IA32 下的分页机制 
                                             <br>小页(4K)两级分页模式，大页(4M)一级 
                                             <br>9．给两个变量，如何找出一个带环单链表中是什么地方出现环的？ 
                                             <br>一个递增一，一个递增二，他们指向同一个接点时就是环出现的地方 
                                             <br>10．在IA32 中一共有多少种办法从用户态跳到内核态？ 
                                             <br>通过调用门，从ring3 到ring0，中断从ring3 到ring0，进入vm86 等等 
                                             <br>11．如果只想让程序有一个实例运行，不能运行两个。像winamp 一样，只能开一个窗口， 
                                             <br>怎样实现？ 
                                             <br>用内存映射或全局原子（互斥变量）、查找窗口句柄.. 
                                             <br>FindWindow，互斥，写标志到文件或注册表,共享内存。. 
                                             <br>12．如何截取键盘的响应，让所有的'a’变成'b’？ 
                                             <br>键盘钩子SetWindowsHookEx 
                                             <br>13．Apartment 在COM 中有什么用？为什么要引入？ 
                                             <br>14．存储过程是什么？有什么用？有什么优点？ 
                                             <br>我的理解就是一堆sql 的集合，可以建立非常复杂的查询，编译运行，所以运行一次后，以 
                                             <br>后再运行速度比单独执行SQL 快很多 
                                             <br>15．Template 有什么特点？什么时候用？ 
                                             <br>16．谈谈Windows DNA 结构的特点和优点。 
                                             <br>网络编程中设计并发服务器，使用多进程与多线程，请问有什么区别？ 
                                             <br>1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。 
                                             <br>2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他 
                                             <br>线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 
                                             <br>两者都可以提高程序的并发度，提高程序运行效率和响应时间。 
                                             <br>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相 
                                             <br>反。同时，线程适合于在SMP 机器上运行，而进程则可以跨机器迁移。 
                                             <br>思科 
                                             <br>1. 用宏定义写出swap（x，y） 
                                             <br>#define swap(x, y)/ 
                                             <br>x = x + y;/ 
                                             <br>y = x - y;/ 
                                             <br>x = x - y; 
                                             <br>2.数组a[N]，存放了1 至N-1 个数，其中某个数重复一次。写一个函数，找出被重复的数 
                                             <br>字.时间复杂度必须为o（N）函数原型： 
                                             <br>int do_dup(int a[],int N) 
                                             <br>3 一语句实现x 是否为2 的若干次幂的判断 
                                             <br>int i = 512; 
                                             <br>cout &lt;&lt; boolalpha &lt;&lt; ((i &amp; (i - 1)) ? false : true) &lt;&lt; endl; 
                                             <br>4.unsigned int intvert(unsigned int x,int p,int n)实现对x 的进行转换,p 为起始转化位,n 为需 
                                             <br>要转换的长度,假设起始点在右边.如x=0b0001 0001,p=4,n=3 转换后x=0b0110 0001 
                                             <br>unsigned int intvert(unsigned int x,int p,int n){ 
                                             <br>unsigned int _t = 0; 
                                             <br>unsigned int _a = 1; 
                                             <br>for(int i = 0; i &lt; n; ++i){ 
                                             <br>_t |= _a; 
                                             <br>_a = _a &lt;&lt; 1; 
                                             <br>} 
                                             <br>_t = _t &lt;&lt; p; 
                                             <br>x ^= _t; 
                                             <br>return x; 
                                             <br>} 
                                             <br>慧通： 
                                             <br>什么是预编译 
                                             <br>何时需要预编译： 
                                             <br>１、总是使用不经常改动的大型代码体。 
                                             <br>２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种 
                                             <br>情况下，可以将所有包含文件预编译为一个预编译头。 
                                             <br>char * const p; 
                                             <br>char const * p 
                                             <br>const char *p 
                                             <br>上述三个有什么区别？ 
                                             <br>char * const p; //常量指针，p 的值不可以修改 
                                             <br>char const * p；//指向常量的指针，指向的常量值不可以改 
                                             <br>const char *p； //和char const *p 
                                             <br>char str1[] = "abc"; 
                                             <br>char str2[] = "abc"; 
                                             <br>const char str3[] = "abc"; 
                                             <br>const char str4[] = "abc"; 
                                             <br>const char *str5 = "abc"; 
                                             <br>const char *str6 = "abc"; 
                                             <br>char *str7 = "abc"; 
                                             <br>char *str8 = "abc"; 
                                             <br>cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl; 
                                             <br>cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl; 
                                             <br>cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl; 
                                             <br>cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl; 
                                             <br>结果是：0 0 1 1 
                                             <br>解答：str1,str2,str3,str4 是数组变量，它们有各自的内存空间； 
                                             <br>而str5,str6,str7,str8 是指针，它们指向相同的常量区域。 
                                             <br>12. 以下代码中的两个sizeof 用法有问题吗？[C 易] 
                                             <br>void UpperCase( char str[] ) // 将str 中的小写字母转换成大写字母 
                                             <br>{ 
                                             <br>for( size_t i=0; i 
                                             if( 'a'&lt;=str[i] &amp;&amp; str[i]&lt;='z' ) 
                                             <br>str[i] -= ('a'-'A' ); 
                                             <br>} 
                                             <br>char str[] = "aBcDe"; 
                                             <br>cout &lt;&lt; "str 字符长度为: " &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl; 
                                             <br>UpperCase( str ); 
                                             <br>cout &lt;&lt; str &lt;&lt; endl; 
                                             <br>答：函数内的sizeof 有问题。根据语法，sizeof 如用于数组，只能测出静态数组的大小，无 
                                             <br>法检测动态分配的或外部数组大小。函数外的str 是一个静态定义的数组，因此其大小为6， 
                                             <br>函数内的str 实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此 
                                             <br>sizeof 作用于上只将其当指针看，一个指针为4 个字节，因此返回4。 
                                             <br>一个32 位的机器,该机器的指针是多少位 
                                             <br>指针是多少位只要看地址总线的位数就行了。80386 以后的机子都是32 的数据总线。所以 
                                             <br>指针的位数就是4 个字节了。 
                                             <br>main() 
                                             <br>{ 
                                             <br>int a[5]={1,2,3,4,5}; 
                                             <br>int *ptr=(int *)(&amp;a+1); 
                                             <br>printf("%d,%d",*(a+1),*(ptr-1)); 
                                             <br>} 
                                             <br>输出：2,5 
                                             <br>*(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5 
                                             <br>&amp;a+1 不是首地址+1，系统会认为加一个a 数组的偏移，是偏移了一个数组的大小（本例是 
                                             <br>5 个int） 
                                             <br>int *ptr=(int *)(&amp;a+1); 
                                             <br>则ptr 实际是&amp;(a[5]),也就是a+5 
                                             <br>原因如下： 
                                             <br>&amp;a 是数组指针，其类型为int (*)[5]; 
                                             <br>而指针加1 要根据指针类型加上一定的值， 
                                             <br>不同类型的指针+1 之后增加的大小不同 
                                             <br>a 是长度为5 的int 数组指针，所以要加5*sizeof(int) 
                                             <br>所以ptr 实际是a[5] 
                                             <br>但是prt 与(&amp;a+1)类型是不一样的(这点很重要) 
                                             <br>所以prt-1 只会减去sizeof(int*) 
                                             <br>a,&amp;a 的地址是一样的，但意思不一样，a 是数组首地址，也就是a[0]的地址，&amp;a 是对象（数 
                                             <br>组）首地址，a+1 是数组下一元素的地址，即a[1],&amp;a+1 是下一个对象的地址，即a[5]. 
                                             <br>1.请问以下代码有什么问题： 
                                             <br>int main() 
                                             <br>{ 
                                             <br>char a; 
                                             <br>char *str=&amp;a; 
                                             <br>strcpy(str,"hello"); 
                                             <br>printf(str); 
                                             <br>return 0; 
                                             <br>} 
                                             <br>没有为str 分配内存空间，将会发生异常 
                                             <br>问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为 
                                             <br>越界进行内在读写而导致程序崩溃。 
                                             <br>char* s="AAA"; 
                                             <br>printf("%s",s); 
                                             <br>s[0]='B'; 
                                             <br>printf("%s",s); 
                                             <br>有什么错？ 
                                             <br>"AAA"是字符串常量。s 是指针，指向这个字符串常量，所以声明s 的时候就有问题。 
                                             <br>cosnt char* s="AAA"; 
                                             <br>然后又因为是常量，所以对是s[0]的赋值操作是不合法的。 
                                             <br>1、写一个“标准”宏，这个宏输入两个参数并返回较小的一个。 
                                             <br>.#define Min(X, Y) ((X)&gt;(Y)?(Y):(X))//结尾没有; 
                                             <br>2、嵌入式系统中经常要用到无限循环，你怎么用C 编写死循环。 
                                             <br>while(1){}或者for(;;) 
                                             <br>3、关键字static 的作用是什么？ 
                                             <br>定义静态变量 
                                             <br>4、关键字const 有什么含意？ 
                                             <br>表示常量不可以修改的变量。 
                                             <br>5、关键字volatile 有什么含意？并举出三个不同的例子？ 
                                             <br>提示编译器对象的值可能在编译器未监测到的情况下改变。 
                                             <br>int (*s[10])(int) 表示的是什么啊 
                                             <br>int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 
                                             <br>1.有以下表达式： 
                                             <br>int a=248; b=4;int const c=21;const int *d=&amp;a; 
                                             <br>int *const e=&amp;b;int const *f const =&amp;a; 
                                             <br>请问下列表达式哪些会被编译器禁止？为什么？ 
                                             <br>*c=32;d=&amp;b;*d=43;e=34;e=&amp;a;f=0x321f; 
                                             <br>*c 这是个什么东东，禁止 
                                             <br>*d 说了是const， 禁止 
                                             <br>e = &amp;a 说了是const 禁止 
                                             <br>const *f const =&amp;a; 禁止 
                                             <br>2.交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3; 
                                             <br>有两种解法, 一种用算术算法, 一种用^(异或) 
                                             <br>a = a + b; 
                                             <br>b = a - b; 
                                             <br>a = a - b; 
                                             <br>or 
                                             <br>a = a^b;// 只能对int,char.. 
                                             <br>b = a^b; 
                                             <br>a = a^b; 
                                             <br>or 
                                             <br>a ^= b ^= a; 
                                             <br>3.c 和c++中的struct 有什么不同？ 
                                             <br>c 和c++中struct 的主要区别是c 中的struct 不可以含有成员函数，而c++中的struct 可以。 
                                             <br>c++中struct 和class 的主要区别在于默认的存取权限不同，struct 默认为public，而class 
                                             <br>默认为private 
                                             <br>4.#include 
                                              
                                              <br>#include 
                                               
                                               <br>void getmemory(char *p) 
                                               <br>{ 
                                               <br>p=(char *) malloc(100); 
                                               <br>strcpy(p,"hello world"); 
                                               <br>} 
                                               <br>int main( ) 
                                               <br>{ 
                                               <br>char *str=NULL; 
                                               <br>getmemory(str); 
                                               <br>printf("%s/n",str); 
                                               <br>free(str); 
                                               <br>return 0; 
                                               <br>} 
                                               <br>程序崩溃，getmemory 中的malloc 不能返回动态内存， free（）对str 操作很危险 
                                               <br>5.char szstr[10]; 
                                               <br>strcpy(szstr,"0123456789"); 
                                               <br>产生什么结果？为什么？ 
                                               <br>长度不一样，会造成非法的OS 
                                               <br>6.列举几种进程的同步机制，并比较其优缺点。 
                                               <br>原子操作 
                                               <br>信号量机制 
                                               <br>自旋锁 
                                               <br>管程，会合，分布式系统 
                                               <br>7.进程之间通信的途径 
                                               <br>共享存储系统 
                                               <br>消息传递系统 
                                               <br>管道：以文件系统为基础 
                                               <br>11.进程死锁的原因 
                                               <br>资源竞争及进程推进顺序非法 
                                               <br>12.死锁的4 个必要条件 
                                               <br>互斥、请求保持、不可剥夺、环路 
                                               <br>13.死锁的处理 
                                               <br>鸵鸟策略、预防策略、避免策略、检测与解除死锁 
                                               <br>15. 操作系统中进程调度策略有哪几种？ 
                                               <br>FCFS(先来先服务)，优先级，时间片轮转，多级反馈 
                                               <br>8.类的静态成员和非静态成员有何区别？ 
                                               <br>类的静态成员每个类只有一个，非静态成员每个对象一个 
                                               <br>9.纯虚函数如何定义？使用时应注意什么？ 
                                               <br>virtual void f()=0; 
                                               <br>是接口，子类必须要实现 
                                               <br>10.数组和链表的区别 
                                               <br>数组：数据顺序存储，固定大小 
                                               <br>连表：数据可以随机存储，大小可动态改变 
                                               <br>12.ISO 的七层模型是什么？tcp/udp 是属于哪一层？tcp/udp 有何优缺点？ 
                                               <br>应用层 
                                               <br>表示层 
                                               <br>会话层 
                                               <br>运输层 
                                               <br>网络层 
                                               <br>物理链路层 
                                               <br>物理层 
                                               <br>tcp /udp 属于运输层 
                                               <br>TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。 
                                               <br>与TCP 不同， UDP 并不提供对IP 协议的可靠机制、流控制以及错误恢复功能等。由 
                                               <br>于UDP 比较简单， UDP 头包含很少的字节，比TCP 负载消耗少。 
                                               <br>tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 
                                               <br>udp: 不提供稳定的服务，包头小，开销小 
                                               <br>1：(void *)ptr 和(*(void**))ptr 的结果是否相同？其中ptr 为同一个指针 
                                               <br>.(void *)ptr 和(*(void**))ptr 值是相同的 
                                               <br>2：int main() 
                                               <br>{ 
                                               <br>int x=3; 
                                               <br>printf("%d",x); 
                                               <br>return 1; 
                                               <br>} 
                                               <br>问函数既然不会被其它函数调用，为什么要返回1？ 
                                               <br>mian 中，c 标准认为0 表示成功，非0 表示错误。具体的值是某中具体出错信息 
                                               <br>1，要对绝对地址0x100000 赋值，我们可以用 
                                               <br>(unsigned int*)0x100000 = 1234; 
                                               <br>那么要是想让程序跳转到绝对地址是0x100000 去执行，应该怎么做？ 
                                               <br>*((void (*)( ))0x100000 ) ( ); 
                                               <br>首先要将0x100000 强制转换成函数指针,即: 
                                               <br>(void (*)())0x100000 
                                               <br>然后再调用它: 
                                               <br>*((void (*)())0x100000)(); 
                                               <br>用typedef 可以看得更直观些: 
                                               <br>typedef void(*)() voidFuncPtr; 
                                               <br>*((voidFuncPtr)0x100000)(); 
                                               <br>2，已知一个数组table，用一个宏定义，求出数据的元素个数 
                                               <br>#define NTBL 
                                               <br>#define NTBL (sizeof(table)/sizeof(table[0])) 
                                               <br>面试题: 线程与进程的区别和联系? 线程是否具有相同的堆栈? dll 是否有独立的堆栈? 
                                               <br>进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操 
                                               <br>作系统就帮你创建了一个主线程。 
                                               <br>每个线程有自己的堆栈。 
                                               <br>DLL 中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL 
                                               <br>中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL 中的代码是EXE 中的线程所 
                                               <br>调用，那么这个时候是不是说这个DLL 没有自己独立的堆栈？如果DLL 中的代码是由DLL 
                                               <br>自己创建的线程所执行，那么是不是说DLL 有独立的堆栈？ 
                                               <br>以上讲的是堆栈，如果对于堆来说，每个DLL 有自己的堆，所以如果是从DLL 中动态分配 
                                               <br>的内存，最好是从DLL 中删除，如果你从DLL 中分配内存，然后在EXE 中，或者另外一 
                                               <br>个DLL 中删除，很有可能导致程序崩溃 
                                               <br>unsigned short A = 10; 
                                               <br>printf("~A = %u/n", ~A); 
                                               <br>char c=128; 
                                               <br>printf("c=%d/n",c); 
                                               <br>输出多少？并分析过程 
                                               <br>第一题，～A ＝0xfffffff5,int 值为－11，但输出的是uint。所以输出4294967285 
                                               <br>第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00 的补码就是128， 
                                               <br>所以输出－128。 
                                               <br>这两道题都是在考察二进制向int 或uint 转换时的最高位处理。 
                                               <br>分析下面的程序： 
                                               <br>void GetMemory(char **p,int num) 
                                               <br>{ 
                                               <br>*p=(char *)malloc(num); 
                                               <br>} 
                                               <br>int main() 
                                               <br>{ 
                                               <br>char *str=NULL; 
                                               <br>GetMemory(&amp;str,100); 
                                               <br>strcpy(str,"hello"); 
                                               <br>free(str); 
                                               <br>if(str!=NULL) 
                                               <br>{ 
                                               <br>strcpy(str,"world"); 
                                               <br>} 
                                               <br>printf("/n str is %s",str); 
                                               <br>getchar(); 
                                               <br>} 
                                               <br>问输出结果是什么？希望大家能说说原因，先谢谢了 
                                               <br>输出str is world。 
                                               <br>free 只是释放的str 指向的内存空间,它本身的值还是存在的. 
                                               <br>所以free 之后，有一个好的习惯就是将str=NULL. 
                                               <br>此时str 指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储 
                                               <br>空间是可能被重新分配给其他变量的, 
                                               <br>尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出 
                                               <br>world 来。 
                                               <br>这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。 
                                               <br>当你malloc 一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些）， 
                                               <br>然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的 
                                               <br>地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继 
                                               <br>续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。 
                                               <br>char a[10],strlen(a)为什么等于15？运行的结果 
                                               <br>#include "stdio.h" 
                                               <br>#include "string.h" 
                                               <br>void main() 
                                               <br>{ 
                                               <br>char aa[10]; 
                                               <br>printf("%d",strlen(aa)); 
                                               <br>} 
                                               <br>sizeof()和初不初始化，没有关系； 
                                               <br>strlen()和初始化有关。 
                                               <br>char (*str)[20];/*str 是一个数组指针，即指向数组的指针．*/ 
                                               <br>char *str[20];/*str 是一个指针数组，其元素为指针型数据．*/ 
                                               <br>long a=0x801010; 
                                               <br>a+5=? 
                                               <br>0x801010 用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720， 
                                               <br>再加上5 就是8392725 罗 
                                               <br>1)给定结构struct A 
                                               <br>{ 
                                               <br>char t:4; 
                                               <br>char k:4; 
                                               <br>unsigned short i:8; 
                                               <br>unsigned long m; 
                                               <br>};问sizeof(A) = ? 
                                               <br>给定结构struct A 
                                               <br>{ 
                                               <br>char t:4; 4 位 
                                               <br>char k:4; 4 位 
                                               <br>unsigned short i:8; 8 位 
                                               <br>unsigned long m; // 偏移2 字节保证4 字节对齐 
                                               <br>}; // 共8 字节 
                                               <br>2)下面的函数实现在一个数上加一个数，有什么错误？请改正。 
                                               <br>int add_n ( int n ) 
                                               <br>{ 
                                               <br>static int i = 100; 
                                               <br>i += n; 
                                               <br>return i; 
                                               <br>} 
                                               <br>当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在 
                                               <br>static 上？ 
                                               <br>// 帮忙分析一下 
                                               <br>#include 
                                                
                                                <br>#include 
                                                 
                                                 <br>#include 
                                                  
                                                  <br>#include 
                                                   
                                                   <br>#include 
                                                    
                                                    <br>#include 
                                                     
                                                     <br>typedef struct AA 
                                                     <br>{ 
                                                     <br>int b1:5; 
                                                     <br>int b2:2; 
                                                     <br>}AA; 
                                                     <br>void main() 
                                                     <br>{ 
                                                     <br>AA aa; 
                                                     <br>char cc[100]; 
                                                     <br>strcpy(cc,"0123456789abcdefghijklmnopqrstuvwxyz"); 
                                                     <br>memcpy(&amp;aa,cc,sizeof(AA)); 
                                                     <br>cout &lt;&lt; aa.b1 &lt; 
                                                      
                                                      <br>cout &lt;&lt; aa.b2 &lt; 
                                                       
                                                       <br>} 
                                                       <br>答案是-16 和１ 
                                                       <br>首先sizeof(AA)的大小为4,b1 和b2 分别占5bit 和2bit. 
                                                       <br>经过strcpy 和memcpy 后,aa 的4 个字节所存放的值是: 
                                                       <br>0,1,2,3 的ASC 码，即00110000,00110001,00110010,00110011 
                                                       <br>所以，最后一步：显示的是这４个字节的前５位，和之后的２位 
                                                       <br>分别为：10000,和01 
                                                       <br>因为int 是有正负之分所以：答案是-16 和１ 
                                                       <br>求函数返回值，输入x=9999; 
                                                       <br>int func （ x ） 
                                                       <br>{ 
                                                       <br>int countx = 0; 
                                                       <br>while ( x ) 
                                                       <br>{ 
                                                       <br>countx ++; 
                                                       <br>x = x&amp;(x-1); 
                                                       <br>} 
                                                       <br>return countx; 
                                                       <br>} 
                                                       <br>结果呢？ 
                                                       <br>知道了这是统计9999 的二进制数值中有多少个1 的函数，且有 
                                                       <br>9999＝9×1024＋512＋256＋15 
                                                       <br>9×1024 中含有1 的个数为2； 
                                                       <br>512 中含有1 的个数为1； 
                                                       <br>256 中含有1 的个数为1； 
                                                       <br>15 中含有1 的个数为4； 
                                                       <br>故共有1 的个数为8，结果为8。 
                                                       <br>1000 - 1 = 0111，正好是原数取反。这就是原理。 
                                                       <br>用这种方法来求1 的个数是很效率很高的。 
                                                       <br>不必去一个一个地移位。循环次数最少。 
                                                       <br>int a,b,c 请写函数实现C=a+b ,不可以改变数据类型,如将c 改为long int,关键是如何处理溢 
                                                       <br>出问题 
                                                       <br>bool add (int a, int b,int *c) 
                                                       <br>{ 
                                                       <br>*c=a+b; 
                                                       <br>return (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp;(*c 
                                                       
                                                      
                                                     
                                                    
                                                   
                                                  
                                                 
                                                
                                               
                                              
                                             
                                            
                                           
                                          
                                         
                                        
                                       
                                      
                                     
                                    
                                   
                                  
                                 
                                
                               
                              
                             
                            
                           
                          
                         
                        
                      a || *c&gt;b))); <br>} <br>分析： <br>struct bit <br>{ int a:3; <br>int b:2; <br>int c:3; <br>}; <br>int main() <br>{ <br>bit s; <br>char *c=(char*)&amp;s; <br>cout&lt; 
                       
                         &lt; 
                         
                         <br>*c=0x99; 
                         <br>cout &lt;&lt; s.a &lt; 
                         
                           &lt; 
                          
                            &lt; 
                           
                             &lt; 
                            
                              &lt; 
                              
                              <br>int a=-1; 
                              <br>printf("%x",a); 
                              <br>return 0; 
                              <br>} 
                              <br>输出为什么是 
                              <br>4 
                              <br>1 
                              <br>-1 
                              <br>-4 
                              <br>ffffffff 
                              <br>因为0x99 在内存中表示为100 11 001 , a = 001, b = 11, c = 100 
                              <br>当c 为有符合数时, c = 100, 最高1 为表示c 为负数，负数在计算机用补码表示，所以c = -4; 
                              <br>同理 
                              <br>b = -1; 
                              <br>当c 为有符合数时, c = 100,即c = 4,同理b = 3 
                              <br>位域： 
                              <br>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如 
                              <br>在存放一个开关量时，只有0 和1 两种状态， 用一位二进位即可。为了节省存储空间，并 
                              <br>使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节 
                              <br>中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在 
                              <br>程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。 
                              <br>一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为： 
                              <br>struct 位域结构名 
                              <br>{ 位域列表}; 
                              <br>其中位域列表的形式为： 类型说明符位域名：位域长度 
                              <br>例如： 
                              <br>struct bs 
                              <br>{ 
                              <br>int a:8; 
                              <br>int b:2; 
                              <br>int c:6; 
                              <br>}; 
                              <br>位域变量的说明与结构变量说明的方式相同。可采用先定义后说明，同时定义说明或者直 
                              <br>接说明这三种方式。例如： 
                              <br>struct bs 
                              <br>{ 
                              <br>int a:8; 
                              <br>int b:2; 
                              <br>int c:6; 
                              <br>}data; 
                              <br>说明data 为bs 变量，共占两个字节。其中位域a 占8 位，位域b 占2 位，位域c 占6 位。 
                              <br>对于位域的定义尚有以下几点说明： 
                              <br>1. 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另 
                              <br>一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如： 
                              <br>struct bs 
                              <br>{ 
                              <br>unsigned a:4 
                              <br>unsigned :0 /*空域*/ 
                              <br>unsigned b:4 /*从下一单元开始存放*/ 
                              <br>unsigned c:4 
                              <br>} 
                              <br>在这个位域定义中，a 占第一字节的4 位，后4 位填0 表示不使用，b 从第二字节开始，占 
                              <br>用4 位，c 占用4 位。 
                              <br>2. 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能 
                              <br>超过8 位二进位。 
                              <br>3. 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例 
                              <br>如： 
                              <br>struct k 
                              <br>{ 
                              <br>int a:1 
                              <br>int :2 /*该2 位不能使用*/ 
                              <br>int b:3 
                              <br>int c:2 
                              <br>}; 
                              <br>从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配 
                              <br>的。 
                              <br>二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名•位域名位 
                              <br>域允许用各种格式输出。 
                              <br>main(){ 
                              <br>struct bs 
                              <br>{ 
                              <br>unsigned a:1; 
                              <br>unsigned b:3; 
                              <br>unsigned c:4; 
                              <br>} bit,*pbit; 
                              <br>bit.a=1; 
                              <br>bit.b=7; 
                              <br>bit.c=15; 
                              <br>pri 
                              <br>改错： 
                              <br>#include 
                               
                               <br>int main(void) { 
                               <br>int **p; 
                               <br>int arr[100]; 
                               <br>p = &amp;arr; 
                               <br>return 0; 
                               <br>} 
                               <br>解答： 
                               <br>搞错了,是指针类型不同, 
                               <br>int **p; //二级指针 
                               <br>&amp;arr; //得到的是指向第一维为100 的数组的指针 
                               <br>#include 
                                
                                <br>int main(void) { 
                                <br>int **p, *q; 
                                <br>int arr[100]; 
                                <br>q = arr; 
                                <br>p = &amp;q; 
                                <br>return 0; 
                                <br>} 
                                <br>下面这个程序执行后会有什么错误或者效果: 
                                <br>#define MAX 255 
                                <br>int main() 
                                <br>{ 
                                <br>unsigned char A[MAX],i;//i 被定义为unsigned char 
                                <br>for (i=0;i&lt;=MAX;i++) 
                                <br>A[i]=i; 
                                <br>} 
                                <br>解答：死循环加数组越界访问（C/C++不进行数组越界检查） 
                                <br>MAX=255 
                                <br>数组A 的下标范围为:0..MAX-1,这是其一.. 
                                <br>其二.当i 循环到255 时,循环内执行: 
                                <br>A[255]=255; 
                                <br>这句本身没有问题..但是返回for (i=0;i&lt;=MAX;i++)语句时, 
                                <br>由于unsigned char 的取值范围在(0..255),i++以后i 又为0 了..无限循环下去. 
                                <br>struct name1{ 
                                <br>char str; 
                                <br>short x; 
                                <br>int num; 
                                <br>} 
                                <br>struct name2{ 
                                <br>char str; 
                                <br>int num; 
                                <br>short x; 
                                <br>} 
                                <br>sizeof(struct name1)=8,sizeof(struct name2)=12 
                                <br>在第二个结构中，为保证num 按四个字节对齐，char 后必须留出3 字节的空间；同时为保 
                                <br>证整个结构的自然对齐（这里是4 字节对齐），在x 后还要补齐2 个字节，这样就是12 字 
                                <br>节。 
                                <br>intel： 
                                <br>A.c 和B.c 两个c 文件中使用了两个相同名字的static 变量,编译的时候会不会有问题?这两 
                                <br>个static 变量会保存到哪里（栈还是堆或者其他的）? 
                                <br>static 的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。 
                                <br>他们都放在数据区，但是编译器对他们的命名是不同的。 
                                <br>如果要使变量在其他模块也有意义的话，需要使用extern 关键字。 
                                <br>struct s1 
                                <br>{ 
                                <br>int i: 8; 
                                <br>int j: 4; 
                                <br>int a: 3; 
                                <br>double b; 
                                <br>}; 
                                <br>struct s2 
                                <br>{ 
                                <br>int i: 8; 
                                <br>int j: 4; 
                                <br>double b; 
                                <br>int a:3; 
                                <br>}; 
                                <br>printf("sizeof(s1)= %d/n", sizeof(s1)); 
                                <br>printf("sizeof(s2)= %d/n", sizeof(s2)); 
                                <br>result: 16, 24 
                                <br>第一个struct s1 
                                <br>{ 
                                <br>int i: 8; 
                                <br>int j: 4; 
                                <br>int a: 3; 
                                <br>double b; 
                                <br>}; 
                                <br>理论上是这样的，首先是i 在相对0 的位置，占8 位一个字节，然后，j 就在相对一个字节 
                                <br>的位置，由于一个位置的字节数是4 位的倍数，因此不用对齐，就放在那里了，然后是a， 
                                <br>要在3 位的倍数关系的位置上，因此要移一位，在15 位的位置上放下，目前总共是18 位， 
                                <br>折算过来是2 字节2 位的样子，由于double 是8 字节的，因此要在相对0 要是8 个字节的 
                                <br>位置上放下，因此从18 位开始到8 个字节之间的位置被忽略，直接放在8 字节的位置了， 
                                <br>因此，总共是16 字节。 
                                <br>第二个最后会对照是不是结构体内最大数据的倍数，不是的话，会补成是最大数据的倍数 
                                <br>上面是基本问题，接下来是编程问题： 
                                <br>本人很弱，这几个题也搞不定，特来求救： 
                                <br>1）读文件file1.txt 的内容（例如）： 
                                <br>12 
                                <br>34 
                                <br>56 
                                <br>输出到file2.txt： 
                                <br>56 
                                <br>34 
                                <br>12 
                                <br>（逆序） 
                                <br>2）输出和为一个给定整数的所有组合 
                                <br>例如n=5 
                                <br>5=1+4；5=2+3（相加的数不能重复） 
                                <br>则输出 
                                <br>1，4；2，3。 
                                <br>望高手赐教！！ 
                                <br>第一题,注意可增长数组的应用. 
                                <br>#include 
                                 
                                 <br>#include 
                                  
                                  <br>int main(void) 
                                  <br>{ 
                                  <br>int MAX = 10; 
                                  <br>int *a = (int *)malloc(MAX * sizeof(int)); 
                                  <br>int *b; 
                                  <br>FILE *fp1; 
                                  <br>FILE *fp2; 
                                  <br>fp1 = fopen("a.txt","r"); 
                                  <br>if(fp1 == NULL) 
                                  <br>{printf("error1"); 
                                  <br>exit(-1); 
                                  <br>} 
                                  <br>fp2 = fopen("b.txt","w"); 
                                  <br>if(fp2 == NULL) 
                                  <br>{printf("error2"); 
                                  <br>exit(-1); 
                                  <br>} 
                                  <br>int i = 0; 
                                  <br>int j = 0; 
                                  <br>while(fscanf(fp1,"%d",&amp;a[i]) != EOF) 
                                  <br>{ 
                                  <br>i++; 
                                  <br>j++; 
                                  <br>if(i &gt;= MAX) 
                                  <br>{ 
                                  <br>MAX = 2 * MAX; 
                                  <br>b = (int*)realloc(a,MAX * sizeof(int)); 
                                  <br>if(b == NULL) 
                                  <br>{ 
                                  <br>printf("error3"); 
                                  <br>exit(-1); 
                                  <br>} 
                                  <br>a = b; 
                                  <br>} 
                                  <br>} 
                                  <br>for(;--j &gt;= 0;) 
                                  <br>fprintf(fp2,"%d/n",a[j]); 
                                  <br>fclose(fp1); 
                                  <br>fclose(fp2); 
                                  <br>return 0; 
                                  <br>} 
                                  <br>第二题. 
                                  <br>#include 
                                   
                                   <br>int main(void) 
                                   <br>{ 
                                   <br>unsigned long int i,j,k; 
                                   <br>printf("please input the number/n"); 
                                   <br>scanf("%d",&amp;i); 
                                   <br>if( i % 2 == 0) 
                                   <br>j = i / 2; 
                                   <br>else 
                                   <br>j = i / 2 + 1; 
                                   <br>printf("The result is /n"); 
                                   <br>for(k = 0; k &lt; j; k++) 
                                   <br>printf("%d = %d + %d/n",i,k,i - k); 
                                   <br>return 0; 
                                   <br>} 
                                   <br>#include 
                                    
                                    <br>void main() 
                                    <br>{ 
                                    <br>unsigned long int a,i=1; 
                                    <br>scanf("%d",&amp;a); 
                                    <br>if(a%2==0) 
                                    <br>{ 
                                    <br>for(i=1;i 
                                    
                                   
                                  
                                 
                                
                               
                              
                             
                            
                           
                          
                         
                        
                      printf("%d",a,a-i); 
                      <br>} 
                      <br>else 
                      <br>for(i=1;i&lt;=a/2;i++) 
                      <br>printf(" %d, %d",i,a-i); 
                      <br>} 
                      <br>兄弟,这样的题目若是做不出来实在是有些不应该, 给你一个递规反向输出字符串的例子,可 
                      <br>谓是反序的经典例程. 
                      <br>void inverse(char *p) 
                      <br>{ 
                      <br>if( *p = = '/0' ) 
                      <br>return; 
                      <br>inverse( p+1 ); 
                      <br>printf( "%c", *p ); 
                      <br>} 
                      <br>int main(int argc, char *argv[]) 
                      <br>{ 
                      <br>inverse("abc/0"); 
                      <br>return 0; 
                      <br>} 
                      <br>借签了楼上的“递规反向输出” 
                      <br>#include 
                       
                       <br>void test(FILE *fread, FILE *fwrite) 
                       <br>{ 
                       <br>char buf[1024] = {0}; 
                       <br>if (!fgets(buf, sizeof(buf), fread)) 
                       <br>return; 
                       <br>test( fread, fwrite ); 
                       <br>fputs(buf, fwrite); 
                       <br>} 
                       <br>int main(int argc, char *argv[]) 
                       <br>{ 
                       <br>FILE *fr = NULL; 
                       <br>FILE *fw = NULL; 
                       <br>fr = fopen("data", "rb"); 
                       <br>fw = fopen("dataout", "wb"); 
                       <br>test(fr, fw); 
                       <br>fclose(fr); 
                       <br>fclose(fw); 
                       <br>return 0; 
                       <br>} 
                       <br>在对齐为4 的情况下 
                       <br>struct BBB 
                       <br>{ 
                       <br>long num； 
                       <br>char *name; 
                       <br>short int data; 
                       <br>char ha; 
                       <br>short ba[5]; 
                       <br>}*p; 
                       <br>p=0x1000000; 
                       <br>p+0x200=____; 
                       <br>(Ulong)p+0x200=____; 
                       <br>(char*)p+0x200=____; 
                       <br>希望各位达人给出答案和原因，谢谢拉 
                       <br>解答：假设在32 位CPU 上， 
                       <br>sizeof(long) = 4 bytes 
                       <br>sizeof(char *) = 4 bytes 
                       <br>sizeof(short int) = sizeof(short) = 2 bytes 
                       <br>sizeof(char) = 1 bytes 
                       <br>由于是4 字节对齐， 
                       <br>sizeof(struct BBB) = sizeof(*p) 
                       <br>= 4 + 4 + 2 + 1 + 1/*补齐*/ + 2*5 + 2/*补齐*/ = 24 bytes (经Dev-C++验证) 
                       <br>p=0x1000000; 
                       <br>p+0x200=____; 
                       <br>= 0x1000000 + 0x200*24 
                       <br>(Ulong)p+0x200=____; 
                       <br>= 0x1000000 + 0x200 
                       <br>(char*)p+0x200=____; 
                       <br>= 0x1000000 + 0x200*4 
                       <br>你可以参考一下指针运算的细节 
                       <br>写一段程序，找出数组中第k 大小的数，输出数所在的位置。例如{2，4，3，4，7}中，第 
                       <br>一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3 随便输出哪一个均可。 
                       <br>函数接口为：int find_orderk(const int* narry,const int n,const int k) 
                       <br>要求算法复杂度不能是O(n^2） 
                       <br>谢谢！ 
                       <br>可以先用快速排序进行排序，其中用另外一个进行地址查找 
                       <br>代码如下，在VC++6.0 运行通过。给分吧^-^ 
                       <br>//快速排序 
                       <br>#include 
                        
                        <br>usingnamespacestd; 
                        <br>intPartition (int*L,intlow,int high) 
                        <br>{ 
                        <br>inttemp = L[low]; 
                        <br>intpt = L[low]; 
                        <br>while (low &lt; high) 
                        <br>{ 
                        <br>while (low &lt; high &amp;&amp; L[high] &gt;= pt) 
                        <br>--high; 
                        <br>L[low] = L[high]; 
                        <br>while (low &lt; high &amp;&amp; L[low] &lt;= pt) 
                        <br>++low; 
                        <br>L[low] = temp; 
                        <br>} 
                        <br>L[low] = temp; 
                        <br>returnlow; 
                        <br>} 
                        <br>voidQSort (int*L,intlow,int high) 
                        <br>{ 
                        <br>if (low &lt; high) 
                        <br>{ 
                        <br>intpl = Partition (L,low,high); 
                        <br>QSort (L,low,pl - 1); 
                        <br>QSort (L,pl + 1,high); 
                        <br>} 
                        <br>} 
                        <br>intmain () 
                        <br>{ 
                        <br>intnarry[100],addr[100]; 
                        <br>intsum = 1,t; 
                        <br>cout &lt;&lt; "Input number:" &lt;&lt; endl; 
                        <br>cin &gt;&gt; t; 
                        <br>while (t != -1) 
                        <br>{ 
                        <br>narry[sum] = t; 
                        <br>addr[sum - 1] = t; 
                        <br>sum++; 
                        <br>cin &gt;&gt; t; 
                        <br>} 
                        <br>sum -= 1; 
                        <br>QSort (narry,1,sum); 
                        <br>for (int i = 1; i &lt;= sum;i++) 
                        <br>cout &lt;&lt; narry[i] &lt;&lt; '/t'; 
                        <br>cout &lt;&lt; endl; 
                        <br>intk; 
                        <br>cout &lt;&lt; "Please input place you want:" &lt;&lt; endl; 
                        <br>cin &gt;&gt; k; 
                        <br>intaa = 1; 
                        <br>intkk = 0; 
                        <br>for (;;) 
                        <br>{ 
                        <br>if (aa == k) 
                        <br>break; 
                        <br>if (narry[kk] != narry[kk + 1]) 
                        <br>{ 
                        <br>aa += 1; 
                        <br>kk++; 
                        <br>} 
                        <br>} 
                        <br>cout &lt;&lt; "The NO." &lt;&lt; k &lt;&lt; "number is:" &lt;&lt; narry[sum - kk] &lt;&lt; endl; 
                        <br>cout &lt;&lt; "And it's place is:" ; 
                        <br>for (i = 0;i &lt; sum;i++) 
                        <br>{ 
                        <br>if (addr[i] == narry[sum - kk]) 
                        <br>cout &lt;&lt; i &lt;&lt; '/t'; 
                        <br>} 
                        <br>return0; 
                        <br>} 
                        <br>1、找错 
                        <br>Void test1() 
                        <br>{ 
                        <br>char string[10]; 
                        <br>char* str1="0123456789"; 
                        <br>strcpy(string, str1);// 溢出，应该包括一个存放'/0'的字符string[11] 
                        <br>} 
                        <br>Void test2() 
                        <br>{ 
                        <br>char string[10], str1[10]; 
                        <br>for(I=0; I&lt;10;I++) 
                        <br>{ 
                        <br>str1[i] ='a'; 
                        <br>} 
                        <br>strcpy(string, str1);// I，i 没有声明。 
                        <br>} 
                        <br>Void test3(char* str1) 
                        <br>{ 
                        <br>char string[10]; 
                        <br>if(strlen(str1)&lt;=10)// 改成&lt;10,字符溢出，将strlen 改为sizeof 也可以 
                        <br>{ 
                        <br>strcpy(string, str1); 
                        <br>} 
                        <br>} 
                        <br>2. 
                        <br>void g(int**); 
                        <br>int main() 
                        <br>{ 
                        <br>int line[10],i; 
                        <br>int *p=line; //p 是地址的地址 
                        <br>for (i=0;i&lt;10;i++) 
                        <br>{ 
                        <br>*p=i; 
                        <br>g(&amp;p);//数组对应的值加1 
                        <br>} 
                        <br>for(i=0;i&lt;10;i++) 
                        <br>printf("%d/n",line[i]); 
                        <br>return 0; 
                        <br>} 
                        <br>void g(int**p) 
                        <br>{ 
                        <br>(**p)++; 
                        <br>(*p)++;// 无效 
                        <br>} 
                        <br>输出： 
                        <br>1 
                        <br>2 
                        <br>3 
                        <br>4 
                        <br>5 
                        <br>6 
                        <br>7 
                        <br>8 
                        <br>9 
                        <br>10 
                        <br>3. 写出程序运行结果 
                        <br>int sum(int a) 
                        <br>{ 
                        <br>auto int c=0; 
                        <br>static int b=3; 
                        <br>c+=1; 
                        <br>b+=2; 
                        <br>return(a+b+c); 
                        <br>} 
                        <br>void main() 
                        <br>{ 
                        <br>int I; 
                        <br>int a=2; 
                        <br>for(I=0;I&lt;5;I++) 
                        <br>{ 
                        <br>printf("%d,", sum(a)); 
                        <br>} 
                        <br>} 
                        <br>// static 会保存上次结果，记住这一点，剩下的自己写 
                        <br>输出：8,10,12,14,16, 
                        <br>4. 
                        <br>int func(int a) 
                        <br>{ 
                        <br>int b; 
                        <br>switch(a) 
                        <br>{ 
                        <br>case 1: 30; 
                        <br>case 2: 20; 
                        <br>case 3: 16; 
                        <br>default: 0 
                        <br>} 
                        <br>return b; 
                        <br>} 
                        <br>则func(1)=? 
                        <br>// b 定义后就没有赋值。 
                        <br>5: 
                        <br>int a[3]; 
                        <br>a[0]=0; a[1]=1; a[2]=2; 
                        <br>int *p, *q; 
                        <br>p=a; 
                        <br>q=&amp;a[2]; 
                        <br>则a[q-p]=a[2] 
                        <br>解释：指针一次移动一个int 但计数为1 
                        <br>今天早上的面试题9 道，比较难，向牛人请教，国内的一牛公司，坐落在北京北四环某大 
                        <br>厦： 
                        <br>1、线形表a、b 为两个有序升序的线形表，编写一程序，使两个有序线形表合并成一个有 
                        <br>序升序线形表h； 
                        <br>答案在请化大学严锐敏《数据结构第二版》第二章例题，数据结构当中，这个叫做：两路 
                        <br>归并排序 
                        <br>Linklist *unio(Linklist *p,Linklist *q){ 
                        <br>linklist *R,*pa,*qa,*ra; 
                        <br>pa=p; 
                        <br>qa=q; 
                        <br>R=ra=p; 
                        <br>while(pa-&gt;next!=NULL&amp;&amp;qa-&gt;next!=NULL){ 
                        <br>if(pa-&gt;data&gt;qa-&gt;data){ 
                        <br>ra-&gt;next=qa; 
                        <br>qa=qa-&gt;next; 
                        <br>} 
                        <br>else{ 
                        <br>ra-&gt;next=pa; 
                        <br>pa=pa-&gt;next; 
                        <br>} 
                        <br>} 
                        <br>if(pa-&gt;next!=NULL) 
                        <br>ra-&gt;next=pa; 
                        <br>if(qa-&gt;next!=NULL) 
                        <br>ra-&gt;next==qa; 
                        <br>return R; 
                        <br>} 
                        <br>2、运用四色定理，为N 个局域举行配色，颜色为1、2、3、4 四种，另有数组adj[][N]，如 
                        <br>adj[i][j]=1 则表示i 区域与j 区域相邻，数组color[N]，如color[i]=1,表示i 区域的颜色为1 号 
                        <br>颜色。 
                        <br>四色填充 
                        <br>3、用递归算法判断数组a[N]是否为一个递增数组。 
                        <br>递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回false 
                        <br>结束： 
                        <br>bool fun( int a[], int n ) 
                        <br>{ 
                        <br>if( n= =1 ) 
                        <br>return true; 
                        <br>if( n= =2 ) 
                        <br>return a[n-1] &gt;= a[n-2]; 
                        <br>return fun( a,n-1) &amp;&amp; ( a[n-1] &gt;= a[n-2] ); 
                        <br>} 
                        <br>4、编写算法，从10 亿个浮点数当中，选出其中最大的10000 个。 
                        <br>用外部排序，在《数据结构》书上有 
                        <br>《计算方法导论》在找到第n 大的数的算法上加工 
                        <br>5、编写一unix 程序，防止僵尸进程的出现. 
                        <br>Top 
                        <br>free131(白日?做梦!) ( ) 信誉：100 2006-4-17 10:17:34 得分: 0 
                        <br>同学的4 道面试题，应聘的职位是搜索引擎工程师，后两道超级难，（希望大家多给一些 
                        <br>算发） 
                        <br>1.给两个数组和他们的大小，还有一动态开辟的内存，求交集，把交集放到动态内存dongtai， 
                        <br>并且返回交集个数 
                        <br>long jiaoji(long* a[],long b[],long* alength,long blength,long* dongtai[]) 
                        <br>2.单连表的建立，把'a'--'z'26 个字母插入到连表中，并且倒叙，还要打印！ 
                        <br>方法1： 
                        <br>typedef struct val 
                        <br>{ int date_1; 
                        <br>struct val *next; 
                        <br>}*p; 
                        <br>void main(void) 
                        <br>{ char c; 
                        <br>for(c=122;c&gt;=97;c--) 
                        <br>{ p.date=c; 
                        <br>p=p-&gt;next; 
                        <br>} 
                        <br>p.next=NULL; 
                        <br>} 
                        <br>} 
                        <br>方法2： 
                        <br>node *p = NULL; 
                        <br>node *q = NULL; 
                        <br>node *head = (node*)malloc(sizeof(node)); 
                        <br>head-&gt;data = ' ';head-&gt;next=NULL; 
                        <br>node *first = (node*)malloc(sizeof(node)); 
                        <br>first-&gt;data = 'a';first-&gt;next=NULL;head-&gt;next = first; 
                        <br>p = first; 
                        <br>int longth = 'z' - 'b'; 
                        <br>int i=0; 
                        <br>while ( i&lt;=longth ) 
                        <br>{ 
                        <br>node *temp = (node*)malloc(sizeof(node)); 
                        <br>temp-&gt;data = 'b'+i;temp-&gt;next=NULL;q=temp; 
                        <br>head-&gt;next = temp; temp-&gt;next=p;p=q; 
                        <br>i++; 
                        <br>} 
                        <br>print(head); 
                        <br>3.可怕的题目终于来了 
                        <br>象搜索的输入信息是一个字符串，统计300 万输入信息中的最热门的前十条，我们每次输 
                        <br>入的一个字符串为不超过255byte,内存使用只有1G, 
                        <br>请描述思想，写出算发（c 语言），空间和时间复杂度， 
                        <br>4.国内的一些帖吧，如baidu,有几十万个主题，假设每一个主题都有上亿的跟帖子，怎么样 
                        <br>设计这个系统速度最好，请描述思想，写出算发（c 语言），空间和时间复杂度， 
                        <br>#include string.h 
                        <br>main(void) 
                        <br>{ char *src="hello,world"; 
                        <br>char *dest=NULL; 
                        <br>dest=(char *)malloc(strlen(src)); 
                        <br>int len=strlen(str); 
                        <br>char *d=dest; 
                        <br>char *s=src[len]; 
                        <br>while(len--!=0) 
                        <br>d++=s--; 
                        <br>printf("%s",dest); 
                        <br>} 
                        <br>找出错误！！ 
                        <br>#include "string.h" 
                        <br>#include "stdio.h" 
                        <br>#include "malloc.h" 
                        <br>main(void) 
                        <br>{ 
                        <br>char *src="hello,world"; 
                        <br>char *dest=NULL; 
                        <br>dest=(char *)malloc(sizeof(char)*(strlen(src)+1)); 
                        <br>int len=strlen(src); 
                        <br>char *d=dest; 
                        <br>char *s=src+len-1; 
                        <br>while(len--!=0) 
                        <br>*d++=*s--; 
                        <br>*d='/0'; 
                        <br>printf("%s",dest); 
                        <br>} 
                        <br>1. 简述一个Linux 驱动程序的主要流程与功能。 
                        <br>2. 请列举一个软件中时间换空间或者空间换时间的例子。 
                        <br>void swap(int a,int b) 
                        <br>{ 
                        <br>int c; c=a;a=b;b=a; 
                        <br>} 
                        <br>---&gt;空优 
                        <br>void swap(int a,int b) 
                        <br>{ 
                        <br>a=a+b;b=a-b;a=a-b; 
                        <br>} 
                        <br>6. 请问一下程序将输出什么结果？ 
                        <br>char *RetMenory(void) 
                        <br>{ 
                        <br>char p[] = “hellow world”; 
                        <br>return p; 
                        <br>} 
                        <br>void Test(void) 
                        <br>{ 
                        <br>char *str = NULL; 
                        <br>str = RetMemory(); 
                        <br>printf(str); 
                        <br>} 
                        <br>RetMenory 执行完毕，p 资源被回收，指向未知地址。返回地址，str 的内容应是不可预测 
                        <br>的, 打印的应该是str 的地址 
                        <br>写一个函数,它的原形是int continumax(char *outputstr,char *intputstr) 
                        <br>功能： 
                        <br>在字符串中找出连续最长的数字串，并把这个串的长度返回，并把这个最长数字串付给其中 
                        <br>一个函数参数outputstr 所指内存。例如："abcd12345ed125ss123456789"的首地址传给 
                        <br>intputstr 后，函数将返回 
                        <br>9，outputstr 所指的值为123456789 
                        <br>int continumax(char *outputstr, char *inputstr) 
                        <br>{ 
                        <br>char *in = inputstr, *out = outputstr, *temp, *final; 
                        <br>int count = 0, maxlen = 0; 
                        <br>while( *in != '/0' ) 
                        <br>{ 
                        <br>if( *in &gt; 47 &amp;&amp; *in &lt; 58 ) 
                        <br>{ 
                        <br>for(temp = in; *in &gt; 47 &amp;&amp; *in &lt; 58 ; in++ ) 
                        <br>count++; 
                        <br>} 
                        <br>else 
                        <br>in++; 
                        <br>if( maxlen &lt; count ) 
                        <br>{ 
                        <br>maxlen = count; 
                        <br>count = 0; 
                        <br>final = temp; 
                        <br>} 
                        <br>} 
                        <br>for(int i = 0; i &lt; maxlen; i++) 
                        <br>{ 
                        <br>*out = *final; 
                        <br>out++; 
                        <br>final++; 
                        <br>} 
                        <br>*out = '/0'; 
                        <br>return maxlen; 
                        <br>} 
                        <br>不用库函数,用C 语言实现将一整型数字转化为字符串 
                        <br>方法1： 
                        <br>int getlen(char *s){ 
                        <br>int n; 
                        <br>for(n = 0; *s != '/0'; s++) 
                        <br>n++; 
                        <br>return n; 
                        <br>} 
                        <br>void reverse(char s[]) 
                        <br>{ 
                        <br>int c,i,j; 
                        <br>for(i = 0,j = getlen(s) - 1; i &lt; j; i++,j--){ 
                        <br>c = s[i]; 
                        <br>s[i] = s[j]; 
                        <br>s[j] = c; 
                        <br>} 
                        <br>} 
                        <br>void itoa(int n,char s[]) 
                        <br>{ 
                        <br>int i,sign; 
                        <br>if((sign = n) &lt; 0) 
                        <br>n = -n; 
                        <br>i = 0; 
                        <br>do{/*以反序生成数字*/ 
                        <br>s[i++] = n%10 + '0';/*get next number*/ 
                        <br>}while((n /= 10) &gt; 0);/*delete the number*/ 
                        <br>if(sign &lt; 0) 
                        <br>s[i++] = '-'; 
                        <br>s[i] = '/0'; 
                        <br>reverse(s); 
                        <br>} 
                        <br>方法2: 
                        <br>#include 
                         
                         <br>using namespace std; 
                         <br>void itochar(int num); 
                         <br>void itochar(int num) 
                         <br>{ 
                         <br>int i = 0; 
                         <br>int j ; 
                         <br>char stra[10]; 
                         <br>char strb[10]; 
                         <br>while ( num ) 
                         <br>{ 
                         <br>stra[i++]=num%10+48; 
                         <br>num=num/10; 
                         <br>} 
                         <br>stra[i] = '/0'; 
                         <br>for( j=0; j &lt; i; j++) 
                         <br>{ 
                         <br>strb[j] = stra[i-j-1]; 
                         <br>} 
                         <br>strb[j] = '/0'; 
                         <br>cout&lt; 
                         
                           &lt; 
                           
                           <br>} 
                           <br>int main() 
                           <br>{ 
                           <br>int num; 
                           <br>cin&gt;&gt;num; 
                           <br>itochar(num); 
                           <br>return 0; 
                           <br>} 
                           <br>前几天面试，有一题想不明白,请教大家！ 
                           <br>typedef struct 
                           <br>{ 
                           <br>int a:2; 
                           <br>int b:2; 
                           <br>int c:1; 
                           <br>}test; 
                           <br>test t; 
                           <br>t.a = 1; 
                           <br>t.b = 3; 
                           <br>t.c = 1; 
                           <br>printf("%d",t.a); 
                           <br>printf("%d",t.b); 
                           <br>printf("%d",t.c); 
                           <br>谢谢! 
                           <br>t.a 为01,输出就是1 
                           <br>t.b 为11，输出就是－1 
                           <br>t.c 为1，输出也是-1 
                           <br>3 个都是有符号数int 嘛。 
                           <br>这是位扩展问题 
                           <br>01 
                           <br>11 
                           <br>1 
                           <br>编译器进行符号扩展 
                           <br>求组合数： 求n 个数（1....n）中k 个数的组合.... 
                           <br>如：combination(5,3) 
                           <br>要求输出：543，542，541，532，531，521，432，431，421，321， 
                           <br>#include 
                            
                            <br>int pop(int *); 
                            <br>int push(int ); 
                            <br>void combination(int ,int ); 
                            <br>int stack[3]={0}; 
                            <br>top=-1; 
                            <br>int main() 
                            <br>{ 
                            <br>int n,m; 
                            <br>printf("Input two numbers:/n"); 
                            <br>while( (2!=scanf("%d%*c%d",&amp;n,&amp;m)) ) 
                            <br>{ 
                            <br>fflush(stdin); 
                            <br>printf("Input error! Again:/n"); 
                            <br>} 
                            <br>combination(n,m); 
                            <br>printf("/n"); 
                            <br>} 
                            <br>void combination(int m,int n) 
                            <br>{ 
                            <br>int temp=m; 
                            <br>push(temp); 
                            <br>while(1) 
                            <br>{ 
                            <br>if(1==temp) 
                            <br>{ 
                            <br>if(pop(&amp;temp)&amp;&amp;stack[0]==n) //当栈底元素弹出&amp;&amp;为可能取的最小值，循环退出 
                            <br>break; 
                            <br>} 
                            <br>else if( push(--temp)) 
                            <br>{ 
                            <br>printf("%d%d%d ",stack[0],stack[1],stack[2]);//§ä¨ì¤@? 
                            <br>pop(&amp;temp); 
                            <br>} 
                            <br>} 
                            <br>} 
                            <br>int push(int i) 
                            <br>{ 
                            <br>stack[++top]=i; 
                            <br>if(top&lt;2) 
                            <br>return 0; 
                            <br>else 
                            <br>return 1; 
                            <br>} 
                            <br>int pop(int *i) 
                            <br>{ 
                            <br>*i=stack[top--]; 
                            <br>if(top&gt;=0) 
                            <br>return 0; 
                            <br>else 
                            <br>return 1; 
                            <br>} 
                            <br>1、用指针的方法，将字符串“ABCD1234efgh”前后对调显示 
                            <br>#include 
                             
                             <br>#include 
                              
                              <br>#include 
                               
                               <br>int main() 
                               <br>{ 
                               <br>char str[] = "ABCD1234efgh"; 
                               <br>int length = strlen(str); 
                               <br>char * p1 = str; 
                               <br>char * p2 = str + length - 1; 
                               <br>while(p1 &lt; p2) 
                               <br>{ 
                               <br>char c = *p1; 
                               <br>*p1 = *p2; 
                               <br>*p2 = c; 
                               <br>++p1; 
                               <br>--p2; 
                               <br>} 
                               <br>printf("str now is %s/n",str); 
                               <br>system("pause"); 
                               <br>return 0; 
                               <br>} 
                               <br>2、有一分数序列：1/2,1/4,1/6,1/8……，用函数调用的方法，求此数列前20 项的和 
                               <br>#include 
                                
                                <br>double getValue() 
                                <br>{ 
                                <br>double result = 0; 
                                <br>int i = 2; 
                                <br>while(i &lt; 42) 
                                <br>{ 
                                <br>result += 1.0 / i;//一定要使用1.0 做除数，不能用1，否则结果将自动转化成整数， 
                                <br>即0.000000 
                                <br>i += 2; 
                                <br>} 
                                <br>return result; 
                                <br>} 
                                <br>int main() 
                                <br>{ 
                                <br>printf("result is %f/n", getValue()); 
                                <br>system("pause"); 
                                <br>return 0; 
                                <br>} 
                                <br>Top 
                                <br>free131(白日?做梦!) ( ) 信誉：100 2006-4-17 10:18:33 得分: 0 
                                <br>有一个数组a[1000]存放0--1000;要求每隔二个数删掉一个数，到末尾时循环至开头继续进 
                                <br>行，求最后一个被删掉的数的原始下标位置。 
                                <br>以7 个数为例： 
                                <br>{0,1,2,3,4,5,6,7} 0--&gt;1--&gt;2（删除）--&gt;3--&gt;4--&gt;5(删除)--&gt;6--&gt;7--&gt;0（删除），如此循环 
                                <br>直到最后一个数被删除。 
                                <br>方法1：数组 
                                <br>#include 
                                 
                                 <br>using namespace std; 
                                 <br>#define null 1000 
                                 <br>int main() 
                                 <br>{ 
                                 <br>int arr[1000]; 
                                 <br>for (int i=0;i&lt;1000;++i) 
                                 <br>arr[i]=i; 
                                 <br>int j=0; 
                                 <br>int count=0; 
                                 <br>while(count&lt;999) 
                                 <br>{ 
                                 <br>while(arr[j%1000]==null) 
                                 <br>j=(++j)%1000; 
                                 <br>j=(++j)%1000; 
                                 <br>while(arr[j%1000]==null) 
                                 <br>j=(++j)%1000; 
                                 <br>j=(++j)%1000; 
                                 <br>while(arr[j%1000]==null) 
                                 <br>j=(++j)%1000; 
                                 <br>arr[j]=null; 
                                 <br>++count; 
                                 <br>} 
                                 <br>while(arr[j]==null) 
                                 <br>j=(++j)%1000; 
                                 <br>cout&lt; 
                                 
                                   &lt; 
                                   
                                   <br>return 0; 
                                   <br>}方法2：链表 
                                   <br>#include 
                                    
                                    <br>using namespace std; 
                                    <br>#define null 0 
                                    <br>struct node 
                                    <br>{ 
                                    <br>int data; 
                                    <br>node* next; 
                                    <br>}; 
                                    <br>int main() 
                                    <br>{ 
                                    <br>node* head=new node; 
                                    <br>head-&gt;data=0; 
                                    <br>head-&gt;next=null; 
                                    <br>node* p=head; 
                                    <br>for(int i=1;i&lt;1000;i++) 
                                    <br>{ 
                                    <br>node* tmp=new node; 
                                    <br>tmp-&gt;data=i; 
                                    <br>tmp-&gt;next=null; 
                                    <br>head-&gt;next=tmp; 
                                    <br>head=head-&gt;next; 
                                    <br>} 
                                    <br>head-&gt;next=p; 
                                    <br>while(p!=p-&gt;next) 
                                    <br>{ 
                                    <br>p-&gt;next-&gt;next=p-&gt;next-&gt;next-&gt;next; 
                                    <br>p=p-&gt;next-&gt;next; 
                                    <br>} 
                                    <br>cout&lt; 
                                    
                                      data; 
                                     <br>return 0; 
                                     <br>} 
                                     <br>方法3：通用算法 
                                     <br>#include 
                                      
                                      <br>#define MAXLINE 1000 //元素个数 
                                      <br>/* 
                                      <br>MAXLINE 元素个数 
                                      <br>a[] 元素数组 
                                      <br>R[] 指针场 
                                      <br>suffix 下标 
                                      <br>index 返回最后的下标序号 
                                      <br>values 返回最后的下标对应的值 
                                      <br>start 从第几个开始 
                                      <br>K 间隔 
                                      <br>*/ 
                                      <br>int find_n(int a[],int R[],int K,int&amp; index,int&amp; values,int s=0) { 
                                      <br>int suffix; 
                                      <br>int front_node,current_node; 
                                      <br>suffix=0; 
                                      <br>if(s==0) { 
                                      <br>current_node=0; 
                                      <br>front_node=MAXLINE-1; 
                                      <br>} 
                                      <br>else { 
                                      <br>current_node=s; 
                                      <br>front_node=s-1; 
                                      <br>} 
                                      <br>while(R[front_node]!=front_node) { 
                                      <br>printf("%d/n",a[current_node]); 
                                      <br>R[front_node]=R[current_node]; 
                                      <br>if(K==1) { 
                                      <br>current_node=R[front_node]; 
                                      <br>continue; 
                                      <br>} 
                                      <br>for(int i=0;i 
                                       
                                       <br>front_node=R[front_node]; 
                                       <br>} 
                                       <br>current_node=R[front_node]; 
                                       <br>} 
                                       <br>index=front_node; 
                                       <br>values=a[front_node]; 
                                       <br>return 0; 
                                       <br>} 
                                       <br>int main(void) { 
                                       <br>int a[MAXLINE],R[MAXLINE],suffix,index,values,start,i,K; 
                                       <br>suffix=index=values=start=0; 
                                       <br>K=2; 
                                       <br>for(i=0;i 
                                       a[i]=i; 
                                       <br>R[i]=i+1; 
                                       <br>} 
                                       <br>R[i-1]=0; 
                                       <br>find_n(a,R,K,index,values,2); 
                                       <br>printf("the value is %d,%d/n",index,values); 
                                       <br>return 0; 
                                       <br>} 
                                       <br>试题： 
                                       <br>void test2() 
                                       <br>{ 
                                       <br>char string[10], str1[10]; 
                                       <br>int i; 
                                       <br>for(i=0; i&lt;10; i++) 
                                       <br>{ 
                                       <br>str1[i] = 'a'; 
                                       <br>} 
                                       <br>strcpy( string, str1 ); 
                                       <br>} 
                                       <br>解答：对试题2，如果面试者指出字符数组str1 不能在数组内结束可以给3 分；如果面试者 
                                       <br>指出strcpy(string, str1)调用使得从str1 内存起复制到string 内存起所复制的字节数具有不 
                                       <br>确定性可以给7 分，在此基础上指出库函数strcpy 工作方式的给10 分； 
                                       <br>str1 不能在数组内结束:因为str1 的存储为：{a,a,a,a,a,a,a,a,a,a},没有'/0'(字符串结束符)， 
                                       <br>所以不能结束 
                                       <br>strcpy( char *s1,char *s2)他的工作原理是，扫描s2 指向的内存，逐个字符付到s1 所指向 
                                       <br>的内存，直到碰到'/0',因为str1 结尾没有'/0'，所以具有不确定性，不知道他后面还会付什么 
                                       <br>东东。 
                                       <br>正确应如下 
                                       <br>void test2() 
                                       <br>{ 
                                       <br>char string[10], str1[10]; 
                                       <br>int i; 
                                       <br>for(i=0; i&lt;9; i++) 
                                       <br>{ 
                                       <br>str1[i] = 'a'+i; //把abcdefghi 赋值给字符数组 
                                       <br>} 
                                       <br>str[i]='/0';//加上结束符 
                                       <br>strcpy( string, str1 ); 
                                       <br>} 
                                       <br>第二个code 题是实现strcmp 
                                       <br>int StrCmp(const char *str1, const char *str2) 
                                       <br>做是做对了，没有抄搞，比较乱 
                                       <br>int StrCmp(const char *str1, const char *str2) 
                                       <br>{ 
                                       <br>assert(str1 &amp;&amp; srt2); 
                                       <br>while (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2) { 
                                       <br>str1++, str2++; 
                                       <br>} 
                                       <br>if (*str1 &amp;&amp; *str2) 
                                       <br>return (*str1-*str2); 
                                       <br>elseif (*str1 &amp;&amp; *str2==0) 
                                       <br>return 1; 
                                       <br>elseif (*str1 = = 0 &amp;&amp; *str2) 
                                       <br>return -1; 
                                       <br>else 
                                       <br>return 0; 
                                       <br>} 
                                       <br>int StrCmp(const char *str1, const char *str2) 
                                       <br>{ 
                                       <br>//省略判断空指针(自己保证) 
                                       <br>while(*str1 &amp;&amp; *str1++ = = *str2++); 
                                       <br>return *str1-*str2; 
                                       <br>} 
                                       <br>第三个code 题是实现子串定位 
                                       <br>int FindSubStr(const char *MainStr, const char *SubStr) 
                                       <br>做是做对了，没有抄搞，比较乱 
                                       <br>int MyStrstr(const char* MainStr, const char* SubStr) 
                                       <br>{ 
                                       <br>const char *p; 
                                       <br>const char *q; 
                                       <br>const char * u = MainStr; 
                                       <br>//assert((MainStr!=NULL)&amp;&amp;( SubStr!=NULL));//用断言对输入进行判断 
                                       <br>while(*MainStr) //内部进行递增 
                                       <br>{ 
                                       <br>p = MainStr; 
                                       <br>q = SubStr; 
                                       <br>while(*q &amp;&amp; *p &amp;&amp; *p++ == *q++); 
                                       <br>if(!*q ) 
                                       <br>{ 
                                       <br>return MainStr - u +1 ;//MainStr 指向当前起始位，u 指向 
                                       <br>} 
                                       <br>MainStr ++; 
                                       <br>} 
                                       <br>return -1; 
                                       <br>} 
                                       <br>分析： 
                                       <br>int arr[] = {6,7,8,9,10}; 
                                       <br>int *ptr = arr; 
                                       <br>*(ptr++)+=123; 
                                       <br>printf(“ %d %d ”, *ptr, *(++ptr)); 
                                       <br>输出：8 8 
                                       <br>过程：对于*(ptr++)+=123;先做加法6+123，然后++，指针指向7；对于printf(“ %d %d ”, *ptr, 
                                       <br>*(++ptr));从后往前执行，指针先++，指向8，然后输出8，紧接着再输出8 
                                       <br>华为全套完整试题 
                                       <br>高级题 
                                       <br>6、已知一个单向链表的头，请写出删除其某一个结点的算法，要求，先找到此结点，然后 
                                       <br>删除。 
                                       <br>slnodetype *Delete(slnodetype *Head,int key){}中if(Head-&gt;number==key) 
                                       <br>{ 
                                       <br>Head=Pointer-&gt;next; 
                                       <br>free(Pointer); 
                                       <br>break; 
                                       <br>} 
                                       <br>Back = Pointer; 
                                       <br>Pointer=Pointer-&gt;next; 
                                       <br>if(Pointer-&gt;number==key) 
                                       <br>{ 
                                       <br>Back-&gt;next=Pointer-&gt;next; 
                                       <br>free(Pointer); 
                                       <br>break; 
                                       <br>} 
                                       <br>void delete(Node* p) 
                                       <br>{ 
                                       <br>if(Head = Node) 
                                       <br>while(p) 
                                       <br>} 
                                       <br>有一个16 位的整数，每4 位为一个数，写函数求他们的和。 
                                       <br>解释： 
                                       <br>整数1101010110110111 
                                       <br>和1101+0101+1011+0111 
                                       <br>感觉应该不难，当时对题理解的不是很清楚，所以写了一个函数，也不知道对不对。 
                                       <br>疑问： 
                                       <br>既然是16 位的整数，1101010110110111 是2 进制的，那么函数参数怎么定义呢，请 
                                       <br>大虾指教。 
                                       <br>答案：用十进制做参数，计算时按二进制考虑。 
                                       <br>/* n 就是16 位的数，函数返回它的四个部分之和*/ 
                                       <br>char SumOfQuaters(unsigned short n) 
                                       <br>{ 
                                       <br>char c = 0; 
                                       <br>int i = 4; 
                                       <br>do 
                                       <br>{ 
                                       <br>c += n &amp; 15; 
                                       <br>n = n &gt;&gt; 4; 
                                       <br>} while (--i); 
                                       <br>return c; 
                                       <br>} 
                                       <br>有1,2,....一直到n 的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1), 
                                       <br>使用交换,而且一次只能交换两个数.（华为） 
                                       <br>#include 
                                        
                                        <br>int main() 
                                        <br>{ 
                                        <br>int a[] = {10,6,9,5,2,8,4,7,1,3}; 
                                        <br>int len = sizeof(a) / sizeof(int); 
                                        <br>int temp; 
                                        <br>for(int i = 0; i &lt; len; ) 
                                        <br>{ 
                                        <br>temp = a[a[i] - 1]; 
                                        <br>a[a[i] - 1] = a[i]; 
                                        <br>a[i] = temp; 
                                        <br>if ( a[i] == i + 1) 
                                        <br>i++; 
                                        <br>} 
                                        <br>for (int j = 0; j &lt; len; j++) 
                                        <br>cout&lt; 
                                        
                                          &lt;&lt;","; 
                                         <br>return 0; 
                                         <br>} 
                                         <br>（慧通） 
                                         <br>1 写出程序把一个链表中的接点顺序倒排 
                                         <br>typedef struct linknode 
                                         <br>{ 
                                         <br>int data; 
                                         <br>struct linknode *next; 
                                         <br>}node; 
                                         <br>//将一个链表逆置 
                                         <br>node *reverse(node *head) 
                                         <br>{ 
                                         <br>node *p,*q,*r; 
                                         <br>p=head; 
                                         <br>q=p-&gt;next; 
                                         <br>while(q!=NULL) 
                                         <br>{ 
                                         <br>r=q-&gt;next; 
                                         <br>q-&gt;next=p; 
                                         <br>p=q; 
                                         <br>q=r; 
                                         <br>} 
                                         <br>head-&gt;next=NULL; 
                                         <br>head=p; 
                                         <br>return head; 
                                         <br>} 
                                         <br>2 写出程序删除链表中的所有接点 
                                         <br>void del_all(node *head) 
                                         <br>{ 
                                         <br>node *p; 
                                         <br>while(head!=NULL) 
                                         <br>{ 
                                         <br>p=head-&gt;next; 
                                         <br>free(head); 
                                         <br>head=p; 
                                         <br>} 
                                         <br>cout&lt;&lt;"释放空间成功!"&lt; 
                                          
                                          <br>} 
                                          <br>3 两个字符串，s,t;把t 字符串插入到s 字符串中，s 字符串有足够的空间存放t 字符串 
                                          <br>void insert(char *s, char *t, int i) 
                                          <br>{ 
                                          <br>char *q = t; 
                                          <br>char *p =s; 
                                          <br>if(q == NULL)return; 
                                          <br>while(*p!='/0') 
                                          <br>{ 
                                          <br>p++; 
                                          <br>} 
                                          <br>while(*q!=0) 
                                          <br>{ 
                                          <br>*p=*q; 
                                          <br>p++; 
                                          <br>q++; 
                                          <br>} 
                                          <br>*p = '/0'; 
                                          <br>} 
                                          <br>分析下面的代码： 
                                          <br>char *a = "hello"; 
                                          <br>char *b = "hello"; 
                                          <br>if(a= =b) 
                                          <br>printf("YES"); 
                                          <br>else 
                                          <br>printf("NO"); 
                                          <br>这个简单的面试题目,我选输出no(对比的应该是指针地址吧),可在VC 是YES 在C 是NO 
                                          <br>lz 的呢，是一个常量字符串。位于静态存储区，它在程序生命期内恒定不变。如果编译器优 
                                          <br>化的话，会有可能a 和b 同时指向同一个hello 的。则地址相同。如果编译器没有优化，那 
                                          <br>么就是两个不同的地址，则不同 
                                          <br>写一个函数，功能：完成内存之间的拷贝 
                                          <br>memcpy source code: 
                                          <br>270 void* memcpy( void *dst, const void *src, unsigned int len ) 
                                          <br>271 { 
                                          <br>272 register char *d; 
                                          <br>273 register char *s; 
                                          <br>27 
                                          <br>275 if (len == 0) 
                                          <br>276 return dst; 
                                          <br>277 
                                          <br>278 if (is_overlap(dst, src, len, len)) 
                                          <br>279 complain3("memcpy", dst, src, len); 
                                          <br>280 
                                          <br>281 if ( dst &gt; src ) { 
                                          <br>282 d = (char *)dst + len - 1; 
                                          <br>283 s = (char *)src + len - 1; 
                                          <br>284 while ( len &gt;= 4 ) { 
                                          <br>285 *d-- = *s--; 
                                          <br>286 *d-- = *s--; 
                                          <br>287 *d-- = *s--; 
                                          <br>288 *d-- = *s--; 
                                          <br>289 len -= 4; 
                                          <br>290 } 
                                          <br>291 while ( len-- ) { 
                                          <br>292 *d-- = *s--; 
                                          <br>293 } 
                                          <br>294 } else if ( dst &lt; src ) { 
                                          <br>295 d = (char *)dst; 
                                          <br>296 s = (char *)src; 
                                          <br>297 while ( len &gt;= 4 ) { 
                                          <br>298 *d++ = *s++; 
                                          <br>299 *d++ = *s++; 
                                          <br>300 *d++ = *s++; 
                                          <br>301 *d++ = *s++; 
                                          <br>302 len -= 4; 
                                          <br>303 } 
                                          <br>304 while ( len-- ) { 
                                          <br>305 *d++ = *s++; 
                                          <br>306 } 
                                          <br>307 } 
                                          <br>308 return dst; 
                                          <br>309 } 
                                          <br>公司考试这种题目主要考你编写的代码是否考虑到各种情况，是否安全（不会溢出） 
                                          <br>各种情况包括： 
                                          <br>１、参数是指针，检查指针是否有效 
                                          <br>２、检查复制的源目标和目的地是否为同一个，若为同一个，则直接跳出 
                                          <br>３、读写权限检查 
                                          <br>４、安全检查，是否会溢出 
                                          <br>memcpy 拷贝一块内存，内存的大小你告诉它 
                                          <br>strcpy 是字符串拷贝，遇到'/0'结束 
                                          <br>/* memcpy ─── 拷贝不重叠的内存块*/ 
                                          <br>void memcpy(void* pvTo, void* pvFrom, size_t size) 
                                          <br>{ 
                                          <br>void* pbTo = (byte*)pvTo; 
                                          <br>void* pbFrom = (byte*)pvFrom; 
                                          <br>ASSERT(pvTo != NULL &amp;&amp; pvFrom != NULL); //检查输入指针的有效性 
                                          <br>ASSERT(pbTo&gt;=pbFrom+size || pbFrom&gt;=pbTo+size);//检查两个指针指向的内存是否重 
                                          <br>叠 
                                          <br>while(size--&gt;0) 
                                          <br>*pbTo++ == *pbFrom++; 
                                          <br>return(pvTo); 
                                          <br>} 
                                          <br>华为面试题：怎么判断链表中是否有环？ 
                                          <br>bool CircleInList(Link* pHead) 
                                          <br>{ 
                                          <br>if(pHead = = NULL || pHead-&gt;next = = NULL)//无节点或只有一个节点并且无自环 
                                          <br>return (false); 
                                          <br>if(pHead-&gt;next = = pHead)//自环 
                                          <br>return (true); 
                                          <br>Link *pTemp1 = pHead;//step 1 
                                          <br>Link *pTemp = pHead-&gt;next;//step 2 
                                          <br>while(pTemp != pTemp1 &amp;&amp; pTemp != NULL &amp;&amp; pTemp-&gt;next != NULL) 
                                          <br>{ 
                                          <br>pTemp1 = pTemp1-&gt;next; 
                                          <br>pTemp = pTemp-&gt;next-&gt;next; 
                                          <br>} 
                                          <br>if(pTemp = = pTemp1) 
                                          <br>return (true); 
                                          <br>return (false); 
                                          <br>} 
                                          <br>两个字符串，s,t;把t 字符串插入到s 字符串中，s 字符串有足够的空间存放t 字符串 
                                          <br>void insert(char *s, char *t, int i) 
                                          <br>{ 
                                          <br>memcpy(&amp;s[strlen(t)+i],&amp;s[i],strlen(s)-i); 
                                          <br>memcpy(&amp;s[i],t,strlen(t)); 
                                          <br>s[strlen(s)+strlen(t)]='/0'; 
                                          <br>} 
                                          <br>1。编写一个C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是 
                                          <br>由同一字符组成的。 
                                          <br>char * search(char *cpSource, char ch) 
                                          <br>{ 
                                          <br>char *cpTemp=NULL, *cpDest=NULL; 
                                          <br>int iTemp, iCount=0; 
                                          <br>while(*cpSource) 
                                          <br>{ 
                                          <br>if(*cpSource == ch) 
                                          <br>{ 
                                          <br>iTemp = 0; 
                                          <br>cpTemp = cpSource; 
                                          <br>while(*cpSource == ch) 
                                          <br>++iTemp, ++cpSource; 
                                          <br>if(iTemp &gt; iCount) 
                                          <br>iCount = iTemp, cpDest = cpTemp; 
                                          <br>if(!*cpSource) 
                                          <br>break; 
                                          <br>} 
                                          <br>++cpSource; 
                                          <br>} 
                                          <br>return cpDest; 
                                          <br>} 
                                          <br>2。请编写一个C 函数，该函数在给定的内存区域搜索给定的字符，并返回该字符所在位 
                                          <br>置索引值。 
                                          <br>int search(char *cpSource, int n, char ch) 
                                          <br>{ 
                                          <br>int i; 
                                          <br>for(i=0; i 
                                          return i; 
                                          <br>} 
                                          <br>一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指向的 
                                          <br>节点？ 
                                          <br>将这个指针指向的next 节点值copy 到本节点，将next 指向next-&gt;next,并随后删除原next 
                                          <br>指向的节点。 
                                          <br>#include 
                                           
                                           <br>void foo(int m, int n) 
                                           <br>{ 
                                           <br>printf("m=%d, n=%d/n", m, n); 
                                           <br>} 
                                           <br>int main() 
                                           <br>{ 
                                           <br>int b = 3; 
                                           <br>foo(b+=3, ++b); 
                                           <br>printf("b=%d/n", b); 
                                           <br>return 0; 
                                           <br>} 
                                           <br>输出：m=7,n=4,b=7(VC6.0) 
                                           <br>这种方式和编译器中得函数调用关系相关即先后入栈顺序。不过不同 
                                           <br>编译器得处理不同。也是因为C 标准中对这种方式说明为未定义，所以 
                                           <br>各个编译器厂商都有自己得理解，所以最后产生得结果完全不同。 
                                           <br>因为这样，所以遇见这种函数，我们首先要考虑我们得编译器会如何处理 
                                           <br>这样得函数，其次看函数得调用方式，不同得调用方式，可能产生不同得 
                                           <br>结果。最后是看编译器优化。 
                                           <br>2.写一函数，实现删除字符串str1 中含有的字符串str2. 
                                           <br>第二个就是利用一个KMP 匹配算法找到str2 然后删除（用链表实现的话，便捷于数组） 
                                           <br>/*雅虎笔试题(字符串操作) 
                                           <br>给定字符串A 和B,输出A 和B 中的最大公共子串。 
                                           <br>比如A="aocdfe" B="pmcdfa" 则输出"cdf" 
                                           <br>*/ 
                                           <br>//Author: azhen 
                                           <br>#include 
                                            
                                            <br>#include 
                                             
                                             <br>#include 
                                              
                                              <br>char *commanstring(char shortstring[], char longstring[]) 
                                              <br>{ 
                                              <br>int i, j; 
                                              <br>char *substring=malloc(256); 
                                              <br>if(strstr(longstring, shortstring)!=NULL) //如果……，那么返回shortstring 
                                              <br>return shortstring; 
                                              <br>for(i=strlen(shortstring)-1;i&gt;0; i--) //否则，开始循环计算 
                                              <br>{ 
                                              <br>for(j=0; j&lt;=strlen(shortstring)-i; j++){ 
                                              <br>memcpy(substring, &amp;shortstring[j], i); 
                                              <br>substring[i]='/0'; 
                                              <br>if(strstr(longstring, substring)!=NULL) 
                                              <br>return substring; 
                                              <br>} 
                                              <br>} 
                                              <br>return NULL; 
                                              <br>} 
                                              <br>main() 
                                              <br>{ 
                                              <br>char *str1=malloc(256); 
                                              <br>char *str2=malloc(256); 
                                              <br>char *comman=NULL; 
                                              <br>gets(str1); 
                                              <br>gets(str2); 
                                              <br>if(strlen(str1)&gt;strlen(str2)) //将短的字符串放前面 
                                              <br>comman=commanstring(str2, str1); 
                                              <br>else 
                                              <br>comman=commanstring(str1, str2); 
                                              <br>printf("the longest comman string is: %s/n", comman); 
                                              <br>} 
                                              <br>11.写一个函数比较两个字符串str1 和str2 的大小，若相等返回0，若str1 大于 
                                              <br>str2 返回1，若str1 小于str2 返回－1 
                                              <br>int strcmp ( const char * src,const char * dst) 
                                              <br>{ 
                                              <br>int ret = 0 ; 
                                              <br>while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) &amp;&amp; *dst) 
                                              <br>{ 
                                              <br>++src; 
                                              <br>++dst; 
                                              <br>} 
                                              <br>if ( ret &lt; 0 ) 
                                              <br>ret = -1 ; 
                                              <br>else if ( ret &gt; 0 ) 
                                              <br>ret = 1 ; 
                                              <br>return( ret ); 
                                              <br>} 
                                              <br>3,求1000！的未尾有几个0（用素数相乘的方法来做，如72=2*2*2*3*3）; 
                                              <br>求出1-&gt;1000 里,能被5 整除的数的个数n1,能被25 整除的数的个数n2,能被125 整除的数 
                                              <br>的个数n3, 
                                              <br>能被625 整除的数的个数n4. 
                                              <br>1000!末尾的零的个数=n1+n2+n3+n4; 
                                              <br>#include 
                                               
                                               <br>#define NUM 1000 
                                               <br>int find5(int num){ 
                                               <br>int ret=0; 
                                               <br>while(num%5==0){ 
                                               <br>num/=5; 
                                               <br>ret++; 
                                               <br>} 
                                               <br>return ret; 
                                               <br>} 
                                               <br>int main(){ 
                                               <br>int result=0; 
                                               <br>int i; 
                                               <br>for(i=5;i&lt;=NUM;i+=5) 
                                               <br>{ 
                                               <br>result+=find5(i); 
                                               <br>} 
                                               <br>printf(" the total zero number is %d/n",result); 
                                               <br>return 0; 
                                               <br>} 
                                               <br>1. 有双向循环链表结点定义为： 
                                               <br>struct node 
                                               <br>{ int data; 
                                               <br>struct node *front,*next; 
                                               <br>}; 
                                               <br>有两个双向循环链表A，B，知道其头指针为：pHeadA,pHeadB，请写一函数将两链表中 
                                               <br>data 值相同的结点删除 
                                               <br>BOOL DeteleNode(Node *pHeader, DataType Value) 
                                               <br>{ 
                                               <br>if (pHeader == NULL) return; 
                                               <br>BOOL bRet = FALSE; 
                                               <br>Node *pNode = pHead; 
                                               <br>while (pNode != NULL) 
                                               <br>{ 
                                               <br>if (pNode-&gt;data == Value) 
                                               <br>{ 
                                               <br>if (pNode-&gt;front == NULL) 
                                               <br>{ 
                                               <br>pHeader = pNode-&gt;next; 
                                               <br>pHeader-&gt;front = NULL; 
                                               <br>} 
                                               <br>else 
                                               <br>{ 
                                               <br>if (pNode-&gt;next != NULL) 
                                               <br>{ 
                                               <br>pNode-&gt;next-&gt;front = pNode-&gt;front; 
                                               <br>} 
                                               <br>pNode-&gt;front-&gt;next = pNode-&gt;next; 
                                               <br>} 
                                               <br>Node *pNextNode = pNode-&gt;next; 
                                               <br>delete pNode; 
                                               <br>pNode = pNextNode; 
                                               <br>bRet = TRUE; 
                                               <br>//不要break 或return, 删除所有 
                                               <br>} 
                                               <br>else 
                                               <br>{ 
                                               <br>pNode = pNode-&gt;next; 
                                               <br>} 
                                               <br>} 
                                               <br>return bRet; 
                                               <br>} 
                                               <br>void DE(Node *pHeadA, Node *pHeadB) 
                                               <br>{ 
                                               <br>if (pHeadA == NULL || pHeadB == NULL) 
                                               <br>{ 
                                               <br>return; 
                                               <br>} 
                                               <br>Node *pNode = pHeadA; 
                                               <br>while (pNode != NULL) 
                                               <br>{ 
                                               <br>if (DeteleNode(pHeadB, pNode-&gt;data)) 
                                               <br>{ 
                                               <br>if (pNode-&gt;front == NULL) 
                                               <br>{ 
                                               <br>pHeadA = pNode-&gt;next; 
                                               <br>pHeadA-&gt;front = NULL; 
                                               <br>} 
                                               <br>else 
                                               <br>{ 
                                               <br>pNode-&gt;front-&gt;next = pNode-&gt;next; 
                                               <br>if (pNode-&gt;next != NULL) 
                                               <br>{ 
                                               <br>pNode-&gt;next-&gt;front = pNode-&gt;front; 
                                               <br>} 
                                               <br>} 
                                               <br>Node *pNextNode = pNode-&gt;next; 
                                               <br>delete pNode; 
                                               <br>pNode = pNextNode; 
                                               <br>} 
                                               <br>else 
                                               <br>{ 
                                               <br>pNode = pNode-&gt;next; 
                                               <br>} 
                                               <br>} 
                                               <br>} 
                                               <br>2. 编程实现：找出两个字符串中最大公共子字符串,如"abccade","dgcadde"的最大子串为 
                                               <br>"cad" 
                                               <br>int GetCommon(char *s1, char *s2, char **r1, char **r2) 
                                               <br>{ 
                                               <br>int len1 = strlen(s1); 
                                               <br>int len2 = strlen(s2); 
                                               <br>int maxlen = 0; 
                                               <br>for(int i = 0; i &lt; len1; i++) 
                                               <br>{ 
                                               <br>for(int j = 0; j &lt; len2; j++) 
                                               <br>{ 
                                               <br>if(s1[i] == s2[j]) 
                                               <br>{ 
                                               <br>int as = i, bs = j, count = 1; 
                                               <br>while(as + 1 &lt; len1 &amp;&amp; bs + 1 &lt; len2 &amp;&amp; s1[++as] == s2[++bs]) 
                                               <br>count++; 
                                               <br>if(count &gt; maxlen) 
                                               <br>{ 
                                               <br>maxlen = count; 
                                               <br>*r1 = s1 + i; 
                                               <br>*r2 = s2 + j; 
                                               <br>} 
                                               <br>} 
                                               <br>} 
                                               <br>} 
                                               <br>3. 编程实现：把十进制数(long 型)分别以二进制和十六进制形式输出，不能使用printf 系列 
                                               <br>库函数 
                                               <br>char* test3(long num) { 
                                               <br>char* buffer = (char*)malloc(11); 
                                               <br>buffer[0] = '0'; 
                                               <br>buffer[1] = 'x'; 
                                               <br>buffer[10] = '/0'; 
                                               <br>char* temp = buffer + 2; 
                                               <br>for (int i=0; i &lt; 8; i++) { 
                                               <br>temp[i] = (char)(num&lt;&lt;4*i&gt;&gt;28); 
                                               <br>temp[i] = temp[i] &gt;= 0 ? temp[i] : temp[i] + 16; 
                                               <br>temp[i] = temp[i] &lt; 10 ? temp[i] + 48 : temp[i] + 55; 
                                               <br>} 
                                               <br>return buffer; 
                                               <br>} 
                                               <br>输入N, 打印N*N 矩阵 
                                               <br>比如N = 3，打印： 
                                               <br>1 2 3 
                                               <br>8 9 4 
                                               <br>7 6 5 
                                               <br>N = 4，打印： 
                                               <br>1 2 3 4 
                                               <br>12 13 14 5 
                                               <br>11 16 15 6 
                                               <br>10 9 8 7 
                                               <br>解答： 
                                               <br>1 #define N 15 
                                               <br>int s[N][N]; 
                                               <br>void main() 
                                               <br>{ 
                                               <br>int k = 0, i = 0, j = 0; 
                                               <br>int a = 1; 
                                               <br>for( ; k &lt; (N+1)/2; k++ ) 
                                               <br>{ 
                                               <br>while( j &lt; N-k ) s[i][j++] = a++; i++; j--; 
                                               <br>while( i &lt; N-k ) s[i++][j] = a++; i--; j--; 
                                               <br>while( j &gt; k-1 ) s[i][j--] = a++; i--; j++; 
                                               <br>while( i &gt; k ) s[i--][j] = a++; i++; j++; 
                                               <br>} 
                                               <br>for( i = 0; i &lt; N; i++ ) 
                                               <br>{ 
                                               <br>for( j = 0; j &lt; N; j++ ) 
                                               <br>cout &lt;&lt; s[i][j] &lt;&lt; '/t'; 
                                               <br>cout &lt;&lt; endl; 
                                               <br>} 
                                               <br>} 
                                               <br>2 define MAX_N 100 
                                               <br>int matrix[MAX_N][MAX_N]; 
                                               <br>/* 
                                               <br>*（x,y）：第一个元素的坐标 
                                               <br>* start：第一个元素的值 
                                               <br>* n：矩阵的大小 
                                               <br>*/ 
                                               <br>void SetMatrix(int x, int y, int start, int n) { 
                                               <br>int i, j; 
                                               <br>if (n &lt;= 0) //递归结束条件 
                                               <br>return; 
                                               <br>if (n == 1) { //矩阵大小为1 时 
                                               <br>matrix[x][y] = start; 
                                               <br>return; 
                                               <br>} 
                                               <br>for (i = x; i &lt; x + n-1; i++) //矩阵上部 
                                               <br>matrix[y][i] = start++; 
                                               <br>for (j = y; j &lt; y + n-1; j++) //右部 
                                               <br>matrix[j][x+n-1] = start++; 
                                               <br>for (i = x+n-1; i &gt; x; i--) //底部 
                                               <br>matrix[y+n-1][i] = start++; 
                                               <br>for (j = y+n-1; j &gt; y; j--) //左部 
                                               <br>matrix[j][x] = start++; 
                                               <br>SetMatrix(x+1, y+1, start, n-2); //递归 
                                               <br>} 
                                               <br>void main() { 
                                               <br>int i, j; 
                                               <br>int n; 
                                               <br>scanf("%d", &amp;n); 
                                               <br>SetMatrix(0, 0, 1, n); 
                                               <br>//打印螺旋矩阵 
                                               <br>for(i = 0; i &lt; n; i++) { 
                                               <br>for (j = 0; j &lt; n; j++) 
                                               <br>printf("%4d", matrix[i][j]); 
                                               <br>printf("/n"); 
                                               <br>} 
                                               <br>} 
                                               <br>斐波拉契数列递归实现的方法如下： 
                                               <br>int Funct( int n ) 
                                               <br>{ 
                                               <br>if(n==0) return 1; 
                                               <br>if(n==1) return 1; 
                                               <br>retrurn Funct(n-1) + Funct(n-2); 
                                               <br>} 
                                               <br>请问，如何不使用递归，来实现上述函数？ 
                                               <br>请教各位高手！ 
                                               <br>解答：int Funct( int n ) // n 为非负整数 
                                               <br>{ 
                                               <br>int a=0; 
                                               <br>int b=1; 
                                               <br>int c; 
                                               <br>if(n==0) c=1; 
                                               <br>else if(n==1) c=1; 
                                               <br>else for(int i=2;i&lt;=n;i++) //应该n 从2 开始算起 
                                               <br>{ 
                                               <br>c=a+b; 
                                               <br>a=b; 
                                               <br>b=c; 
                                               <br>} 
                                               <br>return c; 
                                               <br>} 
                                               <br>解答： 
                                               <br>现在大多数系统都是将低字位放在前面，而结构体中位域的申明一般是先声明高位。 
                                               <br>100 的二进制是001 100 100 
                                               <br>低位在前高位在后 
                                               <br>001----s3 
                                               <br>100----s2 
                                               <br>100----s1 
                                               <br>所以结果应该是1 
                                               <br>如果先申明的在低位则： 
                                               <br>001----s1 
                                               <br>100----s2 
                                               <br>100----s3 
                                               <br>结果是4 
                                               <br>1、原题跟little-endian，big-endian 没有关系 
                                               <br>2、原题跟位域的存储空间分配有关，到底是从低字节分配还是从高字节分配，从Dev C++ 
                                               <br>和VC7.1 上看，都是从低字节开始分配，并且连续分配，中间不空，不像谭的书那样会留 
                                               <br>空位 
                                               <br>3、原题跟编译器有关，编译器在未用堆栈空间的默认值分配上有所不同，Dev C++未用空 
                                               <br>间分配为 
                                               <br>01110111b，VC7.1 下为11001100b,所以在Dev C++下的结果为5，在VC7.1 下为1。 
                                               <br>注：PC 一般采用little-endian，即高高低低，但在网络传输上，一般采用big-endian，即高 
                                               <br>低低高，华为是做网络的，所以可能考虑big-endian 模式，这样输出结果可能为4 
                                               <br>判断一个字符串是不是回文 
                                               <br>int IsReverseStr(char *aStr) 
                                               <br>{ 
                                               <br>int i,j; 
                                               <br>int found=1; 
                                               <br>if(aStr==NULL) 
                                               <br>return -1; 
                                               <br>j=strlen(aStr); 
                                               <br>for(i=0;i 
                                               if(*(aStr+i)!=*(aStr+j-i-1)) 
                                               <br>{ 
                                               <br>found=0; 
                                               <br>break; 
                                               <br>} 
                                               <br>return found; 
                                               <br>} 
                                               <br>Josephu 问题为：设编号为1，2，… n 的n 个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的 
                                               <br>人从1 开始报数，数到m 的那个人出列，它的下一位又从1 开始报数，数到m 的那个人又 
                                               <br>出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。 
                                               <br>数组实现： 
                                               <br>#include 
                                                
                                                <br>#include 
                                                 
                                                 <br>int Josephu(int n, int m) 
                                                 <br>{ 
                                                 <br>int flag, i, j = 0; 
                                                 <br>int *arr = (int *)malloc(n * sizeof(int)); 
                                                 <br>for (i = 0; i &lt; n; ++i) 
                                                 <br>arr[i] = 1; 
                                                 <br>for (i = 1; i &lt; n; ++i) 
                                                 <br>{ 
                                                 <br>flag = 0; 
                                                 <br>while (flag &lt; m) 
                                                 <br>{ 
                                                 <br>if (j == n) 
                                                 <br>j = 0; 
                                                 <br>if (arr[j]) 
                                                 <br>++flag; 
                                                 <br>++j; 
                                                 <br>} 
                                                 <br>arr[j - 1] = 0; 
                                                 <br>printf("第%4d 个出局的人是：%4d 号/n", i, j); 
                                                 <br>} 
                                                 <br>free(arr); 
                                                 <br>return j; 
                                                 <br>} 
                                                 <br>int main() 
                                                 <br>{ 
                                                 <br>int n, m; 
                                                 <br>scanf("%d%d", &amp;n, &amp;m); 
                                                 <br>printf("最后胜利的是%d 号！/n", Josephu(n, m)); 
                                                 <br>system("pause"); 
                                                 <br>return 0; 
                                                 <br>} 
                                                 <br>链表实现： 
                                                 <br>#include 
                                                  
                                                  <br>#include 
                                                   
                                                   <br>typedef struct Node 
                                                   <br>{ 
                                                   <br>int index; 
                                                   <br>struct Node *next; 
                                                   <br>}JosephuNode; 
                                                   <br>int Josephu(int n, int m) 
                                                   <br>{ 
                                                   <br>int i, j; 
                                                   <br>JosephuNode *head, *tail; 
                                                   <br>head = tail = (JosephuNode *)malloc(sizeof(JosephuNode)); 
                                                   <br>for (i = 1; i &lt; n; ++i) 
                                                   <br>{ 
                                                   <br>tail-&gt;index = i; 
                                                   <br>tail-&gt;next = (JosephuNode *)malloc(sizeof(JosephuNode)); 
                                                   <br>tail = tail-&gt;next; 
                                                   <br>} 
                                                   <br>tail-&gt;index = i; 
                                                   <br>tail-&gt;next = head; 
                                                   <br>for (i = 1; tail != head; ++i) 
                                                   <br>{ 
                                                   <br>for (j = 1; j &lt; m; ++j) 
                                                   <br>{ 
                                                   <br>tail = head; 
                                                   <br>head = head-&gt;next; 
                                                   <br>} 
                                                   <br>tail-&gt;next = head-&gt;next; 
                                                   <br>printf("第%4d 个出局的人是：%4d 号/n", i, head-&gt;index); 
                                                   <br>free(head); 
                                                   <br>head = tail-&gt;next; 
                                                   <br>} 
                                                   <br>i = head-&gt;index; 
                                                   <br>free(head); 
                                                   <br>return i; 
                                                   <br>} 
                                                   <br>int main() 
                                                   <br>{ 
                                                   <br>int n, m; 
                                                   <br>scanf("%d%d", &amp;n, &amp;m); 
                                                   <br>printf("最后胜利的是%d 号！/n", Josephu(n, m)); 
                                                   <br>system("pause"); 
                                                   <br>return 0; 
                                                   <br>} 
                                                   <br>已知strcpy 函数的原型是： 
                                                   <br>char * strcpy(char * strDest,const char * strSrc); 
                                                   <br>1.不调用库函数，实现strcpy 函数。 
                                                   <br>2.解释为什么要返回char *。 
                                                   <br>解说： 
                                                   <br>1.strcpy 的实现代码 
                                                   <br>char * strcpy(char * strDest,const char * strSrc) 
                                                   <br>{ 
                                                   <br>if ((strDest==NULL)||(strSrc==NULL)) file://[/1] 
                                                   <br>throw "Invalid argument(s)"; //[2] 
                                                   <br>char * strDestCopy=strDest; file://[/3] 
                                                   <br>while ((*strDest++=*strSrc++)!='/0'); file://[/4] 
                                                   <br>return strDestCopy; 
                                                   <br>} 
                                                   <br>错误的做法： 
                                                   <br>[1] 
                                                   <br>(A)不检查指针的有效性，说明答题者不注重代码的健壮性。 
                                                   <br>(B)检查指针的有效性时使用((!strDest)||(!strSrc))或(!(strDest&amp;&amp;strSrc))，说明答题者对 
                                                   <br>C 语言中类型的隐式转换没有深刻认识。在本例中char *转换为bool 即是类型隐式转换， 
                                                   <br>这种功能虽然灵活，但更多的是导致出错概率增大和维护成本升高。所以C++专门增加了 
                                                   <br>bool、true、false 三个关键字以提供更安全的条件表达式。 
                                                   <br>(C)检查指针的有效性时使用((strDest==0)||(strSrc==0))，说明答题者不知道使用常量的 
                                                   <br>好处。直接使用字面常量（如本例中的0）会减少程序的可维护性。0 虽然简单，但程序中 
                                                   <br>可能出现很多处对指针的检查，万一出现笔误，编译器不能发现，生成的程序内含逻辑错误， 
                                                   <br>很难排除。而使用NULL 代替0，如果出现拼写错误，编译器就会检查出来。 
                                                   <br>[2] 
                                                   <br>(A)return new string("Invalid argument(s)");，说明答题者根本不知道返回值的用途，并 
                                                   <br>且他对内存泄漏也没有警惕心。从函数中返回函数体内分配的内存是十分危险的做法，他把 
                                                   <br>释放内存的义务抛给不知情的调用者，绝大多数情况下，调用者不会释放内存，这导致内存 
                                                   <br>泄漏。 
                                                   <br>(B)return 0;，说明答题者没有掌握异常机制。调用者有可能忘记检查返回值，调用者还 
                                                   <br>可能无法检查返回值（见后面的链式表达式）。妄想让返回值肩负返回正确值和异常值的双 
                                                   <br>重功能，其结果往往是两种功能都失效。应该以抛出异常来代替返回值，这样可以减轻调用 
                                                   <br>者的负担、使错误不会被忽略、增强程序的可维护性。 
                                                   <br>[3] 
                                                   <br>(A)忘记保存原始的strDest 值，说明答题者逻辑思维不严密。 
                                                   <br>[4] 
                                                   <br>(A)循环写成while (*strDest++=*strSrc++);，同[1](B)。 
                                                   <br>(B)循环写成while (*strSrc!='/0') *strDest++=*strSrc++;，说明答题者对边界条件的检查 
                                                   <br>不力。循环体结束后，strDest 字符串的末尾没有正确地加上'/0'。 
                                                   <br>一、请填写BOOL , float, 指针变量与“零值”比较的if 语句。(10 分) 
                                                   <br>请写出BOOL flag 与“零值”比较的if 语句。(3 分) 
                                                   <br>标准答案： 
                                                   <br>if ( flag ) 
                                                   <br>if ( !flag ) 如下写法均属不良风格，不得分。 
                                                   <br>if (flag == TRUE) 
                                                   <br>if (flag == 1 ) 
                                                   <br>if (flag == FALSE) 
                                                   <br>if (flag == 0) 
                                                   <br>请写出float x 与“零值”比较的if 语句。(4 分) 
                                                   <br>标准答案示例： 
                                                   <br>const float EPSINON = 0.00001; 
                                                   <br>if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON) 
                                                   <br>不可将浮点变量用“==”或“！=”与数字比较，应该设法转化成“&gt;=”或“&lt;=”此类 
                                                   <br>形式。 
                                                   <br>如下是错误的写法，不得分。 
                                                   <br>if (x == 0.0) 
                                                   <br>if (x != 0.0) 
                                                   <br>请写出char *p 与“零值”比较的if 语句。(3 分) 
                                                   <br>标准答案： 
                                                   <br>if (p == NULL) 
                                                   <br>if (p != NULL) 如下写法均属不良风格，不得分。 
                                                   <br>if (p == 0) 
                                                   <br>if (p != 0) 
                                                   <br>if (p) 
                                                   <br>if (!) 
                                                   <br>二、以下为Windows NT 下的32 位C++程序，请计算sizeof 的值(10 分) 
                                                   <br>char str[] = “Hello” ; 
                                                   <br>char *p = str ; 
                                                   <br>int n = 10; 
                                                   <br>请计算 
                                                   <br>sizeof (str ) = 6 (2 分) 
                                                   <br>sizeof ( p ) = 4 (2 分) 
                                                   <br>sizeof ( n ) = 4 (2 分) void Func ( char str[100]) 
                                                   <br>{ 
                                                   <br>请计算 
                                                   <br>sizeof( str ) = 4 (2 分) 
                                                   <br>} 
                                                   <br>void *p = malloc( 100 ); 
                                                   <br>请计算 
                                                   <br>sizeof ( p ) = 4 (2 分) 
                                                   <br>三、简答题(25 分) 
                                                   <br>1、头文件中的ifndef/define/endif 干什么用？(5 分) 
                                                   <br>答：防止该头文件被重复引用。 
                                                   <br>2、#include? 和#include “filename.h” 有什么区别？(5 分) 
                                                   <br>答：对于#include? ，编译器从标准库路径开始搜索filename.h 
                                                   <br>对于#include “filename.h” ，编译器从用户的工作路径开始搜索filename.h 
                                                   <br>3、const 有什么用途？(请至少说明两种)(5 分) 
                                                   <br>答：(1)可以定义const 常量 
                                                   <br>(2)const 可以修饰函数的参数、返回值，甚至函数的定义体。被const 修饰的东西都 
                                                   <br>受到 
                                                   <br>强制保护，可以预防意外的变动，能提高程序的健壮性。 
                                                   <br>4、在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？ (5 分 
                                                   <br>) 
                                                   <br>答：C++语言支持函数重载，C 语言不支持函数重载。函数被C++编译后在库中的名字 
                                                   <br>与 
                                                   <br>C 语言 
                                                   <br>的不同。假设某个函数的原型为： void foo(int x, int y); 
                                                   <br>该函数被C 编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int 
                                                   <br>之类的 
                                                   <br>名字。 
                                                   <br>C++提供了C 连接交换指定符号extern“C”来解决名字匹配问题。 
                                                   <br>5、请简述以下两个for 循环的优缺点(5 分) 
                                                   <br>for (i=0; i＜N; i++) 
                                                   <br>{ 
                                                   <br>if (condition) 
                                                   <br>DoSomething(); 
                                                   <br>else 
                                                   <br>DoOtherthing(); 
                                                   <br>} 
                                                   <br>if (condition) 
                                                   <br>{ 
                                                   <br>for (i=0; i＜N; i++) 
                                                   <br>DoSomething(); 
                                                   <br>} 
                                                   <br>else 
                                                   <br>{ 
                                                   <br>for (i=0; i＜N; i++) 
                                                   <br>DoOtherthing(); 
                                                   <br>} 
                                                   <br>优点：程序简洁 
                                                   <br>缺点：多执行了N-1 次逻辑判断，并且打断了循环“流水线”作业，使得编译器不能 
                                                   <br>对循环进行优化处理，降低了效率。优点：循环的效率高 
                                                   <br>缺点：程序不简洁 
                                                   <br>四、有关内存的思考题(每小题5 分，共20 分) 
                                                   <br>void GetMemory(char *p) 
                                                   <br>{ 
                                                   <br>p = (char *)malloc(100); 
                                                   <br>} 
                                                   <br>void Test(void) 
                                                   <br>{ 
                                                   <br>char *str = NULL; 
                                                   <br>GetMemory(str); 
                                                   <br>strcpy(str, "hello world"); 
                                                   <br>printf(str); 
                                                   <br>} 
                                                   <br>请问运行Test 函数会有什么样的结果？ 
                                                   <br>答：程序崩溃。 
                                                   <br>因为GetMemory 并不能传递动态内存， 
                                                   <br>Test 函数中的str 一直都是NULL。 
                                                   <br>strcpy(str, "hello world");将使程序崩溃。 
                                                   <br>char *GetMemory(void) 
                                                   <br>{ 
                                                   <br>char p[] = "hello world"; 
                                                   <br>return p; 
                                                   <br>} 
                                                   <br>void Test(void) 
                                                   <br>{ 
                                                   <br>char *str = NULL; 
                                                   <br>str = GetMemory(); 
                                                   <br>printf(str); 
                                                   <br>} 
                                                   <br>请问运行Test 函数会有什么样的结果？ 
                                                   <br>答：可能是乱码。 
                                                   <br>因为GetMemory 返回的是指向“栈内存”的指针，该指针的地址不是NULL，但其原现 
                                                   <br>的 
                                                   <br>内容已经被清除，新内容不可知。 
                                                   <br>void GetMemory2(char **p, int num) 
                                                   <br>{ 
                                                   <br>*p = (char *)malloc(num); 
                                                   <br>} 
                                                   <br>void Test(void) 
                                                   <br>{ 
                                                   <br>char *str = NULL; 
                                                   <br>GetMemory(&amp;str, 100); 
                                                   <br>strcpy(str, "hello"); 
                                                   <br>printf(str); 
                                                   <br>} 
                                                   <br>请问运行Test 函数会有什么样的结果？ 
                                                   <br>答： 
                                                   <br>(1)能够输出hello 
                                                   <br>(2)内存泄漏 
                                                   <br>void Test(void) 
                                                   <br>{ 
                                                   <br>char *str = (char *) malloc(100); 
                                                   <br>strcpy(str, “hello”); 
                                                   <br>free(str); 
                                                   <br>if(str != NULL) 
                                                   <br>{ 
                                                   <br>strcpy(str, “world”); 
                                                   <br>printf(str); 
                                                   <br>} 
                                                   <br>} 
                                                   <br>请问运行Test 函数会有什么样的结果？ 
                                                   <br>答：篡改动态内存区的内容，后果难以预料，非常危险。 
                                                   <br>因为free(str);之后，str 成为野指针， 
                                                   <br>if(str != NULL)语句不起作用。 
                                                   <br>五、编写strcpy 函数(10 分) 
                                                   <br>已知strcpy 函数的原型是 
                                                   <br>char *strcpy(char *strDest, const char *strSrc); 
                                                   <br>其中strDest 是目的字符串，strSrc 是源字符串。 
                                                   <br>(1)不调用C++/C 的字符串库函数，请编写函数strcpy 
                                                   <br>char *strcpy(char *strDest, const char *strSrc); 
                                                   <br>{ 
                                                   <br>assert((strDest!=NULL) &amp;&amp; (strSrc !=NULL)); // 2 分 
                                                   <br>char *address = strDest; // 2 分 
                                                   <br>while( (*strDest++ = * strSrc++) != '/0’ ) // 2 分 
                                                   <br>NULL ; 
                                                   <br>return address ; // 2 分 
                                                   <br>} 
                                                   <br>(2)strcpy 能把strSrc 的内容复制到strDest，为什么还要char * 类型的返回值？ 
                                                   <br>答：为了实现链式表达式。// 2 分 
                                                   <br>例如int length = strlen( strcpy( strDest, “hello world”) ); 
                                                   <br>六、编写类String 的构造函数、析构函数和赋值函数(25 分) 
                                                   <br>已知类String 的原型为： 
                                                   <br>class String 
                                                   <br>{ 
                                                   <br>public: 
                                                   <br>String(const char *str = NULL); // 普通构造函数 
                                                   <br>String(const String &amp;other); // 拷贝构造函数 
                                                   <br>~ String(void); // 析构函数 
                                                   <br>String &amp; operate =(const String &amp;other); // 赋值函数 
                                                   <br>private: 
                                                   <br>char *m_data; // 用于保存字符串 
                                                   <br>}; 
                                                   <br>请编写String 的上述4 个函数。 
                                                   <br>标准答案： 
                                                   <br>// String 的析构函数 
                                                   <br>String::~String(void) // 3 分 
                                                   <br>{ 
                                                   <br>delete [] m_data; 
                                                   <br>// 由于m_data 是内部数据类型，也可以写成delete m_data; 
                                                   <br>} 
                                                   <br>// String 的普通构造函数 
                                                   <br>String::String(const char *str) // 6 分 
                                                   <br>{ 
                                                   <br>if(str==NULL) 
                                                   <br>{ 
                                                   <br>m_data = new char[1]; // 若能加NULL 判断则更好 
                                                   <br>*m_data = '/0’; 
                                                   <br>} 
                                                   <br>else 
                                                   <br>{ 
                                                   <br>int length = strlen(str); 
                                                   <br>m_data = new char[length+1]; // 若能加NULL 判断则更好 
                                                   <br>strcpy(m_data, str); 
                                                   <br>} 
                                                   <br>} 
                                                   <br>// 拷贝构造函数 
                                                   <br>String::String(const String &amp;other) // 3 分 
                                                   <br>{ 
                                                   <br>int length = strlen(other.m_data); 
                                                   <br>m_data = new char[length+1]; // 若能加NULL 判断则更好 
                                                   <br>strcpy(m_data, other.m_data); 
                                                   <br>} 
                                                   <br>// 赋值函数 
                                                   <br>String &amp; String::operate =(const String &amp;other) // 13 分 
                                                   <br>{ 
                                                   <br>// (1) 检查自赋值// 4 分 
                                                   <br>if(this == &amp;other) 
                                                   <br>return *this; 
                                                   <br>// (2) 释放原有的内存资源// 3 分 
                                                   <br>delete [] m_data; 
                                                   <br>// (3)分配新的内存资源，并复制内容// 3 分 
                                                   <br>int length = strlen(other.m_data); 
                                                   <br>m_data = new char[length+1]; // 若能加NULL 判断则更好 
                                                   <br>strcpy(m_data, other.m_data); 
                                                   <br>// (4)返回本对象的引用// 3 分 
                                                   <br>1、内存分配方式 
                                                   <br>内存分配方式有三种： 
                                                   <br>（1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的 
                                                   <br>整个运行期间都存在。例如全局变量，static 变量。 
                                                   <br>（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函 
                                                   <br>数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很 
                                                   <br>高，但是分配的内存容量有限。 
                                                   <br>（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意 
                                                   <br>多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由我们 
                                                   <br>决定，使用非常灵活，但问题也最多。 
                                                   <br>2、常见的内存错误及其对策 
                                                   <br>发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行 
                                                   <br>时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户 
                                                   <br>怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。常见的内存错 
                                                   <br>误及其对策如下： 
                                                   <br>* 内存分配未成功，却使用了它。 
                                                   <br>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在 
                                                   <br>使用内存之前检查指针是否为NULL。如果指针p 是函数的参数，那么在函数的入口处用a 
                                                   <br>ssert(p!=NULL)进行 
                                                   <br>检查。如果是用malloc 或new 来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行 
                                                   <br>防错处理。 
                                                   <br>* 内存分配虽然成功，但是尚未初始化就引用它。 
                                                   <br>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为 
                                                   <br>零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽 
                                                   <br>管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了 
                                                   <br>赋初值，即便是赋零值也不可省略，不要嫌麻烦。 
                                                   <br>* 内存分配成功并且已经初始化，但操作越过了内存的边界。 
                                                   <br>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for 循环语句中，循 
                                                   <br>环次数很容易搞错，导致数组操作越界。 
                                                   <br>* 忘记了释放内存，造成内存泄露。 
                                                   <br>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不 
                                                   <br>到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。 
                                                   <br>动态内存的申请与释放必须配对，程序中malloc 与free 的使用次数一定要相同，否则 
                                                   <br>肯定有错误（new/delete 同理）。 
                                                   <br>* 释放了内存却继续使用它。 
                                                   <br>有三种情况： 
                                                   <br>（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了 
                                                   <br>内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。 
                                                   <br>（2）函数的return 语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为 
                                                   <br>该内存在函数体结束时被自动销毁。 
                                                   <br>（3）使用free 或delete 释放了内存后，没有将指针设置为NULL。导致产生“野指针”。 
                                                   <br>【规则1】用malloc 或new 申请内存之后，应该立即检查指针值是否为NULL。防止 
                                                   <br>使用指针值为NULL 的内存。 
                                                   <br>【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 
                                                   <br>【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。 
                                                   <br>【规则4】动态内存的申请与释放必须配对，防止内存泄漏。 
                                                   <br>【规则5】用free 或delete 释放了内存之后，立即将指针设置为NULL，防止产生“野 
                                                   <br>指针”。 
                                                   <br>3、指针与数组的对比 
                                                   <br>C++/C 程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为 
                                                   <br>两者是等价的。 
                                                   <br>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而 
                                                   <br>不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。 
                                                   <br>指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动 
                                                   <br>态内存。指针远比数组灵活，但也更危险。 
                                                   <br>下面以字符串为例比较指针与数组的特性。 
                                                   <br>3.1 修改内容 
                                                   <br>示例3-1 中，字符数组a 的容量是6 个字符，其内容为hello。a 的内容可以改变，如a 
                                                   <br>[0]= 'X’。指针p 指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的 
                                                   <br>内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= 'X’有什么不妥，但是该 
                                                   <br>语句企图修改常量字符串的内容而导致运行错误。 
                                                   <br>char a[] = “hello”; 
                                                   <br>a[0] = 'X’; 
                                                   <br>cout &lt;&lt; a &lt;&lt; endl; 
                                                   <br>char *p = “world”; // 注意p 指向常量字符串 
                                                   <br>p[0] = 'X’; // 编译器不能发现该错误 
                                                   <br>cout &lt;&lt; p &lt;&lt; endl; 
                                                   <br>示例3.1 修改数组和指针的内容 
                                                   <br>3.2 内容复制与比较 
                                                   <br>不能对数组名进行直接复制与比较。示例7-3-2 中，若想把数组a 的内容复制给数组b， 
                                                   <br>不能用语句b = a ，否则将产生编译错误。应该用标准库函数strcpy 进行复制。同理，比 
                                                   <br>较b 和a 的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp 进行比较。 
                                                   <br>语句p = a 并不能把a 的内容复制指针p，而是把a 的地址赋给了p。要想复制a 的 
                                                   <br>内容，可以先用库函数malloc 为p 申请一块容量为strlen(a)+1 个字符的内存，再用strcpy 
                                                   <br>进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp 来 
                                                   <br>比较。 
                                                   <br>// 数组… 
                                                   <br>char a[] = "hello"; 
                                                   <br>char b[10]; 
                                                   <br>strcpy(b, a); // 不能用b = a; 
                                                   <br>if(strcmp(b, a) == 0) // 不能用if (b == a) 
                                                   <br>… 
                                                   <br>// 指针… 
                                                   <br>int len = strlen(a); 
                                                   <br>char *p = (char *)malloc(sizeof(char)*(len+1)); 
                                                   <br>strcpy(p,a); // 不要用p = a; 
                                                   <br>if(strcmp(p, a) == 0) // 不要用if (p == a) 
                                                   <br>… 
                                                   <br>示例3.2 数组和指针的内容复制与比较 
                                                   <br>3.3 计算内存容量 
                                                   <br>用运算符sizeof 可以计算出数组的容量（字节数）。示例7-3-3（a）中，sizeof(a)的 
                                                   <br>值是12（注意别忘了’’）。指针p 指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得 
                                                   <br>到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p 所指的内存容量。C++/C 
                                                   <br>语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。 
                                                   <br>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。示例7-3-3 
                                                   <br>（b）中，不论数组a 的容量是多少，sizeof(a)始终等于sizeof(char *)。 
                                                   <br>char a[] = "hello world"; 
                                                   <br>char *p = a; 
                                                   <br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节 
                                                   <br>cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节 
                                                   <br>示例3.3（a） 计算数组和指针的内存容量 
                                                   <br>void Func(char a[100]) 
                                                   <br>{ 
                                                   <br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节 
                                                   <br>} 
                                                   <br>示例3.3（b） 数组退化为指针 
                                                   <br>4、指针参数是如何传递内存的？ 
                                                   <br>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。示例7-4-1 中，Test 
                                                   <br>函数的语句GetMemory(str, 200)并没有使str 获得期望的内存，str 依旧是NULL，为什么？ 
                                                   <br>void GetMemory(char *p, int num) 
                                                   <br>{ 
                                                   <br>p = (char *)malloc(sizeof(char) * num); 
                                                   <br>} 
                                                   <br>void Test(void) 
                                                   <br>{ 
                                                   <br>char *str = NULL; 
                                                   <br>GetMemory(str, 100); // str 仍然为NULL 
                                                   <br>strcpy(str, "hello"); // 运行错误 
                                                   <br>} 
                                                   <br>示例4.1 试图用指针参数申请动态内存 
                                                   <br>毛病出在函数GetMemory 中。编译器总是要为函数的每个参数制作临时副本，指针参 
                                                   <br>数p 的副本是_p，编译器使_p = p。如果函数体内的程序修改了_p 的内容，就导致参数 
                                                   <br>p 的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p 申请了新的 
                                                   <br>内存，只是把_p 所指的内存地址改变了，但是p 丝毫未变。所以函数GetMemory 并不能 
                                                   <br>输出任何东西。事实上，每执行一次GetMemory 就会泄露一块内存，因为没有用free 释放 
                                                   <br>内存。 
                                                   <br>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例4.2。 
                                                   <br>void GetMemory2(char **p, int num) 
                                                   <br>{ 
                                                   <br>*p = (char *)malloc(sizeof(char) * num); 
                                                   <br>} 
                                                   <br>void Test2(void) 
                                                   <br>{ 
                                                   <br>char *str = NULL; 
                                                   <br>GetMemory2(&amp;str, 100); // 注意参数是&amp;str，而不是str 
                                                   <br>strcpy(str, "hello"); 
                                                   <br>cout&lt;&lt; str &lt;&lt; endl; 
                                                   <br>free(str); 
                                                   <br>} 
                                                   <br>示例4.2 用指向指针的指针申请动态内存 
                                                   <br>由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。 
                                                   <br>这种方法更加简单，见示例4.3。 
                                                   <br>char *GetMemory3(int num) 
                                                   <br>{ 
                                                   <br>char *p = (char *)malloc(sizeof(char) * num); 
                                                   <br>return p; 
                                                   <br>} 
                                                   <br>void Test3(void) 
                                                   <br>{ 
                                                   <br>char *str = NULL; 
                                                   <br>str = GetMemory3(100); 
                                                   <br>strcpy(str, "hello"); 
                                                   <br>cout&lt;&lt; str &lt;&lt; endl; 
                                                   <br>free(str); 
                                                   <br>} 
                                                   <br>示例4.3 用函数返回值来传递动态内存 
                                                   <br>用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return 语句用错了。 
                                                   <br>这里强调不要用return 语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡， 
                                                   <br>见示例4.4。 
                                                   <br>char *GetString(void) 
                                                   <br>{ 
                                                   <br>char p[] = "hello world"; 
                                                   <br>return p; // 编译器将提出警告 
                                                   <br>} 
                                                   <br>void Test4(void) 
                                                   <br>{ 
                                                   <br>char *str = NULL; 
                                                   <br>str = GetString(); // str 的内容是垃圾 
                                                   <br>cout&lt;&lt; str &lt;&lt; endl; 
                                                   <br>} 
                                                   <br>示例4.4 return 语句返回指向“栈内存”的指针 
                                                   <br>用调试器逐步跟踪Test4，发现执行str = GetString 语句后str 不再是NULL 指针，但 
                                                   <br>是str 的内容不是“hello world”而是垃圾。 
                                                   <br>如果把示例4.4 改写成示例4.5，会怎么样？ 
                                                   <br>char *GetString2(void) 
                                                   <br>{ 
                                                   <br>char *p = "hello world"; 
                                                   <br>return p; 
                                                   <br>} 
                                                   <br>void Test5(void) 
                                                   <br>{ 
                                                   <br>char *str = NULL; 
                                                   <br>str = GetString2(); 
                                                   <br>cout&lt;&lt; str &lt;&lt; endl; 
                                                   <br>} 
                                                   <br>示例4.5 return 语句返回常量字符串 
                                                   <br>函数Test5 运行虽然不会出错，但是函数GetString2 的设计概念却是错误的。因为Ge 
                                                   <br>tString2 内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。 
                                                   <br>无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。 
                                                   <br>5、杜绝“野指针” 
                                                   <br>“野指针”不是NULL 指针，是指向“垃圾”内存的指针。人们一般不会错用NULL 指针， 
                                                   <br>因为用if 语句很容易判断。但是“野指针”是很危险的，if 语句对它不起作用。“野指针”的成 
                                                   <br>因主要有两种： 
                                                   <br>（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL 指针，它 
                                                   <br>的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指 
                                                   <br>针设置为NULL，要么让它指向合法的内存。例如 
                                                   <br>char *p = NULL; 
                                                   <br>char *str = (char *) malloc(100); 
                                                   <br>（2）指针p 被free 或者delete 之后，没有置为NULL，让人误以为p 是个合法的指针。 
                                                   <br>（3）指针操作超越了变量的作用范围。这种情况让人防不胜防，示例程序如下： 
                                                   <br>class A 
                                                   <br>{ 
                                                   <br>public: 
                                                   <br>void Func(void){ cout &lt;&lt; “Func of class A” &lt;&lt; endl; } 
                                                   <br>}; 
                                                   <br>void Test(void) 
                                                   <br>{ 
                                                   <br>A *p; 
                                                   <br>{ 
                                                   <br>A a; 
                                                   <br>p = &amp;a; // 注意a 的生命期 
                                                   <br>} 
                                                   <br>p-&gt;Func(); // p 是“野指针” 
                                                   <br>} 
                                                   <br>函数Test 在执行语句p-&gt;Func()时，对象a 已经消失，而p 是指向a 的，所以p 就成 
                                                   <br>了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。 
                                                   <br>6、有了malloc/free为什么还要new/delete？ 
                                                   <br>malloc 与free 是C++/C 语言的标准库函数，new/delete 是C++的运算符。它们都可用 
                                                   <br>于申请动态内存和释放内存。 
                                                   <br>对于非内部数据类型的对象而言，光用maloc/free 无法满足动态对象的要求。对象在 
                                                   <br>创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free 
                                                   <br>是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任 
                                                   <br>务强加于malloc/free。 
                                                   <br>因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能 
                                                   <br>完成清理与释放内存工作的运算符delete。注意new/delete 不是库函数。我们先看一看ma 
                                                   <br>lloc/free 和new/delete 如何实现对象的动态内存管理，见示例6。 
                                                   <br>class Obj 
                                                   <br>{ 
                                                   <br>public : 
                                                   <br>Obj(void){ cout &lt;&lt; “Initialization” &lt;&lt; endl; } 
                                                   <br>~Obj(void){ cout &lt;&lt; “Destroy” &lt;&lt; endl; } 
                                                   <br>void Initialize(void){ cout &lt;&lt; “Initialization” &lt;&lt; endl; } 
                                                   <br>void Destroy(void){ cout &lt;&lt; “Destroy” &lt;&lt; endl; } 
                                                   <br>}; 
                                                   <br>void UseMallocFree(void) 
                                                   <br>{ 
                                                   <br>Obj *a = (obj *)malloc(sizeof(obj)); // 申请动态内存 
                                                   <br>a-&gt;Initialize(); // 初始化 
                                                   <br>//… 
                                                   <br>a-&gt;Destroy(); // 清除工作 
                                                   <br>free(a); // 释放内存 
                                                   <br>} 
                                                   <br>void UseNewDelete(void) 
                                                   <br>{ 
                                                   <br>Obj *a = new Obj; // 申请动态内存并且初始化 
                                                   <br>//… 
                                                   <br>delete a; // 清除并且释放内存 
                                                   <br>} 
                                                   <br>示例6 用malloc/free 和new/delete 如何实现对象的动态内存管理 
                                                   <br>类Obj 的函数Initialize 模拟了构造函数的功能，函数Destroy 模拟了析构函数的功能。 
                                                   <br>函数UseMallocFree 中，由于malloc/free 不能执行构造函数与析构函数，必须调用成员函 
                                                   <br>数Initialize 和Destroy 来完成初始化与清除工作。函数UseNewDelete 则简单得多。 
                                                   <br>所以我们不要企图用malloc/free 来完成动态对象的内存管理，应该用new/delete。由 
                                                   <br>于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free 和new/delete 是 
                                                   <br>等价的。 
                                                   <br>既然new/delete 的功能完全覆盖了malloc/free，为什么C++不把malloc/free 淘汰出局 
                                                   <br>呢？这是因为C++程序经常要调用C 函数，而C 程序只能用malloc/free 管理动态内存。 
                                                   <br>如果用free 释放“new 创建的动态对象”，那么该对象因无法执行析构函数而可能导致程 
                                                   <br>序出错。如果用delete 释放“malloc 申请的动态内存”，理论上讲程序不会出错，但是该程序 
                                                   <br>的可读性很差。所以new/delete 必须配对使用，malloc/free 也一样。 
                                                   <br>7、内存耗尽怎么办？ 
                                                   <br>如果在申请动态内存时找不到足够大的内存块，malloc 和new 将返回NULL 指针，宣 
                                                   <br>告内存申请失败。通常有三种方式处理“内存耗尽”问题。 
                                                   <br>（1）判断指针是否为NULL，如果是则马上用return 语句终止本函数。例如： 
                                                   <br>void Func(void) 
                                                   <br>{ 
                                                   <br>A *a = new A; 
                                                   <br>if(a == NULL) 
                                                   <br>{ 
                                                   <br>return; 
                                                   <br>} 
                                                   <br>… 
                                                   <br>} 
                                                   <br>（2）判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。例如： 
                                                   <br>void Func(void) 
                                                   <br>{ 
                                                   <br>A *a = new A; 
                                                   <br>if(a == NULL) 
                                                   <br>{ 
                                                   <br>cout &lt;&lt; “Memory Exhausted” &lt;&lt; endl; 
                                                   <br>exit(1); 
                                                   <br>} 
                                                   <br>… 
                                                   <br>} 
                                                   <br>（3）为new 和malloc 设置异常处理函数。例如Visual C++可以用_set_new_hander 
                                                   <br>函数为new 设置用户自己定义的异常处理函数，也可以让malloc 享用与new 相同的异常 
                                                   <br>处理函数。详细内容请参考C++使用手册。 
                                                   <br>上述（1）（2）方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方 
                                                   <br>式（1）就显得力不从心（释放内存很麻烦），应该用方式（2）来处理。 
                                                   <br>很多人不忍心用exit(1)，问：“不编写出错处理程序，让操作系统自己解决行不行？” 
                                                   <br>不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用e 
                                                   <br>xit(1) 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死 
                                                   <br>之前会犯下更多的罪。 
                                                   <br>有一个很重要的现象要告诉大家。对于32 位以上的应用程序而言，无论怎样使用mal 
                                                   <br>loc 与new，几乎不可能导致“内存耗尽”。我在Windows 98 下用Visual C++编写了测试程 
                                                   <br>序，见示例7。这个程序会无休止地运行下去，根本不会终止。因为32 位操作系统支持“虚 
                                                   <br>存”，内存用完了，自动用硬盘空间顶替。我只听到硬盘嘎吱嘎吱地响，Window 98 已经累 
                                                   <br>得对键盘、鼠标毫无反应。 
                                                   <br>我可以得出这么一个结论：对于32 位以上的应用程序，“内存耗尽”错误处理程序毫无 
                                                   <br>用处。这下可把Unix 和Windows 程序员们乐坏了：反正错误处理程序不起作用，我就不 
                                                   <br>写了，省了很多麻烦。 
                                                   <br>我不想误导读者，必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。 
                                                   <br>void main(void) 
                                                   <br>{ 
                                                   <br>float *p = NULL; 
                                                   <br>while(TRUE) 
                                                   <br>{ 
                                                   <br>p = new float[1000000]; 
                                                   <br>cout &lt;&lt; “eat memory” &lt;&lt; endl; 
                                                   <br>if(p==NULL) 
                                                   <br>exit(1); 
                                                   <br>} 
                                                   <br>} 
                                                   <br>示例7 试图耗尽操作系统的内存 
                                                   <br>8、malloc/free 的使用要点 
                                                   <br>函数malloc 的原型如下： 
                                                   <br>void * malloc(size_t size); 
                                                   <br>用malloc 申请一块长度为length 的整数类型的内存，程序如下： 
                                                   <br>int *p = (int *) malloc(sizeof(int) * length); 
                                                   <br>我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。 
                                                   <br>* malloc 返回值的类型是void *，所以在调用malloc 时要显式地进行类型转换，将vo 
                                                   <br>id * 转换成所需要的指针类型。 
                                                   <br>* malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们 
                                                   <br>通常记不住int, float 等数据类型的变量的确切字节数。例如int 变量在16 位系统下是2 个 
                                                   <br>字节，在32 位下是4 个字节；而float 变量在16 位系统下是4 个字节，在32 位下也是4 
                                                   <br>个字节。最好用以下程序作一次测试： 
                                                   <br>cout &lt;&lt; sizeof(char) &lt;&lt; endl; 
                                                   <br>cout &lt;&lt; sizeof(int) &lt;&lt; endl; 
                                                   <br>cout &lt;&lt; sizeof(unsigned int) &lt;&lt; endl; 
                                                   <br>cout &lt;&lt; sizeof(long) &lt;&lt; endl; 
                                                   <br>cout &lt;&lt; sizeof(unsigned long) &lt;&lt; endl; 
                                                   <br>cout &lt;&lt; sizeof(float) &lt;&lt; endl; 
                                                   <br>cout &lt;&lt; sizeof(double) &lt;&lt; endl; 
                                                   <br>cout &lt;&lt; sizeof(void *) &lt;&lt; endl; 
                                                   <br>在malloc 的“()”中使用sizeof 运算符是良好的风格，但要当心有时我们会昏了头，写出 
                                                   <br>p = malloc(sizeof(p))这样的程序来。 
                                                   <br>* 函数free 的原型如下： 
                                                   <br>void free( void * memblock ); 
                                                   <br>为什么free 函数不象malloc 函数那样复杂呢？这是因为指针p 的类型以及它所指的内 
                                                   <br>存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p 是NULL 指针，那么fr 
                                                   <br>ee 对p 无论操作多少次都不会出问题。如果p 不是NULL 指针，那么free 对p 连续操作两 
                                                   <br>次就会导致程序运行错误。 
                                                   <br>9、new/delete 的使用要点 
                                                   <br>运算符new 使用起来要比函数malloc 简单得多，例如： 
                                                   <br>int *p1 = (int *)malloc(sizeof(int) * length); 
                                                   <br>int *p2 = new int[length]; 
                                                   <br>这是因为new 内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的 
                                                   <br>对象而言，new 在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那 
                                                   <br>么new 的语句也可以有多种形式。例如 
                                                   <br>class Obj 
                                                   <br>{ 
                                                   <br>public : 
                                                   <br>Obj(void); // 无参数的构造函数 
                                                   <br>Obj(int x); // 带一个参数的构造函数 
                                                   <br>… 
                                                   <br>} 
                                                   <br>void Test(void) 
                                                   <br>{ 
                                                   <br>Obj *a = new Obj; 
                                                   <br>Obj *b = new Obj(1); // 初值为1 
                                                   <br>… 
                                                   <br>delete a; 
                                                   <br>delete b; 
                                                   <br>} 
                                                   <br>如果用new 创建对象数组，那么只能使用对象的无参数构造函数。例如 
                                                   <br>Obj *objects = new Obj[100]; // 创建100 个动态对象 
                                                   <br>不能写成 
                                                   <br>Obj *objects = new Obj[100](1);// 创建100 个动态对象的同时赋初值1 
                                                   <br>在用delete 释放对象数组时，留意不要丢了符号'[]’。例如 
                                                   <br>delete []objects; // 正确的用法 
                                                   <br>delete objects; // 错误的用法 
                                                   <br>后者相当于delete objects[0]，漏掉了另外99 个对象。 
                                                   <br>10、一些心得体会 
                                                   <br>我认识不少技术不错的C++/C 程序员，很少有人能拍拍胸脯说通晓指针与内存管理（包 
                                                   <br>括我自己）。我最初学习C 语言时特别怕指针，导致我开发第一个应用软件（约1 万行C 
                                                   <br>代码）时没有使用一个指针，全用数组来顶替指针，实在蠢笨得过分。躲避指针不是办法， 
                                                   <br>后来我改写了这个软件，代码量缩小到原先的一半。 
                                                   <br>我的经验教训是： 
                                                   <br>（1）越是怕指针，就越要使用指针。不会正确使用指针，肯定算不上是合格的程序员。 
                                                   <br>（2）必须养成“使用调试器逐步跟踪程序”的习惯，只有这样才能发现问题的本质。 
                                                   <br>strlen 与sizeof 的区别 
                                                   <br>--------------------- 
                                                   <br>1.sizeof 操作符的结果类型是size_t，它在头文件中typedef 为unsigned int 类型。 
                                                   <br>该类型保证能容纳实现所建立的最大对象的字节大小。 
                                                   <br>2.sizeof 是算符，strlen 是函数。 
                                                   <br>3.sizeof 可以用类型做参数，strlen 只能用char*做参数，且必须是以''/0''结尾的。 
                                                   <br>sizeof 还可以用函数做参数，比如： 
                                                   <br>short f(); 
                                                   <br>printf("%d/n", sizeof(f())); 
                                                   <br>输出的结果是sizeof(short)，即2。 
                                                   <br>4.数组做sizeof 的参数不退化，传递给strlen 就退化为指针了。 
                                                   <br>5.大部分编译程序在编译的时候就把sizeof 计算过了是类型或是变量的长度这就是 
                                                   <br>sizeof(x)可以用来定义数组维数的原因 
                                                   <br>char str[20]="0123456789"; 
                                                   <br>int a=strlen(str); //a=10; 
                                                   <br>int b=sizeof(str); //而b=20; 
                                                   <br>6.strlen 的结果要在运行的时候才能计算出来，时用来计算字符串的长度，不是类型占内存 
                                                   <br>的大小。 
                                                   <br>7.sizeof 后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof 是个操作 
                                                   <br>符不是个函数。 
                                                   <br>8.当适用了于一个结构类型时或变量， sizeof 返回实际的大小， 
                                                   <br>当适用一静态地空间数组， sizeof 归还全部数组的尺寸。 
                                                   <br>sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸 
                                                   <br>9.数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址， 
                                                   <br>如： 
                                                   <br>fun(char [8]) 
                                                   <br>fun(char []) 
                                                   <br>都等价于fun(char *) 
                                                   <br>在C++里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小 
                                                   <br>如果想在函数内知道数组的大小， 需要这样做： 
                                                   <br>进入函数后用memcpy 拷贝出来，长度由另一个形参传进去 
                                                   <br>fun(unsiged char *p1, int len) 
                                                   <br>{ 
                                                   <br>unsigned char* buf = new unsigned char[len+1] 
                                                   <br>memcpy(buf, p1, len); 
                                                   <br>} 
                                                   <br>10.我们能常在用到sizeof 和strlen 的时候，通常是计算字符串数组的长度 
                                                   <br>看了上面的详细解释，发现两者的使用还是有区别的，从这个例子可以看得很清楚： 
                                                   <br>char str[20]="0123456789"; 
                                                   <br>int a=strlen(str); //a=10; &gt;&gt;&gt;&gt; strlen 计算字符串的长度，以结束符0x00 为字符串结束。 
                                                   <br>int b=sizeof(str); //而b=20; &gt;&gt;&gt;&gt; sizeof 计算的则是分配的数组str[20] 所占的内存空间的 
                                                   <br>大小，不受里面存储的内容改变。 
                                                   <br>上面是对静态数组处理的结果，如果是对指针，结果就不一样了 
                                                   <br>char* ss = "0123456789"; 
                                                   <br>sizeof(ss) 结果4 ＝＝＝》ss 是指向字符串常量的字符指针，sizeof 获得的是一个指针的 
                                                   <br>之所占的空间,应该是 
                                                   <br>长整型的，所以是4 
                                                   <br>sizeof(*ss) 结果1 ＝＝＝》*ss 是第一个字符其实就是获得了字符串的第一位'0' 所占的 
                                                   <br>内存空间，是char 类 
                                                   <br>型的，占了1 位 
                                                   <br>strlen(ss)= 10 &gt;&gt;&gt;&gt; 如果要获得这个字符串的长度，则一定要使用strlen 
                                                   <br>int x=35; 
                                                   <br>char str[10]; 
                                                   <br>//问：strlen(str)和sizeof(str)的值分别是多少？ 
                                                   <br>// strlen(str) 值不确定，strlen 根据'/0'确定字符串是否结束。 
                                                   <br>// sizeof(str)=10 sizeof 一个数组为数组长度 
                                                   <br>strcpy(str,"www.it315.org"/*共13 个字母*/); 
                                                   <br>//问:此时x 和strlen(str)的值分别是多少？ 
                                                   <br>// x 为35 
                                                   <br>// strcpy(char* dest, const char* src) 
                                                   <br>// 根据src 来复制dest，依照src 的'/0'决定复制的长度，而dest 必须要提供足够的长度， 
                                                   <br>这里会引起溢出，strlen 返回13，但是数组外部的数据已经被破坏 
                                                   <br>//(作者注:我下面给出了更确切的答案) 
                                                   <br>str="it315.org";//编译能通过吗？ 
                                                   <br>// 数组不能赋值，只能初始化。char str[10] = "it315.org"; 
                                                   <br>// 而且初始化时编译器会检查数组的长度与初始化串的长度是否匹配 
                                                   <br>char *pstr; 
                                                   <br>strcpy(pstr," 
                                                   <a href="http://www.it315.org" rel="nofollow">http://www.it315.org");</a> 
                                                   <br>//上句编译能通过吗？运行时有问题吗？ 
                                                   <br>// 可以通过编译，但是pstr 指向了常量区，运行时最好只做读操作，写操作不保险 
                                                   <br>//(作者注:我下面给出了更确切的答案) 
                                                   <br>13.const char *p1; 
                                                   <br>char * const p2; 
                                                   <br>//上面两句有什么区别吗？ 
                                                   <br>// const char* 和char const* 一样，都是表示指向常量的字符指针。 
                                                   <br>// char * const 表示指向字符的常量指针 
                                                   <br>p1=(const char *)str; 
                                                   <br>//如果是p1=str；编译能够通过吗？明白为什么要类型转换？类型转换的本质是什么？ 
                                                   <br>// 可以通过编译。关于常量与非常量指针的关系是这样的： 
                                                   <br>// const 指针可以指向const 或者非const 区域，不会造成什么问题。 
                                                   <br>// 非const 指针不能指向const 区域，会引起错误。 
                                                   <br>strcpy(p1,"abc");//编译能够通过吗？ 
                                                   <br>// 不能通过，strcpy( char*, const char*); char* 不能指向const char* 
                                                   <br>printf("%d",str);//有问题吗？ 
                                                   <br>// 没有问题，输出的是str 的地址信息。 
                                                   <br>pstr=3000;//编译能过吗？如果不行，该如何修改以保证编译通过呢？ 
                                                   <br>// 不能通过，char* pstr 表示pstr 是个字符指针，不能指向3000 的整形变量。 
                                                   <br>// 修改的话，可以这样：pstr = (char*)3000，把pstr 指向3000 这个地址; 
                                                   <br>long y=(long)pstr;//可以这样做吗？ 
                                                   <br>// 可以，y 的值为pstr 所指的地址。不过如果是纯粹要地址的话，最好是用unsigned long。 
                                                   <br>int *p=str; 
                                                   <br>*p=0x00313200; 
                                                   <br>printf("%s",str);//会是什么效果？提示0x31 对应字符'1',0x32 对应字符'2'。 
                                                   <br>// 首先编译未必会过关，有些编译器可能不允许int * 直接指向char*。最好是改为int *p = 
                                                   <br>(int*)str; 
                                                   <br>// 过关了效果就是什么东西都没有。int *p=str; p 为str 所指的地址，*p 表示修改了str 所指 
                                                   <br>向的内存。 
                                                   <br>// 由于sizeof(int)在32 位机上，int 有4 个字节（其实具体要看编译器的配置文件，好像是 
                                                   <br>limit.h，一般是4 个字节）所以修改了str[0]-str[3] 
                                                   <br>// 由于0x00313200 头尾都是0，所以字符串为'/0'开头，什么都打印不出来。这里有个 
                                                   <br>Big-endin 和little-endin 的问题。以0x31323334 为例 
                                                   <br>// little-endin 的机器上面，0x31323334 在内存中排列顺序为34 33 32 31，输出为4321， 
                                                   <br>如INTEL 芯片的pc 
                                                   <br>// big-endin 机器上面为31 32 33 34 ，输出为1234，如IBM POWERPC 
                                                   <br>p=3000;//p+1 的结果会是多少？ 
                                                   <br>// 3000+sizeof(int); 指针+1 均为原来地址加上sizeof(指针所指的数据类型) 
                                                   <br>char *pc=new char[100];//上述语句在内存中占据几个内存块，怎样的布局情况？ 
                                                   <br>// 本身pc 会占用函数栈一个4 字节的指针长度（具体是否为4 个字节要看机器和编译器）。 
                                                   <br>// new 会在堆上申请100 个字节sizeof(char)的连续空间。 
                                                   <br>void test(char **p) 
                                                   <br>{ 
                                                   <br>*p=new char[100]; 
                                                   <br>}//这个编译函数有问题吗？外面要调用这个函数，该怎样传递参数？ 
                                                   <br>// 该程序没有问题。需要在函数中对指针所指的地址进行变化是必须传人指针的地址。 
                                                   <br>// 原因是这样的：如果传入的为指针本身，在函数调用的时候，实参会被复制一个实例， 
                                                   <br>这样就不是原来的指针了，对该指针本身进行的任何改变都不能传递回去了。 
                                                   <br>// 可以这样理解，如果传入的参数为int，那么对int 本身的值的改变就传不回去啦，加个* 
                                                   <br>也是一样的。 
                                                   <br>//能明白typedef int (*PFUN)(int x,int y)及其作用吗？ 
                                                   <br>// 定义了一个函数指针类型的宏，这样PFUN 就表示指向返回值为int，且同时带2 个int 
                                                   <br>参数的函数指针类型了。 
                                                   <br>// 可以用来定义这样的变量： 
                                                   <br>// 比如有个函数为int fun( int x, int y ); 
                                                   <br>// PFUN p = fun; 
                                                   <br>//(作者注:我下面给出了更确切的答案) 
                                                   <br>-------------------------------------------------------------------------------------------------------------- 
                                                   <br>下面是我的一点补充: 
                                                   <br>第二题: 
                                                   <br>int x=35; 
                                                   <br>char str[10]; 
                                                   <br>strcpy(str,"www.it315.org"/*共13 个字母*/); 
                                                   <br>//问:此时x 和strlen(str)的值分别是多少？ 
                                                   <br>答:strlen 的值为13,在VC++环境下,x 的值是要改变的(其他编译器下没试,).虽然表面上看来, 
                                                   <br>在程序中并没有修改x 的值,但是实际运行的结果是上面的x 的值发生了修改,这是因为 
                                                   <br>strcpy 以后,把多余的数据拷贝进了str 的邻居(int 类型的x)中,所以x 的数据也就变了.这是 
                                                   <br>一个曾让我刻骨铭心的问题,在我刚出道时遇到这个问题,虽然在朋友的帮助下解决了这个 
                                                   <br>问题,但一直不明白x 的值为何变了,只有最后走上培训教师的岗位,才开始梳理自己曾经的 
                                                   <br>困惑,才开始总结以前的经验供学员们借鉴.我觉得这个题目的价值非常之大,它能引起学员 
                                                   <br>对字符串拷贝越界问题的足够重视,并且通过这个问题更能明白字符串的处理是怎么回时, 
                                                   <br>更能明白字符串与字符数组的关系:字符串就是一个字符数组,只是把这个字符数组用在处 
                                                   <br>理串的函数中时,这些函数不考虑数组的长度,只是记住数组的首地址,从首地址开始处理,并 
                                                   <br>在遇到0 时结束处理, 
                                                   <br>第四题: 
                                                   <br>char *pstr; 
                                                   <br>strcpy(pstr," 
                                                   <a href="http://www.it315.org" rel="nofollow">http://www.it315.org");</a> 
                                                   <br>//上句编译能通过吗？运行时有问题吗？ 
                                                   <br>答: 编译可以通过，但是pstr 没有进行有效的初始化,它指向了一个不确定的内存区，运行 
                                                   <br>时会出现内存不可写错误! 
                                                   <br>最后一题: 
                                                   <br>//能明白typedef int (*PFUN)(int x,int y)及其作用吗？ 
                                                   <br>答:函数指针最大的用处在于它可以被一个模板方法调用,这是我在学java 的设计模式时领 
                                                   <br>悟到的.例如,有两个函数的流程结构完全一致,只是内部调用的具体函数不同,如下所示: 
                                                   <br>void func1() 
                                                   <br>{ 
                                                   <br>//一段流程代码和面向方面的代理,如安全检查,日志记录等 
                                                   <br>int sum = add( x , y); 
                                                   <br>//一段流程代码和面向方面的代理,如安全检查,日志记录等 
                                                   <br>} 
                                                   <br>void func2() 
                                                   <br>{ 
                                                   <br>//与func1 完全相同的一段流程代码和面向方面的代理,如安全检查,日志记录等 
                                                   <br>int difference = sub( x , y); 
                                                   <br>//与func1 完全相同的一段流程代码和面向方面的代理,如安全检查,日志记录等 
                                                   <br>} 
                                                   <br>那么,可以只定义一个函数,如下所示 
                                                   <br>void func(PFUNC p) 
                                                   <br>{ 
                                                   <br>//与func1 完全相同的一段流程代码和面向方面的代理,如安全检查,日志记录等 
                                                   <br>int difference = p( x , y); 
                                                   <br>//与func1 完全相同的一段流程代码和面向方面的代理,如安全检查,日志记录等 
                                                   <br>} 
                                                   <br>调用程序在调用时,让参数p 分别指向add 和sub 函数就可以了. 
                                                   
                                                  
                                                 
                                                
                                               
                                              
                                             
                                            
                                           
                                          
                                         
                                        
                                       
                                      
                                     
                                    
                                   
                                  
                                 
                                
                               
                              
                             
                            
                           
                          
                         
                        
                       
                      
                     
                    
                   
                  
                 
                
               
              
             
            
           
          
         
        
       
      
     
    
   
 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bc035a62b458c5a80ae5f0f1730ab5a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;笔试题汇总（5）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b7c2422ee2c6c18be644d20cbdb038e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android程序怎样禁止横竖屏切换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>