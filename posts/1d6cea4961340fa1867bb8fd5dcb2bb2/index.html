<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的 “==” 与 equals 的区别 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中的 “==” 与 equals 的区别" />
<meta property="og:description" content="Java中的 “==” 与 equals 的区别 1.“==” 在Java中有两大类数据类型，一类是基础数据类型共有八种分别是byte、 short、 int、 long、 float、 double、 char、boolean，另一类则是引用数据类型，例如String、Integer等等。
“ == ” 作为比较运算符，是用于比较两个值是否相等的，但是在比较基础数据类型和引用数据类型时是不一样的。
例如以下代码，两个基本类型作比较：
int a = 1; int b = 1; System.out.println(a == b); 我们可以看到返回结构为true,说明 a 和 b的值是相同的
那如果比较两个引用数据类型呢？
String s1 = new String(&#34;abc&#34;); String s2 = new String(&#34;abc&#34;); System.out.println(s1 == s2); 我们可以看到，s1 和 s2的值明明都是abc，但比较出来结果确是false，为什么呢？
我们这里new了两个String对象,两个对象存储的地址是不同的，就算是值相同比较出来的结果也一定是false，因为 “==”在比较引用数据类型时比较的是引用（地址）是否相同
综上所述：
“ == ” 在比较基本数据类型比较的是值是否相同，而在比较引用数据类型的时候则是比较引用是否相同。
equals equals被定义在了Object类中，Object类是所有类的父类，也就是说所有类都继承于Object,这也是为什么所有类都是可以调用或重写Object中的方法的。
我们通过Object的源码可以看到，equals方法的底层实现仍然是 “ == ”，但我们需要注意一点，equals不能比较两个基本数据类型。
可为什么我们去比较字符串时用equals比较的是两个值是否相等呢，我们可以从String源码中获得答案。
前面说到，所有类都继承于Object类，那也就是说所有的Object子类都是可以重写Object中定义的方法的。这里String就是重写了父类的equals方法从而实现了值得比较，可以看到，进入到这个方法时会先比较引用（地址）是否相同，若地址相同值一定是相同得，随后进行类型判断，若传入得参数类型是String,则继续比较，否则会返回false,若为ture进入判断中将参数转为String类型，比较长度，长度一致则会去遍历字符数组（String底层实现是字符数组，这里就不过多赘述了），若字符串中每个字符都相等则返回true.这样就实现了值得比较。
接下来我们看在Integer中得equals方法是这样的
若参数类型一致则调用intValue方法将参数转为int类型进行比较。
综上所述：
equals方法在Object中定义，其底层还是用得“==”去实现的，但是有些对象，例如String、Integer等等，则是重写了equals方法实现了值得比较。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1d6cea4961340fa1867bb8fd5dcb2bb2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-15T17:26:50+08:00" />
<meta property="article:modified_time" content="2024-03-15T17:26:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的 “==” 与 equals 的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Java___equals__0"></a>Java中的 “==” 与 equals 的区别</h2> 
<h3><a id="1_1"></a>1.“==”</h3> 
<p>在Java中有两大类数据类型，一类是基础数据类型共有八种分别是byte、 short、 int、 long、 float、 double、 char、boolean，另一类则是引用数据类型，例如String、Integer等等。<br> “ == ” 作为比较运算符，是用于比较两个值是否相等的，但是在比较基础数据类型和引用数据类型时是不一样的。<br> 例如以下代码，两个基本类型作比较：</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们可以看到返回结构为true,说明 a 和 b的值是相同的<br> <img src="https://images2.imgbox.com/d3/26/m9pxy9CB_o.png" alt="在这里插入图片描述"><br> 那如果比较两个引用数据类型呢？</p> 
<pre><code class="prism language-java"><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们可以看到，s1 和 s2的值明明都是abc，但比较出来结果确是false，为什么呢？<br> 我们这里new了两个String对象,两个对象存储的地址是不同的，就算是值相同比较出来的结果也一定是false，因为 “==”在比较引用数据类型时比较的是引用（地址）是否相同<br> <img src="https://images2.imgbox.com/d4/c5/PGhIlI9Y_o.png" alt="在这里插入图片描述"><br> 综上所述：<br> “ == ” 在比较基本数据类型比较的是值是否相同，而在比较引用数据类型的时候则是比较引用是否相同。</p> 
<h3><a id="equals_24"></a>equals</h3> 
<p>equals被定义在了Object类中，Object类是所有类的父类，也就是说所有类都继承于Object,这也是为什么所有类都是可以调用或重写Object中的方法的。<br> 我们通过Object的源码可以看到，equals方法的底层实现仍然是 “ == ”，但我们需要注意一点，equals不能比较两个基本数据类型。<br> <img src="https://images2.imgbox.com/02/38/iZUeX72g_o.png" alt="在这里插入图片描述"><br> 可为什么我们去比较字符串时用equals比较的是两个值是否相等呢，我们可以从String源码中获得答案。<br> <img src="https://images2.imgbox.com/7e/91/G2Y0xu5p_o.png" alt="在这里插入图片描述"><br> 前面说到，所有类都继承于Object类，那也就是说所有的Object子类都是可以重写Object中定义的方法的。这里String就是重写了父类的equals方法从而实现了值得比较，可以看到，进入到这个方法时会先比较引用（地址）是否相同，若地址相同值一定是相同得，随后进行类型判断，若传入得参数类型是String,则继续比较，否则会返回false,若为ture进入判断中将参数转为String类型，比较长度，长度一致则会去遍历字符数组（String底层实现是字符数组，这里就不过多赘述了），若字符串中每个字符都相等则返回true.这样就实现了值得比较。</p> 
<p>接下来我们看在Integer中得equals方法是这样的<br> <img src="https://images2.imgbox.com/f6/d5/Sd7wNJmR_o.png" alt="在这里插入图片描述"><br> 若参数类型一致则调用intValue方法将参数转为int类型进行比较。</p> 
<p>综上所述：<br> equals方法在Object中定义，其底层还是用得“==”去实现的，但是有些对象，例如String、Integer等等，则是重写了equals方法实现了值得比较。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6f7f92602c09340b2f967fd052a9cd63/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">html5播放flv视频</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0ac3e87481beed128dabc1b8a7e31cda/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自动化测试Allure报告使用详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>