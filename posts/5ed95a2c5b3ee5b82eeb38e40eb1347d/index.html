<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>UDP数据报套接字编程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="UDP数据报套接字编程" />
<meta property="og:description" content="1.1UDP编程原理 对于UDP协议来说，具有无连接，面向数据报的特征，即每次都是没有建立连接，并且一次发送全部数据报，一次接收全部的数据报。Java中使用UDP协议通信，主要基于DatagramSocket类来发送或接收数据报套接字，并使用DatagramPacket作为创建的UDP数据报，DatagramPacket类对象就是UDP协议中Socket的数据报。 1.2 DatagramSocket API DatagramSocket 是UDP Socket，用于发送和接收UDP数据报。
(1) DatagramSocket 构造方法： (2)DatagramSocket 方法： 1.3DatagramPacket类 （1）DatagramPacket构造方法 构造方法如下：
（2）DatagramPacket普通方法 2.1服务器端代码 public class EchoServer {//服务器端 //1、创建一个DatagramSocket对象 DatagramSocket socket = null; public EchoServer(int port) throws SocketException {//服务器端需要自己指定端口号 socket = new DatagramSocket(port);//这么写就是手动指定端口号 //socket = new DatagramSocket();//这么写就是系统自动分配端口号 } public void start() throws IOException { System.out.println(&#34;服务器启动...&#34;); while (true){ DatagramPacket requestPacket = new DatagramPacket(new byte[4096],4096); //requestPacket这个对象是用来承载数据的，在创建的时候需要创建一块内存空间来保存数据 socket.receive(requestPacket); //当前完成的receive之后，数据是以二进制的形式存储到DatagramPacket中 //还需要把这个二进制的数据转化成字符串的形式 String request = new String(requestPacket.getData(),0,requestPacket.getLength()); //范围为0到requestPacket.getLength()，requestPacket.getLength()表示数据的真实长度 //2、根据请求，计算响应（服务器端最核心的作用） String response = process(request); //3、把响应写回到客户端 //搞一个响应对象，DatagramPacket //把DatagramPacket构造刚才的数据，再通过send返回 DatagramPacket responsePacket = new DatagramPacket(response." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5ed95a2c5b3ee5b82eeb38e40eb1347d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T13:33:09+08:00" />
<meta property="article:modified_time" content="2024-03-14T13:33:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">UDP数据报套接字编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.1UDP编程原理</h2> 
<p>          对于UDP协议来说，具有无连接，面向数据报的特征，即每次都是没有建立连接，并且一次发送全部数据报，一次接收全部的数据报。Java中使用UDP协议通信，主要基于DatagramSocket类来发送或接收数据报套接字，并使用DatagramPacket作为创建的UDP数据报，DatagramPacket类对象就是UDP协议中Socket的数据报。 </p> 
<h2>1.2 <strong>DatagramSocket API</strong></h2> 
<p>DatagramSocket 是UDP Socket，用于发送和接收UDP数据报。</p> 
<h3>(1) DatagramSocket 构造方法：</h3> 
<p><img alt="" height="199" src="https://images2.imgbox.com/6c/6d/aSjze8Gz_o.png" width="813"></p> 
<h3>(2)DatagramSocket 方法： </h3> 
<p><img alt="" height="236" src="https://images2.imgbox.com/9a/10/mc2VhYkD_o.png" width="772"></p> 
<h2 id="1.2DatagramPacket%E7%B1%BB">1.3DatagramPacket类</h2> 
<h3 id="%EF%BC%881%EF%BC%89DatagramPacket%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">（1）DatagramPacket构造方法</h3> 
<p>构造方法如下：</p> 
<p> <img alt="" height="295" src="https://images2.imgbox.com/ac/4d/ABi4sxSn_o.png" width="780"></p> 
<h3>（2）DatagramPacket普通方法 </h3> 
<p><img alt="" height="287" src="https://images2.imgbox.com/fb/91/OuDVeJsh_o.png" width="809"></p> 
<h2>2.1服务器端代码</h2> 
<p></p> 
<pre><code>public class EchoServer {//服务器端
    //1、创建一个DatagramSocket对象
    DatagramSocket socket = null;
    public EchoServer(int port) throws SocketException {//服务器端需要自己指定端口号
        socket = new DatagramSocket(port);//这么写就是手动指定端口号
        //socket = new DatagramSocket();//这么写就是系统自动分配端口号
    }
 
    public void start() throws IOException {
        System.out.println("服务器启动...");
        while (true){
            DatagramPacket requestPacket = new DatagramPacket(new byte[4096],4096);
            //requestPacket这个对象是用来承载数据的，在创建的时候需要创建一块内存空间来保存数据
            socket.receive(requestPacket);
            //当前完成的receive之后，数据是以二进制的形式存储到DatagramPacket中
            //还需要把这个二进制的数据转化成字符串的形式
            String request = new String(requestPacket.getData(),0,requestPacket.getLength());
            //范围为0到requestPacket.getLength()，requestPacket.getLength()表示数据的真实长度
            //2、根据请求，计算响应（服务器端最核心的作用）
            String response = process(request);
            //3、把响应写回到客户端
            //搞一个响应对象，DatagramPacket
            //把DatagramPacket构造刚才的数据，再通过send返回
            DatagramPacket responsePacket = new DatagramPacket(response.getBytes(),
                    0,
                    response.getBytes().length,
                    requestPacket.getSocketAddress());//指定数据内容，同时指定数据要发给谁
            socket.send(responsePacket);
            //4、打印一个日志，把这次的数据交互的详情给打印出来
            System.out.printf("[%s:%d] req = %s,resp = %s\n",
                    responsePacket.getAddress().toString(),
                    responsePacket.getPort(),
                    request,
                    response);
        }
    }
    public String process(String request) {//请求是啥样，响应就是啥样
        //回转响应的方法
        return request;
    }
    public static void main(String[] args) throws IOException {
        EchoServer server = new EchoServer(9090);//实例测试
        server.start();
    }
}</code></pre> 
<h2> 2.2客服端代码</h2> 
<pre><code>public class EchoClient {//客户端
    private DatagramSocket socket = null;
    private String serverIP = "";
    private int serverPort = 0;
    public EchoClient(String ip,int port) throws SocketException {
        //创建这个对象不能手动指定端口
        socket = new DatagramSocket();
        //由于 UDP自身不会持有对端信息，就需要在应用程序里，把对端的情况给记录下来
        //这里咱们主要记录对端的ip和端口
        serverIP = ip;
        serverPort = port;
    }
    public void start() throws IOException {
        System.out.println("客户端启动...");
        Scanner scanner = new Scanner(System.in);
        while (true){
            //1、控制台读取数据，作为请求
            System.out.println(" -&gt; ");
            String request = scanner.next();
            //2、把请求的内容构造成DatagramSocket对象，发送给服务器
            DatagramPacket requestPacket = new DatagramPacket(request.getBytes(),
                    request.getBytes().length,
                    InetAddress.getByName(serverIP),
                    serverPort);
            socket.send(requestPacket);
            //3、尝试获取服务器响应
            DatagramPacket responsePacket = new DatagramPacket(new byte[4096],4096);
            socket.receive(responsePacket);
            //4、把响应给转换出字符串，并显示出来
            String response = new String(responsePacket.getData(),
                    0,
                    responsePacket.getLength());
            System.out.println(response);
        }
    }
    public static void main(String[] args) throws IOException {
        EchoClient client = new EchoClient("127.0.0.1",9090);
        client.start();
    }
}</code></pre> 
<h2>2.3运行结果</h2> 
<p><img alt="" height="292" src="https://images2.imgbox.com/66/05/9Vz9DQGg_o.png" width="599"></p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/1b/ec/eRQ1PXrX_o.png" width="597"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d0c7435340cc13e57fe06dfbb5d3a84/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue的axios教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7913b66c1b3b31da7fe001dace10a9a6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">应用服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>