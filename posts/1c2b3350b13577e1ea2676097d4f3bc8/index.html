<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Makefile工程管理器 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Makefile工程管理器" />
<meta property="og:description" content="文章目录 导引makefile的规则和伪目标makefile规则makefile伪目标 makefile中的变量自定义变量自动变量预定义变量和环境变量 makefile的规则Makefile引用其他Makefile 导引 如果是一个单独的.c文件，我们可以使用一条gcc指令去完成编译，得到可执行文件。
例如：
//test.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &#34;test.h&#34; int main(void) { //print(); printf(&#34;This is test file\n&#34;); return 0; } ubuntu@ubuntu16:/work$ gcc -o test test.c 得到可执行文件test.
ubuntu@ubuntu16:/work$ ./test This is test file 那么如果是两个或多个c文件编译成一个可执行文件，就需要多条指令。
如：
现在有两个c文件，test.c和test1.c
//test.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &#34;test.h&#34; int main(void) { print(); printf(&#34;to call test1&#39;s function\n&#34;); return 0; } //test1.c #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int print(void) { printf(&#34;this is test1 file\n&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1c2b3350b13577e1ea2676097d4f3bc8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-30T09:19:56+08:00" />
<meta property="article:modified_time" content="2020-06-30T09:19:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Makefile工程管理器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">导引</a></li><li><a href="#makefile_81" rel="nofollow">makefile的规则和伪目标</a></li><li><ul><li><ul><li><a href="#makefile_82" rel="nofollow">makefile规则</a></li><li><a href="#makefile_107" rel="nofollow">makefile伪目标</a></li></ul> 
  </li></ul> 
  </li><li><a href="#makefile_127" rel="nofollow">makefile中的变量</a></li><li><ul><li><ul><li><a href="#_131" rel="nofollow">自定义变量</a></li><li><a href="#_164" rel="nofollow">自动变量</a></li><li><a href="#_200" rel="nofollow">预定义变量和环境变量</a></li></ul> 
  </li></ul> 
  </li><li><a href="#makefile_207" rel="nofollow">makefile的规则</a></li><li><a href="#MakefileMakefile_261" rel="nofollow">Makefile引用其他Makefile</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>导引</h2> 
<p>如果是一个单独的.c文件，我们可以使用一条gcc指令去完成编译，得到可执行文件。<br> 例如：</p> 
<pre><code class="prism language-c"><span class="token comment">//test.c</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"test.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//print();</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is test file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c">ubuntu@ubuntu16<span class="token punctuation">:</span><span class="token operator">/</span>work$ gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>c
</code></pre> 
<p>得到可执行文件test.</p> 
<pre><code class="prism language-c">ubuntu@ubuntu16<span class="token punctuation">:</span><span class="token operator">/</span>work$ <span class="token punctuation">.</span><span class="token operator">/</span>test 
This is test file
</code></pre> 
<p>那么如果是两个或多个c文件编译成一个可执行文件，就需要多条指令。<br> 如：<br> 现在有两个c文件，test.c和test1.c</p> 
<pre><code class="prism language-c"><span class="token comment">//test.c</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"test.h"</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"to call test1's function\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">//test1.c</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"this is test1 file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>需要实现一个.h文件来声明函数</p> 
<pre><code class="prism language-c"><span class="token comment">//test.h</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>那么我们想要编译成可执行文件需要执行如下命令：</p> 
<pre><code class="prism language-c">ubuntu@ubuntu16<span class="token punctuation">:</span><span class="token operator">/</span>work$ gcc <span class="token operator">-</span>o test<span class="token punctuation">.</span>o <span class="token operator">-</span>c test<span class="token punctuation">.</span>c
ubuntu@ubuntu16<span class="token punctuation">:</span><span class="token operator">/</span>work$ gcc <span class="token operator">-</span>o test1<span class="token punctuation">.</span>o <span class="token operator">-</span>c test1<span class="token punctuation">.</span>c
ubuntu@ubuntu16<span class="token punctuation">:</span><span class="token operator">/</span>work$ gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
</code></pre> 
<pre><code class="prism language-c">ubuntu@ubuntu16<span class="token punctuation">:</span><span class="token operator">/</span>work$ <span class="token punctuation">.</span><span class="token operator">/</span>test 
this is test1 file
to call test1's function
</code></pre> 
<p>假设test.c文件有修改或者工程里面有很多.c文件，按照上面的方式处理，工程量就会很大，一旦有一个文件修改了，就需要重新搞一遍。<br> 针对上面的情况，进入make工程管理器的概念，它是自动管理器能根据文件时间自动发现更新过的文件而减少编译的工作量，同时通过读入makefile文件来执行大量的编译工作。</p> 
<h2><a id="makefile_81"></a>makefile的规则和伪目标</h2> 
<h4><a id="makefile_82"></a>makefile规则</h4> 
<p>规则:用于说明如何生成一个或多个目标文件<br> 规则格式：</p> 
<pre><code class="prism language-c">target<span class="token punctuation">:</span>dependency_file <span class="token comment">//目标项：依赖项</span>
<span class="token operator">&lt;</span>TAB<span class="token operator">&gt;</span>command          <span class="token comment">//必须以tab开头，command编译命令</span>
</code></pre> 
<p>makefile中之影该有一个最终目标，第一条规则伪最终目标</p> 
<p>那么上述的多条指令编译成可执行文件test,如何使用makefile去编译？如下：</p> 
<pre><code class="prism language-c">test<span class="token punctuation">:</span>test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o #目标：依赖项 #makefile文件中只有一个最终目标，第一条规则即是最终目标
	gcc <span class="token operator">-</span>o test  test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o

test1<span class="token punctuation">.</span>o<span class="token punctuation">:</span>test1<span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o test1<span class="token punctuation">.</span>o <span class="token operator">-</span>c test1<span class="token punctuation">.</span>c

test<span class="token punctuation">.</span>o<span class="token punctuation">:</span>test<span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o test<span class="token punctuation">.</span>o <span class="token operator">-</span>c test<span class="token punctuation">.</span>c

</code></pre> 
<h4><a id="makefile_107"></a>makefile伪目标</h4> 
<p><strong>使用.PHONY这个makefile关键字来定义伪目标</strong></p> 
<pre><code class="prism language-c">test<span class="token punctuation">:</span>test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o #目标：依赖项 #makefile文件中只有一个最终目标，第一条规则即是最终目标
	gcc <span class="token operator">-</span>o test  test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o

test1<span class="token punctuation">.</span>o<span class="token punctuation">:</span>test1<span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o test1<span class="token punctuation">.</span>o <span class="token operator">-</span>c test1<span class="token punctuation">.</span>c

test<span class="token punctuation">.</span>o<span class="token punctuation">:</span>test<span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o test<span class="token punctuation">.</span>o <span class="token operator">-</span>c test<span class="token punctuation">.</span>c

<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>clean rebuild #伪目标
clean<span class="token punctuation">:</span>
	rm <span class="token operator">*</span><span class="token punctuation">.</span>o test

rebuild<span class="token punctuation">:</span>clean test
</code></pre> 
<h2><a id="makefile_127"></a>makefile中的变量</h2> 
<p>变量类型：<br> <mark>用户自定义变量，自动变量，预定义变量，环境变量</mark></p> 
<h4><a id="_131"></a>自定义变量</h4> 
<p>定义格式：<br> 1.<mark>变量名=变量值</mark><br> 2.<mark>变量名:=变量值 （一般使用这种格式）</mark></p> 
<p><mark>如何引用变量？</mark><br> $(变量名) = ？//赋值<br> ？ = $(变量名) //引用</p> 
<pre><code class="prism language-c"># 自定义变量的使用

SOURCE<span class="token punctuation">:</span><span class="token operator">=</span>test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
EXE<span class="token punctuation">:</span><span class="token operator">=</span>test

$<span class="token punctuation">(</span>warning <span class="token string">"SOURCE = $(SOURCE),EXE = $(EXE)"</span><span class="token punctuation">)</span>
$<span class="token punctuation">(</span>EXE<span class="token punctuation">)</span><span class="token punctuation">:</span>$<span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span>#目标：依赖项 #makefile文件中只有一个最终目标，第一条规则即是最终目标
	gcc <span class="token operator">-</span>o $<span class="token punctuation">(</span>EXE<span class="token punctuation">)</span> $<span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span>

test1<span class="token punctuation">.</span>o<span class="token punctuation">:</span>test1<span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o test1<span class="token punctuation">.</span>o <span class="token operator">-</span>c test1<span class="token punctuation">.</span>c

test<span class="token punctuation">.</span>o<span class="token punctuation">:</span>test<span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o test<span class="token punctuation">.</span>o <span class="token operator">-</span>c test<span class="token punctuation">.</span>c

<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>clean rebuild #伪目标
clean<span class="token punctuation">:</span>
	rm <span class="token operator">*</span><span class="token punctuation">.</span>o test

rebuild<span class="token punctuation">:</span>clean test

</code></pre> 
<h4><a id="_164"></a>自动变量</h4> 
<p><mark>$@: 当前规则的目标文件<br> $&lt;: 当前规则的第一个依赖文件<br> $^: 当前规则的所有依赖文件<br> $?: 当前规则中日期新于目标文件的所有相关文件列表，逗号分割<br> $(@D): 目标文件的目录名部分<br> $(@F): 目标文件的文件名部分</mark></p> 
<pre><code class="prism language-c"># 自定义变量的使用

SOURCE<span class="token punctuation">:</span><span class="token operator">=</span>test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
EXE<span class="token punctuation">:</span><span class="token operator">=</span>test

$<span class="token punctuation">(</span>warning <span class="token string">"SOURCE = $(SOURCE),EXE = $(EXE)"</span><span class="token punctuation">)</span>
$<span class="token punctuation">(</span>EXE<span class="token punctuation">)</span><span class="token punctuation">:</span>$<span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span>#目标：依赖项 #makefile文件中只有一个最终目标，第一条规则即是最终目标
	gcc <span class="token operator">-</span>o $<span class="token punctuation">(</span>EXE<span class="token punctuation">)</span> $<span class="token punctuation">(</span>SOURCE<span class="token punctuation">)</span>

test1<span class="token punctuation">.</span>o<span class="token punctuation">:</span>test1<span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o $@ <span class="token operator">-</span>c $<span class="token operator">^</span> 

# $@<span class="token punctuation">:</span>表示当前规则的目标文件
# @<span class="token operator">^</span><span class="token punctuation">:</span>当前规则的所有依赖文件

test<span class="token punctuation">.</span>o<span class="token punctuation">:</span>test<span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o $@ <span class="token operator">-</span>c $<span class="token operator">^</span>

<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>clean rebuild #伪目标
clean<span class="token punctuation">:</span>
	<span class="token operator">-</span>rm <span class="token operator">*</span><span class="token punctuation">.</span>o test 
	<span class="token macro property">#rm前面加-的意思是，也许某些文件出现问题，请忽略，继续做后面的事</span>

rebuild<span class="token punctuation">:</span>clean test

</code></pre> 
<h4><a id="_200"></a>预定义变量和环境变量</h4> 
<p>查看环境变量的命令export</p> 
<p>内部事先定义好的变量，但是它的值是固定的，并且有些值为空。</p> 
<p>一般自己编写makefile不使用环境变量，因为不具备通用性，换了编译环境，可能环境变量和预定义变量会不一样。</p> 
<h2><a id="makefile_207"></a>makefile的规则</h2> 
<p>1&gt;:<strong>普通规则</strong>：上述介绍的皆是普通规则<br> 2&gt;:<mark>隐含规则</mark>：<br> make 自动推导，只要 make 看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果 make 找到一个 whatever.o，那么 whatever.c，就会是 whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的 makefile再也不用写得这么复杂。我们的是新的 makefile 又出炉了。</p> 
<pre><code class="prism language-c">
test<span class="token punctuation">:</span>test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
	gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o

<span class="token macro property">#test1.o:test1.c</span>
<span class="token macro property">#	gcc -o $@ -c $^ </span>

<span class="token macro property">#test.o:test.c</span>
<span class="token macro property">#	gcc -o $@ -c $^</span>

<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>clean rebuild #伪目标
clean<span class="token punctuation">:</span>
	<span class="token operator">-</span>rm <span class="token operator">*</span><span class="token punctuation">.</span>o test 
	<span class="token macro property">#rm前面加-的意思是，也许某些文件出现问题，请忽略，继续做后面的事</span>

rebuild<span class="token punctuation">:</span>clean test

</code></pre> 
<pre><code class="prism language-c">ubuntu@ubuntu16<span class="token punctuation">:</span><span class="token operator">/</span>work<span class="token operator">/</span>C<span class="token operator">++</span><span class="token operator">/</span>make$ make
cc    <span class="token operator">-</span>c <span class="token operator">-</span>o test<span class="token punctuation">.</span>o test<span class="token punctuation">.</span>c
cc    <span class="token operator">-</span>c <span class="token operator">-</span>o test1<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>c
gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
</code></pre> 
<p>3&gt;:<mark>模式规则</mark></p> 
<p>通过匹配模式找字符串，%匹配一个或多个任意字符串，<br> %.o:%.c任何目标文件的依赖文件是与目标文件同名的，并且扩展名为.c的文件</p> 
<pre><code class="prism language-c">
test<span class="token punctuation">:</span>test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
	gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o

<span class="token operator">%</span><span class="token punctuation">.</span>o<span class="token punctuation">:</span><span class="token operator">%</span><span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o $@ <span class="token operator">-</span>c $<span class="token operator">^</span>

<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>clean rebuild #伪目标
clean<span class="token punctuation">:</span>
	<span class="token operator">-</span>rm <span class="token operator">*</span><span class="token punctuation">.</span>o test 
	<span class="token macro property">#rm前面加-的意思是，也许某些文件出现问题，请忽略，继续做后面的事</span>

rebuild<span class="token punctuation">:</span>clean test

</code></pre> 
<h2><a id="MakefileMakefile_261"></a>Makefile引用其他Makefile</h2> 
<p>在 Makefile 使用 include 关键字可以把别的 Makefile 包含进来，这很像 C 语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include 的语法是：</p> 
<pre><code class="prism language-c">include <span class="token operator">&lt;</span>filename<span class="token operator">&gt;</span>
</code></pre> 
<p>filename 可以是当前操作系统 Shell 的文件模式（可以保含路径和通配符）。<br> 在 include 前面可以有一些空字符，但是绝不能是[Tab]键开始。include 和可以用一个或多个空格隔开。举个例子，你有这样几个 Makefile：a.mk、b.mk、c.mk，还有一个文件叫 foo.make，以及一个变量$(bar)，其包含了 e.mk 和 f.mk，那么，下面的语句：</p> 
<pre><code class="prism language-c">include foo<span class="token punctuation">.</span>make <span class="token operator">*</span><span class="token punctuation">.</span>mk $<span class="token punctuation">(</span>bar<span class="token punctuation">)</span>
</code></pre> 
<p>等价于：</p> 
<pre><code class="prism language-c">include foo<span class="token punctuation">.</span>make a<span class="token punctuation">.</span>mk b<span class="token punctuation">.</span>mk c<span class="token punctuation">.</span>mk e<span class="token punctuation">.</span>mk f<span class="token punctuation">.</span>mk
</code></pre> 
<p>make 命令开始时，<mark>会把找寻 include 所指出的其它 Makefile，并把其内容安置在当前的位置.</mark></p> 
<p>举个例子：</p> 
<pre><code class="prism language-c"><span class="token macro property"># Makefile</span>
test<span class="token punctuation">:</span>test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
	gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
	
include file<span class="token punctuation">.</span>mk
# 引用file<span class="token punctuation">.</span>mk文件

<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>clean rebuild #伪目标
clean<span class="token punctuation">:</span>
	<span class="token operator">-</span>rm <span class="token operator">*</span><span class="token punctuation">.</span>o test 
	<span class="token macro property">#rm前面加-的意思是，也许某些文件出现问题，请忽略，继续做后面的事</span>

rebuild<span class="token punctuation">:</span>clean test

</code></pre> 
<pre><code class="prism language-c"><span class="token macro property"># file.mk</span>
<span class="token operator">%</span><span class="token punctuation">.</span>o<span class="token punctuation">:</span><span class="token operator">%</span><span class="token punctuation">.</span>c
	gcc <span class="token operator">-</span>o $@ <span class="token operator">-</span>c $<span class="token operator">^</span>
</code></pre> 
<pre><code class="prism language-c">ubuntu@ubuntu16<span class="token punctuation">:</span><span class="token operator">/</span>work$ make
gcc <span class="token operator">-</span>o test<span class="token punctuation">.</span>o <span class="token operator">-</span>c test<span class="token punctuation">.</span>c
gcc <span class="token operator">-</span>o test1<span class="token punctuation">.</span>o <span class="token operator">-</span>c test1<span class="token punctuation">.</span>c
gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>o test1<span class="token punctuation">.</span>o
</code></pre> 
<p>如果文件都没有指定绝对路径或是相对路径的话，make 会在当前目录下首先寻找，如果当前目录下没有找到，那么，make 还会在下面的几个目录下找：</p> 
<ol><li> <p>如果 make 执行时，有“-I”或“–include-dir”参数，那么 make 就会在这个参数所指定的目录下去寻<br> 找。</p> </li><li> <p>如果目录/include（一般是：/usr/local/bin 或/usr/include）存在的话，make 也会去找。<br> 如果有文件没有找到的话，make 会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成 makefile 的读取，make 会再重试这些没有找到，或是不能读取的文件，如果还是不行，make 才会出现一条致命信息。如果你想让 make 不理那些无法读取的文件，而继续执行，你可以在 include前加一个减号“<mark>-</mark>”。如：</p> <pre><code class="prism language-c"><span class="token operator">-</span>include <span class="token operator">&lt;</span>filename<span class="token operator">&gt;</span>
</code></pre> <p>其表示，无论 include 过程中出现什么错误，都不要报错继续执行。和其它版本 make 兼容的相关命令是 sinclude，其作用和这一个是一样的。</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c5ef620837ff18f872460d8835b4484/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">codeforces 1374E1 Reading Books (easy version)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a9da0f4e2aa811fadd00a23fa85a340/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python量化分析库 Backtrader入门之一</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>