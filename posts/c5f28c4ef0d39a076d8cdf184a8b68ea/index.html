<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态规划经典问题整理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="动态规划经典问题整理" />
<meta property="og:description" content="单序列： 最长连续递增序列 最长递增子序列 最长递增子序列的个数 最大子序和 最大整除子集
爬楼梯最长定差子序列 爬楼梯 使用最小花费爬楼梯 比特位计数 旋转数字
把数字翻译成字符串 青蛙过河 最低加油次数 栅栏涂色 寻找数组的错位排列
所有子字符串中的元音 打家劫舍 打家劫舍 II 解决智力问题 带因子的二叉树 解决智力问题 分隔数组以得到最大和 可被三整除的最大和 检查数组是否存在有效划分 活字印刷 填充书架
统计特殊子序列的数目
双序列：
正则表达式匹配 最长公共子序列 不相交的线 最长重复子数组 通配符匹配
编辑距离 交错字符串 同源字符串检测 最长等差数列 最长的斐波那契子序列的长度 判断子序列 子序列的数目 卖木头块 填充书架
区间动态规划：
最少回文分割 猜数字大小 II 戳气球 为运算表达式设计优先级 预测赢家 最大平均值和的分组 多边形三角剖分的最低得分
状态转移动态规划：
删除一次得到子数组最大和 经过一次操作后的最大子数组和 最大交替子数组和 多米诺和托米诺平铺 统计只差一个字符的子串数目 学生出勤记录 II
背包问题：
零钱兑换 组合总和 Ⅳ 零钱兑换 II 分割等和子集 划分为k个相等的子集 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c5f28c4ef0d39a076d8cdf184a8b68ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-02-28T19:47:19+08:00" />
<meta property="article:modified_time" content="2024-02-28T19:47:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态规划经典问题整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>单序列：</strong>  </p> 
<p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence" rel="nofollow" title="最长连续递增序列">最长连续递增序列</a>  <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" rel="nofollow" title="最长递增子序列">最长递增子序列</a> <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs" rel="nofollow" title="  ">  </a><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" rel="nofollow" title="最长递增子序列的个数">最长递增子序列的个数</a><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs" rel="nofollow" title="  ">  </a><a href="https://leetcode-cn.com/problems/maximum-subarray" rel="nofollow" title="最大子序和  ">最大子序和  </a><br><a href="https://leetcode-cn.com/problems/largest-divisible-subset/" rel="nofollow" title="最大整除子集">最大整除子集</a></p> 
<p><a href="https://leetcode-cn.com/problems/climbing-stairs/" rel="nofollow" title=" 爬楼梯"> 爬楼梯</a><a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/" rel="nofollow" title="最长定差子序列 ">最长定差子序列 </a><a href="https://leetcode-cn.com/problems/climbing-stairs/" rel="nofollow" title=" 爬楼梯"> 爬楼梯</a> <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs" rel="nofollow" title="使用最小花费爬楼梯">使用最小花费爬楼梯</a> <a href="https://leetcode-cn.com/problems/counting-bits/" rel="nofollow" title="比特位计数">比特位计数</a> <a href="https://leetcode-cn.com/problems/rotated-digits/" rel="nofollow" title="旋转数字">旋转数字</a></p> 
<p><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof" rel="nofollow" title="把数字翻译成字符串 ">把数字翻译成字符串 </a><a href="https://leetcode-cn.com/problems/frog-jump" rel="nofollow" title="青蛙过河">青蛙过河</a> <a href="https://leetcode-cn.com/problems/minimum-number-of-refueling-stops" rel="nofollow" title="最低加油次数">最低加油次数</a>  <a href="https://leetcode-cn.com/problems/paint-fence/" rel="nofollow" title="栅栏涂色">栅栏涂色</a> <a href="https://leetcode-cn.com/problems/find-the-derangement-of-an-array/" rel="nofollow" title="寻找数组的错位排列">寻找数组的错位排列</a></p> 
<p><a href="https://leetcode-cn.com/problems/vowels-of-all-substrings" rel="nofollow" title="所有子字符串中的元音">所有子字符串中的元音</a>  <a href="https://leetcode-cn.com/problems/house-robber" rel="nofollow" title="打家劫舍  ">打家劫舍  </a><a href="https://leetcode-cn.com/problems/house-robber-ii" rel="nofollow" title="打家劫舍 II">打家劫舍 II</a>  <a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/" rel="nofollow" title="解决智力问题  ">解决智力问题  </a><a href="https://leetcode-cn.com/problems/binary-trees-with-factors/" rel="nofollow" title="带因子的二叉树">带因子的二叉树</a><a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/" rel="nofollow" title=" 解决智力问题   "> 解决智力问题   </a></p> 
<p>  <a href="https://leetcode.cn/problems/partition-array-for-maximum-sum/" rel="nofollow" title="分隔数组以得到最大和">分隔数组以得到最大和</a> <a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/" rel="nofollow" title="可被三整除的最大和">可被三整除的最大和</a> <a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/" rel="nofollow" title="检查数组是否存在有效划分">检查数组是否存在有效划分</a> <a href="https://leetcode.cn/problems/letter-tile-possibilities/" rel="nofollow" title="活字印刷">活字印刷</a> <a href="https://leetcode.cn/problems/filling-bookcase-shelves/" rel="nofollow" title="填充书架">填充书架</a></p> 
<p><a href="https://leetcode.cn/problems/count-number-of-special-subsequences/" rel="nofollow" title="统计特殊子序列的数目">统计特殊子序列的数目</a></p> 
<p><strong>双序列：</strong></p> 
<p><a href="https://leetcode-cn.com/problems/regular-expression-matching" rel="nofollow" title="正则表达式匹配">正则表达式匹配</a>    <a href="https://leetcode-cn.com/problems/longest-common-subsequence" rel="nofollow" title="最长公共子序列">最长公共子序列</a>    <a href="https://leetcode-cn.com/problems/uncrossed-lines" rel="nofollow" title="不相交的线">不相交的线</a>   <a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" rel="nofollow" title="最长重复子数组">最长重复子数组</a>  <a href="https://leetcode-cn.com/problems/wildcard-matching" rel="nofollow" title="通配符匹配">通配符匹配</a></p> 
<p><a href="https://leetcode-cn.com/problems/edit-distance" rel="nofollow" title="编辑距离">编辑距离</a> <a href="https://leetcode-cn.com/problems/interleaving-string" rel="nofollow" title="  交错字符串">  交错字符串</a>   <a href="https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings" rel="nofollow" title="同源字符串检测">同源字符串检测</a>  <a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/" rel="nofollow" title="最长等差数列">最长等差数列</a> <a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/" rel="nofollow" title="最长的斐波那契子序列的长度">最长的斐波那契子序列的长度</a> <a href="https://leetcode-cn.com/problems/is-subsequence" rel="nofollow" title="判断子序列">判断子序列</a> <a href="https://leetcode-cn.com/problems/21dk04" rel="nofollow" title="子序列的数目">子序列的数目</a> <a href="https://leetcode.cn/problems/selling-pieces-of-wood/" rel="nofollow" title="卖木头块">卖木头块</a> <a href="https://leetcode.cn/problems/filling-bookcase-shelves/" rel="nofollow" title="填充书架">填充书架</a></p> 
<p><strong>区间动态规划：</strong></p> 
<p><a href="https://leetcode-cn.com/problems/omKAoA" rel="nofollow" title="最少回文分割  ">最少回文分割  </a><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii" rel="nofollow" title="猜数字大小 II">猜数字大小 II</a> <a href="https://leetcode-cn.com/problems/burst-balloons/" rel="nofollow" title="戳气球">戳气球</a> <a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/" rel="nofollow" title="为运算表达式设计优先级">为运算表达式设计优先级</a> <a href="https://leetcode-cn.com/problems/predict-the-winner/" rel="nofollow" title="预测赢家 ">预测赢家 </a><a href="https://leetcode-cn.com/problems/largest-sum-of-averages/" rel="nofollow" title="最大平均值和的分组 ">最大平均值和的分组 </a><a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/" rel="nofollow" title="多边形三角剖分的最低得分">多边形三角剖分的最低得分</a></p> 
<p><strong>状态转移动态规划：</strong></p> 
<p><a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/" rel="nofollow" title="删除一次得到子数组最大和">删除一次得到子数组最大和</a>  <a href="https://leetcode.cn/problems/maximum-subarray-sum-after-one-operation/" rel="nofollow" title="经过一次操作后的最大子数组和">经过一次操作后的最大子数组和</a> <a href="https://leetcode.cn/problems/maximum-alternating-subarray-sum/" rel="nofollow" title="最大交替子数组和">最大交替子数组和</a> <a href="https://leetcode.cn/problems/domino-and-tromino-tiling/" rel="nofollow" title="多米诺和托米诺平铺">多米诺和托米诺平铺</a> <a href="https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/" rel="nofollow" title="统计只差一个字符的子串数目">统计只差一个字符的子串数目</a> <a href="https://leetcode.cn/problems/student-attendance-record-ii/" rel="nofollow" title="学生出勤记录 II">学生出勤记录 II</a></p> 
<p><strong>背包问题：</strong></p> 
<p><a href="https://leetcode-cn.com/problems/coin-change" rel="nofollow" title="零钱兑换">零钱兑换</a>  <a href="https://leetcode-cn.com/problems/combination-sum-iv" rel="nofollow" title="组合总和 Ⅳ">组合总和 Ⅳ</a> <a href="https://leetcode-cn.com/problems/coin-change-2" rel="nofollow" title=" 零钱兑换 II"> 零钱兑换 II</a>  <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" rel="nofollow" title="分割等和子集">分割等和子集</a>  <a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/" rel="nofollow" title="划分为k个相等的子集 ">划分为k个相等的子集 </a></p> 
<p>. <a href="https://leetcode-cn.com/problems/ones-and-zeroes" rel="nofollow" title="一和零">一和零</a>（双序列背包） <a href="https://leetcode-cn.com/problems/target-sum" rel="nofollow" title="目标和">目标和</a>   <a href="https://leetcode-cn.com/problems/word-break" rel="nofollow" title="单词拆分 ">单词拆分 </a><a href="https://leetcode-cn.com/problems/soup-servings/" rel="nofollow" title="分汤  ">分汤  </a><a href="https://leetcode-cn.com/problems/number-of-ways-to-buy-pens-and-pencils/" rel="nofollow" title="买钢笔和铅笔的方案数">买钢笔和铅笔的方案数</a></p> 
<p><strong>路径动态规划：</strong></p> 
<p><a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones" rel="nofollow" title="统计全为 1 的正方形子矩阵">统计全为 1 的正方形子矩阵</a> <a href="https://leetcode-cn.com/problems/maximal-square" rel="nofollow" title="最大正方形">最大正方形</a><a href="https://leetcode-cn.com/problems/IlPe0q" rel="nofollow" title=" 三角形中最小路径之和"> 三角形中最小路径之和</a> <a href="https://leetcode-cn.com/problems/largest-plus-sign/" rel="nofollow" title="最大加号标志">最大加号标志</a></p> 
<p><a href="https://leetcode-cn.com/problems/minimum-path-sum" rel="nofollow" title="最小路径和">最小路径和</a>  <a href="https://leetcode-cn.com/problems/unique-paths-ii" rel="nofollow" title="不同路径 II">不同路径 II</a>  <a href="https://leetcode-cn.com/problems/dungeon-game/" rel="nofollow" title="地下城游戏">地下城游戏</a>  <a href="https://leetcode-cn.com/problems/01-matrix" rel="nofollow" title="01 矩阵">01 矩阵</a> <a href="https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land/" rel="nofollow" title="统计农场中肥沃金字塔的数目">统计农场中肥沃金字塔的数目</a> <a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" rel="nofollow" title="出界的路径数  ">出界的路径数  </a><a href="https://leetcode-cn.com/problems/longest-line-of-consecutive-one-in-matrix/" rel="nofollow" title="​​​​​​矩阵中最长的连续1线段">​​​​​​矩阵中最长的连续1线段</a><a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" rel="nofollow" title="  出界的路径数   ">  出界的路径数   </a><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/" rel="nofollow" title="K 站中转内最便宜的航班">K 站中转内最便宜的航班</a>  <a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/" rel="nofollow" title="网格图中递增路径的数目">网格图中递增路径的数目</a></p> 
<p><strong>决策动态规划：</strong></p> 
<p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" rel="nofollow" title="188. 买卖股票的最佳时机 IV">188. 买卖股票的最佳时机 IV</a>  <br><a href="https://leetcode-cn.com/problems/new-21-game/" rel="nofollow" title="新 21 点">新 21 点</a>  <a href="https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/" rel="nofollow" title="926. 将字符串翻转到单调递增  ">926. 将字符串翻转到单调递增  </a></p> 
<p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" rel="nofollow" title="乘积最大子数组">乘积最大子数组</a> <a href="https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/" rel="nofollow" title="乘积为正数的最长子数组长度">乘积为正数的最长子数组长度</a> <a href="https://leetcode-cn.com/problems/ugly-number-ii/" rel="nofollow" title="丑数 II">丑数 II</a>  <a href="https://leetcode-cn.com/problems/beautiful-arrangement/" rel="nofollow" title="优美的排列">优美的排列</a> <a href="https://leetcode-cn.com/problems/2-keys-keyboard/" rel="nofollow" title="只有两个键的键盘  ">只有两个键的键盘  </a><a href="https://leetcode-cn.com/problems/flip-game-ii/" rel="nofollow" title="翻转游戏 II">翻转游戏 II</a> <a href="https://leetcode.cn/problems/count-ways-to-distribute-candies/" rel="nofollow" title="计算分配糖果的不同方式">计算分配糖果的不同方式</a> <a href="https://leetcode.cn/problems/stone-game-ii/" rel="nofollow" title="石子游戏 II">石子游戏 II</a></p> 
<p><strong>动态规划与树结合：</strong></p> 
<p><a href="https://leetcode-cn.com/problems/house-robber-iii" rel="nofollow" title="打家劫舍 III   ">打家劫舍 III   </a><a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/" rel="nofollow" title="二叉树中的最长交错路径">二叉树中的最长交错路径</a> <a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/" rel="nofollow" title="二叉搜索子树的最大键值和">二叉搜索子树的最大键值和</a>  <a href="https://leetcode.cn/problems/count-number-of-possible-root-nodes/" rel="nofollow" title="统计可能的树根数目">统计可能的树根数目</a> <a href="https://leetcode.cn/problems/sum-of-distances-in-tree/" rel="nofollow" title="树中距离之和">树中距离之和</a></p> 
<p><strong>数位动态规划</strong></p> 
<p><a href="https://leetcode.cn/problems/numbers-with-repeated-digits/" rel="nofollow" title="至少有 1 位重复的数字">至少有 1 位重复的数字</a>  <a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/" rel="nofollow" title="不含连续1的非负整数">不含连续1的非负整数</a></p> 
<p><strong>倍增  </strong></p> 
<p><a href="https://leetcode.cn/problems/powx-n/" rel="nofollow" title="Pow(x, n)">Pow(x, n)</a>  <a href="https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/" rel="nofollow" title="在传球游戏中最大化函数值">在传球游戏中最大化函数值</a></p> 
<h4>单序列</h4> 
<p>1、<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" rel="nofollow" title="最长递增子序列">最长递增子序列</a>  </p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, n):
    for j in range(0, i):
        if nums[j] &lt; nums[i]:
            dp[i] = max(dp[i], dp[j] + 1)
        if dp[i] &gt; maxl:
            maxl = dp[i]</code></pre> 
<p>注：采用动态规划的方法的时间复杂度为O(n^2), 最优的方法是采用二分插入的方法如下所示：</p> 
<pre style="margin-left:0;"><code class="language-python">LIS = [nums[0]]
for num in nums[1:]:
    if num &gt; LIS[-1]:
        LIS.append(num)
    else:
        index = bisect_left(LIS, num)
        LIS[index] = num
return len(LIS)</code></pre> 
<p> 如果求单调不递增的子序列还需要num &gt;= LIS[-1] 并且使用bisect_right，见<a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/" rel="nofollow" title="使数组 K 递增的最少操作次数">使数组 K 递增的最少操作次数</a></p> 
<p>2、<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" rel="nofollow" title="最长递增子序列的个数">最长递增子序列的个数</a></p> 
<pre style="margin-left:0;"><code class="language-python">nums = [-float('inf')] + nums + [float('inf')]
n = len(nums)
dp = [0] * n
for i in range(0, n - 1):
    for j in range(i + 1, n):
        if nums[j] &gt; nums[i]:
            dp[j] = max(dp[i] + 1, dp[j])

path = [1] + [0] * (n - 1)
for i in range(1, n):
    for j in range(0, i):
        if dp[i] == dp[j] + 1 and nums[i] &gt; nums[j]:
            path[i] += path[j]

return path[-1]</code></pre> 
<p> 同理，根据1的最优方法，我们可以对2的方法进行优化</p> 
<p>3、<a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" rel="nofollow" title="最长连续递增序列">最长连续递增序列</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, n):
    if nums[i - 1] &lt; nums[i]:
        dp[i] = max(dp[i], dp[i - 1] + 1)
    if dp[i] &gt; maxl:
        maxl = dp[i]</code></pre> 
<p>4、<a href="https://leetcode-cn.com/problems/maximum-subarray/" rel="nofollow" title="最大子序和">最大子序和</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, n):
    dp[i] = max(dp[i], dp[i - 1] + nums[i])
    if dp[i] &gt; maxl:
        maxl = dp[i]</code></pre> 
<p>5、<a href="https://leetcode-cn.com/problems/largest-divisible-subset/" rel="nofollow" title="最大整除子集">最大整除子集</a>：</p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(n):
    for j in range(i + 1, n):
        if nums[j] % nums[i] == 0:
            dp[j] = max(dp[j], dp[i] + 1)</code></pre> 
<p>6、<a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/" rel="nofollow" title="最长定差子序列">最长定差子序列</a></p> 
<pre style="margin-left:0;"><code class="language-python">d = {}
for a in arr:
    d[a] = d.get(a - difference, 0) + 1
return max(d.values())</code></pre> 
<p>7、<a href="https://leetcode-cn.com/problems/climbing-stairs/" rel="nofollow" title="爬楼梯">爬楼梯</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(2, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]</code></pre> 
<p>8、<a href="https://leetcode-cn.com/problems/find-the-derangement-of-an-array/" rel="nofollow" title="寻找数组的错位排列">寻找数组的错位排列</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(2, n):
    dp[i] = (i - 1) * (dp[i - 1] + dp[i - 2])</code></pre> 
<p>9、 <a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/" rel="nofollow" title="使用最小花费爬楼梯">使用最小花费爬楼梯</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(2, len(cost) + 1):
    dp[i] = min(dp[i - 2] + cost[i - 2], dp[i - 1] + cost[i - 1])</code></pre> 
<p>10、<a href="https://leetcode-cn.com/problems/counting-bits/" rel="nofollow" title="比特位计数">比特位计数</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, n + 1):
    if i &amp; 1 == 0:
        dp[i] = dp[i &gt;&gt; 1]
    else:
        dp[i] = dp[i - 1] + 1</code></pre> 
<p>11、<a href="https://leetcode-cn.com/problems/rotated-digits/" rel="nofollow" title="旋转数字">旋转数字</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def rotatedDigits(self, N: int) -&gt; int:
        ans, dp = 0, [0, 0, 1, -1, -1, 1, 1, -1, 0, 1] + [0] * (N - 9)
        for i in range(N + 1):
            dp[i] = -1 in (dp[i // 10], dp[i % 10]) and -1 or dp[i // 10] | dp[i % 10]
            ans += dp[i] == 1
        return ans</code></pre> 
<p>12、<a href="https://leetcode-cn.com/problems/house-robber-ii/" rel="nofollow" title="打家劫舍 II">打家劫舍 II</a></p> 
<pre style="margin-left:0;"><code class="language-python">a, b = nums[0], max(nums[0], nums[1])
for i in range(2, len(nums) - 1):
    a = max(a + nums[i], b)
    b, a = a, b
res1 = b
a, b = nums[1], max(nums[1], nums[2])
for i in range(3, len(nums)):
    a = max(a + nums[i], b)
    b, a = a, b 
return max(b, res1)</code></pre> 
<p> 13、<a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/" rel="nofollow" title="解决智力问题">解决智力问题</a></p> 
<pre style="margin-left:0;"><code class="language-python">n = len(questions)
dp = [0] * (n + 1)
for i, q in enumerate(questions):
    dp[i + 1] = max(dp[i + 1], dp[i])
    j = min(i + q[1] + 1, n)
    dp[j] = max(dp[j], dp[i] + q[0])
return dp[n]</code></pre> 
<p>14、<a href="https://leetcode-cn.com/problems/paint-fence/" rel="nofollow" title="栅栏涂色">栅栏涂色</a></p> 
<pre style="margin-left:0;"><code class="language-python">if n == 1: return k
dp = [0] * (n + 1)
dp[1], dp[2] = k, k * k
for i in range(3, n + 1):
    dp[i] = dp[i - 1] * (k - 1) + dp[i - 2] * (k - 1)
return dp[-1]</code></pre> 
<p>15、<a href="https://leetcode-cn.com/problems/binary-trees-with-factors/" rel="nofollow" title="带因子的二叉树">带因子的二叉树</a></p> 
<pre style="margin-left:0;"><code class="language-python">arr.sort()
for i, a in enumerate(arr):
    dp[a] = 1
    for j in range(i):
        if a % arr[j] == 0 and a // arr[j] in set(arr):
            dp[a] += dp[arr[j]] * dp[a // arr[j]]

return sum(count for num, count in dp.items())
</code></pre> 
<p>16、<a href="https://leetcode.cn/problems/partition-array-for-maximum-sum/" rel="nofollow" title="分隔数组以得到最大和">分隔数组以得到最大和</a></p> 
<pre style="margin-left:0;"><code class="language-python">n = len(arr)
dp = [0] * (n + 1)
for i in range(1, n + 1):
    maxl = 0
    for j in range(i - 1, max(i - k, 0) - 1, - 1):
        maxl = max(maxl, arr[j])
        dp[i] = max(dp[i], dp[j] + maxl * (i - j))
return dp[-1]</code></pre> 
<p>17、<a href="https://leetcode.cn/problems/greatest-sum-divisible-by-three/" rel="nofollow" title="可被三整除的最大和">可被三整除的最大和</a></p> 
<pre style="margin-left:0;"><code class="language-python">dp = [0] * div
for n in nums:
    nw = [0] * div
    for d in range(div):
        nw[d] = dp[d] + n
    for t in nw:
        dp[t % div] = max(dp[t % div], t)    
return dp[0]</code></pre> 
<p>18、<a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/" rel="nofollow" title="检查数组是否存在有效划分">检查数组是否存在有效划分</a></p> 
<pre style="margin-left:0;"><code class="language-python">dp = [True] + [False] * len(nums)
for i in range(1, len(nums)):
    dp[i + 1] |= dp[i - 1] and nums[i] == nums[i - 1]
    dp[i + 1] |= dp[i - 2] and nums[i] == nums[i - 1] and nums[i] == nums[i - 2]
    dp[i + 1] |= dp[i - 2] and nums[i] - nums[i - 1] == 1 and nums[i - 1] - nums[i - 2] == 1
return dp[-1]</code></pre> 
<p>该题也可以用贪心去做，但是贪心的过程较为繁琐，而且时间复杂度也为O(n) </p> 
<p>19、<a href="https://leetcode.cn/problems/letter-tile-possibilities/" rel="nofollow" title="活字印刷">活字印刷</a> （动态规划 + 组合数学）</p> 
<pre style="margin-left:0;"><code class="language-python">dp, cv, alllen = [1] + [0] * len(tiles), Counter(tiles).values(), 0
for v in cv:
    alllen += v
    for i in range(alllen, 0, -1): 
        dp[i] += sum(dp[i - j] * math.comb(i, j) for j in range(1, min(i,v) + 1))
return sum(dp) - 1</code></pre> 
<p>20、<a href="https://leetcode.cn/problems/filling-bookcase-shelves/" rel="nofollow" title="填充书架">填充书架</a> </p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(books) + 1):
    tmp_width, j, h = 0, i, 0
    while j &gt; 0:
        tmp_width += books[j - 1][0]
        if tmp_width &gt; shelf_width:
            break
        h = max(h, books[j - 1][1])
        dp[i] = min(dp[i], dp[j - 1] + h)
        j -= 1
return dp[-1]</code></pre> 
<p>21、<a href="https://leetcode.cn/problems/count-number-of-special-subsequences/" rel="nofollow" title="统计特殊子序列的数目">统计特殊子序列的数目</a> </p> 
<pre><code class="language-python">class Solution:
    def countSpecialSubsequences(self, nums: List[int]) -&gt; int:
        mod = 10**9 + 7
        f0 = f1 = f2 = 0
        for num in nums:
            if num == 0:
                f0 = (f0 * 2 + 1) % mod
            elif num == 1:
                f1 = (f1 * 2 + f0) % mod
            else:
                f2 = (f2 * 2 + f1) % mod
        return f2</code></pre> 
<h4>双序列</h4> 
<p>1、<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" rel="nofollow" title="最长公共子序列">最长公共子序列</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(text1) + 1):
    for j in range(1, len(text2) + 1):
        if text1[i - 1] == text2[j - 1]:
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></pre> 
<p>2、 <a href="https://leetcode-cn.com/problems/uncrossed-lines/" rel="nofollow" title="不相交的线">不相交的线</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(nums1) + 1):
    for j in range(1, len(nums2) + 1):
        if nums1[i - 1] == nums2[j - 1]:
            dp[i][j] = dp[i - 1][j - 1] + 1
        else:
            dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])</code></pre> 
<p>3、<a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" rel="nofollow" title="最长重复子数组">最长重复子数组</a></p> 
<pre style="margin-left:0;"><code class="language-python">m, n = len(nums1), len(nums2)
dp = [[0] * (n + 1) for _ in range(m + 1)]
maxl = 0
for i in range(1, m + 1):
    for j in range(1, n + 1):
        if nums1[i - 1] == nums2[j - 1]:
            dp[i][j] = dp[i - 1][j - 1] + 1
        if dp[i][j] &gt; maxl:
            maxl = dp[i][j]
return maxl</code></pre> 
<p>注：使用滑动窗口的方法可以使时间复杂度降到O((m + n) *min(m, n)), 空间复杂度降为O(1)</p> 
<pre style="margin-left:0;"><code class="language-python">m, n = len(nums1), len(nums2)
maxl = 0
for d in range(1 - m, n):
    l = 0
    for i in range(max(0, -d), min(m, n - d)):
        if nums1[i] == nums2[i + d]:
            l += 1
            maxl = max(maxl, l)
        else: l = 0
return maxl</code></pre> 
<p> 还可以使用二分查找+哈希的方法使得时间复杂度降为O((m + n) *log(min(m, n)))</p> 
<p>4、 <a href="https://leetcode-cn.com/problems/wildcard-matching/" rel="nofollow" title="通配符匹配">通配符匹配</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(p) + 1):
    for j in range(1, len(s) + 1):
        if p[i - 1] == '?':
            dp[i][j] = dp[i - 1][j - 1]
        elif p[i - 1] == '*':
            dp[i][j] = dp[i - 1][j] or dp[i - 1][j - 1] or dp[i][j - 1]
        elif p[i - 1] == s[j - 1]:
            dp[i][j] = dp[i - 1][j - 1]
        else:
            dp[i][j] = False</code></pre> 
<p>5、<a href="https://leetcode-cn.com/problems/regular-expression-matching/" rel="nofollow" title="正则表达式匹配">正则表达式匹配</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(p) + 1):
    for j in range(1, len(s) + 1):
        if p[i - 1] == s[j - 1] or p[i - 1] == '.':
            dp[i][j] = dp[i - 1][j - 1]
        elif p[i - 1] == '*':
            if p[i - 2] == s[j - 1] or p[i - 2] == '.':
                dp[i][j] = dp[i - 2][j] or dp[i][j - 1]
            else:
                dp[i][j] = dp[i - 2][j]
        else:
            dp[i][j] = False</code></pre> 
<p>6、<a href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence/" rel="nofollow" title="最长等差数列">最长等差数列</a></p> 
<pre style="margin-left:0;"><code class="language-python">dp = dict()
for cur in range(1, len(nums)):
    for prev in range(cur):
        diff = nums[cur] - nums[prev]
        dp[(cur, diff)] = dp.get((prev, diff), 1) + 1
return max(dp.values())</code></pre> 
<p>7、<a href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/" rel="nofollow" title="最长的斐波那契子序列的长度">最长的斐波那契子序列的长度</a></p> 
<pre style="margin-left:0;"><code class="language-python">index = {x: i for i, x in enumerate(A)}
longest = collections.defaultdict(lambda: 2)

ans = 0
for k, z in enumerate(A):
    for j in range(k):
        i = index.get(z - A[j], None)
        if i is not None and i &lt; j:
            cand = longest[j, k] = longest[i, j] + 1
            ans = max(ans, cand)

return ans if ans &gt;= 3 else 0</code></pre> 
<p>8、<a href="https://leetcode-cn.com/problems/is-subsequence/" rel="nofollow" title="判断子序列">判断子序列</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(s) + 1):
    for j in range(1, len(t) + 1):
        if s[i - 1] == t[j - 1]:
            dp[i][j] = dp[i - 1][j - 1]
        else:
            dp[i][j] = dp[i][j - 1]</code></pre> 
<p>该方法可以使用双指针进行求解 </p> 
<p>9、<a href="https://leetcode-cn.com/submissions/detail/210716100/" rel="nofollow" title="子序列的数目">子序列的数目</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(t) + 1):
    for j in range(i, len(s) + 1):
        if t[i - 1] == s[j - 1]:
            dp[j] = dp[i - 1][j - 1] + dp[i][j - 1]
        else:
            dp[j] = dp[i][j - 1]
</code></pre> 
<p>10、 <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" rel="nofollow" title="通过删除字母匹配到字典里最长单词">通过删除字母匹配到字典里最长单词</a></p> 
<p> 类似于判断子序列，可以采用双指针进行求解，本题是一个长串匹配多个短串，可以采用动态的方法构造状态转移矩阵，减少长串指针的空跳</p> 
<p>构造过程：</p> 
<pre style="margin-left:0;"><code class="language-python">m, set_s = len(s), set(s)
f = [defaultdict(lambda: m) for _ in range(m + 1)]

for i in reversed(range(m)):
    for c in set_s:
        if s[i] == c:
            f[i][ord(c) - ord('a')] = i
        else:
            f[i][ord(c) - ord('a')] = f[i + 1][ord(c) - ord('a')]</code></pre> 
<p>匹配过程：</p> 
<pre style="margin-left:0;"><code class="language-python">res = ""
for t in dictionary:
    match = True
    j = 0
    for i in range(len(t)):
        if f[j][ord(t[i]) - ord('a')] == m:
            match = False
            break
        j = f[j][ord(t[i]) - ord('a')] + 1
    if match:
        if len(t) &gt; len(res) or (len(t) == len(res) and t &lt; res):
            res = t
return res</code></pre> 
<p> 11、<a href="https://leetcode-cn.com/problems/interleaving-string/" rel="nofollow" title="交错字符串">交错字符串</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(len(s1) + 1):
    for j in range(len(s2) + 1):
        if i &gt; 0 and s1[i - 1] == s3[i + j - 1]:
            dp[i][j] = dp[i][j] or dp[i - 1][j]
        if j &gt; 0 and s2[j - 1] == s3[i + j - 1]:
            dp[i][j] = dp[i][j] or dp[i][j - 1]</code></pre> 
<p> 12、<a href="https://leetcode-cn.com/problems/edit-distance/" rel="nofollow" title="编辑距离">编辑距离</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(word1)+1):
    for j in range(1, len(word2)+1):
        if word1[i - 1] == word2[j - 1]:
            dp[i][j] = dp[i - 1][j -1]
        else:
            dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1)</code></pre> 
<p>13、<a href="https://leetcode.cn/problems/selling-pieces-of-wood/" rel="nofollow" title="卖木头块">卖木头块</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, m + 1):
    for j in range(1, n + 1):
        dp[i][j] = mp[i, j]
        for k in range(1, j + 1):
            dp[i][j] = max(dp[i][j], dp[i][j - k] + dp[i][k])
        for l in range(1, i + 1):                      
            dp[i][j] = max(dp[i][j], dp[i - l][j] + dp[l][j])</code></pre> 
<h4>区间动态规划</h4> 
<p>1、<a href="/" rel="nofollow">猜数字大小 II</a></p> 
<pre style="margin-left:0;"><code class="language-python">for j in range(2, n + 1):
    for i in reversed(range(1, j)):             
        f[i][j] = min(max(f[i][x - 1], f[x + 1][j]) + x for x in range(i, j))
return f[1][n]
</code></pre> 
<p>2、<a href="https://leetcode-cn.com/problems/omKAoA/" rel="nofollow" title="最少回文分割">最少回文分割</a></p> 
<pre style="margin-left:0;"><code class="language-python">#求取区间是否是回文串
for l in range(n-1, -1, -1):
    for r in range(l + 1, n):
        if s[l] == s[r]:
            if l + 1 == r:
                f[l][r] = True
            else:
                f[l][r] = f[l + 1][r - 1]</code></pre> 
<pre style="margin-left:0;"><code class="language-python">#求取最小分割
for i in range(1, len(s)):
    dp[i] = 0 if f[0][i] else i
    for j in range(1, i + 1):
        if f[j][i]:
            dp[i] = min(dp[i], dp[j - 1] + 1)</code></pre> 
<p>3、<a href="https://leetcode-cn.com/problems/burst-balloons/" rel="nofollow" title="戳气球">戳气球</a> </p> 
<pre style="margin-left:0;"><code class="language-python">for i in reversed(range(n)):
    for j in range(i + 2, n + 2):
        for k in range(i + 1, j):
            val = nums[i] * nums[k] * nums[j]
            dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + val)</code></pre> 
<p>4、<a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/" rel="nofollow" title="为运算表达式设计优先级">为运算表达式设计优先级</a> </p> 
<pre style="margin-left:0;"><code class="language-python">nums = [int(num) for num in re.split("[+\-*]", input)]
opts = re.sub('[0-9]', "", input)
opt_m = {'+':(lambda x, y:x+ y), '-':(lambda x, y:x - y), '*':(lambda x, y:x * y)}
dp = [[[] for _ in range(len(nums))] for _ in range(len(nums))]


for j in range(len(nums)):
    for i in reversed(range(j + 1)):
        if i == j:
            dp[i][j].append(nums[i])
        else:
            for k in range(i, j):                   
                dp[i][j].extend([opt_m[opts[k]](x,y) for x, y in product(dp[i][k], dp[k + 1][j])])</code></pre> 
<p>5、<a href="https://leetcode-cn.com/problems/predict-the-winner/" rel="nofollow" title="预测赢家">预测赢家</a></p> 
<pre style="margin-left:0;"><code class="language-python">length = len(nums)
dp = [[0] * length for _ in range(length)]
for i, num in enumerate(nums):
    dp[i][i] = num
for i in range(length - 2, -1, -1):
    for j in range(i + 1, length):
        dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1])
return dp[0][length - 1] &gt;= 0</code></pre> 
<p>6、 <a href="https://leetcode-cn.com/problems/largest-sum-of-averages/" rel="nofollow" title="最大平均值和的分组">最大平均值和的分组</a></p> 
<pre style="margin-left:0;"><code class="language-python">P, N = [0], len(nums)
for x in nums: P.append(P[-1] + x)
def average(i, j):
    return (P[j] - P[i]) / float(j - i)

dp = [average(i, N) for i in range(N)]
for k in range(K-1):
    for i in range(N):
        for j in range(i+1, N):
            dp[i] = max(dp[i], average(i, j) + dp[j])

return dp[0]</code></pre> 
<p>7、<a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/" rel="nofollow" title="多边形三角剖分的最低得分">多边形三角剖分的最低得分</a></p> 
<pre style="margin-left:0;"><code class="language-python">n = len(A)
dp = [[inf] * n for _ in range(n)]
for i in range(n - 1):
    dp[i][i + 1] = 0
for i in reversed(range(n)):
    for j in range(i + 2, n):
        for k in range(i + 1, j):
            dp[i][j] = min(dp[i][j], dp[i][k] + A[i] * A[k] * A[j] + dp[k][j])
return dp[0][-1]</code></pre> 
<h4>状态转移动态规划</h4> 
<p>1、<a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/" rel="nofollow" title="删除一次得到子数组最大和">删除一次得到子数组最大和</a></p> 
<pre style="margin-left:0;"><code class="language-python">dp0, dp1, ans = arr[0], 0, arr[0]
for i in arr[1:]:
    dp1 = max(dp1 + i, dp0)
    dp0 = max(dp0 + i, i)
    ans = max(ans, dp0, dp1)
return ans</code></pre> 
<p>2、<a href="https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/" rel="nofollow" title="删除一次得到子数组最大和">删除一次得到子数组最大和</a></p> 
<pre style="margin-left:0;"><code class="language-python">dp0, dp1 = nums[0], max(nums[0], nums[0] ** 2)
maxl = max(dp0, dp1)
for i in range(1, len(nums)):
    dp1 = max(dp1 + nums[i], max(dp0, 0) + nums[i] ** 2)
    dp0 = max(dp0 + nums[i], nums[i])
    maxl = max(maxl, dp0, dp1)
return maxl</code></pre> 
<p>3、<a href="https://leetcode.cn/problems/maximum-alternating-subarray-sum/" rel="nofollow" title="最大交替子数组和">最大交替子数组和</a></p> 
<pre style="margin-left:0;"><code class="language-python">ans, dp0, dp1 = nums[0], nums[0], -inf
for num in nums[1:]:
    dp0, dp1 = max(num, dp1 + num), dp0 - num
    ans = max(ans, dp0, dp1)
return ans</code></pre> 
<p> 4、<a href="https://leetcode-cn.com/problems/domino-and-tromino-tiling/" rel="nofollow" title="多米诺和托米诺平铺">多米诺和托米诺平铺</a> </p> 
<pre style="margin-left:0;"><code class="language-python">#dp1[k] 总计k列，最后一列满的种数
#dp2[k] 总计k列，最后一列差一个满
dp1, dp2 = [0] * (max(3, n + 1)), [0] * (max(3, n + 1))
dp2[1], dp2[2] = 0, 2
dp1[1], dp1[2] = 1, 2
for i in range(3, n + 1):
    dp2[i] = dp2[i - 1] + 2 *dp1[i - 2]
    dp1[i] = dp1[i - 1] + dp1[i - 2] + dp2[i - 1]
return dp1[n] % (10 ** 9 + 7)</code></pre> 
<p>5、<a href="https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/" rel="nofollow" title="统计只差一个字符的子串数目">统计只差一个字符的子串数目</a></p> 
<p>        cnt[i-1][j-1]为以<code>s[i-1]</code>和<code>t[j-1]</code>结尾的恰好只有一个字符不同的子串对数目<code>，same[i][j]</code>记录以<code>s[i]</code>和<code>t[j]</code>结尾的连续相同的字符数量。</p> 
<p><img alt="" height="277" src="https://images2.imgbox.com/bb/cb/am7GHpU1_o.png" width="904"></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def countSubstrings(self, s: str, t: str) -&gt; int:
        m, n = len(s), len(t)
        dp = [(0, 0)]*(n+1) # 记录 (以s[i]和t[j]结尾的 满足条件的子字符串对数目, 连续相同的位数)
        tot = 0   # 总的满足条件的子字符串对数目
        for i in range(m):
            last = dp[0]
            for j in range(n):
                if s[i] == t[j]:
                    cur = (dp[j][0], dp[j][1] + 1)
                    tot += dp[j][0]
                else:
                    cur = (dp[j][1] + 1, 0)
                    tot += dp[j][1] + 1
                dp[j], last = last, cur
            dp[n] = last
        return tot</code></pre> 
<p>6、 <a href="https://leetcode.cn/problems/student-attendance-record-ii/" rel="nofollow" title="学生出勤记录 II">学生出勤记录 II</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def checkRecord(self, n: int) -&gt; int:
        mod = 10 ** 9 + 7
        dp = [[0] * 2  for _ in range(3)]
        dp[0][0] = 1
        for i in range(n):
            tp = [[0] * 2  for _ in range(3)]
            #以A为结尾
            for j in range(3):
                tp[0][1] = (tp[0][1] + dp[j][0]) % mod
            
            #以P为结尾
            for j in range(3):
                for k in range(2):
                    tp[0][k] = (tp[0][k] + dp[j][k]) % mod

            #以L为结尾
            for j in range(1, 3):
                for k in range(2):
                    tp[j][k] = (tp[j][k] + dp[j - 1][k]) % mod
                  
            dp = tp
        return sum([sum(p) for p in dp]) % mod</code></pre> 
<p>本题还可以使用快速幂的方法将时间复杂度降为O(logn)<img alt="" src="https://images2.imgbox.com/9c/a7/YFHAL5OJ_o.png"></p> 
<p> 代码如下：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def checkRecord(self, n: int) -&gt; int:
        MOD = 10**9 + 7
        mat = [
            [1, 1, 0, 1, 0, 0],
            [1, 0, 1, 1, 0, 0],
            [1, 0, 0, 1, 0, 0],
            [0, 0, 0, 1, 1, 0],
            [0, 0, 0, 1, 0, 1],
            [0, 0, 0, 1, 0, 0],
        ]
        
        def multiply(a: List[List[int]], b: List[List[int]]) -&gt; List[List[int]]:
            rows, columns, temp = len(a), len(b[0]), len(b)
            c = [[0] * columns for _ in range(rows)]
            for i in range(rows):
                for j in range(columns):
                    for k in range(temp):
                        c[i][j] += a[i][k] * b[k][j]
                        c[i][j] %= MOD
            return c
        
        def matrixPow(mat: List[List[int]], n: int) -&gt; List[List[int]]:
            ret = [[1, 0, 0, 0, 0, 0]]
            while n &gt; 0:
                if (n &amp; 1) == 1:
                    ret = multiply(ret, mat)
                n &gt;&gt;= 1
                mat = multiply(mat, mat)
            return ret

        res = matrixPow(mat, n)
        ans = sum(res[0])
        return ans % MOD

</code></pre> 
<h4>背包问题</h4> 
<p>1、<a href="https://leetcode-cn.com/problems/coin-change" rel="nofollow" title="零钱兑换">零钱兑换</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(amount + 1):
    for coin in coins:
        if i - coin &gt;= 0:
            dp[i] = min(dp[i], 1 + dp[i - coin])</code></pre> 
<p>2、<a href="https://leetcode-cn.com/problems/coin-change-2/" rel="nofollow" title="零钱兑换II">零钱兑换II</a>  （单序列完全背包，正向遍历， 无放入顺序）</p> 
<pre style="margin-left:0;"><code class="language-python">for coin in coins:
    for i in range(amount + 1):
        if i - coin &gt;= 0:
            dp[i] = dp[i] + dp[i - coin]</code></pre> 
<p>3、<a href="https://leetcode-cn.com/problems/number-of-ways-to-buy-pens-and-pencils/" rel="nofollow" title="买钢笔和铅笔的方案数">买钢笔和铅笔的方案数</a></p> 
<pre style="margin-left:0;"><code class="language-python">dp = [1] + (total) * [0]
for cost in (cost1, cost2):
    for i in range(1, total + 1):
        if i - cost &gt;= 0:
            dp[i] += dp[i - cost]
return sum(dp)</code></pre> 
<p>该题最优的方法是使用乘法原理：</p> 
<pre style="margin-left:0;"><code class="language-python">res = 0
for i in range(total // cost1 + 1):
    res += math.ceil((total-cost1 * i) // cost2 + 1)</code></pre> 
<p>3、<a href="https://leetcode-cn.com/problems/combination-sum-iv/" rel="nofollow" title="组合总和Ⅳ">组合总和Ⅳ</a> （单序列完全背包，正向遍历， 有放入顺序）</p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(target + 1):
    for num in nums:
        if i - num &gt;= 0:
            dp[i] = dp[i] + dp[i - num]
</code></pre> 
<p>4、 <a href="https://leetcode-cn.com/problems/ones-and-zeroes" rel="nofollow" title="一和零">一和零</a>（双序列01背包，逆向遍历）</p> 
<pre style="margin-left:0;"><code class="language-python">for s in strs:
    c0, c1 = s.count('0'), s.count('1')
    for i in reversed(range(c0, m + 1)):
        for j in reversed(range(c1, n + 1)):
            dp[i][j] = max(dp[i][j], dp[i - c0][j - c1] + 1)</code></pre> 
<p>5、<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" rel="nofollow" title="分割等和子集">分割等和子集</a> （单序列01背包）</p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(nums)):     
    for j in range(1, target + 1):
        dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i]]</code></pre> 
<p>6、<a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/" rel="nofollow" title="划分为k个相等的子集">划分为k个相等的子集</a> </p> 
<pre style="margin-left:0;"><code class="language-python">size, n = 1 &lt;&lt; len(nums), len(nums)
dp, s = [False] * size, [0] * size
dp[0] = True
for i in range(size):
    if not dp[i]: continue
    for j in range(n):
        if i &amp; (1 &lt;&lt; j) != 0:
            continue
        next_i = i | (1 &lt;&lt; j)
        if dp[next_i]: continue
        if (s[i] % side) + nums[j] &lt;= side:
            s[next_i] = s[i] + nums[j]
            dp[next_i] = True
        else: break
return dp[-1]</code></pre> 
<p>7、<a href="https://leetcode-cn.com/problems/perfect-squares/" rel="nofollow" title="完全平方数">完全平方数</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, n + 1):
    j = 1
    while j * j &lt;= n:
        if i - j * j &gt;= 0:
            dp[i] = min(dp[i - j * j] + 1, dp[i])
            j += 1
        else:
            break</code></pre> 
<p>8、<a href="https://leetcode-cn.com/problems/target-sum/" rel="nofollow" title="目标和">目标和</a></p> 
<pre style="margin-left:0;"><code class="language-python">for num in nums:
    for j in range((s + t) // 2, num - 1, -1):
        dp[j] += dp[j - num]</code></pre> 
<p> 9、<a href="https://leetcode-cn.com/problems/word-break/" rel="nofollow" title="单词拆分">单词拆分</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(len(s)):
    for word in wordDict:
        if s[i + 1 - len(word): i + 1] == word:
            dp[i + 1] = dp[i + 1] or dp[i + 1 - len(word)]</code></pre> 
<p>10、<a href="https://leetcode-cn.com/problems/soup-servings/" rel="nofollow" title="分汤">分汤</a>（双序列完全背包，正向遍历）</p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, n + 1):
    for j in range(1, n + 1):
        dp[i][j] = 0.25 * (dp[max(i - 4, 0)][j] + dp[max(i - 3, 0)][j - 1] + 
        dp[max(i - 2, 0)][max(j - 2, 0)] + dp[i - 1][max(j - 3, 0)])</code></pre> 
<p>当维数过大，或者维数不确定时，使用自底向上动态规划容易造成维数灾难，例如：<a href="https://leetcode-cn.com/problems/shopping-offers/" rel="nofollow" title="638. 大礼包">638. 大礼包</a>，所以应该使用自顶向下的记忆化搜索的方法。</p> 
<p>对于所给数据如果有一定特征，可以使用贪心的算法来优化，例如：<a href="https://leetcode.cn/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/" rel="nofollow" title="和为 K 的最少斐波那契数字数目">和为 K 的最少斐波那契数字数目</a></p> 
<h4>路径动态规划</h4> 
<p>1、<a href="https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones" rel="nofollow" title="统计全为 1 的正方形子矩阵">统计全为 1 的正方形子矩阵</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(0, m):
    for j in range(0, n):
        if i == 0 or j == 0:
            dp[i][j] = matrix[i][j]
        elif matrix[i][j] == 1:
            dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1
        c += dp[i][j]</code></pre> 
<p>2、<a href="https://leetcode-cn.com/problems/maximal-square/" rel="nofollow" title="最大正方形">最大正方形</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(0, m):
    for j in range(0, n):
        if i == 0 or j == 0:
            dp[i][j] = int(matrix[i][j])
        elif matrix[i][j] == '1':
            dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1
        max_c = max(max_c, dp[i][j])</code></pre> 
<p>3、 <a href="https://leetcode-cn.com/problems/IlPe0q/" rel="nofollow" title="三角形中最小路径之和">三角形中最小路径之和</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, len(triangle)):
    for j in range(len(triangle[i])):
        if j == 0:
            triangle[i][j] = triangle[i -1][0] + triangle[i][j]
        elif j == len(triangle[i]) - 1:
            triangle[i][j] = triangle[i -1][j - 1] + triangle[i][j]
        else:
            triangle[i][j] = min(triangle[i -1][j - 1], triangle[i -1][j]) + triangle[i][j]</code></pre> 
<p> 4、<a href="https://leetcode-cn.com/problems/minimum-path-sum/" rel="nofollow" title="最小路径和">最小路径和</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(len(grid)):
    for j in range(len(grid[i])):
        if i == 0 and j &gt; 0:
            dp[j] = dp[j - 1] + grid[i][j]
        elif j == 0 and i &gt; 0:
            dp[j] = dp[j] + grid[i][j]
        elif j &gt; 0 and  i &gt; 0:
            dp[j] = min(dp[j - 1] + grid[i][j], dp[j] + grid[i][j])</code></pre> 
<p>5、<a href="https://leetcode-cn.com/problems/unique-paths-ii/" rel="nofollow" title="不同路径 II">不同路径 II</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(0, m):
    for j in range(0, n):
        if obstacleGrid[i][j] == 1:
            dp[j] = 0
        elif i &gt; 0 and j &gt; 0:
            dp[j] = dp[j] + dp[j - 1]
        elif j &gt; 0 and i == 0:
            dp[j] = dp[j - 1]</code></pre> 
<p>6、<a href="https://leetcode-cn.com/problems/dungeon-game/" rel="nofollow" title="地下城游戏">地下城游戏</a>（不同路径的逆向遍历）</p> 
<pre style="margin-left:0;"><code class="language-python">m, n = len(dungeon), len(dungeon[0])
dp = [[[0, 0] for _ in range(n)] for _ in range(m)]
for i, j in product(reversed(range(m)), reversed(range(n))):
    if i == m - 1 and j == n - 1:
        dp[i][j] = min(0, dungeon[i][j])
    elif i == m - 1:
        dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])
    elif j == n - 1:
        dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])
    else:
        dp[i][j] = min(0, max(dp[i][j + 1], dp[i + 1][j]) + dungeon[i][j]) 
return -dp[0][0] + 1</code></pre> 
<p>7、<a href="/" rel="nofollow">01 矩阵</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(m):
    for j in range(n):
        if mat[i][j] == 0:
            dist[i][j] = 0
        if i &gt; 0:
            dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1)
        if j &gt; 0:
            dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1)
for i in range(m - 1, -1, -1):
    for j in range(n - 1, -1, -1):
        if i &lt; m - 1:
            dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1)
        if j &lt; n - 1:
            dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1)</code></pre> 
<p>8、<a href="https://leetcode-cn.com/problems/count-fertile-pyramids-in-a-land/" rel="nofollow" title="统计农场中肥沃金字塔的数目">统计农场中肥沃金字塔的数目</a></p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(m):
    for j in range(n):
        if grid[i][j] == 1:
            if j == 0 or j == n - 1:
                dp[i][j] = 1
            else:
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i - 1][j + 1]) + 1
        else:
            dp[i][j] = 0 </code></pre> 
<p>9、<a href="https://leetcode-cn.com/problems/out-of-boundary-paths/" rel="nofollow" title="出界的路径数">出界的路径数</a> </p> 
<pre style="margin-left:0;"><code class="language-python">for k in range(maxMove):
    for i in range(m):
        for j in range(n):
            if k == 0:
                dp[i][j][k] += 1 if i - 1 &lt; 0 else 0
                dp[i][j][k]+= 1 if i + 1 &gt;= m else 0
                dp[i][j][k]+= 1 if j - 1 &lt; 0 else 0
                dp[i][j][k] += 1 if j + 1 &gt;= n else 0
            else:
                dp[i][j][k] += dp[i - 1][j][k - 1] if i &gt; 0 else 0
                dp[i][j][k] += dp[i + 1][j][k - 1] if i + 1 &lt; m else 0
                dp[i][j][k] += dp[i][j - 1][k - 1] if j &gt; 0 else 0
                dp[i][j][k] += dp[i][j + 1][k - 1] if j + 1 &lt; n else 0
return sum(dp[startRow][startColumn])</code></pre> 
<p>10、<a href="https://leetcode-cn.com/problems/longest-line-of-consecutive-one-in-matrix/" rel="nofollow" title="矩阵中最长的连续1线段">矩阵中最长的连续1线段</a></p> 
<pre style="margin-left:0;"><code class="language-python">m, n = len(mat), len(mat[0])
#用dp[i][j][k]记录，k分别表示水平、垂直、对角、反对角四个状态
dp = [[[0]*4 for _ in range(n+2)] for _ in range(m+2)]
ans = 0
for i in range(1, m+1):
    for j in range(1, n+1):
        if mat[i-1][j-1] == 1:
            dp[i][j][0] = dp[i-1][j][0] + 1
            dp[i][j][1] = dp[i][j-1][1] + 1
            dp[i][j][2] = dp[i-1][j-1][2] + 1
            dp[i][j][3] = dp[i-1][j+1][3] + 1
            ans = max(ans, max(dp[i][j]))
return ans</code></pre> 
<p> 11、<a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/" rel="nofollow" title="K 站中转内最便宜的航班">K 站中转内最便宜的航班</a></p> 
<pre style="margin-left:0;"><code class="language-python">dp = [float('inf') for _ in range(n)]
dp[src] = 0
for i in range(K+1):
    tmp = dp[:]
    for u, v, w in flights:
        dp[v] = min(dp[v],tmp[u] + w)
return dp[dst] if dp[dst] != float('inf') else -1</code></pre> 
<p> 也可以使用堆的方法进行遍历</p> 
<pre style="margin-left:0;"><code class="language-python">graph = collections.defaultdict(dict)
for start,end,cost in flights:
    graph[start][end] = cost

queue, v = [(0,0,src)], set()
while queue:
    cost, k, pos = heapq.heappop(queue)
    if pos == dst: return cost
    if (pos, k) in v: continue
    v.add((pos, k))
    if k &gt; K: continue
    for nxpos, nxcost in graph[pos].items():
        if (nxpos, k + 1) not in v:
            heapq.heappush(queue,(cost + nxcost, k + 1, nxpos))
return -1</code></pre> 
<p>12、<a href="https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/" rel="nofollow" title="网格图中递增路径的数目">网格图中递增路径的数目</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def countPaths(self, grid: List[List[int]]) -&gt; int:
        m, n = len(grid), len(grid[0])
        dp = [[1 for i in range(n)] for j in range(m)]
        s = []
        mod = 10 ** 9 + 7
        for i in range(m):
            for j in range(n):
                s.append([grid[i][j], i, j])
        s.sort()
        while s:
            _, i, j = s.pop()#从尾部弹出则是从大到小遍历
            for x, y in [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]]:
                if 0 &lt;= x &lt; m and 0 &lt;= y &lt; n and grid[x][y] &gt; _:
                    dp[i][j] += dp[x][y]
            dp[i][j] %= mod
        return sum(sum(i) for i in dp) % mod</code></pre> 
<p>使用记忆化深搜会更简单：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def countPaths(self, grid: List[List[int]]) -&gt; int:
        m, n = len(grid), len(grid[0])
        @cache
        def dfs(i, j):
            res = 1
            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                ni, nj = i + dx, j + dy
                if 0 &lt;= ni &lt; m and 0 &lt;= nj &lt; n and grid[ni][nj] &gt; grid[i][j]:
                    res = (res + dfs(ni, nj)) % (10 ** 9 + 7)
            return res
        res = 0
        for i, j in product(range(m), range(n)):
            res = (res + dfs(i, j)) % (10 ** 9 + 7)
        return res</code></pre> 
<p>        注：有些问题只适合于记忆化深搜，例如：<a href="https://leetcode.cn/problems/sort-integers-by-the-power-value/" rel="nofollow" title="将整数按权重排序">将整数按权重排序</a>，如果利用dp的方法，如果要通过所有测试用例，dp长度至少为300 * 最高值 + 3， 而且运行时间远大于记忆化深搜。</p> 
<h4>决策动态规划</h4> 
<p>1、<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/" rel="nofollow" title="买卖股票的最佳时机 IV">买卖股票的最佳时机 IV</a></p> 
<pre style="margin-left:0;"><code class="language-python"># dp[i][kk][0]表示第i天第k笔交易不持有股票, dp[i][kk][1]表示第i天第k笔交易持有股票
for i in range(1, n):
    for kk in range(1, k + 1):
        dp[i][kk][0] = max(dp[i-1][kk][0], dp[i-1][kk][1] + prices[i])
        dp[i][kk][1] = max(dp[i-1][kk][1], dp[i-1][kk-1][0] - prices[i])
return dp[n-1][k][0]</code></pre> 
<p>2、 <a href="https://leetcode-cn.com/problems/flip-string-to-monotone-increasing/" rel="nofollow" title="将字符串翻转到单调递增">将字符串翻转到单调递增</a></p> 
<pre style="margin-left:0;"><code class="language-python">#a0最后一位为0最少需要翻转次数，a1最后一位为1最少需要翻转次数
for c in s:
    if c == '0':
        a1 = min(a0, a1) + 1
    else:
        a1 = min(a0, a1)
        a0 = a0 + 1
</code></pre> 
<p>3、<a href="https://leetcode-cn.com/problems/maximum-product-subarray/" rel="nofollow" title="乘积最大子数组">乘积最大子数组</a> </p> 
<pre style="margin-left:0;"><code class="language-python">maxF, minF, ans = nums[0], nums[0], nums[0]
length = len(nums)
for i in range(1, length):
    mx, mn = maxF, minF # 只用两个变量来维护i−1时刻的状态,优化空间
    maxF = max(mx * nums[i], nums[i], mn * nums[i])
    minF = min(mn * nums[i], nums[i], mx * nums[i])
    ans = max(maxF, ans)      
return ans</code></pre> 
<p> 4、<a href="https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/" rel="nofollow" title="乘积为正数的最长子数组长度">乘积为正数的最长子数组长度</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def getMaxLen(self, nums: List[int]) -&gt; int:
        length = len(nums)
        positive, negative = [0] * length, [0] * length
        if nums[0] &gt; 0:
            positive[0] = 1
        elif nums[0] &lt; 0:
            negative[0] = 1
        
        maxLength = positive[0]
        for i in range(1, length):
            if nums[i] &gt; 0:
                positive[i] = positive[i - 1] + 1
                negative[i] = (negative[i - 1] + 1 if negative[i - 1] &gt; 0 else 0)
            elif nums[i] &lt; 0:
                positive[i] = (negative[i - 1] + 1 if negative[i - 1] &gt; 0 else 0)
                negative[i] = positive[i - 1] + 1
            else:
                positive[i] = negative[i] = 0
            maxLength = max(maxLength, positive[i])

        return maxLength
</code></pre> 
<p>该题还可以使用贪心的方法进行处理，按零分组，找第一个负数和最后一个负数的位置 </p> 
<p> 5、<a href="https://leetcode-cn.com/problems/ugly-number-ii/" rel="nofollow" title="丑数 II">丑数 II</a></p> 
<pre style="margin-left:0;"><code class="language-python">dp = (n + 1) * [0]
n2, n3, n5 = 1, 1, 1
dp[1] = 1
for i in range(2, n + 1):
     dp[i] = min(2 * dp[n2], 3 * dp[n3], 5 * dp[n5])
     if dp[i] == 2 * dp[n2]: n2 += 1
     if dp[i] == 3 * dp[n3]: n3 += 1
     if dp[i] == 5 * dp[n5]: n5 += 1
return dp[n]</code></pre> 
<p>6、 <a href="https://leetcode-cn.com/problems/beautiful-arrangement/" rel="nofollow" title="优美的排列">优美的排列</a></p> 
<pre style="margin-left:0;"><code class="language-python">f = [0] * (1 &lt;&lt; n)
f[0] = 1
for mask in range(1, 1 &lt;&lt; n):
    num = bin(mask).count("1")
    for i in range(n):
        if mask &amp; (1 &lt;&lt; i) and (num % (i + 1) == 0 or (i + 1) % num == 0):
            f[mask] += f[mask ^ (1 &lt;&lt; i)]
return f[(1 &lt;&lt; n) - 1]</code></pre> 
<p>7、<a href="https://leetcode-cn.com/problems/2-keys-keyboard/" rel="nofollow" title="只有两个键的键盘">只有两个键的键盘</a> </p> 
<pre style="margin-left:0;"><code class="language-python">if n == 1: return 0
dp = [[inf] * (n // 2 + 1) for _ in range(n + 1)]
dp[1][0], dp[1][1] = 0, 1
for i in range(2, n + 1):
    for k in range(1, i // 2 + 1):
        if i - k &gt;= 0:
            dp[i][k] = min(dp[i][k], dp[i - k][k] + 1)
        if k == i // 2 and i % 2 == 0:
            dp[i][k] = min(dp[i][k], min(dp[k]) + 2)
return min(dp[-1])</code></pre> 
<p>由于一个素数的字母的最小操作次数是其本身，所以可以转化为如下动态规划算法：</p> 
<pre style="margin-left:0;"><code class="language-python">f = [0] * (n + 1)
for i in range(2, n + 1):
    f[i] = float("inf")
    j = 1
    while j * j &lt;= i:
        if i % j == 0:
            f[i] = min(f[i], f[j] + i // j)
            f[i] = min(f[i], f[i // j] + j)
        j += 1
return f[n]</code></pre> 
<p> 由于两个素数的和小于其乘积，所以可优化成采用分解质因数的方法</p> 
<p>8、<a href="https://leetcode-cn.com/problems/new-21-game/" rel="nofollow" title="新 21 点 ">新 21 点 </a> （前缀和 + 动态规划）</p> 
<pre style="margin-left:0;"><code class="language-python">dp = [1] + [0] * n
for i in range(1, n + 1):
    if i &lt;= n - k:
        dp[i] = dp[i - 1] + 1
        continue
    dp[i] = dp[i - 1] - (dp[i - maxPts - 1] if i - maxPts &gt; 0 else 0)
    dp[i] = dp[i - 1] + dp[i] / maxPts
return dp[-1] - (dp[-2] if n &gt;= 1 else 0)</code></pre> 
<p>9、<a href="https://leetcode.cn/problems/count-ways-to-distribute-candies/" rel="nofollow" title="计算分配糖果的不同方式">计算分配糖果的不同方式</a> （斯特林数）</p> 
<pre style="margin-left:0;"><code class="language-python">for i in range(1, k + 1):       #盒子
	for j in range(i + 1, n + 1):   #糖果数
		#新的糖果，单独一个盒子
		dp[i][j] = dp[i-1][j-1]
		#新的糖果，加入其他的盒子
		dp[i][j] += dp[i][j-1] * i</code></pre> 
<p>10、<a href="https://leetcode.cn/problems/stone-game-ii/" rel="nofollow" title="石子游戏 II">石子游戏 II</a>（前缀和 + 动态规划）</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def stoneGameII(self, piles: List[int]) -&gt; int:
        pre = [0]
        for p in piles:
            pre.append(pre[-1] + p)
        
        n = len(piles)
        @cache
        def dfs(i, M):
            if i + 2 * M &gt;= n:
                return pre[-1] - pre[i]
            maxl = 0
            for j in range(1, 2 * M + 1):
                maxl = max(maxl, pre[-1] - pre[i] - dfs(j + i, max(M, j)))
            return maxl
        
        return dfs(0, 1)</code></pre> 
<h4><strong> 动态规划与树结合</strong></h4> 
<p>1、<a href="https://leetcode.cn/problems/house-robber-iii/" rel="nofollow" title="打家劫舍 III">打家劫舍 III</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def rob(self, root: TreeNode) -&gt; int:
        def dfs(p):
            if not p: return 0, 0
            la, lb = dfs(p.left)
            ra, rb = dfs(p.right)
            return max(lb + rb + p.val, ra + la), ra + la
        return max(dfs(root))</code></pre> 
<p>2、<a href="https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/" rel="nofollow" title="二叉树中的最长交错路径">二叉树中的最长交错路径</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def longestZigZag(self, root: TreeNode) -&gt; int:
        maxl = 0
        def dfs(p):
            nonlocal maxl
            if not p: return -1, -1
            l1, r1 = dfs(p.left)
            l2, r2 = dfs(p.right)
            maxl = max(maxl, r1 + 1, l2 + 1)
            return r1 + 1, l2 + 1
        dfs(root)
        return maxl</code></pre> 
<p>3、<a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/" rel="nofollow" title="二叉搜索子树的最大键值和">二叉搜索子树的最大键值和</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def maxSumBST(self, root: Optional[TreeNode]) -&gt; int:
        maxl = 0
        def dfs(p):          
            min1, max1, s1 = dfs(p.left) if p.left else (inf, -inf, 0)
            min2, max2, s2 = dfs(p.right) if p.right else (inf, -inf, 0)
            if max1 &lt; p.val &lt; min2:
                nonlocal maxl
                maxl = max(maxl, s1 + s2 + p.val)
                return min(min1, p.val), max(max2, p.val), s1 + s2 + p.val
            return -inf, inf, 0
        dfs(root)
        return maxl</code></pre> 
<p>4、 <a href="https://leetcode.cn/problems/count-number-of-possible-root-nodes/" rel="nofollow" title="统计可能的树根数目">统计可能的树根数目</a> （换根dp）</p> 
<p>（1）先从任意一个根出发，求解所有点</p> 
<p>（2）再换根，计算变化的点</p> 
<pre><code class="language-python">class Solution:
    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -&gt; int:
        m = defaultdict(list)
        for f, t in edges:
            m[f].append(t)
            m[t].append(f)
        
        s = defaultdict(int)
        for f, t in guesses:
            s[f, t] += 1
            
        t = 0
        def dfs(i, last):
            nonlocal t
            for j in m[i]:
                if j == last: continue
                t += s[i, j] 
                dfs(j, i)
        
        dfs(0, -1)
        res = 0
        def dfs2(i, last, t):
            nonlocal res
            if t &gt;= k: res += 1
            for j in m[i]:
                if j == last: continue
                dfs2(j, i, t - s[i, j] + s[j, i])
                
        dfs2(0, -1, t)
        return res</code></pre> 
<p>5、 <a href="https://leetcode.cn/problems/sum-of-distances-in-tree/" rel="nofollow" title="树中距离之和">树中距离之和</a>  （换根dp）</p> 
<pre><code class="language-python">class Solution:
    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -&gt; List[int]:
        m = defaultdict(list)
        for f, t in edges:
            m[f].append(t)
            m[t].append(f)
        
        dises, sizes  = [0] * n, [0] * n
        #节点到所有孩子节点的距离，以及节点与所有孩子节点的个数
        def dfs(i, last):
            dis, size = 0, 1
            for j in m[i]:
                if j == last: continue
                child_dis, child_size = dfs(j, i)
                dis += child_dis + child_size
                size += child_size
            dises[i], sizes[i] = dis, size
            return dis, size

        dfs(0, -1)

        res = [0] * n
        res[0] = dises[0]
        def dfs2(i, last, dis, size):      
            sum_child_size, sum_child_dis = 0, 0
            for j in m[i]:
                if j == last: continue
                sum_child_size += sizes[j]
                sum_child_dis += dises[j]
            
            for j in m[i]:
                if j == last: continue
                parent_dis = dis + 2 * (sum_child_size - sizes[j]) + sum_child_dis - dises[j] + size
                parent_size = size + sum_child_size - sizes[j] + 1
                res[j] = parent_dis + dises[j]
                dfs2(j, i,  parent_dis, parent_size)
        
        dfs2(0, -1, 0, 1)

        return res</code></pre> 
<h4>数位动态规划</h4> 
<p>1、<a href="https://leetcode.cn/problems/numbers-with-repeated-digits/" rel="nofollow" title="至少有 1 位重复的数字">至少有 1 位重复的数字</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def numDupDigitsAtMostN(self, n: int) -&gt; int:
        s = str(n)
        @cache
        def f(i: int, mask: int, is_limit: bool, is_num: bool) -&gt; int:
            if i == len(s):
                return int(is_num)
            res = 0
            if not is_num:  # 可以跳过当前数位
                res = f(i + 1, mask, False, False)
            up = int(s[i]) if is_limit else 9
            for d in range(0 if is_num else 1, up + 1):  # 枚举要填入的数字 d
                if mask &gt;&gt; d &amp; 1 == 0:  # d 不在 mask 中
                    res += f(i + 1, mask | (1 &lt;&lt; d), is_limit and d == up, True)
            return res
        return n - f(0, 0, True, False)</code></pre> 
<p>2、<a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/" rel="nofollow" title="不含连续1的非负整数">不含连续1的非负整数</a></p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def findIntegers(self, n: int) -&gt; int:
        s = str(bin(n))[2:]
        @cache
        def f(i: int, pre1: bool, is_limit: bool) -&gt; int:
            if i == len(s):
                return 1
            up = int(s[i]) if is_limit else 1
            res = f(i + 1, False, is_limit and up == 0)  # 填 0
            if not pre1 and up == 1:  # 可以填 1
                res += f(i + 1, True, is_limit)  # 填 1
            return res
        return f(0, False, True)</code></pre> 
<h4>倍增</h4> 
<p>1、<a class="link-info" href="https://leetcode.cn/problems/powx-n/" rel="nofollow" title="Pow(x, n)">Pow(x, n)</a>  -- 快速幂算法</p> 
<pre><code class="language-python">class Solution:
    def myPow(self, x: float, n: int) -&gt; float:
        if n == 0: return 1
        n, f = abs(n), (n &lt; 0)
        p = [x] * n.bit_length()
        for i in range(n.bit_length() - 1):
            p[i + 1] = p[i] * p[i]
        res = 1
        for i in range(n.bit_length()):
            if (n &gt;&gt; i) &amp; 1:
                res *= p[i]
        if f: return 1 / res
        return res</code></pre> 
<p>2、<a class="link-info" href="https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game/" rel="nofollow" title="在传球游戏中最大化函数值">在传球游戏中最大化函数值</a>  -- (求解第k个祖先)</p> 
<pre><code class="language-python">class Solution:
    def getMaxFunctionValue(self, receiver: List[int], k: int) -&gt; int:
        n = len(receiver)
        m = k.bit_length() - 1
        pa = [[(p, p)] + [None] * m for p in receiver]
        for i in range(m):
            for x in range(n):
                p, s = pa[x][i]
                pp, ss = pa[p][i]
                pa[x][i + 1] = (pp, s + ss)  # 合并节点值之和

        ans = 0
        for i in range(n):
            x = sum = i
            for j in range(m + 1):
                if (k &gt;&gt; j) &amp; 1:  # k 的二进制从低到高第 j 位是 1
                    x, s = pa[x][j]
                    sum += s
            ans = max(ans, sum)
        return ans</code></pre> 
<h4 style="background-color:transparent;"> 状态压缩与优化</h4> 
<p>1、取余法：（<a href="https://leetcode-cn.com/problems/climbing-stairs/" rel="nofollow" title="70. 爬楼梯">70. 爬楼梯</a>）</p> 
<pre style="margin-left:0;"><code class="language-python">dp = [1, 2] 
for i in range(2, n):
    dp[i % 2] = dp [(i -1) % 2] + dp[(i - 2) % 2]
return dp[(n - 1) % 2]
</code></pre> 
<p>2、常数级别压缩： （<a href="https://leetcode-cn.com/problems/climbing-stairs/" rel="nofollow" title="70. 爬楼梯">70. 爬楼梯</a>）</p> 
<pre style="margin-left:0;"><code class="language-python">a, b = 0, 1
for i in range(n):
    a, b = b, a + b
return b</code></pre> 
<p>3、二维压缩成一维：（<a href="https://leetcode-cn.com/problems/edit-distance/" rel="nofollow" title="72. 编辑距离">72. 编辑距离</a>）</p> 
<pre style="margin-left:0;"><code class="language-python">s, t = (word1, word2) if len(word1) &gt; len(word2) else (word2, word1)
dp = [j for j in range(len(t) + 1)]
for i in range(1, len(s)+1):
    dpij, dp[0] = dp[0], i
    for j in range(1, len(t) + 1):
        temp = dp[j]
        if s[i - 1] == t[j - 1]:
            dp[j] = dpij
        else:
            dp[j] = min(dp[j] + 1, dp[j - 1] + 1, dpij + 1)
        dpij = temp
return dp[-1]</code></pre> 
<p>4、使用位运算进行压缩：（<a href="https://leetcode.cn/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/" rel="nofollow" title="2510. Check if There is a Path With Equal Number of 0's And 1's">2510. Check if There is a Path With Equal Number of 0's And 1's</a>） </p> 
<p>常规方法，使用集合存储结果，运行时间为376ms，内存消耗146.8mb，代码如下：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def isThereAPath(self, grid: List[List[int]]) -&gt; bool:
        m, n = len(grid), len(grid[0])
        @cache
        def dfs(i, j):
            if i &lt;= 0 and j &lt; 0 or i &lt; 0 and j &lt;= 0: return {0}
            if i &lt; 0 or j &lt; 0: return set()
            res = set()
            for e in dfs(i - 1, j) | dfs(i, j - 1):
                if grid[i][j]:
                    res.add(e + 1)
                else:
                    res.add(e - 1)
            return res
           
        return 0 in dfs(m - 1, n - 1)</code></pre> 
<p>如果使用位运算存储结果，运行时间为60ms，内存消耗22.2mb，代码如下：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def isThereAPath(self, grid: List[List[int]]) -&gt; bool:
        m, n = len(grid), len(grid[0])
        @cache
        def dfs(i, j):
            if i &lt;= 0 and j &lt; 0 or i &lt; 0 and j &lt;= 0: return 1 &lt;&lt; (m + n)
            if i &lt; 0 or j &lt; 0: return 0
            if grid[i][j]:
                return (dfs(i - 1, j) &lt;&lt; 1) | (dfs(i, j - 1) &lt;&lt; 1)
            else:
                return (dfs(i - 1, j) &gt;&gt; 1) | (dfs(i, j - 1) &gt;&gt; 1)

        return ((dfs(m - 1, n - 1) &gt;&gt; (m + n)) &amp; 1) == 1</code></pre> 
<p>5、使用26个字母空间</p> 
<p>（1）<a href="https://leetcode.cn/problems/longest-ideal-subsequence/" rel="nofollow" title="2370. 最长理想子序列">2370. 最长理想子序列</a>：</p> 
<pre style="margin-left:0;"><code class="language-python">f = [0] * 26
for c in s:
    c = ord(c) - ord('a')
    f[c] = 1 + max(f[max(c - k, 0): c + k + 1])
return max(f)</code></pre> 
<p>（2）<a href="https://leetcode.cn/problems/distinct-subsequences-ii/" rel="nofollow" title="不同的子序列 II">不同的子序列 II</a></p> 
<p> 对于相同的子序列，只会考虑其最后一次出现的位置（下标序列的字典序最大）</p> 
<pre><code class="language-python">class Solution:
    def distinctSubseqII(self, s: str) -&gt; int:
        mod = 10 ** 9 + 7
        dp = [0] * 26
        for c in s:
            i = ord(c) - ord('a')
            for j in range(26):
                if i == j: continue
                dp[i] = (dp[j] + dp[i]) % mod
            dp[i] = (dp[i] + 1) % mod
        return sum(dp) % mod</code></pre> 
<p> 6、使用线段树 （<a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/" rel="nofollow" title="2407. 最长递增子序列 II">2407. 最长递增子序列 II</a>）</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def lengthOfLIS(self, nums: List[int], k: int) -&gt; int:
        tmp = SegmentTree([0] * (max(nums) + 1))
        for x in nums:
            note = tmp.query(max(0, x-k), x-1)
            tmp.update(x, note + 1)
        return tmp.query(0, max(nums))
        
class SegmentTree:
    def __init__(self, data, merge=max): 
        self.data = data
        self.n = len(data)
        self.tree = [None] * (4 * self.n)
        self._merge = merge
        if self.n:
            self._build(0, 0, self.n-1)


    def query(self, ql, qr):
        return self._query(0, 0, self.n-1, ql, qr)

    def update(self, index, value):
        self.data[index] = value
        self._update(0, 0, self.n-1, index)

    def _build(self, tree_index, l, r):
        if l == r:
            self.tree[tree_index] = self.data[l]
            return
        mid = (l+r) // 2
        left, right = 2 * tree_index + 1, 2 * tree_index + 2
        self._build(left, l, mid)
        self._build(right, mid+1, r)
        self.tree[tree_index] = self._merge(self.tree[left], self.tree[right])

    def _query(self, tree_index, l, r, ql, qr):
        if l == ql and r == qr:
            return self.tree[tree_index]

        mid = (l+r) // 2
        left, right = tree_index * 2 + 1, tree_index * 2 + 2
        if qr &lt;= mid:
            return self._query(left, l, mid, ql, qr)
        elif ql &gt; mid:
            return self._query(right, mid+1, r, ql, qr)

        return self._merge(self._query(left, l, mid, ql, mid), 
                          self._query(right, mid+1, r, mid+1, qr))

    def _update(self, tree_index, l, r, index):
        if l == r == index:
            self.tree[tree_index] = self.data[index]
            return
        mid = (l+r)//2
        left, right = 2 * tree_index + 1, 2 * tree_index + 2
        if index &gt; mid:
            self._update(right, mid+1, r, index)
        else:
            self._update(left, l, mid, index)
        self.tree[tree_index] = self._merge(self.tree[left], self.tree[right])</code></pre> 
<p>7、提高状态空间的重用性</p> 
<p>（1）2143.<a href="https://leetcode.cn/problems/choose-numbers-from-two-arrays-in-range/" rel="nofollow" title="在两个数组的区间中选取数字">在两个数组的区间中选取数字</a>中，如下方法设置状态空间运行结果为超时</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def countSubranges(self, nums1: List[int], nums2: List[int]) -&gt; int:
        n = len(nums1)
        @cache
        def dfs(i, l, is_start, r, is_end):
            if i == n: 
                return int(l == r) if is_start else 0
            res = 0
            if not is_start:
                res += dfs(i + 1, l, False, r, False)
                res += dfs(i + 1, l + nums1[i], True, r , False)
                res += dfs(i + 1, l, True, r + nums2[i], False)              
            elif is_start and not is_end:
                res += dfs(i + 1, l + nums1[i], True, r , False)
                res += dfs(i + 1, l, True, r + nums2[i], False)
                res += dfs(i + 1, l, True, r, True)
            else:
                res += dfs(i + 1, l, True, r, True)
            return res
        return dfs(0, 0, False, 0, False)</code></pre> 
<p>       这是因为(l, r) == (1, 1) 与 (l, r) == (6, 6)的状态是等价的，但是状态空间没有复用，导致重复计算，所以可以按如下方法改正，状态空间优化成一个，结果通过：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def countSubranges(self, nums1: List[int], nums2: List[int]) -&gt; int:
        n = len(nums1)
        @cache
        def dfs(i, d, is_start, is_end):
            if i == n: return int(d == 0) if is_start else 0
            if is_end: return int(d == 0)
            res = 0
            if not is_start:
                res += dfs(i + 1, d, False, False)
                res += dfs(i + 1, d + nums1[i], True, False)
                res += dfs(i + 1, d - nums2[i], True, False)              
            elif is_start and not is_end:
                res += dfs(i + 1, d + nums1[i], True, False)
                res += dfs(i + 1, d - nums2[i], True, False)
                res += dfs(i + 1, d, True, True)
            else:
                res += dfs(i + 1, d, True, True)
            return res
        return dfs(0, 0, False, False) % (10 ** 9 + 7)</code></pre> 
<p>（2）在<a href="https://leetcode.cn/problems/profitable-schemes/" rel="nofollow" title="盈利计划">盈利计划</a>中，如下方法超时：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -&gt; int:    
        mod = 10 ** 9 + 7
        @cache
        def dfs(i, n, p):
            if i == len(group):
                return p &gt;= minProfit
            res = 0
            if group[i] &lt;= n:
                res = (res + dfs(i + 1, n - group[i], p + profit[i])) % mod
            return (res + dfs(i + 1, n, p)) % mod
        
        return dfs(0, n, 0) % mod</code></pre> 
<p> 这是由于当前盈利值达到最低要求后，后续结果只与剩余人数有关，所以按照最小盈利值对状态进行重用，如下所示。</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def profitableSchemes(self, n: int, minProfit: int, group: List[int], profit: List[int]) -&gt; int:    
        mod = 10 ** 9 + 7
        @cache
        def dfs(i, n, p):
            if i == len(group):
                return int(p == minProfit)
            res = 0
            if group[i] &lt;= n:
                res = (res + dfs(i + 1, n - group[i], min(minProfit, p + profit[i]))) % mod
            return (res + dfs(i + 1, n, p)) % mod
        
        return dfs(0, n, 0) % mod</code></pre> 
<p> 8、缩短计算步数 </p> 
<p>（1） <a href="https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/" rel="nofollow" title="Minimum Time to Kill All Monsters">Minimum Time to Kill All Monsters</a></p> 
<p>        如下解法运行超时，因为当怪物需要的能量比较大时，计算次数变多。</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def minimumTime(self, power: List[int]) -&gt; int:
        n, mp = len(power), max(power)
        @cache
        def dfs(g, v, inc):
            if v == (1 &lt;&lt; n) - 1: return 0
            res, gg, step = inf, g - inc, 0
            while gg &lt;= mp:
                gg += inc
                step += 1
                for i in range(n):
                    if (v &gt;&gt; i) &amp; 1 == 0 and gg &gt;= power[i]:
                        res = min(res, dfs(inc + 1, v | (1 &lt;&lt; i), inc + 1) + step)
            return res
        return dfs(1, 0, 1)</code></pre> 
<p>          根据题意，结果只与打败怪物的顺序有关，与积攒能量的过程无关，所以可以优化成下面的方法，减少重复计算，同时优化状态空间。</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def minimumTime(self, power: List[int]) -&gt; int:
        n, mp = len(power), max(power)
        @cache
        def dfs(v, inc):
            if v == (1 &lt;&lt; n) - 1: return 0
            res = inf
            for i in range(n):
                if (v &gt;&gt; i) &amp; 1 == 0:
                    res = min(res, dfs(v | (1 &lt;&lt; i), inc + 1) + ceil(power[i] / inc))
            return res
        return dfs(0, 1)</code></pre> 
<p>（2）<a href="https://leetcode.cn/problems/number-of-good-binary-strings/" rel="nofollow" title="好二进制字符串的数量">好二进制字符串的数量</a></p> 
<p>根据题意设计如下代码，会超时：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def goodBinaryStrings(self, minLength: int, maxLength: int, oneGroup: int, zeroGroup: int) -&gt; int:
        @cache
        def dfs(i, p):
            res = 0
            if minLength &lt;= i &lt;= maxLength and p == 0:
                res = 1
            if i == maxLength: return res
            if p &lt;= 0:
                res += dfs(i + 1, -((-p + 1) % zeroGroup))
            if p &gt;= 0:
                res += dfs(i + 1, (p + 1) % oneGroup)
            return res % (10 ** 9 + 7)
        return dfs(0, 0) % (10 ** 9 + 7)</code></pre> 
<p>        由于要求具有连续相同字符，所以不需要计算使用每个字符的状态，如下所示，通过减少状态空间和缩短步数来达到优化的目的。</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def goodBinaryStrings(self, minLength: int, maxLength: int, oneGroup: int, zeroGroup: int) -&gt; int:
        @cache
        def dfs(i):
            res = 0
            if minLength &lt;= i &lt;= maxLength:
                res = 1
            if i == maxLength: return res
            if i + oneGroup &lt;= maxLength:
                res += dfs(i + oneGroup)
            if i + zeroGroup &lt;= maxLength:
                res += dfs(i + zeroGroup)
            return res % (10 ** 9 + 7)
        return dfs(0) % (10 ** 9 + 7)</code></pre> 
<p>（3） <a href="https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/" rel="nofollow" title="吃掉 N 个橘子的最少天数">吃掉 N 个橘子的最少天数</a></p> 
<p>       直接使用暴力dp超时，因为n最大超过10^9, 每次减一需要的时间比较长，所以可以对减一部分进行优化，由于n 变为 二分之一或者三分之一步数总是比连续减一的步数小，所以可以写成如下代码：</p> 
<pre><code class="language-python">class Solution:
    @lru_cache(None) 
    def minDays(self, n: int) -&gt; int:
        if n == 0: return 0
        if n == 1: return 1
        return 1 + min(self.minDays(n//2) + n % 2, self.minDays(n//3) + n % 3)</code></pre> 
<p>9、剪枝法</p> 
<p>（1） <a href="https://leetcode.cn/problems/maximum-earnings-from-taxi/" rel="nofollow" title="出租车的最大盈利">出租车的最大盈利</a></p> 
<p>  如下使用动态规划的方法，会超时</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:
        rides.sort()
        @cache
        def dfs(j):            
            idx = bisect_left(rides, [j, 0, 0])
            if idx &gt;= len(rides): return 0
            maxl = 0
            for i in range(idx, len(rides)):
                start, end, tip = rides[i]
                maxl = max(maxl, dfs(end) + end - start + tip)
            return maxl
        return dfs(0)</code></pre> 
<p>       这是因为当两个区间不相交时，两个区间都取到时收益最大，所以在新的起始点大于最小终止点时，结束计算，如下所示：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:
        rides.sort()
        @cache
        def dfs(j):            
            idx = bisect_left(rides, [j, 0, 0])
            if idx &gt;= len(rides): return 0
            maxl = 0
            s0, e0, t0 = rides[idx]
            for i in range(idx, len(rides)):
                start, end, tip = rides[i]
                e0 = min(e0, end)
                if start &gt;= e0: break
                maxl = max(maxl, dfs(end) + end - start + tip)
            return maxl
        return dfs(0)</code></pre> 
<p> 也可以利用区间结束点的顺序和二分查找法对其进行优化：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -&gt; int:
        rides = sorted(rides, key=lambda x: x[1])
        dp = [[0, 0]]
        for s, e, p in rides:
            i = bisect.bisect(dp, [s + 1]) - 1
            if dp[i][1] +  p + e - s &gt; dp[-1][1]:
                dp.append([e, dp[i][1] + p + e - s])
        return dp[-1][1]</code></pre> 
<p>（2）<a href="https://leetcode.cn/problems/stone-game-v/" rel="nofollow" title="石子游戏 V">石子游戏 V</a></p> 
<p>常规的dp导致超时，根据等比数列求和公式可知，能预估后续得分之和，当小于当前最大值时可以剪枝，代码如下：</p> 
<pre><code class="language-python">class Solution:
    def stoneGameV(self, stoneValue: List[int]) -&gt; int:
        pre = [0]
        for v in stoneValue:
            pre.append(pre[-1] + v)
        
        @cache
        def dfs(i, j):
            if i == j: return 0
            maxl = 0
            for k in range(i, j):
                left = pre[k + 1] - pre[i]
                right = pre[j + 1] - pre[k + 1]
                if left &lt; right:
                    if maxl &gt;= 2 * left: continue
                    maxl = max(maxl, dfs(i, k) + left)
                elif right &lt; left:
                    if maxl &gt;= 2 * right: continue
                    maxl = max(maxl, dfs(k + 1, j) + right)
                else:
                    if maxl &gt;= 2 * right: continue
                    maxl = max(maxl, dfs(i, k) + left, dfs(k + 1, j) + right)
            return maxl
        return dfs(0, len(stoneValue) - 1)</code></pre> 
<p>（3）<a href="https://leetcode.cn/problems/maximum-points-after-collecting-coins-from-all-nodes/" rel="nofollow" title="收集所有金币可获得的最大积分">收集所有金币可获得的最大积分</a></p> 
<p>由于每个节点的金币数量最高为10^4，所以当除数大于2^13时金币数为0，可以不用继续往下进行。</p> 
<pre><code class="language-python">class Solution:
    def maximumPoints(self, edges: List[List[int]], coins: List[int], k: int) -&gt; int:
        m = defaultdict(set)
        for f, t in edges:
            m[f].add(t)
            m[t].add(f)
        
        def dfs(p, last):
            for np in list(m[p]):
                if np == last:
                    m[p].remove(np)
                    continue
                dfs(np, p)
        dfs(0, -1)

        @cache
        def dp(p, mm):
            r1 = coins[p] // mm - k
            r2 = coins[p] // mm // 2
            for np in m[p]:        
                if r1 &lt; r2 and mm &lt; 2 ** 13:
                    r2 += dp(np, 2 * mm)
                r1 += dp(np, mm)
            return max(r1, r2)
        
        return dp(0, 1)</code></pre> 
<p>10、逆向思维求解  -- <a href="https://leetcode.cn/problems/number-of-great-partitions/" rel="nofollow" title="好分区的数目">好分区的数目</a></p> 
<p> 如果直接求解好分区数量，但是背包容量太大，会超时，代码如下：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def countPartitions(self, nums: List[int], k: int) -&gt; int:
        sm = sum(nums)
        @cache
        def dfs(i, s):
            if i == len(nums):
                return 1 if sm - s &gt;= k and s &gt;= k else 0 
            return dfs(i + 1, s + nums[i]) + dfs(i + 1, s)
        return dfs(0, 0) % (10 ** 9 + 7)</code></pre> 
<p>可以通过求不好分区数量，再用总数相减来提高求解效率，即第一个组或第二个组的元素和小于 k的方案数。根据对称性，我们只需要计算第一个组的元素和小于 k 的方案数，然后乘 2即可：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def countPartitions(self, nums: List[int], k: int) -&gt; int:
        sm = sum(nums)
        if sm &lt; k * 2: return 0
        mod = (10 ** 9 + 7) 
        @cache
        def dfs(i, s):
            if i == len(nums): return 1 
            res = dfs(i + 1, s)
            if s &gt;= nums[i]:
                res += dfs(i + 1, s - nums[i])
            return res % mod 
        return (pow(2, len(nums), mod) - dfs(0, k - 1) * 2) % mod</code></pre> 
<p>再转化成01背包的形式，进一步提高效率：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def countPartitions(self, nums: List[int], k: int) -&gt; int:
        if sum(nums) &lt; k * 2: return 0
        MOD = 10 ** 9 + 7
        f = [0] * k
        f[0] = 1
        for x in nums:
            for j in range(k - 1, x - 1, -1):
                f[j] = (f[j] + f[j - x]) % MOD
        return (pow(2, len(nums), MOD) - sum(f) * 2) % MOD</code></pre> 
<p>11、问题转化 -- <a href="https://leetcode.cn/problems/minimum-total-space-wasted-with-k-resizing-operations/" rel="nofollow" title="K 次调整数组大小浪费的最小总空间">K 次调整数组大小浪费的最小总空间</a> </p> 
<p>直接使用动态规划进行求解，会超时:</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def minSpaceWastedKResizing(self, nums: List[int], k: int) -&gt; int:
        n = len(nums)
        
        @cache
        def dfs(i, j, k):
            if i == len(nums): return 0
            if nums[i] &lt;= nums[j]:
                minl = dfs(i + 1, j, k) + nums[j] - nums[i]
            else: minl = inf
            if k &gt; 0:
                for jj in range(j + 1, n):
                    if nums[jj] &gt;= nums[i]:
                        minl = min(minl, dfs(i + 1, jj, k - 1) + nums[jj] - nums[i])
            return minl
        
        return min(dfs(0, j, k) for j in range(n))</code></pre> 
<p> 可以理解成将数组分成k + 1组，求每组最大值<strong>乘以</strong>这一段的长度<strong>再减去</strong>这一段的元素和，找到总体最小值，代码如下：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def minSpaceWastedKResizing(self, nums: List[int], k: int) -&gt; int:
        n = len(nums)
        pre = [0]
        for num in nums:
            pre.append(pre[-1] + num)

        @cache
        def diff(i, j):
            return (j - i + 1) * max(nums[i: j + 1]) -  pre[j + 1] + pre[i]

        @cache
        def dfs(i, j, k):
            minl = diff(i, j)
            if k &gt; 0:
                for t in range(i, j):
                    minl = min(minl, dfs(i, t, k - 1) + diff(t + 1, j))

            return minl
        
        return dfs(0, n - 1, k)
</code></pre> 
<p>12、降低参数维度</p> 
<p>（1）减少不必要的参数 -- <a href="https://leetcode.cn/problems/max-dot-product-of-two-subsequences/" rel="nofollow" title="两个子序列的最大点积">两个子序列的最大点积</a></p> 
<p>如下所示，如果用f来判别是否为空数组，运行时间为1148ms</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -&gt; int:
        @cache
        def dfs(i, j, f):
            if i == len(nums1) or j == len(nums2): return 0 if f else -inf
            return max(dfs(i + 1, j, f), dfs(i, j + 1, f), dfs(i + 1, j + 1, True) + nums1[i] * nums2[j])
        return dfs(0, 0, False)</code></pre> 
<p> 可以改变max的判断来减少维度，运行时间为628ms</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def maxDotProduct(self, nums1: List[int], nums2: List[int]) -&gt; int:
        @cache
        def dfs(i, j):
            if i == len(nums1) or j == len(nums2): return -inf
            return max(dfs(i + 1, j), dfs(i, j + 1), dfs(i + 1, j + 1) + nums1[i] * nums2[j], nums1[i] * nums2[j])
        return dfs(0, 0)</code></pre> 
<p>（2）将参数移至返回值   -- <a href="https://leetcode.cn/problems/minimum-number-of-work-sessions-to-finish-the-tasks/" rel="nofollow" title="完成任务的最少工作时间段">完成任务的最少工作时间段</a> </p> 
<p>当任务已使用时间在函数参数时，运行时间为7092ms</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -&gt; int:
        n = len(tasks)
        @cache
        def dfs(v, s):
            if v.bit_count() == n:
                return 0
            minl = inf
            for i in range(n):
                if (v &gt;&gt; i) &amp; 1 == 1: continue
                if tasks[i] &lt;= s:
                    minl = min(minl, dfs(v | (1 &lt;&lt; i), s - tasks[i]))
                else:
                    minl = min(minl, dfs(v | (1 &lt;&lt; i), sessionTime - tasks[i]) + 1)
            return minl
        return dfs(0, sessionTime) + 1</code></pre> 
<p>          当任务已使用时间放到返回值时，运行时间为1196ms</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def minSessions(self, tasks: List[int], sessionTime: int) -&gt; int:
        n = len(tasks)
        @cache
        def dfs(v):
            if v.bit_count() == n:
                return 1, 0
            minl, mins = inf, inf
            for i in range(n):
                if (v &gt;&gt; i) &amp; 1 == 1: continue
                l, s = dfs(v | (1 &lt;&lt; i))
                if tasks[i] + s &lt;= sessionTime:
                    minl, mins = min((minl, mins), (l, s + tasks[i]))
                else:
                    minl, mins = min((minl, mins), (l + 1, tasks[i]))
            return minl, mins
        return dfs(0)[0]</code></pre> 
<p>（3） <a href="https://leetcode.cn/problems/apply-operations-to-make-two-strings-equal/" rel="nofollow" title="执行操作使两个字符串相等">执行操作使两个字符串相等</a></p> 
<p> 根据题意，使用动态规划进行求解，代码如下，用时368ms</p> 
<pre><code class="language-python">class Solution:
    def minOperations(self, s1: str, s2: str, x: int) -&gt; int:
        if abs(s1.count('1') - s2.count('1')) &amp; 1 == 1:
            return -1
        @cache
        def dfs(i, t, is_prev):
            if i == len(s1):
                return inf if t &gt; 0 or is_prev else 0
            if (s1[i] == s2[i]) == (not is_prev):
                return dfs(i + 1, t, False)
            
            minl = min(dfs(i + 1, t + 1, False) + x, dfs(i + 1, t, True) + 1)
            if t &gt; 0:
                minl = min(minl, dfs(i + 1, t - 1, False))

            return minl

        return dfs(0, 0, False)</code></pre> 
<p> 可以证明不同字符之间只能有一次操作，所以可以在不同字符下标处进行转移，缩短计算步数。</p> 
<p><img alt="" height="962" src="https://images2.imgbox.com/ab/c7/ba8x8QQO_o.png" width="1027"></p> 
<p>代码如下，运行时间为43ms：</p> 
<pre><code class="language-python">class Solution:
    def minOperations(self, s1: str, s2: str, x: int) -&gt; int:
        if s1 == s2:
            return 0
        p = [i for i, (x, y) in enumerate(zip(s1, s2)) if x != y]

        if len(p) % 2:
            return -1
        f0, f1 = 0, x
        for i, j in pairwise(p):
            f0, f1 = f1, min(f1 + x, f0 + (j - i) * 2)
        return f1 // 2</code></pre> 
<p> 13、转化转移方程，减少循环 -- <a href="https://leetcode.cn/problems/maximum-number-of-points-with-cost/" rel="nofollow" title="扣分后的最大得分">扣分后的最大得分</a></p> 
<p>        该题直接使用暴力法超时，代码如下：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def maxPoints(self, points: List[List[int]]) -&gt; int:
        m, n = len(points), len(points[0])
        dp = points[0]
        for i in range(1, m):
            temp = [0] * n
            for j in range(n):
                for jj in range(n):
                    temp[j] = max(temp[j], points[i][j] + dp[jj] - abs(j - jj))
            dp = temp
        return max(dp)</code></pre> 
<p><img alt="" height="909" src="https://images2.imgbox.com/52/09/SNmj1SaM_o.png" width="1200"> 最终代码如下：</p> 
<pre style="margin-left:0;"><code class="language-python">class Solution:
    def maxPoints(self, points: List[List[int]]) -&gt; int:
        m, n = len(points), len(points[0])
        dp = points[0]
        for i in range(1, m):
            temp = [0] * n
            maxl2 = [-inf]
            for j in reversed(range(n)):
                maxl2.append(max(maxl2[-1], dp[j] - j))

            maxl2 = maxl2[::-1]
            maxl = -inf
            for j in range(n):
                maxl = max(maxl, dp[j] + j)
                temp[j] = max(temp[j], points[i][j] - j + maxl, points[i][j] + j + maxl2[j])
            dp = temp
        return max(dp)</code></pre> 
<p>14、 使用二分法进行优化 -- <a href="https://leetcode.cn/problems/maximum-number-of-events-that-can-be-attended-ii/" rel="nofollow" title="最多可以参加的会议数目 II">最多可以参加的会议数目 II</a> </p> 
<p><img alt="" height="873" src="https://images2.imgbox.com/51/cb/MhrMwE8Z_o.png" width="1200"></p> 
<pre><code class="language-python">class Solution:
    def maxValue(self, events: List[List[int]], k: int) -&gt; int:
        events.sort(key=lambda e: e[1])
        n = len(events)
        f = [[0] * (k + 1) for _ in range(n + 1)]
        for i, (start, end, val) in enumerate(events):
            p = bisect_left(events, start, hi=i, key=lambda e: e[1])  # hi=i 表示二分上界为 i（默认为 n）
            for j in range(1, k + 1):
                # 为什么是 p 不是 p+1：上面算的是 &gt;= start，-1 后得到 &lt; start，但由于还要 +1，抵消了
                f[i + 1][j] = max(f[i][j], f[p][j - 1] + val)
        return f[n][k]</code></pre> 
<p>15、使用单调栈进行优化 -- <a href="https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule/" rel="nofollow" title="工作计划的最低难度">工作计划的最低难度</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4a/b8/IPmILolY_o.png"></p> 
<p>  代码如下：</p> 
<pre><code class="language-python">class Solution:
    def minDifficulty(self, a: List[int], d: int) -&gt; int:
        n = len(a)
        if n &lt; d:
            return -1

        f = [[inf] * n for _ in range(d)]
        f[0] = list(accumulate(a, max))
        for i in range(1, d):
            st = []  # (下标 j，从 f[i-1][left[j]] 到 f[i-1][j-1] 的最小值)
            for j in range(i, n):
                mn = f[i - 1][j - 1]  # 只有 a[j] 一项工作
                while st and a[st[-1][0]] &lt;= a[j]:  # 向左一直计算到 left[j]
                    mn = min(mn, st.pop()[1])
                f[i][j] = mn + a[j]  # 从 a[left[j]+1] 到 a[j] 的最大值是 a[j]
                if st:  # 如果这一段包含 &lt;=left[j] 的工作，那么这一段的最大值必然不是 a[j]
                    f[i][j] = min(f[i][j], f[i][st[-1][0]])  # 答案和 f[i][left[j]] 是一样的
                st.append((j, mn))  # 注意这里保存的不是 f[i][j]
        return f[-1][-1]</code></pre> 
<p>16、改变递推顺序 --  <a href="https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/" rel="nofollow" title="通过给定词典构造目标字符串的方案数">通过给定词典构造目标字符串的方案数</a></p> 
<p>如下代码的运行时间为3532ms</p> 
<pre><code class="language-python">class Solution:
    def numWays(self, words: List[str], target: str) -&gt; int:
        m, n = len(words[0]), len(target)
        mp = defaultdict(lambda: defaultdict(int))
        for word in words:
            for i, c in enumerate(word):
                mp[c][i] += 1
        mod = 10 ** 9 + 7
        @cache
        def dfs(i, j):
            if i == n: return 1
            res = 0
            for k in range(j, m - (n - i - 1)):      
                if mp[target[i]][k] &gt; 0:
                    res = (res + mp[target[i]][k] % mod * dfs(i + 1, k + 1) % mod) % mod
            return res % mod
        return dfs(0, 0)</code></pre> 
<p>改成对于word每个下标是否取用作为递推顺序，代码如下，运行时间为632ms</p> 
<pre><code class="language-python">class Solution:
    def numWays(self, words: List[str], target: str) -&gt; int:
        m, n = len(words[0]), len(target)
        mp = defaultdict(lambda: defaultdict(int))
        for word in words:
            for i, c in enumerate(word):
                mp[c][i] += 1 

        @cache
        def dfs(i, j):
            if i == n: return 1
            if m - j &lt; n - i: return 0
            return (mp[target[i]][j] * dfs(i + 1, j + 1) + dfs(i, j + 1)) % (10 ** 9 + 7)
        return dfs(0, 0)</code></pre> 
<p>17、改变状态空间  -- <a href="https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/" rel="nofollow" title="每个人戴不同帽子的方案数">每个人戴不同帽子的方案数</a></p> 
<p>如果以帽子使用作为状态空间时则超时，代码如下：</p> 
<pre><code class="language-python">class Solution:
    def numberWays(self, hats: List[List[int]]) -&gt; int:
        @cache
        def dfs(mask):
            if mask.bit_count() == len(hats): return 1
            res = 0
            for h in hats[mask.bit_count()]:
                if (mask &gt;&gt; h) &amp; 1 == 0:
                    res = (res + dfs(mask | (1 &lt;&lt; h))) % (10 ** 9 + 7)
            return res
        return dfs(0)</code></pre> 
<p>如果以人的使用作为状态空间时则通过，这是因为人数不超过10，帽子数为40，帽子的状态空间远远比人的要稀疏，代码如下：</p> 
<pre><code class="language-python">class Solution:
    def numberWays(self, hats: List[List[int]]) -&gt; int:
        mp = defaultdict(list)
        s = set()
        for i, hat in enumerate(hats):
            for a_hat in hat: 
                mp[a_hat].append(i)
                s.add(a_hat)
        s = list(s)
        @cache
        def dfs(i, mask):
            if mask.bit_count() == len(hats): return 1
            if i == len(s): return 0
            res = 0
            for j in mp[s[i]]:
                if (mask &gt;&gt; j) &amp; 1 == 0:
                    res = (res + dfs(i + 1, mask | (1 &lt;&lt; j))) % (10 ** 9 + 7)
            res = (res + dfs(i + 1, mask)) % (10 ** 9 + 7)
            return res

        return dfs(0, 0)</code></pre> 
<p>18、使用前缀和进行优化 -- <a href="https://leetcode.cn/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/" rel="nofollow" title="生成数组">生成数组</a></p> 
<pre><code class="language-python">class Solution:
    def numOfArrays(self, N: int, M: int, K: int) -&gt; int:
        dp = [[[0 for _ in range(M + 1)] for _ in range(K + 1)] for _ in range(N + 1)]

        for k in range(1, M + 1):
            dp[1][1][k] = 1
        
        for i, j, k in itertools.product(range(1, N + 1), range(1, K + 1), range(M + 1)):
            dp[i][j][k] += dp[i - 1][j][k] * k
            dp[i][j][k] += sum(dp[i - 1][j - 1][1:k])
        
        return sum(dp[N][K][1:]) % (10 ** 9 + 7)</code></pre> 
<p>使用前缀和进行优化，以减少重复计算，代码如下：</p> 
<pre><code class="language-python">class Solution:
    def numOfArrays(self, n: int, m: int, k: int) -&gt; int:
        # 不存在搜索代价为 0 的数组
        if k == 0:
            return 0

        f = [[[0] * (m + 1) for _ in range(k + 1)] for __ in range(n + 1)]
        mod = 10**9 + 7
        # 边界条件，所有长度为 1 的数组的搜索代价都为 1
        for j in range(1, m + 1):
            f[1][1][j] = 1
        for i in range(2, n + 1):
            # 搜索代价不会超过数组长度
            for s in range(1, min(k, i) + 1):
                # 前缀和
                presum_j = 0
                for j in range(1, m + 1):
                    f[i][s][j] = (f[i - 1][s][j] * j + presum_j) % mod
                    presum_j += f[i - 1][s - 1][j]
        
        # 最终的答案是所有 f[n][k][..] 的和
        # 即数组长度为 n，搜索代价为 k，最大值任意
        ans = sum(f[n][k][j] for j in range(1, m + 1)) % mod
        return ans</code></pre> 
<h4 style="background-color:transparent;"> 求解最优路径</h4> 
<p>1、直接记录路径：（<a href="https://leetcode-cn.com/problems/largest-divisible-subset/" rel="nofollow" title="最大整除子集">最大整除子集</a>）</p> 
<pre style="margin-left:0;"><code class="language-python">dp= [[x] for x in nums]
for i in range(len(nums)):
    for j in range(i + 1, len(nums)):
        if nums[j] % nums[i] == 0 and len(dp[i]) + 1 &gt; len(dp[j]):
            dp[j] = dp[i] + [nums[j]]
return max(dp, key=len)</code></pre> 
<p>2、回溯： （<a href="https://leetcode-cn.com/problems/largest-divisible-subset/" rel="nofollow" title="最大整除子集">最大整除子集</a>）</p> 
<pre style="margin-left:0;"><code class="language-python">maxl, temp = max(dp), None
res, l = [], maxl
for i in reversed(range(n)):
    if l == dp[i]:
        if l == maxl or temp is not None and temp % nums[i] == 0:
            temp = nums[i]
            res.insert(0, nums[i])
            l = l - 1</code></pre> 
<p>注：使用记忆化搜索有可能会导致超时，例如<a href="https://leetcode.cn/problems/maximum-score-from-performing-multiplication-operations/" rel="nofollow" title="1770. 执行乘法运算的最大分数">1770. 执行乘法运算的最大分数</a>，所以可以使用del func 或者func.cache_clear()清除缓存</p> 
<h4>参考资料</h4> 
<p><a href="https://blog.csdn.net/wangdd_199326/article/details/76464333" title="史上最全最丰富的“最长公共子序列”、“最长公共子串”问题的解法与思路_王小东大将军的博客-CSDN博客_最长公共子序列问题">史上最全最丰富的“最长公共子序列”、“最长公共子串”问题的解法与思路_王小东大将军的博客-CSDN博客_最长公共子序列问题</a></p> 
<p><a href="https://blog.csdn.net/smallfish_love/article/details/52277838" title="动态规划-----两个字符串交叉组成第三个字符">动态规划-----两个字符串交叉组成第三个字符</a></p> 
<p><a href="https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html" rel="nofollow" title="​​​​​​动态规划解决01背包问题 - Christal_R - 博客园">​​​​​​动态规划解决01背包问题 - Christal_R - 博客园</a></p> 
<p><a href="https://blog.csdn.net/QiaoRuoZhuo/article/details/77117366" title="最大连续子序列之和练习最大m子段和_QiaoRuoZhuo的专栏-CSDN博客">最大连续子序列之和练习最大m子段和_QiaoRuoZhuo的专栏-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/IMLYZ/article/details/76614763" title="动态规划总结及题目推荐_IMLYZ的博客-CSDN博客">动态规划总结及题目推荐_IMLYZ的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f5609d2a7808fabb77d9c2b11d17b9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ArmV8架构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b0fd6816766ad8808a321953dc34cfb7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mybatis源码分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>