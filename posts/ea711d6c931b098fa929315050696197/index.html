<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【一】Lambda表达式 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【一】Lambda表达式" />
<meta property="og:description" content="1.Lambda表达式概述
​ Lambda表达式是现代C&#43;&#43;在C &#43;&#43; 11和更高版本中的一个新的语法糖 ，在C&#43;&#43;11、C&#43;&#43;14、C&#43;&#43;17和C&#43;&#43;20中Lambda表达的内容还在不断更新。 lambda表达式（也称为lambda函数）是在调用或作为函数参数传递的位置处定义匿名函数对象的便捷方法。通常，lambda用于封装传递给算法或异步方法的几行代码 。
2.Lambda表达式定义
2.1 Lambda表达式语法定义
1） 捕获列表。在C &#43;&#43;规范中也称为Lambda导入器， 捕获列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数，捕获列表能够捕捉上下文中的变量以供Lambda函数使用。
[]表示不捕获任何变量[var]表示值传递方式捕获变量var[=]表示值传递方式捕获所有父作用域的变量（包括this）[&amp;var]表示引用传递捕捉变量var[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）[this]表示值传递方式捕捉当前的this指针[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量 [&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。
2） 参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略。
3） 可变规格*。mutable修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。*
4）异常说明。用于Lamdba表达式内部函数抛出异常。
5）返回类型。 追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”-&gt;”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。
6）lambda函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。
3. 应用案例
#include &lt;iostream&gt; using namespace std; class Test { public: void Func(int x, int y) { auto f = [this] { return m_a; }; cout &lt;&lt; f() &lt;&lt; endl; } private: int m_a = 10; }; int main(int argc, const char* argv[]) { //1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ea711d6c931b098fa929315050696197/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-10T08:39:48+08:00" />
<meta property="article:modified_time" content="2023-11-10T08:39:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【一】Lambda表达式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.Lambda表达式概述<br> ​ Lambda表达式是现代C++在C ++ 11和更高版本中的一个新的语法糖 ，在C++11、C++14、C++17和C++20中Lambda表达的内容还在不断更新。 lambda表达式（也称为lambda函数）是在调用或作为函数参数传递的位置处定义匿名函数对象的便捷方法。通常，lambda用于封装传递给算法或异步方法的几行代码 。<br> 2.Lambda表达式定义</p> 
<p>2.1 Lambda表达式语法定义</p> 
<p><img alt="" src="https://images2.imgbox.com/0b/c3/aPz9eXhy_o.png"><br> 1） 捕获列表。在C ++规范中也称为Lambda导入器， 捕获列表总是出现在Lambda函数的开始处。实际上，[]是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数，捕获列表能够捕捉上下文中的变量以供Lambda函数使用。</p> 
<ul><li>[]表示不捕获任何变量</li><li>[var]表示值传递方式捕获变量var</li><li>[=]表示值传递方式捕获所有父作用域的变量（包括this）</li><li>[&amp;var]表示引用传递捕捉变量var</li><li>[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）</li><li>[this]表示值传递方式捕捉当前的this指针</li><li>[=,&amp;a,&amp;b]表示以引用传递的方式捕捉变量a和b，以值传递方式捕捉其它所有变量</li><li> <p>[&amp;,a,this]表示以值传递的方式捕捉变量a和this，引用传递方式捕捉其它所有变量。</p> </li></ul> 
<p>2） 参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略。<br> 3） 可变规格*。mutable修饰符， 默认情况下Lambda函数总是一个const函数，mutable可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。*<br> 4）异常说明。用于Lamdba表达式内部函数抛出异常。<br> 5）返回类型。 追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”-&gt;”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。<br> 6）lambda函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。<br>  </p> 
<p>3.  应用案例</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
using namespace std;
class Test
{
public:
    void Func(int x, int y)
    {
        auto f = [this] {
            return m_a;
        };
        cout &lt;&lt; f() &lt;&lt; endl;
    }

private:
    int m_a = 10;
};
int main(int argc, const char* argv[])
{
    //1.[]不捕获任何变量
    int j = 5;
//    auto f = [] {return j; };	//编译报错

    //2. 静态局部变量,可以直接使用
    static int i = 9;
    auto f1 = [] {return i; };
    cout &lt;&lt; f1() &lt;&lt; endl;	//15

    //3. [&amp;]捕获外部作用域中所有变量，并作为引用在函数体内使用
    int m = 9;
    auto f2 = [&amp;] {
        m = 15;
        return m;
    };
    cout &lt;&lt; f2() &lt;&lt; endl;	//15
    cout &lt;&lt; m &lt;&lt; endl;	//15

    //4. [=]捕获外部作用域中所有变量，并作为值(副本)在函数体内使用,但不许给它赋值
    int k = 1;
    auto f3 = [=] {
//        k = 15;	//非法,不可以给它赋值，因为是以值的方式捕获
    };

    //5. [this]捕获当前类中this指针,让lambda表达式有和当前类成员函数同样的访问权限。
    //如果[]中已经使用了 &amp; 或 =，那么默认已经使用了this,可以使用当前类的成员变量和成员函数。
    Test test;
    test.Func(10, 12);

    //6. [变量名]如果多个变量名，则彼此之间用，分割，按值捕获变量名代表的变量，其他的变量则不捕获
    //	[&amp;变量名]按引用捕获变量名代表的变量，同时不捕获其他变量
    int a = 10, b = 5;
    auto f4 = [a, b] {	//[&amp;a, &amp;b]
        cout &lt;&lt; a &lt;&lt;" " &lt;&lt;  b &lt;&lt; endl;
    };
    f4();

    //7. [=,&amp;变量名] 按值捕获所有外部变量,但按引用捕获&amp;中所指的变量，
    //=必须在开头位置,表示默认以值捕获(隐式捕获方式),后续其他的都是显示捕获
    auto f5 = [=, &amp;a, &amp;b] {
        cout &lt;&lt; k &lt;&lt; " " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
    };

    //8. [&amp;, 变量名] 和7相反作用
    auto f6 = [&amp;, a, b] {
        cout &lt;&lt; k &lt;&lt; " " &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; endl;
    };

    return 0;
}</code></pre> 
<pre></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/060f89a3069f57bca948434ac7752ed8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue2前端使用axios发起post请求，后端(springboot)拿不到值解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/24771568c0cb1f7a465d617e80a0b576/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ElementUI中el-table组件中的cell-class-name属性如何传参</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>