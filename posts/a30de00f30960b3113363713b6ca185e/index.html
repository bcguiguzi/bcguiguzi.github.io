<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>递归算法实现选择排序（YOJ2.0中的题） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="递归算法实现选择排序（YOJ2.0中的题）" />
<meta property="og:description" content="一遍过！
没有草稿！没有任何错误！
太爽了！
因为必须是倒序输出，所以只能用递归，比起之前做的一题，这一题要求是比较严格的
而且最后正确的数列顺序是在改变步骤之后输出，而改变步骤必须伴随着改变后的数组输出
所以你得先正确选择排序一遍，得到排序后的数组，用新数组记录下来，旧数组随着改变步骤的输出而不断变回最开始的那个数组
最后输出步骤数和新数组
代码如下：
#include&lt;stdio.h&gt; void function(int location); int num[101]; int num_last[101]; int n; int m;//交换次数 int main(void) { scanf(&#34;%d&#34;, &amp;n); for(int i = 1; i &lt;= n; i&#43;&#43;)//从1开始记录 scanf(&#34;%d&#34;, &amp;num[i]); function(1); printf(&#34;Total steps:%d\n&#34;, m); printf(&#34;Right order:&#34;); for(int i = 1; i &lt;= n; i&#43;&#43;) { printf(&#34;%d&#34;, num_last[i]); if(i != n) putchar(&#39; &#39;); } return 0; } void function(int location) { int min = num[location], min_loc = location; for(int i = location &#43; 1; i &lt;= n; i&#43;&#43;) if(min &gt; num[i]) { min = num[i]; min_loc = i; } if(min_loc !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a30de00f30960b3113363713b6ca185e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-31T15:02:14+08:00" />
<meta property="article:modified_time" content="2023-10-31T15:02:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">递归算法实现选择排序（YOJ2.0中的题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/7b/5e6ivXR1_o.png"></p> 
<p>一遍过！</p> 
<p>没有草稿！没有任何错误！</p> 
<p>太爽了！</p> 
<p>因为必须是倒序输出，所以只能用递归，比起之前做的一题，这一题要求是比较严格的</p> 
<p>而且最后正确的数列顺序是在改变步骤之后输出，而改变步骤必须伴随着改变后的数组输出</p> 
<p>所以你得先正确选择排序一遍，得到排序后的数组，用新数组记录下来，旧数组随着改变步骤的输出而不断变回最开始的那个数组</p> 
<p>最后输出步骤数和新数组</p> 
<p>代码如下：</p> 
<pre><code class="language-cs">#include&lt;stdio.h&gt;
void function(int location);
int num[101];
int num_last[101];
int n;
int m;//交换次数

int main(void)
{
    scanf("%d", &amp;n);
    for(int i = 1; i &lt;= n; i++)//从1开始记录
        scanf("%d", &amp;num[i]);
    function(1);
    printf("Total steps:%d\n", m);
    printf("Right order:");
    for(int i = 1; i &lt;= n; i++)
    {
        printf("%d", num_last[i]);
        if(i != n)
            putchar(' ');
    }
    
    return 0;
}
void function(int location)
{
    int min = num[location], min_loc = location;
    for(int i = location + 1; i &lt;= n; i++)
        if(min &gt; num[i])
        {
            min = num[i];
            min_loc = i;
        }
    if(min_loc != location)
    {
        m += 1;
        num[min_loc] = num[location];
        num[location] = min;
    }

    //递归
    if(location != n - 1)
        function(location + 1);
    else
        for(int i = 1; i &lt;= n; i++)
            num_last[i] = num[i]; 

    //输出
    if(min_loc != location)
    {
        printf("%d&lt;-&gt;%d:", location, min_loc);
        for(int i = 1; i &lt;= n; i++)
            printf("%d%c", num[i], (i == n) ? '\n' :' ');
        num[location] = num[min_loc];
        num[min_loc] = min;
    }

    return;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ebe57f20f3eaaad9ccb7fab6bea8213/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java-ssm使用逆向工程生成代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9f2fe0a44b6ce062f27262f277b6418c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MineCraft 1.20.1模组开发-（1）-为蓝宝石剑添加右键发射凋零骷髅头以及攻击附加漂浮的效果</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>