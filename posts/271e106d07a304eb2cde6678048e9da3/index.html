<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Pytorch学习记录（6）池化层的使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Pytorch学习记录（6）池化层的使用" />
<meta property="og:description" content="Pytorch学习记录（6）池化层的使用 1.池化层的定义以及池化层的原理： 池化操作(Pooling)是CNN中非常常见的一种操作，Pooling层是模仿人的视觉系统对数据进行降维，池化操作通常也叫做子采样(Subsampling)或降采样(Downsampling)，在构建卷积神经网络时，往往会用在卷积层之后，通过池化来降低卷积层输出的特征维度，有效减少网络参数的同时还可以防止过拟合现象。
主要功能有以下几点：
抑制噪声，降低信息冗余。
提升模型的尺度不变性、旋转不变形。
降低模型计算量。
防止过拟合。
其中常用的池化操作，有maxpool与avgpool，还有随机池化、全局平均池化等其他非常多的池化操作，具体详见卷积神经网络中的各种池化操作 - pprp - 博客园 (cnblogs.com)。
本文以maxpool与avgpool为例子进行着重介绍：
2.最大池化的实现： 以最大池化操作处理二维照片为例，数据集仍选择CIFAR10，代码如下：
import torch.nn as nn import torch import torchvision from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter from torchvision import transforms # 创建的单层最大池化层类 # Pytorch中模型的三要素 1.nn.Module class MyPool(nn.Module): # Pytorch中模型的三要素 2.__init__() def __init__(self): super(MyPool, self).__init__() self.maxpool1 = torch.nn.MaxPool2d(kernel_size=3, stride=1, padding=0) # Pytorch中模型的三要素 3. forward() def forward(self, x): x = self.maxpool1(x) return x # 将数据集图像从PIL格式转化为Tensor格式 tran_tensor = transforms." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/271e106d07a304eb2cde6678048e9da3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-07T16:58:46+08:00" />
<meta property="article:modified_time" content="2023-03-07T16:58:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Pytorch学习记录（6）池化层的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">Pytorch学习记录（6）池化层的使用</h2> 
 <p style=""></p> 
 <h2 style="">1.池化层的定义以及池化层的原理：</h2> 
 <p style="text-indent:1.4em;">池化操作(Pooling)是CNN中非常常见的一种操作，Pooling层是模仿人的视觉系统对数据进行降维，池化操作通常也叫做子采样(Subsampling)或降采样(Downsampling)，在构建卷积神经网络时，往往会用在卷积层之后，通过池化来降低卷积层输出的特征维度，有效减少网络参数的同时还可以防止过拟合现象。</p> 
 <p style="text-indent:1.4em;">主要功能有以下几点：</p> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>抑制噪声，降低信息冗余。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>提升模型的尺度不变性、旋转不变形。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>降低模型计算量。</p></li></ul> 
 <ul><li style="margin-left:2.8em;list-style-type:circle;text-indent:0;"><p>防止过拟合。</p></li></ul> 
 <p style="padding-left:1.4em;">其中常用的池化操作，有maxpool与avgpool，还有随机池化、全局平均池化等其他非常多的池化操作，具体详见<a class="kdocs-link" style="color:#0A6CFF;" href="https://www.cnblogs.com/pprp/p/12456403.html" rel="nofollow noopener noreferrer" target="_blank">卷积神经网络中的各种池化操作 - pprp - 博客园 (cnblogs.com)</a>。</p> 
 <p style="padding-left:1.4em;">本文以maxpool与avgpool为例子进行着重介绍：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:695px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:86.33094%;height:0;"> 
    <img src="https://images2.imgbox.com/f4/41/Psn0hpcZ_o.png" style="margin-left:;display:block;width:695px;margin-top:-86.33094%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="padding-left:1.4em;"></p> 
 <h2 style="">2.最大池化的实现：</h2> 
 <p style="text-indent:1.4em;">以最大池化操作处理二维照片为例，数据集仍选择CIFAR10，代码如下：</p> 
 <pre class="kdocs-python"><code class="language-python">import torch.nn as nn
import torch
import torchvision
from torch.utils.data import DataLoader
from torch.utils.tensorboard import SummaryWriter
from torchvision import transforms


# 创建的单层最大池化层类
# Pytorch中模型的三要素 1.nn.Module
class MyPool(nn.Module):
    # Pytorch中模型的三要素 2.__init__()
    def __init__(self):
        super(MyPool, self).__init__()
        self.maxpool1 = torch.nn.MaxPool2d(kernel_size=3, stride=1, padding=0)

    # Pytorch中模型的三要素 3. forward()
    def forward(self, x):
        x = self.maxpool1(x)
        return x


# 将数据集图像从PIL格式转化为Tensor格式
tran_tensor = transforms.ToTensor()

# 使用CIFAR10数据集
# root数据集的位置,train是否是训练集,transform数据集,download是否下载数据集
dataset = torchvision.datasets.CIFAR10(root="./data", train=False, transform=tran_tensor, download=True)

# 加载数据集dataloader
# dataset数据集的位置,batch_size一次性加载的数据集图像,shuffle是否洗牌,num_workers单多线程,drop_last是否舍去最后总数据集个数除以batch_size个数的余数
dataloader = DataLoader(dataset=dataset, batch_size=64, shuffle=True, num_workers=0, drop_last=False)

# 创建Tensorboard.SummaryWriter模板
writer = SummaryWriter("logs")

step = 0
for data in dataloader:
    imgs, targets = data
    print("imgs.shape", imgs.shape)
    writer.add_images("maxpool_input", imgs, step)
    # 创建MyPool类
    mypool = MyPool()
    # 将图像喂给单层最大池化层的模型
    outputs = mypool(imgs)
    print("outputs.shape", outputs.shape)
    writer.add_images("maxpool_output", outputs, step)
    step = step + 1
writer.close()
</code></pre> 
 <p style="text-indent:1.4em;">通过tensorboard对于输入与输出进行查看：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1189px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:83.851974%;height:0;"> 
    <img src="https://images2.imgbox.com/f5/c8/le7W2dQG_o.png" style="margin-left:;display:block;width:1189px;margin-top:-83.851974%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1284px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:76.24611%;height:0;"> 
    <img src="https://images2.imgbox.com/cd/13/YrwL1JmA_o.png" style="margin-left:;display:block;width:1284px;margin-top:-76.24611%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;">通过对比输入图像和输出图像可知，输出图像比输入图像模糊，有点像加了马赛克的感觉，但是仍然保留了图像的基本特征。</p> 
 <p style=""></p> 
 <h2 style="text-align:left;">3.平均池化的实现：</h2> 
 <p style="text-indent:1.4em;">以平均池化操作处理二维照片为例，数据集仍选择CIFAR10，代码如下：</p> 
 <pre class="kdocs-python"><code class="language-python">import torch.nn as nn
import torch
import torchvision
from torch.utils.data import DataLoader
from torch.utils.tensorboard import SummaryWriter
from torchvision import transforms


class MyPool(nn.Module):
    def __init__(self):
        super(MyPool, self).__init__()
        self.avgpool1 = torch.nn.AvgPool2d(kernel_size=3, stride=1, padding=0)

    def forward(self, x):
        x = self.avgpool1(x)
        return x


tran_tensor = transforms.ToTensor()
dataset = torchvision.datasets.CIFAR10(root="./data", train=False, transform=tran_tensor, download=True)
dataloader = DataLoader(dataset=dataset, batch_size=64, shuffle=True, num_workers=0, drop_last=False)

writer = SummaryWriter("logs")

step = 0
for data in dataloader:
    imgs, targets = data
    print("imgs.shape", imgs.shape)
    writer.add_images("avgpool_input", imgs, step)
    mypool = MyPool()
    outputs = mypool(imgs)
    print("outputs.shape", outputs.shape)
    writer.add_images("avgpool_output", outputs, step)
    step = step + 1
writer.close()</code></pre> 
 <p style="text-indent:1.4em;text-align:left;">通过tensorboard对于输入与输出进行查看：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1282px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:77.067085%;height:0;"> 
    <img src="https://images2.imgbox.com/c3/b5/GofaU8XV_o.png" style="margin-left:;display:block;width:1282px;margin-top:-77.067085%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:1233px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:77.53447%;height:0;"> 
    <img src="https://images2.imgbox.com/64/3a/eVhnH80o_o.png" style="margin-left:;display:block;width:1233px;margin-top:-77.53447%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style="text-indent:1.4em;">通过对比输入图像和输出图像可知，输出图像比输入图像模糊，有点像加了马赛克的感觉，但是仍然保留了图像的基本特征。</p> 
 <p style=""></p> 
 <h2 style="">4.池化层input和output尺寸信息：</h2> 
 <p style="text-indent:1.4em;">在input和output中，要重点关注尺寸信息，对于输入和输出的尺寸信息计算关系如下所示，更多细节可参照PyTorch官网信息<a class="kdocs-link" style="color:#0A6CFF;" href="https://pytorch.org/docs/stable/generated/torch.nn.MaxPool2d.html#torch.nn.MaxPool2d" rel="nofollow noopener noreferrer" target="_blank">MaxPool2d — PyTorch 1.13 documentation</a></p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:740px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:41.08108%;height:0;"> 
    <img src="https://images2.imgbox.com/96/99/pos23ZsO_o.png" style="margin-left:;display:block;width:740px;margin-top:-41.08108%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <p style=""></p> 
 <h2 style="">5.总结：</h2> 
 <p style="text-indent:1.4em;">在本文中总结了神经网络的池化层的基本使用方法，并通过构建一个类Mypool介绍二维的最大池化MaxPool2d以及平均池化AvgPool2d的具体使用方法。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71894ed3ec97d2aa5d06f87c30341e4d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">操作VMware vCenter Converter 实现物理机迁移到虚拟机</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5bfc9ac290b39e32c8fdb65dc2c5a42/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java生成PDF表单及pdf转图片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>