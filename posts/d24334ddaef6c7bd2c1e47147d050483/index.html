<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浏览器的任务队列-宏任务、微任务的执行顺序 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浏览器的任务队列-宏任务、微任务的执行顺序" />
<meta property="og:description" content="重点： 1、首先要清楚常见的宏任务和微任务有哪些
宏任务：setTimeout、setInterval、ajax；
微任务：promise、async/await
2、其次要清楚的是 微任务 执行时机比 宏任务 早
1、微任务和宏任务的执行规则 此处需要注意的是，当所有微任务执行完毕后才会取出一个宏任务执行，宏任务中存在微任务的话还是需要将所有微任务执行完在取出一个宏任务继续执行。
2、JS运行机制 此处不做过多介绍，主要注意以下几点：
js是单线程，所谓单线程就是指JS在引擎中只负责解释和执行JS代码的线程只有一个。这点事核心，将来也不会改变。同步任务会在调用栈中按照顺序等待主线程一次执行；异步任务会在异步任务有了结果后，将注册的回调函数放在任务队列中，等待主线程空闲的时候，被读取到栈内等待主线程的执行Promise本身事同步的立即执行函数，他的.then()和catch()方法是异步的（微任务）async/await是建立在Promise机制上，当调用一个async函数时，会返回一个promise对象，而await操作符后面的表达式就是这个promise，返回值实际上就是peomise的回调函数resolve的参数。async方法执行时，遇到await会立即执行表达式，async表达式定义的函数是立即执行的，await表达式后面的代码放在微任务执行，包括赋值。 以下举几个例子
async function test1() { console.log(&#34;test1 begin&#34;); const result = await test2(); console.log(&#34;result&#34;, result); console.log(&#34;test1 end&#34;); } async function test2() { console.log(&#34;test2&#34;); } console.log(&#34;script begin&#34;); test1(); console.log(&#34;script end&#34;); 控制台打印：
前面注意事项5中说了，async方法执行时，遇到await会立即执行表达式，所有第三次输出应该是test2。await后面的代码将放在微任务中排队。
结果： 1 4 7 5 2 3 6" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d24334ddaef6c7bd2c1e47147d050483/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-11T16:42:09+08:00" />
<meta property="article:modified_time" content="2022-08-11T16:42:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浏览器的任务队列-宏任务、微任务的执行顺序</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>重点：</h3> 
<p>1、首先要清楚常见的宏任务和微任务有哪些</p> 
<blockquote> 
 <p><strong><span style="color:#ff9900;">宏任务：setTimeout、setInterval、ajax；</span></strong></p> 
 <p><strong><span style="color:#ff9900;">微任务：promise、async/await</span></strong></p> 
</blockquote> 
<p>2、其次要清楚的是  <strong>微任务</strong> 执行时机比 <strong>宏任务  早</strong></p> 
<h3>1、微任务和宏任务的执行规则</h3> 
<p><img alt="" height="383" src="https://images2.imgbox.com/b7/91/M9OijHx8_o.png" width="734"></p> 
<blockquote> 
 <p> 此处需要注意的是，当<strong>所有</strong>微任务执行完毕后才会取出<strong>一个</strong>宏任务执行，<strong><span style="color:#fe2c24;">宏任务中存在微任务的话还是需要将所有微任务执行完在取出一个宏任务继续执行。</span></strong></p> 
</blockquote> 
<h3>2、JS运行机制</h3> 
<p>此处不做过多介绍，主要注意以下几点：</p> 
<ol><li>js是单线程，所谓单线程就是指JS在引擎中只负责解释和执行JS代码的线程只有一个。这点事核心，将来也不会改变。</li><li>同步任务会在调用栈中按照顺序等待主线程一次执行；异步任务会在异步任务<strong>有了结果后</strong>，将注册的回调函数放在任务队列中，等待主线程空闲的时候，被读取到栈内等待主线程的执行</li><li>Promise本身事同步的<strong>立即执行函数</strong>，<strong>他的.then()和catch()方法是异步的（微任务）</strong></li><li>async/await是建立在Promise机制上，当调用一个async函数时，会返回一个promise对象，而<strong>await操作符后面</strong>的表达式就是这个promise，返回值实际上就是peomise的回调函数resolve的参数。</li><li>async方法执行时，遇到await会立即执行表达式，<strong>async表达式定义的函数是立即执行的</strong>，<strong>await表达式后面的代码放在微任务执行，包括赋值。</strong> 
  <hr></li></ol> 
<p>以下举几个例子</p> 
<pre><code class="language-javascript">async function test1() {
    console.log("test1 begin");
    const result = await test2();
    console.log("result", result);
    console.log("test1 end");
  }
  async function test2() {
    console.log("test2");
  }
  console.log("script begin");
  test1();
  console.log("script end");
</code></pre> 
<p>控制台打印：</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/64/4f/D4elaQMQ_o.png" width="239"></p> 
<p> 前面注意事项5中说了，async方法执行时，遇到await会立即执行表达式，所有第三次输出应该是test2。await后面的代码将放在微任务中排队。</p> 
<p><img alt="" height="839" src="https://images2.imgbox.com/15/2f/euHKrzMm_o.png" width="508"></p> 
<p>结果： 1 4 7 5 2 3 6</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ab66857a7702f8df5f01b3264b15e9fa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">报错：“ReferenceError: echarts is not defined“</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1464ead4399b824dbf4f464ce49a0c9c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">求解递归方程的方法：递归树法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>