<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2017-2018 ACM-ICPC Asia East Continent League Final (ECL-Final 2017) J - Straight Master (思维乱搞) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2017-2018 ACM-ICPC Asia East Continent League Final (ECL-Final 2017) J - Straight Master (思维乱搞)" />
<meta property="og:description" content="J. Straight Master
time limit per test
2.0 s
memory limit per test
256 MB
input
standard input
output
standard output
A straight is a poker hand containing five cards of sequential rank, not necessarily to be the same suit. For example, a hand containing 7 club, 6 spade, 5 spade, 4 heart and 3 diamond forms a straight. In this problem, we extend the definition of a straight to allow 3 to 5 cards of sequential rank." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/dbfbbc173487236b00423ac3d2389caf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-05T15:23:06+08:00" />
<meta property="article:modified_time" content="2018-11-05T15:23:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2017-2018 ACM-ICPC Asia East Continent League Final (ECL-Final 2017) J - Straight Master (思维乱搞)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>J. Straight Master</p> 
<p>time limit per test</p> 
<p>2.0 s</p> 
<p>memory limit per test</p> 
<p>256 MB</p> 
<p>input</p> 
<p>standard input</p> 
<p>output</p> 
<p>standard output</p> 
<p>A straight is a poker hand containing five cards of sequential rank, not necessarily to be the same suit. For example, a hand containing 7 club, 6 spade, 5 spade, 4 heart and 3 diamond forms a straight. In this problem, we extend the definition of a straight to allow 3 to 5 cards of sequential rank. Hence a hand containing K spade, Q club, and J heart is also a straight.</p> 
<p>Mr. Panda is playing a poker game called Straight Master. The game uses a large deck of card that has <em>N</em> ranks from 1 to <em>N</em>. The rule of the game is simple: split the cards in Mr. Panda's hand into several straights of length from 3 to 5.</p> 
<p>Now given a hand of cards, can you help Mr. Panda to determine if it is possible to split the cards into straights?</p> 
<p>Input</p> 
<p>The first line of the input gives the number of test cases, <em>T</em>. <em>T</em> test cases follow.</p> 
<p>Each test case contains two lines. The first line contains an integer <em>N</em>, indicating the number of ranks in the deck. The next line contains <em>N</em> integers <em>a</em>1, <em>a</em>2, ..., <em>a</em><em>N</em> indicating the number of cards for each rank in Mr. Panda's hand.</p> 
<ul><li>1 ≤ <em>T</em> ≤ 100.</li><li>1 ≤ <em>N</em> ≤ 2 × 105.</li><li>0 ≤ <em>a</em><em>i</em> ≤ 109.</li><li><img alt="" class="has" src="https://images2.imgbox.com/4c/9a/Oyym3bK0_o.png">.</li></ul> 
<p>Output</p> 
<p>For each test case, output one line containing "Case #x: y", where x is the test case number (starting from 1) and y is Yes if Mr. Panda can split all his cards into straights of length from 3 to 5, or No otherwise.</p> 
<p>Example</p> 
<p>Input</p> 
<p>Copy</p> 
<pre id="id005266462447694877">2
13
1 2 2 1 0 0 0 0 0 0 0 0 0
13
1 1 1 1 0 1 1 0 0 0 0 0 0
</pre> 
<p>Output</p> 
<p>Copy</p> 
<pre id="id00011326518555476727">Case #1: Yes
Case #2: No
</pre> 
<p>Note</p> 
<p>In the first test case, Mr. Panda can split his cards into two straights: [1, 2, 3] and [2, 3, 4]. In the second test case, there is no way to form a straight for card 6 and 7.</p> 
<p> </p> 
<p>题意:</p> 
<p>有n种牌，给你每张牌的数量a[i],牌的大小就是i。如果有连续的3/4/5张牌，就可以组成顺子(i,i+1,i+2/i,i+1,i+2,i+3/i,i+1,i+2,i+3,i+4)。</p> 
<p>问你能不能把这些牌分成一堆堆的顺子，不能有单个的牌。</p> 
<p>解析:</p> 
<p>先贴一下大佬的题解和代码</p> 
<p>相当于每次把一个长度为3~5的区间整体减1，问最后是否能够全部减成0。</p> 
<p>显然，每次把一个长度大于5的区间整体减1也是可以的，因为6 = 3+3,7 = 3+4......</p> 
<p>所以问题就变成了每次修改一个长度大于等于3的区间。</p> 
<p>可以先维护原本序列的差分，然后区间整体减1就相当于a[l]--, a[r+1]++。</p> 
<p>所以只要贪心的枚举每个大于0的位置，然后找后面的离他最近的小于0的数字匹配，把前者减，后者加，就可以了。</p> 
<p>如果最近的距离 &lt; 3那么就是不可以。</p> 
<p> </p> 
<p>构造成差分一个很棒的性质就是我们模拟区间更新的时候，就不需要把[l,r]这一段值都更新。</p> 
<p>因为你更新一个差分数组，该区间内两两之间的差值是不会变的，变的只是边界上的差值，所以只需要更新a[l],a[r]就可以了</p> 
<p>然后代码里面找一个最近的负值匹配，这样能保证c[i]就是区间[i,r)的最小值，即是区间更新的值的大小。</p> 
<p>然后匹配完成之后如果c[r]&gt;0，说明还可以继续匹配，那么我们就贪心地继续匹配下去。如果不继续下去，可能下一次</p> 
<p>的匹配就无法完成。用一个例子来讲</p> 
<p>8</p> 
<p>a[]:</p> 
<p>3    6    7    8    7    6    5</p> 
<p>c[]:</p> 
<p>3    3    1    1   -1   -1   -1   -5</p> 
<p>3    3    3    3    2    1             //第一次更新[1,4]-3,然后c[5]变成2&gt;0，继续贪心匹配，更新到[5,5]-2，c[6]=1&gt;0，更新[6,6]-1,end</p> 
<p>      3    3    3    3    3    3           //[2,8]-3 </p> 
<p>            1    1    1    1    1        //[3,8]-1</p> 
<p>                  1    1    1    1        //[4,8]-1</p> 
<p>如果第一次就到[1,4]为止，那么c[5]=2,那么就无法更新[5,5],[6,6]这两个区间但是其实这两个区间完全是可以跟在[1,4]后面更新</p> 
<p>掉的，因为他们接在一起是连续的，并且值是递减的。</p> 
<p> </p> 
<p>虽然讲了那么多，我自己也还不是完全理解大佬的想法...为什么要用差分..为什么要用正负值匹配....</p> 
<p><a href="https://www.cnblogs.com/ruthank/p/9568459.html" rel="nofollow">原文</a></p> 
<pre class="has"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using namespace std;
typedef long long LL;
const int maxn = 200000 + 100;

int a[maxn];
LL c[maxn];

int main()
{
    int t;
    scanf("%d", &amp;t);
    for (int ca = 1; ca &lt;= t; ca++)
    {
        memset(a, 0, sizeof(a));
        int n;
        scanf("%d", &amp;n);
        for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]);
        for (int i = 1; i &lt;= n+1; i++) c[i] = a[i]-a[i-1];

        bool flag = true;
        int r = 0;
        for (int i = 1; i &lt;= n; i++)
        {
            while(c[i] &gt; 0)
            {
                while(c[r] &gt;= 0)
                    if (++r &gt; n+1) flag = false;
                if (r-i &lt;= 2) flag = false;
                if (!flag) break;
                c[r] += c[i], c[i] = 0;
                if (c[r] &gt; 0) c[i] = c[r], c[r] = 0;
            }
            if (!flag) break;
        }

        printf("Case #%d: %s\n", ca, flag?"Yes":"No");
    }
}</code></pre> 
<p>下面讲讲我自己的想法，因为3，4，5是可以组成任意长度的。</p> 
<p>那么我们对于每遍历到一张牌，都先把他往前面的牌去匹配。如果前面的牌不够了，在往后面找2张牌，来组成顺子</p> 
<p>譬如</p> 
<p>3    6    7    8    7     7</p> 
<p>3    3    3    <span style="color:#f33b45;">3   2     2          </span>//当遍历到8时，我们先让他匹配前面的顺子，然后多出来2，那么我们找后面2张牌，组成新的顺子</p> 
<p>      3    3    3   <span style="color:#f33b45;">3</span><span style="color:#003006;">     </span><span style="color:#f33b45;">3</span><span style="color:#003006;">          //7也一样，先匹配前面的，发现匹配完</span></p> 
<p>            1    1   1     </p> 
<p>                  2    2    2</p> 
<p>每一次与前面的组成顺子/组成新的顺子就要更新ex4[]数组，用来表示ex4[i]表示末尾到i的顺子的牌的数量，</p> 
<p>即i+1可以匹配前面的顺子的数量</p> 
<pre class="has"><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long ll;

const int MAX = 2e5+100;

int a[MAX];
int ex4[MAX],ex5[MAX];

int main()
{
    int t;
    scanf("%d",&amp;t);
    int cas=0;
    while(t--)
    {
        cas++;
        int n;
        scanf("%d",&amp;n);
        for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),ex4[i]=ex5[i]=0;
        int flag=1;
        for(int i=1;i&lt;=n;i++)
        {
            if(!a[i]) continue;
            if(ex4[i-1]&gt;a[i])
            {
                ex4[i]+=a[i];
                ex4[i-1]=0;
                a[i]=0;
            }
            else
            {
                a[i]-=ex4[i-1];
                ex4[i]+=ex4[i-1];
                ex4[i-1]=0;
                if(a[i])
                {
                    int ok=0;
                    for(int j=i+1;j&lt;=i+2&amp;&amp;j&lt;=n;j++)
                    {
                        if(a[j]&gt;=a[i])
                        {
                            ok++;
                        }
                    }
                    if(ok&lt;2)
                    {
                        flag=0;
                        break;
                    }
                    else
                    {
                        a[i+1]-=a[i];
                        a[i+2]-=a[i];
                        ex4[i+2]+=a[i];
                        a[i]=0;
                    }
                }
            }

        }
        
        printf("Case #%d: ",cas);
        if(flag) printf("Yes\n");
        else printf("No\n");

    }
    return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/222b9a0323588e77fbdeb12253501751/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">scipy.stats的用法——常见的分布和函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f70f5b285d988449566379ec741cffe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于Qos中常用的CIR、PIR、CBS、PBS、EBS的解释以及用法关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>