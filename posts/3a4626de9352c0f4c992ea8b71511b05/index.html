<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>API 设计的原则 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="API 设计的原则" />
<meta property="og:description" content="我在 Thoughtworks 上曾经读到过一篇文章《API 设计的几条原则》我觉得写得非常不错，链接我放底下，推荐阅读。
在我多年的工作历程中，我深刻意识到 API 的设计至关重要，但是我发现，在一般的组织中，API 的设计却往往草率。这主要体现在几个方面：
操刀人选草率 ：不少团队的 API 设计，都是负责实现的同事进行的，这些同事很多情况下，并不是团队里最资深，最了解各个系统构造的人，在设计的时候，就不能考虑到更多的东西；接口缺乏标准 ：公司稍微大一点的情况下，很容易缺乏全公司统一的标准，往往就是各个团队有各个团队的标准，如果仅是如此尚好，有时候不同团队的标准不兼容；命名草率：接口上选用的单词，往往非常随机，取决于设计者的个人修养，而这些命名有时候并某有经过审计，在定稿的时候，上下游都没有认真的思考过，有时候名字取得过大，有时候取得过小，非常妨碍使用者的理解，甚至造成误导； 我观国内外一些顶级的开源项目，API 动辄几年十几年不变，就深感佩服。那么 API 设计到底要考虑些什么因素，怎样设计，才能做到这样的稳定呢？
API 本质上是系统不同部分之间通信的协议，当然也包括跟外部系统之间的通信。要想设计得好，就要将系统充分的抽象，这个过程之中，要尽量摒弃掉抽象之外的因素的影响。比如，接口运行的网络协议（TCP/UDP），内容格式（文本/二进制），调用者的形态（服务器/客户端），这类都不应该预定一种假设。
原文的作者认为，设计 API 是非常难的，评估 API 的好坏也是非常难的，所以给出一些原则，共参考：
使用成熟度合适的 RESTful API RESTful 风格的 API 具有一些天然的优势，例如通过 HTTP 协议降低了客户端的耦合，具有极好的开放性。因此越来越多的开发者使用 RESTful 这种风格设计 API，但是 RESTful 只能算是一个设计思想或理念，不是一个 API 规范，没有一些具体的约束条件。
因此在设计 RESTful 风格的 API 时候，需要参考 RESTful 成熟度模型。
成熟度等级解释示例Level 0定义一个 URI 所有请求通过 POST 完成POST /?action=changeUserPasswordLevel 1创建独立的资源地址，隔离 API 的范围POST /user?action=updateLevel 2使用 HTTP 动词定义对资源的操作GET /user/01Level 3使用 API 超媒体 （HATEOAS，返回的 body 中索引相关的资源地址{ &#34;links&#34; : [ &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3a4626de9352c0f4c992ea8b71511b05/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-10T17:08:23+08:00" />
<meta property="article:modified_time" content="2024-03-10T17:08:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">API 设计的原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/1a/16/uv1MM994_o.png" alt="在这里插入图片描述" width="750"></p> 
<p>我在 Thoughtworks 上曾经读到过一篇文章《API 设计的几条原则》我觉得写得非常不错，链接我放底下，推荐阅读。</p> 
 
<p>在我多年的工作历程中，我深刻意识到 API 的设计至关重要，但是我发现，在一般的组织中，API 的设计却往往草率。这主要体现在几个方面：</p> 
<ol><li><strong>操刀人选草率</strong> ：不少团队的 API 设计，都是负责实现的同事进行的，这些同事很多情况下，并不是团队里最资深，最了解各个系统构造的人，在设计的时候，就不能考虑到更多的东西；</li><li><strong>接口缺乏标准</strong> ：公司稍微大一点的情况下，很容易缺乏全公司统一的标准，往往就是各个团队有各个团队的标准，如果仅是如此尚好，有时候不同团队的标准不兼容；</li><li><strong>命名草率</strong>：接口上选用的单词，往往非常随机，取决于设计者的个人修养，而这些命名有时候并某有经过审计，在定稿的时候，上下游都没有认真的思考过，有时候名字取得过大，有时候取得过小，非常妨碍使用者的理解，甚至造成误导；</li></ol> 
<p>我观国内外一些顶级的开源项目，API 动辄几年十几年不变，就深感佩服。那么 API 设计到底要考虑些什么因素，怎样设计，才能做到这样的稳定呢？</p> 
<p>API 本质上是系统不同部分之间通信的协议，当然也包括跟外部系统之间的通信。要想设计得好，就要将系统充分的抽象，这个过程之中，要尽量摒弃掉抽象之外的因素的影响。比如，接口运行的网络协议（TCP/UDP），内容格式（文本/二进制），调用者的形态（服务器/客户端），这类都不应该预定一种假设。</p> 
<p>原文的作者认为，设计 API 是非常难的，评估 API 的好坏也是非常难的，所以给出一些原则，共参考：</p> 
<h2><a id="_RESTful_API_19"></a>使用成熟度合适的 RESTful API</h2> 
<p>RESTful 风格的 API 具有一些天然的优势，例如通过 HTTP 协议降低了客户端的耦合，具有极好的开放性。因此越来越多的开发者使用 RESTful 这种风格设计 API，但是 RESTful 只能算是一个设计思想或理念，不是一个 API 规范，没有一些具体的约束条件。</p> 
<p>因此在设计 RESTful 风格的 API 时候，需要参考 RESTful 成熟度模型。</p> 
<table><thead><tr><th>成熟度等级</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td>Level 0</td><td align="left">定义一个 URI 所有请求通过 POST 完成</td><td align="left"><code>POST /?action=changeUserPassword</code></td></tr><tr><td>Level 1</td><td align="left">创建独立的资源地址，隔离 API 的范围</td><td align="left"><code>POST /user?action=update</code></td></tr><tr><td>Level 2</td><td align="left">使用 HTTP 动词定义对资源的操作</td><td align="left"><code>GET /user/01</code></td></tr><tr><td>Level 3</td><td align="left">使用 API 超媒体 （HATEOAS，返回的 body 中索引相关的资源地址</td><td align="left"><code>{ "links" : [ "/users/", "/products/" ] } </code></td></tr></tbody></table> 
<p>一般团队选用的等级在 Level 2，这是一个参考，不过我自己实践下来看，Level 2 也是比较难的，我所在的团队可能还在使用 Level 1，因为更直观一点，比较容易掌握，大家的理解也比较容易一致。</p> 
<p>这里补充一个对成熟度模型的解释：</p> 
<ul><li>Level 0，有点像系统间的 RPC 调用一样，类比一下编程泛型的话，就是面向过程编程。你远程调用服务器的一个方法，得到返回值。</li><li>Level 1，引入资源的概念，资源与资源之间隔离了。有点像面向对象编程，调用一个对象上的方法。</li><li>Level 2，引入 HTTP 动词，把 HTTP 协议当成原本设计的意图去使用，而不是退化个一个管道。</li><li>Level 3，引入超媒体概念，HATEOAS（作为应用状态引擎的超文本）</li></ul> 
<h2><a id="_41"></a>避免简单封装</h2> 
<p>API应该服务业务能力的封装，避免简单封装让API彻底变成了数据库操作接口。例如标记订单状态为已支付，应该提供形如 <code>POST /orders/1/pay</code> 这样的API。而非 <code>PATCH /orders/1</code>，然后通过具体的字段更新订单。</p> 
<p>因为订单支付是有具体的业务逻辑，可能涉及到大量复杂的操作，使用简单的更新操作将业务逻辑泄漏到系统之外。同时系统外也需要知道订单状态 这个内部使用的字段。</p> 
<p>更重要的是，破坏了业务逻辑的封装，同时也会影响其他非功能需求。例如，权限控制、日志记录、通知等。</p> 
<h2><a id="_49"></a>关注点分离</h2> 
<p>好的接口应该做到不多东西，不少东西。 怎么理解呢？在用户修改密码和修改个人资料的场景中，这两个操作看起来很类似，然后设计API的时候使用了一个通用的 <code>/users/1/udpateURI</code>。</p> 
<p>然后定义了一个对象，这个对象可能直接使用了User这个类：</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"username"</span><span class="token operator">:</span> <span class="token string">"用户名"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"password"</span><span class="token operator">:</span> <span class="token string">"密码"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个对象在修改用户名的时候， password是不必要的，但是在修改密码的操作中，一个password字段却不够用了，可能还需要confirmPassword。</p> 
<p>于是这个接口变成：</p> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"username"</span><span class="token operator">:</span> <span class="token string">"用户名"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"password"</span><span class="token operator">:</span><span class="token string">"密码"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"confirmPassword"</span><span class="token operator">:</span><span class="token string">"重复密码"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这种类的复用会给后续维护的开发者带来困惑，同时对消费者也非常不友好。合理的设计应该是两个分离的 API：</p> 
<pre><code class="prism language-json"><span class="token comment">// POST /users/{userId}/password</span>

<span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"password"</span><span class="token operator">:</span><span class="token string">"密码"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"confirmPassword"</span><span class="token operator">:</span><span class="token string">"重复密码"</span>
<span class="token punctuation">}</span>
<span class="token comment">// PATCH /users/{userId}</span>

<span class="token punctuation">{<!-- --></span>
  <span class="token string-property property">"username"</span><span class="token operator">:</span><span class="token string">"用户名"</span><span class="token punctuation">,</span>
  <span class="token string-property property">"xxxx"</span><span class="token operator">:</span><span class="token string">"其他可更新的字段"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>对应的实现，在 Java 中需要定义两个 DTO，分别处理不同的接口。这也体现了面向对象思想中的关注点分离。</p> 
<h2><a id="_93"></a>互斥穷举</h2> 
<p>API 之间尽量遵守 <strong>MECE</strong> （互斥穷举）原则，不应该提供相互叠加的 API。例如订单和订单项这两个资源，如果提供了形如 <code>PUT /orders/1/order-items/1</code> 这样的接口去修改订单项，接口 <code>PUT /orders/1</code> 就不应该具备处理某一个 order-item 的能力。</p> 
<p>这样的好处是不会存在重复的 API，造成维护和理解上的复杂性。如何做到完全穷尽和彼此独立呢？</p> 
<p>简单的方法是使用一个表格设计 API，标出每个 URI 具备的能力。</p> 
<p>资源 URL 设计来源于 DDD 领域建模就非常简单了，聚合根作为根 URL，实体作为二级 URI 设计。聚合根之间应该彻底没有任何联系，实体和聚合根之间的责任应该明确。</p> 
<p>产生这类问题的根源还是缺乏合理的抽象。如果存在 API 中可以通过用户组操作用户，通过用户的 URI 操作用户属于的用户组，这其中的问题是缺少了成员这一概念。用户组下面的本质上并不是用户，而是用户和用户组的关系，即成员。</p> 
<h2><a id="_105"></a>版本化</h2> 
<p>一个对外开放的服务，极大的概率会发生变化。业务变化可能修改 API 参数或响应数据结构，以及资源之间的关系。一般来说，字段的增加不会影响旧的客户端运行。但是当存在一些破坏性修改时，就需要使用新的版本将数据导向到新的资源地址。</p> 
<p>版本信息的传输，可以通过下面几种方式</p> 
<ul><li>URI 前缀</li><li>Header</li><li>Query</li></ul> 
<p>比较推荐的做法是使用 URI 前缀，例如<code>/v1/users/</code>表达获取 v1 版本下的用户列表。</p> 
<p>常见的反模式是通过增加 URI 后缀来实现的，例如<code>/users/1/updateV2</code>。这样做的缺陷是版本信息侵入到业务逻辑中，对路由的统一管理带来不便。</p> 
<p>使用 Header 和 Query 发送版本信息则较为相似，不同之处在于，使用 URI 前缀在 MVC 框架中实现相对简单，只需要定义好路由即可。使用 Header 和 Query 还需要编写额外的拦截器。</p> 
<h2><a id="_121"></a>合理命名</h2> 
<p>设计 API 时候的命名涉及多个地方：URI、请求参数、响应数据等。通常来说最主要，也是最难的一个是全局命名统一。</p> 
<p>其次，命名需要注意这些：</p> 
<ul><li>尽可能和领域名词保持一致，例如聚合根、实体、事件等</li><li>RESTful 设计的 URI 中使用名词复数</li><li>尽可能不要过度简写，例如将 user 简写成usr</li><li>尽可能使用不需要编码的字符</li></ul> 
<p>用领域名词来对 API 设计命名不是一件特别难的事情。识别出的领域名词可以直接作为 URI 来使用。如果存在多个单词的连接可以使用中横线，例如 <code>/orders/1/order-items</code></p> 
<h2><a id="_134"></a>安全</h2> 
<p>安全是任何一项软件设计都必须要考虑的事情，对于 API 设计来说，暴露给内部系统的 API 和开放给外部系统的 API 略有不同。</p> 
<p>内部系统，更多的是考虑是否足够健壮。对接收的数据有足够的验证，并给出错误信息，而不是什么信息都接收，然后内部业务逻辑应该边界值的影响变得莫名其妙。</p> 
<p>而对于外部系统的 API 则有更多的挑战。</p> 
<ul><li>错误的调用方式</li><li>接口滥用</li><li>浏览器消费 API 时因安全漏洞导致的非法访问</li></ul> 
<p>所以设计 API 时应该考虑响应的应对措施。针对错误的调用方式，API 不应该进入业务处理流程，及时给出错误信息；对于接口滥用的情况，需要做一些限速的方案；对于一些浏览器消费者的问题，可以在让 API 返回一些安全增强头部，例如：X-XSS-Protection、Content-Security-Policy 等。</p> 
<h2><a id="API__147"></a>API 设计评审清单</h2> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> URI 命名是否通过聚合根和实体统一</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> URI 命名是否采用名词复数和连接线</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> URI 命名是否都是单词小写</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> URI 是否暴露了不必要的信息，例如/cgi-bin</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> URI 规则是否统一</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 资源提供的能力是否彼此独立</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> URI 是否存在需要编码的字符</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 请求和返回的参数是否不多不少</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 资源的 ID 参数是否通过 PATH 参数传递</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 认证和授权信息是否暴露到 query 参数中</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 参数是否使用奇怪的缩写</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 参数和响应数据中的字段命名统一</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否存在无意义的对象包装 例如{“data”:{}'}</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 出错时是否破坏约定的数据结构</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否使用合适的状态码</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否使用合适的媒体类型</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 响应数据的单复是否和数据内容一致</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 响应头中是否有缓存信息</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否进行了版本管理</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 版本信息是否作为 URI 的前缀存在</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否提供 API 服务期限</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否提供了 API 返回所有 API 的索引</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否进行了认证和授权</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否采用 HTTPS</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否检查了非法参数</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否增加安全性的头部</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否有限流策略</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否支持 CORS</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 响应中的时间格式是否采用ISO 8601标准</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> 是否存在越权访问</li></ul> 
<p>《<a href="https://insights.thoughtworks.cn/how-to-design-api/" rel="nofollow">API设计的几条原则</a>》</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a07ce298f655960f8057387a43bedee8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UE5 局域网联机，寻找会话失败。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b03f40a38bcc07f36f2d1b416b83424/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux 配置jdk环境变量</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>