<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ansible的事实，循环和条件判断 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ansible的事实，循环和条件判断" />
<meta property="og:description" content="1. 管理事实 1.1描述ansible事实 ​ ansible的事实是ansible在受管主机上自动检测到的变量。可以直接再playbook中直接引用的
事实中包括一下一些数据：
主机名称内核版本网络接口IP地址操作系统版本各种环境变量CPU数量提供的或可用的内存可用磁盘空间 借助事实，我们可以更加方便的检索受管主机的状态，并根据这些数据来确定要执行的操作，例如：
可以根据含有受管主机当前内核版本的事实运行条件任务，以此来重启服务器可以根据通过事实报告的可用内存来自定义MySQL配置文件可以根据事实的值设置配置文件中使用的IPv4地址 在我们运行playbook的第一个任务之前，ansible会自动运行setup模块来收集事实。
查看为受管主机收集的事实的一种方式是，运行一个收集事实并使用debug模块显示ansible_facts变量值的简短playbook。
[root@ansible ansible]# cat playbook/test.yml --- - name: test hosts: all tasks: - name: print all facts debug: var: ansible_facts 运行该playbook，则事实就会显示在输出内容中：
[root@ansible ansible]# ansible-playbook playbook/test.yml PLAY [test] *********************************************************************************************** TASK [Gathering Facts] ************************************************************************************ok: [192.168.10.201] TASK [print all facts] ************************************************************************************ok: [192.168.10.201] =&gt; { &#34;ansible_facts&#34;: { &#34;all_ipv4_addresses&#34;: [ &#34;192.168.10.201&#34; ], &#34;all_ipv6_addresses&#34;: [ &#34;fe80::20c:29ff:fe77:cc9a&#34; ], &#34;ansible_local&#34;: {}, &#34;apparmor&#34;: { &#34;status&#34;: &#34;disabled&#34; }, &#34;architecture&#34;: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c6e9666eacab8c737a06154d6eaaf3b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-24T16:51:34+08:00" />
<meta property="article:modified_time" content="2021-07-24T16:51:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ansible的事实，循环和条件判断</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1. 管理事实</h3> 
<h4><a id="11ansible_2"></a>1.1描述ansible事实</h4> 
<p>​ ansible的事实是ansible在受管主机上自动检测到的变量。可以直接再playbook中直接引用的</p> 
<p>事实中包括一下一些数据：</p> 
<ul><li>主机名称</li><li>内核版本</li><li>网络接口</li><li>IP地址</li><li>操作系统版本</li><li>各种环境变量</li><li>CPU数量</li><li>提供的或可用的内存</li><li>可用磁盘空间</li></ul> 
<p>借助事实，我们可以更加方便的检索受管主机的状态，并根据这些数据来确定要执行的操作，例如：</p> 
<ul><li>可以根据含有受管主机当前内核版本的事实运行条件任务，以此来重启服务器</li><li>可以根据通过事实报告的可用内存来自定义MySQL配置文件</li><li>可以根据事实的值设置配置文件中使用的IPv4地址</li></ul> 
<p>在我们运行playbook的第一个任务之前，ansible会自动运行setup模块来收集事实。</p> 
<p>查看为受管主机收集的事实的一种方式是，运行一个收集事实并使用debug模块显示ansible_facts变量值的简短playbook。</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml 
---
- name: test
  hosts: all
  tasks:
    - name: print all facts
      debug:
        var: ansible_facts
</code></pre> 
<p>运行该playbook，则事实就会显示在输出内容中：</p> 
<pre><code>[root@ansible ansible]# ansible-playbook playbook/test.yml 

PLAY [test] ***********************************************************************************************
TASK [Gathering Facts] ************************************************************************************ok: [192.168.10.201]

TASK [print all facts] ************************************************************************************ok: [192.168.10.201] =&gt; {
    "ansible_facts": {
        "all_ipv4_addresses": [
            "192.168.10.201"
        ],
        "all_ipv6_addresses": [
            "fe80::20c:29ff:fe77:cc9a"
        ],
        "ansible_local": {},
        "apparmor": {
            "status": "disabled"
        },
        "architecture": "x86_64",
        "bios_date": "07/22/2020",
        "bios_version": "6.00",
        "cmdline": {
            "BOOT_IMAGE": "(hd0,msdos1)/vmlinuz-4.18.0-257.el8.x86_64",
            "crashkernel": "auto",
            "quiet": true,
            "rd.lvm.lv": "cs/swap",
            "resume": "/dev/mapper/cs-swap",
            "rhgb": true,
            "ro": true,
            "root": "/dev/mapper/cs-root"
     …………………………………………………………………………略略
</code></pre> 
<p>其中的内容有很多我们可以用到的数据。</p> 
<p>下面有一些我们可能从受管节点收集的并可在playbook中使用的一些事实：<br> <strong>Ansible事实的示例</strong></p> 
<table><thead><tr><th>变量</th><th align="center"><strong>事实</strong></th></tr></thead><tbody><tr><td>ansible_facts[‘hostname’]</td><td align="center">短主机名</td></tr><tr><td>ansible_facts[‘fqdn’]</td><td align="center">完全限定域名</td></tr><tr><td>ansible_facts[‘default_ipv4’] [‘address’]</td><td align="center">IPv4地址</td></tr><tr><td>ansible_facts[‘interfaces’]</td><td align="center">所有网络接口的名称列表</td></tr><tr><td>ansible_facts[‘devices’] [‘vda’] [‘partitions’] [‘vda1’] [‘size’]</td><td align="center">/dev/vda1磁盘分区的大小</td></tr><tr><td>ansible_facts[‘dns’] [‘nameservers’]</td><td align="center">DNS服务器列表</td></tr><tr><td>ansible_facts[‘kernel’]</td><td align="center">当前运行的内核版本</td></tr></tbody></table> 
<p>在playbook中使用事实时，Ansible将事实的变量名动态替换为对应的值：</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  tasks:
    - name: test print facts
      debug:
        msg: &gt;
          The default IPv4 address of {<!-- -->{ ansible_facts.fqdn }}
          is {<!-- -->{ ansible_facts.default_ipv4.address }}
</code></pre> 
<p>运行此playbook查看结果</p> 
<pre><code>[root@ansible ansible]# ansible-playbook playbook/test.yml

PLAY [test] ***********************************************************************************************
TASK [Gathering Facts] ************************************************************************************ok: [192.168.10.201]

TASK [test print facts] ***********************************************************************************ok: [192.168.10.201] =&gt; {
    "msg": "The default IPv4 address of localhost.localdomain is 192.168.10.201\n"
}

PLAY RECAP ************************************************************************************************192.168.10.201             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

[root@ansible ansible]#
</code></pre> 
<h4><a id="12__127"></a>1.2 关闭事实收集</h4> 
<p>​ 如果我们不想用到事实中的数据，我们可以选择关闭事实收集的功能</p> 
<pre><code>---
- name: test
  hosts: all
  gather_facts: no
</code></pre> 
<p>只需要在playbook中加入gather_facts: no即可</p> 
<p>不过即使play设置了<strong>gather_facts: no</strong> 也可以随时通过运行使用setup模块的任务来手动收集事实：</p> 
<pre><code>---
- name: test
  hosts: all
  gather_facts: no
  tasks:
    - name: get facts
      setup:
    - name: test print facts
      debug:
        msg: &gt;
          The default IPv4 address of {<!-- -->{ ansible_facts.fqdn }}
          is {<!-- -->{ ansible_facts.default_ipv4.address }}
</code></pre> 
<h4><a id="13_159"></a>1.3创建自定义事实</h4> 
<p>​ 除了使用系统捕获的事实外，我们还可以自定义事实，并将其本地存储在每个受管主机上。这些事实整合到setup模块在受管主机上运行时收集的标准事实列表中。它们让受管主机能够向Ansible提供任意变量，以用于调整play的行为。</p> 
<p>​ 有了自定义事实，我们可以为受管主机定义特定的值，供play用于填充配置文件或有条件地运行任务。动态自定义事实允许在play运行时以编程方式确定这些事实的值，甚至还可以确定提供哪些事实。</p> 
<p>​ 默认情况下，setup模块从各受管主机的**/etc/ansible/facts.d<strong>目录下的文件和脚本中加载自定义事实。各个文件或脚本的名称必须以</strong>.fact**结尾才能被使用。动态自定义事实脚本必须输出JSON格式的事实，而且必须是可执行文件。</p> 
<p>​ 以下是采用INI格式编写的静态自定义事实文件。INI格式的自定义事实文件包含由一个部分定义的顶层值，后跟用于待定义的事实的键值对：</p> 
<pre><code>[root@localhost ~]# mkdir -p /etc/ansible/facts.d/
[root@localhost ~]# cd /etc/ansible/facts.d/
[root@localhost facts.d]# vim test.fact
[root@localhost facts.d]# cat test.fact 
[packages]
web_package = httpd
db_package = mariadb-server
[root@localhost facts.d]#
</code></pre> 
<p>然后我们在ansible主机上获取受管主机的事实时，就会显示我们所自定义的事实：</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  tasks:
    - name: test 
      debug:
        msg: &gt;
          The package to install on {<!-- -->{ ansible_facts['hostname'] }}
          is {<!-- -->{ ansible_facts['ansible_local']['test']['packages']['web_package'] }}
[root@ansible ansible]# ansible-playbook playbook/test.yml

PLAY [test] ****************************************************************************************
TASK [Gathering Facts] ************************************************************************************ok: [192.168.10.201]

TASK [test] *****************************************************************************************ok: [192.168.10.201] =&gt; {
    "msg": "The package to install on localhost is httpd\n"
}

PLAY RECAP *****************************************************************************************192.168.10.201             : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

</code></pre> 
<h4><a id="14__208"></a>1.4 使用魔法变量</h4> 
<p>一些变量并非事实或通过setup模块配置，但也由Ansible自动设置。这些魔法变量也可用于获取与特定受管主机相关的信息。</p> 
<p>最常用的有四个：</p> 
<table><thead><tr><th align="left">魔法变量</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">hostvars</td><td align="left">包含受管主机的变量，可以用于获取另一台受管主机的变量的值。 如果还没有为受管主机收集事实，则它不会包含该主机的事实。</td></tr><tr><td align="left">group_names</td><td align="left">列出当前受管主机所属的所有组</td></tr><tr><td align="left">groups</td><td align="left">列出清单中的所有组和主机</td></tr><tr><td align="left">inventory_hostname</td><td align="left">包含清单中配置的当前受管主机的主机名称。 因为各种原因有可能与事实报告的主机名称不同</td></tr></tbody></table> 
<p>另外还有许多其他的“魔法变量”。有关更多信息，请参见以下链接：<br> https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable。<br> 若要深入了解它们的值，一个途径是使用debug模块报告特定主机的<strong>hostvars</strong>变量的内容：</p> 
<pre><code>[root@ansible ansible]# ansible all -m debug -a 'var=hostvars["localhost"]'
192.168.10.201 | SUCCESS =&gt; {
    "hostvars[\"localhost\"]": {
        "ansible_check_mode": false,
        "ansible_connection": "local",
        "ansible_diff_mode": false,
        "ansible_facts": {},
        "ansible_forks": 5,
        "ansible_inventory_sources": [
            "/etc/ansible/inventory"
        ],
        "ansible_playbook_python": "/usr/bin/python3.6",
        "ansible_python_interpreter": "/usr/bin/python3.6",
        "ansible_verbosity": 0,
        "ansible_version": {
            "full": "2.9.23",
            "major": 2,
            "minor": 9,
            "revision": 23,
            "string": "2.9.23"
        },
        "group_names": [],
        "groups": {
            "all": [
                "192.168.10.201"
            ],
            "ungrouped": [],
            "web1": [
                "192.168.10.201"
            ]
        },
        "inventory_hostname": "localhost",
        "inventory_hostname_short": "localhost",
        "omit": "__omit_place_holder__cbc8c8b8658480e6dcb5fbc05337c84da4bf90d3",
        "playbook_dir": "/etc/ansible"
    }
}
[root@ansible ansible]#
</code></pre> 
<h3><a id="2__270"></a>2. 编写循环和条件任务</h3> 
<h4><a id="11__272"></a>1.1 利用循环迭代任务</h4> 
<p>​ 通过利用循环，我们无需编写多个使用同一模块的任务。例如，他们不必编写五个任务来确保存在五个用户，而是只需编写一个任务来对含有五个用户的列表迭代，从而确保它们都存在。</p> 
<p>​ Ansible支持使用<strong>loop</strong>关键字对一组项目迭代任务。可以配置循环以利用列表中的各个项目、列表中各个文件的内容、生成的数字序列或更为复杂的结构来重复任务。</p> 
<p>​ 让我们来写一个简单的循环：</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  tasks:
    - name: test
      user:
        name: "{<!-- -->{ item }}"
        state: present
      loop:
        - tom1
        - tom2
        - tom3
[root@ansible ansible]#
</code></pre> 
<p>这样就可以让他们进行逐一的创建用户，执行一下这个playbook看看效果：</p> 
<pre><code>[root@ansible ansible]# ansible-playbook playbook/test.yml

PLAY [test] ***********************************************************************************************
TASK [Gathering Facts] ************************************************************************************ok: [192.168.10.201]

TASK [test] ***********************************************************************************************changed: [192.168.10.201] =&gt; (item=tom1)
changed: [192.168.10.201] =&gt; (item=tom2)
changed: [192.168.10.201] =&gt; (item=tom3)

PLAY RECAP ************************************************************************************************192.168.10.201             : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

[root@ansible ansible]#
</code></pre> 
<p>我们也可以通过一个变量提供<strong>loop</strong>所使用的列表。在以下示例中，变量<strong>users</strong>含有需要创建的用户：</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  vars:
    users:
      - tom1
      - tom2
      - tom3
  tasks:
    - name: test
      user:
        name: "{<!-- -->{ item }}"
        state: present
      loop:
        "{<!-- -->{ users }}"
[root@ansible ansible]#
</code></pre> 
<h5><a id="111__336"></a>1.1.1 循环散列或字典列表</h5> 
<p>​ <strong>loop</strong>列表不需要是简单值列表。在以下示例中，列表中的每个项实际上是散列或字典。示例中的每个散列或字典具有两个键，即<strong>name</strong>和<strong>groups</strong>，当前item循环变量中每个键的值可以分别通过<strong>item.name</strong>和<strong>item.groups</strong>变量来检索。</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  tasks:
    - name: test
      user:
        name: "{<!-- -->{ item.name }}"
        state: present
        uid: "{<!-- -->{ item.uid }}"
      loop:
        - name: tom1
          uid: 3000
        - name: tom2
          uid: 3001
        - name: tom3
          uid: 3002
[root@ansible ansible]#
</code></pre> 
<p>然后我们运行查看效果</p> 
<pre><code>[root@ansible ansible]# ansible-playbook playbook/test.yml

PLAY [test] *****************************************************************************************

TASK [Gathering Facts] *****************************************************************************************ok: [192.168.10.201]

TASK [test] *****************************************************************************************changed: [192.168.10.201] =&gt; (item={'name': 'tom1', 'uid': 3000})
changed: [192.168.10.201] =&gt; (item={'name': 'tom2', 'uid': 3001})
changed: [192.168.10.201] =&gt; (item={'name': 'tom3', 'uid': 3002})

PLAY RECAP *****************************************************************************************192.168.10.201             : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

</code></pre> 
<h4><a id="12__380"></a>1.2 有条件地运行任务</h4> 
<p>​ Ansible可使用conditionals在符合特定条件时执行任务或play。例如，可以利用一个条件在Ansible安装或配置服务前确定受管主机上的可用内存。</p> 
<p>​ 我们可以利用条件来区分不同的受管主机，并根据它们所符合的条件来分配功能角色。Playbook变量、注册的变量和Ansible事实都可通过条件来进行测试。可以使用比较字符串、数字数据和布尔值的运算符。</p> 
<p>以下场景说明了在Ansible中使用条件的情况：</p> 
<ul><li>可以在变量中定义硬限制（如min_memory）并将它与受管主机上的可用内存进行比较。</li><li>Ansible可以捕获并评估命令的输出，以确定某一任务在执行进一步操作前是否已经完成。例如，如果某一程序失败，则将路过批处理。</li><li>可以利用Ansible事实来确定受管主机网络配置，并决定要发送的模板文件（如，网络绑定或中继）。</li><li>可以评估CPU的数量，来确定如何正确调节某一Web服务器。</li><li>将注册的变量与预定义的变量进行比较，以确定服务是否已更改。例如，测试服务配置文件的MD5检验以和查看服务是否已更改。</li></ul> 
<h5><a id="121__394"></a>1.2.1 条件任务语句</h5> 
<p>​ <strong>when</strong>语句用于有条件地运行任务。它取要测试的条件为值。如果条件满足，则运行任务。如果条件不满足，则跳过任务。</p> 
<p>可以测试的一个最简单条件是某一布尔变量是<strong>True</strong>还是<strong>False</strong>。以下示例中的<strong>when</strong>语句导致任务仅在<strong>run_my_task</strong>为<strong>True</strong>时运行：</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  vars:
    run_my_task: true
  tasks:
    - name: test
      user:
        name: "{<!-- -->{ item.name }}"
        state: absent
      loop:
        - name: tom1
        - name: tom2
        - name: tom3
      when: run_my_task
[root@ansible ansible]# ansible-playbook playbook/test.yml

PLAY [test] *****************************************************************************************

TASK [Gathering Facts] *****************************************************************************************ok: [192.168.10.201]

TASK [test] *****************************************************************************************changed: [192.168.10.201] =&gt; (item={'name': 'tom1'})
changed: [192.168.10.201] =&gt; (item={'name': 'tom2'})
changed: [192.168.10.201] =&gt; (item={'name': 'tom3'})

PLAY RECAP *****************************************************************************************192.168.10.201             : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

[root@ansible ansible]#
</code></pre> 
<p>以下示例测试my_service变量是否具有值。若有值，则将my_service的值用作要安装的软件包的名称。如果未定义my_service变量，则跳过任务且不显示错误。</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  vars:
    my_service: httpd
  tasks:
    - name: test
      yum:
        name: "{<!-- -->{ my_service }}"
        state: latest
      when: my_service is defined
[root@ansible ansible]# ansible-playbook playbook/test.yml

PLAY [test] *****************************************************************************************
TASK [Gathering Facts] 

*****************************************************************************************ok: [192.168.10.201]

TASK [test] *****************************************************************************************changed: [192.168.10.201]

PLAY RECAP *****************************************************************************************192.168.10.201             : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0   

</code></pre> 
<p>下表显示了在处理条件时可使用的一些运算：<br> <strong>示例条件</strong></p> 
<table><thead><tr><th align="left">操作</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">等于（值为字符串）</td><td align="left">ansible_machine == “x86_64”</td></tr><tr><td align="left">等于（值为数字）</td><td align="left">max_memory == 512</td></tr><tr><td align="left">小于</td><td align="left">min_memory &lt; 128</td></tr><tr><td align="left">大于</td><td align="left">min_memory &gt; 256</td></tr><tr><td align="left">小于等于</td><td align="left">min_memory &lt;= 256</td></tr><tr><td align="left">大于等于</td><td align="left">min_memory &gt;= 512</td></tr><tr><td align="left">不等于</td><td align="left">min_memory != 512</td></tr><tr><td align="left">变量存在</td><td align="left">min_memory is defined</td></tr><tr><td align="left">变量不存在</td><td align="left">min_memory is not defined</td></tr><tr><td align="left">布尔变量是True。1、True或yes的求值为True</td><td align="left">memory_available</td></tr><tr><td align="left">布尔变量是False。0、False或no的求值为False</td><td align="left">not memory_available</td></tr><tr><td align="left">第一个变量的值存在，作为第二个变量的列表中的值</td><td align="left">ansible_distribution in supported_distros</td></tr></tbody></table> 
<h5><a id="122__480"></a>1.2.2 测试多个条件</h5> 
<p>一个<strong>when</strong>语句可用于评估多个条件。使用<strong>and</strong>和<strong>or</strong>关键字组合条件，并使用括号分组条件。</p> 
<p>如果任一条件为真时满足条件语句，则应当使用<strong>or</strong>语句。例如，如果计算机上运行的是红帽企业linux或Fedora，则下述条件得到满足：</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  vars:
    my_service: httpd
  tasks:
    - name: test
      yum:
        name: "{<!-- -->{ my_service }}"
        state: latest
      when: ansible_distribution == "Redhat" or ansible_distribution == "Fedora"
[root@ansible ansible]# ansible-playbook playbook/test.yml

PLAY [test] *****************************************************************************************
TASK [Gathering Facts] 

*****************************************************************************************ok: [192.168.10.201]

TASK [test] *****************************************************************************************skipping: [192.168.10.201]		##因为我用的不是Redhat or Fedora系统，所以跳过

PLAY RECAP *****************************************************************************************192.168.10.201             : ok=1    changed=0    unreachable=0    failed=0    skipped=1    rescued=0    ignored=0   

[root@ansible ansible]#
</code></pre> 
<p>使用<strong>and</strong>运算时，两个条件都必须为真，才能满足整个条件语句。例如，如果远程主机是红帽企业Linux7.5主机，并且安装的内核是指定版本，则将满足以下条件：</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  vars:
    my_service: httpd
  tasks:
    - name: test
      yum:
        name: "{<!-- -->{ my_service }}"
        state: latest
      when: ansible_distribution_version == "7.5" and ansible_kernel == "3.10.0-327.el7.x86_64"		
[root@ansible ansible]#
</code></pre> 
<p>也可以这样写：</p> 
<pre><code>when:
  - ansible_distribution_version == "7.5"
  - ansible_kernel == "3.10.0-327.el7.x86_64"
</code></pre> 
<p>这样的方式更加的可读</p> 
<h4><a id="13__543"></a>1.3 组合循环和有条件任务</h4> 
<p>​ 循环和条件可以组合使用。</p> 
<p>​ 在下例中，<strong>yum</strong>模块将安装<strong>mariadb-server</strong>软件包，只要/上挂载的文件系统具有超过300MB的可用空间。<strong>ansible_mounts</strong>事实是一组字典，各自代表一个已挂载文件系统的相关事实。循环迭代列表中每一字典，只有找到了代表两个条件都为真的已挂载文件系统的字典时，条件语句才得到满足。</p> 
<pre><code>[root@ansible ansible]# cat playbook/test.yml
---
- name: test
  hosts: all
  vars:
    my_service: httpd
  tasks:
    - name: test
      yum:
        name: mariadb-server
        state: latest
      loop: "{<!-- -->{ ansible_mounts }}"
      when: item.mount == "/" and item.size_available &gt; 300000000
[root@ansible ansible]#
</code></pre> 
<p>对某个任务结合使用<strong>when</strong>和<strong>loop</strong>时，将对每个项检查<strong>when</strong>语句。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5fe7ced212e43eb1519cd009221e1e5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机共享打印怎么设置密码,共享打印机需要密码的解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6b66629617d12c2780a76f9582dbf85b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">挑战SQL语句面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>