<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【IMX6ULL驱动开发学习】09.Linux之I2C驱动框架简介和驱动程序模板 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【IMX6ULL驱动开发学习】09.Linux之I2C驱动框架简介和驱动程序模板" />
<meta property="og:description" content="参考：Linux之I2C驱动_linux i2c驱动_风间琉璃•的博客-CSDN博客​​​​​​
目录
一、I2C驱动框架简介
1.1 I2C总线驱动
1.2 I2C设备驱动
二、I2C总线-设备-驱动模型
2.1 i2c_driver
2.2 i2c_client
2.3 I2C 设备数据收发和处理
三、Linux I2C驱动程序模板
一、I2C驱动框架简介 在 Linux 内核中 I2C 的体系结构分为 3 个部分：
I2C 核心： I2C 核心提供了 I2C 总线驱动和设备驱动的注册、 注销方法I2C 总线驱动： I2C 总线驱动是对 I2C 硬件体系结构中适配器端的实现， 适配器可由CPU 控制， 甚至可以直接集成在 CPU 内部。I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。I2C 设备驱动： I2C 设备驱动是对 I2C 硬件体系结构中设备端的实现， 设备一般挂接在受 CPU 控制的 I2C 适配器上， 通过 I2C 适配器与 CPU 交换数据。 1.1 I2C总线驱动 I2C 总线和 platform 总线类似， 区别在于platform 总线是虚拟的一条总线， 而 I2C 总线是实际" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3962d7867f8516f0be0494b0e2dfd3f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-25T20:16:25+08:00" />
<meta property="article:modified_time" content="2023-08-25T20:16:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【IMX6ULL驱动开发学习】09.Linux之I2C驱动框架简介和驱动程序模板</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 参考：<a href="https://blog.csdn.net/qq_53144843/article/details/127089880" title="Linux之I2C驱动_linux i2c驱动_风间琉璃•的博客-CSDN博客​​​​​​">Linux之I2C驱动_linux i2c驱动_风间琉璃•的博客-CSDN博客​​​​​​</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81I2C%20%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81I2C%20%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B" rel="nofollow">一、I2C驱动框架简介</a></p> 
<p id="1.1%20I2C%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8-toc" style="margin-left:80px;"><a href="#1.1%20I2C%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8" rel="nofollow">1.1 I2C总线驱动</a></p> 
<p id="1.2%C2%A0I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-toc" style="margin-left:80px;"><a href="#1.2%C2%A0I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8" rel="nofollow">1.2 I2C设备驱动</a></p> 
<p id="%E4%BA%8C%E3%80%81I2C%E6%80%BB%E7%BA%BF-%E8%AE%BE%E5%A4%87-%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81I2C%E6%80%BB%E7%BA%BF-%E8%AE%BE%E5%A4%87-%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B" rel="nofollow">二、I2C总线-设备-驱动模型</a></p> 
<p id="2.1%C2%A0i2c_driver-toc" style="margin-left:80px;"><a href="#2.1%C2%A0i2c_driver" rel="nofollow">2.1 i2c_driver</a></p> 
<p id="2.2%20i2c_client-toc" style="margin-left:80px;"><a href="#2.2%20i2c_client" rel="nofollow">2.2 i2c_client</a></p> 
<p id="2.3%C2%A0I2C%20%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86-toc" style="margin-left:80px;"><a href="#2.3%C2%A0I2C%20%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86" rel="nofollow">2.3 I2C 设备数据收发和处理</a></p> 
<p id="%E4%B8%89%E3%80%81Linux%20I2C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81Linux%20I2C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF" rel="nofollow">三、Linux I2C驱动程序模板</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81I2C%20%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">一、I2C驱动框架简介</h3> 
<p>在 Linux 内核中 I2C 的体系结构分为 3 个部分：</p> 
<ul><li><span style="color:#fe2c24;"><strong>I2C 核心</strong></span>： I2C 核心提供了<strong> <span style="color:#fe2c24;">I2C 总线驱动和设备驱动的注册、 注销方法</span></strong></li><li><span style="color:#fe2c24;"><strong>I2C 总线驱动</strong></span>： I2C 总线驱动是对<strong> I2C 硬件体系结构中适配器端的实现</strong>， 适配器可由CPU 控制， 甚至可以直接集成在 CPU 内部。I2C 总线驱动就是 SOC 的<strong> I2C 控制器驱动</strong>，也叫做 <strong>I2C 适配器驱动</strong>。</li><li><span style="color:#fe2c24;"><strong>I2C 设备驱动</strong></span>： I2C 设备驱动是对 <strong>I2C 硬件体系结构中设备端的实现</strong>，<span style="color:#fe2c24;"> <strong>设备一般挂接在受 CPU 控制的 I2C 适配器上， 通过 I2C 适配器与 CPU 交换数据</strong></span>。</li></ul> 
<h4 id="1.1%20I2C%E6%80%BB%E7%BA%BF%E9%A9%B1%E5%8A%A8">1.1 I2C总线驱动</h4> 
<p>I2C 总线和 platform 总线类似， 区别在于platform 总线是虚拟的一条总线， 而<span style="color:#fe2c24;"> I2C 总线是实际<br> 存在的</span>。 对于使用 I2C 通信的设备， <span style="color:#ff9900;"><strong>在驱动中直接使用 I2C 总结即可</strong></span>。 I2C 总线驱动的重点是 I2C 适配器驱动， 主要涉及到两个结构体： i2c_adapter 和 i2c_algorithm。 在 Linux 内核中用 i2c_adapter 结构体来表示 I2C 适配器。 i2c_adapter 结构体定义在 include/linux/i2c.h 文件中</p> 
<pre><code class="language-objectivec">struct i2c_adapter {
    struct module *owner;
    unsigned int class; /* classes to allow probing for */
    const struct i2c_algorithm *algo; /* 总线访问算法 */
    void *algo_data;
 
    /* data fields that are valid for all devices */
    struct rt_mutex bus_lock;
 
    int timeout; /* in jiffies */
    int retries;
    struct device dev; /* the adapter device */
 
    int nr;
    char name[48];
    struct completion dev_released;
 
    struct mutex userspace_clients_lock;
    struct list_head userspace_clients;
 
    struct i2c_bus_recovery_info *bus_recovery_info;
    const struct i2c_adapter_quirks *quirks;
};</code></pre> 
<p>i2c_algorithm 类型的指针变量algo， 对于一个 I2C 适配器， 要对外提供读写 API 函数， 设备驱动程序可以使用这些 API 函数来完成读写操作。<span style="color:#fe2c24;"><strong> i2c_algorithm 是 I2C 适配器与 IIC 设备进行通信的方法</strong>。</span>i2c_algorithm 结构体定义在 include/linux/i2c.h 文件中</p> 
<pre><code class="language-objectivec"> 
struct i2c_algorithm 
{
    ......
    int (*master_xfer)(struct i2c_adapter *adap,struct i2c_msg *msgs,int num);
    int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,
    unsigned short flags, char read_write,
    u8 command, int size, union i2c_smbus_data *data);
 
    /* To determine what the adapter supports */
    u32 (*functionality) (struct i2c_adapter *);
    ......
};</code></pre> 
<p>一般 SOC 的 I2C 总线驱动都是由半导体厂商编写的，所以大多数只要专注于 I2C 设备驱动即可。</p> 
<h4 id="1.2%C2%A0I2C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8">1.2 I2C设备驱动</h4> 
<p>在 I2C 设备驱动中主要有两个重要的结构体：<span style="color:#fe2c24;"><strong> i2c_client 和 i2c_driver。 i2c_client 是描述设备信息的，i2c_driver 描述驱动内容</strong></span>。</p> 
<p>当驱动和设备匹配成功后，每检测到一个 I2C 设备就会给这个 I2C 设备分配一个<strong>i2c_client</strong>，这个ic_client存储着这个设备的所有信息，如芯片地址。i2c_client 结构体定义在include/linux/i2c.h 文件中</p> 
<pre><code class="language-objectivec">struct i2c_client {
    unsigned short flags; /* 标志 */
    unsigned short addr; /* 芯片地址， 7 位，存在低 7 位*/
    ......
    char name[I2C_NAME_SIZE]; /* 名字 */
    struct i2c_adapter *adapter; /* 对应的 I2C 适配器 */
    struct device dev; /* 设备结构体 */
    int irq; /* 中断 */
    struct list_head detected;
    ......
};</code></pre> 
<p>i2c_driver 类似 platform_driver，是编写 I2C 设备驱动重点要处理的内容， i2c_driver 结构体定义在 include/linux/i2c.h 文件中</p> 
<pre><code class="language-objectivec">struct i2c_driver {
    unsigned int class;
 
    /* Notifies the driver that a new bus has appeared. You should
    * avoid using this, it will be removed in a near future.
    */
    int (*attach_adapter)(struct i2c_adapter *) __deprecated;
 
    /* Standard driver model interfaces */
    int (*probe)(struct i2c_client *, const struct i2c_device_id *);
    int (*remove)(struct i2c_client *);
 
    /* driver model interfaces that don't relate to enumeration */
    void (*shutdown)(struct i2c_client *);
 
    /* Alert callback, for example for the SMBus alert protocol.
    * The format and meaning of the data value depends on the
    * protocol.For the SMBus alert protocol, there is a single bit
    * of data passed as the alert response's low bit ("eventflag"). */
    void (*alert)(struct i2c_client *, unsigned int data);
    /* a ioctl like command that can be used to perform specific
    * functions with the device.
    */
    int (*command)(struct i2c_client *client, unsigned int cmd,void *arg);
 
    struct device_driver driver;
    const struct i2c_device_id *id_table;
 
    /* Device detection callback for automatic device creation */
    int (*detect)(struct i2c_client *, struct i2c_board_info *);
    const unsigned short *address_list;
    struct list_head clients;
};</code></pre> 
<p>当 I2C 设备和驱动匹配成功以后 probe 函数就会执行。device_driver 驱动结构体，<span style="color:#fe2c24;"><strong>如果使用设备树，需要设置 device_driver 的of_match_table 成员变量，即驱动的兼容(compatible)性。 未使用设备树的设备需要设置id_table 设备匹配 ID 表</strong></span>。</p> 
<p>构造i2c_driver结构体，里面会表明支持那些设备，入口函数里注册i2c_driver结构体，如果i2c_driver发现能够支持的i2c_client的话，probe函数就被调用，在probe函数里记录client信息、注册字符设备、注册file_operations、自动创建设备节点</p> 
<p>I2C驱动程序与普通的字符设备驱动程序没有本质差别，唯一差别：发起数据传输时用到i2c_transfer，该函数需要用到适配器（i2c控制器），probe函数被调用时内核会传入i2c_client，i2c_client里含有i2c控制器。</p> 
<h3 id="%E4%BA%8C%E3%80%81I2C%E6%80%BB%E7%BA%BF-%E8%AE%BE%E5%A4%87-%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B">二、I2C总线-设备-驱动模型</h3> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9b/cd/kN4Nv2qw_o.png"></p> 
<h4 id="2.1%C2%A0i2c_driver">2.1 i2c_driver</h4> 
<p>2c_driver表明能支持哪些设备：</p> 
<ul><li> <p>使用of_match_table来判断</p> 
  <ul><li> <p>设备树中，某个I2C控制器节点下可以创建I2C设备的节点</p> 
    <ul><li> <p>如果I2C设备节点的compatible属性跟of_match_table的某项兼容，则匹配成功</p> </li></ul></li><li> <p>i2c_client.name跟某个of_match_table[i].compatible值相同，则匹配成功</p> </li></ul></li><li> <p>使用id_table来判断</p> 
  <ul><li> <p>i2c_client.name跟某个id_table[i].name值相同，则匹配成功</p> </li></ul></li></ul> 
<p>i2c_driver跟i2c_client匹配成功后，就调用i2c_driver.probe函数。</p> 
<pre><code class="language-objectivec">/* 传统匹配方式 ID 列表 */
static const struct i2c_device_id xxx_id[] = {
    {"xxx", 0},
    {}
};
 
 /* 设备树匹配列表 */
static const struct of_device_id xxx_of_match[] = {
    { .compatible = "xxx" },
    { /* Sentinel */ }
};

/* i2c 驱动结构体 */
static struct i2c_driver xxx_driver = {
    .probe = xxx_probe,
    .remove = xxx_remove,
    .driver = {
        .owner = THIS_MODULE,
        .name = "xxx",
        .of_match_table = xxx_of_match,  //使用设备树
    },
    .id_table = xxx_id,   //未使用设备树
};</code></pre> 
<h4 id="2.2%20i2c_client">2.2 i2c_client</h4> 
<p>i2c_client表示一个I2C设备，创建i2c_client的方法有4种：</p> 
<p><strong>（1）方法1：通过设备树来创建（常用）</strong></p> 
<pre><code class="language-objectivec">i2c1: i2c@400a0000 {
		/* ... master properties skipped ... */
		clock-frequency = &lt;100000&gt;;

		flash@50 {
			compatible = "atmel,24c256";
			reg = &lt;0x50&gt;;
		};

		pca9532: gpio@60 {
			compatible = "nxp,pca9532";
			gpio-controller;
			#gpio-cells = &lt;2&gt;;
			reg = &lt;0x60&gt;;
		};
	};</code></pre> 
<p>向 i2c1 添加 flash 子节点，<span style="color:#ff9900;"><strong>flash@50是子节点名字， @后面的50是I2C 器件地址</strong></span>。compatible 属性值为atmel,24c256。reg属性也是设置I2C的器件地址的。I2C 设备节点的创建主要是 compatible 属性和 reg属性的设置，<span style="color:#9c8ec1;"><strong> </strong></span><span style="color:#ff9900;"><strong>一个用于匹配驱动， 一个用于设置器件地址</strong></span>。</p> 
<p><strong>（2）方法2：</strong></p> 
<p>有时候无法知道该设备挂载哪个I2C bus下，无法知道它对应的I2C bus number。 但是可以通过其他方法知道对应的i2c_adapter结构体。 可以使用下面两个函数来创建i2c_client：</p> 
<p>i2c_new_device</p> 
<pre><code class="language-objectivec"> static struct i2c_board_info sfe4001_hwmon_info = {
	I2C_BOARD_INFO("max6647", 0x4e),
  };

  int sfe4001_init(struct efx_nic *efx)
  {
	(...)
	efx-&gt;board_info.hwmon_client =
		i2c_new_device(&amp;efx-&gt;i2c_adap, &amp;sfe4001_hwmon_info);

	(...)
  }</code></pre> 
<p>i2c_new_probed_device</p> 
<pre><code class="language-objectivec">static const unsigned short normal_i2c[] = { 0x2c, 0x2d, I2C_CLIENT_END };

  static int usb_hcd_nxp_probe(struct platform_device *pdev)
  {
	(...)
	struct i2c_adapter *i2c_adap;
	struct i2c_board_info i2c_info;

	(...)
	i2c_adap = i2c_get_adapter(2);
	memset(&amp;i2c_info, 0, sizeof(struct i2c_board_info));
	strscpy(i2c_info.type, "isp1301_nxp", sizeof(i2c_info.type));
	isp1301_i2c_client = i2c_new_probed_device(i2c_adap, &amp;i2c_info,
						   normal_i2c, NULL);
	i2c_put_adapter(i2c_adap);
	(...)
  }</code></pre> 
<p>差别：</p> 
<ul><li> <p>i2c_new_device：会创建i2c_client，即使该设备并不存在</p> </li><li> <p>i2c_new_probed_device：</p> 
  <ul><li> <p>它成功的话，会创建i2c_client，并且表示这个设备肯定存在</p> </li><li> <p>I2C设备的地址可能发生变化，比如AT24C02的引脚A2A1A0电平不一样时，设备地址就不一样</p> </li><li> <p>可以罗列出可能的地址</p> </li><li> <p>i2c_new_probed_device使用这些地址判断设备是否存在</p> </li></ul></li></ul> 
<p><strong>（3）方法3(不推荐)：</strong>由i2c_driver.detect函数来判断是否有对应的I2C设备并生成i2c_client  </p> 
<p><strong>（4）方法4：</strong>通过用户空间(user-space)生成 调试时、或者不方便通过代码明确地生成i2c_client时，可以通过用户空间来生成。</p> 
<pre><code class="language-objectivec">// 创建一个i2c_client, .name = "eeprom", .addr=0x50, .adapter是i2c-3
  # echo eeprom 0x50 &gt; /sys/bus/i2c/devices/i2c-3/new_device
  
// 删除一个i2c_client
  # echo 0x50 &gt; /sys/bus/i2c/devices/i2c-3/delete_device</code></pre> 
<h4 id="2.3%C2%A0I2C%20%E8%AE%BE%E5%A4%87%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E5%92%8C%E5%A4%84%E7%90%86">2.3 I2C 设备数据收发和处理</h4> 
<p>在 I2C 设备驱动中首先要完成 i2c_driver 结构体的创建、 初始化和注册， 当设备和驱动匹配成功后，就会执行 probe 函数， probe 函数中就是执行字符设备驱动的一套流程。</p> 
<p>一般需要在probe函数里面初始化 I2C 设备，要初始化 I2C 设备需要使用 i2c_transfer 函数对 I2C 设备寄存器进行读写操作。 i2c_transfer 函数会调用 I2C 适配器中 i2c_algorithm里面的 master_xfer 函数， 对于 I.MX6U 而言是 i2c_imx_xfer 这个函数。<br>  </p> 
<pre><code class="language-objectivec">int i2c_transfer(struct i2c_adapter *adap,struct i2c_msg *msgs,int num)</code></pre> 
<blockquote> 
 <p>adap： 所使用的 I2C 适配器，<span style="color:#fe2c24;"><strong> i2c_client 会保存其对应的 i2c_adapter</strong></span><br> msgs： I2C 要发送的一个或多个消息<br> num： 消息数量，msgs 的数量<br> 返回值： 负值，失败，其他非负值，发送的 msgs 数量</p> 
</blockquote> 
<p>msgs参数是一个 i2c_msg 类型的指针参数，Linux内核使用 i2c_msg 结构体 描述一个消息。</p> 
<pre><code class="language-objectivec">struct i2c_msg {
    __u16 addr; /* 从机地址 */
    __u16 flags; /* 标志 */
    #define I2C_M_TEN 0x0010
    #define I2C_M_RD 0x0001
    #define I2C_M_STOP 0x8000
    #define I2C_M_NOSTART 0x4000
    #define I2C_M_REV_DIR_ADDR 0x2000
    #define I2C_M_IGNORE_NAK 0x1000
    #define I2C_M_NO_RD_ACK 0x0800
    #define I2C_M_RECV_LEN 0x0400
    __u16 len; /* 消息(本 msg)长度 */
    __u8 *buf; /* 消息数据 */
};</code></pre> 
<p>使用i2c_transfer函数发送数据前，要构建好 i2c_msg，使用 i2c_transfer 进行 I2C 数据收发的模板：</p> 
<pre><code class="language-objectivec">/* 设备结构体 */
struct xxx_dev {
    ......
    void *private_data; /* 私有数据，一般会设置为 i2c_client */
};
 
/*
* @description : 读取 I2C 设备多个寄存器数据
* @param – dev : I2C 设备
* @param – reg : 要读取的寄存器首地址
* @param – val : 读取到的数据
* @param – len : 要读取的数据长度
* @return : 操作结果
*/
static int xxx_read_regs(struct xxx_dev *dev, u8 reg, void *val,
int len)
{
    int ret;
    struct i2c_msg msg[2];
    struct i2c_client *client = (struct i2c_client *)
    dev-&gt;private_data;
 
    /* msg[0]，第一条写消息，发送要读取的寄存器首地址 */
    msg[0].addr = client-&gt;addr; /* I2C 器件地址 */
    msg[0].flags = 0; /* 标记为发送数据 */
    msg[0].buf = &amp;reg; /* 读取的首地址 */
    msg[0].len = 1; /* reg 长度 */
 
    /* msg[1]，第二条读消息，读取寄存器数据 */
    msg[1].addr = client-&gt;addr; /* I2C 器件地址 */
    msg[1].flags = I2C_M_RD; /* 标记为读取数据 */
    msg[1].buf = val; /* 读取数据缓冲区 */
    msg[1].len = len; /* 要读取的数据长度 */
    ret = i2c_transfer(client-&gt;adapter, msg, 2);
    if(ret == 2) 
    {
        ret = 0;
    } 
    else 
    {
        ret = -EREMOTEIO;
    }
    return ret;
}
 
/*
* @description : 向 I2C 设备多个寄存器写入数据
* @param – dev : 要写入的设备结构体
* @param – reg : 要写入的寄存器首地址
* @param – buf : 要写入的数据缓冲区
* @param – len : 要写入的数据长度
* @return : 操作结果
*/
static s32 xxx_write_regs(struct xxx_dev *dev, u8 reg, u8 *buf,u8 len)
{
    u8 b[256];
    struct i2c_msg msg;
    struct i2c_client *client = (struct i2c_client *)
    dev-&gt;private_data;
 
    b[0] = reg; /* 寄存器首地址 */
    memcpy(&amp;b[1],buf,len); /* 将要发送的数据拷贝到数组 b 里面 */
 
    msg.addr = client-&gt;addr; /* I2C 器件地址 */
    msg.flags = 0; /* 标记为写数据 */
 
    msg.buf = b; /* 要发送的数据缓冲区 */
    msg.len = len + 1; /* 要发送的数据长度 */
 
    return i2c_transfer(client-&gt;adapter, &amp;msg, 1);
}</code></pre> 
<p>在设备结构体里面添加一个执行void的指针成员变量<strong>private_data</strong>，此成员变量用于保存设备的私有数据，<strong><span style="color:#fe2c24;">在 I2C 设备驱动中一般将其指向 I2C 设备对应的i2c_client</span></strong>。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/f9/KVA6eKuW_o.png"></p> 
<p></p> 
<p>xxx_read_regs 函数用于读取 I2C 设备多个寄存器数据，然后定义了一个i2c_msg 数组， 2 个数组元素。如图，I2C写时序图，因为 I2C 读取数据的时候要先发送要读取的寄存器地址，然后再读取数据，所以需要准备两个 i2c_msg。一个用于发送寄存器地址，一个用于读取寄存器值。</p> 
<p>对于 msg[0]， 将<span style="color:#0d0016;"> <span style="background-color:#ff9900;">flags设置为 0， 表示写数据</span></span>。 msg[0]的 addr 是 I2C 设备的器件地址， msg[0]的 buf 成员变量就是要读取的寄存器地址。 对于 msg[1]， <span style="background-color:#a2e043;">将 flags 设置为 I2C_M_RD， 表示读取数据</span>。 msg[1]的 buf 成员变量用于保存读取到的数据， len 成员变量就是要读取的数据长度。 调用 i2c_transfer 函数完成 I2C 数据读操作。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bd/e7/c1Ij7EBM_o.png"><br>  </p> 
<p></p> 
<p>xxx_write_regs 函数用于向 I2C 设备多个寄存器写数据。 数组 b 用于存放寄存器首地址和要发送的数据，msg 的 addr设置为 I2C 器件地址。然后设置 msg 的 flags 为 0， 也就是写数据。设置要发送的数据， 也就是数组 b。设置 msg 的 len 为 len+1， 因为要加上一个字节的寄存器地址。 最后通过 i2c_transfer 函数完成向 I2C 设备的写操作。</p> 
<p>另外还有两个API函数分别用于I2C数据的收发操作，这两个函数都会调用i2c_transfer。</p> 
<p><span style="color:#fe2c24;">I2C 数据发送函数 i2c_master_send：</span></p> 
<pre><code class="language-objectivec">int i2c_master_send(const struct i2c_client *client,const char *buf,int count)</code></pre> 
<blockquote> 
 <p>client： I2C 设备对应的 i2c_client<br> buf：要发送的数据<br> count： 要发送的数据字节数，要小于 64KB，以为 i2c_msg 的 len 成员变量是一个 u16(无<br> 符号 16 位)类型的数据。<br> 返回值： 负值，失败，其他非负值，发送的字节数</p> 
</blockquote> 
<p><span style="color:#fe2c24;">I2C 数据接收函数为 i2c_master_recv：</span></p> 
<pre><code class="language-objectivec">int i2c_master_recv(const struct i2c_client *client,char *buf,int count)</code></pre> 
<blockquote> 
 <p>client： I2C 设备对应的 i2c_client<br> buf：要接收的数据</p> 
 <p>count： 要接收的数据字节数，要小于 64KB，以为 i2c_msg 的 len 成员变量是一个 u16(无<br> 符号 16 位)类型的数据<br> 返回值： 负值，失败，其他非负值，发送的字节数</p> 
</blockquote> 
<h3 id="%E4%B8%89%E3%80%81Linux%20I2C%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF">三、Linux I2C驱动程序模板</h3> 
<p>i2c_drv.c</p> 
<pre><code class="language-objectivec">#include "linux/i2c.h"
#include &lt;linux/module.h&gt;
#include &lt;linux/poll.h&gt;

#include &lt;linux/fs.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/miscdevice.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/major.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;
#include &lt;linux/stat.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/tty.h&gt;
#include &lt;linux/kmod.h&gt;
#include &lt;linux/gfp.h&gt;
#include &lt;linux/gpio/consumer.h&gt;
#include &lt;linux/platform_device.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;linux/of_irq.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/fcntl.h&gt;
#include &lt;linux/timer.h&gt;

/* 主设备号                                                                 */
static int major = 0;
static struct class *my_i2c_class;

struct i2c_client *g_client;

static DECLARE_WAIT_QUEUE_HEAD(gpio_wait);
struct fasync_struct *i2c_fasync;


/* 实现对应的open/read/write等函数，填入file_operations结构体                   */
static ssize_t i2c_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)
{
	int err;

	struct i2c_msg msgs[2];

	/* 初始化i2c_msg */

	err = i2c_transfer(g_client-&gt;adapter, msgs, 2);

	/* copy_to_user  */
	
	return 0;
}

static ssize_t i2c_drv_write(struct file *file, const char __user *buf, size_t size, loff_t *offset)
{
	int err;

	/* copy_from_user  */


	struct i2c_msg msgs[2];

	/* 初始化i2c_msg */

	err = i2c_transfer(g_client-&gt;adapter, msgs, 2);

	
	return 0;    
}


static unsigned int i2c_drv_poll(struct file *fp, poll_table * wait)
{
	//printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
	poll_wait(fp, &amp;gpio_wait, wait);
	//return is_key_buf_empty() ? 0 : POLLIN | POLLRDNORM;
	return 0;
}

static int i2c_drv_fasync(int fd, struct file *file, int on)
{
	if (fasync_helper(fd, file, on, &amp;i2c_fasync) &gt;= 0)
		return 0;
	else
		return -EIO;
}


/* 定义自己的file_operations结构体                                              */
static struct file_operations i2c_drv_fops = {
	.owner	 = THIS_MODULE,
	.read    = i2c_drv_read,
	.write   = i2c_drv_write,
	.poll    = i2c_drv_poll,
	.fasync  = i2c_drv_fasync,
};


static int i2c_drv_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	// struct device_node *np = client-&gt;dev.of_node;   从client获取设备节点
	// struct i2c_adapter *adapter = client-&gt;adapter;  从client获取控制器

	/* 记录client */
	g_client = client;

	/* 注册字符设备 */
	/* 注册file_operations 	*/
	major = register_chrdev(0, "100ask_i2c", &amp;i2c_drv_fops);  /* /dev/gpio_desc */

	my_i2c_class = class_create(THIS_MODULE, "100ask_i2c_class");
	if (IS_ERR(my_i2c_class)) {
		printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
		unregister_chrdev(major, "100ask_i2c");
		return PTR_ERR(my_i2c_class);
	}

	device_create(my_i2c_class, NULL, MKDEV(major, 0), NULL, "myi2c"); /* /dev/myi2c */
	
	return 0;
}

static int i2c_drv_remove(struct i2c_client *client)
{
	/* 反注册字符设备 */
	device_destroy(my_i2c_class, MKDEV(major, 0));
	class_destroy(my_i2c_class);
	unregister_chrdev(major, "100ask_i2c");

	return 0;
}

static const struct of_device_id myi2c_dt_match[] = {
	{ .compatible = "100ask,i2cdev" },
	{},
};
static struct i2c_driver my_i2c_driver = {
	.driver = {
		   .name = "100ask_i2c_drv",
		   .owner = THIS_MODULE,
		   .of_match_table = myi2c_dt_match,
	},
	.probe = i2c_drv_probe,
	.remove = i2c_drv_remove,
};


static int __init i2c_drv_init(void)
{
	/* 注册i2c_driver */
	return i2c_add_driver(&amp;my_i2c_driver);
}

static void __exit i2c_drv_exit(void)
{
	/* 反注册i2c_driver */
	i2c_del_driver(&amp;my_i2c_driver);
}

/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */

module_init(i2c_drv_init);
module_exit(i2c_drv_exit);

MODULE_LICENSE("GPL");


</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9d0d9d3f7a9300d0859ab6233baa2abf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【原创】PyCharm启动Debug报错无法运行，提示No such file or directory</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9e99e0fc29797c817ceaac989482825b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【IMX6ULL驱动开发学习】11.Linux之SPI驱动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>