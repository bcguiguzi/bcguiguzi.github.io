<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Targan 算法[有向图强连通分量] - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Targan 算法[有向图强连通分量]" />
<meta property="og:description" content="[有向图强连通分量]
在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点强连通(stronglyconnected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。非强连通图有向图的极大强连通子图，称为强连通分量(strongly connected components)。
下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。
直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2&#43;M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N&#43;M)。本文介绍的是Tarjan算法。
[Tarjan算法]
Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。
定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，
Low(u)=Min{DFN(u),Low(v),(u,v)为树枝边，u为v的父节点
DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)}
当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。
算法伪代码如下
tarjan(u)
{
DFN[u]=Low[u]=&#43;&#43;Index // 为节点u设定次序编号和Low初值
Stack.push(u) // 将节点u压入栈中
for each (u, v) in E // 枚举每一条边
if (v is not visted) // 如果节点v未被访问过
tarjan(v) // 继续向下找
Low[u] = min(Low[u], Low[v])
else if (v in S) // 如果节点u还在栈内
Low[u] = min(Low[u], DFN[v])
if (DFN[u] == Low[u]) // 如果节点u是强连通分量的根
repeat
v = S.pop // 将v退栈，为该强连通分量中一个顶点
print v
until (u== v)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3699251bc04a22d24735e5b59f2c6fba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-05-10T14:21:37+08:00" />
<meta property="article:modified_time" content="2015-05-10T14:21:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Targan 算法[有向图强连通分量]</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> <strong>[有向图强连通分量]</strong></p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>(stronglyconnected)。如果有向图G的每两个顶点都强连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong>(strongly connected components)。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 下图中，子图{1,2,3,4}为一个强连通分量，因为顶点1,2,3,4两两可达。{5},{6}也分别是两个强连通分量。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> <img src="https://images2.imgbox.com/b5/d9/9jaxeU5u_o.gif" alt="" style="border:none; max-width:100%"><br> </p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 直接根据定义，用双向遍历取交集的方法求强连通分量，时间复杂度为O(N^2+M)。更好的方法是Kosaraju算法或Tarjan算法，两者的时间复杂度都是O(N+M)。本文介绍的是Tarjan算法。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> <strong>[Tarjan算法]</strong></p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> Tarjan算法是基于对图深度优先搜索的算法，<u>每个强连通分量为搜索树中的一棵子树</u>。搜索时，把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 定义DFN(u)为节点u搜索的次序编号(时间戳)，Low(u)为u或u的子树能够追溯到的最早的栈中节点的次序号。由定义可以得出，</p> 
<table width="100%" border="0" cellpadding="0" style="font-family:Arial; font-size:14px; line-height:26px; color:rgb(255,0,0)"><tbody><tr><td> <p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> Low(u)=Min{DFN(u),Low(v),(u,v)为树枝边，u为v的父节点<br>            DFN(v),(u,v)为指向栈中节点的后向边(非横叉边)}</p> </td></tr></tbody></table> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> <u>当DFN(u)=Low(u)时，以u为根的搜索子树上所有节点是一个强连通分量。</u></p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 算法伪代码如下</p> 
<table width="104%" border="0" cellpadding="0" style="color:rgb(0,0,0); font-family:Arial; font-size:14px; line-height:26px"><tbody><tr><td> <p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px"> tarjan(u)<br> {<!-- --><br>  DFN[u]=Low[u]=++Index        // 为节点u设定次序编号和Low初值<br>  Stack.push(u)                // 将节点u压入栈中<br>  for each (u, v) in E         // 枚举每一条边<br>   if (v is not visted)        // 如果节点v未被访问过<br>    tarjan(v)                  // 继续向下找<br>    Low[u] = min(Low[u], Low[v])<br>   else if (v in S)            // 如果节点u还在栈内<br>    Low[u] = min(Low[u], DFN[v])<br>  if (DFN[u] == Low[u])        // 如果节点u是强连通分量的根<br>   repeat<br>    v = S.pop                 // 将v退栈，为该强连通分量中一个顶点<br>    print v<br>   until (u== v)<br> }</p> </td></tr></tbody></table> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 接下来是对算法流程的演示。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 从节点1开始DFS，把遍历到的节点加入栈中。搜索到节点u=6时，DFN[6]=LOW[6]，找到了一个强连通分量。退栈到u=v为止，{6}为一个强连通分量。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> <img src="https://images2.imgbox.com/39/e7/jCibAnPu_o.gif" alt="" style="border:none; max-width:100%"><br> </p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 返回节点5，发现DFN[5]=LOW[5]，退栈后{5}为一个强连通分量。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> <img src="https://images2.imgbox.com/00/be/HoOFhW4T_o.gif" alt="" style="border:none; max-width:100%"><br> </p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 返回节点3，继续搜索到节点4，把4加入堆栈。发现节点4像节点1的后向边，节点1还在栈中，所以LOW[4]=1。节点6已经出栈，不再访问6，返回3，(3,4)为树枝边，所以LOW[3]=LOW[4]=1。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> <img src="https://images2.imgbox.com/f0/0d/z9e3GqHj_o.gif" alt="" style="border:none; max-width:100%"><br> </p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 继续回到节点1，最后访问节点2。访问边(2,4)，4还在栈中，所以LOW[2]=4。返回1后，发现DFN[1]=LOW[1]，把栈中节点全部取出，组成一个连通分量{1,3,4,2}。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> <img src="https://images2.imgbox.com/c8/18/CEf01vuO_o.gif" alt="" style="border:none; max-width:100%"><br> </p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 至此，算法结束。经过该算法，求出了图中全部的三个强连通分量{1,3,4,2},{5},{6}。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 可以发现，运行Tarjan算法的过程中，每个顶点都被访问了一次，且只进出了一次堆栈，每条边也只被访问了一次，所以该算法的时间复杂度为O(N+M)。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 求有向图的强连通分量还有一个强有力的算法，为Kosaraju算法。Kosaraju是基于对有向图及其逆图两次DFS的方法，其时间复杂度也是 O(N+M)。与Trajan算法相比，Kosaraju算法可能会稍微更直观一些。但是Tarjan只用对原图进行一次DFS，不用建立逆图，更简洁。 在实际的测试中，Tarjan算法的运行效率也比Kosaraju算法高30%左右。此外，该Tarjan算法与<a target="_blank" href="http://www.byvoid.com/blog/biconnect/" rel="nofollow noopener noreferrer" style="color:rgb(202,0,0); text-decoration:none">求无向图的双连通分量(割点、桥)的Tarjan算法</a>也有着很深的联系。学习该Tarjan算法，也有助于深入理解求双连通分量的Tarjan算法，两者可以类比、组合理解。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> 求有向图的强连通分量的Tarjan算法是以其发明者<a target="_blank" href="http://en.wikipedia.org/wiki/Robert_Tarjan" rel="nofollow noopener noreferrer" style="color:rgb(202,0,0); text-decoration:none">Robert Tarjan</a>命名的。Robert Tarjan还发明了求<a target="_blank" href="http://www.byvoid.com/blog/biconnect/" rel="nofollow noopener noreferrer" style="color:rgb(202,0,0); text-decoration:none">双连通分量</a>的Tarjan算法，以及求最近公共祖先的离线Tarjan算法，在此对Tarjan表示崇高的敬意。</p> 
<p align="left" style="margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px"> void tarjan(int i)<br> {<!-- --><br>  int j;<br>  DFN[i]=LOW[i]=++Dindex;<br>  instack[i]=true;<br>  Stap[++Stop]=i;<br>  for (edge *e=V[i];e;e=e-&gt;next)<br>  {<!-- --><br>   j=e-&gt;t;<br>   if (!DFN[j])<br>   {<!-- --><br>    tarjan(j);<br>    if (LOW[j]&lt;LOW[i])<br>     LOW[i]=LOW[j];<br>   }<br>   else if (instack[j] &amp;&amp; DFN[j]&lt;LOW[i])<br>    LOW[i]=DFN[j];<br>  }<br>  if (DFN[i]==LOW[i])<br>  {<!-- --><br>   Bcnt++;<br>   do<br>   {<!-- --><br>    j=Stap[Stop--];<br>    instack[j]=false;<br>    Belong[j]=Bcnt;<br>   }<br>   while (j!=i);<br>  }<br> }<br> void solve()<br> {<!-- --><br>  int i;<br>  Stop=Bcnt=Dindex=0;<br>  memset(DFN,0,sizeof(DFN));<br>  for (i=1;i&lt;=N;i++)<br>   if (!DFN[i])<br>    tarjan(i);<br> }</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0af12d9592f355fc1c8193bd6174926e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android开发秘籍学习笔记（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9af58203b43095c79ab25c8bd14789d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在VS2012中配置pthread_win32(包含x86和x64两种平台)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>