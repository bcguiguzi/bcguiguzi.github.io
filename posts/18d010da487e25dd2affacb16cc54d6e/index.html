<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>BasicAuth认证(gin框架提供)与Go - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="BasicAuth认证(gin框架提供)与Go" />
<meta property="og:description" content="BasicAuth认证与Go Basic Auth是一种开放平台认证方式，简单的说就是需要你输入用户名和密码才能继续访问。Bath Auth是其中一种认证方式，另一种是OAuth。
Basic Auth认证处理简单几乎没有什么优点了，最大的缺点就是安全性低。不用说，OAuth认证方式克服了Basic Auth认证的所有缺点，并且也是目前广泛应用的。
gin框架提供了Bath Auth认证中间件，我们来看看该怎么玩。
首先是服务端代码：
package main import &#34;gopkg.in/gin-gonic/gin.v1&#34; var secrets = gin.H{ &#34;foo&#34;: gin.H{&#34;email&#34;: &#34;foo@bar.com&#34;, &#34;phone&#34;: &#34;123433&#34;}, &#34;austin&#34;: gin.H{&#34;email&#34;: &#34;austin@example.com&#34;, &#34;phone&#34;: &#34;666&#34;}, &#34;lena&#34;: gin.H{&#34;email&#34;: &#34;lena@guapa.com&#34;, &#34;phone&#34;: &#34;523433&#34;}, } func getSecrets(c *gin.Context) { user := c.MustGet(gin.AuthUserKey).(string) if secret, ok := secrets[user]; ok { c.JSON(200, gin.H{&#34;user&#34;: user, &#34;secret&#34;: secret}) } else { c.JSON(200, gin.H{&#34;user&#34;: user, &#34;secret&#34;: &#34;No SECRET :(&#34;}) } } func main() { r := gin." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/18d010da487e25dd2affacb16cc54d6e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-11T16:52:43+08:00" />
<meta property="article:modified_time" content="2018-07-11T16:52:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">BasicAuth认证(gin框架提供)与Go</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="basicauth认证与go">BasicAuth认证与Go</h2> 
<p>Basic Auth是一种开放平台认证方式，简单的说就是需要你输入用户名和密码才能继续访问。Bath Auth是其中一种认证方式，另一种是OAuth。</p> 
<p>Basic Auth认证处理简单几乎没有什么优点了，最大的缺点就是安全性低。不用说，OAuth认证方式克服了Basic Auth认证的所有缺点，并且也是目前广泛应用的。</p> 
<p>gin框架提供了Bath Auth认证中间件，我们来看看该怎么玩。</p> 
<p>首先是服务端代码：</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"gopkg.in/gin-gonic/gin.v1"</span>

<span class="hljs-keyword">var</span> secrets = gin.H{
    <span class="hljs-string">"foo"</span>:    gin.H{<!-- --><span class="hljs-string">"email"</span>: <span class="hljs-string">"foo@bar.com"</span>, <span class="hljs-string">"phone"</span>: <span class="hljs-string">"123433"</span>},
    <span class="hljs-string">"austin"</span>: gin.H{<!-- --><span class="hljs-string">"email"</span>: <span class="hljs-string">"austin@example.com"</span>, <span class="hljs-string">"phone"</span>: <span class="hljs-string">"666"</span>},
    <span class="hljs-string">"lena"</span>:   gin.H{<!-- --><span class="hljs-string">"email"</span>: <span class="hljs-string">"lena@guapa.com"</span>, <span class="hljs-string">"phone"</span>: <span class="hljs-string">"523433"</span>},
}

<span class="hljs-keyword">func</span> getSecrets(c *gin.Context) {
    user := c.MustGet(gin.AuthUserKey).(<span class="hljs-typename">string</span>)
    <span class="hljs-keyword">if</span> secret, ok := secrets[user]; ok {
        c.JSON<span class="hljs-number">(200</span>, gin.H{<!-- --><span class="hljs-string">"user"</span>: user, <span class="hljs-string">"secret"</span>: secret})
    } <span class="hljs-keyword">else</span> {
        c.JSON<span class="hljs-number">(200</span>, gin.H{<!-- --><span class="hljs-string">"user"</span>: user, <span class="hljs-string">"secret"</span>: <span class="hljs-string">"No SECRET :("</span>})
    }
}

<span class="hljs-keyword">func</span> main() {
    r := gin.Default()
    authorized := r.Group(<span class="hljs-string">"/admin"</span>, gin.BasicAuth(gin.Accounts{
        <span class="hljs-string">"foo"</span>:    <span class="hljs-string">"bar"</span>, <span class="hljs-comment">//用户名：密码</span>
        <span class="hljs-string">"austin"</span>: <span class="hljs-string">"1234"</span>,
        <span class="hljs-string">"lena"</span>:   <span class="hljs-string">"hello2"</span>,
        <span class="hljs-string">"manu"</span>:   <span class="hljs-string">"4321"</span>,
    }))
    authorized.GET(<span class="hljs-string">"/secrets"</span>, getSecrets)
    r.Run(<span class="hljs-string">":8080"</span>)
}</code></pre> 
<p>让我们从<code>main</code>函数开始。<code>Group</code>函数注册了一个群组路由，<code>gin.BasicAuth</code>就是中间件，它的参数<code>gin.Accounts</code>其实是一个<code>map[string]string</code>类型的映射，这里是用来记录用户名和密码。</p> 
<p>然后在路由<code>/admin</code>之下，又注册了<code>/secrets</code>路由，所以他的完整路由应该是<code>/admin/secrets</code>。处理器是<code>getSecrets</code>函数。</p> 
<p>在<code>getSecrets</code>函数中，首先从上下文<code>gin.Context</code>中获取用户名。<code>gin.AuthUserKey</code>是一个字符串常量，定义如下：</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">const</span> AuthUserKey = <span class="hljs-string">"user"</span></code></pre> 
<p>这里获取的用户名就是你访问这个URL时输入的用户名，后台会验证密码，如果用户名和密码都对上了，认证才会成功。</p> 
<p>接下来会利用获得的用户名去<code>secrets</code>结构中查找用户信息。<code>gin.H</code>是一个<code>map[string]interface{}</code>的映射。最后通过JSON返回查询结果。</p> 
<p>现在万事具备，让我们用在浏览器中输入localhost:8080/admin/secrets进行访问，不出意外你会看到一个提示框，要你输入用户名和密码。用户名输入<code>foo</code>，密码输入<code>bar</code>。然后你就能看到一个关于<code>foo</code>的信息的JSON串了。</p> 
<p>下面让我们用curl试试。打开PowerShell，输入<code>curl localhost:8080/admin/secrets</code>，然后帅气的回车。</p> 
<p>。。。</p> 
<p>为什么什么也没有？</p> 
<p>再次输入<code>curl -I localhost:8080/admin/secrets</code>回车，查看响应头，得到的居然是一个401的响应。这是很正常的，应为你并没有提供任何有关用户名和密码的信息，所以认证必然是失败的，认证失败就会得到401的响应。</p> 
<p>我们可以看看<code>BasicAuth</code>函数的源代码：</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">func</span> BasicAuth(accounts Accounts) HandlerFunc {
    <span class="hljs-keyword">return</span> BasicAuthForRealm(accounts, <span class="hljs-string">""</span>)
}</code></pre> 
<p>继续追查<code>BasicAuthForRealm</code>函数：</p> 
<pre class="prettyprint"><code class="language-go hljs "><span class="hljs-keyword">func</span> BasicAuthForRealm(accounts Accounts, realm <span class="hljs-typename">string</span>) HandlerFunc {
    pairs := processAccounts(accounts)

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">func</span>(c *Context) {
        user, found := pairs.searchCredential(c.Request.Header.Get(<span class="hljs-string">"Authorization"</span>))
        <span class="hljs-keyword">if</span> !found {
            c.AbortWithStatus<span class="hljs-number">(401</span>)
        } <span class="hljs-keyword">else</span> {
            c.Set(AuthUserKey, user)
        }
    }
}</code></pre> 
<p>让我们省略一些无关紧要的细节。这里的<code>accounts</code>就是我们调用<code>BasicAuth</code>函数时带入的用户名-密码映射，这里需要用来进行身份验证。最后返回了一个匿名函数，这个匿名函数就是中间件。</p> 
<p>在匿名函数中首先会去请求头中去查找<code>Authorization</code>请求首部，如果找到了，就调用<code>Set</code>函数把这个请求首部中的用户名设置到上下文，也就是<code>gin.Context</code>中。无独有偶，这里我们又看到了<code>AuthUserKey</code>，现在你知道为什么在<code>getSecrets</code>函数中我们要用它去获取用户名了吧。需要注意的是<code>searchCredential</code>函数除了获取用户名还会进行密码验证。</p> 
<p>如果请求头中没有<code>Authorization</code>请求首部，那么恭喜，你将毫无悬念的得到401响应。</p> 
<p>所以，当我们使用curl访问时，需要设置一下请求头。但是问题又来了，该如何设置请求头呢？</p> 
<p>不要紧，其实想通过验证只需要在访问时提供用户名和密码就行了，这一要求通过URL也是可以办到的。如下：</p> 
<pre class="prettyprint"><code class="language-powershell hljs css"><span class="hljs-tag">curl</span> <span class="hljs-tag">foo</span><span class="hljs-pseudo">:bar</span><span class="hljs-at_rule">@<span class="hljs-keyword">localhost:8080/admin/secrets</span></span></code></pre> 
<p>这次就能看到返回的JSON串了。是这样子的：</p> 
<pre class="prettyprint"><code class="language-powershell hljs json">{"<span class="hljs-attribute">secret</span>":<span class="hljs-value">{"<span class="hljs-attribute">email</span>":<span class="hljs-value"><span class="hljs-string">"foo@bar.com"</span></span>,"<span class="hljs-attribute">phone</span>":<span class="hljs-value"><span class="hljs-string">"123433"</span></span>}</span>,"<span class="hljs-attribute">user</span>":<span class="hljs-value"><span class="hljs-string">"foo"</span></span>}</code></pre> 
<p>既然这样，我们不妨再看看这样访问时curl发送给服务器的请求头是怎样的。通过<code>-v</code>选项能达到这一目的：</p> 
<pre class="prettyprint"><code class="language-powershell hljs css"><span class="hljs-tag">curl</span> <span class="hljs-tag">-v</span> <span class="hljs-tag">foo</span><span class="hljs-pseudo">:bar</span><span class="hljs-at_rule">@<span class="hljs-keyword">localhost:8080/admin/secrets</span></span></code></pre> 
<p>这是我们将得到如下的输出：</p> 
<pre class="prettyprint"><code class="language-powershell hljs vbscript">&gt; <span class="hljs-keyword">GET</span> /admin/secrets HTTP/<span class="hljs-number">1.1</span>
&gt; Host: localhost:<span class="hljs-number">8080</span>
&gt; Authorization: Basic Zm9vOmJhcg==
&gt; User-Agent: curl/<span class="hljs-number">7.60</span><span class="hljs-number">.0</span>
&gt; Accept: */*
&gt;
&lt; HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
&lt; Content-Type: application/json; charset=utf-<span class="hljs-number">8</span>
&lt; <span class="hljs-built_in">Date</span>: Wed, <span class="hljs-number">11</span> Jul <span class="hljs-number">2018</span> <span class="hljs-number">06</span>:<span class="hljs-number">14</span>:<span class="hljs-number">26</span> GMT
&lt; Content-Length: <span class="hljs-number">64</span>
&lt;
{<!-- --><span class="hljs-string">"secret"</span>:{<!-- --><span class="hljs-string">"email"</span>:<span class="hljs-string">"foo@bar.com"</span>,<span class="hljs-string">"phone"</span>:<span class="hljs-string">"123433"</span>},<span class="hljs-string">"user"</span>:<span class="hljs-string">"foo"</span>}</code></pre> 
<p><code>&gt;</code>符号后面的是请求，<code>&lt;</code>符号后面的是响应。我们注意到请求头中有这样一行请求首部：</p> 
<pre class="prettyprint"><code class="language-powershell hljs http"><span class="hljs-attribute">Authorization</span>: <span class="hljs-string">Basic Zm9vOmJhcg==</span></code></pre> 
<p>这正是我们苦苦寻觅的验证信息！不过Basic后面一串乱码又是什么鬼？</p> 
<p>其实那不是乱码，那是<code>foo:bar</code>经过base64编码后的结果。也就是说，写在请求头中的验证信息必须经过base64编码。这里提供一个<a href="http://tool.oschina.net/encrypt?type=3" rel="nofollow">网站</a>可以在线进行base64编解码。有关认证的更多信息可以访问<a href="https://tools.ietf.org/html/rfc2617#section-1.2" rel="nofollow">这里</a>。</p> 
<p>如果想通过设置请求头进行验证，按照上面的模式设置请求头就可以啦。下面让我们用这种方式来获取<code>austin</code>的秘密。首先需要访问<a href="http://tool.oschina.net/encrypt?type=3" rel="nofollow">base64编码网站</a>，得到<code>austin:1234</code>经过编码后的内容，然后在PowerShell中输入以下命令：</p> 
<pre class="prettyprint"><code class="language-powershell hljs lasso">curl <span class="hljs-attribute">-v</span> <span class="hljs-attribute">-H</span> <span class="hljs-string">'Authorization: Basic YXVzdGluOjEyMzQ='</span> localhost:<span class="hljs-number">8080</span>/admin/secrets</code></pre> 
<p><code>-H</code>用来向请求头添加自定义字段。再次帅气的回车，你将得到以下内容：</p> 
<pre class="prettyprint"><code class="language-powershell hljs vbscript">&gt; <span class="hljs-keyword">GET</span> /admin/secrets HTTP/<span class="hljs-number">1.1</span>
&gt; Host: localhost:<span class="hljs-number">8080</span>
&gt; User-Agent: curl/<span class="hljs-number">7.60</span><span class="hljs-number">.0</span>
&gt; Accept: */*
&gt; Authorization: Basic YXVzdGluOjEyMzQ=
&gt;
&lt; HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK
&lt; Content-Type: application/json; charset=utf-<span class="hljs-number">8</span>
&lt; <span class="hljs-built_in">Date</span>: Wed, <span class="hljs-number">11</span> Jul <span class="hljs-number">2018</span> <span class="hljs-number">08</span>:<span class="hljs-number">35</span>:<span class="hljs-number">21</span> GMT
&lt; Content-Length: <span class="hljs-number">71</span>
&lt;
{<!-- --><span class="hljs-string">"secret"</span>:{<!-- --><span class="hljs-string">"email"</span>:<span class="hljs-string">"austin@example.com"</span>,<span class="hljs-string">"phone"</span>:<span class="hljs-string">"666"</span>},<span class="hljs-string">"user"</span>:<span class="hljs-string">"austin"</span>}</code></pre> 
<p>成功获取<code>austin</code>的秘密，是不是666。</p> 
<p>最后总结一下认证的三种方式：</p> 
<ol><li>通过浏览器访问，输入用户名和密码；</li><li>通过URL提供用户名和密码，如：user:password@localhost:8080/admin/secrets；</li><li>通过在请求头中添加<code>Authorization</code>字段提供用户名和密码，需要经过base64编码。</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f46eca1f0f78c8c65a7048385935c34/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTTP post 请求携带xml格式报文请求接口</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3bcf8f73e8b868540e842fe042a379f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在浏览器中输入一个网址后，发生了什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>