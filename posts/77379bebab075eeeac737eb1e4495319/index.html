<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux select 一网打尽 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux select 一网打尽" />
<meta property="og:description" content="奇技指南
select, 你可以不用它，但你不能不了解它。
通过阅读本文，可以帮你理清select的来龙去脉， 让你从中了解到：
我们常说的select的1024限制指的是什么 ？怎么会有这样的限制？
都说select效率不高，是这样吗？为什么 ？
select使用中有坑吗？
注：本文的所有内容均指针对 Linux Kernel, 当前使用的源码版本是 5.3.0
原型 int select (int __nfds, fd_set *__restrict __readfds,
fd_set *__restrict __writefds,
fd_set *__restrict __exceptfds,
struct timeval *__restrict __timeout); select是IO多种复用的一种实现，它将需要监控的fd分为读、写、异常三类，使用fd_set表示，当其返回时要么是超时，要么是有至少一种读、写或异常事件发生。
相关数据结构
FD_SET
FD_SET是select最重要的数据结构了，其在内核中的定义如下：
typedef __kernel_fd_set fd_set;
#undef __FD_SETSIZE
#define __FD_SETSIZE 1024
typedef struct {
unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];
} __kernel_fd_set; 我们来简化下，fd_set是一个struct, 其内部只有一个由16个元素组成的unsigned long数组，这个数组一共可以表示16 × 64 = 1024位， 每一位用来表示一个 fd, 这也就是 select针对读、写或异常每一类最多只能有 1024个fd 限制的由来。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/77379bebab075eeeac737eb1e4495319/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-21T19:27:38+08:00" />
<meta property="article:modified_time" content="2019-11-21T19:27:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux select 一网打尽</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <section> 
  <section style="text-align: center"> 
   <section> 
    <section> 
     <section> 
      <section style="text-align: left"> 
       <section> 
        <section style="text-align: right"> 
         <p><strong>奇技指南</strong></p> 
        </section> 
        <section></section> 
       </section> 
      </section> 
      <section style="text-align: justify"> 
       <p>select, 你可以不用它，但你不能不了解它。<br>通过阅读本文，可以帮你理清select的来龙去脉， 让你从中了解到：</p> 
       <ul><li><p>我们常说的select的1024限制指的是什么 ？怎么会有这样的限制？</p></li><li><p>都说select效率不高，是这样吗？为什么 ？</p></li><li><p>select使用中有坑吗？</p></li></ul> 
       <p>注：本文的所有内容均指针对 Linux Kernel, 当前使用的源码版本是 5.3.0</p> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
  <section></section> 
  <section style="text-align: center"> 
   <section> 
    <section style="text-align: left"> 
     <p><strong> 原型 </strong></p> 
    </section> 
   </section> 
  </section> 
  <section> 
   <pre class="has"><code class="language-go"><code>int select (int __nfds, fd_set *__restrict __readfds,<br>           fd_set *__restrict __writefds,<br>           fd_set *__restrict __exceptfds,<br>           struct timeval *__restrict __timeout);</code></code></pre> 
   <p><code>select</code>是IO多种复用的一种实现，它将需要监控的fd分为读、写、异常三类，使用<code>fd_set</code>表示，当其返回时要么是超时，要么是有至少一种读、写或异常事件发生。</p> 
  </section> 
  <section style="text-align: center"> 
   <section> 
    <section style="text-align: left"> 
     <p><strong></strong><strong>相关数据结构</strong></p> 
    </section> 
   </section> 
  </section> 
  <section> 
   <section> 
    <section> 
       
       
    </section> 
    <section> 
     <p><strong>FD_SET</strong></p> 
    </section> 
   </section> 
  </section> 
  <section> 
   <p><code>FD_SET</code>是<code>select</code>最重要的数据结构了，其在内核中的定义如下：</p> 
   <pre class="has"><code class="language-go"><code>typedef __kernel_fd_set     fd_set;<br>#undef __FD_SETSIZE<br>#define __FD_SETSIZE    1024<br><br>typedef struct {<!-- --><br>    unsigned long fds_bits[__FD_SETSIZE / (8 * sizeof(long))];<br>} __kernel_fd_set;</code></code></pre> 
   <p>我们来简化下，<code>fd_set</code>是一个<code>struct</code>, 其内部只有一个由16个元素组成的<code>unsigned long</code>数组，这个数组一共可以表示<code>16 × 64 = 1024</code>位， 每一位用来表示一个 <code>fd</code>, 这也就是 <code>select</code>针对读、写或异常每一类最多只能有 <code>1024</code>个fd 限制的由来。<br></p> 
  </section> 
  <section style="text-align: center"> 
   <section> 
    <section style="text-align: left"> 
     <p><strong></strong><strong>相关宏</strong></p> 
    </section> 
   </section> 
  </section> 
  <section> 
   <p>下面这些宏定义在内核代码<code>fs/select.c</code>中</p> 
   <ul><li><p style="text-align: left"><code>FDS_BITPERLONG</code>: 返回每个<code>long</code>有多少位，通常是64bits</p></li></ul> 
   <pre class="has"><code class="language-go"><code>#define FDS_BITPERLONG    (8*sizeof(long))</code></code></pre> 
   <ul><li> 
     <section> 
      <p><code>FDS_LONGS(nr)</code>: 获取 nr 个fd 需要用几个<code>long</code>来表示</p> 
     </section></li></ul> 
  </section> 
  <section> 
   <section> 
    <pre class="has"><code class="language-go"><code>#define FDS_LONGS(nr) (((nr)+FDS_BITPERLONG-1)/FDS_BITPERLONG)</code></code></pre> 
    <ul><li><p><code>FD_BYTES(nr)</code>: 获取 nr 个fd 需要用 多少个字节来表示</p></li></ul> 
    <pre class="has"><code class="language-go"><code>#define FDS_BYTES(nr) (FDS_LONGS(nr)*sizeof(long))</code></code></pre> 
    <p>下面这些宏可以在gcc源码中找到</p> 
    <ul><li><p><strong><code>FD_ZERO</code>: 初始化一个<code>fd_set</code></strong></p></li></ul> 
    <pre class="has"><code class="language-go"><code>#define __FD_ZERO(s) \<br>  do {                                          \<br>    unsigned int __i;                               \<br>    fd_set *__arr = (s);                            \<br>    for (__i = 0; __i &lt; sizeof (fd_set) / sizeof (__fd_mask); ++__i)        \<br>      __FDS_BITS (__arr)[__i] = 0;                          \<br>  } while (0)</code></code></pre> 
    <p>将上面所说的由16个元素组成的<code>unsigned long</code>数组每一个元素都设为 0;<br></p> 
    <ul><li><p><strong><code>__FD_SET(d, s)</code>: 将一个fd 赋值到 一个 <code>fd_set</code></strong></p></li></ul> 
    <pre class="has"><code class="language-go"><code>#define __FD_SET(d, s) \<br>  ((void) (__FDS_BITS (s)[__FD_ELT(d)] |= __FD_MASK(d)))</code></code></pre> 
    <p><strong>分三步：</strong><br></p> 
   </section> 
  </section> 
  <section> 
   <p>1、__FD_ELT(d)：确定赋值到数组的哪一个元素</p> 
  </section> 
  <section> 
   <pre class="has"><code class="language-go"><code> #define   __FD_ELT(d) \<br>   __extension__                                   \<br>   ({ long int __d = (d);                          \<br>      (__builtin_constant_p (__d)                      \<br>       ? (0 &lt;= __d &amp;&amp; __d &lt; __FD_SETSIZE                       \<br>    ? (__d / __NFDBITS)                            \<br>    : __fdelt_warn (__d))                          \<br>       : __fdelt_chk (__d)); })</code></code></pre> 
   <p>其中 <code>#define __NFDBITS (8 * (int) sizeof (__fd_mask))</code> ， 即<code>__NFDBITS = 64</code></p> 
  </section> 
  <section> 
   <section> 
    <p>这里实现使用了<code>__builtin_constant_p</code>针对常量作了优化，我也没有太理解常量与非常量实现方案有什么不同，我们暂时忽略这个细节看本质。</p> 
    <p>本质就是 一个 <code>unsigned long</code>有64位，直接 <code>__d / __NFDBITS</code>取模就可以确定用数组的哪一个元素了；</p> 
    <p>2、__FD_MASK(d)：确定赋值到一个 unsigned long的哪一位</p> 
   </section> 
  </section> 
  <section> 
   <pre class="has"><code class="language-go"><code>#define   __FD_MASK(d)    ((__fd_mask) (1UL &lt;&lt; ((d) % __NFDBITS)))</code></code></pre> 
   <p>直接 <code>（d) % __NFDBITS)</code>取余后作为 1 左移的位数即可</p> 
  </section> 
  <section> 
   <section> 
    <p>3、|= ：用位或赋值即可</p> 
   </section> 
  </section> 
  <section></section> 
  <section style="text-align: center"> 
   <section> 
    <section style="text-align: left"> 
     <p><strong></strong><strong>在内核中的实现</strong></p> 
    </section> 
   </section> 
  </section> 
  <section> 
   <section> 
      
      
   </section> 
   <section> 
    <p><strong>调用层级</strong></p> 
   </section> 
  </section> 
  <section> 
   <p><img src="https://images2.imgbox.com/f7/e0/5Joi0wKr_o.jpg" style="width: auto"></p> 
  </section> 
  <section> 
   <section> 
      
      
   </section> 
   <section> 
    <p><strong>系统调用入口位置</strong></p> 
   </section> 
  </section> 
  <section> 
   <p>位于<code>fs/select.c</code>中</p> 
   <pre class="has"><code class="language-go"><code>SYSCALL_DEFINE5(select, int, n, fd_set __user *, inp, fd_set __user *, outp,<br>        fd_set __user *, exp, struct timeval __user *, tvp)<br>{<!-- --><br>    return kern_select(n, inp, outp, exp, tvp);<br>}</code></code></pre> 
  </section> 
  <section> 
   <section> 
      
      
   </section> 
   <section> 
    <p><strong>入口函数 kern_select</strong></p> 
   </section> 
  </section> 
  <section> 
   <pre class="has"><code class="language-go"><code>static int kern_select(int n, fd_set __user *inp, fd_set __user *outp,<br>               fd_set __user *exp, struct timeval __user *tvp)<br>{<!-- --><br>    struct timespec64 end_time, *to = NULL;<br>    struct timeval tv;<br>    int ret;<br><br>    if (tvp) {<!-- --><br>        if (copy_from_user(&amp;tv, tvp, sizeof(tv)))<br>            return -EFAULT;<br><br>        to = &amp;end_time;<br>        if (poll_select_set_timeout(to,<br>                tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),<br>                (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC))<br>            return -EINVAL;<br>    }<br><br>    ret = core_sys_select(n, inp, outp, exp, to);<br>    return poll_select_finish(&amp;end_time, tvp, PT_TIMEVAL, ret);<br>}</code></code></pre> 
   <p>做三件事：</p> 
   <p>a. 如果设置了超时，首先准备时间戳 <code>timespec64</code>;</p> 
   <p>b. 调用 <code>core_sys_select</code>，这个是具体的实现，我们下面会重点介绍</p> 
   <p>c. <code>poll_select_finish</code>：做的主要工作就是更新用户调用<code>select</code>时传进来的超时参数<code>tvp</code>，我列一下关键代码：</p> 
   <pre class="has"><code class="language-go"><code>    ktime_get_ts64(&amp;rts);<br>    rts = timespec64_sub(*end_time, rts);<br>    if (rts.tv_sec &lt; 0)<br>        rts.tv_sec = rts.tv_nsec = 0;<br><br>...<br>    struct timeval rtv;<br><br>            if (sizeof(rtv) &gt; sizeof(rtv.tv_sec) + sizeof(rtv.tv_usec))<br>                memset(&amp;rtv, 0, sizeof(rtv));<br>            rtv.tv_sec = rts.tv_sec;<br>            rtv.tv_usec = rts.tv_nsec / NSEC_PER_USEC;<br>            if (!copy_to_user(p, &amp;rtv, sizeof(rtv)))<br>                return ret;</code></code></pre> 
   <p>可以看到先获取当前的时间戳，然后通过<code>timespec64_sub</code>和传入的时间戳（接中传入的是超时时间，实现时会转化为时间戳）求出差值，将此差值传回给用户，即返回了剩余的超时时间。所以这个地方是个小陷阱，用户在调用<code>select</code>时，需要每次重新初始化这个超时时间。</p> 
  </section> 
  <section> 
   <section> 
      
      
   </section> 
   <section> 
    <p><strong>通过 core_sys_select 实现</strong></p> 
   </section> 
  </section> 
  <section> 
   <p>这个函数主要功能是在实现真正的select功能前，准备好 <code>fd_set</code> ，即从用户空间将所需的三类 <code>fd_set</code> 复制到内核空间。从下面的代码中你会看到对于每次的 <code>select</code>系统调用，都需要从用户空间将所需的三类 <code>fd_set</code> 复制到内核空间，这里存在性能上的损耗。</p> 
   <pre class="has"><code class="language-go"><code>int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,<br>               fd_set __user *exp, struct timespec64 *end_time)<br>{<!-- --><br>    fd_set_bits fds;<br>    void *bits;<br>    int ret, max_fds;<br>    size_t size, alloc_size;<br>    struct fdtable *fdt;<br>    /* Allocate small arguments on the stack to save memory and be faster */<br>    long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];<br><br>    ret = -EINVAL;<br>    if (n &lt; 0)<br>        goto out_nofds;<br><br>    /* max_fds can increase, so grab it once to avoid race */<br>    rcu_read_lock();<br>    fdt = files_fdtable(current-&gt;files);<br>    max_fds = fdt-&gt;max_fds;<br>    rcu_read_unlock();<br>    if (n &gt; max_fds)<br>        n = max_fds;<br><br>    /*<br>     * We need 6 bitmaps (in/out/ex for both incoming and outgoing),<br>     * since we used fdset we need to allocate memory in units of<br>     * long-words.<br>     */<br>    size = FDS_BYTES(n);<br>    bits = stack_fds;<br>    if (size &gt; sizeof(stack_fds) / 6) {<!-- --><br>        /* Not enough space in on-stack array; must use kmalloc */<br>        ret = -ENOMEM;<br>        if (size &gt; (SIZE_MAX / 6))<br>            goto out_nofds;<br><br>        alloc_size = 6 * size;<br>        bits = kvmalloc(alloc_size, GFP_KERNEL);<br>        if (!bits)<br>            goto out_nofds;<br>    }<br>    fds.in      = bits;<br>    fds.out     = bits +   size;<br>    fds.ex      = bits + 2*size;<br>    fds.res_in  = bits + 3*size;<br>    fds.res_out = bits + 4*size;<br>    fds.res_ex  = bits + 5*size;<br><br>    if ((ret = get_fd_set(n, inp, fds.in)) ||<br>        (ret = get_fd_set(n, outp, fds.out)) ||<br>        (ret = get_fd_set(n, exp, fds.ex)))<br>        goto out;<br>    zero_fd_set(n, fds.res_in);<br>    zero_fd_set(n, fds.res_out);<br>    zero_fd_set(n, fds.res_ex);<br><br>    ret = do_select(n, &amp;fds, end_time);<br><br>    if (ret &lt; 0)<br>        goto out;<br>    if (!ret) {<!-- --><br>        ret = -ERESTARTNOHAND;<br>        if (signal_pending(current))<br>            goto out;<br>        ret = 0;<br>    }<br><br>    if (set_fd_set(n, inp, fds.res_in) ||<br>        set_fd_set(n, outp, fds.res_out) ||<br>        set_fd_set(n, exp, fds.res_ex))<br>        ret = -EFAULT;<br><br>out:<br>    if (bits != stack_fds)<br>        kvfree(bits);<br>out_nofds:<br>    return ret;<br>}</code></code></pre> 
   <p>代码中的注释很清晰，我们这里简单过一下：</p> 
  </section> 
  <section> 
   <section> 
    <p><strong>分五步：</strong></p> 
   </section> 
  </section> 
  <section> 
   <p>1、规范化select系统调用传入的第一个参数 n</p> 
  </section> 
  <section> 
   <pre class="has"><code class="language-go"><code>/* max_fds can increase, so grab it once to avoid race */<br>  rcu_read_lock();<br>  fdt = files_fdtable(current-&gt;files);<br>  max_fds = fdt-&gt;max_fds;<br>  rcu_read_unlock();<br>  if (n &gt; max_fds)<br>      n = max_fds;</code></code></pre> 
   <p>这个n是三类不同的<code>fd_set</code>中所包括的fd数值的最大值 + 1， linux task打开句柄从0开始，不加1的话可能会少监控fd.</p> 
   <p>用户在使用时可以有个偷懒的做法，就是将这个n设置为 <code>FD_SETSIZE</code>，通常是1024，这将监控的范围扩大到了上限，但实际上远没有这么多fd需要监控，浪费资源。</p> 
   <p>linux man中的解释如下：</p> 
   <blockquote> 
    <p>nfds should be set to the highest-numbered file descriptor in any of the three sets, plus 1.  The  indicated file descriptors in each set are checked, up to this limit (but see BUGS).</p> 
   </blockquote> 
  </section> 
  <section> 
   <section> 
    <p>2、计算内核空间所需要的fd_set的空间, 内核态需要三个fd_set来容纳用户态传递过来的参数，还需要三个fd_set来容纳select调用返回后生成的三灰fd_set, 即一共是6个fd_set</p> 
   </section> 
  </section> 
  <section> 
   <pre class="has"><code class="language-go"><code>   long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];<br>   . . .<br>   size = FDS_BYTES(n);<br>  bits = stack_fds;<br>  if (size &gt; sizeof(stack_fds) / 6) {<!-- --><br>      /* Not enough space in on-stack array; must use kmalloc */<br>      ret = -ENOMEM;<br>      if (size &gt; (SIZE_MAX / 6))<br>          goto out_nofds;<br><br>      alloc_size = 6 * size;<br>      bits = kvmalloc(alloc_size, GFP_KERNEL);<br>      if (!bits)<br>          goto out_nofds;<br>  }<br>  fds.in      = bits;<br>  fds.out     = bits +   size;<br>  fds.ex      = bits + 2*size;<br>  fds.res_in  = bits + 3*size;<br>  fds.res_out = bits + 4*size;<br>  fds.res_ex  = bits + 5*size;<br></code></code></pre> 
   <p>这里有个小技巧，先从内核栈上分配空间，如果不够用，才使用 <code>kvmalloc</code>分配。</p> 
   <p>通过 <code>size = FDS_BYTES(n);</code>计算出单一一种<code>fd_set</code>所需字节数，</p> 
   <p>再能过 <code>alloc_size = 6 * size;</code> 即可计算出所需的全部字节数。</p> 
  </section> 
  <section> 
   <section> 
    <p>3、初始化用作参数的和用作返回值的两类fd_set</p> 
   </section> 
  </section> 
  <section> 
   <pre class="has"><code class="language-go"><code>if ((ret = get_fd_set(n, inp, fds.in)) ||<br>      (ret = get_fd_set(n, outp, fds.out)) ||<br>      (ret = get_fd_set(n, exp, fds.ex)))<br>      goto out;<br>  zero_fd_set(n, fds.res_in);<br>  zero_fd_set(n, fds.res_out);<br>  zero_fd_set(n, fds.res_ex);</code></code></pre> 
  </section> 
  <section> 
   <section> 
    <p>4、真正实现部分 do_select， 我们在下面详讲</p> 
   </section> 
  </section> 
  <section> 
   <p>5、返回结果复制回用户空间</p> 
  </section> 
  <section> 
   <pre class="has"><code class="language-go"><code>if (set_fd_set(n, inp, fds.res_in) ||<br>      set_fd_set(n, outp, fds.res_out) ||<br>      set_fd_set(n, exp, fds.res_ex))<br>      ret = -EFAULT;</code></code></pre> 
   <p>这里又多了一次内核空间到用户空间的copy，而且我们看到返回值也是用<code>fd_set</code>结构来表示，这意味着我们在用户空间处理里也需要遍历每一位。</p> 
  </section> 
  <section> 
   <section> 
      
      
   </section> 
   <section> 
    <p><strong>精华所在 do_select</strong></p> 
   </section> 
  </section> 
  <section> 
   <h6><strong>wait queue</strong></h6> 
   <p>这里用到了Linux里一个很重要的数据结构 <code>wait queue</code>, 我们暂不打算展开来讲，先简单来说下其用法，比如我们在进程中read时经常要等待数据准备好，我们用伪码来写些流程：</p> 
   <pre class="has"><code class="language-go"><code>// Read 代码<br>for (true) {<!-- --><br>    if 数据准备好 {<!-- --><br>        拷贝数据到用户空间buffer<br>        return<br>    } else {<!-- --><br>       创建一个 wait_queue_entry_t  wait_entry;<br>       wait_entry.func = 自定义函数，被唤醒时会调用<br>       wait_entry.private = 自定义的数据结构<br><br>       将此 wait_entry 加入要读取数据的 设备的等待队列<br><br>       set_current_state(TASK_INTERRUPTIBLE) // 将当前进程状态设置为 TASK_INTERRUPTIBLE<br><br>       schedule() // 将当前进程调度走，进行进程切换<br>    }<br>}<br><br>// 设备驱动端代码<br>if 设备有数据可读 {<!-- --><br>   for ( 遍历其wait_queue ) {<!-- --><br>      唤醒 每一个 wait_queue_entry<br>      调用 wait_entry.func {<!-- --><br>           将上面读取进程状态设置为 TASK_RUNNING，并加入CPU核的运行队列，被再次调度后，将读取到数据<br>      }<br>   }<br>}</code></code></pre> 
   <p><code>do_select</code>源码走读<br></p> 
   <ul><li> 
     <section> 
      <p>获取当前三类<code>fd_set</code>中最大的fd</p> 
     </section></li></ul> 
   <section> 
    <pre class="has"><code class="language-go"><code>    rcu_read_lock();<br>  retval = max_select_fd(n, fds);<br>  rcu_read_unlock();<br>  <br>  n = retval;</code></code></pre> 
          上面  
    <code>n = retval</code> 
    中的  
    <code>n</code> 
    , 即为三类 
    <code>fd_set</code> 
    中最大的fd, 也是下面要介绍的循环体的上限 
   </section> 
   <section> 
    <br> 
   </section> 
   <ul><li><p>初始化用作wait queue中的 wait entry 的private数据结构</p></li></ul> 
   <pre class="has"><code class="language-go"><code>poll_initwait(&amp;table);</code></code></pre> 
   <ul><li> 
     <section> 
      <p>核心循环体</p> 
     </section></li></ul> 
   <section> 
    <p>我们讲注释写在这个代码块里</p> 
    <pre class="has"><code class="language-go"><code>// 最外面是一个无限循环，它只有在poll到有效的事件，或者超时，或者有中断发生时，才会退出<br>for (;;) {<!-- --><br>      unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;<br>      bool can_busy_loop = false;<br><br>       // 首先获取需要监控的三类fd_set, 其实是 unsigned long 数组<br>      inp = fds-&gt;in; outp = fds-&gt;out; exp = fds-&gt;ex;<br>       // 初始化用于保存返回值的三类 fd_set对应的unsigned long 数组<br>      rinp = fds-&gt;res_in; routp = fds-&gt;res_out; rexp = fds-&gt;res_ex;<br><br>        // 开始循环遍历覆盖的所有fd, 以上面得到的 n 上限<br>      for (i = 0; i &lt; n; ++rinp, ++routp, ++rexp) {<!-- --><br>          unsigned long in, out, ex, all_bits, bit = 1, j;<br>          unsigned long res_in = 0, res_out = 0, res_ex = 0;<br>          __poll_t mask;<br>            <br>          in = *inp++; out = *outp++; ex = *exp++;<br>          all_bits = in | out | ex;<br>          if (all_bits == 0) {<!-- --><br>                //  如果走到这里，说明在三类fd_set的数组中，与当前下标对应的三个unsigned long的每一位均为0, 即当前<br>                // 不存在任何监控的fd, 开始下一次循环<br>              i += BITS_PER_LONG;<br>              continue;<br>          }<br><br>            // 前面介绍过 fd_set的数组元素是 unsigned long, 即一个元素可表示64个fd, 这里依次遍历这64个bits<br>          for (j = 0; j &lt; BITS_PER_LONG; ++j, ++i, bit &lt;&lt;= 1) {<!-- --><br>              struct fd f;<br>              if (i &gt;= n)<br>                  break;<br>              if (!(bit &amp; all_bits))<br>                  continue;<br>                // 走到这里，说明当前bit位上有监控的fd<br>                <br>              f = fdget(i);<br>              if (f.file) {<!-- --><br>                    // 针对当前fd, 设置其需要监控的事件<br>                  wait_key_set(wait, in, out, bit,<br>                           busy_flag);<br>                    <br>                    // vfs_poll 是重中之重，我们下一节会单独讲解，这里先说明它所作的事<br>                    // 1.  初始化wait entry, 将其加入到这个fd对应的socket的等待队列中<br>                    // 2.  获取当前socket是否有读，写，异常等事件并返回<br>                  mask = vfs_poll(f.file, wait);<br><br>                  fdput(f);<br>                    // 按位与，看是否有相关事件<br>                  if ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) {<!-- --><br>                      res_in |= bit;<br>                      retval++;<br>                      wait-&gt;_qproc = NULL;<br>                  }<br>                  if ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) {<!-- --><br>                      res_out |= bit;<br>                      retval++;<br>                      wait-&gt;_qproc = NULL;<br>                  }<br>                  if ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) {<!-- --><br>                      res_ex |= bit;<br>                      retval++;<br>                      wait-&gt;_qproc = NULL;<br>                  }<br>                    <br>                  /* got something, stop busy polling */<br>                  if (retval) {<!-- --><br>                      can_busy_loop = false;<br>                      busy_flag = 0;<br><br>                  /*<br>                   * only remember a returned<br>                   * POLL_BUSY_LOOP if we asked for it<br>                   */<br>                  } else if (busy_flag &amp; mask)<br>                      can_busy_loop = true;<br><br>              }<br>          }<br>            <br>            // 按unsigned long赋值给返回值数组元素<br>          if (res_in)<br>              *rinp = res_in;<br>          if (res_out)<br>              *routp = res_out;<br>          if (res_ex)<br>              *rexp = res_ex;<br>            <br>            // 这里有两层for循环，这里主动出让CPU, 进行一次调度<br>          cond_resched();<br>      }<br>      wait-&gt;_qproc = NULL;<br>    <br>        // 四种情况下会返回<br>       // 1.  任意监控的fd上有事件发生<br>       //  2. 超时<br>       //  3. 有中断发生<br>       //  4. wait queue相关操作发生错误<br>      if (retval || timed_out || signal_pending(current))<br>          break;<br>      if (table.error) {<!-- --><br>          retval = table.error;<br>          break;<br>      }<br><br>    ......<br>        <br>        //  当前监控的fd上没有事件发生，也没有超时或中断发生，<br>       //   将当前进程设置为 TASK_INTERRUPTIBLE， 并调用 schedule<br>       //   等待事件发生时，对应的socket将当前进程唤醒后，从 这里<br>      //   继续运行<br>      if (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,<br>                     to, slack))<br>          timed_out = 1;<br>  }</code></code></pre> 
    <p>简单总结如下：<br></p> 
    <p>a. 循环遍历每一个监控的fd；</p> 
    <p>b. 有下列情况之一则返回：</p> 
    <pre class="has"><code class="language-go"><code>       1.  任意监控的fd上有事件发生<br>       2. 超时<br>       3. 有中断发生<br>       4. wait queue相关操作发生错误</code></code></pre> 
    <p>c. 如查无上述情况，将当前进程设置为 TASK_INTERRUPTIBLE， 并调用 <code>schedule</code>作进程切换；<br></p> 
    <p>d. 等待socket 事件发生，对应的socket将当前进程唤醒后，当前进程被再次调度切换回来，继续运行；</p> 
    <p>细心的你可能已经发现，这个有个影响效率的问题：即使只有一个监控中的fd有事件发生，当前进程就会被唤醒，然后要将所有监控的fd都遍历一边，依次调用<code>vfs_poll</code>来获取其有效事件，好麻烦啊～～～</p> 
    <h6>vfs_poll 讲解</h6> 
    <ul><li><p>调用层级</p></li></ul> 
    <p><img src="https://images2.imgbox.com/24/6a/iYvSIzOU_o.png" style="width: auto"></p> 
    <ul><li> 
      <section> 
       <section> 
        <p>作用：</p> 
       </section> 
      </section></li></ul> 
    <section> 
     <section> 
      <pre class="has"><code class="language-go"><code>1.  初始化wait entry, 将其加入到这个fd对应的socket的等待队列中<br>2.  获取当前socket是否有读，写，异常等事件并返回</code></code></pre> 
      <ul><li> 
        <section> 
         <section> 
          <section> 
           <section> 
            <p>加入等待队列时，最终会调用 <code>fs_select.c</code>中的 <code>__pollwait</code></p> 
           </section> 
          </section> 
         </section> 
        </section></li></ul> 
      <section> 
       <section> 
        <section> 
         <section> 
          <pre class="has"><code class="language-go"><code>static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,<br>              poll_table *p)<br>{<!-- --><br>  struct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);<br>  struct poll_table_entry *entry = poll_get_entry(pwq);<br>  if (!entry)<br>      return;<br>  entry-&gt;filp = get_file(filp);<br>  entry-&gt;wait_address = wait_address;<br>  entry-&gt;key = p-&gt;_key;<br>  init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);<br>  entry-&gt;wait.private = pwq;<br>    <br>    // 加入到socket的等待队列<br>  add_wait_queue(wait_address, &amp;entry-&gt;wait);<br>}</code></code></pre> 
         </section> 
        </section> 
       </section> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
  <section style="text-align: center"> 
   <section> 
    <section style="text-align: left"> 
     <p><strong> 总结 </strong></p> 
    </section> 
   </section> 
  </section> 
  <section> 
   <ul><li><p><code>select</code>调用中每类<code>fd_set</code>中最多容纳1024个fd；</p></li><li><p>每次调用<code>select</code>都需要将三类<code>fd_set</code>从用户空间复制到内核空间；</p></li><li><p><code>wait queue</code>是个好东西，<code>select</code>会被当前进程task加入到每一个监控的socket的等待队列；</p></li><li><p><code>select</code>进程被唤醒后即使只有一个被监控的fd有事件发生，也会再次将所有的监控fd遍历一次；</p></li><li><p>在遍历fd的过程中会调用<code>cond_resched（）</code>来主动出让CPU, 作进程切换；</p></li></ul> 
  </section> 
  <section> 
   <section> 
    <section> 
     <section> 
      <section> 
       <section></section> 
       <section></section> 
      </section> 
      <section style="text-align: left"> 
       <p><strong>关注我们</strong></p> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
  <section style="text-align: center"> 
   <section> 
    <section style="text-align: right"> 
     <section> 
      <section> 
       <section> 
        <section> 
         <p>界世的你当不<br></p> 
        </section> 
       </section> 
      </section> 
     </section> 
     <section> 
      <section> 
       <section style="text-align: left"> 
        <p>只做你的肩膀</p> 
       </section> 
      </section> 
     </section> 
     <section> 
      <section style="text-align: justify"> 
       <p>无</p> 
      </section> 
     </section> 
    </section> 
    <section> 
     <section> 
      <section style="text-align: right"> 
       <section> 
        <img src="https://images2.imgbox.com/24/42/wYHDVyhp_o.png" style="width: 100%"> 
       </section> 
      </section> 
     </section> 
     <section> 
      <section style="text-align: left"> 
       <section> 
        <img src="https://images2.imgbox.com/ab/4f/3MybXfPn_o.png" style="width: 100%"> 
       </section> 
      </section> 
     </section> 
    </section> 
    <section> 
     <section> 
      <section> 
       <p> 360官方技术公众号 </p> 
      </section> 
      <section> 
       <p>技术干货|一手资讯|精彩活动</p> 
      </section> 
     </section> 
    </section> 
    <section style="text-align: left"> 
     <section> 
      <section> 
       <p>空·</p> 
      </section> 
     </section> 
    </section> 
   </section> 
  </section> 
 </section> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0249045c684c58a6227758fce5a17cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vector二维数组的初始化</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d378d2a5f9aa850ec698d9e722f9da6c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Linux】pip is configured with locations that require TLS/SSL, however the ssl module in Python is no</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>