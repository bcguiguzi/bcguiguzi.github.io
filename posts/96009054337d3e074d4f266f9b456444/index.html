<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android 中的线程池 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android 中的线程池" />
<meta property="og:description" content="Android 中的线程池： 线程池的优点： 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。能够对线程进行简单管理，并提供定时执行以及指定间隔循环执行等功能。 ThreadPoolExecutor Android 中的线程池的概念来源于 Java 中的 Executor，Executor 是一个接口，真正的实现为 ThreadPoolExecutor。ThreadPoolExecutor 的构造方法中的参数直接影响线程池的功能特性。
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize 线程池的核心线程数。默认情况下，核心线程会在线程中一直存活，即使它们处于闲置状态。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize;
如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行。
maximumPoolSize 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize。
keepAliveTime 非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设置为 True 时，keepAliveTime 同样会作用于核心线程。
unit 用于指定 keepAliveTime 参数的时间单位，这是一个枚举，常用的有 TimeUnit.MILLISECONDS(毫秒)、TimeUnit.SECONDS(秒)以及 TimeUnit.MINUTES(分钟)等。
workQueue 线程池中的任务队列，通过线程池的 executor 方法提交的 Runnable 对象会存储在这个参数中。当线程池中的线程数超过它的 corePoolSize 的时候，线程会进入任务队列等待。
什么是阻塞队列。 队列： 队列是一种特殊的线性表，它只允许表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样（先进先出），队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为对头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。
阻塞队列： 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 ThreadPoolExecutor 执行任务时大致遵循如下规则： 如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。如果在步骤 2 中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程规定的最大值，那么会立刻启动一个非核心线程来执行任务。如果步骤 3 中线程数量已经达到线程池规定的最大值，那么就拒绝执行任务，并调用 RejectedExecutionHandler." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/96009054337d3e074d4f266f9b456444/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-09T11:53:44+08:00" />
<meta property="article:modified_time" content="2021-06-09T11:53:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android 中的线程池</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Android__0"></a>Android 中的线程池：</h3> 
<h4><a id="_2"></a>线程池的优点：</h4> 
<ol><li>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。</li><li>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。</li><li>能够对线程进行简单管理，并提供定时执行以及指定间隔循环执行等功能。</li></ol> 
<h4><a id="ThreadPoolExecutor_8"></a>ThreadPoolExecutor</h4> 
<p>Android 中的线程池的概念来源于 Java 中的 Executor，Executor 是一个接口，真正的实现为 ThreadPoolExecutor。ThreadPoolExecutor 的构造方法中的参数直接影响线程池的功能特性。</p> 
<pre><code>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
</code></pre> 
<h5><a id="corePoolSize_22"></a>corePoolSize</h5> 
<blockquote> 
 <p>线程池的核心线程数。默认情况下，核心线程会在线程中一直存活，即使它们处于闲置状态。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize;</p> 
</blockquote> 
<blockquote> 
 <p>如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行。</p> 
</blockquote> 
<h5><a id="maximumPoolSize_27"></a>maximumPoolSize</h5> 
<blockquote> 
 <p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize。</p> 
</blockquote> 
<h5><a id="keepAliveTime_30"></a>keepAliveTime</h5> 
<blockquote> 
 <p>非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设置为 True 时，keepAliveTime 同样会作用于核心线程。</p> 
</blockquote> 
<h5><a id="unit_33"></a>unit</h5> 
<blockquote> 
 <p>用于指定 keepAliveTime 参数的时间单位，这是一个枚举，常用的有 TimeUnit.MILLISECONDS(毫秒)、TimeUnit.SECONDS(秒)以及 TimeUnit.MINUTES(分钟)等。</p> 
</blockquote> 
<h5><a id="workQueue_36"></a>workQueue</h5> 
<blockquote> 
 <p>线程池中的任务队列，通过线程池的 executor 方法提交的 Runnable 对象会存储在这个参数中。当线程池中的线程数超过它的 corePoolSize 的时候，线程会进入任务队列等待。</p> 
</blockquote> 
<h4><a id="_39"></a>什么是阻塞队列。</h4> 
<h4><a id="_40"></a>队列：</h4> 
<blockquote> 
 <p>队列是一种特殊的线性表，它只允许表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样（先进先出），队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为对头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。</p> 
</blockquote> 
<h4><a id="_43"></a>阻塞队列：</h4> 
<blockquote> 
 <ul><li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li><li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</li></ul> 
</blockquote> 
<h4><a id="ThreadPoolExecutor__48"></a>ThreadPoolExecutor 执行任务时大致遵循如下规则：</h4> 
<blockquote> 
 <ol><li>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</li><li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</li><li>如果在步骤 2 中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程规定的最大值，那么会立刻启动一个非核心线程来执行任务。</li><li>如果步骤 3 中线程数量已经达到线程池规定的最大值，那么就拒绝执行任务，并调用 RejectedExecutionHandler.rejectedExecution()方法通知。</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8e/02/bflvj3MM_o.png" alt="image"></p> 
<h4><a id="_57"></a>常见的四类线程池</h4> 
<h5><a id="FixedThreadPool_58"></a>FixedThreadPool</h5> 
<blockquote> 
 <p>通过Executors 的 newFixedThreadPool 方法来创建。它是一种线程数量固定的线程池，当线程处于空闲状态时，它们不会被回收，除非线程池关闭了。FixedThreadPool 中只有核心线程并且这些核心线程没有超时机制，另外任务队列也是没有大小限制的。</p> 
</blockquote> 
<pre><code>public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(nThreads,
                                  nThreads,
                                  0L,
                                  TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}
</code></pre> 
<h5><a id="CachedThreadPool_72"></a>CachedThreadPool</h5> 
<blockquote> 
 <p>通过Executors 的 newCachedThreadPool 方法来创建。它是一种线程数量不定的线程池，它只有非核心线程，并且其最大线程数为 Integer.MAX_VALUE.由于线程数可以任意大，所以线程池的空闲线程都有超时机制，这个时间为60秒，超过60秒闲置线程就会被回收。这类线程池比较适合执行大量的耗时较少的任务。当整个线程池都处于闲置状态时，线程池的线程都会超时而被停止，这个时候线程池没有任何线程，几乎不占用任何系统资源。</p> 
</blockquote> 
<pre><code>public static ExecutorService newCachedThreadPool(){
    return new ThreadPoolExecutor(0L,
                                  Integer.MAX_VALUE,
                                  60L,
                                  TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre> 
<h5><a id="ScheduledThreadPool_85"></a>ScheduledThreadPool</h5> 
<p>通过 Executors 的 newScheduledThreadPool 方法来创建。它的核心线程数量是固定的，而非核心线程数量是没有限制的，并且当非核心线程闲置时会被立即回收。这类线程池主要用于执行定时任务和具有固定周期的重复任务。</p> 
<pre><code>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize){
    return new ScheduledThreadPoolExecutor(corePoolSize);
} 

public ScheduledThreadPoolExecutor(int corePoolSize){
    super(corePoolSize,
          Integer.MAX_VALUE,
          0,
          NANOSECONDS,
          new DelayedWorkQueue());
}
</code></pre> 
<h5><a id="SingleThreadExeutor_102"></a>SingleThreadExeutor</h5> 
<p>通过 Executors 的 newSingleThreadExecutor 方法来创建。这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。</p> 
<pre><code>public static ExecutorService newSingleThreadExecutor(){
    return new FinalizableDelegatedExecutorService(
    new ThreadPoolExecutor(1,
                           1,
                           0L,
                           TimeUnit.MILLISECNDS,
                           new LinkedBlockingQueue&lt;Runnable&gt;()));
}
</code></pre> 
<h6><a id="Android__116"></a>内容参考《Android 开发艺术探索》</h6>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/24e81fd9de17f0598b933c28e433dafa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C#捕获windows关机事件，在系统关机前做一些自己想做的事</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa34c54642a0885e1b9f39bd3d45043d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021-06-09 MARKDOWN编辑器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>