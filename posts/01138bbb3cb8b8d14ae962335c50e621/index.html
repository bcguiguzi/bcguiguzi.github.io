<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【820复试】数据结构面试问题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【820复试】数据结构面试问题" />
<meta property="og:description" content="文章目录 1.用循环比递归的效率高吗2.顺序表和链表的比较3.头指针和头结点的区别4.如何区分循环队列是队满还是队空？5.栈在通过后缀表达式求值的算法思想6.栈在递归中的应用7.队列在层次遍历中的作用8.队列在计算机系统中的应用9.矩阵的压缩存储10.串的模式匹配11.如何由遍历序列构造一棵二叉树12.线索二叉树的概念13.树的4种存储方式14.平衡二叉树15.dijkstra算法16.Floyd算法17.Prim算法18.Kraskal算法19.拓扑排序20.B树和B&#43;树21.哈希表的概念、构造方法，哈希冲突的解决方法22.内部排序辨析23.外部排序辨析 1.用循环比递归的效率高吗 循环和递归两者是可以互换的，无法陈述谁效率高。
递归
优点：代码简洁清晰，容易检查正确性；
缺点：递归调用次数较多时，要增加额外的堆栈处理，有可能产生堆栈溢出的情况，会对执行效率有一定的影响。
循环
优点：结构检点，速度快；
缺点：不能解决全部问题，有些问题适合于用递归来解决不适合用循环解决。
2.顺序表和链表的比较 从 存取方式、 逻辑结构和物理结构、 查找插入和删除操作、空间分配四个方面分别做比较即可。
3.头指针和头结点的区别 头指针：是指向第一个结点存储位置的指针，具有表示作用，头指针是链表的必要元素，无论链表是否为空，头指针都存在。
头结点：是放在第一个元素结点之前，便于在第一个元素结点之前进行插入和删除的操作，头结点不是链表的必须元素，可有可无，头结点的数据域也可以不存储任何信息。
4.如何区分循环队列是队满还是队空？ ①牺牲一个单元来区分队满和队空。
队空就是Q.front == Q.rear
队满就是(Q.rear&#43;1)%Maxsize == Q.front
②增设数据成员元素
队空Q.size0
队满Q.sizeMaxsize
③标记上一次是入队还是出队
若是入队flag=1，此时出现Q.frontQ.rear，那么即为队满
若是出队flag=0，此时出现Q.frontQ.rear，那么即为队空
5.栈在通过后缀表达式求值的算法思想 但凡出现左括号，做入栈操作，否则做以下操作：
是否为空？与栈顶元素是否匹配？
表达式检验结束后，还要检查栈中是否还有元素。
6.栈在递归中的应用 在递归函数中，每次函数调用都会创建一个新的函数调用帧（frame），这个帧包含了函数的局部变量、参数值以及函数返回地址等信息。
当函数调用自身（递归调用）时，每次都会创建一个新的函数调用帧。这些函数调用帧被存储在内存中的栈数据结构中，这就是所谓的调用栈（call stack）。
当递归函数开始执行时，会一直递归调用自身，每次递归调用都会将一个新的函数调用帧压入调用栈中。
当递归条件不再满足，函数开始返回时，会从栈顶依次弹出函数调用帧，并执行相应的返回操作，直到栈为空，整个递归过程结束。
7.队列在层次遍历中的作用 遇到某类信息需要逐层/逐行处理时，往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，待当前层或当前行处理完毕，就可以处理下一层或下一行。
二叉树的层序遍历、广度优先搜索、任务调度、消息队列、缓冲池、批处理系统。
8.队列在计算机系统中的应用 任务调度和作业管理： 操作系统使用队列来管理和调度各种任务和作业。例如，多任务操作系统可以使用队列来安排进程的执行顺序，确保按照优先级和其他调度策略执行任务。I/O请求管理： 计算机系统中的I/O设备通常会产生大量的请求，如磁盘I/O请求、网络数据包等。队列被广泛应用于管理这些请求，以便按照请求到达的顺序来处理它们。消息传递和事件处理： 在事件驱动的系统中，队列用于管理事件和消息的处理顺序。例如，图形用户界面（GUI）应用程序可以使用队列来处理用户输入事件、定时器事件等。网络数据包排队： 在网络系统中，路由器和交换机使用队列来缓冲传入和传出的数据包。这些队列可以帮助调节网络流量，并确保数据包按照一定的优先级和服务质量要求被处理。缓存系统： 队列常被用于实现缓存系统，例如最近最少使用（LRU）缓存算法。在缓存满时，新的数据项可以被放入队列，而最久未使用的数据项可以从队列的头部被移除。并发编程： 在多线程和并发编程中，队列常被用于实现线程间的通信和同步。例如，生产者-消费者模型中，一个线程（生产者）向队列中放入数据，而另一个线程（消费者）则从队列中取出数据进行处理。日志和消息处理系统： 队列可用于实现日志和消息处理系统，用于收集、存储和处理系统产生的日志和消息。通过将日志和消息放入队列中，可以实现异步处理和解耦。批处理系统： 在数据处理领域，队列被广泛用于构建批处理系统。数据处理任务可以被放入队列中，然后由后台任务逐个处理，从而提高处理效率。 9.矩阵的压缩存储 矩阵的压缩存储是一种优化存储矩阵的方法，特别是当矩阵中有大量的重复值或者是稀疏矩阵（大部分元素为零）时。
它的主要目的是减少内存占用，提高存储和处理效率。
行压缩存储、列压缩存储、对角线压缩存储、十字链表法。
10.串的模式匹配 朴素算法（Naive Algorithm）：
也称为暴力匹配算法，它是最简单直观的模式匹配算法。它的思路是在文本串中从头到尾逐个字符地与模式串进行比较，直到找到匹配或者遍历完整个文本串。
朴素算法的时间复杂度为 O(m*n)，其中 m 是模式串的长度，n 是文本串的长度。
// 朴素算法函数 int naiveSearch(char *text, char *pattern) { int textLength = strlen(text); int patternLength = strlen(pattern); for (int i = 0; i &lt;= textLength - patternLength; &#43;&#43;i) { int j; // 检查文本串中从第 i 个位置开始的子串是否与模式串匹配 for (j = 0; j &lt; patternLength; &#43;&#43;j) { if (text[i &#43; j] !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/01138bbb3cb8b8d14ae962335c50e621/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-16T20:19:36+08:00" />
<meta property="article:modified_time" content="2024-03-16T20:19:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【820复试】数据结构面试问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><ul><li><a href="#1_1" rel="nofollow">1.用循环比递归的效率高吗</a></li><li><a href="#2_13" rel="nofollow">2.顺序表和链表的比较</a></li><li><a href="#3_17" rel="nofollow">3.头指针和头结点的区别</a></li><li><a href="#4_23" rel="nofollow">4.如何区分循环队列是队满还是队空？</a></li><li><a href="#5_37" rel="nofollow">5.栈在通过后缀表达式求值的算法思想</a></li><li><a href="#6_44" rel="nofollow">6.栈在递归中的应用</a></li><li><a href="#7_52" rel="nofollow">7.队列在层次遍历中的作用</a></li><li><a href="#8_58" rel="nofollow">8.队列在计算机系统中的应用</a></li><li><a href="#9_69" rel="nofollow">9.矩阵的压缩存储</a></li><li><a href="#10_76" rel="nofollow">10.串的模式匹配</a></li><li><a href="#11_156" rel="nofollow">11.如何由遍历序列构造一棵二叉树</a></li><li><a href="#12_164" rel="nofollow">12.线索二叉树的概念</a></li><li><a href="#134_171" rel="nofollow">13.树的4种存储方式</a></li><li><a href="#14_239" rel="nofollow">14.平衡二叉树</a></li><li><a href="#15dijkstra_247" rel="nofollow">15.dijkstra算法</a></li><li><a href="#16Floyd_310" rel="nofollow">16.Floyd算法</a></li><li><a href="#17Prim_333" rel="nofollow">17.Prim算法</a></li><li><a href="#18Kraskal_377" rel="nofollow">18.Kraskal算法</a></li><li><a href="#19_425" rel="nofollow">19.拓扑排序</a></li><li><a href="#20BB_477" rel="nofollow">20.B树和B+树</a></li><li><a href="#21_495" rel="nofollow">21.哈希表的概念、构造方法，哈希冲突的解决方法</a></li><li><a href="#22_511" rel="nofollow">22.内部排序辨析</a></li><li><a href="#23_525" rel="nofollow">23.外部排序辨析</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h5><a id="1_1"></a>1.用循环比递归的效率高吗</h5> 
<p>循环和递归两者是可以互换的，无法陈述谁效率高。</p> 
<p>递归<br> 优点：代码简洁清晰，容易检查正确性；<br> 缺点：递归调用次数较多时，要增加额外的堆栈处理，有可能产生堆栈溢出的情况，会对执行效率有一定的影响。</p> 
<p>循环<br> 优点：结构检点，速度快；<br> 缺点：不能解决全部问题，有些问题适合于用递归来解决不适合用循环解决。</p> 
<h5><a id="2_13"></a>2.顺序表和链表的比较</h5> 
<p>从 存取方式、 逻辑结构和物理结构、 查找插入和删除操作、空间分配四个方面分别做比较即可。</p> 
<h5><a id="3_17"></a>3.头指针和头结点的区别</h5> 
<p>头指针：是指向第一个结点存储位置的指针，具有表示作用，头指针是链表的必要元素，无论链表是否为空，头指针都存在。</p> 
<p>头结点：是放在第一个元素结点之前，便于在第一个元素结点之前进行插入和删除的操作，头结点不是链表的必须元素，可有可无，头结点的数据域也可以不存储任何信息。</p> 
<h5><a id="4_23"></a>4.如何区分循环队列是队满还是队空？</h5> 
<p>①牺牲一个单元来区分队满和队空。<br> 队空就是Q.front == Q.rear<br> 队满就是(Q.rear+1)%Maxsize == Q.front</p> 
<p>②增设数据成员元素<br> 队空Q.size<mark>0<br> 队满Q.size</mark>Maxsize</p> 
<p>③标记上一次是入队还是出队<br> 若是入队flag=1，此时出现Q.front<mark>Q.rear，那么即为队满<br> 若是出队flag=0，此时出现Q.front</mark>Q.rear，那么即为队空</p> 
<h5><a id="5_37"></a>5.栈在通过后缀表达式求值的算法思想</h5> 
<p>但凡出现左括号，做入栈操作，否则做以下操作：<br> 是否为空？与栈顶元素是否匹配？</p> 
<p>表达式检验结束后，还要检查栈中是否还有元素。</p> 
<h5><a id="6_44"></a>6.栈在递归中的应用</h5> 
<p>在递归函数中，每次函数调用都会创建一个新的函数调用帧（frame），这个帧包含了函数的局部变量、参数值以及函数返回地址等信息。<br> 当函数调用自身（递归调用）时，每次都会创建一个新的函数调用帧。这些函数调用帧被存储在内存中的栈数据结构中，这就是所谓的调用栈（call stack）。</p> 
<p>当递归函数开始执行时，会一直递归调用自身，每次递归调用都会将一个新的函数调用帧压入调用栈中。<br> 当递归条件不再满足，函数开始返回时，会从栈顶依次弹出函数调用帧，并执行相应的返回操作，直到栈为空，整个递归过程结束。</p> 
<h5><a id="7_52"></a>7.队列在层次遍历中的作用</h5> 
<p>遇到某类信息需要逐层/逐行处理时，往往是在处理当前层或当前行时就对下一层或下一行做预处理，把处理顺序安排好，待当前层或当前行处理完毕，就可以处理下一层或下一行。</p> 
<p>二叉树的层序遍历、广度优先搜索、任务调度、消息队列、缓冲池、批处理系统。</p> 
<h5><a id="8_58"></a>8.队列在计算机系统中的应用</h5> 
<ol><li><strong>任务调度和作业管理：</strong> 操作系统使用队列来管理和调度各种任务和作业。例如，多任务操作系统可以使用队列来安排进程的执行顺序，确保按照优先级和其他调度策略执行任务。</li><li><strong>I/O请求管理：</strong> 计算机系统中的I/O设备通常会产生大量的请求，如磁盘I/O请求、网络数据包等。队列被广泛应用于管理这些请求，以便按照请求到达的顺序来处理它们。</li><li><strong>消息传递和事件处理：</strong> 在事件驱动的系统中，队列用于管理事件和消息的处理顺序。例如，图形用户界面（GUI）应用程序可以使用队列来处理用户输入事件、定时器事件等。</li><li><strong>网络数据包排队：</strong> 在网络系统中，路由器和交换机使用队列来缓冲传入和传出的数据包。这些队列可以帮助调节网络流量，并确保数据包按照一定的优先级和服务质量要求被处理。</li><li><strong>缓存系统：</strong> 队列常被用于实现缓存系统，例如最近最少使用（LRU）缓存算法。在缓存满时，新的数据项可以被放入队列，而最久未使用的数据项可以从队列的头部被移除。</li><li><strong>并发编程：</strong> 在多线程和并发编程中，队列常被用于实现线程间的通信和同步。例如，生产者-消费者模型中，一个线程（生产者）向队列中放入数据，而另一个线程（消费者）则从队列中取出数据进行处理。</li><li><strong>日志和消息处理系统：</strong> 队列可用于实现日志和消息处理系统，用于收集、存储和处理系统产生的日志和消息。通过将日志和消息放入队列中，可以实现异步处理和解耦。</li><li><strong>批处理系统：</strong> 在数据处理领域，队列被广泛用于构建批处理系统。数据处理任务可以被放入队列中，然后由后台任务逐个处理，从而提高处理效率。</li></ol> 
<h5><a id="9_69"></a>9.矩阵的压缩存储</h5> 
<p>矩阵的压缩存储是一种优化存储矩阵的方法，特别是当矩阵中有大量的重复值或者是稀疏矩阵（大部分元素为零）时。<br> 它的主要目的是<strong>减少内存占用</strong>，提高<strong>存储和处理效率</strong>。</p> 
<p>行压缩存储、列压缩存储、对角线压缩存储、十字链表法。</p> 
<h5><a id="10_76"></a>10.串的模式匹配</h5> 
<p><strong>朴素算法（Naive Algorithm）：</strong><br> 也称为暴力匹配算法，它是最简单直观的模式匹配算法。它的思路是在文本串中从头到尾逐个字符地与模式串进行比较，直到找到匹配或者遍历完整个文本串。<br> 朴素算法的时间复杂度为 O(m*n)，其中 m 是模式串的长度，n 是文本串的长度。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 朴素算法函数</span>
<span class="token keyword">int</span> <span class="token function">naiveSearch</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>text<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>pattern<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> textLength <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> patternLength <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> textLength <span class="token operator">-</span> patternLength<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> j<span class="token punctuation">;</span>
        <span class="token comment">// 检查文本串中从第 i 个位置开始的子串是否与模式串匹配</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> patternLength<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>text<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span> <span class="token operator">!=</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 如果当前字符不匹配，则跳出内循环</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果内循环完全匹配了模式串，则返回匹配位置</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> patternLength<span class="token punctuation">)</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 没有找到匹配的子串，返回 -1</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>Knuth-Morris-Pratt 算法（KMP Algorithm）：</strong><br> KMP 算法是一种高效的模式匹配算法，它利用了模式串中已经匹配的信息来避免不必要的比较。<br> 通过构建部分**匹配表（Partial Match Table）**来记录模式串中的前缀和后缀的最长公共部分，KMP 算法能够在 O(n+m) 的时间复杂度内完成匹配，其中 n 是文本串的长度，m 是模式串的长度。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 构建部分匹配表</span>
<span class="token keyword">void</span> <span class="token function">buildPartialMatchTable</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>pattern<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>table<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> patternLength <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>
    table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 首字符的部分匹配值总是 0</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 用于记录当前匹配的长度</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> patternLength<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果当前字符和当前匹配长度处的字符相同，匹配长度加1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pattern<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>length<span class="token punctuation">;</span>
            table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> length<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 如果当前字符和当前匹配长度处的字符不同，根据部分匹配表更新当前匹配长度</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                length <span class="token operator">=</span> table<span class="token punctuation">[</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>i<span class="token punctuation">;</span> <span class="token comment">// 回退一步重新尝试匹配</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span>   table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// KMP算法函数</span>
<span class="token keyword">int</span> <span class="token function">KMP</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>text<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>pattern<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> textLength <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> patternLength <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>table <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>patternLength <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">buildPartialMatchTable</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> table<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// i用于遍历文本串，j用于遍历模式串</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> textLength<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token operator">++</span>i<span class="token punctuation">;</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> patternLength<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">free</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> i <span class="token operator">-</span> j<span class="token punctuation">;</span> <span class="token comment">// 匹配成功，返回匹配位置的起始索引</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> textLength <span class="token operator">&amp;&amp;</span> text<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> pattern<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                j <span class="token operator">=</span> table<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 根据部分匹配表更新模式串的起始位置</span>
            <span class="token keyword">else</span>
                <span class="token operator">++</span>i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 未找到匹配，返回 -1</span>
<span class="token punctuation">}</span>

调用<span class="token function">KMP</span><span class="token punctuation">(</span>text<span class="token punctuation">,</span>pattern<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//text文本串，pattern模式串</span>
</code></pre> 
<h5><a id="11_156"></a>11.如何由遍历序列构造一棵二叉树</h5> 
<p>先序+中序</p> 
<p>后序+中序</p> 
<p>层序+中序</p> 
<h5><a id="12_164"></a>12.线索二叉树的概念</h5> 
<p>对于n个结点的二叉树，在二叉链存储结构中有<strong>n+1</strong>个空链域，利用这些空链域存放在某种遍历次<br> 序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</p> 
<p><strong>注意</strong>：线索链表解决了无法直接找到该结点在某种遍历序列中的前驱和后继结点的问题，解决了二叉链表找左、右孩子困难的问题。</p> 
<h5><a id="134_171"></a>13.树的4种存储方式</h5> 
<p>①<strong>双亲表示法</strong>：这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示<br> 其双亲结点在数组中的位置。结构体为【[data]，[parent]】。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>  <span class="token comment">// 父节点的索引</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">addChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> parentIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> childData<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> childIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 查找一个空闲的位置存储新的子节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_NODES<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            childIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>childIndex <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        tree<span class="token punctuation">[</span>childIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> childData<span class="token punctuation">;</span>
        tree<span class="token punctuation">[</span>childIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parentIndex<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No space to add child.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该存储结构利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的<br> 双亲结点，<strong>但</strong>求结点的孩子时需要遍历整个结构。</p> 
<p>②<strong>孩子表示法</strong>：将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时n 个结点<br> 就有n 个孩子链表（叶子结点的孩子链表为空表），这种存储方式寻找子女的操作非常直接，而<br> 寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 定义树节点结构</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>firstChild<span class="token punctuation">;</span>  <span class="token comment">// 指向第一个孩子节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>nextSibling<span class="token punctuation">;</span> <span class="token comment">// 指向右兄弟节点</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//链式结构</span>
</code></pre> 
<p>③<strong>孩子兄弟表示法</strong>：二叉树表示法，使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 定义树节点结构</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>firstChild<span class="token punctuation">;</span>  <span class="token comment">// 指向第一个孩子节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>nextSibling<span class="token punctuation">;</span>  <span class="token comment">// 指向右兄弟节点</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//结构相同，但是写法不同</span>
</code></pre> 
<p>④<strong>左右孩子表示法</strong>：用于二叉树，每个结点包括三部分内容：结点值、指向结点左孩子结点的指针，及指向结点右孩子结点的指针。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 定义树节点结构</span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>LeftChild<span class="token punctuation">;</span>  <span class="token comment">// 指向结点左孩子节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token operator">*</span>RightChild<span class="token punctuation">;</span>  <span class="token comment">// 指向结点右孩子节点</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="14_239"></a>14.平衡二叉树</h5> 
<p>为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任<br> 意结点的左、右子树高度差的绝对值不超过1, 将这样的二叉树称为平衡二叉树(Balanced Binary<br> Tree), 简称平衡树。<br> 定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点<br> 的平衡因子的值只可能是-1 、0 或1 。</p> 
<h5><a id="15dijkstra_247"></a>15.dijkstra算法</h5> 
<p>一种用于计算图中<strong>单源最短路径</strong>的贪心算法。Dijkstra 算法基于贪心策略，每次选择当前距离起点最近的节点作为下一个中间节点，并更新与该节点相邻的节点的最短路径。</p> 
<p>基本步骤：<br> 1.初始化距离数组 <code>dist</code> 和标记数组 <code>visited</code>，用于记录每个节点到起点的最短距离和节点是否已经访问过。<br> 2.将起点的最短距离设为0，并标记起点为已访问。<br> 3.对于起点相邻的所有节点，更新它们的最短距离为起点到它们的距离，并标记它们为已访问。<br> 4.重复以下步骤，直到所有节点都被访问过：<br> a. 从未访问的节点中选择距离起点最近的节点。<br> b. 对于选中的节点，更新其相邻节点的最短距离为起点到该节点的距离加上选中节点的最短距离。<br> c. 将选中的节点标记为已访问。<br> 5.当所有节点都被访问过后，距离数组 <code>dist</code> 中存储的即为起点到每个节点的最短距离。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 计算未访问节点中距离起点最近的节点的索引</span>
<span class="token keyword">int</span> <span class="token function">minDistance</span><span class="token punctuation">(</span><span class="token keyword">int</span> dist<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> visited<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> min <span class="token operator">=</span> INF<span class="token punctuation">,</span> min_index<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> min<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            min <span class="token operator">=</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
            min_index <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> min_index<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 使用 Dijkstra 算法计算单源最短路径</span>
<span class="token keyword">void</span> <span class="token function">dijkstra</span><span class="token punctuation">(</span><span class="token keyword">int</span> graph<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> src<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> dist<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// 存储从源到每个顶点的最短距离</span>
    <span class="token keyword">bool</span> visited<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 记录每个顶点是否已被访问</span>

    <span class="token comment">// 初始化所有距离为无穷大，所有节点均未被访问</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
        dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> INF<span class="token punctuation">;</span>
        visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  <span class="token comment">//可以用memset(dist, INF, sizeof(dist));替换</span>

    dist<span class="token punctuation">[</span>src<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 源节点到自身的距离为0</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> count <span class="token operator">&lt;</span> V <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> count<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token function">minDistance</span><span class="token punctuation">(</span>dist<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 选取未访问节点中距离最近的节点</span>
        visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 标记该节点为已访问</span>

        <span class="token comment">// 更新相邻节点的最短距离</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">!=</span> INF <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span>
                dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">printSolution</span><span class="token punctuation">(</span>dist<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 打印最短路径</span>
<span class="token keyword">void</span> <span class="token function">printSolution</span><span class="token punctuation">(</span><span class="token keyword">int</span> dist<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Vertex \t Distance from Source\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d \t %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="16Floyd_310"></a>16.Floyd算法</h5> 
<p>一种用于求解所有节点对之间最短路径的动态规划算法。它可以处理带权重的有向图或无向图，即使存在<strong>负权边或负权环</strong>，也能正确计算出最短路径。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">floyd</span><span class="token punctuation">(</span><span class="token keyword">int</span> graph<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_NODES<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    <span class="token comment">// 逐步考察每一个中间节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//枚举每一个中间结点</span>
        <span class="token comment">// 以结点 i 为起点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 以结点 j 为终点</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果从结点i经过结点k再到结点j的路径更短，则更新最短路径</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> graph<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> graph<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="17Prim_333"></a>17.Prim算法</h5> 
<p>一种用于求解最小生成树的贪心算法。最小生成树是一棵包含图中所有节点且边权重之和最小的树。Prim算法从一个初始节点开始，逐步选取与当前生成树相连的权重最小的边，直到所有节点都被加入到生成树中为止。</p> 
<p>Prim算法的基本思想：<br> 1.选择一个初始节点作为生成树的根节点，并将其加入生成树中。<br> 2.在生成树与剩余节点之间的边中选择权重最小的边，并将其加入生成树。<br> 3.重复步骤2，直到所有节点都被加入到生成树中。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">prim</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">bool</span> visited<span class="token punctuation">[</span>MAX_NODES<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 记录已加入生成树的节点</span>
    visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> MST<span class="token punctuation">[</span>MAX_NODES<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 最小生成树的边集合</span>
    <span class="token keyword">int</span> edgeCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>edgeCount <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> minEdge <span class="token operator">=</span> INF<span class="token punctuation">;</span>
        <span class="token keyword">int</span> minNode <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> node <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> node <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> node<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> neighbor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> neighbor <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> neighbor<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minEdge<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        minEdge <span class="token operator">=</span> graph<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">[</span>neighbor<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        minNode <span class="token operator">=</span> neighbor<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minNode <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            MST<span class="token punctuation">[</span>edgeCount<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> minNode<span class="token punctuation">;</span>
            MST<span class="token punctuation">[</span>edgeCount<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> minEdge<span class="token punctuation">;</span>
            edgeCount<span class="token operator">++</span><span class="token punctuation">;</span>
            visited<span class="token punctuation">[</span>minNode<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 输出最小生成树的边集合</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Minimum Spanning Tree edges:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d - %d\n"</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> MST<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="18Kraskal_377"></a>18.Kraskal算法</h5> 
<p>一种用于求解最小生成树（Minimum Spanning Tree，MST）的贪心算法。其基本思想是从图中所有边中选择权重最小的边，然后逐步添加边，直到所有的顶点都被连接为止。在添加边的过程中，要确保不形成环路，因为最小生成树是一个树，不应该包含环路。</p> 
<p>以下是Kruskal算法的基本步骤：<br> 1.将图中的所有边按照权重进行排序。<br> 2.初始化一个空的最小生成树。<br> 3.依次遍历排好序的边，每次选择一条边，判断加入后是否形成环路。若不形成环路，则将该边加入最小生成树。<br> 4.重复步骤3，直到最小生成树中包含了所有的顶点。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// Kruskal算法</span>
<span class="token keyword">void</span> <span class="token function">KruskalMST</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Graph</span><span class="token operator">*</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> V <span class="token operator">=</span> graph<span class="token operator">-&gt;</span>V<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">Edge</span> result<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 存储最小生成树的边</span>
    <span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 用于result数组的索引</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 用于遍历graph-&gt;edge数组</span>
    <span class="token keyword">int</span> parent<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 用于记录顶点的父节点</span>
    <span class="token comment">// 初始化parent数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> parent<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 将图的所有边按照权重进行排序</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>graph<span class="token operator">-&gt;</span>edge<span class="token punctuation">,</span> graph<span class="token operator">-&gt;</span>E<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>graph<span class="token operator">-&gt;</span>edge<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">struct</span> <span class="token class-name">Edge</span><span class="token operator">*</span> a1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span><span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">Edge</span><span class="token operator">*</span> b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Edge</span><span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">;</span>
        <span class="token keyword">return</span> a1<span class="token operator">-&gt;</span>weight <span class="token operator">&gt;</span> b1<span class="token operator">-&gt;</span>weight<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 遍历排序后的边数组，构建最小生成树</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">&lt;</span> V <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> graph<span class="token operator">-&gt;</span>E<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">struct</span> <span class="token class-name">Edge</span> next_edge <span class="token operator">=</span> graph<span class="token operator">-&gt;</span>edge<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> next_edge<span class="token punctuation">.</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> next_edge<span class="token punctuation">.</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果不形成环路，则加入最小生成树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            result<span class="token punctuation">[</span>e<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> next_edge<span class="token punctuation">;</span>
            <span class="token function">Union</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 输出最小生成树的边</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Edges in the minimum spanning tree:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> minimumCost <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> e<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d - %d: %d\n"</span><span class="token punctuation">,</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>src<span class="token punctuation">,</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>dest<span class="token punctuation">,</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span>
        minimumCost <span class="token operator">+=</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Minimum cost of MST: %d\n"</span><span class="token punctuation">,</span> minimumCost<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="19_425"></a>19.拓扑排序</h5> 
<p>一种对有向无环图（DAG）进行排序的算法，它使得图中的所有顶点按照一定的顺序排列，使得所有的有向边从前面的顶点指向后面的顶点。如果图中存在环路，则无法进行拓扑排序。</p> 
<p>拓扑排序的基本思想：<br> 不断地从图中选择入度为0的顶点，并删除以该顶点为起点的边，直到图中所有的顶点都被选择完毕为止。如果图中有顶点无法被选择，则说明图中存在环路，无法进行拓扑排序。</p> 
<p>拓扑排序的算法步骤：<br> 1.初始化一个队列，并将所有入度为0的顶点加入队列。<br> 2.不断地从队列中取出顶点，并将该顶点输出到拓扑排序结果中。<br> 3.对于每个被取出的顶点，遍历其所有邻接顶点，将这些邻接顶点的入度减1。若某个邻接顶点的入度减为0，则将其加入队列。<br> 4.重复步骤2和步骤3，直到队列为空。</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 拓扑排序算法</span>
<span class="token keyword">void</span> <span class="token function">topologicalSort</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Graph</span><span class="token operator">*</span> graph<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> V <span class="token operator">=</span> graph<span class="token operator">-&gt;</span>V<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> indegree <span class="token operator">=</span> graph<span class="token operator">-&gt;</span>indegree<span class="token punctuation">;</span>
    <span class="token comment">// 初始化一个队列</span>
    <span class="token keyword">int</span> queue<span class="token punctuation">[</span>MAX_VERTICES<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> front <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> rear <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 将入度为0的顶点加入队列</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 记录拓扑排序结果</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> topologicalOrder <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>V <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>front <span class="token operator">&lt;=</span> rear<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> vertex <span class="token operator">=</span> queue<span class="token punctuation">[</span>front<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 出队列</span>
        topologicalOrder<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> vertex<span class="token punctuation">;</span>
        <span class="token comment">// 遍历顶点的邻接顶点，减少其入度</span>
        <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token operator">*</span> temp <span class="token operator">=</span> graph<span class="token operator">-&gt;</span>adjList<span class="token punctuation">[</span>vertex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            indegree<span class="token punctuation">[</span>temp<span class="token operator">-&gt;</span>vertex<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>temp<span class="token operator">-&gt;</span>vertex<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                queue<span class="token punctuation">[</span><span class="token operator">++</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>vertex<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            temp <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 输出拓扑排序结果</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Topological Sort Order: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> topologicalOrder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="20BB_477"></a>20.B树和B+树</h5> 
<p><strong>B树（B-tree）</strong>：</p> 
<ul><li>B树是一种平衡的多路搜索树，其中每个节点可以包含多个子节点。</li><li>每个节点中的关键字按非递减顺序排列，且节点中关键字的数量至少等于子节点数目的一半。</li><li>所有叶子节点位于同一层，并且没有数据的重复。</li><li>B树的节点在插入和删除操作后可以进行自平衡，使得树保持平衡状态。</li></ul> 
<p><strong>B+树（B±tree）</strong>：</p> 
<ul><li>B+树是在B树的基础上进行了改进，它与B树相比有更大的节点容量。</li><li>B+树的内部节点不存储数据，只存储关键字和指向子节点的指针。</li><li>所有数据都存储在叶子节点中，叶子节点之间使用指针连接成一个有序链表，使得范围查询更加高效。</li><li>B+树的叶子节点形成了一个有序链表，可以进行范围查询等操作。</li></ul> 
<p>B+树通常被认为是一种更适合数据库索引的数据结构，因为它的数据存储方式更加有序，可以更快地进行范围查询和顺序遍历。</p> 
<h5><a id="21_495"></a>21.哈希表的概念、构造方法，哈希冲突的解决方法</h5> 
<p>哈希表基于哈希函数（Hash Function）实现，将关键字映射到表中的位置。<br> 通常，哈希函数将关键字转换为固定长度的哈希值，然后根据哈希值确定关键字在表中的位置。</p> 
<p>构造方法：<br> 1.<strong>选择哈希函数</strong>：选择合适的哈希函数是构造哈希表的第一步。哈希函数应该将关键字均匀地分布到哈希表中的位置，以避免冲突。<br> 2.<strong>确定哈希表大小</strong>：确定哈希表的大小，通常选择素数作为表的大小，以减少冲突的可能性。<br> 3.<strong>解决冲突</strong>：在确定了哈希函数和哈希表大小后，需要解决哈希冲突的问题。常见的冲突解决方法包括开放定址法（如线性探测和二次探测）、链地址法和再哈希法等。</p> 
<p><strong>哈希冲突的解决方法</strong>：</p> 
<ol><li><strong>开放定址法</strong>：当发生冲突时，通过探测序列来找到下一个可用的位置。常见的探测方法有线性探测、二次探测和双重散列。</li><li><strong>链地址法</strong>：将哈希表的每个位置都连接一个链表，当发生冲突时，将冲突的元素添加到链表中。这种方法需要在表中存储指向链表头的指针。</li><li><strong>再哈希法</strong>：当发生冲突时，使用另一个哈希函数对冲突的关键字进行重新哈希，直到找到空闲位置为止。通常需要多个哈希函数。</li></ol> 
<h5><a id="22_511"></a>22.内部排序辨析</h5> 
<p>内部排序是指对数据集合（通常是存储在内存中）进行排序的过程。<br> 在内部排序中，整个数据集合可以一次性加载到内存中，并且所有的排序操作都在内存中进行，因此也称为内存排序。</p> 
<ol><li><strong>冒泡排序（Bubble Sort）</strong>：依次比较相邻的元素，将较大（或较小）的元素逐步交换至右侧，直到整个序列有序。时间复杂度：O(n^2) 空间复杂度：O(1)</li><li><strong>选择排序（Selection Sort）</strong>：每次从未排序的部分选择最小（或最大）的元素，放置到已排序部分的末尾。时间复杂度：O(n^2) 空间复杂度：O(1)</li><li><strong>插入排序（Insertion Sort）</strong>：将未排序的元素逐个插入到已排序部分的合适位置，直到整个序列有序。时间复杂度：O(n^2) 空间复杂度：O(1)</li><li><strong>希尔排序（Shell Sort）</strong>：是插入排序的改进版本，通过将序列分成多个子序列进行排序，然后逐步缩小子序列的长度，最终完成排序。<br> 时间复杂度：O(n log n)~O(n^2) 空间复杂度：O(1)</li><li><strong>归并排序（Merge Sort）</strong>：采用分治法，将序列分成两个子序列，分别进行排序，然后将排好序的子序列合并成一个有序序列。时间复杂度：O(n log n) 空间复杂度：O(n)</li><li><strong>快速排序（Quick Sort）</strong>：采用分治法，通过选择一个基准元素，将序列分成小于基准的部分和大于基准的部分，然后对这两部分分别进行递归排序。时间复杂度：O(n log n) 空间复杂度：O(log n) ~ O(n)</li><li><strong>堆排序（Heap Sort）</strong>：利用堆这种数据结构进行排序，通过构建最大堆或最小堆来实现排序。时间复杂度：O(n log n) 空间复杂度：O(1)</li></ol> 
<h5><a id="23_525"></a>23.外部排序辨析</h5> 
<p>外部排序是一种在数据量过大无法全部加载到内存中进行排序时使用的排序方法。<br> 它通常涉及将数据分成适当大小的块，然后在内存中对每个块进行排序，最后将排序后的块合并成一个有序序列。<br> 外部排序的核心思想是<strong>尽量减少</strong>对外部存储的访问次数，以提高排序效率。</p> 
<ol><li><strong>多路归并排序</strong>： 
  <ul><li><strong>基本思想</strong>：将数据分成多个块，每个块都能够全部加载到内存中进行排序。然后利用归并排序的思想，将多个有序块合并成一个更大的有序块，直到整个数据集合排序完成。</li><li><strong>优点</strong>：适用于大规模数据的排序，且可以利用多个磁盘进行并行排序。</li><li><strong>缺点</strong>：需要额外的磁盘空间来存储排序后的块，且合并过程可能会产生额外的磁盘读写开销。</li></ul> </li><li><strong>置换-选择排序</strong>： 
  <ul><li><strong>基本思想</strong>：将数据分成多个块，并在内存中维护一个“缓冲区”，用于存储每个块中的一部分数据。然后在缓冲区中选择最小（或最大）的元素，输出到外部存储，直到所有块中的数据都被输出。</li><li><strong>优点</strong>：不需要额外的磁盘空间来存储排序后的块，适用于数据集合无法全部加载到内存中的情况。</li><li><strong>缺点</strong>：可能需要多次访问外部存储，造成较高的磁盘读写开销。</li></ul> </li><li><strong>多路平衡归并排序</strong>： 
  <ul><li><strong>基本思想</strong>：类似于多路归并排序，但是在归并过程中需要保持各个块之间的平衡，以提高归并的效率。</li><li><strong>优点</strong>：能够更好地利用外部存储的空间，减少归并过程中的磁盘读写开销。</li><li><strong>缺点</strong>：实现较为复杂，需要维护块之间的平衡。</li></ul> </li><li><strong>外部快速排序</strong>： 
  <ul><li><strong>基本思想</strong>：类似于快速排序，但是在划分过程中需要将数据分成适当大小的块，并在内存中对每个块进行排序。然后利用归并操作将排序后的块合并成一个有序序列。</li><li><strong>优点</strong>：基于快速排序，具有较好的平均时间复杂度。</li><li><strong>缺点</strong>：可能会产生较大的磁盘读写开销，特别是在数据分布不均匀的情况下。</li></ul> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88d4cedec3bbaf103f562dcfe3e019d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spring boot集成redis实现共享存储session</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52c8b08cb3b849781efde6a28326e789/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决IDEA右侧的maven窗口消失</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>