<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简易的自定义Shell实现 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简易的自定义Shell实现" />
<meta property="og:description" content="简易自定义Shell实现 1. 程序概述2. 主要函数解析2.1 getcommand2.2 commandsplit2.3 execute2.4 builtin 3. 完整程序 1. 程序概述 首先，让我们了解一下这个自定义Shell的主要功能和结构。该Shell具有以下特点：
基本的命令解析和执行内建命令支持（cd、export、echo）获取用户名、主机名和当前工作目录显示错误代码传递和显示 2. 主要函数解析 2.1 getcommand int getcommand(char* command) { printf(&#34;[%s%s %s]# &#34;,getUsername(),getHostname(),getPWDname()); char* r = fgets(command,MAXIN,stdin); if(r == NULL) return 0; command[strlen(command)-1] = &#39;\0&#39;; return 1; } 此函数用于获取用户输入的命令，并将其存储在指定的字符数组中。它显示包含用户名、主机名和当前工作目录的命令提示符。
2.2 commandsplit void commandsplit(char* in, char* out[]) { int argc = 0; out[argc&#43;&#43;] = strtok(in,SEPARATOR); while( out[argc&#43;&#43;] = strtok(NULL,SEPARATOR)); return ; } commandsplit 函数将输入的命令字符串分割成命令和参数的数组，并用 SEPARATOR 定义的分隔符进行切割。
2.3 execute void execute(char* agrv[]) { pid_t id = fork(); if(id == 0) { execvp(agrv[0],agrv); exit(1); } else { int status = 0; pid_t rid = waitpid(id,&amp;status,0); if(rid &gt; 0 ) { lostcode = WEXITSTATUS(status); } } } execute 函数使用 fork 创建子进程，并在子进程中执行用户输入的命令。父进程等待子进程执行完成，并获取子进程的退出状态。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8fce0d82f3fda59d7a5f9f47f2391bc3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-14T11:09:59+08:00" />
<meta property="article:modified_time" content="2023-12-14T11:09:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简易的自定义Shell实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>简易自定义Shell实现</h4> 
 <ul><li><a href="#1__2" rel="nofollow">1. 程序概述</a></li><li><a href="#2__9" rel="nofollow">2. 主要函数解析</a></li><li><ul><li><a href="#21_getcommand_10" rel="nofollow">2.1 getcommand</a></li><li><a href="#22_commandsplit_23" rel="nofollow">2.2 commandsplit</a></li><li><a href="#23_execute_35" rel="nofollow">2.3 execute</a></li><li><a href="#24_builtin_58" rel="nofollow">2.4 builtin</a></li></ul> 
  </li><li><a href="#3__79" rel="nofollow">3. 完整程序</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__2"></a>1. 程序概述</h2> 
<p>首先，让我们了解一下这个自定义Shell的主要功能和结构。该Shell具有以下特点：</p> 
<ol><li>基本的命令解析和执行</li><li>内建命令支持（cd、export、echo）</li><li>获取用户名、主机名和当前工作目录显示</li><li>错误代码传递和显示</li></ol> 
<h2><a id="2__9"></a>2. 主要函数解析</h2> 
<h3><a id="21_getcommand_10"></a>2.1 getcommand</h3> 
<pre><code>int getcommand(char* command)
{
  printf("[%s%s %s]# ",getUsername(),getHostname(),getPWDname());
  char* r = fgets(command,MAXIN,stdin);
  if(r == NULL) return 0;
  command[strlen(command)-1] = '\0';
  return 1; 
}
</code></pre> 
<p>此函数用于获取用户输入的命令，并将其存储在指定的字符数组中。它显示包含用户名、主机名和当前工作目录的命令提示符。</p> 
<h3><a id="22_commandsplit_23"></a>2.2 commandsplit</h3> 
<pre><code>void commandsplit(char* in, char* out[])
{
  int argc = 0;
  out[argc++] = strtok(in,SEPARATOR);
  while( out[argc++] = strtok(NULL,SEPARATOR));
 return ; 
}
</code></pre> 
<p>commandsplit 函数将输入的命令字符串分割成命令和参数的数组，并用 SEPARATOR 定义的分隔符进行切割。</p> 
<h3><a id="23_execute_35"></a>2.3 execute</h3> 
<pre><code>void execute(char* agrv[])
{
    pid_t id = fork();
    if(id == 0)
    {
     execvp(agrv[0],agrv); 
      exit(1);
    }
    else
    {
      int status = 0;
      pid_t rid = waitpid(id,&amp;status,0);
      if(rid &gt; 0 ) 
      {
          lostcode = WEXITSTATUS(status);
      }
    }
}
</code></pre> 
<p>execute 函数使用 fork 创建子进程，并在子进程中执行用户输入的命令。父进程等待子进程执行完成，并获取子进程的退出状态。</p> 
<h3><a id="24_builtin_58"></a>2.4 builtin</h3> 
<pre><code>int builtin(char* argc[])
{
    if(strcmp(argc[0],"cd") == 0)
    {
      
      cd(argc);
      return 1;
    }
    else
    {
        printf("%s\n",getenv(e));
        return 1;
    }
    return 0;
}

</code></pre> 
<p>builtin 函数用于处理内建命令，如 cd、export 和 echo。它通过比较命令字符串来确定是否为内建命令，并调用相应的功能函数执行。</p> 
<h2><a id="3__79"></a>3. 完整程序</h2> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

#define MAXIN 100
#define SIZE 100
#define SEPARATOR " "

int lostcode = 0;
char cwd[1024];  
char env[1024];

char* getUsername()
{
  return getenv("USER");
}
char* getHostname()
{
  return getenv("HOSTNAME");
}
char* getPWDname()
{
  return getenv("PWD");
}
int getcommand(char* command)
{
  printf("[%s%s %s]# ",getUsername(),getHostname(),getPWDname());
  char* r = fgets(command,MAXIN,stdin);
  if(r == NULL) return 0;
  command[strlen(command)-1] = '\0';
  return 1; 
}
void commandsplit(char* in,char* out[])
{
  int argc = 0;
  out[argc++] = strtok(in,SEPARATOR);
  while( out[argc++] = strtok(NULL,SEPARATOR));
  return ; 
}
void execute(char* agrv[])
{
    pid_t id = fork();
    if(id == 0)
    {
     execvp(agrv[0],agrv); 
      exit(1);
    }
    else
    {
      int status = 0;
      pid_t rid = waitpid(id,&amp;status,0);
      if(rid &gt; 0 ) 
      {
          lostcode = WEXITSTATUS(status);
      }
    }
}
void cd(char* argc[])
{
  char* path = argc[1];
  chdir(path);
  getcwd(path,1024); 
  sprintf(cwd,"PWD=%s",path);
  putenv(cwd);
}
int builtin(char* argc[])
{
    if(strcmp(argc[0],"cd") == 0)
    {
      cd(argc);
      return 1;
    }
    else if(strcmp(argc[0],"export") == 0)
    {
      if(argc[1] == NULL) return 1;
      strcpy(env,argc[1]);  
        
        putenv(env);
        return 1;
    }
    else if(strcmp(argc[0],"echo") == 0)
    {
      char* e = argc[1]+1;
      if(strcmp(e,"?") == 0)
      {
        printf("%d\n",lostcode);
        return 1;
      }
      else
      {
          printf("%s\n",getenv(e));
          return 1;
      }
    }
    return 0;
}
int main()
{
  while(1)
  {
      char command[MAXIN];
    //获取命令
    if(!getcommand(command)) return 1;
    //字符串分隔
    char* argv[SIZE];
    commandsplit(command,argv);
    //是否是内建命令
    int n = builtin(argv);
    if(n) continue;
    //指令执行
    execute(argv);  
  }
  return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/844b4d4ce5434dcf6c27977acffd255f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">快递鸟「物流导盲犬」助力鞋服头部企业客户全链路物流数字化升级</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b622added38729cedd7217dc7bd72fd1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu上安装Chrome浏览器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>