<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pandas学习之一：excel转字典 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pandas学习之一：excel转字典" />
<meta property="og:description" content="1.to_dict() 函数基本语法 DataFrame.to_dict (self, orient=&#39;dict&#39; , into= ) --- 官方文档 函数种只需要填写一个参数：orient 即可 ，但对于写入orient的不同，字典的构造方式也不同，官网一共给出了6种，并且其中一种是列表类型：
orient =&#39;dict&#39;，是函数默认的，转化后的字典形式：{column(列名) : {index(行名) : value(值) )}}；orient =&#39;list&#39; ，转化后的字典形式：{column(列名) :{[ values ](值)}};orient =&#39;series&#39; ，转化后的字典形式：{column(列名) : Series (values) (值)};orient =&#39;split&#39; ，转化后的字典形式：{&#39;index&#39; : [index]，‘columns&#39; :[columns]，’data‘ : [values]};orient =&#39;records&#39; ，转化后是 list形式：[{column(列名) : value(值)}......{column:value}];orient =&#39;index&#39; ，转化后的字典形式：{index(值) : {column(列名) : value(值)}}; 备注：
1，上面中 value 代表数据表中的值，column表示列名，index 表示行名，如下图所示：
2，{ }表示字典数据类型，字典中的数据是以 {key : value} 的形式显示，是键名和键值一一对应形成的。
2，关于6种构造方式进行代码实例 六种构造方式所处理 DataFrame 数据是统一的，如下：
&gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; df =pd." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9cd57149530a77d407088b28432fef6d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-08T15:32:42+08:00" />
<meta property="article:modified_time" content="2022-03-08T15:32:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pandas学习之一：excel转字典</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong><code>1.to_dict()</code> 函数基本语法</strong></h2> 
<blockquote> 
 <code>DataFrame.to_dict</code>  
 <strong>(<em>self</em>,</strong>  
 <em>orient='dict'</em> 
 <strong>,</strong>  
 <em>into=</em> 
 <strong>)</strong> --- 官方文档 
</blockquote> 
<p>函数种只需要填写一个参数：<strong>orient</strong> 即可 ，但对于写入orient的不同，字典的构造方式也不同，官网一共给出了6种，并且其中一种是列表类型：</p> 
<ul><li><strong>orient ='dict'</strong>，是函数默认的，转化后的字典形式：{column(列名) : {index(行名) : value(值) )}}；</li><li><strong>orient ='list'</strong> ，转化后的字典形式：{column(列名) :{[ values ](值)}};</li><li><strong>orient ='series'</strong> ，转化后的字典形式：{column(列名) : Series (values) (值)};</li><li><strong>orient ='split'</strong> ，转化后的字典形式：{'index' : [index]，‘columns' :[columns]，’data‘ : [values]};</li><li><strong>orient ='records'</strong> ，转化后是 list形式：[{column(列名) : value(值)}......{column:value}];</li><li><strong>orient ='index'</strong> ，转化后的字典形式：{index(值) : {column(列名) : value(值)}};</li></ul> 
<p>备注：</p> 
<p>1，上面中 <code>value</code> 代表数据表中的值，<code>column</code>表示列名，<code>index</code> 表示行名，如下图所示：</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b2/f4/zDDbfyeZ_o.png"></p> 
<p></p> 
<p>2，{ }表示字典数据类型，字典中的数据是以 <strong>{key : value}</strong> 的形式显示，是键名和键值一一对应形成的。</p> 
<h2><strong>2，关于6种构造方式进行代码实例</strong></h2> 
<p>六种构造方式所处理 <code>DataFrame</code> 数据是统一的，如下：</p> 
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; df =pd.DataFrame({'col_1':[1,2],'col_2':[0.5,0.75]},index =['row1','row2'])
&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75</code></pre> 
<p></p> 
<h4><strong>2.1，orient ='dict' — {column(列名) : {index(行名) : value(值) )}}</strong></h4> 
<p><code>to_dict('list')</code> 时，构造好的字典形式：{第一列的列名:{第一行的行名：value值，第二行行名，value值}，....}；</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; <a href="https://www.zhihu.com/search?q=df.to_dict&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1112971172%7D" rel="nofollow" title="df.to_dict">df.to_dict</a>('dict')
{'col_1': {'row1': 1, 'row2': 2}, 'col_2': {'row1': 0.5, 'row2': 0.75}}</code></pre> 
<p><code>orient = 'dict</code> 可以很方面得到 在<strong>某一列</strong>对应的行名与各值之间的字典数据类型，例如在源数据上面我想得到在<code>col_1</code>这一列行名与各值之间的字典，直接在生成字典查询列名为<code>col_1</code>：</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('dict')['col_1']
{'row1': 1, 'row2': 2}</code></pre> 
<h4><strong>2.2，orient ='list' — {column(列名) :{[ values ](值)}};</strong></h4> 
<p>生成字典中 <code>key</code>为各列名，<code>value</code>为各列对应值的列表</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('list')
{'col_1': [1, 2], 'col_2': [0.5, 0.75]}</code></pre> 
<p><code>orient = 'list'</code> 时，可以很方面得到 在<strong>某一列</strong> 各值所生成的列表集合，例如我想得到<code>col_2</code> 对应值得列表：</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('list')['col_2']
[0.5, 0.75]</code></pre> 
<h4><strong>2.3，orient ='series' — {column(列名) : Series (values) (值)};</strong></h4> 
<p><code>orient ='series'</code> 与 <code>orient = 'list'</code> 唯一区别就是，这里的 <code>value</code> 是 <code>Series数据类型</code>，而前者为<code>列表类型</code></p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('series')
{'col_1': row1    1
row2    2
Name: col_1, dtype: int64, 'col_2': row1    0.50
row2    0.75
Name: col_2, dtype: float64}</code></pre> 
<h4><strong>2.4，orient ='split' — {'index' : [index]，‘columns' :[columns]，’data‘ : [values]};</strong></h4> 
<p><code>orient ='split'</code> 得到三个键值对，列名、行名、值各一个，<code>value</code>统一都是列表形式；</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('split')
{'index': ['row1', 'row2'], 'columns': ['col_1', 'col_2'], 'data': [[1, 0.5], [2, 0.75]]}</code></pre> 
<p><code>orient = 'split'</code> 可以很方面得到 <code>DataFrame<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E8%A1%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1112971172%7D" rel="nofollow" title="数据表">数据表</a></code> 中全部 <strong>列名或者行名</strong> 的列表形式，例如我想得到全部列名：</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('split')['columns']
['col_1', 'col_2']</code></pre> 
<h4><strong>2.5，orient ='records' — [{column:value(值)},{column:value}....{column:value}];</strong></h4> 
<p>注意的是，<code>orient ='records'</code> 返回的数据类型不是 <code>dict</code> ; 而是<code>list</code> 列表形式，由全部列名与每一行的值形成一一对应的映射关系:</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('records')
[{'col_1': 1, 'col_2': 0.5}, {'col_1': 2, 'col_2': 0.75}]</code></pre> 
<p>这个构造方式的好处就是，很容易得到 列名与某一行值形成得字典数据；例如我想要第2行<code>{<!-- --><a href="https://www.zhihu.com/search?q=column%3Avalue&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1112971172%7D" rel="nofollow" title="column:value">column:value</a>}</code>得数据：</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('records')[1]
{'col_1': 2, 'col_2': 0.75}</code></pre> 
<h4><strong>2.6，orient ='index' — {index:{culumn:value}};</strong></h4> 
<p><code>orient ='index'</code>与<code>2.1</code>用法刚好相反，求某一行中列名与值之间一一对应关系(查询效果与2.5相似)：</p> 
<pre><code>&gt;&gt;&gt; df
      col_1  col_2
row1      1   0.50
row2      2   0.75
&gt;&gt;&gt; df.to_dict('index')
{'row1': {'col_1': 1, 'col_2': 0.5}, 'row2': {'col_1': 2, 'col_2': 0.75}}
​
#查询行名为 row2 列名与值一一对应字典数据类型
&gt;&gt;&gt; df.to_dict('index')['row2']
{'col_1': 2, 'col_2': 0.75}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/528c21aaac5eb4245f2d2f5df276b5a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">目标检测算法YOLOv4详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ed016e7d6cda168def797a50c77e2d9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java线程池案例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>