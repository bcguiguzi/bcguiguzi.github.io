<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;】vector容器详解&amp;&amp;迭代器失效问题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;】vector容器详解&amp;&amp;迭代器失效问题" />
<meta property="og:description" content="目录
vector介绍：
vector常用接口：
1、构造函数（constructor）
2、析构（destructor）
3、迭代器（iterator） 4、容量相关
5、元素访问 6、修改相关
迭代器失效问题 什么是迭代器？
迭代器与指针：
迭代器的分类和操作：
为什么对迭代器分类？
迭代器失效问题即解决方法
vector介绍： 1、vector是表示可变大小的序列容器
2、就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。
3、本质讲，vector使用动态分配数组来存储它的元素。当元素插入的时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。
4、vector分配空间粗略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于再末尾插入一个元素的时候是在常数时间的复杂度完成的。
5、因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态曾张。
6、与其他动态序列容器相比（deques、lists and forward _lists）， vector在访问元素时候更加高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_lists统一的迭代器和引用更好。
vector常用接口： 1、构造函数（constructor） const allocator_type &amp; alloc = allocator_type()是一个配置器相关内容，它是用于指定要使用的空间配置器的，STL提供的默认的空间配置器，我们基本不用管这个参数，除非是我们自己实现了一个空间配置器，然后希望使用我们自己写的空间配置器。暂时忽略即可。
①explicit vector(const allocator_type &amp; alloc = allocator_type())：构建一个没有元素的空容器
②explicit vector(size_type n, const value_type&amp; val = value_type(), const allocator_type &amp; alloc = allocator_type())：构造n个值为val的容器
③template&lt;class InputIterator&gt;
vector(InputIterator first, InputIterator last, const allocator_type &amp; alloc = allocator_type())：根据给定的范围构造容器v3，这个范围也可以是数组的一部分。
④vector(const vector&amp; x)：拷贝构造，用容器x的内容来构造新的容器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/70b6d8cc64de0c195d8033251347dff6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-14T10:51:27+08:00" />
<meta property="article:modified_time" content="2022-04-14T10:51:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;】vector容器详解&amp;&amp;迭代器失效问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="vector%E4%BB%8B%E7%BB%8D%EF%BC%9A-toc" style="margin-left:0px;"><a href="#vector%E4%BB%8B%E7%BB%8D%EF%BC%9A" rel="nofollow">vector介绍：</a></p> 
<p id="vector%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%9A-toc" style="margin-left:0px;"><a href="#vector%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%9A" rel="nofollow">vector常用接口：</a></p> 
<p id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88constructor%EF%BC%89-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88constructor%EF%BC%89" rel="nofollow">1、构造函数（constructor）</a></p> 
<p id="2%E3%80%81%E6%9E%90%E6%9E%84%EF%BC%88destructor%EF%BC%89-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E6%9E%90%E6%9E%84%EF%BC%88destructor%EF%BC%89" rel="nofollow">2、析构（destructor）</a></p> 
<p id="3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iterator%EF%BC%89%C2%A0-toc" style="margin-left:40px;"><a href="#3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iterator%EF%BC%89%C2%A0" rel="nofollow">3、迭代器（iterator） </a></p> 
<p id="4%E3%80%81%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3-toc" style="margin-left:40px;"><a href="#4%E3%80%81%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3" rel="nofollow">4、容量相关</a></p> 
<p id="5%E3%80%81%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%C2%A0-toc" style="margin-left:40px;"><a href="#5%E3%80%81%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%C2%A0" rel="nofollow">5、元素访问 </a></p> 
<p id="6%E3%80%81%E4%BF%AE%E6%94%B9%E7%9B%B8%E5%85%B3-toc" style="margin-left:40px;"><a href="#6%E3%80%81%E4%BF%AE%E6%94%B9%E7%9B%B8%E5%85%B3" rel="nofollow">6、修改相关</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:0px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">迭代器失效问题 </a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F" rel="nofollow">什么是迭代器？</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E6%8C%87%E9%92%88%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E6%8C%87%E9%92%88%EF%BC%9A" rel="nofollow">迭代器与指针：</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%93%8D%E4%BD%9C%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%93%8D%E4%BD%9C%EF%BC%9A" rel="nofollow">迭代器的分类和操作：</a></p> 
<p id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB%EF%BC%9F" rel="nofollow">为什么对迭代器分类？</a></p> 
<p id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E5%8D%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E5%8D%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" rel="nofollow">迭代器失效问题即解决方法</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="vector%E4%BB%8B%E7%BB%8D%EF%BC%9A">vector介绍：</h2> 
<blockquote> 
 <p>1、vector是表示可变大小的序列容器</p> 
 <p>2、就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。</p> 
 <p>3、本质讲，vector使用动态分配数组来存储它的元素。当元素插入的时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。</p> 
 <p>4、vector分配空间粗略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于再末尾插入一个元素的时候是在常数时间的复杂度完成的。</p> 
 <p> 5、因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态曾张。</p> 
 <p>6、与其他动态序列容器相比（deques、lists and forward _lists）， vector在访问元素时候更加高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_lists统一的迭代器和引用更好。</p> 
</blockquote> 
<h2 id="vector%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3%EF%BC%9A">vector常用接口：</h2> 
<h3 id="1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88constructor%EF%BC%89">1、构造函数（constructor）</h3> 
<p>const allocator_type &amp; alloc = allocator_type()是一个配置器相关内容，它是用于指定要使用的空间配置器的，STL提供的默认的空间配置器，我们基本不用管这个参数，除非是我们自己实现了一个空间配置器，然后希望使用我们自己写的空间配置器。暂时忽略即可。</p> 
<blockquote> 
 <p>①explicit vector(const allocator_type &amp; alloc = allocator_type())：构建一个没有元素的空容器</p> 
 <p>②explicit vector(size_type n, const value_type&amp; val = value_type(), const allocator_type &amp; alloc = allocator_type())：构造n个值为val的容器</p> 
 <p><img alt="" height="287" src="https://images2.imgbox.com/8b/c4/PndZ7f3f_o.png" width="989"></p> 
 <p>③template&lt;class InputIterator&gt;</p> 
 <p>vector(InputIterator first, InputIterator last, const allocator_type &amp; alloc = allocator_type())：根据给定的范围构造容器v3，这个范围也可以是数组的一部分。</p> 
 <p><img alt="" height="472" src="https://images2.imgbox.com/5d/2a/ejhJIxPB_o.png" width="1064"></p> 
 <p> ④vector(const vector&amp; x)：拷贝构造，用容器x的内容来构造新的容器</p> 
</blockquote> 
<blockquote> 
 <p>vector&amp; operator=(const vector&amp; x)：赋值运算符重载 <img alt="" height="190" src="https://images2.imgbox.com/08/22/4RDkZqK8_o.png" width="870"></p> 
</blockquote> 
<h3 id="2%E3%80%81%E6%9E%90%E6%9E%84%EF%BC%88destructor%EF%BC%89">2、析构（destructor）</h3> 
<blockquote> 
 <p>~vector() </p> 
</blockquote> 
<h3 id="3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iterator%EF%BC%89%C2%A0">3、迭代器（iterator） </h3> 
<p>迭代器都是左闭右开</p> 
<blockquote> 
 <p>①begin() &amp; end()</p> 
 <p>iterator begin()  |  const_iterator begin() const：获取第一个数据位置的iterator或者const_iterator</p> 
 <p>iterator end()  |  const_iterator end() const：获取最后一个数据的下一个位置的iterator或者const_iterator</p> 
 <p><img alt="" height="237" src="https://images2.imgbox.com/86/10/MBWk8YhR_o.png" width="743"></p> 
 <p>②rbegin() &amp; rend()</p> 
 <p>reverse_iterator rbegin()  |   const_reverse_iterator rbegin() const：获取最后一个数据位置的reverse_iterator或者const_reverse_iterator</p> 
 <p> reverse_iterator rend()  |   const_reverse_iterator rend() const：获取第一个数据的前一个位置的reverse_iterator或者const_reverse_iterator</p> 
 <p><img alt="" height="169" src="https://images2.imgbox.com/d9/3a/Kwt2lbmb_o.png" width="616"></p> 
 <p>③cbegin() &amp; cend()   （C++11）</p> 
 <p>const_iterator cbegin() const noexcept;</p> 
 <p>const_iterator cend() const noexcept;</p> 
 <p>返回的迭代器指向的元素不可被修改。</p> 
 <p>④crbegin() &amp; crend()  （C++）：返回的迭代器指向的元素不可被修改</p> 
</blockquote> 
<h3 id="4%E3%80%81%E5%AE%B9%E9%87%8F%E7%9B%B8%E5%85%B3">4、容量相关</h3> 
<blockquote> 
 <p>①size_type size() const：获取容器中有效元素的个数</p> 
 <p>②size_type capacity() const：获取容器的容量</p> 
 <p>③empty：判断容器是否为空，是的话返回true</p> 
 <p>④void  resize(size_type n, value_type val = value_ type())：将容器有效元素的个数更新为n个，如果n大于原来容器的有效元素size，则多出来的元素使用val填充：</p> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">n &lt;= size ：将容器的有效元素减少至n个（将size的值改为n）</span></span></p> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">n &gt; size：</span></span></p> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">        n &lt;= capacity：将容器的有效元素个数增加至n,多出来的n - size个元素使用val填充</span></span></p> 
 <p><span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">        n &gt; capacity：扩容，将容器的有效元素增加至n</span></span></p> 
 <p>⑤void  reserve(size_type n)：扩容</p> 
 <p>n &lt;= capacity：直接忽略，不做处理</p> 
 <p>n &gt; capacity：扩容</p> 
 <p>注意：vs下capacity是按照1.5倍增长的，g++是按照2倍增长的。reserve只负责开辟空间，如果确定知道需要用多少空间，reserve可以缓解vector增容的代价缺陷问题。resize在开辟空间的同时还会进行初始化，影响size。 </p> 
</blockquote> 
<h3 id="5%E3%80%81%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%C2%A0">5、元素访问 </h3> 
<blockquote> 
 <p>①operator[]：通过下标的方式访问元素</p> 
 <p>reference operator[] (size_type n);</p> 
 <p>const_reference operator[] (size_type n)const;</p> 
 <p>②通过下标访问元素</p> 
 <p>reference at(size_type n);</p> 
 <p>const_reference at(size_type n) const;</p> 
 <p>二者的功能一直，都是访问下标n处的元素。唯一不同的是：处理异常情况的方式不同。operator[]-&gt;触发assert断言，at-&gt;抛出异常。</p> 
 <p>③front &amp; back：front获取第一个元素，back获取最后一个元素。</p> 
 <p>④data  (C++11)：获取指向内部元素数组的指针</p> 
 <p>value_type* data() noexcept  |  const value_type* data() const noexcept;</p> 
 <p><img alt="" height="209" src="https://images2.imgbox.com/ee/68/GTTWSnAr_o.png" width="1017"></p> 
</blockquote> 
<h3 id="6%E3%80%81%E4%BF%AE%E6%94%B9%E7%9B%B8%E5%85%B3">6、修改相关</h3> 
<blockquote> 
 <p>① push_back：在容器末尾插入一个元素</p> 
 <p>void push_back (const value_type&amp; val);</p> 
 <p>②pop_back：将容器的最后一个元素删除</p> 
 <p>void pop_back()；对一个空的容器使用，pop_back会触发assert会触发assert断言，导致程序崩溃。</p> 
 <p>③insert</p> 
 <p>iterator insert(iterator position, const value_type&amp;val)：在position位置插入元素val</p> 
 <p>iterator insert(iterator position,size_type n,  const value_type&amp;val)：在position处插入n个元素val。</p> 
 <p>void insert (iterator position, InputIterator first, InpurIterator last)：在position处插入一段区间内的元素。</p> 
 <p><img alt="" height="224" src="https://images2.imgbox.com/9a/d1/Mg4mnsOL_o.png" width="995"></p> 
 <p>④erase</p> 
 <p>iterator erase(iterator position)：删除position位置的元素</p> 
 <p>iterator erase(iterator first, iterator last)：删除一段范围[first, last)内的元素</p> 
 <p>⑤swap：交换</p> 
 <p>⑥clear：清空容器的有效元素</p> 
</blockquote> 
<h2 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%C2%A0">迭代器失效问题 </h2> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F">什么是迭代器？</h4> 
<blockquote> 
 <p>在STL中，容器的迭代器（Iterator）被作为容器元素对象或者IO流中的对象的位置指示器。因此，我们可以把迭代器理解为面向对象的指针（一种泛型指针或者通用指针），它不依赖元素的真是类型。</p> 
 <p>简而言之，迭代器是为了降低容器和泛型算法之间的耦合性而设计的，泛型算法的参数不是容器，而是迭代器。</p> 
 <p>容器迭代器的作用类似于数据库中的游标，它屏蔽了底层存储空间的不连续性，在上层使容器元素维持一种“逻辑连续”的假象。</p> 
</blockquote> 
<h4 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E6%8C%87%E9%92%88%EF%BC%9A">迭代器与指针：</h4> 
<blockquote> 
 <p>迭代器只是在某些操作上与我们学过的指针有些类似，但是迭代器并不是指针。</p> 
 <p>指针代表真正的内存地址，即对象在内存中的存储位置。</p> 
 <p>迭代器则代表元素在容器中的相对位置。</p> 
</blockquote> 
<h4 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB%E5%92%8C%E6%93%8D%E4%BD%9C%EF%BC%9A">迭代器的分类和操作：</h4> 
<p> 具体分为5类：</p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/98/4e/KR8GgZP9_o.png" width="929"></p> 
<p>支持的操作：</p> 
<p><img alt="" height="934" src="https://images2.imgbox.com/ef/cc/eESCejwl_o.png" width="931"></p> 
<p>对于完全连续的容器（例如vector），没有必要重新定义迭代器类型，其元素的职责就可以完全直接充当迭代器。vector::iterator 和 const_iterator一般定义如下：</p> 
<pre><code>typedef T* iterator;
typedef const T* const_iterator;</code></pre> 
<p> 对于不连续存储或以其他方式存储的容器，例如list等，需要自己定义迭代器类（class），一般情况下它们是对元素指针的封装，即模拟指针。</p> 
<p>常用的容器的迭代器类别：</p> 
<p><img alt="" height="433" src="https://images2.imgbox.com/b2/f9/beFuBgWZ_o.png" width="500"></p> 
<h4 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%86%E7%B1%BB%EF%BC%9F">为什么对迭代器分类？</h4> 
<blockquote> 
 <p> 主要是泛型算法可以根据不同类别的迭代器具有不同能力来实现不同性能的版本，使得能力大的迭代器用于这些算法时具有更高的效率。</p> 
 <p>连续存储的容器，其元素的位置指示器有两种，下标和迭代器。下标的类型为unsigned int(size_t) ,有效范围是begin() ~ end()</p> 
 <p>这类容器的接口中都会提供相应的两种元素访问方法，典型的就是string和vector，它们都支持begin(), end(), operator[]操作</p> 
</blockquote> 
<p>使用建议：</p> 
<blockquote> 
 <p>尽量使用迭代器类型，而不是使用指针。</p> 
 <p>只使用迭代器提供的标准操作，不使用任何非标准操作，以避免版本更新时出现不兼容的情况。</p> 
 <p>当不会改变容器中的元素值得时候，使用const迭代器 </p> 
</blockquote> 
<h4 id="%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E5%8D%B3%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95">迭代器失效问题即解决方法</h4> 
<blockquote> 
 <p>迭代器失效是指容器底层存储发生变动时，原来指向容器中某个或某些元素得迭代器由于元素存储位置发生了改变而不再指向他们，从而成为无效的迭代器。</p> 
</blockquote> 
<p>引起迭代器失效的主要操作：</p> 
<blockquote> 
 <p>改变容器容量得方法：reserve()、resize()、push_back()、pop_back()、insert()、erase()、clear()</p> 
 <p>一些泛型算法：sort()、copy()、replace()、remove()、unipue()等 </p> 
</blockquote> 
<p>push_back()： </p> 
<pre><code>
	vector&lt;int&gt; v1;
	v1.push_back(1);
	vector&lt;int&gt;::iterator iter = v1.begin();
	for (int i = 0; i &lt; 10; i++) {
		v1.push_back(2);
	}
	cout &lt;&lt; *iter &lt;&lt; endl;//迭代器失效
	system("pause");
	return 0;</code></pre> 
<p>解决方法：</p> 
<p>①在调用上述操作后重新获取迭代器</p> 
<pre><code>	vector&lt;int&gt; v1;
	v1.push_back(1);
	auto iter = v1.begin();
	for (int i = 0; i &lt; 10; i++) {
		v1.push_back(2);
	}
	iter = v1.begin();  //重新获取迭代器
	cout &lt;&lt; *iter &lt;&lt; endl;</code></pre> 
<p>②在修该容器前为其预留足够的空间避免存储空间重新分配。</p> 
<p>erase()：</p> 
<pre><code>	vector&lt;int&gt; v2{ 1,2,3,4,5 };
	auto it = find(v2.begin(), v2.end(), 5);
	//删除末尾元素，此时迭代器失效
	v2.erase(it);
	cout &lt;&lt; *it &lt;&lt; endl;
	system("pause");
	return 0;</code></pre> 
<p>由于erase得返回值是被删除元素的下一个位置，所以会存在一种情况：删除末尾元素，这样该函数返回得就是end()的位置。</p> 
<p>如何解决？</p> 
<blockquote> 
 <p>删除非末尾元素：使用语句iter = v.erase(iter)在删除元素的同时更新迭代器。</p> 
 <pre><code>	vector&lt;int&gt; v2{ 1,2,3,4,5 };
	//找到并删除非末尾元素
	auto it = find(v2.begin(), v2.end(), 3);
	it = v2.erase(it);

	cout &lt;&lt; *it &lt;&lt; endl;</code></pre> 
 <p>删除末尾元素：此时erase返回的是end()的位置，因此要想继续使用该迭代器，应该重新为其赋值为合法值。</p> 
 <pre><code>	vector&lt;int&gt; v2{ 1,2,3,4,5 };
	//找到并删除非末尾元素
	//auto it = find(v2.begin(), v2.end(), 3);
	//it = v2.erase(it);

	auto it = find(v2.begin(), v2.end(), 5);
	v2.erase(it);
	it = v2.begin();
	cout &lt;&lt; *it &lt;&lt; endl;</code></pre> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e2e9d55a0754de639c18e7114bdfb1e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vector＜string＞的应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3dce1d0e9410d360a73cc53d6ee928e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于服务器并发量的简单计算</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>