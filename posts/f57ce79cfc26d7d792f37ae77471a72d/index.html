<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA 基础 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA 基础" />
<meta property="og:description" content="JAVA 异常分类及处理 异常分类 Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception Error 1. Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果 出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。 Exception （ RuntimeException、CheckedException ） 2. Exception 又有两个分支，一个是运行时异常 RuntimeException ，一个是 CheckedException。 RuntimeException 如 ： NullPointerException 、 ClassCastException ；一个是检查异常 CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException 是 那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一 定是程序员的错误. 13/04/2018 Page 102 of 283 检查异常 CheckedException ：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强 制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一 般包括几个方面： 1. 试图在文件尾部读取数据 2. 试图打开一个错误格式的 URL 3. 试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在 异常的处理方式 遇到问题不进行具体处理，而是继续抛给调用者 （ throw,throws ） 抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常 。 public static void main(String[] args) { String s = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f57ce79cfc26d7d792f37ae77471a72d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-22T11:10:52+08:00" />
<meta property="article:modified_time" content="2021-09-22T11:10:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA 基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <span style="color:#000000;"><strong>JAVA </strong></span> 
 <span style="color:#000000;"><strong>异常分类及处理</strong></span> 
</div> 
<div>
    
 <div> 
  <img alt="" height="513" src="https://images2.imgbox.com/1e/fa/kEaoqJ5y_o.png" width="913"> 
 </div> 
 <div></div> 
 <div> 
  <h4><span style="color:#000000;"><strong>异常分类</strong></span></h4> 
  <p></p> 
  <div> 
   <span style="color:#000000;">Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 </span> 
   <span style="color:#1f497d;">Error 和 Exception </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong><em>Error </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">1. Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong><em>Exception</em></strong></span> 
   <span style="color:#000000;"><strong><em>（</em></strong></span> 
   <span style="color:#000000;"><em>RuntimeException、CheckedException</em></span> 
   <span style="color:#000000;"><strong><em>） </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">2. Exception 又有两个分支，一个是运行时异常 RuntimeException ，一个是 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">CheckedException。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong>RuntimeException </strong></span> 
   <span style="color:#000000;">如 ： NullPointerException 、 ClassCastException ；一个是检查异常 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException 是 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">定是程序员的错误.</span> 
   <span style="color:#000000;">13/04/2018 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Page 102 of 283 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong>检查异常 CheckedException</strong></span> 
   <span style="color:#000000;">：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">般包括几个方面： </span> 
  </div> 
  <div> 
   <span style="color:#000000;">1. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">试图在文件尾部读取数据 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">2. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">试图打开一个错误格式的 URL </span> 
  </div> 
  <div> 
   <span style="color:#000000;">3. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</span> 
  </div> 
  <div></div> 
  <h4><span style="color:#000000;"><strong>异常的处理方式</strong></span></h4> 
  <p></p> 
  <div> 
   <span style="color:#000000;"><strong><em>遇到问题不进行具体处理，而是继续抛给调用者 （</em></strong></span> 
   <span style="color:#1f497d;"><strong><em>throw,throws</em></strong></span> 
   <span style="color:#000000;"><strong><em>） </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常</span> 
   <span style="color:#000000;">。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">public static void main(String[] args) { </span> 
  </div> 
  <div> 
   <span style="color:#000000;">String s = "abc"; </span> 
  </div> 
  <div> 
   <span style="color:#000000;">if(s.equals("abc")) { </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">throw new NumberFormatException(); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">} else { </span> 
  </div> 
  <div> 
   <span style="color:#000000;">System.out.println(s); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">} </span> 
  </div> 
  <div> 
   <span style="color:#000000;">} </span> 
  </div> 
  <div> 
   <span style="color:#000000;">int div(int a,int b) </span> 
   <span style="color:#1f497d;">throws Exception</span> 
   <span style="color:#000000;">{ </span> 
  </div> 
  <div> 
   <span style="color:#000000;">return a/b;} </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong><em>try catch </em></strong></span> 
   <span style="color:#000000;"><strong><em>捕获异常针对性处理方式</em></strong></span> 
  </div> 
  <h4><span style="color:#000000;"><strong>Throw 和 throws 的区别：</strong></span></h4> 
  <p></p> 
  <div> 
   <span style="color:#000000;"><strong><em>位置不同 </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">1. </span> 
   <span style="color:#1f497d;">throws 用在函数上</span> 
   <span style="color:#000000;">，后面跟的是异常类，可以跟多个；</span> 
   <span style="color:#1f497d;">而 throw 用在函数内</span> 
   <span style="color:#000000;">，后面跟的 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">是异常对象。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong><em>功能不同： </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">2. </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">throws 用来声明异常，让调用者只知道该功能可能出现的问题</span> 
   <span style="color:#000000;">，可以给出预先的处理方 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">式；</span> 
   <span style="color:#1f497d;">throw 抛出具体的问题对象，执行到 throw，功能就已经结束了</span> 
   <span style="color:#000000;">，跳转到调用者，并 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">句，因为执行不到。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">3. </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">throws 表示出现异常的一种可能性</span> 
   <span style="color:#000000;">，并不一定会发生这些异常；</span> 
   <span style="color:#1f497d;">throw </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">则是抛出了异常</span> 
   <span style="color:#000000;">， </span> 
  </div> 
  <div> 
   <span style="color:#000000;">执行 throw 则一定抛出了某种异常对象。</span> 
   <span style="color:#000000;">13/04/2018 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Page 103 of 283 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">4. 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">常，真正的处理异常由函数的上层调用处理</span> 
  </div> 
  <h3><span style="color:#000000;"><strong>JAVA </strong></span><span style="color:#000000;"><strong>反射</strong></span></h3> 
  <h4><span style="color:#000000;"><strong>动态语言</strong></span></h4> 
  <p></p> 
  <div> 
   <span style="color:#000000;">动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言， </span> 
  </div> 
  <div> 
   <span style="color:#000000;">而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。</span> 
  </div> 
  <h4><span style="color:#000000;"><strong>反射机制概念 （</strong></span><span style="color:#1f497d;"><strong>运行状态中知道类所有的属性和方法</strong></span><span style="color:#000000;"><strong>）</strong></span></h4> 
  <p><img alt="" height="360" src="https://images2.imgbox.com/91/98/20oetW0e_o.png" width="948"></p> 
  <div> 
   <span style="color:#000000;">在 Java 中的反射机制是指</span> 
   <span style="color:#1f497d;">在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">并且对于任意一个对象，都能够调用它的任意一个方法</span> 
   <span style="color:#000000;">；这种动态获取信息以及动态调用对象方 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">法的功能成为 Java 语言的反射机制。</span> 
  </div> 
  <h4><span style="color:#000000;"><strong>反射的应用场合</strong></span></h4> 
  <p></p> 
  <div> 
   <span style="color:#000000;"><strong><em>编译时类型和运行时类型 </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如： </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Person p=new Student(); </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">其中编译时类型为 Person，运行时类型为 Student</span> 
   <span style="color:#000000;">。</span> 
   <span style="color:#000000;">13/04/2018 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Page 104 of 283 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong><em>的编译时类型无法获取具体方法 </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">程序在运行时还可能接收到外部传入的对象，</span> 
   <span style="color:#1f497d;">该对象的编译时类型为 Object</span> 
   <span style="color:#000000;">,但是程序有需要调用 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">该对象的运行时类型的方法。为了解决这些问题，</span> 
   <span style="color:#1f497d;">程序需要在运行时发现对象和类的真实信息</span> 
   <span style="color:#000000;">。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">和类的真实信息，此时就必须使用到反射了。</span> 
  </div> 
  <h4><span style="color:#000000;"><strong>Java 反射 API</strong></span></h4> 
  <p></p> 
  <div> 
   <span style="color:#000000;"><strong><em>反射 </em></strong></span> 
   <span style="color:#000000;"><strong><em>API </em></strong></span> 
   <span style="color:#000000;"><strong><em>用来生成 </em></strong></span> 
   <span style="color:#000000;"><strong><em>JVM </em></strong></span> 
   <span style="color:#000000;"><strong><em>中的类、接口或则对象的信息。 </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">1. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Class 类：反射的核心类，可以获取类的属性，方法等信息。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">2. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">值。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">3. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">者执行方法。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">4. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。</span> 
  </div> 
  <h4><span style="color:#000000;"><strong>反射使用步骤（获取 Class 对象、调用对象方法）</strong></span></h4> 
  <p></p> 
  <div> 
   <span style="color:#000000;">1. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">法。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">2. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">调用 Class 类中的方法，既就是反射的使用阶段。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">3. </span> 
  </div> 
  <div> 
   <span style="color:#000000;">使用反射 API 来操作这些信息。</span> 
  </div> 
  <h4><span style="color:#000000;"><strong>获取 Class 对象的 3 种方法 </strong></span></h4> 
  <p></p> 
  <div> 
   <span style="color:#000000;"><strong><em>调用某个对象的 </em></strong></span> 
   <span style="color:#000000;"><strong><em>getClass()</em></strong></span> 
   <span style="color:#000000;"><strong><em>方法 </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">Person p=new Person(); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Class clazz=p.getClass(); </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong><em>调用某个类的 </em></strong></span> 
   <span style="color:#000000;"><strong><em>class </em></strong></span> 
   <span style="color:#000000;"><strong><em>属性来获取该类对应的 </em></strong></span> 
   <span style="color:#000000;"><strong><em>Class </em></strong></span> 
   <span style="color:#000000;"><strong><em>对象 </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">Class clazz=Person.class; </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong><em>使用 </em></strong></span> 
   <span style="color:#000000;"><strong><em>Class </em></strong></span> 
   <span style="color:#000000;"><strong><em>类中的 </em></strong></span> 
   <span style="color:#000000;"><strong><em>forName()</em></strong></span> 
   <span style="color:#000000;"><strong><em>静态方法</em></strong></span> 
   <span style="color:#000000;"><strong><em>(</em></strong></span> 
   <span style="color:#000000;"><strong><em>最安全</em></strong></span> 
   <span style="color:#000000;"><strong><em>/</em></strong></span> 
   <span style="color:#000000;"><strong><em>性能最好</em></strong></span> 
   <span style="color:#000000;"><strong><em>) </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">Class clazz=Class.forName("类的全路径"); (最常用) </span> 
  </div> 
  <div> 
   <span style="color:#000000;">当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">和属性。 </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">//获取 Person 类的 Class 对象 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Class clazz=Class.forName("reflection.Person");</span> 
   <span style="color:#000000;">13/04/2018 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Page 105 of 283 </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">//获取 Person 类的所有方法信息 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Method[] method=clazz.getDeclaredMethods(); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">for(Method m:method){ </span> 
  </div> 
  <div> 
   <span style="color:#000000;">System.out.println(m.toString()); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">} </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">//获取 Person 类的所有成员属性信息 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Field[] field=clazz.getDeclaredFields(); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">for(Field f:field){ </span> 
  </div> 
  <div> 
   <span style="color:#000000;">System.out.println(f.toString()); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">} </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">//获取 Person 类的所有构造方法信息 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Constructor[] constructor=clazz.getDeclaredConstructors(); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">for(Constructor c:constructor){ </span> 
  </div> 
  <div> 
   <span style="color:#000000;">System.out.println(c.toString()); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">}</span> 
  </div> 
  <h3><span style="color:#000000;"><strong>创建对象的两种方法</strong></span></h3> 
  <p></p> 
  <div> 
   <span style="color:#000000;"><strong><em>Class </em></strong></span> 
   <span style="color:#000000;"><strong><em>对象的 </em></strong></span> 
   <span style="color:#000000;"><strong><em>newInstance() </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">1. 使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">该 Class 对象对应的类有默认的空构造器。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong><em>调用 </em></strong></span> 
   <span style="color:#000000;"><strong><em>Constructor </em></strong></span> 
   <span style="color:#000000;"><strong><em>对象的 </em></strong></span> 
   <span style="color:#000000;"><strong><em>newInstance() </em></strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">2. 先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() </span> 
  </div> 
  <div> 
   <span style="color:#000000;">方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">//获取 Person 类的 Class 对象 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Class clazz=Class.forName("reflection.Person"); </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">//使用.newInstane 方法创建对象 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Person p=(Person) clazz.newInstance(); </span> 
  </div> 
  <div> 
   <span style="color:#1f497d;">//获取构造方法并创建对象 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class); </span> 
  </div> 
  <div> 
   <span style="color:#000000;">//创建对象并设置属性</span> 
   <span style="color:#000000;">13/04/2018 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Page 106 of 283 </span> 
  </div> 
  <div> 
   <span style="color:#000000;">Person p1=(Person) c.newInstance("李四","男",20);</span> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f1c595d2ade3e94f113851529aab3905/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql 6.0 安装中报错：start service失败</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8f4a66ac736b6cf703fc56c125e8b18b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">京东联盟接口——链接取商品sku</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>