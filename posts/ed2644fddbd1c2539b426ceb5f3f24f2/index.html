<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java自定义线程池 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java自定义线程池" />
<meta property="og:description" content="一、线程池的概念和作用 线程池是一种用于管理和重用线程的机制。它允许你创建一个线程池，然后将任务提交给这个线程池，线程池会自动分配线程来执行这些任务。
线程池的作用是优化线程的管理和资源利用，以减少线程创建和销毁的开销，提高系统的性能和响应速度。
二、线程池的参数 如果是在 Spring 中，可以用 ThreadPoolTaskExecutor 配合 @Async 注解来实现。（不太建议）
如果是在 Java 中，可以使用 JUC 并发编程包中的 ThreadPoolExecutor 来实现非常灵活地自定义线程池。
线程池参数：
public ThreadPoolExecutor(int corePoolSize, //核心线程数 int maximumPoolSize, //最大工作线程数 long keepAliveTime, //非核心线程存活时间 TimeUnit unit, //时间单位 BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列 ThreadFactory threadFactory, //线程工厂 RejectedExecutionHandler handler //拒绝策略 ) { 如何确定线程池的参数？
结合实际情况（实际业务场景和系统资源）来测试调整，不断优化。
corePoolSize（核心线程数）：正常情况下，我们的系统应该能同时工作的线程数（随时就绪的状态）
maximumPoolSize（最大线程数 ）：极限情况下，我们的线程池也最多有这么多的线程。
keepAliveTime（空闲线程存活时间）：非核心线程在没有任务的情况下，过多久要删除（理解为开除临时工），从而释放无用的线程资源。
TimeUnit unit（空闲线程存活时间的单位）：分钟、秒
workQueue（工作队列）：用于存放给线程执行的任务，存在一个队列的长度（一定要设置，不要说队列长度无限，因为也会占用资源）
threadFactory（线程工厂）：控制每个线程的生成、线程的属性（比如线程名）
RejectedExecutionHandler（拒绝策略）：任务队列满的时候，我们采取什么措施，比如抛异常、不抛异常、自定义策略。
常见的拒绝策略：
AbortPolicy（默认）：这是默认的拒绝策略。当线程池的任务队列已满，且线程池中的线程数已达到最大值时，新任务将被立即拒绝，并抛出RejectedExecutionException异常。这是一种宁可抛出异常也不丢失任务的策略。
CallerRunsPolicy：在这个策略下，当任务被拒绝时，会由提交任务的线程自己来执行这个任务。这意味着如果线程池被拒绝接受新任务，提交任务的线程将尝试执行该任务，从而减缓任务提交的速度。
DiscardPolicy：这个策略下，新任务会被默默地丢弃，不会抛出异常，也不会被执行。这可能会导致任务的丢失。
DiscardOldestPolicy：当任务被拒绝时，这个策略会丢弃任务队列中最老的任务，然后尝试再次提交新任务。这可以减少任务丢失的可能性，但可能会导致某些较旧的任务被丢弃。
自定义策略：除了上述内置策略，你还可以实现自定义的拒绝策略，以满足特定需求。你可以实现RejectedExecutionHandler接口，然后根据自己的逻辑来处理被拒绝的任务。
三、线程池如何工作？ 假设核心线程数是：2
最大工作线程数是：4
任务队列大小为：5
下面分析线程池的工作过程：
（1）初始状态时，还没有任务的时候，线程池中是空的，没有线程。
（2）当来了一个任务时，任务数=1，此时就会创建一个核心线程来处理，核心线程数=1，
任务数=2时，再创建一个核心线程，核心线程数=2。此时核心线程数满了。
（3）此时如果再来一个任务，并不会创建线程来处理。而是放到任务队列中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ed2644fddbd1c2539b426ceb5f3f24f2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-19T16:42:37+08:00" />
<meta property="article:modified_time" content="2023-10-19T16:42:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java自定义线程池</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、线程池的概念和作用</h2> 
<p>        线程池是一种用于管理和重用线程的机制。它允许你创建一个线程池，然后将任务提交给这个线程池，线程池会自动分配线程来执行这些任务。</p> 
<p>        线程池的作用是优化线程的管理和资源利用，以减少线程创建和销毁的开销，提高系统的性能和响应速度。</p> 
<h2>二、线程池的参数</h2> 
<p>        如果是在 Spring 中，可以用 ThreadPoolTaskExecutor 配合 @Async 注解来实现。（不太建议）<br>         如果是在 Java 中，可以使用 JUC 并发编程包中的 <strong>ThreadPoolExecutor </strong>来实现非常灵活地自定义线程池。</p> 
<p><strong>线程池参数：</strong></p> 
<pre><code class="language-java">public ThreadPoolExecutor(int corePoolSize, //核心线程数
                          int maximumPoolSize,  //最大工作线程数
                          long keepAliveTime,  //非核心线程存活时间
                          TimeUnit unit,   //时间单位
                          BlockingQueue&lt;Runnable&gt; workQueue,  //阻塞队列
                          ThreadFactory threadFactory,  //线程工厂
                          RejectedExecutionHandler handler //拒绝策略
) {<!-- --></code></pre> 
<p><strong>如何确定线程池的参数？</strong></p> 
<p>结合实际情况（实际业务场景和系统资源）来测试调整，不断优化。</p> 
<p><span style="background-color:#a2e043;">corePoolSize（核心线程数）</span>：正常情况下，我们的系统应该能同时工作的线程数（随时就绪的状态）<br><span style="background-color:#a2e043;">maximumPoolSize（最大线程数 ）</span>：极限情况下，我们的线程池也最多有这么多的线程。<br><span style="background-color:#a2e043;">keepAliveTime（空闲线程存活时间）</span>：非核心线程在没有任务的情况下，过多久要删除（理解为开除临时工），从而释放无用的线程资源。<br><span style="background-color:#a2e043;">TimeUnit unit（空闲线程存活时间的单位）</span>：分钟、秒<br><span style="background-color:#a2e043;">workQueue（工作队列）</span>：用于存放给线程执行的任务，存在一个队列的长度（一定要设置，不要说队列长度无限，因为也会占用资源）<br><span style="background-color:#a2e043;">threadFactory（线程工厂）</span>：控制每个线程的生成、线程的属性（比如线程名）<br><span style="background-color:#a2e043;">RejectedExecutionHandler（拒绝策略）</span>：任务队列满的时候，我们采取什么措施，比如抛异常、不抛异常、自定义策略。</p> 
<blockquote> 
 <p>常见的拒绝策略：</p> 
 <ol><li> <p><strong>AbortPolicy（默认）</strong>：这是默认的拒绝策略。当线程池的任务队列已满，且线程池中的线程数已达到最大值时，新任务将被立即拒绝，并抛出<code>RejectedExecutionException</code>异常。这是一种<span style="background-color:#a2e043;">宁可抛出异常也不丢失任务</span>的策略。</p> </li><li> <p><strong>CallerRunsPolicy</strong>：在这个策略下，当任务被拒绝时，会由提交任务的线程自己来执行这个任务。这意味着如果线程池被拒绝接受新任务，提交任务的线程将尝试执行该任务，从而减缓任务提交的速度。</p> </li><li> <p><strong>DiscardPolicy</strong>：这个策略下，新任务会被默默地丢弃，不会抛出异常，也不会被执行。这可能会导致任务的丢失。</p> </li><li> <p><strong>DiscardOldestPolicy</strong>：当任务被拒绝时，这个策略会<span style="background-color:#a2e043;">丢弃任务队列中最老的任务</span>，然后尝试再次提交新任务。这可以减少任务丢失的可能性，但可能会导致某些较旧的任务被丢弃。</p> </li><li> <p>自定义策略：除了上述内置策略，你还可以实现自定义的拒绝策略，以满足特定需求。你可以实现<code>RejectedExecutionHandler</code>接口，然后根据自己的逻辑来处理被拒绝的任务。</p> </li></ol> 
</blockquote> 
<h2>三、线程池如何工作？</h2> 
<p>假设核心线程数是：2</p> 
<p>最大工作线程数是：4</p> 
<p>任务队列大小为：5</p> 
<p>下面分析线程池的工作过程：</p> 
<p>（1）初始状态时，还没有任务的时候，线程池中是空的，没有线程。</p> 
<p>（2）当来了一个任务时，任务数=1，此时就会创建一个核心线程来处理，核心线程数=1，</p> 
<p>任务数=2时，再创建一个核心线程，核心线程数=2。此时核心线程数满了。</p> 
<p>（3）此时如果再来一个任务，并不会创建线程来处理。而是放到任务队列中。</p> 
<p>（4）当任务队列满了的时候，才会创建非核心线程来处理任务。如果线程数达到最大线程数，任务队列也满了，此时就会触发拒绝策略。</p> 
<p>（5）如果当前线程数超过 corePoolSize（正式员工数），又没有新的任务给他，那么等 keepAliveTime 时间达到后，就可以把这个线程释放。</p> 
<p><strong>一般情况下，任务分为 IO 密集型和计算密集型两种。</strong><br><span style="background-color:#a2e043;">计算密集型：</span>吃 CPU，比如音视频处理、图像处理、数学计算等，一般是设置 corePoolSize 为 CPU 的核数 + 1（空余线程），可以让每个线程都能利用好 CPU 的每个核，而且线程之间不用频繁切换（减少打架、减少开销）<br><span style="background-color:#a2e043;">IO 密集型：</span>吃带宽/内存/硬盘的读写资源，corePoolSize 可以设置大一点，一般经验值是 2n 左右，但是建议以 IO 的能力为主。</p> 
<h2>四、线程池的实现</h2> 
<p>在springboot项目中增加线程池配置类：</p> 
<pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import javax.validation.constraints.NotNull;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

@Configuration
public class ThreadPoolExecutorConfig {

    @Bean
    public ThreadPoolExecutor threadPoolExecutor() {

        //1. 创建线程工厂，用于为线程池创建新的线程对象
        ThreadFactory threadFactory = new ThreadFactory() {
            private int count = 1;

            @Override
            public Thread newThread(@NotNull Runnable r) {
                Thread thread = new Thread(r);
                thread.setName("线程" + count);
                count++;
                return thread;
            }
        };
        //2. 这段代码创建了一个名为 threadPoolExecutor的ThreadPoolExecutor 线程池实例，参数如下：
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(2, 4, 100, TimeUnit.SECONDS,
                new ArrayBlockingQueue&lt;&gt;(4), threadFactory);
        return threadPoolExecutor;
    }
}</code></pre> 
<p><strong>创建一个测试Controller:</strong></p> 
<pre><code class="language-java">import com.fasterxml.jackson.databind.ObjectMapper;
import com.ruoyi.common.core.controller.BaseController;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ThreadPoolExecutor;


@RestController
@RequestMapping("/system/test")
public class QueueController extends BaseController {

    protected final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Autowired
    private ThreadPoolExecutor myThreadPoolExecutor;

    @PreAuthorize("@ss.hasPermi('system:user:list')")
    @GetMapping("/addTask")
    public void addTask(String taskName) {
        //这是Java 8引入的CompletableFuture类的方法，用于在异步线程中执行一个任务。
        // 这个方法接受一个Runnable对象作为参数，其中包含要执行的任务代码。在这个代码块中，任务会在后台线程中执行。
        CompletableFuture.runAsync(() -&gt; {
            logger.info("任务执行中："+taskName+"，执行的线程为："+ Thread.currentThread().getName());
            try{
                Thread.sleep(600000);
            } catch(InterruptedException e) {
                e.printStackTrace();
            }
        }, myThreadPoolExecutor); //传入线程池对象
    }

    @PreAuthorize("@ss.hasPermi('system:user:list')")
    @GetMapping("/get")
    public String get() {
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        int queueSize = myThreadPoolExecutor.getQueue().size();
        map.put("队列长度",queueSize);

        long tasksNum = myThreadPoolExecutor.getTaskCount();
        map.put("任务总数",tasksNum);

        long completedTaskCount = myThreadPoolExecutor.getCompletedTaskCount();
        map.put("已完成的任务数",completedTaskCount);

        int activeCount = myThreadPoolExecutor.getActiveCount();
        map.put("正在工作的线程数", activeCount);

        // 使用Jackson库将map转换为JSON字符串
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            String json = objectMapper.writeValueAsString(map);
            return json;
        } catch (Exception e) {
            e.printStackTrace();
            // 在异常情况下返回错误信息
            return "Error occurred: " + e.getMessage();
        }
    }
}
</code></pre> 
<h2>测试：</h2> 
<p>我们的线程池可以看到：</p> 
<p>核心线程数：2</p> 
<p>最大线程数：4</p> 
<p>任务队列：4</p> 
<p><img alt="" height="114" src="https://images2.imgbox.com/10/93/NEquUAQK_o.png" width="1200"></p> 
<p>添加1个任务：</p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/f6/57/UUS40IJE_o.png" width="854"></p> 
<p>查看线程池情况：</p> 
<p><img alt="" height="372" src="https://images2.imgbox.com/69/40/29a793kP_o.png" width="711"> 再添加一个任务，此时任务数为2：</p> 
<p><img alt="" height="355" src="https://images2.imgbox.com/da/8f/8tcCbv7u_o.png" width="626"></p> 
<p> 再添加任务，此时任务数为3，因为核心线程数是2，所以会被放到任务队列：</p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/b1/66/NybMJrwv_o.png" width="622"> </p> 
<p>继续添加任务，任务为6时，队列满了：</p> 
<p><img alt="" height="367" src="https://images2.imgbox.com/98/88/4wrtXy8Q_o.png" width="660"> </p> 
<p>继续添加任务，会发现线程池会创建非核心线程来处理：</p> 
<p><img alt="" height="315" src="https://images2.imgbox.com/6f/fd/Db3bnc76_o.png" width="559"></p> 
<p>继续添加，<strong>当线程数为4时，队列长度也为4时，都满了</strong>： </p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/7c/ee/SDmWIPqv_o.png" width="562"> </p> 
<p> 如果继续添加任务，会触发拒绝策略：</p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/db/65/wBdlgPmr_o.png" width="1200"></p> 
<p>后面当非核心线程没有工作时，超过过期时间，就会被线程池销毁掉。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e1c27661304d1b518e2bb3dfc5819d6e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux高并发服务器开发第四章：Linux网络编程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ec4ab57597b3231c9a97d2cf810487e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【EI会议征稿】2024年第四届消费电子与计算机工程国际学术会议（ICCECE 2024）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>