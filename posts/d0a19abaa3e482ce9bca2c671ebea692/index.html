<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;实现二叉树的创建及遍历 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;实现二叉树的创建及遍历" />
<meta property="og:description" content="二叉树的结点类 class Node { public: Node() = default; Node(int data) : _data(data), _lchild(nullptr), _rchild(nullptr) {}; public: char _data; // 数据域以 char 型为例，严谨点可写成模板 Node* _lchild; // 指向左孩的指针（左右孩也是一个Node） Node* _rchild; // 指向右孩 }; 二叉树的建立 // 递归建立二叉树,但是这个建完了 T 就不指向根节点了，暂未解决 // 已解决，void CreatBT(Node* T) ---&gt; void CreatBT(Node* &amp;t); 但是为什么这样可行还需要思考一下！！！ // 这里用引用传递的方式，目的是保留原有的根节点指针指向不受影响 void CreatBT(Node* &amp;root) { char ch; cout &lt;&lt; &#34;请输入结点中存放的数据：&#34;; cin &gt;&gt; ch; if(ch == &#39;#&#39;) { root = nullptr; } else { root = new(Node); root-&gt;_data = ch; CreatBT(root-&gt;_lchild); CreatBT(root-&gt;_rchild); } } 先序遍历二叉树 // 先序遍历二叉树 void preOrderTraverse(Node* root) { if(root == nullptr) {} else { cout &lt;&lt; root-&gt;_data &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d0a19abaa3e482ce9bca2c671ebea692/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-08T20:58:54+08:00" />
<meta property="article:modified_time" content="2021-10-08T20:58:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;实现二叉树的创建及遍历</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>二叉树的结点类</h4> 
<pre><code class="language-cpp">class Node
{
public:
    Node() = default;
    Node(int data) : _data(data), _lchild(nullptr), _rchild(nullptr) {};                                                                                                                                                                 
public:
    char _data; // 数据域以 char 型为例，严谨点可写成模板
    Node* _lchild; // 指向左孩的指针（左右孩也是一个Node）
    Node* _rchild; // 指向右孩
};</code></pre> 
<h4>二叉树的建立</h4> 
<pre><code class="language-cpp">// 递归建立二叉树,但是这个建完了 T 就不指向根节点了，暂未解决 // 已解决，void CreatBT(Node* T) ---&gt; void CreatBT(Node* &amp;t);   但是为什么这样可行还需要思考一下！！！
// 这里用引用传递的方式，目的是保留原有的根节点指针指向不受影响
void CreatBT(Node* &amp;root)
{
    char ch;
    cout &lt;&lt; "请输入结点中存放的数据：";
    cin &gt;&gt; ch;
    if(ch == '#')
    {
        root = nullptr;
    }
    else
    {
        root = new(Node);
        root-&gt;_data = ch;
        CreatBT(root-&gt;_lchild);
        CreatBT(root-&gt;_rchild);
    }
}</code></pre> 
<h4>先序遍历二叉树</h4> 
<pre><code class="language-cpp">// 先序遍历二叉树
void preOrderTraverse(Node* root) 
{
    if(root == nullptr) {}
    else 
    {
        cout &lt;&lt; root-&gt;_data &lt;&lt; "  ";
        preOrderTraverse(root-&gt;_lchild); //递归
        preOrderTraverse(root-&gt;_rchild);
    }
}</code></pre> 
<h4>中序遍历二叉树</h4> 
<pre><code class="language-cpp">// 中序遍历二叉树
void inOrderTraverse(Node* root) 
{
    if(root == nullptr) {}
    else 
    {
        inOrderTraverse(root-&gt;_lchild);
        cout &lt;&lt; root-&gt;_data &lt;&lt; "  ";
        inOrderTraverse(root-&gt;_rchild);
    }
}
</code></pre> 
<h4>后序遍历二叉树</h4> 
<pre><code class="language-cpp">// 后序遍历二叉树
void postOrderTraverse(Node* root) 
{
    if(root == nullptr) {}
    else 
    {
        postOrderTraverse(root-&gt;_lchild);
        postOrderTraverse(root-&gt;_rchild);
        cout &lt;&lt; root-&gt;_data &lt;&lt; "  ";
    }
}</code></pre> 
<h4>中序遍历的非递归算法</h4> 
<pre><code class="language-cpp">// 中序遍历的非递归算法
void inOrdrtTraverse_norecursion(Node* root)
{
    Node* p = root;
    stack&lt;Node*&gt; s; // 使用一个栈，保存每个小二叉树的根节点
    while(p != nullptr || !s.empty())
    {
        if(p != nullptr)
        {
            s.push(p);
            p = p-&gt;_lchild;
        }
        else
        {
            Node* q = s.top();
            s.pop();
            cout &lt;&lt; q-&gt;_data &lt;&lt; "  ";
            p = q-&gt;_rchild;
        }
    }
}</code></pre> 
<h4>二叉树的层次遍历</h4> 
<pre><code class="language-cpp">// 二叉树的层次遍历
void LevelOrder(Node* root)
{
    Node* p;
    queue&lt;Node*&gt; q; // 使用一个队列，根节点入队
    q.push(root);
    while(!q.empty())
    {
        p = q.front();
        cout &lt;&lt; p-&gt;_data &lt;&lt; "  ";
        q.pop();
        if(p-&gt;_lchild != nullptr)
        {
            q.push(p-&gt;_lchild);
        }
        if(p-&gt;_rchild != nullptr)
        {
            q.push(p-&gt;_rchild);
        }
    }
}</code></pre> 
<h4>计算二叉树的深度</h4> 
<pre><code class="language-cpp">// 计算二叉树的深度
int Depth(Node* T)
{
    if(T == nullptr)
    {
        return 0;
    }
    else
    {
        int m = Depth(T-&gt;_lchild);
        int n = Depth(T-&gt;_rchild);
        return (m &gt; n) ? (m + 1) : (n + 1);
    }
}</code></pre> 
<h4>计算二叉树的总结点数</h4> 
<pre><code class="language-cpp">// 计算二叉树结点总数
int NodeCount(Node* T)
{
    if(T == nullptr)
    {
        return 0;
    }
    else
    {
        return NodeCount(T-&gt;_lchild) + NodeCount(T-&gt;_rchild) + 1;
    }
}</code></pre> 
<h4>计算二叉树叶子节点数</h4> 
<pre><code class="language-cpp">// 计算二叉树叶子节点数
int leafNodeCount(Node* T)
{
    if(T == nullptr)
    {
        return 0;
    }
    if(T-&gt;_lchild == nullptr &amp;&amp; T-&gt;_rchild == nullptr)
    {
        return 1;
    }
    else
    {
        return leafNodeCount(T-&gt;_lchild) + leafNodeCount(T-&gt;_rchild);
    }
}</code></pre> 
<h4>测试</h4> 
<p>构建如下测试用例二叉树，并依次测试所写的每一个函数。</p> 
<p><img alt="" height="285" src="https://images2.imgbox.com/72/16/7YXnoKvw_o.jpg" width="214"></p> 
<p>按照二叉树的建立函数中的思路，将其以 ‘#’ 补齐为满二叉树，如下 ：</p> 
<p> <img alt="" height="362" src="https://images2.imgbox.com/e0/40/bYu4Liji_o.jpg" width="204"></p> 
<p>其先序遍历为：ABC##DE#G##F###，我们按照这个顺序建立二叉树，并进行测试，结果如下：</p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/c2/f3/NUbeg0LF_o.png" width="993"></p> 
<h4> 完整代码</h4> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
using namespace std;

// 二叉链树的创建和遍历

class Node
{
public:
    Node() = default;
    Node(int data) : _data(data), _lchild(nullptr), _rchild(nullptr) {};                                                                                                                                                                 
public:
    char _data; // 数据域以 char 型为例，严谨点可写成模板
    Node* _lchild; // 指向左孩的指针（左右孩也是一个Node）
    Node* _rchild; // 指向右孩
};

// 递归建立二叉树,但是这个建完了 T 就不指向根节点了，暂未解决 // 已解决，void CreatBT(Node* T) ---&gt; void CreatBT(Node* &amp;t);   但是为什么这样可行还需要思考一下！！！
// 这里用引用传递的方式，目的是保留原有的根节点指针指向不受影响
void CreatBT(Node* &amp;root)
{
    char ch;
    cout &lt;&lt; "请输入结点中存放的数据：";
    cin &gt;&gt; ch;
    if(ch == '#')
    {
        root = nullptr;
    }
    else
    {
        root = new(Node);
        root-&gt;_data = ch;
        CreatBT(root-&gt;_lchild);
        CreatBT(root-&gt;_rchild);
    }
}

// 先序遍历二叉树
void preOrderTraverse(Node* root) 
{
    if(root == nullptr) {}
    else 
    {
        cout &lt;&lt; root-&gt;_data &lt;&lt; "  ";
        preOrderTraverse(root-&gt;_lchild); //递归
        preOrderTraverse(root-&gt;_rchild);
    }
}

// 中序遍历二叉树
void inOrderTraverse(Node* root) 
{
    if(root == nullptr) {}
    else 
    {
        inOrderTraverse(root-&gt;_lchild);
        cout &lt;&lt; root-&gt;_data &lt;&lt; "  ";
        inOrderTraverse(root-&gt;_rchild);
    }
}

// 后序遍历二叉树
void postOrderTraverse(Node* root) 
{
    if(root == nullptr) {}
    else 
    {
        postOrderTraverse(root-&gt;_lchild);
        postOrderTraverse(root-&gt;_rchild);
        cout &lt;&lt; root-&gt;_data &lt;&lt; "  ";
    }
}

// 中序遍历的非递归算法
void inOrdrtTraverse_norecursion(Node* root)
{
    Node* p = root;
    stack&lt;Node*&gt; s; // 使用一个栈，保存每个小二叉树的根节点
    while(p != nullptr || !s.empty())
    {
        if(p != nullptr)
        {
            s.push(p);
            p = p-&gt;_lchild;
        }
        else
        {
            Node* q = s.top();
            s.pop();
            cout &lt;&lt; q-&gt;_data &lt;&lt; "  ";
            p = q-&gt;_rchild;
        }
    }
}

// 二叉树的层次遍历
void LevelOrder(Node* root)
{
    Node* p;
    queue&lt;Node*&gt; q; // 使用一个队列，根节点入队
    q.push(root);
    while(!q.empty())
    {
        p = q.front();
        cout &lt;&lt; p-&gt;_data &lt;&lt; "  ";
        q.pop();
        if(p-&gt;_lchild != nullptr)
        {
            q.push(p-&gt;_lchild);
        }
        if(p-&gt;_rchild != nullptr)
        {
            q.push(p-&gt;_rchild);
        }
    }
}

// 计算二叉树的深度
int Depth(Node* T)
{
    if(T == nullptr)
    {
        return 0;
    }
    else
    {
        int m = Depth(T-&gt;_lchild);
        int n = Depth(T-&gt;_rchild);
        return (m &gt; n) ? (m + 1) : (n + 1);
    }
}

// 计算二叉树结点总数
int NodeCount(Node* T)
{
    if(T == nullptr)
    {
        return 0;
    }
    else
    {
        return NodeCount(T-&gt;_lchild) + NodeCount(T-&gt;_rchild) + 1;
    }
}

// 计算二叉树叶子节点数
int leafNodeCount(Node* T)
{
    if(T == nullptr)
    {
        return 0;
    }
    if(T-&gt;_lchild == nullptr &amp;&amp; T-&gt;_rchild == nullptr)
    {
        return 1;
    }
    else
    {
        return leafNodeCount(T-&gt;_lchild) + leafNodeCount(T-&gt;_rchild);
    }
}

void test01()
{
    Node* T = nullptr;
    CreatBT(T);
    cout &lt;&lt; "该二叉树先序遍历结果为：";
    preOrderTraverse(T);
    cout &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; "该二叉树中序递归遍历结果为：";
    inOrderTraverse(T);
    cout &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; "该二叉树中序非递归遍历结果为：";
    inOrdrtTraverse_norecursion(T);
    cout &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; "该二叉树后序遍历结果为：";
    postOrderTraverse(T);
    cout &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; "该二叉树层次遍历结果为：";
    LevelOrder(T);
    cout &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; "该二叉树的深度为：" &lt;&lt; Depth(T) &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; "该二叉树的结点数为：" &lt;&lt; NodeCount(T) &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; "该二叉树的叶子结点数为：" &lt;&lt; leafNodeCount(T) &lt;&lt; endl &lt;&lt; endl;
}

int main()
{
    test01();

    system("pause");
    return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa79761c4c16fd7dbb39d1ccf65735ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">foreach中无法使用continue</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e7f01aadf450f13b2d874c9bf1a7f266/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【链表篇】牛客刷题周记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>