<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>@RequestMapping与@GetMapping和@PostMapping等注解的区别 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="@RequestMapping与@GetMapping和@PostMapping等注解的区别" />
<meta property="og:description" content=" 目录
前置知识
大致区别
使用场景上的注意事项
如何工作
使用案例
写法对比
前置知识 HTTP请求方法一共有9种，为：GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECTGET(获取资源) 本质就是发送一个请求来取得服务器上的某一资源；资源通过一组HTTP头和呈现数据(如HTML文本，或者图片或者视频等)返回给客户端；GET请求中，永远不会包含呈现数据；即GET请求只用来向服务器获取资源，而GET请求本身不应该携带任何呈现数据POST(传输实体文本) 向指定资源提交数据进行处理请求；数据被包含在POST请求体中(例如提交表单或者上传文件)；POST请求可能会导致新的资源的建立或已有资源的修改MVC中，控制器的定义在Spring MVC中，控制器是指类或者类的方法上添加了@RequestMapping注解的类，并不是使用了@Controller注解的类就是控制器类@Controller注解的类和@Component注解的类在功能上是一样的，都是在辅助@ComponentScan实现组件扫描只是在表意上，在用@Controller注解控制器类比用@Component注解控制器类更清楚一些 大致区别 SpringMVC以前版本的@RequestMapping，到了新版本被下面新注解替代，相当于增加的选项：
@GetMapping@PostMapping@PutMapping@DeleteMapping@PatchMapping 从命名约定我们可以看到每个注解都是为了处理各自的传入请求方法类型，即@GetMapping用于处理请求方法的GET类型，@PostMapping用于处理请求方法的POST类型等
如果我们想使用传统的@RequestMapping注解实现URL处理程序，那么它应该是这样的：@RequestMapping(value = &#34;/get/{id}&#34;, method = RequestMethod.GET)新方法可以简化为：@GetMapping(&#34;/get/{id}&#34;)@RequestMapping是一个非常通用的注解，它可以应用于类和方法层面用于将任意HTTP请求映射到控制器方法上@RequestMapping表示共享映射，如果没有指定请求方式，将接收所有的HTTP请求方式需要注意的是，大多数控制器方法都应该映射到一个特定的HTTP方法，而不是使用@RequestMapping共享映射当应用于类时，表示该类处理所有的请求；当应用于方法时，表示该方法处理特定的请求此外，@RequestMapping还可以用来指定请求的URL、HTTP方法等；例如：在上述代码中，handleRequest方法将处理所有发送到”/test”的HTTP GET请求在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上；之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系@GetMapping是@RequestMapping的特化版本，专门用于处理HTTP GET请求用于将GET请求映射到控制器处理方法上；当客户端发送HTTP GET请求时，Spring Boot会自动将请求映射到具有相应URL路径的控制器方法上，然后调用该方法处理请求；在调用控制器方法之前，Spring Boot会执行一系列预处理操作，例如解析请求参数和验证请求头；在调用控制器方法之后，Spring Boot会执行一系列后处理操作，例如转换响应信息和生成响应头@GetMapping是一个作为快捷方式的组合注解它在功能上等价于@RequestMapping(method = RequestMethod.GET)和@RequestMapping一样，@GetMapping也可以应用于类和方法层面例如：在上述代码中，home方法将处理所有发送到”/“的HTTP GET请求 使用场景上的注意事项 (1) 在前端method特指了get或post的时候分别使用@GetMapping和@PostMapping(2)如果传的参数是@RequestBody，多参或者传对象的情况下使用@PostMappping这种注解因为@RequestBody是获取请求body中的数据，常用于搭配@PostMapping请求来提交对象数据 如何工作 所有上述注解都已在内部注解了@RequestMapping以及方法元素中的相应值例如，如果我们查看@GetMapping注解的源代码，我们可以看到它已经通过以下方式使用RequestMethod.GET进行了注解：所有其他注解都以相同的方式创建，即@PostMapping使用RequestMethod.POST进行注解，@PutMapping使用RequestMethod.PUT进行注解等 使用案例 (案例1) 下面是结合RestController的简单使用：(案例2) 下面是使用@Controller的代码：在上面的代码中，HomeController类充当请求控制器；它的homeInit()方法将处理所有传入的URI请求&#34;/&#34;；它接受一个Model并返回视图home；使用配置的视图解析器解析视图名称”home“的页面(案例3) 下面是一个同时在类和方法上应用了 @RequestMapping 注解的示例：如上述代码所示，到 /user/login 的请求会由 login() 方法来处理，而到 /user/register 的请求会由 register() 来处理(案例4) 将控制器方法映射到一个特定的HTTP方法上，应用@GetMapping、@PostMapping：通常，这样代码更规范，因为login登录时只需要向服务器获取用户数据，register注册时需要向服务器提交数据组合注解对控制器方法的请求映射进行具体区分，减少了在应用程序上要配置的元数据，并且代码也更易读，有助于控制器对请求的快速匹配以及代码功能区分等(案例5) 在下面的示例中，@RequestParam注解表示请求参数“name”的值将被注入到方法参数中当客户端发送HTTP GET请求“/api/hello?name=world”时，Spring Boot会自动将请求映射到hello()方法，并将参数“world”注入到方法参数中，最终返回字符串“Hello, world!” 写法对比 @RequestMapping：@PostMapping： " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d4f9f32db003bd0b35fb21b8f5aa54f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-08T21:49:22+08:00" />
<meta property="article:modified_time" content="2024-03-08T21:49:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">@RequestMapping与@GetMapping和@PostMapping等注解的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-toc" style="margin-left:80px;"><a href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86" rel="nofollow">前置知识</a></p> 
<p id="%E5%A4%A7%E8%87%B4%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%E5%A4%A7%E8%87%B4%E5%8C%BA%E5%88%AB" rel="nofollow">大致区别</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8A%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8A%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">使用场景上的注意事项</a></p> 
<p id="%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C-toc" style="margin-left:80px;"><a href="#%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C" rel="nofollow">如何工作</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" rel="nofollow">使用案例</a></p> 
<p id="%E5%86%99%E6%B3%95%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#%E5%86%99%E6%B3%95%E5%AF%B9%E6%AF%94" rel="nofollow">写法对比</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span style="color:#956fe7;">前置知识</span></h4> 
<ul><li><strong>HTTP请求方法一共有9种</strong>，为：GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT</li><li><strong>GET(获取资源)</strong> 本质就是发送一个请求来取得服务器上的某一资源；资源通过一组HTTP头和呈现数据(如HTML文本，或者图片或者视频等)返回给客户端；GET请求中，永远不会包含呈现数据；即GET请求只用来向服务器获取资源，而GET请求本身不应该携带任何呈现数据</li><li><strong>POST(传输实体文本)</strong> 向指定资源提交数据进行处理请求；数据被包含在POST请求体中(例如提交表单或者上传文件)；POST请求可能会导致新的资源的建立或已有资源的修改</li><li><strong>MVC中，控制器的定义</strong></li><li>在Spring MVC中，控制器是指类或者类的方法上添加了@RequestMapping注解的类，并不是使用了@Controller注解的类就是控制器类</li><li>@Controller注解的类和@Component注解的类在功能上是一样的，都是在辅助@ComponentScan实现组件扫描</li><li>只是在表意上，在用@Controller注解控制器类比用@Component注解控制器类更清楚一些</li></ul> 
<h4 id="%E5%A4%A7%E8%87%B4%E5%8C%BA%E5%88%AB"><span style="color:#956fe7;">大致区别</span></h4> 
<p>SpringMVC以前版本的@RequestMapping，到了新版本被下面新注解替代，相当于增加的选项：</p> 
<ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li><li>@PatchMapping</li></ul> 
<p>从命名约定我们可以看到每个注解都是为了处理各自的传入请求方法类型，即@GetMapping用于处理请求方法的GET类型，@PostMapping用于处理请求方法的POST类型等</p> 
<ul><li>如果我们想使用传统的@RequestMapping注解实现URL处理程序，那么它应该是这样的：</li><li>@RequestMapping(value = "/get/{id}", method = RequestMethod.GET)</li><li><strong>新方法可以简化为：</strong></li><li>@GetMapping("/get/{id}")</li><li><strong>@RequestMapping</strong>是一个非常通用的注解，它可以应用于类和方法层面</li><li>用于将任意HTTP请求映射到控制器方法上</li><li>@RequestMapping表示共享映射，如果没有指定请求方式，将接收所有的HTTP请求方式</li><li>需要注意的是，大多数控制器方法都应该映射到一个特定的HTTP方法，而不是使用@RequestMapping共享映射</li><li>当应用于类时，表示该类处理所有的请求；当应用于方法时，表示该方法处理特定的请求</li><li>此外，@RequestMapping还可以用来指定请求的URL、HTTP方法等；例如：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/80/58/AWmPCIpH_o.png"></li><li>在上述代码中，handleRequest方法将处理所有发送到”/test”的HTTP GET请求</li><li>在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上；之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系</li><li><strong>@GetMapping</strong>是@RequestMapping的特化版本，专门用于处理HTTP GET请求</li><li>用于将GET请求映射到控制器处理方法上；当客户端发送HTTP GET请求时，Spring Boot会自动将请求映射到具有相应URL路径的控制器方法上，然后调用该方法处理请求；在调用控制器方法之前，Spring Boot会执行一系列预处理操作，例如解析请求参数和验证请求头；在调用控制器方法之后，Spring Boot会执行一系列后处理操作，例如转换响应信息和生成响应头</li><li>@GetMapping是一个作为快捷方式的组合注解</li><li>它在功能上等价于@RequestMapping(method = RequestMethod.GET)</li><li>和@RequestMapping一样，@GetMapping也可以应用于类和方法层面</li><li>例如：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d8/bf/ayLBlhxc_o.png"></li><li>在上述代码中，home方法将处理所有发送到”/“的HTTP GET请求</li></ul> 
<h4 id="%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8A%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span style="color:#956fe7;">使用场景上的注意事项</span></h4> 
<ul><li>(1) 在前端method特指了get或post的时候分别使用@GetMapping和@PostMapping</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9b/4d/L0j1Cfrm_o.png"></li><li>(2)如果传的参数是@RequestBody，多参或者传对象的情况下使用@PostMappping这种注解</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/79/fb/ECwK6gy5_o.png"></li><li>因为@RequestBody是获取请求body中的数据，常用于搭配@PostMapping请求来提交对象数据</li></ul> 
<h4 id="%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span style="color:#956fe7;">如何工作</span></h4> 
<ul><li>所有上述注解都已在内部注解了@RequestMapping以及方法元素中的相应值</li><li>例如，如果我们查看@GetMapping注解的源代码，我们可以看到它已经通过以下方式使用RequestMethod.GET进行了注解：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/63/e9/5hRCwGZU_o.png"></li><li>所有其他注解都以相同的方式创建，即@PostMapping使用RequestMethod.POST进行注解，@PutMapping使用RequestMethod.PUT进行注解等</li></ul> 
<h4 id="%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span style="color:#956fe7;">使用案例</span></h4> 
<ul><li><strong>(案例1)</strong> 下面是结合RestController的简单使用：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/02/d4/N44WYTOq_o.png"></li><li><strong>(案例2)</strong> 下面是使用@Controller的代码：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9c/92/oewIemPC_o.png"></li><li>在上面的代码中，HomeController类充当请求控制器；它的homeInit()方法将处理所有传入的URI请求"/"；它接受一个Model并返回视图home；使用配置的视图解析器解析视图名称”home“的页面</li><li><strong>(案例3)</strong> 下面是一个同时在类和方法上应用了 @RequestMapping 注解的示例：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/a7/Do6xLwnt_o.png"></li><li>如上述代码所示，到 /user/login 的请求会由 login() 方法来处理，而到 /user/register 的请求会由 register() 来处理</li><li><strong>(案例4)</strong> 将控制器方法映射到一个特定的HTTP方法上，应用@GetMapping、@PostMapping：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e3/27/l9CHesKe_o.png"></li><li>通常，这样代码更规范，因为login登录时只需要向服务器获取用户数据，register注册时需要向服务器提交数据</li><li>组合注解对控制器方法的请求映射进行具体区分，减少了在应用程序上要配置的元数据，并且代码也更易读，有助于控制器对请求的快速匹配以及代码功能区分等</li><li><strong>(案例5)</strong> 在下面的示例中，@RequestParam注解表示请求参数“name”的值将被注入到方法参数中</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/a2/90/UVT65p3L_o.png"></li><li>当客户端发送HTTP GET请求“/api/hello?name=world”时，Spring Boot会自动将请求映射到hello()方法，并将参数“world”注入到方法参数中，最终返回字符串“Hello, world!”</li></ul> 
<h4 id="%E5%86%99%E6%B3%95%E5%AF%B9%E6%AF%94"><span style="color:#956fe7;">写法对比</span></h4> 
<ul><li>@RequestMapping：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d7/38/q2Y0TfvV_o.png"></li><li>@PostMapping：</li><li style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6f/9b/SyhPwdiF_o.png"></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ac50b48f7352ee1c1d50520d8a8730c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">力扣hot100题解（python版55-59题）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/853a003a675f3d98e6f02d81ce0471b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Golang基于Redis bitmap实现布隆过滤器（完结版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>