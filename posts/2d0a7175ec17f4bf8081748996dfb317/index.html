<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Promise 实现原理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Promise 实现原理" />
<meta property="og:description" content="前言 这篇文章主要是探究 Promise 的实现原理，对于使用方法，这里不做过多概述，如果还有对 Promise 使用方式不太了解的，可以先看 阮一峰老师的 Promise 教程
Promise 是什么,为什么会出现 Promise？ 抽象表达： Promise 是一门新的技术（ES6规范）Promise 是js 中进行异步变成的新解决方案,在没有 Promise 之前，旧方案是单纯使用回调函数 具体表达： 从语法上来说： promise 是一个构造函数从功能上来说：promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值 作用： Promise 主要是用来解决回调地狱的问题，在没有Promise 之前，如果异步任务比较多，并且有相互依赖的作用，就只能使用回调函数的方式来处理，这样就会形成回调地狱，代码可读性和可维护性会很差。Promise 的 then 方法支持链式调用，很好的解决了之前使用回调函数的书写方式，使代码逻辑很有条理但是Promise 也是有缺点的，首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise 的状态改变 promise 有三种状态
pending (初始状态，或者说是执行中的状态),resolved || fulfilled (已成功，下文中将使用 fulfilled 作为已成功的状态)rejected (已失败)
状态的改变只有两种方式 pending =&gt; fulfilled 或者 pending =&gt; rejected, 并且状态一经改变完成，就不可逆。成功的结果数据一般称为 value 失败的结果数据一般称为 reason Promise 的基本流程如下图 以上对 Promise 做了一个简单的概述，下边我们来实现一个自己的 Promise
Promise 手动实现 首先我们先看下 原生的 Promise 实例对象中都包含的内容：
通过打印看到实例对象的原型上 包含 catch、finally、then、和 constructor 构造函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2d0a7175ec17f4bf8081748996dfb317/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-21T21:43:05+08:00" />
<meta property="article:modified_time" content="2021-02-21T21:43:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Promise 实现原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p><strong>这篇文章主要是探究 Promise 的实现原理，对于使用方法，这里不做过多概述，如果还有对 Promise 使用方式不太了解的，可以先看 <a href="https://es6.ruanyifeng.com/#docs/promise" rel="nofollow">阮一峰老师的 Promise 教程</a></strong></p> 
<h3><a id="Promise__Promise_3"></a>Promise 是什么,为什么会出现 Promise？</h3> 
<ol><li>抽象表达： 
  <ol><li>Promise 是一门新的技术（ES6规范）</li><li>Promise 是js 中进行异步变成的新解决方案,在没有 Promise 之前，旧方案是单纯使用回调函数</li></ol> </li><li>具体表达： 
  <ol><li>从语法上来说： promise 是一个构造函数</li><li>从功能上来说：<strong>promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值</strong></li></ol> </li><li>作用： 
  <ol><li>Promise 主要是用来解决回调地狱的问题，在没有Promise 之前，如果异步任务比较多，并且有相互依赖的作用，就只能使用回调函数的方式来处理，这样就会形成回调地狱，代码可读性和可维护性会很差。</li><li>Promise 的 then 方法支持链式调用，很好的解决了之前使用回调函数的书写方式，使代码逻辑很有条理</li><li><strong>但是Promise 也是有缺点的，首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</strong></li></ol> </li></ol> 
<h3><a id="Promise__16"></a>Promise 的状态改变</h3> 
<p>promise 有三种状态</p> 
<ol><li><code>pending (初始状态，或者说是执行中的状态)</code>,</li><li><code>resolved || fulfilled (已成功，下文中将使用 fulfilled 作为已成功的状态)</code></li><li><code>rejected (已失败)</code><br> 状态的改变只有两种方式 <code>pending =&gt; fulfilled 或者 pending =&gt; rejected</code>, 并且状态一经改变完成，就不可逆。成功的结果数据一般称为 <code>value</code> 失败的结果数据一般称为 <code>reason</code></li></ol> 
<h3><a id="Promise__23"></a>Promise 的基本流程如下图</h3> 
<p><img src="https://images2.imgbox.com/ae/11/HRAlTbp7_o.png" alt="在这里插入图片描述"><br> 以上对 Promise 做了一个简单的概述，下边我们来实现一个自己的 Promise</p> 
<h3><a id="Promise__27"></a>Promise 手动实现</h3> 
<p>首先我们先看下 原生的 Promise 实例对象中都包含的内容：<br> <img src="https://images2.imgbox.com/40/97/VQ2d6kkN_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/92/db/bvMqLazC_o.png" alt="在这里插入图片描述"></p> 
<p>通过打印看到实例对象的原型上 包含 <code>catch、finally、then、和 constructor 构造函数</code><br> 最下边还有两个双方括号包含的内置属性 <code>PromiseState、对应的就是Pormise 的状态 pending/ fulfilled/rejected 。 PromiseResult 对应的就是执行完成后，成功或失败的结果，</code></p> 
<p><strong>下边我们根据上图的内容，和 Promise API 先搭建一下 Promise 的整体框架代码如下:</strong></p> 
<pre><code class="prism language-javascript"><span class="token comment">// 这里直接声明一个 Promise 类可以覆盖掉 原生 Promise</span>
<span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 添加初始属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'pending'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> <span class="token keyword">null</span>

    <span class="token comment">// 声明一个栈，用来存放then方法中的回调，onResolved, onRejected，之所以用栈，是因为</span>
    <span class="token comment">// 同一个实例 可以同时制定多个 then 方法，也就会有多个回调</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token comment">// 保存实例对象 this</span>
    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>

    <span class="token comment">// resolve 函数</span>
    <span class="token keyword">function</span> <span class="token function">resolve</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>

    <span class="token comment">// reject 函数</span>
    <span class="token keyword">function</span> <span class="token function">reject</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 执行器函数</span>
    <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加 then 方法 === es5  Promise.prototype.then () {}  方法</span>
  <span class="token function">then</span> <span class="token punctuation">(</span>onResolved<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加 catch 方法 === es5  Promise.prototype.catch () {}  方法</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加 resolve 方法  === es5 Promise.resolve () {} 方法</span>
  <span class="token keyword">static</span> <span class="token function">resolve</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 添加 reject 方法  === es5 Promise.reject () {} 方法</span>
  <span class="token keyword">static</span> <span class="token function">reject</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 添加 all 方法 === es5 Promise.all () {} 方法</span>
  <span class="token keyword">static</span> <span class="token function">all</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 添加 race 方法  === es5 Promise.race () {} 方法</span>
  <span class="token keyword">static</span> <span class="token function">race</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>上边的代码中 static 关键字 static 是ES6 class 中的新语法，用来声明 类中的静态方法<br> 上边的 constructor(executor) 中的 executor 参数是执行器函数作为参数，其实就是下边代码中实例化 Promise 对象中的函数中的 参数 <code>(resolve, reject) =&gt; {}</code> 这部分内容，这个函数参数中有两个函数，第一个习惯上叫做 resolve 是成功的状态下执行的函数， 第二个是 reject 是失败状态下执行的函数</p> 
</blockquote> 
<pre><code class="prism language-javascript">    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Ok'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>接下来我们开始一步步的完善上边的 Promise 类</p> 
<h4><a id="1_constructor__resolve__reject__96"></a>1、完善 constructor 中的 resolve() 和 reject() 函数</h4> 
<p>示例代码</p> 
<pre><code class="prism language-javascript">  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Ok'</span><span class="token punctuation">)</span>
      <span class="token comment">// reject('Error')</span>
      <span class="token comment">// throw 'Error' // 这里抛出错误，错误信息 也会赋值给 PromiseResult 属性，对应的  PromiseState 状态变为 rejected</span>
      <span class="token comment">// 使用定时器 来模拟异步操作，执行成功后调用 resolve， 失败调用 reject  </span>
      <span class="token comment">// setTimeout(() =&gt; {<!-- --></span>
      <span class="token comment">//   // resolve('OK')</span>
      <span class="token comment">//   reject('Error')</span>
      <span class="token comment">// }, 1000)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

</code></pre> 
<p>首先根据上边的示例来写 constructor 中的 resolve() 和 reject()</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 直接覆盖掉 原生 promise</span>
<span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 添加初始属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'pending'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> <span class="token keyword">null</span>

    <span class="token comment">// 声明一个栈，用来存放then方法中的回调，onResolved, onRejected，之所以用栈，是因为</span>
    <span class="token comment">// 同一个实例 可以同时制定多个 then 方法，也就会有多个回调</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token comment">// 保存实例对象 this</span>
    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>

    <span class="token comment">// resolve 函数</span>
    <span class="token keyword">function</span> <span class="token function">resolve</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 修改状态前，先判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token comment">// 1.修改对象状态 (promiseSate)</span>
      self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'fulfilled'</span> <span class="token comment">// resolved</span>
      <span class="token comment">// 2.设置对象结果值 (promiseResult)</span>
      self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data
    <span class="token punctuation">}</span>

    <span class="token comment">// reject 函数</span>
    <span class="token keyword">function</span> <span class="token function">reject</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 修改状态前，先判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token comment">// 1.修改对象状态 (promiseSate)</span>
      self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'rejected'</span>
      <span class="token comment">// 2.设置对象结果值 (promiseResult)</span>
      self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 执行器函数</span>
    <span class="token comment">// 这里使用 try catch 是为了捕获执行器执行的时候抛出异常</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 同步调用[执行器函数(也就是 executor)]</span>
      <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 修改 Promise 对象状态为 失败</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
  <span class="token operator">...</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>首先我们用：</p> 
 <ol><li><code>this.PromiseState = 'pending'</code> 来管理状态，状态改变的时候直接修改这个变量的值 。</li><li><code>this.PromiseResult = null</code> 这个变量用来管理 执行完成后返回的结果值</li><li><code>this.callbacks = []</code> 栈用来存放，当实例对象指定多个 then 方法时，传入的 onResolved onRejected 回调函数，后续会说明。</li></ol> 
</blockquote> 
<blockquote> 
 <ol><li>上边我们说过改变 Promise 状态的两种方式是 <code>pending =&gt; fulfilled 或者 pending =&gt; rejected</code>, 并且状态一经改变完成，就不可逆</li><li>所以在 resolve 和 reject 函数中要先判断 <code>PromiseState</code> 如果不是初始状态 <code>pending</code> 的情况下直接 <code>return</code> 不继续向下执行. 否则就是 <code>pending</code> 状态，对应的改变 PromiseState 状态为 <code>fulfilled || rejected</code> 和 PromiseResult 的值</li></ol> 
</blockquote> 
<h4><a id="2__then__173"></a>2、完善 原型上的 then 方法</h4> 
<p>示例代码</p> 
<pre><code class="prism language-javascript">  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Ok'</span><span class="token punctuation">)</span>
      <span class="token comment">// reject('Error')</span>

      <span class="token comment">// setTimeout(() =&gt; {<!-- --></span>
      <span class="token comment">//   // resolve('OK')</span>
      <span class="token comment">//   reject('Error')</span>
      <span class="token comment">// }, 1000)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// Ok</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> reason <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token comment">// 调用 reject 这里 reason 就是 Error</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 下边的注释打开以后，就等于是给 实例对象 p 指定了 多个 then 方法,这种情况下，多个 then 方法都会被执行</span>
    <span class="token comment">// p.then(value =&gt; {<!-- --></span>
    <span class="token comment">//   alert(value)</span>
    <span class="token comment">// }, reason =&gt; {<!-- --></span>
    <span class="token comment">//   alert(reason)</span>
    <span class="token comment">// })</span>
    
   <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
</code></pre> 
<blockquote> 
 <p>then 方法特性：<br> 接受两个回调函数:</p> 
 <ol><li>onResolved 函数: 成功的回调函数 (value) =&gt; {}<br> PromiseState =&gt; fulfilled PromiseResult =&gt; 成功的返回值</li><li>onRejected 函数: 失败的回调函数 (reason) =&gt; {}<br> PromiseState =&gt; rejected PromiseResult =&gt; 失败的返回值</li><li>以上两个参数都是可选的，如果调用 then 方法的时候两个参数都不传，为了不影响then后续的链式调用，then方法内部需要自己再执行onResolved 和 onRejected函数 ，这样如果执行过程中抛出异常就会被 then 最后的 catch 方法捕捉到。onResolved 后，就不会影响后续的 then 方法的执行</li><li>then 方法中会返回一个 Promise 对象，这样才可以开启 then 方法的链式调用，通过then的链式调用串连多个同步/异步任务</li><li>如果 then 方法中抛出一个异常 throw ‘Fail’ 错误信息 也会赋值给 PromiseResult 属性，对应的 PromiseState 状态变为 rejected<br> 抛出异常示例代码</li></ol> 
</blockquote> 
<pre><code class="prism language-javascript">    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Ok'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">let</span> res <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">throw</span> <span class="token string">'Fail'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> reason <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>res 示例对象中的 PromiseResult = ‘Fail’ PromiseState = ‘rejected’</p> 
</blockquote> 
<blockquote> 
 <ol start="6"><li>如果Promise 对象中封装了任务，然后在调用实例对象上的 then 方法的时候，这里会涉及到一个状态改变的时机问题，<br> 如果封装的是同步任务，则先改变状态，在执行 then 方法中的回调函数<br> 如果封装的是异步任务，则先执行 then 方法中的回调，然后把then 中的onResolved 和 onRejected 存起来 等异步任务执行完成以后在 修改 状态，再执行之前存储的 onResolved 或者 onRejected 示例如下</li></ol> 
</blockquote> 
<pre><code class="prism language-javascript">  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'OK'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> reason <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> 
<p>完善 then 方法</p> 
<pre><code class="prism language-javascript"><span class="token operator">...</span>
<span class="token operator">...</span>
  <span class="token comment">// 添加 then 方法</span>
  <span class="token function">then</span> <span class="token punctuation">(</span>onResolved<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment">// 判断调用 then 方法的时候，回调函数参数 onRejected 没有传的情况,给 onRejected 指定一个函数，如果执行失败，就会走这个指定的</span>
    <span class="token comment">// onRejected 函数，然后抛出错误，链式调用最后边的 catch 就会捕获到</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function-variable function">onRejected</span> <span class="token operator">=</span> reason <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> reason
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断如果调用 then 方法的时候什么都不传，并且后边还跟着 then 方法的情况，给 onResolved 指定一个函数执行，这样可以让后边的 then 不受影响继续向下执行</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onResolved <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function-variable function">onResolved</span> <span class="token operator">=</span> value <span class="token operator">=&gt;</span> value
    <span class="token punctuation">}</span>
    <span class="token comment">// 这里之所以需要 return Promise 是因为，then 方法调用也会有返回Promise对象</span>
    <span class="token comment">// 返回的 Promise 对象中的 PromiseResult 的值取决于 传入进来的 onResolved 回调函数执行后的返回值</span>
    <span class="token comment">// 返回的 Promise 对象中的 PromiseState 的值取决于：</span>
    <span class="token comment">//    执行器中的回调函数是同步操作：PromiseState = 执行器中调用的回调函数 是 resolve(fulfilled) 还是 reject(rejected)</span>
    <span class="token comment">// </span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 封装函数</span>
      <span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里的 try  catch 是为了防止实例对象调用 then 方法中的两个回调 onResolved， onRejected 函数中抛出错误的时候可以继续执行代码，并捕获错误信息</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 获取回调函数的执行结果</span>
          <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseResult<span class="token punctuation">)</span>
          <span class="token comment">// 判断</span>
          <span class="token comment">// 如果实例中调用 then 方法的返回值也是一个 Promise对象，这里的 result等于也就是一个 Promise 对象的实例</span>
          <span class="token comment">// 然后继续调用实例上的 then 方法执行对应的 resolve() 和 reject 就可以，这样就会重新去执行 Promise 构造函数中的</span>
          <span class="token comment">// resolve 或者 reject 方法</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果是Promise 类型的对象</span>
            result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
              <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
              <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 结果的对象状态为 [成功]</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 调用回调函数，先判断 PromiseState 状态</span>
      <span class="token comment">// 这里是同步的状态下，已经修改过状态，并修改了结果以后，执行到 then 的操作</span>
      <span class="token comment">// 所以要先判断状态</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">===</span> <span class="token string">'fulfilled'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里要用 setTimeout 包裹一下，使其变为异步任务，把任务放进队列</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">callback</span><span class="token punctuation">(</span>onResolved<span class="token punctuation">)</span> 
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">===</span> <span class="token string">'rejected'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里要用 setTimeout 包裹一下，使其变为异步任务，把任务放进队列</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">callback</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  
      <span class="token comment">// 这里是异步执行的状态下，状态还是 pending 没有被修改过，说明异步执行还在执行过程中，</span>
      <span class="token comment">// 然后先执行到了 then 方法。这里需要先把 onResolved， onRejected 两个回调函数先存一下</span>
      <span class="token comment">// 等到异步执行完成，调用了 resolve || reject 的时候，在 resolve || reject 函数中再去判断</span>
      <span class="token comment">// callback 对象中是否有存储回调函数，有的话在执行回调函数</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
          onResolved<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">callback</span><span class="token punctuation">(</span>onResolved<span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          onRejected<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">callback</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>
  <span class="token operator">...</span>
</code></pre> 
<blockquote> 
 <p>完善了 then 方法以后，还要对应的在继续完善下 constructor 中的 resolve reject 方法 ,因为上边的代码最后部分 我们可以看到 ，如果给实例对象 p 指定多个 then 方法的情况下，onResolved / onRejected回调函数会被 追加到 callbacks 栈中，在 constructor 中的 resolve reject 方法是 执行完成后调用的方法，这两个方法执行的最后也要对应的执行下 callbacks 栈中的回调函数<br> 代码如下：</p> 
</blockquote> 
<pre><code class="prism language-javascript">  <span class="token function">constructor</span> <span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token operator">...</span>
	<span class="token operator">...</span>
    <span class="token comment">// resolve 函数</span>
    <span class="token keyword">function</span> <span class="token function">resolve</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 修改状态前，先判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token comment">// 1.修改对象状态 (promiseSate)</span>
      self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'fulfilled'</span> <span class="token comment">// resolved</span>
      <span class="token comment">// 2.设置对象结果值 (promiseResult)</span>
      self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data
      <span class="token comment">// Promise实例中，异步执行完成，执行回调</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        self<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          item<span class="token punctuation">.</span><span class="token function">onResolved</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// reject 函数</span>
    <span class="token keyword">function</span> <span class="token function">reject</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 修改状态前，先判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token comment">// 1.修改对象状态 (promiseSate)</span>
      self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'rejected'</span>
      <span class="token comment">// 2.设置对象结果值 (promiseResult)</span>
      self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data
      <span class="token comment">// Promise实例中，异步执行完成，执行回调</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        self<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          item<span class="token punctuation">.</span><span class="token function">onRejected</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
	<span class="token operator">...</span>
	<span class="token operator">...</span>
  <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>上边的内容不是很好理解，最好是根据 then 方法的特性，写一下示例运行下代码比较好。</p> 
</blockquote> 
<h4><a id="_catch__374"></a>完善原型上的 catch 方法</h4> 
<p>代码示例</p> 
<pre><code class="prism language-javascript">    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// resolve('Ok')</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1111</span><span class="token punctuation">)</span>
      <span class="token comment">// throw 'Errr'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2222</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3333</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>reason <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>catch 特性：</p> 
 <ol><li>接受一个失败的回调函数，这个参数是必须传的。</li><li>异常穿透</li></ol> 
</blockquote> 
<blockquote> 
 <ol><li>上边的代码如果调用 resolve(‘Ok’) 下边then 方法上的执行顺序是从上到下依次执行的，如果调用的是 reject(‘Error’) 则上边的所有then 方法都不会执行，只执行最后的 catch 方法进行错误捕获。</li><li>如果第一个then 中的 throw ‘Error’ 抛出错误以后，下边的两个 then 方法也不会执行，只执行最后的 catch 方法<br> <strong>这种特性叫做异常穿透，如果执行过程中任何一个环节出现错误，都会传到最后失败的回调中处理</strong></li></ol> 
</blockquote> 
<p>下边完善 catch 方法, catch 方法的实现很简单，直接调用 then 方法，并且把 失败的 onRejected 回调函数传入即可， then 方法内部做了 try catch 的异常捕获，只要捕获到 异常，就会执行 rejecte(e) 方法，PromiseState=’rejected‘ PromiseResult=’异常信息‘</p> 
<pre><code class="prism language-javascript"> <span class="token operator">...</span>
  <span class="token comment">// 添加 catch 方法</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>
</code></pre> 
<h4><a id="_Promiseresolve__414"></a>完善 Promise.resolve 方法</h4> 
<p>示例代码：</p> 
<pre><code class="prism language-javascript">    <span class="token comment">// const p = Promise.resolve('OK')</span>
    <span class="token comment">// console.log(p)</span>

    <span class="token comment">// const p2 = Promise.resolve(new Promise((resolve, reject) =&gt; {<!-- --></span>
    <span class="token comment">//   // resolve('success')</span>
    <span class="token comment">//   reject('error')</span>
    <span class="token comment">// }))</span>
    <span class="token comment">// console.log(p2)</span>


    <span class="token keyword">const</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Oh Yeah'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span>
</code></pre> 
<p>静态方法 resolve() 完善</p> 
<pre><code class="prism language-javascript"><span class="token operator">...</span>
  <span class="token comment">// 添加 resolve 方法</span>
  <span class="token keyword">static</span> <span class="token function">resolve</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 返回 promise 对象</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 如果传入的 value 也是promise 实例， 则执行这个实例的 then 方法，然后执行对应的 resolve  reject 方法</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果不是 promise 对象，直接设置成功</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>
</code></pre> 
<blockquote> 
 <p>因为 Promise.resolve 方法执行完成后也会返回一个 Promise 对象，所以这个静态方法中也要返回一个实例化后的 Promise 对象</p> 
</blockquote> 
<h4><a id="Promisereject__456"></a>完善Promise.reject() 方法</h4> 
<p>示例代码：</p> 
<pre><code class="prism language-javascript">  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>

    <span class="token keyword">const</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Ok'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> 
<p>完善静态方法 reject</p> 
<pre><code class="prism language-javascript">  <span class="token comment">// 添加 reject 方法</span>
  <span class="token keyword">static</span> <span class="token function">reject</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>因为 reject() 方法的作用就是执行失败的回调，并返回一个 Promise 对象，所以 reject 静态方法中直接返回 实例化的 Promise 对象，并调用这个对象的 reject 方法。把失败信息传入到 reject(reason)中</p> 
</blockquote> 
<h4><a id="_Pomiseall__482"></a>完善 Pomise.all() 方法</h4> 
<p>示例代码：</p> 
<pre><code class="prism language-javascript">    <span class="token comment">// let p1 = new Promise((resolve, reject) =&gt; {<!-- --></span>
    <span class="token comment">//   setTimeout(() =&gt; {<!-- --></span>
    <span class="token comment">//     resolve('OK')</span>
    <span class="token comment">//   }, 1000);</span>
    <span class="token comment">// })</span>

    <span class="token comment">// let p2 = Promise.resolve('SUccess')</span>
    <span class="token comment">// let p3 = Promise.resolve('Oh Yeah')</span>

    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'OK'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token keyword">let</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'SUccess'</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Oh Yeah'</span><span class="token punctuation">)</span>


    <span class="token comment">// 调用 all 方法</span>
    <span class="token comment">// debugger</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>all() 方法的特性：</p> 
 <ol><li>all 方法中接受一个数组，数组中的每一项都是一个 Promise 对象，数组中的这些 Promise 对象全部都执行成功后的 resolve() 方法，才会最终成功，状态变为 fulfilled 返回值也是一个数组，数组中的每一项对应 all([ ]) 方法数组中每个 Promise 对象返回的结果值。如果其中只要有一个失败，就会全部失败，状态直接变为 rejected， 返回值也会变为失败返回的值。</li></ol> 
</blockquote> 
<p>完善 all 静态方法</p> 
<pre><code class="prism language-javascript">  <span class="token comment">// 添加 all 方法</span>
  <span class="token keyword">static</span> <span class="token function">all</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 返回结果是 promise 对象</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 声明变量</span>
      <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
      <span class="token comment">// 遍历</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//</span>
        promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 得知对象的状态是成功 每个 promise 对象都成功</span>
          count<span class="token operator">++</span>
          <span class="token comment">// 将当前 promise 对象成功的结果，存入到数组中,这里最好不好使用 push 添加，这样顺序有可能会乱，要使用下标的方式添加</span>
          arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v
          <span class="token comment">// 确保 all 中所有的 Promise 对象都执行成功了，再去改变 promiseState 状态，再赋值</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>上边有个很关键的部分，要确保所有的Promise 对象都执行成功以后，再去调用 resolve() 方法，resolve 方法中再修改 PromiseState 状态为 fulfilled</p> 
</blockquote> 
<h4><a id="_Promiserace__543"></a>完善 Promise.race() 静态方法</h4> 
<p>示例代码：</p> 
<pre><code class="prism language-javascript">  <span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>

    <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'OK'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// let p2 = Promise.resolve('SUccess')</span>
    <span class="token keyword">let</span> p2 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> p3 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'Oh Yeah'</span><span class="token punctuation">)</span>


    <span class="token comment">// 调用 all 方法</span>
    <span class="token comment">// debugger</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> 
<blockquote> 
 <p>race() 方法特性：<br> race 翻译后是赛跑的意思，这个方法中也是接受一个数组作为参数，数组的每一项都是一个 promise 对象。这些对象中最先执行完成并且成功的返回值会作为 PromiseResult 的值，状态变为 fulfilled 。 如果其中有一个失败的，这个失败的对象的 返回值 会作为 PromiseResult 的值，状态变为 rejected</p> 
</blockquote> 
<p>完善 race() 静态方法</p> 
<pre><code class="prism language-javascript">  <span class="token comment">// 添加 race 方法</span>
  <span class="token keyword">static</span> <span class="token function">race</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 修改返回对象的状态为 [成功]</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 修改返回对象的状态为 [失败]</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
</code></pre> 
<p>至此 Promise 封装完成。完整代码如下</p> 
<pre><code class="prism language-javascript"><span class="token comment">// 直接覆盖掉 原生 promise</span>
<span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span>executor<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 添加初始属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'pending'</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> <span class="token keyword">null</span>

    <span class="token comment">// 声明一个栈，用来存放then方法中的回调，onResolved, onRejected，之所以用栈，是因为</span>
    <span class="token comment">// 同一个实例 可以同时制定多个 then 方法，也就会有多个回调</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token comment">// 保存实例对象 this</span>
    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>

    <span class="token comment">// resolve 函数</span>
    <span class="token keyword">function</span> <span class="token function">resolve</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 修改状态前，先判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token comment">// 1.修改对象状态 (promiseSate)</span>
      self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'fulfilled'</span> <span class="token comment">// resolved</span>
      <span class="token comment">// 2.设置对象结果值 (promiseResult)</span>
      self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data
      <span class="token comment">// Promise实例中，异步执行完成，执行回调</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        self<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          item<span class="token punctuation">.</span><span class="token function">onResolved</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// reject 函数</span>
    <span class="token keyword">function</span> <span class="token function">reject</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 修改状态前，先判断</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseState <span class="token operator">!==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
      <span class="token comment">// 1.修改对象状态 (promiseSate)</span>
      self<span class="token punctuation">.</span>PromiseState <span class="token operator">=</span> <span class="token string">'rejected'</span>
      <span class="token comment">// 2.设置对象结果值 (promiseResult)</span>
      self<span class="token punctuation">.</span>PromiseResult <span class="token operator">=</span> data
      <span class="token comment">// Promise实例中，异步执行完成，执行回调</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        self<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          item<span class="token punctuation">.</span><span class="token function">onRejected</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 这里使用 try catch 是为了捕获执行器执行的时候抛出异常</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 同步调用[执行器函数(也就是 executor)]</span>
      <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 修改 Promise 对象状态为 失败</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加 then 方法</span>
  <span class="token function">then</span> <span class="token punctuation">(</span>onResolved<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> self <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment">// 判断调用 then 方法的时候，回调函数参数 onRejected 没有传的情况,给 onRejected 指定一个函数，如果执行失败，就会走这个指定的</span>
    <span class="token comment">// onRejected 函数，然后抛出错误，链式调用最后边的 catch 就会捕获到</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onRejected <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function-variable function">onRejected</span> <span class="token operator">=</span> reason <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> reason
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断如果调用 then 方法的时候什么都不传，并且后边还跟着 then 方法的情况，给 onResolved 指定一个函数执行，这样可以让后边的 then 不受影响继续向下执行</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> onResolved <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function-variable function">onResolved</span> <span class="token operator">=</span> value <span class="token operator">=&gt;</span> value
    <span class="token punctuation">}</span>
    <span class="token comment">// 这里之所以需要 return Promise 是因为，then 方法调用也会有返回Promise对象</span>
    <span class="token comment">// 返回的 Promise 对象中的 PromiseResult 的值取决于 传入进来的 onResolved 回调函数执行后的返回值</span>
    <span class="token comment">// 返回的 Promise 对象中的 PromiseState 的值取决于：</span>
    <span class="token comment">//    执行器中的回调函数是同步操作：PromiseState = 执行器中调用的回调函数 是 resolve(fulfilled) 还是 reject(rejected)</span>
    <span class="token comment">// </span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 封装函数</span>
      <span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里的 try  catch 是为了防止实例对象调用 then 方法中的两个回调 onResolved， onRejected 函数中抛出错误的时候可以继续执行代码，并捕获错误信息</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 获取回调函数的执行结果</span>
          <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">type</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>PromiseResult<span class="token punctuation">)</span>
          <span class="token comment">// 判断</span>
          <span class="token comment">// 如果实例中调用 then 方法的返回值也是一个 Promise对象，这里的 result等于也就是一个 Promise 对象的实例</span>
          <span class="token comment">// 然后继续调用实例上的 then 方法执行对应的 resolve() 和 reject 就可以，这样就会重新去执行 Promise 构造函数中的</span>
          <span class="token comment">// resolve 或者 reject 方法</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 如果是Promise 类型的对象</span>
            result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
              <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
              <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 结果的对象状态为 [成功]</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// 调用回调函数，先判断 PromiseState 状态</span>
      <span class="token comment">// 这里是同步的状态下，已经修改过状态，并修改了结果以后，执行到 then 的操作</span>
      <span class="token comment">// 所以要先判断状态</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">===</span> <span class="token string">'fulfilled'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里要用 setTimeout 包裹一下，使其变为异步任务，把任务放进队列</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">callback</span><span class="token punctuation">(</span>onResolved<span class="token punctuation">)</span> 
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">===</span> <span class="token string">'rejected'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这里要用 setTimeout 包裹一下，使其变为异步任务，把任务放进队列</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">callback</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  
      <span class="token comment">// 这里是异步执行的状态下，状态还是 pending 没有被修改过，说明异步执行还在执行过程中，</span>
      <span class="token comment">// 然后先执行到了 then 方法。这里需要先把 onResolved， onRejected 两个回调函数先存一下</span>
      <span class="token comment">// 等到异步执行完成，调用了 resolve || reject 的时候，在 resolve || reject 函数中再去判断</span>
      <span class="token comment">// callback 对象中是否有存储回调函数，有的话在执行回调函数</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>PromiseState <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
          onResolved<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">callback</span><span class="token punctuation">(</span>onResolved<span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          onRejected<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">callback</span><span class="token punctuation">(</span>onRejected<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加 catch 方法</span>
  <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>undefined<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 添加 resolve 方法</span>
  <span class="token keyword">static</span> <span class="token function">resolve</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 返回 promise 对象</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 如果传入的 value 也是promise 实例， 则执行这个实例的 then 方法，然后执行对应的 resolve  reject 方法</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 如果不是 promise 对象，直接设置成功</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 添加 reject 方法</span>
  <span class="token keyword">static</span> <span class="token function">reject</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 添加 all 方法</span>
  <span class="token keyword">static</span> <span class="token function">all</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 返回结果是 promise 对象</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token comment">// 声明变量</span>
      <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
      <span class="token comment">// 遍历</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//</span>
        promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 得知对象的状态是成功 每个 promise 对象都成功</span>
          count<span class="token operator">++</span>
          <span class="token comment">// 将当前 promise 对象成功的结果，存入到数组中,这里最好不好使用 push 添加，这样顺序有可能会乱，要使用下标的方式添加</span>
          arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> v
          <span class="token comment">// 确保 all 中所有的 Promise 对象都执行成功了，再去改变 promiseState 状态，再赋值</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">===</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 添加 race 方法</span>
  <span class="token keyword">static</span> <span class="token function">race</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>v <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 修改返回对象的状态为 [成功]</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> r <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
          <span class="token comment">// 修改返回对象的状态为 [失败]</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/315941f75150b394776fdd717785829c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java创建list对象_java – 创建一个包含多个对象类型的arraylist？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0065ea7cef68c2d0ffc07bf96f6c8dc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">qemu 规范路径,qemu KVM内核模块没有这样的文件或目录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>