<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA线程池的使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA线程池的使用" />
<meta property="og:description" content="一、使用 Executors 创建线程池
Executors是一个线程池工厂类，里面有许多静态方法，供开发者调用。
/* 该方法返回一个固定线程数量的线程池，该线程池池中的线程数量始终不变。 * 当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。 * 若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务 * 默认等待队列长度为Integer.MAX_VALUE */ ExecutorService fixedThreadPool = Executors.newFixedThreadPool(1); /* 该方法返回一个只有一个线程的线程池。 * 若多余一个任务被提交到线程池，任务会被保存在一个任务队列中，等待线程空闲，按先入先出顺序执行队列中的任务 * 默认等待队列长度为Integer.MAX_VALUE */ ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); /* * 该方法返回一个可根据实际情况调整线程数量的线程池。 * 线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。 * 若所有线程均在工作，又有新任务的提交，则会创建新的线程处理任务。 * 所有线程在当前任务执行完毕后，将返回线程池进行复用 */ ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); /* 该方法返回一个ScheduledExecutorService对象，线程池大小为1。 * ScheduledExecutorService接口在ExecutorService接口之上扩展了在给定时间内执行某任务的功能， * 如在某个固定的延时之后执行，或者周期性执行某个任务 */ ExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor(); /* * 该方法也返回一个ScheduledExecutorService对象，但该线程池可以指定线程数量 */ ExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(1); Executors 的静态方法都是基于 ThreadPoolExecutor 类实现的，相当于 ThreadPoolExecutor 的 语法糖。
但这几个静态方法都存在一个弊端，因为会在创建线程池的同时隐式创建等待队列，而队列的长度默认是 Integer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ef9b1bf663eafd9e5221c874d8b5a715/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-31T20:59:00+08:00" />
<meta property="article:modified_time" content="2022-03-31T20:59:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA线程池的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、使用 Executors 创建线程池</p> 
<p>Executors是一个线程池工厂类，里面有许多静态方法，供开发者调用。</p> 
<pre>/* 该方法返回一个固定线程数量的线程池，该线程池池中的线程数量始终不变。
 * 当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。
 * 若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务 
 * 默认等待队列长度为Integer.MAX_VALUE
 */
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(1);

/* 该方法返回一个只有一个线程的线程池。
 * 若多余一个任务被提交到线程池，任务会被保存在一个任务队列中，等待线程空闲，按先入先出顺序执行队列中的任务
 * 默认等待队列长度为Integer.MAX_VALUE
 */
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();

/* 
 * 该方法返回一个可根据实际情况调整线程数量的线程池。
 * 线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。
 * 若所有线程均在工作，又有新任务的提交，则会创建新的线程处理任务。
 * 所有线程在当前任务执行完毕后，将返回线程池进行复用
 */
ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();

/* 该方法返回一个ScheduledExecutorService对象，线程池大小为1。
 * ScheduledExecutorService接口在ExecutorService接口之上扩展了在给定时间内执行某任务的功能，
 * 如在某个固定的延时之后执行，或者周期性执行某个任务
 */
ExecutorService newSingleThreadScheduledExecutor = Executors.newSingleThreadScheduledExecutor();

/*
 * 该方法也返回一个ScheduledExecutorService对象，但该线程池可以指定线程数量
 */
ExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(1);</pre> 
<p>Executors 的静态方法都是基于 ThreadPoolExecutor 类实现的，相当于 ThreadPoolExecutor 的 语法糖。</p> 
<p>但这几个静态方法都存在一个弊端，因为会在创建线程池的同时隐式创建等待队列，而队列的长度默认是 Integer.MAX_VALUE ，相当于不限长度，这样就存在OOM的隐患。</p> 
<p>二、使用 ThreadPoolExecutor 创建线程池</p> 
<p>上面说过， Executors 的静态方法都是基于 ThreadPoolExecutor 类实现的，所以在生产环境下，还是建议直接使用 ThreadPoolExecutor 类创建线程池：</p> 
<pre>public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue);</pre> 
<p>ThreadPoolExecutor 有多个构造方法，一般来说使用最精简的即可。</p> 
<p>三、参数含义</p> 
<p>corePoolSize</p> 
<p>指定线程池的核心线程数。</p> 
<p>当一个新任务被添加到线程池时，首先会判断当前的线程数（ThreadCount），如果：</p> 
<p>A：ThreadCount &lt; corePoolSize：即当前线程数小于核心线程数，就会创建一个新的线程来执行这个任务；</p> 
<p>B：ThreadCount &gt;= corePoolSize：即当前线程数大于等于核心线程数，就会将新任务添加到等待队列中。</p> 
<p>该参数的两个特殊参数值：</p> 
<p>1、0： 意味着没有核心线程，全部线程都会受到 keepAliveTime 参数的回收机制影响。</p> 
<p>2、Integer.MAX_VALUE：意味着不限制核心线程数，连等待队列都不需要，可以想象这种情况下很容易OOM。</p> 
<p>maximumPoolSize</p> 
<p>指定线程池的最大线程数，包括核心线程和非核心线程。</p> 
<p>当另一个新任务被添加到线程池时，如果此时等待队列的容量已满，则会判断当前的线程数（ThreadCount），如果：</p> 
<p>A：ThreadCount &lt; maximumPoolSize：即当前线程数小于最大线程数，就会创建一个新的线程来执行这个任务；</p> 
<p>B：ThreadCount == maximumPoolSize：即当前线程数已达到最大值，此时等待队列的容量也已用尽，因此会抛出异常。</p> 
<p>该参数的两个特殊参数值：</p> 
<p>1、0： 意味着只有核心线程，默认情况下全部线程都不会受到 keepAliveTime 参数的回收机制影响，除非设置 allowCoreThreadTimeOut 为 true。</p> 
<p>2、Integer.MAX_VALUE：意味着不限制最大线程数，这种情况下也很容易OOM。</p> 
<p>keepAliveTime</p> 
<p>空闲线程的存活时间。</p> 
<p>默认情况下，该参数只对非核心线程有效。</p> 
<p>在处理大量任务时，可能会创建大量的非核心线程，在所有任务都执行完成后会继续保留这些非核心线程一段时间，等时间到了就会自动回收，以减少系统开销。</p> 
<p>当设置线程池的 allowCoreThreadTimeOut(true) 时，意味着该参数也同时对核心线程有效，在时间到了之后，全部线程都会自动回收。</p> 
<p>unit</p> 
<p>空闲线程存活时间的单位。</p> 
<p>workQueue</p> 
<p>等待队列。</p> 
<p>创建线程池时另外一个容易引起OOM的重要参数，主要包括以下几种：</p> 
<p>1、ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p> 
<p>2、LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按 FIFO（先进先出）排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool() 使用了这个队列。</p> 
<p>3、SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。</p> 
<p>4、PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p> 
<p>以最常用的 <strong>LinkedBlockingQueue</strong> 为例：</p> 
<pre>//创建一个容量为9999的队列实例
BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;(9999);</pre> 
<p>关于线程池各参数的作用，可以通过下面的图片进行详细了解：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1a/da/gDaXX8e7_o.png"></p> 
<p>四、使用线程池的注意事项</p> 
<p>一句话：应该最大化的，同时也要有限度的满足业务需求。</p> 
<p>在实际使用线程池时，首先应该确保所创建的线程池可以满足业务设计需求，主要就是线程数和队列容量，前者由CPU核心数限制，后者由服务器内存限制。</p> 
<p>线程太少，则消费队列的时间就长，就需要更大容量的队列；线程太多，会增加大量的上下文切换时间，反而不利于合理分配CPU的计算资源。</p> 
<p>队列太小，则添加任务时可能会抛出异常；队列太大，会占用更多的内存消耗。</p> 
<p>关键是切勿使用无边界值（Integer.MAX_VALUE），这也是造成OOM的最主要原因。</p> 
<p>可以根据服务器配置和业务需求，对这两个方面进行均衡考虑。</p> 
<p>五、使用案例</p> 
<pre>int cpuCoreCnt = Runtime.getRuntime().availableProcessors(); //获取服务器CPU核心数
int corePoolSize = cpuCoreCnt;      // 核心线程数
int maximumPoolSize = cpuCoreCnt;   // 最大线程数
int keepAliveTime = 30;             // 非核心线程的空闲存活时长（分钟）
int queueCapacity = 9999;           // 队列最大长度

BlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;(queueCapacity);
ThreadPoolExecutor threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, queue);
threadPool.allowCoreThreadTimeOut(true);    //允许回收核心线程</pre> 
<p>上面案例中，使用CPU核心数作为最大线程数，相对来说还是比较合理的。</p> 
<p>等待队列的容量尽可能设置的大一些，和添加任务时抛出异常相比，多付出一些内存来实现更大容量的队列还是非常值得的。</p> 
<p>keepAliveTime 也可以适当设置的长一些，避免太快回收，毕竟频繁的创建线程也是需要时间开销的。</p> 
<p>最后还设置了allowCoreThreadTimeOut方法，允许自动回收核心线程，用来减少阻塞线程的性能消耗。</p> 
<p>六、线程池复用</p> 
<p>线程池在完成全部的任务后，会自动进入摸鱼状态，期间会根据配置自动回收空闲线程，直到新的任务被添加进来再起来工作。</p> 
<p>即使设置了 allowCoreThreadTimeOut(true) 对核心线程进行回收，有新任务时也会重新创建核心线程继续进入工作状态。</p> 
<p>只要不是 调用 shutdown() 手动关闭它，正常情况下线程池是可以长期重复性使用的。</p> 
<p>有些强迫症患者（比如本人）会非常介意一个无所事事的线程池在内存里装死，因此必须手动 shutdown 才会安心。</p> 
<p>但这样的话，之前的线程池就彻底挂掉了，再向其中添加任务时会抛出异常。</p> 
<p>有效的做法是，将创建线程池的部分单独封装，每次添加任务时都进行判断，如果当前线程池已经挂掉了，就重新创建一个：</p> 
<pre>/**
 * &lt;p&gt;
 * 添加任务
 * 注：如果线程池已关闭，会自动创建新的线程池
 * &lt;/p&gt;
 * 
 * @param task
 */
public void addTask(Task task){
	if(threadPool.isShutdown()) createThreadPool(corePoolSize, maximumPoolSize, keepAliveTime);
	threadPool.execute(task);
}</pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4414a84d0cb49cbab3b89b1419c92f34/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【电子技术】眼图的基本概念和原理（1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1eb10a8d3c98b767bca7c9cbcc9a5d0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vuex 基础</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>