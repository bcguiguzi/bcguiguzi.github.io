<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;四种类型转换运算符 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;四种类型转换运算符" />
<meta property="og:description" content="上节讲到，隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，让程序员意识到自己在做什么。
但是，这种强调风险的方式还是比较粗放，粒度比较大，它并没有表明存在什么风险，风险程度如何。再者，C风格的强制类型转换统一使用( )，而( )在代码中随处可见，所以也不利于使用文本检索工具（例如 Windows 下的 Ctrl&#43;F、Linux 下的 grep 命令、Mac 下的 Command&#43;F）定位关键代码。
为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C&#43;&#43; 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：
关键字说明static_cast用于良性转换，一般不会导致意外发生，风险很低。const_cast用于 const 与非 const、volatile 与非 volatile 之间的转换。reinterpret_cast高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C&#43;&#43; 类型转换。dynamic_cast 借助 RTTI，用于类型安全的向下转型（Downcasting）。这四个关键字的语法格式都是一样的，具体为： xxx_cast(data)
newType 是要转换成的新类型，data 是被转换的数据。例如，老式的C风格的 double 转 int 的写法为：
double scores = 95.5; int n = (int)scores; C&#43;&#43; 新风格的写法为：
double scores = 95.5; int n = static_cast&lt;int&gt;(scores); static_cast 关键字 static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：
原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；
void 指针和具体类型指针之间的转换，例如void *转int *、char *转void *等；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/66954ef16ad2e4035f17cf19bc2f1567/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-30T23:29:03+08:00" />
<meta property="article:modified_time" content="2023-10-30T23:29:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;四种类型转换运算符</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>上节讲到，隐式类型转换是安全的，显式类型转换是有风险的，C语言之所以增加强制类型转换的语法，就是为了强调风险，让程序员意识到自己在做什么。</p> 
<p>但是，这种强调风险的方式还是比较粗放，粒度比较大，它并没有表明存在什么风险，风险程度如何。再者，C风格的强制类型转换统一使用( )，而( )在代码中随处可见，所以也不利于使用文本检索工具（例如 Windows 下的 Ctrl+F、Linux 下的 grep 命令、Mac 下的 Command+F）定位关键代码。</p> 
<p>为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++ 对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：</p> 
<table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>static_cast</td><td>用于良性转换，一般不会导致意外发生，风险很低。</td></tr><tr><td>const_cast</td><td>用于 const 与非 const、volatile 与非 volatile 之间的转换。</td></tr><tr><td>reinterpret_cast</td><td>高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的 C++ 类型转换。</td></tr><tr><td>dynamic_cast 借助 RTTI，用于类型安全的向下转型（Downcasting）。</td><td></td></tr><tr><td>这四个关键字的语法格式都是一样的，具体为：</td><td></td></tr></tbody></table> 
<blockquote> 
 <p>xxx_cast(data)</p> 
</blockquote> 
<p>newType 是要转换成的新类型，data 是被转换的数据。例如，老式的C风格的 double 转 int 的写法为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">double</span> scores <span class="token operator">=</span> <span class="token number">95.5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>scores<span class="token punctuation">;</span>
</code></pre> 
<p>C++ 新风格的写法为：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">double</span> scores <span class="token operator">=</span> <span class="token number">95.5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="static_cast__28"></a>static_cast 关键字</h4> 
<p>static_cast 只能用于良性转换，这样的转换风险较低，一般不会发生什么意外，例如：<br> 原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；<br> void 指针和具体类型指针之间的转换，例如void *转int *、char *转void *等；<br> 有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如 double 转 Complex（调用转换构造函数）、Complex 转 double（调用类型转换函数）。</p> 
<p>需要注意的是，static_cast 不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：<br> 两个具体类型指针之间的转换，例如int *转double *、Student *转int *等。不同类型的数据存储格式不一样，长度也不一样，用 A 类型的指针指向 B 类型的数据后，会按照 A 类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。<br> int 和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件。</p> 
<p>static_cast 也不能用来去掉表达式的 const 修饰和 volatile 修饰。换句话说，不能将 const/volatile 类型转换为非 const/volatile 类型。</p> 
<p>static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</p> 
<p>下面的代码演示了 static_cast 的正确用法和错误用法：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Complex</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> real <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> imag <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_real</span><span class="token punctuation">(</span>real<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_imag</span><span class="token punctuation">(</span>imag<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">operator</span> <span class="token keyword">double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_real<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">//类型转换函数</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">double</span> m_real<span class="token punctuation">;</span>
    <span class="token keyword">double</span> m_imag<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//下面是正确的用法</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    Complex <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">12.5</span><span class="token punctuation">,</span> <span class="token number">23.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> n <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//宽转换，没有信息丢失</span>
    <span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//窄转换，可能会丢失信息</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将void指针转换为具体类型指针</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将具体类型指针，转换为void指针</span>
    <span class="token keyword">double</span> real<span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用类型转换函数</span>
   
    <span class="token comment">//下面的用法是错误的</span>
    <span class="token keyword">float</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//不能在两个具体类型的指针之间进行转换</span>
    p3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0X2DF9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//不能将整数转换为指针类型</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="const_cast__74"></a>const_cast 关键字</h4> 
<p>const_cast 比较好理解，它用来去掉表达式的 const 修饰或 volatile 修饰。换句话说，const_cast 就是用来将 const/volatile 类型转换为非 const/volatile 类型。</p> 
<p>下面我们以 const 为例来说明 const_cast 的用法：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">234</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"n = "</span><span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"*p = "</span><span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：</p> 
<pre><code class="prism language-cpp">n <span class="token operator">=</span> <span class="token number">100</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">234</span>
</code></pre> 
<p>&amp;n用来获取 n 的地址，它的类型为const int *，必须使用 const_cast 转换为int *类型后才能赋值给 p。由于 p 指向了 n，并且 n 占用的是栈内存，有写入权限，所以可以通过 p 修改 n 的值。</p> 
<p>有读者可能会问，为什么通过 n 和 *p 输出的值不一样呢？这是因为 <code>C++ 对常量的处理更像是编译时期的#define，是一个值替换的过程，代码中所有使用 n 的地方在编译期间就被替换成了 100</code>。换句话说，第 8 行代码被修改成了下面的形式：<br> cout&lt;&lt;"n = "&lt;&lt;100&lt;&lt;endl;</p> 
<p>这样以来，即使程序在运行期间修改 n 的值，也不会影响 cout 语句了。更多关于 const 的内容请猛击《C++中的const又玩出了新花样》。</p> 
<p>使用 const_cast 进行强制类型转换可以突破 C/C++ 的常数限制，修改常数的值，因此有一定的危险性；但是程序员如果这样做的话，基本上会意识到这个问题，因此也还有一定的安全性。</p> 
<h4><a id="reinterpret_cast__107"></a>reinterpret_cast 关键字</h4> 
<p>reinterpret 是“重新解释”的意思，顾名思义，<code>reinterpret_cast 这种转换仅仅是对二进制位的重新解释</code>，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。</p> 
<p>reinterpret_cast 可以认为是 static_cast 的一种补充，一些 static_cast 不能完成的转换，就可以用 reinterpret_cast 来完成，例如两个具体类型指针之间的转换、int 和指针之间的转换（有些编译器只允许 int 转指针，不允许反过来）。</p> 
<p>下面的代码代码演示了 reinterpret_cast 的使用：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> m_b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//将 char* 转换为 float*</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"http://c.biancheng.net"</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token comment">//将 int 转换为 int*</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将 A* 转换为 int*</span>
    p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>p<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
   
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：</p> 
<pre><code class="prism language-cpp"><span class="token number">3.0262e+29</span>
<span class="token number">25</span>
</code></pre> 
<p>可以想象，用一个 float 指针来操作一个 char 数组是一件多么荒诞和危险的事情，这样的转换方式不到万不得已的时候不要使用。将A<em>转换为int</em>，使用指针直接访问 private 成员刺穿了一个类的封装性，更好的办法是让类提供 get/set 函数，间接地访问成员变量。</p> 
<h4><a id="dynamic_cast__147"></a>dynamic_cast 关键字</h4> 
<p>dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。<code>向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功</code>。</p> 
<p>dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</p> 
<p>dynamic_cast 的语法格式为：<br> dynamic_cast (expression)</p> 
<p>newType 和 expression 必须同时是指针类型或者引用类型。换句话说，dynamic_cast 只能转换指针类型和引用类型，其它类型（int、double、数组、类、结构体等）都不行。</p> 
<p>对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出std::bad_cast异常。</p> 
<ol><li>向上转型（Upcasting）<br> 向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功。<code>因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别了</code>。</li></ol> 
<p>「向上转型时不执行运行期检测」虽然提高了效率，但也留下了安全隐患，请看下面的代码：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">get_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_a<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">m_b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">get_b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> m_b<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">//情况①</span>
    Derived <span class="token operator">*</span>pd1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">78</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Base <span class="token operator">*</span>pb1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pd1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"pd1 = "</span><span class="token operator">&lt;&lt;</span>pd1<span class="token operator">&lt;&lt;</span><span class="token string">", pb1 = "</span><span class="token operator">&lt;&lt;</span>pb1<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>pb1<span class="token operator">-&gt;</span><span class="token function">get_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    pb1<span class="token operator">-&gt;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//情况②</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    Derived <span class="token operator">*</span>pd2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Base <span class="token operator">*</span>pb2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Base<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pd2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"pd2 = "</span><span class="token operator">&lt;&lt;</span>pd2<span class="token operator">&lt;&lt;</span><span class="token string">", pb2 = "</span><span class="token operator">&lt;&lt;</span>pb2<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>pb2<span class="token operator">-&gt;</span><span class="token function">get_a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token comment">//输出一个垃圾值</span>
    pb2<span class="token operator">-&gt;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//内存错误</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>情况①是正确的，没有任何问题。对于情况②，pd 指向的是整型变量 n，并没有指向一个 Derived 类的对象，在使用 dynamic_cast 进行类型转换时也没有检查这一点，而是将 pd 的值直接赋给了 pb（这里并不需要调整偏移量），最终导致 pb 也指向了 n。因为 pb 指向的不是一个对象，所以get_a()得不到 m_a 的值（实际上得到的是一个垃圾值），pb2-&gt;func()也得不到 func() 函数的正确地址。<br> pb2-&gt;func()得不到 func() 的正确地址的原因在于，pb2 指向的是一个假的“对象”，它没有虚函数表，也没有虚函数表指针，而 func() 是虚函数，必须到虚函数表中才能找到它的地址。<br> 2) 向下转型（Downcasting）<br> 向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败。那么，哪些向下转型是安全地呢，哪些又是不安全的呢？下面我们通过一个例子来演示：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"Class A"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_a<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"Class B"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"Class C"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">C</span></span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{<!-- --></span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"Class D"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> m_d<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    A <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    B <span class="token operator">*</span>pb<span class="token punctuation">;</span>
    C <span class="token operator">*</span>pc<span class="token punctuation">;</span>
   
    <span class="token comment">//情况①</span>
    pb <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向下转型失败</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Downcasting failed: A* to B*"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Downcasting successfully: A* to B*"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        pb <span class="token operator">-&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pc <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>C<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向下转型失败</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pc <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Downcasting failed: A* to C*"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Downcasting successfully: A* to C*"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        pc <span class="token operator">-&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"-------------------------"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
   
    <span class="token comment">//情况②</span>
    pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向上转型都是允许的</span>
    pb <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向下转型成功</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pb <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Downcasting failed: A* to B*"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Downcasting successfully: A* to B*"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        pb <span class="token operator">-&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    pc <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>C<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向下转型成功</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>pc <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Downcasting failed: A* to C*"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token operator">&lt;&lt;</span><span class="token string">"Downcasting successfully: A* to C*"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
        pc <span class="token operator">-&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>运行结果：</p> 
<pre><code class="prism language-cpp">Downcasting failed<span class="token operator">:</span> A<span class="token operator">*</span> to B<span class="token operator">*</span>
Downcasting failed<span class="token operator">:</span> A<span class="token operator">*</span> to C<span class="token operator">*</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
Downcasting successfully<span class="token operator">:</span> A<span class="token operator">*</span> to B<span class="token operator">*</span>
Class D
Downcasting successfully<span class="token operator">:</span> A<span class="token operator">*</span> to C<span class="token operator">*</span>
Class D
</code></pre> 
<p>这段代码中类的继承顺序为：A --&gt; B --&gt; C --&gt; D。pa 是A<em>类型的指针，当 pa 指向 A 类型的对象时，向下转型失败，pa 不能转换为B</em>或C<em>类型。当 pa 指向 D 类型的对象时，向下转型成功，pa 可以转换为B</em>或C*类型。同样都是向下转型，为什么 pa 指向的对象不同，转换的结果就大相径庭呢？</p> 
<p>在<code>《C++ RTTI机制下的对象内存模型（透彻）》</code>一节中，我们讲到了有虚函数存在时对象的真实内存模型，并且也了解到，每个类都会在内存中保存一份类型信息，编译器会将存在继承关系的类的类型信息使用指针“连接”起来，从而形成一个继承链（Inheritance Chain），也就是如下图所示的样子：</p> 
<p>当使用 dynamic_cast 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类）的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。</p> 
<p>对于本例中的情况①，pa 指向 A 类对象，根据该对象找到的就是 A 的类型信息，当程序从这个节点开始向上遍历时，发现 A 的上方没有要转换的 B 类型或 C 类型（实际上 A 的上方没有任何类型了），所以就转换败了。对于情况②，pa 指向 D 类对象，根据该对象找到的就是 D 的类型信息，程序从这个节点向上遍历的过程中，发现了 C 类型和 B 类型，所以就转换成功了。</p> 
<p>总起来说，dynamic_cast 会在程序运行过程中遍历继承链，如果途中遇到了要转换的目标类型，那么就能够转换成功，如果直到继承链的顶点（最顶层的基类）还没有遇到要转换的目标类型，那么就转换失败。对于同一个指针（例如 pa），它指向的对象不同，会导致遍历继承链的起点不一样，途中能够匹配到的类型也不一样，所以相同的类型转换产生了不同的结果。</p> 
<p>从表面上看起来 dynamic_cast 确实能够向下转型，本例也很好地证明了这一点：B 和 C 都是 A 的派生类，我们成功地将 pa 从 A 类型指针转换成了 B 和 C 类型指针。但是从本质上讲，dynamic_cast 还是只允许向上转型，因为它只会向上遍历继承链。造成这种假象的根本原因在于，派生类对象可以用任何一个基类的指针指向它，这样做始终是安全的。本例中的情况②，pa 指向的对象是 D 类型的，pa、pb、pc 都是 D 的基类的指针，所以它们都可以指向 D 类型的对象，dynamic_cast 只是让不同的基类指针指向同一个派生类对象罢了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/52089dcf09f525b4868af30fa8fe1567/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">leetcode_811. 子域名访问计数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ebe57f20f3eaaad9ccb7fab6bea8213/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java-ssm使用逆向工程生成代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>