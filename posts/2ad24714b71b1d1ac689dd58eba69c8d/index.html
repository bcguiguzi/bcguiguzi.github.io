<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>pg常用命令（二） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="pg常用命令（二）" />
<meta property="og:description" content="数据库版本 ：9.6.6
注意 ：PostgreSQL中的不同类型的权限有SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER,CREATE,CONNECT,TEMPORARY,EXECUTE 和 USAGE。
1. 登录PG数据库 以管理员身份 postgres 登陆，然后通过
#psql -U postgres #sudo -i -u postgres ​ $ psql xc_hzh_linan #登录xc_hzh_linan数据库 $ psql -U postgres test #以postgres用户身份，登录test数据库 psql -h localhost -p 5432 -U postgress testdb 界面效果为:
postgres@ubuntu:~$ psql psql (9.5.19) Type &#34;help&#34; for help. ​ postgres=# 简单说一下pgsql 的相关命令
使用反斜线作为命令前缀.
退出 \q 列出所有的数据库 \l 列出所有的数据库的大小 \l&#43; 更改当前连接的数据库 \c 列出当前数据库的连接信息 \connect 列出当前数据库和连接的详细信息 \conninfo 查看当前数据库里面的表和拥有者和表大小 \dt &#43; 展示所有用户 \dg ​ 查看所有表名的列表 \d 获取表结构 \d a 展示所有用户 \du 查看t_sms表的结构 \d t_sms 展示数据库里面的所有的表 \dt 列出所有的数据库的详细信息（包括数据库大小和字符格式） \l&#43; 显示用户访问权限。 \z或\dp 显示所有可设置的访问权限 \h GRAN 显示用户的对所有数据库表的详细访问权限 \dp或者\z 确认当前连接的用户为超级用户postgres，且该用户后创建角色和数据库的权限等 #select current_user; 在超级用户连接postgres后，设置不允许普通用户a连接数据库 #alter role a nologin; ​ 使用普通用户a连接数据库正常 #\c highgo a ​ 查看当前连接的用户名： foo=#select * from current_user; 或 foo=#select user; ​ 查看所有用户名： foo=#\du ​ 数据库表的备份与恢复： pg_dump -h 192." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/2ad24714b71b1d1ac689dd58eba69c8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-17T09:39:34+08:00" />
<meta property="article:modified_time" content="2022-08-17T09:39:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">pg常用命令（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>数据库版本 ：9.6.6</p> 
<p><strong>注意 ：PostgreSQL中的不同类型的权限有</strong>SELECT,INSERT,UPDATE,DELETE,TRUNCATE,REFERENCES,TRIGGER,CREATE,CONNECT,TEMPORARY,EXECUTE 和 USAGE。</p> 
<h2>1. 登录PG数据库</h2> 
<p><strong>以管理员身份 postgres 登陆，然后通过</strong></p> 
<pre> #psql -U postgres
 #sudo -i -u postgres
 ​
 $ psql  xc_hzh_linan                    #登录xc_hzh_linan数据库
 $ psql -U postgres test               #以postgres用户身份，登录test数据库
 psql -h localhost -p 5432 -U postgress testdb

</pre> 
<p><strong>界面效果为:</strong></p> 
<pre> postgres@ubuntu:~$ psql
 psql (9.5.19)
 Type "help" for help.
 ​
 postgres=# 

</pre> 
<ol><li> <p>简单说一下pgsql 的相关命令</p> </li></ol> 
<p>使用反斜线作为命令前缀.</p> 
<pre> 退出    \q
 列出所有的数据库      \l
 列出所有的数据库的大小      \l+
 更改当前连接的数据库       \c
 列出当前数据库的连接信息    \connect
 列出当前数据库和连接的详细信息 \conninfo
 查看当前数据库里面的表和拥有者和表大小         \dt +
 展示所有用户           \dg
 ​
 查看所有表名的列表             \d
 获取表结构                   \d a
 展示所有用户               \du
 查看t_sms表的结构      \d t_sms 
 展示数据库里面的所有的表         \dt
 列出所有的数据库的详细信息（包括数据库大小和字符格式）         \l+
 显示用户访问权限。                            \z或\dp
 显示所有可设置的访问权限                     \h GRAN
 显示用户的对所有数据库表的详细访问权限     \dp或者\z
 确认当前连接的用户为超级用户postgres，且该用户后创建角色和数据库的权限等     #select current_user;
 在超级用户连接postgres后，设置不允许普通用户a连接数据库         #alter role a nologin;
 ​
 使用普通用户a连接数据库正常                   #\c highgo a
 ​
 查看当前连接的用户名：
 foo=#select * from current_user;
 或
 foo=#select user;
 ​
 查看所有用户名：
 foo=#\du
 ​
 数据库表的备份与恢复：
 pg_dump -h 192.168.2.242 -U postgres -p 5432 -c --if-exists -t t_sms dev_huishishuju &gt; t_sms.db 远程备份

</pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/ba/32/MiSSVgP5_o.png"><strong>使用案例 ：</strong></p> 
<pre> t_gj_tzy=# \l+
                                                                    List of databases
    Name    |  Owner   | Encoding |  Collate   |   Ctype    |   Access privileges   |  Size   | Tablespace |                Description                 
 -----------+----------+----------+------------+------------+-----------------------+---------+------------+--------------------------------------------
  postgres  | postgres | UTF8     | zh_CN.utf8 | zh_CN.utf8 |                       | 7079 kB | pg_default | default administrative connection database
  t_gj_tzy  | wsgjjkzg | UTF8     | zh_CN.utf8 | zh_CN.utf8 | =Tc/wsgjjkzg         +| 21 GB   | pg_default | 
            |          |          |            |            | wsgjjkzg=CTc/wsgjjkzg |         |            | 
  template0 | postgres | UTF8     | zh_CN.utf8 | zh_CN.utf8 | =c/postgres          +| 6969 kB | pg_default | unmodifiable empty database
 ​
 PostgreSQL 查找当前数据库的所有表 select * from pg_tables where schemaname = 'public';

</pre> 
<p>查看每个表的大小</p> 
<pre> postgres=# \dt+
                                  List of relations
  Schema |            Name            | Type  |  Owner   |    Size    | Description 
 --------+----------------------------+-------+----------+------------+-------------
  public | acknowledges               | table | postgres | 0 bytes    | 
  public | actions                    | table | postgres | 16 kB      | 
  public | alerts                     | table | postgres | 8192 bytes | 
  public | application_discovery      | table | postgres | 0 bytes    | 
  public | application_prototype      | table | postgres | 8192 bytes | 
  public | application_template       | table | postgres | 40 kB      | 
  public | applications               | table | postgres | 56 kB      | 
  public | auditlog                   | table | postgres | 0 bytes    | 
  public | auditlog_details           | table | postgres | 8192 bytes | 

</pre> 
<h2>添加索引</h2> 
<pre> CREATE INDEX idx_ke_kid
 ​
   ON base.keyword_engine
 ​
   USING btree
 ​
   (keyword_id);

</pre> 
<h3>2、创建用户以及相关权限设置</h3> 
<p>创建用户</p> 
<pre> create role zhaobsh;
 ​
 create user wzq with password '123456';                       #设置用户，并设置密码
 create database xc_hzh_linan owner xchzhlinan ;         #创建数据库以及所属用户

</pre> 
<p><strong>更改用户密码</strong></p> 
<pre> alter role zhaobsh with password 'Test6530';
 ​
 or
 ​
 \password zhaobsh
 ​
 ALTER USER postgres WITH PASSWORD 'postgres';

</pre> 
<p><strong>注：</strong></p> 
<ul><li> <p>密码postgres要用引号引起来</p> </li><li> <p>命令最后有分号</p> </li></ul> 
<p><strong>修改数据库 属主</strong></p> 
<pre> alter database "GSCloud1903" owner to zhaobsh;
 ALTER ROLE user_4 WITH CREATEROLE;            /*赋予创建角色的权限*/  
 alter database "GSCloud1903" rename to zhaobsh;              --修改schema的名称

</pre> 
<p><strong>授权给用户</strong> <a href="https://so.csdn.net/so/search?q=PostgreSQL&amp;spm=1001.2101.3001.7020" title="PostgreSQL">PostgreSQL</a>中预定义了许多不同类型的内置权限，如：SELECT、INSERT、UPDATE、DELETE、RULE、REFERENCES、TRIGGER、CREATE、TEMPORARY、EXECUTE和USAGE。</p> 
<pre> grant all on database "GSCloud1903" to zhaobsh;                          #赋予用户zhaobsh数据库所有权限
 ​
 grant UPDATE ON database "GSCloud1903" to zhaobsh;             # 赋予用户zhaobsh数据库更新权限
 ​
 /* 赋给用户表的所有权限 */
 GRANT ALL ON tablename TO user; 
 ​
 /* 赋给用户数据库的所有权限 */
 GRANT ALL PRIVILEGES ON DATABASE dbname TO dbuser;
 ​
 /* 撤销用户权限 */
 REVOKE privileges ON tablename FROM user;

</pre> 
<p><strong>连接用户和数据库</strong> 使用创建的用户能登录查看相应数据库，则可进行下一步。</p> 
<pre> [root@localhost ~]# psql -h localhost -U monitoring -p 54321 wiseucmsg</pre> 
<h2>3、撤销用户权限</h2> 
<p><strong>撤销用户 runoob权限：</strong></p> 
<pre> =# REVOKE ALL ON COMPANY FROM runoob;                 </pre> 
<p><strong>删除用户：</strong></p> 
<pre> runoobdb=# drop user runoob;</pre> 
<p><strong>设置是 supseruser 以及 登录权限</strong></p> 
<pre> alter user zhaobsh superuser login</pre> 
<p>修改指定用户指定权限</p> 
<pre> alter user postgres superuser createrole createdb replication;
 注意：如果出现 FATAL： role '...' is not permitted to log in.  的错误
 ​
 alter user postgres superuser createrole createdb replication login;

</pre> 
<h2>4、查看用户权限</h2> 
<p>1、查看某用户的表权限</p> 
<pre> select * from information_schema.table_privileges where grantee='user_name';</pre> 
<p>2、查看usage权限表</p> 
<pre> select * from information_schema.usage_privileges where grantee='user_name';</pre> 
<p>3、查看存储过程函数相关权限表</p> 
<pre> select * from information_schema.routine_privileges where grantee='user_name';</pre> 
<p>4、建用户授权</p> 
<pre> create user user_name;
 alter user user_name with password '';
 alter user user_name with CONNECTION LIMIT  20;#连接数限制
 123</pre> 
<h2>创建数据库</h2> 
<pre> CREATE DATABASE dbname;
 ​
 postgres=# create database dbtest owner username; -- 创建数据库指定所属者
 CREATE DATABASE

</pre> 
<p>或者</p> 
<pre> $ createdb -h localhost -p 5432 -U postgres runoobdb
 password ******

</pre> 
<p><strong>将数据库得权限，全部赋给某个用户</strong></p> 
<pre> postgres=# grant all on database dbtest to username; -- 将dbtest所有权限赋值给username
 GRANT
 ​
 设置是 supseruser 以及 登录权限
 alter user zhaobsh superuser login

</pre> 
<p><strong>在pg数据库中创建只读用户可以采用如下方法。大体实现就是将特定schema的相关权限赋予只读用户</strong></p> 
<pre> --创建用户
 CREATE USER readonly WITH ENCRYPTED PASSWORD '123456';
 ​
 --设置用户默认开启只读事务
 ALTER USER readonly SET default_transaction_read_only = ON;
 ​
 --设置用户登录权限
 ​
 ALTER USER readonly WITH login;
 ​
 --将schema中usage权限赋予给readonly用户,访问所有已存在的表
 GRANT usage ON SCHEMA xyh TO readonly;
 ​
 --将schema中表的查询权限赋予给readonly用户,访问所有已存在的表
 GRANT SELECT ON ALL tables IN SCHEMA xyh TO readonly;
 ​
 --未来访问xyh模式下所有新建的表：
 ALTER DEFAULT privileges IN SCHEMA xyh GRANT SELECT ON tables TO readonly;
 ​
  
 ​
 --查数据库
 ​
 select * from pg_database;
 ​
 --查模式
 ​
 select exists(select 1 from pg_namespace where nspname='xyh'); </pre> 
<p></p> 
<p></p> 
<h2>5、 修改linux系统中postgres用户的密码</h2> 
<p>PostgreSQL会创建一个默认的linux用户postgres，修改该用户密码的方法如下： <strong>步骤一：删除用户postgres的密码</strong></p> 
<pre> sudo  passwd -d postgres

</pre> 
<p><strong>步骤二：设置用户postgres的密码</strong></p> 
<pre> sudo -u postgres passwd

</pre> 
<p><strong>系统提示输入新的密码</strong></p> 
<pre> Enter new UNIX password: 
 ​
 Retype new UNIX password: 
 ​
 passwd: password updated successfully

</pre> 
<h2>6、使用pgAdmin客户端 工具创建数据库</h2> 
<p>pgAdmin 工具提供了完整操作数据库的功能： <img alt="在这里插入图片描述" src="https://images2.imgbox.com/9e/3e/CY4OX0rB_o.png"></p> 
<h2>7、数据库的导入导出</h2> 
<p><strong>导入整个数据库</strong></p> 
<pre> psql -U username databasename &lt; /data/dum.sql -- 用户名和数据库名
 pg_dump ga_zj_taizhou.sql | psql wang_wang

</pre> 
<p>或者</p> 
<pre> 进入具体的数据库导入
 postgres@ubuntu:~$ psql
 psql (9.6.6)
 Type "help" for help.
 ​
 postgres=# \c wang_wang     
 You are now connected to database "wang_wang" as user "postgres".
 wang_wang=# \i ga_zj_taizhou.sql

</pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/3a/4f/axNbao3E_o.png"><strong>注意 ：</strong> 因为是从其他地方备份出来的sql文件，从一个数据库导入另一台数据库可能会报下面的错误</p> 
<pre> \i /root/test.sql            #导入数据库数据
 psql:ga_zj_taizhou.sql:1408597: ERROR:  role "pm" does not exist
 psql:ga_zj_taizhou.sql:1408598: ERROR:  role "laoyw" does not exist

</pre> 
<p><strong>解决办法 ：</strong> 格式：create user 自定义用户名称 superuser;</p> 
<pre> postgres=# create user root superuser ;

</pre> 
<p>然后\q退出数据库，再实现psql -d your_db -f sql_path 例如：</p> 
<pre> # psql -d mz -f /usr/mydownloads/proj_llmrs.sql 

</pre> 
<h2>8、忘记postgres用户密码怎么办？</h2> 
<p>环境：</p> 
<pre> Ubuntu 16.04
 postgres : apt-get install postgresql 9.5版本

</pre> 
<p>sudo vim /etc/postgresql/9.5/main/pg_hba.conf</p> 
<pre> local   all             postgres                                peer
 ​
 # TYPE  DATABASE        USER            ADDRESS                 METHOD
 ​
 # "local" is for Unix domain socket connections only
 local   all             all                                     peer
 # IPv4 local connections:
 host    all             all             127.0.0.1/32            md5
 # IPv6 local connections:
 host    all             all             ::1/128                 md5

</pre> 
<p>重启postgressql服务。</p> 
<pre> ~$ systemctl restart postgresq

</pre> 
<p>免密码登录</p> 
<pre> localhost:~$ psql -U postgres -h 127.0.0.1
 psql (9.5.12)
 SSL connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)
 Type "help" for help.
 postgres=#

</pre> 
<p>修改密码并退出</p> 
<pre> postgres=# alter user postgres with password '123';
 ALTER ROLE
 postgres=# \q

</pre> 
<p>修改回认证并退出： trust改为md5</p> 
<blockquote> 
 <p>sudo vim /etc/postgresql/9.5/main/pg_hba.conf</p> 
</blockquote> 
<pre> # IPv4 local connections:
 host    all             all             127.0.0.1/32            trust

</pre> 
<p>重启并登陆：</p> 
<pre> parallels@parallels-vm:~$ systemctl restart postgresql
 parallels@parallels-vm:~$ psql -U postgres -h 127.0.0.1
 Password for user postgres: 
 psql (9.5.12)
 SSL connection (protocol: TLSv1.2, cipher: ECDHE-RSA-AES256-GCM-SHA384, bits: 256, compression: off)
 Type "help" for help.

</pre> 
<h2>9. Ubuntu系统</h2> 
<p><strong>创建新用户</strong></p> 
<pre> root@ubuntu:~# useradd wang
 root@ubuntu:~# passwd wang
 Enter new UNIX password: 
 Retype new UNIX password: 
 passwd: password updated successfully

</pre> 
<p>常见报错 ： 没有家目录,新用户登陆错误</p> 
<pre> root@ubuntu:~# su - wang
 No directory, logging in with HOME=/
 $ 

</pre> 
<p><strong>Linux授予某个用户对某个文件夹的读写权限</strong></p> 
<pre> $ sudo chmod -R 755 /data/data1
 ​
 $ chown -R user1.user1 1.txt
 查看目录的权限
 data# ls -l 

</pre> 
<p><strong>备份数据</strong> 从外网拷贝到本地 scp -r *.sql zhaobsh@192.187.100.1:/data/data1</p> 
<p><strong>导入数据</strong> 登录数据库 postgres@dbmaser:~$ psql -U wsgjjkzg -d t_gj_tzy &lt; /data/data1/t_gj_tzy.20191029235826.sql</p> 
<p><strong>查看导入的数据</strong> su - postgresl \c GSCloud1903 #切换到GSCloud1903 postgres=# \c t_gj_tzy You are now connected to database “t_gj_tzy” as user “postgres”.</p> 
<p>\c dt+ #查看当前数据库里面的表和拥有者和表大小</p> 
<h3><strong>清空数据库中所有数据</strong></h3> 
<pre> //删除public模式以及模式里面所有的对象
 DROP SCHEMA public CASCADE;
 //创建public模式
 CREATE SCHEMA public;

</pre> 
<h3><strong>清除全表，建议使用truncate</strong></h3> 
<p>2种方法都只删数据，保留表结构</p> 
<p><strong>方法一 ，适用数据量较小的情况</strong></p> 
<pre> delete from  tablename;
 </pre> 
<p><strong>方法二，适合删除大量数据，速度快</strong></p> 
<pre> TRUNCATE TABLE tablename;
 ​
 若该表有外键，要用级联方式删所有关联的数据
 ​
 TRUNCATE TABLE tablename CASCADE;
 12345
 test03=# select * from test;  
  id | info | crt_time   
 ----+------+----------  
 (0 rows) 

</pre> 
<p>注意 ：</p> 
<pre> //当表没有其他关系时
 TRUNCATE TABLE tablename;
 //当表中有外键时，要用级联方式删所有关联的数据
 TRUNCATE TABLE tablename CASCADE;

</pre> 
<p>清除所有超过1w条数据的表数据。</p> 
<pre> SELECT * FROM count_em_all(10000) AS r ORDER BY r.num_rows DESC;
 </pre> 
<p><strong>扩展</strong> 在 mysql中，只需要执行：</p> 
<pre> TRUNCATE table_name;
 </pre> 
<p>即可，数据会情况，而且自增id也会变回0；</p> 
<p>但在 postgresql 则稍有不同，因为 postgresql 的自增id是通过序列 sequence来完成的，</p> 
<p>所以情况数据后，还需要还原序列 sequence：</p> 
<pre> TRUNCATE bigtable, fattable RESTART IDENTITY;
 </pre> 
<p>官方文档：<a href="https://www.postgresql.org/docs/9.2/static/sql-truncate.html" rel="nofollow" title="PostgreSQL: Documentation: 9.2: TRUNCATE">PostgreSQL: Documentation: 9.2: TRUNCATE</a></p> 
<p>另一种方式：（因为版本不同，可能命令不同）</p> 
<pre> truncate table table_name;
 alter sequence seq_name start 1;
 </pre> 
<h3>postgres数据库中删除指定的数据的sql语句</h3> 
<p>查询数据库中default_table表中的name字段为空的条件</p> 
<pre> SELECT * from default_table WHERE name is null;
 </pre> 
<p>删除数据库中default_table表的name字段为空的数据</p> 
<pre> DELETE  FROM default_table WHERE  name is null;  
 </pre> 
<p><strong>创建索引语句</strong></p> 
<pre> create index i_jdbc_sql_record_zh01 on t_jdbc_sql_record(c_bh_group,dt_zxsj,N_CHECKSTATUS,C_PSSQL_HASH);
 alter table t_jdbc_sql_content add constraint t_jdbc_sql_content_pkey primary key (C_BH);
 ​
 123</pre> 
<p><strong>异步提交和unlogged table</strong></p> 
<pre> -- 异步提交,更改完重启数据库
  alter system set synchronous_commit to off;
  -- unlogged table 
  create unlogged table t_jdbc_sql_record 
  ...
  create unlogged table t_jdbc_sql_content 
 123456</pre> 
<h3>POSTGRESQL 数据库导入导出</h3> 
<pre> 导入整个数据库
 ​
 psql -U postgres(用户名)  数据库名(缺省时同用户名) &lt; /data/dum.sql
 ​
 导出整个数据库
 1.导出数据库：方式一：pg_dump -U postgres -f c:\db.sqlpostgis
 ​
 方式二：pg_dump -Upostgres postgis &gt; c:\db.sql
 ​
 pg_dump -h localhost -U postgres(用户名) 数据库名(缺省时同用户名)   &gt;/data/dum.sql
 ​
 导出某个表
 ​
 pg_dump -h localhost -U postgres(用户名) 数据库名(缺省时同用户名)  -t table(表名) &gt;/data/dum.sql
 ​
 导入具体表：
 ​
 psql -d postgis -f c:\ dump.sqlpostgres
 ​
 压缩方法
 ​
 一般用dump导出数据会比较大，推荐使用xz压缩
 ​
 压缩方法  xz dum.sql 会生成 dum.sql.xz 的文件
 ​
 ​
 xz压缩数据倒数数据库方法
 ​
 xzcat /data/dum.sql.xz | psql -h localhost -U postgres(用户名) 数据库名(缺省时同用户名)
 1234567891011121314151617181920212223242526272829</pre> 
<h2>查看postgresql数据库用户系统权限、对象权限的方法</h2> 
<p>1、查看某用户的系统权限</p> 
<pre> SELECT * FROM pg_roles WHERE rolname='postgres';</pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/04/6a/sc7HxPxs_o.png"> 2、查看某用户的表权限</p> 
<pre> select * from information_schema.table_privileges where grantee='postgres';</pre> 
<p>3、查看某用户的usage权限</p> 
<pre> select * from information_schema.usage_privileges where grantee='postgres';</pre> 
<p>4、查看某用户在存储过程函数的执行权限</p> 
<pre> select * from information_schema.routine_privileges where grantee='postgres';</pre> 
<p>5、查看某用户在某表的列上的权限</p> 
<pre> select * from information_schema.column_privileges where grantee='postgres';</pre> 
<p>6、查看当前用户能够访问的数据类型</p> 
<pre> select * from information_schema.data_type_privileges ;</pre> 
<p>7、查看用户自定义类型上授予的USAGE权限</p> 
<pre> select * from information_schema.udt_privileges where grantee='postgres';</pre> 
<h2>工作中常见用法 ：</h2> 
<p><strong>1.查看运行时间长的sql</strong></p> 
<pre> select pid,datname,usename,client_addr,query_start,now()-query_start as time_run, query from pg_stat_activity
 where state='active' order by time_run desc limit 20;</pre> 
<p>2.查看指定表空间下的表和索引</p> 
<pre> SELECT  c.relname, t.spcname FROM  pg_class c left JOIN pg_tablespace t ON c.reltablespace = t.oid WHERE t.spcname = 'data1tbs';</pre> 
<p>默认表空间的话where判断 c.reltablespace=0 或 t.spcname is null</p> 
<p><strong>3、查看指定pid需要的锁状态</strong></p> 
<pre> select pc.relname,pl.* from pg_locks pl left join pg_class pc on pc.relfilenode=pl.relation where pl.pid=13912</pre> 
<p><strong>4、查看未使用索引</strong></p> 
<pre> select schemaname,relname,indexrelname,idx_scan from pg_stat_user_indexes where idx_scan=0 and schemaname='public' and indexrelname not like '%_pkey'</pre> 
<p><strong>5、查看指定表的索引</strong></p> 
<pre> select schemaname,relname,indexrelname,idx_scan from pg_stat_user_indexes where schemaname='public' and relname='visited_article'</pre> 
<p><strong>6、某个pid在等待的锁的持有者</strong></p> 
<pre> select pl1.*,pl2.pid,pa.usename,pa.query from pg_locks pl1 left join pg_locks pl2 on pl1.transactionid=pl2.transactionid and pl2.granted
 left join pg_stat_activity pa on pl2.pid=pa.pid where pl1.pid=21641 and not pl1.granted</pre> 
<p><strong>7、查看所有锁的状态</strong></p> 
<pre> select
      pg_stat_activity.datname,pg_class.relname,pg_locks.transactionid, pg_locks.mode, pg_locks.granted,
      pg_stat_activity.usename,substr(pg_stat_activity.query,1,30), pg_stat_activity.query_start,
      age(now(),pg_stat_activity.query_start) as "age", pg_stat_activity.pid
    from pg_stat_activity,pg_locks left
      outer join pg_class on (pg_locks.relation = pg_class.oid) 
    where pg_locks.pid=pg_stat_activity.pid order by query_start limit 100;</pre> 
<p>8、查看指定schema 里所有的索引大小，按从大到小的顺序排列</p> 
<pre> select indexrelname, pg_size_pretty(pg_relation_size(relid)) from pg_stat_user_indexes where schemaname='public' order by pg_relation_size(relid) desc;
 ​</pre> 
<p>9、查询所有表大小，并且按从大到小排序</p> 
<pre> select relname, pg_size_pretty(pg_relation_size(relid)) as size from pg_stat_user_tables ORDER BY size desc;</pre> 
<p>10、查询指定模式下面所有表大小，并按表大小排序</p> 
<pre> select relname, pg_size_pretty(pg_relation_size(relid)) as size from pg_stat_user_tables where schemaname = 'authevent'  ORDER BY size desc;
 </pre> 
<p>–查看DB大小</p> 
<pre> select pg_size_pretty(pg_database_size('ve'));  
 </pre> 
<p>–查看表大小(不含索引等信息)</p> 
<pre> select pg_relation_size('user');                      
 select pg_size_pretty(pg_relation_size('use'))  
 </pre> 
<p>–查看每个DB的使用情况(读,写,缓存,更新,事务等)</p> 
<pre> select * from pg_stat_database
 </pre> 
<p>–查看索引的使用情况</p> 
<pre> select * from pg_stat_user_indexes;

</pre> 
<p>–查看表所对应的数据文件路径与大小</p> 
<pre> SELECT pg_relation_filepath(oid), relpages FROM pg_class WHERE relname = 'empsalary';
 1</pre> 
<p>–查看表空间大小</p> 
<pre> select pg_tablespace_size('pg_default');

</pre> 
<p>714 境内采集器</p> 
<pre> SELECT  ip FROM asset_server where is_server=1 and  ip  not like '%163.106.130.%' and ip  not like '132.117.354.%' and idc_id not in(16,9)  and ip not IN('161.10.84.11','180.132.214.110')
</pre> 
<p>27 大服务器</p> 
<pre> SELECT  ip FROM asset_server where is_server=1 and  (ip   like '%183.106.110.%' or ip  like '122.227.254.%'  or ip  IN('80.102.214.130'))
</pre> 
<p>24 境外采集器</p> 
<pre> SELECT  ip FROM asset_server where is_server=1 and   idc_id in(16,9) and ip not in('57.39.42.18','143.331.144.190','113.10.10.11')
</pre> 
<p>1 阿里云</p> 
<pre> SELECT  ip FROM asset_server where  ip  IN('132.10.34.121')

</pre> 
<p>4 v，pn 与浏览器专用 37.69.82.18（“浏览器代理服务器”） “183.211.104.114”</p> 
<pre> SELECT  * FROM asset_server where is_server=1 and   idc_id in(16,9) and ip in('37.69.82.18','183.211.104.114')

</pre> 
<p>4.6.5 排除境，外 阿里云</p> 
<pre>    SELECT  * FROM asset_server where is_server=1  and idc_id not in(16,9)  and ip not IN('132.110.194.141')
</pre> 
<p>4.6.7 --统计全网服务器（按机房）</p> 
<pre> select COUNT(ass.ip),ass.idc_id,idc.name  from  asset_server  ass  left join asset_serveridc idc on idc.id=ass.idc_id where ass.is_server=1 group by ass.idc_id,idc.name;
</pre> 
<p><strong>4.6.8 联合状态查询</strong></p> 
<p>–查询内存1g的</p> 
<pre> select ass.ip,ast.memtotal from  asset_server ass inner join (select max(id),sid_id,cast(trim(both ' MB' from memtotal) as integer) as memtotal  from  asset_serverstatus group by sid_id,memtotal ) as  ast
 on ass.id=ast.sid_id where ass.is_server=1 and ast.memtotal&lt;1200 order by ass.ip;
</pre> 
<p>–查询内存1g的 排除香港</p> 
<pre> select count(ass.ip) from  asset_server ass inner join (select max(id),sid_id, cast(trim(both ' MB' from memtotal) as integer) as memtotal  from  asset_serverstatus group by sid_id,memtotal ) as  ast
 on ass.id=ast.sid_id where ass.is_server=1 and ass.idc_id !=16 and ast.memtotal&lt;1200;
 ​
 select ass.ip,ast.memtotal from  asset_server ass inner join (select max(id),sid_id,cast(trim(both ' MB' from memtotal) as integer) as memtotal  from  asset_serverstatus group by sid_id,memtotal ) as  ast
 on ass.id=ast.sid_id where ass.is_server=1 and ass.idc_id !=16 and ast.memtotal&lt;1200 order by ass.ip;
</pre> 
<p>–查询内存1g的 排除香港 部署有totalspider的</p> 
<pre> select count(ass.ip) from  asset_server ass inner join (select max(id),sid_id,cast(trim(both ' MB' from memtotal) as integer) as memtotal  from  asset_serverstatus group by sid_id,memtotal ) as  ast
 on ass.id=ast.sid_id where ass.is_server=1 and ass.idc_id !=16 and ass.describe LIKE  '%totalspider%' and ast.memtotal&lt;1200;

</pre> 
<p>–查询内存大于1g 小于2g 排除香港的机器</p> 
<pre> psql -h db.www.qwq.com -p 5432 -U yun -c "select ip, ast.memtotal from asset_server ass inner join (select max(id),sid_id,cast(trim(both ' MB' from memtotal) as integer) as memtotal from asset_serverstatus group by sid_id,memtotal ) as ast
 on ass.id=ast.sid_id where ass.is_server=1 and ass.idc_id !=16 and ast.memtotal&gt;1200 and ast.memtotal&lt;3000;"
</pre> 
<p>查询机房归属地在上海的（代号42）的内存大小</p> 
<pre> psql yunwei -c " select ass.ip,ast.memtotal from  asset_server ass inner join (select max(id),sid_id,cast(trim(both ' MB' from memtotal) as integer) as memtotal from asset_serverstatus group by sid_id,memtotal ) as ast on ass.id=ast.sid_id where ass.is_server=1 and ast.memtotal &lt; 1024 and ass.idc_id=42 order by ass.ip;"

</pre> 
<p>1、 postgres@ubuntu:~$ psql -U wzq -d template0 psql: FATAL: Peer authentication failed for user “wzq”</p> 
<p>其中peer authentication 比较注目，很明显，错误和权限有关联。</p> 
<p>参考链接PostgreSQL 修改设置数据库的默认用户以及权限. ：<a href="http://www.cnblogs.com/jinanxiaolaohu/p/11452472.html" rel="nofollow" title="PostgreSQL 修改设置数据库的默认用户以及权限. - 济南小老虎 - 博客园">PostgreSQL 修改设置数据库的默认用户以及权限. - 济南小老虎 - 博客园</a>：<a href="https://blog.csdn.net/weixin_30265103/article/details/101908371" title="PostgreSQL 修改设置数据库的默认用户以及权限._weixin_30265103的博客-CSDN博客">PostgreSQL 修改设置数据库的默认用户以及权限._weixin_30265103的博客-CSDN博客</a></p> 
<p>PostgreSQL清空表并保留表结构、清空数据库还原数据库为新建时的状态的方法 ：<a href="https://blog.csdn.net/u013719339/article/details/79627010" title="PostgreSQL清空表并保留表结构、清空数据库还原数据库为新建时的状态的方法_路人甲JIA的博客-CSDN博客_pgsql 清空表">PostgreSQL清空表并保留表结构、清空数据库还原数据库为新建时的状态的方法_路人甲JIA的博客-CSDN博客_pgsql 清空表</a></p> 
<p>PostgreSQL 如何实现批量更新、删除、插入 ：<a href="https://yq.aliyun.com/articles/74420" rel="nofollow" title="PostgreSQL 如何实现批量更新、删除、插入-阿里云开发者社区">PostgreSQL 如何实现批量更新、删除、插入-阿里云开发者社区</a></p> 
<p>postgresql 删除单个表的数据 ：<a href="https://blog.csdn.net/kmust20093211/article/details/47734975" title="postgresql 删除单个表的数据_kmust20093211的博客-CSDN博客_postgresql 删除一条数据">postgresql 删除单个表的数据_kmust20093211的博客-CSDN博客_postgresql 删除一条数据</a></p> 
<p>postgresql批量删除表 ：<a href="https://blog.csdn.net/weixin_30384217/article/details/98387285" title="postgresql批量删除表_weixin_30384217的博客-CSDN博客">postgresql批量删除表_weixin_30384217的博客-CSDN博客</a></p> 
<p>修改postgres密码 ：<a href="https://blog.csdn.net/qiuyoujie/article/details/89853029" title="修改postgres密码_渡人先渡己的博客-CSDN博客_postgres修改密码">修改postgres密码_渡人先渡己的博客-CSDN博客_postgres修改密码</a></p> 
<p><strong><a href="https://www.jb51.net/article/203163.htm" rel="nofollow" title="https://www.jb51.net/article/203163.htm">https://www.jb51.net/article/203163.htm</a></strong></p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/5f/ae/PTuVav9U_o.png"></p> 
<h2>10. pg数据制造</h2> 
<h3>1. 分区表数据批量造数据</h3> 
<p>1.1 <strong>启动PostreSQL</strong></p> 
<pre> docker pull postgre
 ​
 docker run -e POSTGRES_PASSWORD=123456 -p 5432:5432 --name potgre postgres:latest
 ​
 psql -h 127.0.0.1 -p 5432 -U postgres -d postgres</pre> 
<blockquote> 
 <p>下面的例子我们将为把订单 orders 表使用分区表来实现。order 中含有 id、user_id、create_time 三个属性，并根据 create_time 按照月份进行分区。</p> 
</blockquote> 
<p><strong>1.2 创建父表</strong></p> 
<pre> CREATE TABLE orders (id serial,user_id int4,create_time timestamp(0)) PARTITION BY RANGE(create_time);</pre> 
<p><strong>1.3 创建分区表</strong></p> 
<pre> CREATE TABLE orders_history PARTITION OF orders FOR VALUES FROM ('2000-01-01') TO ('2020-03-01');
 ​
 CREATE TABLE orders_202003 PARTITION OF orders FOR VALUES FROM ('2020-03-01') TO ('2020-04-01');
 ​
 CREATE TABLE orders_202004 PARTITION OF orders FOR VALUES FROM ('2020-04-01') TO ('2020-05-01');
 ​
 CREATE TABLE orders_202005 PARTITION OF orders FOR VALUES FROM ('2020-05-01') TO ('2020-06-01');
 ​
 CREATE TABLE orders_202006 PARTITION OF orders FOR VALUES FROM ('2020-06-01') TO ('2020-07-01');</pre> 
<p><strong>1.4 在分区上创建索引</strong></p> 
<pre> CREATE INDEX order_idx_history_create_time ON orders_history USING btree(create_time);
 ​
 CREATE INDEX order_idx_202003_create_time ON orders_202003 USING btree(create_time);
 ​
 CREATE INDEX order_idx_202004_create_time ON orders_202004 USING btree(create_time);
 ​
 CREATE INDEX order_idx_202005_create_time ON orders_202005 USING btree(create_time);
 ​
 CREATE INDEX order_idx_202006_create_time ON orders_202006 USING btree(create_time);</pre> 
<p><strong>1.5 向分区表中插入数据</strong></p> 
<blockquote> 
 <p>按照分钟进行数据的插入，如果需要创建海量数据可以把 1 minute 换成 1 millisecond(毫秒)或者 second(秒)</p> 
</blockquote> 
<pre> INSERT INTO orders (user_id, create_time) select 1000, generate_series('2020-01-01'::date, '2020-05-31'::date, '1 minute');</pre> 
<h4>11. ADB 批量</h4> 
<pre> 1. 创建表
 CREATE TABLE orders (
 id serial,
 user_id int4,
 create_time DATE
 ) PARTITION BY RANGE (create_time) (START (date '1992-01-01') INCLUSIVE END (date '2000-01-01'));
 2. 插入数据
 INSERT INTO orders (user_id, create_time) select 1000, generate_series('1992-01-01'::date, '1992-04-01'::date, '1 minute');</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/395860db7198ee8b69e6edec10016930/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">function $(id) {}表示什么函数,关于document.getElementBuId的简写 $(id)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5b80c8fc1a7884db8394b3d995b7ada5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器被攻击的处理方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>