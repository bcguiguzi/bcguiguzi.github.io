<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;STD库 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;STD库" />
<meta property="og:description" content="1.vector
// vector 的常用方式 //vector 与数组的区别是，vector的存储量是随开随用的 #include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; int main() { vector&lt;int&gt; vec;//定义一个vertor（类似于数组） int n; int x; cin &gt;&gt; n; for(int i = 0; i &lt; n; i&#43;&#43;) { cin &gt;&gt; x; vec.push_back(x); }//将x存入vertor里 vec.pop_back();//可以删除最后一个元素. std::vector&lt;int&gt;::iterator it;//定义一个迭代器(指针)it //auto it = vec.begin();//也可以使用auto自动识别迭代器 //本质是指针 for(auto it = vec.begin();it != vec.end();it&#43;&#43;)//it&#43;&#43;,是指针指向数组(vec)的下一个数(it--反之)和数组的&#43;&#43;或者--有区别 { printf(&#34;%d &#34;,*it); }//自动识别输出，逆向输出使用rbegin(),rend()即可 for(it = vec.begin(); it != vec.end(); it&#43;&#43;) { printf(&#34;%d &#34;,*it); }//使用迭代器输出 for(int i = 0;i &lt; vec." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0d66e88ee8a449b3e5813d9d91e34a54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-21T16:32:50+08:00" />
<meta property="article:modified_time" content="2023-02-21T16:32:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;STD库</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="1.vector-toc" style="margin-left:40px;"></h4> 
<p>1.vector</p> 
<pre><code class="language-cpp">// vector 的常用方式
//vector 与数组的区别是，vector的存储量是随开随用的

#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; vec;//定义一个vertor（类似于数组）
    int n;
    int x;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; x;
        vec.push_back(x);
    }//将x存入vertor里

    vec.pop_back();//可以删除最后一个元素.
    std::vector&lt;int&gt;::iterator it;//定义一个迭代器(指针)it

    //auto it = vec.begin();//也可以使用auto自动识别迭代器
      //本质是指针

    for(auto it = vec.begin();it != vec.end();it++)//it++,是指针指向数组(vec)的下一个数(it--反之)和数组的++或者--有区别
    {
        printf("%d ",*it);
    }//自动识别输出，逆向输出使用rbegin(),rend()即可

    for(it = vec.begin(); it != vec.end(); it++)
    {
        printf("%d ",*it);
    }//使用迭代器输出


    for(int i = 0;i &lt; vec.size();i++)//vec.size()是返回vector里元素的个数
    {
        printf("%d ",vec[i]);
    }//使用数组输出;

    for(int i = vec.size() - 1;i &gt;= 0;i--)
    {
        printf("%d ",vec[i])
    }//数组逆向输出


    for(auto i : vec)//auto 是自动排判别
    {
        printf("%d ",i);
    }//使用auto取vec里的值，然后输出
</code></pre> 
<pre><code class="language-cpp">/其他常用方法

//排序
    //sort(vec.begin(),vec.end());//对vertor正向排序
    //reverse(vec.begin(),vec.end());//sort后可reverse逆向排序

//清空
    vec.clear();//清空vector里的元素(仅适应于一维)
    vector&lt;int&gt; vec[100];//类似于二维数组int vec[100][100];

    for(int i = 1;i &lt; n;i++)
    {
        vec[i].clear();
    }//二维清空

//删除
    for(auto it = vec.begin();it != vec.end();)
    {
        if(*it == 4)
            it = vec.erase(it);//删除指定元素
        else
            it++;
    }//使用指针（迭代器）删除
    //注释 ： 因为我们要删除本质是指向的数，使用删除后要将当前指向的指针重新指向下一个数
    //保证其连续性
    for(auto i: vec)
    {
        printf("%d ",i);
    }

//其他不常用方法

    vec.front();//返回他的第一个数
    vec.back();//返回最后一个数

    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p>2.string(字符串类型)</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    string a,b;//定义一个string类型
    cin &gt;&gt; a &gt;&gt; b;
    a += b;//字符串类型拼接 a = "aaa" + b = "bbb";


//查找
    s.find('b');//找出某个字符串第一次出现的位置

//排序
    //sort(a.begin() , a.end());


//添加控制
    string a="";
    a.push_back('b');//在字符串最后插入一个字符
    a.push_back('1');
    a.push_back('2');
    a.push_back('3');
    cout&lt;&lt;a[0]&lt;&lt;' '&lt;&lt;a[1]&lt;&lt;' '&lt;&lt;a[2];//输出1 2 3

//删除控制
    a.pop_back();//删除字符串最后一个元素
    b.pop_back();
    cout &lt;&lt; a &lt;&lt;"\n"&lt;&lt; b &lt;&lt; endl;


//找东西(定位)
    cout &lt;&lt; a.find('b') &lt;&lt; endl;//找出某个字符串第一次出现的位置并返回其下标
    cout &lt;&lt; b.find('b') &lt;&lt; endl;


//截取字符串
    //a = "abcdddddd";
    //a.substr(begin,end);//开始的数组下标到结束的数组下标
    a.substr(0,3);//abc
    a.substr(3,3);//ddd
    a.substr(3,10);//dddddd =&gt; a.substr(3)
    //注意 : 结束的数组下标即使超过字符串最大容量其返回值也不会数组越界，会截取可截取的所有元素


    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p>3.pair（双胞胎类型）</p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
//定义双胞胎类型
    pair&lt;int,int&gt;pll;
    pair&lt;int,int&gt;a,b;
    typedef pair&lt;int ,int&gt;pll;
    pll a,b;

//输入方式
    cin &gt;&gt; a.first &gt;&gt; b.second;
    cin &gt;&gt; pll;
//其他输入方式
    int x;int y;
    cin &gt;&gt; x &gt;&gt; y;
    pll = {x,y};
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<hr> 
<p>4.栈</p> 
<pre><code class="language-cpp">//特点：先放后出
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    stack &lt;int&gt; sta;//定义
    int n,t;
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n;i++)
    {
        cin &gt;&gt; t;
        std.push(t);//入栈
    }


//其他用法
    sta.size();//返回元素个数
    sta.empty();//判断空栈
    sta.top();//弹出最顶部
    sta.pop();//删除最顶部


//删除全部
    while(sta.size())
    {
        cout &lt;&lt; sta.top();
        sta.pop();
    }
    return 0;
}

</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p>5.队列</p> 
<pre><code class="language-cpp">//特点：先进先出
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    queue&lt;int&gt; q;//定义
    int n,t;
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n;i++)
    {
        cin &gt;&gt; t;
        q.push(t);
    }


//其他操作
    while(q.size())
    {
        int x = q.front();//返回当前队列头
        q.pop();//必须删除才能取下一个
        cout &lt;&lt; x &lt;&lt; endl;
        q.bcak();//返回最后一个元素
    }//输出


//数组模拟
    int n,t;
    int tt = 0;//队头(数组最右端)
    int hh = 0;//队尾(数组最左端)
    int z[1001];
    for(int i = 0;i &lt; n;i++)
    {
        cin &gt;&gt; t;
        z[tt++] = t;
    }
    while(hh &lt; tt)
    {
        int y = z[hh++];
        cout &lt;&lt; y &lt;&lt; endl;
    }//输出
    return 0;
}
</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p>6.双端队列</p> 
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    deque&lt;int&gt; q;


//放置
    q.push_back(t);//放置尾部
    q.push_front(t);//放置头部


//删除
    q.pop_back();//删尾
    q.pop_front;//删尾



//输出
    while(q.size())
    {
        int x = q.front();
        int y = q.back();
        q.pop_back();
        q.pop_front();
        cout &lt;&lt; x;
    }
    return 0;
}

</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p>7.堆</p> 
<pre><code class="language-cpp">// 特点 ： 1.自动排序内部数，小到大或大到小
//         2.二叉数结构
//         3.nlogn(排序)
//         4.logn(查找)
#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
//定义
    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q1; //greater是小根堆，用vector装载内部元素（小到大排序）
	priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q2; //less是大根堆（大到小排序）
    q1.push(1);
    q2.push(2);

//输入
    int n,t;
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n;i++)
    {
        cin &gt;&gt; t;
        q.push(t);
    }

//输出
    while(q.size())
    {
        int x = q.top();
        q.pop();
        cout &lt;&lt; x;
    }


//其他用法
    q.top();//取最顶部（最小值）
    q.pop();//删除最顶部
    return 0;
}
</code></pre> 
<p></p> 
<p></p> 
<hr> 
<p>8.set</p> 
<pre><code class="language-cpp">// 特点 ： 1.红黑树结构，可以输出后自动排序去重

#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    set&lt;int&gt; se;
    int n,t;
    cin &gt;&gt; n;
    for(int i = 0;i &lt; n;i++)
    {
        cin &gt;&gt; t;
        se.insert(t);//存入
    }


//指针输出
    std::set&lt;int&gt;::iterator it;
    for(it = begin();it != end();it++)
    {
        cout &lt;&lt; *it;
    }//输出后自动排序且去重复


//auto输出
    for(auto j : se)
    {
        cout &lt;&lt; j;
    }//输出后自动排序且去重复


//查找
    auto j = se.find(3);//假设查找3
    cout &lt;&lt; *j;//如果存在则输出其指向的指针，不存在则报错（返回边界end()）
    if(j != end())
        cout &lt;&lt; "找到了";


//二分查找
    auto i = se.lower_bound(3);//二分查找函数
    i++;
    i--;
    //其返回值为指针，i与i左右相邻的数
    cout &lt;&lt; *i;


//其他用法
    se.clear();//清空


//指针删除
    auto i = se.find(3);//先找到其，返回其指针
    i++;//指针向后遍历（删去3后面的数）
    i--;//指针向前遍历（删去3前面的数）

    if(i != se.end())
        i = se.erase(i);
    for(auto i : se)
            cout &lt;&lt; i &lt;&lt; ' ';
//若没有要找的3，则只排序去重不删除。如果i++或者i--操作后没有要找的3，则删除数组对应的下标
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p>9.map</p> 
<pre><code class="language-cpp">// 特点 ： 1.红黑树结构，可以输出后自动排序去重
//         2.map里的操作只针对于关键字

#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    //关键字 关键值
    map&lt;int,int&gt; mp;

//输入
	mp.insert({ 1,2 });//插入一个 1 关键字，并给这个关键字的关键值赋值 2
	mp.insert({ 1,1 });//因为 1 关键字已经存在，所以把关键值修改成 1
    int n,t,s;
    cin &gt;&gt; n &gt;&gt; t;
    for(int i = 0;i &lt; n;i++)
    {
        cin &gt;&gt; t &gt;&gt; s;
        mp[t] = s;
        mp[t]++;
    }


//输出
    for(auto j : mp)
        cout &lt;&lt; j.first &lt;&lt; j.second;

    for (auto it = mp.begin(); it != mp.end(); it++)
        cout &lt;&lt; (*it).first &lt;&lt; ' ' &lt;&lt; (*it).second &lt;&lt; endl;

    for (auto it = se.rbegin(); it != se.rend(); it++)//反向遍历
        cout &lt;&lt; *it &lt;&lt; endl;


//删除
    mp.erase(3);//删除某个指定的关键字
    	//如果是遍历删除 map 内特定的第 x 个数，跟 vector 删除一样要注意指针衔接
	int k = 0;
	for (auto it = mp.begin(); it != mp.end();k++)
    {
		if (k == x)
            it = mp.erase(it);
		else
            it++;
	}


//查找
    mp.find();//找到某个数，返回指针
    mp.cout();//计数某个数出现的次数，返回数值

    auto j = mp.find(3);//查找 3 关键字在 map 内的下标
    //如果不存在则 j == mp.end()
    if (j != mp.end())
        cout &lt;&lt; (*j).first;//返回其关键字的指针


//二分查找
    auto g = mp.lower_bound(3);//查找 map 内第一个大于等于 3 的数的下标
    //如果不存在则 g == mp.end()
    if (g != mp.end())
        cout &lt;&lt; (*g).first;


//其他
    mp.clear();//清空
    mp.size();
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<hr> 
<p>lower_bound(二分函数)</p> 
<pre><code class="language-cpp">//特点 ： 1.找大于等于某数的第一个数，查找的数组必须有序
//        2.并返回其数组下标


#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    int n = 7;//7个数
	int a[] = { 2,4,6,7,9,12,111 };//范围：0 ~ 6
	int t = lower_bound(a, a + n, 8) - a;//数组中大于等于8的第一个数

    printf("%d",t);//返回其下标

	if (t != n)//找不到会返回边界，边界是 7
		cout &lt;&lt; a[t] &lt;&lt; endl;

	int b[] = { 0,2,4,6,7,9,12,111 };//范围：1 ~ 7
	t = lower_bound(b + 1, b + n + 1, 8) - b;

	if (t != n + 1)//找不到会返回边界，边界是 8
		cout &lt;&lt; b[t] &lt;&lt; endl;
    return 0;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p>unique(去重函数) </p> 
<pre><code class="language-cpp">//特点 ：1.unique本身的功能是将排序后的数组内的所有重复元素在 O(n) 时间内堆积到数组末端
//  2. 同时它会返回一个指针/下标（区别于你传入的是容器还是数组） —— 堆积的第一个重复元素的位置

#include &lt;bits/stdc++.h&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; vec = { 1,3,4,5,1,1,9 };
	sort(vec.begin(), vec.end());


	vec.erase(unique(vec.begin(), vec.end()), vec.end());//我们再利用vector的区间删除功能就能完成去重的过程

	for (auto j : vec)
        cout &lt;&lt; j &lt;&lt; ' ';

	int a[10] = { 1,2,3,8,7,5,3,1,2,4 };
	int n = 10;
	sort(a, a + n);//排序

	for(i, 0, n - 1)
        cout &lt;&lt; a[i] &lt;&lt; ' ';
	cout &lt;&lt; endl;

	n = unique(a, a + n) - a;//n 之后的元素似乎会有变动，但不影响去重本身的正确性

	forr(i, 0, n - 1)
        cout &lt;&lt; a[i] &lt;&lt; ' ';

    return 0;
}
</code></pre> 
<hr> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/36a5fe406f27807896a39760c2dd22c7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python将计算结果拷贝至粘贴板</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f0f8dfd780505563c66ec5f5867cba97/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GPU训练时查看占用显存、杀死进程命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>