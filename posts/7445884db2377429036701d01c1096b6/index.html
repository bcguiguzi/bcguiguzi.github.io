<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《vtk9 book》 官方web版 第3章 - 计算机图形基础 （5 / 5） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《vtk9 book》 官方web版 第3章 - 计算机图形基础 （5 / 5）" />
<meta property="og:description" content="vtkProp的组件和其他类型 通常希望将演员收集到一个依赖于变换的层次结构中。例如，一个机器人手臂可以由刚性连接的链接表示，这些链接在肩关节、上臂、肘部、下臂、腕关节和手部等关节处连接在一起。在这种配置中，当肩关节旋转时，期望的行为是整个手臂一起旋转，因为这些链接是连接在一起的。这是 VTK 中所称的装配的一个例子。vtkAssembly 只是 VTK 中许多类似演员的类之一。正如图 3-34 所示，这些类被排列成 vtkProps 的层次结构。（在舞台和电影术语中，道具是指出现或在舞台上使用的东西。）在 VTK 中，通过实例化一个 vtkAssembly 然后向其添加部分来形成装配。部分是 vtkProp3D 的任何实例，包括其他装配。这意味着可以将装配形成层次结构（只要它们不包含自引用循环）。装配遵守前一节“变换矩阵”中所示的转换串联规则。以下是如何创建一个简单装配层次结构的示例（来自 assembly.tcl）。
vtkSphereSource sphere vtkPolyDataMapper sphereMapper sphereMapper SetInputConnection [sphere GetOutputPort] vtkActor sphereActor sphereActor SetMapper sphereMapper sphereActor SetOrigin 2 1 3 sphereActor RotateY 6 sphereActor SetPosition 2.25 0 0 [sphereActor GetProperty] SetColor 1 0 1 vtkCubeSource cube vtkPolyDataMapper cubeMapper cubeMapper SetInputConnection [cube GetOutputPort] vtkActor cubeActor cubeActor SetMapper cubeMapper cubeActor SetPosition 0.0 .25 0 [cubeActor GetProperty] SetColor 0 0 1 vtkConeSource cone vtkPolyDataMapper coneMapper coneMapper SetInputConnection [cone GetOutputPort] vtkActor coneActor coneActor SetMapper coneMapper coneActor SetPosition 0 0 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7445884db2377429036701d01c1096b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-10T18:15:42+08:00" />
<meta property="article:modified_time" content="2024-03-10T18:15:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《vtk9 book》 官方web版 第3章 - 计算机图形基础 （5 / 5）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>        vtkProp的组件和其他类型</h4> 
<p>        通常希望将演员收集到一个依赖于变换的层次结构中。例如，一个机器人手臂可以由刚性连接的链接表示，这些链接在肩关节、上臂、肘部、下臂、腕关节和手部等关节处连接在一起。在这种配置中，当肩关节旋转时，期望的行为是整个手臂一起旋转，因为这些链接是连接在一起的。这是 VTK 中所称的装配的一个例子。vtkAssembly 只是 VTK 中许多类似演员的类之一。正如图 3-34 所示，这些类被排列成 vtkProps 的层次结构。（在舞台和电影术语中，道具是指出现或在舞台上使用的东西。）在 VTK 中，通过实例化一个 vtkAssembly 然后向其添加部分来形成装配。部分是 vtkProp3D 的任何实例，包括其他装配。这意味着可以将装配形成层次结构（只要它们不包含自引用循环）。装配遵守前一节“变换矩阵”中所示的转换串联规则。以下是如何创建一个简单装配层次结构的示例（来自 assembly.tcl）。</p> 
<pre><code class="language-cpp">vtkSphereSource sphere
vtkPolyDataMapper sphereMapper
   sphereMapper SetInputConnection [sphere GetOutputPort]
vtkActor sphereActor
  sphereActor SetMapper sphereMapper
  sphereActor SetOrigin 2 1 3
  sphereActor RotateY 6
  sphereActor SetPosition 2.25 0 0
  [sphereActor GetProperty] SetColor 1 0 1

vtkCubeSource cube
vtkPolyDataMapper cubeMapper
  cubeMapper SetInputConnection [cube GetOutputPort]
vtkActor cubeActor
  cubeActor SetMapper cubeMapper
  cubeActor SetPosition 0.0 .25 0
  [cubeActor GetProperty] SetColor 0 0 1

vtkConeSource cone
vtkPolyDataMapper coneMapper
  coneMapper SetInputConnection [cone GetOutputPort]
vtkActor coneActor
  coneActor SetMapper coneMapper
  coneActor SetPosition 0 0 .25
  [coneActor GetProperty] SetColor 0 1 0

vtkCylinderSource cylinder
vtkPolyDataMapper cylinderMapper
  cylinderMapper SetInputConnection [cylinder GetOutputPort]
  cylinderMapper SetResolveCoincidentTopologyToPolygonOffset

vtkActor cylinderActor
  cylinderActor SetMapper cylinderMapper
  [cylinderActor GetProperty] SetColor 1 0 0

vtkAssembly assembly
  assembly AddPart cylinderActor
  assembly AddPart sphereActor
  assembly AddPart cubeActor
  assembly AddPart coneActor
  assembly SetOrigin 5 10 15

# allows faces a specified camera and is used for billboards.
  assembly AddPosition 5 0 0
  assembly RotateX 15

ren1 AddActor assembly
ren1 AddActor coneActor</code></pre> 
<p></p> 
<p class="img-center"><img alt="Figure3-34" height="293" src="https://images2.imgbox.com/38/35/DENfRsoL_o.png" width="435"></p> 
<p><strong>Figure 3-34</strong>. Figure 3-34 The vtkProp hierarchy. Props that can be transformed in 3D space are a subclass of vtkProp3D. Images can be drawn effectively with vtkImageActor. Overlay text and graphics use vtkActor2D. Hierarchical groups of vtkProps are gathered into a vtkPropAssembly. Volume rendering uses vtkVolume. Collections of transformable props create a vtkAssembly. Level-of-detail rendering uses vtkLODProp3D and vtkLODActor. A vtkFollower allows faces a specified camera and is used for billboards.</p> 
<p></p> 
<p>图3-34 vtkProp层次结构。可以在3D空间中进行变换的Props是vtkProp3D的子类。可以使用vtkImageActor有效绘制图像。叠加文本和图形使用vtkActor2D。vtkProps的分层组合被聚集到vtkPropAssembly中。体积渲染使用vtkVolume。可变换props的集合创建vtkAssembly。细节级别渲染使用vtkLODProp3D和vtkLODActor。vtkFollower允许面向指定摄像头，用于广告牌。</p> 
<p></p> 
<p></p> 
<p>        请注意，在这个示例中，各种actor都是使用AddPart()方法添加到装配中的。装配的顶层元素是层次结构中唯一添加到渲染器中的道具（使用AddActor()）。还要注意coneActor出现了两次：一次作为装配的一部分，一次作为单独的actor添加到渲染器中使用AddActor()。正如你所想象的那样，这意味着装配的渲染需要连接变换矩阵，以确保每个vtkProp3D的正确定位。此外，层次装配在拾取过程中需要特殊处理（即，在图形上选择道具），因为一个vtkProp可以在不同的装配层次结构中出现多次。在第8章“拾取”中更详细地讨论了拾取问题。</p> 
<p>        正如图3-34所示，还有其他类型的vtkProp。这些大多数将在本书中的许多示例中进行非正式描述。特别是，当我们描述体积渲染时（请参阅第7章“体积渲染”），对vtkVolume进行了广泛覆盖。</p> 
<p>3.11 章总结<br>         渲染是使用计算机生成图像的过程。计算机图形学是涵盖渲染技术的研究领域，是数据可视化的基础。</p> 
<p>        三维渲染技术模拟光线和相机与对象或演员的交互，以生成图像。一个场景由光源、相机和演员的组合组成。对象顺序渲染技术按顺序在场景中渲染演员来生成图像。图像顺序技术逐像素渲染图像。基于多边形的图形硬件基于对象顺序技术。光線跟踪或光線投射是一种图像顺序技术。</p> 
<p>        光照模型需要颜色的规范。我们看到了RGB（红-绿-蓝）和HSV（色调-饱和度-明度）颜色模型。对于大多数用户来说，HSV模型比RGB模型更自然。光照模型还包括由环境光、漫反射和镜面反射光引起的效果。</p> 
<p>        计算机图形学中有四个重要的坐标系。模型系统是我们定义几何形状的三维坐标系。世界系统是全局笛卡尔坐标系。所有建模数据最终都被转换为世界系统。视图坐标系表示相机可见的内容。它是一个从（-1,1）缩放的二维系统。显示坐标系使用计算机显示器上的实际像素位置。</p> 
<p>        齐次坐标是一个4D坐标系，我们可以在其中包含透视变换的效果。变换矩阵是作用于齐次坐标的4x4矩阵。变换矩阵可以表示演员的平移、缩放和旋转的效果。这些矩阵可以相乘以给出组合变换。</p> 
<p>        图形编程通常使用高级图形库和专用硬件系统实现。这些专用系统提供更好的性能和更容易实现图形应用程序。这些系统中实现的常见技术包括抖动和z缓冲。抖动是一种通过混合可用颜色的组合来模拟颜色的技术。Z缓冲是一种执行隐藏线和隐藏表面消除的技术。</p> 
<p>        可视化工具包使用基于光源、相机、演员和渲染器的图形模型。渲染器绘制到渲染窗口中。演员属性由属性对象表示，它们的几何由映射器对象表示。这些各种类的实例化共同形成一个场景。与场景中的对象的交互由vtkRenderWindowInteractor和vtkInteractorStyle类实现。这些类使用命令/观察者设计模式，触发和响应事件。用户可以观察特定事件并编写回调函数，执行任意任务，轻松扩展工具包以适用于特定应用程序。</p> 
<h4>3.12 章参考文献说明</h4> 
<p><br>         本章为读者提供了足够的信息，以理解计算机图形学中使用的基本问题和术语。有许多涵盖计算机图形学更详细内容的好书，建议那些希望更全面了解的读者阅读。计算机图形学的圣经是[FoleyVanDam90]。对于希望阅读更少令人生畏的书籍的人来说，[BurgerGillies89]和[Watt93]也是有用的参考书。您还可以查阅ACM SIGGRAPH会议的论文集。这些会议包括一些计算机图形学中最重要工作的论文和其他论文的参考文献。[Carlson85]为那些希望了解更多关于人类视觉系统的人提供了很好的介绍。</p> 
<h4>3.13 参考文献</h4> 
<p><br> [Bresenham65] J. E. Bresenham. “一种用于数字绘图机的计算机控制算法。”IBM系统杂志，4(1)：25–30，1965年1月。</p> 
<p>[BurgerGillies89] P. Burger 和 D. Gillies。交互式计算图形功能、过程和设备级方法。Addison-Wesley，Reading, MA，1989年。</p> 
<p>[Carlson85] N. R. Carlson。行为生理学（第3版）。Allyn and Bacon Inc.，Newton, MA，1985年。</p> 
<p>[Dartnall83] H. J. A. Dartnall，J. K. Bowmaker 和 J. D. Mollon。“人类视觉色素：来自七个人眼睛的显微光度测定结果。”皇家学会会议录，伦敦，1983年。</p> 
<p>[FoleyVanDam90] J. D. Foley，A. van Dam，S. K. Feiner 和 J. F. Hughes。计算机图形学原理与实践（第2版）。Addison-Wesley，Reading, MA，1990年。</p> 
<p>[Fuchs80] H. Fuchs，Z. M. Kedem 和 B. F. Naylor。“通过先验树结构生成可见表面的改进模型。”计算机图形学（SIGGRAPH‘80），14(3)：124–133，1980年。</p> 
<p>[Gamma95] E. Gamma，R. Helm，R. Johnson，J. Vlissides。设计模式 可重用面向对象软件的元素。Addison-Wesley，1995年。ISBN0-201-63361-2。</p> 
<p>[Ousterhout94] J. K.Ousterhout。Tcl和Tk工具包。Addison-Wesley Publishing Company，Reading, MA，1994年。</p> 
<p>[Watt93] A. Watt。3D计算机图形学（第2版）。Addison-Wesley，Reading, MA，1993年。</p> 
<p>[Whitted80] T. Whitted。“用于阴影显示的改进照明模型。”ACM通讯，23(6)：343-349，1980年。</p> 
<h4>3.14 练习</h4> 
<p><br> 3.1 估计一束光从太阳发射、到达地球并击中一个一平方米的野餐毯的几率。您可以假设太阳是一个点光源，均匀地向所有方向发射光线。从太阳到地球的大致距离为150,000,000公里。</p> 
<p>a) 当太阳正好在头顶上方时，几率是多少？</p> 
<p>b) 当太阳相对于野餐毯的表面法线倾斜45度时，几率是多少？</p> 
<p>c) 您做了什么样的假设或近似？</p> 
<p>3.2 根据您在练习3.1中的结果，确定一束光从太阳射到野餐毯上并进入观察者眼睛的几率存在哪些困难？</p> 
<p>3.3 青色可以在HSV和RGB颜色空间中表示，如图3-4所示。这两种青色的表示不会产生相同的波长强度图。它们有何不同？</p> 
<p>3.4 vtkSphereSource类生成一个球体的多边形模型。使用本章末尾的示例作为起点，创建一个程序来显示一个白色的球体。将环境和漫反射强度设置为0.5。然后在此程序中添加一个for循环，调整这个球体的环境和漫反射颜色，使得随着循环的进行，漫反射颜色从红色变为蓝色，环境颜色从蓝色变为绿色。您也可以尝试调整其他光照参数，如镜面颜色、环境、漫反射和镜面强度。</p> 
<p>3.5 使用练习3.4中描述的vtkSphereSource，创建一个程序来显示在位置为(1,1,1)处放置了一个光源的球体。然后通过添加一个for循环来扩展此程序，调整活动摄像机的裁剪范围，以便可以看到球体内部的逐渐增加的部分。通过增加裁剪范围的第一个值，您将调整前裁剪平面的位置。一旦前裁剪平面开始与球体相交，您应该能够看到其内部。vtkSphereSource的默认半径为0.5，因此请确保您以小于1.0的增量调整裁剪范围。</p> 
<p>3.6 修改“渲染一个圆锥”的程序，以便用户可以输入齐次坐标中的世界坐标，并且程序将输出结果的显示坐标。参考vtkRenderer的参考页面，其中有一些有用的方法。</p> 
<p>a) 有哪些世界坐标您预计在显示坐标中是未定义的？</p> 
<p>b) 当世界坐标在相机后面时会发生什么？</p> 
<p>3.7 考虑对一个10x10像素的正方形进行光栅化。比较在平面、Gouraud或Phong着色的情况下需要进行的算术操作数量的近似差异。</p> 
<p>3.8 使用z缓冲时，我们在光栅化一个基元时还必须插值z值（或深度）。从练习3.7开始，计算在光栅化我们的正方形时计算z缓冲值的额外负担是什么？</p> 
<p>3.9 vtkTransform有一个GetOrientation()方法，它查看从一系列旋转构建的结果转换矩阵，并提供将重现该矩阵的单个x、y和z旋转的方法。指定一系列旋转的顺序，并使用GetOrientation()请求方向。然后按照vtkActor执行旋转的相同顺序应用旋转，并验证生成的4x4转换矩阵是否相同。</p> 
<p>3.10 vtkTransform默认情况下在当前转换的右侧应用新的转换。PostMultiply()方法更改了这种行为，使得转换应用在左侧。</p> 
<p>a) 使用vtkTransform创建一个变换，使用各种变换操作符，包括Scale()、RotateXYZ()和Translate()。然后使用PostMultiplyOn()创建相同的矩阵。</p> 
<p>b) 在一系列转换的右侧应用旋转实际上是围绕其自身坐标系旋转对象。使用rotations.tcl脚本验证这一点。你能解释一下吗？</p> 
<p>c) 在一系列转换的左侧应用旋转实际上是围绕世界坐标系旋转对象。修改rotations.tcl脚本以说明这一点。（提示：您将需要使用vtkTransform创建一个显式变换，并使用SetUserMatrix()设置actor的变换。）</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da935013de546aa3a0855f4ec43e0f07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《vtk9 book》 官方web版 第3章 - 计算机图形基础 （4 / 5）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8456fa49bf6c41dd0be6a163963fa5aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Transformer——Attention 注意力机制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>