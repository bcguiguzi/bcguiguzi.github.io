<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>递归算法的时间复杂度计算 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="递归算法的时间复杂度计算" />
<meta property="og:description" content="在算法分析中，当一个算法中包含递归调用时，其时间复杂度的分析会转化为一个递归方程求解。实际上，这个问题是数学上求解渐近阶的问题，而递归方程的形式多种多样，其求解方法也是不一而足，比较常用的有以下四种方法：
(1)代入法(Substitution Method)
代入法的基本步骤是先推测递归方程的显式解，然后用数学归纳法来验证该解是否合理。
(2)迭代法(Iteration Method)
迭代法的基本步骤是迭代地展开递归方程的右端，使之成为一个非递归的和式，然后通过对和式的估计来达到对方程左端即方程的解的估计。
(3)套用公式法(Master Method)
这个方法针对形如“T(n) = aT(n/b) &#43; f(n)”的递归方程。这种递归方程是分治法的时间复杂性所满足的递归关系，即一个规模为n的问题被分成规模均为n/b的a个子问题，递归地求解这a个子问题，然后通过对这a个子间题的解的综合，得到原问题的解。
(4)差分方程法(Difference Formula Method)
可以将某些递归方程看成差分方程，通过解差分方程的方法来解递归方程，然后对解作出渐近阶估计。
下面就以上方法给出一些例子说明。
一、代入法
大整数乘法计算时间的递归方程为：T(n) = 4T(n/2) &#43; O(n)，其中T(1) = O(1)，我们猜测一个解T(n) = O(n2 )，根据符号O的定义，对n&gt;n0，有T(n) &lt; cn2 - eO(2n)（注意，这里减去O(2n)，因其是低阶项，不会影响到n足够大时的渐近性），把这个解代入递归方程，得到：
T(n) = 4T(n/2) &#43; O(n)
≤ 4c(n/2)2 - eO(2n/2)) &#43; O(n)
= cn2 - eO(n) &#43; O(n)
≤ cn2
其中，c为正常数，e取1，上式符合 T(n)≤cn2 的定义，则可认为O(n2 )是T(n)的一个解，再用数学归纳法加以证明。
二、迭代法
某算法的计算时间为：T(n) = 3T(n/4) &#43; O(n)，其中T(1) = O(1)，迭代两次可将右端展开为：
T(n) = 3T(n/4) &#43; O(n)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/67b565756158471ba509b22681ce826a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-10-16T21:56:45+08:00" />
<meta property="article:modified_time" content="2013-10-16T21:56:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">递归算法的时间复杂度计算</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; color:rgb(73,73,73); font-family:simsun; font-size:14px; background-color:rgb(226,221,199)"> 在算法分析中，当一个算法中包含递归调用时，其时间复杂度的分析会转化为一个递归方程求解。实际上，这个问题是数学上求解渐近阶的问题，而递归方程的形式多种多样，其求解方法也是不一而足，比较常用的有以下四种方法：</p> 
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; color:rgb(73,73,73); font-family:simsun; font-size:14px; background-color:rgb(226,221,199)">  <wbr></wbr></p> 
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; color:rgb(73,73,73); font-family:simsun; font-size:14px; background-color:rgb(226,221,199)">  <wbr></wbr> <wbr></wbr> <wbr></wbr> (1)代入法(Substitution Method)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 代入法的基本步骤是先推测递归方程的显式解，然后用数学归纳法来验证该解是否合理。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> (2)迭代法(Iteration Method)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 迭代法的基本步骤是迭代地展开递归方程的右端，使之成为一个非递归的和式，然后通过对和式的估计来达到对方程左端即方程的解的估计。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> (3)套用公式法(Master Method)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 这个方法针对形如“T(n) = aT(n/b) + f(n)”的递归方程。这种递归方程是分治法的时间复杂性所满足的递归关系，即一个规模为n的问题被分成规模均为n/b的a个子问题，递归地求解这a个子问题，然后通过对这a个子间题的解的综合，得到原问题的解。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> (4)差分方程法(Difference Formula Method)</p> 
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; color:rgb(73,73,73); font-family:simsun; font-size:14px; background-color:rgb(226,221,199)">  <wbr></wbr> <wbr></wbr> <wbr></wbr> 可以将某些递归方程看成差分方程，通过解差分方程的方法来解递归方程，然后对解作出渐近阶估计。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 下面就以上方法给出一些例子说明。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 一、代入法<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 大整数乘法计算时间的递归方程为：T(n) = 4T(n/2) + O(n)，其中T(1) = O(1)，我们猜测一个解T(n) = O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> )，根据符号O的定义，对n&gt;n0，有T(n) &lt; cn<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> - eO(2n)（注意，这里减去O(2n)，因其是低阶项，不会影响到n足够大时的渐近性），把这个解代入递归方程，得到：<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> T(n) = <wbr></wbr> 4T(n/2) + O(n)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> ≤ 4c(n/2)<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> - eO(2n/2)) + O(n)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> = <wbr></wbr> cn<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> - eO(n) + O(n)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> ≤ cn<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 其中，c为正常数，e取1，上式符合 T(n)≤cn<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> 的定义，则可认为O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> )是T(n)的一个解，再用数学归纳法加以证明。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 二、迭代法<br> <br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 某算法的计算时间为：T(n) = 3T(n/4) + O(n)，其中T(1) = O(1)，迭代两次可将右端展开为：<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> T(n) = 3T(n/4) + O(n)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> = O(n) + 3( O(n/4) + 3T(n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> ) )<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> = O(n) + 3( O(n/4) + 3( O(n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> ) + 3T(n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">3</span></sup> ) ) )<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 从上式可以看出，这是一个递归方程，我们可以写出迭代i次后的方程：<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> T(n) = O(n) + 3( O(n/4) + 3( O(n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> ) + ... + 3( n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i</span></sup> + 3T(n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i+1</span></sup> ) ) ) )<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 当n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i+1</span></sup> =1时，T(n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i+1</span></sup> )=1，则<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> T(n) = n + (3/4) + (3<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> /4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> )n + ... + (3<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i</span></sup> /4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i</span></sup> )n + (3<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i+1</span></sup> )T(1)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> &lt; 4n + 3<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i+1</span></sup><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 而由n/4<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i+1</span></sup> =1可知，i&lt;log<sub><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">4</span></sub> n，从而<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 3<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">i+1</span></sup> ≤ 3<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">4</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">n+1</span></sup> = 3<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">3</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">n*log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">4</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">3</span></sup> +1 = 3nlog<sub><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">4</span></sub> 3<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 代入得：<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> T(n) &lt; 4n + 3nlog<sub><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">4</span></sub> 3，即T(n) = O(n)。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 三、套用公式法<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 这个方法为估计形如：</p> 
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; color:rgb(73,73,73); font-family:simsun; font-size:14px; background-color:rgb(226,221,199)"> 　　T(n) = aT(n/b) + f(n)</p> 
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; color:rgb(73,73,73); font-family:simsun; font-size:14px; background-color:rgb(226,221,199)"> 　　其中，a≥1和b≥1，均为常数，f(n)是一个确定的正函数。在f(n)的三类情况下，我们有T(n)的渐近估计式：<br> <br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 1.若对于某常数ε&gt;0，有f(n) = O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a-ε</span></sup> )，则T(n) = O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> )<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 2.若f(n) = O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> )，则T(n) = O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> *logn)<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 3.若f(n) = O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a+ε</span></sup> )，且对于某常数c&gt;1和所有充分大的正整数n，有af(n/b)≤cf(n)，则T(n)=O(f(n))。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 设T(n) = 4T(n/2) + n，则a = 4，b = 2，f(n) = n，计算得出n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> = n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">2</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">4</span></sup> = n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> ，而f(n) = n = O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2-ε</span></sup> )，此时ε= 1，根据第1种情况，我们得到T(n) = O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">2</span></sup> )。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 这里涉及的三类情况，都是拿f(n)与n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> 作比较，而递归方程解的渐近阶由这两个函数中的较大者决定。在第一类情况下，函数n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> 较大，则T(n)=O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> )；在第三类情况下，函数f(n)较大，则T(n)=O(f (n))；在第二类情况下，两个函数一样大，则T(n)=O(n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> *logn)，即以n的对数作为因子乘上f(n)与T(n)的同阶。<br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr><br>  <wbr></wbr> <wbr></wbr> <wbr></wbr> 但上述三类情况并没有覆盖所有可能的f(n)。在第一类情况和第二类情况之间有一个间隙：f(n)小于但不是多项式地小于n<sup><span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">log</span><sub><span style="font-size:10px; word-wrap:normal; word-break:normal; line-height:18px">b</span></sub> <span style="font-size:12px; word-wrap:normal; word-break:normal; line-height:19px">a</span></sup> ，第二类与第三类之间也存在这种情况，此时公式法不适用。</p> 
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; color:rgb(73,73,73); font-family:simsun; font-size:14px; background-color:rgb(226,221,199)"> <br> </p> 
<p style="margin-top:0px; margin-bottom:5px; padding-top:0px; padding-bottom:0px; border:0px; list-style:none; word-wrap:normal; word-break:normal; line-height:21px; color:rgb(73,73,73); font-family:simsun; font-size:14px; background-color:rgb(226,221,199)"> 转自：<a target="_blank" href="http://blog.sina.com.cn/s/blog_4aba4b7101013vmh.html" rel="nofollow noopener noreferrer">http://blog.sina.com.cn/s/blog_4aba4b7101013vmh.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/453639c3250e56144abe2574a08c2269/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">字符串与字符数组</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c01856f6f51f004b0e9e6cb8d105880/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">10月飞马小编特别推荐：PDP领导力测试</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>