<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android：启动流程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android：启动流程" />
<meta property="og:description" content="Android启动流程 第一步：启动电源以及系统启动 当电源按下，引导芯片代码开始从预定义的地方(固化在ROM)开始执行。加载引导程序到RAM，然后 执行
第二步：引导程序 引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针 对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qi bootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运 营商加锁和限制的地方。
引导程序分两个阶段执行。
第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序; 第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程 序可以根据配置参数或者输入数据设置内核。 Android引导程序可以在\bootable\bootloader\legacy\usbloader找到。传统的加载器包含两个文件， 需要在这里说明:
init.s初始化堆栈，清零BBS段，调用main.c的_main()函数; main.c初始化硬件(闹钟、主板、键盘、控制台)，创建linux标签
第三步：内核 Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表， 加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第 一个进程
第四步：init进程 （搭建环境&#43;启动zygote） init进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main()方法执行init进程的职责。
创建和挂载启动所需的文件目录初始化和启动属性服务解析init.rc配置文件并 启动zygote进程
3.1 ----》SystemServers—》开启一系列服务（AMS、WMS、PKMS、PMS、、、、）
3.2 ----》Launcher --&gt; app —&gt; 从 zygote fork 子进程 app 第五步：启动Lancher App fork函数 pid_t fork(void) 返回值分两种情况:
返回0表示成功创建子进程，并且接下来进入子进程执行流程返回PID(&gt;0)，成功创建子进程，并且继续执行父进程流程代码返回非正数(&lt;0)，创建子进程失败，失败原因主要有: 进程数超过系统所能创建的上限，errno会被设置为EAGAIN系统内存不足，errno会被设置为 ENOMEM 使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空 间:包括进程上下文(进程执行活动全过程的静态描述)、进程堆栈、打开的文件描述符、信号控 制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等(只有小量信 息)。因此，使用 fork() 函数的代价是很大的
子进程与父进程的区别:
除了文件锁以外,其他的锁都会被继承各自的进程ID和父进程ID不同子进程的未决告警被清除;子进程的未决信号集设置为空集。 相关面试题 你了解Android启动流程吗 当按电源键触发开机，首先会从ROM中预定义的地方加载引导程序BootLoader到RAM中，并执行BootLoader程序启动Linux kernel，然后启动用户级别的第一个进程：init进程。init进程会解析init.rc脚本并做一些初始化工作，包括挂载文件系统、创建工作目录以及启动系统服务进程等，其中系统服务进程包括Zygote、system manger、media等。在zygote中会进一步启动system_server进程，并启动AMS、WMS、PMS等服务，等这些服务启动后AMS就会打开Launcher应用的home activity，然后看到了手机的“桌面”
system_server为什么要在zygote中启动，而不是由init启动 zygote作为孵化器可以提前加载一些资源，这样fork()时基于Copy_On_Write 机制创建的其他进程就能直接使用这些资源而不用重新加载。比如system_server可以直接使用Zygote中的JNI函数、共享库、常用的类、以及主题资源
zygote为什么不用Binder机制进行IPC通信 Binder 机制中存在 Binder 线程池，是多线程的，如果 Zygote 采用 Binder 的话就存在上面说的fork() 与 多线程的问题了。其实严格来说，Binder 机制不一定要多线程，所谓的 Binder 线程只不过是在循环读取 Binder 驱动的消息而已，只注册一个 Binder 线程也是可以工作的，比如 service manager就是这样的。实际上 Zygote 尽管没有采取 Binder 机制，它也不是单线程的，但它在 fork() 前主动停止了其他线程，fork() 后重新启动了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c4cca025945f0edae11918ba94c80bf6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-11T15:12:16+08:00" />
<meta property="article:modified_time" content="2023-04-11T15:12:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android：启动流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Android_0"></a>Android启动流程</h3> 
<p><img src="https://images2.imgbox.com/20/03/Zn9M5T90_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_3"></a>第一步：启动电源以及系统启动</h5> 
<p>当电源按下，引导芯片代码开始从预定义的地方(固化在ROM)开始执行。加载引导程序到RAM，然后 执行</p> 
<h5><a id="_6"></a>第二步：引导程序</h5> 
<p>引导程序是在Android操作系统开始运行前的一个小程序。引导程序是运行的第一个程序，因此它是针 对特定的主板与芯片的。设备制造商要么使用很受欢迎的引导程序比如redboot、uboot、qi bootloader或者开发自己的引导程序，它不是Android操作系统的一部分。引导程序是OEM厂商或者运 营商加锁和限制的地方。<br> 引导程序分两个阶段执行。<br> 第一个阶段，检测外部的RAM以及加载对第二阶段有用的程序; 第二阶段，引导程序设置网络、内存等等。这些对于运行内核是必要的，为了达到特殊的目标，引导程 序可以根据配置参数或者输入数据设置内核。 Android引导程序可以在\bootable\bootloader\legacy\usbloader找到。传统的加载器包含两个文件， 需要在这里说明:<br> init.s初始化堆栈，清零BBS段，调用main.c的_main()函数; main.c初始化硬件(闹钟、主板、键盘、控制台)，创建linux标签</p> 
<h5><a id="_12"></a>第三步：内核</h5> 
<p>Android内核与桌面linux内核启动的方式差不多。内核启动时，设置缓存、被保护存储器、计划列表， 加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第 一个进程</p> 
<h5><a id="init_zygote_14"></a>第四步：init进程 （搭建环境+启动zygote）</h5> 
<p>init进程是Linux系统中用户空间的第一个进程，进程号固定为1。Kernel启动后，在用户空间启动init进程，并调用init中的main()方法执行init进程的职责。</p> 
<ol><li>创建和挂载启动所需的文件目录</li><li>初始化和启动属性服务</li><li>解析init.rc配置文件并 <strong>启动zygote进程</strong><br> 3.1 ----》SystemServers—》开启一系列服务（AMS、WMS、PKMS、PMS、、、、）<br> 3.2 ----》Launcher --&gt; app —&gt; 从 zygote fork 子进程 app</li></ol> 
<h5><a id="Lancher_App_25"></a>第五步：启动Lancher App</h5> 
<h3><a id="fork_27"></a>fork函数</h3> 
<pre><code class="prism language-bash">pid_t fork<span class="token punctuation">(</span>void<span class="token punctuation">)</span>
</code></pre> 
<p>返回值分两种情况:</p> 
<ul><li>返回0表示成功创建子进程，并且接下来进入子进程执行流程</li><li>返回PID(&gt;0)，成功创建子进程，并且继续执行父进程流程代码</li><li>返回非正数(&lt;0)，创建子进程失败，失败原因主要有: 进程数超过系统所能创建的上限，errno会被设置为EAGAIN系统内存不足，errno会被设置为 ENOMEM</li></ul> 
<p><img src="https://images2.imgbox.com/f4/b0/CBC3CciF_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空 间:包括进程上下文(进程执行活动全过程的静态描述)、进程堆栈、打开的文件描述符、信号控 制设定、进程优先级、进程组号等。子进程所独有的只有它的进程号，计时器等(只有小量信 息)。因此，使用 fork() 函数的代价是很大的</p> 
</blockquote> 
<p>子进程与父进程的区别:</p> 
<ol><li>除了文件锁以外,其他的锁都会被继承</li><li>各自的进程ID和父进程ID不同</li><li>子进程的未决告警被清除;</li><li>子进程的未决信号集设置为空集。</li></ol> 
<h3><a id="_46"></a>相关面试题</h3> 
<h5><a id="Android_48"></a>你了解Android启动流程吗</h5> 
<p>当按电源键触发开机，首先会从ROM中预定义的地方加载引导程序BootLoader到RAM中，并执行BootLoader程序启动Linux kernel，然后启动用户级别的第一个进程：init进程。init进程会解析init.rc脚本并做一些初始化工作，包括挂载文件系统、创建工作目录以及启动系统服务进程等，其中系统服务进程包括Zygote、system manger、media等。在zygote中会进一步启动system_server进程，并启动AMS、WMS、PMS等服务，等这些服务启动后AMS就会打开Launcher应用的home activity，然后看到了手机的“桌面”</p> 
<h5><a id="system_serverzygoteinit_51"></a>system_server为什么要在zygote中启动，而不是由init启动</h5> 
<p>zygote作为孵化器可以提前加载一些资源，这样fork()时基于Copy_On_Write 机制创建的其他进程就能直接使用这些资源而不用重新加载。比如system_server可以直接使用Zygote中的JNI函数、共享库、常用的类、以及主题资源</p> 
<h5><a id="zygoteBinderIPC_55"></a>zygote为什么不用Binder机制进行IPC通信</h5> 
<p>Binder 机制中存在 Binder 线程池，是多线程的，如果 Zygote 采用 Binder 的话就存在上面说的fork() 与 多线程的问题了。其实严格来说，Binder 机制不一定要多线程，所谓的 Binder 线程只不过是在循环读取 Binder 驱动的消息而已，只注册一个 Binder 线程也是可以工作的，比如 service manager就是这样的。实际上 Zygote 尽管没有采取 Binder 机制，它也不是单线程的，但它在 fork() 前主动停止了其他线程，fork() 后重新启动了。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d8fa66929f2e5526179d28c6b08c9da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows 10怎样安装.msi文件？三分钟解决问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/63917b55bc0cdde95b0e8e49ec73248e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LeetCode 新手村刷题（GO）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>