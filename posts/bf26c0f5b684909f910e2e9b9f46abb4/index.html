<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【IMX6ULL驱动开发学习】10.Linux I2C驱动实战：AT24C02驱动设计流程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【IMX6ULL驱动开发学习】10.Linux I2C驱动实战：AT24C02驱动设计流程" />
<meta property="og:description" content="前情回顾：【IMX6ULL驱动开发学习】09.Linux之I2C框架简介和驱动程序模板_阿龙还在写代码的博客-CSDN博客
目录
一、修改设备树（设备树用来指定引脚资源）
二、编写驱动
2.1 i2c_drv_read
2.2 i2c_drv_write
2.3 完整驱动程序
三、上机测试
一、修改设备树（设备树用来指定引脚资源） 放在哪个I2C控制器下面AT24C02的I2C设备地址（查看芯片手册 0x50）compatible属性：用来寻址驱动程序 修改设备树：在内核目录下 vi arch/arm/boot/dts/100ask_imx6ull-14x14.dts &amp;i2c1 { clock-frequency = &lt;100000&gt;; pinctrl-names = &#34;default&#34;; pinctrl-0 = &lt;&amp;pinctrl_i2c1&gt;; status = &#34;okay&#34;; at24c02 { compatible = &#34;100ask,i2cdev&#34;; reg = &lt;0x50&gt;;//设备地址 查看芯片手册 }; }; at24c02节点会转换成i2c_client，i2c_client里有个adpater，即i2c_client.adpater。i2c_client.adpater将指向一个i2c控制器，i2c控制器与&amp;i2c1节点对应，即&amp;i2c1就是一个i2c控制器，内核里对&amp;i2c1这个i2c控制器已经编写好了驱动程序。
二、编写驱动 在I2C驱动框架的基础上对i2c_drv_read和i2c_drv_write函数修改
2.1 i2c_drv_read 实现读AT24C02的0地址数据需要完成一下步骤：
初始化i2c_msg
发起一次写操作: 把0发给AT24C02, 表示要从0地址读数据
发起一次读操作: 得到数据
/* 实现对应的open/read/write等函数，填入file_operations结构体 */ static ssize_t i2c_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset) { int err; unsigned char *kern_buf; struct i2c_msg msgs[2]; /* 从0读取size字节 */ kern_buf = kmalloc(size, GFP_KERNEL); /* 初始化i2c_msg * 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/bf26c0f5b684909f910e2e9b9f46abb4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-24T23:40:31+08:00" />
<meta property="article:modified_time" content="2023-08-24T23:40:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【IMX6ULL驱动开发学习】10.Linux I2C驱动实战：AT24C02驱动设计流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>前情回顾：<a href="https://blog.csdn.net/qq_43460230/article/details/132477473?spm=1001.2014.3001.5501" title="【IMX6ULL驱动开发学习】09.Linux之I2C框架简介和驱动程序模板_阿龙还在写代码的博客-CSDN博客">【IMX6ULL驱动开发学习】09.Linux之I2C框架简介和驱动程序模板_阿龙还在写代码的博客-CSDN博客</a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88%E8%AE%BE%E5%A4%87%E6%A0%91%E7%94%A8%E6%9D%A5%E6%8C%87%E5%AE%9A%E5%BC%95%E8%84%9A%E8%B5%84%E6%BA%90%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88%E8%AE%BE%E5%A4%87%E6%A0%91%E7%94%A8%E6%9D%A5%E6%8C%87%E5%AE%9A%E5%BC%95%E8%84%9A%E8%B5%84%E6%BA%90%EF%BC%89" rel="nofollow">一、修改设备树（设备树用来指定引脚资源）</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99%E9%A9%B1%E5%8A%A8-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99%E9%A9%B1%E5%8A%A8" rel="nofollow">二、编写驱动</a></p> 
<p id="2.1%C2%A0i2c_drv_read-toc" style="margin-left:80px;"><a href="#2.1%C2%A0i2c_drv_read" rel="nofollow">2.1 i2c_drv_read</a></p> 
<p id="2.2%C2%A0i2c_drv_write-toc" style="margin-left:80px;"><a href="#2.2%C2%A0i2c_drv_write" rel="nofollow">2.2 i2c_drv_write</a></p> 
<p id="2.3%20%E5%AE%8C%E6%95%B4%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.3%20%E5%AE%8C%E6%95%B4%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F" rel="nofollow">2.3 完整驱动程序</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%B8%8A%E6%9C%BA%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E4%B8%8A%E6%9C%BA%E6%B5%8B%E8%AF%95" rel="nofollow">三、上机测试</a></p> 
<p></p> 
<h3 id="%E4%B8%80%E3%80%81%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%91%EF%BC%88%E8%AE%BE%E5%A4%87%E6%A0%91%E7%94%A8%E6%9D%A5%E6%8C%87%E5%AE%9A%E5%BC%95%E8%84%9A%E8%B5%84%E6%BA%90%EF%BC%89">一、修改设备树（设备树用来指定引脚资源）</h3> 
<ul><li>放在哪个I2C控制器下面</li><li>AT24C02的I2C设备地址（查看芯片手册 0x50）</li><li>compatible属性：用来寻址驱动程序</li></ul> 
<p>修改设备树：在内核目录下 vi  arch/arm/boot/dts/100ask_imx6ull-14x14.dts </p> 
<pre><code class="language-objectivec">&amp;i2c1 {
    clock-frequency = &lt;100000&gt;;
    pinctrl-names = "default";
    pinctrl-0 = &lt;&amp;pinctrl_i2c1&gt;;
    status = "okay";

    at24c02 { 
       compatible = "100ask,i2cdev";
       reg = &lt;0x50&gt;;//设备地址 查看芯片手册
    };  
};</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/0f/86/YX3FIq5y_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/06/27/6825m4BS_o.png"></p> 
<p>at24c02节点会转换成i2c_client，i2c_client里有个adpater，即i2c_client.adpater。i2c_client.adpater将指向一个i2c控制器，i2c控制器与&amp;i2c1节点对应，即&amp;i2c1就是一个i2c控制器，内核里对&amp;i2c1这个i2c控制器已经编写好了驱动程序。</p> 
<h3 id="%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99%E9%A9%B1%E5%8A%A8">二、编写驱动</h3> 
<p>在I2C驱动框架的基础上对i2c_drv_read和i2c_drv_write函数修改</p> 
<h4 id="2.1%C2%A0i2c_drv_read">2.1 i2c_drv_read</h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/61/6a/zErRvKRK_o.png"></p> 
<p>实现读AT24C02的0地址数据需要完成一下步骤：</p> 
<ul><li> <p>初始化i2c_msg</p> </li><li> <p>发起一次写操作: 把0发给AT24C02, 表示要从0地址读数据</p> </li><li> <p>发起一次读操作: 得到数据</p> </li></ul> 
<pre><code class="language-objectivec">/* 实现对应的open/read/write等函数，填入file_operations结构体                   */
static ssize_t i2c_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)
{
	int err;
	unsigned char *kern_buf;
	struct i2c_msg msgs[2];

	/* 从0读取size字节 */

	kern_buf = kmalloc(size, GFP_KERNEL);

	/* 初始化i2c_msg 
	 * 1. 发起一次写操作: 把0发给AT24C02, 表示要从0地址读数据
	 * 2. 发起一次读操作: 得到数据
	 */
	msgs[0].addr  = g_client-&gt;addr; //设备树里记录了设备地址：0x50
	msgs[0].flags = 0;              //flags为0：写操作 
	msgs[0].buf   = kern_buf;		//取得数据
	kern_buf[0]   = 0; 				//buf里第一个字节表示设备存储空间地址，把地址数据0发给设备
	msgs[0].len   = 1;				//发送长度为1，即 发送一个字节数据0给设备

	msgs[1].addr  = g_client-&gt;addr;
	msgs[1].flags = I2C_M_RD;  		//读操作
	msgs[1].buf   = kern_buf;		//读到的数据保存在kern_buf里
	msgs[1].len   = size;			//读size个数据

	//函数由内核提供
	err = i2c_transfer(g_client-&gt;adapter, msgs, 2);

	/* copy_to_user  */
	err = copy_to_user(buf, kern_buf, size);

	kfree(kern_buf);
	
	return size;
}</code></pre> 
<h4 id="2.2%C2%A0i2c_drv_write">2.2 i2c_drv_write</h4> 
<p>AT24C02一页只有8个字节内存，故写入多数据需要循环写入</p> 
<p>实现AT24C02的0地址起的读数据需要完成一下步骤：</p> 
<ul><li> <p>初始化i2c_msg</p> </li><li> <p>发起一次写操作：把地址发给AT24C02, 表示要从该地址读数据</p> </li><li> <p>地址偏移并继续写</p> </li></ul> 
<pre><code class="language-objectivec">//一页只有8个字节 循环写
static ssize_t i2c_drv_write(struct file *file, const char __user *buf, size_t size, loff_t *offset)
{
	int err;
	unsigned char kern_buf[9];
	struct i2c_msg msgs[1];
	int len;
	unsigned char addr = 0;

	/* 把size字节的数据写入地址0 */

	//kern_buf = kmalloc(size+1, GFP_KERNEL);

	while (size &gt; 0)
	{
		if (size &gt; 8)
			len = 8;
		else
			len = size;

		size -= len;

		/* copy_from_user  */
		err = copy_from_user(kern_buf+1, buf, len);
		buf += len;


		/* 初始化i2c_msg 
		* 1. 发起一次写操作: 把0发给AT24C02, 表示要从0地址读数据
		* 2. 发起一次读操作: 得到数据
		*/
		msgs[0].addr  = g_client-&gt;addr;
		msgs[0].flags = 0;  /* 写操作 */
		msgs[0].buf   = kern_buf;
		kern_buf[0]   = addr;  // 写AT24C02的地址，从0开始写，buf里第一个字节表示设备存储空间地址
		msgs[0].len   = len+1;
		addr += len;

		err = i2c_transfer(g_client-&gt;adapter, msgs, 1);

		mdelay(20);//写一页需要时间约10ms，烧写一页数据需等待
	}

	//kfree(kern_buf);
	
	return size;    
}</code></pre> 
<h4 id="2.3%20%E5%AE%8C%E6%95%B4%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F">2.3 完整驱动程序</h4> 
<p>i2c_drv.c</p> 
<pre><code class="language-objectivec">#include "asm/uaccess.h"
#include "linux/delay.h"
#include "linux/i2c.h"
#include &lt;linux/module.h&gt;
#include &lt;linux/poll.h&gt;

#include &lt;linux/fs.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/miscdevice.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/major.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;
#include &lt;linux/stat.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/tty.h&gt;
#include &lt;linux/kmod.h&gt;
#include &lt;linux/gfp.h&gt;
#include &lt;linux/gpio/consumer.h&gt;
#include &lt;linux/platform_device.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;linux/of_irq.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/fcntl.h&gt;
#include &lt;linux/timer.h&gt;

/* 主设备号                                                                 */
static int major = 0;
static struct class *my_i2c_class;

static struct i2c_client *g_client;

static DECLARE_WAIT_QUEUE_HEAD(gpio_wait);
struct fasync_struct *i2c_fasync;


/* 实现对应的open/read/write等函数，填入file_operations结构体                   */
static ssize_t i2c_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)
{
	int err;
	unsigned char *kern_buf;
	struct i2c_msg msgs[2];

	/* 从0读取size字节 */

	kern_buf = kmalloc(size, GFP_KERNEL);

	/* 初始化i2c_msg 
	 * 1. 发起一次写操作: 把0发给AT24C02, 表示要从0地址读数据
	 * 2. 发起一次读操作: 得到数据
	 */
	msgs[0].addr  = g_client-&gt;addr; //设备树里记录了设备地址：0x50
	msgs[0].flags = 0;              //flags为0：写操作 
	msgs[0].buf   = kern_buf;		//取得数据
	kern_buf[0]   = 0; 				//buf里第一个字节表示设备存储空间地址，把地址数据0发给设备
	msgs[0].len   = 1;				//发送长度为1，即 发送一个字节数据0给设备

	msgs[1].addr  = g_client-&gt;addr;
	msgs[1].flags = I2C_M_RD;  		//读操作
	msgs[1].buf   = kern_buf;		//读到的数据保存在kern_buf里
	msgs[1].len   = size;			//读size个数据

	//函数由内核提供
	err = i2c_transfer(g_client-&gt;adapter, msgs, 2);

	/* copy_to_user  */
	err = copy_to_user(buf, kern_buf, size);

	kfree(kern_buf);
	
	return size;
}

//一页只有8个字节 循环写
static ssize_t i2c_drv_write(struct file *file, const char __user *buf, size_t size, loff_t *offset)
{
	int err;
	unsigned char kern_buf[9];
	struct i2c_msg msgs[1];
	int len;
	unsigned char addr = 0;

	/* 把size字节的数据写入地址0 */

	//kern_buf = kmalloc(size+1, GFP_KERNEL);

	while (size &gt; 0)
	{
		if (size &gt; 8)
			len = 8;
		else
			len = size;

		size -= len;

		/* copy_from_user  */
		err = copy_from_user(kern_buf+1, buf, len);
		buf += len;


		/* 初始化i2c_msg 
		* 1. 发起一次写操作: 把0发给AT24C02, 表示要从0地址读数据
		* 2. 发起一次读操作: 得到数据
		*/
		msgs[0].addr  = g_client-&gt;addr;
		msgs[0].flags = 0;  /* 写操作 */
		msgs[0].buf   = kern_buf;
		kern_buf[0]   = addr;  // 写AT24C02的地址，从0开始写，buf里第一个字节表示设备存储空间地址
		msgs[0].len   = len+1;
		addr += len;

		err = i2c_transfer(g_client-&gt;adapter, msgs, 1);

		mdelay(20);//写一页需要时间约10ms，烧写一页数据需等待
	}

	//kfree(kern_buf);
	
	return size;    
}


static unsigned int i2c_drv_poll(struct file *fp, poll_table * wait)
{
	//printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
	poll_wait(fp, &amp;gpio_wait, wait);
	//return is_key_buf_empty() ? 0 : POLLIN | POLLRDNORM;
	return 0;
}

static int i2c_drv_fasync(int fd, struct file *file, int on)
{
	if (fasync_helper(fd, file, on, &amp;i2c_fasync) &gt;= 0)
		return 0;
	else
		return -EIO;
}


/* 定义自己的file_operations结构体                                              */
static struct file_operations i2c_drv_fops = {
	.owner	 = THIS_MODULE,
	.read    = i2c_drv_read,
	.write   = i2c_drv_write,
	.poll    = i2c_drv_poll,
	.fasync  = i2c_drv_fasync,
};


static int i2c_drv_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	// struct device_node *np = client-&gt;dev.of_node;
	// struct i2c_adapter *adapter = client-&gt;adapter;

	/* 记录client */
	g_client = client;

	/* 注册字符设备 */
	/* 注册file_operations 	*/
	major = register_chrdev(0, "100ask_i2c", &amp;i2c_drv_fops);  /* /dev/gpio_desc */

	my_i2c_class = class_create(THIS_MODULE, "100ask_i2c_class");
	if (IS_ERR(my_i2c_class)) {
		printk("%s %s line %d\n", __FILE__, __FUNCTION__, __LINE__);
		unregister_chrdev(major, "100ask_i2c");
		return PTR_ERR(my_i2c_class);
	}

	device_create(my_i2c_class, NULL, MKDEV(major, 0), NULL, "myi2c"); /* /dev/myi2c */
	
	return 0;
}

static int i2c_drv_remove(struct i2c_client *client)
{
	/* 反注册字符设备 */
	device_destroy(my_i2c_class, MKDEV(major, 0));
	class_destroy(my_i2c_class);
	unregister_chrdev(major, "100ask_i2c");

	return 0;
}

static const struct of_device_id myi2c_dt_match[] = {
	{ .compatible = "100ask,i2cdev" },
	{},
};

//必须有这个，不然装载驱动不成功
static const struct i2c_device_id at24c02_ids[] = {
	{ "xxxxyyy",	(kernel_ulong_t)NULL },
	{ /* END OF LIST */ }
};
static struct i2c_driver my_i2c_driver = {
	.driver = {
		   .name = "100ask_i2c_drv",
		   .owner = THIS_MODULE,
		   .of_match_table = myi2c_dt_match,
	},
	.probe = i2c_drv_probe,
	.remove = i2c_drv_remove,
	.id_table = at24c02_ids,
};


static int __init i2c_drv_init(void)
{
	/* 注册i2c_driver */
	return i2c_add_driver(&amp;my_i2c_driver);
}

static void __exit i2c_drv_exit(void)
{
	/* 反注册i2c_driver */
	i2c_del_driver(&amp;my_i2c_driver);
}

/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */

module_init(i2c_drv_init);
module_exit(i2c_drv_exit);

MODULE_LICENSE("GPL");


</code></pre> 
<h3 id="%E4%B8%89%E3%80%81%E4%B8%8A%E6%9C%BA%E6%B5%8B%E8%AF%95">三、上机测试</h3> 
<ul><li>在/home/book/100ask_imx6ull-sdk/Linux-4.9.88目录下重新编译设备树：make dtbs</li><li>复制到单板上，如下：</li></ul> 
<pre><code class="language-objectivec">PC:
cp arch/arm/boot/dts/100ask_imx6ull-14x14.dtb ~/nfs_rootfs/
 
开发板:
mount -t nfs -o nolock,vers=3 192.168.5.11:/home/book/nfs_rootfs /mnt
cp /mnt/100ask_imx6ull-14x14.dtb  /boot
reboot
 </code></pre> 
<ul><li>进入系统固件目录下查看cd /sys/firmware/devicetree/base/</li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/29/e5/8E65GK9U_o.png"></p> 
<ul><li>在系统 总线 i2c 设备下面查看是否有这个设备</li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cf/b0/bVEDWypn_o.png"> </p> 
<p> 有这个设备，但没有对应驱动程序</p> 
<ul><li>挂载网络文件系统：mount -t nfs -o nolock,vers=3 192.168.5.11:/home/book/nfs_rootfs /mnt</li><li>装载驱动程序：insmod i2c_drv.ko</li><li>查看对应设备节点：ls /dev/myi2c -l  </li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/14/f9/bACUzKH2_o.png"></p> 
<ul><li>查看用法、测试驱动程序 </li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/ed/lJlD20TH_o.png"> </p> 
<p> 成功读出数据！</p> 
<p></p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ae486d3dc48832ac675dbd5e97ca21f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL MVCC的详解之Read View</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9d0d9d3f7a9300d0859ab6233baa2abf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【原创】PyCharm启动Debug报错无法运行，提示No such file or directory</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>