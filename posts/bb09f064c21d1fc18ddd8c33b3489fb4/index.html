<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入详解数据库事务（开发必用） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入详解数据库事务（开发必用）" />
<meta property="og:description" content="一.事务的概念： 一组逻辑操作单元，时数据从一个状态转换到另一个状态。
二.事务处理的原则： 保证所有的事务都被当做一个操作单元来执行，即使出现了故障，也不能改变这种处置原则。要么与事务相关的数据全部被修改，并永远的提交保存下来，要么所有的事务全部回滚到事务没被执行的状态。
三.那些操作会影响数据库的提交 （一）.数据库连接一旦断开，数据库的数据都被会提交
（二）.DDL操作完成，数据自动提交，并且无法回滚
（三）.DML操作默认为提交，但是可以通过 set auto commit = false;来设置不允许自动提交
四.模拟事务提交
事务执行过程图：
通用的包含事务的更新方法
/** * 包含事务的通行的方法实现增删改 * @param conn 从外部传入的数据库连接，意图在执行完一次DML操作时，数据库的连接不会断开， * 确保事务不会因为连接断而出现提交的现象 * @param sql 增删改语句 * @param args 占位符？个数不一定，根据sql占位符的个数，传入对应数量object */ public static int update(Connection conn,String sql,Object... args){ int temp = -1; PreparedStatement pst = null; try{ //2.预编译sql语句 pst = conn.prepareStatement(sql); //3.填充占位符 for (int i = 0; i &lt; args.length; i&#43;&#43;) { pst.setObject(i&#43;1,args[i]); } //4.执行 /* pst." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/bb09f064c21d1fc18ddd8c33b3489fb4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-06T17:38:52+08:00" />
<meta property="article:modified_time" content="2022-04-06T17:38:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入详解数据库事务（开发必用）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="%E2%80%8B"><img alt="" height="597" src="https://images2.imgbox.com/d0/ce/3ixIBnLW_o.jpg" width="690"></h3> 
<h2></h2> 
<h2></h2> 
<h2></h2> 
<h2></h2> 
<h2></h2> 
<h2 id="%C2%A0%E4%B8%80.%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A"> 一.事务的概念：</h2> 
<p>一组逻辑操作单元，时数据从一个状态转换到另一个状态。</p> 
<h2 id="%C2%A0%E4%BA%8C.%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9A"> 二.事务处理的原则：</h2> 
<p>        保证所有的事务都被当做一个操作单元来执行，即使出现了故障，也不能改变这种处置原则。要么与事务相关的数据全部被修改，并永远的<strong>提交</strong>保存下来，要么所有的事务全部<strong>回滚</strong>到事务没被执行的状态。</p> 
<h2 id="%E4%B8%89.%E9%82%A3%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%8F%90%E4%BA%A4">三.那些操作会影响数据库的提交</h2> 
<p>（一）.数据库连接一旦断开，数据库的数据都被会提交</p> 
<p>（二）.DDL操作完成，数据自动提交，并且无法回滚</p> 
<p>（三）.DML操作默认为提交，但是可以通过 set auto commit = false;来设置不允许自动提交</p> 
<p>四.模拟事务提交</p> 
<p>事务执行过程图：</p> 
<p><img alt="" height="516" src="https://images2.imgbox.com/53/93/BundkQdQ_o.png" width="696"></p> 
<p> </p> 
<p> </p> 
<p>通用的包含事务的更新方法</p> 
<pre><code>    /**
     * 包含事务的通行的方法实现增删改
     * @param conn 从外部传入的数据库连接，意图在执行完一次DML操作时，数据库的连接不会断开，
     *             确保事务不会因为连接断而出现提交的现象
     * @param sql 增删改语句
     * @param args 占位符？个数不一定，根据sql占位符的个数，传入对应数量object
     */
    public static int update(Connection conn,String sql,Object... args){
        int temp = -1;
        PreparedStatement pst = null;
        try{
            //2.预编译sql语句
            pst = conn.prepareStatement(sql);
            //3.填充占位符
            for (int i = 0; i &lt; args.length; i++) {
                pst.setObject(i+1,args[i]);
            }
            //4.执行
            /*
            pst.execute();如果是查询操作返回的是true
                            如果是更新操作返回的是false；
            pst.executeUpdate();返回执行操作以后受影响的行数
             */
//            pst.execute();
            temp = pst.executeUpdate();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            //5.释放资源
            closeResource(null,pst);
        }
        return temp;
    }</code></pre> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89.%E6%A8%A1%E6%8B%9F%E5%AD%98%E5%9C%A8%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84102%E7%BB%99103%E8%BD%AC%E8%B4%A6100%E5%85%83%E6%93%8D%E4%BD%9C%EF%BC%9B">（一）.模拟存在异常情况下的102给103转账100元操作；</h3> 
<pre><code>public void testTransaction() throws Exception {
        Connection conn = null;
        //102向103转账100元
        try{
            conn = JDBCUtils.getConnection();
            //关闭DML自动调教功能
            conn.setAutoCommit(false);
            String sql1 = "update user_tab set balance = balance - 100 where id = ?";
            update(conn,sql1,102);
            //模拟异常
            System.out.println(10/0);
            //103接受102转账100元
            String sql2 = "update user_tab set balance = balance + 100 where id = ?";
            update(conn,sql2,103);
            //提交事务
            conn.commit();
            System.out.println("转账成功");
        }catch (Exception e ){
            e.printStackTrace();
            //出现异常数据回滚
            conn.rollback();
        }finally {
//将自动提交功能设置还原为true
            conn.setAutoCommit(true);
            JDBCUtils.closeResource(conn,null);
        }
    }</code></pre> 
<p><strong><span style="color:#fe2c24;">转账失败</span></strong></p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/64/d6/OvJ2pK2D_o.png" width="906"></p> 
<p></p> 
<p><img alt="" height="305" src="https://images2.imgbox.com/37/58/sNMVd7SS_o.png" width="466"></p> 
<h3 id="%C2%A0%EF%BC%88%E4%BA%8C%EF%BC%89.%E6%A8%A1%E6%8B%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%BC%82%E5%B8%B8%E4%B8%8B%E8%BD%AC%E8%B4%A6%E7%9A%84%E6%83%85%E5%86%B5"> （二）.模拟不存在异常下转账的情况</h3> 
<pre><code>public void testTransaction() throws Exception {
        Connection conn = null;
        //102向103转账100元
        try{
            conn = JDBCUtils.getConnection();
            //关闭DML自动调教功能
            conn.setAutoCommit(false);
            String sql1 = "update user_tab set balance = balance - 100 where id = ?";
            update(conn,sql1,102);
            //模拟异常
//        System.out.println(10/0);
            //103接受102转账100元
            String sql2 = "update user_tab set balance = balance + 100 where id = ?";
            update(conn,sql2,103);
            //提交事务
            conn.commit();
            System.out.println("转账成功");
        }catch (Exception e ){
            e.printStackTrace();
            //出现异常数据回滚
            conn.rollback();
        }finally {
//将自动提交功能设置还原为true
            conn.setAutoCommit(true);
            JDBCUtils.closeResource(conn,null);
        }
    }</code></pre> 
<p><strong><span style="color:#fe2c24;">转账成功</span></strong></p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/b8/1b/z9pqMrGD_o.png" width="537"></p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/fc/05/27ZEpg4f_o.png" width="501"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p><img alt="" height="842" src="https://images2.imgbox.com/95/e2/cQZtaFct_o.jpg" width="1000"></p> 
<h2 id="%E4%BA%94.%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E5%B1%9E%E6%80%A7">四.事务的ACID属性</h2> 
<h3 id="%E4%B8%80.%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B1%9E%E6%80%A7">（一）.事务的属性</h3> 
<h4 id="1.%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9A">1.原子性：</h4> 
<p>        原子性是指事务时一个不可分割的工作单元，事务中的操作要么都发生，要么都不发生</p> 
<h4 id="2.%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9A">2.一致性：</h4> 
<p>        事务必须使数据库从一个一致状态转换到另一个一致状态</p> 
<h4 id="3.%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%9A">3.隔离性：</h4> 
<p>        事务并发在执行时，各个事务之间的数据互不干扰的，各个事务 之间的数据不受任何影响</p> 
<h4 id="4.%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9A">4.持久性：</h4> 
<p>        事务一旦被提交，就是永久性的改变，接下来发生的事或数据库故障都不会对其有任何我影响。</p> 
<h3 id="%E4%BA%8C.%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98">（二）.事务的并发问题</h3> 
<h4 id="1.%E8%84%8F%E8%AF%BB%EF%BC%9A">1.脏读：</h4> 
<p>        读出了<span style="color:#a2e043;"><strong>未提交</strong></span>的数据。</p> 
<p>        事务T1，事务T2，T1读入一个数据段A，读出值为1，此时T2修改了A的值，T1将A= 2的值读出，但此时T2撤销了事务，回滚到A=1的阶段。此时T1读出的数据无效，即为脏读：</p> 
<h4 id="2.%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9A">2.不可重复读：</h4> 
<p><span style="color:#a2e043;"><strong>只读提交</strong></span>的数据，并且第一次读出来是什么，在提交之前，读出来的东西和第一次保持一致；</p> 
<p>        事务T1在第一次读到A=1，在读到以后，无论其他事务（T2）对字段A怎么<span style="color:#ff9900;"><strong>更新</strong></span>提交（A=2），T1在提交前读出A字段永远都是A=1；</p> 
<h4 id="3.%E5%B9%BB%E8%AF%BB%EF%BC%9A">3.幻读：</h4> 
<p>事务T1第一次读出100条数据，T2<span style="color:#ff9900;"><strong>插入</strong></span>3条数据并提交，T1提交后，T1再次读，读出103条数去，即为幻读，</p> 
<p></p> 
<h3 id="%E4%B8%89.%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">（三）.隔离级别</h3> 
<p><span style="color:#38d8f0;"><strong>1. READ UNCOMMITED（读未提交的数据）</strong></span></p> 
<p><span style="color:#38d8f0;"><strong>2. READ COMMITED(读已提交的数据）</strong></span></p> 
<p><span style="color:#38d8f0;"><strong>3. REPEATED READ(可重复读）</strong></span></p> 
<p><span style="color:#38d8f0;"><strong>4. </strong></span><strong><span style="color:#38d8f0;">串行化：SERIALIZABLE</span></strong>（各个事务顺序执行）</p> 
<p></p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/f7/e3/g3kWvuU4_o.jpg" width="679"></p> 
<h3 id="%E5%9B%9B.java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%88%E6%A1%86%E6%9E%B6%E5%BF%85%E7%94%A8%EF%BC%8C%E6%8F%90%E5%89%8D%E6%89%93%E5%9F%BA%E7%A1%80%EF%BC%89">（四）.java代码实现隔离级别（<span style="color:#6eaad7;"><strong>框架必用，提前打基础</strong></span>）</h3> 
<pre><code>package Transaction;

import UpAndSelMethod.Method;
import jdbcUtil.JDBCUtils;
import org.junit.Test;
import userBean.User;

import java.sql.Connection;
//*********卧槽，为啥我设置隔离级别为读未提交却读不出来修改了却为体骄傲的数据，麻了******************
public class Test隔离级别 {
    //**************************测试事务并发问题与隔离级别的关系*********************************

    //测试查询
    @Test
    public void testTransactionSelect() throws Exception {
        Connection conn = JDBCUtils.getConnection();
        //设置sql语句
        String sql = "select id,name,balance from user_tab where id = ?";
        //查看当前连接的的隔离级别
        System.out.println(conn.getTransactionIsolation());
        //设置当前连接的隔离级别为读未提交
        conn.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);
        System.out.println(conn.getTransactionIsolation());
        User user = Method.selectinfo(User.class, sql, 103);
        System.out.println(user);
    }
    //测试更新
    @Test
    public void testTransactionUpdate() throws Exception {
        //获取连接
        Connection conn = JDBCUtils.getConnection();
        //设置自动提交为false
        conn.setAutoCommit(false);
        //sql
        String sql = "update user_tab set balance = ? where id = ?";
        //执行更新操作
        Method.update(conn,sql,5000,103);
        //线程睡眠15秒
        Thread.sleep(15000);
        //睡眠结束
        System.out.println("修改完成");

    }

}
</code></pre> 
<p><img alt="" height="719" src="https://images2.imgbox.com/9d/a4/87Rr9a2S_o.png" width="1200"></p> 
<p> </p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/82/55/jRPLiC1m_o.jpg" width="750"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cf16abe0a2a6002ea7bf53729f0c8225/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">组合设计模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2783acf5e178ff457ec796afee7b7fd2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Edge小技巧(持续更新)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>