<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis主从复制和哨兵模式详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis主从复制和哨兵模式详解" />
<meta property="og:description" content="小伙伴们好，欢迎关注，一起学习，无限进步
以下内容为学习Redis过程中的笔记
文章目录 Redis主从复制概念环境配置一主二从哨兵模式（重点） Redis主从复制 概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。
默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。
主从复制的作用主要包括：
1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis 服务器的并发量。
4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。
一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：
1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；
2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。
电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是&#34;多读少写&#34;。
对于这种场景，我们可以使如下这种架构：
主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！
只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！
环境配置 127.0.0.1:6379&gt; info replication # 查看当前库的信息 # Replication role:master # 角色 master connected_slaves:0 # 没有从机 master_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882a master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 复制3个配置文件，修改对应的信息：
1、端口号
2、pid名字
3、log文件名字
4、dump.rdb名字
修改完后，启动3个redis服务
通过进程信息查看
ps -ef|grep redis 查看除注释外的配置文件
cat redis.conf | grep -v &#34;#&#34; | grep -v &#34;^$&#34; # 查看配置文件并拷贝 cat redis." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/49b3705474b13ba65b5d64898f0e8b46/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-01T07:49:27+08:00" />
<meta property="article:modified_time" content="2024-03-01T07:49:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis主从复制和哨兵模式详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>小伙伴们好，欢迎关注，一起学习，无限进步<br> 以下内容为学习Redis过程中的笔记</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Redis_4" rel="nofollow">Redis主从复制</a></li><li><ul><li><a href="#_6" rel="nofollow">概念</a></li><li><a href="#_33" rel="nofollow">环境配置</a></li><li><a href="#_78" rel="nofollow">一主二从</a></li><li><a href="#_127" rel="nofollow">哨兵模式（重点）</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Redis_4"></a>Redis主从复制</h3> 
<h4><a id="_6"></a>概念</h4> 
<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。</p> 
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p> 
<p>主从复制的作用主要包括：<br> 1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br> 2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。<br> 3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis 服务器的并发量。</p> 
<p>4、高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p> 
<p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：<br> 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br> 2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。</p> 
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是"多读少写"。</p> 
<p>对于这种场景，我们可以使如下这种架构：</p> 
<p><img src="https://images2.imgbox.com/da/06/f6XMvoIh_o.png" alt="在这里插入图片描述"></p> 
<p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！<br> 只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p> 
<h4><a id="_33"></a>环境配置</h4> 
<pre><code class="prism language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> info replication  <span class="token comment"># 查看当前库的信息</span>
<span class="token comment"># Replication</span>
role:master  <span class="token comment"># 角色 master</span>
connected_slaves:0 <span class="token comment"># 没有从机</span>
master_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882a
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
</code></pre> 
<p><strong>复制3个配置文件，修改对应的信息：</strong></p> 
<p>1、端口号</p> 
<p>2、pid名字</p> 
<p>3、log文件名字</p> 
<p>4、dump.rdb名字</p> 
<p>修改完后，启动3个redis服务</p> 
<p>通过进程信息查看</p> 
<pre><code class="prism language-bash"><span class="token function">ps</span> -ef<span class="token operator">|</span><span class="token function">grep</span> redis
</code></pre> 
<p><mark>查看除注释外的配置文件</mark></p> 
<pre><code class="prism language-bash"><span class="token function">cat</span> redis.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token string">"#"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token string">"^$"</span>
<span class="token comment"># 查看配置文件并拷贝</span>
<span class="token function">cat</span> redis.conf <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token string">"#"</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token string">"^$"</span> <span class="token operator">&gt;</span> ./redis6380.conf
</code></pre> 
<h4><a id="_78"></a>一主二从</h4> 
<p>默认启动 redis 服务，每台 Redis服务器都是主节点，已办情况下只配置从机就好了。</p> 
<pre><code class="prism language-bash">slaveof <span class="token number">127.0</span>.0.1 <span class="token number">6379</span>  <span class="token comment"># 使用命令配置关闭服务就会失效，长期使用应该在 redis.conf 中配置</span>
info replication <span class="token comment"># 查看节点信息</span>

<span class="token comment"># 在从机中查看</span>
<span class="token number">127.0</span>.0.1:638<span class="token operator"><span class="token file-descriptor important">0</span>&gt;</span> info replication
<span class="token comment"># Replication</span>
role:slave  <span class="token comment"># 当前角色是从机</span>
master_host:127.0.0.1  <span class="token comment"># 可以的看到主机的信息</span>
master_port:6379

<span class="token comment"># 在主机中查看</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> info replication
<span class="token comment"># Replication</span>
role:master
connected_slaves:1  <span class="token comment"># 多了从机的配置</span>
slave0:ip<span class="token operator">=</span><span class="token number">127.0</span>.0.1,port<span class="token operator">=</span><span class="token number">6380</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">42</span>,lag<span class="token operator">=</span><span class="token number">1</span>   <span class="token comment"># 多了从机的配置</span>
</code></pre> 
<p>真实的主从配置应该是在配置文件中配置，使用命令只能暂时配置。</p> 
<p><strong>注意细节</strong></p> 
<p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存。</p> 
<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息。</p> 
<p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机。只要变为从机，立马就会从主机中获取值！</p> 
<p><strong>复制原理：</strong></p> 
<p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p> 
<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p> 
<p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p> 
<p>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p> 
<p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到。</p> 
<p>如果主机断开了连接，我们可以使用 <mark>slaveof no one</mark> 让自己变成主机，其他的节点就可以手动连接到最新的这个主节点。这时候如果主机恢复了，就需要重新连接。</p> 
<h4><a id="_127"></a>哨兵模式（重点）</h4> 
<p>自动选举老大的模式</p> 
<p><strong>概述</strong></p> 
<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。</p> 
<p>谋权篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数<mark>自动将从库转换为主库</mark>。</p> 
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</strong></p> 
<p><img src="https://images2.imgbox.com/22/7a/E4y8MJco_o.png" alt="在这里插入图片描述"></p> 
<p>哨兵的两个作用</p> 
<ul><li> <p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p> </li><li> <p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</p> </li></ul> 
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p> 
<p><img src="https://images2.imgbox.com/34/e3/iHUePUiz_o.png" alt="在这里插入图片描述"></p> 
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p> 
<p>目前是 redis 是一主二从的状态</p> 
<p>1、配置哨兵配置文件 sentinel.conf (简单配置)</p> 
<pre><code class="prism language-bash"><span class="token comment"># sentinel monitor 被监控的名称 host port 1</span>
sentinel monitor myredis <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">1</span>
</code></pre> 
<p>后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p> 
<p>2、启动哨兵！</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@izuf61151k3ad2dso6mo9oz bin<span class="token punctuation">]</span><span class="token comment"># redis-sentinel ./sentinel.conf</span>
</code></pre> 
<p>如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）</p> 
<p>如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！</p> 
<p><strong>哨兵模式优点：</strong></p> 
<p>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有<br> 2、 主从可以切换，故障可以转移，系统的可用性就会更好<br> 3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！</p> 
<p><strong>缺点：</strong><br> 1、Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！<br> 2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</p> 
<p><strong>配置多个哨兵</strong></p> 
<p>1、复制 3 个 sentinel.conf 文件</p> 
<p>2、配置对应的端口号，工作目录，主机连接地址</p> 
<p>3、**启动顺序&gt;**先启服务器主机，在启从机，在启动哨兵</p> 
<p><strong>哨兵模式的全部配置：</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># Example sentinel.conf</span>
<span class="token comment"># 哨兵sentinel实例运行的端口 默认26379</span>
port <span class="token number">26379</span>
<span class="token comment"># 增加日志目录 </span>
logfile /logs/sentinel_26379.log
<span class="token comment"># 哨兵sentinel的工作目录</span>
<span class="token function">dir</span> /tmp
<span class="token comment"># 哨兵sentinel监控的redis主节点的 ip port</span>
<span class="token comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符".-_"组成。</span>
<span class="token comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span>
<span class="token comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span>
sentinel monitor mymaster <span class="token number">127.0</span>.0.1 <span class="token number">6379</span> <span class="token number">2</span>
<span class="token comment"># 2 表是至少有两个从机认为主机宕机，才开始选取新的主机,每行最后的数字，不能大于哨兵的数量，不能小于哨兵数量的一半。</span>
<span class="token comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span>
<span class="token comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span>
<span class="token comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span>
sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
<span class="token comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span>
<span class="token comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span>
sentinel down-after-milliseconds mymaster <span class="token number">30000</span>
<span class="token comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span>

<span class="token comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span>
sentinel parallel-syncs mymaster <span class="token number">1</span>
<span class="token comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span>
<span class="token comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span>
<span class="token comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span>
<span class="token comment">#3.当想要取消一个正在进行的failover所需要的时间。 </span>
<span class="token comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span>
<span class="token comment"># 默认三分钟</span>
<span class="token comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span>
sentinel failover-timeout mymaster <span class="token number">180000</span>
<span class="token comment"># SCRIPTS EXECUTION</span>
<span class="token comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知</span>
相关人员。
<span class="token comment">#对于脚本的运行结果有以下规则：</span>
<span class="token comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span>
<span class="token comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span>
<span class="token comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span>
<span class="token comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span>
<span class="token comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span>
<span class="token comment">#通知脚本</span>
<span class="token comment"># shell编程</span>
<span class="token comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span>
sentinel notification-script mymaster /var/redis/notify.sh
<span class="token comment"># 客户端重新配置主节点参数脚本</span>
<span class="token comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span>
<span class="token comment"># 以下参数将会在调用脚本时传给脚本:</span>
<span class="token comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span>
<span class="token comment"># 目前&lt;state&gt;总是“failover”,</span>
<span class="token comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span>
<span class="token comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span>
<span class="token comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span>
<span class="token comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span>
sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="token comment"># 一般都是由运维来配置！</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/15cccc49c2bceea3bfd3519ae13215b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络编程难点之select、poll与epoll详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f50d04269aa66a84383e2b5074f9a6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FMD 8位MCU入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>