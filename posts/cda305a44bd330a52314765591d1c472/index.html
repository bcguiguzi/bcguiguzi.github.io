<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;基础知识归纳(1)-大厂必备八股文篇 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;基础知识归纳(1)-大厂必备八股文篇" />
<meta property="og:description" content="共享数据的保护： 常引用：使所引用的形参不能被更新
void display(const double&amp; a);常对象：在生存期内不能被更新，但必须被初始化
A const a(3,4);常成员函数：不能修改对象中数据成员，也不能调用类中没有被const 修饰的成员函数（常对象唯一的对外接口）.如果声明了一个常对象，则该对象只能调用他的常函数！-&gt;可以用于对重载函数的区分;
void print();
void print() const;extern int a:使其他文件也能访问该变量
声明一个函数或定义函数时，冠以static的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数(每一个cpp 文件就是一个编译单元)。 运算符重载注意 单目运算符最好重载为成员函数，双目最好为友元函数。=、[]只能重载成员函数，&lt;&lt;、&gt;&gt;只能重载为友元函数。 程序内存分配方式以及它们的区别 内存分配大致上可以分成5块：
栈区（stack）。栈，就是那些由编译器在需要时分配，在不需
要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。（由编译器管理）堆区（heap）。一般由程序员分配、释放，若程序员不是放，程
序结束时可能由系统回收。注意，它与数据结构中的堆是两回事，分配方式类似于链表。全局区（静态区）（static）。全局变量和静态变量被分配到同
一块内存中。程序结束后由系统释放。常量存储区。常量字符串就是放在这里的，不允许修改，程序
结束后由系统释放。程序代码区。存放函数体的二进制代码。 全局变量与全局静态变量的区别 若程序由一个源文件构成时，全局变量与全局静态变量没有区别。若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的源文件所独享，即：全局静态变量对组成该程序的其它源文件是无效的。具有外部链接的静态，可以在所有源文件里调用，除了本文件，其他文件可以通过extern的方式引用。
----静态变量只被所属源文件使用 new delete 与malloc free 的联系与区别 new delete和malloc free都是释放申请的堆上的空间，都是成对存在的，否则将会造成内存泄露或二次释放不同的是，new delete是C&#43;&#43;中定义的操作符，new除了分配空间外，还会调用类的构造函数来完成初始化工作，delete除了释放空间外还会调用类的析构函数。而malloc和free是C语言中定义的函数。 explicit 函数声明时加上explicit可以阻止函数参数被隐式转换。
Class A { explicit A(int a); } Void main() { A a1=12; //不加explicit时会被隐式转换位 A a1=A(12);加了此时编译器会报错。 } 被声明为explicit的构造函数通常比non-explicit 函数更受欢迎。
mutable关键字 mutalbe的中文意思是“可变的，易变的”，跟constant（既C&#43;&#43;中的const）是反义词。在C&#43;&#43;中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量(mutable只能由于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。
我们知道，假如类的成员函数不会改变对象的状态，那么这个成员函数一般会声明为const。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。（使用mutable修饰的数据成员可以被const成员函数修改）。
用const修饰函数的返回值 如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。例如函数
Const char * GetString(void); // 如下语句将出现编译错误： char*str = GetString(); // 正确的用法是 Const char *str =GetString(); 一般只在返回值为引用和指针时使用，返回其他值时没有这个必要。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/cda305a44bd330a52314765591d1c472/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-08T20:07:21+08:00" />
<meta property="article:modified_time" content="2021-01-08T20:07:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;基础知识归纳(1)-大厂必备八股文篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="_0"></a>共享数据的保护：</h4> 
<ol><li>常引用：使所引用的形参不能被更新<br> void display(const double&amp; a);</li><li>常对象：在生存期内不能被更新，但必须被初始化<br> A const a(3,4);</li><li>常成员函数：不能修改对象中数据成员，也不能调用类中没有被const 修饰的成员函数（常对象唯一的对外接口）.如果声明了一个常对象，则该对象只能调用他的常函数！-&gt;可以用于对重载函数的区分;<br> void print();<br> void print() const;</li><li>extern int a:使其他文件也能访问该变量<br> 声明一个函数或定义函数时，冠以static的话，函数的作用域就被限制在了当前编译单元，当前编译单元内也必须包含函数的定义，也只在其编译单元可见，其他单元不能调用这个函数(每一个cpp 文件就是一个编译单元)。</li></ol> 
<h4><a id="_11"></a>运算符重载注意</h4> 
<ul><li>单目运算符最好重载为成员函数，双目最好为友元函数。</li><li>=、[]只能重载成员函数，&lt;&lt;、&gt;&gt;只能重载为友元函数。</li></ul> 
<h4><a id="_15"></a>程序内存分配方式以及它们的区别</h4> 
<p>内存分配大致上可以分成5块：</p> 
<ol><li>栈区（stack）。栈，就是那些由编译器在需要时分配，在不需<br> 要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。（由编译器管理）</li><li>堆区（heap）。一般由程序员分配、释放，若程序员不是放，程<br> 序结束时可能由系统回收。注意，它与数据结构中的堆是两回事，分配方式类似于链表。</li><li>全局区（静态区）（static）。全局变量和静态变量被分配到同<br> 一块内存中。程序结束后由系统释放。</li><li>常量存储区。常量字符串就是放在这里的，不允许修改，程序<br> 结束后由系统释放。</li><li>程序代码区。存放函数体的二进制代码。</li></ol> 
<h4><a id="_27"></a>全局变量与全局静态变量的区别</h4> 
<ol><li>若程序由一个源文件构成时，全局变量与全局静态变量没有区别。</li><li>若程序由多个源文件构成时，全局变量与全局静态变量不同：全局静态变量使得该变量成为定义该变量的源文件所独享，即：全局静态变量对组成该程序的其它源文件是无效的。</li><li>具有外部链接的静态，可以在所有源文件里调用，除了本文件，其他文件可以通过extern的方式引用。<br> ----静态变量只被所属源文件使用</li></ol> 
<h4><a id="new_delete_malloc_free__33"></a>new delete 与malloc free 的联系与区别</h4> 
<ul><li>new delete和malloc free都是释放申请的堆上的空间，都是成对存在的，否则将会造成内存泄露或二次释放</li><li>不同的是，new delete是C++中定义的操作符，new除了分配空间外，还会调用类的构造函数来完成初始化工作，delete除了释放空间外还会调用类的析构函数。而malloc和free是C语言中定义的函数。</li></ul> 
<h4><a id="explicit_37"></a>explicit</h4> 
<p>函数声明时加上explicit可以阻止函数参数被隐式转换。</p> 
<pre><code class="prism language-cpp">Class <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
   <span class="token keyword">explicit</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Void <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
   A a1<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">;</span>   <span class="token comment">//不加explicit时会被隐式转换位 A a1=A(12);加了此时编译器会报错。</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>被声明为explicit的构造函数通常比non-explicit 函数更受欢迎。</p> 
<h4><a id="mutable_52"></a>mutable关键字</h4> 
<p>mutalbe的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量(mutable只能由于修饰类的非静态数据成员)，将永远处于可变的状态，即使在一个const函数中。</p> 
<p>我们知道，假如类的成员函数不会改变对象的状态，那么这个成员函数一般会声明为const。但是，有些时候，我们需要在const的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被mutalbe来修饰。（使用mutable修饰的数据成员可以被const成员函数修改）。</p> 
<h4><a id="const_57"></a>用const修饰函数的返回值</h4> 
<p>如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。例如函数</p> 
<pre><code class="prism language-cpp">Const <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 如下语句将出现编译错误：</span>
<span class="token keyword">char</span><span class="token operator">*</span>str <span class="token operator">=</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 正确的用法是</span>
Const <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span><span class="token function">GetString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>一般只在返回值为引用和指针时使用，返回其他值时没有这个必要。</p> 
<h4><a id="constenum_68"></a>宏、const和enum</h4> 
<ol><li>#define 不被视为语言的一部分。对于单纯常量，最好用const对象或者enum替换#define。</li><li>对于类似函数的宏，尽量使用内联函数替换掉#define。</li></ol> 
<h4><a id="stack_72"></a>stack的生存期</h4> 
<blockquote> 
 <p>C++中的static对象是指存储区不属于stack和heap、"寿命"从被构造出来直至程序结束为止的对象。这些对象包括全局对象，定义于namespace作用域的对象，在class、function以及file作用域中被声明为static的对象。其中，函数内的static对象称为local static对象，而其它static对象称为non-local static对象。</p> 
</blockquote> 
<p><mark>这两者在何时被初始化(构造)这个问题上存在细微的差别</mark>：</p> 
<ul><li>对于local static对象，在其所属的函数被调用之前，该对象并不存在，即只有在第一次调用对应函数时，local static对象才被构造出来。</li><li>而对于non-local static对象，在main()函数开始前就已经被构造出来，并在main()函数结束后被析构。</li></ul> 
<p>建议：</p> 
<ol><li>对内置对象进行手工初始化，因为C++不保证初始化它们。</li><li>构造函数最好使用成员初值列，而不要在构造函数本体中使用赋值操作。初值列中列出的成员变量，其排序次序应该和它们在class中的声明次序相同(初始化顺序与声明变量顺序一致)。</li><li>为免除“跨编译单元的初始化次序问题”，尽量以local static对象替换non-local static对象。</li></ol> 
<h4><a id="STL_84"></a>STL相关</h4> 
<ol><li>STL被组织成13个头文件。algorithm、deque、functional、iterator、vector、list、map、memory、numeric、queue、set、stack 和 utility。</li><li>STL是C++通用库，由<strong>容器，算法，迭代器，仿函数，内存配置器</strong>构成。</li><li>容器<br> 作为STL的最主要组成部分－－容器，分为向量（vector），双端队列(deque)，表(list)，队列（queue），堆栈(stack)，集合(set)，多重集合(multiset)，映射(map)，多重映射(multimap)。</li></ol> 
<blockquote> 
 <p>关联式容器：map,multimap和set,multiset(multi代表允许重复元素)。<br> &lt; map&gt;中包含 pair&lt;typename T1,typename T2&gt;这种对组的结构体。<br> 函数get_allocator()用于获取map或multimap的内存配置器，内存配置器类似于指针的首地址。</p> 
</blockquote> 
<pre><code class="prism language-cpp">MAP<span class="token operator">::</span>allocator_type m1_alloc<span class="token punctuation">;</span>
MAP m1<span class="token punctuation">;</span>
m1_alloc<span class="token operator">=</span>m1<span class="token punctuation">.</span><span class="token function">get_allocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ctg<span class="token operator">=</span><span class="token function">count_if</span><span class="token punctuation">(</span>myvector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>myvector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">bind2nd</span><span class="token punctuation">(</span>greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">bind2nd</span><span class="token punctuation">(</span>greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>表示数值大于<span class="token number">2</span>的情况，为真时才执行
<span class="token comment">//类似的：</span>
<span class="token function">find_if</span><span class="token punctuation">(</span>myvector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>myvector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">bind2nd</span><span class="token punctuation">(</span>greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<ol start="4"><li>算法<br> 算法部分主要由头文件&lt; algorithm&gt;，&lt; numeric&gt;和组成。&lt; algorithm&gt;是所有STL头文件中最大的一个，它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范 围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。中则定义了一些模板类，用以声明函数对象。</li></ol> 
<blockquote> 
 <ul><li>auto_ptr只能对new分配的内存使用，不能对new[]的使用。</li><li>algorithm 中的for_each(T.begin(),T.end(),function);find(T.begin(),T.end(),value)</li><li>T.reserve(x):预留空间。实际空间小于它则扩充</li></ul> 
</blockquote> 
<ol start="5"><li>迭代器<br> 在头文件 iterator中,<strong>迭代器类型：输入型迭代器，输出型迭代器，前向迭代器（前两者结合），双向迭代器（可回头），随机存取迭代器。</strong></li></ol> 
<blockquote> 
 <p>迭代配接器是特殊的迭代器，可使算法能够以逆向，安插模式进行工作。<br> 比如：</p> 
 <ul><li>逆向迭代器：T.rbegin（），T.rend()，rbegin()指向最后一个元素，++操作逐次向前。</li><li>插入型迭代器：T.front_inserter(),T.back_inserter()，<br> copy(d1.begin(),d1.end(),inserter(d2,d2.begin()):把每个元素都插在前一个元素的前面</li><li>流迭代器：copy(d1.begin(),d1.end(),ostream_iterator(cout,”, ”)):把d1复制到输出流上输出，每个元素以,隔开。</li><li>迭代器辅助函数：advance():使迭代器前进或后退。如advance(it,-1);<br> distance():求两个迭代器之间的距离，要求同类型而且前者可以自增到后者<br> iter_swap（）：交换两个迭代器的所知内容。<br> <img src="https://images2.imgbox.com/76/cf/szAHwP83_o.png" alt="在这里插入图片描述"></li></ul> 
</blockquote> 
<ol start="6"><li>仿函数<br> 就是函数对象，类重载了操作符 ();</li><li>适配器<br> 适配器是用来修改其他组件接口的STL组件，是带有一个参数的类模板（这个参数是操作的值的数据类型）。<strong>STL定义了3种形式的适配器：容器适配器，迭代器适配器，函数适配器。</strong></li></ol> 
<blockquote> 
 <ul><li><strong>容器适配器：包括栈（stack）、队列(queue)、优先(priority_queue)</strong>。使用容器适配器，stack就可以被实现为基本容器类型（vector,dequeue,list）的适配。可以把stack看作是某种特殊的vctor,deque或者list容器，只是其操作仍然受到stack本身属性的限制。queue和priority_queue与之类似。<strong>容器适配器的接口更为简单，只是受限比一般容器要多</strong>。<img src="https://images2.imgbox.com/93/10/tnid5f9l_o.png" alt="在这里插入图片描述"></li><li><strong>迭代器适配器</strong>：修改为某些基本容器定义的迭代器的接口的一种STL组件。反向迭代器和插入迭代器都属于迭代器适配器，迭代器适配器扩展了迭代器的功能。</li><li><strong>函数适配器</strong>：通过转换或者修改其他函数对象使其功能得到扩展。这一类适配器有否定器（相当于"非"操作）、绑定器、函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或是将多参数的函数对象转化为少参数的函数对象。</li></ul> 
</blockquote> 
<ol start="8"><li>空间/内存配置器(Allocator)<br> 分为一级配置器和二级配置器；</li></ol> 
<ul><li>一级配置器：当申请空间大小超过128bytes时，直接调用malloc/free进行分配和释放</li><li>二级适配器：当申请空间小于128bytes时使用<br> <img src="https://images2.imgbox.com/a9/5c/RjKmpQfB_o.png" alt="在这里插入图片描述"><br> 首先会调用ROUND_UP()，这个是将要申请的内存字节数上调为8的倍数，然后再去内存池中获取分配的空间；</li></ul> 
<blockquote> 
 <p>STL的分配器(allocaotr)用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：</p> 
 <ul><li>new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容</li><li>delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存<br> 为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。</li><li>同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。</li></ul> 
</blockquote> 
<h4><a id="_138"></a>程序编译</h4> 
<ul><li>程序编译是指将编译好的源文件翻译成二进制目标代码的过程。主要是检查语法错误，正确的源程序文件经过编译后在磁盘上生成目标文件。编译产生的目标文件是可重定位的程序模块，不能直接运行。链接则是把目标文件和其他分别进行编译生成的目标程序模块以及系统提供的标准库函数链接在一起，生成可运行的可执行文件。</li></ul> 
<h4><a id="const__141"></a>const 赋值类型不一致时，生成新的常量</h4> 
<pre><code class="prism language-cpp">Char a<span class="token operator">=</span>’c’<span class="token punctuation">;</span>
Char<span class="token operator">&amp;</span> b<span class="token operator">=</span>a<span class="token punctuation">;</span>
Const <span class="token keyword">int</span><span class="token operator">&amp;</span> rc<span class="token operator">=</span>a<span class="token punctuation">;</span>
b<span class="token operator">=</span>’x’<span class="token punctuation">;</span>
</code></pre> 
<p>const引用类型初始化时前后数据类型不一致时，生成一个新的只读类型。此时b改变a的值时，rc所指的值不变。</p> 
<blockquote> 
 <p>C++不支持引用数组</p> 
</blockquote> 
<h4><a id="C_151"></a>C++单例模式示例(多线程下)</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">danli</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token function">danli</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>

	<span class="token punctuation">}</span>
	<span class="token keyword">static</span> danli<span class="token operator">*</span> instance<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> danli<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
	<span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// instance == NULL不代表instance一定没被new过</span>
        <span class="token punctuation">{<!-- --></span>
           <span class="token comment">// 双重判断，避免多线程环境下每次调用getInstance()函数都会先加锁再判断</span>
           <span class="token comment">// 只有在instance == NULL时再加锁去申请对象</span>
            unique_lock<span class="token operator">&lt;</span>muytex<span class="token operator">&gt;</span> <span class="token function">mymute</span><span class="token punctuation">(</span>resource_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">danli</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		        <span class="token keyword">static</span> huishou h1<span class="token punctuation">;</span>
		    <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
		<span class="token keyword">return</span> instance<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">class</span> <span class="token class-name">huishou</span>
	<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token operator">~</span><span class="token function">huishou</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
			<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">delete</span> instance<span class="token punctuation">;</span>
				instance <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>静态成员变量在main()之前创建，再main()之后回收。</p> 
<h4><a id="_192"></a>位运算</h4> 
<ol><li>左移运算符m &lt;&lt; n表示把m左移n位。在左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0；<br> 00001010 &lt;&lt; 2 = 00101000</li><li>右移运算符m &gt;&gt; n表示把m右移n位。在右移n位的时候，最右边的n位将被丢弃，但对有符号和无符号数时，最左边添加的数字不同；<br> 如果是无符号数，则最左边的n位用0替代；<br> 如果是有符号数，则用符号位替代；<br> 10001010 &gt;&gt; 3 = 11110001<br> 00001010 &gt;&gt; 3 = 00000001<br> 在实际运用中，负数实际上是用绝对值的补码进行存储和表示的；<br> 例如：整数-13的二进制数中含1的位数有30个（int 4个字节，13=00…1101，补码为11…0011）;</li></ol> 
<h4><a id="Chttpsimgblogcsdnimgcn20210108225053569pngxossprocessimagewatermarktype_ZmFuZ3poZW5naGVpdGkshadow_10text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzQ5Njgzsize_16color_FFFFFFt_70httpsimgblogcsdnimgcn20210108225108207pngxossprocessimagewatermarktype_ZmFuZ3poZW5naGVpdGkshadow_10text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzQ5Njgzsize_16color_FFFFFFt_70_202"></a>C++二维数组作为形参传递参数<img src="https://images2.imgbox.com/76/59/Ffn7pLy6_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/c9/5d/7MFk6auH_o.png" alt="在这里插入图片描述"></h4> 
<p><img src="https://images2.imgbox.com/10/9b/COWt2apW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/81/7a/gGxYZWfA_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="static_205"></a>全局变量和static变量的区别</h4> 
<blockquote> 
 <p>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p> 
</blockquote> 
<h4><a id="_208"></a>为什么栈要比堆速度要快</h4> 
<ul><li>首先, 栈是本着LIFO原则的存储机制, 对栈数据的定位相对比较快速, 而堆则是随机分配的空间, 处理的数据比较多, 无论如何, 至少要两次定位.</li><li>其次, 栈是由CPU提供指令支持的, 在指令的处理速度上, 对栈数据进行处理的速度自然要优于由操作系统支持的堆数据.</li><li>再者, 栈是在一级缓存中做缓存的, 而堆则是在二级缓存中, 两者在硬件性能上差异巨大.</li><li>最后, 各语言对栈的优化支持要优于对堆的支持, 比如swift语言中, 三个字及以内的struct结构, 可以在栈中内联, 从而达到更快的处理速度.</li></ul> 
<h4><a id="c__213"></a>c++ 析构函数调用时间</h4> 
<ol><li>对象生命周期结束，被销毁时</li><li>delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时</li><li>对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用</li></ol> 
<h4><a id="ccoutprintf_218"></a>c++中关于cout与printf的简单区别</h4> 
<p><img src="https://images2.imgbox.com/6e/60/JzTV6HiL_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/66/37/BIz5L6sd_o.png" alt="在这里插入图片描述"><br> 详细请参考：<a href="https://blog.csdn.net/qq_42191017/article/details/81709315?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">c++中关于cout与printf的简单区别</a></p> 
<h4><a id="classstruct_222"></a>class与struct区别</h4> 
<p>C++中，class与struct都可以定义一个类。他们有以下两点区别：</p> 
<ol><li>默认继承权限，如果不指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；</li><li>成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。<br> 以上两点也是struct和class最基本的差别，也是最本质的差别；</li></ol> 
<h4><a id="____228"></a>静态绑定 动态绑定 （也叫动态连编，静态连编）</h4> 
<blockquote> 
 <p>如果父类中存在有虚函数，那么编译器便会为之生成虚表（属于类）与虚指针（属于某个对象），在程序运行时，根据虚指针的指向，来决定调用哪个虚函数，这称之与动态绑定，与之相对的是静态绑定，静态绑定在编译期就决定了。</p> 
</blockquote> 
<ol><li>class和template都支持接口与多态；</li><li>对classes而言，接口是显式的，以函数签名为中心。多态则是通过virtual函数发生于运行期；</li><li>对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。</li><li>泛型<br> 泛型是通过参数化类型来实现在同一份代码上操作多种数据类型。利用“参数化类型”将类型抽象化，从而实现灵活的复用。</li></ol> 
<h4><a id="CC_236"></a>C/C++中指针和引用的区别</h4> 
<ol><li>指针有自己的一块空间，指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元，即指针是一个实体。而引用只是一个别名；</li><li>使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li><li>指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li><li>作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li><li>可以有const指针，但是没有const引用；</li><li>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li><li>指针可以有多级指针（**p），而引用至于一级；</li><li>指针和引用使用++运算符的意义不一样；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</li></ol> 
<h4><a id="c_246"></a>c++里面的四种智能指针以及代码实现</h4> 
<ul><li>为什么要使用智能指针：<br> 智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。</li></ul> 
<ol><li>auto_ptr（c++98的方案，cpp11已经抛弃）<br> 采用所有权模式。</li></ol> 
<pre><code class="prism language-cpp">auto_ptr<span class="token operator">&lt;</span> string<span class="token operator">&gt;</span> p1 <span class="token punctuation">(</span><span class="token keyword">new</span> string <span class="token punctuation">(</span>"I reigned lonely as a cloud<span class="token punctuation">.</span>”<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
auto_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> p2<span class="token punctuation">;</span>
p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span> <span class="token comment">//auto_ptr不会报错.</span>
</code></pre> 
<blockquote> 
 <p>此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！</p> 
</blockquote> 
<ol start="2"><li>unique_ptr（替换auto_ptr）<br> unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。</li></ol> 
<blockquote> 
 <p>采用所有权模式，还是上面那个例子</p> 
</blockquote> 
<pre><code class="prism language-cpp">unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> p3 <span class="token punctuation">(</span><span class="token keyword">new</span> string <span class="token punctuation">(</span><span class="token string">"auto"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//#4</span>
unique_ptr<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> p4；                       <span class="token comment">//#5</span>
p4 <span class="token operator">=</span> p3<span class="token punctuation">;</span><span class="token comment">//此时会报错！！</span>
</code></pre> 
<blockquote> 
 <p>编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。</p> 
</blockquote> 
<ol start="3"><li>shared_ptr<br> shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。</li></ol> 
<blockquote> 
 <ul><li>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。</li><li>成员函数<br> use_count 返回引用计数的个数<br> unique 返回是否是独占所有权( use_count 为 1)<br> swap 交换两个 shared_ptr 对象(即交换所拥有的对象)<br> reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少<br> get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的</li></ul> 
</blockquote> 
<ol start="4"><li>weak_ptr<br> weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。<br> 详细请参阅：<a href="https://blog.csdn.net/ypshowm/article/details/89034855">四种智能指针以及代码实现</a> / <a href="https://www.cnblogs.com/yunlambert/p/9518045.html" rel="nofollow">谈谈智能指针</a></li></ol> 
<h4><a id="_282"></a>虚函数和多态</h4> 
<p><img src="https://images2.imgbox.com/28/46/Zj3UYoWd_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="extern_C_285"></a>extern "C"的主要作用简单解释</h4> 
<ul><li> <p>extern "C"的主要作用就是为了<strong>能够正确实现C++代码调用其他C语言代码</strong>。加上extern "C"后，会指示<strong>编译器这部分代码按C语言（而不是C++）的方式进行编译</strong>。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p> </li><li> <p>这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，<strong>为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C</strong>，而extern "C"就是其中的一个策略。</p> </li></ul> 
<h4><a id="C_290"></a>请你说说C语言是怎么进行函数调用的</h4> 
<p>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。（<strong>ESP</strong>（Extended Stack Pointer）为扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针）</p> 
<blockquote> 
 <p>C语言参数压栈顺序？：从右到左</p> 
</blockquote> 
<h4><a id="C_293"></a>C++中拷贝赋值函数的形参能否进行值传递？</h4> 
<p>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数(aa = ex.aa; //此处调用拷贝构造函数)。。如此循环，无法完成拷贝，栈也会满。</p> 
<h4><a id="include_296"></a>include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别</h4> 
<pre><code>编译器预处理阶段查找头文件的路径不一样
</code></pre> 
<ol><li>使用双引号包含的头文件，查找头文件路径的顺序为：<br> 当前头文件目录<br> 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）<br> 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li><li>对于使用尖括号包含的头文件，查找头文件的路径顺序为：<br> 编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）<br> 系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径</li></ol> 
<h4><a id="STL_305"></a>STL中迭代器有什么作用作用，有指针为何还要迭代器</h4> 
<ol><li>迭代器<br> Iterator（迭代器）模式又称游标（Cursor）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。<br> 或者这样说可能更容易理解：<strong>Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。</strong><br> 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。</li><li>迭代器和指针的区别<br> 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，-&gt;、、++、–等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象, <strong>本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，–等操作。</strong><br> 迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。</li><li>迭代器产生原因<br> Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。</li></ol> 
<h4><a id="C_315"></a>一个C++源文件从文本到可执行文件经历的过程</h4> 
<p>对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：</p> 
<ol><li>预编译，预编译的时候做一些简单的文本替换，比如宏替换，而不进行语法的检查；</li><li>编译，在编译阶段，编译器将检查一些语法错误，但是，如果使用的函数事先没有定义这种情况，不再这一阶段检查，编译后，得到.s文件</li><li>汇编，将C/C++代码变为汇编代码，得到.o或者.obj文件</li><li>链接，将所用到的外部文件链接在一起，在这一阶段，就会检查使用的函数有没有定义，链接过后，形成可执行文件.exe<br> 详细请参阅：<a href="https://blog.csdn.net/daaikuaichuan/article/details/89060957">一个C++源文件从文本到可执行文件经历的过程</a></li></ol> 
<h4><a id="_323"></a>内存泄漏原因和判断方法</h4> 
<blockquote> 
 <p>内存泄漏通常是因为调用了malloc/new等内存申请操作，但是缺少了对应的free/delete。<br> 为了判断内存是否泄漏，我们一方面可以使用Linux环境下的内存泄漏检查工具Valgrind，另一方面我们写代码的时候，可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致，以此来判断内存是否有泄漏。</p> 
</blockquote> 
<p>内存泄漏分类：</p> 
<ol><li>堆内存泄漏（heap leak）。堆内存值得是程序运行过程中根据需要分配通过malloc\realloc\new等从堆中分配的一块内存，再完成之后必须要通过调用对应的free或者delete删除。<br> 如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。</li><li>系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap，handle，SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。</li><li>没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确的释放，从而造成内存泄漏。</li></ol> 
<blockquote> 
 <p><img src="https://images2.imgbox.com/d7/9b/hAuQlLNi_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/c0/96/58lcAc71_o.png" alt="在这里插入图片描述"><br> 详细请查阅： <a href="https://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html" rel="nofollow">C/C++内存泄漏及检测</a></p> 
</blockquote> 
<h4><a id="newmalloc_334"></a>new和malloc的区别</h4> 
<ol><li>new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；</li><li>new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回<br> 值一般都需要进行类型转化。</li><li>new不仅分配一段内存，而且会调用构造函数，malloc不会。</li><li>new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候<br> 会调用对象的析构函数，而free则不会。</li><li>new是一个操作符可以重载，malloc是一个库函数。</li><li>malloc分配的内存不够的时候，可以用realloc扩容。new没用这样操作。</li><li>new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。</li><li>申请数组时：new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]<br> ，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。</li></ol> 
<h4><a id="_346"></a>段错误的产生原因</h4> 
<h6><a id="1__347"></a>1. 段错误是什么</h6> 
<p>一句话来说，段错误是指访问的内存超出了系统给这个程序所设定的内存空间，例如访问了不存在的内存地址、访问了系统保护的内存地址、访问了只读的内存地址等等情况。这里贴一个对于“段错误”的准确定义。</p> 
<h6><a id="2_349"></a>2.段错误产生的原因</h6> 
<ol><li>访问不存在的内存地址</li><li>访问系统保护的内存地址</li><li>访问只读的内存地址</li><li>栈溢出<br> 详细请参阅：<a href="https://www.cnblogs.com/lidabo/p/4545625.html" rel="nofollow">Linux环境下段错误的产生原因及调试方法小结</a></li></ol> 
<h4><a id="C_356"></a>C++重载实现原理</h4> 
<p><img src="https://images2.imgbox.com/cc/c9/bC7ozUjD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="C__358"></a>C++ 函数调用过程</h4> 
<p>总结起来整个过程就三步：<br> 1）根据调用的函数名找到函数入口；<br> 2）在栈中审请调用函数中的参数及函数体内定义的变量的内存空间<br> 3）函数执行完后，释放函数在栈中的审请的参数和变量的空间，最后返回值（如果有的话）<br> 详细请查阅：<a href="https://blog.csdn.net/qq_38646470/article/details/79213082">函数调用过程</a> / <a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601204.html" rel="nofollow">C/C++函数调用过程分析</a></p> 
<h4><a id="sizeof_365"></a>sizeof求类型大小</h4> 
<ol><li>类的大小为类的<strong>非静态成员数据的类型大小之和</strong>，也就是说静态成员数据不作考虑。</li><li>普通成员函数与sizeof无关。</li><li>虚函数由于要维护在虚函数表，所以要占据一个指针大小，也就是4字节。</li><li>类的总大小也遵守类似class字节对齐的，调整规则。<br> 例如有如下结构体：</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> Stu
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token keyword">char</span> sex<span class="token punctuation">;</span>
    <span class="token keyword">float</span> hight<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>那么一个这样的结构体变量占多大内存呢？也就是<br> cout&lt;&lt;sizeof(Stu)&lt;&lt;endl; 会输出什么？<br> 在了解字节对齐方式之前想当然的会以为：sizeof(Stu) = sizeof(int)+sizeof(char)+sizeof(float) = 9.<br> 然而事实并非如此！</p> 
<blockquote> 
 <p>字节对齐原则:在系统默认的对齐方式下：每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，且最终占用字节数为成员类型中最大占用字节数的整数倍。</p> 
</blockquote> 
<p>在这个例子中，id的偏移量为0（0=4<em>0），sex的偏移量为4（4=1</em>4），hight的偏移量为8（8=2<em>4），此时占用12字节，也同时满足12=3</em>4.所以sizeof(Stu)=12.</p> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> A <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> y<span class="token punctuation">;</span>
	<span class="token keyword">char</span> z<span class="token punctuation">;</span>
	<span class="token keyword">long</span> <span class="token keyword">long</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token number">16</span>字节
<span class="token keyword">struct</span> A <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> y<span class="token punctuation">;</span>
	<span class="token keyword">char</span> z<span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token number">8</span>字节

<span class="token keyword">struct</span> A <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> y<span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> z<span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token number">12</span>字节
<span class="token keyword">struct</span> A <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token number">1</span>字节
</code></pre> 
<p><img src="https://images2.imgbox.com/1e/01/EGpHCvpR_o.png" alt="在这里插入图片描述"><br> 我的总结：</p> 
<ol><li>最终大小一定是最大数据类型的整数倍；</li><li>静态变量不占空间</li><li>每种类型的偏移量为自身的n倍；</li></ol> 
<p>详细请查阅：<a href="https://blog.csdn.net/weixin_30412577/article/details/95141536?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">struct/class等内存字节对齐问题详解</a></p> 
<h4><a id="c__415"></a>如何调试c++ 多线程程序？</h4> 
<ol><li>打印日志，日志中加上线程ID；（简单粗暴）</li><li>gdb有thread相关命令，如infothread（简写成infoth）显示线程消息，bxxthreadyy可以针对某个thread设置断点，threadxx（简写成thrxx）切换到某个thread。再配合frame（简写f）相关的命令（比如up，down在不同frame间跳转），基本可以处理若干个不同的线程间的debug……</li></ol> 
<p>详细请查阅：<a href="https://www.cnblogs.com/LuckCoder/p/10948242.html" rel="nofollow">C++(vs)多线程调试 （转）</a></p> 
<h4><a id="_421"></a>面向对象和面向过程的区别</h4> 
<ul><li>面向对象方法中，把数据和数据操作放在一起，组成对象；对同类的对象抽象出其共性组成类；类通过简单的接口与外界发生联系，对象和对象之间通过消息进行通信。<strong>面向对象的三大特性是"封装、“多态”、“继承”，五大原则是"单一职责原则"、“开放封闭原则”、“里氏替换原则”、“依赖倒置原则”、“接口分离原则”</strong>。</li><li>而面向过程方法是<strong>以过程为中心的开发方法</strong>，它自顶向下顺序进行， <strong>程序结构按照功能划分成若干个基本模块，这些模块形成树状结构</strong>。</li></ul> 
<blockquote> 
 <p>（过程）优点：<strong>性能比面向对象高</strong>，因为类调用时需要实例化，开销比较大，比较消耗源;比如嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。缺点：没有面向对象易维护、易复用、易扩展。<br> （对象）优点：<strong>易维护、易复用、易扩展</strong>，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统。缺点：性能比面向过程低。</p> 
</blockquote> 
<h4><a id="_428"></a>关于引用赋值的多态：</h4> 
<pre><code class="prism language-cpp">Class <span class="token class-name">B</span><span class="token punctuation">;</span>
Class <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token keyword">public</span> B<span class="token punctuation">;</span>

B<span class="token operator">&amp;</span> b<span class="token punctuation">;</span>
D<span class="token operator">&amp;</span> d<span class="token punctuation">;</span>
B<span class="token operator">&amp;</span> b1 <span class="token operator">=</span> d <span class="token punctuation">;</span>  <span class="token comment">//父类可以作为子类的引用，此时b1表现和指针形式一致（会调用B的非虚函数）</span>
D<span class="token operator">&amp;</span> d1 <span class="token operator">=</span> b； <span class="token comment">//错误，不能将子类作为父类的引用</span>
</code></pre> 
<h4><a id="_438"></a>模板的声明和实现不能分开的原因</h4> 
<ol><li>链接的时候，需要实例化模板，这时候就需要找模板的具体实现了。假设在main函数中<strong>调用了一个模板函数</strong>，<strong>这时候就需要去实例化该类型的模板</strong>。注意main函数里面只包含了.h文件，也就是<strong>只有模板的声明，没有具体实现。就会报错</strong>。</li><li>而模板的实现.cpp里面，虽然有模板的具体实现，但是没有谁在该.cpp里面使用一个模板函数，就不会生成一个具体化的实例</li></ol> 
<p>详细请参阅：<a href="https://www.cnblogs.com/callme/articles/6142129.html" rel="nofollow">C++ 模板类的声明与实现分离问题</a> / <a href="https://blog.csdn.net/weixin_40539125/article/details/83375452?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">C++ 模板类的声明与实现分离问题（模板实例化）</a></p> 
<h4><a id="C_443"></a>C++类中引用成员和常量成员的初始化（初始化列表）</h4> 
<p>如果一个类是这样定义的：</p> 
<pre><code class="prism language-cpp">Class <span class="token class-name">A</span>
<span class="token punctuation">{<!-- --></span>
     <span class="token keyword">public</span><span class="token operator">:</span>
          <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> pram1<span class="token punctuation">,</span> <span class="token keyword">int</span> pram2<span class="token punctuation">,</span> <span class="token keyword">int</span> pram3<span class="token punctuation">)</span><span class="token punctuation">;</span>
     privite<span class="token operator">:</span>
          <span class="token keyword">int</span> a<span class="token punctuation">;</span>
          <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
          <span class="token keyword">const</span> <span class="token keyword">int</span> c<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>假如在构造函数中对三个私有变量进行赋值则通常会这样写：</p> 
<pre><code class="prism language-cpp">A<span class="token operator">::</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> pram1<span class="token punctuation">,</span> <span class="token keyword">int</span> pram2<span class="token punctuation">,</span> <span class="token keyword">int</span> pram3<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
     a<span class="token operator">=</span>pram1<span class="token punctuation">;</span>
     b<span class="token operator">=</span>pram2<span class="token punctuation">;</span>
     c<span class="token operator">=</span>pram3<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是，这样是编译不过的。因为常量和引用初始化必须赋值。所以上面的构造函数的写法只是简单的赋值，并不是初始化。</p> 
<p>正确写法应该是：</p> 
<pre><code class="prism language-cpp">A<span class="token operator">::</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> pram1<span class="token punctuation">,</span> <span class="token keyword">int</span> pram2<span class="token punctuation">,</span> <span class="token keyword">int</span> pram3<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span>pram2<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">c</span><span class="token punctuation">(</span>pram3<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
     a<span class="token operator">=</span>pram1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>采用初始化列表实现了对常量和引用的初始化。采用括号赋值的方法，<strong>括号赋值只能用在变量的初始化而不能用在定义之后的赋值</strong>。</p> 
<blockquote> 
 <p><strong>凡是有引用类型的成员变量或者常量类型的变量的类，不能有缺省构造函数</strong>。<strong>默认构造函数没有对引用成员提供默认的初始化机制，也因此造成引用未初始化的编译错误。并且必须使用初始化列表进行初始化const对象、引用对象。</strong></p> 
</blockquote> 
<h5><a id="_477"></a>枚举变量和宏的区别</h5> 
<p><img src="https://images2.imgbox.com/b8/9c/NmMU04MI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7a/29/YYLyEYmY_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/3d/6d/dCtsUUpW_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="memsetint_481"></a>memset为int型数组初始化问题</h4> 
<p>头文件：#include &lt;string.h&gt;<br> memset() 函数用来将指定内存的前n个字节设置为特定的值，其原型为：</p> 
<pre><code class="prism language-cpp"> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token function">memset</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">,</span> size_t num <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>参数说明：</p> 
<ul><li>ptr 为要操作的内存的指针。</li><li>value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，int 和 char 可以根据 ASCII 码相互转换。</li><li>num 为 ptr 的前 num 个字节，size_t 就是unsigned int。</li></ul> 
<blockquote> 
 <p>【函数说明】memset() 会将 ptr 所指的内存区域的前 num 个字节的值都设置为 value，然后返回指向 ptr 的指针。</p> 
</blockquote> 
<p>无法下面这样初始化，这样的结果是a被赋值成168430090，168430090.。。。。。。。。。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这是因为int由4个字节(说)表示，并且不能得到数组a中整数的期望值。<br> <strong>但我经常看到程序员使用memset将int数组元素设置为0或-1。其他值不行！</strong></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token function">memset</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//假设a为int型数组：</span>
<span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0x7f</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//a数组每个空间将被初始化为0x7f7f7f7f,原因是C函数传参过程中的指针降级，导致sizeof(a)，返回的是一个 something*指针类型大小的的字节数，如果是32位，就是4字节。所以memset按字节赋值。</span>
<span class="token function">memset</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0xaf</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//a数组每个空间将被初始化为0xafafafaf</span>
</code></pre> 
<h4><a id="Cvolatile_511"></a>C++中volatile的作用</h4> 
<blockquote> 
 <p>总结：建议编译器不要对该变量进行优化</p> 
</blockquote> 
<p>volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题。</p> 
<p>定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。</p> 
<p>在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。</p> 
<p>而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序（如中断程序、另外的线程等）所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。如下程序对这一现象进行了模拟。</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a<span class="token operator">=</span>i<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    _asm
    <span class="token punctuation">{<!-- --></span>
        mov dword ptr <span class="token punctuation">[</span>ebp<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">80</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> b<span class="token operator">=</span>i<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
程序在VS2012环境下生成Release版本，输出结果是：
10
10
*/</span>
</code></pre> 
<p>阅读以上程序，注意以下几个要点：</p> 
<ul><li>以上代码必须在Release模式下考查，因为只有Release模式下才会对程序代码进行优化，而这种优化在变量共享的环境下容易引发问题。</li><li>在语句b=i；之前，已经通 过内联汇编代码修改了i的值，但是i的变化却没有反映到b中，如果i是一个被多个任务共享的变量，这种优化带来的错误很可能是致命的。</li><li>汇编代码[ebp-4]表示变量i的存储单元，因为ebp是扩展基址指针寄存器，存放函数所属栈的栈底地址，先入栈，占用4个字节。随着函数内申明的局部变量的增多，esp（栈顶指针寄存器）就会相应的减小，因为栈的生长方向由高地址向低地址生长。i为第一个变量，栈空间已被ebp入栈占用了4个字节，所以i的地址为ebp-i，[ebp-i]则表示变量i的存储单元。</li></ul> 
<p>详细请参考：</p> 
<blockquote> 
 <p>https://blog.csdn.net/weixin_41656968/article/details/80958973<br> https://www.cnblogs.com/god-of-death/p/7852394.html<br> https://blog.csdn.net/garrulousabyss/article/details/83500576</p> 
</blockquote> 
<h4><a id="_inline__554"></a>编译器对 inline 函数的处理步骤</h4> 
<ol><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）</li></ol> 
<h6><a id="_560"></a>优缺点</h6> 
<ul><li>优点</li></ul> 
<ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol> 
<ul><li>缺点</li></ul> 
<ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol> 
<h6><a id="virtualinline_570"></a>虚函数（virtual）可以是内联函数（inline）吗？</h6> 
<ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生;</li></ul> 
<h4><a id="Const___const_575"></a>Const * 和 *const区别</h4> 
<p><img src="https://images2.imgbox.com/ba/97/30yjG9zY_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_577"></a>自我赋值可能带来的危害有哪些？</h4> 
<ol><li>“自我赋值安全性”问题：<br> 考虑一种情况：假如指针x和y同时指向了同一个位于堆内存的对象，此时执行自我赋值时，需要先把一边给删除掉，然后为其重新分配等号右边大小的存储空间。但是此时等号右边和左边指向同一对象已被回收，因此接下来的操作都是在操作已被回收的空间，这都是不安全的。（类把自己内部资源释放掉了，然后又去拷贝这个资源）</li><li>“异常安全性”问题：<br> 在分配新的存储空间时(内存空间不够用，或别的原因)导致的异常安全性问题，此时由于空间没分配成功，左边指向的仍是一个被回收的内存空间。</li></ol> 
<h4><a id="_582"></a>右值引用</h4> 
<p><img src="https://images2.imgbox.com/16/07/Iwyd5BBS_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="_584"></a>左值和右值区别：</h6> 
<ul><li>左值引用， 使用 T&amp;, 只能绑定左值</li><li>右值引用， 使用 T&amp;&amp;， 只能绑定右值</li><li>常量左值， 使用 const T&amp;, 既可以绑定左值又可以绑定右值</li><li><strong>已命名的右值引用，编译器会认为是个左值</strong></li><li>编译器有返回值优化，但不要过于依赖</li></ul> 
<p>需要注意一下几点：</p> 
<ol><li>str6 = std::move(str2)，虽然将str2的资源给了str6，但是str2并没有立刻析构，只有在str2离开了自己的作用域的时候才会析构，<strong>所以，如果继续使用str2的m_data变量，可能会发生意想不到的错误</strong>。</li><li>如果我们没有提供移动构造函数，<strong>只提供了拷贝构造函数，std::move()会失效但是不会发生错误</strong>，因为<strong>编译器找不到移动构造函数就去寻找拷贝构造函数，也这是拷贝构造函数的参数是const T&amp;常量左值引用的原因</strong>！</li><li>c++11中的所有容器都实现了move语义，move只是转移了资源的控制权，<strong>本质上是将左值强制转化为右值使用</strong>，以用于移动拷贝或赋值，避免对含有资源的对象发生无谓的拷贝。move对于拥有如内存、文件句柄等资源的成员的对象有效，如果是一些基本类型，如int和char[10]数组等**，如果使用move，仍会发生拷贝（因为没有对应的移动构造函数）**，所以说move对含有资源的对象说更有意义。</li></ol> 
<h6><a id="universal_references_597"></a>universal references(通用引用)</h6> 
<p>当右值引用和模板结合的时候，就复杂了。T&amp;&amp;并不一定表示右值引用，它可能是个左值引用又可能是个右值引用。例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span> T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//10是右值</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//x是左值</span>
</code></pre> 
<p>如果上面的函数模板表示的是右值引用的话，肯定是不能传递左值的，但是事实却是可以。**这里的&amp;&amp;是一个未定义的引用类型，称为universal references，它必须被初始化，它是左值引用还是右值引用却决于它的初始化，**如果它被一个左值初始化，它就是一个左值引用；如果被一个右值初始化，它就是一个右值引用。</p> 
<p>注意：<strong>只有当发生自动类型推断时（如函数模板的类型自动推导，或auto关键字），&amp;&amp;才是一个universal references。</strong></p> 
<h6><a id="_611"></a>完美转发</h6> 
<p>所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"process(int&amp;):"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"process(int&amp;&amp;):"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">myforward</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"myforward(int&amp;&amp;):"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">process</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">process</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//a被视为左值 process(int&amp;):0</span>
    <span class="token function">process</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//1被视为右值 process(int&amp;&amp;):1</span>
    <span class="token function">process</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//强制将a由左值改为右值 process(int&amp;&amp;):0</span>
    <span class="token function">myforward</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//右值经过forward函数转交给process函数，却称为了一个左值，</span>
    <span class="token comment">//原因是该右值有了名字  所以是 process(int&amp;):2</span>
    <span class="token function">myforward</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 同上，在转发的时候右值变成了左值  process(int&amp;):0</span>
    <span class="token comment">// forward(a) // 错误用法，右值引用不接受左值</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的例子就是不完美转发，而c++中提供了一个std::forward()模板函数解决这个问题。将上面的myforward()函数简单改写一下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">myforward</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"myforward(int&amp;&amp;):"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">process</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">myforward</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// process(int&amp;&amp;):2</span>
</code></pre> 
<p>上面修改过后还是不完美转发，myforward()函数能够将右值转发过去，但是并不能够转发左值，解决办法就是借助universal references通用引用类型和std::forward()模板函数共同实现完美转发。例子如下：</p> 
<pre><code class="prism language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">RunCode</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"rvalue ref"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">RunCode</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lvalue ref"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">RunCode</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const rvalue ref"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">RunCode</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const lvalue ref"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这里利用了universal references，如果写T&amp;,就不支持传入右值，而写T&amp;&amp;，既能支持左值，又能支持右值</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">perfectForward</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">RunCode</span><span class="token punctuation">(</span>forward<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">notPerfectForward</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">RunCode</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">notPerfectForward</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lvalue ref</span>
    <span class="token function">notPerfectForward</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lvalue ref</span>
    <span class="token function">notPerfectForward</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const lvalue ref</span>
    <span class="token function">notPerfectForward</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const lvalue ref</span>

    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">perfectForward</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lvalue ref</span>
    <span class="token function">perfectForward</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rvalue ref</span>
    <span class="token function">perfectForward</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const lvalue ref</span>
    <span class="token function">perfectForward</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// const rvalue ref</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面的代码测试结果表明，在universal references和std::forward的合作下，能够完美的转发这4种类型。</p> 
<p>详细请查阅：<a href="https://blog.csdn.net/tonglin12138/article/details/91479048">C++：浅谈右值引用</a> / <a href="https://www.cnblogs.com/likaiming/p/9045642.html" rel="nofollow">左值和右值区别</a> / <a href="https://www.jianshu.com/p/d19fc8447eaa" rel="nofollow">我理解的右值引用、移动语义和完美转发</a></p> 
<h6><a id="_699"></a>总结</h6> 
<ul><li>由两种值类型，左值和右值。</li><li>有三种引用类型，左值引用、右值引用和通用引用。左值引用只能绑定左值，右值引用只能绑定右值，通用引用由初始化时绑定的值的类型确定。</li><li>左值和右值是独立于他们的类型的，右值引用可能是左值可能是右值，如果这个右值引用已经被命名了，他就是左值。</li><li>引用折叠规则：所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用。当T&amp;&amp;为模板参数时，输入左值，它将变成左值引用，输入右值则变成具名的右值应用。</li><li>移动语义可以减少无谓的内存拷贝，要想实现移动语义，需要实现移动构造函数和移动赋值函数。</li><li>std::move()将一个左值转换成一个右值，强制使用移动拷贝和赋值函数，这个函数本身并没有对这个左值什么特殊操作。</li><li>std::forward()和universal references通用引用共同实现完美转发。</li><li>用empalce_back()替换push_back()增加性能。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c6af530e3910ac4f390a6840c3aaa993/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Wayland (简体中文)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b079d7bf44f876ea7f086be349342819/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">centos7/8 重置root密码 小白教学！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>