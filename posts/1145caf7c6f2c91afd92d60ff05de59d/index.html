<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入了解以太坊虚拟机 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入了解以太坊虚拟机" />
<meta property="og:description" content="本文由币乎社区（bihu.com）内容支持计划赞助。
译者说，深入了解以太坊虚拟机是一个系列的文章，一共5篇！ 本文是第1篇，主要介绍的是以太坊虚拟机汇编代码基础。后续的4篇译文链接在本文的结尾处。
Solidity提供了很多高级语言的抽象概念，但是这些特性让人很难明白在运行程序的时候到底发生了什么。我阅读了Solidity的文档，但依旧存在着几个基本的问题没有弄明白。
string, bytes32, byte[], bytes之间的区别是什么？
该在什么地方使用哪个类型？ 将 string 转换成bytes时会怎么样？可以转换成byte[]吗？ 它们的存储成本是多少？ EVM是如何存储映射( mappings)的？
为什么不能删除一个映射？ 可以有映射的映射吗？(可以，但是怎样映射？) 为什么存在存储映射，但是却没有内存映射？ 编译的合约在EVM看来是什么样子的？
合约是如何创建的？ 到底什么是构造器？ 什么是 fallback 函数？ 我觉得学习在以太坊虚拟机(EVM)上运行的类似Solidity 高级语言是一种很好的投资，有几个原因：
Solidity不是最后一种语言。更好的EVM语言正在到来。（拜托？） EVM是一个数据库引擎。要理解智能合约是如何以任意EVM语言来工作的，就必须要明白数据是如何被组织的，被存储的，以及如何被操作的。 知道如何成为贡献者。以太坊的工具链还处于早期，理解EVM可以帮助你实现一个超棒的工具给自己和其他人使用。 智力的挑战。EVM可以让你有个很好的理由在密码学、数据结构、编程语言设计的交集之间进行翱翔。 在这个系列的文章中，我会拆开一个简单的Solidity合约，来让大家明白它是如何以EVM字节码(bytecode)来运行的。
我希望能够学习以及会书写的文章大纲：
EVM字节码的基础认识 不同类型(映射，数组)是如何表示的 当一个新合约创建之后会发生什么 当一个方法被调用时会发生什么 ABI如何桥接不同的EVM语言 我的最终目标是整体的理解一个编译的Solidity合约。让我们从阅读一些基本的EVM字节码开始。
EVM指令集将是一个比较有帮助的参考。
一个简单的合约 我们的第一个合约有一个构造器和一个状态变量：
// c1.sol pragma solidity ^0.4.11; contract C { uint256 a; function C() { a = 1; } } 用solc来编译此合约：
$ solc --bin --asm c1.sol ======= c1.sol:C ======= EVM assembly: /* &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1145caf7c6f2c91afd92d60ff05de59d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-02-06T06:46:23+08:00" />
<meta property="article:modified_time" content="2018-02-06T06:46:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入了解以太坊虚拟机</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <pre></pre> 
<div> 
 <p>本文由币乎社区（bihu.com）内容支持计划赞助。</p> 
 <blockquote> 
  <p>译者说，深入了解以太坊虚拟机是一个系列的文章，一共5篇！ 本文是第1篇，主要介绍的是以太坊虚拟机汇编代码基础。后续的4篇译文链接在本文的结尾处。</p> 
 </blockquote> 
 <p>Solidity提供了很多高级语言的抽象概念，但是这些特性让人很难明白在运行程序的时候到底发生了什么。我阅读了Solidity的文档，但依旧存在着几个基本的问题没有弄明白。</p> 
 <p><em>string, bytes32, byte[], bytes之间的区别是什么？</em></p> 
 <ul><li>该在什么地方使用哪个类型？ </li><li>将 string 转换成bytes时会怎么样？可以转换成byte[]吗？ </li><li>它们的存储成本是多少？ </li></ul> 
 <p><em>EVM是如何存储映射( mappings)的？</em></p> 
 <ul><li>为什么不能删除一个映射？ </li><li>可以有映射的映射吗？(可以，但是怎样映射？) </li><li>为什么存在存储映射，但是却没有内存映射？ </li></ul> 
 <p><em>编译的合约在EVM看来是什么样子的？</em></p> 
 <ul><li>合约是如何创建的？ </li><li>到底什么是构造器？ </li><li>什么是 fallback 函数？ </li></ul> 
 <p>我觉得学习在以太坊虚拟机(EVM)上运行的类似Solidity 高级语言是一种很好的投资，有几个原因：</p> 
 <ol><li> <em>Solidity不是最后一种语言</em>。更好的EVM语言正在到来。（拜托？） </li><li> <em>EVM是一个数据库引擎</em>。要理解智能合约是如何以任意EVM语言来工作的，就必须要明白数据是如何被组织的，被存储的，以及如何被操作的。 </li><li> <em>知道如何成为贡献者。</em>以太坊的工具链还处于早期，理解EVM可以帮助你实现一个超棒的工具给自己和其他人使用。 </li><li> <em>智力的挑战。</em>EVM可以让你有个很好的理由在密码学、数据结构、编程语言设计的交集之间进行翱翔。 </li></ol> 
 <p>在这个系列的文章中，我会拆开一个简单的Solidity合约，来让大家明白它是如何以EVM字节码(bytecode)来运行的。</p> 
 <p>我希望能够学习以及会书写的文章大纲：</p> 
 <ul><li>EVM字节码的基础认识 </li><li>不同类型(映射，数组)是如何表示的 </li><li>当一个新合约创建之后会发生什么 </li><li>当一个方法被调用时会发生什么 </li><li>ABI如何桥接不同的EVM语言 </li></ul> 
 <p>我的最终目标是整体的理解一个编译的Solidity合约。让我们从阅读一些基本的EVM字节码开始。</p> 
 <p><a href="https://link.jianshu.com?t=https://gist.github.com/hayeah/bd37a123c02fecffbe629bf98a8391df" rel="nofollow">EVM指令集</a>将是一个比较有帮助的参考。</p> 
 <h3>一个简单的合约</h3> 
 <p>我们的第一个合约有一个构造器和一个状态变量：</p> 
 <pre><code class="language-javascript"><code class="javascript"><span class="hljs-comment">// c1.sol</span>
pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;
contract C {
    uint256 a;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>) </span>{
      a = <span class="hljs-number">1</span>;
    }
}
</code></code></pre> 
 <p>用<code>solc</code>来编译此合约：</p> 
 <pre><code class="language-cpp"><code class="cpp">$ solc --bin --<span class="hljs-keyword">asm</span> c1.sol
======= c1.sol:C =======
EVM assembly:
    <span class="hljs-comment">/* "c1.sol":26:94  contract C {... */</span>
  mstore(<span class="hljs-number">0x40</span>, <span class="hljs-number">0x60</span>)
    <span class="hljs-comment">/* "c1.sol":59:92  function C() {... */</span>
  jumpi(tag_1, iszero(callvalue))
  <span class="hljs-number">0x0</span>
  dup1
  revert
tag_1:
tag_2:
    <span class="hljs-comment">/* "c1.sol":84:85  1 */</span>
  <span class="hljs-number">0x1</span>
    <span class="hljs-comment">/* "c1.sol":80:81  a */</span>
  <span class="hljs-number">0x0</span>
    <span class="hljs-comment">/* "c1.sol":80:85  a = 1 */</span>
  dup2
  swap1
  sstore
  pop
    <span class="hljs-comment">/* "c1.sol":59:92  function C() {... */</span>
tag_3:
    <span class="hljs-comment">/* "c1.sol":26:94  contract C {... */</span>
tag_4:
  dataSize(sub_0)
  dup1
  dataOffset(sub_0)
  <span class="hljs-number">0x0</span>
  codecopy
  <span class="hljs-number">0x0</span>
  <span class="hljs-keyword">return</span>
stop
sub_0: assembly {
        <span class="hljs-comment">/* "c1.sol":26:94  contract C {... */</span>
      mstore(<span class="hljs-number">0x40</span>, <span class="hljs-number">0x60</span>)
    tag_1:
      <span class="hljs-number">0x0</span>
      dup1
      revert
auxdata: <span class="hljs-number">0xa165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029</span>
}
Binary:
<span class="hljs-number">60606040523415600e57600080</span>fd5b5b60016000819055505b5b60368060266000396000f30060606040525b600080fd00a165627a7a72305820af3193f6fd31031a0e0d2de1ad2c27352b1ce081b4f3c92b5650ca4dd542bb770029
</code></code></pre> 
 <p><code>6060604052...</code>这串数字就是EVM实际运行的字节码。</p> 
 <h3>一小步一小步的来</h3> 
 <p>上面一半的编译汇编是大多数Solidity程序中都会存在的样板语句。我们稍后再来看这些。现在，我们来看看合约中独特的部分，简单的存储变量赋值：</p> 
 <pre class="hljs undefined"><code>a = 1
</code></pre> 
 <p>代表这个赋值的字节码是<code>6001600081905550</code>。我们把它拆成一行一条指令：</p> 
 <pre class="hljs undefined"><code>60 01
60 00
81
90
55
50
</code></pre> 
 <p>EVM本质上就是一个循环，从上到下的执行每一条命令。让我们用相应的字节码来注释汇编代码(缩进到标签<code>tag_2</code>下)，来更好的看看他们之间的关联：</p> 
 <pre><code class="language-cpp"><code class="cpp">tag_2:
  <span class="hljs-comment">// 60 01</span>
  <span class="hljs-number">0x1</span>
  <span class="hljs-comment">// 60 00</span>
  <span class="hljs-number">0x0</span>
  <span class="hljs-comment">// 81</span>
  dup2
  <span class="hljs-comment">// 90</span>
  swap1
  <span class="hljs-comment">// 55</span>
  sstore
  <span class="hljs-comment">// 50</span>
  pop
</code></code></pre> 
 <p>注意<code>0x1</code>在汇编代码中实际上是<code>push(0x1)</code>的速记。这条指令将数值1压入栈中。</p> 
 <p>只是盯着它依然很难明白到底发生了什么，不过不用担心，一行一行的模拟EVM是比较简单的。</p> 
 <h3>模拟EVM</h3> 
 <p>EVM是个堆栈机器。指令可能会使用栈上的数值作为参数，也会将值作为结果压入栈中。让我们来思考一下<code>add</code>操作。</p> 
 <p>假设栈上有两个值：</p> 
 <pre class="hljs json"><code class="json">[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]
</code></pre> 
 <p>当EVM看见了<code>add</code>，它会将栈顶的2项相加，然后将答案压入栈中，结果是：</p> 
 <pre class="hljs json"><code class="json">[<span class="hljs-number">3</span>]
</code></pre> 
 <p>接下来，我们用<code>[]</code>符号来标识栈：</p> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">// 空栈</span>
<span class="hljs-built_in">stack</span>: []
<span class="hljs-comment">// 有3个数据的栈，栈顶项为3，栈底项为1</span>
<span class="hljs-built_in">stack</span>: [<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]
</code></code></pre> 
 <p>用<code>{}</code>符号来标识合约存储器：</p> 
 <pre><code class="language-php"><code class="php"><span class="hljs-comment">// 空存储</span>
store: {}
<span class="hljs-comment">// 数值0x1被保存在0x0的位置上</span>
store: { <span class="hljs-number">0x0</span> =&gt; <span class="hljs-number">0x1</span> }
</code></code></pre> 
 <p>现在让我们来看看真正的字节码。我们将会像EVM那样来模拟<code>6001600081905550</code>字节序列，并打印出每条指令的机器状态：</p> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">// 60 01:将1压入栈中</span>
<span class="hljs-number">0x1</span>
  <span class="hljs-built_in">stack</span>: [<span class="hljs-number">0x1</span>]
<span class="hljs-comment">// 60 00: 将0压入栈中</span>
<span class="hljs-number">0x0</span>
  <span class="hljs-built_in">stack</span>: [<span class="hljs-number">0x0</span> <span class="hljs-number">0x1</span>]
<span class="hljs-comment">// 81: 复制栈中的第二项</span>
dup2
  <span class="hljs-built_in">stack</span>: [<span class="hljs-number">0x1</span> <span class="hljs-number">0x0</span> <span class="hljs-number">0x1</span>]
<span class="hljs-comment">// 90: 交换栈顶的两项数据</span>
swap1
  <span class="hljs-built_in">stack</span>: [<span class="hljs-number">0x0</span> <span class="hljs-number">0x1</span> <span class="hljs-number">0x1</span>]
<span class="hljs-comment">// 55: 将数值0x01存储在0x0的位置上</span>
<span class="hljs-comment">// 这个操作会消耗栈顶两项数据</span>
sstore
  <span class="hljs-built_in">stack</span>: [<span class="hljs-number">0x1</span>]
  store: { <span class="hljs-number">0x0</span> =&gt; <span class="hljs-number">0x1</span> }
<span class="hljs-comment">// 50: pop (丢弃栈顶数据)</span>
pop
  <span class="hljs-built_in">stack</span>: []
  store: { <span class="hljs-number">0x0</span> =&gt; <span class="hljs-number">0x1</span> }
</code></code></pre> 
 <p>最后，栈就为空栈，而存储器里面有一项数据。</p> 
 <p>值得注意的是Solidity已经决定将状态变量<code>uint256 a</code>保存在<code>0x0</code>的位置上。其他语言完全可以选择将状态变量存储在其他的任何位置上。</p> 
 <p><code>6001600081905550</code>字节序列在本质上用EVM的操作伪代码来表示就是：</p> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">// a = 1</span>
sstore(<span class="hljs-number">0x0</span>, <span class="hljs-number">0x1</span>)
</code></code></pre> 
 <p>仔细观察，你就会发现<code>dup2</code>，<code>swap1</code>，<code>pop</code>都是多余的，汇编代码可以更简单一些：</p> 
 <pre class="hljs undefined"><code>0x1
0x0
sstore
</code></pre> 
 <p>你可以模拟上面的3条指令，然后会发现他们的机器状态结果都是一样的：</p> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-built_in">stack</span>: []
store: { <span class="hljs-number">0x0</span> =&gt; <span class="hljs-number">0x1</span> }
</code></code></pre> 
 <h3>两个存储变量</h3> 
 <p>让我们再额外的增加一个相同类型的存储变量：</p> 
 <pre><code class="language-javascript"><code class="javascript"><span class="hljs-comment">// c2.sol</span>
pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;
contract C {
    uint256 a;
    uint256 b;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>) </span>{
      a = <span class="hljs-number">1</span>;
      b = <span class="hljs-number">2</span>;
    }
}
</code></code></pre> 
 <p>编译之后，主要来看<code>tag_2</code>：</p> 
 <pre><code class="language-cpp"><code class="cpp">$ solc --bin --<span class="hljs-keyword">asm</span> c2.sol
<span class="hljs-comment">//前面的代码忽略了</span>
tag_2:
    <span class="hljs-comment">/* "c2.sol":99:100  1 */</span>
  <span class="hljs-number">0x1</span>
    <span class="hljs-comment">/* "c2.sol":95:96  a */</span>
  <span class="hljs-number">0x0</span>
    <span class="hljs-comment">/* "c2.sol":95:100  a = 1 */</span>
  dup2
  swap1
  sstore
  pop
    <span class="hljs-comment">/* "c2.sol":112:113  2 */</span>
  <span class="hljs-number">0x2</span>
    <span class="hljs-comment">/* "c2.sol":108:109  b */</span>
  <span class="hljs-number">0x1</span>
    <span class="hljs-comment">/* "c2.sol":108:113  b = 2 */</span>
  dup2
  swap1
  sstore
  pop
</code></code></pre> 
 <p>汇编的伪代码：</p> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">// a = 1</span>
sstore(<span class="hljs-number">0x0</span>, <span class="hljs-number">0x1</span>)
<span class="hljs-comment">// b = 2</span>
sstore(<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>)
</code></code></pre> 
 <p>我们可以看到两个存储变量的存储位置是依次排列的，<code>a</code>在<code>0x0</code>的位置而<code>b</code>在<code>0x1</code>的位置。</p> 
 <h3>存储打包</h3> 
 <p>每个存储槽都可以存储32个字节。如果一个变量只需要16个字节但是使用全部的32个字节会很浪费。Solidity为了高效存储，提供了一个优化方案：如果可以的话，就将两个小一点的数据类型进行打包然后存储在一个存储槽中。</p> 
 <p>我们将<code>a</code>和<code>b</code>修改成16字节的变量：</p> 
 <pre><code class="language-javascript"><code class="javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;
contract C {
    uint128 a;
    uint128 b;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>) </span>{
      a = <span class="hljs-number">1</span>;
      b = <span class="hljs-number">2</span>;
    }
}
</code></code></pre> 
 <p>编译此合约：</p> 
 <pre><code class="language-cpp"><code class="cpp">$ solc --bin --<span class="hljs-keyword">asm</span> c3.sol
</code></code></pre> 
 <p>产生的汇编代码现在更加的复杂一些：</p> 
 <pre><code class="language-cpp"><code class="cpp">tag_2:
  <span class="hljs-comment">// a = 1</span>
  <span class="hljs-number">0x1</span>
  <span class="hljs-number">0x0</span>
  dup1
  <span class="hljs-number">0x100</span>
  <span class="hljs-built_in">exp</span>
  dup2
  sload
  dup2
  <span class="hljs-number">0xffffffffffffffffffffffffffffffff</span>
  mul
  <span class="hljs-keyword">not</span>
  <span class="hljs-keyword">and</span>
  swap1
  dup4
  <span class="hljs-number">0xffffffffffffffffffffffffffffffff</span>
  <span class="hljs-keyword">and</span>
  mul
  <span class="hljs-keyword">or</span>
  swap1
  sstore
  pop
  <span class="hljs-comment">// b = 2</span>
  <span class="hljs-number">0x2</span>
  <span class="hljs-number">0x0</span>
  <span class="hljs-number">0x10</span>
  <span class="hljs-number">0x100</span>
  <span class="hljs-built_in">exp</span>
  dup2
  sload
  dup2
  <span class="hljs-number">0xffffffffffffffffffffffffffffffff</span>
  mul
  <span class="hljs-keyword">not</span>
  <span class="hljs-keyword">and</span>
  swap1
  dup4
  <span class="hljs-number">0xffffffffffffffffffffffffffffffff</span>
  <span class="hljs-keyword">and</span>
  mul
  <span class="hljs-keyword">or</span>
  swap1
  sstore
  pop
</code></code></pre> 
 <p>上面的汇编代码将这两个变量打包放在一个存储位置(<code>0x0</code>)上，就像这样：</p> 
 <pre class="hljs json"><code class="json">[         b         ][         a         ]
[<span class="hljs-number">16</span> bytes / <span class="hljs-number">128</span> bits][<span class="hljs-number">16</span> bytes / <span class="hljs-number">128</span> bits]
</code></pre> 
 <p>进行打包的原因是因为目前最昂贵的操作就是存储的使用：</p> 
 <ul><li><code>sstore</code>指令第一次写入一个新位置需要花费20000 gas</li><li><code>sstore</code>指令后续写入一个已存在的位置需要花费5000 gas</li><li><code>sload</code>指令的成本是500 gas</li><li>大多数的指令成本是3~10 gas</li></ul> 
 <p>通过使用相同的存储位置，Solidity为存储第二个变量支付5000 gas，而不是20000 gas，节约了15000 gas。</p> 
 <h3>更多优化</h3> 
 <p>应该可以将两个128位的数打包成一个数放入内存中，然后使用一个'sstore'指令进行存储操作，而不是使用两个单独的<code>sstore</code>命令来存储变量<code>a</code>和<code>b</code>，这样就额外的又省了5000 gas。</p> 
 <p>你可以通过添加<code>optimize</code>选项来让Solidity实现上面的优化：</p> 
 <pre><code class="language-cpp"><code class="cpp">$ solc --bin --<span class="hljs-keyword">asm</span> --optimize c3.sol
</code></code></pre> 
 <p>这样产生的汇编代码只有一个<code>sload</code>指令和一个<code>sstore</code>指令:</p> 
 <pre><code class="language-php"><code class="php">tag_2:
    <span class="hljs-comment">/* "c3.sol":95:96  a */</span>
  <span class="hljs-number">0x0</span>
    <span class="hljs-comment">/* "c3.sol":95:100  a = 1 */</span>
  dup1
  sload
    <span class="hljs-comment">/* "c3.sol":108:113  b = 2 */</span>
  <span class="hljs-number">0x200000000000000000000000000000000</span>
  not(sub(exp(<span class="hljs-number">0x2</span>, <span class="hljs-number">0x80</span>), <span class="hljs-number">0x1</span>))
    <span class="hljs-comment">/* "c3.sol":95:100  a = 1 */</span>
  swap1
  swap2
  <span class="hljs-keyword">and</span>
    <span class="hljs-comment">/* "c3.sol":99:100  1 */</span>
  <span class="hljs-number">0x1</span>
    <span class="hljs-comment">/* "c3.sol":95:100  a = 1 */</span>
  <span class="hljs-keyword">or</span>
  sub(exp(<span class="hljs-number">0x2</span>, <span class="hljs-number">0x80</span>), <span class="hljs-number">0x1</span>)
    <span class="hljs-comment">/* "c3.sol":108:113  b = 2 */</span>
  <span class="hljs-keyword">and</span>
  <span class="hljs-keyword">or</span>
  swap1
  sstore
</code></code></pre> 
 <p>字节码是：</p> 
 <pre class="hljs undefined"><code>600080547002000000000000000000000000000000006001608060020a03199091166001176001608060020a0316179055
</code></pre> 
 <p>将字节码解析成一行一指令：</p> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">// push 0x0</span>
<span class="hljs-number">60</span> <span class="hljs-number">00</span>
<span class="hljs-comment">// dup1</span>
<span class="hljs-number">80</span>
<span class="hljs-comment">// sload</span>
<span class="hljs-number">54</span>
<span class="hljs-comment">// push17 将下面17个字节作为一个32个字的数值压入栈中</span>
<span class="hljs-number">70</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>
<span class="hljs-comment">/* not(sub(exp(0x2, 0x80), 0x1)) */</span>
<span class="hljs-comment">// push 0x1</span>
<span class="hljs-number">60</span> <span class="hljs-number">01</span>
<span class="hljs-comment">// push 0x80 (32)</span>
<span class="hljs-number">60</span> <span class="hljs-number">80</span>
<span class="hljs-comment">// push 0x80 (2)</span>
<span class="hljs-number">60</span> <span class="hljs-number">02</span>
<span class="hljs-comment">// exp</span>
<span class="hljs-number">0</span>a
<span class="hljs-comment">// sub</span>
<span class="hljs-number">03</span>
<span class="hljs-comment">// not</span>
<span class="hljs-number">19</span>
<span class="hljs-comment">// swap1</span>
<span class="hljs-number">90</span>
<span class="hljs-comment">// swap2</span>
<span class="hljs-number">91</span>
<span class="hljs-comment">// and</span>
<span class="hljs-number">16</span>
<span class="hljs-comment">// push 0x1</span>
<span class="hljs-number">60</span> <span class="hljs-number">01</span>
<span class="hljs-comment">// or</span>
<span class="hljs-number">17</span>
<span class="hljs-comment">/* sub(exp(0x2, 0x80), 0x1) */</span>
<span class="hljs-comment">// push 0x1</span>
<span class="hljs-number">60</span> <span class="hljs-number">01</span>
<span class="hljs-comment">// push 0x80</span>
<span class="hljs-number">60</span> <span class="hljs-number">80</span>
<span class="hljs-comment">// push 0x02</span>
<span class="hljs-number">60</span> <span class="hljs-number">02</span>
<span class="hljs-comment">// exp</span>
<span class="hljs-number">0</span>a
<span class="hljs-comment">// sub</span>
<span class="hljs-number">03</span>
<span class="hljs-comment">// and</span>
<span class="hljs-number">16</span>
<span class="hljs-comment">// or</span>
<span class="hljs-number">17</span>
<span class="hljs-comment">// swap1</span>
<span class="hljs-number">90</span>
<span class="hljs-comment">// sstore</span>
<span class="hljs-number">55</span>
</code></code></pre> 
 <p>上面的汇编代码中使用了4个神奇的数值：</p> 
 <ul><li>0x1(16字节)，使用低16字节</li></ul> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">// 在字节码中表示为0x01</span>
<span class="hljs-number">16</span>:<span class="hljs-number">32</span> <span class="hljs-number">0x00000000000000000000000000000000</span>
<span class="hljs-number">00</span>:<span class="hljs-number">16</span> <span class="hljs-number">0x00000000000000000000000000000001</span>
</code></code></pre> 
 <ul><li>0x2(16字节)，使用高16字节</li></ul> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">//在字节码中表示为0x200000000000000000000000000000000 </span>
<span class="hljs-number">16</span>:<span class="hljs-number">32</span> <span class="hljs-number">0x00000000000000000000000000000002</span>
<span class="hljs-number">00</span>:<span class="hljs-number">16</span> <span class="hljs-number">0x00000000000000000000000000000000</span>
</code></code></pre> 
 <ul><li>not(sub(exp(0x2, 0x80), 0x1))</li></ul> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">// 高16字节的掩码</span>
<span class="hljs-number">16</span>:<span class="hljs-number">32</span> <span class="hljs-number">0x00000000000000000000000000000000</span> 
<span class="hljs-number">00</span>:<span class="hljs-number">16</span> <span class="hljs-number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span>
</code></code></pre> 
 <ul><li>sub(exp(0x2, 0x80), 0x1)</li></ul> 
 <pre><code class="language-cpp"><code class="cpp"><span class="hljs-comment">// 低16字节的掩码</span>
<span class="hljs-number">16</span>:<span class="hljs-number">32</span> <span class="hljs-number">0x00000000000000000000000000000000</span> 
<span class="hljs-number">00</span>:<span class="hljs-number">16</span> <span class="hljs-number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</span>
</code></code></pre> 
 <p>代码将这些数值进行了一些位的转换来达到想要的结果：</p> 
 <pre><code class="language-css"><code class="css">16<span class="hljs-selector-pseudo">:32</span> 0<span class="hljs-selector-tag">x00000000000000000000000000000002</span> 
00<span class="hljs-selector-pseudo">:16</span> 0<span class="hljs-selector-tag">x00000000000000000000000000000001</span>
</code></code></pre> 
 <p>最后，该32字节的数值被保存在了<code>0x0</code>的位置上。</p> 
 <h3>Gas 的使用</h3> 
 <blockquote> 
  <p>60008054700<strong>200000000000000000000000000000000</strong>6001608060020a03199091166001176001608060020a0316179055</p> 
 </blockquote> 
 <p>注意<code>0x200000000000000000000000000000000</code>被嵌入到了字节码中。但是编译器也可能选择使用<code>exp(0x2, 0x81)</code>指令来计算数值，这会导致更短的字节码序列。</p> 
 <p>但结果是<code>0x200000000000000000000000000000000</code>比<code>exp(0x2, 0x81)</code>更便宜。让我们看看与gas费用相关的信息：</p> 
 <ul><li>一笔交易的每个零字节的数据或代码费用为 4 gas</li><li>一笔交易的每个非零字节的数据或代码的费用为 68 gas</li></ul> 
 <p>来计算下两个表示方式所花费的gas成本：</p> 
 <ul><li><p><code>0x200000000000000000000000000000000</code>字节码包含了很多的0，更加的便宜。<br>(1 * 68) + (32 * 4) = 196</p></li><li><p><code>608160020a</code>字节码更短，但是没有0。<br>5 * 68 = 340</p></li></ul> 
 <p>更长的字节码序列有很多的0，所以实际上更加的便宜！</p> 
 <h3>总结</h3> 
 <p>EVM的编译器实际上不会为字节码的大小、速度或内存高效性进行优化。相反，它会为gas的使用进行优化，这间接鼓励了计算的排序，让以太坊区块链可以更高效一点。</p> 
 <p>我们也看到了EVM一些奇特的地方：</p> 
 <ul><li>EVM是一个256位的机器。以32字节来处理数据是最自然的</li><li>持久存储是相当昂贵的</li><li>Solidity编译器会为了减少gas的使用而做出相应的优化选择</li></ul> 
 <p>Gas成本的设置有一点武断，也许未来会改变。当成本改变的时候，编译器也会做出不同的优化选择。</p> 
 <p>本系列文章其他部分译文链接：</p> 
 <ul><li><a href="https://www.jianshu.com/p/9df8d15418ed" rel="nofollow">固定长度数据类型的表示方法(第2部分)</a></li><li><a href="https://www.jianshu.com/p/af5721c79505" rel="nofollow">动态数据类型的表示方法(第3部分)</a></li><li><a href="https://www.jianshu.com/p/d0e8e825d41b" rel="nofollow">ABI编码外部方法调用的方式(第4部分)</a></li><li><a href="https://www.jianshu.com/p/d9137e87c9d3" rel="nofollow">一个新合约被创建后会发生什么(第5部分)</a></li></ul> 
 <p>翻译作者: <a href="https://link.jianshu.com?t=https://lilymoana.github.io/" rel="nofollow">许莉</a><br>原文地址：<a href="https://link.jianshu.com?t=https://medium.com/@hayeah/diving-into-the-ethereum-vm-6e8d5d2f3c30" rel="nofollow">Diving Into The Ethereum VM Part One</a></p> 
</div> 
<br> 
<br>作者：Lilymoana 
<br>链接：https://www.jianshu.com/p/1969f3761208 
<br>來源：简书 
<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb6215e9eac9a6342b7ab25960f4d40e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">列表页点击商品跳转到对应商品的详情页</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82d13168456359a19669d112e591b04a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue.js项目 el-input 组件 监听回车键实现搜索</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>