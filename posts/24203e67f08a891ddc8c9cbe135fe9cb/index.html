<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STL——vector与迭代器 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STL——vector与迭代器" />
<meta property="og:description" content="文章目录 前言：vector与数组迭代器---“通用指针&#34;迭代器的本质迭代器的分类迭代器失效 vector功能复写成员变量构造函数默认构造函数自定义的构造函数拷贝构造函数赋值运算符 size()capacity()operator[]begin()end()reserve()resize()push_back()pos_back()insert()erase()find(） 全部代码 前言： 博主收集的资料New Young，连载中。博主收录的问题:New Young转载请标明出处：New Young vector与数组 vector在底层是一种类似数组的C&#43;&#43;类模板，因此vector容器一但实例化其大小是不变的，但是容器中指向堆上的元素对象是动态变化的，支持“增删查改&#34;，同数组一样对于插入，insert的效率是很低的
迭代器—“通用指针&#34; 迭代器的本质 循环的控制方式有2种：标志控制(while),计数控制(for),而迭代器将这2种循环方式的统一为一种控制方式—迭代器控制—“通用指针&#34;为什么称迭代器为指针，因为其的行为和指针非常相似，另外不同容器的迭代器类型是不同的，因此这里的“通用&#34;是一种概念上的通用几乎所有的的泛型容器和泛型算法都使用迭代器来访问对象 迭代器的分类 迭代器功能Input_iterator–输入迭代器只提高读操作Output_iterator–输出迭代器只提高写操作Forward_iterator–单向迭代器只能向前访问下一元素，不能向后访问，支持&#43;&#43;Bidirectional_iterator–双向迭代器双向访问迭代器，支持&#43;&#43;与–Random_iterator–随机迭代器可以随机访问对象中的每一个元素，支持&#43;&#43;，-,&#43;,–等运算 从表中可以得出，功能更全的迭代器是支持向功能少的迭代器支持的接口进行传参的
迭代器失效 迭代器失效指的是：当容器底层发生变化，原来的迭代器可能由于元素存储位置的变动，成为野指针或者后续的迭代器不在指向准确的数据。
常见的引发操作：insert()时的扩容，erase（）的缩容，clear（），remove()等
解决方法：及时的更新迭代器并通过返回值得到正确的指向下一个元素的
vector功能复写 成员变量 typedef T* iterator; iterator _start; iterator _finish; iterator _end_of_storage; 构造函数 默认构造函数 vector() :_start(nullptr), _finish(nullptr), _end_of_storage(nullptr) {} 自定义的构造函数 vector支持通过迭代器区间来初始化对象
template&lt;class inputIterator&gt; vector(inputIterator first, inputIterator last) :_start(nullptr), _finish(nullptr), _end_of_storage(nullptr) { while (first != last) { push_back(*first); &#43;&#43;first; } } 拷贝构造函数 vector(const vector&lt;T&gt;&amp; v)//提前初始化成员，防止delete随机值 : _start(nullptr), _finish(nullptr), _end_of_storage(nullptr) { vector&lt;T&gt; tmp(v." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/24203e67f08a891ddc8c9cbe135fe9cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-29T23:28:32+08:00" />
<meta property="article:modified_time" content="2022-11-29T23:28:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STL——vector与迭代器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言：</a></li><li><a href="#vector_9" rel="nofollow">vector与数组</a></li><li><a href="#_16" rel="nofollow">迭代器---“通用指针"</a></li><li><ul><li><a href="#_18" rel="nofollow">迭代器的本质</a></li><li><a href="#_24" rel="nofollow">迭代器的分类</a></li><li><a href="#_41" rel="nofollow">迭代器失效</a></li></ul> 
  </li><li><a href="#vector_51" rel="nofollow">vector功能复写</a></li><li><ul><li><a href="#_53" rel="nofollow">成员变量</a></li><li><a href="#_64" rel="nofollow">构造函数</a></li><li><ul><li><a href="#_66" rel="nofollow">默认构造函数</a></li><li><a href="#_74" rel="nofollow">自定义的构造函数</a></li><li><a href="#_92" rel="nofollow">拷贝构造函数</a></li><li><a href="#_108" rel="nofollow">赋值运算符</a></li></ul> 
   </li><li><a href="#size_120" rel="nofollow">size()</a></li><li><a href="#capacity_129" rel="nofollow">capacity()</a></li><li><a href="#operator_138" rel="nofollow">operator[]</a></li><li><a href="#begin_153" rel="nofollow">begin()</a></li><li><a href="#end_170" rel="nofollow">end()</a></li><li><a href="#reserve_187" rel="nofollow">reserve()</a></li><li><a href="#resize_225" rel="nofollow">resize()</a></li><li><a href="#push_back_253" rel="nofollow">push_back()</a></li><li><a href="#pos_back_268" rel="nofollow">pos_back()</a></li><li><a href="#insert_279" rel="nofollow">insert()</a></li><li><a href="#erase_312" rel="nofollow">erase()</a></li><li><a href="#find_334" rel="nofollow">find(）</a></li></ul> 
  </li><li><a href="#_350" rel="nofollow">全部代码</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言：</h2> 
<blockquote> 
 <ul><li>博主收集的资料<a href="https://blog.csdn.net/qq_55439426/article/details/122731683?spm=1001.2014.3001.5501">New Young</a>，连载中。</li><li>博主收录的问题:<a href="https://blog.csdn.net/qq_55439426/article/details/122619476?spm=1001.2014.3001.5501">New Young</a></li><li>转载请标明出处：<a href="https://blog.csdn.net/qq_55439426?spm=1000.2115.3001.5343">New Young</a></li></ul> 
</blockquote> 
<h2><a id="vector_9"></a>vector与数组</h2> 
<p>vector在底层是一种类似数组的C++类模板，因此vector容器一但实例化其大小是不变的，但是容器中指向堆上的元素对象是动态变化的，支持“增删查改"，同数组一样对于插入，insert的效率是很低的</p> 
<p><img src="https://images2.imgbox.com/c7/9d/6xsxN6JT_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_16"></a>迭代器—“通用指针"</h2> 
<h3><a id="_18"></a>迭代器的本质</h3> 
<ol><li>循环的控制方式有2种：标志控制(while),计数控制(for),而迭代器将这2种循环方式的统一为一种控制方式—迭代器控制—“通用指针"</li><li>为什么称迭代器为指针，因为其的行为和指针非常相似，另外不同容器的迭代器类型是不同的，因此这里的“通用"是一种概念上的通用</li><li>几乎所有的的泛型容器和泛型算法都使用迭代器来访问对象</li></ol> 
<h3><a id="_24"></a>迭代器的分类</h3> 
<table><thead><tr><th align="left">迭代器</th><th>功能</th><th></th></tr></thead><tbody><tr><td align="left">Input_iterator–输入迭代器</td><td>只提高读操作</td><td></td></tr><tr><td align="left">Output_iterator–输出迭代器</td><td>只提高写操作</td><td></td></tr><tr><td align="left">Forward_iterator–单向迭代器</td><td>只能向前访问下一元素，不能向后访问，支持++</td><td></td></tr><tr><td align="left">Bidirectional_iterator–双向迭代器</td><td>双向访问迭代器，支持++与–</td><td></td></tr><tr><td align="left">Random_iterator–随机迭代器</td><td>可以随机访问对象中的每一个元素，支持++，-,+,–等运算</td><td></td></tr></tbody></table> 
<p>从表中可以得出，功能更全的迭代器是支持向功能少的迭代器支持的接口进行传参的</p> 
<p><img src="https://images2.imgbox.com/99/2f/UJ5oNIiK_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_41"></a>迭代器失效</h3> 
<ol><li> <p>迭代器失效指的是：当容器底层发生变化，原来的迭代器可能由于元素存储位置的变动，成为野指针或者后续的迭代器不在指向准确的数据。</p> </li><li> <p>常见的引发操作：insert()时的扩容，erase（）的缩容，clear（），remove()等</p> </li><li> <p>解决方法：及时的更新迭代器并通过返回值得到正确的指向下一个元素的</p> </li></ol> 
<h2><a id="vector_51"></a>vector功能复写</h2> 
<h3><a id="_53"></a>成员变量</h3> 
<pre><code class="prism language-c++">typedef T* iterator;
iterator _start;
iterator _finish;
iterator _end_of_storage;
</code></pre> 
<h3><a id="_64"></a>构造函数</h3> 
<h4><a id="_66"></a>默认构造函数</h4> 
<pre><code class="prism language-c++">vector()
		:_start(nullptr), _finish(nullptr), _end_of_storage(nullptr)
	{}
</code></pre> 
<h4><a id="_74"></a>自定义的构造函数</h4> 
<p>vector支持通过迭代器区间来初始化对象</p> 
<pre><code class="prism language-c++">	template&lt;class inputIterator&gt;
	vector(inputIterator first, inputIterator last)
		:_start(nullptr), _finish(nullptr), _end_of_storage(nullptr)

	{
		while (first != last)
		{
			push_back(*first);
			++first;
		}
	}
</code></pre> 
<h4><a id="_92"></a>拷贝构造函数</h4> 
<pre><code class="prism language-c++">vector(const vector&lt;T&gt;&amp; v)//提前初始化成员，防止delete随机值
		: _start(nullptr),
		_finish(nullptr),
		_end_of_storage(nullptr)
	{
	
		vector&lt;T&gt; tmp(v.begin(), v.end());
		std::swap(_start, tmp._start);
		std::swap(_finish, tmp._finish);
		std::swap(_end_of_storage, tmp._end_of_storage);
	}
</code></pre> 
<h4><a id="_108"></a>赋值运算符</h4> 
<pre><code class="prism language-c++">	//现代写法
	vector&lt;T&gt;&amp; operator=(vector&lt;T&gt;v)
	{
		std::swap(_start, v._start);
		std::swap(_finish, v._finish);
		std::swap(_end_of_storage, v._end_of_storage);
	}
</code></pre> 
<h3><a id="size_120"></a>size()</h3> 
<pre><code class="prism language-c++">size_t size()const
	{
		return _finish - _start;
	}
</code></pre> 
<h3><a id="capacity_129"></a>capacity()</h3> 
<pre><code class="prism language-c++">size_t capacity()const
	{
			return _end_of_storage - _start;
	}
</code></pre> 
<h3><a id="operator_138"></a>operator[]</h3> 
<pre><code class="prism language-c++">T&amp; operator[](size_t pos)
	{
		assert(pos &lt; size());
		return _start[pos];
	}
	const T&amp; operator[](size_t pos)const 
	{
		assert(pos &lt; size());
		return _start[pos];
	}
</code></pre> 
<h3><a id="begin_153"></a>begin()</h3> 
<pre><code class="prism language-c++">typedef T* iterator;
	iterator begin()
	{

		return _start;
	}
typedef T* const_iterator;
	const_iterator begin()const
	{
		return _start;

	}
</code></pre> 
<h3><a id="end_170"></a>end()</h3> 
<pre><code class="prism language-c++">typedef T* iterator;
iterator end()
	{
		return _finish;

	}
typedef T* const_iterator;
const_iterator end()const
	{
		return _finish;

	}
</code></pre> 
<h3><a id="reserve_187"></a>reserve()</h3> 
<pre><code class="prism language-c++">void reserve(size_t n)
	{
		if (n &gt; capacity())
		{
			T* tmp = new T[n];
			int sz = size();
			if (_start != nullptr)
			{
				//使用memcpy会导致浅拷贝野指针问题
				//memcpy(tmp, _start, sizeof(T)*sz);
				
				//使用深拷贝赋值
				// 或者定位new
				for (size_t i = 0; i &lt; sz; ++i)
				{
					//调用深拷贝的赋值函数
					tmp[i] = _start[i];
				
				}
				delete[]_start;
			}
				

			_start = tmp;
			//注意这里要用旧的size，因为_start改变时，
			//finish未变，直接使用size()，可能会出现负的情况
			_finish = _start + sz;
			_end_of_storage = _start + n;
		}
	}
	
</code></pre> 
<h3><a id="resize_225"></a>resize()</h3> 
<p>编译器对很多类型包括内置类型都将它们进行了提升，类似一种类，因此int()=0；</p> 
<pre><code class="prism language-c++">	void resize(size_t n, const T&amp; value = T())
	{
		if (n &lt; size())
		{
			_finish = _start + n;
		}
		else
		{
			if (n &gt; capacity())
			{
				reserve(n);
			}
			//初始化大于size()的空间
			for (size_t i =  size(); i &lt; n; ++i)
			{
				_start[i]  = value;
			}
			_finish = _start + n;
			_end_of_storage = _start + n;
		}
	}
</code></pre> 
<h3><a id="push_back_253"></a>push_back()</h3> 
<pre><code class="prism language-c++">void push_back(const T&amp; value)
	{
		if (_finish == _end_of_storage)
		{
			reserve(capacity() == 0 ? 4 : 2 * capacity());
		}
		*_finish = value;
		++_finish;

	}
</code></pre> 
<h3><a id="pos_back_268"></a>pos_back()</h3> 
<pre><code class="prism language-c++">void pop_back()
	{
		assert(_finish &gt; _start);
		 --_finish;
			
	}
</code></pre> 
<h3><a id="insert_279"></a>insert()</h3> 
<p>如果inisrt中发生了扩容导致pos指向的空间被释放<br> 又pos本身是一个指针，这就成了对野指针的操作是非法的----迭代器失效</p> 
<pre><code class="prism language-c++">iterator  insert(iterator  pos,const T&amp; value)
	{
		assert(pos &gt;= _start);
		assert(pos &lt;= _finish);

		//扩容会导致pos失效，需要更新pos
		if (_finish == _end_of_storage)
		{
			size_t len = pos - _start;
			reserve(capacity() == 0 ?  4 : 2 * capacity());
			pos = _start + len;
		}

		iterator end = _finish;
		while (end &gt; pos)
		{
		
			*(end) = *(end - 1);
			--end;
		}

		*pos = value;
		++_finish;
		return pos;
	}
</code></pre> 
<h3><a id="erase_312"></a>erase()</h3> 
<pre><code class="prism language-c++">	//不同版本的erase可能会 异地 缩容，因此要返回一个
	iterator erase(iterator  pos)
	{
	
		assert(pos &gt;= _start);
		assert(pos &lt; _finish);
			
		iterator begin = pos + 1;
		while (begin &lt; _finish)
		{
			*(begin - 1) = *(begin);
			++begin;
		}
		--_finish;
		return pos;
	}

</code></pre> 
<h3><a id="find_334"></a>find(）</h3> 
<pre><code class="prism language-c++">template&lt;class InputIterator, class T&gt;
  InputIterator find (InputIterator first, InputIterator last, const T&amp; val)
{
  while (first!=last) {
    if (*first==val) return first;
    ++first;
  }
  return last;
}
</code></pre> 
<h2><a id="_350"></a>全部代码</h2> 
<p>Vector.h</p> 
<pre><code class="prism language-c++">#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include &lt;stdlib.h&gt; 
#include &lt;string&gt;
#include &lt;assert.h&gt;
#include&lt;time.h&gt;
#include&lt;windows.h&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;

namespace My_Vet
{
template &lt;class T&gt;
class vector
{
public:
	typedef T* iterator;
	iterator begin()
	{

		return _start;
	}
	iterator end()
	{
		return _finish;

	}
	typedef T* const_iterator;
	const_iterator begin()const
	{
		return _start;

	}
	const_iterator end()const
	{
		return _finish;

	}


	vector()
		:_start(nullptr), _finish(nullptr), _end_of_storage(nullptr)
	{}

	//传统写法
	/*vector(const vector&lt;T&gt;&amp; v)
	{

		T* tmp = new &lt;T&gt;[v.size()*sizeof(T)];
		delete[]_start;
		_start = tmp;
		_finish = tmp + v.size();
		_end_of_storage = tmp + v.capacity();
		//传统写法要考虑浅拷贝问题
		//memcpy(_start, v._start, sizeof(T)*v.size());
		for(size_t i =0;i&lt;sz;++i)
		{
		        _start[i]=v._start[i];
		}
		
	}*/

	//现在写法
	//因为vector只有默认的构造函数，无自定义构造函数，因此需要自定义构造函数
	// 
	template&lt;class inputIterator&gt;
	vector(inputIterator first, inputIterator last)
		:_start(nullptr), _finish(nullptr), _end_of_storage(nullptr)

	{
		while (first != last)
		{
			push_back(*first);
			++first;
		}
	}

	vector(const vector&lt;T&gt;&amp; v)//提前初始化成员，防止delete随机值
		: _start(nullptr),
		_finish(nullptr),
		_end_of_storage(nullptr)
	{
	
		vector&lt;T&gt; tmp(v.begin(), v.end());
		std::swap(_start, tmp._start);
		std::swap(_finish, tmp._finish);
		std::swap(_end_of_storage, tmp._end_of_storage);
	}

	//现代写法
	vector&lt;T&gt;&amp; operator=(vector&lt;T&gt;v)
	{
		std::swap(_start, v._start);
		std::swap(_finish, v._finish);
		std::swap(_end_of_storage, v._end_of_storage);
	}
	size_t size()const
	{
		return _finish - _start;
	}
	size_t capacity()const
	{
			return _end_of_storage - _start;
	}
	T&amp; operator[](size_t pos)
	{
		assert(pos &lt; size());
		return _start[pos];
	}
	const T&amp; operator[](size_t pos)const 
	{
		assert(pos &lt; size());
		return _start[pos];
	}


	void reserve(size_t n)
	{
		if (n &gt; capacity())
		{
			T* tmp = new T[n];
			int sz = size();
			if (_start != nullptr)
			{
				//使用memcpy会导致浅拷贝野指针问题
				//memcpy(tmp, _start, sizeof(T)*sz);
				
				//使用深拷贝赋值
				// 或者定位new
				for (size_t i = 0; i &lt; sz; ++i)
				{
					//调用深拷贝的赋值函数
					tmp[i] = _start[i];
				
				}
				delete[]_start;
			}
				

			_start = tmp;
			//注意这里要用旧的size，因为_start改变时，
			//finish未变，直接使用size()，可能会出现负的情况
			_finish = _start + sz;
			_end_of_storage = _start + n;
		}
	}
	
	//编译器对很多类型包括内置类型都将它们进行了提升，类似一种类，因此int()=0；
	void resize(size_t n, const T&amp; value = T())
	{
		if (n &lt; size())
		{
			_finish = _start + n;
		}
		else
		{
			if (n &gt; capacity())
			{
				reserve(n);
			}
			//初始化大于size()的空间
			for (size_t i =  size(); i &lt; n; ++i)
			{
				_start[i]  = value;
			}
			_finish = _start + n;
			_end_of_storage = _start + n;
		}
	}
	void push_back(const T&amp; value)
	{
		if (_finish == _end_of_storage)
		{
			reserve(capacity() == 0 ? 4 : 2 * capacity());
		}
		*_finish = value;
		++_finish;

	}

	void pop_back()
	{
		assert(_finish &gt; _start);
		 --_finish;
			
	}
	//如果inisrt中发生了扩容导致pos指向的空间被释放
	//又pos本身是一个指针，这就成了对野指针的操作是非法的----迭代器失效

	iterator  insert(iterator  pos,const T&amp; value)
	{
		assert(pos &gt;= _start);
		assert(pos &lt;= _finish);

		//扩容会导致pos失效，需要更新pos
		if (_finish == _end_of_storage)
		{
			size_t len = pos - _start;
			reserve(capacity() == 0 ?  4 : 2 * capacity());
			pos = _start + len;
		}

		iterator end = _finish;
		while (end &gt; pos)
		{
		
			*(end) = *(end - 1);
			--end;
		}

		*pos = value;
		++_finish;
		return pos;
	}

	//不同版本的erase可能会 异地 缩容，因此要返回一个
	iterator erase(iterator  pos)
	{
	
		assert(pos &gt;= _start);
		assert(pos &lt; _finish);
			
		iterator begin = pos + 1;
		while (begin &lt; _finish)
		{
			*(begin - 1) = *(begin);
			++begin;
		}
		--_finish;
		return pos;
	}

	~vector()
	{
		delete[]_start;
		_start = _finish = _end_of_storage = nullptr;
		//std::cout &lt;&lt; "~vector()" &lt;&lt; std::endl;
	}

	//iterator find()
	//{
	//


	//}
	private:
		iterator _start;
		iterator _finish;
		iterator _end_of_storage;

};
}

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38e831f46a6e27189820352c0f9cd84e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【c&#43;&#43;】：智能指针</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be89b0f68b650edb31c9b9a38a097d25/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">github个人博客快速搭建教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>