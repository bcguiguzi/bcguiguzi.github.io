<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java byte数据转换和处理总结 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java byte数据转换和处理总结" />
<meta property="og:description" content="java byte数据转换和处理总结 java程序或Android程序的socket数据传输，都是通过byte数组，但是int类型是4个byte组成的，如何把一个整形int转换成byte数组，同时如何把一个长度为4的byte数组转换为int类型。
一.byte和int相互转换的方法： /** * int到byte[] * @param i * @return */ public static byte[] intToByteArray(int i) { byte[] result = new byte[4]; // 由高位到低位 result[0] = (byte) ((i &gt;&gt; 24) &amp; 0xFF); result[1] = (byte) ((i &gt;&gt; 16) &amp; 0xFF); result[2] = (byte) ((i &gt;&gt; 8) &amp; 0xFF); result[3] = (byte) (i &amp; 0xFF); return result; } /** * byte[]转int * @param bytes * @return */ public static int byteArrayToInt(byte[] bytes) { int value = 0; // 由高位到低位 for (int i = 0; i &lt; 4; i&#43;&#43;) { int shift = (4 - 1 - i) * 8; value &#43;= (bytes[i] &amp; 0x000000FF) &lt;&lt; shift;// 往高位游 } return value; } //测试数据 public static void main(String[] args) { byte[] b = intToByteArray(128); System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a8d3b2194017939c4a96683b216a607f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-29T22:51:44+08:00" />
<meta property="article:modified_time" content="2018-03-29T22:51:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java byte数据转换和处理总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="java-byte数据转换和处理总结">java byte数据转换和处理总结</h2> 
<p>java程序或Android程序的socket数据传输，都是通过byte数组，但是int类型是4个byte组成的，如何把一个整形int转换成byte数组，同时如何把一个长度为4的byte数组转换为int类型。</p> 
<h3 id="一byte和int相互转换的方法">一.byte和int相互转换的方法：</h3> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/** 
 * int到byte[] 
 *<span class="hljs-javadoctag"> @param</span> i 
 *<span class="hljs-javadoctag"> @return</span> 
 */</span>  
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">intToByteArray</span>(<span class="hljs-keyword">int</span> i) {  
    <span class="hljs-keyword">byte</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span>];  
    <span class="hljs-comment">// 由高位到低位  </span>
    result[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">byte</span>) ((i &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xFF</span>);  
    result[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">byte</span>) ((i &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);  
    result[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>) ((i &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);  
    result[<span class="hljs-number">3</span>] = (<span class="hljs-keyword">byte</span>) (i &amp; <span class="hljs-number">0xFF</span>);  
    <span class="hljs-keyword">return</span> result;  
}  

<span class="hljs-javadoc">/** 
 * byte[]转int 
 *<span class="hljs-javadoctag"> @param</span> bytes 
 *<span class="hljs-javadoctag"> @return</span> 
 */</span>  
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">byteArrayToInt</span>(<span class="hljs-keyword">byte</span>[] bytes) {  
    <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;  
    <span class="hljs-comment">// 由高位到低位  </span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {  
        <span class="hljs-keyword">int</span> shift = (<span class="hljs-number">4</span> - <span class="hljs-number">1</span> - i) * <span class="hljs-number">8</span>;  
        value += (bytes[i] &amp; <span class="hljs-number">0x000000FF</span>) &lt;&lt; shift;<span class="hljs-comment">// 往高位游  </span>
    }  
    <span class="hljs-keyword">return</span> value;  
}  


<span class="hljs-comment">//测试数据</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {  
    <span class="hljs-keyword">byte</span>[] b = intToByteArray(<span class="hljs-number">128</span>);  
    System.out.println(Arrays.toString(b));<span class="hljs-comment">//打印byte的每一个字节  </span>

    <span class="hljs-keyword">int</span> i = byteArrayToInt(b);  
    System.out.println(i);  <span class="hljs-comment">//打印byte转变为Int后的数据 </span>
}   

</code></pre> 
<h3 id="二byte和string相互转换">二.byte和String相互转换</h3> 
<p>上面只说到byte和int的相互转换，其实呢byte和String也是可以相互转换的，毕竟Socket通信也是需要传递字符串的。 <br> 其他的方面，char和long、float这些数据都是可以转换为byte的，但是实际应用场合比较少。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//String 和byte相互转换的示例</span>

    String <span class="hljs-keyword">string</span> = <span class="hljs-string">"hello 世界小姐"</span>;

        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">string</span>.getBytes();<span class="hljs-comment">//获得byte数组</span>

        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"bytes--&gt;"</span> + Arrays.toString(bytes));<span class="hljs-comment">//打印byte数组</span>

        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"string--&gt;"</span> + <span class="hljs-keyword">new</span> String(bytes));<span class="hljs-comment">//获得byte数组转换来的String数据，并打印</span>
</code></pre> 
<p>上面第一第二都是byte数组和其他数据相互转换，其实也可以通过流的来获取字节，传递过去后再把字节放到流里面去，解封出来，但是那样还是太麻烦的！不建议做。</p> 
<h3 id="三byte占用字节大小详解">三.byte占用字节大小详解</h3> 
<p>在Java中一共有8种基本数据类型，其中有4种整型，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型和1种用于表示真值的boolean类型。（一个字节等于8个bit）</p> 
<h4 id="1整型">1.整型</h4> 
<table><thead><tr><th>类型</th><th>存储需求</th><th>bit数</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>4*8</td><td>很大</td><td></td></tr><tr><td>short</td><td>2字节</td><td>2*8</td><td>－32768～32767</td><td></td></tr><tr><td>long</td><td>8字节</td><td>8*8</td><td>非常大</td><td></td></tr><tr><td>byte</td><td>1字节</td><td>1*8</td><td>－128～127</td><td></td></tr></tbody></table> 
<p>2.浮点型</p> 
<table><thead><tr><th>类型</th><th>存储需求</th><th>bit数</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>4*8</td><td>很大</td><td>float类型的数值有一个后缀F(例如：3.14F)</td></tr><tr><td>double</td><td>8字节</td><td>8*8</td><td>非常大</td><td>没有后缀F的浮点数值(如3.14)默认为double类型</td></tr></tbody></table> 
<p>3.char类型</p> 
<table><thead><tr><th>类型</th><th>存储需求</th><th>bit数</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td>2字节</td><td>2*8</td><td>－32768～32767</td><td></td></tr></tbody></table> 
<p>4.boolean类型</p> 
<table><thead><tr><th>类型</th><th>存储需求</th><th>bit数</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td>boolean</td><td>1字节</td><td>1*8</td><td>false、true</td><td></td></tr></tbody></table> 
<h3 id="四string与byte字节数组中文转换乱码问题">四.String与byte[]字节数组中文转换乱码问题</h3> 
<p>在Java中，String.getBytes(String decode)方法会根据指定的decode编码返回某字符串在该编码下的byte数组表示，如</p> 
<p>byte[] b_gbk = “中”.getBytes(“GBK”);</p> 
<p>byte[] b_utf8 = “中”.getBytes(“UTF-8”); </p> 
<p>byte[] b_iso88591 = “中”.getBytes(“ISO8859-1”);</p> 
<p>byte[] b_unicode = “中”.getBytes(“unicode”);</p> 
<p>将分别返回“中”这个汉字在GBK、UTF-8和ISO8859-1编码下的byte数组表示， <br> 此时b_gbk的长度为2，b_utf8的长度为3，b_iso88591的长度为1, <br> b_unicode 的长度为4（系统的的unicode采用的是big-endian就是前面是两个字节来表示这个的，unicode采用的都是两个字节编码，所以后面是4个字节 ）。</p> 
<p>而与getBytes相对的，可以通过new String(byte[], decode)的方式来还原这个“中”字时，这个new String(byte[], decode)实际是使用decode指定的编码来将byte[]解析成字符串。</p> 
<p>String s_gbk = new String(b_gbk,”GBK”);</p> 
<p>String s_utf8 = new String(b_utf8,”UTF-8”); </p> 
<p>String s_iso88591 = new String(b_iso88591,”ISO8859-1”);</p> 
<p>通过打印s_gbk、s_utf8和s_iso88591，会发现，s_gbk和s_utf8都是“中”，而只有s_iso88591是一个不认识的字符，为什么使用ISO8859-1编码再组合之后， <br> 无法还原“中”字呢，其实原因很简单，因为ISO8859-1编码的编码表中， <br> 根本就没有包含汉字字符，当然也就无法通过”中”.getBytes(“ISO8859-1”);来得到正确的“中”字在ISO8859-1中的编码值了，所以再通过new String()来还原就无从谈起了。</p> 
<p>因此，通过String.getBytes(String decode)方法来得到byte[]时，一定要确定decode的编码表中确实存在String表示的码值，这样得到的byte[]数组才能正确被还原。</p> 
<p>有时候，为了让中文字符适应某些特殊要求（如http header头要求其内容必须为iso8859-1 编码），可能会通过将中文字符按照字节方式来编码的情况， <br> 如 String s_iso88591 = new String(“中”.getBytes(“UTF-8”),”ISO8859-1”)，这样得到的s_iso8859-1字符串实际是三个在ISO8859-1中的字符， <br> 在将这些字符传递到目的地后，目的地程序再通过相反的方式String s_utf8 = new String(s_iso88591.getBytes(“ISO8859-1”),”UTF-8”)来得到正确的中文汉字“中”。 <br> 这样就既保证了遵守协议规定、也支持中文。</p> 
<p>String的getBytes()方法是得到一个字串的字节数组，这是众所周知的。但特别要注意的是，本方法将返回该操作系统默认的编码格式的字节数组。 <br> 如果你在使用这个方法时不考虑到这一点，你会发现在一个平台上运行． 良好的系统，放到另外一台机器后会产生意想不到的问题。</p> 
<p>对也String来说，一个英文字符固定占1个字节，而中文字符占2个（GBK编码）或3个（UTF-8编码）字节。</p> 
<h3 id="五byte字节其他的知识">五.byte字节其他的知识</h3> 
<h4 id="两个字节能不能表示一个int呢">两个字节能不能表示一个int呢？</h4> 
<p>其实也是可以的，就是有一些坑会在里面！ <br> 代码：</p> 
<pre class="prettyprint"><code class=" hljs cs">   <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;
   <span class="hljs-keyword">byte</span> b1 = (<span class="hljs-keyword">byte</span>) ((a &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);   <span class="hljs-comment">//高8位</span>
   <span class="hljs-keyword">byte</span> b2 = (<span class="hljs-keyword">byte</span>) (a &amp; <span class="hljs-number">0xFF</span>); <span class="hljs-comment">//低8位</span>
   System.<span class="hljs-keyword">out</span>.println(a+<span class="hljs-string">"--&gt;"</span>+(b1)+(b2) );


   <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span> = <span class="hljs-number">0</span>;
   <span class="hljs-keyword">value</span> += (b1 &amp; <span class="hljs-number">0xFF</span>) &lt;&lt; <span class="hljs-number">8</span>;<span class="hljs-comment">// 往高位游</span>
   <span class="hljs-keyword">value</span> += (b2 &amp; <span class="hljs-number">0xFF</span>);<span class="hljs-comment">//</span>
   System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"value="</span> + <span class="hljs-keyword">value</span>);
</code></pre> 
<p>如果a的数值在0到32767之内都是正常的。</p> 
<p>正常情况是没有问题的，像一般字符串的长度用两个字节的byte和int相互转换来表示长度，但是如果是负数就不可以用两个字节byte来和int相互转换了。 <br> 因为如果是负数的话符号位就是1了，左移和右移有很大想差别。 <br> 像会出现负数的情况还是要使用四个byte来和int做相互转换传递数据。</p> 
<h4 id="在线测试一下">在线测试一下</h4> 
<p>如果想简单验证也可以使用在线java编译工具，测试一下： <br> <a href="http://www.runoob.com/try/runcode.php?filename=HelloWorld&amp;type=java" rel="nofollow noopener noreferrer" target="_blank">http://www.runoob.com/try/runcode.php?filename=HelloWorld&amp;type=java</a> <br> 把上面的代码复制进去就可以了，这个在线的便宜工具只能识别一些简单的类，想字节流那些还是不能识别的。</p> 
<h2 id="共勉别忘了你是第一名">共勉：别忘了你是第一名</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/440c3ee459ee30b8dcc5ded8f6605824/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ContentProvider&amp;ContentResolver</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2f106a96c7d25de9dfb0109ff9a0ccea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">作为移动端(Android)开发的我已被前端框架Bootstrap所折服</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>