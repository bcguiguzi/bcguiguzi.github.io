<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker容器网络模式与数据管理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker容器网络模式与数据管理" />
<meta property="og:description" content="文章目录 一、Docker容器操作1、容器创建2、查看容器的运行状态3、启动容器4、创建并开启容器5、终止容器运行6、容器的进入7、复制文件到容器中/宿主机中8、容器的导出与导入9、删除容器 二、Docker网络1、Docker网络实现原理2、Docker的网络模式 三、网络模式详解1、host模式2、container模式3、none模式4、bridge模式5、自定义网络 四、CPU资源控制1、cgroups概述2、cgroups的四大功能3、设置CPU使用率上限4、设置CPU资源占用比（设置多个容器时才有效）5、设置容器绑定指定的CPU 五、对内存使用的限制1、创建指定物理内存的容器2、创建指定物理内存和swap的容器1、设置限制项2、创建容器，并限制写速度3、通过dd来验证写速度4、清理docker占用的磁盘空间 六、Docker的数据管理1、管理Docker容器的方式2、数据卷3、数据卷容器 七、容器互联（使用centos镜像）1、定义2、创建容器互联 一、Docker容器操作 1、容器创建 将镜像加载到容器的过程。新创建的容器默认处于停止状态，不运行任何程序，需要在其中发起一个进程来启动容器
格式∶docker create [选项] 镜像常用选项∶ -i∶让容器的输入保持打开 -t∶让Docker分配一个伪终端 docker create -it nginx:latest bash #bash为系统命令/bin/bash、/usr/bin/bash的缩写 2、查看容器的运行状态 docker ps -a #-a 选项可以显示所有的容器，不加-a只显示运行的容器 3、启动容器 docker start 容器的ID/名称 docker ps -a 4、创建并开启容器 （1）格式
docker run 镜像 bash -c shell命令 例如：docker run nginx:latest bash -c ls / #会发现创建了一个新容器并启动执行一条 shell 命令，容器将这条命令作为第一个进程，命令执行完毕后容器的第一个进程也关闭则容器就停止了 （2）docker run运行过程
可以直接执行 docker run 命令，等同于先执行 docker create 命令，再执行 docker start 命令。 注意∶容器是一个与其中运行的 shell 命令共存亡的终端，命令运行容器运行，命令结束容器退出。 docker 容器默认会把容器内部第一个进程，也就是 pid=1 的程序作为docker容器是否正在运行的依据，如果docker容器中pid = 1 的进程挂了，那么docker容器便会直接退出，也就是说Docker容器中必须有一个前台进程，否则认为容器已经挂掉。 当利用 docker run 来创建容器时，Docker 在后台的标准运行过程是∶ （1）检查本地是否存在指定的镜像。当镜像不存在时，会从公有仓库下载 （2）利用镜像创建并启动一个容器 （3）分配一个文件系统给容器，在只读的镜像层外面挂载一层可读写层 （4）从宿主主机配置的网桥接口中桥接一个虚拟机接口到容器中 （5）分配一个地址池中的 IP 地址给容器; （6）执行用户指定的应用程序，执行完毕后容器被终止运行 （3）在后台持续运行docker run创建的容器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a7fe5c480d7e302602f7ff7dc64120d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-13T08:51:14+08:00" />
<meta property="article:modified_time" content="2022-01-13T08:51:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker容器网络模式与数据管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Docker_2" rel="nofollow">一、Docker容器操作</a></li><li><ul><li><a href="#1_4" rel="nofollow">1、容器创建</a></li><li><a href="#2_22" rel="nofollow">2、查看容器的运行状态</a></li><li><a href="#3_32" rel="nofollow">3、启动容器</a></li><li><a href="#4_44" rel="nofollow">4、创建并开启容器</a></li><li><a href="#5_87" rel="nofollow">5、终止容器运行</a></li><li><a href="#6_111" rel="nofollow">6、容器的进入</a></li><li><a href="#7_123" rel="nofollow">7、复制文件到容器中/宿主机中</a></li><li><a href="#8_141" rel="nofollow">8、容器的导出与导入</a></li><li><a href="#9_172" rel="nofollow">9、删除容器</a></li></ul> 
  </li><li><a href="#Docker_207" rel="nofollow">二、Docker网络</a></li><li><ul><li><a href="#1Docker_209" rel="nofollow">1、Docker网络实现原理</a></li><li><a href="#2Docker_236" rel="nofollow">2、Docker的网络模式</a></li></ul> 
  </li><li><a href="#_270" rel="nofollow">三、网络模式详解</a></li><li><ul><li><a href="#1host_272" rel="nofollow">1、host模式</a></li><li><a href="#2container_282" rel="nofollow">2、container模式</a></li><li><a href="#3none_307" rel="nofollow">3、none模式</a></li><li><a href="#4bridge_312" rel="nofollow">4、bridge模式</a></li><li><a href="#5_330" rel="nofollow">5、自定义网络</a></li></ul> 
  </li><li><a href="#CPU_361" rel="nofollow">四、CPU资源控制</a></li><li><ul><li><a href="#1cgroups_363" rel="nofollow">1、cgroups概述</a></li><li><a href="#2cgroups_367" rel="nofollow">2、cgroups的四大功能</a></li><li><a href="#3CPU_374" rel="nofollow">3、设置CPU使用率上限</a></li><li><a href="#4CPU_470" rel="nofollow">4、设置CPU资源占用比（设置多个容器时才有效）</a></li><li><a href="#5CPU_505" rel="nofollow">5、设置容器绑定指定的CPU</a></li></ul> 
  </li><li><a href="#_531" rel="nofollow">五、对内存使用的限制</a></li><li><ul><li><a href="#1_533" rel="nofollow">1、创建指定物理内存的容器</a></li><li><a href="#2swap_546" rel="nofollow">2、创建指定物理内存和swap的容器</a></li><li><a href="#1_568" rel="nofollow">1、设置限制项</a></li><li><a href="#2_583" rel="nofollow">2、创建容器，并限制写速度</a></li><li><a href="#3dd_591" rel="nofollow">3、通过dd来验证写速度</a></li><li><a href="#4docker_600" rel="nofollow">4、清理docker占用的磁盘空间</a></li></ul> 
  </li><li><a href="#Docker_610" rel="nofollow">六、Docker的数据管理</a></li><li><ul><li><a href="#1Docker_612" rel="nofollow">1、管理Docker容器的方式</a></li><li><a href="#2_616" rel="nofollow">2、数据卷</a></li><li><a href="#3_644" rel="nofollow">3、数据卷容器</a></li></ul> 
  </li><li><a href="#centos_677" rel="nofollow">七、容器互联（使用centos镜像）</a></li><li><ul><li><a href="#1_679" rel="nofollow">1、定义</a></li><li><a href="#2_683" rel="nofollow">2、创建容器互联</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Docker_2"></a>一、Docker容器操作</h2> 
<h3><a id="1_4"></a>1、容器创建</h3> 
<p>将镜像加载到容器的过程。新创建的容器默认处于停止状态，不运行任何程序，需要在其中发起一个进程来启动容器</p> 
<pre><code>格式∶docker create [选项]
 
镜像常用选项∶
-i∶让容器的输入保持打开
-t∶让Docker分配一个伪终端
 
docker create -it nginx:latest bash    #bash为系统命令/bin/bash、/usr/bin/bash的缩写
</code></pre> 
<p><img src="https://images2.imgbox.com/be/3f/p8XA3pkd_o.png" alt="img"></p> 
<h3><a id="2_22"></a>2、查看容器的运行状态</h3> 
<pre><code>docker ps -a       #-a 选项可以显示所有的容器，不加-a只显示运行的容器
</code></pre> 
<p><img src="https://images2.imgbox.com/e5/e2/GSBvYNxx_o.png" alt="img"></p> 
<h3><a id="3_32"></a>3、启动容器</h3> 
<pre><code>docker start 容器的ID/名称
 
docker ps -a
</code></pre> 
<p><img src="https://images2.imgbox.com/a2/bd/llxkpwhe_o.png" alt="img"></p> 
<h3><a id="4_44"></a>4、创建并开启容器</h3> 
<p>（1）格式</p> 
<pre><code>docker run 镜像 bash -c shell命令
 
例如：docker run nginx:latest bash -c ls /  #会发现创建了一个新容器并启动执行一条 shell 命令，容器将这条命令作为第一个进程，命令执行完毕后容器的第一个进程也关闭则容器就停止了
</code></pre> 
<p><img src="https://images2.imgbox.com/8d/7a/TXr0igVI_o.png" alt="img"></p> 
<p>（2）docker run运行过程</p> 
<pre><code>可以直接执行 docker run 命令，等同于先执行 docker create 命令，再执行 docker start 命令。
注意∶容器是一个与其中运行的 shell 命令共存亡的终端，命令运行容器运行，命令结束容器退出。
docker 容器默认会把容器内部第一个进程，也就是 pid=1 的程序作为docker容器是否正在运行的依据，如果docker容器中pid = 1 的进程挂了，那么docker容器便会直接退出，也就是说Docker容器中必须有一个前台进程，否则认为容器已经挂掉。
当利用 docker run 来创建容器时，Docker 在后台的标准运行过程是∶
（1）检查本地是否存在指定的镜像。当镜像不存在时，会从公有仓库下载
（2）利用镜像创建并启动一个容器
（3）分配一个文件系统给容器，在只读的镜像层外面挂载一层可读写层
（4）从宿主主机配置的网桥接口中桥接一个虚拟机接口到容器中
（5）分配一个地址池中的 IP 地址给容器;
（6）执行用户指定的应用程序，执行完毕后容器被终止运行
</code></pre> 
<p>（3）在后台持续运行docker run创建的容器</p> 
<pre><code>需要在docker run命令之后添加 -d 选项让 Docker 容器以守护形式在后台运行。并且容器所运行的程序不能结束。
docker run -d nginx:latest bash -c "while true;do echo hello;done"
docker ps -a      #可以看出容器始终处于UP，运行状态
 
docker run -itd --name test1 nginx:latest bash  
</code></pre> 
<p><img src="https://images2.imgbox.com/ca/29/sNLz57ni_o.png" alt="img"></p> 
<h3><a id="5_87"></a>5、终止容器运行</h3> 
<pre><code>格式∶ docker stop 容器的ID/名称
docker stop [-t] de7091f9d88e       #-t指定等待多少秒后直接kill该容器，默认10秒
 
docker ps -a
 
格式：docker kill 容器的ID/名称
docker kill c14bf5853a5e
 
docker ps -a
 
#kill和stop区别在于stop会通知容器需要进行关闭，在等待10S左右关闭容器，预留一个服务缓存数据保存的时间，而kill会立刻关闭容器，缓存在内存中的数据有可能会直接丢失
</code></pre> 
<p><img src="https://images2.imgbox.com/43/e8/Q2NjHy9i_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/f5/51/8Dezkd0H_o.png" alt="img"></p> 
<h3><a id="6_111"></a>6、容器的进入</h3> 
<pre><code>格式∶ docker exec -it 容器ID/名称 /bin/bash
-i 选项表示让容器的输入保持打开
-t 选项表示让 Docker 分配一个伪终端
</code></pre> 
<p><img src="https://images2.imgbox.com/41/83/86oeBWtq_o.png" alt="img"></p> 
<h3><a id="7_123"></a>7、复制文件到容器中/宿主机中</h3> 
<pre><code>echo "hello world" &gt; ~/test.txt      #在当前目录创建一个文件，然后复制到容器中
docker cp ~/test.txt 924756260cb1:/opt/
  
#从容器复制文件到主机
docker cp 924756260cb1:/opt/test.txt ~/abc123.txt
</code></pre> 
<p><img src="https://images2.imgbox.com/a2/2b/coSlTuJB_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/e6/94/Zct3WNi9_o.png" alt="img"></p> 
<h3><a id="8_141"></a>8、容器的导出与导入</h3> 
<p>用户可以将任何一个Docker容器从一台机器迁移到另一台机器。在迁移过程中，可以使用docker export命令将已经创建好的容器导出为文件，无论这个容器是处于运行状态还是停止状态均可导出。可将导出文件传输到其他机器，通过相应的导入命令实现容器的迁移</p> 
<p>（1）导出</p> 
<pre><code>docker export 容器ID/名称 &gt;文件名
docker export 5c48f0d8de05 &gt; nginx.tar
scp scp nginx.tar 192.168.80.12:/opt
</code></pre> 
<p><img src="https://images2.imgbox.com/20/ab/s99YOb4O_o.png" alt="img"></p> 
<p>（2）导入</p> 
<pre><code>cat 文件名 | docker import - 镜像名称:标签
cat nginx.tar | docker import - nginx:test 
 
docker run -itd --name jc 0553d2743bba bash   #重新创建容器
</code></pre> 
<p><img src="https://images2.imgbox.com/05/63/hwnFrnnm_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/c2/a7/quYehWeT_o.png" alt="img"></p> 
<h3><a id="9_172"></a>9、删除容器</h3> 
<pre><code>#需要先停止容器进行删除，如果强制删除运行状态容器需要加上“-f”，rmi为删除镜像仓库，而使用rm可以删除容器
格式∶docker rm [-f] 容器ID/名称
docker stop 容器ID                            #删除已经终止状态的容器
docker rm 容器ID
docker rm -f 容器ID                           #强制删除正在运行的容器
 
#批量停止容器
docker ps -a | awk 'NR&gt;=2{print "docker stop "$1}' | bash               
docker ps -a | awk 'NR&gt;=2{print $1}' | xargs docker stop
 
#批量删除所有容器
docker ps -a | awk 'NR&gt;=2{print "docker rm "$1}'| bash
docker ps -a | awk 'NR&gt;=2{print $1}'| xargs docker rm
 
#批量删镜像
docker images | awk 'NR&gt;=2{print "docker rmi "$3}'| bash
  
#删除none镜像
docker images | grep none | awk '{print $3}' | xargs docker rmi
 
#批量清理后台停止的容器
docker rm $(docker ps -a -q)
</code></pre> 
<p><img src="https://images2.imgbox.com/2b/01/cKJhta70_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/a8/03/QS2cKmXF_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/3f/56/XMPP90NC_o.png" alt="img"></p> 
<h2><a id="Docker_207"></a>二、Docker网络</h2> 
<h3><a id="1Docker_209"></a>1、Docker网络实现原理</h3> 
<p>（1）Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥（docker0），Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的 Container-IP直接通信，默认分配的IP网段为172.17.0.0，docker0为172.17.0.1作为网关</p> 
<p>（2）Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法直接通过Container-IP 访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即 docker run 创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过 [宿主机IP]:[容器端口] 访问容器</p> 
<p>（3）格式</p> 
<pre><code>docker run -d --name test1 -P nginx           #-P不指定，随机映射端口（从32768开始）
  
docker run -d --name test2 -p 43999:80 nginx  #-p指定映射端口
docker ps-a
 
浏览器访问∶http://192.168.142.4:49154、http://192.168.142.4:43999
</code></pre> 
<p><img src="https://images2.imgbox.com/00/a1/mK0yPrvO_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/d7/a6/mFMJjHCm_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/81/28/r7ryutFD_o.png" alt="img"></p> 
<h3><a id="2Docker_236"></a>2、Docker的网络模式</h3> 
<p>（1）五种网络模式</p> 
<p>• Host:容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口</p> 
<p>• Container:创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围</p> 
<p>• None:该模式关闭了容器的网络功能</p> 
<p>• Bridge:默认为该模式，此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及iptables nat表配置与宿主机通信</p> 
<p>• 自定义网络</p> 
<p>（2）查看docker网络列表</p> 
<pre><code>安装Docker时，它会自动创建三个网络，bridge（创建容器默认连接到此网络）、none 、host
命令：docker network ls 或 docker network list
</code></pre> 
<p><img src="https://images2.imgbox.com/fc/6f/Ei8eIuHH_o.png" alt="img"></p> 
<p>（3）指定容器的网络模式</p> 
<pre><code>• host模式:使用--net=host 指定
• none模式:使用 --net=none 指定
• container模式:使用--net=container∶NAME or ID指定
• bridge模式:使用 --net=bridge 指定，默认设置，可省略
</code></pre> 
<h2><a id="_270"></a>三、网络模式详解</h2> 
<h3><a id="1host_272"></a>1、host模式</h3> 
<p>（1）相当于Vmware中的桥接模式，与宿主机在同一个网络中，但没有独立IP地址</p> 
<p>（2）Docker使用了Linux中的Namespaces技术来进行资源隔离，如PID Namesoace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。</p> 
<p>（3）一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、iptable规则等都与其他的Network Namespace隔离</p> 
<p>（4）一个Docker容器一般会分配一个独立的Network Namespace，但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡、配置自己的IP等，而是使用宿主机的IP和端口</p> 
<h3><a id="2container_282"></a>2、container模式</h3> 
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个Network<br> Namespace，而不是和宿主机共享。新创建的容器不会创建自已的网卡，配置自已的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信</p> 
<pre><code>#新建一个容器
docker run -itd --name jc nginx:latest /bin/bash
docker ps -a
docker inspect -f '{<!-- -->{.State.Pid}}' caccb08b3f68    #查看容器进程号
 
ls -l /proc/6002/ns
</code></pre> 
<p><img src="https://images2.imgbox.com/86/48/mRURG3XR_o.png" alt="img"></p> 
<pre><code>docker run -itd --name jc2 --net=container: caccb08b3f68 nginx:latest /bin/bash
docker ps -a
docker inspect -f '{<!-- -->{.State.Pid}}' 7308326d1d99
ls -l /proc/9469/ns
</code></pre> 
<p><img src="https://images2.imgbox.com/e9/34/I5pPDzbc_o.png" alt="img"></p> 
<h3><a id="3none_307"></a>3、none模式</h3> 
<p>（1）使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置<br> （2）也就是说，这个Docker容器没有网卡、IP、路由等信息。这种网络模式下容器只有lo回环网络，没有其他网卡。这种类型的网络没有办法联网，但封闭的网络能很好的保证容器的安全性</p> 
<h3><a id="4bridge_312"></a>4、bridge模式</h3> 
<p>（1）bridge模式是docker的默认网络模式，不用–net参数，就是bridge模式</p> 
<p>（2）相当于Vmware中的nat模式，容器使用独立network Namespace，并连接到docker0虚拟网卡。通过docker0网桥以及iptables nat表配置与宿主机通信，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上</p> 
<p>• 当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中</p> 
<p>• 从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此veth 设备常用来连接两个网络设备</p> 
<p>• Docker将 veth pair 设备的一端放在新创建的容器中，并命名为 eth0（容器的网卡），另一端放在主机中，以 veth*这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。可以通过 brctl show命令查看</p> 
<p>• 使用 docker run -p 时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看</p> 
<p><img src="https://images2.imgbox.com/d0/5c/U5WepuuY_o.png" alt="img"></p> 
<h3><a id="5_330"></a>5、自定义网络</h3> 
<pre><code>#直接使用bridge模式，是无法支持指定IP运行docker的，例如执行以下命令就会报错
docker run -itd --name jc4 --network bridge --ip 172.17.0.10 centos:7 /bin/bash  
  
#创建自定义网络
#可以先自定义网络，再使用指定IP运行docker
docker network create --subnet=172.20.0.0/16 --opt "com.docker.network.bridge.name"="docker1" mynetwork
 
#docker1 为执行 ifconfig -a 命令时，显示的网卡名，如果不使用 --opt 参数指定此名称，那你在使用 ifconfig -a 命令查看网络信息时，看到的是类似br-110eb56a0b22 这样的名字，这显然不怎么好记。
#mynetwork为执行docker network list命令时，显示的bridge网络模式名称
  
docker run -itd --name jc4--net mynetwork --ip 172.20.0.10 centos:7 /bin/bash
ifconfig       #该命令需要安装net-tools
</code></pre> 
<p><img src="https://images2.imgbox.com/2c/68/qWOc5QNc_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/d2/e5/66Cedv19_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/7f/fb/QNnrXQjL_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/53/8d/S3RqinWq_o.png" alt="img"></p> 
<h2><a id="CPU_361"></a>四、CPU资源控制</h2> 
<h3><a id="1cgroups_363"></a>1、cgroups概述</h3> 
<p>是一个非常强大的linux内核工具，他不仅可以限制被namespace 隔离起来的资源，还可以为资源设置权重、计算使用量、操控进程启停等等，所以cgroups (Control groups）实现了对资源的配额和度量</p> 
<h3><a id="2cgroups_367"></a>2、cgroups的四大功能</h3> 
<p>（1）资源限制：可以对任务使用的资源总额进行限制<br> （2）优先级分配：通过分配的cpu时间片数量以及磁盘To带宽大小，实际上相当于控制了任务运行优先级<br> （3）资源统计：可以统计系统的资源使用量，如cpu时长，内存用量等<br> （4）任务控制：cgroup可以对任务执行挂起、恢复等操作</p> 
<h3><a id="3CPU_374"></a>3、设置CPU使用率上限</h3> 
<p>（1）–cpu-period与–cpu-quota</p> 
<p>• Linux 通过 CFS（Completely Fair Scheduler，完全公平调度器）来调度各个进程对 CPU 的使用。CFS 默认的调度周期是 100ms,我们可以设置每个容器进程的调度周期，以及在这个周期内各个容器最多能使用多少 CPU 时间</p> 
<p>• 使用–cpu-period 即可设置调度周期，使用 --cpu-quota 即可设置在每个周期内容器能使用的 CPU 时间。两者可以配合使用。CFS周期的有效范围是 1ms~1s，对应的 --cpu-period 的数值范围是 1000~100000（微秒）</p> 
<p>• 容器的CPU配额必须不小于1ms，即–cpu-quota 的值必须 &gt;= 1000</p> 
<p>（2）查看两个配额数值</p> 
<pre><code>docker run -itd --name jc1 centos:7 /bin/bash   #创建一个容器
 
docker ps -a
CONTAINER ID   IMAGE      COMMAND       CREATED         STATUS        PORTS     NAMES
45509991194c   centos:7   "/bin/bash"   40 seconds ago   Up 39 second             jc1
 
cd /sys/fs/cgroup/cpu/docker/a8116f7815a35d43af77b661fe5846e1e550029c0034d3f84f9fdabd49996bc5/
 
cat cpu.cfs_quota_us
-1
 
cat cpu.cfs_period_us
100000
----------------------------------------------
#cpu.cfs_period_us：cpu分配的周期(微秒，所以文件名中用 us 表示），默认为100000。
#cpu.cfs_quota_us：表示该control group限制占用的时间（微秒），默认为-1，表示不限制如果设为50000，表示占用50000/100000=50%的cpu
</code></pre> 
<p><img src="https://images2.imgbox.com/50/be/LMwbD89c_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/bd/e8/weJw7MzX_o.png" alt="img"></p> 
<p>（3）进行CPU压力测试</p> 
<pre><code>docker exec -it 45509991194c  /bin/bash  #进入容器
写一个死循环脚本
vi cpu.sh
#!/bin/bash
i=0
while true
do
let i++
done
 
chmod +x cpu.sh
./cpu.sh
另开一个终端用top命令查看cpu占比                 #可以看到这个脚本占了很多的cpu资源

</code></pre> 
<p><img src="https://images2.imgbox.com/02/89/FlG5wewO_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/89/db/xVYR7APh_o.png" alt="img"></p> 
<p>（4）设置50%的比例分配CPU使用时间上限</p> 
<pre><code>第一种方法：
1.docker run -itd --name jc2 --cpu-quota 50000 centos:7 /bin/bash   #可以重新创建一个容器并设置限额
2.docker exec -it  af6a2c2befe7 /bin/bash  #进入容器
3.写一个死循环脚本来测试
vi cpu.sh
#!/bin/bash
i=0
while true
do
let i++
done
 
chmod +x cpu.sh
./cpu.sh
4.另开一个终端用top命令查看cpu占比  
第二种方法：
1.cd /sys/fs/cgroup/cpu/docker/af6a2c2befe7a4b313c7fdd2dda1c4376af2b31cd45cc3b890e95d45b664a1cc/
2.echo 50000 &gt; cpu.cfs_quota_us
3.docker exec -it af6a2c2befe7 /bin/bash
4../cpu.sh
5.另开一个终端用top命令查看cpu占比   　　
</code></pre> 
<p><img src="https://images2.imgbox.com/d4/4f/8kUIw1gO_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/b1/91/C8sLzmY5_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/a8/3b/zMZAhS6n_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/83/44/sybd5ZjF_o.png" alt="img"></p> 
<h3><a id="4CPU_470"></a>4、设置CPU资源占用比（设置多个容器时才有效）</h3> 
<p>（1）格式</p> 
<pre><code>Docker 通过--cpu-shares 指定 CPU 份额，默认值为1024，值为1024的倍数。
#创建两个容器为 c1 和 c2，若只有这两个容器，设置容器的权重，使得c1和c2的CPU资源占比为1/3和2/3。
docker run -itd --name jc3 --cpu-shares 4096 centos:7 bash
docker run -itd --name jc4 --cpu-shares 12288 centos:7 bash
</code></pre> 
<p><img src="https://images2.imgbox.com/8d/5f/KgK8vADM_o.png" alt="img"></p> 
<p>（2）分别进入容器，进行压力测试</p> 
<pre><code>yum install -y epel-release
yum install stress -y
stress -c 4             #产生四个进程，每个进程都反复不停的计算随机数的平方根
</code></pre> 
<p><img src="https://images2.imgbox.com/3f/50/VnyEYfgK_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/a7/fa/Zp0iHEDV_o.png" alt="img"></p> 
<p>（3）查看容器运行状态（动态更新）</p> 
<pre><code>docker stats
</code></pre> 
<p><img src="https://images2.imgbox.com/d2/a6/cwUUrEuC_o.png" alt="img"></p> 
<h3><a id="5CPU_505"></a>5、设置容器绑定指定的CPU</h3> 
<p>（1）先分配虚拟机4个CPU核数</p> 
<pre><code>docker run -itd --name jc5 --cpuset-cpus 1,3 centos:7 /bin/bash
</code></pre> 
<p><img src="https://images2.imgbox.com/b6/18/wYqIwi7Q_o.png" alt="img"></p> 
<p>（2）进入容器，进行压力测试</p> 
<pre><code>docker exec -it cf1c78cbfe79 bash
 
yum install -y epel-release
yum install stress -y
stress -c 4
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/a5/nwXhjCjM_o.png" alt="img"></p> 
<p>（3）退出容器，执行top命令再按1查看cpu使用情况</p> 
<p><img src="https://images2.imgbox.com/72/b4/TVRMT0Cq_o.png" alt="img"></p> 
<h2><a id="_531"></a>五、对内存使用的限制</h2> 
<h3><a id="1_533"></a>1、创建指定物理内存的容器</h3> 
<pre><code>-m(--memory=)选项用于限制容器可以使用的最大内存
docker run -itd --name jc6 -m 512m centos:7 /bin/bash
 
docker stats
</code></pre> 
<p><img src="https://images2.imgbox.com/1c/8f/LEmjguDZ_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/21/4b/2pwuXLCP_o.png" alt="img"></p> 
<h3><a id="2swap_546"></a>2、创建指定物理内存和swap的容器</h3> 
<pre><code>docker run -itd --name jc7 -m 512m --memory-swap 1g centos:7 /bin/bash
 
强调一下，--memory-swap是必须要与--memory一起使用的
 
正常情况下，--memory-swap的值包含容器可用内存和可用swap
所以-m 300m --memory-swap=1g 的含义为:容器可以使用300M 的物理内存，并且可以使用700M (1G - 300M）的swap
 
如果--memory-swap设置为0或者不设置，则容器可以使用的swap大小为-m值的两倍
如果--memory-swap的值和-m值相同，则容器不能使用swap
如果--memory-Swap值为-1，它表示容器程序使用的内存受限，而可以使用的swap空间使用不受限制（宿主机有多少，swap容器就可以使用多少)

</code></pre> 
<p><img src="https://images2.imgbox.com/b9/da/eD47UNd9_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/fc/7d/PK2adMjS_o.png" alt="img"></p> 
<p>六、对磁盘IO配额控制（blkio）的限制</p> 
<h3><a id="1_568"></a>1、设置限制项</h3> 
<pre><code>--device-read-bps：限制某个设备上的读速度bps（数据量），单位可以是kb、mb(M)或者gb。
例：docker run -itd --name jc8 --device-read-bps /dev/sda:1M  centos:7 /bin/bash
 
--device-write-bps ： 限制某个设备上的写速度bps（数据量），单位可以是kb、mb(M)或者gb。
例：docker run -itd --name jc8 --device-write-bps /dev/sda:1mb centos:7 /bin/bash
 
--device-read-iops ：限制读某个设备的iops（次数）
  
--device-write-iops ：限制写入某个设备的iops（次数）
2、创建容器，并限制写速度
</code></pre> 
<h3><a id="2_583"></a>2、创建容器，并限制写速度</h3> 
<pre><code>docker run -itd --name jc9 --device-write-bps /dev/sda:1mb centos:7 /bin/bash 
</code></pre> 
<p><img src="https://images2.imgbox.com/33/bd/iWFLrSKd_o.png" alt="img"></p> 
<h3><a id="3dd_591"></a>3、通过dd来验证写速度</h3> 
<pre><code>docker exec -it cfa60bfee91c bash  #进入容器
dd if=/dev/zero of=test.out bs=1M count=50 oflag=direct #添加oflag参数以规避掉文件系统cache
</code></pre> 
<p><img src="https://images2.imgbox.com/fb/af/Uw77LPeE_o.png" alt="img"></p> 
<h3><a id="4docker_600"></a>4、清理docker占用的磁盘空间</h3> 
<pre><code>docker system prune -a  #可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络
</code></pre> 
<p><img src="https://images2.imgbox.com/d3/74/Dak27TEw_o.png" alt="img"></p> 
<h2><a id="Docker_610"></a>六、Docker的数据管理</h2> 
<h3><a id="1Docker_612"></a>1、管理Docker容器的方式</h3> 
<p>管理Docker容器中数据主要有2种方式：数据卷（Data Volumes）和数据卷容器（DataVolumes Containers）</p> 
<h3><a id="2_616"></a>2、数据卷</h3> 
<p>（1）定义</p> 
<p>数据卷是一个供容器使用的特殊目录，位于容器中。可将宿主机的目录挂载到数据卷上，对数据卷的修改操作立刻可见，并且更新数据不会影响镜像，从而实现数据在宿主机与容器之间的迁移。数据卷的使用类似于Linux下对目录进行的mount操作</p> 
<p>（2）创建格式</p> 
<pre><code>docker run -itd -v /var/www:/data1 --name web1 centos:7 /bin/bash  #宿主机目录/var/www挂载到容器中的/data1
 
-v:在容器内创建数据卷
注意:宿主机本地目录的路径必须是使用绝对路径。如果路径不存在，Docker会自动创建相应的路径
</code></pre> 
<p><img src="https://images2.imgbox.com/3d/35/iDuUjv0y_o.png" alt="img"></p> 
<p>（3）创建文件测试</p> 
<pre><code>1.在宿主机的挂载目录创建文件测试数据卷
2.在数据卷创建文件测试宿主机的挂载目录
</code></pre> 
<p><img src="https://images2.imgbox.com/2f/2f/v2A96o0k_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/29/a7/2Q1WYxqn_o.png" alt="img"></p> 
<h3><a id="3_644"></a>3、数据卷容器</h3> 
<p>（1）定义</p> 
<p>如果需要在容器之间共享一些数据，最简单的方法就是使用数据卷容器。数据卷容器是一个普通的容器，专门提供数据卷给其他容器挂载使用</p> 
<p>（2）创建一个容器作为数据卷容器</p> 
<pre><code>docker run -itd --name web2 -v /data1 -v /data2 -v /data3 centos:7 /bin/bash               
docker exec -it 7089958811d3 bash  #进入数据卷容器
echo "11111" &gt; /data1/123.txt
echo "22222" &gt; /data2/456.txt
echo "33333" &gt; /data3/789.txt
exit
</code></pre> 
<p><img src="https://images2.imgbox.com/40/81/eEdBmALe_o.png" alt="img"></p> 
<p>（3）挂载数据卷容器中的数据卷到新的容器</p> 
<pre><code>使用--volumes-from来挂载web2容器中的数据卷到新的容器
 
docker run -itd --volumes-from web2 --name web3 centos:7 /bin/bash
docker exec -it 02c46e912b19 bash   #进入新容器
cat /data1/123.txt
cat /data2/456.txt
cat /data3/789.txt
</code></pre> 
<p><img src="https://images2.imgbox.com/fc/b6/1ZhwO6Hs_o.png" alt="img"></p> 
<h2><a id="centos_677"></a>七、容器互联（使用centos镜像）</h2> 
<h3><a id="1_679"></a>1、定义</h3> 
<p>容器互联是通过容器的名称在容器间建立一条专门的网络通信隧道。简单点说，就是会在源容器和接收容器之间建立一条隧道，接收容器可以看到源容器指定的信息</p> 
<h3><a id="2_683"></a>2、创建容器互联</h3> 
<pre><code>1.#创建并运行源容器取名web1
docker run -itd -P --name web1 centos:7 /bin/bash
2.#创建并运行接收容器取名web2，使用--1ink选项指定连接容器以实现容器互联
3.docker run -itd -P --name web2 --link web1:jc centos:7 /bin/bash      #--link容器名:连接的别名
4.#进web2容器，ping sb/web1
docker exec -it web2 bash
ping web1/jc
</code></pre> 
<p><img src="https://images2.imgbox.com/9d/c8/oQ4uNnJn_o.png" alt="img"></p> 
<p><img src="https://images2.imgbox.com/9b/0c/qOecwYN7_o.png" alt="img"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e05d48b93da5f8b3f5159bd6a21beb8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">调用函数，求加减乘除（基础）。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b9e88cd95fcb6e69b77076fabc495ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UI自动化测试工具-UFT-Object Repository | Local Object Repository</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>