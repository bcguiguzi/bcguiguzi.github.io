<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CompletableFuture在异常处理方面的一些常见问题和解决方案，建议牢记！ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CompletableFuture在异常处理方面的一些常见问题和解决方案，建议牢记！" />
<meta property="og:description" content="在Java并发编程中，CompletableFuture是一个强大的工具，可以帮助我们实现异步编程。它提供了丰富的方法来处理异步操作的结果和异常。然而，当使用CompletableFuture处理异常时，我们可能会遇到一些坑。本文将详细介绍CompletableFuture在异常处理方面的一些常见问题和解决方案。
CompletableFuture简介 CompletableFuture是Java 8引入的一个类，位于java.util.concurrent包下。它提供了一种方便的方式来进行异步编程，尤其是在处理一系列并发任务时非常有用。
CompletableFuture支持链式调用和组合多个异步任务。我们可以通过调用各种方法来注册回调函数，在任务完成时获取结果或处理异常。
异常处理的常见陷阱 在使用CompletableFuture处理异常时，有几个常见的陷阱可能会导致错误的结果或难以调试的问题。下面是其中一些值得注意的陷阱：
1. 异常被吞噬 在CompletableFuture中，如果一个阶段发生异常并且没有适当处理，异常可能会被吞噬而不会传播到后续阶段。这可能导致我们无法及时发现并处理潜在的问题。
例如，考虑以下代码片段：
java复制代码CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; { throw new RuntimeException(&#34;Oops!&#34;); }); CompletableFuture&lt;String&gt; result = future.thenApply(i -&gt; &#34;Success: &#34; &#43; i); result.join(); // 此处不会抛出异常 在上面的代码中，当我们调用result.join()时，并没有抛出预期的异常。这是因为在future阶段抛出的异常没有正确地传播到result阶段。
2. 异常处理丢失 有时，我们可能会使用CompletableFuture的exceptionally方法来处理异常，并返回一个默认值或执行其他操作。然而，如果我们在exceptionally方法中不正确地处理异常，就会导致异常被丢失。
java复制代码CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; { throw new RuntimeException(&#34;Oops!&#34;); }); CompletableFuture&lt;String&gt; result = future.exceptionally(ex -&gt; { System.out.println(&#34;Error occurred: &#34; &#43; ex); return &#34;Default Value&#34;; }); result.join(); // 此处不会输出错误信息 在上面的代码中，虽然我们在exceptionally方法中打印了错误信息，但是在调用result.join()时，并没有输出预期的错误信息。这是因为exceptionally方法只是对异常进行处理，并返回了一个默认值，而并没有将异常传播到后续阶段。
3. 异常处理导致堆栈追踪丢失 在使用CompletableFuture时，有时我们可能需要将异常重新抛出，以便在调用链的更高层进行处理或记录堆栈追踪信息。然而，如果我们不小心处理异常并重新抛出时，可能会导致堆栈追踪信息丢失。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4236cb33a86de09c3d19b45e77ac72e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-29T13:19:12+08:00" />
<meta property="article:modified_time" content="2023-06-29T13:19:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CompletableFuture在异常处理方面的一些常见问题和解决方案，建议牢记！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在Java并发编程中，CompletableFuture是一个强大的工具，可以帮助我们实现异步编程。它提供了丰富的方法来处理异步操作的结果和异常。然而，当使用CompletableFuture处理异常时，我们可能会遇到一些坑。本文将详细介绍CompletableFuture在异常处理方面的一些常见问题和解决方案。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ea/86/Y6gM51kJ_o.png"></p> 
<h2>CompletableFuture简介</h2> 
<p>CompletableFuture是Java 8引入的一个类，位于java.util.concurrent包下。它提供了一种方便的方式来进行异步编程，尤其是在处理一系列并发任务时非常有用。</p> 
<p>CompletableFuture支持链式调用和组合多个异步任务。我们可以通过调用各种方法来注册回调函数，在任务完成时获取结果或处理异常。</p> 
<h2>异常处理的常见陷阱</h2> 
<p>在使用CompletableFuture处理异常时，有几个常见的陷阱可能会导致错误的结果或难以调试的问题。下面是其中一些值得注意的陷阱：</p> 
<h2>1. 异常被吞噬</h2> 
<p>在CompletableFuture中，如果一个阶段发生异常并且没有适当处理，异常可能会被吞噬而不会传播到后续阶段。这可能导致我们无法及时发现并处理潜在的问题。</p> 
<p>例如，考虑以下代码片段：</p> 
<pre><code>java复制代码CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException("Oops!");
});

CompletableFuture&lt;String&gt; result = future.thenApply(i -&gt; "Success: " + i);

result.join(); // 此处不会抛出异常
</code></pre> 
<p>在上面的代码中，当我们调用result.join()时，并没有抛出预期的异常。这是因为在future阶段抛出的异常没有正确地传播到result阶段。</p> 
<h2>2. 异常处理丢失</h2> 
<p>有时，我们可能会使用CompletableFuture的exceptionally方法来处理异常，并返回一个默认值或执行其他操作。然而，如果我们在exceptionally方法中不正确地处理异常，就会导致异常被丢失。</p> 
<pre><code>java复制代码CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException("Oops!");
});

CompletableFuture&lt;String&gt; result = future.exceptionally(ex -&gt; {
    System.out.println("Error occurred: " + ex);
    return "Default Value";
});

result.join(); // 此处不会输出错误信息
</code></pre> 
<p>在上面的代码中，虽然我们在exceptionally方法中打印了错误信息，但是在调用result.join()时，并没有输出预期的错误信息。这是因为exceptionally方法只是对异常进行处理，并返回了一个默认值，而并没有将异常传播到后续阶段。</p> 
<h2>3. 异常处理导致堆栈追踪丢失</h2> 
<p>在使用CompletableFuture时，有时我们可能需要将异常重新抛出，以便在调用链的更高层进行处理或记录堆栈追踪信息。然而，如果我们不小心处理异常并重新抛出时，可能会导致堆栈追踪信息丢失。</p> 
<pre><code>java复制代码CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException("Oops!");
});

CompletableFuture&lt;String&gt; result = future.thenApply(i -&gt; {
    try {
        return process(i);
    } catch (Exception ex) {
        throw new RuntimeException("Error occurred: " + ex.getMessage());
    }
});

result.join(); // 此处堆栈追踪信息丢失
</code></pre> 
<p>在上面的代码中，我们在thenApply方法中捕获异常，并通过重新抛出RuntimeException来处理异常。然而，在调用result.join()时，我们会发现堆栈追踪信息已经丢失了。这是因为我们重新抛出的异常并没有将原始异常的堆栈追踪信息包含在内。</p> 
<h2>4. 异常处理过于冗长</h2> 
<p>在处理多个CompletableFuture链时，如果每个阶段都需要处理异常，可能会导致代码变得冗长和复杂。每个阶段都需要使用exceptionally或handle方法来处理异常，使代码难以维护和理解。</p> 
<pre><code>java复制代码CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException("Oops!");
});

CompletableFuture&lt;String&gt; future2 = future1.thenApply(i -&gt; {
    try {
        return process(i);
    } catch (Exception ex) {
        throw new RuntimeException("Error occurred: " + ex.getMessage());
    }
}).exceptionally(ex -&gt; {
    System.out.println("Error occurred: " + ex);
    return "Default Value";
});

String result = future2.join();
</code></pre> 
<p>在上面的代码中，我们需要在每个阶段中都处理异常，使代码变得冗长。当存在多个链式调用时，异常处理逻辑会更加复杂。</p> 
<h2>异常处理的解决方案</h2> 
<p>为了避免上述陷阱和问题，我们可以采用一些解决方案来更好地处理CompletableFuture中的异常。</p> 
<h2>1. 使用whenComplete方法</h2> 
<p>whenComplete方法可以在任务完成时触发回调函数，无论是正常完成还是发生异常。通过在whenComplete方法中处理异常，我们可以确保异常得到正确的传播和处理。</p> 
<pre><code>java复制代码CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException("Oops!");
});

CompletableFuture&lt;String&gt; result = future.thenApply(i -&gt; "Success: " + i)
        .whenComplete((res, ex) -&gt; {
            if (ex != null) {
                System.out.println("Error occurred: " + ex);
            }
        });

result.join(); // 此处会输出错误信息
</code></pre> 
<p>在上面的代码中，我们使用whenComplete方法来处理异常。在回调函数中，我们检查ex参数是否为null，如果不为null，则说明发生了异常，并进行相应的处理。这样，异常就能够正确地传播并在需要时进行处理。</p> 
<h2>2. 使用exceptionally方法处理异常</h2> 
<p>exceptionally方法可以用于处理异常，并返回一个默认值或执行其他操作。在使用exceptionally方法时，我们需要确保正确地处理异常并重新抛出，以便异常能够传播到后续阶段。</p> 
<pre><code>java复制代码CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException("Oops!");
});

CompletableFuture&lt;String&gt; result = future.thenApply(i -&gt; "Success: " + i)
        .exceptionally(ex -&gt; {
            System.out.println("Error occurred: " + ex);
            throw new RuntimeException("Error occurred: " + ex);
        });

result.join(); // 此处会抛出重新抛出的异常
</code></pre> 
<p>在上面的代码中，我们使用exceptionally方法处理异常。在异常处理函数中，我们打印错误信息并重新抛出异常。这样，异常就能够正确地传播到后续阶段。</p> 
<h2>3. 使用handle方法处理异常</h2> 
<p>handle方法可以用于处理异常，并根据需要返回一个新的结果。与exceptionally方法不同的是，handle方法可以处理正常的返回结果和异常，并返回一个新的结果。</p> 
<pre><code>java复制代码CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException("Oops!");
});

CompletableFuture&lt;String&gt; result = future.handle((res, ex) -&gt; {
    if (ex != null) {
        System.out.println("Error occurred: " + ex);
        return "Default Value";
    } else {
        return "Success: " + res;
    }
});

result.join(); // 此处会返回默认值
</code></pre> 
<p>在上面的代码中，我们使用handle方法处理异常。在处理函数中，我们检查异常是否为null，如果不为null，则说明发生了异常并返回一个默认值。否则，我们返回正常的结果。</p> 
<h2>4. 使用CompletableFuture.allOf组合多个CompletableFuture</h2> 
<p>当需要处理多个CompletableFuture时，我们可以使用CompletableFuture.allOf方法来组合它们，并在所有任务完成后进行处理。通过使用whenComplete或exceptionally方法，我们可以处理所有任务的异常，并确保异常正确地传播和处理。</p> 
<pre><code>java复制代码CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; {
    throw new RuntimeException("Oops!");
});

CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; 42);

CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(future1, future2);

combinedFuture.whenComplete((res, ex) -&gt; {
    if (ex != null) {
        System.out.println("Error occurred: " + ex);
    }
});

combinedFuture.join(); // 此处会输出错误信息
</code></pre> 
<p>在上面的代码中，我们使用CompletableFuture.allOf方法组合了future1和future2，并使用whenComplete方法处理异常。通过这种方式，我们可以在所有任务完成后统一处理异常，并确保异常正确地传播。</p> 
<h2>总结</h2> 
<p>CompletableFuture提供了强大的功能来处理异步编程中的结果和异常。然而，在处理异常时，我们需要注意一些常见的陷阱。这包括异常被吞噬、异常处理丢失、堆栈追踪丢失和异常处理过于冗长。</p> 
<p>为了解决这些问题，我们可以采用一些解决方案。首先，使用whenComplete方法可以在任务完成时触发回调函数，并正确地处理异常。其次，使用exceptionally方法可以处理异常并重新抛出，以便异常能够传播到后续阶段。另外，使用handle方法可以处理正常的返回结果和异常，并返回一个新的结果。最后，使用CompletableFuture.allOf方法可以组合多个CompletableFuture，并统一处理所有任务的异常。</p> 
<p>通过避免陷阱并采用正确的异常处理方法，我们可以更好地利用CompletableFuture的功能，提高代码的可靠性和可维护性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/963b4dbd2f41c607dc963511cf6bf52a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter中的Web应用程序开发：构建现代Web应用程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2b43756347dd676cc66bbd4798770f15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">django中migrate和makemigrations 区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>