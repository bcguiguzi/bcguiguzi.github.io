<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[联邦学习] FedAvg聚合算法详解及代码实现 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[联邦学习] FedAvg聚合算法详解及代码实现" />
<meta property="og:description" content="该文章首发于若绾 [联邦学习] FedAvg聚合算法详解及代码实现,转载请标注出处。
论文原文：Communication-Efficient Learning of Deep Networks from Decentralized Data
概述 在现代计算机科学中，机器学习被广泛应用于各种领域。然而，机器学习需要大量的数据才能达到最佳性能。在某些情况下，由于数据隐私和安全的原因，集中式训练模型可能不可行。这就是联邦学习的概念出现的原因。联邦学习是一种机器学习范式，其中模型在本地设备上训练，而不是在集中式服务器上训练。本篇博客将介绍一种常用的联邦学习算法——FedAvg。
FedAvg是一种常用的联邦学习算法，它通过加权平均来聚合模型参数。FedAvg的基本思想是将本地模型的参数上传到服务器，服务器计算所有模型参数的平均值，然后将这个平均值广播回所有本地设备。这个过程可以迭代多次，直到收敛。
为了保证模型聚合的准确性，FedAvg算法采用加权平均的方式进行模型聚合。具体来说，每个设备上传的模型参数将赋予一个权重，然后进行加权平均。设备上传的模型参数的权重是根据设备上的本地数据量大小进行赋值的，数据量越多的设备权重越大。
FedAvg的优势 与其他联邦学习算法相比，FedAvg有以下优点：
低通信开销：由于只需要上传本地模型参数，因此通信开销较低。
支持异质性数据：由于本地设备可以使用不同的数据集，因此FedAvg可以处理异质性数据。
泛化性强：FedAvg算法通过全局模型聚合，利用所有设备上的本地数据训练全局模型，从而提高了模型的精度和泛化性能。
FedAvg的缺点 尽管FedAvg具有许多优点，但它仍然存在一些缺点：
需要协调：由于需要协调多个本地设备的计算，因此FedAvg需要一个中心化的协调器来执行此任务。这可能会导致性能瓶颈或单点故障。
数据不平衡问题：在FedAvg算法中，每个设备上传的模型参数的权重是根据设备上的本地数据量大小进行赋值的。这种方式可能会导致数据不平衡的问题，即数据量较小的设备对全局模型的贡献较小，从而影响模型的泛化性能。
FedAvg的算法流程 伪代码 详解 服务器初始化全局模型参数 w 0 w_0 w0​；
所有本地设备随机选择一部分数据集，并在本地计算本地模型参数 w i w_i wi​；
所有本地设备上传本地模型参数 w i w_i wi​ 到服务器；
服务器计算所有本地模型参数的加权平均值 w ˉ \bar{w} wˉ，并广播到所有本地设备；
所有本地设备采用 w ˉ \bar{w} wˉ 作为本地模型参数的初始值，重复步骤2~4，直到全局模型收敛。
代码实现 Code def fedavg(self): # FedAvg with weight total_samples = sum(self.num_samples) base = [0] * len(self." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/b25c68c0d2dddac1b164b231355c26ba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-06T00:03:59+08:00" />
<meta property="article:modified_time" content="2023-04-06T00:03:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[联邦学习] FedAvg聚合算法详解及代码实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>该文章首发于<a href="https://www.royc30ne.com/fedavg/" rel="nofollow">若绾 [联邦学习] FedAvg聚合算法详解及代码实现</a>,转载请标注出处。<br> <strong>论文原文：<a href="https://proceedings.mlr.press/v54/mcmahan17a/mcmahan17a.pdf" rel="nofollow">Communication-Efficient Learning of Deep Networks from Decentralized Data</a></strong></p> 
<h3><a id="_3"></a>概述</h3> 
<p>在现代计算机科学中，机器学习被广泛应用于各种领域。然而，机器学习需要大量的数据才能达到最佳性能。在某些情况下，由于数据隐私和安全的原因，集中式训练模型可能不可行。这就是联邦学习的概念出现的原因。联邦学习是一种机器学习范式，其中模型在本地设备上训练，而不是在集中式服务器上训练。本篇博客将介绍一种常用的联邦学习算法——FedAvg。</p> 
<p>FedAvg是一种常用的联邦学习算法，它通过加权平均来聚合模型参数。FedAvg的基本思想是将本地模型的参数上传到服务器，服务器计算所有模型参数的平均值，然后将这个平均值广播回所有本地设备。这个过程可以迭代多次，直到收敛。</p> 
<p>为了保证模型聚合的准确性，FedAvg算法采用加权平均的方式进行模型聚合。具体来说，每个设备上传的模型参数将赋予一个权重，然后进行加权平均。设备上传的模型参数的权重是根据设备上的本地数据量大小进行赋值的，数据量越多的设备权重越大。</p> 
<h3><a id="FedAvg_11"></a>FedAvg的优势</h3> 
<p>与其他联邦学习算法相比，FedAvg有以下优点：</p> 
<ul><li> <p>低通信开销：由于只需要上传本地模型参数，因此通信开销较低。</p> </li><li> <p>支持异质性数据：由于本地设备可以使用不同的数据集，因此FedAvg可以处理异质性数据。</p> </li><li> <p>泛化性强：FedAvg算法通过全局模型聚合，利用所有设备上的本地数据训练全局模型，从而提高了模型的精度和泛化性能。</p> </li></ul> 
<h3><a id="FedAvg_21"></a>FedAvg的缺点</h3> 
<p>尽管FedAvg具有许多优点，但它仍然存在一些缺点：</p> 
<ul><li> <p>需要协调：由于需要协调多个本地设备的计算，因此FedAvg需要一个中心化的协调器来执行此任务。这可能会导致性能瓶颈或单点故障。</p> </li><li> <p>数据不平衡问题：在FedAvg算法中，每个设备上传的模型参数的权重是根据设备上的本地数据量大小进行赋值的。这种方式可能会导致数据不平衡的问题，即数据量较小的设备对全局模型的贡献较小，从而影响模型的泛化性能。</p> </li></ul> 
<h3><a id="FedAvg_29"></a>FedAvg的算法流程</h3> 
<h4><a id="_31"></a>伪代码</h4> 
<p><img src="https://images2.imgbox.com/59/d9/YCKDwgja_o.png" alt="fedavg-pseudocode.png"></p> 
<h4><a id="_35"></a>详解</h4> 
<ol><li> <p>服务器初始化全局模型参数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            w 
           
          
            0 
           
          
         
        
          w_0 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3011em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>；</p> </li><li> <p>所有本地设备随机选择一部分数据集，并在本地计算本地模型参数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            w 
           
          
            i 
           
          
         
        
          w_i 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span>；</p> </li><li> <p>所有本地设备上传本地模型参数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            w 
           
          
            i 
           
          
         
        
          w_i 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span class="" style="top: -2.55em; margin-left: -0.0269em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span> 到服务器；</p> </li><li> <p>服务器计算所有本地模型参数的加权平均值 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            w 
           
          
            ˉ 
           
          
         
        
          \bar{w} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5678em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.5678em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.1667em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span></span>，并广播到所有本地设备；</p> </li><li> <p>所有本地设备采用 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            w 
           
          
            ˉ 
           
          
         
        
          \bar{w} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.5678em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.5678em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord mathnormal" style="margin-right: 0.0269em;">w</span></span><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="accent-body" style="left: -0.1667em;"><span class="mord">ˉ</span></span></span></span></span></span></span></span></span></span></span> 作为本地模型参数的初始值，重复步骤2~4，直到全局模型收敛。</p> </li></ol> 
<h3><a id="_Code_47"></a>代码实现 Code</h3> 
<pre><code>def fedavg(self):
        # FedAvg with weight
        total_samples = sum(self.num_samples)
        base = [0] * len(self.weights[0])
        for i, client_weight in enumerate(self.weights):
            total_samples += self.num_samples[i]
            for j, v in enumerate(client_weight):
                base[j] += (self.num_samples[i] / total_samples * v.astype(np.float64))

        # Update the model
        return base
</code></pre> 
<h3><a id="_63"></a>结论</h3> 
<p>总体来说，FedAvg算法是一种有效的联邦学习算法，能够在保护隐私数据的同时，利用本地数据训练全局模型，降低通信开销和支持分布式设备，同时提高模型的精度和泛化性能。随着联邦学习的发展和应用场景的不断扩大，FedAvg算法的研究和应用也将不断深入。未来，FedAvg算法有望在算法优化、隐私保护、模型压缩等方面得到进一步改进，并应用于更多的领域和场景中。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c440e06f31e2eaf8bd80dbf5cc497245/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MPU6050 简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67526e6bcc15d8657224df9cd0bd7493/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CentOS7设置阿里源</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>