<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Node.js 多进程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Node.js 多进程" />
<meta property="og:description" content="我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。
每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。
Node 提供了 child_process 模块来创建子进程，方法有：
exec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。
spawn - child_process.spawn 使用指定的命令行参数创建新进程。
fork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(&#39;./son.js&#39;) 相当于 spawn(&#39;node&#39;, [&#39;./son.js&#39;]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。
exec() 方法 child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。
语法如下所示：
child_process.exec(command[, options], callback) 参数 参数说明如下：
command： 字符串， 将要运行的命令，参数使用空格隔开
options ：对象，可以是：
cwd ，字符串，子进程的当前工作目录env，对象 环境变量键值对encoding ，字符串，字符编码（默认： &#39;utf8&#39;）shell ，字符串，将要执行命令的 Shell（默认: 在 UNIX 中为/bin/sh， 在 Windows 中为cmd.exe， Shell 应当能识别 -c开关在 UNIX 中，或 /s /c 在 Windows 中。 在Windows 中，命令行解析应当能兼容cmd." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/be65019964ef7c6fd9d2ab08930640c7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-20T08:14:12+08:00" />
<meta property="article:modified_time" content="2023-05-20T08:14:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Node.js 多进程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p> 
<p>每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。</p> 
<p>Node 提供了 child_process 模块来创建子进程，方法有：</p> 
<ul><li> <p><strong>exec</strong> - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</p> </li><li> <p><strong>spawn</strong> - child_process.spawn 使用指定的命令行参数创建新进程。</p> </li><li> <p><strong>fork</strong> - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork('./son.js') 相当于 spawn('node', ['./son.js']) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</p> </li></ul> 
<hr> 
<h3>exec() 方法</h3> 
<p>child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</p> 
<p>语法如下所示：</p> 
<pre>child_process.exec(command[, options], callback)</pre> 
<h4>参数</h4> 
<p>参数说明如下：</p> 
<p><strong>command：</strong> 字符串， 将要运行的命令，参数使用空格隔开</p> 
<p><strong>options ：对象，可以是：</strong></p> 
<ul><li>cwd ，字符串，子进程的当前工作目录</li><li>env，对象 环境变量键值对</li><li>encoding ，字符串，字符编码（默认： 'utf8'）</li><li>shell ，字符串，将要执行命令的 Shell（默认: 在 UNIX 中为<code>/bin/sh</code>， 在 Windows 中为<code>cmd.exe</code>， Shell 应当能识别 <code>-c</code>开关在 UNIX 中，或 <code>/s /c</code> 在 Windows 中。 在Windows 中，命令行解析应当能兼容<code>cmd.exe</code>）</li><li>timeout，数字，超时时间（默认： 0）</li><li>maxBuffer，数字， 在 stdout 或 stderr 中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死 （默认: 200*1024）</li><li>killSignal ，字符串，结束信号（默认：'SIGTERM'）</li><li>uid，数字，设置用户进程的 ID</li><li>gid，数字，设置进程组的 ID</li></ul> 
<p><strong>callback ：</strong>回调函数，包含三个参数error, stdout 和 stderr。</p> 
<p>exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。</p> 
<h4>实例</h4> 
<p>让我们创建两个 js 文件 support.js 和 master.js。</p> 
<h3>support.js 文件代码：</h3> 
<p>console.log("进程 " + process.argv[2] + " 执行。" );</p> 
<h3>master.js 文件代码：</h3> 
<p>const fs = require('fs'); const child_process = require('child_process'); for(var i=0; i&lt;3; i++) { var workerProcess = child_process.exec('node support.js '+i, function (error, stdout, stderr) { if (error) { console.log(error.stack); console.log('Error code: '+error.code); console.log('Signal received: '+error.signal); } console.log('stdout: ' + stdout); console.log('stderr: ' + stderr); }); workerProcess.on('exit', function (code) { console.log('子进程已退出，退出码 '+code); }); }</p> 
<p>执行以上代码，输出结果为：</p> 
<pre>$ node master.js 
子进程已退出，退出码 0
stdout: 进程 1 执行。

stderr: 
子进程已退出，退出码 0
stdout: 进程 0 执行。

stderr: 
子进程已退出，退出码 0
stdout: 进程 2 执行。

stderr: </pre> 
<hr> 
<h3>spawn() 方法</h3> 
<p>child_process.spawn 使用指定的命令行参数创建新进程，语法格式如下：</p> 
<pre>child_process.spawn(command[, args][, options])</pre> 
<h4>参数</h4> 
<p>参数说明如下：</p> 
<p><strong>command：</strong> 将要运行的命令</p> 
<p><strong>args：</strong> Array 字符串参数数组</p> 
<p><strong>options Object</strong></p> 
<ul><li>cwd String 子进程的当前工作目录</li><li>env Object 环境变量键值对</li><li>stdio Array|String 子进程的 stdio 配置</li><li>detached Boolean 这个子进程将会变成进程组的领导</li><li>uid Number 设置用户进程的 ID</li><li>gid Number 设置进程组的 ID</li></ul> 
<p>spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。</p> 
<h4>实例</h4> 
<p>让我们创建两个 js 文件 support.js 和 master.js。</p> 
<h3>support.js 文件代码：</h3> 
<p>console.log("进程 " + process.argv[2] + " 执行。" );</p> 
<h3>master.js 文件代码：</h3> 
<p>const fs = require('fs'); const child_process = require('child_process'); for(var i=0; i&lt;3; i++) { var workerProcess = child_process.spawn('node', ['support.js', i]); workerProcess.stdout.on('data', function (data) { console.log('stdout: ' + data); }); workerProcess.stderr.on('data', function (data) { console.log('stderr: ' + data); }); workerProcess.on('close', function (code) { console.log('子进程已退出，退出码 '+code); }); }</p> 
<p>执行以上代码，输出结果为：</p> 
<pre>$ node master.js stdout: 进程 0 执行。

子进程已退出，退出码 0
stdout: 进程 1 执行。

子进程已退出，退出码 0
stdout: 进程 2 执行。

子进程已退出，退出码 0</pre> 
<hr> 
<h3>fork 方法</h3> 
<p>child_process.fork 是 spawn() 方法的特殊形式，用于创建进程，语法格式如下：</p> 
<pre>child_process.fork(modulePath[, args][, options])</pre> 
<h4>参数</h4> 
<p>参数说明如下：</p> 
<p><strong>modulePath</strong>： String，将要在子进程中运行的模块</p> 
<p><strong>args</strong>： Array 字符串参数数组</p> 
<p><strong>options</strong>：Object</p> 
<ul><li>cwd String 子进程的当前工作目录</li><li>env Object 环境变量键值对</li><li>execPath String 创建子进程的可执行文件</li><li>execArgv Array 子进程的可执行文件的字符串参数数组（默认： process.execArgv）</li><li>silent Boolean 如果为<code>true</code>，子进程的<code>stdin</code>，<code>stdout</code>和<code>stderr</code>将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：<code>false</code>）</li><li>uid Number 设置用户进程的 ID</li><li>gid Number 设置进程组的 ID</li></ul> 
<p>返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。</p> 
<h4>实例</h4> 
<p>让我们创建两个 js 文件 support.js 和 master.js。</p> 
<h3>support.js 文件代码：</h3> 
<p>console.log("进程 " + process.argv[2] + " 执行。" );</p> 
<h3>master.js 文件代码：</h3> 
<p>const fs = require('fs'); const child_process = require('child_process'); for(var i=0; i&lt;3; i++) { var worker_process = child_process.fork("support.js", [i]); worker_process.on('close', function (code) { console.log('子进程已退出，退出码 ' + code); }); }</p> 
<p>执行以上代码，输出结果为：</p> 
<pre>$ node master.js 
进程 0 执行。
子进程已退出，退出码 0
进程 1 执行。
子进程已退出，退出码 0
进程 2 执行。
子进程已退出，退出码 0</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/800cbf75612b5b34e0fccd4443bef301/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于jQuery的在线商城设计与实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7da1d29aefb5d69b432f9ce1564bdf37/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">蓝桥杯题单day3【题目】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>