<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM -- 垃圾回收；垃圾回收算法（三） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM -- 垃圾回收；垃圾回收算法（三）" />
<meta property="og:description" content="阅读前可参考 https://blog.csdn.net/MinggeQingchun/article/details/126947384
https://blog.csdn.net/MinggeQingchun/article/details/127066302
一、标记对象是否为垃圾 JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。
其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。
而Java堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分
（一）引用计数法 引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器&#43;1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1
优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。
缺点：无法检测出循环引用。 如A对象有一个对B对象的引用，B对象反过来引用A对象。这样，他们的引用计数永远不可能为0
JVM并未采取此种方式，而是可达性分析
（二）可达性分析 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
可达性算法是目前主流的虚拟机都采用的算法，程序把所有的引用关系看作一张图，从一个节点GC Roots开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。
在Java语言中，可作为GC Roots的对象包括下面几种：
（1）虚拟机栈中引用的对象（栈帧中的本地变量表）
（2）方法区中类静态属性引用的对象
（3）方法区中常量引用的对象
（4）本地方法栈中JNI（Native方法）引用的对象
从上图中，reference1、 reference2、reference3都是 GC Root
reference1 --&gt; 对象实例1
reference2 --&gt; 对象实例2
reference3 --&gt; 对象实例4 --&gt; 对象实例6
可以得出对象实例1、2、4、6都具有对象可达性，也就是存活对象，不能被GC回收的对象。而随想实例3、5虽然直接相连，但并没有任何一个GC Roots与之相连，即GC Roots不可达对象，就会被GC回收的对象
二、垃圾回收原理 垃圾回收 GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、老年代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停
堆内存被划分为两块，一块的年轻代，另一块是老年代。老年代：年轻代比例为2:1
年轻代又分为Eden和survivor。他俩空间大小比例默认为8:2
幸存区又分为s0（From Space）和s1（To Space）。这两个空间大小是一模一样的，就是一对双胞胎，他俩是1:1的比例
堆内存垃圾回收过程 1、新生成的对象首先放到Eden区（伊甸园区），当Eden区满了会触发Minor GC
2、第一步GC活下来的对象，会被移动到survivor区中的S0区（From Space），S0区满了之后会触发Minor GC，S0区存活下来的对象会被移动到S1区（To Space），S0区空闲
S1满了之后再GC，存活下来的对象再次移动到S0区，S1区空闲，这样反反复复GC，每GC一次，对象的年龄就涨一岁，达到某个阈值后（15），就会进入老年代
3、在发生一次Minor GC后（前提条件），老年代可能会出现Major GC，这个视垃圾回收器而定
Full GC触发条件
手动调用System.gc，会不断的执行Full GC" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f9f22bba5256e9db79c563a5418a113a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-06T12:06:56+08:00" />
<meta property="article:modified_time" content="2023-05-06T12:06:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM -- 垃圾回收；垃圾回收算法（三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>阅读前可参考</h4> 
<p><a href="https://blog.csdn.net/MinggeQingchun/article/details/126947384" title="https://blog.csdn.net/MinggeQingchun/article/details/126947384">https://blog.csdn.net/MinggeQingchun/article/details/126947384</a></p> 
<p><a href="https://blog.csdn.net/MinggeQingchun/article/details/127066302" title="https://blog.csdn.net/MinggeQingchun/article/details/127066302">https://blog.csdn.net/MinggeQingchun/article/details/127066302</a></p> 
<p></p> 
<h2>一、标记对象是否为垃圾</h2> 
<p>JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、堆区、方法区。</p> 
<p>其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。</p> 
<p>而Java堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分</p> 
<h3>（一）引用计数法</h3> 
<p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1</p> 
<ul><li> <p>优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p> </li><li> <p>缺点：<strong>无法检测出循环引用。</strong> 如A对象有一个对B对象的引用，B对象反过来引用A对象。这样，他们的引用计数永远不可能为0</p> </li></ul> 
<p><img alt="" height="146" src="https://images2.imgbox.com/25/14/AHEmthHI_o.png" width="396"></p> 
<p>JVM并未采取此种方式，而是可达性分析</p> 
<h3>（二）可达性分析</h3> 
<blockquote> 
 <p><span style="color:#ff9900;"><strong>Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</strong></span></p> 
</blockquote> 
<p>可达性算法是目前主流的虚拟机都采用的算法，程序把所有的引用关系看作一张图，从一个节点GC Roots开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。</p> 
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p> 
<p>（1）虚拟机栈中引用的对象（栈帧中的本地变量表）</p> 
<p>（2）方法区中类静态属性引用的对象</p> 
<p>（3）方法区中常量引用的对象</p> 
<p>（4）本地方法栈中JNI（Native方法）引用的对象</p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/93/d9/MzNuKLYK_o.png" width="717"></p> 
<p>从上图中，reference1、 reference2、reference3都是 GC Root</p> 
<p>reference1 --&gt; 对象实例1</p> 
<p>reference2 --&gt; 对象实例2</p> 
<p>reference3 --&gt; 对象实例4 --&gt; 对象实例6</p> 
<p>可以得出对象实例1、2、4、6都具有对象可达性，也就是存活对象，不能被GC回收的对象。而随想实例3、5虽然直接相连，但并没有任何一个GC Roots与之相连，即GC Roots不可达对象，就会被GC回收的对象</p> 
<p></p> 
<h2>二、垃圾回收原理</h2> 
<p>垃圾回收 GC (Garbage Collection)的基本原理：将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、老年代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停</p> 
<ul><li> <p>堆内存被划分为<code>两块</code>，一块的<code>年轻代</code>，另一块是<code>老年代。老年代：年轻代比例为2:1</code></p> </li><li> <p>年轻代又分为<code>Eden</code>和<code>survivor</code>。他俩空间大小比例默认为8:2</p> </li><li> <p>幸存区又分为<code>s0（</code>From Space<code>）</code>和<code>s1（</code>To Space<code>）</code>。这两个空间大小是一模一样的，就是一对双胞胎，他俩是1:1的比例</p> </li></ul> 
<h3><img alt="" src="https://images2.imgbox.com/df/5d/nb8yqByh_o.png"></h3> 
<p><img alt="" height="1022" src="https://images2.imgbox.com/5c/3e/pOCx3f3q_o.png" width="1200"></p> 
<blockquote> 
 <h3><span style="color:#fe2c24;"><strong>堆内存垃圾回收过程 </strong></span></h3> 
 <p>1、<code>新生成</code>的对象首先放到<span style="color:#ff9900;"><strong><code>Eden</code>区（伊甸园区</strong>）</span>，当Eden区<code>满了</code>会触发<span style="color:#ff9900;"><strong><code>Minor GC</code></strong></span></p> 
 <p></p> 
 <p>2、第一步GC活下来的对象，会被移动到<span style="color:#ff9900;"><strong><code>survivor</code>区</strong></span>中的<strong><span style="color:#ff9900;">S0区<code>（</code>From Space<code>）</code></span></strong>，<strong>S0区满了之后会触发<code>Minor GC</code>，S0区存活下来的对象会被移动到<span style="color:#ff9900;">S1区<code>（</code>To Space<code>）</code></span>，S0区空闲</strong></p> 
 <p></p> 
 <p><strong>S1满了之后再GC，存活下来的对象再次移动到S0区，S1区空闲</strong>，这样反反复复GC，每GC一次，对象的年龄就<code>涨一岁</code>，达到某个阈值后（15），就会进入<code>老年代</code></p> 
 <p></p> 
 <p>3、在发生一次<code>Minor GC</code>后（前提条件），老年代可能会出现<span style="color:#ff9900;"><strong><code>Major GC</code></strong></span>，这个视垃圾回收器而定</p> 
 <p></p> 
 <p>Full GC触发条件</p> 
 <ul><li> <p>手动调用System.gc，会不断的执行Full GC</p> </li><li> <p>老年代空间不足/满了</p> </li><li> <p>方法区空间不足/满了</p> </li></ul> 
</blockquote> 
<blockquote> 
 <h3><strong><span style="color:#fe2c24;"><code>stop-the-world</code></span></strong>（STW）</h3> 
 <p><code>stop-the-world</code>会在任何一种GC算法中发生。stop-the-world 意味着JVM因为需要执行GC而<code>停止</code>应用程序的执行。</p> 
 <p>当stop-the-world 发生时，除GC所需的线程外，所有的<code>线程</code>都进入<code>等待</code>状态，直到GC任务完成。GC优化很多时候就是减少stop-the-world 的发生</p> 
</blockquote> 
<blockquote> 
 <p><strong>JVM GC只回收<code>堆内存</code>和<code>方法区内</code>的对象。而<code>栈内存</code>的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内</strong></p> 
</blockquote> 
<p>可参考</p> 
<p><a href="http://t.zoukankan.com/itlaoge-p-14219646.html" rel="nofollow" title="7种jvm垃圾回收器，这次全部搞懂 - 走看看">7种jvm垃圾回收器，这次全部搞懂 - 走看看</a></p> 
<h4>1、Minor GC</h4> 
<p>对新生代的对象的收集</p> 
<p>Minor GC指新生代GC，即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作，当新生代无法为新生对象分配内存空间的时候，会触发Minor GC。因为新生代中大多数对象的生命周期都很短，所以发生Minor GC的频率很高，虽然它会触发stop-the-world，但是它的回收速度很快</p> 
<h4>2、Major GC</h4> 
<p>对老年代的对象的收集</p> 
<p>Major GC清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC</p> 
<h4>3、Full GC</h4> 
<p>程序中主动调用System.gc()强制执行的GC</p> 
<p>Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代 永久代perm gen）的全局范围的GC。Full GC不等于Major GC，也不等于Minor GC+Major GC，发生Full GC需要看使用了什么垃圾收集器组合，才能解释是什么样的垃圾回收</p> 
<p></p> 
<h2>三、五种引用</h2> 
<p>1、强引用</p> 
<p>2、软引用</p> 
<p>3、弱引用</p> 
<p>4、虚引用</p> 
<p>5、终结器引用</p> 
<h3>（一）强引用</h3> 
<p>只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</p> 
<h3>（二）软引用（SoftReference）</h3> 
<p>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足时会再次触发垃圾回收</strong>，回收软引用 对象 可以配合引用队列来释放软引用自身</p> 
<p>如下代码，VM设置对打堆内存20M，注释部分运行循环5次后就会报错堆内存溢出</p> 
<pre><code class="language-java">/**
 * 软引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class GC2SoftReference {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) throws IOException {
        //java.lang.OutOfMemoryError: Java heap space
        /*List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            list.add(new byte[_4MB]);
        }
        System.in.read();*/

        //软引用
        soft();
    }

    public static void soft() {
        // list --&gt; SoftReference --&gt; byte[]

        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB]);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());

        }
        System.out.println("循环结束：" + list.size());
        for (SoftReference&lt;byte[]&gt; ref : list) {
            System.out.println(ref.get());
        }
    }
}</code></pre> 
<p>使用软引用输出，取值查看时前4个对象都被回收，只有第5个对象存在 </p> 
<p><img alt="" height="360" src="https://images2.imgbox.com/d5/25/F3v1U6qh_o.png" width="117"></p> 
<p>VM加入参数查看输出</p> 
<pre>-Xmx20m -XX:+PrintGCDetails -verbose:gc</pre> 
<p>在输出第3个对象时就触发了GC </p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/81/b5/X7feqLHD_o.png" width="1093"></p> 
<p>软引用队列</p> 
<pre><code class="language-java">/**
 * 软引用, 配合引用队列
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class GC3SoftReferenceQueue {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();

        // 引用队列
        ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();

        for (int i = 0; i &lt; 5; i++) {
            // 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去
            SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4MB], queue);
            System.out.println(ref.get());
            list.add(ref);
            System.out.println(list.size());
        }

        // 从队列中获取无用的 软引用对象，并移除
        Reference&lt;? extends byte[]&gt; poll = queue.poll();
        while( poll != null) {
            list.remove(poll);
            poll = queue.poll();
        }

        System.out.println("===========================");
        for (SoftReference&lt;byte[]&gt; reference : list) {
            System.out.println(reference.get());
        }

    }
}
</code></pre> 
<p><img alt="" height="616" src="https://images2.imgbox.com/92/4d/OV2nRR5N_o.png" width="1094"></p> 
<h3>（三）弱引用（WeakReference）</h3> 
<p>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足，都会回收弱引用对象</strong>，可以配合引用队列来释放弱引用自身</p> 
<pre><code class="language-java">/**
 * 弱引用
 * -Xmx20m -XX:+PrintGCDetails -verbose:gc
 */
public class GC4WeakReference {
    private static final int _4MB = 4 * 1024 * 1024;

    public static void main(String[] args) {
        //  list --&gt; WeakReference --&gt; byte[]
        List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 5; i++) {
            WeakReference&lt;byte[]&gt; ref = new WeakReference&lt;&gt;(new byte[_4MB]);
            list.add(ref);
            for (WeakReference&lt;byte[]&gt; w : list) {
                System.out.print(w.get()+" ");
            }
            System.out.println();

        }
        System.out.println("循环结束：" + list.size());
    }
}</code></pre> 
<p><img alt="" height="423" src="https://images2.imgbox.com/d7/1d/P8h67Fju_o.png" width="1097"></p> 
<h3>（四）虚引用（PhantomReference）</h3> 
<p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法释放直接内存</p> 
<h3>（五）终结器引用（FinalReference）</h3> 
<p>所有对象都继承自Object，而Object中有一个finalize()方法，对象可以重写finalize()方法，在对象进行垃圾回收时该方法将被调用。但是对象已经没有强引用了，finalize()方法其实就是通过终结器引用实现的。在B对象断开A4的强引用后，终结器引用会被加入引用队列，由一个优先级很低的finalizeHandler进行扫描，当扫描到引用队列中的终结器引用后，会执行其所引用的A4对象的finalize()方法。由于finalize()方法不会被立刻执行，而是先进行入队，并且负责扫描的finalizeHandler优先级低，可能导致finalize()迟迟得不到执行，因此不推荐使用它进行资源回收</p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/78/be/4kM3RCfr_o.png" width="302"></p> 
<p>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象</p> 
<h2>四、垃圾回收算法</h2> 
<h3>（一）标记-清除算法（Mark Sweep）</h3> 
<h4>标记阶段：</h4> 
<p>标记的过程其实就是前面介绍的可达性分析算法的过程，遍历所有的 GC Roots 对象，对从 GCRoots 对象可达的对象都打上一个标识，一般是在对象的 header 中，将其记录为可达对象</p> 
<h4>清除阶段：</h4> 
<p>清除的过程是对堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象header 信息），则将其回收</p> 
<p><strong>缺点：</strong></p> 
<p>（1）会产生内存碎片</p> 
<p>（2）有大对象需要分配连续内存空间时，可能二次触发垃圾回收机制</p> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong>大对象</strong></span>是指，需要大量连续内存空间的Java对象，典型的大对象就是很长的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020" title="字符串">字符串</a>或者大数组</p> 
</blockquote> 
<p><strong>结论：适用于老年代，存活对象较多的情况下比较高效</strong></p> 
<h3>（二）标记-整理/压缩算法（Mark Compact）</h3> 
<p>对标记的垃圾进行清理后，将零散的内存空间进行压缩，不断的把活动内存、不连续的内存复制到近似连续的内存空间中去，保证被使用的内存，尽量有空洞存在</p> 
<p><strong>优点：</strong>避免产生大量内存碎片</p> 
<p><strong>缺点：</strong>整体效率较低</p> 
<h3>（三）复制算法（Copy）</h3> 
<p>标记出所有存活的对象，并将这些存活的对象复制到一块新的内存（图中右边内存空间），之后将运来的内存（图中左边内存空间）全部回收</p> 
<p><img alt="" height="306" src="https://images2.imgbox.com/f9/9e/Yr0qCVr2_o.png" width="847"></p> 
<p><strong>优点：</strong></p> 
<p>（1）效率高，没碎片</p> 
<p>（2）仅扫描整个空间一次</p> 
<p><strong>缺点：</strong></p> 
<p>（1）需要一块空的内存空间</p> 
<p>（2）需要复制移动对象</p> 
<p>（3）内存利用率较低，且不适合在对象存活率较高的老年底使用</p> 
<p><strong>适用于新生代，即”朝生夕死“</strong></p> 
<p></p> 
<h2><strong>五、</strong>分代回收算法</h2> 
<p>分代收集算法就是目前虚拟机使用的回收算法。它解决了标记整理不适用于老年代的问题，将内存分为各个年代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）</p> 
<p>在JDK8以前，它对方法区的实现叫做<strong>永久代</strong>，它就是使用了堆的一部分，作为方法区</p> 
<p>而在JDK8以后，移除了永久代的实现，换了一种<strong>元空间</strong>的实现，元空间使用了操作系统的一部分（一些内存 ）作为了方法区，而不再是堆的一部分</p> 
<p><img alt="" src="https://images2.imgbox.com/09/1f/fhkoLOig_o.png"></p> 
<p><img alt="" height="1022" src="https://images2.imgbox.com/05/d3/y06Fb35J_o.png" width="1200"></p> 
<p>在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率搞，没有额外空间对它进行分配担保，所以只能使用标记清除或者标记整理算法</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/37/92/M8TujgVo_o.png" width="726"></p> 
<blockquote> 
 <p>对象首先分配在伊甸园区域</p> 
 <p>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的 对象年龄加 1并且交换 from to</p> 
 <p>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p> 
 <p>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）</p> 
 <p>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时 间更长</p> 
</blockquote> 
<h4>设置VM相关参数 </h4> 
<table border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><td style="width:349px;">参数</td><td style="width:349px;">含义</td></tr><tr><td style="width:349px;">-Xms</td><td style="width:329px;">堆初始大小（堆内存初始大小，单位m、g）</td></tr><tr><td style="width:349px;">-Xmx 或 -XX:MaxHeapSize=size</td><td style="width:329px;">堆最大大小，一般不要大于物理内存的80%</td></tr><tr><td style="width:349px;">-Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )</td><td style="width:329px;">新生代大小</td></tr><tr><td style="width:349px;">-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td><td style="width:329px;">幸存区比例（动态）</td></tr><tr><td style="width:349px;">-XX:SurvivorRatio=ratio</td><td style="width:329px;">幸存区比例</td></tr><tr><td style="width:349px;">-XX:MaxTenuringThreshold=threshold</td><td style="width:329px;">晋升老年代阈值</td></tr><tr><td style="width:349px;">-XX:+PrintTenuringDistribution</td><td style="width:329px;">晋升详情</td></tr><tr><td style="width:349px;">-XX:+PrintGCDetails -verbose:gc</td><td style="width:329px;">GC详情</td></tr><tr><td style="width:349px;">-XX:+ScavengeBeforeFullGC</td><td style="width:329px;">FullGC 前 MinorGC</td></tr><tr><td style="width:329px;">-XX:PermSize</td><td style="width:349px;">非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了</td></tr><tr><td style="width:329px;">-XX:MaxPermSize</td><td style="width:349px;">非堆内存最大允许大小</td></tr><tr><td style="width:329px;">-XX:SurvivorRatio=8</td><td style="width:349px;">年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td></tr><tr><td style="width:329px;">-XX:+DisableExplicitGC</td><td style="width:349px;">关闭System.gc()</td></tr><tr><td style="width:329px;">-XX:+CollectGen0First</td><td style="width:349px;">FullGC时是否先YGC，默认false</td></tr><tr><td style="width:329px;">-XX:TLABWasteTargetPercent</td><td style="width:349px;">TLAB占eden区的百分比，默认是1%</td></tr><tr><td style="width:329px;">-Xnoclassgc</td><td style="width:349px;">禁用垃圾回收</td></tr></tbody></table> 
<h4>TLAB 内存 </h4> 
<p><span style="color:#fe2c24;"><strong>TLAB</strong></span>全称是<span style="color:#ff9900;"><strong>Thread Local Allocation Buffer</strong></span>即<span style="color:#ff9900;"><strong><code>线程本地分配缓存</code></strong></span>，从名字上看是一个线程专用的内存分配区域，是为了加速对象分配而生的。</p> 
<p>每一个线程都会产生一个TLAB，该线程独享的工作区域，Java虚拟机使用这种TLAB区来避免多线程冲突问题，提高了对象分配的效率。</p> 
<p>TLAB空间一般不会太大，当大对象无法在TLAB分配时，则会直接分配到堆上</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:680px;"><tbody><tr><td>参数</td><td>含义</td></tr><tr><td>-Xx:+UseTLAB</td><td>使用TLAB</td></tr><tr><td>-XX:+TLABSize</td><td>设置TLAB大小</td></tr><tr><td>-XX:TLABRefillWasteFraction</td><td>设置维护进入TLAB空间的单个对象大小，他是一个比例值，默认为64，即如果对象大于整个空间的1/64，则在堆创建</td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB信息</td></tr><tr><td>Xx:ResizeTLAB</td><td>自调整TLABRefillWasteFraction阀值</td></tr></tbody></table> 
<pre><code class="language-java">/**
 * 分代回收
 * -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
 */
public class GC5Generational {
    private static final int _512KB = 512 * 1024;
    private static final int _1MB = 1024 * 1024;
    private static final int _6MB = 6 * 1024 * 1024;
    private static final int _7MB = 7 * 1024 * 1024;
    private static final int _8MB = 8 * 1024 * 1024;

    // -Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc -XX:-ScavengeBeforeFullGC
    public static void main(String[] args) throws InterruptedException {

    }
}</code></pre> 
<p><img alt="" height="209" src="https://images2.imgbox.com/e5/e2/xRrWbkpq_o.png" width="928"></p> 
<p>伊甸园 </p> 
<p><img alt="" height="546" src="https://images2.imgbox.com/a3/b7/WxGWOZR6_o.png" width="1148"></p> 
<p>伊甸园对象到From、to空间中， From、to空间交换</p> 
<p><img alt="" height="580" src="https://images2.imgbox.com/ab/97/K5x1xaw0_o.png" width="1138">大对象直接晋升老年代</p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/8f/cb/Cve3bcDF_o.png" width="1042"></p> 
<p>OOM</p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/e5/e1/eXwNREbI_o.png" width="1175"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b3cd83d50690bcb9f191e499758987d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是引用计数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3fbbd7526bb5195e59a165aed835644d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">From.Item 包裹自定义 RangePicker 组件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>