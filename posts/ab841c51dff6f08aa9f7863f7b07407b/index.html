<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 存储的基本管理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 存储的基本管理" />
<meta property="og:description" content="Linux 存储的基本管理 1. 实验环境的配置2. 设备识别3. 设备挂载4. 设备中文件的查找5. 分区6. swap 分区7. 磁盘配额 1. 实验环境的配置 在虚拟机中添加一块硬盘。
linux 中用超级用户的身份打开虚拟机控制界面，选择要添加硬盘的虚拟机；选择Add Hardware ，进入添加设别界面；
选择添加一块 5G 的硬盘，如图所示；
完成之后，会看到系统中有两块硬盘。
2. 设备识别 设备接入系统后都是以文件的形式存在。
设备文件名称：
SATA/SAS/USB /dev/sda, /dev/sdb ##s= SATA ，d=DISK ，a表示第一块，b 表示第二块
IDE /dev/hd0，/dev/hd1 ##h= hard
VIRTIO-BLOCK /dev/vda，/dev/vdb ##V=virtio
M2 (SSD) /dev/nvme0，/dev/nvme1 ##nvme=m2
SD/MMC/EMMC(卡) /dev/cdrom，/dev/sr0，/dev/sr1 ##mmcblk=mmc卡
光驱 /dev/cdrom，/dev/sr0，/dev/sr1
设备查看
命令含义fdisk -l查看磁盘分区情况lsblk设备使用情况blkid设备管理方式及设备iddf查看正在被系统挂载的设备cat /proc/partitions查看系统识别设备 其中 df -h 和 df -H 时以规定的方式来显示正在被系统挂载设别的大小；如图所示：
输入命令 df 查看正在被系统挂载的设备；
输入命令 df -h 是以 2 的 n 次方计算大小；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ab841c51dff6f08aa9f7863f7b07407b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-28T12:17:40+08:00" />
<meta property="article:modified_time" content="2021-02-28T12:17:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 存储的基本管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Linux 存储的基本管理</h4> 
 <ul><li><ul><li><a href="#1__5" rel="nofollow">1. 实验环境的配置</a></li><li><a href="#2__24" rel="nofollow">2. 设备识别</a></li><li><a href="#3__72" rel="nofollow">3. 设备挂载</a></li><li><a href="#4__140" rel="nofollow">4. 设备中文件的查找</a></li><li><a href="#5__231" rel="nofollow">5. 分区</a></li><li><a href="#6_swap__439" rel="nofollow">6. swap 分区</a></li><li><a href="#7__489" rel="nofollow">7. 磁盘配额</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1__5"></a>1. 实验环境的配置</h3> 
<p>在虚拟机中添加一块硬盘。<br> linux 中用超级用户的身份打开虚拟机控制界面，选择要添加硬盘的虚拟机；选择Add Hardware ，进入添加设别界面；</p> 
<p><img src="https://images2.imgbox.com/73/ac/7vaiosng_o.png" alt="在这里插入图片描述"></p> 
<p>选择添加一块 5G 的硬盘，如图所示；</p> 
<p><img src="https://images2.imgbox.com/69/2f/ftZDuCxk_o.png" alt="在这里插入图片描述"><br> 完成之后，会看到系统中有两块硬盘。<br> <img src="https://images2.imgbox.com/86/9c/Y7JkRo6W_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__24"></a>2. 设备识别</h3> 
<p>设备接入系统后都是以文件的形式存在。</p> 
<p>设备文件名称：</p> 
<p>SATA/SAS/USB /dev/sda, /dev/sdb ##s= SATA ，d=DISK ，a表示第一块，b 表示第二块<br> IDE /dev/hd0，/dev/hd1 ##h= hard<br> VIRTIO-BLOCK /dev/vda，/dev/vdb ##V=virtio<br> M2 (SSD) /dev/nvme0，/dev/nvme1 ##nvme=m2<br> SD/MMC/EMMC(卡) /dev/cdrom，/dev/sr0，/dev/sr1 ##mmcblk=mmc卡<br> 光驱 /dev/cdrom，/dev/sr0，/dev/sr1</p> 
<p>设备查看</p> 
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>fdisk -l</td><td>查看磁盘分区情况</td></tr><tr><td>lsblk</td><td>设备使用情况</td></tr><tr><td>blkid</td><td>设备管理方式及设备id</td></tr><tr><td>df</td><td>查看正在被系统挂载的设备</td></tr><tr><td>cat /proc/partitions</td><td>查看系统识别设备</td></tr></tbody></table> 
<p>其中 df -h 和 df -H 时以规定的方式来显示正在被系统挂载设别的大小；如图所示：</p> 
<p>输入命令 df 查看正在被系统挂载的设备；<br> 输入命令 df -h 是以 2 的 n 次方计算大小；<br> 输入命令 df -H 是以 10 的 n 次方计算大小；</p> 
<p><img src="https://images2.imgbox.com/e6/27/ZCTiXaUt_o.png" alt="在这里插入图片描述"><br> 输入命令 lsblk 可以查看设备的使用情况；<br> 输入命令 blkid 查看设备管理方式及设备id；</p> 
<p><img src="https://images2.imgbox.com/70/0f/QkRvG1dW_o.png" alt="在这里插入图片描述"></p> 
<p>输入命令 cat /proc/partitions 查看系统识别设备；<br> 输入命令 fdisk -l 查看磁盘分区情况；</p> 
<p><img src="https://images2.imgbox.com/d7/35/wv2w72Ak_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3__72"></a>3. 设备挂载</h3> 
<p>在系统中有设备 id 的设备是可以被系统使用的。</p> 
<ul><li>设备临时挂载</li></ul> 
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>mount -o 挂载参数 设备（挂载点）</td><td>指定参数挂载设备</td></tr><tr><td>umount 设备（挂载点）</td><td>卸载挂载</td></tr><tr><td>mount</td><td>查看挂载信息</td></tr><tr><td>fuser -kvm 设备（挂载点）</td><td>当出现设备正忙时来卸载设备</td></tr><tr><td>mount -o remount，参数 挂载点</td><td>转换挂载参数</td></tr></tbody></table> 
<p>输入命令 df 查看正在被系统挂载的设备；可以看到 /dev/vda1 挂载在 /boot 中；<br> 输入命令 ls /boot 查看 boot 中的内容；<br> 输入命令 umount /dev/vda1 表示将 /dev/vda1 挂载的设备卸载掉；在卸载完成之后，此时查看 /boot 中的内容，可以看到 /boot 中无法读取 /dev/vda1 中的数据；</p> 
<p><img src="https://images2.imgbox.com/bb/c8/qWI4Zv2A_o.png" alt="在这里插入图片描述"><br> 已经卸载的设备可以挂载到其他目录上，<br> 输入命令 mount /dev/vda1 /mnt/ 表示将设备 /dev/vda1 挂载到 /mnt/目录上；<br> 此时在 /mnt/中可以看到和之前挂在 /boot/ 中的内容一致；</p> 
<p><img src="https://images2.imgbox.com/1a/7e/25zms0NI_o.png" alt="在这里插入图片描述"></p> 
<p>在卸载设备时，当设备正在被系统的程序使用，此时并不能卸载掉设备。<br> 此时要卸载设备需要结束掉设备上进程；<br> 输入命令 fuser -vm /mnt/-v ，其中 -v 表示显示详细信息， -m 表示显示进程；此命令的意思是查看设备上运行的程序有哪些；<br> 输入命令 fuser -kvm /mnt/-v ，其中 -k 表示结束进程，此命令可以结束设备上运行的大多数进程。</p> 
<p><img src="https://images2.imgbox.com/03/50/njndRnwG_o.png" alt="在这里插入图片描述"></p> 
<p>输入命令 mount 可以查看挂载的信息；</p> 
<p><img src="https://images2.imgbox.com/e9/11/VrRbL5GF_o.png" alt="在这里插入图片描述"><br> 在使用 mount 挂载设备时，挂载目录中默认对任何用户开放权限，这对于系统来说时不安全的表现；<br> 在挂载时，可以指定挂载参数来挂载设备，如输入命令 mount -o ro /dev/vda1 /mnt/ 表示只读挂载，任何人对于挂载目录只能看不能写；<br> 在挂载完成之后在用 mount 命令查看挂载信息时，最后一行会有详细的显示；</p> 
<p>在完成以上操作后，输入命令 mount -o remount,rw /dev/vda1 ，表示重新挂载 /mnt/ 上的设备并激活读写参数；</p> 
<p><img src="https://images2.imgbox.com/78/9e/S41YdEUV_o.png" alt="在这里插入图片描述"></p> 
<ul><li>设备永久挂载<br> 编辑 /etc/fstab ，设备挂载策略文件；<br> 如文件的最后一行所示， /dev/vdb1 为挂载的设备 ， /mnt/ 为挂载点， xfs 为文件系统类型 ， default 为挂载参数，0表示不备份 ，0表示不检测。</li></ul> 
<p><img src="https://images2.imgbox.com/c1/13/7HpC3iqH_o.png" alt="在这里插入图片描述"></p> 
<p>在编辑完此文件后，所编写的内容并不会马上生效，此时可以输入命令 mount -a ，让系统重新读取 /etc/fstab 文件。</p> 
<p><img src="https://images2.imgbox.com/3d/a1/qT9MaWvS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>注：</strong><br> 此文件内容编写错误会导致系统启动失败； 按照提示在操作系统界面输入超级用户密码； 注释错误行或者修改正确； 重启系统即可。</p> 
<h3><a id="4__140"></a>4. 设备中文件的查找</h3> 
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>find -name</td><td>按名称查找</td></tr><tr><td>find -user</td><td>按用户查找</td></tr><tr><td>find -group</td><td>按组查找</td></tr><tr><td>find -type</td><td>按类型查找</td></tr><tr><td>find -perm</td><td>按权限查找</td></tr><tr><td>find -exec</td><td>对查找的内容做执行动作</td></tr><tr><td>find -maxdepth</td><td>按最大深度查找</td></tr><tr><td>find -mindepth</td><td>按最小深度查找</td></tr><tr><td>find -cmin 1 -1 +1</td><td>按照修改时间查找</td></tr><tr><td>find -size +/-/1M</td><td>按照文件大小查找</td></tr><tr><td>find -o</td><td>按照或者的关系查找</td></tr><tr><td>find -a</td><td>按照并且的关系查找</td></tr><tr><td>find -not</td><td>查找不包括的内容</td></tr></tbody></table> 
<p>为了可以清楚的看到该实验的效果，建议以下的文件并修改其权限、用户和组的信息如下图所示：</p> 
<p><img src="https://images2.imgbox.com/49/ea/kXm4U3li_o.png" alt="在这里插入图片描述"></p> 
<p>输入命令 watch -n 1 ls -l /mnt/ 对目录中的文件进行监控，以便后面执行命令可以清楚的看到效果。</p> 
<p>重新打开一个 shell 窗口：<br> 输入命令 find /etc/ -name passwd 表示按名称在 /etc/中进行查找 passwd；<br> 输入命令 find /etc/ -maxdepth 2 -name passwd 表示按照最大查找深度为2 在 /etc/中进行查找 passwd；<br> 输入命令 find /etc/ -maxdepth 1 -name passwd 表示按照最大查找深度为1 在 /etc/中进行查找 passwd；<br> 输入命令 find /etc/ -mindepth 2 -name passwd 表示按照最小深度为2 在 /etc/ 中查找 passwd；<br> 输入命令 find /etc/ -mindepth 1 -name passwd 表示按照最小深度为1 在 /etc/ 中查找 passwd；<br> 输入命令 find /mnt/ -maxdepth 1 -type d 表示按照最大深度为1 在 /mnt/ 中查找类型为目录的文件<br> 输入命令 find /mnt/ -mindepth 2 -type d 表示按照最小深度为2 在 /mnt/ 中查找类型为目录的文件；<br> 输入命令 find /mnt/ -mindepth 1 -type d 表示按照最小深度为1 在 /mnt/ 中查找类型为目录的文件；<br> 输入命令 find /mnt/ -mindepth 0 -type d 表示按照最小深度为0 在 /mnt/ 中查找类型为目录的文件；</p> 
<p><img src="https://images2.imgbox.com/51/ca/vkkLGoXA_o.png" alt="在这里插入图片描述"><br> 输入命令 find /mnt/ -user root 表示按照超级用户来查找文件；<br> 输入命令 find /mnt/ -user root 表示按 westos 组来查找文件；<br> 输入命令 find /mnt/ -user zxk -group westos 表示按照 zxk 用户和 westos 组的条件来查找文件；<br> 输入命令 find /mnt/ -user zxk -group root 表示按照 zxk 用户和 root 组的条件来查找文件；<br> 输入命令 find /mnt/ -user zxk -a -group westos 表示按照 zxk 用户和 westos 组的条件来查找文件；<br> 输入命令 find /mnt/ -user zxk -o -group root 表示按照 zxk 用户或者 root 组的条件来查找文件；<br> 输入命令 find /mnt/ -type -d 表示按照类型为目录的条件查找文件；</p> 
<p><img src="https://images2.imgbox.com/50/0e/RInwq1qn_o.png" alt="在这里插入图片描述"></p> 
<p>输入命令 find /mnt/ -not -user root 表示按照不是超级用户的条件来查找文件；</p> 
<p><img src="https://images2.imgbox.com/e3/d1/jZGvPluW_o.png" alt="在这里插入图片描述"><br> 输入命令 touch /mnt/zxkfile4 表示修改 /mnt/zxkfile4 的时间；<br> 输入命令 find /mnt/ -cmin 1 表示查找 1分钟以内修改的文件；<br> 输入命令 find /mnt/ -cmin +1 表示查找修改超过 1 分钟的文件；</p> 
<p><img src="https://images2.imgbox.com/c2/71/dSzLhEpb_o.png" alt="在这里插入图片描述"></p> 
<p>以上新建的文件都是空文件，用以下命令给文件写入内容；<br> 输入命令 dd if=/dev/zero of=/mnt/zxkfile1 bs=1M count=10 表示给 zxkfile1 文件中写入大小为 10 M 的内容；<br> 输入命令 dd if=/dev/zero of=/mnt/zxkfile2 bs=1M count=20 表示给 zxkfile2 文件中写入大小为 20 M 的内容；<br> 输入命令 dd if=/dev/zero of=/mnt/zxkfile3 bs=1M count=40 表示给 zxkfile3 文件中写入大小为 40 M 的内容；</p> 
<p><img src="https://images2.imgbox.com/bc/0b/7cIpfntg_o.png" alt="在这里插入图片描述"></p> 
<p>输入命令 find /mnt/ -size 20M，表示在 /mnt/ 中查找文件大小为20M 的文件；<br> 输入命令 find /mnt/ -size -20M，表示在 /mnt/ 中查找文件大小小于20M 的文件；<br> 输入命令 find /mnt/ -size +20M，表示在 /mnt/ 中查找文件大小大于20M 的文件；</p> 
<p><img src="https://images2.imgbox.com/3b/e4/BnIB2ylp_o.png" alt="在这里插入图片描述"><br> 输入命令 find /mnt/ -perm 222，表示查找文件权限为 222 的文件；</p> 
<p>输入命令 find /mnt/ -perm /222，表示查找文件权限 u位、g位或者 o位含有2的文件；<br> 输入命令 find /mnt/ -perm -222，表示查找文件权限 u 位有2 ，G位有2 和o 位有2 的文件；</p> 
<p><img src="https://images2.imgbox.com/18/e3/FO0v0C89_o.png" alt="在这里插入图片描述"></p> 
<p>对于文件的查找，并不是目的；对查找到的文件执行命令才是目的；<br> 如输入 find /mnt/ -perm -002 -exec chmod 554 { } ; 表示在 /mnt/中查找文件权限 u 位有0 ，g位有0 和o 位有 2 的文件，并将查到的文家权限修改为 554。{ }表示find 命令查找结果，\ 是为了解释“；”。</p> 
<p><img src="https://images2.imgbox.com/ad/29/wcocYK8z_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5__231"></a>5. 分区</h3> 
<p>分区方式：</p> 
<table><thead><tr><th></th><th>位数</th><th>分区表大小</th><th>支持分区个数</th><th>支持单个分区大小</th></tr></thead><tbody><tr><td>legacy</td><td>(MBR) 32</td><td>64byte</td><td>主分区4个， 所有分区16个</td><td>2.2TB</td></tr><tr><td>UEFI</td><td>(GPT) 64</td><td>128byte</td><td>理论上无限制， windows 128</td><td>8ZiB</td></tr></tbody></table> 
<ul><li> <p>MBR 分区方式：</p> </li><li> <p>主分区<br> 主分区表记录分区的信息并可以直接使用的分区</p> </li><li> <p>扩展分区<br> 主分区表记录的分区，不可以直接使用，只是逻辑分区容器</p> </li><li> <p>逻辑分区<br> 扩展分区之上划分的分区叫做逻辑分区</p> </li><li> <p>分区方法</p> </li></ul> 
<ol><li>交互模式分区方法<br> fdisk /dev/sdb</li></ol> 
<p>输入命令 fdisk /dev/sdb ， /dev/sdb 为要分区的设别名称；<br> 输入 m 可以获得帮助；</p> 
<p><img src="https://images2.imgbox.com/07/b6/tfPjV3gi_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>m</td><td>获得帮助</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>l</td><td>列出所有分区类型</td></tr><tr><td>n</td><td>新建</td></tr><tr><td>p</td><td>显示分区表</td></tr><tr><td>t</td><td>更改分区类型</td></tr><tr><td>w</td><td>保存更改</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>g</td><td>设定分区方式为 GPT</td></tr><tr><td>o</td><td>设定分区方式为 mbr</td></tr></tbody></table> 
<p>如再输入命令 fdisk /dev/sdb ，对设备进行分区时，输入命令 g ，表示设定分区方式为 GPT 格式；当输入 p 来显示分区表的时候，会看到类型为 gpt；当输入 o ，表示设定分区方式为 mbr 格式；当输入 p 来显示分区表的时候，会看到类型为 dos；</p> 
<p><img src="https://images2.imgbox.com/a0/2b/VAYGkCyG_o.png" alt="在这里插入图片描述"><br> 如再输入命令 fdisk /dev/sdb ，对设备进行分区时；输入参数 n 表示新建分区；<br> 会有如下的提示：<br> Partition type<br> p primary (0 primary, 0 extended, 4 free) ## 主分区<br> e extended (container for logical partitions) ## 扩展分区</p> 
<p>Select (default p): p ## 表示建立主分区，此处直接回车会默认设定为主分区<br> Partition number (1-4, default 1): ## 分区表位置，默认会依次排序<br> First sector (2048-10485759, default 2048): ## 分区起始位置推荐使用默认<br> Last sector, +sectors or +size{K,M,G,T,P} (2048-10485759, default 10485759): +200M ##分区结束位置，+200M 表示设定此分区大小为200M；</p> 
<p><img src="https://images2.imgbox.com/a9/f9/gnr2w1uB_o.png" alt="在这里插入图片描述"></p> 
<p>当用 mbr 格式对设备进行分区时，只能分4个区，； 当4个主分区出现时，硬盘即使有容量也不能再新建分区，此时要新建就要删除一个；当删除设备时，一定确保设备在系统中未被使用，否则系统很有可能崩溃；</p> 
<p><img src="https://images2.imgbox.com/d7/d6/gEWijRvP_o.png" alt="在这里插入图片描述"></p> 
<p>当删除最后一个分区后，再新建分区时，将最后一个分区新建为扩展分区，划分扩展分区时，要将所有剩余容量都给扩展分区；扩展分区建成之后，此时再新建分区时，所新建的为逻辑分区；</p> 
<p><img src="https://images2.imgbox.com/13/a2/vDfdXg2H_o.png" alt="在这里插入图片描述"></p> 
<p>在创建好所有的分区之后，要输入命令 wq 来保存退出，如果直接 q 表示不保存退出；<br> 在保存退出之后 输入命令 udevadm settle ，同步分区表到系统；<br> 在同步之后再输入命令 cat /proc/partitions 即可看到所有的分区信息；</p> 
<p><img src="https://images2.imgbox.com/a7/3f/PtTgRZTJ_o.png" alt="在这里插入图片描述"></p> 
<p>输入命令 fdisk /dev/sdb ，对设备分区进行管理；输入参数 d 删除新建的分区；当删除设备时，一定确保设备在系统中未被使用，否则系统很有可能崩溃。按照提示依次删除需要删除的设备即可。</p> 
<p><img src="https://images2.imgbox.com/60/74/1DVMk9uC_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>非交互模式设定分区方式：</li></ol> 
<table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>parted /dev/vdb mklabel msdos</td><td>将 /dev/vdb设备设为 dos 格式</td></tr><tr><td>parted /dev/vdb mklabel gpt</td><td>将 /dev/vdb设备设为 gpt 格式</td></tr><tr><td>parted /dev/vdb mkpart primary 1 100</td><td>划分 /dev/vdb设备的第一个主分区大小为100M</td></tr><tr><td>parted /dev/vdb rm 2</td><td>删除 /dev/vdb设备上的第二个分区</td></tr></tbody></table> 
<p>输入命令 parted /dev/vdb mklabel msdos ，将/dev/vdb设备设为 dos 格式 ；<br> 输入命令 fdisk -l 来查看设别信息，可以看到信息标识为 dos；</p> 
<p><img src="https://images2.imgbox.com/1e/95/1K2HOqHV_o.png" alt="在这里插入图片描述"></p> 
<p>输入命令 parted /dev/vdb mklabel gpt ，将/dev/vdb设备设为 gpt 格式 ；<br> 输入命令 fdisk -l 来查看设别信息，可以看到信息标识为 gpt；</p> 
<p><img src="https://images2.imgbox.com/22/61/cKJNCXbs_o.png" alt="在这里插入图片描述"></p> 
<p>输入命令 parted /dev/vdb mkpart primary 1 100，即可建立一块大小为 100M的主分区；<br> 输入命令 parted /dev/vdb mkpart primary 101 500，即可建立一块大小为400M 的分区；<br> 注：用非交互的模式建立分区时，从第二块开始要做计算。如上就是在第一块的基础上加上400，建立400M分区的格式。</p> 
<p><img src="https://images2.imgbox.com/06/a1/WiQshQGN_o.png" alt="在这里插入图片描述"></p> 
<p>在建立好分区之后，输入命令 parted /dev/vdb rm 2；即可删除第二块分区。</p> 
<p><img src="https://images2.imgbox.com/8b/65/cArFDP7P_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>常用文件系统对比</li></ol> 
<table><thead><tr><th>文件系统</th><th>FAT16</th><th>FAT32</th><th>NTFS</th><th>NTFS</th><th>EXT3</th><th>EXT4</th><th>XFS</th></tr></thead><tbody><tr><td>最大卷</td><td>2GB</td><td>4GB</td><td>256TB</td><td>32TB</td><td>1EB</td><td>16EB</td><td></td></tr><tr><td>最大单个文件</td><td>4GB</td><td>8TB</td><td>16TB</td><td>2TB</td><td>16TB</td><td>8EB</td><td></td></tr><tr><td>最大文件个数</td><td>65536</td><td>4177920</td><td>4294967295</td><td>32000个子目录</td><td>无限子目录</td><td></td><td></td></tr><tr><td>代表系统</td><td>DOS</td><td>Win95</td><td>Win98</td><td>Win2000以后</td><td>RHEL5</td><td>RHEL6</td><td>HEL7～</td></tr></tbody></table> 
<p>mkfs.xfs -K /dev/sdb1 ## 格式化设备为xfs 文件系统（相当于在/dev/sdb1 上安装设备管理软件）； -K 不丢弃空数据块。</p> 
<p>在对设备分区之后，可以将分区设备进行挂载；当再输入 mount /dev/vdb1 /mnt/ 将分区挂载到 /mnt/ 上时，会提示无法识别文件系统，不知道是什么类型的；<br> 此时需要输入命令来对文件系统格式化，如输入 mkfs.xfs /dev/vdb1 ，表示将文件系统格式化成 xfs 格式；如果格式化硬盘时，上面有文件，那么就需要加参数 -f ;<br> 在格式化好文件系统之后，便可将其挂载；</p> 
<p><img src="https://images2.imgbox.com/05/69/SE0DnWod_o.png" alt="在这里插入图片描述"></p> 
<ol start="4"><li>永久挂载<br> 在完成上述格式化之后，便可将其挂载，但是此种挂载方式为临时挂载，当重启系统之后，挂载便不再存在。</li></ol> 
<p>mount /dev/sdb1 /mnt/westos ，mount 命令在挂载为临时挂载；<br> 如果需要永久挂载需要编写 /etc/fstab 配置文件。</p> 
<p>输入命令 vim /etc/fstab ，编写内容如下所示，表示将文件系统格式为 xfs 的设备 /dev/vdb1 以默认的方式挂载到 /mnt/上，无备份不检测。</p> 
<p><strong>注</strong>：此文件千万不能编写错误，编写错误之后，系统就起不来。</p> 
<p><img src="https://images2.imgbox.com/c2/43/VmpYEV3h_o.png" alt="在这里插入图片描述"></p> 
<p>在编写完成之后，文件并不会立即生效，此时可以输入命令 mount -a 使其立即生效。</p> 
<ol start="5"><li>设备删除<br> dd if=/dev/zero of=/dev/vdb bs=1M count=1</li></ol> 
<p>在被一个设备上的所有分区删除完毕时，此时输入 fdisk -l 对设备信息查看，可以看到即使已经将新建的分区删除完毕，此时建立过分区的设备上还有标识信息存在；<br> 可以输入命令 dd if=/dev/zero of=/dev/vdb bs=1M count=1 ，表示从无限零字节的文件中截取一块大小为1M的数据放在该设备上，便可将标识信息删除；将其完全删除成初始的样子。<br> 此时再输入 fdisk -l 对设备信息查看时，便不再看到标识信息；</p> 
<p><img src="https://images2.imgbox.com/10/c5/BpUoP4ga_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6_swap__439"></a>6. swap 分区</h3> 
<ul><li> <p>作用：<br> 程序在运行时所有数据是在 RAM，当 RAM使用量超过了限额，为了使系统更加稳定，我们在硬盘上划分一部分空间来作内存缓冲区 swap；此时当内存使用超过限额，内核会把内存中闲置的数据存放到 swap 分区中，当程序需要 swap 分区中的数据时内核将 swap 分区中的数据再交还给内存进程处理</p> </li><li> <p>swap 分区大小建议：</p> <pre><code>内存大小			swap分区建议大小		当允许HIBERNATE
2GiB以下		        内存两倍			   内存3倍
2-8GiB			  等于物理内存	     物理内存2倍
8-64GiB				 4GiB			 1.5倍物理内存
64GiB以上			 4GiB			 HIBERNATE不开
</code></pre> </li><li> <p>swap管理<br> swapon -s ##查看swap分区信息<br> swapon -a /dev/vdb1 ##打开swap分区<br> mkswap /dev/sda1 ##格式化设备位swap格式<br> swapon /dev/sda1 -p 0-32767 ## -p表示指定swap的优先级<br> swapoff /dev/sda1 ##关闭swap分区</p> </li></ul> 
<p>输入命令 fdisk /dev/vdb 新建一个分区，并将新建的分区修改为 swap 分区类型；操作过程如下图所示：</p> 
<p><img src="https://images2.imgbox.com/dd/9f/IgZiSORE_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/95/0c/LdceIYcT_o.png" alt="在这里插入图片描述"><br> 当 swap 分区创建成功之后，输入命令 udevadm settle 加载分区信息表；再输入命令 mkswap /dev/vdb1 来格式化新建的分区为 swap 格式；再输入命令 swapon -a 来开启 swap 分区；此时再输入命令 swapon -s 就可以看到新建的 swap 分区信息；</p> 
<p><img src="https://images2.imgbox.com/e7/13/3AwChpbS_o.png" alt="在这里插入图片描述"></p> 
<p>以上对于分区的设定是临时的；如果永久的添加 swap 分区就需要编辑配置文件 /etc/fstab ；编辑内容如图所示，编辑完配置文件之后，再次开机时便还可以看到分区信息；</p> 
<p>如果需要设定分区的优先级，可以将 defaults 修改为优先级的 id 即可永久指定成功。</p> 
<p><img src="https://images2.imgbox.com/e3/fe/USF3CPrj_o.png" alt="在这里插入图片描述"></p> 
<ul><li>删除 swap 分区</li></ul> 
<ol><li>删除配置文件的内容；</li><li>输入命令 swapoff /dev/vdb1 关闭 swap 分区；</li><li>删除 swap 分区；</li></ol> 
<p>完成以上设定之后， swap 分区就被彻底的删除成功。</p> 
<p><img src="https://images2.imgbox.com/3b/c3/khpV4cLj_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7__489"></a>7. 磁盘配额</h3> 
<p>以上挂载设备之后，所设定主机的用户对挂载的设备有使用权限，但是如果不做设定，当好几个用户同时使用一个设备时，很可能一个用户便将此设备占满，这种是不合理的设置，需要做磁盘配额的设定。</p> 
<p>作用：<br> 设定用户能写入指定设备的最大额度</p> 
<p>设定方法：</p> 
<ol><li>临时设定配额</li></ol> 
<p>输入命令 mount -o usrquota /dev/vdb1 /mnt/ ，表示挂载设备并激活配额参数，防止一个用户占用一个硬盘；<br> 输入命令 edquota -u zxk ，表示设定 zxk 用户的配额；</p> 
<p>默认的设置如下所示：Filesystem 设备名称，blocks 表示用户已经创建数据，soft 软限， hard (最大大小）硬限， inodes 表示用户可以创建数据 ；<br> <img src="https://images2.imgbox.com/e6/1a/Oqi4r0AO_o.png" alt="在这里插入图片描述"><br> 设定如下 ：表示 zxk 这个用户最多只能写入50M。</p> 
<p><img src="https://images2.imgbox.com/fd/d1/JJGvOGPq_o.png" alt="在这里插入图片描述"><br> 测试：</p> 
<p>输入命令 su - zxk，切换用户；<br> 输入命令 dd if=/dev/zero of=/pub/leefile bs=1M count=40 ，截取数据小于54M成功；<br> 输入命令 dd if=/dev/zero of=/pub/leefile bs=1M count=52 ，截取失败，只能写入小于50M的数据。</p> 
<p><img src="https://images2.imgbox.com/20/2b/s2wHdtFn_o.png" alt="在这里插入图片描述"></p> 
<ol start="2"><li>永久开启配额<br> 以上设定只时临时设定，当再次开启系统时还是会回到之前的状态。<br> 输入命令 vim /etc/fstab 编辑配置文件；添加配额参数，此参数的添加，会在开机时自动开启配额，否则配额不会自动激活。如图所示：</li></ol> 
<p><img src="https://images2.imgbox.com/d7/87/3WRE1YHS_o.png" alt="在这里插入图片描述"></p> 
<p>永久关闭配额：</p> 
<p>vim /etc/fstab ， 去掉配额参数 usrquota；<br> 然后将设备卸载就成功了;<br> 此时再挂载上去，可以看到挂载信息中并没有开启配额。</p> 
<p><img src="https://images2.imgbox.com/ea/41/lip5IS8a_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/985a276d44f4bbde37d526dcd08c0e75/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java future 异常处理_java – 从CompletableFuture抛出异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b67ff6abce440443bf6e438dde651b7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java算法 蛇形矩阵_算法基础之蛇形矩阵</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>