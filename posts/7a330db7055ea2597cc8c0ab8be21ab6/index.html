<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>华为OD试题-最长合法表达式 C&#43;&#43; - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="华为OD试题-最长合法表达式 C&#43;&#43;" />
<meta property="og:description" content="参数最长合法表达式 题目
提取字符串中的最长合法简单数学表达式
字符串长度最长的，并计算表达式的值。
如果没有返回0.
简单数学表达式只能包含以下内容:
0 - 9数字，符号 &#43; - *
说明 :
1.所有数字，计算结果都不超过 long
2.如果有多个长度一样的，请返回第一个表达式的结果
3.数学表达式，必须是最长的，合法的
4.操作符不能连续出现，如 &#43;--&#43;1 是不合法的
输入
字符串
输出描述
表达式值
示例
输入
1 - 2abcd
输出
1
解题思路及解题代码： 用正则表达式解，我的方式比较粗暴，所以大家就参考一下吧 这里进行对裁剪好的字符串的计算,也是使用正则表达式判断数字的位置，因为regex_search这个函数在匹配的时候会返回匹配字符串的包含首地址（frist）和不包含的结束地址（second）恰好是运算符的位置，所以遍历的同时也可以记录运算符。
默认第一个运算符是&#43;，先运算再更新运算符。
​int calculateExpression(string&amp; expression) { regex pattern(&#34;(\\d{1,10})&#34;); smatch match; string::const_iterator citer = expression.cbegin(); int result = 0; char op = &#39;&#43;&#39;; while (regex_search(citer, expression.cend(), match, pattern))//循环匹配 { citer = match[0].second; switch (op) { case &#39;&#43;&#39;: result &#43;= stoi(match[0]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7a330db7055ea2597cc8c0ab8be21ab6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-20T20:57:23+08:00" />
<meta property="article:modified_time" content="2023-12-20T20:57:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">华为OD试题-最长合法表达式 C&#43;&#43;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2></h2> 
<h2>参数最长合法表达式   </h2> 
<p>题目<br> 提取字符串中的最长合法简单数学表达式<br> 字符串长度最长的，并计算表达式的值。<br> 如果没有返回0.<br> 简单数学表达式只能包含以下内容:<br> 0 - 9数字，符号 + - *<br> 说明 :<br>     1.所有数字，计算结果都不超过 long<br>     2.如果有多个长度一样的，请返回第一个表达式的结果<br>     3.数学表达式，必须是最长的，合法的<br>     4.操作符不能连续出现，如 +--+1 是不合法的<br>     输入<br>     字符串<br>     输出描述<br>     表达式值<br>     示例<br>     输入<br>     1 - 2abcd<br>     输出<br>     1</p> 
<h2>解题思路及解题代码：</h2> 
<p>用正则表达式解，我的方式比较粗暴，所以大家就参考一下吧 </p> 
<p>这里进行对裁剪好的字符串的计算,也是使用正则表达式判断数字的位置，因为regex_search这个函数在匹配的时候会返回匹配字符串的包含首地址（frist）和不包含的结束地址（second）恰好是运算符的位置，所以遍历的同时也可以记录运算符。</p> 
<p>默认第一个运算符是+，先运算再更新运算符。</p> 
<pre><code class="language-cpp">​int calculateExpression(string&amp; expression) {
    regex pattern("(\\d{1,10})");
    smatch match;
    string::const_iterator citer = expression.cbegin();
    int result = 0;
    char op = '+';
    while (regex_search(citer, expression.cend(), match, pattern))//循环匹配
    {
        citer = match[0].second;
        switch (op)
        {
        case '+':
            result += stoi(match[0].str()); 
            break;
        case '-':
            result -= stoi(match[0].str());
            break;
        case '*':
            result *= stoi(match[0].str());
            break;
        default:
            break;
        }
        if (citer != expression.cend()) 
        {
            op = *citer;
        }
    }

    return result;
}</code></pre> 
<p>删除字符串中的空格，否则影响正则表达式的匹配。 </p> 
<pre><code class="language-cpp">void trim(string&amp; s)
{
    int index = 0;
    if (!s.empty())
    {
        while ((index = s.find(' ', index)) != string::npos)
        {
            s.erase(index, 1);
        }
    }
}

​</code></pre> 
<p>///\主函数对输入字符进行合法算式的匹配，保存最长的表达式字符串索引。</p> 
<pre><code class="language-cpp">int main()
{
    //string input;
    //getline(cin, input);
    string str = "aaavvvdddeee4-4+6fff333+5+9+ 12 -1000++++++5555_5555avg444+5h90hhh1+2abc";
    trim(str);
    regex pattern("(\\d{1,10})((([+]\\d{1,10})|([*]\\d{1,10})|([-]\\d{1,10}))*)");
    smatch match;
    string::const_iterator citer = str.cbegin();
    vector&lt;string&gt;strs;
    int lens = 0,max = 0,index = 0,maxIndex = 0;
    while (regex_search(citer, str.cend(), match, pattern))//循环匹配
    {
        citer = match[0].second;
        cout &lt;&lt; match[0] &lt;&lt; endl;
        strs.push_back(match[0]);
        lens = match[0].str().size();
        
        if (max &lt;= lens)
        {
            max = lens;
            maxIndex = index;
        }
        index++;
    }
    cout &lt;&lt; calculateExpression(strs[maxIndex]);
    return 0;
}</code></pre> 
<p></p> 
<h2>参考文章：</h2> 
<p style="background-color:transparent;"><a href="https://blog.csdn.net/qq_45254369/article/details/125491031" title="C++11之正则表达式（regex_match、regex_search、regex_replace）_c++ regex_replace-CSDN博客">C++11之正则表达式（regex_match、regex_search、regex_replace）_c++ regex_replace-CSDN博客</a><br><a href="https://blog.csdn.net/qionggaobi9328/article/details/106123560" title="【C++】去除字符串string中的空格（两头空格、所有空格）_c++ string去除空格-CSDN博客">【C++】去除字符串string中的空格（两头空格、所有空格）_c++ string去除空格-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9161de2f007c8c18c49eff2d094fad5b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;】STL 容器 - vector 动态数组容器 ⑥ ( 使用迭代器遍历 vector 容器步骤 | 获取指容器向首元素的迭代器 begin 函数 | 获取末尾迭代器 | * 迭代器解引用 )</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3f86f60d55a17eaabcfc3b6422d8073c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第八课：eNSP 链路聚合2种方式（手工模式和LACP模式）拓扑配置教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>