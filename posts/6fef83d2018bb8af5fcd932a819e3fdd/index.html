<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>联邦学习：联邦场景下的跨域推荐 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="联邦学习：联邦场景下的跨域推荐" />
<meta property="og:description" content="原文链接：https://zhuanlan.zhihu.com/p/553492147
1 导引 1.1 跨域推荐模型 推荐系统中常常面临冷启动和用户交互数据稀疏的问题。解决这个问题的一个手段就是对用户在多个领域(domain)的日志数据联合起来进行建模，这里的多个领域的数据可以指用户在诸如新闻App、音乐App、视频App等多个软件的日志数据（比如点击的浏览新闻标题和描述等）。这种联合建模基于一个假设：用户在不同领域也倾向于拥有相似的偏好，比如喜欢爱情电影的用户也很可能喜欢言情小说。
而多视角(multi view)或跨域(cross domain)推荐模型[1]就是一种常见的跨领域数据联合建模方式，它会将多个视角/多个领域对应的特征映射到一个共享的隐空间（latent space）。事实上，这即是迁移学习中经典的几何特征变换（表征对齐） [11]思路，也是度量学习（Metric Learning）[12]思想的一种体现。
跨领域数据建模的多视角DNN
上图展示了对跨域数据建模的多视角DNN，它基于深度结构化语义模型（Deep Structured Sematic Models， DSSM）的计算最大化用户视角和多个物品视角对应隐向量的相似度，并按照相似度排序来推荐物品。图中的User View对应的特征为用户使用搜索引擎的查询信息，而其他的Item View对应的特征为用户在其它App所点击过的物品特征数据。该模型假定所有领域都对应着共同的用户。它使用了DNN将多个视角对应的高维稀疏特征映射xU ,x1, ..., xD到共享隐空间中的低维稠密特征yU, y1, ..., yD。
之后可以计算用户隐向量和物品隐向量的语义相似度：
这里假设用户隐向量和物品隐向量相关，然后接下来的目标就是为每个视角都找到一个非线性的映射，以使视角和其它物品视角在隐空间的相似度之和最大化：
其中为各个视角对应的权重参数，一共有个N用户-物品对样本和D个物品视角，其中每个物品视角xj都有其单独的输入特征维度dj。
第i个用户-物品对样本拥有一个用户视角的输入特征和其对应的物品视角特征，这里a是样本i对应物品视角的索引，样本i对应的其它物品视角的输入则设为0向量。为温度系数。
如上文所述，跨域推荐本质上是个迁移学习问题，它需要在多个领域异构数据的基础上通过某种“桥梁”（bridge）来提高一个或多个目标域的推荐效果。这里的“桥梁”指不同领域之间的关联项目，比如共同的用户，共同的物品，共同的特征等。上面的多视角DNN模型就假定所有领域都对应着共同的用户。
1.2 联邦跨域推荐模型 跨域推荐在实际应用中常常面临隐私性的挑战，其一是不同用户的数据难以合法地进行集中化收集；其二是其使用的迁移学习模型跨不同的域和数据集进行映射，这常常会关联到不同的组织机构，同样会面临隐私问题。此时上面提到的需要将数据集中起来的跨域推荐方法就不再行得通了，需要考虑在联邦场景下的跨域推荐模型。
而联邦场景下的跨域推荐模型根据其隐私保护的出发点不同，可大致分为以下三类：
横向 保证用户（client）之间的数据数据不共享，但多视角的数据是打通的。如下图所示[7]，不同的用户可能具有A、B两个领域的信息，且A领域的数据和B领域的数据可共享： 纵向 可以将用户的数据进行集中化收集，但多视角的数据不能共享。如下图所示[8]，Platform 1 到Platform K 都拥有用户的行为数据，然后依靠第三方的服务器对其进行联合建模。 横向&#43;纵向 不仅保证client之间的数据不共享，且多视角的数据也是不能共享的。如下图所示[5]，用户 u 的数据不能直接上传到云端（但可上传下载模型），且对于用户 u 而言，其在领域 d1的数据不能与其在领 d2 的数据共享。 我个人觉得在保证隐私的条件下进行多视角之间的信息共享（纵向/横向&#43;纵向）是最有意思的，其核心是联邦迁移学习相关的理论：即在隐私保护的前提下，根据不同领域之间的关联来生成共享表征。根据我阅读过的大部分论文来看，如不同领域对应不同的组织机构，则它们的embeddings不能直接进行迁移，需要采取间接的迁移方法。这些方法具体来说就五花八门了，有用GAN来生成带差分隐私保护的共享embeddings的（参见《联邦学习：联邦场景下的多源知识图谱嵌入》），有用另一个中间视角的数据来训练共享子模型的[4]，有用VAE来生成一个独立于所有领域的共享embeddings的[5]，有先对数据加以差分隐私保护再用自编码器生成共享embeddings的[6]。可以预见这在未来仍将是个热点。
以下我们分别看下这三类所对应的相关论文，了解一下该领域的大致情况。
2. 论文阅读 2.1 ECML-PKDD 2020《Federated multi-view matrix factorization for personalized recommendations》 这篇论文提出了联邦多视角矩阵分解分解算法，因为其使用的多视角数据不涉及跨组织机构，故只需要保证用户数据不共享即可，属于前面所说的横向类型。具体而言，在传统的矩阵分解算法中，常常只考虑用户-物品矩阵，即所谓共现矩阵R，通过分解该矩阵得到用户的隐向量矩阵P和物品隐向量矩阵Q：
之后再基于用户矩阵P和物品矩阵Q得到用户u对物品i的预估评分：
其中是用户i在用户矩阵P中的对应行向量，是物品j在物品矩阵Q中的对应行向量。
而所谓多视角矩阵分解，即包括以下三个视角：用户-物品，用户-特征，物品-特征。这三个视角分别对应用户-物品矩阵，用户特征矩阵，物品特征矩阵。这里为用户个数，为物品个数，和分别为用户和物品的特征维度。则多视角矩阵分解可表示为如下形式：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6fef83d2018bb8af5fcd932a819e3fdd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-07T16:46:38+08:00" />
<meta property="article:modified_time" content="2023-11-07T16:46:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">联邦学习：联邦场景下的跨域推荐</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>原文链接：<a class="link-info" href="https://zhuanlan.zhihu.com/p/553492147" rel="nofollow" title="https://zhuanlan.zhihu.com/p/553492147">https://zhuanlan.zhihu.com/p/553492147</a></p> 
</blockquote> 
<h2 id="h_553492147_0" style="background-color:transparent;">1 导引</h2> 
<h3 id="h_553492147_1">1.1 <strong>跨域推荐模型</strong></h3> 
<p>推荐系统中常常面临冷启动和用户交互数据稀疏的问题。解决这个问题的一个手段就是对用户在多个领域(domain)的日志数据联合起来进行建模，这里的多个领域的数据可以指用户在诸如新闻App、音乐App、视频App等多个软件的日志数据（比如点击的浏览新闻标题和描述等）。这种联合建模基于一个假设：用户在不同领域也倾向于拥有相似的偏好，比如喜欢爱情电影的用户也很可能喜欢言情小说。</p> 
<p><strong>而多视角(multi view)或跨域(cross domain)推荐模型[1]就是一种常见的跨领域数据联合建模方式，它会将多个视角/多个领域对应的特征映射到一个共享的隐空间（latent space）</strong>。事实上，这即是迁移学习中经典的<strong>几何特征变换（表征对齐）</strong> <strong>[11]</strong>思路，也是<strong>度量学习（Metric Learning）[12]</strong>思想的一种体现。</p> 
<p><img alt="" height="602" src="https://images2.imgbox.com/14/7f/YGeHq1rR_o.png" width="928"></p> 
<p style="text-align:center;">跨领域数据建模的多视角DNN</p> 
<p>上图展示了对跨域数据建模的多视角DNN，它基于深度结构化语义模型（Deep Structured Sematic Models， DSSM）的计算最大化用户视角和多个物品视角对应隐向量的相似度，并按照相似度排序来推荐物品。图中的User View对应的特征为用户使用搜索引擎的查询信息，而其他的Item View对应的特征为用户在其它App所点击过的物品特征数据。该模型假定所有领域都对应着共同的用户。它使用了DNN将多个视角对应的高维稀疏特征映射xU ,x1, ..., xD到共享隐空间中的低维稠密特征yU, y1, ..., yD。</p> 
<p>之后可以计算用户隐向量<img alt="y_{U}" class="mathcode" src="https://images2.imgbox.com/5c/12/4Yd10Rop_o.png">和物品隐向量<img alt="y_{j}\left ( j=1, ..., D \right )" class="mathcode" src="https://images2.imgbox.com/df/ff/rHg0oOTW_o.png">的语义相似度：</p> 
<p class="img-center"><img alt="" height="51" src="https://images2.imgbox.com/99/62/kso2N70Z_o.png" width="224"></p> 
<p>这里假设用户隐向量<img alt="y_{U}" class="mathcode" src="https://images2.imgbox.com/03/c1/uyFz7McA_o.png">和物品隐向量<img alt="y_{j}\left ( j=1, ..., D \right )" class="mathcode" src="https://images2.imgbox.com/70/31/pszEnsKR_o.png">相关，然后接下来的目标就是为每个视角都找到一个非线性的映射，以使<img alt="y_{U}" class="mathcode" src="https://images2.imgbox.com/81/1d/4fZOqGt4_o.png">视角和其它物品视角<img alt="y_{1}, ..., y_{D}" class="mathcode" src="https://images2.imgbox.com/6c/29/chTBEQNZ_o.png">在隐空间的相似度之和最大化：</p> 
<p class="img-center"><img alt="" height="69" src="https://images2.imgbox.com/90/93/xEnLjD34_o.png" width="395"></p> 
<p> 其中<img alt="W_{U}, W_{1}, ..., W_{D}" class="mathcode" src="https://images2.imgbox.com/cf/68/ed1LnfrE_o.png">为各个视角对应的权重参数，一共有个N用户-物品对样本和D个物品视角，其中每个物品视角xj都有其单独的输入特征维度dj。</p> 
<p> 第i个用户-物品对样本拥有一个用户视角的输入特征<img alt="x_{i,u}" class="mathcode" src="https://images2.imgbox.com/ba/9d/RVBdsEbV_o.png">和其对应的物品视角特征<img alt="x_{i,a}" class="mathcode" src="https://images2.imgbox.com/f7/90/VxMdBheZ_o.png">，这里a是样本i对应物品视角的索引，样本i对应的其它物品视角的输入<img alt="x_{i,j\neq a}" class="mathcode" src="https://images2.imgbox.com/d1/50/FGsThnb6_o.png">则设为0向量。<img alt="\gamma" class="mathcode" src="https://images2.imgbox.com/e4/9c/IYAKuJ1z_o.png">为温度系数。</p> 
<p> 如上文所述，<strong>跨域推荐本质上是个迁移学习问题，它需要在多个领域异构数据的基础上通过某种“桥梁”（bridge）来提高一个或多个目标域的推荐效果。这里的“桥梁”指不同领域之间的关联项目，比如共同的用户，共同的物品，共同的特征等</strong>。上面的多视角DNN模型就假定所有领域都对应着共同的用户。</p> 
<h3 id="h_553492147_2" style="background-color:transparent;">1.2 联邦跨域推荐模型</h3> 
<p> 跨域推荐在实际应用中常常面临隐私性的挑战，其一是不同用户的数据难以合法地进行集中化收集；其二是其使用的迁移学习模型跨不同的域和数据集进行映射，这常常会关联到不同的组织机构，同样会面临隐私问题。此时上面提到的需要将数据集中起来的跨域推荐方法就不再行得通了，需要考虑在联邦场景下的跨域推荐模型。</p> 
<p>而联邦场景下的跨域推荐模型根据其隐私保护的出发点不同，可大致分为以下三类：</p> 
<ul><li><strong>横向 </strong>保证用户（client）之间的数据数据不共享，但多视角的数据是打通的。如下图所示[7]，不同的用户可能具有A、B两个领域的信息，且A领域的数据和B领域的数据可共享：</li></ul> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d9/0b/naBCEZX8_o.png" width="1200"></p> 
<ul><li> <strong>纵向 </strong>可以将用户的数据进行集中化收集，但多视角的数据不能共享。如下图所示[8]，Platform 1 到Platform K 都拥有用户的行为数据，然后依靠第三方的服务器对其进行联合建模。</li><li><img alt="" height="1200" src="https://images2.imgbox.com/8a/4a/5wEKyx6p_o.png" width="1200"> <strong>横向+纵向 </strong>不仅保证client之间的数据不共享，且多视角的数据也是不能共享的。如下图所示[5]，用户 u 的数据不能直接上传到云端（但可上传下载模型），且对于用户 u 而言，其在领域 d1的数据不能与其在领 d2 的数据共享。</li></ul> 
<p><img alt="" height="561" src="https://images2.imgbox.com/f5/5e/HoLyMETp_o.png" width="712"></p> 
<p> </p> 
<p><strong>我个人觉得在保证隐私的条件下进行多视角之间的信息共享（纵向/横向+纵向）是最有意思的，其核心是联邦迁移学习相关的理论：即在隐私保护的前提下，根据不同领域之间的关联来生成共享表征</strong>。根据我阅读过的大部分论文来看，如不同领域对应不同的组织机构，则它们的embeddings不能直接进行迁移，需要采取间接的迁移方法。这些方法具体来说就五花八门了，有用GAN来生成带差分隐私保护的共享embeddings的（参见<a href="https://zhuanlan.zhihu.com/p/548242915" rel="nofollow" title="《联邦学习：联邦场景下的多源知识图谱嵌入》">《联邦学习：联邦场景下的多源知识图谱嵌入》</a>），有用另一个中间视角的数据来训练共享子模型的[4]，有用VAE来生成一个独立于所有领域的共享embeddings的[5]，有先对数据加以差分隐私保护再用自编码器生成共享embeddings的[6]。可以预见这在未来仍将是个热点。</p> 
<p>以下我们分别看下这三类所对应的相关论文，了解一下该领域的大致情况。</p> 
<h2> 2. 论文阅读</h2> 
<h3> 2.1 ECML-PKDD 2020《Federated multi-view matrix factorization for personalized recommendations》</h3> 
<p> 这篇论文提出了联邦多视角矩阵分解分解算法，<strong>因为其使用的多视角数据不涉及跨组织机构，故只需要保证用户数据不共享即可，属于前面所说的横向类型</strong>。具体而言，在传统的矩阵分解算法中，常常只考虑用户-物品矩阵，即所谓共现矩阵R，通过分解该矩阵得到用户的隐向量矩阵P和物品隐向量矩阵Q：</p> 
<p class="img-center"><img alt="" height="33" src="https://images2.imgbox.com/b6/0f/hkTOOusU_o.png" width="84"></p> 
<p> 之后再基于用户矩阵P和物品矩阵Q得到用户u对物品i的预估评分：</p> 
<p class="img-center"><img alt="" height="43" src="https://images2.imgbox.com/dc/b5/i4VuKPg0_o.png" width="121"></p> 
<p>其中<img alt="p_{i}" class="mathcode" src="https://images2.imgbox.com/34/b2/oiOSemwN_o.png">是用户i在用户矩阵P中的对应行向量，<img alt="q_{i}" class="mathcode" src="https://images2.imgbox.com/d2/ef/QUbU17UA_o.png">是物品j在物品矩阵Q中的对应行向量。</p> 
<p> 而所谓多视角矩阵分解，即包括以下三个视角：用户-物品，用户-特征，物品-特征。这三个视角分别对应用户-物品矩阵<img alt="R\in \mathbb{R}^{N_{u}\times N_{v}}" class="mathcode" src="https://images2.imgbox.com/b2/29/uiTfC4Ye_o.png">，用户特征矩阵<img alt="X\in \mathbb{R}^{N_{u}\times D_{u}}" class="mathcode" src="https://images2.imgbox.com/08/10/sJaMT9RU_o.png">，物品特征矩阵<img alt="Y\in \mathbb{R}^{N_{u}\times D_{v}}" class="mathcode" src="https://images2.imgbox.com/93/10/PH8s3yRE_o.png">。这里<img alt="N_{u}" class="mathcode" src="https://images2.imgbox.com/d0/d7/ynJIIbIP_o.png">为用户个数，<img alt="N_{v}" class="mathcode" src="https://images2.imgbox.com/e8/b3/yb8dnZSj_o.png">为物品个数，<img alt="D_{u}" class="mathcode" src="https://images2.imgbox.com/31/0e/Xx5YLrwy_o.png">和<img alt="D_{v}" class="mathcode" src="https://images2.imgbox.com/39/2f/kh9jai14_o.png">分别为用户和物品的特征维度。则多视角矩阵分解可表示为如下形式：</p> 
<p class="img-center"><img alt="" height="85" src="https://images2.imgbox.com/13/e8/shu0QhMm_o.png" width="84"></p> 
<p> 如下图所示：</p> 
<p class="img-center"><img alt="" height="340" src="https://images2.imgbox.com/37/85/7cFE964K_o.png" width="556"></p> 
<p style="text-align:center;"> 多视角矩阵分解示意图</p> 
<p> 其中<img alt="P\in \mathbb{R}^{N_{u}\times K}" class="mathcode" src="https://images2.imgbox.com/50/80/T2s5Bzae_o.png">是用户隐向量矩阵，<img alt="Q\in \mathbb{R}^{N_{v}\times K}" class="mathcode" src="https://images2.imgbox.com/bf/26/NHPz7QFB_o.png">是物品隐向量矩阵，<img alt="U\in \mathbb{R}^{D_{u}\times K}" class="mathcode" src="https://images2.imgbox.com/ff/12/rh5x0iaP_o.png">是用户特征隐向量矩阵，<img alt="V\in \mathbb{R}^{D_{v}\times K}" class="mathcode" src="https://images2.imgbox.com/23/bf/Sbko0KnA_o.png">是物品特征隐向量矩阵，这里K是隐向量维度。</p> 
<p> 此时所要优化的目标函数可以写为：</p> 
<p class="img-center"><img alt="" height="146" src="https://images2.imgbox.com/8a/de/ZsRWFdAl_o.png" width="514"></p> 
<p> 这里<img alt="c_{ij}=1+\alpha r_{ij}" class="mathcode" src="https://images2.imgbox.com/bd/a3/woDbVm4x_o.png">，<img alt="\alpha" class="mathcode" src="https://images2.imgbox.com/03/c2/QH45ePeO_o.png">是一个表示隐式反馈不确定性的置信参数；<img alt="\lambda _{2}" class="mathcode" src="https://images2.imgbox.com/c7/8c/fg2c54Qb_o.png">是L2正则项；<img alt="\lambda _{1}" class="mathcode" src="https://images2.imgbox.com/6a/7a/AOINJOJb_o.png">表示用户-物品视角与其它视角间的信息共享强度，若令<img alt="\lambda _{1}=0" class="mathcode" src="https://images2.imgbox.com/38/25/N8qDLNqt_o.png">则表示用户-物品视角不与其它视角进行信息共享，<img alt="0\leqslant \lambda _{1}\leqslant 1" class="mathcode" src="https://images2.imgbox.com/38/71/5ozBAfD7_o.png">可以根据数据生成过程的先验知识选择，也可以通过超参数优化来决定。</p> 
<p> 模型参数P,Q,U,V可以通过交替最小二乘法（Alternating Least Square, ASL）来求解。</p> 
<p> 下图描述了在联邦场景下用交替最小二乘法求解该问题的算法。</p> 
<p><img alt="" height="624" src="https://images2.imgbox.com/04/71/jwPsbfh2_o.png" width="1200"></p> 
<p style="text-align:center;"> 联邦场景下使用交替最小二乘法求解多视角矩阵分解</p> 
<p>如图所示，用户i和物品的交互信息r(i)（用户i在R中的对应行向量）及用户i的特征向量<img alt="x_{i}" class="mathcode" src="https://images2.imgbox.com/7c/64/XUQ96QQf_o.png">（用户i在X中的对应行向量）只能在client i本地使用。物品的特征矩阵Y存储在item server中。fl server会将Q,U分发给client（用户），并将Q发往item server。 </p> 
<p> 在每个client i，用户的隐向量<img alt="p_{i}" class="mathcode" src="https://images2.imgbox.com/57/91/hOz7Wa4I_o.png">会在本地进行计算，其中会使用到该用户与物品的交互信息r(i)、该用户的特征向量<img alt="x_{i}" class="mathcode" src="https://images2.imgbox.com/31/33/6NENj6kb_o.png">与来自server的Q,U。新的用户隐向量<img alt="p_{i}^{*}" class="mathcode" src="https://images2.imgbox.com/d9/9e/njfcwg39_o.png">计算公式如下：</p> 
<p class="img-center"><img alt="" height="36" src="https://images2.imgbox.com/f6/b2/bseeaPxV_o.png" width="400"></p> 
<p> 之后，client i按照下式计算<img alt="f\left ( j,i \right )" class="mathcode" src="https://images2.imgbox.com/e4/82/KxSLAdX7_o.png">(用于之后在fl server计算<img alt="\frac{\partial J}{\partial q_{j}}" class="mathcode" src="https://images2.imgbox.com/3a/f1/c5UczlVL_o.png">以更新Q)：</p> 
<p class="img-center"><img alt="" height="46" src="https://images2.imgbox.com/c8/57/AbvMakUF_o.png" width="253"></p> 
<p> 按照下式梯度<img alt="f\left ( j,i \right )" class="mathcode" src="https://images2.imgbox.com/ec/9f/hQrLuidR_o.png">(用于之后在fl server计算<img alt="\frac{\partial J}{\partial u_{d_{u}}}" class="mathcode" src="https://images2.imgbox.com/b3/64/eqXb0r3L_o.png">以更新U)：</p> 
<p class="img-center"><img alt="" height="46" src="https://images2.imgbox.com/40/50/TGSpQe1c_o.png" width="280"></p> 
<p>上述计算完毕后将<img alt="f\left ( j,i \right )" class="mathcode" src="https://images2.imgbox.com/e3/77/cy2DDHel_o.png">, <img alt="f\left ( i,d_{u} \right )" class="mathcode" src="https://images2.imgbox.com/25/38/dYxBqDNj_o.png">发往fl server。</p> 
<p> 与此同时，在item server，物品特征隐向量矩阵V也会得到更新（其中会用到物品特征），新的物品隐向量<img alt="v_{d_{y}}^{*}" class="mathcode" src="https://images2.imgbox.com/88/8f/KoK2iJP8_o.png">计算方式如下：</p> 
<p class="img-center"><img alt="" height="50" src="https://images2.imgbox.com/c6/22/1onRt99H_o.png" width="260"></p> 
<p> 更新完成后，在此基础上计算<img alt="f\left ( j,d_{y} \right )" class="mathcode" src="https://images2.imgbox.com/d4/6d/34ks1sri_o.png">(用于之在fl server计算<img alt="\frac{\partial J}{\partial q_{j}}" class="mathcode" src="https://images2.imgbox.com/72/94/CqVsCoST_o.png">以更新Q)：</p> 
<p class="img-center"><img alt="" height="45" src="https://images2.imgbox.com/92/97/YohAdg3L_o.png" width="288"></p> 
<p> 之后再将<img alt="f\left ( j,d_{y} \right )" class="mathcode" src="https://images2.imgbox.com/cc/01/w9i4zSQk_o.png">发给fl server。</p> 
<p> 而在fl server接收<img alt="f\left ( j,i \right )" class="mathcode" src="https://images2.imgbox.com/2d/e0/U0Oz3CbG_o.png">, <img alt="f\left ( i,d_{u} \right )" class="mathcode" src="https://images2.imgbox.com/03/27/ot7T3l97_o.png">, <img alt="f\left ( j,d_{y} \right )" class="mathcode" src="https://images2.imgbox.com/3b/65/CcV2UC8H_o.png">后，按照下列两个式子计算梯度并更新Q和U:</p> 
<p class="img-center"><img alt="" height="120" src="https://images2.imgbox.com/f4/7a/R3XgnYa9_o.png" width="421"></p> 
<p> 然后又将Q和U发往各client，将Q发往item server，以此循环往复。</p> 
<p> 综上，该篇论文按照损失函数J对多视角数据矩阵R, X, Y共同进行矩阵分解，以学习隐向量矩阵P,Q,U和V，具体算法采用了联邦交替最小二乘法。可以注意到联邦场景下对参数矩阵Q和U进行的更新并不需要对用户数据进行聚合（虽然Q和U的更新依赖于用户数据）。</p> 
<h3> 2.2 FTL-IJCAI21 《A federated multi-view deep learning framework for privacy-preserving recommendations》</h3> 
<p> 上面提到的是基于联邦矩阵分解的推荐模型，而下面要介绍的是联邦场景下基于内容的(content-based)推荐模型，它侧重将用户或者物品的特征信息作为输入特征来建模。具体的模型采用我们第1部分中所叙述的多视角DSSM模型。<strong>该模型同时满足了多个client数据的隐私性和单个client中多视角数据的隐私性，属于横向+纵向类型</strong>。</p> 
<p>不过本文与原始多视角模型中共享用户视角的特征不同，本文共享的是物品视角的特征。设共有C个client，第c个client中的本地数据集表示为<img alt="D^{c}=\left \{ x_{I},x_{1},...,x_{D} \right \}" class="mathcode" src="https://images2.imgbox.com/53/25/dxJVmwNn_o.png">。这里x1, ..., xD为用户在D个不同App中记录的多视角特征数据，而物品视角数据集<img alt="x_{I}\in \mathbb{R}^{d_{I}}" class="mathcode" src="https://images2.imgbox.com/14/51/54HVxT35_o.png">从server下载，比如移动App的后端。DSSM模型将从各个App视角数据集<img alt="x_{I},x_{1},...,x_{D}" class="mathcode" src="https://images2.imgbox.com/c3/30/WnszI7v2_o.png">和物品数据集<img alt="x_{I}" class="mathcode" src="https://images2.imgbox.com/4e/de/tS5cMZPj_o.png">中分别提取隐向量。算法的目标是为每个视角学得一个非线性映射<img alt="f\left ( \cdot \right )" class="mathcode" src="https://images2.imgbox.com/52/98/LihMjNbg_o.png">以使物品视角隐向量和多个用户视角隐向量相似度的和最大化。第c个client的目标定义如下：</p> 
<p class="img-center"><img alt="" height="92" src="https://images2.imgbox.com/3e/4d/ipmdtGBn_o.png" width="496"></p> 
<p> 这里<img alt="N_{c}" class="mathcode" src="https://images2.imgbox.com/72/1f/WywhPHQW_o.png">表示client c中用户-物品对的数量，第i个用户-物品对样本拥有一个物品视角的输入特征<img alt="x_{i,I}" class="mathcode" src="https://images2.imgbox.com/ae/ea/UIN4Mlei_o.png">和其对应的用户视角特征<img alt="x_{i,a}" class="mathcode" src="https://images2.imgbox.com/06/d5/bnXTqqS8_o.png">，这里a是样本i对应用户视角的索引。y表示<img alt="f\left ( \cdot \right )" class="mathcode" src="https://images2.imgbox.com/76/31/HnTWo2FZ_o.png">的映射结果，<img alt="\gamma" class="mathcode" src="https://images2.imgbox.com/b3/f5/SikYzd0K_o.png">是温度参数。</p> 
<p> 联邦多视角DSSM模型（FL-MV-DSSM）求解算法的架构如下所示：</p> 
<p><img alt="" height="467" src="https://images2.imgbox.com/35/aa/xnHksNwb_o.png" width="1200"></p> 
<p style="text-align:center;">联邦多视角DSSM模型（FL-MV-DSSM） </p> 
<p> </p> 
<p>（a）FL-MV-DSSM和（b）SEMI-FL-MV-DSSM 都以传统的FedAvg算法为基础，且它们都需要server提供物品数据供所有client共享。不过在FL-MV-DSSM中每个client c中用户子模型和物品子模型的梯度会根据本地用户数据和本地物品数据进行计算，然后在server端对用户和物品子模型的梯度进行聚合；而SEMI-FL-MV-DSSM则只会聚合物品子模型的梯度，而不会聚合用户子模型的梯度。</p> 
<p>注意，client在将梯度发往server前，会在本地先多个视角所算得的物品子模型梯度聚合（注意，D个用户视角共享同一个物品特征，会总共算得D个物品子模型的梯度）；而为了保护各视角梯度中蕴含的敏感信息，FL-MV-DSSM使用差分隐私技术向各个视角所算得的物品子模型梯度中加入高斯噪声。在本地聚合完成后，client又会再将前述物品子模型梯度同D个用户子模型的梯度进行加密，然后发往server。</p> 
<h3> 2.3 SIGIR21 《FedCT: Federated Collaborative Transfer for Recommendation》</h3> 
<p> <strong>本论文提出的模型满足了多个client数据的隐私性和单个client中跨域数据的隐私性，也属于横向+纵向类型</strong>。不过与前文采用的方法不同，本文提出的DUE(Decentralized User Encoding)模型并没有利用一个中间视角的数据来训练共享子模型，而是采用变分自编码器（VAE）来生成一个单独的用户编码隐向量，该隐向量可以被所有领域共享。在模型训练过程中，每个领域会使其对应的用户隐向量去对齐这个领域共享的用户隐向量。</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/17/f2/GgL0htkj_o.png" width="725"></p> 
<p style="text-align:center;"> 领域两两间的知识迁移和基于中间表示的迁移方式对比</p> 
<p> 上面的图 (a) 中展示的为领域-领域两两间的EMCD[8]式（直接对齐）知识迁移，而 (b) 则为本文提出的DUE模型中所采用的基于中间表征的迁移方式。用户的表征<img alt="X_{u}=\left [ U_{u}^{(d_{1})},...,U_{u}^{(d^{_{D}})} \right ]" class="mathcode" src="https://images2.imgbox.com/f3/f3/XSEexvFn_o.png">。事实上，(a) 中的这种方法直接迁移用户表征有违隐私性，而且当领域数量增长时计算量会很大。而 (b) 则更能保证隐私性，而且其计算代价也不会随领域数量快速增长。此外，(b) 这种方法有利于各领域随时加入（plug-in）和退出（plug-out），更具灵活性。</p> 
<p>设领域集合为<img alt="" height="16" src="https://images2.imgbox.com/73/92/Pivf5asR_o.png" width="105">。对每个领域d∈D，将起对应的物品集合表示为Id(大小为Nd)。设领域之间的物品无重叠，即满足<img alt="" height="16" src="https://images2.imgbox.com/3e/55/IqIbRzAf_o.png" width="190">。设每个client对应一个用户，一共有C个用户。一个领域d可能只涉及到用户集合的子集<img alt="" height="19" src="https://images2.imgbox.com/fa/31/XaanfvKJ_o.png" width="57">，一个用户u∈U也可能只涉及到领域集合的子集<img alt="" height="18" src="https://images2.imgbox.com/71/99/wodvOSPO_o.png" width="64">。每个领域都有对应的共现矩阵Rd及其协同过滤模型fd，fd为一个给定用户-物品对(u,i)预测评分结果:<img alt="" height="25" src="https://images2.imgbox.com/14/a6/KxZ4RJxW_o.png" width="124">的函数，这里<img alt="" height="21" src="https://images2.imgbox.com/7a/e3/wro8dfzy_o.png" width="79">表示用户u在领域d的表征，Ld为用户表征的维度。在本文的边缘跨领域推荐场景下，fd和U(d)根据特定领域的协同过滤目标函数<img alt="" height="23" src="https://images2.imgbox.com/03/50/epvjG5q0_o.png" width="28">进行预训练，并作为该领域对应的本地预训练模型使用。 </p> 
<p> 加上server端，整体的联邦跨领域迁移架构如下图所示（图中仅仅展示了单个用户）：</p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/6c/7c/hKtLtxIh_o.png" width="712"></p> 
<p style="text-align:center;">FedCT中联邦跨领域迁移架构示意图 </p> 
<p> 这里设Sd为server端的领域服务商存储空间（存有fd和Ud）；<img alt="\varepsilon _{u}" class="mathcode" src="https://images2.imgbox.com/4d/21/9QoCZAZv_o.png">为用户在设备上所拥有的个人存储空间（任何领域都能对其进行访问），用于存放共享隐向量<img alt="z_{u}" class="mathcode" src="https://images2.imgbox.com/7b/e5/1kCfPX6p_o.png">；<img alt="\varepsilon _{d,u}" class="mathcode" src="https://images2.imgbox.com/e7/fd/n4YuxTrk_o.png">为领域服务商在用户设备上的存储空间。它能够与Sd同步获取预训练模型并与用户的个人存储空间<img alt="\varepsilon _{u}" class="mathcode" src="https://images2.imgbox.com/f3/a7/2G0CVogG_o.png">通信。正如图中所示，对任意领域d和d′而言，本文在设定上禁止<img alt="" height="21" src="https://images2.imgbox.com/5b/8e/uK69wNRZ_o.png" width="75">和<img alt="" height="20" src="https://images2.imgbox.com/4d/3e/7Z2N4uUQ_o.png" width="79">的信息交互。不过，正如我们前面所说的，本文允许用户个人存储空间<img alt="\varepsilon _{u}" class="mathcode" src="https://images2.imgbox.com/4e/a8/smqlj7lw_o.png">和client端任意领域存储空间<img alt="\varepsilon _{d,u}" class="mathcode" src="https://images2.imgbox.com/2f/01/nHVN2X6j_o.png">的信息交换，这也就意味着用户个人存储空间充当了中间代理的作用，以协调间接性的知识迁移。</p> 
<p>本文的最终目标是在为目标领域<img alt="" height="19" src="https://images2.imgbox.com/19/58/x8TsoFbO_o.png" width="53">的冷启动用户提供推荐（使用根据其它领域的用户表征做为辅助信息）。给定多个领域的用户表征做为训练数据，则问题就成为了学习对用户表示进行迁移的模型：<img alt="" height="21" src="https://images2.imgbox.com/52/0d/vu0IdDoq_o.png" width="200">，该模型将来自所有领域的用户信息映射到dt：</p> 
<p class="img-center"><img alt="" height="34" src="https://images2.imgbox.com/c5/d0/Pp2R9RQZ_o.png" width="126"></p> 
<p> 这里假定用户的表征<img alt="" height="31" src="https://images2.imgbox.com/6e/b2/iuveKlzj_o.png" width="165">在优化和推断的过程中是固定的。若是在中心化环境下，所有领域协作训练一个共享的g是很容易的。但正如开头所说，直接迁移emebddings会带来隐私性的问题，而这就需要使用用户存储空间中的共享编码隐向量zu这一中介了。</p> 
<p> 由于需要隐向量与用户emebddings的双向编码与恢复，故采用AE/VAE对用户隐向量进行建模。具体地，本文为每个领域d都设置了一个VAE gd(包含编码器和解码器）。如下图所示，设<img alt="" height="22" src="https://images2.imgbox.com/76/10/PkPVKsjF_o.png" width="71">，则gd由一个编码器<img alt="" height="20" src="https://images2.imgbox.com/ba/37/81dzD3MY_o.png" width="143">(参数为Φd，负责根据特定领域的用户表征U(d)生成zu)和一个解码器<img alt="" height="20" src="https://images2.imgbox.com/ce/bb/5va36Oav_o.png" width="143">（参数为Θd，负责根据zu生成<img alt="" height="24" src="https://images2.imgbox.com/95/dd/kVNKXs8K_o.png" width="33">）组成。这里<img alt="" height="20" src="https://images2.imgbox.com/90/fb/Koi07uFk_o.png" width="66">生成的<img alt="" height="25" src="https://images2.imgbox.com/36/15/ucXBuiTM_o.png" width="32">含有来自所有领域的丰富信息，将会被用于之后的推荐服务。另一方面，每个领域也会不断更新自己的编码器和解码器。</p> 
<p><img alt="" height="601" src="https://images2.imgbox.com/50/65/7MYQDql4_o.png" width="1200"></p> 
<p>下面我们来看论文VAE部分的模型和损失函数细节。这里论文采用生成模型的视角（关于生成模型的一些前置知识可以参见我的文章<a href="https://zhuanlan.zhihu.com/p/568100850" rel="nofollow" title="《寻找领域不变量：从生成模型到因果表征 》">《寻找领域不变量：从生成模型到因果表征 》</a>），对隐向量 zu 进行变分推断。 </p> 
<p class="img-center"><img alt="" height="256" src="https://images2.imgbox.com/a1/e2/1XrUqv3h_o.png" width="242"></p> 
<p> 首先，将用户表征 Xu 视为观测数据，它由隐向量 zu 生成：</p> 
<p class="img-center"><img alt="" height="43" src="https://images2.imgbox.com/df/b9/yiebzH2j_o.png" width="380"></p> 
<p>注意，这里论文假设各领域的独立性，有： <img alt="" height="28" src="https://images2.imgbox.com/3a/27/QVvCoW5e_o.png" width="143"> 。 zu 的后验分布 <img alt="" height="24" src="https://images2.imgbox.com/f1/3a/e3dUtYq1_o.png" width="124"> 难以推断，故采用其变分近似 <img alt="" height="22" src="https://images2.imgbox.com/ef/a6/Jq6QxOzf_o.png" width="120"> 。优化目标为最大化与用户表征 Xu 相关联的变分下界：</p> 
<p class="img-center"><img alt="" height="67" src="https://images2.imgbox.com/2b/61/lmrnGkRC_o.png" width="483"></p> 
<p> 用户 u 本地训练的损失函数损失函数由 Ldec 与 Lenc 两部分组成：</p> 
<p class="img-center"><img alt="" height="27" src="https://images2.imgbox.com/4c/16/cnTLJ69u_o.png" width="203"></p> 
<p> 其中， Ldec 在最大化解码分布 <img alt="" height="19" src="https://images2.imgbox.com/95/b5/9dBA2IKo_o.png" width="40">的同时，拉近共享隐向量分布 <img alt="" height="20" src="https://images2.imgbox.com/d1/8a/hvSWF2f4_o.png" width="99"> 和其先验 <img alt="" height="18" src="https://images2.imgbox.com/86/51/TsqlZqlY_o.png" width="44"> 的距离：</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/7d/88/ebd1Micx_o.png" width="1037">  <img alt="" height="23" src="https://images2.imgbox.com/44/59/7oVP2wPv_o.png" width="40">则拉近隐向量近似后验 <img alt="" height="30" src="https://images2.imgbox.com/1b/63/XW13nNzU_o.png" width="128"> 和共享隐向量分布的距离：</p> 
<p class="img-center"><img alt="" height="49" src="https://images2.imgbox.com/82/fe/NoRVsWvO_o.png" width="388"></p> 
<p> 接下来设 <img alt="" height="20" src="https://images2.imgbox.com/55/7d/ZZu3raj5_o.png" width="186"> ，<img alt="" height="19" src="https://images2.imgbox.com/fb/6a/K1Di39GM_o.png" width="118">，<img alt="" height="27" src="https://images2.imgbox.com/72/99/jG6tLzFd_o.png" width="146"> ，且通过重参数化来完成Zu的采样过程： <img alt="" height="21" src="https://images2.imgbox.com/45/0a/9wE06ENN_o.png" width="88">， <img alt="" height="26" src="https://images2.imgbox.com/a5/5d/uLPUJoup_o.png" width="199"> 。</p> 
<p>将编码器的分布函数代入上式，我们就能进一步地将损失函数写为:</p> 
<p class="img-center"><img alt="" height="168" src="https://images2.imgbox.com/c4/3c/HT27PabH_o.png" width="414"></p> 
<p>对于解码器分布 <img alt="" height="20" src="https://images2.imgbox.com/4a/41/yXoGgLJ0_o.png" width="34">，虽然前面假定了各领域条件独立，即各领域允许有不同的解码器损失函数，但这里为了简便，我们统一定义为高斯核：</p> 
<p class="img-center"><img alt="" height="73" src="https://images2.imgbox.com/3d/2a/RTGagGbX_o.png" width="380"></p> 
<p>这里 <img alt="" height="26" src="https://images2.imgbox.com/55/7c/C2IM3ruV_o.png" width="121">，且方差 <img alt="\sigma" class="mathcode" src="https://images2.imgbox.com/f2/9e/tgt4C65P_o.png"> 在实验中固定，此时即为最小化均方误差。</p> 
<p>最后我们可以得到联邦优化过程如下：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/bd/3b/RYDo4Ys1_o.png" width="1176"></p> 
<p>注意，这里在用户 u 本地进行联邦平均的是各领域迭代更新之后的用户隐向量 <img alt="" height="21" src="https://images2.imgbox.com/2b/77/rLQBKBF5_o.png" width="41"> ，而不是各领域的用户embeddings本身。<strong>不同领域的用户embeddings是不能直接拿来混合平均的，因为这样会导致领域的信息丢失（这也就是为什么会有EMCDR等基于表征对齐的方法出现的原因）</strong>。正如上面所说的，本文采取的方案则更进一步，在用户表征基础上提取用户隐向量，并使得各领域的用户隐向量去对齐共享的用户隐向量，从而在隐私保护的条件下来完成知识迁移。此外，在用户本地的编码器和解码器参数也是按照不同领域来分别进行的平均。</p> 
<h3 id="h_553492147_7">2.4 WWW22 《Differential Private Knowledge Transfer for Privacy-Preserving Cross-Domain Recommendation》</h3> 
<p><strong>本文不考虑用户间数据的隔离性，只考虑在两个相互隔离的领域间进行知识迁移，属于纵向类型</strong>。本文假定两个领域（源域和目标域）之间有着相同的用户，但是有着不同的用户-物品共现矩阵，目标在于在保证数据隐私的情况下，利用原域的数据以提高目标域的推荐表现。本文基于Johnson-Lindenstrauss变换(JLT)将共现矩阵加以差分隐保护，然后使用深度自编码器和深度学习网络来分别对源域和目标域中的共现矩阵进行建模，</p> 
<p>本文采用的技术解决方案具体描述如下两个阶段：</p> 
<p>在第一阶段，先基于JLT变换将共现矩阵由高维空间映射到低维空间空间，能够在够保护数据隐私（即无法辨识出某个用户的评分情况）的同时保持用户间的几何相似度（即相似评分的用户有相似品味）。此外本文还给出了考虑到稀疏情形的JLT(SJLT)，能够进一步减少JLT的计算复杂度并解决源域的数据稀疏性问题，其中使用了sub-Gaussian随机矩阵和Hadamard变换。</p> 
<p>在第二阶段，本文提出了一个异构的跨领域推荐模型（HeteroCDR），该模型使用深度自编码器和DNN来分别对差分隐私保护的源域共现矩阵和目标域共现矩阵进行建模。此外，论文对这两个网络学得的用户embeddings进行对齐，从而使知识能够进行迁移。</p> 
<p> 论文采用JLT随机变换以得到差分隐私保护的共现矩阵R′。JLT将一个来自<img alt="" height="21" src="https://images2.imgbox.com/7f/89/LHdbGJU7_o.png" width="23">的向量变换到<img alt="" height="23" src="https://images2.imgbox.com/4b/24/hTX1udf2_o.png" width="23">：<img alt="" height="20" src="https://images2.imgbox.com/67/e7/C2B2Px4D_o.png" width="96">。这里<img alt="" height="21" src="https://images2.imgbox.com/c4/fd/Povy8auz_o.png" width="128">，<img alt="" height="21" src="https://images2.imgbox.com/56/0c/lsRJv2SH_o.png" width="46">为所有元素为1的稠密矩阵。</p> 
<p>而稀疏架构下的JLT和JLT的作用原理相似，也是定义一个从从高维到低维空间的映射，同时大概率保持变换后向量的l2范数不变。将稀疏向量从<img alt="" height="18" src="https://images2.imgbox.com/cd/10/1190wXJN_o.png" width="22">转换到<img alt="" height="23" src="https://images2.imgbox.com/ff/e5/A0SXKey6_o.png" width="25">的SJLT定义为：<img alt="" height="20" src="https://images2.imgbox.com/9c/92/5DJVn6eI_o.png" width="96">，这里<img alt="" height="21" src="https://images2.imgbox.com/54/8c/EEY0AMP1_o.png" width="340"></p> 
<p class="img-center"><img alt="" height="60" src="https://images2.imgbox.com/de/c2/R9wevwgI_o.png" width="416"></p> 
<p><img alt="" height="18" src="https://images2.imgbox.com/f3/81/WUZwmBLm_o.png" width="159">是标准化后的Hadamard矩阵(每个元素都是 +1或−1且每行互相正交)，这里<img alt="" height="20" src="https://images2.imgbox.com/7a/10/GqpHncWb_o.png" width="139">是一个按位运算并模2的内积，D是个随机对角矩阵并满足</p> 
<p class="img-center"><img alt="" height="24" src="https://images2.imgbox.com/85/25/7sO8qF6e_o.png" width="259"></p> 
<p> 整个隐私保护下的跨领域推荐架构如下：</p> 
<p style="text-align:center;"><img alt="" height="685" src="https://images2.imgbox.com/49/4a/7iFbOsT3_o.png" width="1200">基于差分隐私和自编码器的跨领域推荐</p> 
<p> 如图所示，将<img alt="" height="23" src="https://images2.imgbox.com/10/eb/CqJdFXsL_o.png" width="97">变换到<img alt="" height="19" src="https://images2.imgbox.com/12/c4/XD4b5q73_o.png" width="88">后，会通过自编码器来学习用户的embeddings（用于源域和目标域的知识迁移）。先通过编码器获取用户embeddings：<img alt="" height="30" src="https://images2.imgbox.com/11/5a/kaXqwC7Q_o.png" width="168">，这里ℎ是用户embeddings的维度；然后解码器对共现矩阵进行重构：<img alt="" height="25" src="https://images2.imgbox.com/c4/ce/AVTKzRes_o.png" width="169">。重构的loss为：</p> 
<p class="img-center"><img alt="" height="52" src="https://images2.imgbox.com/5f/9e/4jPoaR9B_o.png" width="198"></p> 
<p>这里F为均方误差。</p> 
<p>此外，论文对源域和目标域用户embeddings进行对齐以完成知识迁移。在对齐模型中，论文将用户embeddings的loss表示如下：</p> 
<p class="img-center"><img alt="" height="48" src="https://images2.imgbox.com/b5/de/LPcYnwCt_o.png" width="187"></p> 
<p> 在目标域B方面，采用深度矩阵分解模型来拟合用户评分，其核心思想为最小化真实评分<img alt="" height="27" src="https://images2.imgbox.com/5c/4a/lYCg9Ns2_o.png" width="21">和预测评分<img alt="" height="25" src="https://images2.imgbox.com/09/34/GKv24F0P_o.png" width="25">之间的交叉熵，这里预测评分由多层全连接网络输出。该网络会先计算计算用户和物品的隐向量<img alt="" height="21" src="https://images2.imgbox.com/85/a3/ojK6lpSJ_o.png" width="75">和<img alt="" height="23" src="https://images2.imgbox.com/78/99/UJL7O4L1_o.png" width="60">(ℎ表示隐向量维度)，然后计算用户和物品的隐向量的余弦相似度做为评分预测值，即<img alt="" height="24" src="https://images2.imgbox.com/a5/ad/znEDW9SC_o.png" width="105">。损失函数描述如下：</p> 
<p class="img-center"><img alt="" height="61" src="https://images2.imgbox.com/4b/08/zlJFBl36_o.png" width="523"></p> 
<p> 最终的完整损失函数为以上三个损失函数之和：</p> 
<p class="img-center"><img alt="" height="33" src="https://images2.imgbox.com/70/25/A5s9cmJm_o.png" width="258"></p> 
<h3 id="h_553492147_8">2.5 CIKM22 《<strong>FedCDR: Federated Cross-Domain Recommendation for Privacy-Preserving Rating Prediction</strong>》[7]</h3> 
<p><strong>本论文提出的模型满足了多个client数据的隐私性，但单个client中跨领域数据是可以共享的，属于横向类型</strong>。本文的亮点在于使每个客户端维护一个用户个性化模型，聚合时只将物品模型和领域迁移模型的参数上传服务器，而将用户个性化模型留在客户端。这样，本文的方法在解决了不同客户端之间数据异构问题的同时，也保证了用户隐私并减少了参数通信量（说实话，个人感觉这个创新点太水）。</p> 
<p>如下是本文算法的框架示意图：</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/27/30/9uNaKwA5_o.png" width="1200"></p> 
<p>图中展示了种类型的客户端，包括只有A领域数据的客户端、同时具有A、B两个领域数据的客户端以及只有B领域数据的客户端。每个客户端利用评分预测模型预训练得到个性化的用户模型和物品模型后，再采用EMCDR[8]中的跨域映射（mapping）手法，将领域A的用户隐向量变换到领域B（B到A同理）。事实上，这里的所谓跨域映射操作非常类似于异构知识图谱的对齐操作（可以参见我的文章<a href="https://zhuanlan.zhihu.com/p/548242915" rel="nofollow" title="《知识图谱实体对齐：基于平移（translation）嵌入的方法 》">《知识图谱实体对齐：基于平移（translation）嵌入的方法 》</a>）。之后在上传参数时将用户个性化模型参数留在本地，而将物品模型和跨域迁移模型的参数上传到服务器。下面我们分别叙述客户端本地的各个模型部件：</p> 
<p><strong>评分（Rating）预测模型</strong></p> 
<p>评分预测模块采用矩阵分解[9]模型得到用户和物品的隐向量。对于物品直接进行嵌入得到物品隐向量；而对于用户，为了保证其隐私，论文设计了一个个性化模块 ℎ 以获取其个性化用户向量：</p> 
<p class="img-center"><img alt="" height="47" src="https://images2.imgbox.com/a4/66/QFtmaMKX_o.png" width="122"></p> 
<p>训练的损失函数可定义为：</p> 
<p class="img-center"><img alt="" height="57" src="https://images2.imgbox.com/fc/80/cZcGOJko_o.png" width="252"></p> 
<p> 评分预测模型的示意图如下所示：</p> 
<p class="img-center"><img alt="" height="334" src="https://images2.imgbox.com/88/c6/8TcvoL2Z_o.png" width="488"></p> 
<p> <strong>跨域推荐（CDR）模型</strong></p> 
<p>将采用EMCDR中的跨域映射手法。设有领域A和B，一个MLP <img alt="" height="20" src="https://images2.imgbox.com/dd/ec/7OBCBXCl_o.png" width="62"> 负责将领域A的知识迁移到B（也即将A领域的用户隐向量变换到B领域），变换后的用户向量 <img alt="" height="22" src="https://images2.imgbox.com/c4/00/xAnsxeIM_o.png" width="46"> 能够被计算为（B到A同理）：</p> 
<p class="img-center"><img alt="" height="105" src="https://images2.imgbox.com/51/ee/ZtZ8y2gP_o.png" width="546"></p> 
<p> (PS：在推荐阶段，变换后的用户向量<img alt="" height="21" src="https://images2.imgbox.com/5a/06/jrSxtjyQ_o.png" width="41"> 和<img alt="" height="24" src="https://images2.imgbox.com/c7/6d/e7sOFHtG_o.png" width="47"> 将被用于冷启动用户推荐）</p> 
<p> 跨域推荐模型的示意图如下所示：</p> 
<p class="img-center"><img alt="" height="445" src="https://images2.imgbox.com/e4/ba/eM82byPf_o.png" width="498"></p> 
<p>在本地评分预测模型的预训练和跨域推荐模型（迁移映射）的训练都完毕之后，客户端将A和B领域的物品隐向量和迁移模型参数分别上传到A、B领域对应的服务器，由A、B两个服务器来分别对物品模型参数和跨领域迁移模型参数进行聚合。<strong>注意，用户模型参数要留在本地。此外，本文对于A和B领域的物品模型参数和迁移模型参数也是分别进行的平均，而不是混在一起进行平均</strong>。</p> 
<h3 id="h_553492147_9">2.6 AAAI23 《<strong>Win-Win: A Privacy-Preserving Federated Framework for Dual-Target Cross-Domain Recommendation</strong>》[13]</h3> 
<p><strong>本文不考虑用户间数据的隔离性，只考虑在两个相互隔离的领域间进行知识迁移，属于纵向类型</strong>。本文设计了一个正交变换矩阵+局部差分隐私（LDP）技术来进行用户embeddings的双向跨域迁移（本文的创新点在于双向迁移，即标题中的Win-Win，不过个人感觉这个创新点也太水）。本文方法整体的架构如下图所示：</p> 
<p><img alt="" height="728" src="https://images2.imgbox.com/d4/d1/EQqwV7zf_o.png" width="1200"></p> 
<p>首先，本文采用深度矩阵分解模型[16]得到用户和物品的embeddings（以领域A为例）：</p> 
<p class="img-center"><img alt="" height="58" src="https://images2.imgbox.com/48/ce/OHT7zmNW_o.png" width="308"></p> 
<p>这里 <img alt="" height="23" src="https://images2.imgbox.com/9f/75/7NyPkMj3_o.png" width="33"> 为ratings矩阵 <img alt="" height="20" src="https://images2.imgbox.com/a5/ab/l2d1eVLA_o.png" width="30"> 的第 i 行（对应第 i 个用户）， <img alt="" height="25" src="https://images2.imgbox.com/05/8c/nWDyVxAJ_o.png" width="31"> 为ratings矩阵 <img alt="" height="20" src="https://images2.imgbox.com/22/ef/U3bb6n6r_o.png" width="30"> 的第 j 列（对应第 j 个物品）。</p> 
<p>然后，本文引入一个正交矩阵来进行领域间的embeddings迁移。这里采用正交矩阵的原因是正交变换保内积，从而变换后的用户embeddings之间的相似度不变；此外，正交矩阵等于其转置，因此若已知 A 到 B 的变换矩阵的话，从 B 到 A 的变换能够直接使用其转置以简化学习过程与降低计算复杂度。设领域 A 的用户 i 的embeddings <img alt="" height="21" src="https://images2.imgbox.com/8d/73/TuC8Slg8_o.png" width="26"> 变换到领域 B 去后表示为 <img alt="" height="23" src="https://images2.imgbox.com/a1/8d/ajRDgMSR_o.png" width="89"> ，领域 B 的用户 i 的embeddings <img alt="" height="23" src="https://images2.imgbox.com/07/e2/Rlj2SqSH_o.png" width="22"> 变换到领域 A 去后表示为 <img alt="" height="24" src="https://images2.imgbox.com/bb/04/CPYh4EXt_o.png" width="83"> ，则我们有：</p> 
<p class="img-center"><img alt="" height="58" src="https://images2.imgbox.com/24/60/1Kmt8dpl_o.png" width="215"></p> 
<p> 这里 <img alt="" height="19" src="https://images2.imgbox.com/46/3c/PlfIe9OA_o.png" width="108"> 分别是领域 A 和 B 的正交变换矩阵，它们在本地更新完成（即更新为 <img alt="" height="24" src="https://images2.imgbox.com/9f/63/UmRlLJdD_o.png" width="138"> ）之后会相互交换并聚合，因此是一致同步且相等的。 [⋅]T⊤ 表示矩阵转置。 <img alt="" height="22" src="https://images2.imgbox.com/ea/ff/4SeIGHgV_o.png" width="69"> 表示均值为0，方差为 <img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/09/30/wD21JDAq_o.png"> 的Laplace噪声（其中方差用于控制噪声强弱）。 <img alt="\lambda" class="mathcode" src="https://images2.imgbox.com/6e/5e/hlcG2np0_o.png"> 越大，则噪声越大且越利于隐私保护。</p> 
<p> 最后，文章设计了自适应embeddings融合机制来对领域原embeddings和变换过来的embeddings进行融合（仍以领域 A 为例），自适应的门控选择向量计算如下：</p> 
<p class="img-center"><img alt="" height="63" src="https://images2.imgbox.com/b1/be/YQ86OLYz_o.png" width="395"></p> 
<p>之后以此权重对用户的embeddings进行门控聚合：</p> 
<p class="img-center"><img alt="" height="30" src="https://images2.imgbox.com/f5/b8/qeku5v1O_o.png" width="241"></p> 
<p>直观地理解，若 <img alt="" height="25" src="https://images2.imgbox.com/22/6d/BugzCiH2_o.png" width="23"> 和 <img alt="" height="24" src="https://images2.imgbox.com/34/11/MddXmGXJ_o.png" width="34"> 差异越大（领域gap越大），则固守原领域embeddings <img alt="" height="25" src="https://images2.imgbox.com/1f/25/avyC0ZEb_o.png" width="23"> 的旧知识就越多，接受 <img alt="" height="24" src="https://images2.imgbox.com/ae/d9/cIGdhjE0_o.png" width="34"> 的新知识就越少。这在直观上确实可以在一定程度上缓解负迁移问题。</p> 
<p>最后，作者运用得到的用户和物品的embeddings来计算内积相似度，并据此来计算归一化交叉熵损失（参考深度矩阵分解论文[16]）：</p> 
<p class="img-center"><img alt="" height="81" src="https://images2.imgbox.com/ef/4e/pX1smjWU_o.png" width="529"></p> 
<h3 id="h_553492147_10"><strong>2.7 AAAI23 《PPGenCDR: A Stable and Robust Framework for Privacy-Preserving Cross-Domain Recommendation》[14]</strong></h3> 
<p><strong>本文不考虑用户间数据的隔离性，只考虑在两个相互隔离的领域间进行知识迁移，属于纵向类型</strong>。本文的亮点在于通过GAN来在隐私保护的前提下对源域私有数据（即用户ratings）的分布进行建模，并将隐私保护后的源域数据做为知识迁移到目标域，以提高目标域的推荐表现。本文方法整体的架构如下图所示：</p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/c3/00/Ki8I3SY3_o.png" width="1200"></p> 
<p> 如上图所示，本文由位于源域的隐私保护生成器模块（SPPG，包括SPP和GS两部分），和位于目标域的跨域推荐模块（RCDR）组成。隐私保护模块用于生成隐私保护后的源域用户数据 <img alt="" height="21" src="https://images2.imgbox.com/36/d7/STisTins_o.png" width="30">（注意，生成的 <img alt="" height="22" src="https://images2.imgbox.com/b1/d7/fOvRkt9K_o.png" width="32"> 数据类型为浮点型），因为因为我不是搞隐私保护方向的。因此就不再对此详细展开叙述，感兴趣的童鞋可以去阅读原始论文。接下来重点叙述一下本文所设计的跨域推荐模块，也即论文如何同时利用源域的隐私保护数据<img alt="" height="23" src="https://images2.imgbox.com/7d/f1/2fLKdx9b_o.png" width="33">和目标域的稀疏数据 <img alt="" height="22" src="https://images2.imgbox.com/28/60/ajX873Wi_o.png" width="29"> 来共同提高目标域的推荐表现。</p> 
<p> 设用户 u 经过隐私保护后的ratings数据为 <img alt="" height="25" src="https://images2.imgbox.com/29/10/Yg16xtjo_o.png" width="85"> （ K 为源域的维度大小），本文设计了一个profile extraction模块来通过重构 <img alt="" height="22" src="https://images2.imgbox.com/64/e8/A1FmtQgz_o.png" width="35">来提取隐表征 <img alt="" height="24" src="https://images2.imgbox.com/86/73/q9zRGud4_o.png" width="152"> 做为用户的profile：</p> 
<p class="img-center"><img alt="" height="68" src="https://images2.imgbox.com/63/94/MXinpXkm_o.png" width="341"></p> 
<p> 这里 N 为batch size。此外，在目标域也采用Embedding Lookup操作由目标域的ratings RT 得到目标域的用户profiles ZT 和物品表征 VT （注意，目标域的 RT 数据类型为0-1型），并设计了profile alignment模块来进行源域和目标域用户的表征对齐：</p> 
<p class="img-center"><img alt="" height="56" src="https://images2.imgbox.com/fa/d8/CGaUJyCx_o.png" width="240"></p> 
<p> 最后，推荐预测模块基于用户的profile ZT 及物品的表征 vT 来最小化交叉熵 <img alt="" height="24" src="https://images2.imgbox.com/fd/a1/LmeGyLz8_o.png" width="53"> ：</p> 
<p class="img-center"><img alt="" height="53" src="https://images2.imgbox.com/e3/3c/RIvDAuGm_o.png" width="229"></p> 
<p> 这里 <img alt="" height="26" src="https://images2.imgbox.com/02/11/GZp9CDnt_o.png" width="131"> 为用户 u 在目标域中的的预测偏好。</p> 
<p> 为了增强目标域推荐表现的鲁棒性，作者还将 ZT 与 VT 沿维度方向进行解耦，解耦后的特征将会直接被用于预测目标域的用户偏好。为了完成用户表征的解耦，论文首先构建了一个cross correlation矩阵 <img alt="" height="21" src="https://images2.imgbox.com/54/c0/y2h6pVN4_o.png" width="88"> 来度量用户归一化表征的不同维度间的相似性，该矩阵的计算公式为 <img alt="" height="20" src="https://images2.imgbox.com/be/67/nKfBziiX_o.png" width="392">。为了达到解耦的目的，我们希望该矩阵的对角元素 <img alt="" height="27" src="https://images2.imgbox.com/b2/26/rZBDtljs_o.png" width="38"> 去逼近1（同一个维度的表征一致），而其余元素 <img alt="" height="28" src="https://images2.imgbox.com/54/b3/XqKXLlPn_o.png" width="38">去逼近0（不同维度的表征相互独立）。相似地，本文也为物品表征 VT 构建了cross-correlation矩阵 <img alt="" height="28" src="https://images2.imgbox.com/2b/ab/oiXJSa6d_o.png" width="101">并希望其满足同样的条件。最后，为了完成解耦操作需要去最小化下列鲁棒性正则项：</p> 
<p class="img-center"><img alt="" height="40" src="https://images2.imgbox.com/11/58/UWCJTejX_o.png" width="310"></p> 
<p> 综上所述，跨域序列推荐模块（RCDR）的总优化目标为：</p> 
<p class="img-center"><img alt="" height="29" src="https://images2.imgbox.com/4f/c4/G2PKu0G8_o.png" width="421"></p> 
<p> 这里 <img alt="" height="21" src="https://images2.imgbox.com/fb/05/nLXwXd4X_o.png" width="20"> 和 <img alt="" height="23" src="https://images2.imgbox.com/91/e5/cEKDBdvQ_o.png" width="24"> 为平衡不同类型损失的超参数。</p> 
<p> </p> 
<h3 id="h_553492147_11"><strong>2.8 IJCAI23 《Federated Probabilistic Preference Distribution Modelling with Compactness Co-Clustering for Privacy-Preserving Multi-Domain Recommendation》[15]</strong></h3> 
<p><strong>本文不考虑用户间数据的隔离性，只考虑在两个相互隔离的领域间进行相互知识迁移，属于纵向类型</strong>。本文的亮点在于设计了一个FPPDM模块来建模不同领域用户/物品的概率分布，并通过联邦学习的聚合策略来对用户/物品的分布信息进行跨域共享。此外，本文还提出了一种co-clustering方法来对具有相似特性的用户进行聚类（FPPDM++），以更好地利用相似用户的语义信息。</p> 
<p><img alt="" height="451" src="https://images2.imgbox.com/ef/9d/l7U0Cang_o.png" width="1200"></p> 
<p> 首先，设第 k 个领域的用户和物品的交互矩阵 <img alt="" height="51" src="https://images2.imgbox.com/ef/cb/ojdl9qnt_o.png" width="169"> （这里 <img alt="" height="29" src="https://images2.imgbox.com/96/ef/v9ZgbZ5g_o.png" width="137">， NU 为用户数量，所有域用户重叠； NV 为第 k 个领域的物品数量），用户和物品的embeddings矩阵为 <img alt="" height="24" src="https://images2.imgbox.com/7b/5e/SbWKUlC2_o.png" width="178"> ，则我们可在此基础上运用GCN对用户/物品的偏好分布 <img alt="" height="24" src="https://images2.imgbox.com/1f/6d/YaramPDu_o.png" width="365"> 进行建模：</p> 
<p class="img-center"><img alt="" height="91" src="https://images2.imgbox.com/e6/a2/tapLDB0u_o.png" width="480"></p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/a5/a1/55zktVgs_o.png" width="610"></p> 
<p> 在对用户/物品的分布进行建模后，作者提出了下列的基于分布的度量学习loss：</p> 
<p class="img-center"><img alt="" height="88" src="https://images2.imgbox.com/66/0d/375FRmvF_o.png" width="499"></p> 
<p>这里 <img alt="" height="23" src="https://images2.imgbox.com/bc/e2/QbJkJYee_o.png" width="34"> 表示作为正例的用户-物品对， <img alt="" height="27" src="https://images2.imgbox.com/f5/e7/IVa79rkX_o.png" width="51">表示第 i 个用户的负例物品。 D(⋅) 表示高斯分布之间的Wasserstein距离，可以被计算如下：</p> 
<p class="img-center"><img alt="" height="50" src="https://images2.imgbox.com/55/96/9VH2xnDP_o.png" width="563"></p> 
<p> 在进行联邦聚合时，只需要对用户分布的均值和方差进行聚合即可：</p> 
<p class="img-center"><img alt="" height="73" src="https://images2.imgbox.com/07/65/89PxTeb6_o.png" width="382"></p> 
<p> 为了使得本地和全局的重叠用户分布能够一致地进行知识迁移，作者还设计了一个联邦正则项来减少本地和全局用户分布之间的距离：</p> 
<p class="img-center"><img alt="" height="54" src="https://images2.imgbox.com/fa/37/5AlnSucA_o.png" width="357"></p> 
<p> 故所提出的FPPDM模块的领域 k 的总损失函数如下：</p> 
<p class="img-center"><img alt="" height="37" src="https://images2.imgbox.com/44/0c/DtFjVePO_o.png" width="196"></p> 
<p> 这里 <img alt="" height="19" src="https://images2.imgbox.com/7b/cf/sPTNf4tF_o.png" width="20"> 表示平衡超参数。<br> 在FPPDM模块外，作者还设计了一个按照用户之间的相似度对用户进行的聚类策略（FPPDM++），由于和联邦关系不大再加上篇幅有限，这里就不继续展开叙述了，感兴趣的童鞋可以去阅读原始论文。</p> 
<h2 id="h_553492147_13">参考</h2> 
<ul><li>[1] Elkahky A M, Song Y, He X. A multi-view deep learning approach for cross domain user modeling in recommendation systems[C]//Proceedings of the 24th international conference on world wide web. 2015: 278-288.</li><li>[2] 杨强. 迁移学习[M]. 机械工业出版社, 2020.</li><li>[3] Flanagan A, Oyomno W, Grigorievskiy A, et al. Federated multi-view matrix factorization for personalized recommendations[C]//Joint European Conference on Machine Learning and Knowledge Discovery in Databases. Springer, Cham, 2020: 324-347.</li><li>[4] Hao Li, Mingkai Huang, Bing Bai, et al. A federated multi-view deep learning framework for privacy-preserving recommendations[C]//FTL-IJCAI. 2021.</li><li>[5] Liu S, Xu S, Yu W, et al. FedCT: Federated collaborative transfer for recommendation[C]//Proceedings of the 44th international ACM SIGIR conference on research and development in information retrieval. 2021: 716-725.</li><li>[6] Chen C, Wu H, Su J, et al. Differential Private Knowledge Transfer for Privacy-Preserving Cross-Domain Recommendation[C]//Proceedings of the ACM Web Conference 2022. 2022: 1455-1465.</li><li>[7] Meihan W, Li L, Tao C, et al. FedCDR: Federated Cross-Domain Recommendation for Privacy-Preserving Rating Prediction[C]//Proceedings of the 31st ACM International Conference on Information &amp; Knowledge Management. 2022: 2179-2188.</li><li>[8] Man T, Shen H, Jin X, et al. Cross-domain recommendation: An embedding and mapping approach[C]//IJCAI. 2017, 17: 2464-2470.</li><li>[9] Koren Y, Bell R, Volinsky C. Matrix factorization techniques for recommender systems[J]. Computer, 2009, 42(8): 30-37.</li><li>[10] Wu C, Wu F, Lyu L, et al. FedCTR: Federated Native Ad CTR Prediction with Cross Platform User Behavior Data[J]. ACM Transactions on Intelligent Systems and Technology (TIST), 2022.</li><li>[11] 王晋东，陈益强. 迁移学习导论（第2版）[M]. 电子工业出版社, 2022.</li><li>[12] 周志华. 机器学习[M]. 清华大学出版社, 2016.</li><li>[13] Chen G, Zhang X, Su Y, et al. Win-win: a privacy-preserving federated framework for dual-target cross-domain recommendation[C]//Proceedings of the AAAI Conference on Artificial Intelligence. 2023, 37(4): 4149-4156.</li><li>[14] Liao X, Liu W, Zheng X, et al. PPGenCDR: A Stable and Robust Framework for Privacy-Preserving Cross-Domain Recommendation[[C]//Proceedings of the AAAI Conference on Artificial Intelligence. 2023, 4453-4461.</li><li>[15] Liu W, Chen C, Liao X, et al. Federated Probabilistic Preference Distribution Modelling with Compactness Co-Clustering for Privacy-Preserving Multi-Domain Recommendation[J].</li><li>[16] Xue H J, Dai X, Zhang J, et al. Deep matrix factorization models for recommender systems[C]//IJCAI. 2017, 17: 3203-3209.</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/741be4a6634665da7836aad6e052a0c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用与非门等效替代异或门和或门,并制作半加器和全加器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8696b53edb8471b60bb72338036b2309/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">超市自助付款系统 毕业设计 JAVA&#43;Vue&#43;SpringBoot&#43;MySQL</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>