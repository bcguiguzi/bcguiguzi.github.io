<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深刻理解PHP面向对象的高级功能 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深刻理解PHP面向对象的高级功能" />
<meta property="og:description" content="个人博客网站文章地址：http://blog.mclink.xyz/index/article/index/id/24.html
对PHP oop编程的学习与认知。
1.使用Per-Class常量。
用途：可以在不需要初始化该类的情况下使用：
例子：
&lt;?php class Man //定义Man类 { const birthday = 19960101; //定义常量变量 } //使用const修饰的变量，我们可以通过：：操作符对其进行访问。例如： echo Man::birthday; //使用const修饰的变量是无法进行修改的，例如： // Man::birthday=19990101; //上面那句是会报语法错误的。 ?&gt; 执行结果：打印出变量值 也就是19960101
2.对静态方法的实现
用途：PHP可以在方法前面使用static关键字，该方法就可以在未初始化类的情况下通过类名::来进行调用，类似于上面。例如：
&lt;?php class Man //创建一个Man类 { static function boy() //创建静态方法 { return &#39;boy&#39;;	//函数返回字符串boy } } echo Man::boy(); //打印函数的返回值，也就是boy //但是在静态方法中，是不能使用this关键字的。因为可能会没有可以引用的对象实例 //通俗点说，就是一般我们调用函数是使用obj-&gt;method(),而$this就是当前的对象，但是因为 //我们没有对类进行进行实例化，也就没有所谓的对象，故不能使用。 ?&gt; 3.延迟静态绑定
从PHP5.3版本引入了延迟静态绑定（last static binding）的概念。
用途：允许在一个静态继承的上下文中对一个被调用类的引用。父类可以使用子类重载的静态方法。例如：
&lt;?php class father //father类 { public static function who() { echo __CLASS__;//__CLASS__作用是当前的类名，此处打印出father } public static function test() { static ::who();//进行静态绑定 } } class son extends father//son类继承father类 { public static function who() { echo __CLASS__; //打印 出son } } son::test(); //结果是打印出son." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6035daf18b0278ea55e79e0a52910318/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-09T14:53:49+08:00" />
<meta property="article:modified_time" content="2018-03-09T14:53:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深刻理解PHP面向对象的高级功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>个人博客网站文章地址：http://blog.mclink.xyz/index/article/index/id/24.html</p> 
<p>对PHP oop编程的学习与认知。</p> 
<p>1.使用Per-Class常量。</p> 
<p>用途：可以在不需要初始化该类的情况下使用：</p> 
<p>例子：</p> 
<pre><code class="language-php">&lt;?php
 class Man //定义Man类
 {
 	const birthday = 19960101; //定义常量变量
 }
  //使用const修饰的变量，我们可以通过：：操作符对其进行访问。例如：
  
   echo Man::birthday;
  //使用const修饰的变量是无法进行修改的，例如：
  
  // Man::birthday=19990101;
  
  //上面那句是会报语法错误的。

 ?&gt;
 
 </code></pre> 
<p>执行结果：打印出变量值 也就是19960101</p> 
<p>2.对静态方法的实现</p> 
<p>用途：PHP可以在方法前面使用static关键字，该方法就可以在未初始化类的情况下通过类名::来进行调用，类似于上面。例如：</p> 
<pre><code class="language-php">&lt;?php
  class Man //创建一个Man类
  {
	static function boy() //创建静态方法
	{
	   return 'boy';	//函数返回字符串boy
	}
  }
  echo Man::boy(); //打印函数的返回值，也就是boy
  
  //但是在静态方法中，是不能使用this关键字的。因为可能会没有可以引用的对象实例
  //通俗点说，就是一般我们调用函数是使用obj-&gt;method(),而$this就是当前的对象，但是因为
  //我们没有对类进行进行实例化，也就没有所谓的对象，故不能使用。
  
 ?&gt;
 </code></pre> 
<p>3.延迟静态绑定</p> 
<p>从PHP5.3版本引入了延迟静态绑定（last static binding）的概念。</p> 
<p>用途：允许在一个静态继承的上下文中对一个被调用类的引用。父类可以使用子类重载的静态方法。例如：</p> 
<pre><code class="language-php">&lt;?php
 class father //father类
 { 
 	public static function who()
 	{
 		echo __CLASS__;//__CLASS__作用是当前的类名，此处打印出father
 	}
 	public static function test()
 	{
 		static ::who();//进行静态绑定
 	}
 	
 }
 class son extends father//son类继承father类
 {
 	public static function who()
 	{
 		echo __CLASS__; //打印 出son
 	}
 }
  son::test(); //结果是打印出son.
  //在这行代码中，test()是父类的一个方法，但是因为静态绑定，使得子类可以使用test()
  //并且使用子类中重载的who方法，打印出son。
 ?&gt;
 </code></pre> 
<p>4.使用instanceof关键字对类的类型和类型提示进行检查</p> 
<p>用途：可以检查对象是否是特定类的实例，是否从某个类继承过来或者是否实现了某个接口。是一个高效率的条件操作符，</p> 
<p>例如：</p> 
<pre><code class="language-php">&lt;?php
 interface  a //声明接口a
 {
 	
 }
 class AAA //声明类AAA
 {
			
 }
 class BBB extends AAA implements a //声明类BBB继承类AAA并且实现接口a
 {
 	
 }

 $a=new AAA();
 $b=new BBB();
 echo $b instanceof BBB.'&lt;br/&gt;'; //打印结果为 1（true）
 echo $b instanceof  AAA.'&lt;br/&gt;';//打印结果为 1（true）
 echo $b instanceof  a;          //打印结果为 1（true）
?&gt;
 </code></pre> 
<p>此外，PHP还提供了类的类型提示的思想，通常我们向一个函数传递一个参数时，不能传递该参数的类型。使用类类型提示，可以指定必须传入的参数为类类型。如果传入的不符合。将产生一个错误。类型检查等价于instanceof的作用。</p> 
<p>例如：</p> 
<p>function check(B $someclass)</p> 
<p>{ </p> 
<p>//...</p> 
<p>}</p> 
<p>这样上例函数要求$someclass必须是类B的实例。如果这样调用，将会产生致命的错误：</p> 
<p>check($a); //$a是类A的实例</p> 
<p><br></p> 
<p>5.使用clone关键字对对象进行克隆</p> 
<p>用途：允许复制一个已有的对象。例如：</p> 
<p>$c = clone $b;</p> 
<p>$c将有与对象$b相同类的副本，而且具有相同的属性值。</p> 
<p>但是，有时候我们并不想把默认行为也同时克隆出来，此时我们应该在基类中创建一个__clone()方法。这个方法的创建类似于构造函数或者析构函数，使用这个方法的好处是在使用默认行为创建一个副本后能够被调用，我们可以只改变希望改变的内容。当我们使用clone关键字时，__clone()函数会被自动调用。</p> 
<p><br></p> 
<p>6.PHP对抽象类的使用</p> 
<p>抽象类是不能被实例化的，同样类方法也没有实现，只是提供类方法的声明，没有具体的实现。</p> 
<p>PHP使用关键字abstract来修饰一个抽象类/抽象方法。</p> 
<p>注意：包含抽象方法的任何类自身必须也是抽象的。（跟C++差不多）</p> 
<p>用途：抽象类主要是作为基类来使用的，抽象方法和抽象类主要用于复杂的类层次结构，该层次关系需要确保每一个子类都包含并且重载了某些特定的方法。</p> 
<p><br></p> 
<p>7.使用__call()重载方法</p> 
<p> 这个方法的实现类似与__get(),__set(),__construct(),__desconstruct().</p> 
<p>用途：实现方法的重载</p> 
<p>例如：</p> 
<pre><code class="language-php">&lt;?php
 class overload
 {
 	public function __call($method,$p) //第一个参数是包含了被调用的方法名称，第二个参数是包含了传递给该方法的参数数组
 	{
 		if($method == 'display')
 		{
 			if(is_object($p[0]))
 			{
 				$this-&gt;displayObject($p[0]);
 			}
 			else if(is_array($p[0]))
 			{
 				$this-&gt;displayArray($p[0]);
 			}
 			else
 			{
 				$this-&gt;displayScalar($p[0]);
 			}
 		}
 		
 	}
 	function displayObject()
 	{
 		echo 'Object';
 	}
 	function displayArray()
 	{
 		echo 'Array';
 	}
 	function displayScalar()
 	{
 		echo 'Scalar';
 	}
 	
 }
 $ov=new overload();
 $ov-&gt;display($ov);         //结果打印出Object
 $ov-&gt;display(array(1,2,3)); //结果打印出Array
 $ov-&gt;display('cat');        //结果打印出Scalar
 
 //注意，我们不用实现任何display方法。
?&gt;
 </code></pre> 
<p>8.对__autoload()方法的使用。</p> 
<p>该方法并不是一个类方法，而是一个单独的函数，也就是说，我们可以在任何类声明之外声明这个函数，如果实现了这个函数，它将在实例化一个还没有被声明的类自动调用。</p> 
<p>用途：尝试包含或请求任何用来初始化所需类的文件。</p> 
<p>例如：</p> 
<pre><code class="language-php">function __autoload($name)
 {
	include_once $name.'.php';
 }</code></pre> 
<p>上面的代码，当我们实例化一个还没有声明的类时,便会自动包括具有与该类相同名称的文件。</p> 
<p><br></p> 
<p>9.实现迭代</p> 
<p>PHP提供了一个十分有用的特性，就是可以使用foreach()方法通过循环的方式取出一个对象的所有属性，就像数组那样。</p> 
<p>例如：</p> 
<pre><code class="language-php">&lt;?php
 class test
 {
 	public $a=1;
 	public $b=2;
 	public $c=3;
 }
 $y=new test();
 foreach ($y as $value)
 {
 	echo $value.'&lt;br/&gt;';
 }
?&gt;
 
 </code></pre> 
<p>打印结果是：</p> 
<p>1</p> 
<p>2</p> 
<p>3</p> 
<p>10.实现对类的打印</p> 
<p>如果我们想把一个类打印出来，PHP提供了一个__toString()函数。</p> 
<p>具体实现：</p> 
<pre><code class="language-php">&lt;?php
 class test
 {
 	public $a=1;
 	public $b=2;
 	public  function __toString()
 	{
		return(var_export($this,TRUE)); //var_export()函数打印出类中的所有属性		
 	}
 }
 $y=new test();
 echo $y; //打印结果：test::__set_state(array( 'a' =&gt; 1, 'b' =&gt; 2, ))
?&gt;</code></pre> 
<p>11.使用反射(Reflection)API</p> 
<p>反射是通过访问已有类和对象来找到类和对象的结构和内容的能力。</p> 
<p>用途：当使用未知或文档不详的类时，就可以使用。</p> 
<p>例如：</p> 
<pre><code class="language-php">&lt;?php
 require_once('one.php');
 
 $class= new ReflectionClass('one');
 echo '&lt;pre&gt;'.$class.'&lt;/pre&gt;';
?&gt;
 </code></pre> 
<p>用来找到同目录的one.php,其内容如下：</p> 
<pre><code class="language-php">&lt;?php 
	class one
	{
		public $time=2;
		function test()
		{
			return 'ok';
		}
	}
	$a=new one();
	$a-&gt;test();
?&gt;</code></pre> 
<p>程序的输出为：</p> 
<p><img src="https://images2.imgbox.com/38/03/Wm9M7qgt_o.png" alt=""><br></p> 
<p>可知，反射API的输出信息是非常的详细的。</p> 
<p><br></p> 
<p><br></p> 
<p>本文是由作者纯手工编写，转载请联系作者，注明出处，谢谢。</p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca9033a4bfeb0a78a3da9654e6117e0c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java基础知识点梳理（详细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15652dae54e7515a7deff2bd86c0c614/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity Unet详细介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>