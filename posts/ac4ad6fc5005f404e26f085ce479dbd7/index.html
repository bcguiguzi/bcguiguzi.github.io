<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>unity官方内置网络unet的实例 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="unity官方内置网络unet的实例" />
<meta property="og:description" content="一、添加网络管理组件 新创建一个网络管理器。该网络管理器将控制该项目的网络状态，包括游戏状态管理，生成点管理，场景管理，配对和允许访问相关信息。对于高级用户，可以从NetworkManager派生一个类来自定义组件的行为，扩展未涵盖的NetworkManager
二、创建角色预制体： NetworkIdentity组件介绍：网络物体最基本的组件，客户端与服务器确认是否是一个物体(netID)，也用来表示各个状态，如是否是服务器，是否是客户端，是否有权限，是否是本地玩家等。
三、控制角色移动 四、控制角色射击 子弹预制体的设置
子弹生成：
子弹销毁为什么不用同步，是因为服务端是母体，服务端的销毁掉，客户端自然就会被销毁
五、血量的减少 制作血条：
注意：血量减少，因为服务器是母体，为了防止母体子弹销毁时，客户端子弹还没有碰撞到角色，血量不能及时减少，造成数据不同步，因此血量的控制检测只能是在服务器进行计算并同步到客户端
子弹添加碰撞脚本
六、控制人物的重生 设置重生点：
七、控制敌人的生成 敌人在每个客户端都要产生，所以敌人产生在服务端来做，将产生的敌人同步到客户端上
RPC是远程调用（服务端与客户端互调用），调用服务器端的某个方法，使用Comond，想调用客户端的某个方法使用ClientRPC，
SyncVar是同步一个变量，比如同步主角的血量，
hook，指定一个字符串参数，这个参数指定方法的名字，变量的值发生改变时，调用Hook指定的方法。
using UnityEngine; using System.Collections; using UnityEngine.Networking; public class PlayerController : NetworkBehaviour { public GameObject bulletPrefab; public Transform bulletSpawn;	// Update is called once per frame void Update () { if (isLocalPlayer == false) { return; } float h = Input.GetAxis(&#34;Horizontal&#34;); float v = Input.GetAxis(&#34;Vertical&#34;); transform.Rotate(Vector3.up * h * 120 * Time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ac4ad6fc5005f404e26f085ce479dbd7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-22T15:45:39+08:00" />
<meta property="article:modified_time" content="2020-06-22T15:45:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">unity官方内置网络unet的实例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、添加网络管理组件</h3> 
<p><img alt="" height="355" src="https://images2.imgbox.com/a1/c7/3Ny0zvrm_o.png" width="566"></p> 
<p><img alt="" height="150" src="https://images2.imgbox.com/f8/12/Rgnqztyv_o.png" width="419"></p> 
<p>新创建一个网络管理器。该网络管理器将控制该项目的网络状态，包括游戏状态管理，生成点管理，场景管理，配对和允许访问相关信息。对于高级用户，可以从NetworkManager派生一个类来自定义组件的行为，扩展未涵盖的NetworkManager</p> 
<h3>二、创建角色预制体：</h3> 
<p><img alt="" height="410" src="https://images2.imgbox.com/75/fe/z4x0wjGm_o.png" width="523"></p> 
<p>NetworkIdentity组件介绍：网络物体最基本的组件，客户端与服务器确认是否是一个物体(netID)，也用来表示各个状态，如是否是服务器，是否是客户端，是否有权限，是否是本地玩家等。</p> 
<p><img alt="" height="316" src="https://images2.imgbox.com/8c/78/ACgpJYL6_o.png" width="559"></p> 
<h3>三、控制角色移动</h3> 
<p><img alt="" height="460" src="https://images2.imgbox.com/f4/1a/w7wG5VtZ_o.png" width="570"></p> 
<p><img alt="" height="577" src="https://images2.imgbox.com/ec/bf/tJHqNd1R_o.png" width="377"></p> 
<h3>四、控制角色射击</h3> 
<p>子弹预制体的设置</p> 
<p><img alt="" height="649" src="https://images2.imgbox.com/88/7c/zYo93l43_o.png" width="536"></p> 
<p>子弹生成：</p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/c8/f4/gV0XJy0t_o.png" width="496"></p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/98/a1/evIqDNYS_o.png" width="1090"></p> 
<p>子弹销毁为什么不用同步，是因为服务端是母体，服务端的销毁掉，客户端自然就会被销毁</p> 
<h3>五、血量的减少</h3> 
<p>制作血条：</p> 
<p><img alt="" height="220" src="https://images2.imgbox.com/66/30/syPzpC6P_o.png" width="502"></p> 
<p><img alt="" height="216" src="https://images2.imgbox.com/14/78/KHozcAWX_o.png" width="516"></p> 
<p>注意：血量减少，因为服务器是母体，为了防止母体子弹销毁时，客户端子弹还没有碰撞到角色，血量不能及时减少，造成数据不同步，因此血量的控制检测只能是在服务器进行计算并同步到客户端</p> 
<p><img alt="" height="408" src="https://images2.imgbox.com/bc/6e/15OJlIEL_o.png" width="355"> <img alt="" height="401" src="https://images2.imgbox.com/92/cd/1c4Sv618_o.png" width="492"></p> 
<p>子弹添加碰撞脚本</p> 
<p><img alt="" height="411" src="https://images2.imgbox.com/7b/c3/qGxyWmce_o.png" width="387">  <img alt="" height="355" src="https://images2.imgbox.com/3c/76/lPUz2gx0_o.png" width="410"></p> 
<h3>六、控制人物的重生</h3> 
<p>设置重生点：</p> 
<p><img alt="" height="224" src="https://images2.imgbox.com/14/bd/EbcYn6Qg_o.png" width="417">  <img alt="" height="233" src="https://images2.imgbox.com/b7/df/BuStjH4G_o.png" width="380"></p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/fd/3f/qVVWyYPJ_o.png" width="838"></p> 
<h3>七、控制敌人的生成</h3> 
<p><img alt="" height="552" src="https://images2.imgbox.com/f7/dd/ynTyGf3P_o.png" width="560"></p> 
<p>  <img alt="" height="337" src="https://images2.imgbox.com/e1/21/HN59LFxv_o.png" width="519"></p> 
<p>敌人在每个客户端都要产生，所以敌人产生在服务端来做，将产生的敌人同步到客户端上</p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/f6/5c/vF6s3Hk6_o.png" width="488">  </p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/47/2c/AQv5qOpd_o.png" width="856"></p> 
<p><img alt="" height="261" src="https://images2.imgbox.com/2f/4e/CGq6x6yq_o.png" width="569"></p> 
<p>RPC是远程调用（服务端与客户端互调用），调用服务器端的某个方法，使用Comond，想调用客户端的某个方法使用ClientRPC，</p> 
<p>SyncVar是同步一个变量，比如同步主角的血量，</p> 
<p>hook，指定一个字符串参数，这个参数指定方法的名字，变量的值发生改变时，调用Hook指定的方法。</p> 
<pre><code class="language-cs">using UnityEngine;
using System.Collections;
using UnityEngine.Networking;

public class PlayerController : NetworkBehaviour {

    public GameObject bulletPrefab;
    public Transform bulletSpawn;	
	// Update is called once per frame
	void Update () {
        if (isLocalPlayer == false)
        {
            return;
        }
        float h = Input.GetAxis("Horizontal");
        float v = Input.GetAxis("Vertical");

        transform.Rotate(Vector3.up * h * 120 * Time.deltaTime);
        transform.Translate(Vector3.forward * v * 3 * Time.deltaTime);

        if (Input.GetKeyDown(KeyCode.Space))
        {
            CmdFire();
        }
	}  
    [Command]//这个命令， 各个客户端会调用这个方法，但是运行是在服务器端运行的
    void CmdFire()//这个方法需要在server里面调用，必须以Cmd开头
    {
        // 子弹的生成 需要server完成，然后把子弹同步到各个client
        GameObject bullet = Instantiate(bulletPrefab, bulletSpawn.position, bulletSpawn.rotation) as GameObject;
        bullet.GetComponent&lt;Rigidbody&gt;().velocity = bullet.transform.forward * 10;//给初速度
        Destroy(bullet, 2);
        NetworkServer.Spawn(bullet);//网络生成子弹，同步到客户端，如果没有这句代码的的话，另外一个客户端是看不到子弹的生成的
      //bullet 属于网络的一个东西，这句只是把子弹物体分发给了客户端，但是没有给客户端的子弹给与速度
    }
    public override void OnStartLocalPlayer()
    {
        //这个方法只会在本地角色那里调用  当角色被创建的时候
        GetComponent&lt;MeshRenderer&gt;().material.color = Color.blue;
    }
}
</code></pre> 
<pre><code class="language-cs">using UnityEngine;
using System.Collections;
using UnityEngine.UI;
using UnityEngine.Networking;
public class Health : NetworkBehaviour {
    public const int maxHealth = 100;
    //下面SyncVar同步的功能会一直检测，检测到之后会调用这个方法，每个客户端都会调用的
    [SyncVar(hook="OnChangeHealth") ]
    public int currentHealth = maxHealth;
    public Slider healthSlider;
    public bool destroyOnDeath = false;//为true，表示是敌人，要销毁   
    public void TakeDamage(int damage) //下面是在服务端执行的方法
    {
        if (isServer == false) return;// 血量的处理只在服务器端执行
        currentHealth -= damage;
        if (currentHealth &lt;= 0)
        {
            if (destroyOnDeath) //表示是敌人，要销毁
            {
                Destroy(this.gameObject); return;
            }
             currentHealth = maxHealth;//死亡之后，当前血量恢复到最大血量            
            RpcRespawn();//不是敌人的话，要重生
        }
    }
    //上面定义同步变量，更新变化后的变量
    void OnChangeHealth(int health)
    {
        healthSlider.value = health / (float)maxHealth;
    }
    //设置重生点
    private NetworkStartPosition[] spawnPoints;
    void Start()
    {
        if (isLocalPlayer)
        {
            spawnPoints = FindObjectsOfType&lt;NetworkStartPosition&gt;();
        }
    }
    /// &lt;summary&gt;
    /// 人物重生，这个方法应该在客户端调用
    /// &lt;/summary&gt;
    [ClientRpc]
    void RpcRespawn()
    {
        if (isLocalPlayer == false) return;

        Vector3 spawnPosition = Vector3.zero;

        if (spawnPoints != null &amp;&amp; spawnPoints.Length &gt; 0)
        {
            spawnPosition = spawnPoints[Random.Range(0, spawnPoints.Length)].transform.position;
        }
        transform.position = spawnPosition;
    }
}
</code></pre> 
<p> </p> 
<pre><code class="language-cs">using UnityEngine;
using System.Collections;

public class Bullet : MonoBehaviour {
    void OnCollisionEnter(Collision col)
    {
        GameObject hit = col.gameObject;
        Health health = hit.GetComponent&lt;Health&gt;();

        if (health != null)
        {
            health.TakeDamage(10);
        }
        Destroy(this.gameObject);
    }

}
</code></pre> 
<pre><code class="language-cs">using UnityEngine;
using System.Collections;
using UnityEngine.Networking;

public class EnemySpawner : NetworkBehaviour {

    public GameObject enemyPrefab;
    public int numberOfEnemies;
    public override void OnStartServer()
    {
        for (int i = 0; i &lt; numberOfEnemies; i++)//敌人的数量
        {
            Vector3 position = new Vector3(Random.Range(-6f, 6f), 0, Random.Range(-6f, 6f));

            Quaternion rotation = Quaternion.Euler(0, Random.Range(0, 360), 0);

            GameObject enemy = Instantiate(enemyPrefab, position, rotation) as GameObject;

            NetworkServer.Spawn(enemy);//同步到客户端，同步到网络上
        }  
    }
	

}
</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35b84a5ebb935e63c2de487d65674f5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">常规双边带调幅（AM）仿真</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47a3354159255bbcfab7384c8281637a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VMware Fusion 安装Windows 10 运行.exe 文件 提示“不能在虚拟机上运行”</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>