<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>构建无锁的线程安全架构：掌握Java中ThreadLocal的原理灵活应用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="构建无锁的线程安全架构：掌握Java中ThreadLocal的原理灵活应用" />
<meta property="og:description" content="ThreadLocal 是 Java 提供的一个线程级别的变量存储工具，它允许每个线程都有自己独立的变量副本，每个线程可以独立地操作自己的变量副本，互不干扰。本文将详细介绍 ThreadLocal 的原理和使用场景，并通过代码示例进行讲解。
一、ThreadLocal 的原理 1.1 概述 ThreadLocal 提供了一种简单的方式来实现线程封闭（Thread confinement），即将数据与线程关联起来，确保每个线程都拥有自己独立的数据副本，从而避免线程安全问题。在多线程环境下，使用 ThreadLocal 可以方便地实现线程间的数据隔离，保证每个线程都能够访问到自己的数据。
1.2 数据结构 ThreadLocal 内部通过一个特殊的数据结构来存储每个线程的变量副本，这个数据结构被称为 ThreadLocalMap。每个 ThreadLocal 对象作为 key，对应一个 value，表示该线程的变量副本。ThreadLocalMap 是 ThreadLocal 类的一个内部静态类，用于存储线程的局部变量。
ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。
set 给ThreadLocalMap设置值。get 获取ThreadLocalMap。remove 删除ThreadLocalMap类型的对象。 1.3 实现原理 ThreadLocal 的实现原理可以简单概括为以下几个步骤：
在每个线程内部创建一个 ThreadLocalMap 对象，用于存储线程的变量副本。在需要使用线程局部变量的地方，通过 get() 方法获取当前线程对应的 ThreadLocalMap 对象。在 ThreadLocalMap 中以当前 ThreadLocal 对象作为 key，获取或设置变量副本。 具体流程如下图所示：
简单描述也就是这样：
css复制代码main Thread: Thread1: Thread2: ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ │ Thread │ │ Thread │ │ Thread │ │ Thread │ ├─────────┤ ├─────────┤ ├─────────┤ ├─────────┤ │ ├──┐ │ ├──┐ │ ├───&gt;│ │ └─────────┘ │ └─────────┘ │ └─────────┘ └─────────┘ │ │ get() │ set(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7dd27510bdd93d3444a587c633ae17c8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-25T10:28:32+08:00" />
<meta property="article:modified_time" content="2023-06-25T10:28:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">构建无锁的线程安全架构：掌握Java中ThreadLocal的原理灵活应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>ThreadLocal 是 Java 提供的一个线程级别的变量存储工具，它允许每个线程都有自己独立的变量副本，每个线程可以独立地操作自己的变量副本，互不干扰。本文将详细介绍 ThreadLocal 的原理和使用场景，并通过代码示例进行讲解。</p> 
<h2>一、ThreadLocal 的原理</h2> 
<h2>1.1 概述</h2> 
<p>ThreadLocal 提供了一种简单的方式来实现线程封闭（Thread confinement），即将数据与线程关联起来，确保每个线程都拥有自己独立的数据副本，从而避免线程安全问题。在多线程环境下，使用 ThreadLocal 可以方便地实现线程间的数据隔离，保证每个线程都能够访问到自己的数据。</p> 
<h2>1.2 数据结构</h2> 
<p>ThreadLocal 内部通过一个特殊的数据结构来存储每个线程的变量副本，这个数据结构被称为 ThreadLocalMap。每个 ThreadLocal 对象作为 key，对应一个 value，表示该线程的变量副本。ThreadLocalMap 是 ThreadLocal 类的一个内部静态类，用于存储线程的局部变量。</p> 
<p><strong>ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。</strong></p> 
<ul><li>set 给ThreadLocalMap设置值。</li><li>get 获取ThreadLocalMap。</li><li>remove 删除ThreadLocalMap类型的对象。</li></ul> 
<h2>1.3 实现原理</h2> 
<p>ThreadLocal 的实现原理可以简单概括为以下几个步骤：</p> 
<ol><li>在每个线程内部创建一个 ThreadLocalMap 对象，用于存储线程的变量副本。</li><li>在需要使用线程局部变量的地方，通过 get() 方法获取当前线程对应的 ThreadLocalMap 对象。</li><li>在 ThreadLocalMap 中以当前 ThreadLocal 对象作为 key，获取或设置变量副本。</li></ol> 
<p>具体流程如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a3/90/44wYCCgA_o.png"></p> 
<p>简单描述也就是这样：</p> 
<pre><code>css复制代码main Thread:          Thread1:                        Thread2:
┌─────────┐          ┌─────────┐       ┌─────────┐    ┌─────────┐
│ Thread  │          │ Thread  │       │ Thread  │    │ Thread  │
├─────────┤          ├─────────┤       ├─────────┤    ├─────────┤
│         ├──┐       │         ├──┐    │         ├───&gt;│         │
└─────────┘  │       └─────────┘  │    └─────────┘    └─────────┘
             │                    │
     get()   │     set("Data1")   │
   ┌──────────┼──────────────────┼───────────────────┐
   │          │                  │                   │
┌───────────┐  │    ┌───────────┐ │    ┌───────────┐  │
│ ThreadMap │  │    │ ThreadMap │ │    │ ThreadMap │  │
├───────────┤  │    ├───────────┤ │    ├───────────┤  │
│ ThreadMap ├──┼───&gt;│ ThreadMap ├──┼───&gt;│ ThreadMap │  │
└───────────┘  │    └───────────┘ │    └───────────┘  │
               │                  │                   │
           ┌───────────┐      ┌───────────┐       ┌───────────┐
           │ ThreadLocal1 │      │ ThreadLocal1 │       │ ThreadLocal1 │
           ├───────────┤      ├───────────┤       ├───────────┤
           │     Data1     │      │     Data2     │       │     Data3  │
           └───────────┘      └───────────┘       └───────────┘
</code></pre> 
<h2>二、ThreadLocal 的使用场景</h2> 
<h2>2.1 线程安全问题</h2> 
<p>在多线程环境中，多个线程访问共享数据时可能出现线程安全问题，例如数据被意外修改、并发写入等。此时，可以使用 ThreadLocal 将数据与线程关联起来，确保每个线程都操作自己的数据副本，从而避免线程安全问题。</p> 
<h2>2.2 传递上下文信息</h2> 
<p>在一些需要跨层传递上下文信息的场景下，使用 ThreadLocal 可以简化代码实现。例如，在 Web 应用中，用户的登录信息通常需要在多个组件间传递，可以使用 ThreadLocal 来存储用户登录信息，每个组件获取登录信息时直接从 ThreadLocal 中获取，避免了繁琐的参数传递过程。</p> 
<h2>2.3 数据库连接管理</h2> 
<p>在使用数据库连接池时，每个线程从连接池中获取连接执行数据库操作，并在处理完毕后将连接释放到连接池中。此时，可以使用 ThreadLocal 来管理数据库连接，确保每个线程都使用自己独立的连接，避免多线程并发访问同一个连接引发的问题。</p> 
<h2>2.4 其他应用场景</h2> 
<p>除了上述场景，ThreadLocal 还可以用于实现定制化的线程封闭策略，例如在线程池中复用线程时，通过使用 ThreadLocal 可以隔离线程之间的数据。</p> 
<p>总的概括就是：</p> 
<p>（1）每个线程需要有自己单独的实例</p> 
<p>（2）实例需要在多个方法中共享，但不希望被多线程共享</p> 
<h2>三、ThreadLocal 的使用方式</h2> 
<p>下面举几个具体的例子来演示 ThreadLocal 的使用方式。</p> 
<h2>3.1 示例一：传递用户信息</h2> 
<p>假设有一个 Web 应用，需要在不同层级的组件中传递用户的登录信息。首先，我们定义一个包含用户信息的类 User：</p> 
<pre><code>java复制代码public class User {
    private String username;
    // ...
    
    // 构造方法和getter/setter 省略
}
</code></pre> 
<p>接下来，在一个拦截用户请求的过滤器中，将用户信息存储到 ThreadLocal 中：</p> 
<pre><code>java复制代码public class UserFilter implements Filter {
    private static final ThreadLocal&lt;User&gt; userThreadLocal = new ThreadLocal&lt;&gt;();
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        // 从请求中获取用户信息
        User user = extractUserFromRequest(request);
        
        // 将用户信息存储到 ThreadLocal 中
        userThreadLocal.set(user);
        
        try {
            chain.doFilter(request, response);
        } finally {
            // 请求处理完毕后清除 ThreadLocal 中的数据
            userThreadLocal.remove();
        }
    }
    
    private User extractUserFromRequest(ServletRequest request) {
        // 从请求中提取用户信息
        // ...
        return new User("Alice");
    }
}
</code></pre> 
<p>在其他组件中，可以通过 ThreadLocal 获取当前线程对应的用户信息：</p> 
<pre><code>java复制代码public class SomeComponent {
    public void doSomething() {
        User user = UserFilter.userThreadLocal.get();
        // 使用用户信息进行操作
        // ...
    }
}
</code></pre> 
<p>在上述示例中，通过 ThreadLocal 将用户信息存储在不同的线程中，避免了在不同组件间传递参数的麻烦，实现了上下文信息的传递。</p> 
<h2>3.2 示例二：数据库连接管理</h2> 
<p>在一个多线程的数据库访问场景中，使用 ThreadLocal 可以实现每个线程使用自己的数据库连接，封装数据库连接的获取和释放过程。</p> 
<p>首先，定义一个数据库连接管理类：</p> 
<pre><code>java复制代码public class ConnectionManager {
    private static final ThreadLocal&lt;Connection&gt; connectionThreadLocal = new ThreadLocal&lt;&gt;();
    
    public static Connection getConnection() {
        Connection connection = connectionThreadLocal.get();
        if (connection == null) {
            // 创建新的数据库连接
            connection = createConnection();
            connectionThreadLocal.set(connection);
        }
        return connection;
    }
    
    public static void releaseConnection() {
        Connection connection = connectionThreadLocal.get();
        if (connection != null) {
            // 关闭数据库连接
            closeConnection(connection);
            connectionThreadLocal.remove();
        }
    }
    
    private static Connection createConnection() {
        // 创建数据库连接
        // ...
        return new Connection();
    }
    
    private static void closeConnection(Connection connection) {
        // 关闭数据库连接
        // ...
    }
}
</code></pre> 
<p>然后，在数据库访问的代码中，通过 ConnectionManager 来获取和释放数据库连接：</p> 
<pre><code>java复制代码public class UserDao {
    public void save(User user) {
        Connection connection = ConnectionManager.getConnection();
        try {
            // 使用数据库连接进行数据保存操作
            // ...
        } finally {
            ConnectionManager.releaseConnection();
        }
    }
}
</code></pre> 
<p>在上述示例中，每个线程都会通过 ThreadLocal 存储自己的数据库连接，避免了多线程并发访问同一个连接引发的问题。</p> 
<h2>四、存在的问题</h2> 
<p>ThreadLocal 存在的问题以及解决方法：</p> 
<h2>4.1 内存泄漏问题</h2> 
<p>ThreadLocal 的内部实现是通过 ThreadLocalMap 来维护每个线程的局部变量，并且 ThreadLocalMap 中的 Entry 对象使用弱引用来引用 ThreadLocal 对象。这就意味着，在没有其他强引用指向 ThreadLocal 对象时，ThreadLocal 对象可能被垃圾回收器回收，而相应的线程局部变量的值仍然保留在 ThreadLocalMap 中，从而导致内存泄漏问题。</p> 
<p><strong>解决方法：</strong> 为了避免内存泄漏，需要在使用完 ThreadLocal 后手动调用 remove() 方法清理对应的线程局部变量。通常可以通过在 finally 块中进行清理操作，以确保即使发生异常，也能正确清理 ThreadLocal。下面是一个示例代码：</p> 
<pre><code>java复制代码class MyThreadLocalExample {
   private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();

   public static void main(String[] args) {
       try {
           // 设置线程局部变量的值
           threadLocal.set(123);

           // 执行业务逻辑...
       } finally {
           // 清理线程局部变量
           threadLocal.remove();
       }
   }
}
</code></pre> 
<h2>4.2 线程复用时的数据共享问题</h2> 
<p>在线程池等多线程复用的场景中，通过 ThreadLocal 存储的线程局部变量可能会被 “复用” 给其他线程使用，从而导致数据共享问题。也就是说，在某些情况下，多个线程共享同一个 ThreadLocal 的值，这不符合我们使用 ThreadLocal 的初衷。</p> 
<p><strong>解决方法：</strong> 对于线程池等多线程复用的场景，可以考虑使用 InheritableThreadLocal 来解决数据共享问题。InheritableThreadLocal 是 ThreadLocal 的一个子类，它允许子线程从父线程中继承线程局部变量的值。下面是一个简单的示例代码：</p> 
<pre><code>java复制代码class MyInheritableThreadLocalExample {
   private static ThreadLocal&lt;Integer&gt; threadLocal = new InheritableThreadLocal&lt;&gt;();

   public static void main(String[] args) {
       // 设置线程局部变量的值
       threadLocal.set(123);

       // 创建子线程并执行任务
       Thread childThread = new Thread(() -&gt; {
           // 子线程可以继承父线程的线程局部变量的值
           int value = threadLocal.get();
           System.out.println("子线程获取到的值：" + value);
       });
       childThread.start();
   }
}
</code></pre> 
<h2>4.3 使用 ThreadLocal 的弱引用</h2> 
<p>在一些场景下，我们不希望 ThreadLocal 对象长期持有对线程局部变量的引用，以避免潜在的内存泄漏问题。可以使用 WeakReference 或者自定义的 WeakThreadLocal 来实现 ThreadLocal 的弱引用版本。这样，在没有其他强引用指向 ThreadLocal 对象时，ThreadLocal 对象就可以被垃圾回收。</p> 
<p><strong>解决方法：</strong> 下面是一个解决方法的demo代码，展示如何使用 WeakReference 来实现 ThreadLocal 的弱引用版本：</p> 
<pre><code>java复制代码class MyWeakThreadLocalExample {
   private static ThreadLocal&lt;WeakReference&lt;Integer&gt;&gt; threadLocal = new ThreadLocal&lt;&gt;();

   public static void main(String[] args) {
       // 设置线程局部变量的值
       threadLocal.set(new WeakReference&lt;&gt;(123));

       // 业务逻辑...

       // 获取线程局部变量的值
       WeakReference&lt;Integer&gt; reference = threadLocal.get();
       Integer value = reference.get();
       System.out.println("线程局部变量的值：" + value);
   }
}
</code></pre> 
<p>通过及时清理 ThreadLocal、使用 InheritableThreadLocal 或者使用 ThreadLocal 的弱引用，可以解决 ThreadLocal 存在的问题，并保证线程安全和正确性。应根据具体场景选择合适的解决方法。</p> 
<h2>五、ThreadLocal和Synchronized的区别</h2> 
<p>很多同学分不清：ThreadLocal和Synchronized这两种Java多线程编程中用于实现线程安全的两种机制。也不太明白如何去用它们。下面我简单归纳一下吧，它们在实现方式、适用场景和效果上确实是有一些区别的。</p> 
<p>（1）实现方式：</p> 
<ul><li>ThreadLocal：ThreadLocal是一种基于线程的局部变量实现机制。每个线程都有自己独立的ThreadLocal实例，并且每个线程可以访问各自的ThreadLocal实例，线程之间的变量互不干扰。ThreadLocal内部使用一个Map结构，在每个线程内部维护一个变量副本。</li><li>Synchronized：Synchronized是通过互斥锁（也称为监视器锁）来实现线程安全的。当一个线程获取到锁时，其他线程需要等待，直到持有锁的线程释放锁才能执行相应的代码块。</li></ul> 
<p>（2）适用场景：</p> 
<ul><li>ThreadLocal：ThreadLocal适用于需要在线程之间隔离数据的场景，每个线程可以独立地操作自己的变量副本。常见的使用场景包括Web应用程序的请求处理、数据库事务管理等。</li><li>Synchronized：Synchronized适用于多个线程共享同一个资源的场景，需要确保在同一时间只有一个线程访问共享资源，从而避免数据竞争和不一致性。常见的使用场景包括共享数据的读写、临界区的保护等。</li></ul> 
<p>（3）效果：</p> 
<ul><li>ThreadLocal：通过ThreadLocal可以实现线程间的数据隔离，每个线程都有自己独立的变量副本，并且修改不会影响其他线程。这样可以避免使用锁带来的开销，提高并发性能。但需要注意合理管理ThreadLocal实例，避免内存泄漏。</li><li>Synchronized：使用Synchronized可以保证线程安全，确保共享资源在同一时间只能被一个线程访问，从而避免数据竞争和不一致性。Synchronized通过获取锁来控制对共享资源的访问，保证了线程安全。但是，使用锁会引入额外的开销，并且当多个线程竞争同一个锁时，可能会导致线程阻塞和性能下降。</li></ul> 
<p>以下是ThreadLocal和Synchronized的对比情况：</p> 
<table><tbody><tr><td> <p>比较类型</p> </td><td> <p>ThreadLocal</p> </td><td> <p>Synchronized</p> </td></tr><tr><td> <p>实现方式</p> </td><td> <p>基于线程的局部变量</p> </td><td> <p>通过互斥锁（监视器锁）实现</p> </td></tr><tr><td> <p>适用场景</p> </td><td> <p>需要在线程之间隔离数据的场景</p> </td><td> <p>多个线程共享同一个资源的场景</p> </td></tr><tr><td> <p>效果</p> </td><td> <p>线程间数据隔离，避免锁的开销，提高并发性能</p> </td><td> <p>线程安全，保证共享资源在同一时间只能被一个线程访问</p> </td></tr><tr><td> <p>锁的粒度</p> </td><td> <p>线程级别</p> </td><td> <p>对象级别</p> </td></tr><tr><td> <p>并发性能</p> </td><td> <p>可以提高并发性能</p> </td><td> <p>引入额外的开销，可能导致线程阻塞</p> </td></tr><tr><td> <p>内存管理</p> </td><td> <p>需要注意合理管理ThreadLocal实例，避免泄漏</p> </td><td> <p>无需额外的内存管理</p> </td></tr><tr><td> <p>使用复杂度</p> </td><td> <p>相对较低，简单易用</p> </td><td> <p>相对较高，需要手动控制加锁和释放锁</p> </td></tr><tr><td> <p>编程范式</p> </td><td> <p>面向变量副本</p> </td><td> <p>面向共享资源</p> </td></tr></tbody></table> 
<p>ThreadLocal适用于需要在线程间隔离数据的场景，可以提高并发性能，但需要注意管理ThreadLocal实例。Synchronized适用于多个线程共享同一个资源的场景，保证线程安全，但可能引入额外的开销和线程阻塞。 ThreadLocal 可以实现线程级别的变量存储，确保每个线程都拥有自己独立的变量副本，避免线程安全问题。ThreadLocal 的使用场景包括线程安全问题、传递上下文信息、数据库连接管理等。通过合理地运用 ThreadLocal，可以简化多线程编程，提高代码的可读性和可维护性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/43323a536ea187aa45c51c0cf4720beb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于java的个人日记本系统毕业设计(源代码&#43;数据库&#43;部署视频)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aa9eb1d429acb1e60cf9489338ee7f2e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JAVA基础：线程池的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>