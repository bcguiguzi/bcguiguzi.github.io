<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之二叉树的练习题 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构之二叉树的练习题" />
<meta property="og:description" content="1.二叉树的前序遍历 题目：给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
输入：root = [1,null,2,3]
输出：[1,2,3]
这个前序遍历和前文自己写的遍历的不同点：他的返回值是一个List集合，需要用到动态数组来保存元素，而不是简单的打印。
这道题的数组创建要变为成员变量，不能放在方法中，要不每次递归的时候都会开辟一个子数组，答案就不对了
class Solution { //要注意一点，在leetcode上做题，成员变量和方法不能使用static关键字 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { if (root == null){ return list; } //先根 list.add(root.val); //递归访问左子树 preorderTraversal(root.left); //递归访问右子树 preorderTraversal(root.right); return list; } } 2.二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
输入：root = [1,null,2,3]
输出：[1,3,2]
和前序遍历类似
class Solution { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { if (root == null){ return list; } inorderTraversal(root." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/334828895d59ab4393ed74ad5d2e2252/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-21T20:41:48+08:00" />
<meta property="article:modified_time" content="2022-05-21T20:41:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之二叉树的练习题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1httpsleetcodecnproblemsbinarytreepreordertraversal_2"></a>1.<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" rel="nofollow">二叉树的前序遍历</a></h3> 
<blockquote> 
 <p>题目：给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p> 
 <p>输入：root = [1,null,2,3]<br> 输出：[1,2,3]</p> 
</blockquote> 
<blockquote> 
 <p>这个前序遍历和前文自己写的遍历的不同点：他的返回值是一个List集合，需要用到动态数组来保存元素，而不是简单的打印。</p> 
 <p>这道题的数组创建要变为成员变量，不能放在方法中，要不每次递归的时候都会开辟一个子数组，答案就不对了</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//要注意一点，在leetcode上做题，成员变量和方法不能使用static关键字</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> list<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//先根</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//递归访问左子树</span>
        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//递归访问右子树</span>
        <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2httpsleetcodecnproblemsbinarytreeinordertraversal_32"></a>2.<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" rel="nofollow">二叉树的中序遍历</a></h3> 
<blockquote> 
 <p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p> 
 <p>输入：root = [1,null,2,3]<br> 输出：[1,3,2]</p> 
</blockquote> 
<p><strong>和前序遍历类似</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> list<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="3httpsleetcodecnproblemsbinarytreepostordertraversal_56"></a>3.<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" rel="nofollow">二叉树的后序遍历</a></h3> 
<blockquote> 
 <p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p> 
 <p>输入：root = [1,null,2,3]<br> 输出：[3,2,1]</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> list<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> list<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="4httpsleetcodecnproblemssametree_78"></a>4.<a href="https://leetcode.cn/problems/same-tree/" rel="nofollow">相同的树</a></h3> 
<blockquote> 
 <p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p> 
 <p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p> 
 <p>输入：p = [1,2,3], q = [1,2,3]<br> 输出：true</p> 
</blockquote> 
<blockquote> 
 <p>思路：理解语义，这个函数的作用就是判断树是否相同</p> 
 <p>一共分三种情况</p> 
 <ol><li>当两颗子树都为空，一定是相同的，返回true</li><li>当一颗为空，一颗不为空，一定是不相同的，返回false</li><li>当两棵树都不为空，先判断根节点的值是否相同，在利用子函数递归访问左子树看是否相同，在利用子函数在递归访问右子树是否相同，只有当这三个条件都满足了，我们才认为这两颗树是相同的树，返回true</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span>val <span class="token operator">==</span> q<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span>q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span>q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="5httpsleetcodecnproblemssubtreeofanothertree_107"></a>5.<a href="https://leetcode.cn/problems/subtree-of-another-tree/" rel="nofollow">另一棵树的子树</a></h3> 
<blockquote> 
 <p>题目：给你两棵二叉树 root 和 subRoot 。<br> 检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。<br> 如果存在，返回 true ；否则，返回 false 。</p> 
 <p>输入：root = [3,4,5,1,2], subRoot = [4,1,2]<br> 输出：true</p> 
</blockquote> 
<blockquote> 
 <p>思路：三种情况</p> 
 <ol><li>当两颗子树都为空，一定是相同的，返回true</li><li>当一颗为空，一颗不为空，一定是不相同的，返回false</li><li>当两棵树都不为空，利用第4题判断是否为相同树的函数。先判断从两棵树根节点出发是否为相同的树，若不是，在递归访问左子树找是否有和subRoot相同的树，最后，在递归访问右子树找是否有和subRoot相同的树。只要三者满足其一，就表示找到了，返回true。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> subRoot<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> subRoot <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> subRoot <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>subRoot<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>subRoot<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubtree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>subRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> q <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span>val <span class="token operator">==</span> q<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>left<span class="token punctuation">,</span>q<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isSameTree</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>right<span class="token punctuation">,</span>q<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="6httpsleetcodecnproblemsbalancedbinarytree_144"></a>6.<a href="https://leetcode.cn/problems/balanced-binary-tree/" rel="nofollow">平衡二叉树</a></h3> 
<blockquote> 
 <p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p> 
 <p>本题中，一棵高度平衡二叉树定义为：</p> 
 <p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p> 
 <p>输入：root = [3,9,20,null,null,15,7]<br> 输出：true</p> 
</blockquote> 
<blockquote> 
 <p>思路：这道题也是递归思想。</p> 
 <ol><li>当树为空，返回true</li><li>既然定义是高度差不超过1，那我们就需要求每个结点的高度差。先求出以根结点为起点，左子树的最大深度，在求出右子树的最大深度。左右子树的差值的绝对值&lt;=1,就说明以根节点为起点的左右子树是平衡的。</li><li>后面需利用子函数递归求出每个结点的左右子树高度差。</li><li>每个结点都需要满足高度差&lt;=1,才是一颗平衡二叉树。</li></ol> 
 <p>这里需要求最大深度，也是利用递归</p> 
 <ol><li>当树为空，返回0</li><li>当只有根节点，返回1</li><li>当左右子树都存在，先利用子函数递归的访问左子树求它的最大深度，再利用子函数递归访问右子树求最大深度。</li><li>利用max()函数找出左右子树升读的最大值，再加上1（根节点），就是整棵树的最大深度了。</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> abs <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>left <span class="token operator">-</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> abs <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="7httpsleetcodecnproblemssymmetrictree_187"></a>7.<a href="https://leetcode.cn/problems/symmetric-tree/" rel="nofollow">对称二叉树</a></h3> 
<blockquote> 
 <p>题目：</p> 
 <p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p> 
 <p>输入：root = [1,2,2,3,4,4,3]<br> 输出：true</p> 
</blockquote> 
<blockquote> 
 <p>思路：轴对称就是以中间为轴，左子树翻转到右边和右子树翻转到左边是完全相同的结构</p> 
 <p>边界：</p> 
 <ol><li>左子树和右子树都为空，对称</li><li>左子树和右子树一个为空，一个不为空，不对称</li></ol> 
 <p>满足条件</p> 
 <ol><li> <p>左子树的树根和右子树的树根是否相等</p> </li><li> <p>左子树的左树和右子树的右树是否镜像相等，交给子函数</p> </li><li> <p>左子树的右树和右子树的左树是否镜像相等，交给子函数</p> </li><li> <p>当上述三个条件都满足，说明这棵树是对称的</p> </li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//传入两个子树，判断这两颗树是否镜像相等</span>
    <span class="token keyword">return</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isMirror</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> t1<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> t2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//边界</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t1 <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> t2 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> t1<span class="token punctuation">.</span>val <span class="token operator">==</span> t2<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>left<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isMirror</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span>right<span class="token punctuation">,</span>t2<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="8httpsleetcodecnproblemscheckcompletenessofabinarytree_232"></a>8.<a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/" rel="nofollow">二叉树的完全性检验</a></h3> 
<blockquote> 
 <p>给定一个二叉树的 <code>root</code> ，确定它是否是一个 <em>完全二叉树</em> 。</p> 
 <p>输入：root = [1,2,3,4,5,6]<br> 输出：true<br> 解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。</p> 
</blockquote> 
<blockquote> 
 <p>思路：一般判断问题，采用的都是找反例的方式，这道题有两种情况</p> 
 <ol><li>若二叉树中某个节点只有右树没有左树，返回false</li><li>若二叉树中有一个结点的度为一，且这个结点只有左子树没有右子树，那这个结点有且只有一个。</li></ol> 
 <p>一共分为两个阶段，引入标志位</p> 
 <ol><li>第一阶段：这个阶段，每个节点都有左右子树；当碰到第一个只有左子树没有右子树的结点或者是叶子结点，切换状态，进入第二阶段。</li><li>当碰到一个节点只有右树没有左树，反例，false</li><li>第二阶段：该阶段下，每个节点都是叶子节点，若在第二阶段下发现了有结点右子树，返回false</li></ol> 
</blockquote> 
<p><strong>第二种情况图</strong></p> 
<p><img src="https://images2.imgbox.com/86/e3/QpLKM8Nx_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isCompleteTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 判断是否是第二阶段</span>
    <span class="token keyword">boolean</span> isSecondStep <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isSecondStep<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 在第一阶段中，每个节点都必须存在左右子树</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 此时只有左树没有右树，转阶段</span>
                isSecondStep <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 只有右树没左树，反例</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 碰到叶子结点，转阶段</span>
                isSecondStep <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 此时处在第二阶段，所有节点都必须为叶子结点。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 不是叶子结点，反例</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="9httpsleetcodecnproblemsbinarytreepreordertraversal_292"></a>9.<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" rel="nofollow">二叉树的前序遍历</a></h3> 
<blockquote> 
 <p>前序遍历的非递归写法（迭代）</p> 
 <p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p> 
</blockquote> 
<blockquote> 
 <p>思路：利用栈这个结构，循环将节点压入栈。当结点有左右子树，先将右子树压入栈，再将左子树压入栈。将当前节点弹出栈并加入到数组中；若没有左右子树，直接弹出栈；若只有一颗子树，将子树压入栈。当栈为空的时候，遍历结束。</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//先压入根节点</span>
    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="10httpsleetcodecnproblemsbinarytreeinordertraversal_323"></a>10.<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" rel="nofollow">二叉树的中序遍历</a></h3> 
<blockquote> 
 <p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p> 
 <p>迭代</p> 
</blockquote> 
<blockquote> 
 <p>思路：利用栈这个结构，循环将节点压入栈。先访问左子树，在访问右子树，当节点是第二次访问的时候，将这个节点加入到数组中。当结点是第三次访问了，将这个结点弹出栈。当栈为空的时候，遍历结束。</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//指针指向根节点</span>
    <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">//一路向左走到底</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//cur为空，弹出栈顶元素</span>
        cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//访问右子树</span>
        cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="11httpsleetcodecnproblemsbinarytreepostordertraversal_356"></a>11.<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" rel="nofollow">二叉树的后序遍历</a></h3> 
<blockquote> 
 <p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p> 
 <p>迭代</p> 
</blockquote> 
<blockquote> 
 <p>思路：第三次访问根节点才能遍历</p> 
 <ol><li>一路向左走，此时栈顶就是第一个左子树为空的结点</li></ol> 
 <p>如何得知这个结点时第三次访问到？</p> 
 <p>此时引入新的变量prev：指上一个完全访问结束的结点，表示当前节点的右子树是否被处理完毕</p> 
 <p>当cur.right != null &amp;&amp; prev != cur.right 此时cur的右树不为空并且还没被访问完毕</p> 
 <p>当cur.right != null &amp;&amp; prev == cur.right 此时右子树已经处理完毕，将cur弹出并输出节点值</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/b6/71/NkoLzJWb_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 上一个完全处理完毕的节点.</span>
    <span class="token class-name">TreeNode</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 1.先一路向左走到底</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 2.查看当前栈顶元素的情况</span>
        cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 检查右子树的情况</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> cur<span class="token punctuation">.</span>right <span class="token operator">==</span> prev<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 此时右子树为空或者右子树已经被处理完毕</span>
            ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// cur节点就是最新的处理结束的结点</span>
            prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            <span class="token comment">// 继续从栈中取出栈顶元素</span>
            cur <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 此时cur.right != null 且没被访问过，继续访问右子树</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 继续访问右子树</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="12httpsleetcodecnproblemslowestcommonancestorofabinarytree_414"></a>12.<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" rel="nofollow">二叉树的最近公共祖先</a></h3> 
<blockquote> 
 <p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p> 
 <p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p> 
 <p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br> 输出：3<br> 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p> 
</blockquote> 
<blockquote> 
 <p>思路：假设一个结点为p，一个结点为q</p> 
 <p>祖先节点：包括父节点和上层结点，一个节点也可以是它自己的祖先。从祖先节点出发，当前节点处在祖先的树中。</p> 
 <p>最近祖先：距离最靠近的祖先</p> 
 <p>公共祖先：从某个节点开始，能同时找到q和p这两个结点。</p> 
 <p>最近公共祖先：从公共祖先中，深度最大的结点。</p> 
 <p>从根节点开始向下走，某个节点后序遍历能同时找到q和p两个结点，那么这个结点就是p和q的祖先。</p> 
 <p>q和p可能出现在三个位置的两个</p> 
 <ol><li> <p>两个出现在左子树</p> </li><li> <p>有一个时根结点</p> </li><li> <p>两个都出现在右子树</p> </li></ol> 
 <p>此时当前结点就是q和p的公共祖先</p> 
</blockquote> 
<blockquote> 
 <p>最终过程：</p> 
 <p>先找两个节点的所有公共祖先</p> 
 <ol><li> <p>将当前祖先和它的深度保存在Map集合中，遍历这个树的每个节点，遍历结束后，Map中保存在公共祖先和它的深度。</p> </li><li> <p>返回最大深度的那个结点，就是最近公共祖先</p> </li></ol> 
 <p>两个结点的最近公共祖先特点</p> 
 <p>p和q这两个结点会出现在当前节点的三个位置中的两个（p和q不在一棵子树中）</p> 
 <p>左子树</p> 
 <p>根</p> 
 <p>右子树</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
   <span class="token comment">// 最近公共祖先</span>
    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> lca<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 从树中每个节点开始遍历找p和q这两个节点</span>
        <span class="token function">findNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> lca<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">/**
     * 从当前以root为树根的结点开始出发，能否找到p或者q，找到一个就return true
     * @param root
     * @param p
     * @param q
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">findNode</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回1说明，此时从左子树中至少找到了一个节点</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">findNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 返回1说明在右子树中也至少找到了节点</span>
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">findNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 当前树根就是p或者q的其中一个</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right <span class="token operator">+</span> mid  <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 此时p和q出现在以root为根的两个位置，这个root一定是lca!!!</span>
            lca <span class="token operator">=</span> root<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 大于0，说明至少找到一个节点</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right <span class="token operator">+</span> mid<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="13___nowcodercomhttpswwwnowcodercompractice4b91205483694f449f94c179883c1feftpId60tqId29483rp1ruactivityojqrutatsingkaoyanquestionranking_500"></a>13.[二叉树遍历](<a href="https://www.nowcoder.com/practice/4b91205483694f449f94c179883c1fef?tpId=60&amp;&amp;tqId=29483&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/tsing-kaoyan/question-ranking" rel="nofollow">二叉树遍历_牛客题霸_牛客网 (nowcoder.com)</a>)</h3> 
<blockquote> 
 <p>编一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 例如如下的先序遍历字符串： ABC##DE#G##F### 其中“#”表示的是空格，空格字符代表空树。建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。</p> 
 <h4><a id="_504"></a>输入描述：</h4> 
 <p>输入包括1行字符串，长度不超过100。</p> 
 <h4><a id="_508"></a>输出描述：</h4> 
 <p>可能有多组测试数据，对于每组数据， 输出将输入字符串建立二叉树后中序遍历的序列，每个字符后面都有一个空格。 每个输出结果占一行。</p> 
 <p>实例：</p> 
 <p>输入：</p> 
 <p>abc##de#g##f###</p> 
 <p>输出：<br> c b e g d f a</p> 
</blockquote> 
<p><strong>图示</strong></p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HFLhfeU4-1653136710036)(D:\个人\比特\火箭\博客\数据结构之二叉树的练习题\8B986086A8F545819E0C42A24892C415.png)]</p> 
<blockquote> 
 <p>先序：ABCDEGF</p> 
 <p>中序：CBEGDFA</p> 
</blockquote> 
<blockquote> 
 <p>这道题是ACM模式编程</p> 
 <ol><li>所有ACM模式，核心代码都放在类名称为Main，所有核心逻辑都在main中</li><li>需要手动导入包</li><li>要注意输入输出的格式问题</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> val<span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">char</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 表示当前处理到先序遍历的位置</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 从外部获取了一个先序遍历的结果集字符串</span>
            <span class="token comment">// abc##de#g##f###</span>
            <span class="token class-name">String</span> str <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 就按照先序遍历的方式还原这个二叉树，返回根节点</span>
            <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token function">preOrderBuild</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 按照中序遍历的方式输出二叉树的节点值</span>
            <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 按照中序遍历遍历二叉树，打印节点值
     * @param root
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 先递归左子树</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 根  需要在一行</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 最后递归访问右子树</span>
        <span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 传入一个字符串str，按照先序遍历的方式还原为二叉树，返回二叉树的根节点
     * @param str
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">TreeNode</span> <span class="token function">preOrderBuild</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 读取一个字符</span>
        <span class="token comment">// abc##de#g##f###</span>
        <span class="token keyword">char</span> cur <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token char">'#'</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 空树，无需创建节点</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
        index <span class="token operator">++</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">preOrderBuild</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        index <span class="token operator">++</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">preOrderBuild</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="14httpsleetcodecnproblemsconstructbinarytreefrompreorderandinordertraversal_602"></a>14.<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" rel="nofollow">从前序与中序遍历序列构造二叉树</a></h3> 
<blockquote> 
 <p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p> 
 <p>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br> 输出: [3,9,20,null,null,15,7]</p> 
</blockquote> 
<blockquote> 
 <p>思路：首先两种遍历的特点：</p> 
 <p>前序遍历的第一结点就是根节点</p> 
 <p>中序遍历以根节点为中心区分左右子树</p> 
 <ol><li>先从前序遍历中取出当前树的树根</li><li>在中序遍历中找到树根所在的位置pos 
   <ol><li>所有左子树节点值[left,pos)</li><li>所有右子树节点值[pos + 1,right]</li></ol> </li><li>递归上述过程</li><li>当前序遍历的每个值都取出，构建结束</li></ol> 
 <p>核心：</p> 
 <ol><li>使用index表示当前前序遍历处理到哪个结点</li><li>从前序遍历中取出节点值作为当前树的数根节点</li><li>找到中序遍历中数根节点的位置pos。[left,pos - 1]就是左子树；[pos + 1,right]就是右子树</li><li>递归上述过程，当前序遍历的结点全都处理完了，程序结束</li></ol> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//表示处理到前序遍历的位置</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>inorder<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 每次从前序遍历中取出树根值，借助中序遍历的[left,right)还原二叉树，返回树的树根
     * @param preorder
     * @param inorder
     * @param left
     * @param right
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preorder<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//空区间，无任何结点</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> preorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//前序遍历元素全都访问完毕，退出程序</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//从前序遍历中取出当前树的数根节点</span>
        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        index <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">,</span>left<span class="token punctuation">,</span>pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span>inorder<span class="token punctuation">,</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 在中序遍历中找到val对应的索引位置
     * @param val
     * @param inorder
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="16httpsleetcodecnproblemsconstructbinarytreefrominorderandpostordertraversal_680"></a>16.<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" rel="nofollow">从中序与后序遍历序列构造二叉树</a></h3> 
<blockquote> 
 <p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p> 
 <p>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]<br> 输出：[3,9,20,null,null,15,7]</p> 
</blockquote> 
<blockquote> 
 <p>思路：后序遍历是左右根，将其转置，就变为了根右左</p> 
 <p>举例：后序遍历 9 15 7 20 3</p> 
 <p>转置： 3 20 7 15 9</p> 
 <p>和上面的套路一致，将其转置后，先递归构建右子树，在递归构建左子树。其余步骤都是一致的。</p> 
</blockquote> 
<pre><code class="prism language-java">
     <span class="token operator">*</span> 每次从后续遍历中取出树根值，借助中序遍历的<span class="token punctuation">[</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span>还原二叉树，返回树的树根
     <span class="token operator">*</span> <span class="token annotation punctuation">@param</span> postorderRv
     <span class="token operator">*</span> <span class="token annotation punctuation">@param</span> inorder
     <span class="token operator">*</span> <span class="token annotation punctuation">@param</span> left
     <span class="token operator">*</span> <span class="token annotation punctuation">@param</span> right
     <span class="token operator">*</span> <span class="token annotation punctuation">@return</span>
     <span class="token operator">*</span><span class="token operator">/</span>
    <span class="token keyword">private</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> postorderRv<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//空区间，无任何结点</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> postorderRv<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">//后序遍历元素全都访问完毕，退出程序</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//从后序遍历中取出当前树的数根节点</span>
        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>postorderRv<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        index <span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">,</span> inorder<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>postorderRv<span class="token punctuation">,</span>inorder<span class="token punctuation">,</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTreeHelper</span><span class="token punctuation">(</span>postorderRv<span class="token punctuation">,</span>inorder<span class="token punctuation">,</span>left<span class="token punctuation">,</span>pos <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * 在中序遍历中找到val对应的索引位置
     * @param val
     * @param inorder
     * @return
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> val<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="17httpswwwnowcodercompractice947f6eb80d944a84850b0538bf0ec3a5tpId13tqId11179rp1ruactivityojqrutacodinginterviewsquestionranking_739"></a>17.<a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;&amp;tqId=11179&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow">二叉搜索树与双向链表</a></h3> 
<blockquote> 
 <p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示</p> 
 <p><img src="https://images2.imgbox.com/09/c2/D9ox9J4Y_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <h4><a id="_746"></a>输入描述：</h4> 
 <p>二叉树的根节点</p> 
 <h4><a id="_750"></a>返回值描述：</h4> 
 <p>双向链表的其中一个头节点。</p> 
</blockquote> 
<blockquote> 
 <p>思路：二叉搜索树的特点是：左子树的值 &lt; 根结点值 &lt; 右子树的值</p> 
 <p>将二叉搜索树进行中序遍历就能得到一个非递减序列。上图中序遍历之后的结果：4 6 8 10 12 14 16。正好是链表的顺序。</p> 
</blockquote> 
<p><strong>二叉树和双向链表的定义</strong></p> 
<pre><code class="prism language-java"><span class="token class-name">TreeNode</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span> left<span class="token punctuation">;</span>
    <span class="token class-name">TreeNode</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Node</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>
    <span class="token class-name">Node</span> next<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <ol><li>先中序遍历二叉搜索树</li><li>转变后的TreeNode的left指向前驱结点，right指向后继节点。</li><li>先转变左子树，连接树根，后转变右子树。</li></ol> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9a/68/0yKNSOAb_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConvertTree2List</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">/**
     * 传入任意一棵树的树根节点root，就能将这棵BST转为排序后的双向链表，返回链表的头结点
     * @param pRootOfTree
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token class-name">Convert</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> pRootOfTree<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 边界</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pRootOfTree <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 1.先将左子树转为排序后的双向链表</span>
        <span class="token class-name">TreeNode</span> leftHead <span class="token operator">=</span> <span class="token class-name">Convert</span><span class="token punctuation">(</span>pRootOfTree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.找到l1链表的尾结点和当前的树根拼接</span>
        <span class="token class-name">TreeNode</span> leftTail <span class="token operator">=</span> leftHead<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>leftTail <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> leftTail<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            leftTail <span class="token operator">=</span> leftTail<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// leftTail走到了l1的尾结点</span>
        <span class="token comment">// 这里判空的原因左子树就是个空树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 进行拼接</span>
            pRootOfTree<span class="token punctuation">.</span>left <span class="token operator">=</span> leftTail<span class="token punctuation">;</span>
            leftTail<span class="token punctuation">.</span>right <span class="token operator">=</span> pRootOfTree<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 此时l1和root连接起来了</span>
        <span class="token comment">// 3.再将右子树也转为双向链表</span>
        <span class="token class-name">TreeNode</span> rightHead <span class="token operator">=</span> <span class="token class-name">Convert</span><span class="token punctuation">(</span>pRootOfTree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将l2的头结点和root拼接</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rightHead <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            rightHead<span class="token punctuation">.</span>left <span class="token operator">=</span> pRootOfTree<span class="token punctuation">;</span>
            pRootOfTree<span class="token punctuation">.</span>right <span class="token operator">=</span> rightHead<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 返回链表的开始节点。</span>
        <span class="token keyword">return</span> leftHead <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> pRootOfTree <span class="token operator">:</span> leftHead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="18httpsleetcodecnproblemsconstructstringfrombinarytree_823"></a>18.<a href="https://leetcode.cn/problems/construct-string-from-binary-tree/" rel="nofollow">根据二叉树创建字符串</a></h3> 
<blockquote> 
 <p>给你二叉树的根节点 root ，请你采用前序遍历的方式，将二叉树转化为一个由括号和整数组成的字符串，返回构造出的字符串。</p> 
 <p>空节点使用一对空括号对 “()” 表示，转化后需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。</p> 
 <p>输入：root = [1,2,3,4]<br> 输出：“1(2(4))(3)”<br> 解释：初步转化后得到 “1(2(4)())(3()())” ，但省略所有不必要的空括号对后，字符串应该是"1(2(4))(3)" 。</p> 
</blockquote> 
<blockquote> 
 <p>思路：省略括号：</p> 
 <p>当树的左子树不为空，右子树为空可以省略右子树的括号</p> 
 <p>当树的左右子树都为空，左右子树的括号都可以省略</p> 
 <p>当左树为空，右树不为空，则左子树的括号不能省略</p> 
</blockquote> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">tree2str</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 1.先处理根节点</span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.处理左子树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 1(2....)</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 左子树的转换问题交给子函数</span>
            <span class="token function">tree2str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 左子树此时为空且右子树不为空，补上一个()</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 3.处理右子树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 右子树的内容交给子函数</span>
            <span class="token function">tree2str</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0c5a2a5e3dbca891dec8e7910dd69ff4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">c&#43;&#43;:遍历vector容器的5种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/956733b96d5e35df723c4bc181ebb6aa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Cesium 之实现房屋模型拆解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>