<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vim，gcc，gdb与Makefile的使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vim，gcc，gdb与Makefile的使用" />
<meta property="og:description" content="一、Linux编辑器-vim使用 1.vim的基本概念 vim的三种模式(其实有好多模式，目前掌握这3种即可),分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下
（1）正常/普通/命令模式(Normal mode) 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode
（2）插入模式(Insert mode) 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。
（3）末行模式(last line mode） 文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，shift&#43;: 即可进入该模式。要查看你的所有模式：打开vim，底行模式直接输入
:help vim-modes 2. vim的基本操作 进入vim,在系统提示符号输入vim及文件名称后，就进入vim全屏幕编辑画面:
不过有一点要特别注意，就是你进入vim之后，是处于[正常模式]，你要切换到[插入模式]才能够输入文字。
[正常模式]切换至[插入模式]三种方法：
（1）输入a（2）输入i（3）输入o
[插入模式]切换至[正常模式]
目前处于[插入模式]，就只能一直输入文字，如果发现输错了字,想用光标键往回移动，将该字删除，可以先按一下「ESC」键转到[正常模式]再删除文字。当然，也可以直接删除。
[正常模式]切换至[末行模式]
「shift &#43; ;」, 其实就是输入「:」
退出vim及保存文件,在[正常模式]下，按一下「:」冒号键进入「Last line mode」,例如:
: w （保存当前文件）
: wq (输入「wq」,存盘并退出vim)
: q! (输入q!,不存盘强制退出vim)
3.vim正常模式命令集 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；
按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；
按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。
从插入模式切换为命令模式 按「ESC」键。
移动光标 vim可以直接用键盘上的光标来上下左右移动，但正规的vim是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格
按「G」：移动到文章的最后
按「 $ 」：移动到光标所在行的“行尾”
按「^」：移动到光标所在行的“行首”
按「w」：光标跳到下个字的开头
按「e」：光标跳到下个字的字尾
按「b」：光标回到上个字的开头" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/05db709c2c600ba6bcf5cc00ce5058f0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-17T22:11:43+08:00" />
<meta property="article:modified_time" content="2024-03-17T22:11:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vim，gcc，gdb与Makefile的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Linux编辑器-vim使用</h2> 
<h3 style="background-color:transparent;">1.vim的基本概念</h3> 
<p>vim的三种模式(其实有好多模式，目前掌握这3种即可),分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下</p> 
<h4>（1）正常/普通/命令模式(Normal mode)</h4> 
<p>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode</p> 
<h4>（2）插入模式(Insert mode)</h4> 
<p>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。该模式是我们后面用的最频繁的编辑模式。</p> 
<h4>（3）末行模式(last line mode）</h4> 
<p>文件保存或退出，也可以进行文件替换，找字符串，列出行号等操作。 在命令模式下，shift+: 即可进入该模式。要查看你的所有模式：打开vim，底行模式直接输入</p> 
<pre><code class="language-bash">:help vim-modes</code></pre> 
<h3 style="background-color:transparent;">2. vim的基本操作</h3> 
<p>进入vim,在系统提示符号输入vim及文件名称后，就进入vim全屏幕编辑画面:<br> 不过有一点要特别注意，就是你进入vim之后，是处于[正常模式]，你要切换到[插入模式]才能够输入文字。<br> [正常模式]切换至[插入模式]三种方法：<br> （1）输入a（2）输入i（3）输入o</p> 
<p><br> [插入模式]切换至[正常模式]<br> 目前处于[插入模式]，就只能一直输入文字，如果发现输错了字,想用光标键往回移动，将该字删除，可以先按一下「ESC」键转到[正常模式]再删除文字。当然，也可以直接删除。</p> 
<p><br> [正常模式]切换至[末行模式]<br> 「shift + ;」, 其实就是输入「:」</p> 
<p><br> 退出vim及保存文件,在[正常模式]下，按一下「:」冒号键进入「Last line mode」,例如:<br> : w （保存当前文件）<br> : wq (输入「wq」,存盘并退出vim)<br> : q! (输入q!,不存盘强制退出vim)<br>  </p> 
<h3>3.vim正常模式命令集</h3> 
<h4>插入模式</h4> 
<p>按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；<br> 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；<br> 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。</p> 
<h4><br> 从插入模式切换为命令模式</h4> 
<p>按「ESC」键。<br>  </p> 
<h4>移动光标</h4> 
<p>vim可以直接用键盘上的光标来上下左右移动，但正规的vim是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格<br> 按「G」：移动到文章的最后<br> 按「 $ 」：移动到光标所在行的“行尾”<br> 按「^」：移动到光标所在行的“行首”<br> 按「w」：光标跳到下个字的开头<br> 按「e」：光标跳到下个字的字尾<br> 按「b」：光标回到上个字的开头<br> 按「#l」：光标移到该行的第#个位置，如：5l,56l<br> 按［gg］：进入到文本开始<br> 按［shift＋g］：进入文本末端<br> 按「ctrl」+「b」：屏幕往“后”移动一页<br> 按「ctrl」+「f」：屏幕往“前”移动一页<br> 按「ctrl」+「u」：屏幕往“后”移动半页<br> 按「ctrl」+「d」：屏幕往“前”移动半页<br>  </p> 
<h4><strong>删除文字</strong></h4> 
<p>「x」：每按一次，删除光标所在位置的一个字符<br> 「#x」：例如，「6x」表示删除光标所在位置的“后面（包含自己在内）”6个字符<br> 「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符<br> 「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符<br> 「dd」：删除光标所在行<br> 「#dd」：从光标所在行开始删除#行<br>  </p> 
<h4>复制</h4> 
<p>「yw」：将光标所在之处到字尾的字符复制到缓冲区中。<br> 「#yw」：复制#个字到缓冲区<br> 「yy」：复制光标所在行到缓冲区。<br> 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。<br> 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。<br>  </p> 
<h4>替换</h4> 
<p>「r」：替换光标所在处的字符。<br> 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。<br>  </p> 
<h4>撤销上一次操作</h4> 
<p>「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次“u”可以执行多次回<br> 复。<br> 「ctrl + r」: 撤销的恢复</p> 
<h4><br> 更改</h4> 
<p>「cw」：更改光标所在处的字到字尾处<br> 「c#w」：例如，「c3w」表示更改3个字</p> 
<h4><br> 跳至指定的行</h4> 
<p>「ctrl」+「g」列出光标所在行的行号。<br> 「#G」：例如，「15G」，表示移动光标至文章的第15行行首。<br>  </p> 
<h3>4. vim末行模式命令集</h3> 
<p>在使用末行模式之前，请记住先按「ESC」键确定您已经处于正常模式，再按「：」冒号即可进入末行模式。</p> 
<h4><br> 列出行号</h4> 
<p>「set nu」: 输入「set nu」后，会在文件中的每一行前面列出行号。</p> 
<h4><br> 跳到文件中的某一行</h4> 
<p>「#」:「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。</p> 
<h4><br> 查找字符</h4> 
<p>「/关键字」: 先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按<br> 「n」会往后寻找到您要的关键字为止。<br> 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直<br> 按「n」会往前寻找到您要的关键字为止。</p> 
<h4><br> 保存文件</h4> 
<p>「w」: 在冒号输入字母「w」就可以将文件保存起来</p> 
<h4><br> 离开vim</h4> 
<p>「q」：按「q」就是退出，如果无法离开vim，可以在「q」后跟一个「!」强制离开vim。<br> 「wq」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。<br>  </p> 
<h2 style="background-color:transparent;">二、Linux编译器-gcc/g++使用</h2> 
<h3>1. 背景知识</h3> 
<p>（1）预处理（进行宏替换)<br> （2）编译（生成汇编)<br> （3）汇编（生成机器可识别代码）<br> （4）连接（生成可执行文件或库文件)</p> 
<h3>2. gcc如何完成</h3> 
<p>格式 gcc [选项] 要编译的文件 [选项] [目标文件]</p> 
<h4>预处理(进行宏替换)</h4> 
<p>预处理功能主要包括宏定义,文件包含,条件编译,去注释等。<br> 预处理指令是以#号开头的代码行。<br> 实例: gcc –E hello.c –o hello.i<br> 选项“-E”,该选项的作用是让 gcc 在预处理结束后停止编译过程。<br> 选项“-o”是指目标文件,“.i”文件为已经过预处理的C原始程序。</p> 
<h4>编译（生成汇编）</h4> 
<p>在这个阶段中,gcc 首先要检查代码的规范性、是否有语法错误等,以确定代码的实际要做的工作,在检查无误后,gcc 把代码翻译成汇编语言。<br> 用户可以使用“-S”选项来进行查看,该选项只进行编译而不进行汇编,生成汇编代码。<br> 实例: gcc –S hello.i –o hello.s</p> 
<h4>汇编（生成机器可识别代码）</h4> 
<p>汇编阶段是把编译阶段生成的“.s”文件转成目标文件<br> 读者在此可使用选项“-c”就可看到汇编代码已转化为“.o”的二进制目标代码了<br> 实例: gcc –c hello.s –o hello.o</p> 
<h4>连接（生成可执行文件或库文件）</h4> 
<p>在成功编译之后,就进入了链接阶段。<br> 实例: gcc hello.o –o hello<br>  </p> 
<h3>3.gcc选项</h3> 
<p>-E 只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里面<br> -S 编译到汇编语言不进行汇编和链接<br> -c 编译到目标代码<br> -o 文件输出到 文件<br> -static 此选项对生成的文件采用静态链接<br> -g 生成调试信息。GNU 调试器可利用该信息。<br> -shared 此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库.<br> -O0<br> -O1<br> -O2<br> -O3 编译器的优化选项的4个级别，-O0表示没有优化,-O1为缺省值，-O3优化级别最高<br> -w 不生成任何警告信息。<br> -Wall 生成所有警告信息。<br>  </p> 
<h2>三、Linux调试器-gdb使用</h2> 
<h3>1. 背景</h3> 
<p>程序的发布方式有两种，debug模式和release模式<br> Linux gcc/g++出来的二进制程序，默认是release模式<br> 要使用gdb调试，必须在源代码生成二进制程序的时候, 加上 -g 选项<br>  </p> 
<h3>2. 开始使用</h3> 
<p>gdb binFile 退出： ctrl + d 或 quit 调试命令：</p> 
<p><br> list／l 行号：显示binFile源代码，接着上次的位置往下列，每次列10行。<br> list／l 函数名：列出某个函数的源代码。<br> r或run：运行程序。<br> n 或 next：单条执行。<br> s或step：进入函数调用<br> break(b) 行号：在某一行设置断点<br> break 函数名：在某个函数开头设置断点<br> info break ：查看断点信息。<br> finish：执行到当前函数返回，然后挺下来等待命令<br> print(p)：打印表达式的值，通过表达式可以修改变量的值或者调用函数<br> p 变量：打印变量值。<br> set var：修改变量的值<br> continue(或c)：从当前位置开始连续而非单步执行程序<br> run(或r)：从开始连续而非单步执行程序<br> delete breakpoints：删除所有断点<br> delete breakpoints n：删除序号为n的断点<br> disable breakpoints：禁用断点<br> enable breakpoints：启用断点<br> info(或i) breakpoints：参看当前设置了哪些断点<br> display 变量名：跟踪查看一个变量，每次停下来都显示它的值<br> undisplay：取消对先前设置的那些变量的跟踪<br> until X行号：跳至X行<br> breaktrace(或bt)：查看各级函数调用及参数<br> info（i) locals：查看当前栈帧局部变量的值<br> quit：退出gdb<br>  </p> 
<h2>四、Linux项目自动化构建工具-make/Makefile</h2> 
<h3>1.背景</h3> 
<p>会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力<br> 一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作<br> makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。<br> make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。<br> make是一条命令，makefile是一个文件，两个搭配使用，完成项目自动化构建。<br>  </p> 
<h3>2.实例代码</h3> 
<p>C代码</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
printf("hello Makefile!\n");
return 0;
}</code></pre> 
<p>Makefile文件 hello:hello.o gcc hello.o -o hello hello.o:hello.s gcc -c hello.s -o hello.o hello.s:hello.i gcc -S hello.i -o hello.s hello.i:hello.c gcc -E hello.c -o hello.i</p> 
<pre><code class="language-bash">.PHONY:clean
clean:
rm -f hello.i hello.s hello.o hello</code></pre> 
<h3><br> 3.依赖关系</h3> 
<p>上面的文件 hello ,它依赖 hell.o<br> hello.o , 它依赖 hello.s<br> hello.s , 它依赖 hello.i<br> hello.i , 它依赖 hello.c</p> 
<h3>4.依赖方法</h3> 
<p>gcc hello.* -option hello.* ,就是与之对应的依赖关系</p> 
<h3>5.原理</h3> 
<p>make是如何工作的,在默认的方式下，也就是我们只输入make命令。那么，<br> （1）make会在当前目录下找名字叫“Makefile”或“makefile”的文件。<br> （2）如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“hello”这个文件，并把这个文件作为最终的目标文件。<br> （3）如果hello文件不存在，或是hello所依赖的后面的hello.o文件的文件修改时间要比hello这个文件新（可以用 touch 测试），那么，他就会执行后面所定义的命令来生成hello这个文件。<br> （4）如果hello所依赖的hello.o文件不存在，那么make会在当前文件中找目标为hello.o文件的依赖性，如果找到则再根据那一个规则生成hello.o文件。（这有点像一个堆栈的过程）<br> （5）当然，你的C文件和H文件是存在的啦，于是make会生成 hello.o 文件，然后再用 hello.o 文件声明make的终极任务，也就是执行文件hello了。<br> （6）这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。<br> （7）在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。<br> （8）make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p> 
<h3><br> 6.项目清理</h3> 
<p>工程是需要被清理的</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;
int main()
{
printf("hello Makefile!\n");
return 0;
}
</code></pre> 
<pre><code class="language-bash">.PHONY:clean
clean:
rm -f hello.i hello.s hello.o hello</code></pre> 
<p><br><br> 像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。但是一般我们这种clean的目标文件，我们将它设置为伪目标,用 .PHONY 修饰,伪目标的特性是，总是被执行的。可以将我们的 hello 目标文件声明成伪目标，测试一下。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2348a47a729861e28cb7993d47fc413/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络基础知识-操作系统作用&#43;进程管理-嵌入式系统设计师备考笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/460ab8d38fc2eb62b413085a486e7b36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【excel】常用的50个函数与基础操作(逻辑函数)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>