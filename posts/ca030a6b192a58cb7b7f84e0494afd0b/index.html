<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hololens官方教程精简版 - 08. Sharing holograms（共享全息影像） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hololens官方教程精简版 - 08. Sharing holograms（共享全息影像）" />
<meta property="og:description" content="前言 注意：本文已更新到5.5.1f1版本
本篇集中学习全息影像“共享”的功能，以实现在同一房间的人，看到“同一个物体”。之所以打引号，是因为，每个人看到的并非同一个物体，只是空间位置等信息相同的同类物体而已。
要想实现这个效果，有以下几点需要注意：
需开启设备的Spatial Perception功能（在Player Settings…面板的Publishing Settings &gt; Capabilities中勾选）需开启设备的网络功能暂时只能两台以上真机测试，无法在Unity中测试（即便是Remoting连接Hololens也不行）设备在同一房间内（废话） 友情提醒：本章需在多台设备间折腾，把设备休眠时间设置得长一点，会方便很多。具体方法如下： 设备打开，浏览器访问设备IP，进入：Hololens Device Portal，Home菜单下有个Sleep settings，最长设置30分钟。
要实现共享全息影像的效果，主要掌握以下技术点：
使用Socket协议传递数据理解世界坐标系及空间锚点的使用（WorldAnchor及WorldAnchorStore）Sharing组件的使用（锚点的上传和下载） Chapter 1 - Unity Setup 请按照第一篇的教程，完成项目的创建。 新建文件夹：”Assets/_Scenes/Holograms 240/”新建场景：”Assets/_Scenes/Holograms 240/Holograms 240.unity”打开场景，删除默认的Main Camera将”Assets/HoloToolkit/Input/Prefabs/HololensCamera.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/Input/Prefabs/InputManager.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/Input/Prefabs/Cursor/DefaultCursor.prefab”添加到Hierarchy根级 在Hierarchy面板根级，添加一个Cube，设置如下： 本节完成！
Chapter 2 - 使用Socket协议传递数据 目标 使用HoloToolkit提供的Socket套件进行数据传输
实践 搭建Socket服务基础环境
首先要说明的是：HoloToolkit提供的Socket套件，使用的是RakNet，对其原理感兴趣的同学，可以去官网查看。
在下载的HoloToolkit-Unity开发包中，找到：”External\”文件夹，将其复制到项目目录下（与Assets文件夹同级目录）。如图： 点击Unity主菜单下的：HoloToolkit &gt; Sharing Service &gt; Launch Sharing Service，如图： 此时将会打开一个Socket服务端，如图所示，记录下IP，例如本例为：192.168.0.108 在Project面板中，找到：”Assets/HoloToolkit/Sharing/Prefabs/Sharing.prefab”，拖动到Hierarchy根级，并在其Inspector面板中找到Server Address属性，填写上面一步得到的IP地址。如图： 此步相当于为APP增加了一个Socket客户端。 以上步骤完成后，可以点击Play按钮，并观察Socket服务端界面，看是否有设备加入到服务器。如图： 创建Socket消息传输类
上一步中，我们利用HoloToolkit提供的Socket套件，搭建了基础数据传输环境（包含一个Socket服务端程序和一个Socket客户端连接组件），下面用一个移动Cube的例子来学习如何同步数据。
新建文件夹：”Assets/_Scenes/Holograms 240/Scripts/”新建脚本：”Assets/_Scenes/Holograms 240/Scripts/Cube240.cs”，附加给Cube，编写脚本如下： （代码适用：5.5.0f3版本）
using HoloToolkit.Unity.InputModule; using UnityEngine; public class Cube240 : MonoBehaviour, IInputClickHandler { // 是否正在移动 bool isMoving = false; // 单击Cube，切换是否移动 public void OnInputClicked(InputEventData eventData) { isMoving = !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ca030a6b192a58cb7b7f84e0494afd0b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-19T15:20:52+08:00" />
<meta property="article:modified_time" content="2017-01-19T15:20:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hololens官方教程精简版 - 08. Sharing holograms（共享全息影像）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="前言">前言</h3> 
<p><strong>注意：本文已更新到5.5.1f1版本</strong></p> 
<p>本篇集中学习全息影像“共享”的功能，以实现在同一房间的人，看到“同一个物体”。之所以打引号，是因为，每个人看到的并非同一个物体，只是空间位置等信息相同的同类物体而已。</p> 
<p>要想实现这个效果，有以下几点需要注意：</p> 
<ul><li>需开启设备的<strong>Spatial Perception</strong>功能（在<strong>Player Settings…</strong>面板的<strong>Publishing Settings</strong> &gt; <strong>Capabilities</strong>中勾选）</li><li>需开启设备的网络功能</li><li>暂时只能两台以上真机测试，无法在<strong>Unity</strong>中测试（即便是Remoting连接Hololens也不行）</li><li>设备在同一房间内（废话）</li></ul> 
<p><em>友情提醒：本章需在多台设备间折腾，把设备休眠时间设置得长一点，会方便很多。具体方法如下：</em> <br> <em>设备打开，浏览器访问设备IP，进入：<strong>Hololens Device Portal</strong>，<strong>Home</strong>菜单下有个<strong>Sleep settings</strong>，最长设置30分钟。</em></p> 
<p>要实现共享全息影像的效果，主要掌握以下技术点：</p> 
<ul><li>使用Socket协议传递数据</li><li>理解世界坐标系及空间锚点的使用（WorldAnchor及WorldAnchorStore）</li><li>Sharing组件的使用（锚点的上传和下载）</li></ul> 
<h3 id="chapter-1-unity-setup">Chapter 1 - Unity Setup</h3> 
<ol><li>请按照第一篇的教程，完成项目的创建。 </li><li>新建文件夹：”Assets/_Scenes/<strong>Holograms 240</strong>/”</li><li>新建场景：”Assets/_Scenes/Holograms 240/<strong>Holograms 240.unity</strong>”</li><li>打开场景，删除默认的<strong>Main Camera</strong></li><li>将”Assets/HoloToolkit/Input/Prefabs/<strong>HololensCamera</strong>.prefab”添加到Hierarchy根级 </li><li>将”Assets/HoloToolkit/Input/Prefabs/<strong>InputManager</strong>.prefab”添加到Hierarchy根级 </li><li>将”Assets/HoloToolkit/Input/Prefabs/Cursor/<strong>DefaultCursor</strong>.prefab”添加到Hierarchy根级 </li><li>在<strong>Hierarchy</strong>面板根级，添加一个<strong>Cube</strong>，设置如下： <br> <img src="https://images2.imgbox.com/b5/d8/3MAydUQf_o.png" alt="设置Cube" title=""></li></ol> 
<p><strong>本节完成！</strong></p> 
<h3 id="chapter-2-使用socket协议传递数据">Chapter 2 - 使用Socket协议传递数据</h3> 
<h4 id="目标">目标</h4> 
<p><strong>使用HoloToolkit提供的Socket套件进行数据传输</strong></p> 
<h4 id="实践">实践</h4> 
<p><strong>搭建Socket服务基础环境</strong></p> 
<p><em>首先要说明的是：HoloToolkit提供的Socket套件，使用的是<a href="http://www.jenkinssoftware.com/" rel="nofollow"><strong>RakNet</strong></a>，对其原理感兴趣的同学，可以去<a href="http://www.jenkinssoftware.com/" rel="nofollow">官网</a>查看。</em></p> 
<ol><li>在下载的<a href="http://blog.csdn.net/yurichou/article/details/54093609#t2"><strong>HoloToolkit-Unity</strong></a>开发包中，找到：”External\”文件夹，将其复制到项目目录下（与Assets文件夹同级目录）。如图： <br> <img src="https://images2.imgbox.com/f8/4d/1rcRLOJ8_o.png" alt="复制Assets文件夹" title=""></li><li>点击<strong>Unity</strong>主菜单下的：HoloToolkit &gt; Sharing Service &gt; Launch Sharing Service，如图： <br> <img src="https://images2.imgbox.com/2d/dd/AQKk54OA_o.png" alt="打开Sharing Service" title=""></li><li>此时将会打开一个Socket服务端，如图所示，记录下IP，例如本例为：<strong>192.168.0.108</strong> <br> <img src="https://images2.imgbox.com/4a/17/Q1IoGgfU_o.png" alt="打开Socket服务端" title=""></li><li>在<strong>Project</strong>面板中，找到：”Assets/HoloToolkit/Sharing/Prefabs/<strong>Sharing</strong>.prefab”，拖动到<strong>Hierarchy</strong>根级，并在其<strong>Inspector</strong>面板中找到<strong>Server Address</strong>属性，填写上面一步得到的IP地址。如图： <br> <img src="https://images2.imgbox.com/96/4b/XjFdCq5I_o.png" alt="增加Sharing组件" title=""> <br> 此步相当于为APP增加了一个Socket客户端。</li></ol> 
<p>以上步骤完成后，可以点击<strong>Play</strong>按钮，并观察Socket服务端界面，看是否有设备加入到服务器。如图： <br> <img src="https://images2.imgbox.com/b4/46/Kok8n0Tr_o.png" alt="测试Socket连接" title=""></p> 
<hr> 
<p><strong>创建Socket消息传输类</strong></p> 
<p>上一步中，我们利用<strong>HoloToolkit</strong>提供的Socket套件，搭建了基础数据传输环境（包含一个Socket服务端程序和一个Socket客户端连接组件），下面用一个移动Cube的例子来学习如何同步数据。</p> 
<ol><li>新建文件夹：”Assets/_Scenes/Holograms 240/<strong>Scripts/</strong>”</li><li><p>新建脚本：”Assets/_Scenes/Holograms 240/Scripts/<strong>Cube240</strong>.cs”，附加给<strong>Cube</strong>，编写脚本如下： <br> <strong>（代码适用：5.5.0f3版本）</strong></p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Unity.InputModule;
<span class="hljs-keyword">using</span> UnityEngine;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Cube240 : MonoBehaviour, IInputClickHandler {

    <span class="hljs-comment">// 是否正在移动</span>
    <span class="hljs-keyword">bool</span> isMoving = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// 单击Cube，切换是否移动</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInputClicked</span>(InputEventData eventData)
    {
        isMoving = !isMoving;
    }

    <span class="hljs-comment">// 如果Cube为移动状态，让其放置在镜头前2米位置</span>
    <span class="hljs-keyword">void</span> Update () {
        <span class="hljs-keyword">if</span> (isMoving)
        {
            transform.position = Camera.main.transform.position + Camera.main.transform.forward * <span class="hljs-number">2</span>f;
        }
    }
}</code></pre> <p><strong>（代码适用：5.5.1f1版本）</strong></p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Unity.InputModule;
<span class="hljs-keyword">using</span> UnityEngine;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Cube240 : MonoBehaviour, IInputClickHandler
{
    <span class="hljs-comment">// 是否正在移动</span>
    <span class="hljs-keyword">bool</span> isMoving = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// 单击Cube，切换是否移动</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInputClicked</span>(InputClickedEventData eventData)
    {
        isMoving = !isMoving;
    }

    <span class="hljs-comment">// 如果Cube为移动状态，让其放置在镜头前2米位置</span>
    <span class="hljs-keyword">void</span> Update()
    {
        <span class="hljs-keyword">if</span> (isMoving)
        {
            transform.position = Camera.main.transform.position + Camera.main.transform.forward * <span class="hljs-number">2</span>f;
        }
    }
}</code></pre> <p>脚本实现了Cube的移动和放置，可以测试一下效果。</p></li><li>下面，我们来实现两台设备传递Cube的位置。</li><li>在<strong>Hierarchy</strong>面板，创建根级空对象，命名为：”<strong>Controller</strong>”</li><li><p>建立一个消息传递类。 <br> 新建脚本：”Assets/_Scenes/Holograms 240/Scripts/<strong>CustomMessages240</strong>.cs，附加给<strong>Controller</strong>，编辑内容如下：</p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Sharing;
<span class="hljs-keyword">using</span> HoloToolkit.Unity;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> CustomMessages240 : Singleton&lt;CustomMessages240&gt;
{
    <span class="hljs-comment">// 代表当前的Socket连接</span>
    NetworkConnection serverConnection;

    <span class="hljs-comment">// 当前连接的事件监听器，这是一个典型的适配器模式，继承自NetworkConnectionListener</span>
    NetworkConnectionAdapter connectionAdapter;

    <span class="hljs-comment">// 自定义消息类型</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> CustomMessageID : <span class="hljs-keyword">byte</span>
    {
        <span class="hljs-comment">// 自己的消息从MessageID.UserMessageIDStart开始编号，避免与MessageID内置消息编号冲突</span>
        <span class="hljs-comment">// Cube位置消息</span>
        CubePosition = MessageID.UserMessageIDStart,
        Max
    }

    <span class="hljs-comment">// 消息处理代理</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MessageCallback</span>(NetworkInMessage msg);

    <span class="hljs-comment">// 消息处理字典</span>
    <span class="hljs-keyword">public</span> Dictionary&lt;CustomMessageID, MessageCallback&gt; MessageHandlers { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-comment">// 当前用户在Sorket服务器中的唯一编号（自动生成）</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> LocalUserID { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()
    {
        <span class="hljs-keyword">base</span>.Awake();
        <span class="hljs-comment">// 初始化消息处理字典</span>
        MessageHandlers = <span class="hljs-keyword">new</span> Dictionary&lt;CustomMessageID, MessageCallback&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> index = (<span class="hljs-keyword">byte</span>)MessageID.UserMessageIDStart; index &lt; (<span class="hljs-keyword">byte</span>)CustomMessageID.Max; index++)
        {
            <span class="hljs-keyword">if</span> (!MessageHandlers.ContainsKey((CustomMessageID)index))
            {
                MessageHandlers.Add((CustomMessageID)index, <span class="hljs-keyword">null</span>);
            }
        }
    }

    <span class="hljs-keyword">void</span> Start () {
        <span class="hljs-comment">// SharingStage是Sharing组件对应的脚本，内部是对经典的Socket客户端的封装。</span>
        SharingStage.Instance.SharingManagerConnected += Instance_SharingManagerConnected;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Instance_SharingManagerConnected</span>(<span class="hljs-keyword">object</span> sender, System.EventArgs e)
    {
        <span class="hljs-comment">// 初始化消息处理器</span>
        InitializeMessageHandlers();
    }

    <span class="hljs-comment">// 初始化消息处理器</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeMessageHandlers</span>()
    {
        SharingStage sharingStage = SharingStage.Instance;

        <span class="hljs-keyword">if</span> (sharingStage == <span class="hljs-keyword">null</span>)
        {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// 获取当前Socket连接</span>
        serverConnection = sharingStage.Manager.GetServerConnection();
        <span class="hljs-keyword">if</span> (serverConnection == <span class="hljs-keyword">null</span>)
        {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// 初始化消息监听</span>
        connectionAdapter = <span class="hljs-keyword">new</span> NetworkConnectionAdapter();
        connectionAdapter.MessageReceivedCallback += ConnectionAdapter_MessageReceivedCallback;

        <span class="hljs-comment">// 获取当前用户在Socket服务器中生成的唯一编号</span>
        LocalUserID = sharingStage.Manager.GetLocalUser().GetID();

        <span class="hljs-comment">// 根据每个自定义消息，添加监听器</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> index = (<span class="hljs-keyword">byte</span>)MessageID.UserMessageIDStart; index &lt; (<span class="hljs-keyword">byte</span>)CustomMessageID.Max; index++)
        {
            serverConnection.AddListener(index, connectionAdapter);
        }
    }

    <span class="hljs-comment">// 接收到服务器端消息的回调处理</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ConnectionAdapter_MessageReceivedCallback</span>(NetworkConnection connection, NetworkInMessage msg)
    {
        <span class="hljs-keyword">byte</span> messageType = msg.ReadByte();
        MessageCallback messageHandler = MessageHandlers[(CustomMessageID)messageType];
        <span class="hljs-keyword">if</span> (messageHandler != <span class="hljs-keyword">null</span>)
        {
            messageHandler(msg);
        }
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()
    {
        <span class="hljs-keyword">if</span> (serverConnection != <span class="hljs-keyword">null</span>)
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">byte</span> index = (<span class="hljs-keyword">byte</span>)MessageID.UserMessageIDStart; index &lt; (<span class="hljs-keyword">byte</span>)CustomMessageID.Max; index++)
            {
                serverConnection.RemoveListener(index, connectionAdapter);
            }
            connectionAdapter.MessageReceivedCallback -= ConnectionAdapter_MessageReceivedCallback;
        }
        <span class="hljs-keyword">base</span>.OnDestroy();
    }

    <span class="hljs-comment">// 创建一个Out消息（客户端传递给服务端）</span>
    <span class="hljs-comment">// 消息格式第一个必须为消息类型，其后再添加自己的数据</span>
    <span class="hljs-comment">// 我们在所有的消息一开始添加消息发送的用户编号</span>
    <span class="hljs-keyword">private</span> NetworkOutMessage <span class="hljs-title">CreateMessage</span>(<span class="hljs-keyword">byte</span> messageType)
    {
        NetworkOutMessage msg = serverConnection.CreateMessage(messageType);
        msg.Write(messageType);
        msg.Write(LocalUserID);
        <span class="hljs-keyword">return</span> msg;
    }

    <span class="hljs-comment">// 将Cube位置广播给其他用户</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendCubePosition</span>(Vector3 position)
    {
        <span class="hljs-keyword">if</span> (serverConnection != <span class="hljs-keyword">null</span> &amp;&amp; serverConnection.IsConnected())
        {
            <span class="hljs-comment">// 将Cube的位置写入消息</span>
            NetworkOutMessage msg = CreateMessage((<span class="hljs-keyword">byte</span>)CustomMessageID.CubePosition);

            msg.Write(position.x);
            msg.Write(position.y);
            msg.Write(position.z);

            <span class="hljs-comment">// 将消息广播给其他人</span>
            serverConnection.Broadcast(msg,
                MessagePriority.Immediate, <span class="hljs-comment">//立即发送</span>
                MessageReliability.ReliableOrdered, <span class="hljs-comment">//可靠排序数据包</span>
                MessageChannel.Default); <span class="hljs-comment">// 默认频道</span>
        }
    }

    <span class="hljs-comment">// 读取Cube的位置</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vector3 <span class="hljs-title">ReadCubePosition</span>(NetworkInMessage msg)
    {
        <span class="hljs-comment">// 读取用户编号，但不使用</span>
        msg.ReadInt64();

        <span class="hljs-comment">// 依次读取XYZ，这个和发送Cube时，写入参数顺序是一致的</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(msg.ReadFloat(), msg.ReadFloat(), msg.ReadFloat());
    }
}</code></pre></li><li><p>修改<strong>Cube240.cs</strong>，内容如下： <br> <strong>（代码适用：5.5.0f3版本）</strong></p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Sharing;
<span class="hljs-keyword">using</span> HoloToolkit.Unity.InputModule;
<span class="hljs-keyword">using</span> UnityEngine;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Cube240 : MonoBehaviour, IInputClickHandler {

    <span class="hljs-comment">// 是否正在移动</span>
    <span class="hljs-keyword">bool</span> isMoving = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// 消息传递类</span>
    CustomMessages240 customMessage;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()
    {
        customMessage = CustomMessages240.Instance;

        <span class="hljs-comment">// 指定收到Cube位置消息后的处理方法</span>
        customMessage.MessageHandlers[CustomMessages240.CustomMessageID.CubePosition] = OnCubePositionReceived;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCubePositionReceived</span>(NetworkInMessage msg)
    {
        <span class="hljs-comment">// 同步Cube位置</span>
        <span class="hljs-keyword">if</span> (!isMoving)
        {
            transform.position = CustomMessages240.ReadCubePosition(msg);
        }
    }

    <span class="hljs-comment">// 单击Cube，切换是否移动</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInputClicked</span>(InputEventData eventData)
    {
        isMoving = !isMoving;
        <span class="hljs-comment">// 放置Cube后，发送Cube的位置消息给其他人</span>
        <span class="hljs-keyword">if</span> (!isMoving)
        {
            customMessage.SendCubePosition(transform.position);
        }
    }

    <span class="hljs-comment">// 如果Cube为移动状态，让其放置在镜头前2米位置</span>
    <span class="hljs-keyword">void</span> Update () {
        <span class="hljs-keyword">if</span> (isMoving)
        {
            transform.position = Camera.main.transform.position + Camera.main.transform.forward * <span class="hljs-number">2</span>f;
        }
    }
}</code></pre> <p><strong>（代码适用：5.5.1f1版本）</strong></p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Sharing;
<span class="hljs-keyword">using</span> HoloToolkit.Unity.InputModule;
<span class="hljs-keyword">using</span> UnityEngine;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Cube240 : MonoBehaviour, IInputClickHandler
{

    <span class="hljs-comment">// 是否正在移动</span>
    <span class="hljs-keyword">bool</span> isMoving = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// 消息传递类</span>
    CustomMessages240 customMessage;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()
    {
        customMessage = CustomMessages240.Instance;

        <span class="hljs-comment">// 指定收到Cube位置消息后的处理方法</span>
        customMessage.MessageHandlers[CustomMessages240.CustomMessageID.CubePosition] = OnCubePositionReceived;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCubePositionReceived</span>(NetworkInMessage msg)
    {
        <span class="hljs-comment">// 同步Cube位置</span>
        <span class="hljs-keyword">if</span> (!isMoving)
        {
            transform.position = CustomMessages240.ReadCubePosition(msg);
        }
    }

    <span class="hljs-comment">// 单击Cube，切换是否移动</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInputClicked</span>(InputClickedEventData eventData)
    {
        isMoving = !isMoving;
        <span class="hljs-comment">// 放置Cube后，发送Cube的位置消息给其他人</span>
        <span class="hljs-keyword">if</span> (!isMoving)
        {
            customMessage.SendCubePosition(transform.position);
        }
    }

    <span class="hljs-comment">// 如果Cube为移动状态，让其放置在镜头前2米位置</span>
    <span class="hljs-keyword">void</span> Update()
    {
        <span class="hljs-keyword">if</span> (isMoving)
        {
            transform.position = Camera.main.transform.position + Camera.main.transform.forward * <span class="hljs-number">2</span>f;
        }
    }
}</code></pre></li><li>发布到Hololens设备，启动，同时再点击<strong>Unity</strong>的<strong>Play</strong>按钮</li></ol> 
<p>当Hololens放置完Cube后，Play窗口中的Cube也会发生位置变化，反之亦然。</p> 
<hr> 
<p><strong>实时更新Cube的位置</strong></p> 
<p>我们只需做少量改动，就可以实现实时传递Cube的位置。</p> 
<ol><li><p>找到文件”CustomMessages240.cs”的<strong>SendCubePosition</strong>方法（大概在124行的位置），修改为：</p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">// 将Cube位置广播给其他用户</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendCubePosition</span>(Vector3 position, MessageReliability? reliability = MessageReliability.ReliableOrdered)
{
    <span class="hljs-keyword">if</span> (serverConnection != <span class="hljs-keyword">null</span> &amp;&amp; serverConnection.IsConnected())
    {
        <span class="hljs-comment">// 将Cube的位置写入消息</span>
        NetworkOutMessage msg = CreateMessage((<span class="hljs-keyword">byte</span>)CustomMessageID.CubePosition);

        msg.Write(position.x);
        msg.Write(position.y);
        msg.Write(position.z);

        <span class="hljs-comment">// 将消息广播给其他人</span>
        serverConnection.Broadcast(msg,
            MessagePriority.Immediate, <span class="hljs-comment">//立即发送</span>
            reliability.Value, <span class="hljs-comment">//可靠排序数据包</span>
            MessageChannel.Default); <span class="hljs-comment">// 默认频道</span>
    }
}</code></pre></li><li><p>找到”Cube240.cs”文件的<strong>Update</strong>方法，修改为：</p> <pre class="prettyprint"><code class=" hljs avrasm">// 如果Cube为移动状态，让其放置在镜头前<span class="hljs-number">2</span>米位置
void Update () {
    if (isMoving)
    {
        transform<span class="hljs-preprocessor">.position</span> = Camera<span class="hljs-preprocessor">.main</span><span class="hljs-preprocessor">.transform</span><span class="hljs-preprocessor">.position</span> + Camera<span class="hljs-preprocessor">.main</span><span class="hljs-preprocessor">.transform</span><span class="hljs-preprocessor">.forward</span> * <span class="hljs-number">2</span>f<span class="hljs-comment">;</span>
        // 实时传递Cube位置
        customMessage<span class="hljs-preprocessor">.SendCubePosition</span>(transform<span class="hljs-preprocessor">.position</span>, MessageReliability<span class="hljs-preprocessor">.UnreliableSequenced</span>)<span class="hljs-comment">;</span>
    }
}</code></pre></li></ol> 
<p>再次测试，不论是移动还是放置Cube，两个客户端都可以实时看到Cube的位置变化。</p> 
<p>大家注意到，在同步Cube实时移动时，使用了<strong>MessageReliability.UnreliableSequenced</strong>（不可靠序列数据包），而在同步Cube放置时，使用了默认的<strong>MessageReliability.ReliableOrdered</strong>（可靠排序数据包），是有原因的。两种情况对应了两种不同场景，一种是高频的数据同步，另外一种是低频的数据同步。不同场景对消息的可靠性、消息传递序列也有不同的要求。具体请看下面<strong>《关于消息传递方式》</strong>的说明。</p> 
<h4 id="说明">说明</h4> 
<ul><li><p><strong>关于消息结构</strong> <br> 这里要注意的是，组装消息时所使用的数据结构和解析消息时所使用的数据结构需要保持一致。 <br> 比如，本例中，组装Cube消息后的数据结构如下：</p> 
  <ol><li>消息类型，在<code>CreateMessage(byte messageType)</code>方法中的<code>msg.Write(messageType);</code></li><li>用户编号，在<code>CreateMessage(byte messageType)</code>方法中的<code>msg.Write(LocalUserID);</code></li><li>Cube的Ｘ坐标，在<code>SendCubePosition(Vector3 position)</code>方法中的<code>msg.Write(position.x);</code></li><li>Cube的Y坐标，在<code>SendCubePosition(Vector3 position)</code>方法中的<code>msg.Write(position.y);</code></li><li>Cube的Z坐标，在<code>SendCubePosition(Vector3 position)</code>方法中的<code>msg.Write(position.z);</code></li></ol> <p>同样，在解析消息时，也应该按照上面的顺序进行，如下：</p> 
  <ol><li>消息类型，在<code>ConnectionAdapter_MessageReceivedCallback(NetworkConnection connection, NetworkInMessage msg)</code>方法中的<code>byte messageType = msg.ReadByte();</code></li><li>用户编号，在<code>ReadCubePosition(NetworkInMessage msg)</code>方法中的<code>msg.ReadInt64();</code></li><li>Cube的Ｘ坐标，在<code>ReadCubePosition(NetworkInMessage msg)</code>方法中的”return new Vector3(<strong>msg.ReadFloat()</strong>, msg.ReadFloat(), msg.ReadFloat());”</li><li>Cube的Y坐标，在<code>ReadCubePosition(NetworkInMessage msg)</code>方法中的”return new Vector3(msg.ReadFloat(), <strong>msg.ReadFloat()</strong>, msg.ReadFloat());”</li><li>Cube的Z坐标，在<code>ReadCubePosition(NetworkInMessage msg)</code>方法中的”return new Vector3(msg.ReadFloat(), msg.ReadFloat(), <strong>msg.ReadFloat()</strong>);”</li></ol></li><li><p><strong>关于消息传递方式</strong></p> 
  <ul><li>MessageReliability.Reliable <br> <strong>可靠数据包</strong>：数据一定到达，但包可能乱序。适用于开关按钮等类似场景。</li><li>MessageReliability.ReliableOrdered <br> <strong>可靠排序数据包</strong>：数据一定到达，且经过排序，但需要等待传输最慢的包。适用于聊天等类似场景。</li><li>MessageReliability.ReliableSequenced <br> <strong>可靠序列数据包</strong>：数据一定到达，且经过排序，不等待慢包，旧包被抛弃。适用于低频有顺序要求的场景。比如：每2000ms更新物体的位置。</li><li>MessageReliability.Unreliable <br> <strong>不可靠数据包</strong>：数据不一定到达，包也可能乱序。适用于语音通话等类似场景。</li><li>MessageReliability.UnreliableSequenced <br> <strong>不可靠序列数据包</strong>：数据不一定到达，但经过排序，不等待慢包，旧包被抛弃。适用于高频有顺序要求的场景。比如：每100ms更新物体的位置。</li></ul></li></ul> 
<h3 id="chapter-3-空间锚点的使用">Chapter 3 - 空间锚点的使用</h3> 
<h4 id="目标-1">目标</h4> 
<p><strong>实现固化物体到空间，实现仿真的“共享”物体效果</strong></p> 
<h4 id="实践-1">实践</h4> 
<p>上一章节中，我们虽然实现了Cube的数据同步，但因为每台设备启动后的参考坐标系不同，导致看到的Cube仍然是独立与设备的（对不齐）。所以，要实现仿真的“共享”效果，肯定需要同步设备的世界坐标系。这一章节，我们将会结合空间扫描、空间锚点，来调整Cube的位置，以实现高仿真的“共享”效果。</p> 
<p><strong>准备工作：</strong></p> 
<ul><li>需开启设备的<strong>Spatial Perception</strong>功能（在<strong>Player Settings…</strong>面板的<strong>Publishing Settings</strong> &gt; <strong>Capabilities</strong>中勾选）</li><li>两台Hololens</li><li>设备在同一房间内</li></ul> 
<p><strong>原理：</strong></p> 
<ol><li>两台设备在同一房间开启空间扫描，得到基本一致的世界坐标参考系</li><li>其中一台设备在世界坐标系中设置一个锚点（坐标），并绑定到APP中的一个物体上（一般为一个根节点(0, 0, 0)），所有物体作为这个根节点的子集。</li><li>这台设备开设房间（其实就是自己的世界坐标参考系，房间包含上面的锚点），并将锚点上传至服务器</li><li>其他设备加入房间，并下载房间中的锚点信息</li><li>将锚点信息绑定到自己APP的根节点上(0, 0, 0)</li><li>之后通过上文提到的Socket技术，传递子集中的各种数据（比如：LocalPosition等）</li></ol> 
<p><strong>具体实施</strong></p> 
<ol><li>把<strong>Cube</strong>拖放到<strong>Controller</strong>上，作为子集</li><li>在<strong>Project</strong>面板中，找到”Assets/HoloToolkit/ShatialMapping/Prefabs/<strong>SpatialMapping</strong>.prefab”，拖放到<strong>Hierarchy</strong>根级</li><li>为了方便测试，我们放置一个文本，显示测试信息。将”Assets/HoloToolkit/Utilities/Prefabs/FPSDisplay”拖放到<strong>Hierarchy</strong>根级，点击<strong>FPSDisplay</strong>下的<strong>FPSText</strong>，去掉<strong>FPS Display</strong>脚本</li><li><p>新建脚本<strong>ImportExportAnchorManager240.cs</strong>，并附加给<strong>Controller</strong>，内容如下： <br> <strong>（代码适用：5.5.0f3版本）</strong></p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Sharing;
<span class="hljs-keyword">using</span> HoloToolkit.Unity;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.VR.WSA.Persistence;
<span class="hljs-keyword">using</span> UnityEngine.VR.WSA.Sharing;
<span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> UnityEngine.VR.WSA;
<span class="hljs-keyword">using</span> HoloToolkit.Unity.SpatialMapping;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ImportExportAnchorManager240 : Singleton&lt;ImportExportAnchorManager240&gt; {

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 建立共享坐标系过程中的各种状态</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> ImportExportState
    {
        <span class="hljs-comment">// 整体状态</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 开始</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        Start,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 已完成</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        Ready,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 失败</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        Failed,
        <span class="hljs-comment">// 本地锚点存储器状态</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 本地锚点存储器正在初始化</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        AnchorStore_Initializing,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 本地锚点存储器已初始化完成（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        AnchorStore_Initialized,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房间API已初始化完成（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        RoomApiInitialized,
        <span class="hljs-comment">// Anchor creation values</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 需要初始锚点（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        InitialAnchorRequired,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 正在创建初始锚点</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        CreatingInitialAnchor,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 准备导出初始锚点（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        ReadyToExportInitialAnchor,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 正在上传初始锚点</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        UploadingInitialAnchor,
        <span class="hljs-comment">// Anchor values</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 已请求数据</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        DataRequested,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 数据已准备（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        DataReady,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 导入中</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        Importing
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 当前状态</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> ImportExportState currentState = ImportExportState.Start;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 上次状态，用来测试的，代码在Update中</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> ImportExportState lastState = ImportExportState.Start;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 当前状态名</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StateName
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">return</span> currentState.ToString();
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 共享坐标系是否已经建立完成</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> AnchorEstablished
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">return</span> currentState == ImportExportState.Ready;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 序列化坐标锚点并进行设备间的传输</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> WorldAnchorTransferBatch sharedAnchorInterface;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 下载的原始锚点数据</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] rawAnchorData = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 本地锚点存储器</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> WorldAnchorStore anchorStore = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 保存我们正在导出的锚点名称</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> ExportingAnchorName = <span class="hljs-string">"anchor-1234567890"</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 正在导出的锚点数据</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">byte</span>&gt; exportingAnchorBytes = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">byte</span>&gt;();

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 共享服务是否已经准备好，这个是上传和下载锚点数据的前提条件</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> sharingServiceReady = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 共享服务中的房间管理器</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> RoomManager roomManager;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 当前房间（锚点将会保存在房间中）</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> Room currentRoom;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 有时我们会发现一些很小很小的锚点数据，这些往往没法使用，所以我们设置一个最小的可信任大小值</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint</span> minTrustworthySerializedAnchorDataSize = <span class="hljs-number">100000</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房间编号</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> roomID = <span class="hljs-number">8675309</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房间管理器的各种事件监听</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> RoomManagerAdapter roomManagerCallbacks;

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()
    {
        <span class="hljs-keyword">base</span>.Awake();
        <span class="hljs-comment">// 开始初始化本地锚点存储器</span>
        currentState = ImportExportState.AnchorStore_Initializing;
        WorldAnchorStore.GetAsync(AnchorStoreReady);
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 本地锚点存储器已准备好</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;param name="store"&gt;</span>本地锚点存储器<span class="hljs-xmlDocTag">&lt;/param&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnchorStoreReady</span>(WorldAnchorStore store)
    {
        Debug.Log(<span class="hljs-string">"本地锚点存储器（WorldAnchorStore）已准备好 - AnchorStoreReady(WorldAnchorStore store)"</span>);

        anchorStore = store;
        currentState = ImportExportState.AnchorStore_Initialized;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()
    {
        <span class="hljs-keyword">bool</span> isObserverRunning = SpatialMappingManager.Instance.IsObserverRunning();
        Debug.Log(<span class="hljs-string">"空间扫描状态："</span> + isObserverRunning);
        <span class="hljs-keyword">if</span> (!isObserverRunning)
        {
            SpatialMappingManager.Instance.StartObserver();
        }

        <span class="hljs-comment">// 共享管理器是否已经连接</span>
        SharingStage.Instance.SharingManagerConnected += Instance_SharingManagerConnected;

        <span class="hljs-comment">// 是否加入到当前会话中（此事件在共享管理器连接之后才会触发）</span>
        SharingSessionTracker.Instance.SessionJoined += Instance_SessionJoined;
    }

    <span class="hljs-preprocessor">#<span class="hljs-keyword">region</span> 共享管理器连接成功后的一系列处理</span>

    <span class="hljs-comment">// 共享管理器连接事件</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Instance_SharingManagerConnected</span>(<span class="hljs-keyword">object</span> sender, EventArgs e)
    {
        Debug.Log(<span class="hljs-string">"共享管理器连接成功 - Instance_SharingManagerConnected(object sender, EventArgs e)"</span>);

        <span class="hljs-comment">// 从共享管理器中获取房间管理器</span>
        roomManager = SharingStage.Instance.Manager.GetRoomManager();

        <span class="hljs-comment">// 房间管理器的事件监听</span>
        roomManagerCallbacks = <span class="hljs-keyword">new</span> RoomManagerAdapter();

        <span class="hljs-comment">// 房间中锚点下载完成事件</span>
        roomManagerCallbacks.AnchorsDownloadedEvent += RoomManagerCallbacks_AnchorsDownloadedEvent;
        <span class="hljs-comment">// 房间中锚点上传完成事件</span>
        roomManagerCallbacks.AnchorUploadedEvent += RoomManagerCallbacks_AnchorUploadedEvent;

        <span class="hljs-comment">// 为房间管理器添加上面的事件监听</span>
        roomManager.AddListener(roomManagerCallbacks);
    }

    <span class="hljs-comment">// 房间中锚点上传完成事件</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RoomManagerCallbacks_AnchorUploadedEvent</span>(<span class="hljs-keyword">bool</span> successful, XString failureReason)
    {
        <span class="hljs-keyword">if</span> (successful)
        {
            Debug.Log(<span class="hljs-string">"房间锚点上传完成 - RoomManagerCallbacks_AnchorUploadedEvent(bool successful, XString failureReason)"</span>);

            <span class="hljs-comment">// 房间锚点上传成功后，空间坐标共享机制建立完成</span>
            currentState = ImportExportState.Ready;
        }
        <span class="hljs-keyword">else</span>
        {
            Debug.Log(<span class="hljs-string">"房间锚点上传失败 - RoomManagerCallbacks_AnchorUploadedEvent(bool successful, XString failureReason)"</span>);

            <span class="hljs-comment">// 房间锚点上传失败</span>
            Debug.Log(<span class="hljs-string">"Anchor Upload Failed!"</span> + failureReason);
            currentState = ImportExportState.Failed;
        }
    }

    <span class="hljs-comment">// 房间中锚点下载完成事件</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RoomManagerCallbacks_AnchorsDownloadedEvent</span>(<span class="hljs-keyword">bool</span> successful, AnchorDownloadRequest request, XString failureReason)
    {
        <span class="hljs-keyword">if</span> (successful)
        {
            Debug.Log(<span class="hljs-string">"房间锚点下载完成 - RoomManagerCallbacks_AnchorsDownloadedEvent(bool successful, AnchorDownloadRequest request, XString failureReason)"</span>);

            <span class="hljs-comment">// 房间锚点下载完成</span>
            <span class="hljs-comment">// 获取锚点数据长度</span>
            <span class="hljs-keyword">int</span> datasize = request.GetDataSize();
            <span class="hljs-comment">// 将下载的锚点数据缓存到数组中</span>
            rawAnchorData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[datasize];

            request.GetData(rawAnchorData, datasize);

            <span class="hljs-comment">// 保存完锚点数据，可以开始准备传输数据</span>
            currentState = ImportExportState.DataReady;
        }
        <span class="hljs-keyword">else</span>
        {
            Debug.Log(<span class="hljs-string">"锚点下载失败！"</span> + failureReason + <span class="hljs-string">" - RoomManagerCallbacks_AnchorsDownloadedEvent(bool successful, AnchorDownloadRequest request, XString failureReason)"</span>);

            <span class="hljs-comment">// 锚点下载失败，重新开始请求锚点数据</span>
            MakeAnchorDataRequest();
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 请求锚点数据</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeAnchorDataRequest</span>()
    {
        <span class="hljs-keyword">if</span> (roomManager.DownloadAnchor(currentRoom, <span class="hljs-keyword">new</span> XString(ExportingAnchorName)))
        {
            <span class="hljs-comment">// 下载锚点完成</span>
            currentState = ImportExportState.DataRequested;
        }
        <span class="hljs-keyword">else</span>
        {
            currentState = ImportExportState.Failed;
        }
    }

    <span class="hljs-preprocessor">#<span class="hljs-keyword">endregion</span></span>

    <span class="hljs-preprocessor">#<span class="hljs-keyword">region</span> 成功加入当前会话后的一系列处理</span>

    <span class="hljs-comment">// 加入当前会话完成</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Instance_SessionJoined</span>(<span class="hljs-keyword">object</span> sender, SharingSessionTracker.SessionJoinedEventArgs e)
    {
        SharingSessionTracker.Instance.SessionJoined -= Instance_SessionJoined;

        <span class="hljs-comment">// 稍等一下，将共享服务状态设置为正常，即可以开始同步锚点了</span>
        Invoke(<span class="hljs-string">"MarkSharingServiceReady"</span>, <span class="hljs-number">5</span>);
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 将共享服务状态设置为正常</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MarkSharingServiceReady</span>()
    {
        sharingServiceReady = <span class="hljs-keyword">true</span>;


<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> UNITY_EDITOR || UNITY_STANDALONE</span>

        InitRoomApi();

<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 初始化房间，直到加入到房间中（Update中会持续调用）</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitRoomApi</span>()
    {
        <span class="hljs-keyword">int</span> roomCount = roomManager.GetRoomCount();
        <span class="hljs-keyword">if</span> (roomCount == <span class="hljs-number">0</span>)
        {
            Debug.Log(<span class="hljs-string">"未找到房间 - InitRoomApi()"</span>);

            <span class="hljs-comment">// 如果当前会话中，没有获取到任何房间</span>
            <span class="hljs-keyword">if</span> (LocalUserHasLowestUserId())
            {
                <span class="hljs-comment">// 如果当前用户编号最小，则创建房间</span>
                currentRoom = roomManager.CreateRoom(<span class="hljs-keyword">new</span> XString(<span class="hljs-string">"DefaultRoom"</span>), roomID, <span class="hljs-keyword">false</span>);
                <span class="hljs-comment">// 房间创建好，准备加载本地的初始锚点，供其他人共享</span>
                currentState = ImportExportState.InitialAnchorRequired;

                Debug.Log(<span class="hljs-string">"我是房主，创建房间完成 - InitRoomApi()"</span>);
            }
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; roomCount; i++)
            {
                <span class="hljs-comment">// 获取第一个房间为当前房间</span>
                currentRoom = roomManager.GetRoom(i);
                <span class="hljs-keyword">if</span> (currentRoom.GetID() == roomID)
                {
                    <span class="hljs-comment">// 加入当前房间</span>
                    roomManager.JoinRoom(currentRoom);
                    <span class="hljs-comment">// TODO: 加入房间，房间API初始化完成，准备同步初始锚点</span>
                    currentState = ImportExportState.RoomApiInitialized;

                    Debug.Log(<span class="hljs-string">"找到房间并加入！ - InitRoomApi()"</span>);

                    <span class="hljs-keyword">return</span>;
                }
            }
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 判断当前用户编号是不是所有用户中最小的</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;returns&gt;</span><span class="hljs-xmlDocTag">&lt;/returns&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">LocalUserHasLowestUserId</span>()
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; SharingSessionTracker.Instance.UserIds.Count; i++)
        {
            <span class="hljs-keyword">if</span> (SharingSessionTracker.Instance.UserIds[i] &lt; CustomMessages240.Instance.LocalUserID)
            {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-preprocessor">#<span class="hljs-keyword">endregion</span></span>

    <span class="hljs-comment">// Update中处理各种状态（简单状态机）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()
    {
        <span class="hljs-keyword">if</span> (currentState != lastState)
        {
            Debug.Log(<span class="hljs-string">"状态变化："</span> + lastState.ToString() + <span class="hljs-string">" &gt; "</span> + currentState.ToString());
            lastState = currentState;
        }

        <span class="hljs-keyword">switch</span> (currentState)
        {
            <span class="hljs-keyword">case</span> ImportExportState.AnchorStore_Initialized:
                <span class="hljs-comment">// 本地锚点存储器初始化完成</span>
                <span class="hljs-comment">// 如果成功加入当前会话，则开始加载房间</span>
                <span class="hljs-keyword">if</span> (sharingServiceReady)
                {
                    InitRoomApi();
                }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ImportExportState.RoomApiInitialized:
                <span class="hljs-comment">// 房间已加载完成，开始加载锚点信息</span>
                StartAnchorProcess();
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ImportExportState.DataReady:
                <span class="hljs-comment">// 锚点数据下载完成后，开始导入锚点数据</span>
                currentState = ImportExportState.Importing;
                WorldAnchorTransferBatch.ImportAsync(rawAnchorData, ImportComplete);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ImportExportState.InitialAnchorRequired:
                <span class="hljs-comment">// 房主房间创建完成后，需要创建初始锚点共享给他人</span>
                currentState = ImportExportState.CreatingInitialAnchor;
                <span class="hljs-comment">// 创建本地锚点</span>
                CreateAnchorLocally();
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ImportExportState.ReadyToExportInitialAnchor:
                <span class="hljs-comment">// 准备导出初始锚点</span>
                currentState = ImportExportState.UploadingInitialAnchor;
                <span class="hljs-comment">// 执行导出</span>
                Export();
                <span class="hljs-keyword">break</span>;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房主将本地锚点共享给其他人</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Export</span>()
    {
        <span class="hljs-comment">// 获取锚点，这个组件会在CreateAnchorLocally()中自动添加</span>
        WorldAnchor anchor = GetComponent&lt;WorldAnchor&gt;();

        <span class="hljs-keyword">if</span> (anchor == <span class="hljs-keyword">null</span>)
        {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-comment">// 本地保存该锚点</span>
        <span class="hljs-keyword">if</span> (anchorStore.Save(ExportingAnchorName, anchor))
        {
            <span class="hljs-comment">// 将锚点导出</span>
            sharedAnchorInterface = <span class="hljs-keyword">new</span> WorldAnchorTransferBatch();
            sharedAnchorInterface.AddWorldAnchor(ExportingAnchorName, anchor);
            WorldAnchorTransferBatch.ExportAsync(sharedAnchorInterface, WriteBuffer, ExportComplete);
        }
        <span class="hljs-keyword">else</span>
        {
            currentState = ImportExportState.InitialAnchorRequired;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房主导出锚点成功</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;param name="completionReason"&gt;</span><span class="hljs-xmlDocTag">&lt;/param&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExportComplete</span>(SerializationCompletionReason completionReason)
    {
        <span class="hljs-keyword">if</span> (completionReason == SerializationCompletionReason.Succeeded &amp;&amp; exportingAnchorBytes.Count &gt; minTrustworthySerializedAnchorDataSize)
        {
            <span class="hljs-comment">// 将锚点数据上传至当前房间中</span>
            roomManager.UploadAnchor(
                currentRoom,
                <span class="hljs-keyword">new</span> XString(ExportingAnchorName),
                exportingAnchorBytes.ToArray(),
                exportingAnchorBytes.Count);
        }
        <span class="hljs-keyword">else</span>
        {
            currentState = ImportExportState.InitialAnchorRequired;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteBuffer</span>(<span class="hljs-keyword">byte</span>[] data)
    {
        exportingAnchorBytes.AddRange(data);
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房主在本地创建一个新的锚点</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateAnchorLocally</span>()
    {
        Debug.Log(<span class="hljs-string">"开始创建本地锚点"</span>);

        <span class="hljs-comment">// 添加世界锚点组件</span>
        WorldAnchor anchor = GetComponent&lt;WorldAnchor&gt;();
        <span class="hljs-keyword">if</span> (anchor == <span class="hljs-keyword">null</span>)
        {
            anchor = gameObject.AddComponent&lt;WorldAnchor&gt;();
        }

        <span class="hljs-keyword">if</span> (anchor.isLocated)
        {
            <span class="hljs-comment">// 房主自己定位好本地锚点后，准备导出给其他人</span>
            currentState = ImportExportState.ReadyToExportInitialAnchor;
        } 
        <span class="hljs-keyword">else</span>
        {
            anchor.OnTrackingChanged += WorldAnchorForExport_OnTrackingChanged;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WorldAnchorForExport_OnTrackingChanged</span>(WorldAnchor self, <span class="hljs-keyword">bool</span> located)
    {
        <span class="hljs-keyword">if</span> (located)
        {
            <span class="hljs-comment">// 房主自己定位好本地锚点后，准备导出给其他人</span>
            currentState = ImportExportState.ReadyToExportInitialAnchor;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// 房主自己的锚点定位失败，则同步总体失败</span>
            currentState = ImportExportState.Failed;
        }

        self.OnTrackingChanged -= WorldAnchorForExport_OnTrackingChanged;
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 锚点数据下载完成后，开始导入锚点数据</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;param name="completionReason"&gt;</span><span class="hljs-xmlDocTag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;param name="deserializedTransferBatch"&gt;</span><span class="hljs-xmlDocTag">&lt;/param&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ImportComplete</span>(SerializationCompletionReason completionReason, WorldAnchorTransferBatch deserializedTransferBatch)
    {
        <span class="hljs-keyword">if</span> (completionReason == SerializationCompletionReason.Succeeded &amp;&amp; deserializedTransferBatch.GetAllIds().Length &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-comment">// 成功导入锚点</span>
            <span class="hljs-comment">// 获取第一个锚点名称</span>
            <span class="hljs-keyword">bool</span> hasAnchorName = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">string</span>[] anchorNames = deserializedTransferBatch.GetAllIds();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> an <span class="hljs-keyword">in</span> anchorNames)
            {
                <span class="hljs-keyword">if</span> (an == ExportingAnchorName)
                {
                    hasAnchorName = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (!hasAnchorName)
            {
                currentState = ImportExportState.DataReady;
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// 保存锚点到本地</span>
            WorldAnchor anchor = deserializedTransferBatch.LockObject(ExportingAnchorName, gameObject);
            <span class="hljs-keyword">if</span> (anchor.isLocated)
            {
                <span class="hljs-keyword">if</span>(anchorStore.Save(ExportingAnchorName, anchor))
                {
                    currentState = ImportExportState.Ready;
                }
                <span class="hljs-keyword">else</span>
                {
                    currentState = ImportExportState.DataReady;
                }

            }
            <span class="hljs-keyword">else</span>
            {
                anchor.OnTrackingChanged += WorldAnchorForImport_OnTrackingChanged;
            }
        } 
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// 未成功导入，则设置为DataReady，准备在下一帧再次导入，直到导入完成</span>
            currentState = ImportExportState.DataReady;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WorldAnchorForImport_OnTrackingChanged</span>(WorldAnchor self, <span class="hljs-keyword">bool</span> located)
    {
        <span class="hljs-keyword">if</span> (located)
        {
            WorldAnchor anchor = GetComponent&lt;WorldAnchor&gt;();
            <span class="hljs-keyword">if</span> (anchorStore.Save(ExportingAnchorName, anchor))
            {
                currentState = ImportExportState.Ready;
            }
            <span class="hljs-keyword">else</span>
            {
                currentState = ImportExportState.DataReady;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            currentState = ImportExportState.Failed;
        }

        self.OnTrackingChanged -= WorldAnchorForImport_OnTrackingChanged;
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 加载锚点信息</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartAnchorProcess</span>()
    {
        Debug.Log(<span class="hljs-string">"正在获取房间锚点…… - StartAnchorProcess()"</span>);

        <span class="hljs-comment">// 检查当前房间有无锚点</span>
        <span class="hljs-keyword">int</span> anchorCount = currentRoom.GetAnchorCount();

        <span class="hljs-keyword">if</span> (anchorCount &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">bool</span> isRoomAnchorExists = <span class="hljs-keyword">false</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; anchorCount; i++)
            {
                <span class="hljs-keyword">string</span> roomAnchor = currentRoom.GetAnchorName(i).GetString();
                <span class="hljs-keyword">if</span> (roomAnchor == ExportingAnchorName)
                {
                    isRoomAnchorExists = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (isRoomAnchorExists)
            {
                Debug.Log(<span class="hljs-string">"获取房间锚点成功！开始下载锚点"</span>);
                <span class="hljs-comment">// 获取房间锚点信息成功后，开始下载锚点数据</span>
                MakeAnchorDataRequest();
            }
        }
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()
    {
        <span class="hljs-keyword">if</span> (SharingStage.Instance != <span class="hljs-keyword">null</span>)
        {
            SharingStage.Instance.SharingManagerConnected -= Instance_SharingManagerConnected;
        }

        <span class="hljs-keyword">if</span> (roomManagerCallbacks != <span class="hljs-keyword">null</span>)
        {
            roomManagerCallbacks.AnchorsDownloadedEvent -= RoomManagerCallbacks_AnchorsDownloadedEvent;
            roomManagerCallbacks.AnchorUploadedEvent -= RoomManagerCallbacks_AnchorUploadedEvent;

            <span class="hljs-keyword">if</span> (roomManager != <span class="hljs-keyword">null</span>)
            {
                roomManager.RemoveListener(roomManagerCallbacks);
            }
        }

        <span class="hljs-keyword">base</span>.OnDestroy();
    }
}</code></pre> <p><strong>（代码适用：5.5.1f1版本）</strong></p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Sharing;
<span class="hljs-keyword">using</span> HoloToolkit.Unity;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.VR.WSA.Persistence;
<span class="hljs-keyword">using</span> UnityEngine.VR.WSA.Sharing;
<span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> UnityEngine.VR.WSA;
<span class="hljs-keyword">using</span> HoloToolkit.Unity.SpatialMapping;
<span class="hljs-keyword">using</span> System.Text;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ImportExportAnchorManager240 : Singleton&lt;ImportExportAnchorManager240&gt;
{
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 建立共享坐标系过程中的各种状态</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> ImportExportState
    {
        <span class="hljs-comment">// 整体状态</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 开始</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        Start,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 已完成</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        Ready,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 失败</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        Failed,
        <span class="hljs-comment">// 本地锚点存储器状态</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 本地锚点存储器正在初始化</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        AnchorStore_Initializing,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 本地锚点存储器已初始化完成（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        AnchorStore_Initialized,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房间API已初始化完成（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        RoomApiInitialized,
        <span class="hljs-comment">// Anchor creation values</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 需要初始锚点（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        InitialAnchorRequired,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 正在创建初始锚点</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        CreatingInitialAnchor,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 准备导出初始锚点（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        ReadyToExportInitialAnchor,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 正在上传初始锚点</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        UploadingInitialAnchor,
        <span class="hljs-comment">// Anchor values</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 已请求数据</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        DataRequested,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 数据已准备（在状态机中）</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        DataReady,
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 导入中</span>
        <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
        Importing
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 当前状态</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> ImportExportState currentState = ImportExportState.Start;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 上次状态，用来测试的，代码在Update中</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> ImportExportState lastState = ImportExportState.Start;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 当前状态名</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> StateName
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">return</span> currentState.ToString();
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 共享坐标系是否已经建立完成</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> AnchorEstablished
    {
        <span class="hljs-keyword">get</span>
        {
            <span class="hljs-keyword">return</span> currentState == ImportExportState.Ready;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 序列化坐标锚点并进行设备间的传输</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> WorldAnchorTransferBatch sharedAnchorInterface;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 下载的原始锚点数据</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] rawAnchorData = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 本地锚点存储器</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> WorldAnchorStore anchorStore = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 保存我们正在导出的锚点名称</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> ExportingAnchorName = <span class="hljs-string">"anchor-1234567890"</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 正在导出的锚点数据</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">byte</span>&gt; exportingAnchorBytes = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-keyword">byte</span>&gt;();

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 共享服务是否已经准备好，这个是上传和下载锚点数据的前提条件</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> sharingServiceReady = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 共享服务中的房间管理器</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> RoomManager roomManager;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 当前房间（锚点将会保存在房间中）</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> Room currentRoom;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 有时我们会发现一些很小很小的锚点数据，这些往往没法使用，所以我们设置一个最小的可信任大小值</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint</span> minTrustworthySerializedAnchorDataSize = <span class="hljs-number">100000</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房间编号</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> roomID = <span class="hljs-number">8675309</span>;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房间管理器的各种事件监听</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> RoomManagerAdapter roomManagerCallbacks;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 锚点上传完成事件</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action&lt;<span class="hljs-keyword">bool</span>&gt; AnchorUploaded;

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 锚点加载完成事件</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> Action AnchorLoaded;

    <span class="hljs-keyword">private</span> TextMesh lblMsg;
    <span class="hljs-keyword">private</span> StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debug</span>(<span class="hljs-keyword">string</span> msg)
    {
        Debug.Log(msg);
        sb.AppendLine(msg);
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()
    {
        <span class="hljs-keyword">base</span>.Awake();

        lblMsg = GameObject.Find(<span class="hljs-string">"FPSText"</span>).GetComponent&lt;TextMesh&gt;();

        <span class="hljs-comment">// 开始初始化本地锚点存储器</span>
        currentState = ImportExportState.AnchorStore_Initializing;
        WorldAnchorStore.GetAsync(AnchorStoreReady);
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 本地锚点存储器已准备好</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;param name="store"&gt;</span>本地锚点存储器<span class="hljs-xmlDocTag">&lt;/param&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AnchorStoreReady</span>(WorldAnchorStore store)
    {
        debug(<span class="hljs-string">"本地锚点存储器（WorldAnchorStore）已准备好 - AnchorStoreReady(WorldAnchorStore store)"</span>);

        anchorStore = store;
        currentState = ImportExportState.AnchorStore_Initialized;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()
    {

        <span class="hljs-keyword">bool</span> isObserverRunning = SpatialMappingManager.Instance.IsObserverRunning();
        debug(<span class="hljs-string">"空间扫描状态："</span> + isObserverRunning);

        <span class="hljs-keyword">if</span> (!isObserverRunning)
        {
            SpatialMappingManager.Instance.StartObserver();
        }

        <span class="hljs-comment">// 共享管理器是否已经连接</span>
        SharingStage.Instance.SharingManagerConnected += Instance_SharingManagerConnected;

        <span class="hljs-comment">// 是否加入到当前会话中（此事件在共享管理器连接之后才会触发）</span>
        SharingStage.Instance.SessionsTracker.CurrentUserJoined += SessionsTracker_CurrentUserJoined;
        SharingStage.Instance.SessionsTracker.CurrentUserLeft += SessionsTracker_CurrentUserLeft;
    }



    <span class="hljs-preprocessor">#<span class="hljs-keyword">region</span> 共享管理器连接成功后的一系列处理</span>

    <span class="hljs-comment">// 共享管理器连接事件</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Instance_SharingManagerConnected</span>(<span class="hljs-keyword">object</span> sender, EventArgs e)
    {
        debug(<span class="hljs-string">"共享管理器连接成功 - Instance_SharingManagerConnected(object sender, EventArgs e)"</span>);

        <span class="hljs-comment">// 从共享管理器中获取房间管理器</span>
        roomManager = SharingStage.Instance.Manager.GetRoomManager();

        <span class="hljs-comment">// 房间管理器的事件监听</span>
        roomManagerCallbacks = <span class="hljs-keyword">new</span> RoomManagerAdapter();

        <span class="hljs-comment">// 房间中锚点下载完成事件</span>
        roomManagerCallbacks.AnchorsDownloadedEvent += RoomManagerCallbacks_AnchorsDownloadedEvent;
        <span class="hljs-comment">// 房间中锚点上传完成事件</span>
        roomManagerCallbacks.AnchorUploadedEvent += RoomManagerCallbacks_AnchorUploadedEvent;

        <span class="hljs-comment">// 为房间管理器添加上面的事件监听</span>
        roomManager.AddListener(roomManagerCallbacks);
    }

    <span class="hljs-comment">// 房间中锚点上传完成事件</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RoomManagerCallbacks_AnchorUploadedEvent</span>(<span class="hljs-keyword">bool</span> successful, XString failureReason)
    {
        <span class="hljs-keyword">if</span> (successful)
        {
            debug(<span class="hljs-string">"房间锚点上传完成 - RoomManagerCallbacks_AnchorUploadedEvent(bool successful, XString failureReason)"</span>);

            <span class="hljs-comment">// 房间锚点上传成功后，空间坐标共享机制建立完成</span>
            currentState = ImportExportState.Ready;
        }
        <span class="hljs-keyword">else</span>
        {
            debug(<span class="hljs-string">"房间锚点上传失败 - RoomManagerCallbacks_AnchorUploadedEvent(bool successful, XString failureReason)"</span>);

            <span class="hljs-comment">// 房间锚点上传失败</span>
            debug(<span class="hljs-string">"Anchor Upload Failed!"</span> + failureReason);
            currentState = ImportExportState.Failed;
        }

        <span class="hljs-keyword">if</span> (AnchorUploaded != <span class="hljs-keyword">null</span>)
        {
            AnchorUploaded(successful);
        }
    }

    <span class="hljs-comment">// 房间中锚点下载完成事件</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RoomManagerCallbacks_AnchorsDownloadedEvent</span>(<span class="hljs-keyword">bool</span> successful, AnchorDownloadRequest request, XString failureReason)
    {
        <span class="hljs-keyword">if</span> (successful)
        {
            debug(<span class="hljs-string">"房间锚点下载完成 - RoomManagerCallbacks_AnchorsDownloadedEvent(bool successful, AnchorDownloadRequest request, XString failureReason)"</span>);

            <span class="hljs-comment">// 房间锚点下载完成</span>
            <span class="hljs-comment">// 获取锚点数据长度</span>
            <span class="hljs-keyword">int</span> datasize = request.GetDataSize();

            <span class="hljs-comment">// 将下载的锚点数据缓存到数组中</span>
            rawAnchorData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[datasize];

            request.GetData(rawAnchorData, datasize);

            <span class="hljs-comment">// 保存完锚点数据，可以开始准备传输数据</span>
            currentState = ImportExportState.DataReady;
        }
        <span class="hljs-keyword">else</span>
        {
            debug(<span class="hljs-string">"锚点下载失败！"</span> + failureReason + <span class="hljs-string">" - RoomManagerCallbacks_AnchorsDownloadedEvent(bool successful, AnchorDownloadRequest request, XString failureReason)"</span>);

            <span class="hljs-comment">// 锚点下载失败，重新开始请求锚点数据</span>
            MakeAnchorDataRequest();
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 请求锚点数据</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeAnchorDataRequest</span>()
    {
        <span class="hljs-keyword">if</span> (roomManager.DownloadAnchor(currentRoom, <span class="hljs-keyword">new</span> XString(ExportingAnchorName)))
        {
            <span class="hljs-comment">// 下载锚点完成</span>
            currentState = ImportExportState.DataRequested;
        }
        <span class="hljs-keyword">else</span>
        {
            currentState = ImportExportState.Failed;
        }
    }

    <span class="hljs-preprocessor">#<span class="hljs-keyword">endregion</span></span>

    <span class="hljs-preprocessor">#<span class="hljs-keyword">region</span> 成功加入当前会话后的一系列处理</span>

    <span class="hljs-comment">// 加入当前会话完成</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SessionsTracker_CurrentUserJoined</span>(Session session)
    {
        SharingStage.Instance.SessionsTracker.CurrentUserJoined -= SessionsTracker_CurrentUserJoined;

        <span class="hljs-comment">// 稍等一下，将共享服务状态设置为正常，即可以开始同步锚点了</span>
        Invoke(<span class="hljs-string">"MarkSharingServiceReady"</span>, <span class="hljs-number">5</span>);
    }

    <span class="hljs-comment">// 退出当前会话</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SessionsTracker_CurrentUserLeft</span>(Session session)
    {
        sharingServiceReady = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">if</span> (anchorStore != <span class="hljs-keyword">null</span>)
        {
            currentState = ImportExportState.AnchorStore_Initialized;
        }
        <span class="hljs-keyword">else</span>
        {
            currentState = ImportExportState.AnchorStore_Initializing;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 将共享服务状态设置为正常</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MarkSharingServiceReady</span>()
    {
        sharingServiceReady = <span class="hljs-keyword">true</span>;


<span class="hljs-preprocessor">#<span class="hljs-keyword">if</span> UNITY_EDITOR || UNITY_STANDALONE</span>

        InitRoomApi();

<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 初始化房间，直到加入到房间中（Update中会持续调用）</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitRoomApi</span>()
    {
        <span class="hljs-keyword">int</span> roomCount = roomManager.GetRoomCount();

        <span class="hljs-keyword">if</span> (roomCount == <span class="hljs-number">0</span>)
        {
            debug(<span class="hljs-string">"未找到房间 - InitRoomApi()"</span>);

            <span class="hljs-comment">// 如果当前会话中，没有获取到任何房间</span>
            <span class="hljs-keyword">if</span> (LocalUserHasLowestUserId())
            {
                <span class="hljs-comment">// 如果当前用户编号最小，则创建房间</span>
                currentRoom = roomManager.CreateRoom(<span class="hljs-keyword">new</span> XString(<span class="hljs-string">"DefaultRoom"</span>), roomID, <span class="hljs-keyword">false</span>);
                <span class="hljs-comment">// 房间创建好，准备加载本地的初始锚点，供其他人共享</span>
                currentState = ImportExportState.InitialAnchorRequired;

                debug(<span class="hljs-string">"我是房主，创建房间完成 - InitRoomApi()"</span>);
            }
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; roomCount; i++)
            {
                currentRoom = roomManager.GetRoom(i);
                <span class="hljs-keyword">if</span> (currentRoom.GetID() == roomID)
                {
                    <span class="hljs-comment">// 加入当前房间</span>
                    roomManager.JoinRoom(currentRoom);
                    <span class="hljs-comment">// TODO: 加入房间，房间API初始化完成，准备同步初始锚点</span>
                    currentState = ImportExportState.RoomApiInitialized;

                    debug(<span class="hljs-string">"找到房间并加入！ - InitRoomApi()"</span>);

                    <span class="hljs-keyword">return</span>;
                }
            }
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 判断当前用户编号是不是所有用户中最小的</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;returns&gt;</span><span class="hljs-xmlDocTag">&lt;/returns&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">LocalUserHasLowestUserId</span>()
    {
        <span class="hljs-keyword">if</span> (SharingStage.Instance == <span class="hljs-keyword">null</span>)
        {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }
        <span class="hljs-keyword">if</span> (SharingStage.Instance.SessionUsersTracker != <span class="hljs-keyword">null</span>)
        {
            List&lt;User&gt; currentUsers = SharingStage.Instance.SessionUsersTracker.CurrentUsers;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; currentUsers.Count; i++)
            {
                <span class="hljs-keyword">if</span> (currentUsers[i].GetID() &lt; CustomMessages240.Instance.LocalUserID)
                {
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
                }
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-preprocessor">#<span class="hljs-keyword">endregion</span></span>

    <span class="hljs-comment">// Update中处理各种状态（简单状态机）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()
    {
        <span class="hljs-keyword">if</span> (currentState != lastState)
        {
            debug(<span class="hljs-string">"状态变化："</span> + lastState.ToString() + <span class="hljs-string">" &gt; "</span> + currentState.ToString());
            lastState = currentState;
        }

        lblMsg.text = sb.ToString();

        <span class="hljs-keyword">switch</span> (currentState)
        {
            <span class="hljs-keyword">case</span> ImportExportState.AnchorStore_Initialized:
                <span class="hljs-comment">// 本地锚点存储器初始化完成</span>
                <span class="hljs-comment">// 如果成功加入当前会话，则开始加载房间</span>
                <span class="hljs-keyword">if</span> (sharingServiceReady)
                {
                    InitRoomApi();
                }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ImportExportState.RoomApiInitialized:
                <span class="hljs-comment">// 房间已加载完成，开始加载锚点信息</span>
                StartAnchorProcess();
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ImportExportState.DataReady:
                <span class="hljs-comment">// 锚点数据下载完成后，开始导入锚点数据</span>
                currentState = ImportExportState.Importing;
                WorldAnchorTransferBatch.ImportAsync(rawAnchorData, ImportComplete);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ImportExportState.InitialAnchorRequired:
                <span class="hljs-comment">// 房主房间创建完成后，需要创建初始锚点共享给他人</span>
                currentState = ImportExportState.CreatingInitialAnchor;
                <span class="hljs-comment">// 创建本地锚点</span>
                CreateAnchorLocally();
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ImportExportState.ReadyToExportInitialAnchor:
                <span class="hljs-comment">// 准备导出初始锚点</span>
                currentState = ImportExportState.UploadingInitialAnchor;
                <span class="hljs-comment">// 执行导出</span>
                Export();
                <span class="hljs-keyword">break</span>;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房主将本地锚点共享给其他人</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Export</span>()
    {
        <span class="hljs-comment">// 获取锚点，这个组件会在CreateAnchorLocally()中自动添加</span>
        WorldAnchor anchor = GetComponent&lt;WorldAnchor&gt;();

        anchorStore.Clear();
        <span class="hljs-comment">// 本地保存该锚点</span>
        <span class="hljs-keyword">if</span> (anchor != <span class="hljs-keyword">null</span> &amp;&amp; anchorStore.Save(ExportingAnchorName, anchor))
        {
            debug(<span class="hljs-string">"保存锚点完成，准备导出！ - Export()"</span>);
            <span class="hljs-comment">// 将锚点导出</span>
            sharedAnchorInterface = <span class="hljs-keyword">new</span> WorldAnchorTransferBatch();
            sharedAnchorInterface.AddWorldAnchor(ExportingAnchorName, anchor);
            WorldAnchorTransferBatch.ExportAsync(sharedAnchorInterface, WriteBuffer, ExportComplete);
        }
        <span class="hljs-keyword">else</span>
        {
            debug(<span class="hljs-string">"保存本地锚点失败！ - Export()"</span>);

            currentState = ImportExportState.InitialAnchorRequired;
        }
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房主导出锚点成功</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;param name="completionReason"&gt;</span><span class="hljs-xmlDocTag">&lt;/param&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExportComplete</span>(SerializationCompletionReason completionReason)
    {
        <span class="hljs-keyword">if</span> (completionReason == SerializationCompletionReason.Succeeded &amp;&amp; exportingAnchorBytes.Count &gt; minTrustworthySerializedAnchorDataSize)
        {
            <span class="hljs-comment">// 将锚点数据上传至当前房间中</span>
            roomManager.UploadAnchor(
                currentRoom,
                <span class="hljs-keyword">new</span> XString(ExportingAnchorName),
                exportingAnchorBytes.ToArray(),
                exportingAnchorBytes.Count);
        }
        <span class="hljs-keyword">else</span>
        {
            debug(<span class="hljs-string">"导出锚点出错！"</span> + completionReason.ToString());
            currentState = ImportExportState.InitialAnchorRequired;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteBuffer</span>(<span class="hljs-keyword">byte</span>[] data)
    {
        exportingAnchorBytes.AddRange(data);
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 房主在本地创建一个新的锚点</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateAnchorLocally</span>()
    {
        debug(<span class="hljs-string">"开始创建本地锚点"</span>);

        <span class="hljs-comment">// 添加世界锚点组件</span>
        WorldAnchor anchor = GetComponent&lt;WorldAnchor&gt;();
        <span class="hljs-keyword">if</span> (anchor == <span class="hljs-keyword">null</span>)
        {
            anchor = gameObject.AddComponent&lt;WorldAnchor&gt;();
        }

        <span class="hljs-keyword">if</span> (anchor.isLocated)
        {
            <span class="hljs-comment">// 房主自己定位好本地锚点后，准备导出给其他人</span>
            currentState = ImportExportState.ReadyToExportInitialAnchor;
        }
        <span class="hljs-keyword">else</span>
        {
            anchor.OnTrackingChanged += WorldAnchorForExport_OnTrackingChanged;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WorldAnchorForExport_OnTrackingChanged</span>(WorldAnchor self, <span class="hljs-keyword">bool</span> located)
    {
        <span class="hljs-keyword">if</span> (located)
        {
            <span class="hljs-comment">// 房主自己定位好本地锚点后，准备导出给其他人</span>
            currentState = ImportExportState.ReadyToExportInitialAnchor;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// 房主自己的锚点定位失败，则同步总体失败</span>
            currentState = ImportExportState.Failed;
        }

        self.OnTrackingChanged -= WorldAnchorForExport_OnTrackingChanged;
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 锚点数据下载完成后，开始导入锚点数据</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;param name="completionReason"&gt;</span><span class="hljs-xmlDocTag">&lt;/param&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;param name="deserializedTransferBatch"&gt;</span><span class="hljs-xmlDocTag">&lt;/param&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ImportComplete</span>(SerializationCompletionReason completionReason, WorldAnchorTransferBatch deserializedTransferBatch)
    {
        <span class="hljs-keyword">if</span> (completionReason == SerializationCompletionReason.Succeeded &amp;&amp; deserializedTransferBatch.GetAllIds().Length &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-comment">// 成功导入锚点</span>
            <span class="hljs-comment">// 获取第一个锚点名称</span>
            <span class="hljs-keyword">bool</span> hasAnchorName = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">string</span>[] anchorNames = deserializedTransferBatch.GetAllIds();
            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> an <span class="hljs-keyword">in</span> anchorNames)
            {
                <span class="hljs-keyword">if</span> (an == ExportingAnchorName)
                {
                    hasAnchorName = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (!hasAnchorName)
            {
                currentState = ImportExportState.DataReady;
                <span class="hljs-keyword">return</span>;
            }

            <span class="hljs-comment">// 保存锚点到本地</span>
            WorldAnchor anchor = deserializedTransferBatch.LockObject(ExportingAnchorName, gameObject);
            <span class="hljs-keyword">if</span> (anchor.isLocated)
            {
                <span class="hljs-keyword">if</span> (anchorStore.Save(ExportingAnchorName, anchor))
                {
                    currentState = ImportExportState.Ready;
                }
                <span class="hljs-keyword">else</span>
                {
                    currentState = ImportExportState.DataReady;
                }

            }
            <span class="hljs-keyword">else</span>
            {
                anchor.OnTrackingChanged += WorldAnchorForImport_OnTrackingChanged;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-comment">// 未成功导入，则设置为DataReady，准备在下一帧再次导入，直到导入完成</span>
            currentState = ImportExportState.DataReady;
        }
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WorldAnchorForImport_OnTrackingChanged</span>(WorldAnchor self, <span class="hljs-keyword">bool</span> located)
    {
        <span class="hljs-keyword">if</span> (located)
        {
            WorldAnchor anchor = GetComponent&lt;WorldAnchor&gt;();
            <span class="hljs-keyword">if</span> (anchorStore.Save(ExportingAnchorName, anchor))
            {
                currentState = ImportExportState.Ready;
            }
            <span class="hljs-keyword">else</span>
            {
                currentState = ImportExportState.DataReady;
            }
        }
        <span class="hljs-keyword">else</span>
        {
            currentState = ImportExportState.Failed;
        }

        self.OnTrackingChanged -= WorldAnchorForImport_OnTrackingChanged;
    }

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;summary&gt;</span></span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> 加载锚点信息</span>
    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span> <span class="hljs-xmlDocTag">&lt;/summary&gt;</span></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartAnchorProcess</span>()
    {
        debug(<span class="hljs-string">"正在获取房间锚点…… - StartAnchorProcess()"</span>);

        <span class="hljs-comment">// 检查当前房间有无锚点</span>
        <span class="hljs-keyword">int</span> anchorCount = currentRoom.GetAnchorCount();

        <span class="hljs-keyword">if</span> (anchorCount &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">bool</span> isRoomAnchorExists = <span class="hljs-keyword">false</span>;

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; anchorCount; i++)
            {
                <span class="hljs-keyword">string</span> roomAnchor = currentRoom.GetAnchorName(i).GetString();
                <span class="hljs-keyword">if</span> (roomAnchor == ExportingAnchorName)
                {
                    isRoomAnchorExists = <span class="hljs-keyword">true</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }

            <span class="hljs-keyword">if</span> (isRoomAnchorExists)
            {
                debug(<span class="hljs-string">"获取房间锚点成功！开始下载锚点"</span>);
                <span class="hljs-comment">// 获取房间锚点信息成功后，开始下载锚点数据</span>
                MakeAnchorDataRequest();
            }
        }
    }

    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span>()
    {
        <span class="hljs-keyword">if</span> (SharingStage.Instance != <span class="hljs-keyword">null</span>)
        {
            SharingStage.Instance.SharingManagerConnected -= Instance_SharingManagerConnected;
            <span class="hljs-keyword">if</span> (SharingStage.Instance.SessionsTracker != <span class="hljs-keyword">null</span>)
            {
                SharingStage.Instance.SessionsTracker.CurrentUserJoined -= SessionsTracker_CurrentUserJoined;
                SharingStage.Instance.SessionsTracker.CurrentUserLeft -= SessionsTracker_CurrentUserLeft;
            }
        }

        <span class="hljs-keyword">if</span> (roomManagerCallbacks != <span class="hljs-keyword">null</span>)
        {
            roomManagerCallbacks.AnchorsDownloadedEvent -= RoomManagerCallbacks_AnchorsDownloadedEvent;
            roomManagerCallbacks.AnchorUploadedEvent -= RoomManagerCallbacks_AnchorUploadedEvent;

            <span class="hljs-keyword">if</span> (roomManager != <span class="hljs-keyword">null</span>)
            {
                roomManager.RemoveListener(roomManagerCallbacks);
            }

            roomManagerCallbacks.Dispose();
            roomManagerCallbacks = <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-keyword">if</span> (roomManager != <span class="hljs-keyword">null</span>)
        {
            roomManager.Dispose();
            roomManager = <span class="hljs-keyword">null</span>;
        }

        <span class="hljs-keyword">base</span>.OnDestroy();
    }
}</code></pre> <p>代码有点多，但理解起来并不困难，核心就是一个维护一个<strong>简单状态机</strong>，我写好了注释，然后还画了张状态图帮助大家理解，如下： <br> <img src="https://images2.imgbox.com/1e/86/FVsUOWiT_o.jpg" alt="共享空间锚点状态图" title=""></p></li><li><p>因为<strong>Cube</strong>已经作为<strong>Controller</strong>的子集，我们将之前传递<strong>Position</strong>改为传递<strong>LocalPosition</strong>，修改<strong>Cube240.cs</strong>内容如下： <br> <strong>（代码适用：5.5.0f3版本）</strong></p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Sharing;
<span class="hljs-keyword">using</span> HoloToolkit.Unity.InputModule;
<span class="hljs-keyword">using</span> UnityEngine;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Cube240 : MonoBehaviour, IInputClickHandler {

    <span class="hljs-comment">// 是否正在移动</span>
    <span class="hljs-keyword">bool</span> isMoving = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// 消息传递类</span>
    CustomMessages240 customMessage;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()
    {
        customMessage = CustomMessages240.Instance;

        <span class="hljs-comment">// 指定收到Cube位置变化消息后的处理方法</span>
        customMessage.MessageHandlers[CustomMessages240.CustomMessageID.CubePosition] = OnCubePositionReceived;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCubePositionReceived</span>(NetworkInMessage msg)
    {
        <span class="hljs-comment">// 同步Cube位置</span>
        <span class="hljs-keyword">if</span> (!isMoving)
        {
            transform.localPosition = CustomMessages240.ReadCubePosition(msg);
        }
    }

    <span class="hljs-comment">// 单击Cube，切换是否移动</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInputClicked</span>(InputEventData eventData)
    {
        isMoving = !isMoving;
        <span class="hljs-comment">// 放置Cube后，发送Cube的位置消息给其他人</span>
        <span class="hljs-keyword">if</span> (!isMoving)
        {
            customMessage.SendCubePosition(transform.localPosition);
        }
    }

    <span class="hljs-comment">// 如果Cube为移动状态，让其放置在镜头前2米位置</span>
    <span class="hljs-keyword">void</span> Update () {
        <span class="hljs-keyword">if</span> (isMoving)
        {
            transform.position = Camera.main.transform.position + Camera.main.transform.forward * <span class="hljs-number">2</span>f;
            customMessage.SendCubePosition(transform.localPosition, MessageReliability.UnreliableSequenced);
        }
    }
}</code></pre> <p><strong>（代码适用：5.5.1f1版本）</strong></p> <pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> HoloToolkit.Sharing;
<span class="hljs-keyword">using</span> HoloToolkit.Unity.InputModule;
<span class="hljs-keyword">using</span> UnityEngine;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Cube240 : MonoBehaviour, IInputClickHandler
{

    <span class="hljs-comment">// 是否正在移动</span>
    <span class="hljs-keyword">bool</span> isMoving = <span class="hljs-keyword">false</span>;

    <span class="hljs-comment">// 消息传递类</span>
    CustomMessages240 customMessage;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()
    {
        customMessage = CustomMessages240.Instance;

        <span class="hljs-comment">// 指定收到Cube位置变化消息后的处理方法</span>
        customMessage.MessageHandlers[CustomMessages240.CustomMessageID.CubePosition] = OnCubePositionReceived;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCubePositionReceived</span>(NetworkInMessage msg)
    {
        <span class="hljs-comment">// 同步Cube位置</span>
        <span class="hljs-keyword">if</span> (!isMoving)
        {
            transform.localPosition = CustomMessages240.ReadCubePosition(msg);
        }
    }

    <span class="hljs-comment">// 单击Cube，切换是否移动</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInputClicked</span>(InputClickedEventData eventData)
    {
        isMoving = !isMoving;
        <span class="hljs-comment">// 放置Cube后，发送Cube的位置消息给其他人</span>
        <span class="hljs-keyword">if</span> (!isMoving)
        {
            customMessage.SendCubePosition(transform.localPosition);
        }
    }

    <span class="hljs-comment">// 如果Cube为移动状态，让其放置在镜头前2米位置</span>
    <span class="hljs-keyword">void</span> Update()
    {
        <span class="hljs-keyword">if</span> (isMoving)
        {
            transform.position = Camera.main.transform.position + Camera.main.transform.forward * <span class="hljs-number">2</span>f;
            customMessage.SendCubePosition(transform.localPosition, MessageReliability.UnreliableSequenced);
        }
    }
}</code></pre> <p><strong>本节完成！</strong></p></li></ol> 
<p>将代码发布到两台设备上，进行测试！注意，本例中一开始并未同步Cube位置，需要某台设备移动Cube后才能看见效果。</p> 
<p>完成后，<strong>Hierarchy</strong>结构类似： <br> <img src="https://images2.imgbox.com/29/36/n6P1ti74_o.png" alt="Hierarchy结构" title=""></p> 
<h4 id="说明-1">说明</h4> 
<p>学习官方教程的过程中，有很大几率会遇到多台设备物体虽然能够正常显示Cube，也能正常移动Cube，但各设备的Cube并没有重叠。移动Cube时，可能另一台设备的Cube是往不同的方向移动。要问为什么？因为官方代码中充满了下面这种代码：</p> 
<pre class="prettyprint"><code class=" hljs avrasm">roomManager<span class="hljs-preprocessor">.GetRoom</span>(<span class="hljs-number">0</span>)
currentRoom<span class="hljs-preprocessor">.GetAnchorName</span>(<span class="hljs-number">0</span>)
wat<span class="hljs-preprocessor">.GetAllIds</span>()[<span class="hljs-number">0</span>]</code></pre> 
<p>入坑的同学现在应该已经明白了，当出现多个房间或者多个锚点时，设备总是拿第一个。造成设备间同步的并不一定是同一个房间或者锚点。</p> 
<h3 id="小结">小结</h3> 
<p>这一节太伤元气，小结就写成问答形式了。</p> 
<ol><li><p><strong>问：</strong> 为什么真机扫描不出来空间模型？ <br> <strong>答：</strong> 请检查是否开启<strong>Spatial Perception</strong>功能（最终需要检查<strong>Package.appxmanifest</strong>文件中节点是否加入了我们需要的设备特性），下面是我测试时的配置：</p> <pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">Capabilities</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Capability</span> <span class="hljs-attribute">Name</span>=<span class="hljs-value">"internetClient"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Capability</span> <span class="hljs-attribute">Name</span>=<span class="hljs-value">"internetClientServer"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">Capability</span> <span class="hljs-attribute">Name</span>=<span class="hljs-value">"privateNetworkClientServer"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">uap2:Capability</span> <span class="hljs-attribute">Name</span>=<span class="hljs-value">"spatialPerception"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">DeviceCapability</span> <span class="hljs-attribute">Name</span>=<span class="hljs-value">"microphone"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">Capabilities</span>&gt;</span></code></pre> <p>另外，请检查是否放置了<strong>SpatialMapping.prefab</strong>，并打开<strong>Auto Start Observer</strong></p></li><li><strong>问：</strong> 出现”SpatialAnchorTransferManager denied access to WorldAnchor serialization”的提示 <br> <strong>答：</strong> 首先，请不要在Unity里测试（不管是不是Remoting），否则这个现象肯定会出现 <br> 其次，看第1点。</li><li><strong>问：</strong> 只能用多台真机进行测试吗？ <br> <strong>答：</strong> 目前是这样，主要是因为<strong>World Anchor</strong></li><li><strong>问：</strong> 设备中共享的物体，并没有重叠？ <br> <strong>答：</strong> 好吧，请注意代码逻辑，这要求设备扫描了同一空间，加入了同一房间，共享了同一锚点，锚点附加同一物体（要求真高！）。</li><li><strong>问：</strong> SpatialMapping好卡啊 <br> <strong>答：</strong> 暂时先关闭<strong>Draw Visual Meshes</strong>吧</li><li><strong>问：</strong> 设备测试的时候，设备休眠时间太短，在哪里可以设置得长一点？ <br> <strong>答：</strong> 设备打开，浏览器访问设备IP，进入：<strong>Hololens Device Portal</strong>，<strong>Home</strong>菜单下有个<strong>Sleep settings</strong>，最长设置30分钟。</li></ol> 
<blockquote> 
 <p>参考文档 <br> <a href="https://developer.microsoft.com/en-us/windows/mixed-reality/holograms_240" rel="nofollow">官方教程Holograms 240：https://developer.microsoft.com/en-us/windows/mixed-reality/holograms_240</a></p> 
</blockquote> 
<hr> 
<p>VR/AR/MR技术交流QQ群：594299228 <br> <img src="https://images2.imgbox.com/6b/df/SdERbRhj_o.png" alt="VR/AR/MR技术交流QQ群：594299228" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c071918bd8e18f9bb77937612ed2724/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">用js原生加jquery实现下拉跳转至商品详情页，上拉回到商品简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bfbcf0335c82c2e290b15f31dc14e0e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">维纳过程（Wiener Process）与高斯过程（Gaussian Process）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>