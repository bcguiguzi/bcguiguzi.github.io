<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js算法-快速排序(Quicksort) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js算法-快速排序(Quicksort)" />
<meta property="og:description" content="快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要O(nLogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序O(nLogn)通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成 快速排序可能大家都学过，在面试中也经常会遇到，哪怕你是做前端的也需要会写，这里会列举两种不同的快排代码进行分析
快速排序的3个基本步骤： 从数组中选择一个元素作为基准点排序数组，所有比基准值小的元素摆放在左边，而大于基准值的摆放在右边。每次分割结束以后基准值会插入到中间去。最后利用递归，将摆放在左边的数组和右边的数组在进行一次上述的1和2操作。 为了更深入的理解，可以看下面这张图
我们根据上面这张图，来用文字描述一下
选择左右边的元素为基准数，7将小于7的放在左边，大于7的放在右边，然后将基准数放到中间然后再重复操作从左边的数组选择一个基准点23比2大则放到基准树的右边右边的数组也是一样选择12作为基准数，15比12大所以放到了12的右边最后出来的结果就是从左到右 2 ，3，7，12，15了 以上就是快速排序基本的一个实现思想。
快速排序实现方式一 这是我最近看到的一种快排代码
var quickSort = function(arr) { if (arr.length &lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i&#43;&#43;) { if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return quickSort(left)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c191ba37e8537a69af22f958bacc416a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-08T13:23:13+08:00" />
<meta property="article:modified_time" content="2019-01-08T13:23:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js算法-快速排序(Quicksort)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <blockquote>
   快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要O(nLogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序O(nLogn)通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成 
 </blockquote> 
 <p>快速排序可能大家都学过，在面试中也经常会遇到，哪怕你是做前端的也需要会写，这里会列举两种不同的快排代码进行分析</p> 
 <h4>快速排序的3个基本步骤：</h4> 
 <ol><li>从数组中选择一个元素作为基准点</li><li>排序数组，所有比基准值小的元素摆放在左边，而大于基准值的摆放在右边。每次分割结束以后基准值会插入到中间去。</li><li>最后利用递归，将摆放在左边的数组和右边的数组在进行一次上述的1和2操作。</li></ol> 
 <p>为了更深入的理解，可以看下面这张图</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/07/5e/yD7YbOqD_o.png" alt="图片描述" title="图片描述"></span></p> 
 <p>我们根据上面这张图，来用文字描述一下</p> 
 <ol><li>选择左右边的元素为基准数，7</li><li>将小于7的放在左边，大于7的放在右边，然后将基准数放到中间</li><li>然后再重复操作从左边的数组选择一个基准点2</li><li>3比2大则放到基准树的右边</li><li>右边的数组也是一样选择12作为基准数，15比12大所以放到了12的右边</li><li>最后出来的结果就是从左到右 2 ，3，7，12，15了</li></ol> 
 <p>以上就是快速排序基本的一个实现思想。</p> 
 <h4>快速排序实现方式一</h4> 
 <p>这是我最近看到的一种快排代码</p> 
 <pre><code>var quickSort = function(arr) {
  if (arr.length &lt;= 1) {
    return arr;
  }
  var pivotIndex = Math.floor(arr.length / 2);
  var pivot = arr.splice(pivotIndex, 1)[0];
  var left = [];
  var right = [];

  for (var i = 0; i &lt; arr.length; i++) {
    if (arr[i] &lt; pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot], quickSort(right));
};</code></pre> 
 <p>以上代码的实现方式是，选择一个中间的数字为基准点，用两个数组分别去保存比基准数小的值，和比基准数大的值，最后递归左边的数组和右边的数组，用concat去做一个数组的合并。</p> 
 <p>对于这段代码的分析：<br>缺点：</p> 
 <ul><li>获取基准点使用了一个splice操作，在js中splice会对数组进行一次拷贝的操作，而它最坏的情况下复杂度为O(n)，而O(n)代表着针对数组规模的大小进行了一次循环操作。</li><li>首先我们每次执行都会使用到两个数组空间，产生空间复杂度。</li><li>concat操作会对数组进行一次拷贝，而它的复杂度也会是O(n)</li><li>对大量数据的排序来说相对会比较慢</li></ul> 
 <p>优点：</p> 
 <ul><li>代码简单明了，可读性强，易于理解</li><li>非常适合用于面试笔试题</li></ul> 
 <p>那么我们接下来用另外一种方式去实现快速排序</p> 
 <h4>快速排序的实现方式二</h4> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/bb/fb/GomTs1fy_o.png" alt="图片描述" title="图片描述"></span></p> 
 <p>从上面这张图，我们用一个指针i去做了一个分割</p> 
 <ul><li>初始化i = -1</li><li>循环数组，找到比支点小的数就将i向右移动一个位置，同时与下标i交换位置</li><li>循环结束后，最后将支点与i+1位置的元素进行交换位置</li><li>最后我们会得到一个由i指针作为分界点，分割成从下标0-i，和 i+1到最后一个元素。</li></ul> 
 <p>下面我们来看一下代码的实现，整个代码分成三部分，数组交换，拆分，qsort（主函数）三个部分</p> 
 <p>先写最简单的数组交换吧，这个大家应该都懂</p> 
 <pre><code>    function swap(A, i ,j){
        const t = A[i];
        A[i] = A[j];
        A[j] = t;
    }</code></pre> 
 <p>下面是拆分的过程，其实就是对指针进行移动，找到最后指针所指向的位置</p> 
 <pre><code>/**
 * 
 * @param {*} A  数组
 * @param {*} p  起始下标
 * @param {*} r  结束下标 + 1
 */
 function dvide(A, p, r){
    // 基准点
    const pivot = A[r-1];
    
    // i初始化是-1，也就是起始下标的前一个
    let i = p - 1;
    
    // 循环
    for(let j = p; j &lt; r-1; j++){
        // 如果比基准点小就i++，然后交换元素位置
        if(A[j] &lt;= pivot){
            i++;
            swap(A, i, j);
        }
    }
    // 最后将基准点插入到i+1的位置
    swap(A, i+1, r-1);
    // 返回最终指针i的位置
    return i+1;
 }</code></pre> 
 <p>主程序主要是通过递归去重复的调用进行拆分，一直拆分到只有一个数字。</p> 
 <pre><code>    /**
     * 
     * @param {*} A  数组
     * @param {*} p  起始下标
     * @param {*} r  结束下标 + 1
     */
    function qsort(A, p, r){
        r = r || A.length;
        if(p &lt; r - 1){
            const q = divide(A, p, r);
            qsort(A, p, q);
            qsort(A, q + 1, r);
        }
        return A;
    }</code></pre> 
 <h4>完整代码</h4> 
 <pre><code>function swap(A, i, j) {
  const t = A[i];
  A[i] = A[j];
  A[j] = t;
}

/**
 *
 * @param {*} A  数组
 * @param {*} p  起始下标
 * @param {*} r  结束下标 + 1
 */
function divide(A, p, r) {
  const x = A[r - 1];
  let i = p - 1;

  for (let j = p; j &lt; r - 1; j++) {
    if (A[j] &lt;= x) {
      i++;
      swap(A, i, j);
    }
  }

  swap(A, i + 1, r - 1);

  return i + 1;
}

/**
 * 
 * @param {*} A  数组
 * @param {*} p  起始下标
 * @param {*} r  结束下标 + 1
 */
function qsort(A, p = 0, r) {
  r = r || A.length;

  if (p &lt; r - 1) {
    const q = divide(A, p, r);
    qsort(A, p, q);
    qsort(A, q + 1, r);
  }

  return A;
}</code></pre> 
 <h4>总结</h4> 
 <p>第二段的排序算法我们减少了两个O(n)的操作，得到了一定的性能上的提升，而第一种方法数据规模足够大的情况下会相对来说比较慢一些，快速排序在面试中也常常出现，为了笔试更好写一些可能会有更多的前端会选择第一种方式，但也会有一些为难人的面试官提出一些算法中的问题。而在实际的项目中，我觉得第一种方式可以少用。</p> 
 <h4>推荐</h4> 
 <p>本人最近写的关于数据结构系列如下，欢迎大家看看点个赞哈：<br><a href="https://segmentfault.com/a/1190000017551316?share_user=1030000017131767" rel="nofollow">js数据结构-栈</a><br><a href="https://segmentfault.com/a/1190000017569816?share_user=1030000017131767" rel="nofollow">js数据结构-链表</a><br><a href="https://segmentfault.com/a/1190000017556472" rel="nofollow">js数据结构-队列</a><br><a href="https://segmentfault.com/a/1190000017761929" rel="nofollow">js数据结构-二叉树（二叉堆）</a><br><a href="https://segmentfault.com/a/1190000017798199" rel="nofollow">js数据结构-二叉树（二叉搜索树）</a></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed0e8b9703d8e46d308ae67fee23d6e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">阅读作业——关于习而学的看法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d4ee87edc1ccbfbb7e3401b4690c75b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SSD模型训练技巧</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>