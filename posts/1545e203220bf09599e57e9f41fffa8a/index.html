<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QDockWidget详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QDockWidget详解" />
<meta property="og:description" content="QDockWidget类详解 【详细描述】 QDockWidget类提供了一个特殊的窗口部件，它可以是被锁在QMainWindow窗口内部或者是作为顶级窗口悬浮在桌面上。
QDockWidget类提供了dock widget的概念，dock widget也就是我们熟悉的工具面板或者是工具窗口。Dock window是放置在
QMindow窗口周围的dock widget区域中的。
如下图所示：
Dock windows可以在几个区域中移动，或者是悬浮。该类提供的API允许程序员限制dock widgets的移动，悬浮和关闭，以及它
可以被放置的区域。
【外观】 一个QDockWidget包含一个小的工具栏和内容区域。小的工具栏用于显示窗口标题，一个浮动按钮和一个关闭按钮。取决于QDockWidget的状态，浮动按钮和关闭按钮可能或者禁止或者完全不显示。
工具栏和按钮的显示取决于你所使用的样式。
QDockWidget可以作为它子窗口部件的封装，通过setWidget()设置子窗口部件。自定义的尺寸提示，最小和最大化尺寸已经尺寸策略都必须由子窗口部件来实现。QDockWidget会遵守它们，调整它自己的限制包括框架和工具栏。我们不应该为QDockWidget设置尺寸限制，因为它们根据QDockWidget是否锁住而改变，一个锁住的QDockWidget窗口部件不包括框架和小的工具栏。
【类详解】 1、QDockWidget对象包含一些特性，例如：移动、悬浮、关闭等等，这些都是枚举类型：
2、QDockWidget可以放置的位置，也是枚举类型：
3、成员函数：void QDockWidget::setTitleBarWidget(QWidget * widget)
设置任意的widget作为dock widget的工具栏。如果widget设置为0，那么之前在dock widget上设置的任意自定义工具栏都会被清除，但是不是删除，并且会使用默认的工具栏。
如果我们为工具栏设置了widget，那么当它悬浮的时候，QDockWidget不会使用本地窗口装饰它。
下面是对实现自定义的工具栏的一些建议：
*那些不是明确由工具栏处理的鼠标事件应该通过调用QMouseEvent::ignore()函数忽略掉。这些事件就会传递给QDockWidget，由
QDockWidget按照常规的方式处理。拖动鼠标的时候就移动，双击的时候就锁住/解锁等等。
*当为QDockWidget设置了DockWidgetVerticalTitleBar时，那么工具栏窗口部件就会相应的放置在新的位置上。在resizeEvent()中
，工具栏必须检查放置的方向：
QDockWidget *dockWidget = qobject_cast&lt;QDockWidget*&gt;(parentWidget());
if (dockWidget-&gt;features() &amp; QDockWidget::DockWidgetVerticalTitleBar) {
// I need to be vertical
} else {
// I need to be horizontal
}
*工具栏widget必须包含有合法的QWidget::sizeHint()和QWidget::minimumSizeHint()。这些方法必须考虑工具栏放置的方向。
*从一个锁定的widget中移除工具栏是不可能的。然而，我们可以通过将默认构造的QWidget作为工具栏widget来达到这种效果。
4、成员函数：void QDockWidget::setWidget(QWidget * widget)
当widget添加的时候，如果dock widget是可见的，那么你就需要显示的调用show()函数。
在调用这个函数之前，你必须先添加widget的布局，否则，添加的widget就是不可见的。
【示例1】 {效果} {实现} 【示例2】 {效果} {实现} 这里的dockwidget较之前的要丰富得多，是因为自定义了类ColorSwatch，该类继承自QDockWidget：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1545e203220bf09599e57e9f41fffa8a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-06-11T00:36:32+08:00" />
<meta property="article:modified_time" content="2013-06-11T00:36:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QDockWidget详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="font-size:18px">                                                    QDockWidget类详解</span></h2> 
<h3><span style="font-size:14px">【详细描述】</span></h3> 
<span style="font-size:14px">QDockWidget类提供了一个特殊的窗口部件，它可以是被锁在QMainWindow窗口内部或者是作为顶级窗口悬浮在桌面上。<br> QDockWidget类提供了dock widget的概念，dock widget也就是我们熟悉的工具面板或者是工具窗口。Dock window是放置在<br> QMindow窗口周围的dock widget区域中的。<br> </span> 
<p><span style="font-size:14px">如下图所示：</span></p> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/cb/5d/3PizM2DK_o.png" alt=""><br> </span></p> 
<span style="font-size:14px">Dock windows可以在几个区域中移动，或者是悬浮。该类提供的API允许程序员限制dock widgets的移动，悬浮和关闭，以及它<br> 可以被放置的区域。<br> </span> 
<h3><span style="font-size:14px">【外观】</span></h3> 
<p><span style="font-size:14px">一个QDockWidget包含一个小的工具栏和内容区域。小的工具栏用于显示窗口标题，一个浮动按钮和一个关闭按钮。取决于QDockWidget的状态，浮动按钮和关闭按钮可能或者禁止或者完全不显示。</span></p> 
<p><span style="font-size:14px">工具栏和按钮的显示取决于你所使用的样式。</span></p> 
<p><span style="font-size:14px">QDockWidget可以作为它子窗口部件的封装，通过setWidget()设置子窗口部件。自定义的尺寸提示，最小和最大化尺寸已经尺寸策略都必须由子窗口部件来实现。QDockWidget会遵守它们，调整它自己的限制包括框架和工具栏。我们不应该为QDockWidget设置尺寸限制，因为它们根据QDockWidget是否锁住而改变，一个锁住的QDockWidget窗口部件不包括框架和小的工具栏。</span></p> 
<h3><span style="font-size:14px">【类详解】</span></h3> 
<p><span style="font-size:14px">1、QDockWidget对象包含一些特性，例如：移动、悬浮、关闭等等，这些都是枚举类型：</span></p> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/01/c8/p0Ykw1oL_o.png" alt=""><br> </span></p> 
<p><span style="font-size:14px">2、QDockWidget可以放置的位置，也是枚举类型：</span></p> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/21/22/LIdwHppk_o.png" alt=""><br> </span></p> 
<p><span style="font-size:14px">3、成员函数：void QDockWidget::setTitleBarWidget(QWidget * widget)</span></p> 
<p><span style="font-size:14px">设置任意的widget作为dock widget的工具栏。如果widget设置为0，那么之前在dock widget上设置的任意自定义工具栏都会被清除，但是不是删除，并且会使用默认的工具栏。<br> 如果我们为工具栏设置了widget，那么当它悬浮的时候，QDockWidget不会使用本地窗口装饰它。<br> 下面是对实现自定义的工具栏的一些建议：<br> *那些不是明确由工具栏处理的鼠标事件应该通过调用QMouseEvent::ignore()函数忽略掉。这些事件就会传递给QDockWidget，由<br> QDockWidget按照常规的方式处理。拖动鼠标的时候就移动，双击的时候就锁住/解锁等等。<br> *当为QDockWidget设置了DockWidgetVerticalTitleBar时，那么工具栏窗口部件就会相应的放置在新的位置上。在resizeEvent()中<br> ，工具栏必须检查放置的方向：<br> QDockWidget *dockWidget = qobject_cast&lt;QDockWidget*&gt;(parentWidget());<br> if (dockWidget-&gt;features() &amp; QDockWidget::DockWidgetVerticalTitleBar) {<!-- --><br>     // I need to be vertical<br> } else {<!-- --><br>     // I need to be horizontal<br> }<br> *工具栏widget必须包含有合法的QWidget::sizeHint()和QWidget::minimumSizeHint()。这些方法必须考虑工具栏放置的方向。<br> *从一个锁定的widget中移除工具栏是不可能的。然而，我们可以通过将默认构造的QWidget作为工具栏widget来达到这种效果。<br> </span></p> 
<p><span style="font-size:14px">4、成员函数：void QDockWidget::setWidget(QWidget * widget)</span></p> 
<p><span style="font-size:14px">当widget添加的时候，如果dock widget是可见的，那么你就需要显示的调用show()函数。</span></p> 
<p><span style="font-size:14px">在调用这个函数之前，你必须先添加widget的布局，否则，添加的widget就是不可见的。</span></p> 
<h3><span style="font-size:14px">【示例1】</span></h3> 
<h4><span style="font-size:14px">{效果}</span></h4> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/46/da/QuO7LDPK_o.png" alt=""><br> </span></p> 
<h4><span style="font-size:14px">{实现}</span></h4> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/44/25/XBMyVF6Y_o.png" alt=""><br> </span></p> 
<h3><span style="font-size:14px">【示例2】</span></h3> 
<h4><span style="font-size:14px">{效果}</span></h4> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/f1/11/SFOFM1GH_o.png" alt=""><br> </span></p> 
<h4><span style="font-size:14px">{实现}</span></h4> 
<p><span style="font-size:14px">这里的dockwidget较之前的要丰富得多，是因为自定义了类ColorSwatch，该类继承自QDockWidget：</span></p> 
<p></p> 
<pre><code class="language-cpp"><span style="font-family:Verdana;font-size:14px;">class ColorSwatch : public QDockWidget
{
    Q_OBJECT

    QAction *closableAction;
    QAction *movableAction;
    QAction *floatableAction;
    QAction *floatingAction;
    QAction *verticalTitleBarAction;

    QActionGroup *allowedAreasActions;
    QAction *allowLeftAction;
    QAction *allowRightAction;
    QAction *allowTopAction;
    QAction *allowBottomAction;

    QActionGroup *areaActions;
    QAction *leftAction;
    QAction *rightAction;
    QAction *topAction;
    QAction *bottomAction;

    QAction *changeSizeHintsAction;

    QMenu *tabMenu;
    QMenu *splitHMenu;
    QMenu *splitVMenu;

    QAction *windowModifiedAction;

public:
    explicit ColorSwatch(const QString &amp;colorName, QWidget *parent = 0, Qt::WindowFlags flags = 0);

    QMenu *menu;
    void setCustomSizeHint(const QSize &amp;size);

protected:
    virtual void contextMenuEvent(QContextMenuEvent *event);
    virtual void resizeEvent(QResizeEvent *e);

private:
    void allow(Qt::DockWidgetArea area, bool allow);
    void place(Qt::DockWidgetArea area, bool place);

private slots:
    void changeClosable(bool on);
    void changeMovable(bool on);
    void changeFloatable(bool on);
    void changeFloating(bool on);
    void changeVerticalTitleBar(bool on);
    void updateContextMenu();

    void allowLeft(bool a);
    void allowRight(bool a);
    void allowTop(bool a);
    void allowBottom(bool a);

    void placeLeft(bool p);
    void placeRight(bool p);
    void placeTop(bool p);
    void placeBottom(bool p);

    void splitInto(QAction *action);
    void tabInto(QAction *action);
};</span></code></pre> 
<span style="font-size:14px"><br> 我们来看看它的构造函数：</span> 
<p></p> 
<p><span style="font-size:14px">    explicit ColorSwatch(const QString &amp;colorName, QWidget *parent = 0, Qt::WindowFlags flags = 0);<br> </span></p> 
<p><span style="font-size:14px">这里我们比较关注的是第一个参数，dockwidget的颜色，这一点从前面的运行效果也可以看出来，然后比较关注的就是第三个参数，</span><span style="font-size:14px">主要设置QDockWidget的一些标志，我们可以看看它的实例化：</span></p> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/45/f6/OUv6zkED_o.png" alt=""><br> </span></p> 
<p><span style="font-size:14px">再来看看在自定义的类中定义了不少QAction，这些是上下文菜单中使用的，如下图，具体的使用方式就是根据QDockWidget的features()函数</span><span style="font-size:14px">判断某些特性是否选中：</span></p> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/4f/68/S2zK8gnb_o.png" alt=""><br> </span></p> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/35/7c/VqHszKtB_o.png" alt=""><br> </span></p> 
<p><span style="font-size:14px">最后，我们还是用了之前介绍QDockWidget类时重点提到的两个函数：</span></p> 
<h5><span style="font-size:14px">(1)setWidget()</span></h5> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/ee/5d/eJG9E07D_o.png" alt=""><br> </span></p> 
<h5><span style="font-size:14px">(2)setTitleBarWidget()</span></h5> 
<p><span style="font-size:14px"><img src="https://images2.imgbox.com/9a/e1/eCx79THD_o.png" alt=""><br> </span></p> 
<h3><span style="font-size:14px">参考：</span></h3> 
<p><span style="font-size:14px">(1)<a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qdockwidget.html" rel="nofollow">http://qt-project.org/doc/qt-5.0/qtwidgets/qdockwidget.html</a></span></p> 
<p><span style="font-size:14px">(2)<a href="http://qt-project.org/doc/qt-5.0/qtwidgets/mainwindows-dockwidgets.html" rel="nofollow">http://qt-project.org/doc/qt-5.0/qtwidgets/mainwindows-dockwidgets.html</a></span></p> 
<p><span style="font-size:14px">(3)<a href="http://qt-project.org/doc/qt-5.0/qtwidgets/mainwindows-mainwindow.html" rel="nofollow">http://qt-project.org/doc/qt-5.0/qtwidgets/mainwindows-mainwindow.html</a></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c61b83e60422d8e3d1bf21e7875acdac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux--watch命令使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4b924d19c0516214b71a5bbca1dbb188/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux 内核线程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>