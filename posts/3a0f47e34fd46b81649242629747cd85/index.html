<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的四种引用类型 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中的四种引用类型" />
<meta property="og:description" content="1、Java中四种引用类型：强软弱虚 面试：强引用和弱引用的区别？
1.1 强引用 普通变量赋值即为强引用，如 A a = new A();
强引用的回收特点：
当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收具有强引用的对象，来解决内存不足的问题。通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收。
如果想中断或者回收强引用对象可以显式地将引用赋值为null(a=null)，这样的话JVM就会在合适的时间，进行垃圾回收。
1.2. 软引用（SoftReference） “内存不够就回收，内存充足不回收”
“适合做缓存”
1、例如：SoftReference a = new SoftReference(new A());引用和对象通过SoftReference建立关联
2、当系统内存够用就保留不回收（及时发生了GC），内存不足时，会被回收
3、软引用自身不会被垃圾回收，因为GC Root还引用着，软引用自身需要配合引用队列来释放。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。
4、软引用适合缓存使用的场景，当内存不够的时候，对象是被回收的。
1.3. SoftReference实现Cache(例子) SoftReference是强引用，它保存的对象实例，除非JVM即将OutOfMemory，否则不会被GC回收。这个特性使得它特别适合设计对象Cache。对于Cache，我们希望被缓存的对象最好始终常驻内存，但是如果JVM内存吃紧，为了不发生OutOfMemoryError导致系统崩溃，必要的时候也允许JVM回收Cache的内存，待后续合适的时机再把数据重新Load到Cache中。这样可以系统设计得更具弹性。
实例：软引用在设备内存比较少的时候特别有用，比如Android系统。
一个android应用如果设计到通过网络获取图片，为了让系统更快的运行和更节省流量我们可以将已经下载下来的图片在内存中缓存起来，当第二次浏览到该图片时就可以从缓存中拿，如果没有再去加载下载的文件。
安卓里面，listView里面存一张图片和一些文字描述，这些图片要去网络上加载解析渲染后放到内存，非常消耗内存。
问题：
1、 如果每次读取图片都从硬盘读取则会严重影响性能
2、 如果一次性全部加载到内存中又可能造成内存溢出
此时使用软引用可以解决这个问题。
设计思路：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题
JSONRuslt [ { ‘image’:’http://qiniu/222.jpg’, ‘name’:’Iphone13’, ‘price’: 22323 } ] List&lt;Product&gt; list; Android里面控件：ListView展示列表 public class ImageLoader { //强引用，内存不足时候，里面的Bitmap也不会销毁 private Map&lt;String, Bitmap&gt; cacheImage = new HashMap&lt;String, Bitmap&gt;(); //弱引用：内存不足会销毁，下次找不到Bitmap就去硬盘找 private Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; cacheImage = new HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;(); public void loadImage(final String path,final Callback callback){ SoftReference&lt;Bitmap&gt; softReference = cacheImage." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3a0f47e34fd46b81649242629747cd85/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-26T23:10:17+08:00" />
<meta property="article:modified_time" content="2022-09-26T23:10:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的四种引用类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="nnRKM"><strong>1、Java中四种引用类型：强软弱虚</strong></h3> 
<p id="u12c1fd6c"><strong>面试：强引用和弱引用的区别？</strong></p> 
<h4 id="pitWt"><strong>1.1 强引用</strong></h4> 
<p id="u4e57ba4b">普通变量赋值即为强引用，如 A a = new A();</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/47/90/n2lNekyK_o.png"></p> 
<p id="u271428b7">强引用的回收特点：</p> 
<p id="ud910be0e">当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠回收具有强引用的对象，来解决内存不足的问题。通过 GC Root 的引用链，如果强引用不到该对象，该对象才能被回收。</p> 
<p id="uf6569e4d"></p> 
<p id="u93d1d96f">如果想中断或者回收强引用对象可以显式地将引用赋值为null(a=null)，这样的话JVM就会在合适的时间，进行垃圾回收。</p> 
<h4 id="sB93c"><strong>1.2. 软引用（SoftReference）</strong></h4> 
<p id="u95812680"><strong>“内存不够就回收，内存充足不回收”</strong></p> 
<p id="uaf667107"><strong>“适合做缓存”</strong></p> 
<p id="ub2a6ab0c">1、例如：SoftReference a = new SoftReference(new A());引用和对象通过SoftReference建立关联</p> 
<p id="u08ec0076">2、当系统内存够用就保留不回收（及时发生了GC），内存不足时，会被回收</p> 
<p id="u3214b63b">3、软引用自身不会被垃圾回收，因为GC Root还引用着，软引用自身需要配合引用队列来释放。</p> 
<p id="u708611fc">软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p> 
<p id="ud102d22f">4、软引用适合缓存使用的场景，当内存不够的时候，对象是被回收的。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a4/7d/uEIT0qq6_o.png"></p> 
<h4 id="DVSxJ"><strong>1.3. SoftReference实现Cache(例子)</strong></h4> 
<p id="u59f1369e">SoftReference是强引用，它保存的对象实例，除非JVM即将OutOfMemory，否则不会被GC回收。这个特性使得它特别适合设计对象Cache。对于Cache，我们希望被缓存的对象最好始终常驻内存，但是如果JVM内存吃紧，为了不发生OutOfMemoryError导致系统崩溃，必要的时候也允许JVM回收Cache的内存，待后续合适的时机再把数据重新Load到Cache中。这样可以系统设计得更具弹性。</p> 
<p id="u3410e23b"></p> 
<p id="u9aa31397">实例：软引用在设备内存比较少的时候特别有用，比如Android系统。</p> 
<p id="u57e8ebcc">一个android应用如果设计到通过网络获取图片，为了让系统更快的运行和更节省流量我们可以将已经下载下来的图片在内存中缓存起来，当第二次浏览到该图片时就可以从缓存中拿，如果没有再去加载下载的文件。</p> 
<p id="uf6a54d5c">安卓里面，listView里面存一张图片和一些文字描述，这些图片要去网络上加载解析渲染后放到内存，非常消耗内存。</p> 
<p id="ue3097e07"></p> 
<p id="u135a3677"><strong>问题：</strong></p> 
<p id="ua321f554">1、 如果每次读取图片都从硬盘读取则会严重影响性能</p> 
<p id="ua8229e6d">2、 如果一次性全部加载到内存中又可能造成内存溢出</p> 
<p id="ub3b63818"><strong>此时使用软引用可以解决这个问题。</strong></p> 
<p id="uf6deac81">设计思路：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题</p> 
<pre id="O3tpR">JSONRuslt 
[
	{
     	‘image’:’http://qiniu/222.jpg’,
		‘name’:’Iphone13’,
		‘price’: 22323
	}
]
List&lt;Product&gt; list;
Android里面控件：ListView展示列表</pre> 
<pre><code class="hljs">public class ImageLoader {
 	//强引用，内存不足时候，里面的Bitmap也不会销毁
    private Map&lt;String, Bitmap&gt; cacheImage = new HashMap&lt;String, Bitmap&gt;();
    //弱引用：内存不足会销毁，下次找不到Bitmap就去硬盘找
    private Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; cacheImage = new HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();
    
    public void loadImage(final String path,final Callback callback){
        SoftReference&lt;Bitmap&gt; softReference = cacheImage.get(path);
        // 内存的map中有这个Bitmap
        if(softReference!=null){
         	Bitmap bm = softReference.get();
            if(bm!=null){
            	callback.execute(bm);
            	return;
           	 }
        }
        // 改进：内存中没有，先去硬盘判断有没有下载
        // 如果硬盘上有：直接加载硬盘上的
        // 如果硬盘上没有：再去网络下载
        // 内存的map中没有这个Bitmap
        new Thread(new Runnable() {
            public void run() {
                HttpClient client = new DefaultHttpClient();
                try {
                    HttpResponse response = client.execute(new HttpGet(path));
                    HttpEntity entity = response.getEntity();
                    byte []bs= EntityUtils.toByteArray(entity);
                    final Bitmap bm = BitmapFactory.decodeByteArray(bs, 0,bs.length);
                    SoftReference&lt;Bitmap&gt; reference = new SoftReference&lt;Bitmap&gt;(bm);
                    cacheImage.put(path,reference);
                    callback.execute(bm);
                    entity.consumeContent();
                    // 改进：下载完之后保存到硬盘
                } catch (Exception e) {
               	 	e.printStackTrace();
            	}
            }
        }).start();
    }
    
    public static abstract class Callback{
        abstract void execute(Bitmap bm);
    }
} </code></pre> 
<p id="u4a29bb6d"></p> 
<h4 id="Fhhpd"><strong>1.4. 弱引用（WeakReference）</strong></h4> 
<p id="u1a8ee71c"><strong>“只要发生GC，一定被回收”</strong></p> 
<p id="u409bb903">1、例如：WeakReference a = new WeakReference(new A());</p> 
<p id="u45c6c01b">2、如果仅有弱引用引用该对象时，只要发生垃圾回收，就会释放该对象</p> 
<p id="u5a33cb8b">3、当一个对象仅仅被weak reference指向, 而没有任何其他strong reference指向的时候, 如果GC运行, 那么这个对象就会被回收。如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象。</p> 
<p id="u6a378906">4、ThreadLocal和WeakHashMap内部都是使用了弱引用，用来保证那些不被用到的key值，在垃圾回收的时候可以被回收掉。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fd/40/qVhx5DrD_o.png"></p> 
<h4 id="hBLQL"><strong>1.1.5.</strong><strong> </strong><strong>虚引用（</strong><strong>PhantomReference）</strong></h4> 
<p id="uee3cfe9a">1、 例如： PhantomReference a = new PhantomReference(new A(), referenceQueue);</p> 
<p id="u3e36c8d4">2、 也称为幽灵引用或者幻影引用，它是最弱的引用关系。无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference类来实现虚引用。</p> 
<p id="ue0b8dfb9">2、必须配合引用队列一起使用，当虚引用所引用的对象被回收时（a对象、b对象），由 Reference Handler 线程将虚引用对象入队，这样就可以知道哪些对象被回收，从而对它们关联的资源做进一步处理</p> 
<p id="u72abb684"></p> 
<p id="u88c9e90c"><strong>引用总结</strong></p> 
<p id="u2f1d476e">1、对于强引用，平时在编写代码时会经常使用。</p> 
<p id="ub4b89190">2、而其他三种类型的引用，使用得最多就是软引用和弱引用，这两种既有相似之处又有区别，他们都来描述<strong>非必须对象</strong>。</p> 
<p id="u64ecf038"><strong>3、被软引用关联的对象只有在内存不足时才会被回收，而被弱引用关联的对象在JVM进行垃圾回收时总会被回收。</strong></p> 
<p id="uf1172295">4、Java中4种引用的级别由高到低依次为：强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af021515bdd0ebe57d9d7da56d39efa0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">视频合并工具有哪些？不如试试这四个好用的软件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d483de09409b4392c5ee70542204e78e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SQL的关系模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>