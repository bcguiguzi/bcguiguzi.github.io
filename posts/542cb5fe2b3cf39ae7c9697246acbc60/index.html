<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【搞定Go语言】第3天1：Go语言操作MySQL - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【搞定Go语言】第3天1：Go语言操作MySQL" />
<meta property="og:description" content="MySQL是业界常用的关系型数据库，本文介绍了Go语言如何操作MySQL数据库。
Go操作MySQL 连接 Go语言中的database/sql包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用database/sql包时必须注入（至少）一个数据库驱动。
我们常用的数据库基本上都有完整的第三方实现。例如：MySQL驱动
下载依赖 go get -u github.com/go-sql-driver/mysql 使用MySQL驱动 func Open(driverName, dataSourceName string) (*DB, error) Open打开一个dirverName指定的数据库，dataSourceName指定数据源，一般至少包括数据库文件名和其它连接必要的信息。
import ( &#34;database/sql&#34; _ &#34;github.com/go-sql-driver/mysql&#34; ) func main() { // DSN:Data Source Name dsn := &#34;user:password@tcp(127.0.0.1:3306)/dbname&#34; db, err := sql.Open(&#34;mysql&#34;, dsn) if err != nil { panic(err) } defer db.Close() // 注意这行代码要写在上面err判断的下面 } 思考题： 为什么上面代码中的defer db.Close()语句不应该写在if err != nil的前面呢？
初始化连接 Open函数可能只是验证其参数格式是否正确，实际上并不创建与数据库的连接。如果要检查数据源的名称是否真实有效，应该调用Ping方法。
返回的DB对象可以安全地被多个goroutine并发使用，并且维护其自己的空闲连接池。因此，Open函数应该仅被调用一次，很少需要关闭这个DB对象。
// 定义一个全局对象db var db *sql.DB // 定义一个初始化数据库的函数 func initDB() (err error) { // DSN:Data Source Name dsn := &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/542cb5fe2b3cf39ae7c9697246acbc60/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-08T22:05:52+08:00" />
<meta property="article:modified_time" content="2020-12-08T22:05:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【搞定Go语言】第3天1：Go语言操作MySQL</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>MySQL是业界常用的关系型数据库，本文介绍了Go语言如何操作MySQL数据库。</p> 
<h2><a id="GoMySQL_2"></a>Go操作MySQL</h2> 
<h3><a id="_3"></a>连接</h3> 
<p>Go语言中的database/sql包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用database/sql包时必须注入（至少）一个数据库驱动。</p> 
<p>我们常用的数据库基本上都有完整的第三方实现。例如：MySQL驱动</p> 
<h3><a id="_8"></a>下载依赖</h3> 
<pre><code class="prism language-bash">go get -u github.com/go-sql-driver/mysql
</code></pre> 
<h3><a id="MySQL_14"></a>使用MySQL驱动</h3> 
<pre><code class="prism language-bash">func Open<span class="token punctuation">(</span>driverName, dataSourceName string<span class="token punctuation">)</span> <span class="token punctuation">(</span>*DB, error<span class="token punctuation">)</span>
</code></pre> 
<p>Open打开一个dirverName指定的数据库，dataSourceName指定数据源，一般至少包括数据库文件名和其它连接必要的信息。</p> 
<pre><code class="prism language-bash"><span class="token function">import</span> <span class="token punctuation">(</span>
	<span class="token string">"database/sql"</span>

	_ <span class="token string">"github.com/go-sql-driver/mysql"</span>
<span class="token punctuation">)</span>

func main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   // DSN:Data Source Name
	dsn :<span class="token operator">=</span> <span class="token string">"user:password@tcp(127.0.0.1:3306)/dbname"</span>
	db, err :<span class="token operator">=</span> sql.Open<span class="token punctuation">(</span><span class="token string">"mysql"</span>, dsn<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		panic<span class="token punctuation">(</span>err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	defer db.Close<span class="token punctuation">(</span><span class="token punctuation">)</span>  // 注意这行代码要写在上面err判断的下面
<span class="token punctuation">}</span>
</code></pre> 
<p>思考题： 为什么上面代码中的defer db.Close()语句不应该写在if err != nil的前面呢？</p> 
<h3><a id="_42"></a>初始化连接</h3> 
<p>Open函数可能只是验证其参数格式是否正确，实际上并不创建与数据库的连接。如果要检查数据源的名称是否真实有效，应该调用Ping方法。</p> 
<p>返回的DB对象可以安全地被多个goroutine并发使用，并且维护其自己的空闲连接池。因此，Open函数应该仅被调用一次，很少需要关闭这个DB对象。</p> 
<pre><code class="prism language-bash">// 定义一个全局对象db
var db *sql.DB

// 定义一个初始化数据库的函数
func initDB<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>err error<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	// DSN:Data Source Name
	dsn :<span class="token operator">=</span> <span class="token string">"user:password@tcp(127.0.0.1:3306)/sql_test?charset=utf8mb4&amp;parseTime=True"</span>
	// 不会校验账号密码是否正确
	// 注意！！！这里不要使用:<span class="token operator">=</span>，我们是给全局变量赋值，然后在main函数中使用全局变量db
	db, err <span class="token operator">=</span> sql.Open<span class="token punctuation">(</span><span class="token string">"mysql"</span>, dsn<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	// 尝试与数据库建立连接（校验dsn是否正确）
	err <span class="token operator">=</span> db.Ping<span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> nil
<span class="token punctuation">}</span>

func main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	err :<span class="token operator">=</span> initDB<span class="token punctuation">(</span><span class="token punctuation">)</span> // 调用输出化数据库的函数
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"init db failed,err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中sql.DB是表示连接的数据库对象（结构体实例），它保存了连接数据库相关的所有信息。它内部维护着一个具有零到多个底层连接的连接池，它可以安全地被多个goroutine同时使用。</p> 
<pre><code class="prism language-bash">SetMaxOpenConns
func <span class="token punctuation">(</span>db *DB<span class="token punctuation">)</span> SetMaxOpenConns<span class="token punctuation">(</span>n int<span class="token punctuation">)</span>
</code></pre> 
<p>SetMaxOpenConns设置与数据库建立连接的最大数目。 如果n大于0且小于最大闲置连接数，会将最大闲置连接数减小到匹配最大开启连接数的限制。 如果n&lt;=0，不会限制最大开启连接数，默认为0（无限制）。</p> 
<h3><a id="SetMaxIdleConns_87"></a>SetMaxIdleConns</h3> 
<pre><code class="prism language-bash">func <span class="token punctuation">(</span>db *DB<span class="token punctuation">)</span> SetMaxIdleConns<span class="token punctuation">(</span>n int<span class="token punctuation">)</span>
</code></pre> 
<p>SetMaxIdleConns设置连接池中的最大闲置连接数。 如果n大于最大开启连接数，则新的最大闲置连接数会减小到匹配最大开启连接数的限制。 如果n&lt;=0，不会保留闲置连接。</p> 
<h2><a id="CRUD_95"></a>CRUD</h2> 
<h3><a id="_96"></a>建库建表</h3> 
<p>我们先在MySQL中创建一个名为sql_test的数据库</p> 
<pre><code class="prism language-bash">CREATE DATABASE sql_test<span class="token punctuation">;</span>
</code></pre> 
<p>进入该数据库:</p> 
<pre><code class="prism language-bash">use sql_test<span class="token punctuation">;</span>
</code></pre> 
<p>执行以下命令创建一张用于测试的数据表：</p> 
<pre><code class="prism language-bash">CREATE TABLE <span class="token variable"><span class="token variable">`</span>user<span class="token variable">`</span></span> <span class="token punctuation">(</span>
    <span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span> BIGINT<span class="token punctuation">(</span>20<span class="token punctuation">)</span> NOT NULL AUTO_INCREMENT,
    <span class="token variable"><span class="token variable">`</span>name<span class="token variable">`</span></span> VARCHAR<span class="token punctuation">(</span>20<span class="token punctuation">)</span> DEFAULT <span class="token string">''</span>,
    <span class="token variable"><span class="token variable">`</span>age<span class="token variable">`</span></span> INT<span class="token punctuation">(</span>11<span class="token punctuation">)</span> DEFAULT <span class="token string">'0'</span>,
    PRIMARY KEY<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span><span class="token function">id</span><span class="token variable">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>ENGINE<span class="token operator">=</span>InnoDB AUTO_INCREMENT<span class="token operator">=</span>1 DEFAULT CHARSET<span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_120"></a>查询</h3> 
<p>为了方便查询，我们事先定义好一个结构体来存储user表的数据。</p> 
<pre><code class="prism language-bash"><span class="token function">type</span> user struct <span class="token punctuation">{<!-- --></span>
	<span class="token function">id</span>   int
	age  int
	name string
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_131"></a>单行查询</h3> 
<p>单行查询db.QueryRow()执行一次查询，并期望返回最多一行结果（即Row）。QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误。（如：未找到结果）</p> 
<pre><code class="prism language-bash">func <span class="token punctuation">(</span>db *DB<span class="token punctuation">)</span> QueryRow<span class="token punctuation">(</span>query string, args <span class="token punctuation">..</span>.interface<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> *Row
</code></pre> 
<p>具体示例代码：</p> 
<pre><code class="prism language-bash">// 查询单条数据示例
func queryRowDemo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	sqlStr :<span class="token operator">=</span> <span class="token string">"select id, name, age from user where id=?"</span>
	var u user
	// 非常重要：确保QueryRow之后调用Scan方法，否则持有的数据库链接不会被释放
	err :<span class="token operator">=</span> db.QueryRow<span class="token punctuation">(</span>sqlStr, 1<span class="token punctuation">)</span>.Scan<span class="token punctuation">(</span><span class="token operator">&amp;</span>u.id, <span class="token operator">&amp;</span>u.name, <span class="token operator">&amp;</span>u.age<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"scan failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	fmt.Printf<span class="token punctuation">(</span><span class="token string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_155"></a>多行查询</h3> 
<p>多行查询db.Query()执行一次查询，返回多行结果（即Rows），一般用于执行select命令。参数args表示query中的占位参数。</p> 
<pre><code class="prism language-bash">func <span class="token punctuation">(</span>db *DB<span class="token punctuation">)</span> Query<span class="token punctuation">(</span>query string, args <span class="token punctuation">..</span>.interface<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>*Rows, error<span class="token punctuation">)</span>
</code></pre> 
<p>具体示例代码：</p> 
<pre><code class="prism language-bash">// 查询多条数据示例
func queryMultiRowDemo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	sqlStr :<span class="token operator">=</span> <span class="token string">"select id, name, age from user where id &gt; ?"</span>
	rows, err :<span class="token operator">=</span> db.Query<span class="token punctuation">(</span>sqlStr, 0<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"query failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	// 非常重要：关闭rows释放持有的数据库链接
	defer rows.Close<span class="token punctuation">(</span><span class="token punctuation">)</span>

	// 循环读取结果集中的数据
	<span class="token keyword">for</span> rows.Next<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		var u user
		err :<span class="token operator">=</span> rows.Scan<span class="token punctuation">(</span><span class="token operator">&amp;</span>u.id, <span class="token operator">&amp;</span>u.name, <span class="token operator">&amp;</span>u.age<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
			fmt.Printf<span class="token punctuation">(</span><span class="token string">"scan failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_189"></a>插入数据</h3> 
<p>插入、更新和删除操作都使用Exec方法。</p> 
<pre><code class="prism language-bash">func <span class="token punctuation">(</span>db *DB<span class="token punctuation">)</span> Exec<span class="token punctuation">(</span>query string, args <span class="token punctuation">..</span>.interface<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Result, error<span class="token punctuation">)</span>
</code></pre> 
<p>Exec执行一次命令（包括查询、删除、更新、插入等），返回的Result是对已执行的SQL命令的总结。参数args表示query中的占位参数。</p> 
<p>具体插入数据示例代码如下：</p> 
<pre><code class="prism language-bash">// 插入数据
func insertRowDemo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	sqlStr :<span class="token operator">=</span> <span class="token string">"insert into user(name, age) values (?,?)"</span>
	ret, err :<span class="token operator">=</span> db.Exec<span class="token punctuation">(</span>sqlStr, <span class="token string">"王五"</span>, 38<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"insert failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	theID, err :<span class="token operator">=</span> ret.LastInsertId<span class="token punctuation">(</span><span class="token punctuation">)</span> // 新插入数据的id
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"get lastinsert ID failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	fmt.Printf<span class="token punctuation">(</span><span class="token string">"insert success, the id is %d.\n"</span>, theID<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_218"></a>更新数据</h3> 
<p>具体更新数据示例代码如下：</p> 
<pre><code class="prism language-bash">// 更新数据
func updateRowDemo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	sqlStr :<span class="token operator">=</span> <span class="token string">"update user set age=? where id = ?"</span>
	ret, err :<span class="token operator">=</span> db.Exec<span class="token punctuation">(</span>sqlStr, 39, 3<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"update failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	n, err :<span class="token operator">=</span> ret.RowsAffected<span class="token punctuation">(</span><span class="token punctuation">)</span> // 操作影响的行数
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"get RowsAffected failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	fmt.Printf<span class="token punctuation">(</span><span class="token string">"update success, affected rows:%d\n"</span>, n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_239"></a>删除数据</h3> 
<p>具体删除数据的示例代码如下：</p> 
<pre><code class="prism language-bash">// 删除数据
func deleteRowDemo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	sqlStr :<span class="token operator">=</span> <span class="token string">"delete from user where id = ?"</span>
	ret, err :<span class="token operator">=</span> db.Exec<span class="token punctuation">(</span>sqlStr, 3<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"delete failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	n, err :<span class="token operator">=</span> ret.RowsAffected<span class="token punctuation">(</span><span class="token punctuation">)</span> // 操作影响的行数
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"get RowsAffected failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	fmt.Printf<span class="token punctuation">(</span><span class="token string">"delete success, affected rows:%d\n"</span>, n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="MySQL_260"></a>MySQL预处理</h2> 
<h3><a id="_261"></a>什么是预处理？</h3> 
<p>普通SQL语句执行过程：</p> 
<pre><code class="prism language-bash">客户端对SQL语句进行占位符替换得到完整的SQL语句。
客户端发送完整SQL语句到MySQL服务端
MySQL服务端执行完整的SQL语句并将结果返回给客户端。
</code></pre> 
<p>预处理执行过程：</p> 
<pre><code class="prism language-bash">把SQL语句分成两部分，命令部分与数据部分。
先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。
然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。
MySQL服务端执行完整的SQL语句并将结果返回给客户端。
</code></pre> 
<h3><a id="_279"></a>为什么要预处理？</h3> 
<p>优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。<br> 避免SQL注入问题。<br> Go实现MySQL预处理<br> database/sql中使用下面的Prepare方法来实现预处理操作。</p> 
<pre><code class="prism language-bash">func <span class="token punctuation">(</span>db *DB<span class="token punctuation">)</span> Prepare<span class="token punctuation">(</span>query string<span class="token punctuation">)</span> <span class="token punctuation">(</span>*Stmt, error<span class="token punctuation">)</span>
</code></pre> 
<p>Prepare方法会先将sql语句发送给MySQL服务端，返回一个准备好的状态用于之后的查询和命令。返回值可以同时执行多个查询和命令。</p> 
<p>查询操作的预处理示例代码如下：</p> 
<pre><code class="prism language-bash">// 预处理查询示例
func prepareQueryDemo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	sqlStr :<span class="token operator">=</span> <span class="token string">"select id, name, age from user where id &gt; ?"</span>
	stmt, err :<span class="token operator">=</span> db.Prepare<span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"prepare failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	defer stmt.Close<span class="token punctuation">(</span><span class="token punctuation">)</span>
	rows, err :<span class="token operator">=</span> stmt.Query<span class="token punctuation">(</span>0<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"query failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	defer rows.Close<span class="token punctuation">(</span><span class="token punctuation">)</span>
	// 循环读取结果集中的数据
	<span class="token keyword">for</span> rows.Next<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		var u user
		err :<span class="token operator">=</span> rows.Scan<span class="token punctuation">(</span><span class="token operator">&amp;</span>u.id, <span class="token operator">&amp;</span>u.name, <span class="token operator">&amp;</span>u.age<span class="token punctuation">)</span>
		<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
			fmt.Printf<span class="token punctuation">(</span><span class="token string">"scan failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"id:%d name:%s age:%d\n"</span>, u.id, u.name, u.age<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>插入、更新和删除操作的预处理十分类似，这里以插入操作的预处理为例：</p> 
<pre><code class="prism language-bash">// 预处理插入示例
func prepareInsertDemo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	sqlStr :<span class="token operator">=</span> <span class="token string">"insert into user(name, age) values (?,?)"</span>
	stmt, err :<span class="token operator">=</span> db.Prepare<span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"prepare failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	defer stmt.Close<span class="token punctuation">(</span><span class="token punctuation">)</span>
	_, err <span class="token operator">=</span> stmt.Exec<span class="token punctuation">(</span><span class="token string">"小王子"</span>, 18<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"insert failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	_, err <span class="token operator">=</span> stmt.Exec<span class="token punctuation">(</span><span class="token string">"沙河娜扎"</span>, 18<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"insert failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	fmt.Println<span class="token punctuation">(</span><span class="token string">"insert success."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="SQL_348"></a>SQL注入问题</h2> 
<p>我们任何时候都不应该自己拼接SQL语句！</p> 
<p>这里我们演示一个自行拼接SQL语句的示例，编写一个根据name字段查询user表的函数如下：</p> 
<pre><code class="prism language-bash">// sql注入示例
func sqlInjectDemo<span class="token punctuation">(</span>name string<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	sqlStr :<span class="token operator">=</span> fmt.Sprintf<span class="token punctuation">(</span><span class="token string">"select id, name, age from user where name='%s'"</span>, name<span class="token punctuation">)</span>
	fmt.Printf<span class="token punctuation">(</span><span class="token string">"SQL:%s\n"</span>, sqlStr<span class="token punctuation">)</span>
	var u user
	err :<span class="token operator">=</span> db.QueryRow<span class="token punctuation">(</span>sqlStr<span class="token punctuation">)</span>.Scan<span class="token punctuation">(</span><span class="token operator">&amp;</span>u.id, <span class="token operator">&amp;</span>u.name, <span class="token operator">&amp;</span>u.age<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"exec failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	fmt.Printf<span class="token punctuation">(</span><span class="token string">"user:%#v\n"</span>, u<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此时以下输入字符串都可以引发SQL注入问题：</p> 
<pre><code class="prism language-bash">sqlInjectDemo<span class="token punctuation">(</span><span class="token string">"xxx' or 1=1#"</span><span class="token punctuation">)</span>
sqlInjectDemo<span class="token punctuation">(</span><span class="token string">"xxx' union select * from user #"</span><span class="token punctuation">)</span>
sqlInjectDemo<span class="token punctuation">(</span><span class="token string">"xxx' and (select count(*) from user) &lt;10 #"</span><span class="token punctuation">)</span>
</code></pre> 
<p>补充：不同的数据库中，SQL语句使用的占位符语法不尽相同。</p> 
<pre><code class="prism language-bash">数据库	占位符语法
MySQL	?
PostgreSQL	<span class="token variable">$1</span>, <span class="token variable">$2</span>等
SQLite	? 和<span class="token variable">$1</span>
Oracle	:name
Go实现MySQL事务
</code></pre> 
<h2><a id="_387"></a>什么是事务？</h2> 
<p>事务：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)，同时这个完整的业务需要执行多次的DML(insert、update、delete)语句共同联合完成。A转账给B，这里面就需要执行两次update操作。</p> 
<p>在MySQL中只有使用了Innodb数据库引擎的数据库或表才支持事务。事务处理可以用来维护数据库的完整性，<code>保证成批的SQL语句要么全部执行，要么全部不执行。</code></p> 
<h3><a id="ACID_392"></a>事务的ACID</h3> 
<p>通常事务必须满足4个条件（ACID）：</p> 
<pre><code class="prism language-bash">原子性（Atomicity，或称不可分割性）、
一致性（Consistency）、
隔离性（Isolation，又称独立性）、
持久性（Durability）。
</code></pre> 
<h3><a id="_402"></a>条件解释</h3> 
<p>原子性：<br> 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br> 一致性：<br> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。<br> 隔离性：<br> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br> 持久性：<br> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p> 
<h3><a id="_412"></a>事务相关方法</h3> 
<p>Go语言中使用以下三个方法实现MySQL中的事务操作。<br> <strong>开始事务：</strong></p> 
<pre><code class="prism language-bash">func <span class="token punctuation">(</span>db *DB<span class="token punctuation">)</span> Begin<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>*Tx, error<span class="token punctuation">)</span>
提交事务

func <span class="token punctuation">(</span>tx *Tx<span class="token punctuation">)</span> Commit<span class="token punctuation">(</span><span class="token punctuation">)</span> error
回滚事务

func <span class="token punctuation">(</span>tx *Tx<span class="token punctuation">)</span> Rollback<span class="token punctuation">(</span><span class="token punctuation">)</span> error
</code></pre> 
<h3><a id="_426"></a>事务示例</h3> 
<p>下面的代码演示了一个简单的事务操作，该事物操作能够确保两次更新操作要么同时成功要么同时失败，不会存在中间状态。</p> 
<pre><code class="prism language-bash">// 事务操作示例
func transactionDemo<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	tx, err :<span class="token operator">=</span> db.Begin<span class="token punctuation">(</span><span class="token punctuation">)</span> // 开启事务
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> tx <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
			tx.Rollback<span class="token punctuation">(</span><span class="token punctuation">)</span> // 回滚
		<span class="token punctuation">}</span>
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"begin trans failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	sqlStr1 :<span class="token operator">=</span> <span class="token string">"Update user set age=30 where id=?"</span>
	ret1, err :<span class="token operator">=</span> tx.Exec<span class="token punctuation">(</span>sqlStr1, 2<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		tx.Rollback<span class="token punctuation">(</span><span class="token punctuation">)</span> // 回滚
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"exec sql1 failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	affRow1, err :<span class="token operator">=</span> ret1.RowsAffected<span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		tx.Rollback<span class="token punctuation">(</span><span class="token punctuation">)</span> // 回滚
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"exec ret1.RowsAffected() failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	sqlStr2 :<span class="token operator">=</span> <span class="token string">"Update user set age=40 where id=?"</span>
	ret2, err :<span class="token operator">=</span> tx.Exec<span class="token punctuation">(</span>sqlStr2, 3<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		tx.Rollback<span class="token punctuation">(</span><span class="token punctuation">)</span> // 回滚
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"exec sql2 failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	affRow2, err :<span class="token operator">=</span> ret2.RowsAffected<span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> nil <span class="token punctuation">{<!-- --></span>
		tx.Rollback<span class="token punctuation">(</span><span class="token punctuation">)</span> // 回滚
		fmt.Printf<span class="token punctuation">(</span><span class="token string">"exec ret1.RowsAffected() failed, err:%v\n"</span>, err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	fmt.Println<span class="token punctuation">(</span>affRow1, affRow2<span class="token punctuation">)</span>
	<span class="token keyword">if</span> affRow1 <span class="token operator">==</span> 1 <span class="token operator">&amp;&amp;</span> affRow2 <span class="token operator">==</span> 1 <span class="token punctuation">{<!-- --></span>
		fmt.Println<span class="token punctuation">(</span><span class="token string">"事务提交啦..."</span><span class="token punctuation">)</span>
		tx.Commit<span class="token punctuation">(</span><span class="token punctuation">)</span> // 提交事务
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		tx.Rollback<span class="token punctuation">(</span><span class="token punctuation">)</span>
		fmt.Println<span class="token punctuation">(</span><span class="token string">"事务回滚啦..."</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	fmt.Println<span class="token punctuation">(</span><span class="token string">"exec trans success!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fbd7c3f2c9921b36ee395c2992070230/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树状数组维护LIS--------------------思维(树状数组)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bebdc9d97f7200442235d3d9e317217/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">简述python程序的基本构成_Python 程序基本结构主要包括哪些内容？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>