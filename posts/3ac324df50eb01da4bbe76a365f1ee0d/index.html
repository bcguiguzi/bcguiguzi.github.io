<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线程基础、线程之间的共享和协作（初篇） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线程基础、线程之间的共享和协作（初篇）" />
<meta property="og:description" content="什么是进程和线程？
进程是操作系统进行资源分配的最小单位。资源包括cpu，内存空间，磁盘io等。同一进程里的多个线程共享该进程的全部系统资源。而进程与进程之间是相互独立的。
线程是cpu调度的最小单位，必须依托于进程而存在。
CPU 核心数和线程数的关系？ 核心数、线程他们是1：1的关系，当intel引入超线程技术后 核心数、线程他们是1：2的关系。 什么是CPU 时间片轮转机制？ 我们平时在开发的时候，感觉并没有受 cpu 核心数的限制，想启动线程就启 动线程，哪怕是在单核 CPU 上因为操作系统提供了一种 CPU 时间片轮转机制。时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称 RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。如果在时间片结束时进程还在运行,则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则 CPU 当即进行切换。而CPU的调度切换就是CPU上下文切换。 什么并行和并发？ 并行是指同时能够执行不同的任务。并发是指能够交替的执行任务。 两者区别 : 一个是交替执行 , 一个是同时执行。其中 并发统计通常和时间单位挂钩的。某一时间段并发量是多少。 线程的优点及缺点？
线程的创建会进行资源分配：栈空间（1M）&#43; 句柄（文件描述符）等
优点：
1.充分利用cpu资源。
2.加快用户响应时间。
3.代码的异步话，模块化，简单化。 缺点：
1.多个线程共享该进程的所有资源，共享资源的安全性。
2.为了保证共享资源的安全性，肯定会加锁，容易产生线程与线程之间死锁。
3.线程数量增加会加重系统cpu资源的消耗。
线程创建的方式？
线程的创建方式就只有2种，这个是官方Thread类注释声明了的。可以去Thread源码看下。
1.继承Thread类
2.实现Runnable接口
Thread和Runnable的区别？
Thread是对线程的抽象，而Runnable是对任务调度的抽象。Thread可以接收任意Runnable的实例执行。
线程终止的方式？
1.调用线程的stop方法，stop方法不建议使用，它不能保证线程资源的释放。除非把线程的资源都释放了才调用stop方法。
2.调用interrupt方法，它不能保证线程马上终止，它只是给线程一个中断的通知，修改线程的中断标志位。interrupt方法通常和isInterrupted()和静态方法Thread.interrupted()联合调用。
代码示例：
线程通过检测自身的中断标识位是否设置为true而响应中断。通常通过调用isInterrupted()和静态方法Thread.interrupted()方法来判断是否被中断。isInterrupted()与interrupted()区别在于返回值不一样，isInterrupted()会返回true而interrupted()会把标志位修改成false来返回。通常情况下都选择使用isInterrupted方法。
线程在堵塞中（线程调用wait(),sleep(),join()）也会执行interrupt和isInterrupted/Thread.interrupted()方法，但该线程并不会中断。线程处于堵塞状态，它对检测当前中断标志位是否设置为true，会在阻塞方法调用处抛出中断异常并把中断标识为马上设置成false。如果要把堵塞的线程中断必须在catch代码块里再次调用interrupt()方法。相当于要调用两次interrupt()方法；
示例：
线程的run方法和start()方法的区别？
Thread类是对java线程的抽象，new Thread()实例只是把线程挂载起来，并没有真正的执行。当线程调用start()方式时，线程才是真正的启动起来。start()方法让线程处于就绪状态等待cpu分配资源，分配到cpu资源时才会调用run方法。start()方法不能重复调用，否则抛出异常，而run()可反复调用它相当于类里的一个成员方法。
其他线程方法？
join（）：可以将两个交替执行的线程合并为顺序执行。 比如在线程 B 中调用了线程 A 的 Join()方法，直到线程 A 执行完毕后，才会继续执行线程 B。
yield()：使当前线程让出 CPU 占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行 yield( )的线程不一定就会持有锁，我们完全可以在释放锁后再调用 yield 方法。所有执行 yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3ac324df50eb01da4bbe76a365f1ee0d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-30T18:44:14+08:00" />
<meta property="article:modified_time" content="2023-06-30T18:44:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线程基础、线程之间的共享和协作（初篇）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#0d0016;"><strong>什么是进程和线程？</strong></span></p> 
<p><strong>进程</strong>是操作系统进行资源分配的最小单位。资源包括cpu，内存空间，磁盘io等。同一进程里的多个线程共享该进程的全部系统资源。而进程与进程之间是相互独立的。</p> 
<p><strong>线程</strong>是cpu调度的最小单位，必须依托于进程而存在。</p> 
<div> 
 <span style="color:#0d0016;"><strong>CPU 核心数和线程数的关系？</strong></span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#494949;">核心数、线程他们是1：1的关系，当intel引入超线程技术后 核心数、线程他们是1：2的关系。</span> 
 </div> 
 <div> 
  <img alt="" height="605" src="https://images2.imgbox.com/25/d6/WjOTYmWb_o.png" width="834"> 
 </div> 
 <div></div> 
 <div> 
  <strong>什么是CPU 时间片轮转机制？</strong> 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <span style="color:#494949;">我们平时在开发的时候，感觉并没有受 cpu 核心数的限制，想启动线程就启 动线程，哪怕是在单核 CPU 上因为操作系统提供了一种 CPU 时间片轮转机制。时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称 RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。如果在时间片结束时进程还在运行,则 CPU 将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则 CPU 当即进行切换。而CPU的调度切换就是CPU上下文切换。</span> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#494949;">什么并行和并发？</span></strong> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#494949;">并行是指同时能够执行不同的任务。并发是指能够交替的执行任务。</span></strong> 
   <span style="color:#000000;">两者区别</span> 
   <span style="color:#000000;">:</span> 
   <span style="color:#000000;">一个是交替执行</span> 
   <span style="color:#000000;">,</span> 
   <span style="color:#000000;">一个是同时执行。其中</span> 
   <span style="color:#494949;">并发统计通常和时间单位挂钩的。某一时间段并发量是多少。 </span> 
  </div> 
 </div> 
 <p></p> 
 <p><strong>线程的优点及缺点？</strong></p> 
 <p>线程的创建会进行资源分配：栈空间（1M）+ 句柄（文件描述符）等</p> 
 <p><strong>优点：</strong></p> 
 <p><span style="color:#494949;">1.充分利用cpu资源。</span></p> 
 <p><span style="color:#494949;">2.加快用户响应时间。</span></p> 
 <p><span style="color:#494949;">3.代码的异步话，模块化，简单化。 </span></p> 
 <p><strong><span style="color:#494949;">缺点：</span></strong></p> 
 <p><span style="color:#494949;">1.多个线程共享该进程的所有资源，共享资源的安全性。</span></p> 
 <p><span style="color:#494949;">2.为了保证共享资源的安全性，肯定会加锁，容易产生线程与线程之间死锁。</span></p> 
 <p><span style="color:#494949;">3.线程数量增加会加重系统cpu资源的消耗。</span></p> 
 <p><strong>线程创建的方式？</strong></p> 
 <p>线程的创建方式就只有2种，这个是官方Thread类注释声明了的。可以去Thread源码看下。</p> 
 <p>1.继承Thread类</p> 
 <p>2.实现Runnable接口</p> 
 <p><strong>Thread和Runnable的区别？</strong></p> 
 <p>Thread是对线程的抽象，而Runnable是对任务调度的抽象。Thread可以接收任意Runnable的实例执行。</p> 
 <p><strong>线程终止的方式？</strong></p> 
 <p>1.调用线程的stop方法，stop方法不建议使用，它不能保证线程资源的释放。除非把线程的资源都释放了才调用stop方法。</p> 
 <p>2.调用interrupt方法，它不能保证线程马上终止，它只是给线程一个中断的通知，修改线程的中断标志位。interrupt方法通常和isInterrupted()和静态方法Thread.interrupted()联合调用。</p> 
 <p><strong>代码示例：</strong></p> 
 <p><img alt="" height="449" src="https://images2.imgbox.com/29/6e/BFTK2lgT_o.png" width="1011"></p> 
 <p> 线程通过检测自身的中断标识位是否设置为true而响应中断。通常通过调用isInterrupted()和静态方法Thread.interrupted()方法来判断是否被中断。isInterrupted()与interrupted()区别在于返回值不一样，isInterrupted()会返回true而interrupted()会把标志位修改成false来返回。通常情况下都选择使用isInterrupted方法。</p> 
 <p>线程在堵塞中（线程调用wait(),sleep(),join()）也会执行interrupt和isInterrupted/Thread.interrupted()方法，但该线程并不会中断。线程处于堵塞状态，它对检测当前中断标志位是否设置为true，会在阻塞方法调用处抛出中断异常并把中断标识为马上设置成false。如果要把堵塞的线程中断必须在catch代码块里再次调用interrupt()方法。相当于要调用两次interrupt()方法；</p> 
 <p>示例：<img alt="" height="591" src="https://images2.imgbox.com/6a/6a/58fz6yAW_o.png" width="671"></p> 
 <p><strong> 线程的run方法和start()方法的区别？</strong></p> 
 <p>Thread类是对java线程的抽象，new Thread()实例只是把线程挂载起来，并没有真正的执行。当线程调用start()方式时，线程才是真正的启动起来。start()方法让线程处于就绪状态等待cpu分配资源，分配到cpu资源时才会调用run方法。start()方法不能重复调用，否则抛出异常，而run()可反复调用它相当于类里的一个成员方法。</p> 
 <p><strong>其他线程方法？</strong></p> 
 <p><strong>join（）：</strong><span style="color:#494949;">可以将两个交替执行的线程合并为顺序执行。 比如在线程 B 中调用了线程 A 的 Join()方法，直到线程 A 执行完毕后，才会继续执行线程 B。</span></p> 
 <p><strong><span style="color:#494949;">yield()</span>：</strong><span style="color:#000000;">使当前线程让出 CPU </span><span style="color:#000000;">占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行 yield( )</span><span style="color:#000000;">的线程不一定就会持有锁，我们完全可以在释放锁后再调用 yield </span><span style="color:#000000;">方法。所有执行 yield()</span><span style="color:#000000;">的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。</span></p> 
 <p><strong>线程运行结构图 </strong></p> 
 <p><img alt="" height="348" src="https://images2.imgbox.com/4f/fb/ekwyr2kd_o.png" width="691"></p> 
 <p></p> 
 <p></p> 
 <p></p> 
 <p></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b608854fc3f92c906f75687cd4335f80/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows下kafka安装</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/06de50855514029e4e9f2698edba9923/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;引用计数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>