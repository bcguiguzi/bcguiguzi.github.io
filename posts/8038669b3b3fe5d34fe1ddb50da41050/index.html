<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot2.0&#43;websocket集成【群发消息&#43;单对单】(二) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot2.0&#43;websocket集成【群发消息&#43;单对单】(二)" />
<meta property="og:description" content="https://blog.csdn.net/qq_21019419/article/details/82804921
版权声明：本文为博主原创文章，遵循 CC 4.0 by-sa 版权协议，转载请附上原文出处链接和本声明。
本文链接：https://blog.csdn.net/qq_21019419/article/details/82804921
第二篇，主要是使用socketjs，stomp模式的websocket简单实现。
第一篇的地址：springboot2.0&#43;websocket集成【群发消息&#43;单对单】
参考：
http://tech.lede.com/2017/03/08/qa/websocket&#43;spring/
https://blog.csdn.net/mr_zhuqiang/article/details/46618197
继续上次的项目。如果对下面的代码有部分看不明白的，请到上一篇看看流程，或者到文末贴出项目的git地址。
1. 先从配置开始，WebStompConfig
代码中的注释基本能够解释清楚每行的意思了，这里就不再细说
完整代码
package com.example.websocketdemo1.stomp;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;
/**
* EnableWebSocketMessageBroker 注解表明： 这个配置类不仅配置了 WebSocket，还配置了基于代理的 STOMP 消息；
* registerStompEndpoints() 方法：添加一个服务端点，来接收客户端的连接。将 “/chat” 路径注册为 STOMP 端点。这个路径与之前发送和接收消息的目的路径有所不同， 这是一个端点，客户端在订阅或发布消息到目的地址前，要连接该端点，即用户发送请求 ：url=’/127.0.0.1:8080/chat’ 与 STOMP server 进行连接，之后再转发到订阅url；
* configureMessageBroker() 方法：配置了一个 简单的消息代理，通俗一点讲就是设置消息连接请求的各种规范信息。
*
* @author linyun
* @date 2018/9/13 下午5:15
*/
@Configuration
@EnableWebSocketMessageBroker" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8038669b3b3fe5d34fe1ddb50da41050/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-16T16:53:00+08:00" />
<meta property="article:modified_time" content="2019-08-16T16:53:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot2.0&#43;websocket集成【群发消息&#43;单对单】(二)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>https://blog.csdn.net/qq_21019419/article/details/82804921</p> 
 <p> </p> 
 <p>版权声明：本文为博主原创文章，遵循 CC 4.0 by-sa 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：https://blog.csdn.net/qq_21019419/article/details/82804921<br><br>第二篇，主要是使用socketjs，stomp模式的websocket简单实现。<br>第一篇的地址：springboot2.0+websocket集成【群发消息+单对单】<br>参考：<br>http://tech.lede.com/2017/03/08/qa/websocket+spring/<br>https://blog.csdn.net/mr_zhuqiang/article/details/46618197<br><br>继续上次的项目。如果对下面的代码有部分看不明白的，请到上一篇看看流程，或者到文末贴出项目的git地址。<br>1. 先从配置开始，WebStompConfig<br><br>代码中的注释基本能够解释清楚每行的意思了，这里就不再细说<br>完整代码<br><br>package com.example.websocketdemo1.stomp;<br><br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.messaging.simp.config.ChannelRegistration;<br>import org.springframework.messaging.simp.config.MessageBrokerRegistry;<br>import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;<br>import org.springframework.web.socket.config.annotation.StompEndpointRegistry;<br>import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;<br><br>/**<br> * EnableWebSocketMessageBroker 注解表明： 这个配置类不仅配置了 WebSocket，还配置了基于代理的 STOMP 消息；<br> * registerStompEndpoints() 方法：添加一个服务端点，来接收客户端的连接。将 “/chat” 路径注册为 STOMP 端点。这个路径与之前发送和接收消息的目的路径有所不同， 这是一个端点，客户端在订阅或发布消息到目的地址前，要连接该端点，即用户发送请求 ：url=’/127.0.0.1:8080/chat’ 与 STOMP server 进行连接，之后再转发到订阅url；<br> * configureMessageBroker() 方法：配置了一个 简单的消息代理，通俗一点讲就是设置消息连接请求的各种规范信息。<br> *<br> * @author linyun<br> * @date 2018/9/13 下午5:15<br> */<br>@Configuration<br>@EnableWebSocketMessageBroker<br>public class WebStompConfig implements WebSocketMessageBrokerConfigurer {<!-- --><br><br>    @Autowired<br>    private WebSocketHandleInterceptor interceptor;<br><br>    @Override<br>    public void registerStompEndpoints(StompEndpointRegistry registry) {<!-- --><br>        //添加一个/chat端点，客户端就可以通过这个端点来进行连接；withSockJS作用是添加SockJS支持<br>        registry.addEndpoint("/chat").setAllowedOrigins("*").withSockJS();<br>    }<br><br>    @Override<br>    public void configureMessageBroker(MessageBrokerRegistry registry) {<!-- --><br>        //定义了两个客户端订阅地址的前缀信息，也就是客户端接收服务端发送消息的前缀信息<br>        registry.enableSimpleBroker("/message", "/notice");<br>        //定义了服务端接收地址的前缀，也即客户端给服务端发消息的地址前缀<br>        registry.setApplicationDestinationPrefixes("/app");<br>    }<br><br>    @Override<br>    public void configureClientInboundChannel(ChannelRegistration registration) {<!-- --><br>        //注册了一个接受客户端消息通道拦截器<br>        registration.interceptors(interceptor);<br>    }<br>}<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br>    22<br>    23<br>    24<br>    25<br>    26<br>    27<br>    28<br>    29<br>    30<br>    31<br>    32<br>    33<br>    34<br>    35<br>    36<br>    37<br>    38<br>    39<br>    40<br>    41<br>    42<br>    43<br>    44<br>    45<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br>    22<br>    23<br>    24<br>    25<br>    26<br>    27<br>    28<br>    29<br>    30<br>    31<br>    32<br>    33<br>    34<br>    35<br>    36<br>    37<br>    38<br>    39<br>    40<br>    41<br>    42<br>    43<br>    44<br>    45<br><br>2. 用户信息注册，WebSocketHandleInterceptor<br><br>上一篇里面，用户信息我们是直接存储到session中，然后再通过握手的时候，将用户信息存入WebSocketSession。<br>这次使用stomp的模式也存在一个单对单的发送消息，就需要知道对方是谁，所以也要注册一下用户信息。<br><br>完整的代码<br><br>package com.example.websocketdemo1.stomp;<br><br>import com.sun.security.auth.UserPrincipal;<br>import org.springframework.messaging.Message;<br>import org.springframework.messaging.MessageChannel;<br>import org.springframework.messaging.simp.stomp.StompCommand;<br>import org.springframework.messaging.simp.stomp.StompHeaderAccessor;<br>import org.springframework.messaging.support.ChannelInterceptor;<br>import org.springframework.messaging.support.MessageHeaderAccessor;<br>import org.springframework.stereotype.Component;<br>import org.springframework.util.StringUtils;<br><br>import java.security.Principal;<br><br>/**<br> * @author linyun<br> * @date 2018/9/13 下午5:57<br> */<br>@Component<br>public class WebSocketHandleInterceptor implements ChannelInterceptor {<!-- --><br><br>    /**<br>     * 绑定user到websocket conn上<br>     * @param message<br>     * @param channel<br>     * @return<br>     */<br>    @Override<br>    public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {<!-- --><br>        StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);<br>        if (StompCommand.CONNECT.equals(accessor.getCommand())) {<!-- --><br>            String username = accessor.getFirstNativeHeader("username");<br>            if (StringUtils.isEmpty(username)) {<!-- --><br>                return null;<br>            }<br>            // 绑定user<br>            Principal principal = new UserPrincipal(username);<br>            accessor.setUser(principal);<br>        }<br>        return message;<br>    }<br>}<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br>    22<br>    23<br>    24<br>    25<br>    26<br>    27<br>    28<br>    29<br>    30<br>    31<br>    32<br>    33<br>    34<br>    35<br>    36<br>    37<br>    38<br>    39<br>    40<br>    41<br>    42<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br>    22<br>    23<br>    24<br>    25<br>    26<br>    27<br>    28<br>    29<br>    30<br>    31<br>    32<br>    33<br>    34<br>    35<br>    36<br>    37<br>    38<br>    39<br>    40<br>    41<br>    42<br><br>注意这里的username信息<br><br>String username = accessor.getFirstNativeHeader("username");<br><br>    1<br><br>    1<br><br>username是在页面中传递来的，具体的传递方式在后面的页面中，具体的参数名称可以随意自定义。<br>另外一种获取用户信息的方式：<br><br>Object raw = message.getHeaders().get(SimpMessageHeaderAccessor.NATIVE_HEADERS);<br>if (raw instanceof Map) {<!-- --><br>    System.out.println(raw);<br>    // 打印raw之后，可以查看头部的参数，包含了username。<br>}<br><br>    1<br>    2<br>    3<br>    4<br>    5<br><br>    1<br>    2<br>    3<br>    4<br>    5<br><br>3.处理消息的类，GreetingController<br><br>用来接收和发送消息。<br>先来一个消息的model，用来包装消息，使用lombok插件，省去了getset了。<br>代码：<br><br>package com.example.websocketdemo1.stomp;<br><br>import lombok.AllArgsConstructor;<br>import lombok.Builder;<br>import lombok.Data;<br>import lombok.NoArgsConstructor;<br><br>/**<br> * @author linyun<br> * @date 2018/9/13 下午5:44<br> */<br>@Data<br>@Builder<br>@NoArgsConstructor<br>@AllArgsConstructor<br>public class Message {<!-- --><br>    private String to;<br>    private Long date;<br>    private String from;<br>    private String content;<br>}<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br><br>controller的完整代码<br><br>package com.example.websocketdemo1.stomp;<br><br>import lombok.extern.slf4j.Slf4j;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.messaging.Message;<br>import org.springframework.messaging.MessageHeaders;<br>import org.springframework.messaging.handler.annotation.*;<br>import org.springframework.messaging.simp.SimpMessagingTemplate;<br>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.RequestMapping;<br><br>import java.security.Principal;<br>import java.util.Map;<br><br>/**<br> * @author linyun<br> * @date 2018/9/13 下午5:42<br> */<br>@Slf4j<br>@Controller<br>public class GreetingController {<!-- --><br><br>    @Autowired<br>    private SimpMessagingTemplate simpMessagingTemplate;<br><br><br>    /**<br>     * 测试页面<br>     * @return<br>     */<br>    @RequestMapping("/chat4")<br>    public String chat4() {<!-- --><br>        return "chat4";<br>    }<br><br>    /**<br>     * 测试页面2<br>     * @return<br>     */<br>    @RequestMapping("/chat5")<br>    public String chat5() {<!-- --><br>        return "chat5";<br>    }<br><br>    /**<br>     * 测试订阅<br>     * @param message<br>     * @param messageHeaders<br>     * @param destination<br>     * @param headers<br>     * @param id<br>     * @param body<br>     */<br>    @MessageMapping("/hello/{id}")<br>    public void hello(Message message,<br>                      MessageHeaders messageHeaders,<br>                      @Header("destination") String destination,<br>                      @Headers Map&lt;String, Object&gt; headers,<br>                      @DestinationVariable long id,<br>                      @Payload String body) {<!-- --><br>        log.info("message:{}", message);<br>        log.info("messageHeaders:{}", messageHeaders);<br>        log.info("destination:{}", destination);<br>        log.info("headers:{}", headers);<br>        log.info("id:{}", id);<br>        log.info("body:{}", body);<br>    }<br><br><br>    /***  群消息   ***/<br><br>    /**<br>     * 主动返回消息。<br>     * @param message<br>     */<br>    @MessageMapping("/hello")<br>    public void hello(@Payload com.example.websocketdemo1.stomp.Message message) {<!-- --><br>        System.out.println(message);<br>        com.example.websocketdemo1.stomp.Message returnMessage = new com.example.websocketdemo1.stomp.Message();<br>        returnMessage.setContent("转发，" + message.getContent());<br>        simpMessagingTemplate.convertAndSend("/message/public", returnMessage);<br>    }<br><br>    /**<br>     * 使用注解的方式返回消息<br>     * @param message<br>     * @return<br>     */<br>    @MessageMapping("/hello1")<br>    @SendTo("/message/public")<br>    public com.example.websocketdemo1.stomp.Message hello1(@Payload com.example.websocketdemo1.stomp.Message message) {<!-- --><br>        System.out.println(message);<br>        com.example.websocketdemo1.stomp.Message returnMessage = new com.example.websocketdemo1.stomp.Message();<br>        returnMessage.setContent("转发2，" + message.getContent());<br>        return returnMessage;<br>    }<br><br>    /***  点对点   ***/<br><br>    /**<br>     * 点对点发送消息。接收消息的人是从消息中获取的。<br>     * @param message<br>     * @param principal<br>     */<br>    @MessageMapping("/hello2")<br>    public void hello2(@Payload com.example.websocketdemo1.stomp.Message message, Principal principal) {<!-- --><br>        System.out.println(message);<br>        System.out.println(principal);<br>        com.example.websocketdemo1.stomp.Message returnMessage = new com.example.websocketdemo1.stomp.Message();<br>        returnMessage.setContent("转发3，" + message.getContent());<br>        simpMessagingTemplate.convertAndSendToUser(message.getTo(), "/notice/msg", returnMessage);<br>    }<br><br>}<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br>    22<br>    23<br>    24<br>    25<br>    26<br>    27<br>    28<br>    29<br>    30<br>    31<br>    32<br>    33<br>    34<br>    35<br>    36<br>    37<br>    38<br>    39<br>    40<br>    41<br>    42<br>    43<br>    44<br>    45<br>    46<br>    47<br>    48<br>    49<br>    50<br>    51<br>    52<br>    53<br>    54<br>    55<br>    56<br>    57<br>    58<br>    59<br>    60<br>    61<br>    62<br>    63<br>    64<br>    65<br>    66<br>    67<br>    68<br>    69<br>    70<br>    71<br>    72<br>    73<br>    74<br>    75<br>    76<br>    77<br>    78<br>    79<br>    80<br>    81<br>    82<br>    83<br>    84<br>    85<br>    86<br>    87<br>    88<br>    89<br>    90<br>    91<br>    92<br>    93<br>    94<br>    95<br>    96<br>    97<br>    98<br>    99<br>    100<br>    101<br>    102<br>    103<br>    104<br>    105<br>    106<br>    107<br>    108<br>    109<br>    110<br>    111<br>    112<br>    113<br>    114<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br>    22<br>    23<br>    24<br>    25<br>    26<br>    27<br>    28<br>    29<br>    30<br>    31<br>    32<br>    33<br>    34<br>    35<br>    36<br>    37<br>    38<br>    39<br>    40<br>    41<br>    42<br>    43<br>    44<br>    45<br>    46<br>    47<br>    48<br>    49<br>    50<br>    51<br>    52<br>    53<br>    54<br>    55<br>    56<br>    57<br>    58<br>    59<br>    60<br>    61<br>    62<br>    63<br>    64<br>    65<br>    66<br>    67<br>    68<br>    69<br>    70<br>    71<br>    72<br>    73<br>    74<br>    75<br>    76<br>    77<br>    78<br>    79<br>    80<br>    81<br>    82<br>    83<br>    84<br>    85<br>    86<br>    87<br>    88<br>    89<br>    90<br>    91<br>    92<br>    93<br>    94<br>    95<br>    96<br>    97<br>    98<br>    99<br>    100<br>    101<br>    102<br>    103<br>    104<br>    105<br>    106<br>    107<br>    108<br>    109<br>    110<br>    111<br>    112<br>    113<br>    114<br><br>稍微解释一下代码中的几个方法<br>第一个方法，/hello/{id}，主要是用来测试在一次发送消息的请求中能够获取到那些参数，合理的利用这些参数于自己的业务中。<br><br>    @MessageMapping("/hello/{id}")<br>    public void hello(Message message,<br>                      MessageHeaders messageHeaders,<br>                      @Header("destination") String destination,<br>                      @Headers Map&lt;String, Object&gt; headers,<br>                      @DestinationVariable long id,<br>                      @Payload String body) {<!-- --><br>        log.info("message:{}", message);<br>        log.info("messageHeaders:{}", messageHeaders);<br>        log.info("destination:{}", destination);<br>        log.info("headers:{}", headers);<br>        log.info("id:{}", id);<br>        log.info("body:{}", body);<br>    }<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br><br>4.结合页面测试<br><br>新建2个页面，页面中设置用户的信息<br><br>http://127.0.0.1:8080/chat4<br>username='tom';<br>http://127.0.0.1:8080/chat5<br>username='jerry';<br><br>    1<br>    2<br>    3<br>    4<br><br>主要是引入 stomp.js和socketjs这2个js。<br>页面完整代码：<br><br>&lt;!DOCTYPE html&gt;<br>&lt;html lang="en"&gt;<br>&lt;head&gt;<br>    &lt;title&gt;测试websocket&lt;/title&gt;<br>    &lt;meta charset="UTF-8"&gt;<br>    &lt;meta name="viewport"<br>          content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"&gt;<br>    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/&gt;<br>    &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/css/bootstrap.min.css"&gt;<br>    &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery-toast-plugin/1.3.2/jquery.toast.min.css"&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div class="container"&gt;<br>    &lt;button type="button" class="btn btn-primary" οnclick="connect()"&gt;链接&lt;/button&gt;<br>    &lt;button type="button" class="btn btn-primary" οnclick="disconnect()"&gt;断开&lt;/button&gt;<br><br>&lt;/div&gt;<br>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js" type="text/javascript"&gt;&lt;/script&gt;<br>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/js/bootstrap.min.js"&gt;&lt;/script&gt;<br>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-toast-plugin/1.3.2/jquery.toast.min.js"&gt;&lt;/script&gt;<br>&lt;script src="http://cdn.sockjs.org/sockjs-0.3.min.js"&gt;&lt;/script&gt;<br>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"&gt;&lt;/script&gt;<br>&lt;script language=javascript&gt;<br><br>    var username = 'tom';<br>    var sendMessage = null;<br>    var disConnect = null;<br><br>    function connect() {<!-- --><br>        var socket = new SockJS("http://127.0.0.1:8080/chat");<br>        var client = Stomp.over(socket);<br>        client.connect({<!-- --><br>            username: username<br>        }, function (succ) {<!-- --><br>            console.log('client connect success:', succ);<br><br>            client.subscribe("/message/public", function (res) {<!-- --><br>                console.log('收到消息---/message/public：',res);<br>            });<br><br>            client.subscribe("/user/notice/msg", function (res) {<!-- --><br>                console.log('个人消息：',res)<br>            });<br>        }, function (error) {<!-- --><br>            console.log('client connect error:', error);<br>        });<br>        sendMessage = function (destination, headers, body) {<!-- --><br>            client.send(destination, headers, body)<br>        };<br>        disConnect = function () {<!-- --><br>            client.disconnect();<br>            console.log('client connect break')<br>        }<br>    }<br><br>    function disconnect() {<!-- --><br>        disConnect();<br>    }<br><br>    //发送聊天信息<br>    function send(roomId, ct) {<!-- --><br>        var messageModel = {};<br>        messageModel.type = 1;<br>        messageModel.content = ct;<br>        messageModel.from = username;<br>        sendMessage("/app/hello/" + roomId, {}, JSON.stringify(messageModel));<br>    }<br><br>    /**<br>     * 测试发送一个消息，如果订阅了/sub/public的用户都会收到消息。<br>     */<br>    function send1() {<!-- --><br>        var messageModel = {};<br>        messageModel.type = 1;<br>        messageModel.content = '你好,' + new Date().getTime();<br>        messageModel.from = username;<br>        sendMessage("/app/hello", {}, JSON.stringify(messageModel));<br>    }<br>    function send2() {<!-- --><br>        var messageModel = {};<br>        messageModel.type = 1;<br>        messageModel.content = 'hello1,' + new Date().getTime();<br>        messageModel.from = username;<br>        sendMessage("/app/hello1", {}, JSON.stringify(messageModel));<br>    }<br>    /** 发送消息给个人，接收者 to **/<br>    function send3() {<!-- --><br>        var messageModel = {};<br>        messageModel.to = 'jerry';<br>        messageModel.type = 1;<br>        messageModel.content = 'hello1,' + new Date().getTime();<br>        messageModel.from = username;<br>        sendMessage("/app/hello2", {}, JSON.stringify(messageModel));<br>    }<br>    }<br>&lt;/script&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br>    22<br>    23<br>    24<br>    25<br>    26<br>    27<br>    28<br>    29<br>    30<br>    31<br>    32<br>    33<br>    34<br>    35<br>    36<br>    37<br>    38<br>    39<br>    40<br>    41<br>    42<br>    43<br>    44<br>    45<br>    46<br>    47<br>    48<br>    49<br>    50<br>    51<br>    52<br>    53<br>    54<br>    55<br>    56<br>    57<br>    58<br>    59<br>    60<br>    61<br>    62<br>    63<br>    64<br>    65<br>    66<br>    67<br>    68<br>    69<br>    70<br>    71<br>    72<br>    73<br>    74<br>    75<br>    76<br>    77<br>    78<br>    79<br>    80<br>    81<br>    82<br>    83<br>    84<br>    85<br>    86<br>    87<br>    88<br>    89<br>    90<br>    91<br>    92<br>    93<br>    94<br>    95<br>    96<br>    97<br>    98<br><br>    1<br>    2<br>    3<br>    4<br>    5<br>    6<br>    7<br>    8<br>    9<br>    10<br>    11<br>    12<br>    13<br>    14<br>    15<br>    16<br>    17<br>    18<br>    19<br>    20<br>    21<br>    22<br>    23<br>    24<br>    25<br>    26<br>    27<br>    28<br>    29<br>    30<br>    31<br>    32<br>    33<br>    34<br>    35<br>    36<br>    37<br>    38<br>    39<br>    40<br>    41<br>    42<br>    43<br>    44<br>    45<br>    46<br>    47<br>    48<br>    49<br>    50<br>    51<br>    52<br>    53<br>    54<br>    55<br>    56<br>    57<br>    58<br>    59<br>    60<br>    61<br>    62<br>    63<br>    64<br>    65<br>    66<br>    67<br>    68<br>    69<br>    70<br>    71<br>    72<br>    73<br>    74<br>    75<br>    76<br>    77<br>    78<br>    79<br>    80<br>    81<br>    82<br>    83<br>    84<br>    85<br>    86<br>    87<br>    88<br>    89<br>    90<br>    91<br>    92<br>    93<br>    94<br>    95<br>    96<br>    97<br>    98<br><br>点击链接按钮，主要是做了几个操作，<br><br>    1. 链接到websocket<br>    2. 订阅/message/public<br>    3. 订阅/user/notice/msg<br><br>5. 跑起来测试<br><br>进入页面后，打开控制台，直接输入命令。如果觉得不方便，可以在页面加几个按钮，美观点=)<br><br>        send(‘123456’,‘hello’);<br><br>此方法会发起一个消息，推送到/app/hello/123456，这个地址，并带上参数messageModel。<br>监控到后台 @MessageMapping("/hello/{id}") 接收到的消息。<br><br>        send1();<br><br>发送一条消息给/app/hello，后台接收到之后通过 simpMessagingTemplate.convertAndSend("/message/public", returnMessage); 广播一条消息给所有订阅了/message/public的用户。<br>所以为了测试，最好多开几个浏览器。观察一下console的打印信息。<br><br>        send3();<br><br>发送一条消息给 @MessageMapping("/hello2") ，注意这里的消息messageModel中加入了to=jerry。后台接收到参数之后，使用 simpMessagingTemplate.convertAndSendToUser(message.getTo(), “/notice/msg”, returnMessage); 将消息发送给jerry，从而实现了单对单的消息推送。<br>6.总结一下<br><br>    stomp底层实现都是广播，单对单只是表面看起来特殊一点，本质其实也是生成的一个唯一的广播地址。测试也简单，打开2个页面登录tom，一个登录jerry。用jerry发送消息给tom。2个tom都会收到消息。<br>    页面中注册订阅地址，后台通过注册的地址发送广播。所以/message和/notice后面的参数其实可以随便写。<br><br>完整项目 git：https://gitlab.com/tulongx/websocketdemo1<br><br>以上。<br><br>--------------------- <br>版权声明：本文为CSDN博主「暴躁兔子」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https://blog.csdn.net/qq_21019419/article/details/82804921</p> 
</div> 
<p>转载于:https://www.cnblogs.com/xiang--liu/p/11364956.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4419ce7e2374902fa82677181cc3064f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">沙漏验机官方最新版 v3.6.1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/271d956147a916b723d38315093fff4d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue中watch的详细用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>