<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>看vue项目体会(app.vue，router的index.js) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="看vue项目体会(app.vue，router的index.js)" />
<meta property="og:description" content="template标签的作用 template本身没有很特别的意义，可以了解下html 的template标签官网以及其他人所描述的“根元素”，是指template标签下的元素，不包括也不是template本身。template只能有一个根元素。 HTML 元素 是一种用于保存客户端内容的机制，该内容在页面加载时不被渲染，但可以在运行时使用JavaScript进行实例化。
可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。虽然, 在加载页面的同时,解析器确实处理 &lt;template&gt;元素的内容，这样做只是确保这些内容是有效的; 然而,元素的内容不会被渲染。
vue-router 基本使用 路由，其实就是指向的意思，当我点击页面上的home按钮时，页面中就要显示home的内容，如果点击页面上的about 按钮，页面中就要显示about 的内容（Home按钮 =&gt; home 内容， about按钮 =&gt; about 内容）。也可以说是一种映射。 所以在页面上有两个部分，一个是点击部分，一个是点击之后，显示内容的部分。
点击之后，怎么做到正确的对应，比如，我点击home 按钮，页面中怎么就正好能显示home的内容。这就要在js 文件中配置路由。
路由中有三个基本的概念 route, routes, router。
route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮 =&gt; home内容， 这是一条route, about按钮 =&gt; about 内容， 这是另一条路由。
routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}]
router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。
客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于hash 和基于html5 history api.
vue-router中的路由也是基于上面的内容来实现的 在vue中实现路由还是相对简单的。因为我们页面中所有内容都是组件化的，我们只要把路径和组件对应起来就可以了，然后在页面中把组件渲染出来。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/bb5605884f02f70378591f871218e818/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-03T11:38:25+08:00" />
<meta property="article:modified_time" content="2019-01-03T11:38:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">看vue项目体会(app.vue，router的index.js)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="template_0"></a>template标签的作用</h3> 
<ol><li>template本身没有很特别的意义，可以了解下html 的template标签</li><li>官网以及其他人所描述的“根元素”，是指template标签下的元素，不包括也不是template本身。template只能有一个根元素。</li></ol> 
<p>HTML 元素 是一种用于保存客户端内容的机制，该内容在页面加载时不被渲染，但可以在运行时使用JavaScript进行实例化。<br> 可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。虽然, 在加载页面的同时,解析器确实处理 <code>&lt;template&gt;</code>元素的内容，这样做只是确保这些内容是有效的; 然而,元素的内容不会被渲染。</p> 
<h3><a id="vuerouter__8"></a>vue-router 基本使用</h3> 
<p>路由，其实就是指向的意思，当我点击页面上的home按钮时，页面中就要显示home的内容，如果点击页面上的about 按钮，页面中就要显示about 的内容（Home按钮 =&gt; home 内容， about按钮 =&gt; about 内容）。也可以说是一种映射。 所以在页面上有两个部分，一个是点击部分，一个是点击之后，显示内容的部分。<br> 点击之后，怎么做到正确的对应，比如，我点击home 按钮，页面中怎么就正好能显示home的内容。这就要在js 文件中配置路由。</p> 
<p>路由中有三个基本的概念 route, routes, router。</p> 
<ol><li> <p>route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮 =&gt; home内容， 这是一条route, about按钮 =&gt; about 内容， 这是另一条路由。</p> </li><li> <p>routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}]</p> </li><li> <p>router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。</p> </li><li> <p>客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于hash 和基于html5 history api.</p> </li></ol> 
<h4><a id="vuerouter_22"></a>vue-router中的路由也是基于上面的内容来实现的</h4> 
<p>在vue中实现路由还是相对简单的。因为我们页面中所有内容都是组件化的，我们只要把路径和组件对应起来就可以了，然后在页面中把组件渲染出来。</p> 
<ol><li> <p>页面实现（html模版中）<br> 在vue-router中, 我们看到它定义了两个标签<code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code>来对应点击和显示部分。<br> <code>&lt;router-link&gt;</code>就是定义页面中点击的部分，<code>&lt;router-view&gt;</code> 定义显示部分，就是点击后，区配的内容显示在什么地方。<br> 所以 <code>&lt;router-link&gt;</code>还有一个非常重要的属性 to，定义点击之后，要到哪里去， 如：<code>&lt;router-link to="/home"&gt;Home&lt;/router-link&gt;</code></p> </li><li> <p>js 中配置路由<br> 首先要定义route, 一条路由的实现。它是一个对象，由两个部分组成： path和component。path 指路径，component 指的是组件。如：{path:’/home’, component: home}</p> </li></ol> 
<blockquote> 
 <p>你可以 router-view 当做是一个容器，它渲染的组件是你使用 vue-router 指定的。</p> 
</blockquote> 
<p>假设我们有如下一个应用：</p> 
<pre><code class="prism language-php"><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token double-quoted-string string">"app"</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre> 
<p><code>&lt;router-view&gt;</code>是一个顶级的外链。它会渲染一个和顶级路由匹配的组件。</p> 
<p>由于在main.js中<code>import router from './router'</code>语句将默认连接到router文件夹中的index.js文件，或者如上文中的router.js中。</p> 
<h3><a id="export_export_default__import___47"></a>export ，export default 和 import 区别 以及用法</h3> 
<h4><a id="exportimport_48"></a>export与import</h4> 
<p>ES6模块主要有两个功能：export和import<br> export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口<br> import用于在一个模块中加载另一个含有export接口的模块。<br> 也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p> 
<h4><a id="exportexport_default_54"></a>export与export default</h4> 
<ol><li>export与export default均可用于导出常量、函数、文件、模块等</li><li>你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用</li><li>在一个文件或模块中，export、import可以有多个，export default仅有一个</li><li>通过export方式导出，在导入时要加{ }，export default则不需要</li></ol> 
<p>这样来说其实很多时候export与export default可以实现同样的目的，只是用法有些区别。注意第四条，通过export方式导出，在导入时要加{ }，export default则不需要。使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名。</p> 
<ul><li>name 在 export default {} 中的作用: 
  <ol><li>name: ‘app’ 相当于一个全局 ID；</li><li>可以不写；</li><li>写了可以提供更好的调试信息（官方文档有）。</li><li>可以理解为是导出的途径。用<code>import App from './App'</code></li></ol> </li></ul> 
<h3><a id="routerjs_69"></a>router.js基本创建过程</h3> 
<ul><li>引入 vue-router</li></ul> 
<pre><code class="prism language-php">import Vue from <span class="token single-quoted-string string">'vue'</span>
import Router from <span class="token single-quoted-string string">'vue-router'</span>

Vue<span class="token punctuation">.</span><span class="token keyword">use</span><span class="token punctuation">(</span>Router<span class="token punctuation">)</span>
</code></pre> 
<ul><li>关于path的定义<br> 入口的页面可以设置path的时候设置为"/"</li><li>定义的path和name的区别<br> path：是路径，还可以有二级路径比如 path: ‘/system/setting’。<br> name：是名字，就相当于给你的这个 path 起个名字方便记住，也可以不设置 name。</li><li>定义 component 指定变量</li></ul> 
<blockquote> 
 <p>在单页应用中，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，不利于用户体验。<br> 而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。</p> 
</blockquote> 
<p><strong>vue懒加载</strong><br> 定义：懒加载也叫延迟加载，即在需要的时候进行加载，随用随载。<br> 使用方法：</p> 
<pre><code class="prism language-php">component<span class="token punctuation">:</span>resolve <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token single-quoted-string string">'@/pages/About'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>resolve<span class="token punctuation">)</span>
</code></pre> 
<blockquote> 
 <p>按需加载会在页面第一次请求的时候，把相关路由组件块的js添加上。<br> 非按需加载（预加载）则会把所有的路由组件块的js包打在一起。<br> <strong>当业务包很大的时候建议用路由的按需加载（懒加载）。</strong></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5300486c454f4b0318ba0cc5326274bd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">程序猿 网站 | 常用 技术学习网站</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab1f2fc8b2488f81beec543ef1420b29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue--创建一个vue项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>