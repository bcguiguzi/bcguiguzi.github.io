<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring websocket 利用注解接收和发送消息 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring websocket 利用注解接收和发送消息" />
<meta property="og:description" content="websocket只定义了文字和字节俩种形式的消息格式，没有像http协议那样子有那么丰富的协议规范，我们看看http的协议格式
websocket之所以没有自己定义那么多的协议格式，是希望有框架自己来实现定义这些格式，我们称之为websocket的子协议，sub-protocol。
STOMP，Streaming Text Orientated Message Protocol，是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP的消息格式如下：
COMMAND header1:value1 header2:value2 Body^@ 例如发送消息
SEND destination:/queue/trade content-type:application/json content-length:44 {&#34;action&#34;:&#34;BUY&#34;,&#34;ticker&#34;:&#34;MMM&#34;,&#34;shares&#34;,44}^@ 再看看订阅消息
SUBSCRIBE id:sub-1 destination:/topic/price.stock.* ^@ 然后服务器进行广播消息
MESSAGE message-id:nxahklf6-1 subscription:sub-1 destination:/topic/price.stock.MMM {&#34;ticker&#34;:&#34;MMM&#34;,&#34;price&#34;:129.45}^@ 详细了解可以看看官网http://stomp.github.io/stomp-specification-1.1.html
spring websocket利用STOMP作为websocket的子协议，原因是stomp可以提供一种类似springmvc的编码方式，可以利用注解进行接收和发送消息以及和springmvc进行无缝的结合。
这样子，我们利用注解来接受和广播websocket信息
@Controller @RequestMapping(&#34;/webSocket&#34;) @MessageMapping(&#34;foo&#34;) public class WebSocketController { @MessageMapping(&#34;handle&#34;) @SendTo(&#34;/topic/greetings&#34;) public String handle(Task task ,String name) { //... return &#34;handle2&#34;; } } @MessageMapping即可以用来类级别上也可以用在方法级别上，类似springmvc，但是为不同的是，springmvc的路径是类路径/方法路径，中间是“/”，例如/webSocket/xxxx,而websocket是用“.”来分开路径的，类路径.方法路径，例如foo.handle来发送消息到特定路径
@SendTo可以把消息广播到路径上去，例如上面可以把消息广播到”/topic/greetings”,如果客户端在这个路径订阅消息，则可以接收到消息
接下来需要注册下基于stomp子协议的websocket到spring中
@Configuration @EnableWebSocketMessageBroker public class WebSocketMessageBrokerConfig implements WebSocketMessageBrokerConfigurer { @Override public void registerStompEndpoints(StompEndpointRegistry registry) { //portfolio-stomp就是websocket的端点，客户端需要注册这个端点进行链接，withSockJS允许客户端利用sockjs进行浏览器兼容性处理 registry." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/40e79d0d0f806aca0b211aadb4da4766/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-21T21:29:47+08:00" />
<meta property="article:modified_time" content="2016-04-21T21:29:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring websocket 利用注解接收和发送消息</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>websocket只定义了文字和字节俩种形式的消息格式，没有像http协议那样子有那么丰富的协议规范，我们看看http的协议格式</p> 
<p><img src="https://images2.imgbox.com/ba/c3/xx7pWqeE_o.png" alt="这里写图片描述" title=""></p> 
<p>websocket之所以没有自己定义那么多的协议格式，是希望有框架自己来实现定义这些格式，我们称之为websocket的子协议，sub-protocol。</p> 
<p>STOMP，Streaming Text Orientated Message Protocol，是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP的消息格式如下：</p> 
<pre class="prettyprint"><code class=" hljs css"><span class="hljs-tag">COMMAND</span>
<span class="hljs-tag">header1</span><span class="hljs-pseudo">:value1</span>
<span class="hljs-tag">header2</span><span class="hljs-pseudo">:value2</span>
<span class="hljs-tag">Body</span>^<span class="hljs-at_rule">@</span></code></pre> 
<p>例如发送消息</p> 
<pre class="prettyprint"><code class=" hljs lasso">SEND
destination:/<span class="hljs-built_in">queue</span>/trade
content<span class="hljs-attribute">-type</span>:application/json
content<span class="hljs-attribute">-length</span>:<span class="hljs-number">44</span>
{<!-- --><span class="hljs-string">"action"</span>:<span class="hljs-string">"BUY"</span>,<span class="hljs-string">"ticker"</span>:<span class="hljs-string">"MMM"</span>,<span class="hljs-string">"shares"</span>,<span class="hljs-number">44</span>}^@</code></pre> 
<p>再看看订阅消息</p> 
<pre class="prettyprint"><code class=" hljs avrasm">SUBSCRIBE
<span class="hljs-label">id:</span><span class="hljs-keyword">sub</span>-<span class="hljs-number">1</span>
<span class="hljs-label">destination:</span>/topic/price<span class="hljs-preprocessor">.stock</span>.*
^@</code></pre> 
<p>然后服务器进行广播消息</p> 
<pre class="prettyprint"><code class=" hljs perl">MESSAGE
message-id:nxahklf6-<span class="hljs-number">1</span>
subscription:<span class="hljs-sub"><span class="hljs-keyword">sub</span>-1
destination:/topic/price.stock.MMM
{<!-- --></span><span class="hljs-string">"ticker"</span>:<span class="hljs-string">"MMM"</span>,<span class="hljs-string">"price"</span>:<span class="hljs-number">129.45</span>}^@</code></pre> 
<p>详细了解可以看看官网<a href="http://stomp.github.io/stomp-specification-1.1.html" rel="nofollow">http://stomp.github.io/stomp-specification-1.1.html</a></p> 
<p>spring websocket利用STOMP作为websocket的子协议，原因是stomp可以提供一种类似springmvc的编码方式，可以利用注解进行接收和发送消息以及和springmvc进行无缝的结合。</p> 
<p>这样子，我们利用注解来接受和广播websocket信息</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Controller</span>
<span class="hljs-annotation">@RequestMapping</span>(<span class="hljs-string">"/webSocket"</span>)
<span class="hljs-annotation">@MessageMapping</span>(<span class="hljs-string">"foo"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketController</span> {<!-- --></span>

<span class="hljs-annotation">@MessageMapping</span>(<span class="hljs-string">"handle"</span>)
<span class="hljs-annotation">@SendTo</span>(<span class="hljs-string">"/topic/greetings"</span>)
<span class="hljs-keyword">public</span> String <span class="hljs-title">handle</span>(Task task ,String name) {
     <span class="hljs-comment">//...</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"handle2"</span>;
}
}</code></pre> 
<p>@MessageMapping即可以用来类级别上也可以用在方法级别上，类似springmvc，但是为不同的是，springmvc的路径是类路径/方法路径，中间是“/”，例如/webSocket/xxxx,而websocket是用“.”来分开路径的，类路径.方法路径，例如foo.handle来发送消息到特定路径</p> 
<p>@SendTo可以把消息广播到路径上去，例如上面可以把消息广播到”/topic/greetings”,如果客户端在这个路径订阅消息，则可以接收到消息</p> 
<p>接下来需要注册下基于stomp子协议的websocket到spring中</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Configuration</span>
<span class="hljs-annotation">@EnableWebSocketMessageBroker</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSocketMessageBrokerConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebSocketMessageBrokerConfigurer</span> {<!-- --></span>

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerStompEndpoints</span>(StompEndpointRegistry registry) {

        <span class="hljs-comment">//portfolio-stomp就是websocket的端点，客户端需要注册这个端点进行链接，withSockJS允许客户端利用sockjs进行浏览器兼容性处理</span>
        registry.addEndpoint(<span class="hljs-string">"/portfolio-stomp"</span>).withSockJS(); 

    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageBroker</span>(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker(<span class="hljs-string">"/topic"</span>);               <span class="hljs-comment">//设置服务器广播消息的基础路径</span>
        registry.setApplicationDestinationPrefixes(<span class="hljs-string">"/app"</span>);  <span class="hljs-comment">//设置客户端订阅消息的基础路径</span>
        registry.setPathMatcher(<span class="hljs-keyword">new</span> AntPathMatcher(<span class="hljs-string">"."</span>));    <span class="hljs-comment">//可以已“.”来分割路径，看看类级别的@messageMapping和方法级别的@messageMapping</span>
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">configureMessageConverters</span>(List&lt;MessageConverter&gt; messageConverters) {

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureWebSocketTransport</span>(WebSocketTransportRegistration registry) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>
        registry.addDecoratorFactory(<span class="hljs-keyword">new</span> MyWebSocketHandlerDecoratorFactory());
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureClientInboundChannel</span>(ChannelRegistration registration) {
         registration.setInterceptors(<span class="hljs-keyword">new</span> MyChannelInterceptor());
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureClientOutboundChannel</span>(ChannelRegistration registration) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>

    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span>(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>

    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addReturnValueHandlers</span>(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers) {
        <span class="hljs-comment">// TODO Auto-generated method stub</span>

    }

}</code></pre> 
<p>前端需要用到sockjs.js和stomp.js</p> 
<pre class="prettyprint"><code class=" hljs scala"><span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> SockJS(<span class="hljs-string">'/whats/portfolio-stomp'</span>);

<span class="hljs-javadoc">/**
 * 建立成功的回调函数
 */</span>
socket.onopen = function() {
    console.log(<span class="hljs-string">'open'</span>);
};

<span class="hljs-javadoc">/**
 * 服务器有消息返回的回调函数
 */</span>
socket.onmessage = function(e) {
    console.log(<span class="hljs-string">'message'</span>, e.data);
};

<span class="hljs-javadoc">/**
 * websocket链接关闭的回调函数
 */</span>
socket.onclose = function() {
    console.log(<span class="hljs-string">'close'</span>);
};

<span class="hljs-keyword">var</span> stompClient = Stomp.over(socket);
stompClient.connect({}, function(frame) {
    stompClient.subscribe(<span class="hljs-string">'/topic/greetings'</span>,  function(data) { <span class="hljs-comment">//订阅消息</span>
         $(<span class="hljs-string">"#ret"</span>).text(data);
    });
});

document.getElementById(<span class="hljs-string">"ws"</span>).onclick = function() {
stompClient.send(<span class="hljs-string">"/app/foo.handle3"</span>, {}, JSON.stringify({
        name : <span class="hljs-string">"nane"</span>,
        taskName : <span class="hljs-string">"taskName"</span>,
        taskDetail : <span class="hljs-string">"taskDetail"</span>
    }));
}</code></pre> 
<p>到这里就可以就服务器就可以接收和广播消息了，而客户端就可以发送和订阅消息了。</p> 
<p>类中的handle的方法参数绑定接收和格式化的处理类似springmvc中方法参数的处理</p> 
<p>而方法参数的返回值会被MessageConverter进行转化封装然后发送给广播出去，类似springmvc的方法中带@responsebody注解时候方法返回值会被httpMessageConverter进行转化一样。</p> 
<p>spring websocket的方法参数中还允许有其他一些参数如下</p> 
<p>Principal principal ,存放用户的登录验证信息 <br> Message message，最基础的消息体，里面方有header和payload等信息 <br> @Payload 消息体内容 <br> @Header(“..”) 某个头部key的值 <br> @Headers, 所有头部key的map集合 <br> MessageHeaders , SimpMessageHeaderAccessor, MessageHeaderAccessor ,StompHeaderAccessor 消息头信息 <br> @DestinationVariable 类似springmvc中的@PathVariable</p> 
<p>在spring websocket中也可以类似springmvc中把变量绑定在路径上，例如</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@MessageMapping</span>(<span class="hljs-string">"bar.{baz}"</span>) 
<span class="hljs-annotation">@SendTo</span>(<span class="hljs-string">"/topic/greetings"</span>)
<span class="hljs-keyword">public</span> String <span class="hljs-title">handle1</span>(@DestinationVariable String baz) {

     <span class="hljs-keyword">return</span> baz;
 }</code></pre> 
<p>这就是注解大概的使用方式，如何已注解方式来进行精准推送和全部推送呢？？</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1c8811cefcdd9c43b197e985842ef81a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Gradle sync failed: failed to find Build Tools revision 23.0.3 解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d0ef5b163f14543e87da27e192204bae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决  /System/Library/Frameworks/Ruby.framework/Versions/2.0/usr/lib/ruby/2.0.0/universal-darwi</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>