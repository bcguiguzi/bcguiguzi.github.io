<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>jsp学习2(jsp的指令) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="jsp学习2(jsp的指令)" />
<meta property="og:description" content="文章目录 jsp的指令jsp中的九大内置对象: jsp的指令 jsp中有三大指令，分别是:
page指令，最复杂，也是最常用的include —&gt;静态包含，这个和requestDispatcher.include区别是后者是动态包含taglib --&gt;导入标签库 在jsp文件中使用指令的格式为：&lt;%@指令名 属性名=属性值 %&gt;,这里主要重点讲解page指令的常用属性：
1、pageEncoding和contentType pageEncoding表示用来设置当前的jsp文件的编码，也即服务端将当前的jsp文件编译成为.java文件的编码。 而contentType则是设置当前的jsp文件的编码，同时会设置响应头Context-Type的编码为这个属性对应的值。 两者的关系是互为补充的，即只要我们设置其中一个属性的值，例如我们设置了pageEncoding的值为utf-8，那么即使我们没有写contentType，那么就会自动设置contentType的值为pageEncoding的值。 如果我们两个属性都没有设置，那么就会默认为iso编码。 2、isErrorPage和errorPage errorPage的值用来表示如果当前的jsp文件发生了异常，那么就会转发到这个属性对应的jsp文件中。 而isErrorPage则是用来判断当前的jsp文件是否是处理异常的，如果为true，那么当前的jsp文件是处理异常的，此时这个jsp文件就可以使用exception内置对象,但是如果为false，那么这个jsp文件不可以使用exception内置对象。 值得注意的是，如果我们在errorPage值对应的jsp文件中设置了isErroPage属性的值为true，那么运行设置errorPage属性的jsp文件的时候，就会发现接收到的状态码为500,否则，如果errorPage值对应的jsp文件中并没有设置isErrorPage或者值为false，那么运行设置errorPage属性的jsp文件的时候，就会发现接收到的状态码为200。 3、autoFlush和buffer autoFlush:表示当前的jsp文件的缓冲池满的时候是否会自动刷新，如果为true，则会自动刷新，否则不会，此时满的时候会抛出异常. buffer:设置jsp文件的缓冲池，默认情况下是8kB. 4、isELIgnore:判断当前的jsp文件是否忽略EL表达式，如果为false，那么不会忽略，即支持EL表达式 5、import:用来导包的，可以在指令中设置多个import属性，也可以将多个import的值写到同一个import中，此时各个值需要用逗号分开。 6、其他: language:表示当前的jsp文件支持的语言 info:表示信息 isThreadSafe:判断是否支持并发，如果为false，说明不是线程安全，也即支持并发，否则为true，说明线程安全，支持的是单线程。 extends:表示这个jsp文件生成的java文件将会继承extends的值。 这里主要验证errorPage和isErrorPage:
&lt;!-- error1.jsp --&gt; &lt;%@ page contentType=&#34;text/html;charset=UTF-8&#34; errorPage=&#34;error2.jsp&#34; language=&#34;java&#34;%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;验证errorPage属性&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% /* 值得注意的是，如果在处理异常的jsp文件中有设置isErrorPage属性为true的时候， 那么这时候发送500的状态码. 但是如果我们没有设置isErrorPage的属性，或者值为false的时候，那么就会将发送 200的状态码。 所以说明了，某个jsp文件作为errorPage属性的值的时候(即error2.jsp)，这个jsp文件并不一定要求 设置isErrorPage属性的。但是如果设置了isErrorPage属性为true，那么就可以使用 jsp中的exception内置对象，否则，如果为false，是不可以使用exception内置对象的。 */ int a = 10 / 0;//出现异常，将根据errorPage属性，转发导对应的jsp文件 %&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- error2.jsp --&gt; &lt;%@ page contentType=&#34;text/html;charset=UTF-8&#34; language=&#34;java&#34; isErrorPage=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/769d1f9b480d0b73b8946b58c62f6200/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-24T18:15:16+08:00" />
<meta property="article:modified_time" content="2022-02-24T18:15:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">jsp学习2(jsp的指令)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#jsp_1" rel="nofollow">jsp的指令</a></li><li><a href="#jsp_191" rel="nofollow">jsp中的九大内置对象:</a></li></ul> 
</div> 
<p></p> 
<h2><a id="jsp_1"></a>jsp的指令</h2> 
<p>jsp中有三大指令，分别是:</p> 
<ul><li>page指令，最复杂，也是最常用的</li><li>include —&gt;静态包含，这个和requestDispatcher.include区别是后者是动态包含</li><li>taglib --&gt;导入标签库</li></ul> 
<p>在jsp文件中使用指令的格式为：&lt;%@指令名 属性名=属性值 %&gt;,这里主要重点讲解page指令的常用属性：</p> 
<pre><code class="prism language-bash"><span class="token number">1</span>、pageEncoding和contentType
pageEncoding表示用来设置当前的jsp文件的编码，也即服务端将当前的jsp文件编译成为.java文件的编码。
而contentType则是设置当前的jsp文件的编码，同时会设置响应头Context-Type的编码为这个属性对应的值。
两者的关系是互为补充的，即只要我们设置其中一个属性的值，例如我们设置了pageEncoding的值为utf-8，那么即使我们没有写contentType，那么就会自动设置contentType的值为pageEncoding的值。
如果我们两个属性都没有设置，那么就会默认为iso编码。
<span class="token number">2</span>、isErrorPage和errorPage
errorPage的值用来表示如果当前的jsp文件发生了异常，那么就会转发到这个属性对应的jsp文件中。
而isErrorPage则是用来判断当前的jsp文件是否是处理异常的，如果为true，那么当前的jsp文件是处理异常的，此时这个jsp文件就可以使用exception内置对象,但是如果为false，那么这个jsp文件不可以使用exception内置对象。
值得注意的是，如果我们在errorPage值对应的jsp文件中设置了isErroPage属性的值为true，那么运行设置errorPage属性的jsp文件的时候，就会发现接收到的状态码为500,否则，如果errorPage值对应的jsp文件中并没有设置isErrorPage或者值为false，那么运行设置errorPage属性的jsp文件的时候，就会发现接收到的状态码为200。
<span class="token number">3</span>、autoFlush和buffer
autoFlush:表示当前的jsp文件的缓冲池满的时候是否会自动刷新，如果为true，则会自动刷新，否则不会，此时满的时候会抛出异常.
buffer:设置jsp文件的缓冲池，默认情况下是8kB.
<span class="token number">4</span>、isELIgnore:判断当前的jsp文件是否忽略EL表达式，如果为false，那么不会忽略，即支持EL表达式
<span class="token number">5</span>、import:用来导包的，可以在指令中设置多个import属性，也可以将多个import的值写到同一个import中，此时各个值需要用逗号分开。
<span class="token number">6</span>、其他:
language:表示当前的jsp文件支持的语言
info:表示信息
isThreadSafe:判断是否支持并发，如果为false，说明不是线程安全，也即支持并发，否则为true，说明线程安全，支持的是单线程。
extends:表示这个jsp文件生成的java文件将会继承extends的值。    
</code></pre> 
<p>这里主要验证errorPage和isErrorPage:</p> 
<pre><code class="prism language-jsp">
&lt;!-- error1.jsp --&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" errorPage="error2.jsp"  language="java"%&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;验证errorPage属性&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%
        /*
        值得注意的是，如果在处理异常的jsp文件中有设置isErrorPage属性为true的时候，
        那么这时候发送500的状态码.
        但是如果我们没有设置isErrorPage的属性，或者值为false的时候，那么就会将发送
        200的状态码。
        所以说明了，某个jsp文件作为errorPage属性的值的时候(即error2.jsp)，这个jsp文件并不一定要求
        设置isErrorPage属性的。但是如果设置了isErrorPage属性为true，那么就可以使用
        jsp中的exception内置对象，否则，如果为false，是不可以使用exception内置对象的。
         */
        int a = 10 / 0;//出现异常，将根据errorPage属性，转发导对应的jsp文件
    %&gt;
&lt;/body&gt;
&lt;/html&gt;

&lt;!-- error2.jsp --&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" isErrorPage="true" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;处理异常的jsp文件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;%
    out.println("使用了isErrorPage内置对象，所以可以使用exception内置对象");
    out.println();
    out.println(exception.toString());
%&gt;
    &lt;h1&gt;这是处理异常的jsp文件，出现异常的jsp文件将会转发导这个jsp文件&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre> 
<p>测试结果:<br> <img src="https://images2.imgbox.com/4f/47/C09PJ9RX_o.png" alt="在这里插入图片描述"><br> 如果我们<strong>在error2.jsp中没有设置isErrorPage的属性为true,那么这时候状态码就是200.</strong></p> 
<p>当然，在web.xml中也可以配置error-page的信息，例如下面的例子：</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!--
    如果jsp文件中发生了java.lang.ArithmeticException，那么就会转发导
    location对应的jsp文件中
    --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exception-type</span><span class="token punctuation">&gt;</span></span>java.lang.ArithmeticException<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exception-type</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span>/jsp/error2.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-page</span><span class="token punctuation">&gt;</span></span>
     <span class="token comment">&lt;!--如果状态码为500，那么转发导jsp目录下的error2.jsp--&gt;</span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>error-code</span><span class="token punctuation">&gt;</span></span>500<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-code</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>location</span><span class="token punctuation">&gt;</span></span>/jsp/error2.jsp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>location</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>error-page</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p><strong>jsp中的include指令是一个静态包含,含有file的属性，对应的值是我们需要请求包含的jsp文件对应的路径.他和requestDispatcher.include的区别是:前者是一个静态包含，并且两个jsp文件将会共同生成一个.java文件，而在requestDispatcher.include中，则是两个servlet对象分别生成2个.java文件，然后将两者的内容进行合并</strong>。</p> 
<p>验证jsp中利用include来静态包含的时候，将2个jsp文件合并到了同一个.java文件中：</p> 
<pre><code class="prism language-jsp">&lt;!-- include1.jsp --&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;学习jsp中的include指令&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;
        jsp中&amp;lt;%@include 属性名=属性值 %&amp;gt;是一个静态包括，&lt;br&gt;
        和requestDispatcher.include的区别是后者是动态包括的。&lt;br&gt;
        并且jsp中的include是将两个jsp文件最后合并成为了一个.java文件,&lt;br&gt;
        而在requestDispatcher.include则是两个jsp文件分别生成对应的.java文件&lt;br&gt;
        然后把两者的结果进行合并的。&lt;br&gt;
    &lt;/p&gt;

    &lt;%
        out.print("这是include1");
    %&gt;
    &lt;%@include file="/jsp/include2.jsp" %&gt; &lt;!--file表示请求包括时对应的jsp文件--&gt;
&lt;/body&gt;
&lt;/html&gt;

&lt;!--include2.jsp--&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;学习jsp中的include指令&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%
        out.print("这是include2");
    %&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre> 
<p>测试结果:<br> <img src="https://images2.imgbox.com/90/31/yFyue5bM_o.png" alt="在这里插入图片描述"><br> 当然在jsp中也有动态标签，例如：</p> 
<ul><li>jsp:include,动态包含，此时<strong>作用和requestDispatcher.include的作用时一样的，并且2个jsp文件分别编译成为.java文件，将内容进行合并而已</strong>。对应的格式为:<pre><code class="prism language-jsp">&lt;jsp:include page="请求包含的jsp文件路径"&gt;
  &lt;!--在这个标签下面，还可以写jsp:param子标签，用于传递参数--&gt;
  &lt;jsp:param name="参数名字" value="参数的值"&gt;&lt;/jsp:param&gt;
&lt;/jsp:include&gt;
</code></pre> </li><li>jsp:forward：用于请求转发，和requestDispatcher.forward的作用一样，同样是<strong>留头不留体</strong>。</li></ul> 
<p>测试jsp:include的代码:</p> 
<pre><code class="prism language-jsp">&lt;!-- include3.jsp --&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;学习jsp中的动态标签&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;
       jsp中使用动态标签格式为：&amp;lt;%@jsp:指令 属性名=属性值 %&amp;gt;&lt;br&gt;
       例如我们需要利用jsp的include是动态包括，那么应该是下面的格式：&lt;br&gt;
       &amp;lt;jsp:include page="包含的jsp文件路径" &amp;gt;&amp;lt;/jsp:include&amp;gt;&lt;br&gt;
        这样这两个jsp文件就是动态包含的关系，分别生成对应的.java文件，然后&lt;br&gt;
        将结果进行合并,这时候requestDispatcher.include是一样的效果的。&lt;br&gt;
        此外在这个标签中还可以添加子标签：jsp:param，用于在请求包括中传递的参数&lt;br&gt;
        &amp;lt;jsp:param name="xxx" value = "yyy" &amp;gt;&lt;br&gt;
    &lt;/p&gt;
    &lt;%
        out.println("这是include3");
    %&gt;
    &lt;jsp:include page="/jsp/include4.jsp"&gt;
        &lt;jsp:param name="username" value="zhangshan"/&gt;
    &lt;/jsp:include&gt;
&lt;/body&gt;
&lt;/html&gt;

&lt;!-- include4.jsp --&gt;
&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;学习jsp中的动态包括&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;%
        String username = request.getParameter("username");
        out.println("这是include4,参数username = " + username);
    %&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>测试结果：<br> <img src="https://images2.imgbox.com/d9/f6/6C69hIPa_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="jsp_191"></a>jsp中的九大内置对象:</h2> 
<pre><code class="prism language-bash">out ---<span class="token operator">&gt;</span>相当于response.getWriter<span class="token punctuation">(</span><span class="token punctuation">)</span>
request ---<span class="token operator">&gt;</span> HttpServletRequest
session ---<span class="token operator">&gt;</span> HttpServletSession
exception ---<span class="token operator">&gt;</span> Throwable
response ---<span class="token operator">&gt;</span> HttpServletResponse
application ---<span class="token operator">&gt;</span> ServletContext
config ---<span class="token operator">&gt;</span> ServletConfig
page ---<span class="token operator">&gt;</span>表示的是当前的jsp文件，可以使用this，是一个Object对象
pageContext ---<span class="token operator">&gt;</span> PageContext，表示的是当前的jsp页面和当前的jsp页面中使用的标签之间共享数据
</code></pre> 
<p>这里主要来将pageContext内置对象。在Servlet中只有三个域对象(request,session,servletContext)，但是在jsp中，则有四个域对象，比Servlet多个了pageContext.所以pageContext也有getAttribute，setAttribute，removeAttribute的方法。</p> 
<ul><li>setAttribute(“xxx”,“xxx_value”,scope)，其中的scope表示对应的域对象，需要利用PageContext获取它的静态成员来获得，例如是在request域中设置，则是PageContext.REQUEST_SCOPE(是一个int类型的值)</li><li>getAttribute(“xxx”,scope):获取scope对应的域对象的xxx的值</li><li>removeAttribute(“xxx”,scope):删除scope对应的域对象中xxx属性</li><li>findAttribute(“xxx”):进行全域查找xxx的值，但是从小到大进行查找，pageContext &lt; request &lt; session &lt; application，所以pageContext会优先查找。</li></ul> 
<p>此外，pageContext含有方法，可以获取其他的8个内置对象。并且pageContext可以获取其他域对象的属性的值,例如getAttribute(“xxx”,“需要获取的域对象名字”),或者setAttribute(“xxx”,“xxx_value”,“其他的域对象”)</p> 
<p>值得注意的是，pageContext还可以进行全域查找findAttribute(“xxx”),从小到大进行查找，如果没有办法在pageContext域中找到xxx的值，那么就会在request中查找，如果还是没有找到，则在session，还是找不到，则在application中。</p> 
<p>⭐由于<strong>pageContext表示的是当前的jsp页面和当前的jsp页面共享标签的值，所以上面中的功能需要保证代理的域对象是在当前的jsp中</strong>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/64ee98d6ed434e441fc637fa3cd10ff9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 开机流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3a0c8ae26dc2499e0069dcdfc6133e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Visual Studio Code安装教程（超详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>