<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android仿斗鱼滑动登录验证 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android仿斗鱼滑动登录验证" />
<meta property="og:description" content="最近事情不是很多,在家无聊的时候看看直播,总能看到一些新奇的验证登录方式,正好自己最近也要去熟悉一下新的开发工具Android Studio,所以打算自己实现一下.
先看一下效果图:
一、确认需求 首先我们确认一下需求,我们分步来看 1.)需要定义一个阴影部分去遮盖图片,确定一个目标位置. 2.)需要一个带有边框的滑块内容,初始位置在最左边. 3.)阴影部分和滑块可以随机旋转,并保持一致. 4.)需要一个拖拽条使滑块随着拖拽条条拖拽而移动 5.)判断是否验证成功
二、分析问题 第一点,很简单我们只需要一直带有透明度的阴影图片,随机的去覆盖在图像上就可以实现. 第二点,需要用到画笔的setXfermode方法来设置图片叠加的显示模式.从而显示出一个带有边框的滑块. 第三点,需要改变图片的matrix来实现对图像的旋转. 第四点,安卓系统自带的SeekBar可以实现拖拽条的功能. 第五点,只需对外提供一个回调接口,来判断是否验证成功即可.
三、代码实现 首先创建一个attr文件来定义一些自定义属性,方便我们使用
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; &lt;resources&gt; &lt;!--滑块的高度--&gt; &lt;attr name=&#34;unitHeight&#34; format=&#34;dimension&#34; /&gt; &lt;!--滑块的宽度--&gt; &lt;attr name=&#34;unitWidth&#34; format=&#34;dimension&#34; /&gt; &lt;!--滑块占图片高度的比例--&gt; &lt;attr name=&#34;unitHeightScale&#34; format=&#34;integer&#34; /&gt; &lt;!--滑块占图片宽度的比例--&gt; &lt;attr name=&#34;unitWidthScale&#34; format=&#34;integer&#34; /&gt; &lt;!--滑块边框的图片资源--&gt; &lt;attr name=&#34;unitShadeSrc&#34; format=&#34;reference&#34; /&gt; &lt;!--阴影部分的图片资源--&gt; &lt;attr name=&#34;unitShowSrc&#34; format=&#34;reference&#34; /&gt; &lt;!--是否需要旋转--&gt; &lt;attr name=&#34;needRotate&#34; format=&#34;boolean&#34; /&gt; &lt;!--验证时的误差值--&gt; &lt;attr name=&#34;deviate&#34; format=&#34;integer&#34; /&gt; &lt;declare-styleable name=&#34;DouYuView&#34;&gt; &lt;attr name=&#34;unitHeight&#34; /&gt; &lt;attr name=&#34;unitWidth&#34; /&gt; &lt;attr name=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c01019b73003e7e0044bc483a22caffb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-04-29T09:53:38+08:00" />
<meta property="article:modified_time" content="2016-04-29T09:53:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android仿斗鱼滑动登录验证</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>最近事情不是很多,在家无聊的时候看看直播,总能看到一些新奇的验证登录方式,正好自己最近也要去熟悉一下新的开发工具Android Studio,所以打算自己实现一下.</p> 
<p>先看一下效果图:</p> 
<p><img src="https://images2.imgbox.com/43/4b/AwiVa5vD_o.gif" alt="这里写图片描述" title=""></p> 
<hr> 
<h4 id="一确认需求">一、确认需求</h4> 
<p>首先我们确认一下需求,我们分步来看 <br> 1.)需要定义一个阴影部分去遮盖图片,确定一个目标位置. <br> 2.)需要一个带有边框的滑块内容,初始位置在最左边. <br> 3.)阴影部分和滑块可以随机旋转,并保持一致. <br> 4.)需要一个拖拽条使滑块随着拖拽条条拖拽而移动 <br> 5.)判断是否验证成功</p> 
<hr> 
<h4 id="二分析问题">二、分析问题</h4> 
<p>第一点,很简单我们只需要一直带有透明度的阴影图片,随机的去覆盖在图像上就可以实现. <br> 第二点,需要用到画笔的setXfermode方法来设置图片叠加的显示模式.从而显示出一个带有边框的滑块. <br> 第三点,需要改变图片的matrix来实现对图像的旋转. <br> 第四点,安卓系统自带的SeekBar可以实现拖拽条的功能. <br> 第五点,只需对外提供一个回调接口,来判断是否验证成功即可.</p> 
<hr> 
<h4 id="三代码实现">三、代码实现</h4> 
<p>首先创建一个attr文件来定义一些自定义属性,方便我们使用</p> 
<pre class="prettyprint"><code class="language-java hljs ">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;
&lt;resources&gt;
    &lt;!--滑块的高度--&gt;
    &lt;attr name=<span class="hljs-string">"unitHeight"</span> format=<span class="hljs-string">"dimension"</span> /&gt;
    &lt;!--滑块的宽度--&gt;
    &lt;attr name=<span class="hljs-string">"unitWidth"</span> format=<span class="hljs-string">"dimension"</span> /&gt;
    &lt;!--滑块占图片高度的比例--&gt;
    &lt;attr name=<span class="hljs-string">"unitHeightScale"</span> format=<span class="hljs-string">"integer"</span> /&gt;
    &lt;!--滑块占图片宽度的比例--&gt;
    &lt;attr name=<span class="hljs-string">"unitWidthScale"</span> format=<span class="hljs-string">"integer"</span> /&gt;
    &lt;!--滑块边框的图片资源--&gt;
    &lt;attr name=<span class="hljs-string">"unitShadeSrc"</span> format=<span class="hljs-string">"reference"</span> /&gt;
    &lt;!--阴影部分的图片资源--&gt;
    &lt;attr name=<span class="hljs-string">"unitShowSrc"</span> format=<span class="hljs-string">"reference"</span> /&gt;
    &lt;!--是否需要旋转--&gt;
    &lt;attr name=<span class="hljs-string">"needRotate"</span> format=<span class="hljs-string">"boolean"</span> /&gt;
    &lt;!--验证时的误差值--&gt;
    &lt;attr name=<span class="hljs-string">"deviate"</span> format=<span class="hljs-string">"integer"</span> /&gt;
    &lt;declare-styleable name=<span class="hljs-string">"DouYuView"</span>&gt;
        &lt;attr name=<span class="hljs-string">"unitHeight"</span> /&gt;
        &lt;attr name=<span class="hljs-string">"unitWidth"</span> /&gt;
        &lt;attr name=<span class="hljs-string">"unitHeightScale"</span> /&gt;
        &lt;attr name=<span class="hljs-string">"unitWidthScale"</span> /&gt;
        &lt;attr name=<span class="hljs-string">"unitShadeSrc"</span> /&gt;
        &lt;attr name=<span class="hljs-string">"unitShowSrc"</span> /&gt;
        &lt;attr name=<span class="hljs-string">"needRotate"</span> /&gt;
        &lt;attr name=<span class="hljs-string">"deviate"</span> /&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;</code></pre> 
<p>然后我们创建一个DouYuView继承自ImageView即可,来定义一下属性</p> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-javadoc">/**
     * 定义画笔
     */</span>
    <span class="hljs-keyword">private</span> Paint mPaint;
    <span class="hljs-javadoc">/**
     * 验证的图像
     */</span>
    <span class="hljs-keyword">private</span> Bitmap mBitmap;
    <span class="hljs-javadoc">/**
     * 验证滑块的高
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUintHeight;
    <span class="hljs-javadoc">/**
     * 验证滑块的宽
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUintWidth;
    <span class="hljs-javadoc">/**
     * 验证滑块宽占用整体图片大小的比例,默认1/5
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUnitWidthScale;
    <span class="hljs-javadoc">/**
     * 验证滑块高度占用整体图片大小的比例,默认1/4
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUnitHeightScale;
    <span class="hljs-javadoc">/**
     * 随机生成滑块的X坐标
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUnitRandomX;
    <span class="hljs-javadoc">/**
     * 随机生成滑块的Y坐标
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUnitRandomY;
    <span class="hljs-javadoc">/***
     * 滑块移动的距离
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> mUnitMoveDistance = <span class="hljs-number">0</span>;
    <span class="hljs-javadoc">/***
     * 滑块图像
     */</span>
    <span class="hljs-keyword">private</span> Bitmap mUnitBp;
    <span class="hljs-javadoc">/**
     * 验证位置图像
     */</span>
    <span class="hljs-keyword">private</span> Bitmap mShowBp;
    <span class="hljs-javadoc">/**
     * 背景阴影图像
     */</span>
    <span class="hljs-keyword">private</span> Bitmap mShadeBp;
    <span class="hljs-javadoc">/**
     * 是否需要旋转
     **/</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> needRotate;
    <span class="hljs-javadoc">/**
     * 旋转的角度
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rotate;
    <span class="hljs-javadoc">/**
     * 判断是否完成的偏差量，默认为10
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> DEFAULT_DEVIATE;
    <span class="hljs-javadoc">/**
     * 判断是否重新绘制图像
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isReSet = <span class="hljs-keyword">true</span>;
</code></pre> 
<p>准备好这些之后,开始实现具体功能,这次我们打算用星星的图片,来设置阴影和滑块,首先我们准备两张图片,如下图(注意,带边框的图片中间部分,使用白色填充的):</p> 
<p><img src="https://images2.imgbox.com/54/e3/k38mUBCr_o.png" alt="阴影星星" title=""> <br> <img src="https://images2.imgbox.com/59/66/QJK9ophN_o.png" alt="边框星星" title=""></p> 
<p>为了使图片不会出现变形等异常,我们需要对图片进行获取及缩放的一些操作,代码如下:</p> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-javadoc">/**
     * 获取实际显示的图片
     *
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> Bitmap <span class="hljs-title">getBaseBitmap</span>() {
        Bitmap b = drawableToBitamp(getDrawable());
        <span class="hljs-keyword">float</span> scaleX = <span class="hljs-number">1.0</span>f;
        <span class="hljs-keyword">float</span> scaleY = <span class="hljs-number">1.0</span>f;
        <span class="hljs-comment">// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；</span>
        scaleX = getWidth() * <span class="hljs-number">1.0</span>f / b.getWidth();
        scaleY = getHeight() * <span class="hljs-number">1.0</span>f / b.getHeight();
        Matrix matrix = <span class="hljs-keyword">new</span> Matrix();
        matrix.setScale(scaleX, scaleY);
        Bitmap bd = Bitmap.createBitmap(b, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, b.getWidth(), b.getHeight(),
                matrix, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> bd;
    }

    <span class="hljs-javadoc">/**
     * drawable转bitmap
     *
     *<span class="hljs-javadoctag"> @param</span> drawable
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">drawableToBitamp</span>(Drawable drawable) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == drawable) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">if</span> (drawable <span class="hljs-keyword">instanceof</span> BitmapDrawable) {
            BitmapDrawable bd = (BitmapDrawable) drawable;
            <span class="hljs-keyword">return</span> bd.getBitmap();
        }
        <span class="hljs-keyword">int</span> w = drawable.getIntrinsicWidth();
        <span class="hljs-keyword">int</span> h = drawable.getIntrinsicHeight();
        Bitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
        Canvas canvas = <span class="hljs-keyword">new</span> Canvas(bitmap);
        drawable.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w, h);
        drawable.draw(canvas);
        <span class="hljs-keyword">return</span> bitmap;
    }

    <span class="hljs-javadoc">/**
     * 缩放图片
     *
     *<span class="hljs-javadoctag"> @param</span> bp
     *<span class="hljs-javadoctag"> @param</span> x
     *<span class="hljs-javadoctag"> @param</span> y
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">handleBitmap</span>(Bitmap bp, <span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y) {
        <span class="hljs-keyword">int</span> w = bp.getWidth();
        <span class="hljs-keyword">int</span> h = bp.getHeight();
        <span class="hljs-keyword">float</span> sx = (<span class="hljs-keyword">float</span>) x / w;
        <span class="hljs-keyword">float</span> sy = (<span class="hljs-keyword">float</span>) y / h;
        Matrix matrix = <span class="hljs-keyword">new</span> Matrix();
        matrix.postScale(sx, sy);
        Bitmap resizeBmp = Bitmap.createBitmap(bp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w,
                h, matrix, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> resizeBmp;
    }</code></pre> 
<p>然后再去生成阴影图像和滑块</p> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-javadoc">/**
     * 创建遮挡的图片(阴影部分)
     *
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">drawTargetBitmap</span>() {
        <span class="hljs-comment">// 绘制图片</span>
        Bitmap showB;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mShowBp) {
            showB = handleBitmap(mShowBp, mUintWidth, mUintHeight);
        } <span class="hljs-keyword">else</span> {
            showB = handleBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.puzzle_show), mUintWidth, mUintHeight);
        }
        <span class="hljs-comment">// 如果需要旋转图片,进行旋转，旋转后为了保持和滑块大小一致,需要重新缩放比例</span>
        <span class="hljs-keyword">if</span> (needRotate) {
            showB = handleBitmap(rotateBitmap(rotate, showB), mUintWidth, mUintHeight);
        }
        <span class="hljs-keyword">return</span> showB;
    }

    <span class="hljs-javadoc">/**
     * 创建结合的图片(滑块)
     *
     *<span class="hljs-javadoctag"> @param</span> bp
     */</span>
    <span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">drawResultBitmap</span>(Bitmap bp) {
        <span class="hljs-comment">// 绘制图片</span>
        Bitmap shadeB;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mShadeBp) {
            shadeB = handleBitmap(mShadeBp, mUintWidth, mUintHeight);
        } <span class="hljs-keyword">else</span> {
            shadeB = handleBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.puzzle_shade), mUintWidth, mUintHeight);
        }
        <span class="hljs-comment">// 如果需要旋转图片,进行旋转,旋转后为了和画布大小保持一致,避免出现图像显示不全,需要重新缩放比例</span>
        <span class="hljs-keyword">if</span> (needRotate) {
            shadeB = handleBitmap(rotateBitmap(rotate, shadeB), mUintWidth, mUintHeight);
        }
        Bitmap resultBmp = Bitmap.createBitmap(mUintWidth, mUintHeight,
                Bitmap.Config.ARGB_8888);
        Paint paint = <span class="hljs-keyword">new</span> Paint();
        paint.setAntiAlias(<span class="hljs-keyword">true</span>);
        Canvas canvas = <span class="hljs-keyword">new</span> Canvas(resultBmp);
        canvas.drawBitmap(shadeB, <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mUintWidth, mUintHeight),
                <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mUintWidth, mUintHeight), paint);
        <span class="hljs-comment">// 选择交集去上层图片</span>
        paint.setXfermode(<span class="hljs-keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));
        canvas.drawBitmap(bp, <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mUintWidth, mUintHeight),
                <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mUintWidth, mUintHeight), paint);
        <span class="hljs-keyword">return</span> resultBmp;
    }
</code></pre> 
<p>准备好这些之后,还需要随机生成一个显示位置和对图像进行旋转的方法就可以在画布上去画出这些内容,代码如下:</p> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-javadoc">/**
     * 随机生成生成滑块的XY坐标
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initUnitXY</span>() {
        mUnitRandomX = (<span class="hljs-keyword">int</span>) (Math.random() * (mBitmap.getWidth() - mUintWidth));
        mUnitRandomY = (<span class="hljs-keyword">int</span>) (Math.random() * (mBitmap.getHeight() - mUintHeight));
        <span class="hljs-comment">// 防止生成的位置距离太近</span>
        <span class="hljs-keyword">if</span> (mUnitRandomX &lt;= mBitmap.getWidth() / <span class="hljs-number">2</span>) {
            mUnitRandomX = mUnitRandomX + mBitmap.getWidth() / <span class="hljs-number">4</span>;
        }
        <span class="hljs-comment">// 防止生成的X坐标截图时导致异常</span>
        <span class="hljs-keyword">if</span> (mUnitRandomX + mUintWidth &gt; getWidth()) {
            initUnitXY();
            <span class="hljs-keyword">return</span>;
        }
    }

    <span class="hljs-javadoc">/**
     * 旋转图片
     *
     *<span class="hljs-javadoctag"> @param</span> degree
     *<span class="hljs-javadoctag"> @param</span> bitmap
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> Bitmap <span class="hljs-title">rotateBitmap</span>(<span class="hljs-keyword">int</span> degree, Bitmap bitmap) {
        Matrix matrix = <span class="hljs-keyword">new</span> Matrix();
        matrix.postRotate(degree);
        Bitmap bm = Bitmap.createBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bitmap.getWidth(),
                bitmap.getHeight(), matrix, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> bm;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span>(Canvas canvas) {
        <span class="hljs-keyword">super</span>.onDraw(canvas);
        <span class="hljs-keyword">if</span> (isReSet) {
            mBitmap = getBaseBitmap();
            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == mUintWidth) {
                mUintWidth = mBitmap.getWidth() / mUnitWidthScale;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == mUintHeight) {
                mUintHeight = mBitmap.getHeight() / mUnitHeightScale;
            }
            initUnitXY();
            mUnitBp = Bitmap.createBitmap(mBitmap, mUnitRandomX, mUnitRandomY, mUintWidth, mUintHeight);
        }
        isReSet = <span class="hljs-keyword">false</span>;
        canvas.drawBitmap(drawTargetBitmap(), mUnitRandomX, mUnitRandomY, mPaint);
        canvas.drawBitmap(drawResultBitmap(mUnitBp), mUnitMoveDistance, mUnitRandomY, mPaint);
    }
</code></pre> 
<p>我们还需要对控件进行重置、控制滑块移动、提供回调方法判断验证是否成功等方法.</p> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-javadoc">/**
     * 重置
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reSet</span>() {
        isReSet = <span class="hljs-keyword">true</span>;
        mUnitMoveDistance = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (needRotate) {
            rotate = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">3</span>) * <span class="hljs-number">90</span>;
        } <span class="hljs-keyword">else</span> {
            rotate = <span class="hljs-number">0</span>;
        }
        invalidate();
    }

    <span class="hljs-javadoc">/**
     * 获取每次滑动的平均偏移值
     *
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getAverageDistance</span>(<span class="hljs-keyword">int</span> max) {
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">float</span>) (mBitmap.getWidth() - mUintWidth) / max;
    }


    <span class="hljs-javadoc">/**
     * 滑块移动距离
     *
     *<span class="hljs-javadoctag"> @param</span> distance
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUnitMoveDistance</span>(<span class="hljs-keyword">float</span> distance) {
        mUnitMoveDistance = distance;
        <span class="hljs-comment">// 防止滑块滑出图片</span>
        <span class="hljs-keyword">if</span> (mUnitMoveDistance &gt; mBitmap.getWidth() - mUintWidth) {
            mUnitMoveDistance = mBitmap.getWidth() - mUintWidth;
        }
        invalidate();

    }
        <span class="hljs-javadoc">/**
     * 拼图成功的回调
     **/</span>
    interface onPuzzleListener {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span>();

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFail</span>();
    }

    <span class="hljs-javadoc">/**
     * 回调
     */</span>
    <span class="hljs-keyword">private</span> onPuzzleListener mlistener;

    <span class="hljs-javadoc">/**
     * 设置回调
     *
     *<span class="hljs-javadoctag"> @param</span> listener
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPuzzleListener</span>(onPuzzleListener listener) {
        <span class="hljs-keyword">this</span>.mlistener = listener;
    }
        <span class="hljs-javadoc">/**
     * 验证是否拼接成功
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPuzzle</span>() {
        <span class="hljs-keyword">if</span> (Math.abs(mUnitMoveDistance - mUnitRandomX) &lt;= DEFAULT_DEVIATE) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mlistener) {
                mlistener.onSuccess();
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mlistener) {
                mlistener.onFail();
            }
        }
    }</code></pre> 
<p>基本上我们需要的功能就实现了.</p> 
<hr> 
<h4 id="四完整的代码及使用">四、完整的代码及使用</h4> 
<p>DouYuView:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> com.example.junweiliu.douyutest;

<span class="hljs-keyword">import</span> android.content.Context;
<span class="hljs-keyword">import</span> android.content.res.TypedArray;
<span class="hljs-keyword">import</span> android.graphics.Bitmap;
<span class="hljs-keyword">import</span> android.graphics.BitmapFactory;
<span class="hljs-keyword">import</span> android.graphics.Canvas;
<span class="hljs-keyword">import</span> android.graphics.Matrix;
<span class="hljs-keyword">import</span> android.graphics.Paint;
<span class="hljs-keyword">import</span> android.graphics.PorterDuff;
<span class="hljs-keyword">import</span> android.graphics.PorterDuffXfermode;
<span class="hljs-keyword">import</span> android.graphics.Rect;
<span class="hljs-keyword">import</span> android.graphics.RectF;
<span class="hljs-keyword">import</span> android.graphics.drawable.BitmapDrawable;
<span class="hljs-keyword">import</span> android.graphics.drawable.Drawable;
<span class="hljs-keyword">import</span> android.util.AttributeSet;
<span class="hljs-keyword">import</span> android.util.Log;
<span class="hljs-keyword">import</span> android.widget.ImageView;

<span class="hljs-javadoc">/**
 * Created by junweiliu on 16/4/26.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DouYuView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImageView</span> {<!-- --></span>
    <span class="hljs-javadoc">/**
     * 定义画笔
     */</span>
    <span class="hljs-keyword">private</span> Paint mPaint;
    <span class="hljs-javadoc">/**
     * 验证的图像
     */</span>
    <span class="hljs-keyword">private</span> Bitmap mBitmap;
    <span class="hljs-javadoc">/**
     * 验证滑块的高
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUintHeight;
    <span class="hljs-javadoc">/**
     * 验证滑块的宽
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUintWidth;
    <span class="hljs-javadoc">/**
     * 验证滑块宽占用整体图片大小的比例,默认1/5
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUnitWidthScale;
    <span class="hljs-javadoc">/**
     * 验证滑块高度占用整体图片大小的比例,默认1/4
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUnitHeightScale;
    <span class="hljs-javadoc">/**
     * 随机生成滑块的X坐标
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUnitRandomX;
    <span class="hljs-javadoc">/**
     * 随机生成滑块的Y坐标
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mUnitRandomY;
    <span class="hljs-javadoc">/***
     * 滑块移动的距离
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> mUnitMoveDistance = <span class="hljs-number">0</span>;
    <span class="hljs-javadoc">/***
     * 滑块图像
     */</span>
    <span class="hljs-keyword">private</span> Bitmap mUnitBp;
    <span class="hljs-javadoc">/**
     * 验证位置图像
     */</span>
    <span class="hljs-keyword">private</span> Bitmap mShowBp;
    <span class="hljs-javadoc">/**
     * 背景阴影图像
     */</span>
    <span class="hljs-keyword">private</span> Bitmap mShadeBp;
    <span class="hljs-javadoc">/**
     * 是否需要旋转
     **/</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> needRotate;
    <span class="hljs-javadoc">/**
     * 旋转的角度
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rotate;
    <span class="hljs-javadoc">/**
     * 判断是否完成的偏差量，默认为10
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> DEFAULT_DEVIATE;
    <span class="hljs-javadoc">/**
     * 判断是否重新绘制图像
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isReSet = <span class="hljs-keyword">true</span>;

    <span class="hljs-javadoc">/**
     * 拼图成功的回调
     **/</span>
    interface onPuzzleListener {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span>();

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFail</span>();
    }

    <span class="hljs-javadoc">/**
     * 回调
     */</span>
    <span class="hljs-keyword">private</span> onPuzzleListener mlistener;

    <span class="hljs-javadoc">/**
     * 设置回调
     *
     *<span class="hljs-javadoctag"> @param</span> listener
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPuzzleListener</span>(onPuzzleListener listener) {
        <span class="hljs-keyword">this</span>.mlistener = listener;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">DouYuView</span>(Context context) {
        <span class="hljs-keyword">this</span>(context, <span class="hljs-keyword">null</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">DouYuView</span>(Context context, AttributeSet attrs) {
        <span class="hljs-keyword">this</span>(context, attrs, <span class="hljs-number">0</span>);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">DouYuView</span>(Context context, AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr) {
        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);
        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.DouYuView);
        mUintWidth = ta.getDimensionPixelOffset(R.styleable.DouYuView_unitHeight, <span class="hljs-number">0</span>);
        mUintHeight = ta.getDimensionPixelOffset(R.styleable.DouYuView_unitHeight, <span class="hljs-number">0</span>);
        mUnitHeightScale = ta.getInteger(R.styleable.DouYuView_unitHeightScale, <span class="hljs-number">4</span>);
        mUnitWidthScale = ta.getInteger(R.styleable.DouYuView_unitWidthScale, <span class="hljs-number">5</span>);
        Drawable showBp = ta.getDrawable(R.styleable.DouYuView_unitShowSrc);
        mShowBp = drawableToBitamp(showBp);
        Drawable shadeBp = ta.getDrawable(R.styleable.DouYuView_unitShadeSrc);
        mShadeBp = drawableToBitamp(shadeBp);
        needRotate = ta.getBoolean(R.styleable.DouYuView_needRotate, <span class="hljs-keyword">true</span>);
        DEFAULT_DEVIATE = ta.getInteger(R.styleable.DouYuView_deviate, <span class="hljs-number">10</span>);
        ta.recycle();
        <span class="hljs-comment">// 初始化</span>
        mPaint = <span class="hljs-keyword">new</span> Paint();
        mPaint.setAntiAlias(<span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">if</span> (needRotate) {
            rotate = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">3</span>) * <span class="hljs-number">90</span>;
        } <span class="hljs-keyword">else</span> {
            rotate = <span class="hljs-number">0</span>;
        }
    }


    <span class="hljs-javadoc">/**
     * 随机生成生成滑块的XY坐标
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initUnitXY</span>() {
        mUnitRandomX = (<span class="hljs-keyword">int</span>) (Math.random() * (mBitmap.getWidth() - mUintWidth));
        mUnitRandomY = (<span class="hljs-keyword">int</span>) (Math.random() * (mBitmap.getHeight() - mUintHeight));
        <span class="hljs-comment">// 防止生成的位置距离太近</span>
        <span class="hljs-keyword">if</span> (mUnitRandomX &lt;= mBitmap.getWidth() / <span class="hljs-number">2</span>) {
            mUnitRandomX = mUnitRandomX + mBitmap.getWidth() / <span class="hljs-number">4</span>;
        }
        <span class="hljs-comment">// 防止生成的X坐标截图时导致异常</span>
        <span class="hljs-keyword">if</span> (mUnitRandomX + mUintWidth &gt; getWidth()) {
            initUnitXY();
            <span class="hljs-keyword">return</span>;
        }
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span>(Canvas canvas) {
        <span class="hljs-keyword">super</span>.onDraw(canvas);
        <span class="hljs-keyword">if</span> (isReSet) {
            mBitmap = getBaseBitmap();
            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == mUintWidth) {
                mUintWidth = mBitmap.getWidth() / mUnitWidthScale;
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == mUintHeight) {
                mUintHeight = mBitmap.getHeight() / mUnitHeightScale;
            }
            initUnitXY();
            mUnitBp = Bitmap.createBitmap(mBitmap, mUnitRandomX, mUnitRandomY, mUintWidth, mUintHeight);
        }
        isReSet = <span class="hljs-keyword">false</span>;
        canvas.drawBitmap(drawTargetBitmap(), mUnitRandomX, mUnitRandomY, mPaint);
        canvas.drawBitmap(drawResultBitmap(mUnitBp), mUnitMoveDistance, mUnitRandomY, mPaint);
    }

    <span class="hljs-javadoc">/**
     * 重置
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reSet</span>() {
        isReSet = <span class="hljs-keyword">true</span>;
        mUnitMoveDistance = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (needRotate) {
            rotate = (<span class="hljs-keyword">int</span>) (Math.random() * <span class="hljs-number">3</span>) * <span class="hljs-number">90</span>;
        } <span class="hljs-keyword">else</span> {
            rotate = <span class="hljs-number">0</span>;
        }
        invalidate();
    }

    <span class="hljs-javadoc">/**
     * 获取每次滑动的平均偏移值
     *
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getAverageDistance</span>(<span class="hljs-keyword">int</span> max) {
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">float</span>) (mBitmap.getWidth() - mUintWidth) / max;
    }


    <span class="hljs-javadoc">/**
     * 滑块移动距离
     *
     *<span class="hljs-javadoctag"> @param</span> distance
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUnitMoveDistance</span>(<span class="hljs-keyword">float</span> distance) {
        mUnitMoveDistance = distance;
        <span class="hljs-comment">// 防止滑块滑出图片</span>
        <span class="hljs-keyword">if</span> (mUnitMoveDistance &gt; mBitmap.getWidth() - mUintWidth) {
            mUnitMoveDistance = mBitmap.getWidth() - mUintWidth;
        }
        invalidate();

    }

    <span class="hljs-javadoc">/**
     * 验证是否拼接成功
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPuzzle</span>() {
        <span class="hljs-keyword">if</span> (Math.abs(mUnitMoveDistance - mUnitRandomX) &lt;= DEFAULT_DEVIATE) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mlistener) {
                mlistener.onSuccess();
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mlistener) {
                mlistener.onFail();
            }
        }
    }

    <span class="hljs-javadoc">/**
     * 创建遮挡的图片(阴影部分)
     *
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">drawTargetBitmap</span>() {
        <span class="hljs-comment">// 绘制图片</span>
        Bitmap showB;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mShowBp) {
            showB = handleBitmap(mShowBp, mUintWidth, mUintHeight);
        } <span class="hljs-keyword">else</span> {
            showB = handleBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.puzzle_show), mUintWidth, mUintHeight);
        }
        <span class="hljs-comment">// 如果需要旋转图片,进行旋转，旋转后为了保持和滑块大小一致,需要重新缩放比例</span>
        <span class="hljs-keyword">if</span> (needRotate) {
            showB = handleBitmap(rotateBitmap(rotate, showB), mUintWidth, mUintHeight);
        }
        <span class="hljs-keyword">return</span> showB;
    }

    <span class="hljs-javadoc">/**
     * 创建结合的图片(滑块)
     *
     *<span class="hljs-javadoctag"> @param</span> bp
     */</span>
    <span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">drawResultBitmap</span>(Bitmap bp) {
        <span class="hljs-comment">// 绘制图片</span>
        Bitmap shadeB;
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != mShadeBp) {
            shadeB = handleBitmap(mShadeBp, mUintWidth, mUintHeight);
        } <span class="hljs-keyword">else</span> {
            shadeB = handleBitmap(BitmapFactory.decodeResource(getResources(), R.mipmap.puzzle_shade), mUintWidth, mUintHeight);
        }
        <span class="hljs-comment">// 如果需要旋转图片,进行旋转,旋转后为了和画布大小保持一致,避免出现图像显示不全,需要重新缩放比例</span>
        <span class="hljs-keyword">if</span> (needRotate) {
            shadeB = handleBitmap(rotateBitmap(rotate, shadeB), mUintWidth, mUintHeight);
        }
        Bitmap resultBmp = Bitmap.createBitmap(mUintWidth, mUintHeight,
                Bitmap.Config.ARGB_8888);
        Paint paint = <span class="hljs-keyword">new</span> Paint();
        paint.setAntiAlias(<span class="hljs-keyword">true</span>);
        Canvas canvas = <span class="hljs-keyword">new</span> Canvas(resultBmp);
        canvas.drawBitmap(shadeB, <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mUintWidth, mUintHeight),
                <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mUintWidth, mUintHeight), paint);
        <span class="hljs-comment">// 选择交集去上层图片</span>
        paint.setXfermode(<span class="hljs-keyword">new</span> PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));
        canvas.drawBitmap(bp, <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mUintWidth, mUintHeight),
                <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mUintWidth, mUintHeight), paint);
        <span class="hljs-keyword">return</span> resultBmp;
    }

    <span class="hljs-javadoc">/**
     * 获取实际显示的图片
     *
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> Bitmap <span class="hljs-title">getBaseBitmap</span>() {
        Bitmap b = drawableToBitamp(getDrawable());
        <span class="hljs-keyword">float</span> scaleX = <span class="hljs-number">1.0</span>f;
        <span class="hljs-keyword">float</span> scaleY = <span class="hljs-number">1.0</span>f;
        <span class="hljs-comment">// 如果图片的宽或者高与view的宽高不匹配，计算出需要缩放的比例；缩放后的图片的宽高，一定要大于我们view的宽高；所以我们这里取大值；</span>
        scaleX = getWidth() * <span class="hljs-number">1.0</span>f / b.getWidth();
        scaleY = getHeight() * <span class="hljs-number">1.0</span>f / b.getHeight();
        Matrix matrix = <span class="hljs-keyword">new</span> Matrix();
        matrix.setScale(scaleX, scaleY);
        Bitmap bd = Bitmap.createBitmap(b, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, b.getWidth(), b.getHeight(),
                matrix, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> bd;
    }

    <span class="hljs-javadoc">/**
     * drawable转bitmap
     *
     *<span class="hljs-javadoctag"> @param</span> drawable
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">private</span> Bitmap <span class="hljs-title">drawableToBitamp</span>(Drawable drawable) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == drawable) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">if</span> (drawable <span class="hljs-keyword">instanceof</span> BitmapDrawable) {
            BitmapDrawable bd = (BitmapDrawable) drawable;
            <span class="hljs-keyword">return</span> bd.getBitmap();
        }
        <span class="hljs-keyword">int</span> w = drawable.getIntrinsicWidth();
        <span class="hljs-keyword">int</span> h = drawable.getIntrinsicHeight();
        Bitmap bitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
        Canvas canvas = <span class="hljs-keyword">new</span> Canvas(bitmap);
        drawable.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w, h);
        drawable.draw(canvas);
        <span class="hljs-keyword">return</span> bitmap;
    }

    <span class="hljs-javadoc">/**
     * 缩放图片
     *
     *<span class="hljs-javadoctag"> @param</span> bp
     *<span class="hljs-javadoctag"> @param</span> x
     *<span class="hljs-javadoctag"> @param</span> y
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Bitmap <span class="hljs-title">handleBitmap</span>(Bitmap bp, <span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y) {
        <span class="hljs-keyword">int</span> w = bp.getWidth();
        <span class="hljs-keyword">int</span> h = bp.getHeight();
        <span class="hljs-keyword">float</span> sx = (<span class="hljs-keyword">float</span>) x / w;
        <span class="hljs-keyword">float</span> sy = (<span class="hljs-keyword">float</span>) y / h;
        Matrix matrix = <span class="hljs-keyword">new</span> Matrix();
        matrix.postScale(sx, sy);
        Bitmap resizeBmp = Bitmap.createBitmap(bp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w,
                h, matrix, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> resizeBmp;
    }

    <span class="hljs-javadoc">/**
     * 旋转图片
     *
     *<span class="hljs-javadoctag"> @param</span> degree
     *<span class="hljs-javadoctag"> @param</span> bitmap
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">public</span> Bitmap <span class="hljs-title">rotateBitmap</span>(<span class="hljs-keyword">int</span> degree, Bitmap bitmap) {
        Matrix matrix = <span class="hljs-keyword">new</span> Matrix();
        matrix.postRotate(degree);
        Bitmap bm = Bitmap.createBitmap(bitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bitmap.getWidth(),
                bitmap.getHeight(), matrix, <span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> bm;
    }
}</code></pre> 
<p>MainActivity:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> com.example.junweiliu.douyutest;

<span class="hljs-keyword">import</span> android.app.Activity;
<span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;
<span class="hljs-keyword">import</span> android.os.Bundle;
<span class="hljs-keyword">import</span> android.util.Log;
<span class="hljs-keyword">import</span> android.widget.SeekBar;
<span class="hljs-keyword">import</span> android.widget.Toast;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> {<!-- --></span>

    <span class="hljs-javadoc">/**
     * 滑块
     */</span>
    <span class="hljs-keyword">private</span> SeekBar mSeekBar;
    <span class="hljs-javadoc">/**
     * 自定义的控件
     */</span>
    <span class="hljs-keyword">private</span> DouYuView mDY;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState) {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initView</span>() {
        mDY = (DouYuView) findViewById(R.id.dy_v);
        mSeekBar = (SeekBar) findViewById(R.id.sb_dy);
        mSeekBar.setOnSeekBarChangeListener(<span class="hljs-keyword">new</span> SeekBar.OnSeekBarChangeListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onProgressChanged</span>(SeekBar seekBar, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">boolean</span> b) {
<span class="hljs-comment">//                Log.e("main", "当前位置" + i);</span>
                mDY.setUnitMoveDistance(mDY.getAverageDistance(seekBar.getMax()) * i);
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartTrackingTouch</span>(SeekBar seekBar) {

            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStopTrackingTouch</span>(SeekBar seekBar) {
                mDY.testPuzzle();
            }
        });
        mDY.setPuzzleListener(<span class="hljs-keyword">new</span> DouYuView.onPuzzleListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span>() {
<span class="hljs-comment">//                mSeekBar.setEnabled(false);</span>
                Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>, <span class="hljs-string">"验证成功"</span>, Toast.LENGTH_SHORT).show();
                mSeekBar.setProgress(<span class="hljs-number">0</span>);
                mDY.reSet();
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFail</span>() {
                Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>, <span class="hljs-string">"验证失败"</span>, Toast.LENGTH_SHORT).show();
                mSeekBar.setProgress(<span class="hljs-number">0</span>);
            }
        });
    }
}
</code></pre> 
<p>xml:</p> 
<pre class="prettyprint"><code class="language-java hljs ">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span>?&gt;
&lt;LinearLayout xmlns:android=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>
    xmlns:dy=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>
    xmlns:tools=<span class="hljs-string">"http://schemas.android.com/tools"</span>
    android:layout_width=<span class="hljs-string">"match_parent"</span>
    android:layout_height=<span class="hljs-string">"match_parent"</span>
    android:gravity=<span class="hljs-string">"center"</span>
    android:orientation=<span class="hljs-string">"vertical"</span>
    android:paddingBottom=<span class="hljs-string">"@dimen/activity_vertical_margin"</span>
    android:paddingLeft=<span class="hljs-string">"@dimen/activity_horizontal_margin"</span>
    android:paddingRight=<span class="hljs-string">"@dimen/activity_horizontal_margin"</span>
    android:paddingTop=<span class="hljs-string">"@dimen/activity_vertical_margin"</span>
    tools:context=<span class="hljs-string">"com.example.junweiliu.douyutest.MainActivity"</span>&gt;

    &lt;com.example.junweiliu.douyutest.DouYuView
        android:id=<span class="hljs-string">"@+id/dy_v"</span>
        android:layout_width=<span class="hljs-string">"wrap_content"</span>
        android:layout_height=<span class="hljs-string">"wrap_content"</span>
        android:layout_marginBottom=<span class="hljs-string">"10dp"</span>
        android:src=<span class="hljs-string">"@mipmap/test"</span>
        dy:unitHeight=<span class="hljs-string">"60dp"</span>
        dy:unitWidth=<span class="hljs-string">"80dp"</span>
        dy:unitShowSrc=<span class="hljs-string">"@mipmap/star_show"</span>
        dy:unitShadeSrc=<span class="hljs-string">"@mipmap/star_shade"</span>
        dy:needRotate=<span class="hljs-string">"true"</span> /&gt;

    &lt;SeekBar
        android:id=<span class="hljs-string">"@+id/sb_dy"</span>
        android:layout_width=<span class="hljs-string">"match_parent"</span>
        android:layout_height=<span class="hljs-string">"wrap_content"</span>
        android:max=<span class="hljs-string">"100"</span> /&gt;
&lt;/LinearLayout&gt;</code></pre> 
<p>实现的效果图如下:</p> 
<p><img src="https://images2.imgbox.com/30/1d/0sJXA1VT_o.gif" alt="这里写图片描述" title=""></p> 
<p><a href="http://download.csdn.net/detail/u013904672/9506717">下载地址</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/765b72482b0e6e29bdc114f366173295/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">快速认识和使用浏览器跟踪Http服务及Http服务调试工具</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4b396f5a85e13fb05ae3fd8eb5922881/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Partition深度解析&amp;一致性hash</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>