<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android限制EditText只能输入中文或者指定内容的实现 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android限制EditText只能输入中文或者指定内容的实现" />
<meta property="og:description" content="最近项目中要限制EditText中只能输入中文,之前写过一个限制EditText只能输入中文的实现,不过存在一些问题,而且扩展性不是很好,所以换了一种方法来实现. 先看一下效果图:
具体实现 一般对EditText的操作及处理都是用addTextChangedListener方法来对EditText进行监听,之后在监听方法中去做处理.这里也打算用这个种方法来做,大体的思路是监听EditText中输入的内容,然后将不是中文的部分清除掉,也就是置为空.所以大概应该这样写
mLimitEt.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { // 1.处理输入的内容s:清除其中不是中文的部分 ... // 2.设置处理完的s mLimitEt.setText(&#34;处理之后的s&#34;); } @Override public void afterTextChanged(Editable s) { } }); 处理的方法这里先不写,先来看一下这样写会出现的一个问题,运行一下,输入一些内容会发现程序崩溃了,查看崩溃信息,会发现出现了StackOverflowError异常,这是什么原因呢?带着疑问去扒了一下源码(看源码时遇到一个问题,升级完Studio之后,发现无法查看源码了,查了一些资料解决了,也有相同问题的童鞋可以参考下我写的 Mac版Android Studio查看不到源码的解决方法,windows版解决方法也类似)出现异常的位置在 mLimitEt.setText()这句代码上,所以先看一下setText()方法.setText方法在TextView中,看一下实现(这里只关心引起异常的部分,其他部分的内容不讨论)
private void setText(CharSequence text, BufferType type, boolean notifyBefore, int oldlen) { ... // Text改变前的回调处理 sendBeforeTextChanged(mText, 0, oldlen, text.length()); ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1fc71a858d30320f79e847ceaf7d8928/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-10T15:52:49+08:00" />
<meta property="article:modified_time" content="2017-01-10T15:52:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android限制EditText只能输入中文或者指定内容的实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>最近项目中要限制EditText中只能输入中文,之前写过一个限制EditText只能输入中文的实现,不过存在一些问题,而且扩展性不是很好,所以换了一种方法来实现. <br> 先看一下效果图:</p> 
<p><img src="https://images2.imgbox.com/63/16/xT7XcTZY_o.gif" alt="这里写图片描述" title=""></p> 
<hr> 
<h3 id="具体实现">具体实现</h3> 
<p>一般对EditText的操作及处理都是用addTextChangedListener方法来对EditText进行监听,之后在监听方法中去做处理.这里也打算用这个种方法来做,大体的思路是<font color="red">监听EditText中输入的内容,然后将不是中文的部分清除掉,也就是置为空.</font>所以大概应该这样写</p> 
<pre class="prettyprint"><code class="language-java hljs "> mLimitEt.addTextChangedListener(<span class="hljs-keyword">new</span> TextWatcher() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTextChanged</span>(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> after) {

            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTextChanged</span>(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> before, <span class="hljs-keyword">int</span> count) {
            <span class="hljs-comment">// 1.处理输入的内容s:清除其中不是中文的部分</span>
            ...
            <span class="hljs-comment">// 2.设置处理完的s</span>
            mLimitEt.setText(<span class="hljs-string">"处理之后的s"</span>);
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTextChanged</span>(Editable s) {

            }
        });</code></pre> 
<p>处理的方法这里先不写,先来看一下这样写会出现的一个问题,运行一下,输入一些内容会发现程序崩溃了,查看崩溃信息,会发现出现了StackOverflowError异常,这是什么原因呢?带着疑问去扒了一下源码(看源码时遇到一个问题,升级完Studio之后,发现无法查看源码了,查了一些资料解决了,也有相同问题的童鞋可以参考下我写的<a href="http://blog.csdn.net/u013904672/article/details/54174347"> Mac版Android Studio查看不到源码的解决方法</a>,windows版解决方法也类似)出现异常的位置在 mLimitEt.setText()这句代码上,所以先看一下setText()方法.setText方法在TextView中,看一下实现(这里只关心引起异常的部分,其他部分的内容不讨论)</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setText</span>(CharSequence text, BufferType type,
                         <span class="hljs-keyword">boolean</span> notifyBefore, <span class="hljs-keyword">int</span> oldlen) {
   ...
   <span class="hljs-comment">// Text改变前的回调处理</span>
   sendBeforeTextChanged(mText, <span class="hljs-number">0</span>, oldlen, text.length());
   ...
   <span class="hljs-comment">// Text改变中的回调处理</span>
   sendOnTextChanged(text, <span class="hljs-number">0</span>, oldlen, textLength);
   ...
   <span class="hljs-comment">// Text改变后的回调处理</span>
   sendAfterTextChanged((Editable) text); 

}</code></pre> 
<p>在setText方法中可以看到这几个方法,然后看一下这些方法做的处理是什么</p> 
<pre class="prettyprint"><code class="language-java hljs ">     <span class="hljs-javadoc">/**
     * Not private so it can be called from an inner class without going
     * through a thunk.
     */</span>
       <span class="hljs-keyword">void</span> sendOnTextChanged(CharSequence text, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> before, <span class="hljs-keyword">int</span> after) {
        <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">final</span> ArrayList&lt;TextWatcher&gt; list = mListeners;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = list.size();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
                list.get(i).onTextChanged(text, start, before, after);
            }
        }

        <span class="hljs-keyword">if</span> (mEditor != <span class="hljs-keyword">null</span>) mEditor.sendOnTextChanged(start, after);
    }

     <span class="hljs-javadoc">/**
     * Not private so it can be called from an inner class without going
     * through a thunk.
     */</span>
    <span class="hljs-keyword">void</span> sendAfterTextChanged(Editable text) {
        <span class="hljs-keyword">if</span> (mListeners != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">final</span> ArrayList&lt;TextWatcher&gt; list = mListeners;
            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = list.size();
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
                list.get(i).afterTextChanged(text);
            }
        }
        hideErrorIfUnchanged();
    }</code></pre> 
<p>看一下这些方法,能不能发现点什么,<font color="red">可以看到有一个ArrayList&lt; TextWatcher &gt;对象,先进行判空处理,如果这个对象中存在TextWatcher监听,则逐条进行回调操作.</font>再回头看一下之前写的EditText中回调方法的实现,在回调中,对这个EditText进行了setText操作,因为EditText实现了TextWatcher的回调接口,这样就导致了无限循环 setText-&gt;onTextChanged-&gt;setText…… 最终导致程序崩溃.那该如何解决这个问题呢.其实很简单,看一下代码</p> 
<pre class="prettyprint"><code class="language-java hljs "> mLimitEt.addTextChangedListener(<span class="hljs-keyword">new</span> TextWatcher() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTextChanged</span>(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> after) {

            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTextChanged</span>(CharSequence s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> before, <span class="hljs-keyword">int</span> count) {
            <span class="hljs-comment">// 1.处理输入的内容s:清除其中不是中文的部分</span>
            ...
            <span class="hljs-comment">// 2.删除监听</span>
            mLimitEt.removeTextChangedListener(<span class="hljs-keyword">this</span>);
            <span class="hljs-comment">// 3.设置处理完的s</span>
            mLimitEt.setText(<span class="hljs-string">"处理之后的s"</span>);
            <span class="hljs-comment">// 4.重新添加监听</span>
            mLimitEt.addTextChangedListener(<span class="hljs-keyword">this</span>);
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTextChanged</span>(Editable s) {

            }
        });</code></pre> 
<p>在setText之前先删除之前的回调监听,setText时因为没有TextWatcher的监听方法,所以不会出现无限循环的情况,当setText之后再重新添加回调监听,这样就避免了崩溃的产生.之后看一下清除非中文部分的实现,直接看代码</p> 
<pre class="prettyprint"><code class="language-java hljs ">    <span class="hljs-javadoc">/**
     * 清除不是中文的内容
     *
     *<span class="hljs-javadoctag"> @param</span> regex
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title">clearLimitStr</span>(String regex, String str) {
        <span class="hljs-keyword">return</span> str.replaceAll(<span class="hljs-string">"[^\u4E00-\u9FA5]"</span>, <span class="hljs-string">""</span>);
    }</code></pre> 
<p>用了String的replaceAll方法来处理输入的内容(用了正则表达式,使用起来很简单).在onTextChanged和afterTextChanged方法中,得到的输入内容其实是整体的输入内容,所以用replaceAll方法,可以去打印一下这几个方法中的参数,这里就不做了.看一下整体代码</p> 
<p>LimitInputTextWatcher:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> com.example.junweiliu.limitinputdemo;

<span class="hljs-keyword">import</span> android.text.Editable;
<span class="hljs-keyword">import</span> android.text.TextWatcher;
<span class="hljs-keyword">import</span> android.widget.EditText;

<span class="hljs-javadoc">/**
 * Created by junweiliu on 17/1/6.
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LimitInputTextWatcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TextWatcher</span> {<!-- --></span>
    <span class="hljs-javadoc">/**
     * et
     */</span>
    <span class="hljs-keyword">private</span> EditText et = <span class="hljs-keyword">null</span>;
    <span class="hljs-javadoc">/**
     * 筛选条件
     */</span>
    <span class="hljs-keyword">private</span> String regex;
    <span class="hljs-javadoc">/**
     * 默认的筛选条件(正则:只能输入中文)
     */</span>
    <span class="hljs-keyword">private</span> String DEFAULT_REGEX = <span class="hljs-string">"[^\u4E00-\u9FA5]"</span>;

    <span class="hljs-javadoc">/**
     * 构造方法
     *
     *<span class="hljs-javadoctag"> @param</span> et
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">LimitInputTextWatcher</span>(EditText et) {
        <span class="hljs-keyword">this</span>.et = et;
        <span class="hljs-keyword">this</span>.regex = DEFAULT_REGEX;
    }

    <span class="hljs-javadoc">/**
     * 构造方法
     *
     *<span class="hljs-javadoctag"> @param</span> et    et
     *<span class="hljs-javadoctag"> @param</span> regex 筛选条件
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">LimitInputTextWatcher</span>(EditText et, String regex) {
        <span class="hljs-keyword">this</span>.et = et;
        <span class="hljs-keyword">this</span>.regex = regex;
    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeTextChanged</span>(CharSequence charSequence, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2) {

    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTextChanged</span>(CharSequence charSequence, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2) {

    }

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterTextChanged</span>(Editable editable) {
        String str = editable.toString();
        String inputStr = clearLimitStr(regex, str);
        et.removeTextChangedListener(<span class="hljs-keyword">this</span>);
        <span class="hljs-comment">// et.setText方法可能会引起键盘变化,所以用editable.replace来显示内容</span>
        editable.replace(<span class="hljs-number">0</span>, editable.length(), inputStr.trim());
        et.addTextChangedListener(<span class="hljs-keyword">this</span>);

    }

    <span class="hljs-javadoc">/**
     * 清除不符合条件的内容
     *
     *<span class="hljs-javadoctag"> @param</span> regex
     *<span class="hljs-javadoctag"> @return</span>
     */</span>
    <span class="hljs-keyword">private</span> String <span class="hljs-title">clearLimitStr</span>(String regex, String str) {
        <span class="hljs-keyword">return</span> str.replaceAll(regex, <span class="hljs-string">""</span>);
    }
}
</code></pre> 
<p>为了扩展性,提出来了一个类,提供了两个构造方法,如果需要限制其他的特殊内容,可以设置正则的规则.当然如果很简单的话,用EidtText自带的digits属性就可以了.<font color="red">还有一个问题,需要注意,代码中没有用et.setText方法,是因为setText方法可能引起键盘变化异常,所以这里用 editable.replace(0, editable.length(), inputStr.trim());这个方法和setText方法的实现效果是一样的.不过也需要对监听进行处理,原因也是因为会引起无限循环,感兴趣的童鞋可以去看一下.</font></p> 
<h3 id="完整代码">完整代码</h3> 
<p>MainActivity:</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">package</span> com.example.junweiliu.limitinputdemo;

<span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;
<span class="hljs-keyword">import</span> android.os.Bundle;
<span class="hljs-keyword">import</span> android.widget.EditText;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> {<!-- --></span>
    <span class="hljs-javadoc">/**
     * et
     */</span>
    <span class="hljs-keyword">private</span> EditText mLimitEt;


    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState) {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mLimitEt = (EditText) findViewById(R.id.et_limit);
        mLimitEt.addTextChangedListener(<span class="hljs-keyword">new</span> LimitInputTextWatcher(mLimitEt));
        <span class="hljs-comment">// 去除除了a-z  A-Z与0-9和中文的其他符号</span>
<span class="hljs-comment">//        mLimitEt.addTextChangedListener(new LimitInputTextWatcher(mLimitEt, "[^a-zA-Z0-9\u4E00-\u9FA5]"));</span>
    }
}
</code></pre> 
<p>activity_main:</p> 
<pre class="prettyprint"><code class="language-xml hljs "><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">RelativeLayout
</span>        <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
        <span class="hljs-attribute">xmlns:tools</span>=<span class="hljs-value">"http://schemas.android.com/tools"</span>
        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>
        <span class="hljs-attribute">android:paddingBottom</span>=<span class="hljs-value">"@dimen/activity_vertical_margin"</span>
        <span class="hljs-attribute">android:paddingLeft</span>=<span class="hljs-value">"@dimen/activity_horizontal_margin"</span>
        <span class="hljs-attribute">android:paddingRight</span>=<span class="hljs-value">"@dimen/activity_horizontal_margin"</span>
        <span class="hljs-attribute">android:paddingTop</span>=<span class="hljs-value">"@dimen/activity_vertical_margin"</span>
        <span class="hljs-attribute">tools:context</span>=<span class="hljs-value">"com.example.junweiliu.limitinputdemo.MainActivity"</span>&gt;</span>
    <span class="hljs-comment">&lt;!--输入框--&gt;</span>
    <span class="hljs-comment">&lt;!--android:digits="1234567890"--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">EditText
</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/et_limit"</span>
            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>
            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
            <span class="hljs-attribute">android:layout_centerHorizontal</span>=<span class="hljs-value">"true"</span>
            <span class="hljs-attribute">android:hint</span>=<span class="hljs-value">"我是一个受限制的输入框"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!--输入框--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">EditText
</span>            <span class="hljs-attribute">android:layout_below</span>=<span class="hljs-value">"@+id/et_limit"</span>
            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>
            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
            <span class="hljs-attribute">android:layout_centerHorizontal</span>=<span class="hljs-value">"true"</span>
            <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"复制我fuzhiwo845"</span>
            <span class="hljs-attribute">android:hint</span>=<span class="hljs-value">""</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">RelativeLayout</span>&gt;</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/acbaf03309b151e4b8988097bd198be7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java IO流学习总结一：输入输出流</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/544fa9db0a77da009a1631b5d1b757b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10操作系统IE11浏览器的日期时间格式调整</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>