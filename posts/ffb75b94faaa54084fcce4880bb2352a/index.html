<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JS手写apply，call，bind函数 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JS手写apply，call，bind函数" />
<meta property="og:description" content="本篇文章咱们来手写简易版的apply，call，bind函数。
实现思路 首先咱们需要思考下这三个函数放到哪里比较合适，因为这三个函数是被函数对象调用的，并且每个函数都可以调用，所以不难想到有一个位置非常合适，函数的显式原型对象上，这样就可以通过原型链被每个函数调用。
手写apply apply函数可以传入两个参数，第一个参数是需要绑定的this对象，第二个参数是传递给函数的参数组成的数组，咱们可以从apply函数的用法倒推它的代码实现。
首先声明一个foo函数，作为测试函数，代码如下图：
之后在函数的显式原型对象上声明一个myapply函数，代码如下图：
第一个参数是执行apply函数后调用函数的对象，为了确保传入的内容是个对象，咱们需要对传入的第一个参数进行判断和处理，代码如下图：
之后咱们需要修改this指向，myapply本身也是个函数，调用者就是使用myapply的函数对象，也就是说此时的this就是调用myapply的函数对象，咱们就可以借助this来建立newObj与调用myapply的函数对象之间的调用关系，代码如下图：
上图可见，在newObj上添加一个fn属性值为调用myapply函数的函数对象，然后执行fn，调用fn后删除newObj上多余的fn属性。
第二个参数是参数构成的数组，可以通过解构的方式获取这些参数，代码如下图：
这样咱们就实现了自己的apply函数。
手写call call和apply第一个参数接收的内容一致，call的后续参数通过参数列表的方式传入，实现思路与apply一样，只是接收参数的方式不同，区别如下图：
其他的代码与myapply函数一样。
手写bind bind的函数的第一个参数接收的内容与apply和call一致，后续参数也是通过参数列表的方式传入，不过bind的内部实现不同之处在于，bind返回了一个具有所需this指向的新函数，代码如下图：
其他的代码与mycall函数一样。
完整代码 function foo(name, age) { console.log(this, name, age); } Function.prototype.myapply = function(newObj, args) { newObj = (newObj === null || newObj === undefined) ? window : Object(newObj); newObj.fn = this; newObj.fn(...args); delete newObj.fn; } Function.prototype.mycall = function(newObj, ...args) { newObj = (newObj === null || newObj === undefined) || Object(newObj); newObj.fn = this; newObj." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ffb75b94faaa54084fcce4880bb2352a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T16:15:03+08:00" />
<meta property="article:modified_time" content="2024-01-06T16:15:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JS手写apply，call，bind函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>  本篇文章咱们来手写简易版的apply，call，bind函数。</p> 
<h3>实现思路</h3> 
<p>  首先咱们需要思考下这三个函数放到哪里比较合适，因为这三个函数是被函数对象调用的，并且每个函数都可以调用，所以不难想到有一个位置非常合适，函数的显式原型对象上，这样就可以通过原型链被每个函数调用。</p> 
<h4>手写apply</h4> 
<p>  apply函数可以传入两个参数，第一个参数是需要绑定的this对象，第二个参数是传递给函数的参数组成的数组，咱们可以从apply函数的用法倒推它的代码实现。</p> 
<p>  首先声明一个foo函数，作为测试函数，代码如下图：</p> 
<p><img alt="" height="230" src="https://images2.imgbox.com/05/d6/hML9BztH_o.png" width="1200"></p> 
<p>  之后在函数的显式原型对象上声明一个myapply函数，代码如下图：</p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/71/f1/y31T5fLN_o.png" width="1200"></p> 
<p>  第一个参数是执行apply函数后调用函数的对象，为了确保传入的内容是个对象，咱们需要对传入的第一个参数进行判断和处理，代码如下图：</p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/3a/b8/XvL2krkD_o.png" width="1200"></p> 
<p>  之后咱们需要修改this指向，myapply本身也是个函数，调用者就是使用myapply的函数对象，也就是说此时的this就是调用myapply的函数对象，咱们就可以借助this来建立newObj与调用myapply的函数对象之间的调用关系，代码如下图：</p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/b6/af/BCwtVJxK_o.png" width="1114"></p> 
<p>  上图可见，在newObj上添加一个fn属性值为调用myapply函数的函数对象，然后执行fn，调用fn后删除newObj上多余的fn属性。</p> 
<p>  第二个参数是参数构成的数组，可以通过解构的方式获取这些参数，代码如下图：</p> 
<p><img alt="" height="298" src="https://images2.imgbox.com/c6/5f/WPZBkrGs_o.png" width="1200"></p> 
<p>  这样咱们就实现了自己的apply函数。</p> 
<h4>手写call</h4> 
<p>  call和apply第一个参数接收的内容一致，call的后续参数通过参数列表的方式传入，实现思路与apply一样，只是接收参数的方式不同，区别如下图：</p> 
<p><img alt="" height="90" src="https://images2.imgbox.com/bf/6b/D9ZdjdTV_o.png" width="1101"></p> 
<p>  其他的代码与myapply函数一样。</p> 
<h4>手写bind</h4> 
<p>  bind的函数的第一个参数接收的内容与apply和call一致，后续参数也是通过参数列表的方式传入，不过bind的内部实现不同之处在于，bind返回了一个具有所需this指向的新函数，代码如下图：</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/36/bb/Bt0F2mUk_o.png" width="1001"></p> 
<p>其他的代码与mycall函数一样。</p> 
<h3>完整代码</h3> 
<pre><code class="language-javascript">function foo(name, age) {
    console.log(this, name, age);
}

Function.prototype.myapply = function(newObj, args) {
    newObj = (newObj === null || newObj === undefined) ? window : Object(newObj);

    newObj.fn = this;
    newObj.fn(...args);

    delete newObj.fn;
}

Function.prototype.mycall = function(newObj, ...args) {
    newObj = (newObj === null || newObj === undefined) || Object(newObj);

    newObj.fn = this;
    newObj.fn(...args);

    delete newObj.fn;
}

Function.prototype.mybind = function(newObj, ...args) {
    newObj = (newObj === null || newObj === undefined) ? window : newObj;
    newObj.fn = this;

    return () =&gt; {
        newObj.fn(...args);
    }
}

foo.myapply({ name:"guanju"}, ["test", 18])
foo.mycall({ name:"guanju"}, "test", 18);
const foo1 = foo.mybind({ name:"guanju"}, "test", 18);
foo1()</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2bd167afc5e59354222631b349d0d493/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">张雪峰说过：计算机专业不要死盯着计算机，还有其他更好的出路</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ca36510aed0b4ae747ade67e22f8bc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Simulink】基于双矢量MPC的三相并网逆变器电流控制（调制模型预测控制）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>