<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java四种引用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java四种引用" />
<meta property="og:description" content="每一种语言都有着自己操作内存元素的方式，C语言通过指针，而java就是通过引用。作为一门面向对象的语言，在java中世事万物皆对象。但是我们操作的标识符实际上是对象的一个引用（reference）。今天我们来分析一下java中的四种引用。
java内存管理分为内存分配和内存回收，都不需要程序员负责，垃圾回收的机制主要是看对象是否有引用指向该对象。
java对象的引用包括
1.强引用(StronglyReference)，2.软引用(SoftReference)，3.弱引用(Weak Reference)，4.虚引用(Phantom Reference) 这4中引用强度依次逐渐减弱
Java中提供这四种引用类型主要有两个目的：
1.第一是可以让程序员通过代码的方式决定某些对象的生命周期；
2.第二是有利于JVM进行垃圾回收。
1.强引用 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。
强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。
private static void testStrongReference() {
Object object = new Object();
Object[] objects = new Object[1000];
}
2.软引用（SoftReference） 如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；
如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。
软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。 SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。
软引用声明格式：
public class SoftRefence {
public static void main(String[] args) {
SoftReference&lt;String&gt; pen = new SoftReference&lt;String&gt;(new String(&#34;penguin&#34;));
System.out.println(pen.get());
//通知JVM进行内存回收
System.gc();
System.out.println(pen.get());
}
}
输出：
可以看得出来，此时JVM内存充足，暂时还没有回收被软引用关联的对象。
软引用适合做缓存，在内存足够时，直接通过软引用取值，无需从真实来源中查询数据，可以显著地提升网站性能。当内存不足时，能让JVM进行内存回收，从而删除缓存，这时候只能从真实来源查询数据。
3.弱引用 （WeakReference） 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7ec9b32894cb72d087d07e0eab714583/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-13T21:40:38+08:00" />
<meta property="article:modified_time" content="2023-10-13T21:40:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java四种引用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>每一种语言都有着自己操作内存元素的方式，C语言通过指针，而java就是通过引用。作为一门面向对象的语言，在java中世事万物皆对象。但是我们操作的标识符实际上是对象的一个引用（reference）。今天我们来分析一下java中的四种引用。</p> 
<p>java内存管理分为内存分配和内存回收，都不需要程序员负责，垃圾回收的机制主要是看对象是否有引用指向该对象。</p> 
<p><strong>java对象的引用包括</strong></p> 
<p>1.强引用(StronglyReference)，2.软引用(SoftReference)，3.弱引用(Weak Reference)，4.虚引用(Phantom Reference)  这4中引用强度依次逐渐减弱</p> 
<p><strong>Java中提供这四种引用类型主要有两个目的：</strong></p> 
<p>1.第一是可以让程序员通过代码的方式决定某些对象的生命周期；</p> 
<p>2.第二是有利于JVM进行垃圾回收。</p> 
<p><img alt="" height="242" src="https://images2.imgbox.com/89/52/CHp1pNSt_o.png" width="552"></p> 
<p></p> 
<h3><strong>1.强引用</strong></h3> 
<p><strong>强引用</strong>是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。</p> 
<p><strong>强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。</strong></p> 
<p><span style="background-color:#a2e043;">    private static void testStrongReference() {<!-- --></span><br><span style="background-color:#a2e043;">        Object object = new Object();</span><br><span style="background-color:#a2e043;">        Object[] objects = new Object[1000];</span><br><span style="background-color:#a2e043;">    }</span></p> 
<h2><strong>2.软引用（SoftReference）</strong></h2> 
<p>如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；</p> 
<p>如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p> 
<p>软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。   <br> SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。</p> 
<p><strong>软引用声明格式：</strong></p> 
<p><span style="background-color:#a2e043;">public class SoftRefence {<!-- --></span><br><span style="background-color:#a2e043;">    public static void main(String[] args) {<!-- --></span><br><span style="background-color:#a2e043;">        SoftReference&lt;String&gt; pen = new SoftReference&lt;String&gt;(new String("penguin"));</span><br><span style="background-color:#a2e043;">        System.out.println(pen.get());</span><br><span style="background-color:#a2e043;">        //通知JVM进行内存回收</span><br><span style="background-color:#a2e043;">        System.gc();</span><br><span style="background-color:#a2e043;">        System.out.println(pen.get());</span><br><span style="background-color:#a2e043;">    }</span><br><span style="background-color:#a2e043;">}</span></p> 
<p><strong>输出：</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/93/18/zKiQDBV8_o.png"></p> 
<p> 可以看得出来，此时JVM内存充足，暂时还没有回收被软引用关联的对象。</p> 
<p>   软引用适合做缓存，在内存足够时，直接通过软引用取值，无需从真实来源中查询数据，可以显著地提升网站性能。当内存不足时，能让JVM进行内存回收，从而删除缓存，这时候只能从真实来源查询数据。</p> 
<h2>3.弱引用 （WeakReference）</h2> 
<p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，<strong>被弱引用关联的对象只 能生存到下一次垃圾收集发生为止</strong>。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只 被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p> 
<h4>弱引用使用：</h4> 
<p><span style="background-color:#a2e043;">public class Weak {<!-- --></span><br><span style="background-color:#a2e043;">    public static void main(String[] args) {<!-- --></span><br><span style="background-color:#a2e043;"> </span><br><span style="background-color:#a2e043;">        WeakReference&lt;String&gt; str = new WeakReference&lt;String&gt;(new String("penguin"));</span><br><span style="background-color:#a2e043;">        System.out.println(str.get());</span><br><span style="background-color:#a2e043;">        //通知JVM进行内存回收</span><br><span style="background-color:#a2e043;">        System.gc();</span><br><span style="background-color:#a2e043;"> </span><br><span style="background-color:#a2e043;">        System.out.println(str.get());</span><br><span style="background-color:#a2e043;"> </span><br><span style="background-color:#a2e043;">    }</span><br><span style="background-color:#a2e043;">}</span></p> 
<p><strong>输出结果：</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/a1/3c/VGuo3IvV_o.png"></p> 
<p> <strong>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中</strong></p> 
<h2>4.虚引用（PhantomReference）</h2> 
<p> 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的 存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供 了PhantomReference类来实现虚引用</p> 
<h3><br><strong> 虚引用和弱引用的区别</strong></h3> 
<p>弱引用应该还可以通过引用来获取对象，但是虚引用根本获取不到对象</p> 
<p><br> 虚引用存在于每一个对象里面，不会对对象的存活造成任何影响，唯一用处就是：能在对象被GC时收到系统通知</p> 
<h4><strong>若某个对象与虚引用关联，那么在任何时候都可能被JVM回收掉。虚引用不能单独使用，必须配合引用队列一起使用。</strong></h4> 
<p><strong><span style="background-color:#a2e043;">public class Phantom {<!-- --></span><br><span style="background-color:#a2e043;">    public static void main(String args[]) {<!-- --></span><br><span style="background-color:#a2e043;"> </span><br><span style="background-color:#a2e043;">        ReferenceQueue&lt;String&gt; queue = new ReferenceQueue&lt;String&gt;();</span><br><span style="background-color:#a2e043;">        PhantomReference&lt;String&gt; str = new PhantomReference&lt;String&gt;("abc", queue);</span><br><span style="background-color:#a2e043;">        System.out.println(str.get());</span><br><span style="background-color:#a2e043;">    }</span><br><span style="background-color:#a2e043;">}</span></strong></p> 
<p><strong>结果：</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/1c/cc/C1N6Lwvv_o.png"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c4df5ce83df57388a2b55788f550b909/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">git使用【提交、回退、链接、公匙链接、分支操作、忽视文件】和 指令大全(一)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ebbd5495bb08a9838359e6e077903875/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">友元函数和友元类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>