<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>干货技巧|关于Redis的16个使用技巧 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="干货技巧|关于Redis的16个使用技巧" />
<meta property="og:description" content="1、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？
回答：持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供了两种持久化方式：RDB（默认） 和AOF。RDB，是Redis DataBase缩写，功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数AOF，f是Append-only file缩写每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作aof写入保存：WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。存储结构:内容是redis通讯协议(RESP )格式的命令文本存储。比较：aof文件比rdb更新频率高，优先使用aof还原数据。aof比rdb更安全也更大rdb性能比aof好如果两个都配了优先加载AOF
2、Redis 单线程为什么还能这么快
命令执行基于内存操作，在内存操作时间是几十纳秒，命令执行是单线程，没有线程切换开销，基于IO多路复用机制提升Redis的I/O利用率高效​ ​数据结构​​。
3、Redis到底是单线程还是多线程？
Redis6.0版本之前的单线程指的是 网络I/O和键值对读写是由一个线程完成的。Redis6.0引入的多线程指的是网络请求过程采用了多线程；而键值对读写命令仍然是单线程处理的，Redis依然是并发安全的。即数据操作模块是单线程的，其它持久化、集群数据同步等，是由额外线程执行的。
4、使用过Redis分布式锁么，它是怎么实现的？
先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！
5、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？
缓存穿透
一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。
如何避免？
对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。
对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。
缓存雪崩
当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。
如何避免？
在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。
6、Redis的并发竞争问题如何解决?
Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：
客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。
服务器角度，利用setnx实现锁。
对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。
7、Redis 支持哪几种数据类型？
String、List、Set、Sorted Set、hashes。
它还有三种特殊的数据结构类型
Geospatial
Hyperloglog
Bitmap
8、Redis 有哪几种数据淘汰策略？
noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
allkeys-random: 回收随机的键使得新添加的数据有空间存放。
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。
9、Redis 集群为什么至少需要三个主节点
因为新主节点的选举现需要大于半数的集群主节点同意才能选举成功，只有两个的话，其中一个挂了，达不到选举新主节点条件的。
10、Redis集群为什么推荐奇数个节点
在挂掉相同机器的前提下，奇数和奇数&#43;1的偶数，效果是一样的，但是却多浪费了一台机器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9e5bc3e7d56fd2c8fdf0718c9396e412/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-15T15:28:38+08:00" />
<meta property="article:modified_time" content="2022-08-15T15:28:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">干货技巧|关于Redis的16个使用技巧</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1、什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？<br> 回答：持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供了两种持久化方式：RDB（默认） 和AOF。RDB，是Redis DataBase缩写，功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数AOF，f是Append-only file缩写每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作aof写入保存：WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。存储结构:内容是redis通讯协议(RESP )格式的命令文本存储。比较：aof文件比rdb更新频率高，优先使用aof还原数据。aof比rdb更安全也更大rdb性能比aof好如果两个都配了优先加载AOF</p> 
<p>2、Redis 单线程为什么还能这么快<br> 命令执行基于内存操作，在内存操作时间是几十纳秒，命令执行是单线程，没有线程切换开销，基于IO多路复用机制提升Redis的I/O利用率高效​ ​数据结构​​。</p> 
<p>3、Redis到底是单线程还是多线程？<br> Redis6.0版本之前的单线程指的是 网络I/O和键值对读写是由一个线程完成的。Redis6.0引入的多线程指的是网络请求过程采用了多线程；而键值对读写命令仍然是单线程处理的，Redis依然是并发安全的。即数据操作模块是单线程的，其它持久化、集群数据同步等，是由额外线程执行的。</p> 
<p>4、使用过Redis分布式锁么，它是怎么实现的？<br> 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p> 
<p>5、什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？<br> 缓存穿透</p> 
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p> 
<p>如何避免？</p> 
<p>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p> 
<p>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p> 
<p>缓存雪崩</p> 
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p> 
<p>如何避免？</p> 
<p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p> 
<p>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p> 
<p>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p> 
<p>6、Redis的并发竞争问题如何解决?<br> Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：</p> 
<p>客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p> 
<p>服务器角度，利用setnx实现锁。</p> 
<p>对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</p> 
<p>7、Redis 支持哪几种数据类型？<br> String、List、Set、Sorted Set、hashes。</p> 
<p>它还有三种特殊的数据结构类型</p> 
<p>Geospatial</p> 
<p>Hyperloglog</p> 
<p>Bitmap</p> 
<p>8、Redis 有哪几种数据淘汰策略？<br> noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</p> 
<p>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</p> 
<p>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</p> 
<p>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</p> 
<p>9、Redis 集群为什么至少需要三个主节点<br> 因为新主节点的选举现需要大于半数的集群主节点同意才能选举成功，只有两个的话，其中一个挂了，达不到选举新主节点条件的。</p> 
<p>10、Redis集群为什么推荐奇数个节点<br> 在挂掉相同机器的前提下，奇数和奇数+1的偶数，效果是一样的，但是却多浪费了一台机器</p> 
<p>例如：3台机器挂两台，和4台机器挂两台同样都不可用。</p> 
<p>​</p> 
<p>11、请说一下缓存击穿问题<br> 缓存击穿： 指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。</p> 
<p>缓存击穿看着有点像，其实它两区别是，缓存雪奔是指数据库压力过大甚至down机，缓存击穿只是大量并发请求到了DB数据库层面。可以认为击穿是缓存雪奔的一个子集吧。有些文章认为它俩区别，是区别在于击穿针对某一热点key缓存，雪奔则是很多key。</p> 
<p>解决方案就有两种：</p> 
<p>1.使用互斥锁方案。缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。</p> 
<p>2. “永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。</p> 
<p>12、说说Redis的常用应用场景<br> 缓存、排行榜、计数器应用、共享Session、分布式锁、社交网络、消息队列、位操作</p> 
<p>13、什么是热Key问题，如何解决热key问题<br> 什么是热Key呢？在Redis中，我们把访问频率高的key，称为热点key。如果某一热点key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务。而热点Key是怎么产生的呢？主要原因有两个：</p> 
<p>用户消费的数据远大于生产的数据，如秒杀、热点新闻等读多写少的场景。</p> 
<p>请求分片集中，超过单Redi服务器的性能，比如固定名称key，Hash落入同一台服务器，瞬间访问量极大，超过机器瓶颈，产生热点Key问题。</p> 
<p>14、那么在日常开发中，如何识别到热点key呢？<br> 凭经验判断哪些是热Key；</p> 
<p>客户端统计上报；</p> 
<p>服务代理层上报</p> 
<p>15、如何解决热key问题？<br> Redis集群扩容：增加分片副本，均衡读流量；</p> 
<p>将热key分散到不同的服务器中；</p> 
<p>使用二级缓存，即JVM本地缓存,减少Redis的读请求。</p> 
<p>16、如何实现一个排行榜功能？<br> 比如，用户每天上传视频，获得点赞的排行榜可以这样设计：</p> 
<p>1.用户Jay上传一个视频，获得6个赞，可以酱紫：</p> 
<p>zadd user:ranking:2021-03-03 Jay 3</p> 
<p>2.过了一段时间，再获得一个赞，可以这样：</p> 
<p>zincrby user:ranking:2021-03-03 Jay 1</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1cbb965950a0a97103cbafb2214fc0c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VUE页面表格数据多卡顿用虚拟表单</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c5c224fd840a6b79d1e749cc9a3800b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CentOS下前后端分离项目（Vue&#43;SpringBoot）的详细部署过程（初学者，简易版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>