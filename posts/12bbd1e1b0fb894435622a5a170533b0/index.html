<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python中import i_解析Python3中的Import - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python中import i_解析Python3中的Import" />
<meta property="og:description" content="Python import的搜索路径
import的搜索路径为：
搜索「内置模块」(built-in module)
搜索 sys.path 中的路径
而sys.path在初始化时，又会按照顺序添加以下路径：
foo.py 所在目录(如果是软链接，那么是真正的 foo.py 所在目录)或当前目录；
环境变量 PYTHONPATH中列出的目录(类似环境变量 PATH，由用户定义，默认为空)；
site 模块被 import 时添加的路径1(site 会在运行时被自动 import)。
import site 所添加的路径一般是 XXX/site-packages。如果懒得记 sys.path 的初始化过程，可以简单的认为 import 的查找顺序是：
内置模块
.py 文件所在目录
pip 或 easy_install 安装的包
绝对导入和相对导入
绝对导入和相对导入的关系可以类比绝对路径和相对路径。
绝对导入的格式为：
import A.B
或
from A import B
相对导入格式为：
from . import B
或
from ..A import B
其中，点号.代表当前模块，..代表上层模块，…代表上上层模块，依次类推。
模块的执行方式
模块的执行可以有两种方式：直接执行和以模块执行，即：
python example/foo.py
或
python -m example.foo
注意，以模块执行时，一定要有包的概念，即example一定是个包，而foo是这个包下的模块，这样才能顺利执行。
包和模块
模块: 一个 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/12bbd1e1b0fb894435622a5a170533b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-16T03:00:33+08:00" />
<meta property="article:modified_time" content="2020-12-16T03:00:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python中import i_解析Python3中的Import</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>Python import的搜索路径</p> 
 <p>import的搜索路径为：</p> 
 <p>搜索「内置模块」(built-in module)</p> 
 <p>搜索 sys.path 中的路径</p> 
 <p>而sys.path在初始化时，又会按照顺序添加以下路径：</p> 
 <p>foo.py 所在目录(如果是软链接，那么是真正的 foo.py 所在目录)或当前目录；</p> 
 <p>环境变量 PYTHONPATH中列出的目录(类似环境变量 PATH，由用户定义，默认为空)；</p> 
 <p>site 模块被 import 时添加的路径1(site 会在运行时被自动 import)。</p> 
 <p>import site 所添加的路径一般是 XXX/site-packages。如果懒得记 sys.path 的初始化过程，可以简单的认为 import 的查找顺序是：</p> 
 <p>内置模块</p> 
 <p>.py 文件所在目录</p> 
 <p>pip 或 easy_install 安装的包</p> 
 <p>绝对导入和相对导入</p> 
 <p>绝对导入和相对导入的关系可以类比绝对路径和相对路径。</p> 
 <p>绝对导入的格式为：</p> 
 <p>import A.B</p> 
 <p>或</p> 
 <p>from A import B</p> 
 <p>相对导入格式为：</p> 
 <p>from . import B</p> 
 <p>或</p> 
 <p>from ..A import B</p> 
 <p>其中，点号.代表当前模块，..代表上层模块，…代表上上层模块，依次类推。</p> 
 <p>模块的执行方式</p> 
 <p>模块的执行可以有两种方式：直接执行和以模块执行，即：</p> 
 <p>python example/foo.py</p> 
 <p>或</p> 
 <p>python -m example.foo</p> 
 <p>注意，以模块执行时，一定要有包的概念，即example一定是个包，而foo是这个包下的模块，这样才能顺利执行。</p> 
 <p>包和模块</p> 
 <p>模块: 一个 .py 文件就是一个模块(module)</p> 
 <p>包: init .py 文件所在目录就是包(package)</p> 
 <p>各种情形测试</p> 
 <p>模块直接导入</p> 
 <p>即模块所在的目录都不是一个包结构，各个模块都是独立的，比如以下的目录结构：</p> 
 <p>D:\LEARN\IMPORT_TEST\TEST1</p> 
 <p>├─pack1</p> 
 <p>│ modu1.py</p> 
 <p>└─pack2</p> 
 <p>modu2.py</p> 
 <p>modu1.py中的内容为：</p> 
 <p>import sys</p> 
 <p>sys.path.append("D:\\learn\\import_test\\TEST1\\pack2")</p> 
 <p>from modu2 import hello2</p> 
 <p>hello2()</p> 
 <p>modu2.py中的内容为：</p> 
 <p>def hello2():</p> 
 <p>print("hello, I am module 2")</p> 
 <p>注意在modu1中一定加上sys.path.append那部分内容，即根据上面的描述，一定要让modu1能找到modu2才行，否则就会出现如下错误：</p> 
 <p>ModuleNotFoundError: No module named 'modu2'</p> 
 <p>此时进入pack1目录下，以直接执行或模块执行的方式都可以顺利输出。</p> 
 <p>包外导入</p> 
 <p>将上面两个模块所在的目录都变为包结构，即：</p> 
 <p>D:\LEARN\IMPORT_TEST\TEST2</p> 
 <p>├─pack1</p> 
 <p>│ modu1.py</p> 
 <p>│ __init__.py</p> 
 <p>└─pack2</p> 
 <p>modu2.py</p> 
 <p>__init__.py</p> 
 <p>此时也能顺利执行，同时比上面非包结构的多出来一条执行方式，即：</p> 
 <p>python -m pack1.modu1</p> 
 <p>即以包名+模块名的方式执行。</p> 
 <p>上面两种情形，即模块与模块、包与包都是相互独立的关系，也就没有相对导入的意义。</p> 
 <p>如果是在一个包内的不同模块的导入，那么最自然的就是使用相对导入。</p> 
 <p>包内相对导入</p> 
 <p>D:\LEARN\IMPORT_TEST\Test3</p> 
 <p>│ __init__.py</p> 
 <p>│</p> 
 <p>├─pack1</p> 
 <p>│ modu1.py</p> 
 <p>│ __init__.py</p> 
 <p>│</p> 
 <p>└─pack2</p> 
 <p>modu2.py</p> 
 <p>__init__.py</p> 
 <p>此时modu1.py中的内容为：</p> 
 <p>from ..pack2.modu2 import hello2</p> 
 <p>hello2()</p> 
 <p>即将sys.path.append去掉，因为是在一个包内相互引用，此时这样写没有意义。</p> 
 <p>此时正确运行的方式是进入Test3上一层的文件夹，然后：</p> 
 <p>python -m Test3.pack1.modu1</p> 
 <p>即明确地告诉解释器模块的层次结构。</p> 
 <p>而如果采用直接运行的方式，比如：</p> 
 <p>python Test3\pack1\modu1.py</p> 
 <p>就会报如下错误：</p> 
 <p>ValueError: attempted relative import beyond top-level package</p> 
 <p>这是因为，相对导入使用模块的 name (这里的name和下面的main都是有两个下划线的，但是网页显示不出来。。)属性来决定模块在包结构中的位置。当 name 属性不包含包信息(i.e. 没有用'.'表示的层次结构，比如' main ‘)，则相对导入将模块解析为顶层模块，而不管模块在文件系统中的实际位置。这里模块被直接运行，则它自己为顶层模块，不存在层次结构，所以找不到其他的相对路径。</p> 
 <p>因此，直接运行带有相对导入的模块是不行的，需要通过模块运行的方式，将包结构明确告诉它才行。</p> 
 <p>这个原理也适用于下面这种错误，比如将modu2移动到pack1中，即与modu1在同一个目录下，然后将modu1的内容改为这样的相对引用：</p> 
 <p>from .modu2 import hello2</p> 
 <p>hello2()</p> 
 <p>此时使用模块执行的方式没有问题，如果还是想尝试直接运行，那么就会出现：</p> 
 <p>ModuleNotFoundError: No module named '__main__.modu2'; '__main__' is not a package</p> 
 <p>原因就是此时没有包结构， main 也不是个包。</p> 
 <p>那么解决方法就是或者使用模块运行的方式运行，或者将它改成下面的绝对导入的方式就可以直接运行。</p> 
 <p>包内绝对导入</p> 
 <p>那么，如果将modu1.py中的内容改为绝对导入，即：</p> 
 <p>from Test3.pack2.modu2 import hello2</p> 
 <p>hello2()</p> 
 <p>此时正确运行方式也是进入Test3上一层文件夹，然后使用模块执行的方式运行：</p> 
 <p>python -m Test3.pack1.modu1</p> 
 <p>如果此时采用直接运行的方式：</p> 
 <p>python Test3\pack1\modu1.py</p> 
 <p>那么就会报错：</p> 
 <p>ModuleNotFoundError: No module named 'Test3'</p> 
 <p>这主要是因为Test3没有被找到，即按照第一部分所说，Test3没有在import的搜索路径中。所以，只要将它加入进去即可，比如：</p> 
 <p>set PYTHONPATH=D:\learn\import_test\</p> 
 <p>此时再直接运行就没有问题了。</p> 
 <p>总结</p> 
 <p>以上所述是小编给大家介绍的Python3中的Import理解，希望对大家有所帮助！</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f26e9bbf97f9d2ebc20f4080d5e60515/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">将List中的某一个元素移动到首位或指定位置——Java学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7afbdde3ad9740c56b853aa59b142de5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android/Java-BigDecimal转String并去掉小数点后面没用的0</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>