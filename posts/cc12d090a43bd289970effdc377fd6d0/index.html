<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux Graphics 周刊（第 8 期） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux Graphics 周刊（第 8 期）" />
<meta property="og:description" content="导读：
dma-buf: Heaps: 代码重构及性能优化drm/uapi: 为 drm_mode_get_connector 添加详细说明drm/ttm: 一些小的修改AOSP/RenderEngine: 引入非线性 display color transformAOSP/SurfaceFlinger: 为 CaptureScreen buffer 添加 GRALLOC_USAGE_HW_COMPOSER usageMesa 20.3.0 发布Khronos 发布 Vulkan 光线追踪（Ray Tracing）最终版Khronos: Vulkan 光线追踪最佳实践之混合渲染Collabora: 在 Wayland 中添加 Color Management 和 HDR 支持Dave Airlie：为什么和 Windows 共享 Linux Graphics 驱动代码并不是件好事 DRM 1. dma-buf: Heaps: 代码重构及性能优化 在经历了7轮 patch review 之后，John Stultz (dma-heap maintainer, Linaro) 的 dma-buf heap 重构 patch 终于可以合入主线了。此次 patch 对 dma-buf heap 做了较大改动，主要是删除了 heap-helpers.c 文件，将其原来的内容合并到 cma-heap.c 和 system-heap.c 中。并对 system heap 做了性能上的优化，例如对于 device 没有 touch 过的 buffer，CPU 访问该 buffer 就无需再做 cache 同步。以及优先采用大页内存分配来提高效率。值得一提的是，在前5轮的 patch 中曾还包含添加 system-uncached heap（还记得周刊第1期中曾报道的 system-uncached heap 吗？），用来在 system heap 上分配不带 cache 的 memory，这种 memory 对于需要频繁在 CPU 和 device 之间来回切换的场景能有明显的性能改善（因为不用频繁刷 cache 了）。但 DRM Maintainer Daniel Vetter 对此 patch 持有反对意见，他需要 John 给出相关数据来证明 system-uncached heap 在性能上确实有所收益，否则这样的 heap 在他看来没有多大意义（而事实上 John 在邮件中也很明确告诉 Daniel，在 userspace 这一侧，Android 的 Hikey960 gralloc 以及 codec2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/cc12d090a43bd289970effdc377fd6d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-03T00:41:31+08:00" />
<meta property="article:modified_time" content="2020-12-03T00:41:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux Graphics 周刊（第 8 期）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p><strong>导读：</strong></p> 
 <ul><li>dma-buf: Heaps: 代码重构及性能优化</li><li>drm/uapi: 为 drm_mode_get_connector 添加详细说明</li><li>drm/ttm: 一些小的修改</li><li>AOSP/RenderEngine: 引入非线性 display color transform</li><li>AOSP/SurfaceFlinger: 为 CaptureScreen buffer 添加 GRALLOC_USAGE_HW_COMPOSER usage</li><li>Mesa 20.3.0 发布</li><li>Khronos 发布 Vulkan 光线追踪（Ray Tracing）最终版</li><li>Khronos: Vulkan 光线追踪最佳实践之混合渲染</li><li>Collabora: 在 Wayland 中添加 Color Management 和 HDR 支持</li><li>Dave Airlie：为什么和 Windows 共享 Linux Graphics 驱动代码并不是件好事</li></ul> 
</blockquote> 
<h3><a id="DRM_15"></a>DRM</h3> 
<h4><a id="1_dmabuf_Heaps__16"></a>1. dma-buf: Heaps: 代码重构及性能优化</h4> 
<p>在经历了7轮 patch review 之后，John Stultz (dma-heap maintainer, Linaro) 的 dma-buf heap 重构 patch 终于可以合入主线了。此次 patch 对 dma-buf heap 做了较大改动，主要是删除了 heap-helpers.c 文件，将其原来的内容合并到 cma-heap.c 和 system-heap.c 中。并对 system heap 做了性能上的优化，例如对于 device 没有 touch 过的 buffer，CPU 访问该 buffer 就无需再做 cache 同步。以及优先采用大页内存分配来提高效率。值得一提的是，在前5轮的 patch 中曾还包含添加 system-uncached heap（还记得周刊<a href="https://blog.csdn.net/hexiaolong2009/article/details/108229362#t3" title="第1期">第1期</a>中曾报道的 system-uncached heap 吗？），用来在 system heap 上分配不带 cache 的 memory，这种 memory 对于需要频繁在 CPU 和 device 之间来回切换的场景能有明显的性能改善（因为不用频繁刷 cache 了）。但 DRM Maintainer Daniel Vetter 对此 patch 持有反对意见，他需要 John 给出相关数据来证明 system-uncached heap 在性能上确实有所收益，否则这样的 heap 在他看来没有多大意义（而事实上 John 在邮件中也很明确告诉 Daniel，在 userspace 这一侧，Android 的 Hikey960 gralloc 以及 codec2.0 的 patch 正焦急地等待着此 patch 的合入，因为它确实带来了性能的大幅提升）。为了能尽早将这部分 Patch 合入主线，John 只能暂时先放弃 system-uncached heap 的添加，先确保重构部分的修改合入主线再来慢慢跟 Daniel 周旋。该 patch 应该会在 linux-5.11 中和大家见面。</p> 
<p>详情：<a href="https://lore.kernel.org/dri-devel/20201121235002.69945-1-john.stultz@linaro.org/" rel="nofollow" title="[PATCH v7 0/5] dma-buf: Code rework and performance improvements for system heap">[PATCH v7 0/5] dma-buf: Code rework and performance improvements for system heap</a></p> 
<h4><a id="2_drmuapi__drm_mode_get_connector__21"></a>2. drm/uapi: 为 drm_mode_get_connector 添加详细说明</h4> 
<p>Simon Ser (Weston/wlroots/Sway Maintainer) 为 drm_mode_get_connector 结构体添加了详细的注释，包括如何执行一个 GETCONNECTOR ioctl 调用，如何强制发起一次 connector probe 操作，以及何时需要使用强制 probe 操作。</p> 
<p>通常我们执行 GETCONNECTOR ioctl 需要执行2次，第一次用来获取 encoder &amp; modes &amp; property 的参数个数，用于在 userspace 为这些参数分配合适的内存空间。第二次调用则是真正的参数获取。需要注意的是，如果在两次 ioctl 中间出现了 connector hotplug，那么实际的参数个数就会发生变化，因此需要再重复调用该 ioctl 直到参数个数稳定下来。</p> 
<p>如果我们在第一次调用时传入的 count_modes 指针为 null，则是表示当前我们要发起一次 force probe 操作，force probe 操作会重新更新当前的 connector 信息（包括 status、modes、EDID 等）。但 force probe 会比较耗时，它会完全阻塞当前的 ioctl，因此如果在屏幕画面更新的过程执行 force probe 则会出现 flicker 或 freeze 的现象。通常情况下 userspace 是不需要执行 force probe 操作的，因为 kernel 驱动在初始化时就已经帮我们做了这个事情，但某些特殊场景下还会用到，比如显示器菜单中的 “Scan connectors” 选项。</p> 
<p>详情：<a href="https://lore.kernel.org/dri-devel/4NxrTtynzPiPX4SOCzxmA1sRB8fVLfeiabVpi5j3Y@cp7-web-041.plabs.ch/" rel="nofollow" title="[PATCH v3] drm: document drm_mode_get_connector">[PATCH v3] drm: document drm_mode_get_connector</a></p> 
<h4><a id="3_drmttm__30"></a>3. drm/ttm: 一些小的修改</h4> 
<p>Christian König (AMD 工程师) 对 ttm driver 做了如下修改：</p> 
<ol><li>移除 vendor driver 中多余的 #include ttm_module.h 代码</li><li>删除 sysfs 下的 ttm 目录，取而代之的是 debugfs 下的 page_pool 调试节点</li><li>只针对 use_dma_alloc 的 pool 才做初始化</li></ol> 
<p>详情：<a href="https://lore.kernel.org/dri-devel/20201117163338.1784-1-christian.koenig@amd.com/" rel="nofollow" title="[PATCH 1/4] drm/ttm/drivers: remove unecessary ttm_module.h include">[PATCH 1/4] drm/ttm/drivers: remove unecessary ttm_module.h include</a></p> 
<h3><a id="AOSP_39"></a>AOSP</h3> 
<h4><a id="1_RenderEngine__display_color_transform_40"></a>1. RenderEngine: 引入非线性 display color transform</h4> 
<p>A display color transform is a non-linear color matrix that should be applied in gamma space. Previously the non-linear display color transform is mixed into the linear color matrix that results in incorrect color inversion behaviour.</p> 
<p>详情：<a href="https://android-review.googlesource.com/c/platform/frameworks/native/+/1426642" rel="nofollow" title="aosp/native[master]: RenderEngine: Introduce non-linear display color transform">aosp/native[master]: RenderEngine: Introduce non-linear display color transform</a></p> 
<h4><a id="2_SurfaceFlinger__CaptureScreen_buffer__GRALLOC_USAGE_HW_COMPOSER_usage_46"></a>2. SurfaceFlinger: 为 CaptureScreen buffer 添加 GRALLOC_USAGE_HW_COMPOSER usage</h4> 
<p>通常截屏时会有个动画的过程，即截屏的一瞬间屏幕截图会缩放一定大小，使得屏幕截图看起来像是悬浮在当前 UI 界面上，此时屏幕截图所在的图层就需要和其它 UI 图层一起做 compose。对于有些平台来说，他们的 DPU 硬件不具有 IOMMU 功能，因此只能处理物理连续的 buffer，对于非连续 buffer 则无法处理。为了能让截图也能在这些平台上使用 DPU 做合成，它们只能通过 GRALLOC_USAGE_HW_COMPOSER 这个 usage 来告诉 gralloc 当前需要分配一个物理连续的 buffer，以便后续使用 DPU 做合成。下面的 patch 就是用来做这件事的：</p> 
<p>详情：<a href="https://android-review.googlesource.com/c/platform/frameworks/native/+/1281993" rel="nofollow" title="aosp/native[master]: SurfaceFlinger: captureScreen buffer set GRALLOC_USAGE_HW_COMPOSER usage">aosp/native[master]: SurfaceFlinger: captureScreen buffer set GRALLOC_USAGE_HW_COMPOSER usage</a></p> 
<h3><a id="Mesa_52"></a>Mesa</h3> 
<h4><a id="Mesa_2030__53"></a>Mesa 20.3.0 发布</h4> 
<p>此次发布的重要 feature 如下:</p> 
<ul><li>lavapipe for vulkan swrast</li><li>v3dv vulkan driver for raspberry PI devices</li><li>lots of clover work, in particular spir-v for clover</li><li>tons of stuff I’ve not mentioned</li></ul> 
<p>详情：<a href="https://lists.freedesktop.org/archives/mesa-announce/2020-November/000605.html" rel="nofollow" title="[Mesa-dev] [ANNOUNCE] mesa 20.3.0-rc1">[Mesa-dev] [ANNOUNCE] mesa 20.3.0-rc1</a></p> 
<h3><a id="Vulkan_62"></a>Vulkan</h3> 
<h4><a id="1_Khronos__Vulkan_Ray_Tracing_63"></a>1. Khronos 发布 Vulkan 光线追踪（Ray Tracing）最终版</h4> 
<p>11月23日，Khronos® 发布了 Vulkan®、GLSL 和 SPIR-V 扩展的最终版本，这些 spec 将光线追踪无缝地集成到了现有的 Vulkan 框架中。这是一个非常重要的里程碑，因为它是业界首个开放的、跨厂商的、跨平台的光线追踪加速标准，可以使用现有的 GPU 计算或专用的光线追踪 IP 来进行部署。Vulkan 光线追踪对于那些使用过 DirectX Raytracing（DXR）的人来说都是很熟悉的，同时它也引入了一些高级功能，例如通过光线追踪可以与 Host CPU 之间实现负载均衡的能力。虽然光线追踪将首先应用于桌面系统，但这些 Vulkan 扩展的设计目的也是在鼓励大家将其应用于移动平台。</p> 
<p>这些扩展最初于2020年3月作为临时版本发布的（详见<a href="https://blog.csdn.net/hexiaolong2009/article/details/108914679#t13" title="周刊 XDC2020 中 “Ray-tracing in Vulkan” 小节">周刊 XDC2020 中 “Ray-tracing in Vulkan” 小节</a>），从那时起 khronos 工作小组就收到了来自硬件厂商和软件开发人员的积极反馈。而此次发布的 Vulkan 光线追踪扩展规范仅仅只是个开始，在接下来的几天甚至几周内，其他生态系统组件（如 Shader 工具链和 Validation Layers 验证层）将同步更新，以支持光线追踪功能，确保开发人员可以在其应用程序中轻松使用这些扩展。这些生态系统更新的进展可以在 <a href="https://khr.io/vulkanrtfeedback" rel="nofollow" title="GitHub">GitHub</a> 上进行查询。同时，支持 Vulkan 光线追踪的 Vulkan SDK（1.2.162 或更高版本）将在12月中旬发布！</p> 
<p>此次最终版本新增了如下扩展：</p> 
<p>Vulkan extension specifications</p> 
<ul><li>VK_KHR_acceleration_structure</li><li>VK_KHR_ray_tracing_pipeline</li><li>VK_KHR_ray_query</li><li>VK_KHR_pipeline_library</li><li>VK_KHR_deferred_host_operations</li></ul> 
<p>SPIR-V extensions specifications</p> 
<ul><li>SPV_KHR_ray_tracing</li><li>SPV_KHR_ray_query</li></ul> 
<p>GLSL extensions specifications</p> 
<ul><li>GLSL_EXT_ray_tracing</li><li>GLSL_EXT_ray_query</li><li>GLSL_EXT_ray_flags_primitive_culling</li></ul> 
<p>这篇文章将着重介绍 Vulkan 光线追踪扩展的临时版本和最终版本之间主要区别，以及阐述这些修改背后的原因是什么。</p> 
<p>详情：<a href="https://www.khronos.org/blog/vulkan-ray-tracing-final-specification-release" rel="nofollow" title="Vulkan Ray Tracing Final Specification Release">Vulkan Ray Tracing Final Specification Release</a></p> 
<h4><a id="2_Khronos_Vulkan__93"></a>2. Khronos: Vulkan 光线追踪最佳实践之混合渲染</h4> 
<p>本文是对上面文章的补充，本篇将着重描述如何让 Vulkan 光线追踪和普通的光栅化操作一起混合使用，以实现实时光线追踪反射的效果，这是一种将在这篇文章中深入研究的技术，同时也将讨论 Vulkan 实时光线追踪的常用方法。本文适用于熟悉 Vulkan API 的开发人员阅读，并以 Wolfenstein:Youngblood 游戏作为案例进行讲解。</p> 
<p>详情：<a href="https://www.khronos.org/blog/vulkan-ray-tracing-best-practices-for-hybrid-rendering" rel="nofollow" title="Vulkan Ray Tracing Best Practices for Hybrid Rendering">Vulkan Ray Tracing Best Practices for Hybrid Rendering</a></p> 
<h3><a id="Wayland_98"></a>Wayland</h3> 
<h4><a id="Collabora__Wayland__Color_Management__HDR__99"></a>Collabora: 在 Wayland 中添加 Color Management 和 HDR 支持</h4> 
<p>Pekka Paalanen（Wayland/Mesa Maintainer）于11月19日在 Collabora 官网发表了一篇关于 Wayland 中 color management 和 High Dynamic Range 的文章，摘要如下：</p> 
<p>目前 Wayland 对颜色管理（Color Management）的支持仍然比较薄弱，同时还缺乏对宽色域（HDR）图像的支持，而这些功能在电影和广播行业已经流行多年了（例如Netflix HDR UI）。<br> 虽然 X11 上对颜色管理已经有了相对成熟的 tuning 工具及操作流程，但就连 X11 也没有实现对 HDR 的支持。目前在 Linux 图形系统中，在 HDR 显示器上观看 HDR 内容的唯一方法就是直接使用 DRM-KMS-API，换句话说就是不使用任何窗口系统，即不使用任何桌面环境。Kodi 是极少数能够做到这一点的应用程序，而本文则会针对以上问题，来讨论如何在 Wayland 上来解决这些问题。</p> 
<p>同时他还向 wayland 协议提交了一份关于 Color Management 的<a href="https://gitlab.freedesktop.org/swick/wayland-protocols/-/blob/color/unstable/color-management/color.rst" rel="nofollow" title="详细文档">详细文档</a>（草稿），用于在 wayland 协议中添加对颜色管理和 HDR 的支持。虽然这个 patch 可能需要经历 1～2 年的时间才能被最终合入，但是这开启了 wayland 对厂商 PQ 功能支持的大门，我们期待这一 feature 能早日合入 wayland 主线！</p> 
<p>详情：<a href="https://www.collabora.com/news-and-blog/blog/2020/11/19/developing-wayland-color-management-and-high-dynamic-range/" rel="nofollow" title="Developing Wayland Color Management and High Dynamic Range">Developing Wayland Color Management and High Dynamic Range</a></p> 
<h3><a id="_110"></a>其它</h3> 
<h4><a id="1_Dave_Airlie_Windows__Linux_Graphics__111"></a>1. Dave Airlie：为什么和 Windows 共享 Linux Graphics 驱动代码并不是件好事</h4> 
<p>最近因为 Phoronix 上的一篇关于在 Windows 和 Linux 之间共享代码文章<a href="https://www.phoronix.com/scan.php?page=article&amp;item=intel-server-igc&amp;num=1" rel="nofollow" title="《Intel's Graphics Driver Now Sharing ~60% Codebase Between Windows/Linux, 90~100% The Performance》">《Intel’s Graphics Driver Now Sharing ~60% Codebase Between Windows/Linux, 90~100% The Performance》</a>，在评论区引来了热议，对此 DRM release Maintainer Dave Airlie (RedHat, Graphics Team) 在自己的博客中发表了他的个人看法。以下是部分摘要：</p> 
<p>作为一个共享的 Windows/Linux stack，Vendor 厂商考虑更多的是他们自己的利益，而非 Linux 社区的利益。为什么这不是个好点子？我首先要说的是，这并不总是一个坏主意。从理论上讲，使用开放源码开发模型的优点来生产这样一个 stack 是可行的，但是大多数厂商似乎都失败了。他们将开源视为一种发布模式，他们在内部进行开发，并在一堆代码迭代之后每隔几周就将结果提交到 github 仓库中。他们构建包含这些开放源码的产品，但是却从不花时间去构建项目或围绕它们的社区进行互动。</p> 
<p>如果我必须共享 Windows/Linux 驱动程序栈，我将(带有偏见的)从最开放的项目开始，并将其带到一个封闭的项目中。我绝对不会以一个新的内部项目开始，试图破坏这两者。例如，如果我需要创建一个Windows OpenGL 驱动，我可以:</p> 
<p>a) 编写一个完整的 GL 实现，并每隔几周就把它抛到一边。让 Windows/Linux 用户使用它，Linux 用户失去了共享栈，发行版失去了一个依赖，而不必建立一个 multi-vendor 的依赖栈，Windows 真的没有任何收获，但我却掌握了自己的命运(社区则不受任何影响)。</p> 
<p>b) 使用 Mesa 并 upstream 我的驱动，这样就可以和 Linux 栈共享我的驱动，将 Windows 代码添加到 Mesa stack 中，这样就可以和 Windows 共享我的驱动。我与其他厂商分享了外部开发的好处，Windows 从中受益，Linux 则保留了它的生态优点。</p> 
<p>对于那些希望在操作系统之间共享更多厂商代码的人来说，这是一个警告，它通常不会以 Linux 变得更好而告终，而是会以 Linux 变得更加碎片化、难以维护以及难以持续发展而告终。</p> 
<p>详情：<a href="https://airlied.blogspot.com/2020/11/linux-graphics-why-sharing-code-with.html" rel="nofollow" title="Linux graphics, why sharing code with Windows isn't always a win">Linux graphics, why sharing code with Windows isn’t always a win</a></p> 
<h4><a id="2_Simon_Ser_10__128"></a>2. Simon Ser: 10 月月报</h4> 
<p>来自 Wayland release Maintainer Simon Ser 的月报，感兴趣的可以读一下。</p> 
<p>详情：<a href="https://emersion.fr/blog/2020/status-update-23/" rel="nofollow" title="Status update, November 2020">Status update, November 2020</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cf4cd3887de40cbeb4e6e152c4dc1367/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">自己配置微擎/微赞的的nginx负载均衡&#43;redis &#43;mysql</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3b496196f9e05ff1eb1f434cb77c656/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【国际化】vue element 国际化 切换语言 中英文  i18n</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>