<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MapReduce 2.0应用场景、原理与基本架构 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MapReduce 2.0应用场景、原理与基本架构" />
<meta property="og:description" content=" 现介绍计算框架MapReduce。MapReduce一个应用场景是有大量文件，里面存储了单词， 且一个单词占一行 。执行任务是如何统计每个单词出现的次数？ 类似应用场景有搜索引擎中，统计最流行的K个搜索词以及统计搜索词频率，帮助优化搜索词提示 。
MapReduce将作业的整个运行过程分为两个阶段 ：Map阶段和Reduce阶段 Map阶段由一定数量的Map Task组成 ：
（1）、输入数据格式解析：InputFormat； （2）、输入数据处理：Mapper ；
（3）、数据分组：Partitioner 。
Reduce阶段由一定数量的Reduce Task组成 ：
（1）、数据远程拷贝 ；
（2）、数据按照key排序； （3）、数据处理：Reducer； （4）、数据输出格式：OutputFormat。 MapReduce的内部逻辑如上图所示。inputformat从hdfs上读取split进行解析，然后输出给mapTask。map阶段的输出写在磁盘上。Partitioner阶段将不同的map结果合理的分配到相应的ReduceTask。最后，通过Outputformat将结果写到HDFS上。
Inputformat有很多继承类，实现将分片数据解析成key/value对。DBInputFormat用来读取数据库，FileInputFormat用来读取各种文件形式。还有一种空文件读取方式EmptyInputFormat。split和block是两个不同的概念。spilt是mapreduce中最小的计算单元。而block是HDFS存储的最小存储单元。其一一对应，都可以由用户任意指定。
上图所示为combiner的作用，conbiner相当于一个本地的reducer操作。将相同key的map结果进行归并。在wordcount操作中conbainer可以将同一个map输出的相同word进行统计。Partitioner决定了Map Task输出的每条数据 交给哪个Reduce Task处理。 默认实现是hash(key) mod R 。其中，R是Reduce Task数目，允许用户自定义。很多情况需自定义Partitioner，比如“hash(hostname(URL)) mod R”确保相同域 名的网页交给同一个Reduce Task处理 。
上图为mapreduce的调度原理之前已经讲解不在赘述。 Client 与MapReduce 1.0的Client类似，用户通过Client与YARN 交互，提交MapReduce作业，查询作业运行状态，管理作业等。 MRAppMaster 功能类似于 1.0中的JobTracker，但不负责资源管理。功能包括：任务划分、资源申请并将之二次分配个Map Task和Reduce Task、任务状态监控和容错。 MRAppMaster有较好容错性。一旦运行失败，由YARN的ResourceManager负责重新启 动，最多重启次数可由用户设置，默认是2次。一旦超过最高重启次数，则作业运行失败。Map Task/Reduce Task 周期性向MRAppMaster汇报心跳。一旦Task挂掉，则MRAppMaster将为之重新申请资源， 并运行之。最多重新运行次数可由用户设置，默认4次。 在任务执行过程中，应该保证数据的本地性。当不能同节点访问数据时，则会进行跨节点访问，减慢执行速度，增加网络传输负载。甚至跨机架访问数据延时会更严重。MapReduce的应用场景包括：简单的数据统计，比如网站pv、uv统计、搜索引擎建索引、海量数据查找、复杂数据分析算法实现。例如：聚类算法 、分类算法、推荐算法以及图算法。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3e823420433f22d3684748aef14be345/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-05T19:15:36+08:00" />
<meta property="article:modified_time" content="2016-07-05T19:15:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MapReduce 2.0应用场景、原理与基本架构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>   <span style="font-size:18px">      现介绍计算框架MapReduce。<span style="font-size:18px">MapReduce一个</span>应用场景是有大量文件，里面存储了单词， 且一个单词占一行 。执行任务是如何统计每个单词出现的次数？ 类似应用场景有搜索引擎中，统计最流行的K个搜索词以及统计搜索词频率，帮助优化搜索词提示 。</span></p> 
<p><span style="font-size:18px">        MapReduce将作业的整个运行过程分为两个阶段 ：Map阶段和Reduce阶段 </span></p> 
<p><span style="font-size:18px">        Map阶段由一定数量的Map Task组成 ：<br>         （1）、输入数据格式解析：InputFormat； </span></p> 
<p><span style="font-size:18px">        （2）、输入数据处理：Mapper ；</span></p> 
<p><span style="font-size:18px">        （3）、数据分组：Partitioner 。</span></p> 
<p><span style="font-size:18px">        Reduce阶段由一定数量的Reduce Task组成 ：<br>         <span style="font-size:18px">（1）、</span>数据远程拷贝 ；</span></p> 
<p><span style="font-size:18px">        <span style="font-size:18px">（2）、</span>数据按照key排序； </span></p> 
<p><span style="font-size:18px">        <span style="font-size:18px">（3）、</span>数据处理：Reducer； </span></p> 
<p><span style="font-size:18px">        <span style="font-size:18px">（4）、</span>数据输出格式：OutputFormat。 </span></p> 
<p><span style="font-size:18px"><br> </span></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/6d/3b/uqyCqAoD_o.png" alt="" style="font-size:18px"></p> 
<p style="text-align:center"><br> </p> 
<p style="text-align:left">           <span style="font-size:18px">MapReduce的内部逻辑如上图所示。inputformat从hdfs上读取split进行解析，然后输出给mapTask。map阶段的输出写在磁盘上。Partitioner阶段将不同的map结果合理的分配到相应的ReduceTask。最后，通过Outputformat将结果写到HDFS上。</span></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/55/9d/hxICZRTM_o.png" alt="" style="font-size:18px"></p> 
<p style="text-align:left">            <span style="font-size:18px">Inputformat有很多继承类，实现将分片数据解析成key/value对。DBInputFormat用来读取数据库，FileInputFormat用来读取各种文件形式。还有一种空文件读取方式EmptyInputFormat。split和block是两个不同的概念。spilt是mapreduce中最小的计算单元。而block是HDFS存储的最小存储单元。其一一对应，都可以由用户任意指定。</span></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/ed/5c/wFI0GZrf_o.png" alt="" style="font-size:18px"></p> 
<p style="text-align:left">           <span style="font-size:18px">上图所示为combiner的作用，conbiner相当于一个本地的reducer操作。将相同key的map结果进行归并。在wordcount操作中conbainer可以将同一个map输出的相同word进行统计。Partitioner决定了Map Task输出的每条数据 交给哪个Reduce Task处理。 默认实现是hash(key) mod R 。其中，R是Reduce Task数目，允许用户自定义。很多情况需自定义Partitioner，比如“hash(hostname(URL)) mod R”确保相同域 名的网页交给同一个Reduce Task处理 。</span></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/22/6a/SsOe2Ji7_o.png" alt="" style="font-size:18px"></p> 
<p style="text-align:left">           <span style="font-size:18px"> 上图为mapreduce的调度原理之前已经讲解不在赘述。 Client 与MapReduce 1.0的Client类似，用户通过Client与YARN 交互，提交MapReduce作业，查询作业运行状态，管理作业等。  MRAppMaster 功能类似于 1.0中的JobTracker，但不负责资源管理。功能包括：任务划分、资源申请并将之二次分配个Map Task和Reduce Task、任务状态监控和容错。 MRAppMaster有较好容错性。一旦运行失败，由YARN的ResourceManager负责重新启 动，最多重启次数可由用户设置，默认是2次。一旦超过最高重启次数，则作业运行失败。Map Task/Reduce Task 周期性向MRAppMaster汇报心跳。一旦Task挂掉，则MRAppMaster将为之重新申请资源， 并运行之。最多重新运行次数可由用户设置，默认4次。 </span></p> 
<p style="text-align:center"><img src="https://images2.imgbox.com/5d/9f/Zrqqou7q_o.png" alt="" style="font-size:18px"></p> 
<p style="text-align:left"><br> </p> 
<p style="text-align:left">           <span style="font-size:18px">在任务执行过程中，应该保证数据的本地性。当不能同节点访问数据时，则会进行跨节点访问，减慢执行速度，增加网络传输负载。甚至跨机架访问数据延时会更严重。MapReduce的应用场景包括：简单的数据统计，比如网站pv、uv统计、搜索引擎建索引、海量数据查找、复杂数据分析算法实现。例如：聚类算法 、分类算法、推荐算法以及图算法。 </span></p> 
<p style="text-align:center"></p> 
<p style="text-align:center"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/46fbeff3c3287c784fae81bc5b20cf7c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络通信之如何广播发送</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/969bfb2a30c76bd83d5286684994c6f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">markdown文本居中，段首缩进的方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>