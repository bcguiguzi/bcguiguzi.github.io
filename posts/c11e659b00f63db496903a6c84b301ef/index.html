<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Python笔记-设计模式】访问者模式 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Python笔记-设计模式】访问者模式" />
<meta property="og:description" content="一、说明 访问者模式是一种行为设计模式，它能在不改变元素类的情况下定义对元素对象的新操作
(一) 解决问题 将算法与对象结构分离，使得算法可以独立于对象结构而变化。主要解决在不改变对象结构的前提下，增加新的操作或功能
(二) 使用场景 对象结构中的元素需要不同方式的操作，并且这些操作需要相互独立，不影响元素类的稳定性和扩展性。对象结构中的元素类经常变化，但是需要为对象结构中的元素添加新的操作。需要对一个对象结构中的元素进行复杂的、多变的操作，而不希望这些操作污染元素类。 二、结构 访问者（Visitor）接口声明了一系列以对象结构的具体元素为参数的访问者方法。如果编程语言支持重载，这些方法的名称可以是相同的，但是其参数一定是不同的。具体访问者（ConcreteVisitor）会为不同的具体元素类实现相同行为的几个不同版本。元素（Element）接口声明了一个方法来“接收”访问者。该方法必须有一个参数被声明为访问者接口类型。具体元素（ConcreteElement）必须实现接收方法。该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。请注意，即使元素基类实现了该方法，所有子类都必须对其进行重写并调用访问者对象中的合适方法。客户端（Client）通常会作为集合或其他复杂对象（例如一个组合树）的代表。客户端通常不知晓所有的具体元素类，因为它们会通过抽象接口与集合中的对象进行交互。 三、伪代码 #!/usr/bin/env python # -*- coding: UTF-8 -*- __doc__ = &#34;&#34;&#34; 访问者模式 例：病人（元素类）有两种类型：急诊病人和住院病人。医生和护士（访问者）对不同类型的病人进行不同的操作。 通过访问者模式，可以实现对病人的管理和处理，而不需要修改病人类的代码。 &#34;&#34;&#34; from abc import ABC, abstractmethod class Patient(ABC): &#34;&#34;&#34;元素基类（病人基类）&#34;&#34;&#34; @abstractmethod def accept(self, visitor): pass class EmergencyPatient(Patient): &#34;&#34;&#34;元素具体类（急诊病人）&#34;&#34;&#34; def accept(self, visitor): visitor.visit_emergency_patient(self) class Inpatient(Patient): &#34;&#34;&#34;元素具体类（住院病人）&#34;&#34;&#34; def accept(self, visitor): visitor.visit_inpatient(self) class Visitor(ABC): &#34;&#34;&#34;访问者基类&#34;&#34;&#34; @abstractmethod def visit_emergency_patient(self, patient): pass @abstractmethod def visit_inpatient(self, patient): pass class Doctor(Visitor): &#34;&#34;&#34;具体访问者，医生类&#34;&#34;&#34; def visit_emergency_patient(self, patient): print(f&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c11e659b00f63db496903a6c84b301ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-01T09:32:04+08:00" />
<meta property="article:modified_time" content="2024-03-01T09:32:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Python笔记-设计模式】访问者模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="400" id="ufe77e88e" src="https://images2.imgbox.com/8b/8a/62opLa9o_o.png" width="640"></p> 
<h2 id="p9BcO">一、说明</h2> 
<p id="u79f47d9f"><strong>访问者模式</strong>是一种行为设计模式，它能在不改变元素类的情况下定义对元素对象的新操作</p> 
<h3 id="r5LkG">(一) 解决问题</h3> 
<p id="u9fded937">将算法与对象结构分离，使得算法可以独立于对象结构而变化。主要解决在不改变对象结构的前提下，增加新的操作或功能</p> 
<h3 id="gcXoU">(二) 使用场景</h3> 
<ul><li id="uf2321cb8">对象结构中的元素需要不同方式的操作，并且这些操作需要相互独立，不影响元素类的稳定性和扩展性。</li><li id="uada9daa5">对象结构中的元素类经常变化，但是需要为对象结构中的元素添加新的操作。</li><li id="u94ece5c2">需要对一个对象结构中的元素进行复杂的、多变的操作，而不希望这些操作污染元素类。</li></ul> 
<h2 id="S4ZVK">二、结构</h2> 
<p class="img-center"><img alt="" height="400" id="ud7e1a8a9" src="https://images2.imgbox.com/e0/66/FrHPWr5q_o.png" width="371"></p> 
<ol><li id="u36f9683d"><strong>访问者（Visitor）</strong>接口声明了一系列以对象结构的具体元素为参数的访问者方法。如果编程语言支持重载，这些方法的名称可以是相同的，但是其参数一定是不同的。</li><li id="u4c411bc3"><strong>具体访问者（ConcreteVisitor）</strong>会为不同的具体元素类实现相同行为的几个不同版本。</li><li id="u481dd960"><strong>元素（Element）</strong>接口声明了一个方法来“接收”访问者。该方法必须有一个参数被声明为访问者接口类型。</li><li id="ue203bb39"><strong>具体元素（ConcreteElement）</strong>必须实现接收方法。该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。请注意，即使元素基类实现了该方法，所有子类都必须对其进行重写并调用访问者对象中的合适方法。</li><li id="ud68ee464"><strong>客户端（Client）</strong>通常会作为集合或其他复杂对象（例如一个组合树）的代表。客户端通常不知晓所有的具体元素类，因为它们会通过抽象接口与集合中的对象进行交互。</li></ol> 
<h2 id="VZCxe">三、伪代码</h2> 
<pre id="qk0wS"><code class="language-python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
__doc__ = """
访问者模式

例：病人（元素类）有两种类型：急诊病人和住院病人。医生和护士（访问者）对不同类型的病人进行不同的操作。
通过访问者模式，可以实现对病人的管理和处理，而不需要修改病人类的代码。
"""

from abc import ABC, abstractmethod


class Patient(ABC):
    """元素基类（病人基类）"""
    @abstractmethod
    def accept(self, visitor):
        pass


class EmergencyPatient(Patient):
    """元素具体类（急诊病人）"""
    def accept(self, visitor):
        visitor.visit_emergency_patient(self)


class Inpatient(Patient):
    """元素具体类（住院病人）"""
    def accept(self, visitor):
        visitor.visit_inpatient(self)


class Visitor(ABC):
    """访问者基类"""
    @abstractmethod
    def visit_emergency_patient(self, patient):
        pass

    @abstractmethod
    def visit_inpatient(self, patient):
        pass


class Doctor(Visitor):
    """具体访问者，医生类"""
    def visit_emergency_patient(self, patient):
        print(f"医生对急诊病人 {patient} 进行检查和治疗。")

    def visit_inpatient(self, patient):
        print(f"医生对住院病人 {patient} 进行观察和治疗。")


class Nurse(Visitor):
    """具体访问者，护士类"""
    def visit_emergency_patient(self, patient):
        print(f"护士对急诊病人 {patient} 进行急救和护理。")

    def visit_inpatient(self, patient):
        print(f"护士对住院病人 {patient} 进行护理和照顾。")


if __name__ == "__main__":
    """
        医生对急诊病人 &lt;__main__.EmergencyPatient object at 0x104e46ac0&gt; 进行检查和治疗。
        护士对急诊病人 &lt;__main__.EmergencyPatient object at 0x104e46ac0&gt; 进行急救和护理。
        医生对住院病人 &lt;__main__.Inpatient object at 0x104e46a30&gt; 进行观察和治疗。
        护士对住院病人 &lt;__main__.Inpatient object at 0x104e46a30&gt; 进行护理和照顾。
    """
    patients = [EmergencyPatient(), Inpatient()]
    doctor = Doctor()
    nurse = Nurse()

    for patient in patients:
        patient.accept(doctor)
        patient.accept(nurse)
</code></pre> 
<h2 id="RdqU2">四、优缺点</h2> 
<h3>优点</h3> 
<ul><li id="u3cf23690">开闭原则：你可以引入在不同类对象上执行的新行为，且无需对这些类做出修改。</li><li id="u9fa84681">单一职责原则：可将同一行为的不同版本移到同一个类中。</li></ul> 
<h3>缺点</h3> 
<ul><li id="u6598b25f">增加新的元素类很困难，因为需要修改所有的访问者类</li><li id="u63f08dc8">访问者模式要求具有稳定的对象结构，如果对象结构经常变化，则会导致访问者类的频繁修改，不利于系统的维护和扩展。</li><li id="u0d56a40f">访问者模式会使代码变得更加复杂，因为它引入了额外的类和接口，增加了系统的抽象性和理解难度</li></ul> 
<hr> 
<p><a href="https://blog.csdn.net/weixin_44904331/article/details/135881751?spm=1001.2014.3001.5502" title="【Python笔记】设计模式-CSDN博客">【Python笔记】设计模式-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f50d04269aa66a84383e2b5074f9a6e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FMD 8位MCU入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44bf4374a434362282f50acea210ca8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python笔记-设计模式】模板方法模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>