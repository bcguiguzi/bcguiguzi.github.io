<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ssh命令详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ssh命令详解" />
<meta property="og:description" content="名称
ssh — OpenSSH SSH客户端（远程登录程序）
概要
ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char]
[-F configfile] [-I pkcs11] [-i identity_file] [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd]
[-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname
[command]
描述
ssh（SSH客户端）是一个用于登录到远程计算机并在远程计算机上执行命令的程序。它旨在提供在不安全网络上的两个不受信任主机之间的安全加密通信。还可以通过安全通道转发X11连接、任意TCP端口和UNIX域套接字。
ssh连接并登录到指定的主机名（可选用户名称）。用户必须通过以下几种方法之一证明自己的身份（请参阅下文）。
如果指定了命令，则在远程主机上执行该命令，而不是登录shell。
以下是选项：
-1 强制ssh尝试仅使用协议版本1。
-2 强制ssh尝试仅使用协议版本2。
-4 强制ssh仅使用IPv4地址。
-6 强制ssh仅使用IPv6地址。
-A 启用身份验证代理连接的转发。这也可以在配置文件中的每个主机上指定。
应谨慎启用代理转发。具有绕过远程主机上文件权限（用于代理的UNIX域套接字）的能力的用户可以通过转发的连接访问本地代理。攻击者无法从代理获取密钥材料，但他们可以执行使用加载到代理中的标识进行身份验证的操作。
-a 禁用身份验证代理连接的转发。
-b bind_address" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/be40f359e8637a757f3f56c0769ba627/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-15T10:49:10+08:00" />
<meta property="article:modified_time" content="2024-01-15T10:49:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ssh命令详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>名称<br>      ssh — OpenSSH SSH客户端（远程登录程序）</p> 
<p>概要<br>      ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char]<br>          [-F configfile] [-I pkcs11] [-i identity_file] [-J [user@]host[:port]] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd]<br>          [-o option] [-p port] [-Q query_option] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname<br>          [command]</p> 
<p>描述<br>      ssh（SSH客户端）是一个用于登录到远程计算机并在远程计算机上执行命令的程序。它旨在提供在不安全网络上的两个不受信任主机之间的安全加密通信。还可以通过安全通道转发X11连接、任意TCP端口和UNIX域套接字。</p> 
<p>     ssh连接并登录到指定的主机名（可选用户名称）。用户必须通过以下几种方法之一证明自己的身份（请参阅下文）。</p> 
<p>     如果指定了命令，则在远程主机上执行该命令，而不是登录shell。</p> 
<p>     以下是选项：</p> 
<p>     -1      强制ssh尝试仅使用协议版本1。</p> 
<p>     -2      强制ssh尝试仅使用协议版本2。</p> 
<p>     -4      强制ssh仅使用IPv4地址。</p> 
<p>     -6      强制ssh仅使用IPv6地址。</p> 
<p>     -A      启用身份验证代理连接的转发。这也可以在配置文件中的每个主机上指定。</p> 
<p>             应谨慎启用代理转发。具有绕过远程主机上文件权限（用于代理的UNIX域套接字）的能力的用户可以通过转发的连接访问本地代理。攻击者无法从代理获取密钥材料，但他们可以执行使用加载到代理中的标识进行身份验证的操作。</p> 
<p>     -a      禁用身份验证代理连接的转发。</p> 
<p>     -b bind_address<br>              在本地机器上使用bind_address作为连接的源地址。仅在具有多个地址的系统上有用。</p> 
<p>     -C      请求对所有数据（包括stdin、stdout、stderr以及用于转发的X11、TCP和UNIX域连接的数据）进行压缩。压缩算法与gzip(1)使用的相同，可以通过协议版本1的CompressionLevel选项控制“级别”。在调制解调器线路和其他慢速连接上压缩是有益的，但在快速网络上只会减慢速度。默认值可以在配置文件中按主机设置；请参阅Compression选项。</p> 
<p>     -c cipher_spec<br>              选择用于加密会话的密码规范。</p> 
<p>             协议版本1允许指定单个密码。支持的值有“3des”、“blowfish”和“des”。对于协议版本2，cipher_spec是按首选顺序列出的以逗号分隔的密码列表。有关更多信息，请参阅ssh_config(5)中的Ciphers关键字。</p> 
<p>     -D [bind_address:]port<br>              指定本地“动态”应用级端口转发。这通过分配一个套接字来监听本地侧的端口，可选地绑定到指定的bind_address。每当连接到此端口时，连接都会通过安全通道转发，并且然后使用应用程序协议确定从远程机器连接到何处。目前支持SOCKS4和SOCKS5协议，ssh将充当SOCKS服务器。只有root可以转发特权端口。动态端口转发也可以在配置文件中指定。</p> 
<p>             IPv6地址可以通过将地址括在方括号中来指定。只有超级用户可以转发特权端口。默认情况下，根据GatewayPorts设置，绑定本地端口。但是，可以使用显式的bind_address将连接绑定到特定地址。 “localhost”的bind_address表示仅绑定本地使用的侦听端口，而空地址或‘*’表示端口应从所有接口可用。</p> 
<p>     -E log_file<br>              将调试日志追加到log_file，而不是标准错误。</p> 
<p>     -e escape_char<br>              为具有pty的会话设置转义字符（默认为‘~’）。转义字符仅在行的开头被识别。转义字符后跟一个点（‘.’）将关闭连接；后跟控制-Z将挂起连接；后跟它本身将发送转义字符一次。将字符设置为“none”将禁用任何转义，使会话完全透明。</p> 
<p>     -F configfile<br>              指定替代的每用户配置文件。如果在命令行上给出了配置文件，则将忽略系统范围的配置文件（/etc/ssh/ssh_config）。每用户配置文件的默认值为~/.ssh/config。</p> 
<p>     -f      请求ssh在执行命令之前切换到后台。如果ssh将要请求密码或密码短语，但用户希望在后台运行它，这很有用。这意味着-n。在远程站点启动X11程序的推荐方式是使用ssh -f host xterm。</p> 
<p>             如果ExitOnForwardFailure配置选项设置为“yes”，则使用-f启动的客户端将等待所有远程端口转发成功建立后再将其放入后台。</p> 
<p>     -G      导致ssh在评估Host和Match块后打印其配置并退出。</p> 
<p>     -g      允许远程主机连接到本地转发的端口。如果在复用的连接上使用，则必须在主进程上指定此选项。</p> 
<p>     -I pkcs11<br>              指定ssh应使用的PKCS＃11共享库，以与提供用户私有RSA密钥的PKCS＃11令牌进行通信。</p> 
<p>     -i identity_file<br>              选择用于公钥身份验证的身份（私钥）的文件。协议版本1的默认值为~/.ssh/identity，协议版本2的默认值为~/.ssh/id_dsa、~/.ssh/id_ecdsa、~/.ssh/id_ed25519和~/.ssh/id_rsa。身份文件也可以在配置文件中按主机指定。可以使用多个-i选项（以及在配置文件中指定的多个身份）。</p> 
<p>     如果没有明确指定CertificateFile指令的证书，ssh还将尝试从将-cert.pub附加到身份文件名的文件中加载证书信息。</p> 
<p>     -J [user@]host[:port]<br>              通过首先与跳转主机建立ssh连接，然后从那里建立到最终目的地的TCP转发来连接到目标主机。可以通过逗号字符分隔的多个跳转跳跃来指定多个跳转跳跃。这是指定ProxyJump配置指令的快捷方式。</p> 
<p>     -K      启用基于GSSAPI的身份验证和凭据（委派）的转发到服务器。</p> 
<p>     -k      禁用对服务器的GSSAPI凭据的转发（委派）。</p> 
<p>     -L [bind_address:]port:host:hostport<br>      -L [bind_address:]port:remote_socket<br>      -L local_socket:host:hostport<br>      -L local_socket:remote_socket<br>              指定将本地（客户端）主机上给定的TCP端口或Unix套接字的连接转发到远程主机上给定的主机和端口或Unix套接字。这通过分配一个套接字来监听本地侧的TCP端口或可选地绑定到指定的bind_address，或者监听Unix套接字。每当在本地端口或套接字上进行连接时，连接都会通过安全通道转发，并且然后使用远程机器上的主机端口hostport或Unix套接字remote_socket进行连接。</p> 
<p>             端口转发也可以在配置文件中指定。只有超级用户可以转发特权端口。IPv6地址可以通过将地址括在方括号中来指定。</p> 
<p>             默认情况下，根据GatewayPorts设置，本地端口将绑定。但是，可以使用显式的bind_address将连接绑定到特定地址。“localhost”的bind_address表示仅绑定本地使用的侦听端口，而空地址或‘*’表示端口应从所有接口可用。</p> 
<p>     -l login_name<br>              指定要在远程机器上登录的用户。这也可以在配置文件中按主机指定。</p> 
<p>     -M      将ssh客户端置于“主”模式，以进行连接共享。多个-M选项将ssh放入需要在接受从属连接之前等待确认的“主”模式。有关详细信息，请参阅ssh_config(5)中的ControlMaster描述。</p> 
<p>     -m mac_spec<br>              以首选顺序指定的逗号分隔的MAC（消息认证代码）算法列表。有关更多信息，请参阅MACs关键字。</p> 
<p>     -N      不要执行远程命令。这对于仅转发端口很有用。</p> 
<p>     -n      将stdin重定向到/dev/null（实际上，阻止从stdin读取）。在ssh在后台运行时必须使用此选项。一个常见的技巧是在远程机器上运行X11程序。例如，ssh -n shadows.cs.hut.fi emacs &amp; 将在shadows.cs.hut.fi上启动一个emacs，X11连接将自动通过加密通道转发。ssh程序将放入后台。（如果ssh需要请求密码或密码短语，则此选项无效；也请参阅-f选项。）<br>      -O ctl_cmd<br> 控制活动连接多路复用主进程。指定了 -O 选项时，ctl_cmd 参数将被解释并传递给主进程。有效的命令有：“check”（检查主进程是否在运行）、“forward”（请求进行转发而无需执行命令）、“cancel”（取消转发）、“exit”（请求主进程退出）和“stop”（请求主进程停止接受进一步的多路复用请求）。<br>       -o option<br>          用于以与配置文件中使用的格式提供选项。这对于指定没有单独的命令行标志的选项很有用。有关下面列出的选项及其可能值的详细信息，请参阅 ssh_config(5)。<br>       -p port<br> 连接到远程主机的端口。这可以在配置文件中以每个主机的方式指定。<br>  -Q query_option<br>          查询 ssh 支持的指定版本 2 的算法。可用的功能有：cipher（支持的对称加密算法）、cipher-auth（支持进行身份验证的对称加密算法）、mac（支持的消息完整性代码）、kex（密钥交换算法）、key（密钥类型）、key-cert（证书密钥类型）、key-plain（非证书密钥类型）和 protocol-version（支持的 SSH 协议版本）。</p> 
<p> -q      安静模式。导致大多数警告和诊断消息被抑制。</p> 
<p> -R [bind_address:]port:host:hostport<br>  -R [bind_address:]port:local_socket<br>  -R remote_socket:host:hostport<br>  -R remote_socket:local_socket<br>          指定将连接到远程（服务器）主机上的给定 TCP 端口或 Unix 套接字转发到本地端口指定的主机和端口，或 Unix 套接字。这通过在远程一侧分配一个套接字来实现，该套接字可监听远程一侧的 TCP 端口或 Unix 套接字。每当在本地端口或套接字上建立连接时，连接都会通过安全通道进行转发，并且会从本地机器上到达 hostport 或 local_socket 的地方建立连接。</p> 
<p>         端口转发也可以在配置文件中指定。只有以 root 用户登录到远程机器时，才能转发特权端口。IPv6 地址可以用方括号括起来指定。</p> 
<p>         默认情况下，服务器上的 TCP 监听套接字将仅绑定到回环接口。这可以通过指定 bind_address 来覆盖。空的 bind_address 或地址 '*' 表示远程套接字应在所有接口上监听。仅当服务器的 GatewayPorts 选项启用时（请参阅 sshd_config(5)），才能成功指定远程 bind_address。</p> 
<p>         如果 port 参数为 '0'，则服务器上将在运行时动态分配监听端口，并将其报告给客户端。当与 -O forward 一起使用时，分配的端口将打印到标准输出。</p> 
<p> -S ctl_path<br>          指定连接共享的控制套接字的位置，或字符串 “none” 以禁用连接共享。有关详细信息，请参阅 ssh_config(5) 中 ControlPath 和 ControlMaster 的描述。</p> 
<p> -s      用于请求在远程系统上调用子系统。子系统有助于使用 SSH 作为其他应用程序的安全传输（例如 sftp(1)）。</p> 
<p> -T      禁用伪终端分配。</p> 
<p> -t      强制伪终端分配。这可用于在远程机器上执行任意基于屏幕的程序，这可能非常有用，例如在实现菜单服务时。多个 -t 选项会强制 tty 分配，即使 ssh 没有本地 tty。</p> 
<p> -V      显示版本号并退出。</p> 
<p> -v      详细模式。导致 ssh 打印有关其进度的调试消息。这对于调试连接、身份验证和配置问题很有帮助。多个 -v 选项会增加详细程度。最大为 3。</p> 
<p> -W host:port<br>          请求将客户端上的标准输入和输出转发到主机上的端口。意味着 -N、-T、ExitOnForwardFailure 和 ClearAllForwardings，尽管这些可以在配置文件中或使用 -o 命令行选项中进行覆盖。</p> 
<p> -w local_tun[:remote_tun]<br>          请求使用指定的 tun(4) 设备进行隧道设备转发，该设备位于客户端（local_tun）和服务器（remote_tun）之间。</p> 
<p>         可以通过数字 ID 或关键字 “any” 指定设备。如果未指定 remote_tun，则默认为 “any”。还请参阅 ssh_config(5) 中的 Tunnel 和 TunnelDevice 指令。如果未设置 Tunnel 指令，则将其设置为默认的隧道模式，即 “point-to-point”。</p> 
<p> -X      启用 X11 转发。这也可以在配置文件中以每个主机的方式指定。</p> 
<p>         应谨慎启用 X11 转发。具有绕过远程主机上文件权限的能力（用于用户的 X 授权数据库）的用户可以通过转发的连接访问本地 X11 显示。然后，攻击者可能能够执行诸如按键监控之类的活动。</p> 
<p>         出于这个原因，默认情况下，X11 转发受到 X11 SECURITY 扩展限制的约束。请参阅 ssh -Y 选项和 ssh_config(5) 中的 ForwardX11Trusted 指令以获取更多信息。</p> 
<p> -x      禁用 X11 转发。</p> 
<p> -Y      启用受信任的 X11 转发。受信任的 X11 转发不受 X11 SECURITY 扩展控制的约束。</p> 
<p> -y      使用 syslog(3) 系统模块发送日志信息。默认情况下，此信息将发送到 stderr。</p> 
<p> ssh 还可以从每个用户的配置文件和系统范围的配置文件中获取配置数据。文件格式和配置选项的详细信息在 ssh_config(5) 中有描述。<br> 身份认证<br> OpenSSH SSH客户端支持SSH协议1和2。默认情况下仅使用协议2，但可以通过ssh_config(5)中的Protocol选项或-1和-2选项进行更改（见上文）。不应使用协议1，仅为支持传统设备而提供。它存在一些密码学弱点，并不支持协议2中可用的许多高级功能。</p> 
<p>可用于身份验证的方法包括：基于GSSAPI的身份验证，基于主机的身份验证，公钥身份验证，挑战-响应身份验证和密码身份验证。尽管可以使用PreferredAuthentications更改默认顺序，但身份验证方法将按上述顺序尝试。</p> 
<p>基于主机的身份验证的工作方式如下：如果用户登录的机器列在远程机器的/etc/hosts.equiv或/etc/ssh/shosts.equiv中，并且双方的用户名相同，或者如果用户的主目录中存在~/.rhosts或~/.shosts文件，并包含包含客户机器名称和该机器上用户名称的行，则考虑用户登录。此外，服务器必须能够验证客户机的主机密钥（参见下文的/etc/ssh/ssh_known_hosts和~/.ssh/known_hosts的描述）以允许登录。此身份验证方法关闭由于IP欺骗，DNS欺骗和路由欺骗而引起的安全漏洞。[管理员注意：/etc/hosts.equiv，~/.rhosts以及rlogin/rsh协议总体上是不安全的，如果需要安全性，则应禁用]</p> 
<p>公钥身份验证的工作方式如下：该方案基于公钥密码学，使用分别使用不同密钥进行加密和解密的密码系统，从加密密钥推导解密密钥是不可行的。每个用户为身份验证目的创建公/私密钥对。服务器知道公钥，只有用户知道私钥。ssh自动实现公钥身份验证协议，使用DSA，ECDSA，Ed25519或RSA算法之一。ssl(8)的HISTORY部分包含对DSA和RSA算法的简要讨论。</p> 
<p>~/.ssh/authorized_keys文件列出了允许登录的公钥。当用户登录时，ssh程序告诉服务器它想要用于身份验证的密钥对。客户端证明它可以访问私钥，服务器检查相应的公钥是否被授权接受该帐户。</p> 
<p>用户通过运行ssh-keygen(1)创建他/她的密钥对。这将私钥存储在~/.ssh/identity（协议1），/.ssh/id_dsa（DSA），/.ssh/id_ecdsa（ECDSA），/.ssh/id_ed25519（Ed25519）或/.ssh/id_rsa（RSA）中，并将公钥存储在用户的主目录中的~/.ssh/identity.pub（协议1），/.ssh/id_dsa.pub（DSA），/.ssh/id_ecdsa.pub（ECDSA），/.ssh/id_ed25519.pub（Ed25519）或/.ssh/id_rsa.pub（RSA）。然后，用户应将公钥复制到远程机器上主目录中的~/.ssh/authorized_keys中。authorized_keys文件对应于传统的~/.rhosts文件，每行一个密钥，尽管每行可以非常长。之后，用户可以在不提供密码的情况下登录。</p> 
<p>公钥身份验证的一个变体以证书身份验证的形式可用：使用签名证书，而不是一组公/私密钥。这有一个优势，即可以使用单个受信任的认证机构代替许多公/私密钥。有关详细信息，请参阅ssh-keygen(1)的CERTIFICATES部分。</p> 
<p>使用公钥或证书身份验证的最便捷方式可能是使用身份验证代理。有关详细信息，请参阅ssh-agent(1)和（可选的）ssh_config(5)中的AddKeysToAgent指令。</p> 
<p>挑战-响应身份验证的工作方式如下：服务器发送任意“挑战”文本，并提示用户响应。挑战-响应身份验证的示例包括BSD身份验证（请参阅login.conf(5)）和PAM（某些非OpenBSD系统）。</p> 
<p>最后，如果其他身份验证方法失败，ssh会提示用户输入密码。密码发送到远程主机进行验证；但是，由于所有通信都是加密的，因此密码不能被正在监听网络的人看到。</p> 
<p>ssh会自动维护和检查包含其曾经使用过的所有主机的身份的数据库。主机密钥存储在用户主目录中的~/.ssh/known_hosts中。此外，文件/etc/ssh/ssh_known_hosts会自动检查已知主机。任何新主机都会自动添加到用户的文件中。如果主机的身份标识发生更改，ssh会发出警告并禁用密码身份验证，以防止服务器欺骗或中间人攻击，后者可以用于规遍加密。StrictHostKeyChecking选项可用于控制对主机密钥不知道或已更改的机器的登录。</p> 
<p>当服务器接受了用户的身份后，服务器将执行非交互会话中指定的命令，或者如果没有指定命令，则登录到该机器并为用户提供正常的shell，作为交互会话。与远程命令或shell的所有通信都将自动加密。</p> 
<p>如果请求交互会话，默认情况下ssh仅在客户端具有伪终端（pty）时才会请求伪终端（pty）。可以使用-T和-t标志覆盖此行为。</p> 
<p>如果分配了伪终端，则用户可以使用下面指定的转义字符。<br> 如果没有分配伪终端，会话是透明的，可以用于可靠地传输二进制数据。在大多数系统上，将转义字符设置为“none”也会使会话透明，即使使用了tty。</p> 
<p>会话在远程机器上的命令或shell退出并关闭所有X11和TCP连接时终止。</p> 
<p>转义字符<br> 当请求伪终端时，ssh通过使用转义字符支持许多功能。</p> 
<p>可以发送单个波浪符作为~~或在波浪符后跟一个不是下面描述的字符。转义字符必须始终在换行符之后才能被解释为特殊字符。可以通过在配置文件中使用EscapeChar配置指令或通过命令行使用-e选项更改转义字符。</p> 
<p>支持的转义字符（假定默认为‘~’）包括：</p> 
<p>    ~. 断开连接。<br>     ~^Z 将ssh放入后台。<br>     ~# 列出转发的连接。<br>     ~&amp; 在等待转发连接/X11会话终止时在注销时将ssh放入后台。<br>     ~? 显示转义字符列表。<br>     ~B 向远程系统发送BREAK（仅在对等方支持时有用）。<br>     ~C 打开命令行。当前，这允许使用-L，-R和-D选项（见上文）添加端口转发。它还允许使用-KL[bind_address:]port取消现有的本地端口转发，使用-KR[bind_address:]port取消现有的远程端口转发，使用-KD[bind_address:]port取消动态端口转发。如果在ssh_config(5)中启用了PermitLocalCommand选项，则!command允许用户执行本地命令。使用-h选项可以获得基本帮助。<br>     ~R 请求重新建立连接（仅在对等方支持时有用）。<br>     ~V 在将错误写入stderr时减少详细程度（LogLevel）。<br>     ~v 在将错误写入stderr时增加详细程度（LogLevel）。</p> 
<p>TCP转发<br> 可以在命令行或配置文件中指定通过安全通道转发任意TCP连接。TCP转发的一个可能的应用是与邮件服务器建立安全连接；另一个是通过防火墙。</p> 
<p>在下面的示例中，我们查看在IRC客户端和服务器之间加密通信，即使IRC服务器不直接支持加密通信。工作方式如下：用户使用ssh连接到远程主机，指定要用于将连接转发到远程服务器的端口。之后，可以在客户机上启动要加密的服务，连接到相同的本地端口，并且ssh将加密并转发连接。</p> 
<p>以下示例将IRC会话从客户机“127.0.0.1”（localhost）隧道到远程服务器“server.example.com”：</p> 
<p>bash</p> 
<p>$ ssh -f -L 1234:localhost:6667 server.example.com sleep 10<br> $ irc -c '#users' -p 1234 pinky 127.0.0.1</p> 
<p>这将隧道连接到IRC服务器“server.example.com”，加入通道“#users”，昵称为“pinky”，使用端口1234。使用哪个端口并不重要，只要它大于1023（请记住，只有root可以在特权端口上打开套接字），并且不与已使用的任何端口冲突。连接将转发到远程服务器上的端口6667，因为那是IRC服务的标准端口。</p> 
<p>使用-f选项将ssh放入后台，指定远程命令“sleep 10”是为了允许一定时间（在示例中为10秒）启动要进行隧道传输的服务。如果在指定的时间内没有进行连接，ssh将退出。</p> 
<p>X11转发<br> 如果ForwardX11变量设置为“yes”（或参见上述-X，-x和-Y选项的描述），并且用户正在使用X11（DISPLAY环境变量已设置），则X11显示的连接将以自动方式转发到远程方，以便从shell（或命令）启动的任何X11程序将通过加密通道进行，连接到实际的X服务器将在本地机器上进行。用户不应手动设置DISPLAY。可以在命令行或配置文件中配置X11连接的转发。</p> 
<p>ssh设置的DISPLAY值将指向服务器机器，但显示号大于零。这是正常的，因为ssh在服务器机器上为通过加密通道转发连接创建一个“代理”X服务器。</p> 
<p>ssh还会在服务器机器上自动设置Xauthority数据。为此，它将生成一个随机的授权cookie，将其存储在服务器上的Xauthority中，并在打开连接时验证任何转发的连接携带此cookie并将其替换为真正的cookie。真正的授权cookie永远不会发送到服务器机器（而且在明文中不发送任何cookie）。</p> 
<p>如果ForwardAgent变量设置为“yes”（或参见上述-A和-a选项的描述）并且用户使用身份验证代理，则与代理的连接将自动转发到远程方。</p> 
<p>验证主机密钥<br> 首次连接到服务器时，用户将看到服务器公钥的指纹（除非禁用了StrictHostKeyChecking选项）。可以使用ssh-keygen(1)确定指纹：</p> 
<p>bash</p> 
<p>$ ssh-keygen -l -f /etc/ssh/ssh_host_rsa_key</p> 
<p>如果已知指纹，则可以进行匹配，并且可以接受或拒绝密钥。如果仅有服务器的传统（MD5）指纹，则可以使用ssh-keygen(1) -E选项将指纹算法降级以进行匹配。</p> 
<p>由于仅通过查看指纹字符串来比较主机密钥的难度，因此还支持通过视觉比较主机密钥，使用随机艺术。通过将VisualHostKey选项设置为“yes”，每次登录到服务器时都会显示一个小的ASCII图形，无论会话本身是否是交互式的。通过学习已知服务器产生的模式，用户可以轻松地发现当显示完全不同的模式时主机密钥已更改。然而，由于这些模式不是唯一的，因此类似于记忆中的模式的模式仅给出主机密钥相同的良好概率，不能保证证明。</p> 
<p>要获取所有已知主机的指纹及其随机艺术的列表，可以使用以下命令行：</p> 
<p>bash</p> 
<p>$ ssh-keygen -lv -f ~/.ssh/known_hosts</p> 
<p>如果指纹未知，则可以使用另一种验证方法：由DNS验证的SSH指纹。将SSHFP资源记录（RR）添加到区域文件中，连接的客户端能够将指纹与所呈现的密钥的指纹进行匹配。</p> 
<p>在此示例中，我们正在将客户端连接到服务器“host.example.com”。首先，SSHFP资源记录应添加到host.example.com的区域文件中：</p> 
<p>bash</p> 
<p>$ ssh-keygen -r host.example.com.</p> 
<p>输出行将必须添加到区域文件中。为检查区域是否回答指纹查询：</p> 
<p>bash</p> 
<p>$ dig -t SSHFP host.example.com</p> 
<p>最后，客户端连接：</p> 
<p>bash</p> 
<p>$ ssh -o "VerifyHostKeyDNS ask" host.example.com<br> [...]<br> 在DNS中找到匹配的主机密钥指纹。<br> 是否要继续连接（是/否）？</p> 
<p>有关更多信息，请参见ssh_config(5)中的VerifyHostKeyDNS选项。</p> 
<p>基于SSH的虚拟专用网络<br> ssh包含对使用tun(4)网络伪设备进行VPN隧道的支持，允许安全地连接两个网络。sshd_config(5)配置选项PermitTunnel控制服务器是否支持此功能，以及在什么级别（第2或第3层流量）。</p> 
<p>以下示例将通过从10.1.1.1到10.1.1.2提供的点对点连接将客户端网络10.0.50.0/24与远程网络10.0.99.0/24连接起来，前提是运行在远程网络网关上的SSH服务器允许此连接。</p> 
<p>在客户端上：</p> 
<p>bash</p> 
<p># ssh -f -w 0:1 192.168.1.15 true<br> # ifconfig tun0 10.1.1.1 10.1.1.2 netmask 255.255.255.252<br> # route add 10.0.99.0/24 10.1.1.2</p> 
<p>在服务器上：</p> 
<p>bash</p> 
<p># ifconfig tun1 10.1.1.2 10.1.1.1 netmask 255.255.255.252<br> # route add 10.0.50.0/24 10.1.1.1</p> 
<p>可以通过/root/.ssh/authorized_keys文件（见下文）和PermitRootLogin服务器选项对客户端访问进行更精细的调整。如果PermitRootLogin设置为“forced-commands-only”，则以下条目将允许从用户“jane”连接到tun(4)设备1，并允许从用户“john”连接到tun设备2：</p> 
<p>bash</p> 
<p>tunnel="1",command="sh /etc/netstart tun1" ssh-rsa ... jane<br> tunnel="2",command="sh /etc/netstart tun2" ssh-rsa ... john</p> 
<p>由于基于SSH的设置涉及相当多的开销，因此它可能更适用于临时设置，例如用于无线VPN。更永久的VPN最好由诸如ipsecctl(8)和isakmpd(8)之类的工具提供。<br> 环境变量<br> SSH_USE_STRONG_RNG<br> 重新播种OpenSSL随机生成器通常是从/dev/urandom完成的。如果设置了SSH_USE_STRONG_RNG环境变量的值不为0，则OpenSSL随机生成器将从/dev/random重新播种。读取的字节数由SSH_USE_STRONG_RNG值定义。最小值为14字节。不建议在没有硬件随机生成器的计算机上使用此设置，因为熵不足会导致连接被阻塞，直到有足够的熵可用。</p> 
<p>文件</p> 
<p>    ~/.rhosts：用于基于主机的身份验证（请参阅上文）。在某些机器上，如果用户的主目录位于NFS分区上，因为sshd(8)以root身份读取它，可能需要对此文件进行全局可读的设置。此外，此文件必须由用户拥有，并且不能对其他人具有写权限。对于大多数机器，推荐的权限是用户读/写，其他人无法访问。<br>     ~/.shosts：与.rhosts完全相同的方式使用此文件，但允许基于主机的身份验证，而不允许使用rlogin/rsh登录。<br>     ~/.ssh/：这个目录是所有用户特定配置和身份验证信息的默认位置。没有保持此目录的全部内容保密的一般要求，但推荐的权限是用户读/写/执行，其他人无法访问。<br>     ~/.ssh/authorized_keys：列出可以用于以该用户身份登录的公钥（DSA，ECDSA，Ed25519，RSA）。此文件的格式在sshd(8)手册页中有描述。这个文件不是高度敏感的，但推荐的权限是用户读/写，其他人无法访问。<br>     ~/.ssh/config：这是每个用户的配置文件。文件格式和配置选项在ssh_config(5)中有描述。由于存在滥用的可能性，因此此文件必须具有严格的权限：用户读/写，其他人无法写入。<br>     ~/.ssh/environment：包含环境变量的附加定义；请参见上文的ENVIRONMENT。<br>     ~/.ssh/identity、 ~/.ssh/id_dsa、 ~/.ssh/id_ecdsa、 ~/.ssh/id_ed25519、 ~/.ssh/id_rsa：包含用于身份验证的私钥。这些文件包含敏感数据，应该可读但不可由其他人访问（读/写/执行）。如果这些文件是其他人可访问的，则ssh将简单地忽略私钥文件。在生成密钥时可以指定一个口令，该口令将用于使用3DES加密此文件的敏感部分。<br>     ~/.ssh/identity.pub、 ~/.ssh/id_dsa.pub、 ~/.ssh/id_ecdsa.pub、 ~/.ssh/id_ed25519.pub、 ~/.ssh/id_rsa.pub：包含用于身份验证的公钥。这些文件不是敏感的，任何人都可以（但不需要）读取。<br>     ~/.ssh/known_hosts：包含用户已登录但系统范围的已知主机密钥列表中尚未包含的所有主机的主机密钥。有关此文件格式的详细信息，请参见sshd(8)。<br>     ~/.ssh/rc：此文件中的命令在用户登录之前由ssh执行，在用户的shell（或命令）启动之前执行。有关更多信息，请参见sshd(8)手册页。<br>     /etc/hosts.equiv：这个文件用于基于主机的身份验证（请参阅上文）。它只能由root可写。<br>     /etc/ssh/shosts.equiv：这个文件与hosts.equiv完全相同，但允许基于主机的身份验证，而不允许使用rlogin/rsh登录。<br>     /etc/ssh/ssh_config：系统范围的配置文件。文件格式和配置选项在ssh_config(5)中有描述。<br>     /etc/ssh/ssh_host_key、 /etc/ssh/ssh_host_dsa_key、 /etc/ssh/ssh_host_ecdsa_key、 /etc/ssh/ssh_host_ed25519_key、 /etc/ssh/ssh_host_rsa_key：这些文件包含主机密钥的私有部分，并用于基于主机的身份验证。<br>     /etc/ssh/ssh_known_hosts：系统范围的已知主机密钥列表。此文件应由系统管理员准备，以包含组织中所有计算机的公共主机密钥。它应该是可全局读取的。有关此文件格式的详细信息，请参见sshd(8)。<br>     /etc/ssh/sshrc：此文件中的命令在用户登录之前由ssh执行，在用户的shell（或命令）启动之前执行。有关更多信息，请参见sshd(8)手册页。</p> 
<p>退出状态<br> ssh退出时，其退出状态为远程命令的退出状态，如果发生错误，则为255。</p> 
<p>IPv6<br> IPv6地址可以在IPv4地址的任何地方使用。在所有条目中，必须将IPv6地址括在方括中。注意：方括是shell的元字符，必须在shell中转义。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/75b6d7b012216c8349dd7ec0762f40e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">六、基于深度学习关键点的指针式表计识别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5ee0737ab96ed3a70bf57d34fd05213a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu打开epub格式的文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>