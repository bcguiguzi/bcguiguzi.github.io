<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LeetCode169. 多数元素（Java） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LeetCode169. 多数元素（Java）" />
<meta property="og:description" content="给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1：
输入：nums = [3,2,3] 输出：3 示例 2：
输入：nums = [2,2,1,1,1,2,2] 输出：2 题解： 本人解法： 先对数组排序，然后直接返回数组的中间位置的值（也就是 ( 数组长度 - 1 ) / 2 ），即为出现次数大于1/2的数。
class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[(nums.length - 1) / 2]; } } 官方解法： 哈希表 思路 我们知道出现次数最多的元素大于n / 2次，所以可以用哈希表来快速统计每个元素出现的次数。
算法 我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。
我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。
class Solution { private Map&lt;Integer, Integer&gt; countNums(int[] nums) { Map&lt;Integer, Integer&gt; counts = new HashMap&lt;Integer, Integer&gt;(); for (int num : nums) { if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3ffb861af56c29be0c1494721c5df299/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-13T08:00:00+08:00" />
<meta property="article:modified_time" content="2024-03-13T08:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LeetCode169. 多数元素（Java）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>给定一个大小为 <code>n</code><em> </em>的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p> 
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p> 
<p></p> 
<p><strong>示例 1：</strong></p> 
<pre><strong>输入：</strong>nums = [3,2,3]
<strong>输出：</strong>3</pre> 
<p><strong>示例 2：</strong></p> 
<pre><strong>输入：</strong>nums = [2,2,1,1,1,2,2]
<strong>输出：</strong>2</pre> 
<h2>题解：</h2> 
<h3>本人解法：</h3> 
<p>先对数组排序，然后直接返回数组的中间位置的值（也就是 ( 数组长度 - 1 ) / 2 ），即为出现次数大于1/2的数。</p> 
<pre><code class="language-java">class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[(nums.length - 1) / 2];
    }
}</code></pre> 
<p><img alt="" height="164" src="https://images2.imgbox.com/3f/fb/srnH2xZe_o.png" width="785"></p> 
<h3>官方解法：</h3> 
<h4>哈希表</h4> 
<h5>思路</h5> 
<p>我们知道出现次数最多的元素大于n / 2次，所以可以用哈希表来快速统计每个元素出现的次数。</p> 
<h5>算法</h5> 
<p>我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。</p> 
<p>我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。</p> 
<pre><code class="language-java">class Solution {
    private Map&lt;Integer, Integer&gt; countNums(int[] nums) {
        Map&lt;Integer, Integer&gt; counts = new HashMap&lt;Integer, Integer&gt;();
        for (int num : nums) {
            if (!counts.containsKey(num)) {
                counts.put(num, 1);
            } else {
                counts.put(num, counts.get(num) + 1);
            }
        }
        return counts;
    }

    public int majorityElement(int[] nums) {
        Map&lt;Integer, Integer&gt; counts = countNums(nums);

        Map.Entry&lt;Integer, Integer&gt; majorityEntry = null;
        for (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) {
            if (majorityEntry == null || entry.getValue() &gt; majorityEntry.getValue()) {
                majorityEntry = entry;
            }
        }

        return majorityEntry.getKey();
    }
}</code></pre> 
<p>复杂度分析</p> 
<p>时间复杂度：</p> 
<p>O(n)，其中 n 是数组 nums 的长度。我们遍历数组 nums 一次，对于 nums 中的每一个元素，将其插入哈希表都只需要常数时间。如果在遍历时没有维护最大值，在遍历结束后还需要对哈希表进行遍历，因为哈希表中占用的空间为 O(n)（可参考下文的空间复杂度分析），那么遍历的时间不会超过 O(n)。因此总时间复杂度为 O(n)。</p> 
<p>空间复杂度：</p> 
<p>O(n)。哈希表最多包含 n−⌊n / 2⌋个键值对，所以占用的空间为 O(n)。这是因为任意一个长度为 n 的数组最多只能包含 n 个不同的值，但题中保证 nums 一定有一个众数，会占用（最少） ⌊n/  2⌋+1个数字。因此最多有 n−(⌊n / 2⌋+1)个不同的其他数字，所以最多有 n−⌊n / 2⌋个不同的元素。</p> 
<hr> 
<p>注：官方解法部分：</p> 
<p>作者：力扣官方题解<br> 链接：<a class="link-info" href="https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/" rel="nofollow" title="https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/">https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/</a><br> 来源：力扣（LeetCode）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d362876c8bf02d2e581b9493781c939/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二，几何相交---4，BO算法---（3）数据结构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a84bbcc6944c03acabd09947f4a4e468/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WPS 相较于其他办公软件有哪些优势？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>