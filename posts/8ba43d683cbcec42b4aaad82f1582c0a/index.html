<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络学习笔记——IP Header Checksum（校验和）的计算方法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络学习笔记——IP Header Checksum（校验和）的计算方法" />
<meta property="og:description" content="从TCP/IP协议看到IP数据报，看到Checksum的算法描述，不甚了了。
The checksum field is the 16 bit one’s complement of the one’s complement sum of all 16 bit words in the header. ————RFC791
1、怎么算IP Header Checksum？ 百度百科里对校验和的解释提到了：1的补码和(one’s complement sum)就是带循环进位(end round carry)的加法，在最后对累加结果取反码。
其实这里讲得很清楚了，但不完全清楚。因为对1的补码和到底怎么算，理解错了。
最开始是按照学数电时对反码加法的理解，即正数的反码等于原码，负数的反码由原码的按位（除了符号位保持为1）取反得到。错。百科最后有附的程序，感觉第10行代码是迷之取反。按这个思路求的结果也不对。 找到一个求IP Header Cheaksum的正确方法： 把划分出所有的16bit数据逐个相加，一旦有进位，就把它加到最低位。最后把结果所有位按位取反。 又找到一个等价的方法：IP数据报首部校验和算法 详细 非代码（接收方检验结果有笔误，但总体写得很棒！） 所有数据逐个相加（使用32位的int类型）把高16位右移16位，再与低16位相加。循环该步，直至结果的二进制表示不超过16位。 2、反码究竟是什么？怎么可以这样用？ 可行的方法找到了，可为什么是这样的呢？就像这篇博客里说的那样，这些16bit数据谈不上有正负号，没有什么符号位，一律按位取反，跟加减算数里的用法相去甚远。
首先根据一下表格明确各个概念：
名称英文名称直译名称反码one’s complement1的补码补码two’s complement2的补码 然后看一下维基百科对ones’ complement的解释
The ones’ complement of a binary number is the value obtained by inverting all the bits in the binary representation of the number (swapping 0s and 1s)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8ba43d683cbcec42b4aaad82f1582c0a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-08T18:18:50+08:00" />
<meta property="article:modified_time" content="2021-07-08T18:18:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络学习笔记——IP Header Checksum（校验和）的计算方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>从TCP/IP协议看到IP数据报，看到Checksum的算法描述，不甚了了。</p> 
<blockquote> 
 <p>The checksum field is the 16 bit one’s complement of the one’s complement sum of all 16 bit words in the header. ————RFC791</p> 
</blockquote> 
<h2><a id="1IP_Header_Checksum_4"></a>1、怎么算IP Header Checksum？</h2> 
<p><a href="https://baike.baidu.com/item/%E6%A0%A1%E9%AA%8C%E5%92%8C/7358071?fr=aladdin" rel="nofollow">百度百科里对校验和的解释</a>提到了：1的补码和(one’s complement sum)就是带循环进位(end round carry)的加法，在最后对累加结果取反码。<br> 其实这里讲得很清楚了，但不完全清楚。因为对1的补码和到底怎么算，理解错了。</p> 
<ol><li><s>最开始是按照学数电时对反码加法的理解，即正数的反码等于原码，负数的反码由原码的按位（除了符号位保持为1）取反得到。错。</s></li><li><s>百科最后有附的程序，感觉第10行代码是迷之取反。按这个思路求的结果也不对。</s></li></ol> 
<p><img src="https://images2.imgbox.com/0f/78/CgxE2efP_o.png" alt="百科所附C语言程序" width="40%" height="40%"></p> 
<ol start="3"><li>找到一个<a href="https://www.thegeekstuff.com/2012/05/ip-header-checksum/" rel="nofollow">求IP Header Cheaksum的正确方法</a>： 
  <ol><li>把划分出所有的<code>16bit</code>数据逐个相加，一旦有进位，就把它加到最低位。</li><li>最后把结果所有位按位取反。</li></ol> </li><li>又找到一个等价的方法：<a href="https://www.cnblogs.com/fhefh/archive/2011/10/18/2216885.html" rel="nofollow">IP数据报首部校验和算法 详细 非代码</a>（接收方检验结果有笔误，但总体写得很棒！） 
  <ol><li>所有数据逐个相加（使用32位的int类型）</li><li>把高16位右移16位，再与低16位相加。循环该步，直至结果的二进制表示不超过16位。</li></ol> </li></ol> 
<h2><a id="2_23"></a>2、反码究竟是什么？怎么可以这样用？</h2> 
<p>可行的方法找到了，可为什么是这样的呢？就像<a href="http://blog.sina.cn/dpool/blog/s/blog_6e48f3460100mgq3.html" rel="nofollow">这篇博客</a>里说的那样，这些<code>16bit</code>数据谈不上有正负号，没有什么符号位，一律按位取反，跟加减算数里的用法相去甚远。</p> 
<p>首先根据一下表格明确各个概念：</p> 
<table><thead><tr><th>名称</th><th>英文名称</th><th>直译名称</th></tr></thead><tbody><tr><td>反码</td><td>one’s complement</td><td>1的补码</td></tr><tr><td>补码</td><td>two’s complement</td><td>2的补码</td></tr></tbody></table> 
<p>然后看一下<a href="https://en.wikipedia.org/wiki/Ones%27_complement" rel="nofollow">维基百科对ones’ complement的解释</a></p> 
<blockquote> 
 <p>The ones’ complement of a binary number is <strong>the value obtained by inverting all the bits in the binary representation of the number</strong> (swapping 0s and 1s). This mathematical operation is primarily of interest in computer science, where it has varying effects depending on how a specific computer represents numbers.<br> <strong>A ones’ complement system or ones’ complement arithmetic is a system in which negative numbers are represented by the inverse of the binary representations of their corresponding positive numbers.</strong> In such a system, a number is negated (converted from positive to negative or vice versa) by computing its ones’ complement. An N-bit ones’ complement numeral system can only represent integers in the range −(2N−1−1) to 2N−1−1 while two’s complement can express −2N−1 to 2N−1−1. It is one of three common representations for negative integers in microprocessors, along with two’s complement and sign-magnitude.<br> The ones’ complement binary numeral system is characterized by the bit complement of any integer value being the arithmetic negative of the value. That is, inverting all of the bits of a number (the logical complement) produces the same result as subtracting the value from 0.</p> 
</blockquote> 
<p>第一段黑体处明确指出1补是所有位按位取反，<br> 第二段黑体部分说1补运算系统中负数表示为对应正数的反码。</p> 
<p>由此可知，<strong>1补就是所有位取反的一个操作，应用在运算中可以方便负数的表示和运算，但这并非其全部用法</strong>。</p> 
<h2><a id="3_41"></a>3、反码求和为什么循环进位？</h2> 
<p>反码求和（one’s complement sum）：循环进位。先求和再取反，与先取反再求和，结果是一样的。<br> 那反码求和为什么是循环进位呢？<br> 可以查看问题 <code>为什么二进制反码加减要循环进位？为什么补码加减不需要循环进位？</code>下的<a href="https://www.zhihu.com/question/27874431/answer/53081713" rel="nofollow">回答</a>。其中有分类讨论，讲得非常棒！<br> 最后也猜了下Checksum使用1补的原因。</p> 
<h2><a id="4_47"></a>4、接收端怎么检验，正常结果应该是什么？</h2> 
<p>接收端收到IP数据报的时候也这么算。<br> 因为Checksum存了其他数据的和的反码（Checksum初始化为<code>0x0000</code>，虽然参加了运算，但跟没参加一样），其他数据之和加上本身的反码，就是<code>0xFFFF</code>，即<code>-0</code>，再取反就是<code>0x0000</code>，即<code>+0</code>。<br> （补充：反码表示负数时，有两个零，补码只有一个零，可以比反码多表示一个负数）</p> 
<h2><a id="5Java_52"></a>5、Java代码简单实现</h2> 
<p>java代码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>it<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CheckSum</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> msg <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0x9C1A</span><span class="token punctuation">,</span> <span class="token number">0xDA88</span><span class="token punctuation">,</span> <span class="token number">0xAD35</span><span class="token punctuation">,</span> <span class="token number">0x0000</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">checkSum</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/**
     * IP Header Checksum
     * @param msg 数组中的每一个数都是16bit的
     * @return 返回16进制的字符串
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">checkSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    	<span class="token comment">// one's complement sum 带循环进位的加法</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">:</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            sum <span class="token operator">+=</span> m<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&gt;</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                sum <span class="token operator">&amp;=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>sum<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
		
		<span class="token comment">// one's complement 每一位都按位取反</span>
        sum <span class="token operator">=</span> <span class="token operator">~</span>sum<span class="token punctuation">;</span>
        sum <span class="token operator">&amp;=</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"0x%04x"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="6_87"></a>6、补充简洁的解释</h2> 
<p>后来查1补的用法时，看到这个<a href="https://www.zhihu.com/question/59407450/answer/208516232" rel="nofollow">回答</a>，非常简洁。</p> 
<blockquote> 
 <p>一个例子就是求校验和（Checksum） 通俗一点来讲是：</p> 
 <ol><li>先是 one’s complement sum，将data按16位分组，所有组相加，再将进位值加到结果的末位。</li><li>再是 one’s complement，结果取反码。</li></ol> 
</blockquote> 
<h2><a id="7_94"></a>7、总结</h2> 
<ol><li>会求Checksum了</li><li>打破了之前对反码的刻板认识</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2699eed7e6d55a63b18fc023a0ad7969/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sqlmap执行POST注入的两种方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21e87bb5406ef589fe7a88c04d90f39f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">论文复现：Active Learning with the Furthest NearestNeighbor Criterion for Facial Age Estimation</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>