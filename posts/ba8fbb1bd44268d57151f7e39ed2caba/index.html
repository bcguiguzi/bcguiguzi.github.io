<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis关键源码深度分析学习 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mybatis关键源码深度分析学习" />
<meta property="og:description" content="一、Mybatis源码分析之SelectOne和自定义方法区别 学习一下自定义查询方法与Mybatis提供的方法有什么不同
先执行自定义的方法（学习流程的时候学习过，熟悉） 和以前一样这里不做过多叙述，就是通过jdk动态代理返回一个ProductMapper的接口对象。
下面去执行Product product = productMapper.selectById(168903089414213632L);这段代码，看看和上次查询一个list有什么不同，我们进入这个方法org.apache.ibatis.binding.MapperMethod.MethodSignature#MethodSignature
我们看到这个方法上次做查询的list这里有个returnsMany的判断如果是个集合或者isArray则返回true，但是我们是selectOne并且我们的returnType是个对象所以是返回false（这是不一样的地方）
继续debug 进入org.apache.ibatis.binding.MapperMethod#execute
根据判断都是false所以走else去调用selectOne（这里是不是和我们标题联系上了）其实他最终还是原理还是相同的。
进入org.apache.ibatis.session.defaults.DefaultSqlSession#selectOne(java.lang.String, java.lang.Object)
selectOne其实去调用selectList方法，但是他有个数量校验，这个错我想大家都见过“selectOne but found n（n&gt;1）”
继续往下走进入：org.apache.ibatis.session.defaults.DefaultSqlSession#selectList(java.lang.String, java.lang.Object, org.apache.ibatis.session.RowBounds)
这里就是上篇查询list&lt;T&gt;流程就一样了，查询完成后拿到list，进行判断
符合条件返回。
下面再看原生的selectOne方法的执行流程 进入selectOnne方法
发现和自定义最后相同还是要去走这个selectOne方法并且通过selectList去查询数据然后进入数量的判断。
但是这里有个不同的，他是怎么把参数与sql语句绑定的，进入：org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler)
进入org.apache.ibatis.mapping.BoundSql#BoundSql的构造方法
将参数赋值给BoundSql的参数对象parameterObject，这样就绑定成功了。下面的执行流程就一样了。
总结 自定义方法: jdk动态代理返回一个ProductMapper的接口对象,就是MapoerProxy的一个实例化对象。通过invoke方法去判断
最后在返回类型去调用selectOne方法。
原生的selectone就少了一个jdk的动态代理，直接调用selectOne方法（最终还是selectList） ================分割线==================
二、Annotation @Select、@Update、@Insert、@Delete 分析Mybatis通过注解的方式去操作数据库 案例：
看看加了注解后他是怎么去构建的，我们把断点打到解析配置的方法中：org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration
看代码也能大致猜到他的过程： 1、解析mapper文件
2、mapper文件中有dao层接口路径
3、通过路径解析查询方法与注解（先去构建mapper文件的sql语句，再去寻找注解方式的sql语句）
进入mapperElement方法： org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement
查看parse方法：org.apache.ibatis.builder.xml.XMLMapperBuilder#parse
进入org.apache.ibatis.builder.xml.XMLMapperBuilder#bindMapperForNamespace方法绑定映射器
进入addMapper方法（org.apache.ibatis.session.Configuration#addMapper）
重点来了：
注解生成器，进入：org.apache.ibatis.builder.annotation.MapperAnnotationBuilder
和我们的注解@select建立联系了，下面继续进入:org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#parse方法
进入org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#parseStatement方法
通过调用这个org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#getSqlSourceFromAnnotations方法来获取sqlSource对象继续往下走
通过这个org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#buildSqlSourceFromStrings方法获取sql语句并返回
我们看一下返回的sqlSource参数
这就拿到了sql执行语句，后面的创建回话，查询数据和以前源码分析相同
总结：注解执行流程
&gt;org.apache.ibatis.session.SqlSessionFactoryBuilder.build(java.io.InputStream)　＞org.apache.ibatis.builder.xml.XMLConfigBuilder &gt;org.apache.ibatis.builder.xml.XMLConfigBuilder.mapperElement &gt;org.apache.ibatis.session.Configuration.addMapper &gt;org.apache.ibatis.binding.MapperRegistry.addMapper &gt;org.apache.ibatis.binding.MapperRegistry.addMapper &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.parseStatement &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.getSqlSourceFromAnnotations &gt;org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ba8fbb1bd44268d57151f7e39ed2caba/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-23T21:09:54+08:00" />
<meta property="article:modified_time" content="2019-09-23T21:09:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis关键源码深度分析学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong><strong><strong>一、Mybatis源码分析之SelectOne和自定义方法区别</strong></strong></strong></h2> 
<p>学习一下自定义查询方法与Mybatis提供的方法有什么不同</p> 
<p><img alt="" class="has" height="568" src="https://images2.imgbox.com/63/11/p4XiZhrr_o.png" width="761"></p> 
<h4>先执行自定义的方法（学习流程的时候学习过，熟悉）</h4> 
<p><img alt="" class="has" height="349" src="https://images2.imgbox.com/7f/a4/AQG7EuOS_o.png" width="836"></p> 
<p>和以前一样这里不做过多叙述，就是通过jdk动态代理返回一个ProductMapper的接口对象。</p> 
<p>下面去执行Product product = productMapper.selectById(168903089414213632L);这段代码，看看和上次查询一个list有什么不同，我们进入这个方法org.apache.ibatis.binding.MapperMethod.MethodSignature#MethodSignature</p> 
<p><img alt="" class="has" height="487" src="https://images2.imgbox.com/8a/e9/ABpU4nTR_o.png" width="1051"></p> 
<p><span style="color:#f33b45;">我们看到这个方法上次做查询的list这里有个returnsMany的判断如果是个集合或者isArray则返回true，但是我们是selectOne并且我们的returnType是个对象所以是返回false（这是不一样的地方）</span></p> 
<p>继续debug 进入org.apache.ibatis.binding.MapperMethod#execute</p> 
<p><img alt="" class="has" height="441" src="https://images2.imgbox.com/96/83/LqE4TZD8_o.png" width="745"></p> 
<p>根据判断都是false所以走else去调用selectOne（这里是不是和我们标题联系上了）其实他最终还是原理还是相同的。</p> 
<p>进入org.apache.ibatis.session.defaults.DefaultSqlSession#<span style="color:#f33b45;">selectOne</span>(java.lang.String, java.lang.Object)</p> 
<p><img alt="" class="has" height="342" src="https://images2.imgbox.com/23/a4/bAqhRScg_o.png" width="1112"></p> 
<p>selectOne其实去调用selectList方法，但是他有个数量校验，这个错我想大家都见过“selectOne but found n（n&gt;1）”</p> 
<p>继续往下走进入：org.apache.ibatis.session.defaults.DefaultSqlSession#selectList(java.lang.String, java.lang.Object, org.apache.ibatis.session.RowBounds)</p> 
<p><img alt="" class="has" height="333" src="https://images2.imgbox.com/4f/b3/JJbfmwSt_o.png" width="916"></p> 
<p>这里就是上篇查询list&lt;T&gt;流程就一样了，查询完成后拿到list，进行判断</p> 
<p> </p> 
<p><img alt="" class="has" height="306" src="https://images2.imgbox.com/bd/90/HeYW5RzS_o.png" width="999"></p> 
<p>符合条件返回。</p> 
<h4>下面再看原生的selectOne方法的执行流程</h4> 
<p><img alt="" class="has" height="132" src="https://images2.imgbox.com/6b/fa/g88IIo80_o.png" width="801"></p> 
<p>进入selectOnne方法</p> 
<p><img alt="" class="has" height="329" src="https://images2.imgbox.com/98/ea/Bu4Ebped_o.png" width="1122"></p> 
<p>发现和自定义最后相同还是要去走这个selectOne方法并且通过selectList去查询数据然后进入数量的判断。</p> 
<p>但是这里有个不同的，他是怎么把参数与sql语句绑定的，进入：org.apache.ibatis.executor.BaseExecutor#query(org.apache.ibatis.mapping.MappedStatement, java.lang.Object, org.apache.ibatis.session.RowBounds, org.apache.ibatis.session.ResultHandler)</p> 
<p><img alt="" class="has" height="246" src="https://images2.imgbox.com/67/5f/MaRd32tF_o.png" width="1200"></p> 
<p>进入org.apache.ibatis.mapping.BoundSql#BoundSql的构造方法</p> 
<p><img alt="" class="has" height="217" src="https://images2.imgbox.com/27/53/2k1WNuLX_o.png" width="1045"></p> 
<p>将参数赋值给BoundSql的参数对象parameterObject，这样就绑定成功了。下面的执行流程就一样了。</p> 
<h4>总结</h4> 
<p>自定义方法: jdk动态代理返回一个ProductMapper的接口对象,就是MapoerProxy的一个实例化对象。通过invoke方法去判断</p> 
<p>最后在返回类型去调用selectOne方法。</p> 
<p><img alt="" class="has" height="441" src="https://images2.imgbox.com/ba/aa/x0UrZncV_o.png" width="745"></p> 
<pre class="has"><code class="language-html">原生的selectone就少了一个jdk的动态代理，直接调用selectOne方法（最终还是selectList）</code></pre> 
<p>================分割线==================</p> 
<h2><strong><strong><strong>二、Annotation @Select、@Update、@Insert、@Delete</strong></strong></strong></h2> 
<h4>分析Mybatis通过注解的方式去操作数据库</h4> 
<p>案例：</p> 
<p><img alt="" class="has" height="322" src="https://images2.imgbox.com/0c/1d/5xhCk1cs_o.png" width="567"></p> 
<p><img alt="" class="has" height="376" src="https://images2.imgbox.com/5f/f7/h7L8FRX8_o.png" width="727"></p> 
<p>看看加了注解后他是怎么去构建的，我们把断点打到解析配置的方法中：org.apache.ibatis.builder.xml.XMLConfigBuilder#parseConfiguration</p> 
<p><img alt="" class="has" height="296" src="https://images2.imgbox.com/a1/4a/H4OSs8kd_o.png" width="958"></p> 
<h4>看代码也能大致猜到他的过程：</h4> 
<p>1、解析mapper文件</p> 
<p><img alt="" class="has" height="81" src="https://images2.imgbox.com/a5/2e/bPysQMuo_o.png" width="520"></p> 
<p>2、mapper文件中有dao层接口路径</p> 
<p><img alt="" class="has" height="46" src="https://images2.imgbox.com/52/b8/EFGWoPOB_o.png" width="676"></p> 
<p>3、通过路径解析查询方法与注解（先去构建mapper文件的sql语句，再去寻找注解方式的sql语句）</p> 
<p><img alt="" class="has" height="290" src="https://images2.imgbox.com/1a/40/HFIljuZv_o.png" width="607"></p> 
<h4>进入mapperElement方法：</h4> 
<p>org.apache.ibatis.builder.xml.XMLConfigBuilder#mapperElement</p> 
<p><img alt="" class="has" height="336" src="https://images2.imgbox.com/41/b0/AZuse77d_o.png" width="888"></p> 
<p>查看parse方法：org.apache.ibatis.builder.xml.XMLMapperBuilder#parse</p> 
<p><img alt="" class="has" height="256" src="https://images2.imgbox.com/85/bb/CJFFQ7ES_o.png" width="731"></p> 
<p>进入org.apache.ibatis.builder.xml.XMLMapperBuilder#bindMapperForNamespace方法绑定映射器</p> 
<p><img alt="" class="has" height="556" src="https://images2.imgbox.com/dc/81/Xn3Pp72Y_o.png" width="980"></p> 
<p>进入addMapper方法（org.apache.ibatis.session.Configuration#addMapper）</p> 
<p>重点来了：</p> 
<p><img alt="" class="has" height="587" src="https://images2.imgbox.com/cc/12/HoURj9c2_o.png" width="946"></p> 
<p>注解生成器，进入：org.apache.ibatis.builder.annotation.MapperAnnotationBuilder</p> 
<p><img alt="" class="has" height="464" src="https://images2.imgbox.com/90/03/t1051Svq_o.png" width="869"></p> 
<p>和我们的注解@select建立联系了，下面继续进入:org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#parse方法</p> 
<p><img alt="" class="has" height="450" src="https://images2.imgbox.com/f6/9f/5vq1JZHU_o.png" width="1023"></p> 
<p>进入org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#parseStatement方法</p> 
<p><img alt="" class="has" height="539" src="https://images2.imgbox.com/4a/8d/4NvSOqf1_o.png" width="1200"></p> 
<p>通过调用这个org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#getSqlSourceFromAnnotations方法来获取sqlSource对象继续往下走</p> 
<p><img alt="" class="has" height="406" src="https://images2.imgbox.com/71/66/GF0FutD0_o.png" width="1122"></p> 
<p>通过这个org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#buildSqlSourceFromStrings方法获取sql语句并返回</p> 
<p>我们看一下返回的sqlSource参数</p> 
<p><img alt="" class="has" height="386" src="https://images2.imgbox.com/89/75/6UR82KZG_o.png" width="834"></p> 
<p>这就拿到了sql执行语句，后面的创建回话，查询数据和以前源码分析相同</p> 
<p>总结：注解执行流程</p> 
<pre class="has"><code class="language-java">&gt;org.apache.ibatis.session.SqlSessionFactoryBuilder.build(java.io.InputStream)　
   　＞org.apache.ibatis.builder.xml.XMLConfigBuilder
       &gt;org.apache.ibatis.builder.xml.XMLConfigBuilder.mapperElement
           &gt;org.apache.ibatis.session.Configuration.addMapper
             &gt;org.apache.ibatis.binding.MapperRegistry.addMapper
               &gt;org.apache.ibatis.binding.MapperRegistry.addMapper
                     
               &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.parseStatement
                   &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.getSqlSourceFromAnnotations
                     &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder.buildSqlSourceFromStrings
                       &gt;org.apache.ibatis.builder.SqlSourceBuilder.parse</code></pre> 
<h4>但是我们这里有个疑问，#{id}是怎么替换成？</h4> 
<p>我们这里去深入研究下；</p> 
<p><img alt="" class="has" height="560" src="https://images2.imgbox.com/70/5c/zBRrmbXW_o.png" width="1095"></p> 
<p>通过这个方法（org.apache.ibatis.builder.annotation.MapperAnnotationBuilder#buildSqlSourceFromStrings）获取的sql语句，我们看看他是怎么获取的</p> 
<p><img alt="" class="has" height="252" src="https://images2.imgbox.com/67/a6/oxT3ncuK_o.png" width="1188"></p> 
<p>进入：org.apache.ibatis.scripting.LanguageDriver#createSqlSource(org.apache.ibatis.session.Configuration, java.lang.String, java.lang.Class&lt;?&gt;)</p> 
<p><img alt="" class="has" height="467" src="https://images2.imgbox.com/ec/9b/Zts0REk7_o.png" width="839"></p> 
<p>进入RawSqlSource <img alt="" class="has" height="176" src="https://images2.imgbox.com/90/39/uzpAtOXR_o.png" width="893"></p> 
<p>拿到参数类型，然后去获取sql源，进入：org.apache.ibatis.builder.SqlSourceBuilder#parse</p> 
<p><img alt="" class="has" height="179" src="https://images2.imgbox.com/97/1a/NI4VA54x_o.png" width="1052"></p> 
<p>看着这里，这个parser对象获得：</p> 
<p><img alt="" class="has" height="249" src="https://images2.imgbox.com/61/b0/2TZ6ETQo_o.png" width="823"></p> 
<p>猜想他是应该要将#{}替换成？ 做准备。我们继续往下走看这个方法org.apache.ibatis.parsing.GenericTokenParser#parse</p> 
<p><img alt="" class="has" height="261" src="https://images2.imgbox.com/df/cb/LjbzJS9F_o.png" width="782"></p> 
<p>这段就是核心代码。</p> 
<p><img alt="" class="has" height="150" src="https://images2.imgbox.com/6c/eb/J7K8EaMb_o.png" width="884"></p> 
<p><img alt="" class="has" height="48" src="https://images2.imgbox.com/82/69/WtSg91gw_o.png" width="955"></p> 
<p>代码太多不好截图，看不到debug流程，不过我加了自己理解注释</p> 
<pre class="has"><code class="language-java">{
    if (text == null || text.isEmpty()) {
      return "";
    }
    // search open token
    //判断该sql语句到指定字符（#{）有多少长度
    int start = text.indexOf(openToken, 0);
    if (start == -1) {
      return text;
    }
    //将sql语句转化成char[]数组
    char[] src = text.toCharArray();
    int offset = 0;
    final StringBuilder builder = new StringBuilder();
    StringBuilder expression = null;
    while (start &gt; -1) {
      if (start &gt; 0 &amp;&amp; src[start - 1] == '\\') {
        // this open token is escaped. remove the backslash and continue.
        builder.append(src, offset, start - offset - 1).append(openToken);
        offset = start + openToken.length();
      } else {
        // found open token. let's search close token.
        if (expression == null) {
          expression = new StringBuilder();
        } else {
          expression.setLength(0);
        }
        //将sql语句从起始位置到#{位置（不包含#{）append到builder中去
        builder.append(src, offset, start - offset);
        //此时将偏移量从0移到一段sql语句（select * from...... id=#{id}）中的#{ 的{ 的位置
        offset = start + openToken.length();
        //最后一个{在sql字符串中的偏移量是多少
        int end = text.indexOf(closeToken, offset);
        while (end &gt; -1) {
          if (end &gt; offset &amp;&amp; src[end - 1] == '\\') {
            // this close token is escaped. remove the backslash and continue.
            expression.append(src, offset, end - offset - 1).append(closeToken);
            offset = end + closeToken.length();
            end = text.indexOf(closeToken, offset);
          } else {
            //将....#{id} 中的参数提取出来
            expression.append(src, offset, end - offset);
            //将偏移量打到末尾
            offset = end + closeToken.length();
            break;
          }
        }
        if (end == -1) {
          // close token was not found.
          builder.append(src, start, src.length - start);
          offset = src.length;
        } else {
          //将?放入新的sql语句中去
          builder.append(handler.handleToken(expression.toString()));
          offset = end + closeToken.length();
        }
      }
      start = text.indexOf(openToken, offset);
    }
    if (offset &lt; src.length) {
      builder.append(src, offset, src.length - offset);
    }
    return builder.toString();
  }</code></pre> 
<p>通过以上流程我们终于将"#{}"替换成“?”.后面的查询流程就和上一篇的执行流程一样了，不在过多叙述。</p> 
<p>至此@Select注解源码分析结束，其实update，delect都差不多。我们可以从加载类MapperAnnotationBuilder看出来。</p> 
<p> </p> 
<p>===================分割线=========================</p> 
<h3><strong><strong><strong>Mybatis源码分析之执行器原理</strong></strong></strong></h3> 
<p>每一个SqlSession都会拥有一个Executor对象，这个对象负责增删改查的具体操作，我们可以简单的将它理解为JDBC中Statement的封装版。</p> 
<p>我们进入org.apache.ibatis.executor.Executor接口：</p> 
<p><img alt="" class="has" height="376" src="https://images2.imgbox.com/97/79/b4V6HZJN_o.png" width="675"></p> 
<p>如图所示，位于继承体系最顶层的是Executor执行器，它有两个实现类，分别是<code>BaseExecutor</code>和 <code>CachingExecutor</code>。</p> 
<p><code>  <strong>BaseExecutor</strong></code><strong> </strong>是一个抽象类，这种通过抽象的实现接口的方式是<code>适配器设计模式之接口适配</code>的体现，是Executor的默认实现，实现了大部分Executor接口定义的功能，降低了接口实现的难度。BaseExecutor的子类有三个，分别是<code>SimpleExecutor</code>、<code>ReuseExecutor</code>和<code>BatchExecutor</code>。</p> 
<p><strong>     SimpleExecutor</strong>: 简单执行器，是MyBatis中默认使用的执行器，每执行一次update或select，就开启一个Statement对象，用完就直接关闭Statement对象(可以是Statement或者是PreparedStatment对象)</p> 
<p><strong>     ReuseExecutor</strong>: 可重用执行器，这里的重用指的是重复使用Statement，它会在内部使用一个Map把创建的Statement都缓存起来，每次执行SQL命令的时候，都会去判断是否存在基于该SQL的Statement对象，如果存在Statement对象并且对应的connection还没有关闭的情况下就继续使用之前的Statement对象，并将其缓存起来。因为每一个SqlSession都有一个新的Executor对象，所以我们缓存在ReuseExecutor上的Statement作用域是同一个SqlSession。</p> 
<p>    <strong>BatchExecutor</strong>: 批处理执行器，用于将多个SQL一次性输出到数据库。update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理的；BatchExecutor相当于维护了多个桶，每个桶里都装了很多属于自己的SQL，就像苹果蓝里装了很多苹果，番茄蓝里装了很多番茄，最后，再统一倒进仓库。（可以是Statement或PrepareStatement对象）</p> 
<p><code> <strong>CachingExecutor</strong></code>: 缓存执行器，先从缓存中查询结果，如果存在，就返回；如果不存在，再委托给Executor delegate 去数据库中取，delegate可以是上面任何一个执行器，前面也有说到，先从缓存中去查询，如果查询不到那就从数据库查询。</p> 
<p>  <strong>Executor创建过程以及源码分析:</strong>其实在mybatis的执行流程中就提到了，创建会话时：</p> 
<pre><code class="language-html hljs">SqlSession session = sessionFactory.openSession();
</code></pre> 
<p>回去执行一个newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)方法</p> 
<p><img alt="" class="has" height="524" src="https://images2.imgbox.com/d4/3d/tFQjHCa3_o.png" width="1057"></p> 
<pre> </pre> 
<p>通常默认是SImpleExcutor执行器，如果想要更改的话有两种方式：1、在mybatis-config.xml的配置文件中选择好</p> 
<p><img alt="" class="has" height="66" src="https://images2.imgbox.com/f0/79/6BZqtF6S_o.png" width="614"></p> 
<p>2、另一种就是创建会话时进行设定</p> 
<p><img alt="" class="has" height="69" src="https://images2.imgbox.com/c6/ce/WmGJjjoT_o.png" width="644"></p> 
<p>我们看看第二种代码是如何执行（其实也是大同小异，只不过带了一个执行器类型的参数）</p> 
<p><img alt="" class="has" height="517" src="https://images2.imgbox.com/94/32/lVwM7CYW_o.png" width="1200"></p> 
<p>这是我们看到执行器的类型是BATCH，继续往下走，看看他如何获取BatchExcutor执行器的，进入org.apache.ibatis.session.Configuration#newExecutor(org.apache.ibatis.transaction.Transaction, org.apache.ibatis.session.ExecutorType)</p> 
<p><img alt="" class="has" height="355" src="https://images2.imgbox.com/20/bb/NoB1XSFV_o.png" width="767"></p> 
<p>我们发现不管是Simple执行器还是Batch执行器实例化都是走BaseExecutor方法</p> 
<p><img alt="" class="has" height="595" src="https://images2.imgbox.com/71/a6/m7UA6YLX_o.png" width="675"></p> 
<p>我们发现一个当他在执行doquery时，他会去调用Batch执行器的方法</p> 
<p><img alt="" class="has" height="445" src="https://images2.imgbox.com/75/d9/xehmw39n_o.png" width="1200"></p> 
<p><img alt="" class="has" height="435" src="https://images2.imgbox.com/ca/0b/bO3lozFN_o.png" width="1200"></p> 
<p>我们看看这个BatchExecutor的方法；</p> 
<pre class="has"><code class="language-java">public class BatchExecutor extends BaseExecutor {

  public static final int BATCH_UPDATE_RETURN_VALUE = Integer.MIN_VALUE + 1002;

  /* Statement链表**/
  private final List&lt;Statement&gt; statementList = new ArrayList&lt;Statement&gt;();

  /* batch结果链表**/
  private final List&lt;BatchResult&gt; batchResultList = new ArrayList&lt;BatchResult&gt;();
  private String currentSql;
  private MappedStatement currentStatement;

  public BatchExecutor(Configuration configuration, Transaction transaction) {
    super(configuration, transaction);
  }

  @Override
  public int doUpdate(MappedStatement ms, Object parameterObject) throws SQLException {
    //获得配置信息
    final Configuration configuration = ms.getConfiguration();
    //获得StatementHandler
    final StatementHandler handler = configuration.newStatementHandler(this, ms, parameterObject, RowBounds.DEFAULT, null, null);
    //获得Sql语句
    final BoundSql boundSql = handler.getBoundSql();
    final String sql = boundSql.getSql();
    final Statement stmt;
    //如果sql语句等于当前sql MappedStatement 等于当前Map碰到Statement
    if (sql.equals(currentSql) &amp;&amp; ms.equals(currentStatement)) {
      int last = statementList.size() - 1;
      //获得最后一个
      stmt = statementList.get(last);
      applyTransactionTimeout(stmt);
      handler.parameterize(stmt);//fix Issues 322
      //有相同的MappedStatement和参数
      BatchResult batchResult = batchResultList.get(last);
      batchResult.addParameterObject(parameterObject);
    } else {
      //如果不存在就创建一个批处理操作
      Connection connection = getConnection(ms.getStatementLog());
      stmt = handler.prepare(connection, transaction.getTimeout());
      //添加批量处理操作
      handler.parameterize(stmt);    //fix Issues 322
      currentSql = sql;
      currentStatement = ms;
      statementList.add(stmt);
      batchResultList.add(new BatchResult(ms, sql, parameterObject));
    }
  // handler.parameterize(stmt);
    //最终是调用jdbc的批处理操作
    handler.batch(stmt);
    return BATCH_UPDATE_RETURN_VALUE;
  }

  @Override
  public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)
      throws SQLException {
    Statement stmt = null;
    try {
      flushStatements();
      //获得配置信息
      Configuration configuration = ms.getConfiguration();
      //获得StatementHandler
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameterObject, rowBounds, resultHandler, boundSql);
      Connection connection = getConnection(ms.getStatementLog());
      stmt = handler.prepare(connection, transaction.getTimeout());
      //获得Statement
      handler.parameterize(stmt);
      return handler.&lt;E&gt;query(stmt, resultHandler);
    } finally {
      closeStatement(stmt);
    }
  }

  @Override
  protected &lt;E&gt; Cursor&lt;E&gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException {
    flushStatements();
    Configuration configuration = ms.getConfiguration();
    StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, null, boundSql);
    Connection connection = getConnection(ms.getStatementLog());
    Statement stmt = handler.prepare(connection, transaction.getTimeout());
    handler.parameterize(stmt);
    return handler.&lt;E&gt;queryCursor(stmt);
  }

  /* 刷新Statement，记录执行次数*/
  @Override
  public List&lt;BatchResult&gt; doFlushStatements(boolean isRollback) throws SQLException {
    try {
      List&lt;BatchResult&gt; results = new ArrayList&lt;BatchResult&gt;();
      if (isRollback) {
        return Collections.emptyList();
      }
      for (int i = 0, n = statementList.size(); i &lt; n; i++) {
        Statement stmt = statementList.get(i);
        applyTransactionTimeout(stmt);
        BatchResult batchResult = batchResultList.get(i);
        try {
          batchResult.setUpdateCounts(stmt.executeBatch());
          MappedStatement ms = batchResult.getMappedStatement();
          List&lt;Object&gt; parameterObjects = batchResult.getParameterObjects();
          KeyGenerator keyGenerator = ms.getKeyGenerator();
          if (Jdbc3KeyGenerator.class.equals(keyGenerator.getClass())) {
            Jdbc3KeyGenerator jdbc3KeyGenerator = (Jdbc3KeyGenerator) keyGenerator;
            jdbc3KeyGenerator.processBatch(ms, stmt, parameterObjects);
          } else if (!NoKeyGenerator.class.equals(keyGenerator.getClass())) { //issue #141
            for (Object parameter : parameterObjects) {
              keyGenerator.processAfter(this, ms, stmt, parameter);
            }
          }
          // Close statement to close cursor #1109
          closeStatement(stmt);
        } catch (BatchUpdateException e) {
          StringBuilder message = new StringBuilder();
          message.append(batchResult.getMappedStatement().getId())
              .append(" (batch index #")
              .append(i + 1)
              .append(")")
              .append(" failed.");
          if (i &gt; 0) {
            message.append(" ")
                .append(i)
                .append(" prior sub executor(s) completed successfully, but will be rolled back.");
          }
          throw new BatchExecutorException(message.toString(), e, results, batchResult);
        }
        //记录操作
        results.add(batchResult);
      }
      return results;
    } finally {
      for (Statement stmt : statementList) {
        closeStatement(stmt);
      }
      currentSql = null;
      statementList.clear();
      batchResultList.clear();
    }
  }

}</code></pre> 
<p>正如概念所说，BatchExecutor执行器就是在update时伪执行，他是等到doQuery方法一起执行。</p> 
<p>我们可以看一下对比：</p> 
<p><img alt="" class="has" height="327" src="https://images2.imgbox.com/f0/85/FqFWMKeG_o.png" width="693"></p> 
<p>执行mybatis的update语句：</p> 
<p><img alt="" class="has" height="715" src="https://images2.imgbox.com/60/35/7bU8Thv3_o.png" width="1103"></p> 
<p>发现BatchExecutor的update方法执行成功后不会返回1，这个需要这注意。在看看数据库有没有变化。</p> 
<p><img alt="" class="has" height="200" src="https://images2.imgbox.com/a7/66/kBjzk3yZ_o.png" width="664"></p> 
<p>这也验证了他的概念当你使用BatchExecutor方法，一旦执行update类方法，如果没有执行查询方法，那么你执行的sql是不是同步到数据库的。我们再次执行update方法后并执行select方法。看看结果。</p> 
<p><img alt="" class="has" height="418" src="https://images2.imgbox.com/fa/ef/Ir1XRxJj_o.png" width="856"></p> 
<p><img alt="" class="has" height="242" src="https://images2.imgbox.com/1b/21/uDaF4EhX_o.png" width="772"></p> 
<p>更改完成。继续学习，坚持。</p> 
<p>=========================结束========================</p> 
<p>下一篇：Mybatis的插件与缓存源码解析</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f430b1e5a35fb74d4a4872177bca121/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">m4r格式转换器免费版 V3.0</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5cfc8a8cf27d78faa009db07b1396d34/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C# 并行编程 PLINQ</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>