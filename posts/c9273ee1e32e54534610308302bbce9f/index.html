<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>D. Counting Factorizations #856 div2 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="D. Counting Factorizations #856 div2" />
<meta property="og:description" content="Problem - 1794D - Codeforces
题意：
一个数分解质因数会变成这样的形式：
把所有的pi和ei放入一个可重集，给你一个可重集，问你原始的数有多少种可能
分析：
性质：底数只能是质数。底数只能有一个，指数可以有很多个
考虑dp
令为选了前i个数， 选了底数的个数为j的方案数
因为输入的为2*n，所以有n个为指数，n个为底数
对于当前枚举到的x来说，假设有y个
x分为两种情况：
第一种是只做指数，已经选了j个底数，假设一共操作了sum个数，所以有sum-j为指数，在剩下的没有操作过的位置上选择y个
第二种是x做一次底数的情况，其他y-1的情况全部作为指数
分步用乘，分类用加
所以这一步由上一步转移而来，用乘
两种不同的情况用加
这里介绍一个小tip
因为这个是二维的，所以必然要用到双重循环，看一下数据范围，二维的会超时，所以还需要优化一下。使用滚动数据，达到降维的效果。开一个类似于临时数组，相当于是这一步算好的情况，然后移到转移的数组上面，（相当于用这个临时数组作为中间数组），达到转移的效果。
这里我看到一篇博客很赞，贴个链接
C&#43;&#43; vector容器的swap方法（容器互换）_vector.swap_对的时间点的博客-CSDN博客
下面贴个这个题的代码：（整个题和代码的思路是看cup大佬qwq）
#pragma GCC optimize(1) #pragma GCC optimize(2) #pragma GCC optimize(3,&#34;Ofast&#34;,&#34;inline&#34;) #define IOS ios::sync_with_stdio(false), cin.tie(0); #include &lt;bits/stdc&#43;&#43;.h&gt; using namespace std; #define int long long typedef long long ll; typedef pair&lt;int,int&gt; PAII; const int N=2e6&#43;10,M=5050,INF=1e18,mod=998244353; int fact[N],infact[N]; bool st[N]; int primes[N]; map&lt;int,int&gt; mp; int cnt; vector&lt;int&gt; dp(N&#43;10,0); int qmi(int a, int k) { int res = 1; while (k) { if (k &amp; 1) res = res * a%mod ; a = a * a%mod ; k &gt;&gt;= 1; } return res; } void init(){ st[1]=1; for (int i = 2; i &lt;= N; i &#43;&#43; ) { if (!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/c9273ee1e32e54534610308302bbce9f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-16T19:38:39+08:00" />
<meta property="article:modified_time" content="2023-03-16T19:38:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">D. Counting Factorizations #856 div2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://codeforces.com/problemset/problem/1794/D" rel="nofollow" title="Problem - 1794D - Codeforces">Problem - 1794D - Codeforces</a></p> 
<p>题意：</p> 
<p>一个数分解质因数会变成这样的形式：<img alt="" height="43" src="https://images2.imgbox.com/44/e5/4UKQzY0I_o.png" width="285"><img alt="x=p1^{e1}*p2^{e2}*...*pn^{en}" class="mathcode" src="https://images2.imgbox.com/00/6c/k2tWenTJ_o.png"></p> 
<p>把所有的pi和ei放入一个可重集，给你一个可重集，问你原始的数有多少种可能</p> 
<p>分析：</p> 
<p>性质：底数只能是质数。底数只能有一个，指数可以有很多个</p> 
<p>考虑dp</p> 
<p>令<img alt="dp[i][j]" class="mathcode" src="https://images2.imgbox.com/ac/a0/g6ujyh4d_o.png">为选了前i个数， 选了底数的个数为j的方案数</p> 
<p>因为输入的为2*n，所以有n个为指数，n个为底数</p> 
<p>对于当前枚举到的x来说，假设有y个</p> 
<p>x分为两种情况：</p> 
<p>第一种是只做指数，已经选了j个底数，假设一共操作了sum个数，所以有sum-j为指数，在剩下的没有操作过的位置上选择y个</p> 
<p>第二种是x做一次底数的情况，其他y-1的情况全部作为指数</p> 
<p>分步用乘，分类用加</p> 
<p>所以这一步由上一步转移而来，用乘</p> 
<p>两种不同的情况用加</p> 
<p>这里介绍一个小tip</p> 
<p>因为这个是二维的，所以必然要用到双重循环，看一下数据范围，二维的会超时，所以还需要优化一下。使用滚动数据，达到降维的效果。开一个类似于临时数组，相当于是这一步算好的情况，然后移到转移的数组上面，（相当于用这个临时数组作为中间数组），达到转移的效果。</p> 
<p>这里我看到一篇博客很赞，贴个链接</p> 
<p><a href="https://blog.csdn.net/qq_41929943/article/details/103190891?spm=1001.2014.3001.5506" title="C++ vector容器的swap方法（容器互换）_vector.swap_对的时间点的博客-CSDN博客">C++ vector容器的swap方法（容器互换）_vector.swap_对的时间点的博客-CSDN博客</a></p> 
<p>下面贴个这个题的代码：（整个题和代码的思路是看cup大佬qwq）</p> 
<pre><code class="language-cpp">#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3,"Ofast","inline")
#define IOS ios::sync_with_stdio(false), cin.tie(0);
#include &lt;bits/stdc++.h&gt;
using namespace std;
#define int long long
typedef long long ll;
typedef pair&lt;int,int&gt; PAII;
const int N=2e6+10,M=5050,INF=1e18,mod=998244353;
int fact[N],infact[N];
bool st[N];
int primes[N];
map&lt;int,int&gt; mp;
int cnt;
vector&lt;int&gt; dp(N+10,0);
int qmi(int a, int k)
{
    int res = 1;
    while (k)
    {
        if (k &amp; 1) res = res * a%mod ;
        a = a * a%mod ;
        k &gt;&gt;= 1;
    }
    return res;
}
void init(){
	st[1]=1;
    for (int i = 2; i &lt;= N; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] &lt;= N / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
    fact[0] = infact[0] = 1;
    for (int i = 1; i &lt; N; i ++ )
    {
        fact[i] = fact[i - 1] * i % mod;
        infact[i] = infact[i - 1] * qmi(i, mod - 2) % mod;
    }
}
int C(int a,int b)
{
	if(a&lt;0||b&lt;0||a&lt;b) return 0;
	return fact[a] * infact[b] % mod * infact[a - b] % mod;
}
signed main(){
    IOS;
    int T;
    T=1;
    //cin&gt;&gt;T;
    init();
    while(T--)
    {
    	mp.clear();
    	int n;
    	cin&gt;&gt;n;
    	for(int i=1;i&lt;=2*n;i++)
    	{
			int x;
			cin&gt;&gt;x;
			mp[x]++;
		}
		dp[0]=1;
		int sum=0;
		for(auto it:mp)
		{
			int x=it.first,y=it.second;
			vector&lt;int&gt; v(n+10,0);
			for(int i=0;i&lt;=n;i++)
			{
				v[i]+=(dp[i]*C(n-(sum-i),y))%mod;
				if(i&gt;=1&amp;&amp;!st[x]) v[i]+=(dp[i-1]*C(n-(sum-i+1),y-1))%mod;
			}
			dp.swap(v);
			sum+=y;
		}
		cout&lt;&lt;dp[n]%mod;
    }
    return 0;
} 
/* 


*/</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a00c6f03982745c16ca11c54459c2650/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; 哈希表基本用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/29c64219112d4efeb6d82235db8a7099/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023荣耀校招机试（java&amp;python&amp;C&#43;&#43;）组装新的数组</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>