<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅显易懂的GCC使用教程——初级篇 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅显易懂的GCC使用教程——初级篇" />
<meta property="og:description" content="浅显易懂的GCC使用教程——初级篇 2018-12-17天气暖，属于冬日里出太阳。最近在学习使用gvim，想着抛弃对IDE的依赖同时也是想了解编译的过程，但除了学习gvim繁多的指令外还得先学习使用gcc编译程序。这篇文章将会用浅显易懂的方式记录下gcc的基本使用，同时也不忘扩展探究。
——Author：Calm
什么是GCC，它能干什么？
GCC、gcc、g&#43;&#43;三者有何关系？
开始开发前该做什么准备？
gcc常用指令讲解？
什么是gcc，它能干什么？ GCC(GNU Compiler Collection)即GNU编译器套件，属于一种编程语言编译器，其原名为GCC（GNU C Compiler）即GNU c语言编译器，虽然缩写一样但是功能上区别很大。GCC的初衷是为GNU操作系统专门编写的一款编译器，原本的GNU是专用于编译C代码，现如今已扩展为可以编译C、C&#43;&#43;、Java、Objective-C等多种编程语言的编译器集合了。这篇文章主要介绍gcc或g&#43;&#43;的使用。
GCC、gcc、g&#43;&#43;三者有何关系？ gcc（GUN C Compiler）是GCC中的c编译器，而g&#43;&#43;（GUN C&#43;&#43; Compiler）是GCC中的c&#43;&#43;编译器。
gcc和g&#43;&#43;两者都可以编译c和cpp文件，但存在差异。gcc在编译cpp时语法按照c来编译但默认不能链接到c&#43;&#43;的库（gcc默认链接c库，g&#43;&#43;默认链接c&#43;&#43;库）。g&#43;&#43;编译.c和.cpp文件都统一按cpp的语法规则来编译。所以一般编译c用gcc，编译c&#43;&#43;用g&#43;&#43;。后文有时间会继续深入探讨区别。
开始开发前该做什么准备？ 软件安装教程：
直接去官网上下载MinGW的包管理器（下载链接：https://osdn.net/projects/mingw/releases/）
下载好后安装包管理器并运行它，可以看到如下界面：
左侧选择“Basic Setup”选项，右侧勾选（点击“Mark for Installation”）需要安装的组件“mingw32-gcc-g&#43;&#43;”。假设你也需要使用MinGW编译Fortran、Object-C、Ada语言的话也可以勾上相应的选项。选择好后点击左上角的Installation菜单中的Apply changes选项即开始在线下载安装相关组件。
安装好后最好配置下环境变量，把MinGw的bin目录加入到环境变量的path中，这样dos在任意目录下都可以调用bin目录下的可执行文件，其他一些软件也能找到gcc的位置。cmd中输入gcc -v查看版本号。
gcc常用指令讲解？ 用gcc在Windows上编译*.c文件并非直接生成*.exe文件（Linux上为*.out），中间还经历了预处理、编译和汇编几个过程，好在gcc提供了生成中间文件的指令，虽然平时开发的时候很少关注编译过程中生成的这些*.i和*.s文件，但对其有一定的了解总归是好的。
【指令】 gcc
使用gcc指令编译*.c文件可以生成*exe可执行文件。下面我们用一段简单的c代码来讲解，Demo.c内源码如下：
#include&lt;stdio.h&gt; int main(void) { printf(&#34;nihao\n&#34;); return 0; } 打开cmd,需要注意的是cmd默认路径一般是c盘，而Demo.c文件可能并不在cmd的默认路径下，我们需要使用dos指令cd到Demo.c所在目录下才能对文件进行操作，示例：
对Demo.c文件执行gcc指令后会在该目录下生成可执行文件a.exe，由于没有制定exe的文件名所以默认为a.exe。
当然也不一定要cd进Demo.c的目录，使用gcc指令时给出Demo.c的绝对路径也可以成功编译，命令如下：
gcc E:\WorkSpace\Test_gcc\Demo.c
【指令】 -o
指令-o（小写）用来指定生成的文件名。
结果如下：
生成的文件不一定要在.c所在目录，可以给出路径指定。
gcc Demo.c -o ..\Demo.exe
该指令指定将exe生成到上一级目录。
生成exe后我们试者执行一下看看结果。
【指令】 -E（预处理（Preprocessing））
指令 -E（大写）将执行预处理操作也即生成*.i文件,gcc编译器将对#开头的指令进行解析。我们修改Demo.c中的代码为如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5c902f2075877fe9e5b8b02cbaaa1af0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-23T16:50:39+08:00" />
<meta property="article:modified_time" content="2018-12-23T16:50:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅显易懂的GCC使用教程——初级篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="centerGCCcenter_0"></a> 
 <center>
   浅显易懂的GCC使用教程——初级篇 
 </center></h2> 
<p><em>  2018-12-17天气暖，属于冬日里出太阳。最近在学习使用gvim，想着抛弃对IDE的依赖同时也是想了解编译的过程，但除了学习gvim繁多的指令外还得先学习使用gcc编译程序。这篇文章将会用浅显易懂的方式记录下gcc的基本使用，同时也不忘扩展探究。</em></p> 
<p align="right">——Author：Calm</p> 
<ul><li> <p>什么是GCC，它能干什么？</p> </li><li> <p>GCC、gcc、g++三者有何关系？</p> </li><li> <p>开始开发前该做什么准备？</p> </li><li> <p>gcc常用指令讲解？</p> </li><li> <h4><a id="gcc_10"></a>什么是gcc，它能干什么？</h4> <p>  GCC(GNU Compiler Collection)即GNU编译器套件，属于一种编程语言编译器，其原名为GCC（GNU C Compiler）即GNU c语言编译器，虽然缩写一样但是功能上区别很大。GCC的初衷是为GNU操作系统专门编写的一款编译器，原本的GNU是专用于编译C代码，现如今已扩展为可以编译C、C++、Java、Objective-C等多种编程语言的编译器集合了。这篇文章主要介绍gcc或g++的使用。</p> </li><li> <h4><a id="GCCgccg_13"></a>GCC、gcc、g++三者有何关系？</h4> <p>  gcc（GUN C Compiler）是GCC中的c编译器，而g++（GUN C++ Compiler）是GCC中的c++编译器。<br>   gcc和g++两者都可以编译c和cpp文件，但存在差异。gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库（gcc默认链接c库，g++默认链接c++库）。g++编译.c和.cpp文件都统一按cpp的语法规则来编译。所以一般编译c用gcc，编译c++用g++。后文有时间会继续深入探讨区别。</p> </li><li> <h4><a id="_17"></a>开始开发前该做什么准备？</h4> 
  <ul><li> <p>软件安装教程：<br>   直接去官网上下载MinGW的包管理器（下载链接：<a href="https://osdn.net/projects/mingw/releases/" rel="nofollow" title="下载MinGW">https://osdn.net/projects/mingw/releases/</a>）</p> <p>  下载好后安装包管理器并运行它，可以看到如下界面：</p> <p><img src="https://images2.imgbox.com/e1/ea/BhskADMK_o.png" alt="在这里插入图片描述"></p> <p>  左侧选择“Basic Setup”选项，右侧勾选（点击“Mark for Installation”）需要安装的组件“mingw32-gcc-g++”。假设你也需要使用MinGW编译Fortran、Object-C、Ada语言的话也可以勾上相应的选项。选择好后点击左上角的Installation菜单中的Apply changes选项即开始在线下载安装相关组件。</p> <p>  安装好后最好配置下环境变量，把MinGw的bin目录加入到环境变量的path中，这样dos在任意目录下都可以调用bin目录下的可执行文件，其他一些软件也能找到gcc的位置。cmd中输入gcc -v查看版本号。</p> <p><img src="https://images2.imgbox.com/6e/bd/plcuA7Tj_o.png" alt="alt test"></p> </li></ul> </li><li> <h4><a id="gcc_34"></a>gcc常用指令讲解？</h4> <p>  用gcc在Windows上编译*.c文件并非直接生成*.exe文件（Linux上为*.out），中间还经历了预处理、编译和汇编几个过程，好在gcc提供了生成中间文件的指令，虽然平时开发的时候很少关注编译过程中生成的这些*.i和*.s文件，但对其有一定的了解总归是好的。</p> <p><img src="https://images2.imgbox.com/cd/4b/7Joqq6TZ_o.png" alt="在这里插入图片描述"></p> 
  <ul><li> <p>【指令】 gcc<br>   使用gcc指令编译*.c文件可以生成*exe可执行文件。下面我们用一段简单的c代码来讲解，Demo.c内源码如下：</p> <pre><code class="prism language-c">
	<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
	
	<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"nihao\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre> <p>  打开cmd,需要注意的是cmd默认路径一般是c盘，而Demo.c文件可能并不在cmd的默认路径下，我们需要使用dos指令cd到Demo.c所在目录下才能对文件进行操作，示例：</p> <p><img src="https://images2.imgbox.com/71/35/JCy9XA4o_o.png" alt="alt test"></p> <p>  对Demo.c文件执行gcc指令后会在该目录下生成可执行文件a.exe，由于没有制定exe的文件名所以默认为a.exe。</p> <p><img src="https://images2.imgbox.com/5c/ff/BPkd5zW2_o.png" alt="alt text"></p> <p>  当然也不一定要cd进Demo.c的目录，使用gcc指令时给出Demo.c的绝对路径也可以成功编译，命令如下：</p> <p><code>gcc E:\WorkSpace\Test_gcc\Demo.c</code></p> </li><li> <p>【指令】 -o<br>   指令-o（小写）用来指定生成的文件名。</p> <p><img src="https://images2.imgbox.com/fd/22/DNRRmEwP_o.png" alt="alt text"></p> <p>结果如下：</p> <p><img src="https://images2.imgbox.com/2a/66/YsZDfWkV_o.png" alt="alt text"></p> <p>  生成的文件不一定要在.c所在目录，可以给出路径指定。</p> <p><code>gcc Demo.c -o ..\Demo.exe</code></p> <p>  该指令指定将exe生成到上一级目录。</p> <p>  生成exe后我们试者执行一下看看结果。</p> <p><img src="https://images2.imgbox.com/77/ab/FEGUaBhj_o.png" alt="alt text"></p> </li><li> <p>【指令】 -E（预处理（Preprocessing））<br>   指令 -E（大写）将执行预处理操作也即生成*.i文件,gcc编译器将对#开头的指令进行解析。我们修改Demo.c中的代码为如下：</p> <pre><code class="prism language-c">
	<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
	<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
	<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">"Test.h"</span></span>
	
	<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	    <span class="token keyword">int</span> a <span class="token operator">=</span> N<span class="token punctuation">;</span>                      <span class="token comment">//宏常量</span>
	    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	    
	    c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
	    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    
	    CODE                            <span class="token comment">//宏替换代码段</span>

		<span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre> <p>在Demo.c同目录下编辑Test.h文件，源码如下：</p> <pre><code class="prism language-c">
	<span class="token macro property">#<span class="token directive keyword">define</span> N 1</span>
	
	<span class="token macro property">#<span class="token directive keyword">define</span>     CODE      if(c &gt; 2)                              \
	                                {                            \
	                                    printf("c &gt; 2\n");       \
	                                }</span>
	
	<span class="token keyword">void</span> <span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">//函数声明(该函数未被调用)</span>

</code></pre> <p>在Demo.c同目录下编辑Test.c文件，源码如下：</p> <pre><code class="prism language-c">
	<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"Test.h"</span></span>
	
	<span class="token keyword">void</span> <span class="token function">DoNothing</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	    <span class="token punctuation">;</span>
	
	    <span class="token keyword">return</span> <span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre> <p>  从源码可知Demo.c中在预处理阶段需要把调用的头文件包含进来，替换宏常量和宏代码段。我们执行指令<code>gcc -E Demo.c -o Demo.i</code>并看看Demo.i文件中的代码。</p> <p>Demo.i文件内容：</p> <p><img src="https://images2.imgbox.com/f0/08/SkaecA6q_o.png" alt="alt text"></p> <p>  -E 指令使gcc执行预处理，预处理时对#类指令进行处理（包含头文件、替换宏常量和宏代码段等操作），也就不难理解为何Demo.i文件会很大了（38KB），整个工程最后被揉合成一个大文件。预处理把注释都去掉了，所以反编译回来的代码是没有注释的！因为注释早就被去掉了。另外可以一提的是使用指令<code>gcc -E Demo.c</code>不指定输出的文件名时内容将会直接输出到Dos框中，而不会产生文件。</p> <p>  我们知道c语言出现语法错误时编译器将会报错，但检查语法错误是在预处理、编译、汇编、链接、生成可执行文件中的哪个阶段执行的呢？为了方便我们编辑Demo2.c代码，有意使源码代码由于错误测试预处理阶段是否会报语法错误。</p> <pre><code class="prism language-c">
	<span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
	
	<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
	    aabbccdd          <span class="token comment">//此处有语法错误</span>
	
	    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

</code></pre> <p>  对Demo2.c执行预处理操作<code>gcc -E Demo2.c</code>。</p> <p><img src="https://images2.imgbox.com/72/b9/KEZSkEuc_o.png" alt="alt test"></p> <p>  由此可知预处理阶段不检查语法错误。</p> </li><li> <p>【指令】 -S（编译（Compiling））<br>   执行-S（大写）指令将*.i文件中源码转化为汇编代码*.s文件。我们执行指令<code>gcc -S Demo.i -o Demo.s</code>，在当前目录下将生成Demo.s文件，用记事本打开会发现c源码已经被编译器转化为汇编代码。</p> <p><img src="https://images2.imgbox.com/13/24/XQjlSTkc_o.png" alt="在这里插入图片描述"></p> <p>  如果使用指令<code>gcc -S Demo.i</code>即不指定输出文件名，默认也将会在当前目录下产生文件Demo.s。</p> <p>  关于前面含有语法错误的Demo2.c我们在编译阶段再试一次，看看是否能检查出语法错误。</p> <p><img src="https://images2.imgbox.com/a8/ad/yrgtiawx_o.png" alt="alt text"></p> <p>  对语法的检查是再编译阶段进行的。</p> </li><li> <p>【指令】 -c（汇编（Assembling））<br>   执行-c（小写）指令将*.s文件中的汇编源码转化未机器能执行的二进制机器码，生成文件*.o。执行指令<code>gcc -c Demo.s -o Demo.o</code>。生成的Demo.o为二进制文件，用记事本打开就是一堆乱码，我这里就不贴图出来了。</p> </li><li> <p>【指令】 gcc *.o（链接（Linking））<br>   经过汇编处理后生成的二进制文件Demo.o虽然已经机器码，但仍然无法运行因为少了链接操作。链接操作可执行指令<code>gcc Demo.o -o Demo.exe</code></p> <p><img src="https://images2.imgbox.com/b6/64/REAned6W_o.png" alt="alt text"></p> <p>  对Demo.o执行链接操作出现报错，提示找不到函数DoNothing的定义。预处理阶段值时将头文件包含进Demo.i文件中，也即Demo.i中含有函数的声明部分，所以编译阶段只检查函数的声明和调用处是否符合函数原型，并未去检查其他*.c文件中的函数定义。<br>   链接阶段就是要把函数库中的函数定义给关联进来，找不到函数定义当然会报错。那么问题来了，我们调用的标准库函数printf为何不报错？其实库函数也不例外，在链接阶段需要关联到函数定义，它的声明部分在标准库函数头文件stdio.h中已给出，而实现部分在某个标准库中封装好了，不同的系统下还会有差异。gcc在链接时默认是包含标准库的库文件路径的，所以它能找到printf函数的定义而不会报错。而DoNothing函数是我们用户自己编写，并未封装成库的形式gcc当然找不到它的定义。倘若把Demo.c中的DoNothing函数调用去掉可以成功执行链接操作吗？当然可以！</p> <p>  为了让Demo.o能成功的生成可执行文件Demo.exe，我们可以将Test.c封装成静态库供其调用，这样就有函数定义了。执行指令<code>gcc -c Test.c -o Test.o</code>生成Test.o二进制文件。这里并不是不用对Test.c执行预处理和编译操作，而是编译器帮我们做了。接着将Test.o生成静态库文件libTest.a，然后再次尝试对Demo.o执行链接操作。</p> <p><img src="https://images2.imgbox.com/a3/08/ZqKneUed_o.png" alt="alt text"></p> <p>  可以看到这次编译器没有报错且成功生成了Demo.exe，执行结果也与预期一直。<br>   关于生成静态库和动态库的gcc指令以及更多其他指令，静态库和动态库的区别和作用，等有时间了继续写个中级篇来讲解吧，一篇文章写得太长大家看了也会枯燥，我写着也需要休息。</p> </li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b980fc4349272e305aaa258590a56cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">String的两种初始化方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/463acc33d513b96173a8a56995e5451e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">半监督深度学习小结：类协同训练和一致性正则化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>