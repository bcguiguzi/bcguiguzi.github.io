<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43; Inline关键字 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43; Inline关键字" />
<meta property="og:description" content=" 原创文章，转载请注明出处。
C&#43;&#43; Inline记录 前言1&gt;inline 函数工作原理2&gt;inline 函数作用2.1&gt;消除函数调用的开销宏定义（define）和内联函数（inline）的区别1&gt;内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。2&gt;内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。3&gt;宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。 2.2&gt;去除函数只能定义一次的限制 3&gt;要注意的几点问：内联函数一定会被编译器在调用点展开吗？问：“调用”普通函数时，一定是调用吗？问：既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？问：既然内联函数可以大大减少由函数调用带来的开销，提高程序的运行效率。那为什么所有的函数不都被设计成内联？ 前言 inline是C&#43;&#43;关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。
1&gt;inline 函数工作原理 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。
普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。
2&gt;inline 函数作用 2.1&gt;消除函数调用的开销 在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。内联函数设计的目的之一，就是取代 #define 的这项功能。
宏定义（define）和内联函数（inline）的区别 1&gt;内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 2&gt;内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。 3&gt;宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。 2.2&gt;去除函数只能定义一次的限制 内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。
3&gt;要注意的几点 问：内联函数一定会被编译器在调用点展开吗？ 错，inline 只是对编译器的建议，而非命令。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。
问：“调用”普通函数时，一定是调用吗？ 错，即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开。
问：既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？ 错。
首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。
而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内联函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。
问：既然内联函数可以大大减少由函数调用带来的开销，提高程序的运行效率。那为什么所有的函数不都被设计成内联？ 因为 内联是以代码膨胀复制为代价 ，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码, 将使程序的总代码量增大，消耗更多的内存空间。
以下情况不宜使用内联：
1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
以下情况适宜使用内联
对于只有几条语句的小函数来说，与函数的调用、返回有关的准备和收尾工作的代码往往比函数体本身的代码要大得多。因此，对于这类简单的、使用频繁的小函数，将之说明为内联函数可提高运行效率。
谢谢，创作不易，大侠请留步… 动起可爱的双手，来个赞再走呗 &lt;(￣︶￣)&gt; " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/50130bd29c44c8a61e7c7f024890ebdd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-08T09:48:17+08:00" />
<meta property="article:modified_time" content="2022-02-08T09:48:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43; Inline关键字</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><font color="red" size="5"> 原创文章，转载请注明出处。</font></p> 
<p></p> 
<div class="toc"> 
 <h4>C++ Inline记录</h4> 
 <ul><li><a href="#_3" rel="nofollow">前言</a></li><li><a href="#font_colorRoyalBlue1inline__6" rel="nofollow"><font color="RoyalBlue">1&gt;inline 函数工作原理</font></a></li><li><a href="#font_colorRoyalBlue2inline__11" rel="nofollow"><font color="RoyalBlue">2&gt;inline 函数作用</font></a></li><li><ul><li><a href="#font_colorRoyalBlue21_12" rel="nofollow"><font color="RoyalBlue">2.1&gt;消除函数调用的开销</font></a></li><li><ul><li><a href="#font_colorRoyalBluedefineinline_14" rel="nofollow"><font color="RoyalBlue">宏定义（define）和内联函数（inline）的区别</font></a></li><li><ul><li><a href="#1_15" rel="nofollow">1&gt;内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</a></li><li><a href="#2_16" rel="nofollow">2&gt;内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</a></li><li><a href="#3_17" rel="nofollow">3&gt;宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</a></li></ul> 
   </li></ul> 
   </li><li><a href="#font_colorRoyalBlue22_19" rel="nofollow"><font color="RoyalBlue">2.2&gt;去除函数只能定义一次的限制</font></a></li></ul> 
  </li><li><a href="#font_colorRoyalBlue3_21" rel="nofollow"><font color="RoyalBlue">3&gt;要注意的几点</font></a></li><li><ul><li><a href="#_22" rel="nofollow">问：内联函数一定会被编译器在调用点展开吗？</a></li><li><a href="#_24" rel="nofollow">问：“调用”普通函数时，一定是调用吗？</a></li><li><a href="#_26" rel="nofollow">问：既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？</a></li><li><a href="#font_colorRoyalBlue_30" rel="nofollow"><font color="RoyalBlue">问：既然内联函数可以大大减少由函数调用带来的开销，提高程序的运行效率。那为什么所有的函数不都被设计成内联？</font></a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_3"></a>前言</h2> 
<p>inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。</p> 
<h2><a id="font_colorRoyalBlue1inline__6"></a><font color="RoyalBlue">1&gt;inline 函数工作原理</font></h2> 
<p>内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</p> 
<p>普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</p> 
<h2><a id="font_colorRoyalBlue2inline__11"></a><font color="RoyalBlue">2&gt;inline 函数作用</font></h2> 
<h3><a id="font_colorRoyalBlue21_12"></a><font color="RoyalBlue">2.1&gt;消除函数调用的开销</font></h3> 
<p>在内联函数出现之前，程序员通常用 #define 定义一些“函数”来消除调用这些函数的开销。<strong>内联函数设计的目的之一</strong>，就是取代 #define 的这项功能。</p> 
<h4><a id="font_colorRoyalBluedefineinline_14"></a><font color="RoyalBlue">宏定义（define）和内联函数（inline）的区别</font></h4> 
<h5><a id="1_15"></a>1&gt;内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</h5> 
<h5><a id="2_16"></a>2&gt;内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</h5> 
<h5><a id="3_17"></a>3&gt;宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</h5> 
<h3><a id="font_colorRoyalBlue22_19"></a><font color="RoyalBlue">2.2&gt;去除函数只能定义一次的限制</font></h3> 
<p>内联函数可以在头文件中被定义，并被多个 .cpp 文件 include，而不会有重定义错误。这也是设计内联函数的主要目的之一。</p> 
<h2><a id="font_colorRoyalBlue3_21"></a><font color="RoyalBlue">3&gt;要注意的几点</font></h2> 
<h3><a id="_22"></a>问：内联函数一定会被编译器在调用点展开吗？</h3> 
<p>错，inline 只是对编译器的建议，而非命令。编译器可以选择忽视 inline。当程序员定义的 inline 函数包含复杂递归，或者 inlinie 函数本身比较长，编译器一般不会将其展开，而仍然会选择函数调用。</p> 
<h3><a id="_24"></a>问：“调用”普通函数时，一定是调用吗？</h3> 
<p>错，即使是普通函数，编译器也可以选择进行优化，将普通函数在“调用”点展开。</p> 
<h3><a id="_26"></a>问：既然内联函数在编译阶段已经在调用点被展开，那么程序运行时，对应的内存中不包含内联函数的定义，对吗？</h3> 
<p>错。<br> 首先，如第一点所言，编译器可以选择调用内联函数，而非展开内联函数。因此，内存中仍然需要一份内联函数的定义，以供调用。<br> 而且，一致性是所有语言都应该遵守的准则。普通函数可以有指向它的函数指针，那么，内联函数也可以有指向它的函数指针，因此，内存中需要一份内联函数的定义，使得这样的函数指针可以存在。</p> 
<h3><a id="font_colorRoyalBlue_30"></a><font color="RoyalBlue">问：既然内联函数可以大大减少由函数调用带来的开销，提高程序的运行效率。那为什么所有的函数不都被设计成内联？</font></h3> 
<p>因为<font color="red"> <em><strong>内联是以代码膨胀复制为代价</strong></em> </font> ，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码, 将使程序的总代码量增大，消耗更多的内存空间。<br> <strong>以下情况不宜使用内联：</strong><br> 1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br> 2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p> 
<p><strong>以下情况适宜使用内联</strong><br> 对于只有几条语句的小函数来说，与函数的调用、返回有关的准备和收尾工作的代码往往比函数体本身的代码要大得多。因此，对于这类简单的、使用频繁的小函数，将之说明为内联函数可提高运行效率。</p> 
<p><font color="DeepPink"><em>谢谢，创作不易，大侠请留步… 动起可爱的双手，来个赞再走呗 &lt;(￣︶￣)&gt;</em> </font></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6038a3295c98a5b8f5a55280c874ad23/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UE4 Shipping下打开系统窗口崩溃问题 附插件下载地址</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/833be67a86c159aa971f1baba6f89b43/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML translate 属性</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>