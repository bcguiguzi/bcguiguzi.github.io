<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux 内核线程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux 内核线程" />
<meta property="og:description" content="函数说明：
kthread_create：创建线程。
struct task_struct *kthread_create(int (*threadfn)(void *data),void *data,const char *namefmt, ...);
线程创建后，不会马上运行，而是需要将kthread_create() 返回的task_struct指针传给wake_up_process()，然后通过此函数运行线程。
kthread_run ：创建并启动线程的函数：
struct task_struct *kthread_run(int (*threadfn)(void *data),void *data,const char *namefmt, ...);
kthread_stop：通过发送信号给线程，使之退出。
int kthread_stop(struct task_struct *thread);
线程一旦启动起来后，会一直运行，除非该线程主动调用do_exit函数，或者其他的进程调用kthread_stop函数，结束线程的运行。 但如果线程函数正在处理一个非常重要的任务，它不会被中断的。当然如果线程函数永远不返回并且不检查信号，它将永远都不会停止。 #include &lt;linux/kthread.h&gt; #include &lt;linux/module.h&gt; #ifndef SLEEP_MILLI_SEC #define SLEEP_MILLI_SEC(nMilliSec)/ do { / long timeout = (nMilliSec) * HZ / 1000; / while(timeout &gt; 0) / { / timeout = schedule_timeout(timeout); / } / }while(0); #endif static struct task_struct * MyThread = NULL; static int MyPrintk(void *data) { char *mydata = kmalloc(strlen(data)&#43;1,GFP_KERNEL); memset(mydata,&#39;/0&#39;,strlen(data)&#43;1); strncpy(mydata,data,strlen(data)); while(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4b924d19c0516214b71a5bbca1dbb188/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-06-14T09:42:58+08:00" />
<meta property="article:modified_time" content="2013-06-14T09:42:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux 内核线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>函数说明：</p> 
<p> </p> 
<p>kthread_create：创建线程。</p> 
<p>struct task_struct *kthread_create(int (*threadfn)(void *data),void *data,const char *namefmt, ...);</p> 
<p>线程创建后，不会马上运行，而是需要将<span style="font-family:新宋体">kthread_create()</span> 返回的task_struct指针传给<span style="font-family:新宋体">wake_up_process()，然后通过此函数运行线程。</span></p> 
<p> </p> 
<p>kthread_run ：创建并启动线程的函数：</p> 
<p>struct task_struct *kthread_run(int (*threadfn)(void *data),void *data,const char *namefmt, ...);</p> 
<p>kthread_stop：通过发送信号给线程，使之退出。</p> 
<p>int kthread_stop(struct task_struct *thread);<br> 线程一旦启动起来后，会一直运行，除非该线程主动调用do_exit函数，或者其他的进程调用kthread_stop函数，结束线程的运行。 </p> 
<p>但如果线程函数正在处理一个非常重要的任务，它不会被中断的。当然如果线程函数永远不返回并且不检查信号，它将永远都不会停止。 <br> </p> 
<p><br> </p> 
<p></p> 
<pre><code class="language-cpp">#include &lt;linux/kthread.h&gt;
#include &lt;linux/module.h&gt;

#ifndef SLEEP_MILLI_SEC   
#define SLEEP_MILLI_SEC(nMilliSec)/
do { /
long timeout = (nMilliSec) * HZ / 1000; /
while(timeout &gt; 0) /
{ /
timeout = schedule_timeout(timeout); /
} /
}while(0);
#endif


static struct task_struct * MyThread = NULL;
static int MyPrintk(void *data)
{
	char *mydata = kmalloc(strlen(data)+1,GFP_KERNEL);
	memset(mydata,'/0',strlen(data)+1);
	strncpy(mydata,data,strlen(data));
	while(!kthread_should_stop())
	{
		SLEEP_MILLI_SEC(1000);
		printk("%s/n",mydata);
	}
	kfree(mydata);
	return 0;
}


static int __init init_kthread(void)
{
	MyThread = kthread_run(MyPrintk,"hello world","mythread");
	return 0;
}

static void __exit exit_kthread(void)
{
	if(MyThread)
	{
		printk("stop MyThread/n");
		kthread_stop(MyThread);
	}
}

module_init(init_kthread);
module_exit(exit_kthread);


MODULE_AUTHOR("YaoGang");
</code></pre> 
<p></p> 
<p><br> </p> 
<p></p> 
<p>这个内核线程的作用就是每隔一秒打印一个“hello world”。</p> 
<p>值得一提的是kthread_should_stop函数，我们需要在开启的线程中嵌入该函数，否则kthread_stop是不起作用的。</p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p>内核经常需要在后台执行一些操作，这种任务就可以通过内核线程（kernlethread）完成--独立运行在内核空间的标准进程。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间，mm指针被设置为NULL；它只在内核空间运行，从来不切换到用户空间去；并且和普通进程一样，可以被调度，也可以被抢占。实际上，内核线程只能由其他内核线程创建，在现有的内核线程中创建一个新的内核线程的方法：<br> <br> kthread_create<span style="font-family:宋体">：创建线程。</span><br> struct <wbr></wbr><wbr></wbr>task_struct <wbr></wbr><wbr></wbr>*kthread_create(int <wbr></wbr><wbr></wbr>(*threadfn)(void <wbr></wbr><wbr></wbr>*data),void <wbr></wbr><wbr></wbr>*data,const <wbr></wbr><wbr></wbr>char <wbr></wbr><wbr></wbr>*namefmt, <wbr></wbr><wbr></wbr>...);<br> 线程创建后，不会马上运行，而是需要将<span style="font-family:Times New Roman">kthread_create() <wbr></wbr><wbr></wbr></span><span style="font-family:宋体">返回的</span><span style="font-family:Times New Roman">task_struct</span><span style="font-family:宋体">指针传给</span><span style="font-family:Times New Roman">wake_up_process()</span><span style="font-family:宋体">，然后通过此函数运行线程。</span><br> kthread_run <wbr></wbr><wbr></wbr><span style="font-family:宋体">：创建并启动线程的函数：</span><br> struct <wbr></wbr><wbr></wbr>task_struct <wbr></wbr><wbr></wbr>*kthread_run(int <wbr></wbr><wbr></wbr>(*threadfn)(void <wbr></wbr><wbr></wbr>*data),void <wbr></wbr><wbr></wbr>*data,const <wbr></wbr><wbr></wbr>char <wbr></wbr><wbr></wbr>*namefmt, <wbr></wbr><wbr></wbr>...);<br> kthread_stop<span style="font-family:宋体">：通过发送信号给线程，使之退出。</span><br> int <wbr></wbr><wbr></wbr>kthread_stop(struct <wbr></wbr><wbr></wbr>task_struct <wbr></wbr><wbr></wbr>*thread);<br> 线程一旦启动起来后，会一直运行，除非该线程主动调用<span style="font-family:Times New Roman">do_exit</span><span style="font-family:宋体">函数，或者其他的进程调用</span><span style="font-family:Times New Roman">kthread_stop</span><span style="font-family:宋体">函数，结束线程的运行。</span><br> 但如果线程函数正在处理一个非常重要的任务，它不会被中断的。当然如果线程函数永远不返回并且不检查信号，它将永远都不会停止。<br> <br> </p> 
<p style="margin:0cm 0cm 0pt 18pt; text-indent:-18pt"><strong><span style="font-family:Times New Roman">1.<span style="font:7pt Times new roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr></span></span>头文件</strong></p> 
<p style="margin:0cm 0cm 0pt"><span style="font-family:Times New Roman">#include&lt;linux/sched.h&gt; <wbr></wbr> <wbr></wbr>//wake_up_process()</span></p> 
<p style="margin:0cm 0cm 0pt"><span style="font-family:Times New Roman">#include&lt;linux/kthread.h&gt;//kthread_create()</span>、<span style="font-family:Times New Roman">kthread_run()</span></p> 
<p style="margin:0cm 0cm 0pt"><span style="font-family:Times New Roman">#include &lt;err.h&gt;//IS_ERR()</span>、<span style="font-family:Times New Roman">PTR_ERR()</span></p> 
<p style="margin:0cm 0cm 0pt 18pt; text-indent:-18pt"><strong><span style="font-family:Times New Roman">2.<span style="font:7pt Times new roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr></span></span>实现</strong></p> 
<p style="margin:0cm 0cm 0pt"><strong>2.1创建线程</strong></p> 
<strong>kernelthread可以用kernel_thread创建，但是在执行函数里面必须用daemonize释放资源并挂到init下，还需要用completion等待这一过程的完成。为了简化操作kthread_create闪亮登场。<br> <br> </strong> 
<p style="margin:0cm 0cm 0pt 19.5pt">在模块初始化时，可以进行线程的创建。使用下面的函数和宏定义：</p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman">struct task_struct*kthread_create(int (*threadfn)(void *data),</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> void*data,</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> const charnamefmt[], ...);</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman">kthread_create源码详解见<a href="http://blog.sina.com.cn/s/blog_6237dcca0100gq67.html" rel="nofollow noopener noreferrer" target="_blank">http://blog.sina.com.cn/s/blog_6237dcca0100gq67.html</a><br> </span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman"><br> </span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman">#define kthread_run(threadfn,data, namefmt,...) <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>\</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman">({<!-- --> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>\</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr>struct task_struct*__k <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>\</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__);\</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr>if(!IS_ERR(__k)) <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>\</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>wake_up_process(__k); <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>\</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr>__k; <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>\</span></p> 
<p style="margin:0cm 0cm 0pt 30.05pt"><span style="font-family:Times New Roman">})</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt">例如：</p> 
<p style="margin:0cm 0cm 0pt 30pt; text-indent:1.5pt"><span style="color:blue">static</span><span style="color:blue">struct</span> task_struct *test_task;</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"><span style="color:blue">static</span><span style="color:blue">int</span> test_init_module(<span style="color:blue">void</span>)</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left">{<!-- --></p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr><span style="color:blue">int</span> err;</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr>test_task = kthread_create(test_thread, NULL,"test_task");</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr><span style="color:blue">if</span>(IS_ERR(test_task)){<!-- --></p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>printk("Unable to start kernel thread.\n");</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>err = PTR_ERR(test_task);</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>test_task = NULL;</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr><span style="color:blue">return</span> err;</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr>}</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr>wake_up_process(test_task);</p> 
<p align="left" style="margin:0cm 0cm 0pt 31.5pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr><span style="color:blue">return</span> 0;</p> 
<p style="margin:0cm 0cm 0pt 21pt; text-indent:21pt">}</p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr></span>module_init(test_init_module);</p> 
<p style="margin:0cm 0cm 0pt"><strong>2.2线程函数</strong></p> 
<p style="margin:0cm 0cm 0pt 19.5pt">在线程函数里，完成所需的业务逻辑工作。主要框架如下所示：</p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman">int threadfunc(void*data){<!-- --></span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>…</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>while(1){<!-- --></span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>set_current_state(TASK_UNINTERRUPTIBLE);</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>if(kthread_should_stop()) break;</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>if(){//</span>条件为真</p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>//</span>进行业务处理</p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>}</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>else{//</span>条件为假</p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>//</span>让出<span style="font-family:Times New Roman">CPU</span>运行其他线程，并在指定的时间内重新被调度</p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>schedule_timeout(HZ);</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>}</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>}</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>…</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>return 0;</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt"><span style="font-family:Times New Roman">}</span></p> 
<p style="margin:0cm 0cm 0pt"><strong>2.3结束线程</strong></p> 
<p style="margin:0cm 0cm 0pt 19.5pt">在模块卸载时，可以结束线程的运行。使用下面的函数：</p> 
<p style="margin:0cm 0cm 0pt 40.5pt; text-indent:1.5pt"><span style="font-family:Times New Roman">int kthread_stop(struct task_struct*k);</span></p> 
<p style="margin:0cm 0cm 0pt 19.5pt">例如：</p> 
<p align="left" style="margin:0cm 0cm 0pt; text-align:left"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr></span><span style="color:blue">static</span><span style="color:blue">void</span> test_cleanup_module(<span style="color:blue">void</span>)</p> 
<p align="left" style="margin:0cm 0cm 0pt 21pt; text-indent:21pt; text-align:left"> {<!-- --></p> 
<p align="left" style="margin:0cm 0cm 0pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr><span style="color:blue">if</span>(test_task){<!-- --></p> 
<p align="left" style="margin:0cm 0cm 0pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>kthread_stop(test_task);</p> 
<p align="left" style="margin:0cm 0cm 0pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>test_task = NULL;</p> 
<p align="left" style="margin:0cm 0cm 0pt; text-align:left"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>}</p> 
<p style="margin:0cm 0cm 0pt 40.5pt; text-indent:1.5pt">}</p> 
<p style="margin:0cm 0cm 0pt 40.5pt; text-indent:1.5pt">module_exit(test_cleanup_module);</p> 
<p style="margin:0cm 0cm 0pt 18pt; text-indent:-18pt"><strong><span style="font-family:Times New Roman">3.<span style="font:7pt Times new roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr></span></span>注意事项</strong></p> 
<p style="margin:0cm 0cm 0pt 36pt; text-indent:-36pt"><span style="font-family:Times New Roman">（1）<span style="font:7pt Times new roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr></span></span>在调用<span style="font-family:Times New Roman">kthread_stop</span>函数时，线程函数不能已经运行结束。否则，<span style="font-family:Times New Roman">kthread_stop</span>函数会一直进行等待。</p> 
<p style="margin:0cm 0cm 0pt 36pt; text-indent:-36pt"><span style="font-family:Times New Roman">（2）<span style="font:7pt Times new roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr></span></span>线程函数必须能让出<span style="font-family:Times New Roman">CPU</span>，以便能运行其他线程。同时线程函数也必须能重新被调度运行。在例子程序中，这是通过<span style="font-family:Times New Roman">schedule_timeout()</span>函数完成的。</p> 
<p style="margin:0cm 0cm 0pt"><strong>4．性能测试</strong></p> 
<p style="margin:0cm 0cm 0pt">可以使用<span style="font-family:Times New Roman">top</span>命令来查看线程（包括内核线程）的<span style="font-family:Times New Roman">CPU</span>利用率。命令如下：</p> 
<p style="margin:0cm 0cm 0pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>top –p</span>线程号</p> 
<p style="margin:0cm 0cm 0pt; text-indent:10.2pt">可以使用下面命令来查找线程号：</p> 
<p style="margin:0cm 0cm 0pt"><span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr>ps aux|grep</span>线程名</p> 
<span style="font-family:Times New Roman"> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr> <wbr></wbr></span> 
注：线程名由 
kthread_create 
函数的第三个参数指定。 
<span style="font-family:Times New Roman"><br> </span> 
<br> 
<p><br> </p> 
<p></p> 
<h4 class="title pre fs1"><span class="tcnt">Ubuntu环境下如何显示printk的输出</span>  <br> </h4> 
<br> 
<p></p> 
<p>在Linux中，驱动程序工作在内核态，内核与用户之间的交互是通过控制台（dev/console）实现的，控制台与终端的概念对于我们“年轻人”来说是容易混淆的，我本人到现在也不是彻底搞明白（菜鸟啊）。内核打印函数printk的输出被定向到文件 /dev/console，但是在Ubuntu环境中，我们使用的通常是虚拟终端 /dev/pts/n。其中n为虚拟终端的编号，如果你当前打开了第3个虚拟终端，那么第3个终端的对应的设备文件即为 /dev/pts/3。可以通过命令tty查看当前终端所对应的设备文件。<br>         在弄清楚了上述概念之后，就不难明白为什么平时在图形界面终端（虚拟终端）下调试驱动程序时printk的输出都看不到了。有两种比较简单的方法可以查看驱动的输出信息，如下所示。<br> <br> <span style="color:#0000ff"><strong>方法一：dmesg命令</strong></span><br> 说明：采用该方法的缺点是需要每次手动执行命令查看消息。<br> <br> <span style="color:#0000ff"><strong>方法二：cat /proc/kmsg &amp;</strong></span><br> 说明：别忘记在命令参数最后加个与号 &amp; 让cat命令工作在后台。采用该方法的优点是只要驱动有消息输出马上就会在终端看到。<br> <br> <strong><span style="color:#ff0000">注</span></strong>：此处只给出解决方法（策略）而非原理（机制）。<br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1545e203220bf09599e57e9f41fffa8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QDockWidget详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/85e5aaa8c2dfc225510e688aafc0e24d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">onvif 客户端的发现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>