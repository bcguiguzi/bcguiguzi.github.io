<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sql查询语句练习 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sql查询语句练习" />
<meta property="og:description" content="select * from emp where a=b group by deptno having c&gt;0 order by sal
#where：子句查询的条件
#group by：按列分组
#having：分组结果的筛选条件
执行顺序： from --&gt; where --&gt; group by --&gt; having --&gt; select --&gt; order by --&gt; limit
where后面不能跟聚合函数
1、先看一下emp表中存放的数据： empno：员工编号
ename：员工姓名
job：员工职位
mgr：部门经理的编号
hiredate：入职日期
sal：薪资
comm：奖金
deptno：部门编号
(1)查询EMP表中各部门工资大于2000的员工人数，并且按人数从高到低排列 思路：
step1：先找出工资大于2000的人 select * from emp where sal&gt;2000; 执行结果如图：
step2：分组找出各个部门工资大于2000的人(对step1中的查询结果按部门进行分组)，并进行人数统计
​ select deptno,count(*) from emp where sal&gt;2000 group by deptno; ​ 执行结果：
step3：对step2中统计出的人数进行排序
select deptno,count(*) sort_count from emp where sal&gt;2000 group by deptno order by sort_count desc; 执行顺序： from --&gt; where --&gt; group by --&gt; having --&gt; select --&gt; order by --&gt; limit" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/96af7fa6ac4a6b8b8f67a208af919761/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-09T22:34:29+08:00" />
<meta property="article:modified_time" content="2023-06-09T22:34:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sql查询语句练习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#fe2c24;">select</span> * <span style="color:#fe2c24;">from</span> emp <span style="color:#fe2c24;">where</span> a=b <span style="color:#fe2c24;">group by</span> deptno <span style="color:#fe2c24;">having</span> c&gt;0 <span style="color:#fe2c24;">order by</span> sal</p> 
<p></p> 
<p>#where：子句查询的条件<br> #group by：按列分组<br> #having：分组结果的筛选条件</p> 
<p>执行顺序：  from --&gt; where --&gt; group by --&gt; having --&gt; select --&gt; order by --&gt; limit</p> 
<p>where后面不能跟聚合函数</p> 
<h2>1、先看一下emp表中存放的数据：</h2> 
<p>empno：员工编号</p> 
<p>ename：员工姓名</p> 
<p>job：员工职位</p> 
<p>mgr：部门经理的编号</p> 
<p>hiredate：入职日期</p> 
<p>sal：薪资</p> 
<p>comm：奖金</p> 
<p>deptno：部门编号</p> 
<p><img alt="" height="206" src="https://images2.imgbox.com/63/69/KzvsdZ2S_o.png" width="553"></p> 
<h3>(1)<strong>查询</strong><strong><strong>EMP</strong></strong><strong><strong>表中各部门工资大于</strong></strong><strong><strong>2000</strong></strong><strong><strong>的员工人数，并且按人数从高到低排列</strong></strong></h3> 
<p>思路：</p> 
<p>step1：先找出工资大于2000的人   </p> 
<pre><code class="language-sql">select * from emp where sal&gt;2000;</code></pre> 
<p></p> 
<p>执行结果如图：</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/1c/5b/rcBa1Puz_o.png" width="603"></p> 
<p>step2：分组找出各个部门工资大于2000的人(对step1中的查询结果按部门进行分组)，并进行人数统计</p> 
<pre><code class="language-sql">​
select deptno,count(*) from emp where sal&gt;2000 group by deptno;

​</code></pre> 
<p>执行结果：</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/c2/c4/k4l3qEBB_o.png" width="274"></p> 
<p>step3：对step2中统计出的人数进行排序</p> 
<pre><code class="language-sql">select deptno,count(*) sort_count
from emp
where sal&gt;2000
group by deptno
order by sort_count desc;</code></pre> 
<p>执行顺序： from --&gt; where --&gt; group by --&gt; having --&gt; select --&gt; order by --&gt; limit</p> 
<p>因为执行顺序select在order by之前，所以select 后面对count(*)重命名之后，order by后面在执行的时候也能识别到</p> 
<p>执行结果如图：</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/3a/b7/LedqLCER_o.png" width="328"></p> 
<h3>(2) 查询EMP表中员工人数大于3的所在部门的部门编号，及对应的人数</h3> 
<p>方法一：使用查询语句嵌套的方法</p> 
<p>step1：先查询出各部门的部门编号以及对应部门的员工数量，对查询的员工数量起了个别名叫dept_num_count</p> 
<pre><code class="language-sql">select deptno,count(*) dept_num_count
from emp
group by deptno;</code></pre> 
<p>运行结果如下图：</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/06/bd/lXqZyuHS_o.png" width="337"></p> 
<p>step2：将step1的查询结果进行过滤，只查询dept_num_count&gt;3的部门信息，并返回部门编号和对应部门的员工数量</p> 
<pre><code class="language-sql">select deptno,dept_num_count
from (select deptno,count(*) dept_num_count
from emp
group by deptno)
where dept_num_count&gt;3;</code></pre> 
<p>执行结果如图：</p> 
<p><img alt="" height="205" src="https://images2.imgbox.com/44/00/1QXY2DMO_o.png" width="383"></p> 
<p> 方法二：直接使用having过滤分组查询结果</p> 
<pre><code class="language-sql">select deptno,count(*)
from emp
group by deptno
having count(*)&gt;3;</code></pre> 
<p>执行结果如图所示：</p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/91/f8/gIUgYGnE_o.png" width="257"></p> 
<h2>2、查询所有科目都大于80的学生信息，表名stu_score</h2> 
<p><img alt="" height="268" src="https://images2.imgbox.com/6c/ab/JClr5jVT_o.png" width="367"></p> 
<p>思路一分析：先查询出分数小于等于80的学生信息，然后条件筛选学生姓名不在分数小于等于80分的查询结果集中(只要有一科成绩小于80，姓名就会查询出来)，再进行去重操作</p> 
<pre><code class="language-sql">select distinct 姓名
from stu_score
where 姓名 not in(select 姓名 from stu_score where 分数&lt;=80);</code></pre> 
<p>执行结果如下：</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/b6/5e/q4KLHZYd_o.png" width="547"></p> 
<p></p> 
<p>思路二分析：只要根据学生姓名进行分组，学生的最小成绩都比80分大那就说明该学生的所有成绩都是大于80分的。</p> 
<pre><code class="language-sql">select 姓名,min(分数)
from stu_score 
group by 姓名
having min(分数)&gt;80;</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="202" src="https://images2.imgbox.com/1d/b4/mwqQ84GP_o.png" width="309"></p> 
<h2></h2> 
<h2></h2> 
<h2>3、习题：</h2> 
<p></p> 
<p>建表及插入数据：</p> 
<pre><code class="language-sql">create table student(
sno varchar2(10) primary key,
sname varchar2(20),
sage number(2),
ssex varchar2(5)
);
create table teacher(
tno varchar2(10) primary key,
tname varchar2(20)
);
create table course(
cno varchar2(10),
cname varchar2(20),
tno varchar2(20),
constraint pk_course primary key (cno,tno)
);
create table sc(
sno varchar2(10),
cno varchar2(10),
score number(4,2),
constraint pk_sc primary key (sno,cno)
);
/*******初始化学生表的数据******/
insert into student values ('s001','张三',23,'男');
insert into student values ('s002','李四',23,'男');
insert into student values ('s003','吴鹏',25,'男');
insert into student values ('s004','琴沁',20,'女');
insert into student values ('s005','王丽',20,'女');
insert into student values ('s006','李波',21,'男');
insert into student values ('s007','刘玉',21,'男');
insert into student values ('s008','萧蓉',21,'女');
insert into student values ('s009','陈萧晓',23,'女');
insert into student values ('s010','陈美',22,'女');
commit;
/******************初始化教师表***********************/
insert into teacher values ('t001', '刘阳');
insert into teacher values ('t002', '谌燕');
insert into teacher values ('t003', '胡明星');
commit;
/***************初始化课程表****************************/
insert into course values ('c001','J2SE','t002');
insert into course values ('c002','Java Web','t002');
insert into course values ('c003','SSH','t001');
insert into course values ('c004','Oracle','t001');
insert into course values ('c005','SQL SERVER 2005','t003');
insert into course values ('c006','C#','t003');
insert into course values ('c007','JavaScript','t002');
insert into course values ('c008','DIV+CSS','t001');
insert into course values ('c009','PHP','t003');
insert into course values ('c010','EJB3.0','t002');
commit;
/***************初始化成绩表***********************/
insert into sc values ('s001','c001',78.9);
insert into sc values ('s002','c001',80.9);
insert into sc values ('s003','c001',81.9);
insert into sc values ('s004','c001',60.9);
insert into sc values ('s001','c002',82.9);
insert into sc values ('s002','c002',72.9);
insert into sc values ('s003','c002',81.9);
insert into sc values ('s001','c003','59');
commit;</code></pre> 
<p>student表：                                                               </p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/f0/ba/aKbrAYKF_o.png" width="257"></p> 
<p> teacher表：</p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/85/1d/m4yWp6Fp_o.png" width="180"></p> 
<p>course表：</p> 
<p><img alt="" height="259" src="https://images2.imgbox.com/71/ad/Xjxj2PQr_o.png" width="284"></p> 
<p>sc表：</p> 
<p> <img alt="" height="207" src="https://images2.imgbox.com/23/8e/5IcDQrJa_o.png" width="209"></p> 
<h3>(1)查询学过“c001”并且也学过编号“c002”课程的同学的学号、姓名；</h3> 
<p>方法一：</p> 
<pre><code class="language-sql">select a.sno,a.sname
from student a join sc b
on a.sno=b.sno
where b.cno in ('c001','c002')
group by a.sno,a.sname
having count(*)=2;

</code></pre> 
<p>根据题目可知，需要用到的表是sc表和student表，先把这两个表连接，因为学生的课程不需要无效匹配，所以直接使用join，先看下前半部分两表关联的结果：</p> 
<pre><code class="language-sql">select a.*,b.*
from student a join sc b
on a.sno=b.sno;</code></pre> 
<p>运行结果如下：可以看到每个学生选的课程都不一样，需要对该结果集进行筛选</p> 
<p><img alt="" height="272" src="https://images2.imgbox.com/e5/43/4pyJ5vdP_o.png" width="414"></p> 
<p>把没有选c001、c002课程的学生过滤掉，只保留选了这两门课程的人</p> 
<p>所以接下来是：</p> 
<pre><code class="language-sql">select a.*,b.*
from student a join sc b
on a.sno=b.sno
where b.cno in ('c001','c002');</code></pre> 
<p>运行结果如下图：从下图可以看到该结果集中所有的数据都有c001和c002这两门课程了，可是题目要求是查询出同时选择c001和c002两门课程的学生，所以需要我们进一步处理</p> 
<p><img alt="" height="271" src="https://images2.imgbox.com/4d/31/NXRdBu7X_o.png" width="424"></p> 
<p> 从上图能看出同时选择了c001和c002的学生的课程数刚好是2，只选择其中一门课程的学生课程数是1，说明了我们可以对上个结果集按学生的姓名、学号进行分组，再对分组出来的课程数量进行计数，并把课程数不是2的学生信息过滤掉，就说明留下来的学生就都是同时选择了c001和c002的学生，将学生的学号和姓名返回</p> 
<pre><code class="language-sql">select a.sname,a.sno
from student a join c b
on a.sno=b.sno
where b.cno in (c001'','c002')
group by a.sname,a.sno
having count(*)=2;
</code></pre> 
<p>查询结果如下图所示：</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/99/88/r8vAaV9Y_o.png" width="267"></p> 
<p>方法二：</p> 
<pre><code class="language-sql">select a.sno,a.sname
from student a join sc b
on a.sno=b.sno
and b.cno='c001'
join sc c
on a.sno=c.sno
where c.cno='c002';</code></pre> 
<p>查询结果如下图：</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/a1/e4/kETy3XVJ_o.png" width="235"></p> 
<p>分步解析：</p> 
<p>step1：先把student表和sc使用join连接起来，再加限定条件把选择了c001课程的人筛选出来</p> 
<pre><code class="language-sql">select a.*,b.*
from student a join sc b
on a.sno=b.sno
and b.cno='c001';</code></pre> 
<p>运行结果如下图：可以看到确实查询出了只选择c001课程的学生</p> 
<p><img alt="" height="197" src="https://images2.imgbox.com/ee/bf/f8k0nnIv_o.png" width="412"></p> 
<p> step2：我们可以用同样的方法可以查询出只选择了c002课程的学生：</p> 
<pre><code class="language-sql">select a.*,c.*
from student a join sc c
on a.sno=c.sno
and c.cno='c002'</code></pre> 
<p>运行结果如下图所示，查询出了只选择c002的学生</p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/81/b2/prBzd2jg_o.png" width="413"></p> 
<p>step3：把step1筛选出的结果集作为一个新表和sc表进行连接：</p> 
<pre><code class="language-sql">select a.*,b.*
from student a join sc b
on a.sno=b.sno
and b.cno='c001'
join sc c
on b.sno=c.sno
and c.cno='c002'
</code></pre> 
<p>运行结果如下图所示：</p> 
<p><img alt="" height="249" src="https://images2.imgbox.com/0b/02/q3lVJgkk_o.png" width="213"></p> 
<p> 能看到step2和step3的表中都有s001、s002、s003，说明两门课程都选了的学生就是他们三个人，所以不用select a.*,b.*，只把他们三个的学号和姓名查询出来即可：</p> 
<p>则代码就变成了：</p> 
<pre><code class="language-sql">select a.sname,a.sno
from student a join sc b
on a.sno=b.sno
and b.cno='c001'
join sc c 
on b.sno=c.sno
and c.cno='c002';
</code></pre> 
<h3>(2)查询学过“谌燕”老师所教的所有课的同学的学号、姓名；</h3> 
<pre><code class="language-sql">select cno,tname
from course
where cno in (select tno from teacher where tname='谌燕')
</code></pre> 
<p>(3)查询“c001”课程比“c002”课程成绩高的所有学生的学号；</p> 
<pre><code class="language-sql">select a.sno,a.score,b.score
from sc a join sc b
on a.cno='c001'
and b.cno='c002'
where a.score&gt;b.score;
</code></pre> 
<p>使用自连接，a表取学号是c001的数据，b表取学号是c002的数据，过滤条件是c001对应的成绩大于c002的成绩，执行结果如图：</p> 
<p><img alt="" height="210" src="https://images2.imgbox.com/a8/47/StpUbdNE_o.png" width="314"></p> 
<p></p> 
<p></p> 
<p> </p> 
<p></p> 
<p>3、(1)求出每个部门超过其所在部门平均工资人员占整个部门人员数目的百分比</p> 
<p>先查看一下emp表的内容：</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/55/dd/jIB2gXuy_o.png" width="565"></p> 
<p>分步解析：</p> 
<p>百分比=超过部门平均工资的人数/整个部门的人数</p> 
<p>step1：先求出部门的平均工资</p> 
<pre><code class="language-sql">select deptno,avg(sal)
from emp
group by deptno
</code></pre> 
<p>运行结果：</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/41/08/2R6dOk5O_o.png" width="241"></p> 
<p> step2：</p> 
<p>将emp表和step1的结果集进行left join连接，连接条件是emp表的deptno(部门编号)和step1的部门编号相等</p> 
<pre><code class="language-sql">select a.deptno,a.sal,b.asal
from emp a
left join (select deptno,avg(sal) asal from emp group by deptno) b
on a.deptno=b.deptno

</code></pre> 
<p>运行结果如下图，图中可以看到部门编号、各部门员工的薪资sal和各部门的平均薪资asal</p> 
<p><img alt="" height="378" src="https://images2.imgbox.com/9b/57/aHQfdWBl_o.png" width="537"></p> 
<p> step3：要得到各部门超过平均薪资的员工数量，需要对step2的结果集进行条件筛选，添加判断条件，只将sal&gt;asal的结果筛选并统计个数，就得到了各部门的员工薪资大于部门平均工资的员工数量</p> 
<pre><code class="language-sql">select a.deptno,round(count(b.deptno)/count(a.deptno),4)*100||'%' 百分比
from emp a
left join (select deptno,avg(sal) asal from emp group by deptno) b
on a.deptno=b.deptno
and a.sal&gt;b.asal 
group by a.deptno;

</code></pre> 
<p>运行结果如下：这里用了简单的字符串拼接符号||以及round函数，round(a,b)表示对数字a保留b位数，举个例子，round(12677.098776,2)=12677.10  对该数字保留两位小数，小数点第三位是8，所以对小数点第二位的9四舍五入就变成了10</p> 
<p><img alt="" height="244" src="https://images2.imgbox.com/47/c1/ZnuKDX1Z_o.png" width="596"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e970f19eb57f7ae858bde12ced142f44/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">云原生到底是个啥玩意？从云端降临的超级技术：云原生</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a66c66554c40c5f4dd6fdbccf5ca6e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ELK日志收集系统简述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>