<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>引用计数算法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="引用计数算法" />
<meta property="og:description" content="前言 相比于前面三种垃圾收集算法，引用计数算法算是实现最简单的了，它只需要一个简单的递归即可实现。现代编程语言比如Lisp，Python，Ruby等的垃圾收集算法采用的就是引用计数算法。现在就让我们来看下引用计数算法(reference counting)是如何工作的。
算法原理 引用计数算法很简单，它实际上是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加一，如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时，那么该对象就会被回收。
比如说，当我们编写以下代码时，
String p = new String(&#34;abc&#34;) abc这个字符串对象的引用计数值为1.
而当我们去除abc字符串对象的引用时，则abc字符串对象的引用计数减1
p = null 由此可见，当对象的引用计数为0时，垃圾回收就发生了。这跟前面三种垃圾收集算法不同，前面三种垃圾收集都是在为新对象分配内存空间时由于内存空间不足而触发的，而且垃圾收集是针对整个堆中的所有对象进行的。而引用计数垃圾收集机制不一样，它只是在引用计数变化为0时即刻发生，而且只针对某一个对象以及它所依赖的其它对象。所以，我们一般也称呼引用计数垃圾收集为直接的垃圾收集机制，而前面三种都属于间接的垃圾收集机制。
而采用引用计数的垃圾收集机制跟前面三种垃圾收集机制最大的不同在于，垃圾收集的开销被分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的&#34;Stop-The-World&#34;的垃圾收集机制。这个也可以从它的伪代码实现中看出：
New(): //分配内存 ref &lt;- allocate() if ref == null error &#34;Out of memory&#34; rc(ref) &lt;- 0 //将ref的引用计数(reference counting)设置为0 return ref atomic Write(dest, ref) //更新对象的引用 addReference(ref) deleteReference(dest) dest &lt;- ref addReference(ref): if ref != null rc(ref) &lt;- rc(ref)&#43;1 deleteReference(ref): if ref != null rc(ref) &lt;- rc(ref) -1 if rc(ref) == 0 //如果当前ref的引用计数为0，则表明其将要被回收 for each fld in Pointers(ref) deleteReference(*fld) free(ref) //释放ref指向的内存空间 对于上面的伪代码，重点在于理解两点，第一个是当对象的引用发生变化时，比如说将对象重新赋值给新的变量等，对象的引用计数如何变化。假设我们有两个变量p和q，它们分别指向不同的对象，当我们将他们指向同一个对象时，下面的图展示了p和q变量指向的两个对象的引用计数的变化。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/a464b116109b46da3285cee15852ef4e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-22T16:18:03+08:00" />
<meta property="article:modified_time" content="2019-08-22T16:18:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">引用计数算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>前言</h3> 
<p>相比于前面三种垃圾收集算法，引用计数算法算是实现最简单的了，它只需要一个简单的递归即可实现。现代编程语言比如Lisp，Python，Ruby等的垃圾收集算法采用的就是引用计数算法。现在就让我们来看下引用计数算法(reference counting)是如何工作的。</p> 
<h3>算法原理</h3> 
<p>引用计数算法很简单，它实际上是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加一，如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时，那么该对象就会被回收。</p> 
<p>比如说，当我们编写以下代码时，</p> 
<pre class="has"><code>String p = new String("abc")
</code></pre> 
<p>abc这个字符串对象的引用计数值为1.</p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/bb/30/FMVWN2hs_o.png"></p> 
<p> </p> 
<p>而当我们去除abc字符串对象的引用时，则abc字符串对象的引用计数减1</p> 
<pre class="has"><code>p = null
</code></pre> 
<p><img alt="" class="has" src="https://images2.imgbox.com/0b/9b/ZmC24SE9_o.png"></p> 
<p>由此可见，当对象的引用计数为0时，垃圾回收就发生了。这跟前面三种垃圾收集算法不同，前面三种垃圾收集都是在为新对象分配内存空间时由于内存空间不足而触发的，而且垃圾收集是针对整个堆中的所有对象进行的。而引用计数垃圾收集机制不一样，它只是在引用计数变化为0时即刻发生，而且只针对某一个对象以及它所依赖的其它对象。所以，我们一般也称呼引用计数垃圾收集为<strong>直接</strong>的垃圾收集机制，而前面三种都属于<strong>间接</strong>的垃圾收集机制。</p> 
<p>而采用引用计数的垃圾收集机制跟前面三种垃圾收集机制最大的不同在于，垃圾收集的开销被分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的"Stop-The-World"的垃圾收集机制。这个也可以从它的伪代码实现中看出：</p> 
<pre class="has"><code>New(): //分配内存
    ref &lt;- allocate()
    if ref == null
        error "Out of memory"
    rc(ref) &lt;- 0  //将ref的引用计数(reference counting)设置为0
    return ref

atomic Write(dest, ref) //更新对象的引用
    addReference(ref)
    deleteReference(dest)
    dest &lt;- ref

addReference(ref):
    if ref != null
        rc(ref) &lt;- rc(ref)+1
        
deleteReference(ref):
    if ref != null
        rc(ref) &lt;- rc(ref) -1
        if rc(ref) == 0 //如果当前ref的引用计数为0，则表明其将要被回收
            for each fld in Pointers(ref)
                deleteReference(*fld)
            free(ref) //释放ref指向的内存空间
</code></pre> 
<p>对于上面的伪代码，重点在于理解两点，第一个是当对象的引用发生变化时，比如说将对象重新赋值给新的变量等，对象的引用计数如何变化。假设我们有两个变量p和q，它们分别指向不同的对象，当我们将他们指向同一个对象时，下面的图展示了p和q变量指向的两个对象的引用计数的变化。</p> 
<pre class="has"><code>String p = new String("abc")
String q = new String("def")
p = q
</code></pre> 
<p>当我们执行代码<strong>p=q</strong>时，实际上相当于调用了伪代码中的<strong>Write(p,q)</strong>， 即对p原先指向的对象要进行deleteReference()操作 - 引用计数减一，因为p变量不再指向该对象了，而对q原先指向的对象要进行addReference()操作 - 引用计数加一。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/42/11/ToBdJPEv_o.png"></p> 
<p>第二点需要理解的是，当某个对象的引用计数减为0时，collector需要递归遍历它所指向的所有域，将它所有域所指向的对象的引用计数都减一，然后才能回收当前对象。在递归过程中，引用计数为0的对象也都将被回收，比如说下图中的phone和address指向的对象。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/72/29/r5eIIay0_o.png"></p> 
<h3>环形数据问题</h3> 
<p>但是这种引用计数算法有一个比较大的问题，那就是它不能处理环形数据 - 即如果有两个对象相互引用，那么这两个对象就不能被回收，因为它们的引用计数始终为1。这也就是我们常说的“内存泄漏”问题。比如下图展示的将p变量赋值为null值后所出现的内存泄漏。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/da/b5/zaH5I16v_o.png"></p> 
<h3>后记</h3> 
<p>到今天为止，四种基本的垃圾收集算法就都介绍完了。每种算法都有它自己的优点和缺点。同时每种基本算法还有它自己的优化算法，但是在这里我只专注于介绍基本的原理，让大家知道它们是怎么工作的，对于它们的优化算法，大家可以自己查阅资料进行学习。后面我们会来看下这几种基本垃圾收集算法怎么组合成更加高级的垃圾收集算法，比如说分代垃圾收集算法等。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7dc15c0beeeb33288565b1dfe96308f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">屏幕适配</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02ca750678048cb7748eeef118f26d40/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vc运行库合集 官方正式版 v2019.07.20</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>