<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java的四种引用方式(强引用，软引用，弱引用，虚引用) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java的四种引用方式(强引用，软引用，弱引用，虚引用)" />
<meta property="og:description" content="文章目录 前言一、强引用（StrongReference）二、软引用（SoftReference）三、弱引用（WeakReference）四、虚引用（PhantomReference）总结 前言 众所周知，Java中是JVM负责内存的分配和回收，这是它的优点（使用方便，程序不用再像使用c那样操心内存），但同时也是它的缺点（不够灵活）。为了解决内存操作不灵活这个问题，可以采用软引用等方法。
在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象。从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。
一、强引用（StrongReference） 强引用是使用最普遍的引用,如果一个对象具有强引用,那么垃圾回收器绝对不会回收它,当内存空间不足时,JVM宁愿抛出OutOfMemoryError 异常也不会随意回收具有强引用的对象来解决内存不足的问题。
String str = &#34;hello&#34;; List&lt;String&gt; list = new Arraylist&lt;String&gt;(); list.add(str); 这个list集合里面的数据不会被释放，内存空间不足是也不会被释放，但我们可以通过调用clear()来进行释放
二、软引用（SoftReference） 如果一个对象只具有软引用,内存空间足够时,垃圾回收器便不会回收它,如果内存空间不足了,那么垃圾回收器就会回收这些对象的内存;只要垃圾回收器没有回收它,该对象就可以被对象使用,软引用可用于实现内存敏感的高速缓存。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。
public class Test { public static void main(String[] args){ System.out.println(&#34;开始&#34;); A a = new A(); SoftReference&lt;A&gt; sr = new SoftReference&lt;A&gt;(a); a = null; if(sr!=null){ a = sr.get(); } else{ a = new A(); sr = new SoftReference&lt;A&gt;(a); } System.out.println(&#34;结束&#34;); } } class A{ int[] a ; public A(){ a = new int[100000000]; } } 当内存足够大时可以把数组存入软引用，取数据时就可从内存里取数据，提高运行效率。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f15e53d3d779d3e48698bc73856770bc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-09T08:03:11+08:00" />
<meta property="article:modified_time" content="2021-08-09T08:03:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java的四种引用方式(强引用，软引用，弱引用，虚引用)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_8" rel="nofollow">前言</a></li><li><a href="#StrongReference_13" rel="nofollow">一、强引用（StrongReference）</a></li><li><a href="#SoftReference_26" rel="nofollow">二、软引用（SoftReference）</a></li><li><a href="#WeakReference_60" rel="nofollow">三、弱引用（WeakReference）</a></li><li><a href="#PhantomReference_72" rel="nofollow">四、虚引用（PhantomReference）</a></li><li><a href="#_76" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="_8"></a>前言</h2> 
<p>众所周知，Java中是JVM负责内存的分配和回收，这是它的优点（使用方便，程序不用再像使用c那样操心内存），但同时也是它的缺点（不够灵活）。为了解决内存操作不灵活这个问题，可以采用软引用等方法。</p> 
<p>在JDK1.2以前的版本中，当一个对象不被任何变量引用，那么程序就无法再使用这个对象。从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p> 
<h2><a id="StrongReference_13"></a>一、强引用（StrongReference）</h2> 
<p>强引用是使用最普遍的引用,如果一个对象具有强引用,那么垃圾回收器绝对不会回收它,当内存空间不足时,JVM宁愿抛出OutOfMemoryError 异常也不会随意回收具有强引用的对象来解决内存不足的问题。</p> 
<pre><code class="prism language-java"> <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
 <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Arraylist</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个list集合里面的数据不会被释放，内存空间不足是也不会被释放，但我们可以通过调用clear()来进行释放</p> 
<h2><a id="SoftReference_26"></a>二、软引用（SoftReference）</h2> 
<p>如果一个对象只具有软引用,内存空间足够时,垃圾回收器便不会回收它,如果内存空间不足了,那么垃圾回收器就会回收这些对象的内存;只要垃圾回收器没有回收它,该对象就可以被对象使用,软引用可用于实现内存敏感的高速缓存。</p> 
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>  

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            
        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            
        <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        a <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>sr<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
            a <span class="token operator">=</span> sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>  
            a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">A</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>            
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
    <span class="token punctuation">}</span>       

<span class="token punctuation">}</span>  

<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token punctuation">;</span>  
    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  
        a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre> 
<p>当内存足够大时可以把数组存入软引用，取数据时就可从内存里取数据，提高运行效率。</p> 
<h2><a id="WeakReference_60"></a>三、弱引用（WeakReference）</h2> 
<p>弱引用与软引用差不多都属于可有可无；弱引用与软引用的区别在于：只具有弱引用的对象生命周期更短，垃圾回收器一旦发现就只具有弱引用的对象，不管当前内存是否足够，都会将其回收，但是垃圾回收器是一个优先级很低的线程，不一定会很快的发现那些只具有弱引用的对象，弱引用可用于解决内存泄漏的问题。</p> 
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p> 
<pre><code class="prism language-java"><span class="token class-name">Object</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//只要c还指向car object, car object就不会被回收</span>
<span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Car</span><span class="token punctuation">&gt;</span></span> weakCar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token punctuation">(</span><span class="token class-name">Car</span><span class="token punctuation">)</span><span class="token punctuation">(</span>car<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>当要获得weak reference引用的object时, 首先需要判断它是否已经被回收，就用weakCar.get()方法判断，如果返回值为null，那么说明weakCar指向的对象已经被回收了。<br> 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。</p> 
<h2><a id="PhantomReference_72"></a>四、虚引用（PhantomReference）</h2> 
<p>虚引用与其它几种引用都不同,虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用,那么它就和没有任何引用一样,在任何时候都可能被垃圾回收器回收,虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用必须和引用队列 （ReferenceQueue）联合使用。垃圾回收器回收对象时，该对象还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br> 在实际程序设计中一般很少使用弱引用与虚引用，使用软用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。</p> 
<h2><a id="_76"></a>总结</h2> 
<p><img src="https://images2.imgbox.com/c6/73/LMh86LwO_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/243946ba144d217529989c830a15c373/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">服务器显示屏 超出工作频率范围,如何解决显示器出错提示：超出工作频率范围...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1da78762eec52c6e535f17bbad7ed907/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">go-gin (youtebu自学) - 第三课 -- 自定义logger中间件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>