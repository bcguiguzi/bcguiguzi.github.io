<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AI-线性回归模型 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AI-线性回归模型" />
<meta property="og:description" content="线性回归应用场景 房价预测，通过分析房地产市场的历史数据，如房屋大小、位置、建造年份等因素，线性回归可以帮助预测未来房价的走势。
销售额预测，企业可以利用线性回归模型来预测产品的销售额，这通常涉及到产品价格、市场营销预算、季节性因素等变量的分析。
贷款额度预测，金融机构可以使用线性回归来评估客户的信用风险，并据此决定贷款额度。
线性回归(Linear regression) 线性回归是一种利用直线方程对变量之间关系进行建模的回归分析方法。
定义：线性回归分析用于研究两个或多个变量之间的关系，其中一个是自变量，另一个是因变量。在这种方法中，目标是找到一个线性方程，即一个直线，该直线能够尽可能好地预测因变量基于自变量的值。公式：线性回归模型通常表示为 ( y = wx &#43; b )，其中 ( y ) 是因变量，( x ) 是自变量，( w ) 是权重（斜率），而 ( b ) 是偏差（截距）。这个方程描述了自变量和因变量之间的直线关系。最小二乘法：为了找到最佳的 ( w ) 和 ( b ) 值，通常采用最小二乘法。该方法通过最小化实际数据点和回归线之间的平方差来求解这些参数。 期末成绩：0.7×考试成绩&#43;0.3×平时成绩 特征值与目标值之间建立了一个关系，这个关系可以理解为线性模型 。 sklearn中， 线性回归的API在linear_model模块中 sklearn.linear_model.LinearRegression()
LinearRegression.coef_：回归系数 代码 from sklearn.linear_model import LinearRegression x = [[80, 86], [82, 80], [85, 78], [90, 90], [86, 82], [82, 90], [78, 80], [92, 94]] y = [84." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/7d5c8d418e1711645de9df3c71e8038e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T13:21:30+08:00" />
<meta property="article:modified_time" content="2024-03-14T13:21:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AI-线性回归模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="1">线性回归应用场景</h3> 
<ul><li> <p>房价预测，通过分析房地产市场的历史数据，如房屋大小、位置、建造年份等因素，线性回归可以帮助预测未来房价的走势。</p> </li><li> <p>销售额预测，企业可以利用线性回归模型来预测产品的销售额，这通常涉及到产品价格、市场营销预算、季节性因素等变量的分析。</p> </li><li> <p>贷款额度预测，金融机构可以使用线性回归来评估客户的信用风险，并据此决定贷款额度。</p> </li></ul> 
<h3>线性回归(Linear regression) </h3> 
<p> 线性回归是一种<strong>利用直线方程对变量之间关系进行建模的回归分析方法</strong>。</p> 
<ol><li><strong>定义</strong>：线性回归分析用于研究两个或多个变量之间的关系，其中一个是自变量，另一个是因变量。在这种方法中，目标是找到一个线性方程，即一个直线，该直线能够尽可能好地预测因变量基于自变量的值。</li><li><strong>公式</strong>：线性回归模型通常表示为 ( y = wx + b )，其中 ( y ) 是因变量，( x ) 是自变量，( w ) 是权重（斜率），而 ( b ) 是偏差（截距）。这个方程描述了自变量和因变量之间的直线关系。</li><li><strong>最小二乘法</strong>：为了找到最佳的 ( w ) 和 ( b ) 值，通常采用最小二乘法。该方法通过最小化实际数据点和回归线之间的平方差来求解这些参数。</li></ol> 
<ul><li>期末成绩：0.7×考试成绩+0.3×平时成绩</li></ul> 
<p>特征值与目标值之间建立了一个关系，这个关系可以理解为线性模型 。 </p> 
<p><strong>sklearn中， 线性回归的API在linear_model模块中 </strong></p> 
<p>sklearn.linear_model.LinearRegression()</p> 
<ul><li>LinearRegression.coef_：回归系数</li></ul> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5f/f9/MZA6Z4N9_o.png"></p> 
<p>代码 </p> 
<pre><code class="language-python">from sklearn.linear_model import LinearRegression
x = [[80, 86],
     [82, 80],
     [85, 78],
     [90, 90],
     [86, 82],
     [82, 90],
     [78, 80],
     [92, 94]]

y = [84.2, 80.6, 80.1, 90, 83.2, 87.6, 79.4, 93.4]

estimator = LinearRegression()

estimator.fit(x,y)
print(estimator.coef_)
estimator.predict([[100, 80]])</code></pre> 
<p>通过<code>sklearn.linear_model.LinearRegression</code>类创建一个线性回归模型实例。这个类有许多参数可以设置，如<code>fit_intercept</code>（是否计算模型的截距）和<code>normalize</code>（是否对数据进行标准化处理）等。</p> 
<ol><li><strong>训练模型</strong>：使用训练集数据调用模型的<code>fit</code>方法来训练模型。</li><li><strong>进行预测</strong>：训练好模型后，使用<code>predict</code>方法对测试集或新数据进行预测。</li><li><strong>评估模型</strong>：常用的评估指标包括均方误差（MSE）、决定系数（R²）等。这些指标可以帮助我们了解模型的预测性能和数据拟合程度。</li></ol> 
<h3>损失函数 </h3> 
<p>用来衡量机器学习模型性能的函数，损失函数可以计算预测值与真实值之间的误差（用一个实数来表示），误差越小说明模型性能越好。</p> 
<p> <img alt="" src="https://images2.imgbox.com/67/c9/Me21lRyY_o.png"></p> 
<ul><li>误差的大小是坐标系中两点之间的距离，将真实值与预测值相减得到误差。</li></ul> 
<p>但是用来衡量回归损失的时候， 不能简单的将每个点的预测误差相加。</p> 
<h3>平方损失 </h3> 
<p>回归问题的损失函数<img alt="" src="https://images2.imgbox.com/1b/22/Ht5kkJtH_o.png"> </p> 
<ol><li>yi 为第i个训练样本的真实值</li><li>h(xi) 为第i个训练样本特征值组合预测函数又称最小二乘法</li></ol> 
<pre><code class="language-python">import numpy as np
from sklearn.linear_model import LinearRegression

if __name__ == '__main__':

    
    x = np.mat([[80, 86],
                [82, 80],
                [85, 78],
                [90, 90],
                [86, 82],
                [82, 90],
                [78, 80],
                [92, 94]])

    # 目标值
    y = np.mat([84.2, 80.6, 80.1, 90, 83.2, 87.6, 79.4, 93.4]).transpose()

    
    ones_array = np.ones([len(x), 1])
    x = np.hstack([ones_array, x])

    
    w = (x.transpose() * x) ** -1 * x.transpose() * y
    print('[%.1f %.1f %.1f]' % (w[0][0], w[1][0], w[2][0]))

    # 使用 LinearRegression 
    estimator = LinearRegression(fit_intercept=True)
    estimator.fit(x, y)
    print(estimator.coef_[0])

    # 输出结果
    # [0.0 0.3 0.7]
    # [0.  0.3 0.7]</code></pre> 
<h3>梯度下降法</h3> 
<p>梯度下降法的基本概念是在一个多维空间内，通过迭代的方式逐步逼近最小值点。在每一步迭代中，都沿着当前点的梯度（即损失函数在该点的导数）方向移动一定的步长，以此来减小损失函数的值。这个过程类似于一个人在山上寻找下山的路，每次都选择当前位置最陡峭的方向向下走一步，最终会到达山底。</p> 
<p>在机器学习中，特别是在线性回归模型中，梯度下降法通常用来最小化预测值与实际值之间的差距，这个差距通过损失函数来量化。线性回归模型的预测公式可以表示为 y = θ0 + θ1x1 + θ2x2 +... + θnxn，其中 θj 是模型参数，包括偏置项 θ0 和特征权重 θ1, θ2,..., θn。梯度下降法通过迭代更新这些参数，使得损失函数最小化。</p> 
<p><strong>全梯度下降算法（FGD） </strong></p> 
<p>每次迭代时, 使用全部样本的梯度值，<strong>计算训练集所有样本误差</strong>，<strong>对其求和再取平均值作为目标函数</strong>。权重向量沿其梯度相反的方向移动，从而使当前目标函数减少得最多。与随机梯度下降（SGD）和小批量梯度下降（MBGD）不同，FGD在每次迭代时使用整个数据集来计算梯度。 </p> 
<p>在实际应用中，FGD通常用于模型训练的优化过程。具体步骤包括初始化模型参数、计算损失函数的梯度、更新参数以及重复迭代直到满足停止条件（如梯度趋近于零、达到预设的迭代次数或损失函数变化小于某个阈值）。由于FGD在每次迭代中使用整个数据集，因此它通常能够更准确地逼近全局最小值，但也因为如此，它的计算成本相对较高，尤其在大数据集上运行时可能会非常缓慢。 </p> 
<p id="2-sgd"><strong>随机梯度下降算法（SGD）</strong></p> 
<p>随机梯度下降（SGD）是机器学习和深度学习中常用的一种优化算法，它的核心在于通过随机选择数据点来计算梯度，并更新模型参数。这种方法特别适用于大规模数据集，因为它可以在不需要遍历整个数据集的情况下进行模型的迭代更新。 </p> 
<pre><code class="language-python">from sklearn.linear_model import SGDRegressor</code></pre> 
<p><strong>随机平均梯度下降算法（SAG）    </strong>  </p> 
<p><strong>随机平均梯度下降（SAG）是一种改进型的随机梯度下降算法，目的是提高收敛速度并减少方差</strong>。</p> 
<ul><li>每次迭代时, 随机选择一个样本的梯度值和以往样本的梯度值的均值</li></ul> 
<h3>回归问题评估 </h3> 
<p id="11"><strong>平均绝对误差</strong></p> 
<pre><code class="language-python">from sklearn.metrics import mean_absolute_error
mean_absolute_error(y_test,y_predict)</code></pre> 
<p><strong> 均方误差</strong></p> 
<pre><code class="language-python">from sklearn.metrics import mean_squared_error
mean_squared_error(y_test,y_predict)</code></pre> 
<p><strong> 均方根误差</strong></p> 
<ul><li> <p>RMSE 越小模型预测约准确</p> </li><li> <p>RMSE 是 MSE 的平方根。某些情况下比MES更有用，由于 MAE 和 RMSE 都是误差的一次方，可以将它们相互比较</p> </li></ul> 
<p> <strong>案例：波士顿房价预测 </strong></p> 
<pre><code class="language-python">from sklearn.datasets import load_boston
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
from sklearn.linear_model import SGDRegressor
from sklearn.linear_model import LinearRegression

def linear_model1():
    
    
    data = load_boston()

    # 数据集划分
    x_train, x_test, y_train, y_test = train_test_split(data.data, data.target, random_state=22)

    # 特征工程-标准化
    transfer = StandardScaler()
    x_train = transfer.fit_transform(x_train)
    x_test = transfer.transform(x_test)

    # 机器学习-线性回归(正规方程)
    estimator = LinearRegression()
    estimator.fit(x_train, y_train)

    # 模型评估
    
    y_predict = estimator.predict(x_test)
    print("预测值为:\n", y_predict)
    print("模型中的系数为:\n", estimator.coef_)
    print("模型中的偏置为:\n", estimator.intercept_)

    
    # 均方误差
    error = mean_squared_error(y_test, y_predict)
    print("误差为:\n", error)

    return None</code></pre> 
<p>使用<code>SGDRegressor</code>类进行线性回归训练的过程：</p> 
<ol><li><strong>创建模型实例</strong>：通过<code>SGDRegressor(max_iter=1000)</code>创建一个随机平均梯度下降回归模型的实例。这里的<code>max_iter=1000</code>表示模型在训练时最多进行1000次迭代。</li><li><strong>拟合数据</strong>：<code>estimator.fit(x_train, y_train)</code>这一行代码的作用是用训练数据集<code>x_train</code>（特征）和<code>y_train</code>（标签）来训练模型。在这个过程中，模型会尝试学习数据之间的关系，以便能够对新的数据进行预测。</li><li><strong>优化过程</strong>：<code>SGDRegressor</code>使用随机梯度下降算法来优化平方损失函数，这是线性回归常用的损失函数。通过最小化损失函数，模型可以学习到最佳的权重系数和偏置项，从而得到一个能够较好地预测未知数据的线性模型。</li><li><strong>模型评估</strong>：在模型训练完成后，通常会使用测试数据集<code>x_test</code>来评估模型的性能。通过调用<code>estimator.predict(x_test)</code>可以获取模型对测试数据的预测值，进而可以通过比较预测值和真实值来计算模型的准确性和其他性能指标。</li></ol> 
<pre><code class="language-python">def linear_model2():
    
    
    data = load_boston()

    # 数据集划分
    x_train, x_test, y_train, y_test = train_test_split(data.data, data.target, random_state=22)

    # 特征工程-标准化
    transfer = StandardScaler()
    x_train = transfer.fit_transform(x_train)
    x_test = transfer.fit_transform(x_test)

    
    estimator = SGDRegressor(max_iter=1000)
    estimator.fit(x_train, y_train)

    
    # 获取系数等值
    y_predict = estimator.predict(x_test)
    print("预测值为:\n", y_predict)
    print("模型中的系数为:\n", estimator.coef_)
    print("模型中的偏置为:\n", estimator.intercept_)

    
    # 均方误差
    error = mean_squared_error(y_test, y_predict)
    print("误差为:\n", error)

    return None</code></pre> 
<p>SGDRegressor学习率</p> 
<pre><code class="language-python">SGDRegressor(max_iter=1000,learning_rate="constant",eta0=0.1)</code></pre> 
<ul><li><code>eta0</code>参数定义了学习率的起始值。在<code>"constant"</code>模式下，这个值在整个训练过程中不会改变。 </li><li>学习率的选择会影响模型的训练速度和最终性能。一个较大的学习率可能会导致快速收敛，但也可能会错过最优解；而一个较小的学习率可能需要更多的迭代次数来达到同样的精度。</li><li>在其他模式下，如<code>"invscaling"</code>，学习率会根据迭代次数进行调整，通常是随着迭代次数的增加而减小，这有助于模型在接近最优解时减少波动，提高收敛精度。</li></ul> 
<p id="3"><strong>模型的保存和加载</strong></p> 
<p>sklearn模型的保存和加载API <code>import joblib</code></p> 
<ul><li>保存：joblib.dump(estimator, 'test.pkl')</li><li>加载：estimator = joblib.load('test.pkl')</li></ul> 
<pre><code class="language-python">from sklearn import svm
from sklearn import datasets
from joblib import dump, load

# 加载数据集
iris = datasets.load_iris()
X, y = iris.data, iris.target

# 训练模型
clf = svm.SVC()
clf.fit(X, y)

# 保存模型
dump(clf, 'model.joblib')

# 加载模型
clf_from_joblib = load('model.joblib')

# 使用加载的模型进行预测
print(clf_from_joblib.predict(X[0:1]))</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d9573cd36de6e395ae8a0dfe11c5fe3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Node.js入门基础—day01</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d0c7435340cc13e57fe06dfbb5d3a84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue的axios教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>