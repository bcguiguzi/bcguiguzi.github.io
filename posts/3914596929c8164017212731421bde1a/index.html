<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JavaScript实现十大排序算法（图文详解） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JavaScript实现十大排序算法（图文详解）" />
<meta property="og:description" content="冒泡排序 排序的效果图 解法 当前解法为升序
冒泡排序的特点，是一个个数进行处理。第i个数，需要与后续的len-i-1个数进行逐个比较。
为什么是 `len-i-1`个数？
因为数组末尾的i个数，已经是排好序的，确认位置不变的了。
为什么确认位置不变，因为它们固定下来之前，已经和前面的数字都一一比较过了。
function bubbleSort(arr){ const len = arr.length; for(let i = 0; i &lt; len - 1; i&#43;&#43;){ for(let j = 0; j &lt; len - i - 1; j&#43;&#43;){ if(arr[j] &gt; arr[j&#43;1]){ const tmp = arr[j&#43;1]; arr[j&#43;1] = arr[j]; arr[j] = tmp; } } } return arr; } 快速排序 概要 快速排序，使用的是分治法的思想。
通过选定一个数字作为比较值，将要排序其他数字，分为 &gt;比较值 和 &lt;比较值，两个部分。并不断重复这个步骤，直到只剩要排序的数字只有本身，则排序完成。
效果图 解法 function quickSort(arr){ sort(arr, 0, arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/3914596929c8164017212731421bde1a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-25T09:24:18+08:00" />
<meta property="article:modified_time" content="2022-05-25T09:24:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JavaScript实现十大排序算法（图文详解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>冒泡排序</h3> 
<h4>排序的效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d2/04/zF5KVV0H_o.gif"></p> 
<h4>解法</h4> 
<blockquote> 
 <p>当前解法为升序</p> 
</blockquote> 
<p>冒泡排序的特点，是一个个数进行处理。第i个数，需要与后续的<code>len-i-1</code>个数进行逐个比较。</p> 
<p>为什么是 `len-i-1`个数？</p> 
<p>因为数组末尾的i个数，已经是排好序的，确认位置不变的了。</p> 
<p>为什么确认位置不变，因为它们固定下来之前，已经和前面的数字都一一比较过了。</p> 
<pre><code>function bubbleSort(arr){
	const len = arr.length;
	for(let i = 0; i &lt; len - 1; i++){
		for(let j = 0; j &lt; len - i - 1; j++){
			if(arr[j] &gt; arr[j+1]){
				const tmp = arr[j+1];
				arr[j+1] = arr[j];
				arr[j] = tmp;
			}
		}
	}

	return arr;
}
</code></pre> 
<h3>快速排序</h3> 
<h4>概要</h4> 
<p>快速排序，使用的是<strong>分治法</strong>的思想。<br> 通过选定一个数字作为比较值，将要排序其他数字，分为 <strong>&gt;比较值</strong> 和 <strong>&lt;比较值</strong>，两个部分。并不断重复这个步骤，直到只剩要排序的数字只有本身，则排序完成。</p> 
<h4>效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/da/7c/VLhr4mfq_o.png"></p> 
<h4>解法</h4> 
<pre><code>function quickSort(arr){

	sort(arr, 0, arr.length - 1);
	return arr;


	function sort(arr, low, high){
		if(low &gt;= high){
			return;
		}
	
		let i = low;
		let j = high;
		const x = arr[i]; // 取出比较值x，当前位置i空出，等待填入
		while(i &lt; j){
			// 从数组尾部，找出比x小的数字
			while(arr[j] &gt;= x &amp;&amp; i &lt; j){
				j--;
			}
			// 将空出的位置，填入当前值， 下标j位置空出
			// ps：比较值已经缓存在变量x中
			if(i &lt; j){
				arr[i] = arr[j]
				i++;
			}

			// 从数组头部，找出比x大的数字
			while(arr[i] &lt;= x &amp;&amp; i &lt; j){
				i++;
			}
			// 将数字填入下标j中，下标i位置突出
			if(i &lt; j){
				arr[j] = arr[i]
				j--;
			}
			// 一直循环到左右指针i、j相遇，
			// 相遇时，i==j, 所以下标i位置是空出的
		}

		arr[i] = x; // 将空出的位置，填入缓存的数字x，一轮排序完成

		// 分别对剩下的两个区间进行递归排序
		sort(arr, low, i - 1);
		sort(arr, i+1, high);
	}
}
</code></pre> 
<h3>希尔排序</h3> 
<h4>概要</h4> 
<p>希尔排序是一种<strong>插入排序</strong>的算法，它是对简单的插入排序进行改进后，更高效的版本。由希尔（Donald Shell）于1959年提出。<br> 特点是利用<strong>增量</strong>，将数组分成一组组子序列，然后对子序列进行插入排序。<br> 由于增量是从大到小，逐次递减，所以也称为<strong>缩小增量排序</strong>。</p> 
<h4>效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1a/a3/g5iqrl7T_o.png"></p> 
<h4>解法</h4> 
<blockquote> 
 <p><strong>注意点</strong><br> 插入排序时，并不是一个分组内的数字一次性用插入排序完成，而是每个分组交叉进行。</p> 
</blockquote> 
<p>执行插入时，使用交换法</p> 
<pre><code>function shellSort(arr){
	// 分组规则 gap/2 递减
	for(let gap = Math.floor(arr.length/2); gap &gt; 0; gap = Math.floor(gap/2)){
		for(let i = gap; i &lt; arr.length; i++){
			let j = i;
			// 分组内数字，执行插入排序，
			// 当下标大的数字，小于 下标小的数字，进行交互
			// 这里注意，分组内的数字，并不是一次性比较完，需要i逐步递增，囊括下个分组内数字
			while(j - gap &gt;= 0 &amp;&amp; arr[j] &lt; arr[j - gap]){
				swap(j, j-gap);
				j = j - gap;
			}
		}
	}

	return arr;

	function swap(a, b){
		const tmp = arr[a];
		arr[a] = arr[b];
		arr[b] = tmp;
	}
}
</code></pre> 
<p>执行插入时，使用移动法</p> 
<pre><code>function shellSort(arr){

	for(let gap = Math.floor(arr.length/2); gap &gt; 0; gap = Math.floor(gap/2)){
		for(let i = gap; i &lt; arr.length; i++){
			let j = i;
			const x = arr[j]; // 缓存数字，空出位置

			while(j - gap &gt;= 0 &amp;&amp; x &lt; arr[j-gap]){
				arr[j] = arr[j - gap]; // 将符合条件的数字，填入空出的位置
				j = j - gap;
			}
			arr[j] = x; // 最后，将缓存的数字，填入空出的位置
		}
	}

	return arr;
}
</code></pre> 
<h3>选择排序</h3> 
<h4>排序的效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/71/87/Jp3WO9fI_o.gif"></p> 
<h4>解法</h4> 
<blockquote> 
 <p>当前解法为升序</p> 
</blockquote> 
<pre><code>function selectionSort(arr){
	const len = arr.length;

	for(let i = 0; i &lt; len-1; i++){
		let minIndex = i;
		for(let j = i+1; j &lt; len; j++){
			if(arr[j] &lt; arr[minIndex]){
				minIndex = j; // 保存最小数的下标
			}
		}

		const tmp = arr[i];
		arr[i] = arr[minIndex];
		arr[minIndex] = tmp;
	}

	return arr;
}
</code></pre> 
<h3>归并排序</h3> 
<h4>概要</h4> 
<p>归并排序，利用<strong>分治</strong>思想，将大的数组，分解为小数组，直至单个元素。然后，使用<strong>选择排序</strong>的方式，对分拆的小数组，进行回溯，并有序合并，直至合并为一个大的数组。</p> 
<h4>效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3b/75/Ca5o9ivt_o.png"></p> 
<h4>小数组合并的过程</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/32/ff/mEGxHM9K_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3b/e1/rI7Nl4x9_o.png"></p> 
<h4>解法</h4> 
<pre><code>
function mergeSort(arr){

	return sort(arr, 0, arr.length - 1); // 注意右区间是arr.length - 1

	// sort方法，进行递归
	function sort(arr, left, right){
		
		// 当left !== right时，证明还没分拆到最小元素
		if(left &lt; right){
			// 取中间值，分拆为两个小的数组
			const mid = Math.floor((left+right) / 2);
			const leftArr = sort(arr, left, mid);
			const rightArr = sort(arr, mid+1, right);
			// 递归合并
			return merge(leftArr, rightArr)
		}

		// left == right, 已经是最小元素，直接返回即可
		return left &gt;= 0 ? [arr[left]] : [];
	}

	// 合并两个有序数组
	function merge(leftArr, rightArr){
		let left = 0;
		let right = 0;
		const tmp = [];

		// 使用双指针，对两个数组进行扫描
		while(left &lt; leftArr.length &amp;&amp; right &lt; rightArr.length){
			if(leftArr[left] &lt;= rightArr[right]){
				tmp.push(leftArr[left++]);
			}else{
				tmp.push(rightArr[right++]);
			}
		}

		// 合并剩下的内容
		if(left &lt; leftArr.length){
			while(left &lt; leftArr.length){
				tmp.push(leftArr[left++]);
			}
		}

		if(right &lt; rightArr.length){
			while(right &lt; rightArr.length){
				tmp.push(rightArr[right++]);
			}
		}

		return tmp;
	}

}
</code></pre> 
<h3>插入排序</h3> 
<h4>排序的效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d2/fb/cj8cXm4w_o.gif"></p> 
<h4>解法</h4> 
<blockquote> 
 <p>当前解法为升序</p> 
</blockquote> 
<pre><code>function insertionSort(arr){
	const len = arr.length;

    // 注意，i 从 1 开始
	for(let i = 1; i &lt; len; i++){
		let preIndex = i - 1;
		let current = arr[i];

        // 位置i之前，是已排好序的数字，while的作用是找到一个坑位，给当前数字current插入
		while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current){
			arr[preIndex+1] = arr[preIndex]; // 对大于current的值，往后移一位，给current的插入腾出位置
			preIndex--;
		}
		arr[preIndex+1] = current;
	}

	return arr;
}
</code></pre> 
<h3>堆排序</h3> 
<h4>概要</h4> 
<blockquote> 
 <p>堆的表示形式</p> 
</blockquote> 
<p><strong>逻辑结构</strong>的表示如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f2/74/GojVvd4l_o.png"></p> 
<p>在<strong>物理数据层</strong>的表示如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7d/5d/hOyMqtBk_o.png"></p> 
<p>堆排序，是<strong>选择排序</strong>的优化版本，利用数据结构——树，对数据进行管理。</p> 
<p>以大顶堆为例:</p> 
<ol><li>通过构建大顶堆</li><li>将堆顶的最大数拿出，与堆底的叶子节点进行交换</li><li>接着，树剪掉最大数的叶子</li><li>再对堆进行调整，重新变成大顶堆</li><li>返回步骤2，以此循环，直至取出所有数</li></ol> 
<h4>效果图</h4> 
<blockquote> 
 <p>在实现代码时，构建大顶堆时，先保证左右子树的有序，再逐步扩大到整棵树。</p> 
</blockquote> 
<p>构建大顶堆</p> 
<p>从第一个非叶子节点开始，调整它所在的子树</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e0/c8/ySmSqBIB_o.png"></p> 
<p>调整下标1节点的子树后，向上继续调整它的父节点（下标0）所在的子树</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6b/2f/7g0IuNiD_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/43/23/gtxNXyJP_o.png"></p> 
<p>最后，完成整个树的调整，构建好大顶堆。</p> 
<p>逐个抽出堆顶最大值</p> 
<p>堆顶数字与最末尾的叶子数字交换，抽出堆顶数字9。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/84/5e/LTEPDKGQ_o.png"></p> 
<p>此时，数字9位置固定下来，树剪掉9所在的叶子。然后，重新构建大顶堆。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9c/46/DUgbQVbx_o.png"></p> 
<p>大顶堆构建好后，继续抽出堆顶数字8，然后再次重新构建大顶堆。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d6/40/E9zewGde_o.png"></p> 
<p>最后，所有节点抽出完成，代表排序已完成。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cb/9a/Zrh9Bfie_o.png"></p> 
<h4>解法</h4> 
<blockquote> 
 <p>以大顶堆为例，对数组进行升序排序</p> 
</blockquote> 
<blockquote> 
 <p><strong>注意点</strong><br> 树的最后一个非叶子节点：<code>(arr.length / 2) - 1</code><br> 非叶子节点<code>i</code>的左叶子节点： <code>i*2+1</code><br> 非叶子节点<code>i</code>的右叶子节点： <code>i*2+2</code></p> 
</blockquote> 
<pre><code>function heapSort(arr){

	// 初次构建大顶堆
	for(let i = Math.floor(arr.length/2) - 1; i &gt;= 0; i--){
		// 开始的第一个节点是 树的最后一个非叶子节点
		// 从构建子树开始，逐步调整
		buildHeap(arr, i, arr.length);
	}

	// 逐个抽出堆顶最大值
	for(let j = arr.length -1 ; j &gt; 0; j--){
		swap(arr, 0, j); // 抽出堆顶（下标0）的值，与最后的叶子节点进行交换
		// 重新构建大顶堆
		// 由于上一步的堆顶最大值已经交换到数组的末尾，所以，它的位置固定下来
		// 剩下要比较的数组，长度是j,所以这里的值length == j
		buildHeap(arr, 0, j); 
	}

	return arr;

	
	// 构建大顶堆
	function buildHeap(arr, i, length){
		let tmp = arr[i]; 
		
		for(let k = 2*i+1; k &lt; length; k = 2*k+1){
			// 先判断左右叶子节点，哪个比较大
			if(k+1 &lt; length &amp;&amp; arr[k+1] &gt; arr[k]){
				k++;
			}
			// 将最大的叶子节点，与当前的值进行比较
			if(arr[k] &gt; tmp){
				// k节点大于i节点的值，需要交换
				arr[i] = arr[k]; // 将k节点的值与i节点的值交换
				i = k; // 注意：交换后，当前值tmp的下标是k，所以需要更新
			}else{
				// 如果tmp大于左右子节点，则它们的子树也不用判断，都是小于当前值
				break;
			}
			
		}

		// i是交换后的下标，更新为tmp
		arr[i] = tmp;
	}


	// 交换值
	function swap(arr, i, j){
		const tmp = arr[i];
		arr[i] = arr[j];
		arr[j] = tmp;
	}
}
</code></pre> 
<h3>计数排序</h3> 
<h4>概要</h4> 
<p>计数排序的要点，是开辟一块连续格子组成的空间，给数据进行存储。<br> 将数组中的数字，依次读取，存入其值对应的下标中。<br> 储存完成后，再按照空间的顺序，依次读取每个格子的数据，输出即可<a class="link-info" href="http://m.godelo.cn" rel="nofollow" title="。">。</a></p> 
<p>所以，<strong>计数排序要求排序的数据，必须是有范围的整数</strong>。</p> 
<h4>效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/31/ea/Kk9WqVfB_o.png"></p> 
<h4>解法</h4> 
<pre><code>function countingSort(arr){
    let maxValue = Number.MIN_VALUE;
    let minValue = Number.MAX_VALUE;
    let offset = 0; // 位移，用于处理负数
    const result = [];

    // 取出数组的最大值, 最小值
    arr.forEach(num =&gt; {
        maxValue = num &gt; maxValue ? num : maxValue;
        minValue = num &gt; minValue ? minValue : num;
    });

    if(minValue &lt; 0){
        offset = -minValue;
    }

    const bucket = new Array(maxValue+offset+1).fill(0); // 初始化连续的格子

    // 将数组中的每个数字，根据值放入对应的下标中，
    // `bucket[num] == n`格子的意义：存在n个数字，值为num
    arr.forEach(num =&gt; {
        bucket[num+offset]++;
    });

    // 读取格子中的数
    bucket.forEach((store, index) =&gt; {
        while(store--){
            result.push(index - offset);
        }
    });

    return result;

}
</code></pre> 
<h3>桶排序</h3> 
<h4>概要</h4> 
<p>桶排序是计数排序的优化版，原理都是一样的：分治法+空间换时间。<br> 将数组进行分组，减少排序的数量，再对子数组进行排序，最后合并即可得到结果。</p> 
<h4>效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/68/fd/rhCafSIn_o.png"></p> 
<h4>解法</h4> 
<blockquote> 
 <p>对桶内数字的排序，本文采用的是<strong>桶排序</strong>递归。其实它的本质是退化到<strong>计数排序</strong>。</p> 
</blockquote> 
<pre><code>function bucketSort(arr, bucketSize = 10){
	// bucketSize 每个桶可以存放的数字区间(0, 9]

	if(arr.length &lt;= 1){
		return arr;
	}
	
	let maxValue = arr[0];
	let minValue = arr[0];
	let result = [];

	// 取出数组的最大值, 最小值
	arr.forEach(num =&gt; {
		maxValue = num &gt; maxValue ? num : maxValue;
		minValue = num &gt; minValue ? minValue : num;
	});

	// 初始化桶的数量
	const bucketCount = Math.floor((maxValue - minValue)/bucketSize) + 1; // 桶的数量
	// 初始化桶的容器
	// 注意这里的js语法，不能直接fill([])，因为生成的二维下标数组，是同一个地址
	const buckets = new Array(bucketCount).fill(0).map(() =&gt; []);

	// 将数字按照映射的规则，放入桶中
	arr.forEach(num =&gt; {
		const bucketIndex = Math.floor((num - minValue)/bucketSize);
		buckets[bucketIndex].push(num);
	});

	// 遍历每个桶内存储的数字
	buckets.forEach(store =&gt; {
		// 桶内只有1个数字或者空桶，或者都是重复数字，则直接合并到结果中
		if(store.length &lt;= 1 || bucketSize == 1){
			result = result.concat(store);
			return;
		}

		// 递归，将桶内的数字，再进行一次划分到不同的桶中
		const subSize = Math.floor(bucketSize/2); // 减少桶内的数字区间，但必须是最少为1
		const tmp = bucketSort(store, subSize &lt;= 1 ? 1: subSize);
		result = result.concat(tmp);
	});

	return result;
}
</code></pre> 
<h3>基数排序</h3> 
<h4>概述</h4> 
<p>基数排序，一般是从右到左，对进制位上的数字进行比较，存入[0, 9]的10个桶中，进行排序。<br> 从低位开始比较，逐位进行比较，让每个进制位（个、十、百、千、万）上的数字，都能放入对应的桶中，形成局部有序。</p> 
<p>为什么10个桶？</p> 
<p>因为十进制数，是由0-9数字组成，对应的进制位上的数字，都会落在这个区间内，所以是10个桶。</p> 
<p>基数排序有两种方式：</p> 
<ul><li> <p>MSD 从高位开始进行排序</p> </li><li> <p>LSD 从低位开始进行排序</p> </li></ul> 
<h4>效果图</h4> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/0b/JwRUGopq_o.png"></p> 
<h4>解法</h4> 
<blockquote> 
 <p>当前解法，只适用正整数的场景。<br> 负数场景，需要加上偏移量解决。可参考 <a href="https://fe-interview.wangxiaokai.vip/writing/counting-sort" rel="nofollow" title="计数排序">计数排序</a> 的解法。</p> 
</blockquote> 
<pre><code>function radixSort(arr){
	let maxNum = arr[0];

	// 求出最大的数字，用于确定最大进制位
	arr.forEach(num =&gt; {
		if(num &gt; maxNum){
			maxNum = num;
		}
	});

	// 获取最大数字有几位
	let maxDigitNum = 0;
	while(maxNum &gt; 0){
		maxNum = Math.floor(maxNum / 10);
		maxDigitNum++;
	}

	// 对每个进制位上的数进行排序
	for(let i = 0; i &lt; maxDigitNum; i++){
		let buckets = new Array(10).fill(0).map(() =&gt; []); // 初始化10个桶
		for(let k = 0; k &lt; arr.length; k++){
			const bucketIndex = getDigitNum(arr[k], i); // 获取当前进制位上的数字
			buckets[bucketIndex].push(arr[k]); // 排序的数字放入对应桶中
		}
		// 所有数字放入桶中后，现从0-9的顺序将桶中的数字取出
		const res = [];
		buckets.forEach(store =&gt; {
			store.forEach(num =&gt; {
				res.push(num); // 注意这里，先存入桶中的数字，先取出，这样才能保持局部有序
			})
		});
		
		arr = res;
	}


	return arr;


	/** 
		求出数字每个进制位上的数字，只支持正整数
		@param num 整数
		@param digit 位数，从0开始
	*/
	function getDigitNum(num, digit){
		return Math.floor(num / Math.pow(10, digit) % 10)
	}
}
</code></pre> 
<h3>算法复杂度</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/46/07/SIvt1eVF_o.png"></p> 
<h3><br> 作者：我是leon</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65c697585d054779dabd117fd96efc7a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac Androidstudio点击打开跳一下就消失</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7cb54de1a2229a9be08d560e84522267/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">docker的基础用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>