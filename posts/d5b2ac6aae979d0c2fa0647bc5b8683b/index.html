<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;初阶 — vector - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;初阶 — vector" />
<meta property="og:description" content="目录
一、vector的介绍及使用
1. vector的介绍
2. vector的使用
2.1 vector的定义
2.2 vector iterator 的使用 2.3 vector 空间增长问题 2.3 vector 增删查改
二、vector（简易）的模拟实现以及会出现的问题
1. vector的核心框架
2. 构造函数，push_back和reserve
3.迭代器和下标访问[ ]
4. pop_back和empty
5. resize
6. insert
7. erase
8. swap 和析构函数
9. 构造函数多种使用场景
10. 拷贝构造和赋值重载
一、vector的介绍及使用 1. vector的介绍 1. vector是表示可变大小数组的序列容器。
2. 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自 动处理。
3. 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是 一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大 小。
4. vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存 储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是 对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。
5. 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增 长。
6. 与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末 尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list 统一的迭代器和引用更好。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d5b2ac6aae979d0c2fa0647bc5b8683b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-03T11:33:33+08:00" />
<meta property="article:modified_time" content="2023-06-03T11:33:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;初阶 — vector</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="240" src="https://images2.imgbox.com/85/16/0pVk0Wcv_o.jpg" width="240"></p> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81vector%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81vector%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8" rel="nofollow">一、vector的介绍及使用</a></p> 
<p id="%C2%A0%C2%A01.%C2%A0vector%E7%9A%84%E4%BB%8B%E7%BB%8D-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A01.%C2%A0vector%E7%9A%84%E4%BB%8B%E7%BB%8D" rel="nofollow">  1. vector的介绍</a></p> 
<p id="%C2%A02.%C2%A0vector%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A02.%C2%A0vector%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow"> 2. vector的使用</a></p> 
<p id="%C2%A0%20%C2%A02.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A02.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89" rel="nofollow">   2.1 vector的定义</a></p> 
<p id="%C2%A0%20%C2%A02.2%20vector%20iterator%20%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A02.2%20vector%20iterator%20%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0" rel="nofollow">   2.2 vector iterator 的使用 </a></p> 
<p id="%C2%A0%20%C2%A02.3%20vector%20%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98%C2%A0-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A02.3%20vector%20%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98%C2%A0" rel="nofollow">   2.3 vector 空间增长问题 </a></p> 
<p id="%C2%A0%20%C2%A02.3%20vector%20%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9-toc" style="margin-left:80px;"><a href="#%C2%A0%20%C2%A02.3%20vector%20%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9" rel="nofollow">   2.3 vector 增删查改</a></p> 
<p id="%E4%BA%8C%E3%80%81vector%EF%BC%88%E7%AE%80%E6%98%93%EF%BC%89%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81vector%EF%BC%88%E7%AE%80%E6%98%93%EF%BC%89%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">二、vector（简易）的模拟实现以及会出现的问题</a></p> 
<p id="%C2%A0%201.%20vector%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6-toc" style="margin-left:40px;"><a href="#%C2%A0%201.%20vector%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6" rel="nofollow">  1. vector的核心框架</a></p> 
<p id="%C2%A0%202.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8Cpush_back%E5%92%8Creserve-toc" style="margin-left:40px;"><a href="#%C2%A0%202.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8Cpush_back%E5%92%8Creserve" rel="nofollow">  2. 构造函数，push_back和reserve</a></p> 
<p id="%C2%A0%203.%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%5B%20%5D-toc" style="margin-left:40px;"><a href="#%C2%A0%203.%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%5B%20%5D" rel="nofollow">  3.迭代器和下标访问[ ]</a></p> 
<p id="4.%20pop_back%E5%92%8Cempty-toc" style="margin-left:40px;"><a href="#4.%20pop_back%E5%92%8Cempty" rel="nofollow">4. pop_back和empty</a></p> 
<p id="%C2%A0%20%C2%A05.%20resize-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A05.%20resize" rel="nofollow">   5. resize</a></p> 
<p id="%C2%A0%20%C2%A06.%20insert-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A06.%20insert" rel="nofollow">   6. insert</a></p> 
<p id="%C2%A0%20%C2%A07.%20erase-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A07.%20erase" rel="nofollow">   7. erase</a></p> 
<p id="%C2%A0%20%C2%A08.%20swap%20%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%20%C2%A08.%20swap%20%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0" rel="nofollow">   8. swap 和析构函数</a></p> 
<p id="%C2%A0%209.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A4%9A%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%C2%A0%209.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A4%9A%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">  9. 构造函数多种使用场景</a></p> 
<p id="%C2%A0%2010.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD-toc" style="margin-left:40px;"><a href="#%C2%A0%2010.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD" rel="nofollow">  10. 拷贝构造和赋值重载</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81vector%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8">一、vector的介绍及使用</h2> 
<h3 id="%C2%A0%C2%A01.%C2%A0vector%E7%9A%84%E4%BB%8B%E7%BB%8D">  1. vector的介绍</h3> 
<blockquote> 
 <p>1. vector是表示可变大小数组的序列容器。</p> 
 <p>2. 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自 动处理。</p> 
 <p>3. 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是 一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大 小。</p> 
 <p>4. vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存 储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是 对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。</p> 
 <p>5. 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增 长。</p> 
 <p>6. 与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末 尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list 统一的迭代器和引用更好。</p> 
</blockquote> 
<h3 id="%C2%A02.%C2%A0vector%E7%9A%84%E4%BD%BF%E7%94%A8"> 2. vector的使用</h3> 
<p>vector学习时一定要学会查看文档：vector的文档介绍，vector在实际中非常的重要，在实际中我们熟悉常 见的接口就可以，下面列出了哪些接口是要重点掌握的。</p> 
<p></p> 
<h4 id="%C2%A0%20%C2%A02.1%20vector%E7%9A%84%E5%AE%9A%E4%B9%89">   2.1 vector的定义</h4> 
<p><img alt="" height="455" src="https://images2.imgbox.com/55/f1/7wuNx2tm_o.png" width="1200"></p> 
<h4 id="%C2%A0%20%C2%A02.2%20vector%20iterator%20%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0">   2.2 vector iterator 的使用 </h4> 
<p><img alt="" height="290" src="https://images2.imgbox.com/f9/08/ckpnjtl0_o.png" width="1200"></p> 
<h4 id="%C2%A0%20%C2%A02.3%20vector%20%E7%A9%BA%E9%97%B4%E5%A2%9E%E9%95%BF%E9%97%AE%E9%A2%98%C2%A0">   2.3 vector 空间增长问题 </h4> 
<p><img alt="" height="405" src="https://images2.imgbox.com/29/64/bpEGm060_o.png" width="1200"></p> 
<h4 id="%C2%A0%20%C2%A02.3%20vector%20%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9">   2.3 vector 增删查改</h4> 
<p><img alt="" height="544" src="https://images2.imgbox.com/86/cf/pM7BK3c4_o.png" width="1200"></p> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81vector%EF%BC%88%E7%AE%80%E6%98%93%EF%BC%89%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98">二、vector（简易）的模拟实现以及会出现的问题</h2> 
<h3 id="%C2%A0%201.%20vector%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6">  1. vector的核心框架</h3> 
<p>        这是根据<strong>STL 源码</strong>经过筛减后得到的核心框架，是不是和string很像。</p> 
<pre><code class="language-cpp">template&lt;class T&gt;
    class vector {
    public:
        typedef T* iterator;
        typedef const T* const_iterator;

        //成员函数

    private:
        iterator _start;
        iterator _finish;
        iterator _end_of_storage;
    };
}
</code></pre> 
<p> vector的底层和string的底层非常相似，都是指针指向一个动态开辟的数组，只不过string的成员是用size和capacity标识容量，而vector的成员是用finish指向size的位置，end_of_storage指向capacity的位置，虽然vector看起来更复杂一些，但本质上是一样的，string用的是下标，vector用的是指针。</p> 
<p><img alt="" height="1020" src="https://images2.imgbox.com/c6/06/aaH01DTw_o.png" width="1200"></p> 
<p></p> 
<h3 id="%C2%A0%202.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8Cpush_back%E5%92%8Creserve">  2. 构造函数，push_back和reserve</h3> 
<p>        还是根据需求写成员函数，有了string的基础写vector还是比较轻松的。（可以参考一下）</p> 
<blockquote> 
 <p><a href="https://blog.csdn.net/weixin_68993573/article/details/127764918?spm=1001.2014.3001.5501" title="(11条消息) C++初阶 — string_晚风不及你的笑427的博客-CSDN博客">(11条消息) C++初阶 — string_晚风不及你的笑427的博客-CSDN博客</a></p> 
</blockquote> 
<p>        无参的构造函数只需要用初始化列表将三个成员指针初始化为空即可。为了方便后续的使用，先把size和capacity实现出来，这两个用指针减指针就可以得到。而后是就插入数据，插入数据跟string一样，判断是否扩容，然后插入数据。正好用到reserve，就把reserve写了，这里reserve稍微有点复杂，因为它涉及到对自定义类型浅拷贝的问题。这里的扩容是重新开空间，有数据就把数据拷贝过去，如果是内置类型，那么memcpy可以正常使用。如果我们是自定义类型，比如vector&lt;vector&lt;int&gt;&gt;，只会让tmp里的指针指向start指向的空间，一旦释放start指向的空间，那么tmp里的指针就成野指针了。但是下面的写法还需要赋值重载函数实现了以后才能使用，所以暂时先用memcpy把一些很简单的成员函数写了，后面在考虑这个问题。</p> 
<pre><code class="language-cpp">//构造函数
		vector()
			:_start(nullptr)
			, _finish(nullptr)
			, _endOfStorage(nullptr)
		{}
//容量
		size_t size()const
		{
			return _finish - _start;
		}
		size_t capacity()const
		{
			return _endOfStorage - _start;
		}
//插入数据
		void push_back(const T&amp; x)
		{
            //判断是否扩容
			if (_finish == _endOfStorage)
			{
				size_t newcapacity = capacity() == 0 ? 4 : capacity() * 2;
				reserve(newcapacity);
			}
			*_finish = x;
			++_finish;
		}
//改变容量，只扩容，不缩容
	void reserve(size_t n)
		{
			if (n &gt; capacity())
			{
				size_t oldsize = size();//记录原来的size，避免释放掉空间以后，finish出问题
				iterator tmp = new T[n];

				if (_start)
				{
					//memcpy(tmp, _start, sizeof(T) * size());这种写法会发生浅拷贝问题
					for (size_t i = 0; i &lt; oldsize; ++i)
					{
						tmp[i] = _start[i];
					}
				}

				delete[] _start;
				_start = tmp;
				_finish = _start + oldsize;
				_endOfStorage = _start + n;
			}
		}
</code></pre> 
<h3 id="%C2%A0%203.%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%5B%20%5D">  3.迭代器和下标访问[ ]</h3> 
<p>        迭代器这里参考string的实现方法，begin就是数组元素的第一个位置，end就是数组元素的下一个位置。同时实现了const版本，便于后续的使用。下标访问这里和库里的一致，加一个断言，让pos必须在有效数值区间，同时重载一个只读的版本，有const类型的对象可以直接调用。</p> 
<pre><code class="language-cpp">//迭代器
        iterator begin()
		{
			return _start;
		}
		iterator end()
		{
			return _finish;
		}
		const_iterator begin()const
		{
			return _start;
		}
		const_iterator end()const
		{
			return _finish;
		}
//下标访问
        T&amp; operator[](size_t pos)
		{
			assert(pos &lt; size());
			return _start[pos];
		}
		const T&amp; operator[](size_t pos)const
		{
			assert(pos &lt; size());
			return _start[pos];
		}</code></pre> 
<h3 id="4.%20pop_back%E5%92%8Cempty">4. pop_back和empty</h3> 
<p>        只要finish == start就认为数组是空的，从尾部删除数据也很简单，finish指针前移一位即可。</p> 
<pre><code class="language-cpp">//删除数据
        void pop_back()
		{
			assert(!empty());
			--_finish;
		}
//判断数组是否为空
        bool empty()const
		{
			return _finish == _start;
		}</code></pre> 
<p><strong>操作演示：</strong></p> 
<p><img alt="" height="1065" src="https://images2.imgbox.com/11/e4/UqZ2Cink_o.png" width="983"></p> 
<h3 id="%C2%A0%20%C2%A05.%20resize">   5. resize</h3> 
<p>        这里resize和string的resize很相似，也是三种情况，1. size &lt; n &lt; capacity，填充数据到到n的位置；2. capacity &lt; n ,扩容并且填充数据，3. n &lt; size ,删除数据剩n个。</p> 
<pre><code class="language-cpp">//改变vector的size，如果不传参数会用匿名对象填充
        void resize(size_t n, const T&amp; value = T())
		{
			if (n &gt; capacity())
			{
				reserve(n);
			}
			if (n &gt; size())
			{
				while (_finish &lt; _start + n)
				{
					*_finish = value;
					++_finish;
				}
			}
			else if (n &lt; size())
			{
				_finish = _start + n;
			}
		}</code></pre> 
<p><strong>操作演示：</strong></p> 
<p><img alt="" height="763" src="https://images2.imgbox.com/59/be/PqGjKhsA_o.png" width="991"></p> 
<h3 id="%C2%A0%20%C2%A06.%20insert">   6. insert</h3> 
<p>        这里需要注意pos的位置要合法，也就是说pos位置要在有效数值区间，加个断言防止出现问题。插入数据有可能会导致空间存满，就会出现扩容需求。扩容这里需要特别注意，会出现迭代器失效问题，因为自己写的扩容是异地扩容，也就是说原本的空间会释放掉，再找块新空间给start，这时pos还指向原来的空间，那么到挪动数据的时候，while循环里的判断条件会出现问题，不是你想要的结果。所以在发生扩容的时候，即使的对pos也进行更新，这样就不会出现迭代器失效的问题了。还有就是这里为什么会 return pos，因为是传值传参，修改内部的pos，并不会对外部的pos进行修改，所以发生扩容的时候内部的pos被修改了，但外部的pos并没有被修改，如果直接在外部解引用访问pos，会发生野指针问题。上述问题只有扩容才会发生。</p> 
<pre><code class="language-cpp">//pos位置插入数据
        iterator insert(iterator pos, const T&amp; x)
		{
			assert(pos &gt;= _start &amp;&amp; pos &lt; _finish);
			if (_finish == _endOfStorage)
			{
				size_t len = pos - _start;
				size_t newcapacity = capacity() == 0 ? 4 : capacity() * 2;
				reserve(newcapacity);
				// 扩容会导致pos迭代器失效，需要更新处理一下
				pos = _start + len;
			}
			//挪动数据
			iterator end = _finish - 1;
			while (pos &lt;= end)
			{
				*(end + 1) = *end;
				--end;
			}
			*pos = x;
			++_finish;
			return pos;
		}</code></pre> 
<p> <strong>操作演示：</strong></p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/42/1a/G7gv9hq6_o.png" width="890"></p> 
<h3 id="%C2%A0%20%C2%A07.%20erase">   7. erase</h3> 
<p>        依旧是先保证pos位置在有效数值区间，删除数据就是把pos后面的数据覆盖上来，那么pos位置的数据就没有了，删除完成，返回删除之后pos的位置，避免因为边界问题引发对pos指针解引用后出现野指针问题。</p> 
<pre><code class="language-cpp">//删除pos位置数据
		iterator erase(iterator pos)
		{
			assert(pos &gt;= _start);
			assert( pos &lt; _finish);
			//挪动数据
			iterator begin = pos + 1;
			while (begin &lt; _finish)
			{
				*(begin - 1) = *begin;
				++begin;
			}
			--_finish;
			return pos;
		}</code></pre> 
<p> <strong>操作演示：</strong></p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/6c/cc/U9KLY7Tn_o.png" width="871"></p> 
<p><img alt="" height="855" src="https://images2.imgbox.com/bc/67/9CxAW1N1_o.png" width="1200"></p> 
<h3 id="%C2%A0%20%C2%A08.%20swap%20%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">   8. swap 和析构函数</h3> 
<p>        这两个函数比较简单，swap在string里有讲，这里就不过多赘述了，用的是现代写法。</p> 
<p>析构函数是释放空间，三个指针赋空。</p> 
<pre><code class="language-cpp">//交换函数
		void swap(vector&lt;T&gt;&amp; v)
		{
			std::swap(_start, v._start);
			std::swap(_finish, v._finish);
			std::swap(_endOfStorage, v._endOfStorage);
		}
//析构函数
        ~vector()
		{
			delete[] _start;
			_start = _finish = _endOfStorage = nullptr;
		}
</code></pre> 
<h3 id="%C2%A0%209.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%A4%9A%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">  9. 构造函数多种使用场景</h3> 
<p>        这里我就直接复用其他函数，这里多写了一个int版本，避免用int类型初始化时，编译器去调用模板。可能会有人问为什么编译器会调用模板初始化？因为两个都是int类型贴合模板，用size_t还要隐式类型转换。</p> 
<pre><code class="language-cpp">//v(10,1)
		vector(int n, const T&amp; value = T())
			:_start(nullptr)
			, _finish(nullptr)
			, _endOfStorage(nullptr)
		{
			reserve(n);
			for (int i = 0;i &lt; n;++i)
			{
				push_back(value);
			}
		}
		vector(size_t n, const T&amp; value = T())
			:_start(nullptr)
			, _finish(nullptr)
			, _endOfStorage(nullptr)
		{
			reserve(n);
			for (size_t i = 0; i &lt; n; ++i)
			{
				push_back(value);
			}
		}
		//模板 用迭代器构造
		template&lt;class InputIterator&gt;
		vector(InputIterator first, InputIterator last)
			:_start(nullptr)
			, _finish(nullptr)
			, _endOfStorage(nullptr)
		{
			while (first != last)
			{
				push_back(*first);
				++first;
			}
		}</code></pre> 
<h3 id="%C2%A0%2010.%20%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E8%B5%8B%E5%80%BC%E9%87%8D%E8%BD%BD">  10. 拷贝构造和赋值重载</h3> 
<p>        这里就直接用现代写法</p> 
<p>拷贝构造：用迭代器区间构造一个tmp，用自己写的交换函数将他们两的空间进行交换，结束后tmp自动析构。</p> 
<p>赋值重载：在传参的时候就已经拷贝构造了一个对象，直接进行交换。这里还有个问题每处理，但是不处理问题也不大，就是自己给自己赋值，虽然说代价（时间消耗）可能会比较大，但是结果没问题，而且也不会有人傻傻的总是自己给自己赋值。</p> 
<pre><code class="language-cpp">	    //v(v1) 拷贝构造
		vector(const vector&lt;T&gt;&amp; v)
			:_start(nullptr)
			, _finish(nullptr)
			, _endOfStorage(nullptr)
		{
			vector&lt;T&gt; tmp(v.begin(),v.end());
			swap(tmp);
			
		}
		//赋值重载
		vector&lt;T&gt;&amp; operator= (vector&lt;T&gt; v)
		{
			swap(v);
			return *this;
		}</code></pre> 
<p>  <strong>操作演示：</strong></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d0/04/ot0J7d5K_o.png" width="853"></p> 
<p>完整代码：<a class="has-card" href="https://gitee.com/auspicious-jing/job-library/blob/master/Vector/Vector/Vector.h" rel="nofollow" title="Vector/Vector/Vector.h · 晚风不及你的笑/作业库 - 码云 - 开源中国 (gitee.com)"><span class="link-card-box"><span class="link-title">Vector/Vector/Vector.h · 晚风不及你的笑/作业库 - 码云 - 开源中国 (gitee.com)</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/8e/b4/FQa0c0Ew_o.png">https://gitee.com/auspicious-jing/job-library/blob/master/Vector/Vector/Vector.h</span></span></a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/edbe69ade5803b7e29b993fbea63364f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OpenWrt 软路由解析公网IPV6域名访问家庭NAS的问题答疑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be0afb8c9c497026ffe356ea19b837e0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">umijs</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>