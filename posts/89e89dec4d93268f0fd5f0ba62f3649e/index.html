<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vuex：弄懂mapState、mapGetters、mapMutations、mapActions - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vuex：弄懂mapState、mapGetters、mapMutations、mapActions" />
<meta property="og:description" content="vuex进阶 一、state 1.1 引入vuex 以后，我们需要在state中定义变量，类似于vue中的data，通过state来存放状态
import Vue from &#39;vue&#39; import Vuex from &#39;vuex&#39; Vue.use(Vuex) export default new Vuex.Store({ state: { //存放状态 nickname:&#39;Simba&#39;, age:20, gender:&#39;男&#39; }, mutations: {}, actions: {}, modules: {} }) 注册两个组件分别引入到app.vue中
&lt;div id=&#34;app&#34;&gt; &lt;vabout&gt; &lt;/vabout&gt; &lt;vhome&gt; &lt;/vhome&gt; &lt;/div&gt; vhome组件内容
&lt;div class=&#34;home&#34;&gt;{{$store.state.nickname}}&lt;/div&gt; vabout组件内容
&lt;h1&gt;{{$store.state.nickname}}:{{$store.state.age}}&lt;/h1&gt; 如图，显示出显示出相应的内容，有了vuex，我们不必在考虑组件之间的传值，直接就可以通过$store来获取不同的数据，但是如果需要vuex中的多个数据的这时候，这样写就太啰嗦了，我们可以将它定义在computed中。
Props，methods,data和computed的初始化都是在beforeCreated和created之间完成的。
例：
&lt;template&gt; &lt;div class=&#34;home&#34;&gt; {{nickname}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &#39;home&#39;, computed:{ nickname(){ return this.$store.state.nickname } } } &lt;/script&gt; 这样引入就方便了很多。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/89e89dec4d93268f0fd5f0ba62f3649e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-17T23:06:08+08:00" />
<meta property="article:modified_time" content="2020-06-17T23:06:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vuex：弄懂mapState、mapGetters、mapMutations、mapActions</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>vuex进阶</strong></h3> 
<h3><strong>一、state</strong></h3> 
<p>1.1 引入vuex 以后，我们需要在state中定义变量，类似于vue中的data，通过state来存放状态</p> 
<pre><code>import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
export default new Vuex.Store({
  state: { //存放状态
    nickname:'Simba',
    age:20,
    gender:'男'
  },
  mutations: {},
  actions: {},
  modules: {}
})</code></pre> 
<p>注册两个组件分别引入到app.vue中</p> 
<pre><code>&lt;div id="app"&gt;
    &lt;vabout&gt; &lt;/vabout&gt;
    &lt;vhome&gt; &lt;/vhome&gt;
  &lt;/div&gt;</code></pre> 
<p>vhome组件内容</p> 
<pre><code>&lt;div class="home"&gt;{<!-- -->{$store.state.nickname}}&lt;/div&gt;</code></pre> 
<p>vabout组件内容</p> 
<pre><code>&lt;h1&gt;{<!-- -->{$store.state.nickname}}:{<!-- -->{$store.state.age}}&lt;/h1&gt;</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/01/e2/AOBLp1CI_o.png" width="534"></p> 
<p>如图，显示出显示出相应的内容，有了vuex，我们不必在考虑组件之间的传值，直接就可以通过$store来获取不同的数据，但是如果需要vuex中的多个数据的这时候，这样写就太啰嗦了，我们可以将它定义在computed中。</p> 
<p><code>Props</code>，<code>methods</code>,<code>data</code>和<code>computed</code>的初始化都是在<code>beforeCreated</code>和<code>created</code>之间完成的。</p> 
<p>例：</p> 
<pre><code>&lt;template&gt;
  &lt;div class="home"&gt;
    {<!-- -->{nickname}}
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name: 'home',
  computed:{
    nickname(){
      return this.$store.state.nickname
    }
  }
}
&lt;/script&gt;</code></pre> 
<p>这样引入就方便了很多。</p> 
<h3><strong>1.2 mapState 辅助函数</strong></h3> 
<p>1.1中的方法虽然引入的时候方便了，但是computed中定义的代码还是很多，而这时候vuex又给我们提供了更简便的方法mapState方法</p> 
<pre><code>import {mapState} from 'vuex'
export default {
  name: 'home',
  computed: mapState(['nickname','age','gender'])
}</code></pre> 
<p> </p> 
<pre><code>mapState(['nickname','age','gender']) //映射哪些字段就填入哪些字段</code></pre> 
<p>这一句代码就相当于下面这些</p> 
<pre><code>nickname(){return this.$store.state.nickname}
age(){return this.$store.state.age}
gender(){return this.$store.state.gender}</code></pre> 
<p><strong>记住：用mapState等这种辅助函数的时候，前面的方法名和获取的属性名是一致的。</strong></p> 
<p>如果我们需要自定义一个计算属性怎么办呢？怎么添加呢？</p> 
<p>毕竟现在已经成这样了 computed: mapState(['nickname','age','gender'])</p> 
<p>这时候我们就需要es6中的展开运算符：...</p> 
<pre><code>computed: {   //computed是不能传参数的
  value(){
   return this.val/7
},
  ...mapState(['nickname','age','gender'])
}</code></pre> 
<h3><strong>二、getters</strong></h3> 
<p>2.1 getters相当于vue中的计算属性，通过getters进一步处理，得到我们想要的值，而且允许传参，第一个参数就是state</p> 
<pre><code>import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
 
export default new Vuex.Store({
  state: { //存放状态
    nickname:'Simba',
    firstname:'张',
    lastname:'三丰',
    age:20,
    gender:'男',
    money:1000
  },
  getters:{
    realname(state){
      return state.firstname+state.lastname
    },
    money_us(state){
      return (state.money/7).toFixed(2)
    }
  },
  mutations: {},
  actions: {},
  modules: {}
})</code></pre> 
<p>vue部分</p> 
<pre><code>computed: {  //computed是不能传参数的
 valued(){
   return this.value/7
 },
 ...mapGetters(['realname','money_us'])
}</code></pre> 
<h3><strong>三、Mutation</strong></h3> 
<p>3.1 我们代码中定义的时候需要些mutations，它类似于vue中的methods，</p> 
<p>mutations需要通过<strong>commit</strong>来调用其里面的方法，它也可以传入参数，第一个参数是<strong>state</strong>，第二个参数是<strong>载荷</strong>（payLoad），也就是额外的参数</p> 
<p>代码如下</p> 
<pre><code>mutations: { //类似于methods
  addAge(state,payLoad){
     state.age+=payLoad.number
  }
}</code></pre> 
<p>template部分</p> 
<pre><code>&lt;div class="home"&gt;
   &lt;div&gt;&lt;button @click="test"&gt;测试&lt;/button&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre> 
<p>js部分</p> 
<pre><code>methods:{
 test(){
   this.$store.commit('addAge',{
     number:5
   })
 }
}</code></pre> 
<p>调用的时候第二个参数最好写成<strong>对象形式</strong>，这样我们就可以传递更多信息。</p> 
<p>但是，这样写还是会遇到同样的问题，就是如果需要操作多个数据，就会变的麻烦，这时候我们就需要<strong>mapMutations</strong>，通过它将方法映射过来</p> 
<h3><strong>3.2 mapMutations</strong></h3> 
<p>跟mapState、mapGetters一样</p> 
<pre><code>methods:{
 ...mapMutations(['addAge'])
}</code></pre> 
<p>mapMutations(['addAge'])这一句就相当于下面的代码</p> 
<pre><code>addAge(payLoad){
  this.$store.commit('addAge',payLoad)
}</code></pre> 
<p>参数我们可以在调用这个方法的时候写入</p> 
<pre><code>&lt;button @click="addAge({number:5})"&gt;测试&lt;/button&gt;</code></pre> 
<p>这时候一些杠精就要说了，我为什么要绕一圈，从mutations里面去改state呢？我能不能直接改state呢？</p> 
<p>比如这样：</p> 
<pre><code>addAge(){
 this.$store.state.age +=5;
}</code></pre> 
<p>实际看结果也可以，那我为什么从mutations里面中转一下呢？</p> 
<p>原因如下：</p> 
<p>① 在mutations中不仅仅能做赋值操作</p> 
<p>② 作者在mutations中做了类似埋点操作，如果从mutations中操作的话， 能被检测到，可以更方便用调试工具调试，调试工具可以检测到实时变化，而直接改变state中的属性，则无法<strong>实时监测</strong></p> 
<p>注意：mutations只能写同步方法，<strong>不能写异步</strong>，比如axios、setTimeout等，这些都不能写，<strong>mutations的主要作用就是为了修改state的</strong>。</p> 
<p>原因类似：如果在mutations中写异步，也能够调成功，但是由于是异步的，不能被调试工具追踪到，所有不推荐这样写，不利于调试,这是官方的约定。</p> 
<h3><strong>3.3 使用常量替代Mutation事件类型</strong></h3> 
<p>把原本的方法名称由字符串转变成常量</p> 
<p>代码如下：</p> 
<pre><code>import Vue from 'vue'
import Vuex from 'vuex'
export const ADD_AGE ='addAge' 
Vue.use(Vuex)
export default new Vuex.Store({
  state: { //存放状态
    nickname:'Simba',
    firstname:'张',
    lastname:'三丰',
    age:20,
    gender:'男',
    money:1000
  },
  getters:{ //类似于 computed
    realname:state =&gt;state.firstname+state.lastname,
    money_us(state){
      return (state.money/7).toFixed(2)
    }
  },
  mutations: { //类似于methods
     [ADD_AGE](state,payLoad){
         state.age+=payLoad.number
     }
  },
  actions: { },
  modules: {}
})
</code></pre> 
<p>将addAge方法名字定义为一个常量，当调用的时候直接引入</p> 
<pre><code>import {ADD_AGE} from '../store'
import {mapMutations} from 'vuex'
export default {
  methods:{
    ...mapMutations([ADD_AGE])
  }
}</code></pre> 
<p>这样写的好处：</p> 
<p>① 不容易写错，字符串容易写错，而且字符串写错以后不会报错位置，而用常量替代，如果写错，eslint可以提示错误位置</p> 
<p>用常量替代mutations的时候我我们可以新建一个文件（mutation_type.js）专门存储这些常量</p> 
<p>mutation_type.js部分</p> 
<pre><code>export default {
   ADD_AGE: ‘addAge’
}</code></pre> 
<p>然后再store/index.js中引入</p> 
<pre><code>import MUTATION_TYPES from ‘./mutation_type’（先引入）
export let MUTATION_TYPE=MUTATION_TYPES （再导出）</code></pre> 
<p>这个地方有一个<strong>坑</strong>，不要将引入和导出合并成一行代码：比如这样</p> 
<pre><code>export { foo, bar } from 'my_module';
// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };</code></pre> 
<p>需要注意的是，<strong>两者并不一样</strong>，写成一行以后，foo和bar实际上并没有被导入当前模块，只是相当于对外<strong>转发</strong>了这两个接口，<strong>导致当前模块不能直接使用</strong>foo和bar。</p> 
<p>vue部分</p> 
<pre><code>import {MUTATION_TYPE} from '../store'
methods:{
  ...mapMutations([MUTATION_TYPE.ADD_AGE])
}</code></pre> 
<p>总结一下：</p> 
<p>① 依赖state得到新的数据，用getters（跟computed一样，只读）</p> 
<p>② 修改state的属性值，就用mutations（同步操作）</p> 
<h3><strong>四、actions</strong></h3> 
<p>4.1 action类似于mutation</p> 
<p>区别：action可以提交mutation</p> 
<p>action也<strong>不要</strong>直接去操作state，而是<strong>去操作</strong>mutation</p> 
<p>action包含<strong>异步操作</strong>，类似于axios请求，可以都放在action中写</p> 
<p>action中的方法默认的就是异步，并且返回promise</p> 
<p>代码如下</p> 
<p>store部分</p> 
<pre><code>actions: {
  getUserInfo(){
    return {
      nickname:'Simba',
      age:20
    }
  }
}</code></pre> 
<p>在actions中定义一个方法：getUserInfo，并且返回一个对象</p> 
<p>vue部分</p> 
<pre><code>created(){
  var res = this.getUserInfo()
  console.log(res)
 
},
methods:{
  ...mapActions(['getUserInfo'])
}</code></pre> 
<p>在created中调用此方法，并将结果赋值给res，打印res，结果打印出Promise</p> 
<p><img alt="" src="https://images2.imgbox.com/37/c2/cZdUcAq5_o.png" width="553"></p> 
<p>这表明，在actions中的方法，默认就是异步的，通过then获取数据</p> 
<p>mapActions(['getUserInfo']) 相当于以下代码</p> 
<pre><code>getUserInfo(){
  return this.$store.dispatch(‘getUserInfo’)
}</code></pre> 
<p>在实际开发当中，state里面的属性值是空的，当登录以后，再进行获取对应的信息。</p> 
<p>登录以后，需要得到用户信息，那如何得到呢？</p> 
<p>首先进入页面的时候调用actions中的getUserInfo方法</p> 
<p>代码如下</p> 
<p>vue部分</p> 
<pre><code>created(){ this.getUserInfo()}
methods:{ ...mapActions([‘getUserInfo’])}</code></pre> 
<p>store部分</p> 
<p>首先要想得到数据，那就相当于给state赋值，那首先想到的就是mutations来操作state，但是请求的接口都是axios异步，所以就不能用mutations而是用actions，通过actions来操作mutations从而操作state</p> 
<pre><code>export default new Vuex.Store({
 state: { 
  nickname:‘’,
  age:0,
  gender:'',
  money:0
 },
 mutations: {
  setUerInfo(state,payLoad){
   state.nickname = payLoad.nickname
   state.age = payLoad.age
   state.gender = payLoad.gender
   state.money = payLoad.money
  }
},
actions: { //actions没有提供state当参数
 async getToken({commit}){
   var res = await axios.get('/token接口')
   commit('setToken',res)
 },
async getUserInfo(context){ 
//context可以理解为它是整个Store的对象.类似于this.$store，
他里面包含了state，getter，mutations，actions
  const res = await axios.get('/接口url')
  context.commit('setUerInfo',res) 
//相当于 this.$store.commit,第一个参数是方法名，第二个参数是要传入的数据
  context.dispatch('getToken') 
//actions也可以调用自己的其他方法
    },
  }
})</code></pre> 
<p>运行过程，调用getUserInfo方法以后，进入actions，然后通过commit调用setUserInfo，将res（用户信息）作为参数传入传入进去，并将相对应的属性值赋值给state，完成这一过程的操作。</p> 
<p>getUserInfo的参数也可以用解构，这样更方便</p> 
<pre><code>async getUserInfo({commit,dispatch}){ 
  const res = await axios.get('/接口url')
  commit('setUerInfo',res) 
  dispatch('getToken')
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58f206d9455dc92b753091484113a6f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">浅析 Semi-Supervised Learning 中的 consistency 问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92e7ff2c338808e1e327158a29f2826e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C11/C&#43;&#43;11内存模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>