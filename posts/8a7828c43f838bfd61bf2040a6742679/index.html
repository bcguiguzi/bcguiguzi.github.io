<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python&#43;Opencv寻找图像中最亮的区域 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python&#43;Opencv寻找图像中最亮的区域" />
<meta property="og:description" content="目录 一、场景需求解读二、算法原理简介三、算法代码实现四、代码运行步骤五、算法效果展示和分析六、思维扩展参考资料注意事项 一、场景需求解读 在有些现实场景中，我们需要去使用算法自动的寻找到图片中的最亮的区域，这个区域是我们感兴趣的目标所在的位置，比较典型的是一个应用是视网膜图像，图像中视网膜所在的位置比较亮，而其它地方比较暗，我们更加关注视网膜所在的区域，因而需要使用算法自动的寻找到这个区域，然后针对这个区域进行处理和分析。下图展示了一个样例图片。
二、算法原理简介 要检测出图像中最亮的区域，我们可以直接使用opencv中自带的函数(minVal, maxVal, minLoc, maxLoc) = cv2.minMaxLoc(gray)，该函数是用来获取图像中的最大值和最小值 所在的位置，而图像中的最大值其实就是最亮的像素点，图像中的最小值其实就是最暗的像素点，该函数的输入参数是一张灰度图像，该函数会返回最大值、最小值、最大值所在位置和最小值所在位置等，我们可以根据获得的位置信息绘制结果。
三、算法代码实现 # coding=utf-8 # 导入python包 import numpy as np import argparse import cv2 # 构建并解析参数 ap = argparse.ArgumentParser() ap.add_argument(&#34;-i&#34;, &#34;--image&#34;, help = &#34;path to the image file&#34;) ap.add_argument(&#34;-r&#34;, &#34;--radius&#34;, type = int, help = &#34;radius of Gaussian blur; must be odd&#34;) args = vars(ap.parse_args()) # 读取图片并将其转化为灰度图片 image = cv2.imread(args[&#34;image&#34;]) orig = image.copy() gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # 利用cv2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8a7828c43f838bfd61bf2040a6742679/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-15T21:10:31+08:00" />
<meta property="article:modified_time" content="2023-03-15T21:10:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python&#43;Opencv寻找图像中最亮的区域</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">一、场景需求解读</a></li><li><a href="#_5" rel="nofollow">二、算法原理简介</a></li><li><a href="#_8" rel="nofollow">三、算法代码实现</a></li><li><a href="#_45" rel="nofollow">四、代码运行步骤</a></li><li><a href="#_51" rel="nofollow">五、算法效果展示和分析</a></li><li><a href="#_55" rel="nofollow">六、思维扩展</a></li><li><a href="#_58" rel="nofollow">参考资料</a></li><li><a href="#_61" rel="nofollow">注意事项</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>一、场景需求解读</h3> 
<p>  在有些现实场景中，我们需要去使用算法自动的寻找到图片中的最亮的区域，这个区域是我们感兴趣的目标所在的位置，比较典型的是一个应用是<strong>视网膜图像</strong>，<strong>图像中视网膜所在的位置比较亮，而其它地方比较暗，我们更加关注视网膜所在的区域，因而需要使用算法自动的寻找到这个区域，然后针对这个区域进行处理和分析</strong>。下图展示了一个样例图片。<br> <img src="https://images2.imgbox.com/39/28/cnoxaHiB_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="_5"></a>二、算法原理简介</h3> 
<p>  要检测出图像中最亮的区域，我们可以直接使用opencv中自带的<strong>函数(minVal, maxVal, minLoc, maxLoc) = cv2.minMaxLoc(gray)，该函数是用来获取图像中的最大值和最小值 所在的位置</strong>，而图像中的最大值其实就是最亮的像素点，图像中的最小值其实就是最暗的像素点，该函数的输入参数是一张灰度图像，该函数会返回最大值、最小值、最大值所在位置和最小值所在位置等，我们可以根据获得的位置信息绘制结果。</p> 
<h3><a id="_8"></a>三、算法代码实现</h3> 
<pre><code># coding=utf-8
# 导入python包
import numpy as np
import argparse
import cv2

# 构建并解析参数
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", help = "path to the image file")
ap.add_argument("-r", "--radius", type = int, help = "radius of Gaussian blur; must be odd")
args = vars(ap.parse_args())

# 读取图片并将其转化为灰度图片
image = cv2.imread(args["image"])
orig = image.copy()
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# 利用cv2.minMaxLoc寻找到图像中最亮和最暗的点
(minVal, maxVal, minLoc, maxLoc) = cv2.minMaxLoc(gray)
# 在图像中绘制结果
cv2.circle(image, maxLoc, 5, (255, 0, 0), 2)

# 应用高斯模糊进行预处理
gray = cv2.GaussianBlur(gray, (args["radius"], args["radius"]), 0)
(minVal, maxVal, minLoc, maxLoc) = cv2.minMaxLoc(gray)
image1 = orig.copy()
cv2.circle(image1, maxLoc, args["radius"], (255, 0, 0), 2)

# 显示结果
result = np.hstack([orig, image, image1])
cv2.imwrite("region5.png", result)
cv2.imshow("Robust", result)
cv2.waitKey(0)

</code></pre> 
<h3><a id="_45"></a>四、代码运行步骤</h3> 
<ul><li><strong>步骤1</strong>-打开一个cmd界面；</li><li><strong>步骤2</strong>-cd /d xxx 切换到代码所在的绝对路径中，<strong>xxx表示代码所在的具体路径</strong>；</li><li><strong>步骤3</strong>-python find_region.py -i img5.png -r 59 运行代码，-i表示设置测试图片，-r表示设置显示的半径大小。</li></ul> 
<h3><a id="_51"></a>五、算法效果展示和分析</h3> 
<p><img src="https://images2.imgbox.com/c9/a2/ASPMiein_o.png" alt="在这里插入图片描述"><br>   上图展示了该算法的运行结果。每一行表示一个测试案例，第1列表示的是输入的原图，第2列表示的是原始的输出结果，即直接使用cv2.minMaxLoc函数的结果，这个函数可以输出图像中最亮的点和最暗的点所在的具体位置和对应的值，但是它容易受到噪声的干扰，第2行第2列输出了错误的结果；第3列表示的是预处理之后的结果，即首先使用高斯函数进行去噪处理，然后再使用cv2.minMaxLoc函数的效果，通过观察图中的结果，我们可以发现改进后的效果更佳明显，准确的检测到了图像中最亮的区域，满足了我们的要求。<strong>需要注意的是，用户需要根据输入图片的大小去调节–radius参数的值，该值必须为奇数。</strong></p> 
<h3><a id="_55"></a>六、思维扩展</h3> 
<p>  对于本文的这个任务而言，其实还可以用其它的思路很好的实现，一个可行的思路是使用<strong>图像二值化+寻找图像中的最大轮廓</strong>来实现，<strong>主要的原始是因为眼球和其它区域之间具有较大的颜色差异，可以通过设置一个合适的阈值来讲它们区分开来，然后在这个二值图像中寻找最大的轮廓就可以找到我们的目标，寻找最大轮廓的目的是因为图像中会含有一些其它的噪声，比如其它区域中比较小的亮区域</strong>，具体的代码实现就留给聪明的你来实现啦。</p> 
<h3><a id="_58"></a>参考资料</h3> 
<p>[1] <a href="https://www.pyimagesearch.com/2014/09/29/finding-brightest-spot-image-using-python-opencv/" rel="nofollow">参考链接</a></p> 
<h3><a id="_61"></a>注意事项</h3> 
<p>[1] 如果您对AI、自动驾驶、AR、ChatGPT等技术感兴趣，欢迎关注我的微信公众号“<strong>AI产品汇</strong>”，有问题可以在公众号中私聊我！<br> [2] 该博客是本人原创博客，如果您对该博客感兴趣，想要转载该博客，请与我联系（qq邮箱：1575262785@qq.com）,我会在第一时间回复大家，谢谢大家的关注.<br> [3] 由于个人能力有限，该博客可能存在很多的问题，希望大家能够提出改进意见。<br> [4] 如果您在阅读本博客时遇到不理解的地方，希望您可以联系我，我会及时的回复您，和您交流想法和意见，谢谢。<br> [5] 本文测试的图片可以通过关注微信公众号<strong>AI产品汇</strong>之后找我索取！<br> [6] <strong>本人业余时间承接各种本科毕设设计和各种小项目，包括图像处理（数据挖掘、机器学习、深度学习等）、matlab仿真、python算法及仿真等，有需要的请加QQ：1575262785详聊！！！</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1b3cba061a6ad91ce7d27c9a7e5c79ca/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS8 服务篇4：FTP文件传输服务搭建与配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b2f07be09345528f6e92ba93ae0e2473/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">前端实现下载pdf功能</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>