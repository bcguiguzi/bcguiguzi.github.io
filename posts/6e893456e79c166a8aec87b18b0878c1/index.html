<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ffmpeg 解码drm显示的示例 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ffmpeg 解码drm显示的示例" />
<meta property="og:description" content="由于记不清 代码参考的出处，如有侵权，请联系删除。
/* * FFMPEG DRM/KMS example application * Jorge Ramirez-Ortiz &lt;jramirez@baylibre.com&gt; * * Main file of the application * Based on code from: * 2001 Fabrice Bellard (FFMPEG/doc/examples/decode_video.c * 2018 Stanimir Varbanov (v4l2-decode/src/drm.c) * * This code has been tested on Linaro&#39;s Dragonboard 820c * kernel v4.14.15, venus decoder * ffmpeg 4.0 &#43; lrusacks ffmpeg/DRM support &#43; review * https://github.com/ldts/ffmpeg branch lrusak/v4l2-drmprime * * Copyright (c) 2018 Baylibre * * Licensed under the Apache License, Version 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6e893456e79c166a8aec87b18b0878c1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-14T17:47:55+08:00" />
<meta property="article:modified_time" content="2019-03-14T17:47:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ffmpeg 解码drm显示的示例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>由于记不清 代码参考的出处，如有侵权，请联系删除。</p> 
<pre class="has"><code class="language-cs">/*
 * FFMPEG DRM/KMS example application
 * Jorge Ramirez-Ortiz &lt;jramirez@baylibre.com&gt;
 *
 * Main file of the application
 *      Based on code from:
 *      	2001 Fabrice Bellard (FFMPEG/doc/examples/decode_video.c
 *      	2018 Stanimir Varbanov (v4l2-decode/src/drm.c)
 *
 * This code has been tested on Linaro's Dragonboard 820c
 *      kernel v4.14.15, venus decoder
 *      ffmpeg 4.0 + lrusacks ffmpeg/DRM support + review
 *      	https://github.com/ldts/ffmpeg  branch lrusak/v4l2-drmprime
 *
 * Copyright (c) 2018 Baylibre
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;xf86drm.h&gt;
#include &lt;xf86drmMode.h&gt;
#include &lt;drm_fourcc.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;getopt.h&gt;

#include &lt;libavcodec/avcodec.h&gt;
#include &lt;libavutil/hwcontext_drm.h&gt;

#define ALIGN(x, a)		((x) + (a - 1)) &amp; (~(a - 1))
#define DRM_ALIGN(val, align)	((val + (align - 1)) &amp; ~(align - 1))

#define INBUF_SIZE 4096

struct drm_buffer {
	unsigned int fourcc;
	unsigned int bo_handle;
	unsigned int fb_handle;
	int dbuf_fd;
	void *mmap_buf;
	uint32_t pitches[4];
	uint32_t offsets[4];
	uint32_t bo_handles[4];
};

struct drm_dev {
	int fd;
	uint32_t conn_id, enc_id, crtc_id, fb_id, plane_id, crtc_idx;
	uint32_t width, height;
	uint32_t pitch, size, handle;
	drmModeModeInfo mode;
	drmModeCrtc *saved_crtc;
	struct drm_dev *next;
};

static struct drm_dev *pdev;
static unsigned int drm_format;

#define DBG_TAG "  ffmpeg-drm"

#define print(msg, ...)							\
	do {								\
			struct timeval tv;				\
			gettimeofday(&amp;tv, NULL);			\
			fprintf(stderr, "%08u:%08u :" msg,		\
				(uint32_t)tv.tv_sec,			\
				(uint32_t)tv.tv_usec, ##__VA_ARGS__);	\
	} while (0)

#define err(msg, ...)  print("error: " msg "\n", ##__VA_ARGS__)
#define info(msg, ...) print(msg "\n", ##__VA_ARGS__)
#define dbg(msg, ...)  print(DBG_TAG ": " msg "\n", ##__VA_ARGS__)

int drm_dmabuf_set_plane(struct drm_buffer *buf, uint32_t width,
			 uint32_t height, int fullscreen)
{
	uint32_t crtc_w, crtc_h;

	crtc_w = width;
	crtc_h = height;

	if (fullscreen) {
		crtc_w = pdev-&gt;width;
		crtc_h = pdev-&gt;height;
	}
	//dbg("\n 111111 plane_id id:%d crtc id:%d ;pdev-&gt;fd &lt;%d&gt;\n", pdev-&gt;plane_id, pdev-&gt;crtc_id, pdev-&gt;fd);

	return drmModeSetPlane(pdev-&gt;fd, pdev-&gt;plane_id, pdev-&gt;crtc_id,
		      buf-&gt;fb_handle, 0,
		      0, 0, crtc_w, crtc_h,
		      0, 0, width &lt;&lt; 16, height &lt;&lt; 16);
}

static int drm_dmabuf_import(struct drm_buffer *buf, unsigned int width,
		      unsigned int height)
{
	return drmPrimeFDToHandle(pdev-&gt;fd, buf-&gt;dbuf_fd, &amp;buf-&gt;bo_handle);
}

static int drm_dmabuf_addfb(struct drm_buffer *buf, uint32_t width, uint32_t height)
{
	int ret;

	if (width &gt; pdev-&gt;width)
		width = pdev-&gt;width;
	if (height &gt; pdev-&gt;height)
		height = pdev-&gt;height;

	width = ALIGN(width, 8);

	uint32_t stride = DRM_ALIGN(width, 128);
	uint32_t y_scanlines = DRM_ALIGN(height, 32);

	ret = drmModeAddFB2(pdev-&gt;fd, width, height, buf-&gt;fourcc, buf-&gt;bo_handles,
			    buf-&gt;pitches, buf-&gt;offsets, &amp;buf-&gt;fb_handle, 0);
	if (ret) {
		err("drmModeAddFB2 failed: %d (%s)\n", ret, strerror(errno));
		return ret;
	}

	return 0;
}

static int find_plane(int fd, unsigned int fourcc, uint32_t *plane_id,
			uint32_t crtc_id, uint32_t crtc_idx)
{
	drmModePlaneResPtr planes;
	drmModePlanePtr plane;
	unsigned int i;
	unsigned int j;
	int ret = 0;
	unsigned int format = fourcc;

	planes = drmModeGetPlaneResources(fd);
	if (!planes) {
		err("drmModeGetPlaneResources failed\n");
		return -1;
	}

	info("drm: found planes %u", planes-&gt;count_planes);

	for (i = 0; i &lt; planes-&gt;count_planes; ++i) {
		plane = drmModeGetPlane(fd, planes-&gt;planes[i]);
		if (!plane) {
			err("drmModeGetPlane failed: %s\n", strerror(errno));
			break;
		}

		if (!(plane-&gt;possible_crtcs &amp; (1 &lt;&lt; crtc_idx))) {
			drmModeFreePlane(plane);
			continue;
		}

		for (j = 0; j &lt; plane-&gt;count_formats; ++j) {
			if (plane-&gt;formats[j] == format)
				break;
		}

		if (j == plane-&gt;count_formats) {
			drmModeFreePlane(plane);
			continue;
		}

		*plane_id = plane-&gt;plane_id;
		
		dbg("00000--plane_id &lt;%d&gt;\n", *plane_id);
		drmModeFreePlane(plane);
		break;
	}

	if (i == planes-&gt;count_planes)
		ret = -1;

	drmModeFreePlaneResources(planes);

	return ret;
}

static struct drm_dev *drm_find_dev(int fd)
{
	int i;
	struct drm_dev *dev = NULL, *dev_head = NULL;
	drmModeRes *res;
	drmModeConnector *conn;
	drmModeEncoder *enc;
	drmModeCrtc *crtc = NULL;

	if ((res = drmModeGetResources(fd)) == NULL) {
		err("drmModeGetResources() failed");
		return NULL;
	}

	if (res-&gt;count_crtcs &lt;= 0) {
		err("no Crtcs");
		goto free_res;
	}

	/* find all available connectors */
	for (i = 0; i &lt; res-&gt;count_connectors; i++) {
		conn = drmModeGetConnector(fd, res-&gt;connectors[i]);

		if (conn) {
			if (conn-&gt;connection == DRM_MODE_CONNECTED) {
				dbg("drm: connector: connected");
			} else if (conn-&gt;connection == DRM_MODE_DISCONNECTED) {
				dbg("drm: connector: disconnected");
			} else if (conn-&gt;connection == DRM_MODE_UNKNOWNCONNECTION) {
				dbg("drm: connector: unknownconnection");
			} else {
				dbg("drm: connector: unknown");
			}
		}

		if (conn != NULL &amp;&amp; conn-&gt;connection == DRM_MODE_CONNECTED
		    &amp;&amp; conn-&gt;count_modes &gt; 0) {
			dev = (struct drm_dev *) malloc(sizeof(struct drm_dev));
			memset(dev, 0, sizeof(struct drm_dev));

			dev-&gt;conn_id = conn-&gt;connector_id;
			dev-&gt;enc_id = conn-&gt;encoder_id;
			dev-&gt;next = NULL;

			memcpy(&amp;dev-&gt;mode, &amp;conn-&gt;modes[0], sizeof(drmModeModeInfo));
			dev-&gt;width = conn-&gt;modes[0].hdisplay;
			dev-&gt;height = conn-&gt;modes[0].vdisplay;

			if (conn-&gt;encoder_id) {
				enc = drmModeGetEncoder(fd, conn-&gt;encoder_id);
				if (!enc) {
					err("drmModeGetEncoder() faild");
					goto free_res;
				}
				if (enc-&gt;crtc_id) {
					crtc = drmModeGetCrtc(fd, enc-&gt;crtc_id);
					if (crtc)
						dev-&gt;crtc_id = enc-&gt;crtc_id;
				}
			}

			drmModeFreeEncoder(enc);

			dev-&gt;saved_crtc = NULL;

			/* create dev list */
			dev-&gt;next = dev_head;
			dev_head = dev;
		}
		drmModeFreeConnector(conn);
	}

	dev-&gt;crtc_idx = -1;

	for (i = 0; i &lt; res-&gt;count_crtcs; ++i) {
		if (dev-&gt;crtc_id == res-&gt;crtcs[i]) {
			dev-&gt;crtc_idx = i;
			break;
		}
	}

	if (dev-&gt;crtc_idx == -1)
		err( "drm: CRTC %u not found\n");

free_res:
	drmModeFreeResources(res);

	return dev_head;
}

static int drm_open(const char *path)
{
	int fd, flags;
	uint64_t has_dumb;
	int ret;

	fd = open(path, O_RDWR);
	if (fd &lt; 0) {
		err("cannot open \"%s\"\n", path);
		return -1;
	}

	/* set FD_CLOEXEC flag */
	if ((flags = fcntl(fd, F_GETFD)) &lt; 0 ||
	     fcntl(fd, F_SETFD, flags | FD_CLOEXEC) &lt; 0) {
		err("fcntl FD_CLOEXEC failed\n");
		goto err;
	}

	/* check capability */
	ret = drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;has_dumb);
	if (ret &lt; 0 || has_dumb == 0) {
		err("drmGetCap DRM_CAP_DUMB_BUFFER failed or doesn't have dumb "
		    "buffer\n");
		goto err;
	}

	return fd;
err:
	close(fd);
	return -1;
}

static int drm_init(unsigned int fourcc, const char *device)
{
	struct drm_dev *dev_head, *dev;
	int fd;
	int ret;

	fd = drm_open(device);
	if (fd &lt; 0)
		return -1;

	dev_head = drm_find_dev(fd);
	if (dev_head == NULL) {
		err("available drm devices not found\n");
		goto err;
	}

	dbg("available connector(s)");

	for (dev = dev_head; dev != NULL; dev = dev-&gt;next) {
		dbg("connector id:%d", dev-&gt;conn_id);
		dbg("\tencoder id:%d crtc id:%d fb id:%d", dev-&gt;enc_id,
		    dev-&gt;crtc_id, dev-&gt;fb_id);
		dbg("\twidth:%d height:%d", dev-&gt;width, dev-&gt;height);
	}

	/* FIXME: use first drm_dev */
	for (dev = dev_head; dev != NULL; dev = dev-&gt;next) {
		if(dev-&gt;conn_id == 78) {
			
			dbg("\n use connect_id &lt;%d&gt;", dev-&gt;conn_id);
			break;
		}
	}
	dev = dev_head;
	dev-&gt;fd = fd;
	pdev = dev;

	dbg("\n encoder id&lt;%d&gt;; crtc id&lt;%d&gt;; \n plane_id id&lt;%d&gt;; dev-&gt;fd &lt;%d&gt;; ", 
							dev-&gt;enc_id, dev-&gt;crtc_id, dev-&gt;plane_id, dev-&gt;fd);

	ret = find_plane(fd, fourcc, &amp;dev-&gt;plane_id, dev-&gt;crtc_id, dev-&gt;crtc_idx);
	if (ret) {
		err("Cannot find plane\n");
		goto err;
	}
//	dbg("\n encoder id&lt;%d&gt;; crtc id&lt;%d&gt;; \n plane_id id&lt;%d&gt;; fd &lt;%d&gt;; \n fourcc &lt;%d&gt;\n", 
	//						dev-&gt;enc_id, dev-&gt;crtc_id, dev-&gt;plane_id, fd, fourcc);

	//dev-&gt;crtc_id = 68;
	//dev-&gt;plane_id = 66;
	info("\n drm: Found %c%c%c%c plane_id: %x \n",
		(fourcc&gt;&gt;0)&amp;0xff, (fourcc&gt;&gt;8)&amp;0xff, (fourcc&gt;&gt;16)&amp;0xff, (fourcc&gt;&gt;24)&amp;0xff,
		dev-&gt;plane_id);
	return 0;

err:
	close(fd);
	pdev = NULL;
	return -1;
}

static int display(struct drm_buffer *drm_buf, int width, int height)
{
        struct drm_gem_close gem_close;
        int ret;

	ret = drm_dmabuf_import(drm_buf, width, height);
	if (ret) {
		err("cannot import dmabuf %d, fd=%d\n", ret, drm_buf-&gt;dbuf_fd);
		return -EFAULT;
	}
	drm_buf-&gt;bo_handles[0] = drm_buf-&gt;bo_handle;
	drm_buf-&gt;bo_handles[1] = drm_buf-&gt;bo_handle;
	drm_buf-&gt;bo_handles[2] = drm_buf-&gt;bo_handle;
	drm_buf-&gt;bo_handles[3] = drm_buf-&gt;bo_handle;

	ret = drm_dmabuf_addfb(drm_buf, width, height);
	if (ret) {
		err("cannot add framebuffer %d\n", ret);
		return -EFAULT;
	}

	drm_dmabuf_set_plane(drm_buf, width, height, 1);

        /* WARNING: this will _obviously_ cause the screen to flicker!!
         *
         *   Instead of using some simple stuff to postpone the release actions
         *   (a list or a ping/ping buffer or whatever) we will just keep it
         *   this way for clarity.
         *
         *   1. the client MUST remove the fb_handle
         *   2. the client MUST close the bo_handle (GEM object)
         *
         *   Not doing so will cause FFMPEG to _fail_ when releasing the capture
         *   mmap'ed buffers since the dmabufs are exported to DRM and therefore
         *   DRM keeps a reference to those buffers.
         *
         *   REQBUFS --&gt; MMAP --&gt; EXPBUF --&gt; fb_handle / bo_handle
         *
         *   ==&gt; releasing the buffers requires the handles to be released
         */

		  // SM2W :  此处不注释掉，3288无法显示
        if (drmModeRmFB(pdev-&gt;fd, drm_buf-&gt;fb_handle))
      //      err("cant remove fb %d\n", drm_buf-&gt;fb_handle);

        memset(&amp;gem_close, 0, sizeof gem_close);
        gem_close.handle = drm_buf-&gt;bo_handle;
        if (drmIoctl(pdev-&gt;fd, DRM_IOCTL_GEM_CLOSE, &amp;gem_close) &lt; 0)
            err("cant close gem: %s\n", strerror(errno));

	return 0;
}

static void decode_and_display(AVCodecContext *dec_ctx, AVFrame *frame,
			AVPacket *pkt, const char *device)
{
	AVDRMFrameDescriptor *desc = NULL;
	struct drm_buffer drm_buf;
	int ret;
	uint8_t *srcSlice[8] = { NULL };
	int srcStride[8] = { 0 };
	int av_format_tmp ;

	ret = avcodec_send_packet(dec_ctx, pkt);
	if (ret &lt; 0) {
		err("Error sending a packet for decoding\n");
		exit(1);
	}

	while (ret &gt;= 0) {
		ret = avcodec_receive_frame(dec_ctx, frame);
		if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF)
			return;
		else if (ret &lt; 0) {
			err("Error during decoding\n");
			exit(1);
		}

		desc = (AVDRMFrameDescriptor *) frame-&gt;data[0];
		
		drm_buf.dbuf_fd = desc-&gt;objects[0].fd;
		for (int i = 0; i &lt; desc-&gt;layers-&gt;nb_planes &amp;&amp; i &lt; 4; i++ ) {
			drm_buf.pitches[i] = desc-&gt;layers-&gt;planes[i].pitch;
			drm_buf.offsets[i] = desc-&gt;layers-&gt;planes[i].offset;
		}

                if (!pdev) {
                    /* initialize DRM with the format returned in the frame */
                    ret = drm_init(desc-&gt;layers[0].format, device);
                    if (ret) {
                        err("Error initializing drm\n");
                        exit(1);
                    }

                    /* remember the format */
                    drm_format = desc-&gt;layers[0].format;
                }

                /* pass the format in the buffer */
                drm_buf.fourcc = drm_format;
		ret = display(&amp;drm_buf, frame-&gt;width, frame-&gt;height);
		if (ret &lt; 0){
			drmModeRmFB(pdev-&gt;fd, drm_buf.fb_handle);
			return;}
    }
}

static const struct option options[] = {
	{
#define help_opt	0
		.name = "help",
		.has_arg = 0,
		.flag = NULL,
	},
	{
#define video_opt	1
		.name = "video",
		.has_arg = 1,
		.flag = NULL,
	},
	{
#define codec_opt	2
		.name = "codec",
		.has_arg = 1,
		.flag = NULL,
	},
	{
#define height_opt	3
		.name = "height",
		.has_arg = 1,
		.flag = NULL,
	},
	{
#define width_opt	4
		.name = "width",
		.has_arg = 1,
		.flag = NULL,
	},
	{
#define device_opt	5
		.name = "device",
		.has_arg = 1,
		.flag = NULL,
	},
	{
		.name = NULL,
	},
};

static void usage(void)
{
	fprintf(stderr, "usage: ffmpeg-drm &lt;options&gt;, with:\n");
	fprintf(stderr, "--help            display this menu\n");
	fprintf(stderr, "--video=&lt;name&gt;    video to display\n");
	fprintf(stderr, "--codec=&lt;name&gt;    ffmpeg codec: ie h264_v4l2m2m\n");
	fprintf(stderr, "--width=&lt;value&gt;   frame width\n");
	fprintf(stderr, "--height=&lt;value&gt;  frame height\n");
    fprintf(stderr, "--device=&lt;value&gt;  dri device to use\n");
	fprintf(stderr, "\n");
}

int main(int argc, char *argv[])
{
	uint8_t inbuf[INBUF_SIZE + AV_INPUT_BUFFER_PADDING_SIZE];
	AVCodecParserContext *parser;
	AVCodecContext *c = NULL;
	const AVCodec *codec;
	AVFrame *frame;
	AVPacket *pkt;
	size_t data_size;
	uint8_t *data;
	FILE *f;
	int ret;
	int lindex, opt;
	unsigned int frame_width = 0, frame_height = 0;
	char *codec_name = NULL, *video_name = NULL;
    char *device_name = "/dev/dri/card0";

	for (;;) {
		lindex = -1;

		opt = getopt_long_only(argc, argv, "", options, &amp;lindex);
		if (opt == EOF)
			break;

		switch (lindex) {
		case help_opt:
			usage();
			exit(0);
		case video_opt:
			video_name = optarg;
			break;
		case codec_opt:
			codec_name = optarg;
			break;
		case width_opt:
			frame_width = atoi(optarg);
			break;
		case height_opt:
			frame_height = atoi(optarg);
			break;
        case device_opt:
			device_name = optarg;
			break;
		default:
			usage();
			exit(1);
		}
	}

	if (!frame_width || !frame_height || !codec_name || !video_name) {
		usage();
		exit(0);
	}

	avcodec_register_all();

	pkt = av_packet_alloc();
	if (!pkt) {
		err("Error allocating packet\n");
		exit(1);
	}

	/* set end of buffer to 0 (this ensures that no overreading happens for
	   damaged MPEG streams) */
	memset(inbuf + INBUF_SIZE, 0, AV_INPUT_BUFFER_PADDING_SIZE);

	/* find the video decoder: ie: h264_v4l2m2m */
	codec = avcodec_find_decoder_by_name(codec_name);
	if (!codec) {
		err("Codec not found\n");
		exit(1);
	}

	parser = av_parser_init(codec-&gt;id);
	if (!parser) {
		err("parser not found\n");
		exit(1);
	}

	c = avcodec_alloc_context3(codec);
	if (!c) {
		err("Could not allocate video codec context\n");
		exit(1);
	}

	/* For some codecs, such as msmpeg4 and mpeg4, width and height
	   MUST be initialized before opening the ffmpeg codec (ie, before
	   calling avcodec_open2) because this information is not available in
	   the bitstream). */
	c-&gt;pix_fmt = AV_PIX_FMT_DRM_PRIME;   /* request a DRM frame */
        c-&gt;coded_height = frame_height;
	c-&gt;coded_width = frame_width;

	/* open it */
	if (avcodec_open2(c, codec, NULL) &lt; 0) {
		err("Could not open codec\n");
		exit(1);
	}

	f = fopen(video_name, "rb");
	if (!f) {
		err("Could not open %s\n", video_name);
		exit(1);
	}

	frame = av_frame_alloc();
	if (!frame) {
		err("Could not allocate video frame\n");
		exit(1);
	}

	while (!feof(f)) {
		/* read raw data from the input file */
		data_size = fread(inbuf, 1, INBUF_SIZE, f);
		if (!data_size)
			break;

		/* use the parser to split the data into frames */
		data = inbuf;
		while (data_size &gt; 0) {
			ret = av_parser_parse2(parser, c, &amp;pkt-&gt;data, &amp;pkt-&gt;size,
				data, data_size, AV_NOPTS_VALUE, AV_NOPTS_VALUE, 0);
			if (ret &lt; 0) {
				err("Error while parsing\n");
				exit(1);
			}

			data += ret;
			data_size -= ret;

			if (pkt-&gt;size)
				decode_and_display(c, frame, pkt, device_name);
		}
	}
	fclose(f);

        decode_and_display(c, frame, NULL, device_name);

        av_parser_close(parser);
	avcodec_free_context(&amp;c);
	av_frame_free(&amp;frame);
	av_packet_free(&amp;pkt);

	return 0;
}
</code></pre> 
<p>但是 该代码，没有调起drm的双缓冲机制，画面刷新有些异常；</p> 
<p>找到了使用双缓冲的dmeo，<a href="https://github.com/dvdhrm/docs/blob/master/drm-howto/modeset-vsync.c">Github: drm-howto/modeset-vsync.c</a>，但是不知道二者怎么结合起来？</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe76a94c101400c5b5d6c45c2bfeec8d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Tensorflow训练过程中查看某参数的值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7b544392f2dd1488548f216bd4f7098d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">集成 FileDownloader 总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>