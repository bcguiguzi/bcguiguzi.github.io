<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Odoo自定义视图教程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Odoo自定义视图教程" />
<meta property="og:description" content="我们在Odoo开发时基本都会对模型定义相关视图，其中常常用到的有form，tree，kanban,另外还有calendar，pivot，graph等视图，可以说视图是Odoo很重要的一个组成部分。此外有时视图自带的功能无法满足需求时，我们还需要尝试去对视图做自定义扩展，所以适当的了解视图的背后的运行机制可以让我们更从容、高效的面对视图开发。
这篇教程中我会介绍如何定义视图，视图的基本运行流程，一些主要属性以及实战部分。为了避免篇幅过长，一些在 Odoo 中添加自定义dashboard页面已经讲解过相同功能点，这篇教程中我不再作讲解，如果读者学习本篇教程感觉困难，那么可以先阅读自定义dashboard的教程。
Prerequisite 本教程基于以下环境开发:
系统: windows wsl - Ubuntu 18.04Odoo: Nightly Odoo 构建的post-20200101 12.0 版本数据库: PostgreSQL 10.11 本教程中的示例代码可以从https://github.com/findsomeoneyys/odoo-custom-view-tutorial中获取，仓库中的每个tag对应一个章节结束后的完整代码，读者可以通过类似以下方式来自由切换到不同章节代码。
1 git checkout v0.1 定义基本模型 可以通过git checkout v0.1查看本章节的完整代码
为了方便展示新视图，我们需要建立基本的模型，视图，和默认数据，这里我建了个Game模型，包含名称，下载量和平台字段。
1 2 3 4 5 6 7 8 9 10 11 # -*- coding: utf-8 -*- from odoo import models, fields, api class Game(models.Model): _name = &#39;echart_views.game&#39; _description = &#39;Games&#39; name = fields.Char(&#39;游戏名&#39;, required=True) downloads = fields.Integer(string=&#39;下载量&#39;, default=0) platform = fields." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/dccdfdda23136d54d34b9fb2dbcba961/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-02T09:36:24+08:00" />
<meta property="article:modified_time" content="2021-12-02T09:36:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Odoo自定义视图教程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>我们在Odoo开发时基本都会对模型定义相关视图，其中常常用到的有form，tree，kanban,另外还有calendar，pivot，graph等视图，可以说视图是Odoo很重要的一个组成部分。此外有时视图自带的功能无法满足需求时，我们还需要尝试去对视图做自定义扩展，所以适当的了解视图的背后的运行机制可以让我们更从容、高效的面对视图开发。</p> 
<p>这篇教程中我会介绍如何定义视图，视图的基本运行流程，一些主要属性以及实战部分。为了避免篇幅过长，一些<a href="https://www.magicican.com/post/odoo-custom-dashboard-tutorial.html" rel="nofollow" title="在 Odoo 中添加自定义dashboard页面">在 Odoo 中添加自定义dashboard页面</a>已经讲解过相同功能点，这篇教程中我不再作讲解，如果读者学习本篇教程感觉困难，那么可以先阅读自定义dashboard的教程。</p> 
<p><a id="more" title=""></a></p> 
<h2 id="Prerequisite">Prerequisite</h2> 
<p>本教程基于以下环境开发:</p> 
<ul><li>系统: windows wsl - <code>Ubuntu 18.04</code></li><li>Odoo: <a href="http://nightly.odoo.com/12.0/nightly/src/" rel="nofollow" title="Nightly Odoo">Nightly Odoo</a> 构建的post-20200101 <code>12.0</code> 版本</li><li>数据库: PostgreSQL 10.11</li></ul> 
<p>本教程中的示例代码可以从<code>https://github.com/findsomeoneyys/odoo-custom-view-tutorial</code>中获取，仓库中的每个<code>tag</code>对应一个章节结束后的完整代码，读者可以通过类似以下方式来自由切换到不同章节代码。</p> 
<table><tbody><tr><td> <pre>1
</pre> </td><td> <pre>git checkout v0.1
</pre> </td></tr></tbody></table> 
<h2 id="定义基本模型">定义基本模型</h2> 
<blockquote> 
 <p>可以通过<code>git checkout v0.1</code>查看本章节的完整代码</p> 
</blockquote> 
<p>为了方便展示新视图，我们需要建立基本的模型，视图，和默认数据，这里我建了个Game模型，包含名称，下载量和平台字段。</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
</pre> </td><td> <pre># -*- coding: utf-8 -*-
from odoo import models, fields, api


class Game(models.Model):
    _name = 'echart_views.game'
    _description = 'Games'

    name = fields.Char('游戏名', required=True)
    downloads = fields.Integer(string='下载量', default=0)
    platform = fields.Char(string='平台')
</pre> </td></tr></tbody></table> 
<p>安装上模块后，便可看到基本的视图。</p> 
<p style="text-align:center;"><img alt="alt" src="https://images2.imgbox.com/45/9f/1go2mT0o_o.png"></p> 
<h2 id="定义新视图">定义新视图</h2> 
<blockquote> 
 <p>可以通过<code>git checkout v0.2</code>查看本章节的完整代码</p> 
</blockquote> 
<p>定义一个新视图的操作量比较大，我们需要给odoo的python代码中增加新视图类型与视图模式，其次我们还需要定义js相关文件和模板代码。</p> 
<h3 id="让Odoo识别新视图类型">让Odoo识别新视图类型</h3> 
<p>首先我们在model下建立两个文件<code>ir_action_act_window.py</code>和<code>ir_ui_view.py</code>，然后加入相关代码，这是为了odoo可以识别我们新定义的视图tag，如果没有这部分代码，在加载相关的xml文件会报错并提示你odoo没有这种类型视图。<br> 这里我把我的新视图命名为<code>eview</code></p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
</pre> </td><td> <pre>ir_action_act_window.py

# -*- coding: utf-8 -*-
from odoo import fields, models


class ActWindowView(models.Model):
    _inherit = 'ir.actions.act_window.view'

    view_mode = fields.Selection(selection_add=[('eview', 'echart views')])
</pre> </td></tr></tbody></table> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
</pre> </td><td> <pre>ir_ui_view.py

# -*- coding: utf-8 -*-
from odoo import fields, models


class View(models.Model):
    _inherit = 'ir.ui.view'

    type = fields.Selection(selection_add=[('eview', 'echart views')])
</pre> </td></tr></tbody></table> 
<p>同时也别忘了在<code>models/__init__.py</code>中加入新增的class</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
</pre> </td><td> <pre># -*- coding: utf-8 -*-

from . import models
from . import ir_ui_view
from . import ir_action_act_window
</pre> </td></tr></tbody></table> 
<h3 id="增加视图所需js文件">增加视图所需js文件</h3> 
<p>Odoo的视图中的底层实现已经将相关功能抽象成几个部分，所以我们只需要继承并实现Odoo为我们预留好的逻辑即可, 一个完整的视图是由<code>view</code>, <code>controller</code>, <code>model</code>, <code>renderer</code>这几个组件组成的。Odoo的视图的实现使用了<a href="https://zh.wikipedia.org/wiki/MVC" rel="nofollow" title="MVC设计模式">MVC设计模式</a>,它们之间的关系如下图所示:</p> 
<p style="text-align:center;"><img alt="alt" src="https://images2.imgbox.com/16/f5/I8WJqNXL_o.png"></p> 
<p>其中需要注意的是MVC设计模式在视图中实际对应<code>controller</code>, <code>model</code>, <code>renderer</code>(MRC),这是因为<code>View</code>在Odoo中有特殊的历史含义(也就是我们提到的展示数据的一种视图类型)。在这几部分中，<code>View</code>更多充当一个入口的角色，类似后端的路由。</p> 
<p>现在我们增加相关js文件与实现逻辑，同时我会讲解各个组件的相关生命周期函数。这里需要注意的是，相关代码注释中如果上面包含<code>@returns {Deferred}</code>,则需要返回一个<a href="https://api.jquery.com/jQuery.Deferred/" rel="nofollow" title="Deferred对象">Deferred对象</a>，这是因为odoo是通过这种方式来增加相关函数的回调执行，如果不返回<code>Deferred</code>对象，有时会产生程序错误，大部分的时候我们只需加上<code>return this._super.apply(this, arguments)</code>或者<code>$.when()</code>即可。</p> 
<h4 id="实现Controller">实现Controller</h4> 
<p>Odoo对于<code>Controller</code>部分抽象出<code>web.AbstractController</code>，所以我们只需继承这个类并填写相关逻辑。<br> 在<code>static/src/js</code>新增<code>eview_controller.js</code>文件，并键入以下代码：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre> </td><td> <pre>odoo.define('echart_views.Controller', function (require) {
    'use strict';

    var AbstractController = require('web.AbstractController');
    var core = require('web.core');
    var qweb = core.qweb;

    var EchartController = AbstractController.extend({
        init: function (parent, model, renderer, params) {
            console.log("eview controller &gt;&gt;&gt; init");
            this._super.apply(this, arguments);
        },
        /**
         * @returns {Deferred}
         */
        start: function() {
            console.log("eview controller &gt;&gt;&gt; start");
            return this._super();
        },
        // 该方法会生成导航栏中的按钮，并可增加绑定按钮事件
        renderButtons: function ($node) {
            console.log("eview controller &gt;&gt;&gt; renderButtons");
            this._super.apply(this, arguments);
        },
        /**
         * 执行该方法重新加载视图，默认逻辑是对调用update的封装
         * @param {Object} [params] This object will simply be given to the update
         * @returns {Deferred}
         */
        reload: function (params) {
            console.log("eview controller &gt;&gt;&gt; reload");
            return this._super.apply(this, arguments);
        },
        /**
         * update是Controller的关键方法，在Odoo默认逻辑中，当用户操作搜索视图，或者部分内部更改会主动调用该方法。
         * 当我们自行编写相关方法时需要主动调用该函数。
         * 这个方法会调用model重新加载数据并通知renderer执行渲染
         * @param {*} params
         * @param {*} options
         * @param {boolean} [options.reload=true] if true, the model will reload data
         *
         * @returns {Deferred}
         */
        update: function (params, options) {
            console.log("eview controller &gt;&gt;&gt; update");
            return this._super.apply(this, arguments);
        },
        /**
         * _update是update的回调方法，区别在于update是重新渲染页面主体部分，
         * _update则是渲染除了主体部分外的组件，比如控制面板中的组件 (buttons, pager, sidebar...)
         * @param {*} state
         * @returns {Deferred}
         */
        _update: function (state) {
            console.log("eview controller &gt;&gt;&gt; _update");
            return this._super.apply(this, arguments);
        },


    });

    return EchartController;

});
</pre> </td></tr></tbody></table> 
<h4 id="实现Model">实现Model</h4> 
<p>同样的，<code>Model</code>部分对应的抽象类是<code>web.AbstractModel</code>, <code>Model</code>是挂在<code>Controller</code>的一个对象，所有数据相关的部分都需要通过它来处理，这部分的主要逻辑很简单，只需要实现<code>get</code>和<code>load</code>方法，通过rpc等方式向后台请求数据，将数据结果保存在对象上比如<code>this.data=result</code>，然后在<code>get</code>方法中返回<code>this.data</code>即可。</p> 
<p>在<code>static/src/js</code>新增<code>eview_model.js</code>文件，并键入以下代码：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre> </td><td> <pre>odoo.define('echart_views.Model', function (require) {
    'use strict';

    var AbstractModel = require('web.AbstractModel');

    var EchartModel = AbstractModel.extend({
        /**
         * 该方法需要返回renderer所需的数据
         * 数据可以通过load/reload执行相关获取数据方法时，设置到该对象上
         */
        get: function () {
            console.log("eview model &gt;&gt;&gt; get");
            this._super();
        },
        /**
         * 只会初次加载时执行一次，需要自定义相关数据获取方法获取数据并设置到该对象上
         *
         * @param {Object} params
         * @param {string} params.modelName the name of the model
         * @returns {Deferred} The deferred resolves to some kind of handle
         */
        load: function (params) {
            console.log("eview model &gt;&gt;&gt; load");
            return this._super.apply(this, arguments);
        },
        /**
         * 当有相关数据变动时，重新获取数据。
         *
         * @param {Object} params
         * @returns {Deferred}
         */
        reload: function (handle, params) {
            console.log("eview model &gt;&gt;&gt; reload");
            return this._super.apply(this, arguments);
        },
    });

    return EchartModel;

});
</pre> </td></tr></tbody></table> 
<h4 id="实现Renderer">实现Renderer</h4> 
<p><code>Renderer</code>部分对应的抽象类是<code>web.AbstractModel</code>，renderer只需关注拿到数据并渲染页面即可，其中<code>this.state</code>对应的是<code>Model</code>中<code>get</code>方法获取的数据。</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre> </td><td> <pre>odoo.define('echart_views.Renderer', function (require) {
    'use strict';

    var AbstractRenderer = require('web.AbstractRenderer');
    var core = require('web.core');

    var qweb = core.qweb;

    var EchartRenderer = AbstractRenderer.extend({
        init: function (parent, state, params) {
            console.log("eview renderer &gt;&gt;&gt; init");
            this._super.apply(this, arguments);

        },
        /**
         *  renderer的渲染逻辑部分，自行渲染相关数据并插入this.$el中
         *
         * @abstract
         * @private
         * @returns {Deferred}
         */
        _render: function () {
            console.log("eview renderer &gt;&gt;&gt; _render");
            var content = $("&lt;div&gt;&lt;p&gt; eview &lt;/p&gt;&lt;/div&gt;");
            this.$el.append(content);
            return this._super.apply(this, arguments);
        },
    });

    return EchartRenderer;

});
</pre> </td></tr></tbody></table> 
<h4 id="实现View">实现View</h4> 
<p><code>View</code>对应的是<code>web.AbstractView</code>抽象类，是<code>View</code>的函数入口，它包含视图的基本定义信息，同时会根据传入的视图结构信息，相关参数初始化<code>controller</code>, <code>model</code>, <code>renderer</code>，当初始化<code>controller</code>完毕后，页面之后的相关处理都与这个类无关了。</p> 
<p>在<code>static/src/js</code>新增<code>eview_view.js</code>文件，并键入以下代码：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre> </td><td> <pre>odoo.define('echart_views.View', function (require) {
    'use strict';

    var AbstractView = require('web.AbstractView');
    var view_registry = require('web.view_registry');
    var Controller = require('echart_views.Controller');
    var eViewModel = require('echart_views.Model');
    var eViewRenderer = require('echart_views.Renderer');


    var EchartView = AbstractView.extend({
        display_name: 'EchartView',
        icon: 'fa-bar-chart',
        cssLibs: [
        ],
        jsLibs: [
        ],
        config: {
            Model: eViewModel,
            Controller: Controller,
            Renderer: eViewRenderer,
        },
        viewType: 'eview',
        groupable: false,
        /**
         * View的入口，会传入相关视图定义的参数(视图结构，字段信息等。。)，
         * 函数会处理并生产3个主要字段：this.rendererParams， this.controllerParams，this.loadParams
         * 分别对应renderer，controller，model的初始化参数，我们可以根据需要自行对相关增加相关参数
         * @param {Object} viewInfo.arch
         * @param {Object} viewInfo
         * @param {Object} viewInfo.fields
         * @param {Object} viewInfo.fieldsInfo
         * @param {Object} params
         * @param {string} params.modelName The actual model name
         * @param {Object} params.context
         */
        init: function (viewInfo, params) {
            console.log("eview view &gt;&gt;&gt; init");
            this._super.apply(this, arguments);
        },
        /**
         * View的主要的执行逻辑，这个方法会分别执行getModel，getRenderer初始化相关组件，
         * 然后对renderer, model设置controller就完成了作用，之后的View相关操作与这个类无关了
         * @param {}} parent 
         */
        getController: function (parent) {
            console.log("eview view &gt;&gt;&gt; getController");
            return this._super.apply(this, arguments);
        },
        // 这里会初始化model，并执行model中load方法
        getModel: function (parent) {
            console.log("eview view &gt;&gt;&gt; getModel");
            return this._super.apply(this, arguments);
        },
        getRenderer: function (parent, state) {
            console.log("eview view &gt;&gt;&gt; getRenderer");
            return this._super.apply(this, arguments);
        },

    });

    view_registry.add('eview', EchartView);

    return EchartView;

});
</pre> </td></tr></tbody></table> 
<h4 id="加载资源与添加新视图">加载资源与添加新视图</h4> 
<p>js部分实现后，我们需要把相关文件加载进odoo中，在<code>views</code>目录下新建文件<code>templates.xml</code>并添加相关代码</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre> </td><td> <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;odoo&gt;

    &lt;template id="assets_end" inherit_id="web.assets_backend"&gt;
        &lt;xpath expr="." position="inside"&gt;

            &lt;script type="text/javascript" src="/echart_views/static/src/js/eview_view.js" /&gt;
            &lt;script type="text/javascript" src="/echart_views/static/src/js/eview_model.js" /&gt;
            &lt;script type="text/javascript" src="/echart_views/static/src/js/eview_controller.js" /&gt;
            &lt;script type="text/javascript" src="/echart_views/static/src/js/eview_renderer.js" /&gt;

        &lt;/xpath&gt;
    &lt;/template&gt;

&lt;/odoo&gt;
</pre> </td></tr></tbody></table> 
<p>然后在<code>__manifest__.py</code>中引入该文件，最后在<code>views.xml</code>的<code>act_window</code>添加我们的新视图模式，以及我们的新视图定义</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre> </td><td> <pre>&lt;record id='echart_views_game_action' model='ir.actions.act_window'&gt;
    &lt;field name="name"&gt;Games&lt;/field&gt;
    &lt;field name="res_model"&gt;echart_views.game&lt;/field&gt;
    &lt;field name="view_type"&gt;form&lt;/field&gt;
    &lt;field name="view_mode"&gt;tree,form,eview&lt;/field&gt;
&lt;/record&gt;

...

&lt;!-- eview View --&gt;
&lt;record id="echart_views_game_view_eview" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Game echart view&lt;/field&gt;
    &lt;field name="model"&gt;echart_views.game&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
        &lt;eview&gt;
            &lt;field name="name"/&gt;
            &lt;field name="downloads"/&gt;
            &lt;field name="platform"/&gt;
        &lt;/eview&gt;
    &lt;/field&gt;
&lt;/record&gt;
</pre> </td></tr></tbody></table> 
<h3 id="小结">小结</h3> 
<p>完成以上步骤后，重启Odoo并更新模块，打开<code>debug=assets</code>模式并进入视图，我们即可看到新增的视图效果与组件和相关函数的加载顺序了。</p> 
<p style="text-align:center;"><img alt="alt" src="https://images2.imgbox.com/ef/2e/sYhbVBQ7_o.png"></p> 
<h2 id="实战">实战</h2> 
<p>在前面的教程中我们了解到了views的组件初始化与生命周期函数，这也意味着我们可以在相关周期函数中加入自己的一系列事件，来实现我们自己独特的视图。<br> 在接下来的章节中我会逐步实现加入视图模板，解析视图字段，事件绑定与处理等功能来实现一个基于echart的自定义饼图，这个视图中我们可以左上角自由切换定义在xml中的字段，饼图中则会统计该字段在数据库的全部数据：如果字段是数值，根据Name自动分类叠加，如果字段是字符串，则对该字段分组统计数量。</p> 
<h3 id="自定义模板与按钮事件绑定">自定义模板与按钮事件绑定</h3> 
<blockquote> 
 <p>可以通过<code>git checkout v0.3</code>查看本章节的完整代码</p> 
</blockquote> 
<p>和<a href="https://www.magicican.com/post/odoo-custom-dashboard-tutorial.html" rel="nofollow" title="在 Odoo 中添加自定义dashboard页面">在 Odoo 中添加自定义dashboard页面</a>中的模板渲染流程一样，首先我们在<code>eview_view.js</code>的<code>jsLibs</code>中加上echart。</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
</pre> </td><td> <pre>...

jsLibs: [
            'https://cdn.jsdelivr.net/npm/echarts@4.6.0/dist/echarts.min.js',
        ],
</pre> </td></tr></tbody></table> 
<p>接着在<code>static/src/xml</code>新增<code>qweb_template.xml</code>文件并增加模板代码,同时在<code>__manifest__.py</code>中引入</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre> </td><td> <pre>qweb_template.xml

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;templates&gt;

    &lt;t t-name="echart_views.page"&gt;
        &lt;div class="container-fluid mt-3"&gt;
            &lt;div id="app" class="mt-2" style="width: 800px;height:500px;"&gt;
                &lt;p&gt;echart&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/t&gt;

&lt;/templates&gt;
</pre> </td></tr></tbody></table> 
<table><tbody><tr><td> <pre>1
2
3
4
5
</pre> </td><td> <pre>__manifest__.py

'qweb': [
        'static/src/xml/qweb_template.xml',
    ]
</pre> </td></tr></tbody></table> 
<p>然后在<code>eview_renderer.js</code>中做相关处理即可，这里我直接根据<a href="https://www.echartsjs.com/examples/zh/editor.html?c=pie-doughnut" rel="nofollow" title="echart-饼图演示">echart-饼图演示</a>实现相关功能。</p> 
<p>在<code>init</code>中加入option参数，同时在<code>_render</code>中渲染模板并初始化echart</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre> </td><td> <pre>init: function (parent, state, params) {
    console.log("eview renderer &gt;&gt;&gt; init");
    this._super.apply(this, arguments);
    this.echart_option = {
        tooltip: {
            trigger: 'item',
            formatter: '{a} &lt;br/&gt;{b}: {c} ({d}%)'
        },
        legend: {
            orient: 'vertical',
            left: 10,
            data: ['直接访问', '邮件营销', '联盟广告', '视频广告', '搜索引擎']
        },
        series: [
            {
                name: '访问来源',
                type: 'pie',
                radius: ['50%', '70%'],
                avoidLabelOverlap: false,
                label: {
                    normal: {
                        show: false,
                        position: 'center'
                    },
                    emphasis: {
                        show: true,
                        textStyle: {
                            fontSize: '30',
                            fontWeight: 'bold'
                        }
                    }
                },
                labelLine: {
                    normal: {
                        show: false
                    }
                },
                data: [
                    {value: 335, name: '直接访问'},
                    {value: 310, name: '邮件营销'},
                    {value: 234, name: '联盟广告'},
                    {value: 135, name: '视频广告'},
                    {value: 1548, name: '搜索引擎'}
                ]
            }
        ]
    };
    

},
_render: function () {
    console.log("eview renderer &gt;&gt;&gt; _render");
    this.$el.empty();
    this.$el.append(qweb.render('echart_views.page'));
    var el = this.$el.find('#app')[0];
    var myChart = echarts.init(el);
    myChart.setOption(this.echart_option);
    return this._super.apply(this, arguments);
},
</pre> </td></tr></tbody></table> 
<p>更新模板并刷新页面，再次打开eview时，我们就会看到一个饼图：</p> 
<p style="text-align:center;"><img alt="alt" src="https://images2.imgbox.com/7e/db/FRfy4K3l_o.png"></p> 
<p>接着我们为导航栏增加按钮，视图导航栏的按钮就是类似tree视图中创建、导入等按钮，通过重写<code>Controller</code>中的<code>renderButtons</code>方法便可轻松实现。<br> 我们继续在<code>qweb_template.xml</code>中新增按钮组的模板代码</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
</pre> </td><td> <pre>&lt;t t-name="echart_views.buttons"&gt;
    &lt;div class="btn-group" role="toolbar" aria-label="Main actions"&gt;
        &lt;button class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false"&gt;
            统计字段
        &lt;/button&gt;
        &lt;div class="dropdown-menu o_echart_measures_list" role="menu"&gt;
            &lt;a class="dropdown-item" href="#" data-field="name"&gt;名字&lt;/a&gt;
            &lt;a class="dropdown-item" href="#" data-field="downloads"&gt;下载量&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/t&gt;
</pre> </td></tr></tbody></table> 
<p>在<code>eview_controller.js</code>中修改<code>renderButtons</code>函数，渲染按钮组并为它们绑定事件</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre> </td><td> <pre>renderButtons: function ($node) {
    console.log("eview controller &gt;&gt;&gt; renderButtons");
    this._super.apply(this, arguments);
    this.$buttons = $(qweb.render('echart_views.buttons'));
    this.$measureList = this.$buttons.find('.o_echart_measures_list');
    this.$buttons.click(this._onButtonClick.bind(this));
    this.$buttons.appendTo($node);
},

....

_onButtonClick: function (event) {
    var $target = $(event.target);
    var field;
    if ($target.parents('.o_echart_measures_list').length) {
        event.preventDefault();
        event.stopPropagation();
        field = $target.data('field');
        _.each(this.$measureList.find('.dropdown-item'), function (item) {
            var $item = $(item);
            $item.toggleClass('selected', $item.data('field') === field);
        });
    }
},
</pre> </td></tr></tbody></table> 
<p>再次进入页面，我们可以发现导航栏部分多了 ‘统计字段’下拉按钮，点击相关选项，按钮组就会处于激活状态</p> 
<p style="text-align:center;"><img alt="alt" src="https://images2.imgbox.com/1d/81/a8w0K0pn_o.png"></p> 
<h3 id="获取视图定义结构信息">获取视图定义结构信息</h3> 
<blockquote> 
 <p>可以通过<code>git checkout v0.4</code>查看本章节的完整代码</p> 
</blockquote> 
<p>刚刚我们的例子中按钮组的数组是写死的，现在我们来做一些改动，把这部分修改成根据我们定义在xml的字段动态生成下拉菜单。</p> 
<p>在我们使用Odoo原生xml定义的field中，是可以自定义添加属性，并且odoo对应会有不一样的行为，比如加上<code>invisible=1</code>时，该字段在视图中会自动隐藏，现在我们也为<code>eview</code>视图中做一些类似的自定义属性处理，我们增加一个<code>type</code>属性，<code>type="name"</code>代表这个字段是记录的显示名字，<code>type="measure"</code>代表这个字段是可加入我们按钮组的下拉菜单中。</p> 
<p>现在我们打开<code>views/views.xml</code>，修改<code>eview</code>的视图，为<code>field</code>加上<code>type</code>属性, 此外 也为<code>eview</code>加上一个<code>chart="bar"</code>属性</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
</pre> </td><td> <pre>&lt;record id="echart_views_game_view_eview" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Game echart view&lt;/field&gt;
    &lt;field name="model"&gt;echart_views.game&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
        &lt;eview chart="bar"&gt;
            &lt;field name="name" type="name"/&gt;
            &lt;field name="downloads" type="measure"/&gt;
            &lt;field name="platform" type="measure"/&gt;
        &lt;/eview&gt;
    &lt;/field&gt;
&lt;/record&gt;
</pre> </td></tr></tbody></table> 
<p>之前提的介绍中提到过视图的结构信息都是会传入<code>View</code>的init方法中,其中<code>this.arch</code>包含Odoo的已经为我们解析好的视图结构化数据,<code>this.fields</code>则包含对应模型中全部字段的信息(包括魔法字段)，在<code>debug=assets</code>控制台打断点输出，我们可以轻松看到完整的结构。</p> 
<p style="text-align:center;"><img alt="alt" src="https://images2.imgbox.com/5a/93/REShqTWD_o.png"></p> 
<p>知道了数据结构后剩下的事就简单多了，我们自定义三个参数<code>displayNameField</code>, <code>measure</code>, <code>measures</code>，分别表示哪个字段对应记录的显示名称，视图当前所选择的统计字段，统计字段的所对应字段定义信息。其中<code>measure</code>, <code>measures</code>会在下章节中使用到。<br> 现在我们回到<code>eview_view.js</code>,修改<code>init</code>方法为如下：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre> </td><td> <pre>init: function (viewInfo, params) {
    console.log("eview view &gt;&gt;&gt; init");
    this._super.apply(this, arguments);

    var self = this;
    var displayNameField;
    var measure;
    var measures = {};

    this.arch.children.forEach(function (field) {
        var fieldName = field.attrs.name;
        if (field.attrs.type === 'measure') {
            if (!measure) {
                measure = fieldName;
            }
            measures[fieldName] = self.fields[fieldName];
        } else if(field.attrs.type === 'name') {
            displayNameField = fieldName;
        }
    });

    this.controllerParams.measures = measures;
},
</pre> </td></tr></tbody></table> 
<p>这段代码中最后一句<code>this.controllerParams.measures = measures;</code>代表我们为<code>Controller</code>的初始参数中添加<code>measures</code>属性，这样我们可以在<code>Controller</code>获取到<br><code>measures</code>数据，到时就可使用这部分数据来渲染模板。<br> 接着我们打开<code>eview_controller.js</code>在<code>init</code>中接收<code>measures</code>字段，并在<code>renderButtons</code>使用这部分数据渲染视图：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre> </td><td> <pre>init: function (parent, model, renderer, params) {
    console.log("eview controller &gt;&gt;&gt; init");
    this._super.apply(this, arguments);
    this.measures = params.measures;
}

....

renderButtons: function ($node) {
    console.log("eview controller &gt;&gt;&gt; renderButtons");
    this._super.apply(this, arguments);
    var context = {
            measures: _.sortBy(_.pairs(this.measures), function (x) {
                return x[1].string.toLowerCase();
            }),
        };
    this.$buttons = $(qweb.render('echart_views.buttons', context));

    .....
},
</pre> </td></tr></tbody></table> 
<p>最后打开<code>xml/qweb_template.xml</code>,将下拉选项部分改成模板语法渲染</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
</pre> </td><td> <pre>&lt;div class="dropdown-menu o_echart_measures_list" role="menu"&gt;
    &lt;t t-foreach="measures" t-as="measure"&gt;
        &lt;a role="menuitem" href="#" class="dropdown-item" t-att-data-field="measure[0]"&gt;&lt;t t-esc="measure[1].string"/&gt;&lt;/a&gt;
    &lt;/t&gt;
&lt;/div&gt;
</pre> </td></tr></tbody></table> 
<p>此时重启Odoo并更新模块，再次进入视图我们可以发现统计字段的选项改变了，我们也可以自行尝试在xml中去除相关<code>field</code>，统计字段的选项也会对应动态改变。</p> 
<h3 id="通过Model在页面中传递数据">通过Model在页面中传递数据</h3> 
<blockquote> 
 <p>可以通过<code>git checkout v0.5</code>查看本章节的完整代码</p> 
</blockquote> 
<p>在视图操作用经常会改变数据，数据改变后我们需要及时处理相关数据并更新视图，在这章里我们将改进按钮组的相关处理，当点击选项时，数据会更新到model中并实时更新我们的视图页面。</p> 
<p>回到<code>eview_view.js</code>,在<code>init</code>末尾加上<code>model</code>的初始参数</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
</pre> </td><td> <pre>init: function (viewInfo, params) {

    ...

    this.loadParams.measure = measure;
    this.loadParams.measures = measures;
    this.loadParams.displayNameField = displayNameField || 'display_name';
},
</pre> </td></tr></tbody></table> 
<p>然后打开<code>eview_model.js</code>，在<code>load</code>和<code>reload</code>的方法中增加获取相关字段值逻辑,同时修改<code>get</code>方法为返回相关字段数据,这里返回数据的部分设置<code>measureString</code>字段来返回对应字段的定义名称。</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre> </td><td> <pre>get: function () {
    console.log("eview model &gt;&gt;&gt; get");
    var measureString = this.measures[this.measure]['string'];
    return {measure: this.measure, measureString: measureString};
},
load: function (params) {
    console.log("eview model &gt;&gt;&gt; load");
    this.measure = params.measure;
    this.measures = params.measures;
    this.displayNameField = params.displayNameField;
    return this._super.apply(this, arguments);
},
reload: function (handle, params) {
    console.log("eview model &gt;&gt;&gt; reload");
    if ('measure' in params) {
        this.measure = params.measure;
    }
    return this._super.apply(this, arguments);
},
</pre> </td></tr></tbody></table> 
<p>同时我们要修改<code>Controller</code>的逻辑，当有数据变动时，我们需要通过调用<code>update</code>方法来更新数据，<code>update</code>会自动代入参数调用<code>model</code>中的<code>reload</code>方法，<br> 同时，触发视图的<code>_render</code>方法重新渲染数据。现在我们稍微修改下<code>_onButtonClick</code>的逻辑</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre> </td><td> <pre>_onButtonClick: function (event) {
    var $target = $(event.target);
    var field;
    if ($target.parents('.o_echart_measures_list').length) {
        event.preventDefault();
        event.stopPropagation();
        field = $target.data('field');
        this._setMeasure(field);
    }
},
_setMeasure: function (measure) {
    var self = this;
    this.update({measure: measure}).then(function () {
        self._updateButtons();
    });
},
_updateButtons: function () {
    if (!this.$buttons) {
        return;
    }
    var state = this.model.get();
    _.each(this.$measureList.find('.dropdown-item'), function (item) {
        var $item = $(item);
        $item.toggleClass('selected', $item.data('field') === state.measure);
    });
},
</pre> </td></tr></tbody></table> 
<p>这里把逻辑拆成了两个方法，一个是<code>_updateButtons</code>，他会通过<code>model.get()</code>来获取当前的数据，然后激活下拉菜单的选项状态，另外一个是<code>_setMeasure</code>，<br> 这个方法的逻辑也很简单，就是对<code>update</code>的一个封装。此外我们再把<code>_updateButtons</code>方法也放在<code>renderButtons</code>中调用下，这样初次加载视图时也会有默认的选项激活状态</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
</pre> </td><td> <pre>renderButtons: function ($node) {
    ...
    this._updateButtons();
    this.$buttons.appendTo($node);
},
</pre> </td></tr></tbody></table> 
<p>最后我们要修改下<code>renderer</code>里面的<code>_render</code>方法，根据<code>model</code>里面的数据来渲染页面。我们为<code>option</code>增加个<code>title</code>属性，并在<code>_render</code>方法中设置这个属性</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre> </td><td> <pre>this.echart_option = {
    ...
    title: {
        text: '',
        left: 'center',
        top: 20,
        textStyle: {
            color: '#ccc'
        }
    },
};

....

_render: function () {
    console.log("eview renderer &gt;&gt;&gt; _render");
    this.$el.empty();

    this.echart_option.title.text = this.state.measureString;
    ....
},
</pre> </td></tr></tbody></table> 
<p>Odoo会自动把从<code>model.get()</code>的数据放到<code>this.state</code>中，直接获取即可。</p> 
<p>刷新页面，此时我们我们可以看到点击下拉选项时，页面会刷新，同时上方标题属性会显示对应字段的定义名。</p> 
<p style="text-align:center;"><img alt="alt" src="https://images2.imgbox.com/1e/2f/dMr4idwn_o.png"></p> 
<h3 id="在Model向后台请求数据">在Model向后台请求数据</h3> 
<blockquote> 
 <p>可以通过<code>git checkout v0.6</code>查看本章节的完整代码</p> 
</blockquote> 
<p>到目前为止，我们基本完成了视图的基本功能了，接下来我们要增加<code>model</code>的逻辑，向后台获取再渲染显示。在<code>eview_model.js</code>中新增一个<code>_fetchData</code>方法获取数据，同时在其他需要获取数据的方法中调用这个函数。</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre> </td><td> <pre>get: function () {
    console.log("eview model &gt;&gt;&gt; get");
    return this.data;
},
load: function (params) {
    console.log("eview model &gt;&gt;&gt; load");
    this.modelName = params.modelName;
    this.domain = params.domain || [];
    this.measure = params.measure;
    this.measures = params.measures;
    this.displayNameField = params.displayNameField;
    return this._fetchData();
},
reload: function (handle, params) {
    console.log("eview model &gt;&gt;&gt; reload");
    if ('measure' in params) {
        this.measure = params.measure;
    }
    if ('domain' in params) {
        this.domain = params.domain;
    }
    return this._fetchData();
},
_fetchData: function () {
    var self = this;
    var measureFieldInfo = this.measures[this.measure];
    var measureString = measureFieldInfo['string'];
    var seriesLegend = [];
    if (measureFieldInfo.type === 'integer') {
        return this._rpc({
            model: this.modelName,
            method: 'search_read',
            domain: this.domain,
            fields: [this.measure, this.displayNameField],
        }).then(function (result) {
            var seriesData = _.map(result, function (data) {
                return {value: data[self.measure], name: data[self.displayNameField]}
            });
            _.each(seriesData, function (d) {
                seriesLegend.push(d['name']);
            });
            self.data = {seriesData: seriesData, measureString: measureString, measure: self.measure, seriesLegend: seriesLegend};
        });
    } else {
        return this._rpc({
            model: this.modelName,
            method: 'search_read',
            domain: this.domain,
            fields: [this.measure],
        }).then(function (result) {
            var resGroupAndCount = _.pairs(_.countBy(result, function(o){return o[self.measure]}));
            var seriesData = _.map(resGroupAndCount, function (data) {
                return {value: data[1], name: data[0]}
            });
            _.each(seriesData, function (d) {
                seriesLegend.push(d['name']);
            });
            self.data = {seriesData: seriesData, measureString: measureString, measure: self.measure, seriesLegend:seriesLegend};
        });
    }
},
</pre> </td></tr></tbody></table> 
<p>这段代码中在初始化数据中加入Odoo参数中的模型名<code>modelName</code>,和搜索框的内容<code>domain</code>，之后通过<code>_rpc</code>方法调用模型自带的<code>search_read</code>获取字段数据，接着在根据字段类型进行分类统计把数据归纳出来放入<code>self.data</code>中。<br> 之后在<code>eview_renderer.js</code>里把<code>option</code>的<code>data</code>部分删除，接着和上个章节一样，在<code>_renderer</code>设置相关字段。</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
</pre> </td><td> <pre>...
this.echart_option.title.text = this.state.measureString;
this.echart_option.series[0].name = this.state.measureString;
this.echart_option.series[0].data = this.state.seriesData;
this.echart_option.legend.data = this.state.seriesLegend;
...
</pre> </td></tr></tbody></table> 
<p>完成后刷新页面再次进入视图，点击选项Odoo会自动从后台获取对应字段的数据，同时右上角的搜索框我们也可以自由输入数据过滤结果。</p> 
<p style="text-align:center;"><img alt="alt" src="https://images2.imgbox.com/3c/d6/9TLUHwz2_o.png"></p> 
<h3 id="让Crontroller处理组件自定义事件">让Crontroller处理组件自定义事件</h3> 
<blockquote> 
 <p>可以通过<code>git checkout v0.7</code>查看本章节的完整代码</p> 
</blockquote> 
<p>在之前的绑定点击事件是指针对按钮组的，实际上当<code>renderer</code>为我们渲染好页面的时候，我们也会有要处理页面相关事件的要求，这个实际上也很简单：<br> 在<code>qweb_template.xml</code>中div上方我们新增一个按钮：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
</pre> </td><td> <pre>&lt;div class="container-fluid mt-3"&gt;
    &lt;button class="btn btn-primary ml-2" id="reloadView"&gt;重新加载&lt;/button&gt;
    &lt;div id="app" class="mt-2" style="width: 800px;height:500px;"&gt;
        &lt;p&gt;echart&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre> </td></tr></tbody></table> 
<p>然后在<code>eview_renderer.js</code>中加入事件注册和相关处理函数:</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
11
</pre> </td><td> <pre>events: _.extend({}, AbstractRenderer.prototype.events, {
    'click #reloadView': '_onClickReloadView',
}),

...

_onClickReloadView: function (ev) {
    ev.preventDefault();
    console.log("eview renderer &gt;&gt;&gt; _onClickReloadView");
    
}
</pre> </td></tr></tbody></table> 
<p>这时刷新页面点击按钮，可以看到控制台的对应输出。但是这只能处理特定元素上的事件，有时候我们会希望点击后整个视图能响应到变化，做一些特别的处理，这时候就要主动触发一个<code>OdooEvent</code>，同时<code>Controller</code>里面加入对应事件处理，比如接下来的代码中就实现了点击按钮让视图重新加载的功能：</p> 
<p>修改<code>renderer</code>中的<code>_onClickReloadView</code>函数，在里面主动通过<code>trigger_up</code>触发一个<code>OdooEvent</code></p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
</pre> </td><td> <pre>_onClickReloadView: function (ev) {
    ev.preventDefault();
    console.log("eview renderer &gt;&gt;&gt; _onClickReloadView");
    this.trigger_up('reload_view');
    
}
</pre> </td></tr></tbody></table> 
<p>在<code>eview_controller.js</code>中加入相关事件处理：</p> 
<table><tbody><tr><td> <pre>1
2
3
4
5
6
7
8
9
10
</pre> </td><td> <pre>custom_events: _.extend({}, AbstractController.prototype.custom_events, {
    'reload_view': '_onClickReloadView',
}),

...

_onClickReloadView: function (ev) {
    console.log("eview controller &gt;&gt;&gt; _onClickReloadView");
    this.reload();
},
</pre> </td></tr></tbody></table> 
<p>再次刷新页面点击按钮，可以看到<code>echart</code>的饼图会重新载入。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d838f2edfa1f8876661f54b5eb91b70e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在 Odoo 中添加自定义dashboard页面</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9b48c424645ae3105b55487c9fca7c1f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Odoo多公司指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>