<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;八股文--基础详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;八股文--基础详解" />
<meta property="og:description" content="目录
1. 智能指针
2. 内存分配
3. 指针参数传递和引用参数传递
4. 关键字static
5. 关键字const
7. 关键字define、const、typedef、inline
8. 重载、重写和重定义
9. 强制转换
10. 指针和引用
11. 野指针和悬空指针
12. 构造函数
13. 堆和栈
14. 函数传参
15. malloc/free和new/delete
16. volatile和extern
17. 类大小
18. 结构体内存对齐
19. 内存泄漏
20. 预处理、编译、汇编、链接
21. 命名空间
22. 模版
1. 智能指针 优点
（1）避免内存泄漏。底层维护一个类，作用域结束可以自动释放内存。
（2）共享指针便于传播和释放。例如多线程使用同一个对象时析构问题。
auto_ptr
（c&#43;&#43;98用，c&#43;&#43;11已放弃）。如下，p2剥夺了p1所有权，访问p1会报错。
auto_ptr&lt;std::string&gt; p1 (new string (&#34;hello&#34;)); auto_ptr&lt;std::string&gt; p2; p2 = p1; unique_ptr
独占所有权的指针，即同一时间只能有一个std::unique_ptr指向同一个对象。如下，P4 = P3会报错，因为P3不能再指向有效数据。
unique_ptr&lt;string&gt; p3 (new string (auto)); unique_ptr&lt;string&gt; p4; p4 = p3; shared_ptr" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/91e8e60f15d8b5648eae2a6700ec64a7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T14:55:21+08:00" />
<meta property="article:modified_time" content="2024-01-05T14:55:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;八股文--基础详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#1.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88" rel="nofollow">1. 智能指针</a></p> 
<p id="2.%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-toc" style="margin-left:0px;"><a href="#2.%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" rel="nofollow">2. 内存分配</a></p> 
<p id="3.%20%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-toc" style="margin-left:0px;"><a href="#3.%20%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" rel="nofollow">3. 指针参数传递和引用参数传递</a></p> 
<p id="4.%20%E5%85%B3%E9%94%AE%E5%AD%97static-toc" style="margin-left:0px;"><a href="#4.%20%E5%85%B3%E9%94%AE%E5%AD%97static" rel="nofollow">4. 关键字static</a></p> 
<p id="5.%20%E5%85%B3%E9%94%AE%E5%AD%97const-toc" style="margin-left:0px;"><a href="#5.%20%E5%85%B3%E9%94%AE%E5%AD%97const" rel="nofollow">5. 关键字const</a></p> 
<p id="7.%20%E5%85%B3%E9%94%AE%E5%AD%97define%E3%80%81const%E3%80%81typedef%E3%80%81inline-toc" style="margin-left:0px;"><a href="#7.%20%E5%85%B3%E9%94%AE%E5%AD%97define%E3%80%81const%E3%80%81typedef%E3%80%81inline" rel="nofollow">7. 关键字define、const、typedef、inline</a></p> 
<p id="8.%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E5%AE%9A%E4%B9%89-toc" style="margin-left:0px;"><a href="#8.%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E5%AE%9A%E4%B9%89" rel="nofollow">8. 重载、重写和重定义</a></p> 
<p id="9.%20%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2-toc" style="margin-left:0px;"><a href="#9.%20%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2" rel="nofollow">9. 强制转换</a></p> 
<p id="10.%20%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8-toc" style="margin-left:0px;"><a href="#10.%20%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8" rel="nofollow">10. 指针和引用</a></p> 
<p id="11.%20%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88-toc" style="margin-left:0px;"><a href="#11.%20%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88" rel="nofollow">11. 野指针和悬空指针</a></p> 
<p id="12.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-toc" style="margin-left:0px;"><a href="#12.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" rel="nofollow">12. 构造函数</a></p> 
<p id="13.%20%E5%A0%86%E5%92%8C%E6%A0%88-toc" style="margin-left:0px;"><a href="#13.%20%E5%A0%86%E5%92%8C%E6%A0%88" rel="nofollow">13. 堆和栈</a></p> 
<p id="14.%20%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82-toc" style="margin-left:0px;"><a href="#14.%20%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82" rel="nofollow">14. 函数传参</a></p> 
<p id="15.%C2%A0malloc%2Ffree%E5%92%8Cnew%2Fdelete-toc" style="margin-left:0px;"><a href="#15.%C2%A0malloc%2Ffree%E5%92%8Cnew%2Fdelete" rel="nofollow">15. malloc/free和new/delete</a></p> 
<p id="16.%20volatile%E5%92%8Cextern-toc" style="margin-left:0px;"><a href="#16.%20volatile%E5%92%8Cextern" rel="nofollow">16. volatile和extern</a></p> 
<p id="17.%20%E7%B1%BB%E5%A4%A7%E5%B0%8F-toc" style="margin-left:0px;"><a href="#17.%20%E7%B1%BB%E5%A4%A7%E5%B0%8F" rel="nofollow">17. 类大小</a></p> 
<p id="18.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90-toc" style="margin-left:0px;"><a href="#18.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90" rel="nofollow">18. 结构体内存对齐</a></p> 
<p id="19.%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F-toc" style="margin-left:0px;"><a href="#19.%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" rel="nofollow">19. 内存泄漏</a></p> 
<p id="20.%20%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5-toc" style="margin-left:0px;"><a href="#20.%20%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5" rel="nofollow">20. 预处理、编译、汇编、链接</a></p> 
<p id="21.%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-toc" style="margin-left:0px;"><a href="#21.%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" rel="nofollow">21. 命名空间</a></p> 
<p id="22.%20%E6%A8%A1%E7%89%88-toc" style="margin-left:0px;"><a href="#22.%20%E6%A8%A1%E7%89%88" rel="nofollow">22. 模版</a></p> 
<p></p> 
<h2 id="1.%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">1. 智能指针</h2> 
<p><strong>优点</strong></p> 
<p>（1）避免内存泄漏。底层维护一个类，作用域结束可以自动释放内存。</p> 
<p>（2）共享指针便于传播和释放。例如多线程使用同一个对象时析构问题。</p> 
<p><strong>auto_ptr</strong></p> 
<p>（c++98用，c++11已放弃）。如下，p2剥夺了p1所有权，访问p1会报错。</p> 
<pre><code class="language-cpp">auto_ptr&lt;std::string&gt; p1 (new string ("hello"));
auto_ptr&lt;std::string&gt; p2;
p2 = p1;</code></pre> 
<p><strong>unique_ptr</strong></p> 
<p>独占所有权的指针，即同一时间只能有一个std::unique_ptr指向同一个对象。如下，P4 = P3会报错，因为P3不能再指向有效数据。</p> 
<pre><code class="language-cpp">unique_ptr&lt;string&gt; p3 (new string (auto));
unique_ptr&lt;string&gt; p4;
p4 = p3;</code></pre> 
<p><strong>shared_ptr</strong></p> 
<p>共享所有权的指针，即可以有多个std::shared_ptr指向同一个对象。有两个指针，一个指向堆内存中的对象，另一个指向共享实例的引用计数器。</p> 
<p>引用计数器</p> 
<ul><li>每次调用shared_ptr的<strong>复制构造函数</strong>时，引用计数器+1。</li><li>每次调用shared_ptr的赋值运算符时，右侧指针计数器+1，左侧指针计数器-1。</li><li>每次调用shared_ptr的析构函数时，计数器均-1。</li><li>计数器为0时，删除该对象。</li></ul> 
<p><strong>weak_ptr</strong></p> 
<p>弱引用指针，即一个std::weak_ptr指向一个std::shared_ptr所管理的对象，但不会增加引用计数。</p> 
<h2 id="2.%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">2. 内存分配</h2> 
<p>栈：存放局部变量和函数参数，编译器管理内存分配和回收。</p> 
<p>堆：程序员管理，手动new/delete或malloc/free，容易造成内存泄漏。</p> 
<p>全局、静态存储区：存储初始化/未初始化的全局变量和静态变量，有初始化和未初始化两个区域。</p> 
<p>代码区：存放二进制代码。</p> 
<p>一维数组动态分配释放代码示例：</p> 
<pre><code>// 动态分配,数组长度为 m
int *array=new int [m];
 
//释放内存
delete [] array;</code></pre> 
<p>二维数组动态分配释放代码示例：</p> 
<pre><code>int **array;
array = new int *[m];
for(int i = 0; i &lt; m; i++ ) {
    array[i] = new int [n];
}
//释放
for(int i = 0; i &lt; m; i++ ) {
    delete [] array[i];
}
delete [] array;</code></pre> 
<p>对象动态分配释放代码示例：</p> 
<pre><code>#include &lt;iostream&gt;
using namespace std;
 
class Box {
   public:
      Box() { 
         cout &lt;&lt; "调用构造函数！" &lt;&lt;endl; 
      }
      ~Box() { 
         cout &lt;&lt; "调用析构函数！" &lt;&lt;endl; 
      }
};
 
int main( )
{
   Box* myBoxArray = new Box[4];
 
   delete [] myBoxArray;
   return 0;
}</code></pre> 
<h2 id="3.%20%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">3. 指针参数传递和引用参数传递</h2> 
<p><strong>指针参数传递</strong></p> 
<p>本质是值传递，传递的是一个地址值，传递过程中，被调函数的形参作为被调函数的局部变量处理，在栈开辟空间存放有主调函数传递来的实参，从而形成实参副本。特点：被调函数对形参指针改变不影响主函数实参指针。</p> 
<p><strong>引用参数传递</strong></p> 
<p>被调函数形参也作为局部变量在栈中开辟了内存空间，存放的是主调函数放进来的实参变量的地址。特点：被调函数对形参指针改变会被处理成间接寻址，即通过栈中存储的地址找到实参，因此，被调函数对形参指针改变会影响主函数实参指针。</p> 
<h2 id="4.%20%E5%85%B3%E9%94%AE%E5%AD%97static">4. 关键字static</h2> 
<p><strong>修饰局部变量</strong></p> 
<p>局部变量一般存储于栈，static修饰的局部变量存储于静态数据区，生命周期会一直延续到整个程序结束，作用域未变还是在其语句块。</p> 
<p><strong>修饰全局变量</strong></p> 
<p>static修饰的全局变量仅在本文件可见。</p> 
<p><strong>修饰函数</strong></p> 
<p>static修饰函数，函数仅在本文件可见。</p> 
<p><strong>修饰类</strong></p> 
<p>static修饰类成员变量，则对应成员变量属于整个类而不是对象，没有this指针(this指向本对象)，需要在类外初始化，供所有对象共享节省内存，并且只能访问static修饰的类成员。</p> 
<p>static修饰类成员方法，则对应成员方法属于整个类而不是对象，没有this指针，并且只能访问静态成员。</p> 
<h2 id="5.%20%E5%85%B3%E9%94%AE%E5%AD%97const">5. 关键字const</h2> 
<p>修饰基本数据类型：使用过程中不可改变常量值</p> 
<p>修饰指针变量：const int* p1，指向整形常量。const int* const p3，指向整形常量的常量指针。</p> 
<p>修饰引用变量：int* const p2，指向整形的常量指针。</p> 
<p>修饰函数：</p> 
<pre><code class="language-cpp">const int&amp; function(int&amp; x); //修饰返回值,返回值是引用,不能被修改
int&amp; function(const int&amp; x); //修饰形参
int&amp; function(int&amp; x) const{} //const成员函数,保证对象成员不被修改,可以访问非const和const的数据成员和变量，可以被重载; 如果成员是指针，则不能保证对象成员不被修改</code></pre> 
<h2 id="7.%20%E5%85%B3%E9%94%AE%E5%AD%97define%E3%80%81const%E3%80%81typedef%E3%80%81inline">7. 关键字define、const、typedef、inline</h2> 
<p>define：编译阶段处理，无类型，无类型检查，遇到就展开。</p> 
<p>const：编译期间处理，有类型，有类型检查。const常量在出现的地方保留真正的数据，编译器有时不为const常量分配内存，直接将const常量添加到表中，省去读写内存，效率更高。</p> 
<p>typedef：定义类型别名；与struct结合，定义类型；编译阶段有效，有类型检查；</p> 
<p>inline：内联函数，调用时进行替换；有类型检查；</p> 
<h2 id="8.%20%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E5%AE%9A%E4%B9%89">8. 重载、重写和重定义</h2> 
<p>重载：overload，函数同名，参数列表不同。</p> 
<p>重写：override，子类重写父类中的虚函数(同名，同参数列表，同返回等)。</p> 
<p>重定义：子类重新定义父类中同名非虚函数，可修改参数列表。</p> 
<h2 id="9.%20%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">9. 强制转换</h2> 
<p>static_cast：转换类型明确；无动态类型检查；派生类转基类安全，所以主要适用于非多态。</p> 
<p>dynamic_cast：动态派生类间转换；type id必须是类指针、类引用或void*；转换安全，类型不一致转换为空指针。</p> 
<p>const_cast：专用于const类型去除或增加；</p> 
<p>reinterpret_cast：整形转指针引用；指针转数组；指针引用间转换；指针引用转整形。</p> 
<h2 id="10.%20%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8">10. 指针和引用</h2> 
<p>指针是一个实体，引用是一个别名。</p> 
<p>指针：独立的变量；有const；可以有多级；可为空；存放地址；编译时添加“指针变量名-指针变量地址”，允许拷贝和赋值；sizeof得到指针类型大小。</p> 
<p>引用：依赖原变量的内存别名；无const；只有1级；编译时，将“引用变量名-引用对象地址”添加到符号表，之后从一而终，不能引用其他数据；sizeof得到所引用对象大小。</p> 
<h2 id="11.%20%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88">11. 野指针和悬空指针</h2> 
<p>野指针：没被初始化的指针。</p> 
<p>悬空指针：指针指向的内存被回收，指针仍然指向这块内存。</p> 
<h2 id="12.%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">12. 构造函数</h2> 
<p>创建类的对象时，编译器会为对象分配内存空间，自动调用构造函数初始化对象成员。</p> 
<p>默认构造函数：一个类没有构造函数，生成默认构造函数条件为：有一个类类型成员变量，继承自含有默认构造函数的基类，继承或声明了虚函数，含有虚基类。</p> 
<p>普通构造函数：创建新对象，初始化成员。</p> 
<p>拷贝构造函数：用一个对象去初始化同类的另一个对象；函数F的参数是类A的对象，F被调用时候；函数F的参数返回值是类A的对象，F返回时。</p> 
<p>转换构造函数：一个构造函数接受一个不同于其类类型的形参，可视为将形参转换成类的一个对象</p> 
<p>移动构造函数：将其它对象拥有的资源内存移位己用。</p> 
<p>赋值运算符重载：=右边的本类对象的值赋值给=左边的对象。</p> 
<pre><code class="language-cpp">A a1, A a2; a1 = a2; // 赋值运算符重载
A a3 = a1; // 拷贝构造函数</code></pre> 
<h2 id="13.%20%E5%A0%86%E5%92%8C%E6%A0%88">13. 堆和栈</h2> 
<p>堆：程序员手动malloc和free或new和delete，如果不及时回收会造成内存泄漏；空间不连续；低地址向高地址扩展；空间较大较灵活；</p> 
<p>栈：需要时编译器分配，不需要时自动回收；连续的存储空间；高地址向低地址扩展；空间较小。</p> 
<h2 id="14.%20%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82">14. 函数传参</h2> 
<p>值传递：形参是实参的拷贝。</p> 
<p>指针传递：值传递的一种，形参指向实参地址。</p> 
<p>引用传递：引用对象的地址放在栈空间。形参任何操作都可以直接映射到外部实参。</p> 
<h2 id="15.%C2%A0malloc%2Ffree%E5%92%8Cnew%2Fdelete">15. malloc/free和new/delete</h2> 
<p>区别：new/delete是操作符，可执行构造函数和析构函数；malloc/free是库函数，不在编译器控制权限之内。</p> 
<p>new：分配未初始化的空间；用对象的构造函数对空间初始化。</p> 
<p>delete：使用析构函数对对象析构；回收内存空间。</p> 
<p>malloc：分配空间。</p> 
<p>free：释放空间。</p> 
<h2 id="16.%20volatile%E5%92%8Cextern">16. volatile和extern</h2> 
<p>volatile：易变性，下一条语句不回去用上一条语句里volatile变量的寄存器内容；不可优化型，不可优化和删除；顺序性，编译器不会进行重排乱序优化。</p> 
<p>extern：C加此声明，表示此变量、函数在别处定义，在此引用；C++中除此之外还有一个规范性作用，即C++调用C库函数需要“extern C”。</p> 
<h2 id="17.%20%E7%B1%BB%E5%A4%A7%E5%B0%8F">17. 类大小</h2> 
<pre><code class="language-cpp">class A{}; sizeof(A) = 1;
class A{virtual Fun(){} }; sizeof(A) = 4(32bit)/8(64bit); // 指向虚函数表
class A{static int a; }; sizeof(A) = 1;
class A{int a; }; sizeof(A) = 4;
class A{static int a; int b; }; sizeof(A) = 4;</code></pre> 
<h2 id="18.%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90">18. 结构体内存对齐</h2> 
<p>结构体第一个成员偏移为0；之后每个成员偏移min(#pragma pack()指定数，数据成员本身长度)；结构体本身也要进行对齐。</p> 
<p>对齐原因：CPU内存访问速度提升；减少额外操作，举例开始存储1字节，读取0-3，读取4，删除0；CPU有时候拒绝处理未内存对齐的数据。</p> 
<h2 id="19.%20%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">19. 内存泄漏</h2> 
<p>申请一块内存空间，使用完毕后未释放，但是指向此空间的指针已被回收，长期以往，这样的空间越来越多，再申请新空间空间不够时，系统崩溃。</p> 
<h2 id="20.%20%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5" style="background-color:transparent;">20. 预处理、编译、汇编、链接</h2> 
<p>预处理：删除#define，展开宏定义，处理所有条件编译指令，处理所有预编译指令，删除所有注释，添加行号和文件名标识。</p> 
<p>编译：源码转换为机器语言，转化为相应的汇编文件。静态编译：编译时候将对应链接库中的函数链接到可执行文件。动态链接：执行时，调用对应的动态链接库的命令。</p> 
<p>汇编：调用汇编器将汇编代码转换为机器可执行的指令。</p> 
<p>链接：将所有.o和库链接在一起，得到可执行文件。</p> 
<h2 id="21.%20%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">21. 命名空间</h2> 
<p>命名空间定义：作为附加信息区分不同库中相同名称的函数、类、变量等。</p> 
<p>代码示例：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
using namespace std;
 
// 第一个命名空间
namespace first_space{
   void func() {
      cout &lt;&lt; "Inside first_space" &lt;&lt; endl;
   }
}
// 第二个命名空间
namespace second_space{
   void func() {
      cout &lt;&lt; "Inside second_space" &lt;&lt; endl;
   }
}
using namespace first_space;
int main () {
   func();
   return 0;
}</code></pre> 
<h2 id="22.%20%E6%A8%A1%E7%89%88">22. 模版</h2> 
<p>模板：创建泛型编程类或函数。</p> 
<p>代码示例：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
 
template &lt;typename T&gt;
inline T const&amp; Max (T const&amp; a, T const&amp; b) { 
    return a &lt; b ? b:a; 
} 
int main () {
 
    int i = 39;
    int j = 20;
    cout &lt;&lt; "Max(i, j): " &lt;&lt; Max(i, j) &lt;&lt; endl; 
 
    double f1 = 13.5; 
    double f2 = 20.7; 
    cout &lt;&lt; "Max(f1, f2): " &lt;&lt; Max(f1, f2) &lt;&lt; endl; 
    return 0;
}</code></pre> 
<p>类模板代码示例：</p> 
<pre><code class="hljs">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt; 
using namespace std;
 
template &lt;class T&gt;
class Stack { 
  private: 
    vector&lt;T&gt; elems;     // 元素 
 
  public: 
    void push(T const&amp;);  // 入栈
    void pop();               // 出栈
    T top() const;            // 返回栈顶元素
    bool empty() const{       // 如果为空则返回真。
        return elems.empty(); 
    } 
}; 
 
template &lt;class T&gt;
void Stack&lt;T&gt;::push (T const&amp; elem) { 
    elems.push_back(elem);    
} 
 
template &lt;class T&gt;
void Stack&lt;T&gt;::pop () { 
    if (elems.empty()) { 
        throw out_of_range("Stack&lt;&gt;::pop(): empty stack"); 
    }
    elems.pop_back();         
} 
 
template &lt;class T&gt;
T Stack&lt;T&gt;::top () const { 
    if (elems.empty()) { 
        throw out_of_range("Stack&lt;&gt;::top(): empty stack"); 
    }
    // 返回最后一个元素
    return elems.back();      
} 
 
int main() { 
    try { 
        Stack&lt;int&gt;         intStack;  // int 类型的栈 
        Stack&lt;string&gt; stringStack;    // string 类型的栈 
 
        intStack.push(7); 
        cout &lt;&lt; intStack.top() &lt;&lt;endl; 
 
        stringStack.push("hello"); 
        cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; 
        stringStack.pop(); 
        stringStack.pop(); 
    } 
    catch (exception const&amp; ex) { 
        cerr &lt;&lt; "Exception: " &lt;&lt; ex.what() &lt;&lt;endl; 
        return -1;
    } 
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f42c8fbff53bb07d636bd161323b33d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;八股文详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1544a06aa3f795a3a87557373bd56cb9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数字逻辑电路入门：从晶体管到逻辑门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>