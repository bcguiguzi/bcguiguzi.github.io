<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Opencv的基础操作 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Opencv的基础操作" />
<meta property="og:description" content="一、图像填充 首先定义图像显示函数：
def cv_show(name, img): cv2.imshow(name, img) cv2.waitKey(0) cv2.destroyAllWindows() 图像读取：
img_cat = cv2.imread(&#39;cat.jpg&#39;) 定义图像填充的大小：
top_size, bottom_size, left_size, right_size = (50, 50, 50, 50) 接下来分别采用复制法、反射法、外包装法、常量法进行填充。
复制法：
# 复制法，复制最边缘像素 replicate = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE) 反射法： # 反射法，对感兴趣的图像中的像素在两边进行复制 reflect = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REFLECT) 第二种反射法
# 反射法，也就是以最边缘像素为周，对称 reflect101 = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REFLECT_101) 外包装法：
# 外包装法 warp = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_WRAP) 常量法：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/60e4fa040d97a9126da3f6e5c1841e1d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-08T21:14:01+08:00" />
<meta property="article:modified_time" content="2022-12-08T21:14:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Opencv的基础操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>一、图像填充</strong></h2> 
<p>首先定义图像显示函数：</p> 
<pre><code class="language-python">def cv_show(name, img):
    cv2.imshow(name, img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()</code></pre> 
<p>图像读取：</p> 
<pre><code class="language-python">img_cat = cv2.imread('cat.jpg')</code></pre> 
<p>定义图像填充的大小：</p> 
<pre><code class="language-python">top_size, bottom_size, left_size, right_size = (50, 50, 50, 50)</code></pre> 
<p> 接下来分别采用复制法、反射法、外包装法、常量法进行填充。</p> 
<p>复制法：</p> 
<pre><code class="language-python"># 复制法，复制最边缘像素
replicate = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)</code></pre> 
<p>反射法： </p> 
<pre><code class="language-python"># 反射法，对感兴趣的图像中的像素在两边进行复制
reflect = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REFLECT)</code></pre> 
<p>第二种反射法</p> 
<pre><code class="language-python"># 反射法，也就是以最边缘像素为周，对称
reflect101 = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size,
                                borderType=cv2.BORDER_REFLECT_101)</code></pre> 
<p>外包装法：</p> 
<pre><code class="language-python"># 外包装法
warp = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_WRAP)</code></pre> 
<p>常量法：</p> 
<pre><code class="language-python"># 常量法，常数值填充，此处填充灰色
constant = cv2.copyMakeBorder(img_cat, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_CONSTANT,
                              value=0)</code></pre> 
<p>输出结果对比如下：</p> 
<p><img alt="" height="681" src="https://images2.imgbox.com/fb/fa/S9lFYbWP_o.png" width="906"></p> 
<p> </p> 
<h2> 二、形态学操作</h2> 
<p>首先读入原始图像：</p> 
<pre><code class="language-python">pie = cv2.imread('pie.jfif')</code></pre> 
<p> <img alt="" height="171" src="https://images2.imgbox.com/0a/9c/rT1pHXmM_o.png" width="208"></p> 
<p> </p> 
<p>定义卷积核：</p> 
<pre><code class="language-python">kernel = np.ones((10, 10), np.uint8)</code></pre> 
<p>腐蚀函数：</p> 
<pre><code class="language-python">dige_erosion = cv2.erode(pie, kernel=kernel, iterations=1)</code></pre> 
<p>输出结果如下：</p> 
<p> <img alt="" height="162" src="https://images2.imgbox.com/d7/1a/8opJiH0F_o.png" width="197"></p> 
<p>膨胀函数：</p> 
<pre><code class="language-python">dige_dilate = cv2.dilate(pie, kernel=kernel, iterations=1)</code></pre> 
<p>输出结果如下：</p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/4e/fe/ERH5FaUt_o.png" width="204"></p> 
<p>开运算：先腐蚀后膨胀</p> 
<pre><code class="language-python">opening = cv2.morphologyEx(pie, cv2.MORPH_OPEN, kernel=kernel)</code></pre> 
<p>输出结果如下：</p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/d4/58/FLZEqTmO_o.png" width="211"></p> 
<p>闭运算：先膨胀后腐蚀</p> 
<pre><code class="language-python">closing = cv2.morphologyEx(pie, cv2.MORPH_CLOSE, kernel=kernel)</code></pre> 
<p>输出结果如下：</p> 
<p><img alt="" height="170" src="https://images2.imgbox.com/b2/38/5vxQGvD1_o.png" width="207"> </p> 
<p>梯度：膨胀-腐蚀</p> 
<pre><code class="language-python">gradient = cv2.morphologyEx(pie, cv2.MORPH_GRADIENT, kernel)</code></pre> 
<p>输出结果如下：</p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/16/0a/5We60jB9_o.png" width="206"></p> 
<p>礼帽：原始输入-开运算结果</p> 
<pre><code class="language-python">tophat = cv2.morphologyEx(pie, cv2.MORPH_TOPHAT, kernel)</code></pre> 
<p>输出结果如下：</p> 
<p><img alt="" height="171" src="https://images2.imgbox.com/23/0a/UnxWks5d_o.png" width="208"></p> 
<p>黑帽：闭运算-原始输入</p> 
<pre><code class="language-python">blackhat = cv2.morphologyEx(pie, cv2.MORPH_BLACKHAT, kernel)</code></pre> 
<p>输出结果如下：</p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/c6/b6/nURJOxfv_o.png" width="210"></p> 
<h2> 三、图像平滑</h2> 
<p>传入原始图像：</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/a4/25/Ucv7Y9Xh_o.png" width="208"></p> 
<p>均值滤波：简单的平均卷积操作</p> 
<pre><code class="language-python">blur = cv2.blur(cat, (3, 3))</code></pre> 
<p><img alt="" height="206" src="https://images2.imgbox.com/09/e0/ZImiEQ5I_o.png" width="206"></p> 
<p> 方框滤波：基本和均值一样，可以选择归一化, normalize为true时就做归一化，和均值滤波一样</p> 
<pre><code class="language-python">box = cv2.boxFilter(cat, -1, (3, 3), normalize=True)</code></pre> 
<p></p> 
<p> <img alt="" height="206" src="https://images2.imgbox.com/3d/79/K03bH4qP_o.png" width="206"></p> 
<p> normalize为False时不做归一化，及不做均值处理，越界后取255</p> 
<pre><code class="language-python">box = cv2.boxFilter(cat, -1, (3, 3), normalize=False)</code></pre> 
<p><img alt="" height="207" src="https://images2.imgbox.com/7a/8c/mdCULnlN_o.png" width="207"></p> 
<p> 高斯滤波：高斯模糊的卷积核里的数值是满足高斯分布的，相当于更重视中间的</p> 
<pre><code class="language-python">gaussian = cv2.GaussianBlur(cat, (3, 3), 1)</code></pre> 
<p><img alt="" height="212" src="https://images2.imgbox.com/2a/d1/WOHxB8i0_o.png" width="212"></p> 
<p>中值滤波：相当于用中值代替</p> 
<pre><code class="language-python">median = cv2.medianBlur(cat, 3)</code></pre> 
<p><img alt="" height="210" src="https://images2.imgbox.com/83/99/L9hSRSI3_o.png" width="210"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a640397c25a01311601d4c918460de1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023年最新最全Java面试八股文整理，不全你来打我</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad9247676b94b7c6ba42771c392ff235/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决404报错（关于servlet路径配置）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>