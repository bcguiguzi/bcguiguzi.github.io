<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>剑指 Offer 32 – II. 从上到下打印二叉树 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="剑指 Offer 32 – II. 从上到下打印二叉树" />
<meta property="og:description" content="剑指 Offer 32 - II. 从上到下打印二叉树 II
和上道题目剑指 Offer 32 – I. 从上到下打印二叉树相似，都是需要层次遍历二叉树，不同的是，需要将同一层的元素放在一个数组中。
为了将同一层的元素放到一个数组汇总，需要记录每一层的元素个数，可以直接通过队列的长度来获取。
// 登录 AlgoMooc 官网获取更多算法图解 // https://www.algomooc.com class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { // 设置 res 用来保存输出结果 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // 边界情况处理 if(root == null) return res; // 设置一个队列，用来存储二叉树中的元素 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); // 队列添加二叉树的根节点 queue.add(root); // 遍历队列，直到队列为空，说明访问了二叉树中所有的节点 while(!queue.isEmpty()){ // 用来记录 queue 的长度，即每层节点的个数 int size = queue.size(); // 用来保存每一层节点，保存成功后添加到 res 中 List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); // 使用 for 循环，将 queue 中的元素添加的 temp 中 for(int i = 0 ; i &lt; size ; i&#43;&#43; ){ // 从 queue 中取出一个节点 TreeNode node = queue." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6353912c5ea4c02a590ae6f1422f40b8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-26T21:55:03+08:00" />
<meta property="article:modified_time" content="2021-09-26T21:55:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">剑指 Offer 32 – II. 从上到下打印二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a class="link-info" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" rel="nofollow" title="剑指 Offer 32 - II. 从上到下打印二叉树 II">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></p> 
<p>和上道题目<a href="https://www.algomooc.com/450.html" rel="nofollow" title="剑指 Offer 32 – I. 从上到下打印二叉树">剑指 Offer 32 – I. 从上到下打印二叉树</a>相似，都是需要<strong>层次遍历二叉树</strong>，不同的是，需要将同一层的元素放在一个数组中。</p> 
<p>为了将同一层的元素放到一个数组汇总，需要记录每一层的元素个数，<strong>可以直接通过队列的长度来获取</strong>。</p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/d7/1f/1r27A5EE_o.png" width="445"></p> 
<p></p> 
<pre><code class="language-java">// 登录 AlgoMooc 官网获取更多算法图解
// https://www.algomooc.com
class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        // 设置 res 用来保存输出结果
        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
        // 边界情况处理
        if(root == null) return res;

        // 设置一个队列，用来存储二叉树中的元素
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        // 队列添加二叉树的根节点
        queue.add(root);

        // 遍历队列，直到队列为空，说明访问了二叉树中所有的节点
        while(!queue.isEmpty()){  
            // 用来记录 queue 的长度，即每层节点的个数
            int size = queue.size();  

            // 用来保存每一层节点，保存成功后添加到 res 中
            List&lt;Integer&gt; temp =  new ArrayList&lt;&gt;(); 

            // 使用 for 循环，将 queue 中的元素添加的 temp 中
            for(int i = 0 ; i &lt; size ;  i++ ){     
                // 从 queue 中取出一个节点         
                TreeNode node = queue.poll();  
                // 把节点存放到 list 中
                temp.add(node.val);  //将节点值加入list

                // 判断当前节点的左子节点是否有值，如果有，则添加到 queue 中
                if(node.left != null)
                    queue.add(node.left);

                // 判断当前节点的右子节点是否有值，如果有，则添加到 queue 中    
                if(node.right != null)
                    queue.add(node.right);
            }

            // 把存放了每一层元素的数组 temp 添加到 res 中
            res.add(temp);
        }

        // 返回 res
        return res;       
    }   
}

</code></pre> 
<p> </p> 
<p><a class="link-info" href="https://www.cnblogs.com/sierrajuan/p/3639353.html" rel="nofollow">ArrayList和LinkedList的区别</a></p> 
<blockquote> 
 <p>        ArrayList和Vector使用了数组的实现，可以认为ArrayList或者Vector封装了对内部数组的操作，比如向数组中添加，删除，插入新的元素或者数据的扩展和重定向。</p> 
 <p>        LinkedList使用了循环双向链表数据结构。与基于数组ArrayList相比，这是两种截然不同的实现技术，这也决定了它们将适用于完全不同的工作场景。</p> 
</blockquote> 
<p>        LinkedList链表由一系列表项连接而成。一个表项总是包含3个部分：元素内容，前驱表和后驱表，如图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/6a/2e/Z9gUyLjP_o.png"></p> 
<p>        在下图展示了一个包含3个元素的LinkedList的各个表项间的连接关系。在JDK的实现中，无论LikedList是否为空，链表内部都有一个header表项，它既表示链表的开始，也表示链表的结尾。表项header的后驱表项便是链表中第一个元素，表项header的前驱表项便是链表中最后一个元素。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bd/57/H2A0Xw6R_o.png"></p> 
<p><a class="link-info" href="https://www.cnblogs.com/pjhaymy/p/13254587.html" rel="nofollow">Java常用API(ArrayList类）</a></p> 
<blockquote> 
 <p>我们为什么要使用ArrayList类？</p> 
 <p>为了更加方便的储存对象，因为使用普通的数组来存储对象太过麻烦了，因为数组的一个很大的弱点就是长度从一开始就固定了，所以Java提供了另一个容器 java.util.ArrayList 集合类,让我们可以更便捷的存储和操作对象数据</p> 
 <p>什么是ArrayList?</p> 
 <p>所以从上面的介绍就可以看出所谓的ArrayList类就是一个长度可变的数组。</p> 
</blockquote> 
<p></p> 
<p><a class="link-info" href="https://blog.csdn.net/wszcy199503/article/details/89403829">ArrayList API</a></p> 
<blockquote> 
 <p>•ArrayList ( )<br> 构造一个空数组列表。</p> 
 <p><br> •ArrayList ( int initialCapacity)<br> 用指定容量构造一个空数组列表。<br> 参数：initalCapacity 数组列表的最初容量</p> 
 <p><br> •boolean add( E obj )<br> 在数组列表的尾端添加一个元素。 永远返回 true。<br> 参数：obj 添加的元素</p> 
 <p><br> •int size( )<br> 返回存储在数组列表中的当前元素数量。（这个值将小于或等于数组列表的容量。)</p> 
 <p><br> •void ensureCapacity( int capacity)<br> 确保数组列表在不重新分配存储空间的情况下就能够保存给定数量的元素。<br> 参数：capacity 需要的存储容量</p> 
 <p><br> •void trimToSize( )<br> 将数组列表的存储容量削减到当前尺寸。</p> 
 <p><br> • void set(int index，E obj)<br> 设置数组列表指定位置的元素值， 这个操作将覆盖这个位置的原有内容。<br> 参数： index 位置（必须介于 0 ~ size()-1 之间）<br> obj 新的值</p> 
 <p><br> • E get(int index)<br> 获得指定位置的元素值。<br> 参数：index 获得的元素位置（必须介于 0 ~ size()-l 之间）</p> 
 <p><br> • void add(int index,E obj)<br> 向后移动元素，以便插入元素。<br> 参数：index 插入位置（必须介于 0 〜 size()-l 之间）<br> obj 新元素</p> 
 <p><br> • E remove (int index)<br> 删除一个元素，并将后面的元素向前移动。被删除的元素由返回值返回。<br> 参数：index 被删除的元素位置（必须介于 0 〜 size()-1之间）<br> ————————————————<br>  </p> 
</blockquote> 
<p></p> 
<p><a class="link-info" href="https://www.cnblogs.com/SUNYZBlog/p/10913581.html" rel="nofollow">Java ArrayList常用接口介绍及示例</a></p> 
<p>有用例</p> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5bbfe38e4d580c7859db740c92562bc6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform...警告</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bd5d305e9373ca0f8479163b112bc4de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决Vue项目打包上线后在控制台还可看见源码的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>