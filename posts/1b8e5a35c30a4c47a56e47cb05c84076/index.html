<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES6详细讲解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES6详细讲解" />
<meta property="og:description" content="一、ES6相关介绍 1.1、什么是ES6 1995年的美国，有一家名为netscape(网景)的公司打造了一款主要用于check验证的脚本语言，而恰在此时，Sun公司的java语言火的一塌糊涂，netscape公司为蹭其热度，便将该脚本语言命名为 JavaScript。不料 JavaScript居然被越来越多的人使用，后效仿大秦的货币统一政策将其提交给国际标准组织ECMA。
该组织发布的标准被称做ECMAScript。 2015年6月发布的版本称为ECMAScript2015，简称ES6。从ES6开始，该组织每年会发布一个版本，版本号比年份最后一位大1，至今最新版本为ES12。
ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准 1.2、学前必知词汇 语法糖：又称糖衣语法，指不改变语言的本质功能，只是使编程变的更加简洁。而本课程后续所学习的很多ES6的新特性大多也都是由一粒粒语法糖所构成，所以ES6的一些新特性并不是真的“新”，只是试图简化语法而已。简言之：ES6是一大盒语法糖，解决了以前ES5很多难受的地方。
Babel：Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。相信未来浏览器会逐渐对其提供原生的支持。
1.3、为什么要学习ES6 ES5语言先天不足，通过学习ES6可以将其很多丑陋的部分进行隐藏。包含了很多超棒的新特性，可以简化很多复杂的操作，从而大大提高开发效率。为后面学习vue、react以及小程序做好充足准备。目前大部分公司的项目都在使用ES6，它是前端发展的趋势，就业必备技能之一。 1.4 严格模式 1.4.1 介绍 ES5 除了正常运行模式（又称为混杂模式），还添加了第二种运行模式：“严格模式”（strict mode）。
严格模式顾名思义，就
是使 JavaScript 在更严格的语法条件下运行。
1.4.2 作用 消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为消除代码运行的一些不安全之处，保证代码运行的安全为未来新版本的 JavaScript 做好铺垫 1.4.3 使用 在全局或函数的第一条语句定义为: &#39;use strict&#39;
如果浏览器不支持，只解析为一条简单的语句, 没有任何副作用
1.4.4 语法和行为改变 必须用 var 声明变量，不允许使用未声明的变量禁止自定义的函数中的 this 指向 window创建 eval 作用域对象不能有重名的属性（Chrome 已经修复了这个 Bug，IE 还会出现）函数不能有重复的形参新增一些保留字, 如: implements interface private protected public使用call、apply传第一个参数为null或undefined时，this值不会跳转到全局对象 1.5 Object 扩展方法 var obj = { name: &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1b8e5a35c30a4c47a56e47cb05c84076/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-25T15:03:47+08:00" />
<meta property="article:modified_time" content="2022-11-25T15:03:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES6详细讲解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="ES6_0"></a>一、<code>ES6</code>相关介绍</h3> 
<h4><a id="11ES6_2"></a>1.1、什么是<code>ES6</code></h4> 
<p>1995年的美国，有一家名为<code>netscape</code>(网景)的公司打造了一款主要用于check验证的脚本语言，而恰在此时，<code>Sun</code>公司的<code>java</code>语言火的一塌糊涂，<code>netscape</code>公司为蹭其热度，便将该脚本语言命名为<code> JavaScript</code>。不料<code> JavaScript</code>居然被越来越多的人使用，后效仿大秦的货币统一政策将其提交给国际标准组织<code>ECMA</code>。</p> 
<p>该组织发布的标准被称做<code>ECMAScript</code>。 2015年6月发布的版本称为<code>ECMAScript2015</code>，简称<code>ES6</code>。从<code>ES6</code>开始，该组织每年会发布一个版本，版本号比年份最后一位大1，至今最新版本为<code>ES12</code>。</p> 
<p><font color="red"> ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准 </font></p> 
<h4><a id="12_10"></a>1.2、学前必知词汇</h4> 
<p><font color="red">语法糖：又称糖衣语法，指不改变语言的本质功能，只是使编程变的更加简洁。</font>而本课程后续所学习的很多<code>ES6</code>的新特性大多也都是由一粒粒语法糖所构成，所以<code>ES6</code>的一些新特性并不是真的“新”，只是试图简化语法而已。简言之：<font color="red"><code>ES6</code>是一大盒语法糖，解决了以前<code>ES5</code>很多难受的地方。</font></p> 
<p><font color="red"><code>Babel</code></font>：<code>Babel</code>是一个广泛使用的<code>ES6</code>转码器，可以将<code>ES6</code>代码转为<code>ES5</code>代码，从而在现有环境执行。这意味着，你可以用<code>ES6</code>的方式编写程序，又不用担心现有环境是否支持。<font color="red">相信未来浏览器会逐渐对其提供原生的支持。</font></p> 
<h4><a id="13ES6_16"></a>1.3、为什么要学习<code>ES6</code></h4> 
<ul><li><code>ES5</code>语言先天不足，通过学习<code>ES6</code>可以将其很多丑陋的部分进行隐藏。</li><li>包含了很多超棒的新特性，可以简化很多复杂的操作，从而大大提高开发效率。</li><li>为后面学习<code>vue</code>、<code>reac</code>t以及小程序做好充足准备。</li><li><font color="red">目前大部分公司的项目都在使用<code>ES6</code>，它是前端发展的趋势，就业必备技能之一。</font></li></ul> 
<h4><a id="14__23"></a>1.4 严格模式</h4> 
<h5><a id="141__25"></a>1.4.1 介绍</h5> 
<p>ES5 除了正常运行模式（又称为混杂模式），还添加了第二种运行模式：“<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" rel="nofollow">严格模式</a>”（strict mode）。</p> 
<p>严格模式顾名思义，就</p> 
<p>是使 JavaScript 在更严格的语法条件下运行。</p> 
<h5><a id="142__33"></a>1.4.2 作用</h5> 
<ol><li>消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为</li><li>消除代码运行的一些不安全之处，保证代码运行的安全</li><li>为未来新版本的 JavaScript 做好铺垫</li></ol> 
<h5><a id="143__39"></a>1.4.3 使用</h5> 
<ul><li> <p>在全局或函数的<strong>第一条语句</strong>定义为: <code>'use strict'</code></p> </li><li> <p>如果浏览器不支持，只解析为一条简单的语句, 没有任何副作用</p> </li></ul> 
<h5><a id="144__45"></a>1.4.4 语法和行为改变</h5> 
<ol><li>必须用 var 声明变量，不允许使用未声明的变量</li><li>禁止自定义的函数中的 this 指向 window</li><li>创建 eval 作用域</li><li>对象不能有重名的属性（Chrome 已经修复了这个 Bug，IE 还会出现）</li><li>函数不能有重复的形参</li><li>新增一些保留字, 如: implements interface private protected public</li><li>使用call、apply传第一个参数为null或undefined时，this值不会跳转到全局对象</li></ol> 
<h4><a id="15_Object__55"></a>1.5 Object 扩展方法</h4> 
<pre><code class="prism language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
     <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">"张阳"</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span>
    <span class="token literal-property property">like</span><span class="token operator">:</span><span class="token punctuation">[</span>
        <span class="token string">"早上跑步"</span><span class="token punctuation">,</span>
        <span class="token string">"晚上复习"</span><span class="token punctuation">,</span>
        <span class="token string">"人帅有腹肌"</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="151_Objectkeysobj_69"></a>1.5.1 Object.keys(obj)</h5> 
<blockquote> 
 <p>遍历obj 对象中的键 (key)</p> 
</blockquote> 
<h5><a id="152_Objectvaluesobj_73"></a>1.5.2 Object.values(obj)</h5> 
<blockquote> 
 <p>遍历obj 对象的值 (value)</p> 
</blockquote> 
<h5><a id="153_Objectcreate_77"></a>1.5.3 Object.create()</h5> 
<p>Object.create 方法可以以**<code>指定对象为原型</code><strong>创建新的对象，同时可以为</strong><code>新的对象</code>**设置属性, 并对属性进行描述</p> 
<blockquote> 
 <p>Object.create(proto, propertiesObject)</p> 
 <p>proto 指定的对象为原型</p> 
 <p>propertiesObject 设置新的属性</p> 
</blockquote> 
<pre><code class="prism language-javascript">o2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span>
  <span class="token literal-property property">p</span><span class="token operator">:</span> <span class="token punctuation">{<!-- --></span>
    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">,</span>
    <span class="token literal-property property">writable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token literal-property property">configurable</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ul><li> <p>value : 指定值</p> </li><li> <p>writable : 标识当前属性值是否是可修改的, 默认为 false</p> </li><li> <p>configurable：标识当前属性是否可以被删除 默认为 false</p> </li><li> <p>enumerable：标识当前属性是否能用for in 枚举 默认为 false</p> </li></ul> 
<h5><a id="154__106"></a>1.5.4 读写器</h5> 
<ul><li> <p>get: 当获取当前属性时的回调函数</p> </li><li> <p>set: 当设置当前属性时</p> </li></ul> 
<p><strong>Object.defineProperty(obj,“key”,{descriptors})</strong> 只能写一个属性</p> 
<blockquote> 
 <p>get,set与value,writable不能同时存在</p> 
</blockquote> 
<pre><code class="prism language-javascript"> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
             <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">18</span><span class="token punctuation">,</span>
             <span class="token literal-property property">writable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//可编辑，默认为false</span>
             <span class="token literal-property property">configurable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment">//可删除，默认为false</span>
             <span class="token literal-property property">enumerable</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//可遍历，默认为false</span>
         <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-javascript"> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
            <span class="token function-variable function">get</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">||</span> <span class="token string">"今麦郎"</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token function-variable function">set</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> v<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<h5><a id="155_ObjectdefineProperties_136"></a>1.5.5 Object.defineProperties()</h5> 
<p>defineProperty复数形式</p> 
<p>直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</p> 
<blockquote> 
 <p>Object.defineProperties(object, descriptors)</p> 
</blockquote> 
<ul><li> <p>object 要操作的对象</p> </li><li> <p>descriptors 属性描述</p> 
  <ul><li>get 作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。</li><li>set 作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。</li></ul> <pre><code class="prism language-javascript"><span class="token keyword">var</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">{<!-- --></span>
                <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
                    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token string">'老王'</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token literal-property property">age</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
                    <span class="token literal-property property">value</span><span class="token operator">:</span><span class="token number">18</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token literal-property property">like</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
                    <span class="token function-variable function">get</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// return  _like || [];</span>

                        <span class="token comment">// 如果不写return </span>
                        <span class="token comment">// 默认return undefined;</span>
                    <span class="token punctuation">}</span><span class="token punctuation">,</span>
                    <span class="token function-variable function">set</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                        _like <span class="token operator">=</span> v<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li></ul> 
<h4><a id="16_callapply__bind_172"></a>1.6 call、apply 和 bind</h4> 
<ul><li> <p>call 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数</p> </li><li> <p>apply 方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数</p> </li><li> <p>bind 同 call 相似，不过该方法会返回一个新的函数，而不会立即执行</p> </li></ul> 
<h3><a id="_182"></a>二、关键字扩展(重点)</h3> 
<h4><a id="21let_184"></a>2.1、let和块级作用域</h4> 
<h5><a id="211ES5_186"></a>2.1.1、<code>ES5</code>没有块级作用域</h5> 
<p>在<strong>ES5</strong>中，JS 的作用域分为全局作用域和局部作用域。通常是用函数区分的，函数内部属于局部作用域。</p> 
<p><strong>ES5</strong>只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景</p> 
<ol><li>内层变量可能会覆盖外层变量。</li><li>用来计数的循环变量泄露为全局变量。</li></ol> 
<h5><a id="212_195"></a>2.1.2、块级作用域</h5> 
<ul><li>在 <strong>ES6</strong> 中新增了块级作用域的概念，使用{}扩起来的区域叫做块级作用域</li><li>let关键字声明变量，实际上为 JavaScript 新增了块级作用域。</li><li>块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。</li><li>在块内使用let声明的变量，只会在当前的块内有效。</li></ul> 
<h5><a id="213let_202"></a>2.1.3、let关键字</h5> 
<p><code>ES6</code>新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效，也就是增加了块级作用域。</p> 
<ul><li> <p>使用块级作用域（let定义的变量属于块级作用域） 防止全局变量污染</p> 
  <ul><li> <p>块级作用域可以任意嵌套</p> </li><li> <p>for循环的计数器，就很合适使用let命令</p> 
    <ul><li>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量</li></ul> <p>你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算</p> </li></ul> </li><li> <p>for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域</p> </li><li> <p>练习1</p> </li></ul> 
<pre><code class="prism language-javascript"> <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      	 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-javascript"><span class="token operator">*</span> 练习<span class="token number">2</span>	

    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token template-punctuation string">`</span></span>`js
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h5><a id="214let_245"></a>2.1.4、let关键字特点</h5> 
<ul><li> <p>let命令不存在变量提升</p> <p>和var不同的还有，let命令不存在变量提升，所以声明前调用变量，都会报错，这就涉及到一个概念——暂时性死区。</p> <p>暂时性死区即：区块中存在<code>let</code>或<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p> </li><li> <p>不允许重复声明</p> </li></ul> 
<p>let 只能声明一次而var 可以声明多次。</p> 
<ul><li> <p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式不再必要了</p> </li><li> <p>let 是在代码块内有效，var 是在全局范围内有效</p> </li><li> <p>不影响作用域链</p> </li></ul> 
<p>let与var都拥有作用域链。</p> 
<p>作用域链： 如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</p> 
<ul><li>不再是顶层全局对象的属性</li></ul> 
<p>使用var定义的全局变量相当于直接挂载在window对象上， 而let不会。</p> 
<h4><a id="22const__275"></a>2.2、<code>const</code> 关键字</h4> 
<p>注意：</p> 
<pre><code>变量：数据可以变化。在执行过程当中，有一些数据会使用多次，根据条件会变化，一般定义为变量。
										
常量：不会变化的数据，有些时候有的数据是不允许修改的，所以需要定义常量。
</code></pre> 
<ul><li>声明一定要赋初始值:一旦声明变量，就必须立即初始化，不能留到以后赋值</li></ul> 
<p><code>const</code> 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</p> 
<ul><li> <p>值不允许修改</p> <p><font color="red">const 其实保证的不是变量的值不变，而是保证变量指向的内存地址不允许改动。所以 使用 const 定义的对象或者数组，其实是可变的。 </font></p> 
  <ul><li> <p><code>const</code>只在声明所在的块级作用域内有效。（与let相同）</p> </li><li> <p><code>const</code>命令声明的常量也是不会提升（与let相同）</p> </li><li> <p><code>const</code>不可重复声明（与let相同）</p> </li><li> <p>不再是顶层全局对象的属性（与let相同）</p> <p>let命令、<code>const</code>命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 <code>ES6 </code>开始，全局变量将逐步与顶层对象的属性脱钩。</p> </li></ul> </li><li> <p><font color="red">const使用的两点建议：</font></p> </li></ul> 
<p><font color="red">1、被多次使用且不允许更改的数据建议通过const定义;</font></p> 
<p><font color="red">2、项目全局常量建议大写，单词之间用-分隔；</font></p> 
<p>3、如果不清楚要使用let还是<code>const</code>,那么就用<code>const</code>。如果后面发生值的改变，那么再将<code>const</code>改成let.</p> 
<pre><code>4、以后不允许使用var
</code></pre> 
<h4><a id="23__315"></a>2.3 、块级作用域的函数声明</h4> 
<ul><li> <p>函数声明一般常用的是两种，一种是function声明，一种是函数表达式。</p> 
  <ul><li> <p>建议函数在顶层作用域和函数作用域之中声明，尽量避免在块级作用域声明。（ "use strict"下报错）</p> </li><li> <p>如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p> </li></ul> </li></ul> 
<h3><a id="_324"></a>三、变量的解构赋值(重点)</h3> 
<h4><a id="31_326"></a>3.1、什么是变量的解构赋值</h4> 
<p>解构 → 解析，重构。</p> 
<p>解构的目标：数组以及对象。</p> 
<p><code>ES</code>6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p> 
<p>解构赋值本质就是赋值：把结构解散重构然后赋值。</p> 
<p>解构赋值是对赋值运算符=的一种扩展。</p> 
<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p> 
<h4><a id="32_341"></a>3.2、引入</h4> 
<p>在<code>ES5</code>中，开发者们为了从对象和数组中获取特定数据并赋值给变量，编写了许多看起来同质化的代码 ;</p> 
<h4><a id="33_346"></a>3.3、解构赋值语法</h4> 
<p>解构的目标 = 解构源;(目标指的是定义的常量或变量，解析源一般指的是数组或对象)</p> 
<p>解构目标：定义的常量或变量</p> 
<p>解构源：待解构的数组或对象</p> 
<h4><a id="34_354"></a>3.4、对象解构赋值</h4> 
<ul><li>对象解构赋值基本语法</li></ul> 
<p>对象的语法形式是在一个赋值操作符= 右边放置一个对象字面量</p> 
<ul><li> <p>顺序不用一一对应</p> 
  <ul><li> <p>= 右侧可以是一个常或变量</p> </li><li> <p>嵌套对象解构</p> </li></ul> <p>解构嵌套对象仍然与对象字面量的语法相似，可以将对象拆解以获取想要的信息</p> </li><li> <p>可忽略部分解构源的属性</p> </li><li> <p>剩余运算符</p> </li><li> <p>不完全解构：变量名称在对象中不存在</p> </li></ul> 
<p>使用解构赋值表达式时，如果指定的变量名称在对象中不存在，那么这个变量会被赋值为undefined</p> 
<ul><li> <p>解构默认值(常用)</p> <p>当指定的属性不存在时，可以定义一个默认值：在属性名称后添加一个等号(=)和相应的默认值即可</p> 
  <ul><li>为非同名局部变量赋值 ，可避免命名冲突</li></ul> </li></ul> 
<p>如果希望使用不同命名的局部变量来存储对象属性的值，<code>ES6</code>中的一个扩展语法可以满足需求，这个语法与完整的对象字面量属性初始化程序的很像。</p> 
<pre><code> *  函数传参数

 解构赋值表达式的值与表达式右侧(也就是=右侧)的值相等，如此一来，在任何可以使用值的地方都可以使用解构赋值表达式 
</code></pre> 
<h4><a id="35_389"></a>3.5、数组解构赋值</h4> 
<ul><li> <p>基本使用</p> <p>与对象解构的语法相比，数组解构就简单多了，它使用的是数组字面量，且解构操作全部在数组内完成，而不是像对象字面量语法一样使用对象的命名属性 。</p> </li><li> <p>忽略元素</p> </li></ul> 
<p>在解构模式中，可以直接省略元素，只为感兴趣的元素提供变量名 。</p> 
<pre><code>* 变量交换
</code></pre> 
<p>数组解构语法还有一个独特的用例：交换两个变量的值。在排序算法中，值交换是一个非常常见的操作，如果要在<code>ES5</code>中交换两个变量的值，则须引入第三个临时变量</p> 
<pre><code>*  添加默认值 
</code></pre> 
<p>也可以在数组解构赋值表达式中为数组中的任意位置添加默认值，当指定位置的属性不存在或其值为undefined时使用默认值</p> 
<ul><li>嵌套数组解构</li></ul> 
<p>嵌套数组解构与嵌套对象解构的语法类似，在原有的数组模式中插入另一个数组模式，即可将解构过程深入到下一个层级</p> 
<ul><li>不定元素</li></ul> 
<p>函数具有不定参数，而在数组解构语法中有一个相似的概念——不定元素。在数组中，可以通过…语法将数组中的其余元素赋值给一个特定的变量</p> 
<ul><li>数组复制</li></ul> 
<p>在<code>ES5</code>中，开发者们经常使用<code>concat()</code>方法来克隆数组</p> 
<h4><a id="36_420"></a>3.6、混合解构（复杂解构）</h4> 
<p>混合使用对象解构和数组解构来创建更多复杂的表达式，可以从任何混杂着对象和数组的数据解构中提取想要的信息</p> 
<p>面试题：</p> 
<pre><code class="prism language-js"><span class="token comment">//复杂解构</span>
<span class="token keyword">let</span> wangfei <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
 <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'王菲'</span><span class="token punctuation">,</span>
 <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
 <span class="token literal-property property">songs</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'红豆'</span><span class="token punctuation">,</span> <span class="token string">'流年'</span><span class="token punctuation">,</span> <span class="token string">'暧昧'</span><span class="token punctuation">,</span> <span class="token string">'传奇'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token literal-property property">history</span><span class="token operator">:</span> <span class="token punctuation">[</span>
       <span class="token punctuation">{<!-- --></span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'窦唯'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token punctuation">{<!-- --></span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'李亚鹏'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token punctuation">{<!-- --></span><span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'谢霆锋'</span><span class="token punctuation">}</span>
     <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// console.log(userName,age,one,two,three,four,name,name2,name3);// 王菲 18 红豆 流年 暧昧 传奇 窦唯 李亚鹏 谢霆锋</span>
</code></pre> 
<h4><a id="37__442"></a>3.7、 解构传递参数</h4> 
<ul><li> <p>解构赋值可以应用在函数参数的传递过程中。</p> 
  <ul><li> <p>如果调用函数时不传入参数或设置默认值，被解构的参数会导致程序抛出错误</p> </li><li> <p>可以为解构参数指定默认值</p> </li></ul> </li></ul> 
<h4><a id="38_451"></a>3.8、解构返回结果</h4> 
<ul><li>函数的多个返回值获取</li></ul> 
<h4><a id="38_456"></a>3.8、字符串解构(了解)</h4> 
<ul><li>字符串也可以解构赋值。这是因为，字符串被转换成了一个类似数组的对象</li></ul> 
<h4><a id="39_460"></a>3.9、数值和布尔值解构(了解)</h4> 
<ul><li>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象</li></ul> 
<h3><a id="spreadrest_464"></a>四、spread运算符与rest参数</h3> 
<p>在<code>ES6</code>中， 三个点(…) 有2个含义。分别表示扩展运算符（spread运算符） 和 剩余运算符（spread运算符）</p> 
<h4><a id="41spread_468"></a>4.1、spread运算符</h4> 
<ul><li>复制、合并数组</li><li>复制、合并对象</li><li>解构数组与对象</li><li>字符串转换为数组</li><li>伪数组转为真数组</li></ul> 
<h4><a id="42rest_476"></a>4.2、rest参数</h4> 
<ul><li>rest 参数（形式为<code>...变量名</code>），rest运算符用于获取函数调用时传入的参数。</li><li>和普通参数混合使用的时候，需要放在参数的最后</li><li>函数的<code>length</code>属性，不包括 rest 参数</li></ul> 
<h3><a id="_482"></a>五、数组的扩展</h3> 
<h4><a id="51_Arrayfrom_484"></a>5.1 Array.from()</h4> 
<blockquote> 
 <p><strong><code>Array.from()</code></strong> 方法对一个类似数组或可迭代对象创建一个新的，<strong>浅拷贝</strong>的数组实例。不影响原数组</p> 
</blockquote> 
<p>Array.from(arrayLike, mapFn, thisArg)</p> 
<ul><li>arrayLike 想要转换成数组的伪数组对象或可迭代对象</li><li><code>mapFn</code> 可选 如果指定了该参数，新数组中的每个元素会执行该回调函数。让你可以在最后生成的数组上再执行一次 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="nofollow"><code>map</code></a> 方法后再返回。</li><li><code>thisArg</code> 可选 可选参数，执行回调函数 <code>mapFn</code> 时 <code>this</code> 对象。</li></ul> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token operator">===</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">//  output: false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token parameter">x</span> <span class="token operator">=&gt;</span> x <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//  output: [2,4,6]</span>
</code></pre> 
<h4><a id="52_Arrayof_500"></a>5.2 Array.of()</h4> 
<blockquote> 
 <p><strong><code>Array.of()</code></strong> 方法通过可变数量的参数创建一个新的 <code>Array</code> 实例，而不考虑参数的数量或类型。</p> 
</blockquote> 
<p>Array.of(element0, element1, /* … ,*/ elementN)</p> 
<pre><code class="prism language-javascript">Array<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [7]                      Array.of 与 Array() 的区别</span>
<span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// array of 7 empty slots      一个参数表示长度为7，但是数组为空，7个空元素</span>
</code></pre> 
<h4><a id="53_copyWithin_511"></a>5.3 copyWithin()</h4> 
<blockquote> 
 <p><strong><code>copyWithin()</code></strong> 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array1<span class="token punctuation">.</span><span class="token function">copyWithin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// expected output: Array ["d", "b", "c", "d", "e"]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array1<span class="token punctuation">.</span><span class="token function">copyWithin</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// expected output: Array ["d", "d", "e", "d", "e"]</span>
</code></pre> 
<p>copyWithin(target, start, end)</p> 
<ul><li>target 复制序列到该位置。默认为0，值大于数组长度不会发生拷贝，负数从末尾开始。</li><li>start 开始复制元素的起始位置。默认为0，负数将从末尾开始计算。</li><li>end copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。负数从末尾开始计算。默认会复制到数组的末尾。</li></ul> 
<h4><a id="54_fill_527"></a>5.4 fill</h4> 
<blockquote> 
 <p><strong><code>fill()</code></strong> 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array1<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// expected output: [1, 2, 0, 0]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array1<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// expected output: [1, 5, 5, 5]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array1<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// expected output: [6, 6, 6, 6]</span>
</code></pre> 
<p>fill(value, start, end) value:填充值 start：起始索引，默认为0 end：终止索引，默认为数组的结尾</p> 
<h4><a id="55_entries_540"></a>5.5 entries()</h4> 
<blockquote> 
 <p>**<code>Object.entries()</code>**方法返回一个给定对象自身可枚举属性的键值对数组 Object.entries(obj)</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token string">'three'</span><span class="token punctuation">,</span><span class="token string">'four'</span><span class="token punctuation">,</span><span class="token string">'five'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>val<span class="token punctuation">]</span> <span class="token keyword">of</span> arr<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>                 <span class="token comment">// 可能由于包装类</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">// output:   1 'one'   2 'two'  3 'three'  4 'four'  5 'five'</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="56_keys_551"></a>5.6 keys()</h4> 
<blockquote> 
 <p><strong><code>Object.keys()</code></strong> 方法会返回一个由一个给定对象的自身<strong>可枚举属性</strong>组成的<strong>数组</strong> , 有包装类，数组实例可以使用。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> arr<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="57_values_561"></a>5.7 values()</h4> 
<blockquote> 
 <p><strong><code>Object.values()</code></strong> 方法会返回一个由一个给定对象的自身<strong>可枚举属性</strong>组成的<strong>数组</strong> , 有包装类，数组实例可以使用。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> arr<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="58_find_571"></a>5.8 find()</h4> 
<blockquote> 
 <p><strong><code>find()</code></strong> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="nofollow"><code>undefined</code></a>。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item <span class="token operator">===</span> <span class="token string">'four'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// output: four</span>
</code></pre> 
<blockquote> 
 <p>find(function(item, index, array) { /* … */ }, thisArg) item: 当前元素 index：当前索引 array：原数组 thisArg: 执行回调时用作 <code>this</code> 的对象。</p> 
</blockquote> 
<h4><a id="59_findIndex_583"></a>5.9 findIndex</h4> 
<blockquote> 
 <p><strong><code>find()</code></strong> 方法返回数组中满足提供的测试函数的第一个元素的索引。没有找到相应的元素返回 -1</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> item <span class="token operator">===</span> <span class="token string">'four'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// output: 3</span>
</code></pre> 
<blockquote> 
 <p>findIndex(function(item, index, array) { /* … */ }, thisArg) item: 当前元素 index：当前索引 array：原数组 thisArg: 执行回调时用作 <code>this</code> 的对象。</p> 
</blockquote> 
<h4><a id="510_includes_594"></a>5.10 includes()</h4> 
<blockquote> 
 <p><strong><code>includes()</code></strong> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span>index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> array<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">''</span> <span class="token operator">:</span> array<span class="token punctuation">[</span>array<span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// [1,2,3,4,5]</span>
</code></pre> 
<blockquote> 
 <p>includes ( searchElement, fromIndex ) searchElement： 需要查找的元素值。 fromIndex: 从什么位置开始查找</p> 
</blockquote> 
<h4><a id="511_flat_607"></a>5.11 flat()</h4> 
<blockquote> 
 <p><strong><code>flat()</code></strong> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。对原数组没有影响。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// expected output: [0, 1, 2, 3, 4]</span>

<span class="token keyword">const</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// expected output: [0, 1, 2, [3, 4]]</span>
</code></pre> 
<ul><li><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1</li><li>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数</li></ul> 
<h3><a id="_623"></a>六、函数的扩展</h3> 
<h4><a id="61__625"></a>6.1、 函数参数默认值</h4> 
<h5><a id="611ES5_627"></a>6.1.1、<code>ES5</code>默认参数</h5> 
<p><code>ES6</code> 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p> 
<h5><a id="612ES6__631"></a>6.1.2、<code>ES6</code> 默认参数</h5> 
<p><code>ES6</code> 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p> 
<h4><a id="62__635"></a>6.2 箭头函数（非常重要）</h4> 
<h5><a id="621_637"></a>6.2.1、什么是箭头函数</h5> 
<p><code>ES6</code> 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p> 
<h5><a id="622_641"></a>6.2.2、箭头函数的写法</h5> 
<p>箭头函数分为以下几种情况</p> 
<ul><li> <p>只有一个参数 并函数体是一句话的时候</p> </li><li> <p>没有参数或者多个参数的时候，参数的括号不能省略</p> </li><li> <p>当函数体不是一句话的时候，花括号 不可以省略</p> 
  <ul><li>如果函数体内只有一行代码，该行代码返回的是对象的话，可以使用括号。</li></ul> </li></ul> 
<h5><a id="623_653"></a>6.23、箭头函数的使用场景</h5> 
<ul><li>定时器回调改写</li><li>map方法回调改写</li></ul> 
<h5><a id="623_658"></a>6.2.3、箭头函数的注意事项</h5> 
<ul><li> <p>关于this</p> <p>箭头函数没有自己的this，箭头函数内部的this并不是调用时候指向的对象,而是定义时指向的对象</p> </li><li> <p>箭头函数不能用于构造函数，也就是不能使用new关键字调用</p> </li><li> <p>箭头函数没有arguments对象</p> </li></ul> 
<ul><li>箭头函数使用call apply bind无法改变this指向</li></ul> 
<h3><a id="_670"></a>七、对象的扩展</h3> 
<h4><a id="71_672"></a>7.1、对象的简写</h4> 
<blockquote> 
 <p><code>ES6</code> 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p> 
</blockquote> 
<h4><a id="72__676"></a>7.2 、属性名表达式</h4> 
<p>JavaScript 定义对象的属性，有两种方法：点运算符和中括号运算符</p> 
<p>但是，如果使用字面量方式定义对象（使用大括号），在 <code>ES5</code> 中只能使用标识符，而不能使用变量定义属性。</p> 
<p>也就是说在<code>ES5</code>中 key/value key是固定不变的，在<code>ES6</code>中，支持属性表达式，支持key发生变化</p> 
<h4><a id="73__41_684"></a>7.3、 对象的扩展运算符 …(见4.1)</h4> 
<h4><a id="74__686"></a>7.4 对象新增的方法</h4> 
<h5><a id="741Objectisv1v2_688"></a>7.4.1、<code>Object.is(v1,v2)</code></h5> 
<blockquote> 
 <p><strong><code>Object.is()</code></strong> 方法判断两个值是否为同一个值</p> 
</blockquote> 
<pre><code class="prism language-javascript">Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// true     解决了NaN不等于NaN的问题</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// false</span>
</code></pre> 
<blockquote> 
 <p>Object.is(value1, value2); 被比较的第一个值。 value2 被比较的第二个值</p> 
</blockquote> 
<h5><a id="742Objectassign_700"></a>7.4.2、合并方法<code>Object.assign()</code></h5> 
<p><strong><code>Object.assign()</code></strong> 方法将所有可枚举的自有属性从一个或多个源对象复制到目标对象，返回修改后的对象。</p> 
<pre><code class="prism language-javascript"><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token literal-property property">c</span><span class="token operator">:</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> returnedTarget <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>    									 <span class="token comment">// output: Object { a: 1, b: 4, c: 5 }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>returnedTarget <span class="token operator">===</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// output: true</span>
</code></pre> 
<blockquote> 
 <p>Object.assign(target, …sources) target 拷贝后返回的新对象 sources 源对象，包含将被合并的属性。</p> 
</blockquote> 
<h5><a id="743_Objectkeys_714"></a>7.4.3 <strong>Object.keys()</strong></h5> 
<blockquote> 
 <p><strong><code>Object.keys()</code></strong> 方法会返回一个由一个给定对象的自身<strong>可枚举属性</strong>组成的<strong>数组</strong> , 有包装类，数组实例可以使用。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
<span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'ling'</span><span class="token punctuation">,</span>
<span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">16</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>  			<span class="token comment">// output: [name,age]</span>
</code></pre> 
<h5><a id="744_Objectvalues_727"></a>7.4.4 Object.values()</h5> 
<blockquote> 
 <p><strong><code>Object.values()</code></strong> 方法会返回一个由一个给定对象的自身<strong>可枚举属性</strong>组成的<strong>数组</strong> , 有包装类，数组实例可以使用。</p> 
</blockquote> 
<pre><code class="prism language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
<span class="token literal-property property">name</span><span class="token operator">:</span><span class="token string">'ling'</span><span class="token punctuation">,</span>
<span class="token literal-property property">age</span><span class="token operator">:</span><span class="token number">16</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment">// output: ['ling',16]</span>
</code></pre> 
<h3><a id="Math_739"></a>八、Math的扩展（了解）</h3> 
<h4><a id="81_741"></a>8.1、指数运算符</h4> 
<ul><li> <p>在Math中提供了 pow的方法 用来计算一个值的n次方</p> </li><li> <p><code>ES11</code> 提出了新的方法求一个值的n次方 那就是 ** 操作符</p> </li></ul> 
<h4><a id="82_747"></a>8.2、进制写法</h4> 
<blockquote> 
 <ul><li><code>ES6</code> 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>和<code>0o</code>表示。</li></ul> 
</blockquote> 
<h4><a id="83Math_751"></a>8.3、Math的新增方法</h4> 
<ul><li><code>Math.trunc()</code>方法会将数字的小数部分去掉，只保留整数部分</li><li><code>Math.sign()</code> 判断一个数字的正数还是负数 还是0 或者是<code>NaN</code></li><li><code>Math.sqrt()</code>平方根</li><li><code>Math.cbrt()</code>立方根</li><li><code>Math.hypot()</code> 求所有参数平方和的平方根</li></ul> 
<h3><a id="Number_759"></a>九、Number的扩展（了解）</h3> 
<ul><li><code>Number.isFinite(i) </code>: 用来检查一个数值是否为有限</li><li><code>Number.isNaN(i)</code> : 判断是否是<code>NaN</code></li><li><code>Number.isInteger(i) </code>: 判断是否是整数</li><li><code>Number.parseInt(str) </code>: 将字符串转换为对应的数值</li></ul> 
<h3><a id="_766"></a>十、新增数据类型（了解）</h3> 
<h4><a id="101Symbol_768"></a>10.1、Symbol</h4> 
<h5><a id="1011Symbol_770"></a>10.1.1、什么是Symbol</h5> 
<p><code>ES5</code> 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是<code>ES6</code>引入<code>Symbol</code>的原因。</p> 
<p><code>ES6</code> 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型</p> 
<h5><a id="1012Symbol_776"></a>10.1.2、Symbol的使用</h5> 
<ul><li> <p>Symbol 值通过<code>Symbol</code>函数生成。</p> </li><li> <p>这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突</p> </li></ul> 
<h5><a id="1013Symbol_782"></a>10.1.3、Symbol表示独一无二的值</h5> 
<pre><code>&gt;	使用 `Symbol.for`("尚硅谷") 通过相同参数设置相同值
</code></pre> 
<h5><a id="1014Symbol_786"></a>10.1.4、Symbol的注意事项</h5> 
<ul><li> <p>Symbol中传入的字符串没有任何意义，只是用来描述Symbol</p> </li><li> <p>Symbol不能使用New调用</p> </li><li> <p>类型转换的时候，不能转数字</p> 
  <ul><li>如果把Symbol当作一个对象的属性和方法的时候，一定要用一个变量来储存，否则定义的属性和方法没有办法使用</li></ul> </li><li> <p>for in 不能遍历出来，可以使用<code>Object.getOwnPropertySymbols</code>方法来拿;</p> </li></ul> 
<h4><a id="102BigInt_796"></a>10.2、<code>BigInt</code></h4> 
<ul><li>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code>Infinity</code>。</li><li>引入了一种新的数据类型 <code>BigInt</code>（大整数），来解决这个问题。<code>BigInt</code> 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</li><li>为了与 Number 类型区别，<code>BigInt</code> 类型的数据必须添加后缀<code>n</code>。 
  <ul><li><code>BigInt </code>与普通整数是两种值，它们之间并不全等。</li></ul> </li><li><code>typeof</code>运算符对于<code> BigIn</code>t 类型的数据返回<code>bigint</code>。 
  <ul><li><code>Bigint</code>类型与Number类型互相转换</li></ul> </li></ul> 
<h3><a id="_805"></a>十一、新增数据结构（了解）</h3> 
<h4><a id="111Set_807"></a>11.1、Set</h4> 
<h5><a id="1111Set_809"></a>11.1.1、什么是Set</h5> 
<ul><li> <p><code>ES6</code> 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p> </li><li> <p><code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。</p> </li><li> <p><code>Set</code>函数可以接受一个数组（或者具有 <code>iterable</code> 接口的其他数据结构）作为参数，用来初始化</p> <p>利用set对象，实现数组去重</p> </li></ul> 
<h5><a id="1112_Set_819"></a>11.1.2、 Set的属性及方法</h5> 
<ul><li>size 返回Set的长度</li><li>add 添加某个值，返回 Set 结构本身。</li><li>delete 删除某个值，返回一个布尔值，表示删除是否成功。</li><li>has 返回一个布尔值，表示该值是否为<code>Set</code>的成员</li><li>clear 清除所有成员，没有返回值。</li><li><code>keys()</code>：返回键名的遍历器,由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</li><li><code>values()</code>：返回键值的遍历器</li><li><code>entries()</code>：返回键值对的遍历器</li><li><code>forEach()</code>：使用回调函数遍历每个成员</li></ul> 
<h5><a id="1113Set_831"></a>11.1.3、Set的其他使用</h5> 
<pre><code> - 求两数组去重后的交集
 - 求两数组去重后的并集
 - 求两数组去重后的差集
</code></pre> 
<h4><a id="112Map_837"></a>11.2、Map</h4> 
<h5><a id="1121Map_839"></a>11.2.1、什么是Map</h5> 
<ul><li> <p>JavaScript 的对象（Object），本质上是键值对的集合，但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p> 
  <ul><li>为了解决这个问题，<code>ES6</code> 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</li></ul> </li></ul> 
<h5><a id="1022Map_845"></a>10.2.2、Map的属性和方法</h5> 
<ul><li><code>size</code>属性返回 Map 结构的成员总数。</li><li><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。<code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</li><li><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li><li><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li><li><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li><li><code>clear</code>方法清除所有成员，没有返回值。</li><li><code>keys()</code>：返回键名的遍历器。</li><li><code>values()</code>：返回键值的遍历器。</li><li><code>entries()</code>：返回所有成员的遍历器。</li><li><code>forEach()</code>：遍历 Map 的所有成员。</li></ul> 
<h3><a id="iterator_858"></a>十二、iterator（了解）</h3> 
<h4><a id="121iterator_860"></a>12.1、什么是iterator</h4> 
<ul><li>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是<code>Map</code>，<code>Map</code>的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。</li><li>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</li><li>Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 <code>ES6</code> 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</li></ul> 
<h4><a id="122iterator_866"></a>12.2、iterator</h4> 
<ul><li> <p>在<code>ES6</code>中，只要一种数据结构具有了<code>Symbol.iterator</code>属性，那么就认为是可以迭代的</p> </li><li> <p>在<code>ES6</code>中，很多数据结构都部署了iterator接口(Array,set,Map,string)</p> </li><li> <p>应用场景：</p> 
  <ul><li>解构赋值的时候默认调用iterator接口</li></ul> </li><li> <p>扩展运算符使用的时候页默认调用iterator接口</p> 
  <ul><li>for of 使用的是iterator接口</li></ul> </li><li> <p>对象是没有部署Iterator接口</p> </li><li> <p>案例：将对象中的两个数组使用for…of进行遍历</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9faf05e41e94b1d2c731ca6935f972b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">day03</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c7f9961c38f8533688cd948151d03e86/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">EasyDSS启动后443端口未被占用，访问不了https网页是什么原因？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>