<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一条 SQL 更新语句如何执行的 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一条 SQL 更新语句如何执行的" />
<meta property="og:description" content="Server 层
存储引擎层
总流程
查询语句
连接器
查询缓存
分析器
优化器
执行器
更新语句
redo log（节省的是随机写磁盘的 IO 消耗（转成顺序写））
InnoDB 引擎
物理日志
循环写
binlog
server层
逻辑日志
追加写入
两阶段提交
为了知道，mysql 中一条 sql 语句是如何执行的，先讲一下 mysql 的宏观分层以及如何执行查询语句.
MySQL 宏观上分为 Server 层 和 存储引擎层， MySQL 通过 server 层调用存储引擎层操作数据返回结果，Server 层又可以分为
连接器分析器优化器执行器 连接器负责跟客户端建立连接、获取权限、维持和管理连接。
分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。
优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 执行器会根据表的引擎定义，去使用这个引擎提供的接口。示例：
mysql&gt; select * from T where ID=10; 比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：
调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 至此，这个语句就执行完成了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/ae82bc1e920c171fb3d948f624748cf4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-13T22:16:26+08:00" />
<meta property="article:modified_time" content="2024-03-13T22:16:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一条 SQL 更新语句如何执行的</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>    Server 层<br>     存储引擎层<br>     总流程<br>         查询语句<br>             连接器<br>             查询缓存<br>             分析器<br>             优化器<br>             执行器<br>         更新语句<br>             redo log（节省的是随机写磁盘的 IO 消耗（转成顺序写））<br>                 InnoDB 引擎<br>                 物理日志<br>                 循环写<br>             binlog<br>                 server层<br>                 逻辑日志<br>                 追加写入<br>             两阶段提交</p> 
</blockquote> 
<p></p> 
<p>为了知道，mysql 中一条 sql 语句是如何执行的，先讲一下 mysql 的宏观分层以及如何执行查询语句.</p> 
<p class="img-center"><img alt="" height="287" src="https://images2.imgbox.com/d1/91/CMM9cUOQ_o.png" width="360"></p> 
<p> MySQL 宏观上分为 <strong><span style="color:#fe2c24;">Server 层</span></strong> 和 <span style="color:#fe2c24;"><strong>存储引擎层</strong></span>， MySQL 通过 server 层调用存储引擎层操作数据返回结果，Server 层又可以分为</p> 
<ol><li>连接器</li><li>分析器</li><li>优化器</li><li>执行器</li></ol> 
<p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p> 
<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p> 
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。 </p> 
<p>执行器会根据表的引擎定义，去使用这个引擎提供的接口。示例：</p> 
<pre><code class="language-sql">mysql&gt; select * from T where ID=10;</code></pre> 
<p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p> 
<ol><li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol> 
<p>至此，这个语句就执行完成了。</p> 
<hr> 
<p>查询语句的那一套流程，更新语句也是同样会走一遍。与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：<strong><span style="color:#fe2c24;">redo log（重做日志）和 binlog（归档日志）</span></strong>。</p> 
<h4>redo log</h4> 
<p>如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。</p> 
<p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面。</p> 
<p>InnoDB 的 redo log 是固定大小的，满了时不能再执行新的更新。由参数 <span style="color:#fe2c24;"><strong>innodb_log_file_size </strong></span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;"><strong> innodb_log_files_in_group </strong></span><span style="color:#0d0016;">决定。</span></p> 
<p class="img-center"><img alt="" height="106" src="https://images2.imgbox.com/c7/6b/aVaV61tv_o.png" width="300"></p> 
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 </p> 
<h4>change buffer</h4> 
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。change buffer 在内存中有拷贝，也会被写入到磁盘上。</p> 
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p> 
<p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p> 
<p class="img-center"><img alt="" height="90" src="https://images2.imgbox.com/37/d8/myoK5XLN_o.png" width="350"></p> 
<p>因为 merge 的时候是真正进行数据更新的时刻，而 change buffer 的主要目的就是将记录的变更动作缓存下来，所以在一个数据页做 merge 之前，change buffer 记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时 change buffer 的使用效果最好。 </p> 
<h4>binlog</h4> 
<p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）.这两种日志有以下三点不同。</p> 
<ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol> 
<hr> 
<p>执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程： </p> 
<ol><li>执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。 <p class="img-center"><img alt="" height="465" src="https://images2.imgbox.com/48/67/ZjCGLfMs_o.png" width="350"></p> </li></ol> 
<p>将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"<strong><span style="color:#fe2c24;">两阶段提交</span></strong>"。 </p> 
<p>推荐阅读</p> 
<p><a class="link-info" href="https://blog.csdn.net/fanghailiang2016/article/details/136635149" title="一条 SQL 更新语句如何执行的">一条 SQL 更新语句如何执行的</a> </p> 
<p><a class="link-info" href="https://blog.csdn.net/fanghailiang2016/article/details/136637168" title="MySQL 事务的原理以及长事务的预防和处置">MySQL 事务的原理以及长事务的预防和处置</a> </p> 
<p><a class="link-info" href="https://blog.csdn.net/fanghailiang2016/article/details/136663389" title="InnoDB索引优化">InnoDB索引优化</a> </p> 
<p><a class="link-info" href="https://blog.csdn.net/fanghailiang2016/article/details/136665141" title="一条 sql 语句可能导致的表锁和行锁以及死锁检测">一条 sql 语句可能导致的表锁和行锁以及死锁检测</a> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/660f69d77724015cecc03bfdc653dfc8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spark ml报错：Error:scalac: missing or invalid dependency detected while loading class file ‘SQLImplici</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/74a5951e41a7f24f079b759da826da07/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">代码随想录算法训练营day59|第十章 单调栈part02</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>