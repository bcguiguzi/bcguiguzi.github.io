<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;primer - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;primer" />
<meta property="og:description" content="c&#43;&#43; primer
c&#43;&#43;定义了几种基本内置类型（字符、整型、浮点数），也提供了自定义数据类型的机制；c&#43;&#43;标准库定义了一些更加复杂的数据类型，如可变长字符串和向量。
第二章：变量和基本类型 2.1.基本内置类型 2.1.1算术类型 c&#43;&#43;定义的基本数据类型包括算术类型（字符、整型数、布尔值、浮点数）和空类型。算术类型又分为两类：整型（int,字符，bool)和浮点型。
字符：c&#43;&#43;提供了几种字符类型，基本的字符类型是char,一个char的空间应确保可以存放机器基本字符集中任意字符对于的数字值（就是说一个char的大小和一个机器字节一样）。wchar_t、char16_t、char32_t用于扩展字符集，wchar_t用于确保可以存放机器最大扩展字符中的任意一个字符，char16_t、char32_t为Unicode字符集服务。
整型：一个int（16位）至少和一个short（16位）一样大，一个long（32位）至少和一个int一样大，一个long long（64位）至少和一个long一样大。
1字节=8bit,字=4or8字节
浮点型：float:1个字（32bit),7个有效位
double:2个字（64bit)，16个有效位
long double:3or4个字（96or128bit）被用于有特殊要求的硬件
带符号类型（正数、负数、0）和无符号类型（大于零的数）：int、short、long、longlong都是带符号类型的，加上unsigned就可以得到无符号类型。
2.1.2类型转换 任意类型→bool:0→false,其它→true
bool→任意类型:false→0，true→1
浮点数→整型：仅保留小数点前部分
整数→浮点型：小数部分记为0，若整数所占空间超过浮点型的容量，可导致精度损失。
给无符号类型一个超出它表示范围的值时，结果为对无符号类型表示数值总数取模后的余数。
赋给带符号类型一个产出其表示范围的值是，结果是未定义的。
无符号数与有符号数相加时，先将有符号数转成无符号数（直接给无符号数赋一个负值），再相加。
带符号类型和无符号类型不要混用。
2.1.3字面值常量 每个字面值常量都对应着一种数据类型，字面值常量的形式和值决定了它的数据类型。
整型和浮点型字面值：0开头代表八进制、0开头代表十进制、0x开头代表十六进制。整型字面值具体的数据类型由它的值和符号决定。默认十进制字面值的类型是带符号数而八进制和十六进制字面值可能带符号也可能是无符号的。
默认浮点型字面值是一个double
字符和字符串字面值：
&#39;a&#39;//字符字面值 &#34;hello world&#34;//字符串字面值 字符串字面值的类型实际上是由常量字符构成的数组，编译器在资格字符串的结尾处加上了一个空字符（’\0’），因此，字符串字面值的实际长度比它的内容多1.
转义序列：分为不可打印字符和含有特殊含义的字符。
\n 换行符 ，\t 横向制表符 ，等等
指定字面值的类型：通过给添加前缀和后缀可以改变整型、浮点型、字符型字面值的默认类型。字符和字符串字面值：
前缀：u(char16_t) ,U(char32_t),L(wchar_t),u8(char)
整型字面值：
后缀：u orU(unsigned),l orL(long),ll orLL(long long)
浮点型字面值：
后缀：f orF(float),l or L(long double)
布尔字面值：true,false
指针字面值：nullptr
2.2变量 变量提供一个具名的、可供程序操作的存储空间。数据类型决定着变量所占空间的大小和布局方式、给值能存储的值的范围，以及变量能参与的运算。
通常情况下,对象是指一块能存储数据并具有某种类型的内存空间。（我们在使用对象这个词时，并不严格区分时类还是内置类型，也不区分是否命名或者只读）
2.2.1变量定义 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象当前的值擦除掉，用一个新值带替代。
列表初始化：利用花括号把一个或多个初始值放在一起的初始化形式。
默认初始化：若变量定义时并没有指定初值，则变量被默认初始化，此时变量被赋予了默认值。
定义于函数体内的内置类型对象如果没有被初始化，则其值违背定义。类的对象如果没有显式地初始化，则其值由类确定。建议初始化每一个内置数据类型。
2.2.2变量声明和定义的关系 c&#43;&#43;支持分离式编译（程序分割为如干个文件，每个文件可被独立编译）
声明使得名字位程序所知，定义负责创建与名字关联的实体。
定义还申请了存储空间，也可能位变量夫一个初始值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/00714578b49918b8f1d73bfec01b1361/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-18T22:33:33+08:00" />
<meta property="article:modified_time" content="2021-04-18T22:33:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;primer</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>c++ primer<br> c++定义了几种基本内置类型（字符、整型、浮点数），也提供了自定义数据类型的机制；c++标准库定义了一些更加复杂的数据类型，如可变长字符串和向量。</p> 
<h2><a id="_2"></a>第二章：变量和基本类型</h2> 
<h3><a id="21_4"></a>2.1.基本内置类型</h3> 
<h4><a id="211_5"></a>2.1.1算术类型</h4> 
<p>c++定义的基本数据类型包括算术类型（字符、整型数、布尔值、浮点数）和空类型。算术类型又分为两类：整型（int,字符，bool)和浮点型。<br> 字符：c++提供了几种字符类型，基本的字符类型是char,一个char的空间应确保可以存放机器基本字符集中任意字符对于的数字值（就是说一个char的大小和一个机器字节一样）。wchar_t、char16_t、char32_t用于扩展字符集，wchar_t用于确保可以存放机器最大扩展字符中的任意一个字符，char16_t、char32_t为Unicode字符集服务。<br> 整型：一个int（16位）至少和一个short（16位）一样大，一个long（32位）至少和一个int一样大，一个long long（64位）至少和一个long一样大。<br> 1字节=8bit,字=4or8字节<br> 浮点型：float:1个字（32bit),7个有效位<br> double:2个字（64bit)，16个有效位<br> long double:3or4个字（96or128bit）被用于有特殊要求的硬件<br> 带符号类型（正数、负数、0）和无符号类型（大于零的数）：int、short、long、longlong都是带符号类型的，加上unsigned就可以得到无符号类型。</p> 
<h4><a id="212_15"></a>2.1.2类型转换</h4> 
<p>任意类型→bool:0→false,其它→true<br> bool→任意类型:false→0，true→1<br> 浮点数→整型：仅保留小数点前部分<br> 整数→浮点型：小数部分记为0，若整数所占空间超过浮点型的容量，可导致精度损失。<br> 给无符号类型一个超出它表示范围的值时，结果为对无符号类型表示数值总数取模后的余数。<br> 赋给带符号类型一个产出其表示范围的值是，结果是未定义的。<br> <strong>无符号数与有符号数相加时，先将有符号数转成无符号数（直接给无符号数赋一个负值），再相加。</strong><br> 带符号类型和无符号类型不要混用。</p> 
<h4><a id="213_25"></a>2.1.3字面值常量</h4> 
<p>每个字面值常量都对应着一种数据类型，字面值常量的形式和值决定了它的数据类型。<br> 整型和浮点型字面值：0开头代表八进制、0开头代表十进制、0x开头代表十六进制。整型字面值具体的数据类型由它的值和符号决定。默认十进制字面值的类型是带符号数而八进制和十六进制字面值可能带符号也可能是无符号的。<br> 默认浮点型字面值是一个double<br> 字符和字符串字面值：</p> 
<pre><code class="prism language-cpp"><span class="token string">'a'</span><span class="token comment">//字符字面值</span>
<span class="token string">"hello world"</span><span class="token comment">//字符串字面值</span>
</code></pre> 
<p>字符串字面值的类型实际上是由常量字符构成的数组，编译器在资格字符串的结尾处加上了一个空字符（’\0’），因此，字符串字面值的实际长度比它的内容多1.<br> 转义序列：分为不可打印字符和含有特殊含义的字符。<br> \n 换行符 ，\t 横向制表符 ，等等<br> 指定字面值的类型：通过给添加前缀和后缀可以改变整型、浮点型、字符型字面值的默认类型。字符和字符串字面值：<br> 前缀：u(char16_t) ,U(char32_t),L(wchar_t),u8(char)<br> 整型字面值：<br> 后缀：u orU(unsigned),l orL(long),ll orLL(long long)<br> 浮点型字面值：<br> 后缀：f orF(float),l or L(long double)<br> 布尔字面值：true,false<br> 指针字面值：nullptr</p> 
<h3><a id="22_47"></a>2.2变量</h3> 
<p>变量提供一个具名的、可供程序操作的存储空间。数据类型决定着变量所占空间的大小和布局方式、给值能存储的值的范围，以及变量能参与的运算。<br> 通常情况下,对象是指一块能存储数据并具有某种类型的内存空间。（我们在使用对象这个词时，并不严格区分时类还是内置类型，也不区分是否命名或者只读）</p> 
<h4><a id="221_50"></a>2.2.1变量定义</h4> 
<p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象当前的值擦除掉，用一个新值带替代。<br> 列表初始化：利用花括号把一个或多个初始值放在一起的初始化形式。<br> 默认初始化：若变量定义时并没有指定初值，则变量被默认初始化，此时变量被赋予了默认值。<br> 定义于函数体内的内置类型对象如果没有被初始化，则其值违背定义。类的对象如果没有显式地初始化，则其值由类确定。建议初始化每一个内置数据类型。</p> 
<h4><a id="222_56"></a>2.2.2变量声明和定义的关系</h4> 
<p>c++支持分离式编译（程序分割为如干个文件，每个文件可被独立编译）<br> 声明使得名字位程序所知，定义负责创建与名字关联的实体。<br> 定义还申请了存储空间，也可能位变量夫一个初始值。<br> 若想声明一个变量而非定义它，应该在变量前添加关键字extern,而且不要显示地初始化变量。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">extern</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token comment">//声明i而非定义i</span>
<span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token comment">//声明并且定义j</span>
</code></pre> 
<p>任何包含了显式初始化的声明即成为定义，变量能且只能被定义一次，但是可以被多次声明。<br> 若在多个文件中使用同一个变量，变量的定义必须且只能出现在一个文件中，但是其它用到该变量的文件必须对其进行声明，绝对不能重复定义。<br> c++是一种静态类型语言，其含义是在编译阶段检查类型，其中检查类型的过程称为类型检查。</p> 
<h4><a id="223_70"></a>2.2.3标识符</h4> 
<p>c++的标识符由字母、数字、下划线组成，其中必须以字母或者下划线开头，长度无限制，但对大小写敏感。命名要规范，最好符合驼峰命名规则。</p> 
<h4><a id="224_73"></a>2.2.4名字的作用域</h4> 
<p>同一个名字在不同的作用域中可能指向不同的实体，名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端结束。<br> 内层作用域：被包含的作用域<br> 外层作用域：包含别的作用域的作用域<br> 允许早内存作用域中重新定义外层作用域已有的名字。</p> 
<pre><code class="prism language-cpp">作用域操作符<span class="token operator">::</span>
</code></pre> 
<h3><a id="23_83"></a>2.3复合类型</h3> 
<p>基于其他类型定义的类型,c++中有好几种复合类型，本文介绍引用和指针。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//int 为基本数据类型，a为声明符</span>
</code></pre> 
<h4><a id="231_89"></a>2.3.1引用</h4> 
<p>引用即是为对象起别名，定义引用时，程序把引用和它的初始值绑定在一起，一旦完成初始化，无法重新绑定到另外一个对象。<br> 引用并非对象，它只是为一个已经存在的对象所起的另外一个名字。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment">//引用的定义</span>
<span class="token comment">//引用的标识符要以&amp;开头，并且引用类型要与其绑定的对象严格匹配</span>
<span class="token comment">//引用类型的初始值必须是一个对象</span>
</code></pre> 
<h4><a id="232_100"></a>2.3.2指针</h4> 
<p>与引用类似，指针也实现了对其他对象的间接访问，但指针又与引用相比有很多不同，1、指针本身是一个对象，允许对指针赋值和拷贝，在指针的生命周期内，它可以先后指向几个不同的对象2、指针无需在定义时赋初值，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。<br> 引用不是对象，没有实际地址，所以不能定义指向引用的指针。指针需要和其指向的对象严格匹配（除开两种特殊情况）<br> 指针的值（即地址）应属于下列4种状态之一：<br> 1、指向一个对象<br> 2、指向紧邻对象所占空间的下一个位置<br> 3、空指针，意味着没有指向任何对象<br> 4、无效指针，上述情况之外的其他值（试图拷贝或者以其它方式访问无效指针的值都将引发错误）<br> 解引用操作仅适用于那些确实指向了某个对象的有效指针。<br> 在声明语句中，&amp; *用于组成符合类型，在表达式中，它们又变成了运算符。<br> 空指针：不指向任何对象，生成空指针的三种方法：``</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//nullptr是一种特殊类型的字面值，可以被转换成任意其它的指针类型</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//指针初始化为字面值0来生成指针</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p3<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//NULL预处理变量，它的值就是0</span>
<span class="token comment">//建议初始化所有指针，并在对象定义完成之后再去定义指向它的指针。</span>
</code></pre> 
<p>赋值和指针：若想搞明白到底是改变了指针的值还是改变了指针所指向对象的值，应该记住赋值改变的永远是等号左侧的对象。<br> 若指针存放的地址相等，则他们相等，否则他们不等。（相等有三种可能：都为空，都指向同一个对象，或者都指向了同一个对象的下一地址）<br> void * 指针<br> void *指针是一种特殊类型的指针，可用于存放任意对象的地址`</p> 
<pre><code class="prism language-cpp"><span class="token keyword">double</span> obj<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">,</span><span class="token operator">*</span>pd<span class="token operator">=</span><span class="token operator">&amp;</span>obj<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token operator">*</span>pv<span class="token operator">=</span><span class="token operator">&amp;</span>obj<span class="token punctuation">;</span><span class="token comment">//void *能存放任意类型对象的地址，obj可以是任意类型的对象</span>
pv<span class="token operator">=</span>pd<span class="token punctuation">;</span><span class="token comment">//pv是可以存放任意类型的指针</span>
</code></pre> 
<p>void *来看内存空间也仅仅是内存空间，没办法获取内存空间中所存的对象（即不能进行解引用操作）。</p> 
<h4><a id="233_130"></a>2.3.3理解复合类型的声明</h4> 
<p>一条定义语句可以定义出不同类型的变量：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token operator">*</span>P<span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token operator">&amp;</span>r<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment">//(*  &amp;为类型修饰符)</span>
<span class="token keyword">int</span><span class="token operator">*</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">;</span><span class="token comment">//基本数据类型是int 而非int*   此条语句定义了指针p1,还有int 的p2</span>
</code></pre> 
<p>指向指针的指针：声明符中修饰符（&amp; *）的个数并没有限制，当多个修饰符连写在一起时，按照逻辑解释即可。<br> 以指针为类：指针时内存中的对象，像其它对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。</p> 
<ul><li>指针 **指向指针的指针 ***指向指针的指针的指针</li></ul> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> ival<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>pi<span class="token operator">=</span><span class="token operator">&amp;</span>ival<span class="token punctuation">;</span><span class="token comment">//pi指向一个int型的数</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>ppi<span class="token operator">=</span><span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token comment">//ppi指向一个int型的指针</span>
</code></pre> 
<p>指向指针的引用：<br> 引用本身不是一个对象，因此不能定义指向引用的指针，但指针是对象，所以存在对指针的引用。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">//p是一个int型的指针</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">&amp;</span>r<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment">//r是一个对指针p的引用</span>
r<span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//r引用了一个指针，因此给r赋值&amp;i  就是令p指向了i</span>
<span class="token operator">*</span>r<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//解引用r得到i,也就是p指向的对象，将i的值改为0</span>
</code></pre> 
<p>要理解r的类型是到底是什么，最简单的办法就是从右至左阅读r的定义，<strong>离变量名最近的符号对变量名有直接的影响</strong></p> 
<h3><a id="24const__158"></a>2.4const 限定符</h3> 
<p>const对象一旦创建其值就不能再改变，所以const对象必须初始化。<br> 默认状态下，const对象仅在文件内有效，当多个文件中出现了同名的const变量时，其实在等同于在不同文件中分别定义了独立的变量。<br> 若想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p> 
<h4><a id="241const_162"></a>2.4.1const的引用</h4> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1<span class="token operator">=</span>ci<span class="token punctuation">;</span><span class="token comment">//引用及其对应的对象都是常量</span>
r1<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//错误，r1是对常量的引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r2<span class="token operator">=</span>ci<span class="token punctuation">;</span><span class="token comment">//错误，试图让一个非常量引用指向一个常量对象</span>
</code></pre> 
<p>引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。<br> 初始化和对const的引用：<br> 2.3.1提到引用的类型必须与其所引用对象的类型一致，但是有两个例外。<br> 例外一：在初始化常量引用时，允许用任意表达式作为初始值，只要表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r1<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment">//允许将const int &amp;绑定到一个普通int上</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//正确，r2是一个常量引用</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r3<span class="token operator">=</span>r1<span class="token operator">*</span><span class="token number">2</span>；
</code></pre> 
<pre><code class="prism language-cpp"><span class="token keyword">double</span> dval <span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> ri<span class="token operator">=</span>dval<span class="token punctuation">;</span>等价于<span class="token keyword">const</span> <span class="token keyword">int</span> temp<span class="token operator">=</span>dval<span class="token punctuation">;</span><span class="token comment">//让双精度浮点数生成一个临时的整型变量 cosnt int &amp;ri=temp;//让ri绑定这个临时量</span>
</code></pre> 
<p>对const的引用可能引用一个并非const的对象</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r1<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment">//引用r1绑定对象i</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2<span class="token operator">=</span>i<span class="token punctuation">;</span><span class="token comment">//r2也绑定了对象i,但是不能通过r2修改i的值</span>
r1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//r1并非常量，i的值修改为0</span>
r2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//错误，r2是一个常量引用，不能修改</span>
</code></pre> 
<h4><a id="242const_194"></a>2.4.2指针和const</h4> 
<p>指向常量的指针不能用于改变其所指对象的值，要想存放存放常量的地址，只能使用指向常量的指针。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token comment">//pi是个常量，它的值不能改变</span>
<span class="token keyword">double</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token comment">//错误：ptr是一个普通指针</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span>cptr <span class="token operator">=</span><span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token comment">//正确，cptr可以指向双精度常量。只能使用指向常量的指针</span>
<span class="token operator">*</span>cptr<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span><span class="token comment">//错误：不能给*cptr赋值</span>
</code></pre> 
<p>指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其它途径改变。<br> const指针：<br> 常量指针必须初始化，而且一旦初始化完成，则它的值（即存放在指针中的那个地址）就不能再改变了。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> errNum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> curErr<span class="token operator">=</span><span class="token operator">&amp;</span>errNumb<span class="token punctuation">;</span><span class="token comment">//常量指针，不变的是指针本身的值</span>
<span class="token comment">//curErr本身是一个常量对象，而*意味着是一个常量指针，int确定了常量指针指向的是一个int对象。</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> <span class="token operator">*</span><span class="token keyword">const</span> pip<span class="token operator">=</span><span class="token operator">&amp;</span>pi<span class="token punctuation">;</span><span class="token comment">//pip是一个指向常量对象的常量指针。</span>
</code></pre> 
<p>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。</p> 
<h4><a id="243const_213"></a>2.4.3顶层const</h4> 
<p>指针本身是不是常量以及指针所指对象是不是常量是两个相互独立的问题；<br> <strong>顶层const:表示指针本身是个常量，更一般的，可以表示任意的对象是个常量，这一点对任何数据类型都适用，如算术类型、类、指针。<br> 底层const:表示指针所指对象是一个常量，与指针和引用等复合类型的基本类型部分有关</strong><br> 但是指针既可以是顶层const,也可以是底层const。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p3<span class="token operator">=</span>p2<span class="token punctuation">;</span><span class="token comment">//第一个const表示指针所指对象是一个常量为底层const,第二个const表示指针是个常量为顶层const</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r<span class="token operator">=</span>ci<span class="token punctuation">;</span>
</code></pre> 
<h4><a id="244constexpr_223"></a>2.4.4constexpr和常量表达式</h4> 
<p>常量表达式：指值不会改变并且在编译过程就能得到计算结果的表达式。<br> 一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> max<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span><span class="token comment">//是</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> sz<span class="token operator">=</span><span class="token function">get_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不是，因为sz 的具体值知道运行时才能获取</span>
</code></pre> 
<p>constexpr变量：<br> 允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个变量表达式。（一般来说，认定变量是以一个常量表达式，那么就把它声明成constexpr类型）<br> 字面值类型：算术类型、引用和指针都属于字面值类型；自定义类、IO库、string类型不属于字面值类型，就不能把他们定义为constexpr。<br> 一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。<br> 指针和constexpr:<br> 限定符constexpr仅对指针有效，与指针所指对象无关：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//p是一个指向常量的指针</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token comment">//q是一个指向整数的常量指针</span>
</code></pre> 
<p>constexpr把它所定义的对象置为了顶层const。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//p是常量指针，指向整型常量i</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token operator">=</span><span class="token operator">&amp;</span>j<span class="token punctuation">;</span><span class="token comment">//p1是常量指针，指向整数j</span>
</code></pre> 
<h3><a id="25_248"></a>2.5处理类型</h3> 
<h4><a id="251_249"></a>2.5.1类型别名</h4> 
<p>类型别名是一个名字，它是某种类型的同义词，有两种方法可以定义类型别名，1、传统的方法是使用typedef 2、别名声明来定义类型的别名</p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">double</span> wages<span class="token punctuation">;</span><span class="token comment">//wages是double的同义词</span>
<span class="token keyword">typedef</span> <span class="token keyword">double</span> base<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">//base是double的同义词，p是double*的同义词</span>
<span class="token comment"></span>
<span class="token keyword">using</span> SI<span class="token operator">=</span>sales_item<span class="token punctuation">;</span><span class="token comment">//SI是sales_item的同义词</span>
</code></pre> 
<p>类型别名等价于类型，两者在任何地方可以互换。<br> 指针、常量和类型名：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span> pstring<span class="token punctuation">;</span><span class="token comment">//pstring 是char *的别名，即pstring是指向char型的指针</span>
<span class="token keyword">const</span> pstring cstr<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//cstr是指向char的常量指针</span>
<span class="token keyword">const</span> pstring <span class="token operator">*</span>ps<span class="token punctuation">;</span><span class="token comment">//ps是一个指针，它指向的对象是 指向char的常量指针</span>
</code></pre> 
<h4><a id="252auto_265"></a>2.5.2auto类型说明符</h4> 
<p>利用auto就可以让编译器替我们去分析表达式所属的类型，auto让编译器通过初始值来推算变量的类型，显然，auto定义的变量必须有初始值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">;</span><span class="token comment">//正确：i是整数，p是整型指针</span>
<span class="token keyword">auto</span> sz<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>pi<span class="token operator">=</span><span class="token number">3.14</span><span class="token punctuation">;</span><span class="token comment">//错误，一个整型，一个浮点型</span>
</code></pre> 
<h4><a id="253auto_272"></a>2.5.3复合类型、常量和auto</h4> 
<ul><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> List item</li></ul> 
<p>auto一般会忽略顶层const,而底层const会保留下来</p> 
<h4><a id="253decltype_279"></a>2.5.3decltype类型指示符</h4> 
<p>希望从表达式的类型推断出要定义的变量的类型，但是又不想用该表达式的值初始化变量。decltype的作用是选择并返回操作数的数据类型。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> ci<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>cj<span class="token operator">=</span>ci<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>ci<span class="token punctuation">)</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//x的类型是const int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> y<span class="token operator">=</span>x<span class="token punctuation">;</span><span class="token comment">//y的类型是const int &amp;,y绑定到了x</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>cj<span class="token punctuation">)</span> z<span class="token punctuation">;</span><span class="token comment">//错误：z是一个引用，必须初始化</span>
</code></pre> 
<p>decltype和引用：<br> 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token operator">=</span><span class="token operator">&amp;</span>i<span class="token punctuation">,</span><span class="token operator">&amp;</span>r<span class="token operator">=</span>i<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>r<span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span> b<span class="token punctuation">;</span><span class="token comment">//正确，r+0的结果是int,b也是一个int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> c<span class="token punctuation">;</span><span class="token comment">//错误，解引用操作将会得到引用类型，得到int &amp;，引用类型必须初始化</span>
</code></pre> 
<p>decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；<br> 如果加上了一层或多层括号，编译器会把它当成一个表达式。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> d<span class="token punctuation">;</span><span class="token comment">//错误，双层括号的结果永远是引用，引用必须初始化</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> e<span class="token punctuation">;</span><span class="token comment">//正确,e是一个未初始化的int</span>
</code></pre> 
<h3><a id="26_304"></a>2.6自定义数据结构</h3> 
<p>数据结构：把一组数据元素组织起来然后使用他们的策略和方法。<br> 类的数据成员定义了类的对象的具体内容，可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将会被默认初始化。<br> 为了确保各个文件中的类定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应该与类的名字一样。<br> 头文件通常只包含那些只能被定义一次的实体，如类、const、和constexpr变量 等。<br> 预处理器：是在编译之前执行的一段程序，可以部分地改变我们所写的程序。<br> 头文件保护符：依赖于预处理变量（已定义的和未定义）<br> #define指令把一个名字设定为预处理变量<br> 另外两个指令则分别检查某个指令的预处理变量是否定义：<br> #ifdef 当且仅当 变量已定义时为真<br> #ifndef当且仅当变量未定义时为真</p> 
<h2><a id="__316"></a>第三章 字符串、向量和数组</h2> 
<p>vector 存放的是某种给定类型对象的可变长序列。</p> 
<h3><a id="31using_319"></a>3.1命名空间的using声明</h3> 
<p>头文件不应该包含using声明。<br> std::cin的含义是：作用域操作符（::）编译器应该从操作符的左侧名字所示的作用域中寻找右侧那个名字。</p> 
<h3><a id="32string_322"></a>3.2标准库类型string</h3> 
<p>如何初始化类的对象由类的本身决定，一个类可以定义很多种初始化对象的方式。</p> 
<pre><code class="prism language-cpp">string s1<span class="token punctuation">;</span>
string <span class="token function">s2</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝初始化</span>
string s2<span class="token operator">=</span>s1<span class="token punctuation">;</span><span class="token comment">//拷贝初始化</span>
string <span class="token function">s3</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接初始化</span>
string s3<span class="token operator">=</span><span class="token string">"value"</span><span class="token punctuation">;</span><span class="token comment">//拷贝初始化</span>
string <span class="token function">s4</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接初始化</span>
string s8<span class="token operator">=</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝初始化，对多个值进行初始化的情况，非要用拷贝初始化的方式也可以，此时需要显式地创建一个（临时）对象用于拷贝。</span>
</code></pre> 
<p>直接初始化：不使用等号，<br> 拷贝初始化:用等号（=)初始化一个变量，实际上执行的是拷贝初始化。</p> 
<pre><code class="prism language-cpp">os<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">;</span><span class="token comment">//将s写到输出流os中，返回os</span>
is<span class="token operator">&gt;&gt;</span>s<span class="token punctuation">;</span><span class="token comment">//将is中读取数据串赋给s,字符串以空白分隔，返回is</span>
<span class="token function">getline</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从is中读取一行赋给s,返回is</span>
</code></pre> 
<p>读取未知数量的string对象：</p> 
<pre><code class="prism language-cpp">string word<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>cin<span class="token operator">&gt;&gt;</span>word<span class="token punctuation">)</span><span class="token comment">//反复读取，直至到达文件末尾</span>
<span class="token punctuation">{<!-- --></span>
cout<span class="token operator">&lt;&lt;</span>word<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//逐个输出单词，每个单词后面紧跟一个换行</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用getline读取一整行</p> 
<pre><code class="prism language-cpp">string line<span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//每次读入一整行，直至到达文件末尾</span>
<span class="token punctuation">{<!-- --></span>
cout<span class="token operator">&lt;&lt;</span>line<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>string::size_type类型是size函数的返回类型，size_type是一个无符号类型的值，而且能存放任何string对象的大小。允许通过auto和decltype来推断变量的类型。<br> string的比较规则：1、若两个string的长度相同，并且短的string与长的string对应的字符都相同，就说短string对象小于较长string对象<br> 2、若两个string对象在某些对应位置上不同，其实是在比较第一组相异字符的结果<br> 字面值和string相加：<br> 因为标准库允许把字符字面值和字符串字面值转换成string对象，所以在需要string对象的地方就可以使用这两种字面值来替代。<br> 当string对象和字符字面值及字符串字面值混在一再语句中，必须确保每个加号运算符（+）的两侧运算对象至少有一个是string。</p> 
<pre><code class="prism language-cpp"><span class="token function">isspace</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断是否空白</span>
<span class="token function">toupper</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//若是小写，则输出对应的大写</span>
</code></pre> 
<p>c++兼容了c,c语言的头文件形如name.h,c++则将这些命名位cname。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//范围for语句</span>
<span class="token comment">//for(declaration:expression)</span>
<span class="token comment">//statement</span>
<span class="token comment">//expression是一个对象，declaration定义一个变量，该变量会用于访问序列中的</span>
<span class="token comment">//基础元素，每次迭代，declaration部分的变会被初始化为expression部分的下一</span>
<span class="token comment">//个元素值</span>
string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"some string"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> c<span class="token operator">:</span>str<span class="token punctuation">)</span><span class="token comment">//对于str中的每个字符</span>
cout<span class="token operator">&lt;&lt;</span>c<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment">//输出当前字符，后面紧跟一个换行符</span>
</code></pre> 
<p>若想使用范围for改变字符串中的字符，需把循环变量定义成引用类型。</p> 
<pre><code class="prism language-cpp">string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>c<span class="token operator">:</span>s<span class="token punctuation">)</span><span class="token comment">//对于s中的每个字符</span>
<span class="token punctuation">{<!-- --></span>
c<span class="token operator">=</span><span class="token function">toupper</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//c是一个引用，因此赋值语句将改变s中字符的值</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="33vector_394"></a>3.3标准库类型vector</h3> 
<p>c++语言既有类模板，也哟哟函数模板，vector是一个类模板。编译器根据模板创建类或者函数的过程被称作实例化。当使用模板时，需要指出编译器应把类或者函数实例成何种类型。</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v1<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">v2</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v2<span class="token operator">=</span>v1<span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">v3</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">v4</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//v4包含了n个重复执行了值初始化的对象</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v5<span class="token punctuation">{<!-- --></span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> v5<span class="token operator">=</span><span class="token punctuation">{<!-- --></span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>不能等价使用的初始化方式的两种类外：<br> 1、使用拷贝（=）初始化时，只能提供一个初始值<br> 2、若提供的是一个类内初始值，则只能用拷贝初始化或使用花括号的形式初始化。</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> v6<span class="token punctuation">{<!-- --></span><span class="token string">"hi"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//错误：不能使用字符串字面值构建vector对象</span>
</code></pre> 
<p>vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。</p> 
<h3><a id="34_415"></a>3.4迭代器介绍</h3> 
<p>有效迭代器或者指向某个元素，或者指向容器中尾元素的下一位置。<br> end迭代器被称为尾后迭代器，特殊情况下（如果容器为空，则begin和end返回的是同一个迭代器）。<br> end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或者解引用操作。<br> c++要养成使用迭代器！=的习惯，就不用在意是那种容器类型。</p> 
<pre><code class="prism language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>const_iterator it3<span class="token punctuation">;</span><span class="token comment">//it3只能读元素，不能写元素</span>
string<span class="token operator">::</span>const_iterator it4<span class="token punctuation">;</span><span class="token comment">//it4只能读字符，不能写字符</span>
iter1<span class="token operator">-</span>iter2<span class="token punctuation">;</span><span class="token comment">//两个迭代器相减的结果是它们之间的距离，参与运算的两个迭代器必</span>
<span class="token comment">//须指向的是同一个容器中的元素或者尾元素的下一位置。其类型是名为difference_type的带符号型整数。</span>
</code></pre> 
<h3><a id="35_427"></a>3.5数组</h3> 
<p>数组的元素是对象，因此不存在引用的数组。<br> 显式初始化数组。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> unsinged sz<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> ia<span class="token punctuation">[</span>sz<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a3<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
string a4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">"hi"</span><span class="token punctuation">,</span><span class="token string">"bye"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>字符数组有一种额外的初始化形式，可用字符串字面值对此类数组初始化。<br> 使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其它字符一样被拷贝到字符串数组当中去：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//列表初始化，没有空字符</span>
<span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{<!-- --></span><span class="token string">'C'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//列表初始化，含有显式的空字符</span>
<span class="token keyword">char</span> a3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"C++"</span><span class="token punctuation">;</span><span class="token comment">//自动添加表示字符串结束的空字符，表示这里有4个字符</span>
</code></pre> 
<p>数组不允许拷贝和赋值，不能将数组的内容拷贝给其它数组作为初始值，也不能使用数组为其它数组赋值。<br> 理解复杂的数组声明：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">*</span>ptrs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//ptrs是含有10个整型指针的数组</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//错误定义：不存在引用的数组。</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>Parray<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">&amp;</span>arr<span class="token punctuation">;</span><span class="token comment">//Parray是一个指针，它指向一个int数组，数组中包含10个元素；可理解为Parray是指向一个含有10个整数的数组。</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arrRef<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">;</span><span class="token comment">//arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型为int;可理解为arrRef引用一个含有10个整数的数组。</span>
</code></pre> 
<p>数组下标通常定义为size_t类型，size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象得大小。<br> c风格字符串：字符串存放在字符数组中并以空字符结束。以空字符结束的意思是在字符串最后得一个字符后面跟着一个空字符（’\0’）。一般用指针来操作这些字符串。<br> 任何出现字符串字面值的地方都可以用空字符结束的字符数组来替代：<br> c++应当尽量使用vector和迭代器，避免使用内置数组和指针；应当尽量使用string,避免使用c风格的基于数组的字符串。</p> 
<h3><a id="36_458"></a>3.6多维数组</h3> 
<p>多维数组指的是数组的数组，对于二维数组来说，常把第一个维度称为行，第二个维度称为列。<br> 使用范围for语句处理多维数组</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>row<span class="token operator">:</span>ia<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>col<span class="token operator">:</span>row<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
col<span class="token operator">=</span>cnt<span class="token punctuation">;</span>
cnt<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>getline首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。<br> 实例化：编译器生成一个模板类或函数的过程。<br> 值初始化：是一种初始化过程，内置类型初始化为0，类类型由类的默认构造函数初始化；只有当类包含默认构造函数时，该类的对象才能被值初始化。<br> a-&gt;b运算符等价于(*a).b;<br> &lt;&lt;运算符：该运算符负责输出string对象中的字符<br> 运算符&gt;&gt;:输入运算符，负责读入一组字符，遇到空白就停止，读入的内容赋给运算符右侧的运算对象，该运算对象是一个string对象。</p> 
<h2><a id="_480"></a>第四章、表达式</h2> 
<p>表达式由一个或多个运算对象组成，对表达式求值将得到一个结果，字面值和变量是最简单的表达式，其结果就是字面值和变量的值。</p> 
<h3><a id="41_482"></a>4.1基础</h3> 
<p>小整数类型（char、bool、short等）通常会被提升成较大的整数类型（主要是int）。<br> 重载运算符：当运算符作用于类类型的运算对象时，用户可以自行定义其含义，这种定义事实上是为已存在的运算符赋予了另外一层含义，所以称之为重载运算符。<br> <strong>左值：指那些求值结果为对象或函数的表达式。一个表示对象的非常量左值可以作为赋值运算符的左侧运算对象。<br> 右值：指一种表达式，其结果是值而非值所在的位置。<br> 归纳：当一个对象被用作右值的时候，用的是对象的值（内容），当对象被用作左值的时候，用的是对象的身份（在内存的位置）。</strong></p> 
<h3><a id="42_488"></a>4.2算术运算符</h3> 
<p>算术运算符（+、-、*、\、%）的运算对象和求值结果都是右值。<br> 在求表达式之前，小整数类型的运算对象被提升为较大的整数类型，所有的运算对象最终会转换成同一类型。<br> 取余的运算对象必须是整数类型。</p> 
<h3><a id="43_493"></a>4.3逻辑和关系运算符</h3> 
<p>关系运算符（！、&lt;、&lt;=、&gt;、&gt;=、==、！=）作用于算术类型或指针类型；<br> 逻辑运算符（&amp;&amp;、||）作用于任意能转换成布尔值的类型；此两类运算符的运算对象和求值结果都是右值。<br> &amp;&amp;：逻辑与运算符，只有当左侧运算对象为真时，才对右侧运算对象求值。<br> ||：逻辑或运算符，只有当左侧运算对象为假时，才对右侧运算对象求值。</p> 
<h3><a id="44_499"></a>4.4赋值运算符</h3> 
<p>赋值运算符的左侧运算对象必须是一个可修改的左值。<br> 赋值运算符的结果是它的左侧运算对象，并且是一个左值。相应的。结果的类型就是左侧运算对象的类型。如果赋值运算符的两个运算对象类型不相同，则右侧运算对象将转成左侧运算对象的类型。</p> 
<h3><a id="45_502"></a>4.5递增和递减运算符</h3> 
<p>递增和递减运算符有两种形式：前置版本和后置版本。<br> ++i:先执行++的操作，再把递增后的值给到对象<br> i++:先把值给对象，再进行递增<br> 递增递减运算符必须作用于左值运算对象。<br> 后置递增运算符的优先级高于解引用运算符，*p++等价于 *（p++）;<br> <strong>建议使用前置运算符。</strong></p> 
<h3><a id="46_509"></a>4.6成员访问运算符</h3> 
<p>ptr-&gt;mem等价于(*ptr).mem;点运算符优先级高于解引用运算符。</p> 
<h3><a id="47_512"></a>4.7条件运算符</h3> 
<p>cond？expr1:expr2;<br> 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果时左值，否则运算的结果是右值。</p> 
<h3><a id="48_515"></a>4.8位运算符</h3> 
<p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能。<br> 运算符（~、&lt;&lt;、&gt;&gt;、&amp;、^、|）位求反、左移、右移、位与、位异或、位或。强烈建议仅将位运算符用于处理无符号类型。<br> 移位运算符：<br> 左移运算符&lt;&lt;:在右侧插入值为0的二进制位；<br> 右移运算符&gt;&gt;:若运算对象是无符号类型：在左侧插入值为0的二进制位；<br> 若运算对象是带符号类型，在左侧插入符号的副本或值为0的二进制位。</p> 
<h3><a id="49sizeof_523"></a>4.9sizeof运算符</h3> 
<p>sizeof运算符返回一条表达式或者一个类型名字所占的字节数。sizeof运算符满足右运算律，其所得值是一个size_t类型的常量表达式。</p> 
<pre><code class="prism language-cpp">Sales_data data<span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token keyword">sizeof</span><span class="token punctuation">(</span>Sales_data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//存储Sales_data类型的对象所占空间的大小</span>
<span class="token keyword">sizeof</span> data<span class="token punctuation">;</span><span class="token comment">//data类型的大小，即sizeof(Sales_data)</span>
<span class="token keyword">sizeof</span> p<span class="token punctuation">;</span><span class="token comment">//指针所占的空间</span>
<span class="token keyword">sizeof</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token comment">//p所指类型的空间大小，即sizeof(Sales_data)</span>
<span class="token keyword">sizeof</span> data<span class="token punctuation">.</span>revenue<span class="token punctuation">;</span><span class="token comment">//Sales_data的revenue成员对应类型的大小</span>
<span class="token keyword">sizeof</span> Sales_data<span class="token operator">::</span>revenue<span class="token punctuation">;</span><span class="token comment">//另一种获取revenue大小的方式</span>
</code></pre> 
<p>对char或者类型为char的表达式执行sizeof运算；<br> 对引用类型执行sizeof运算得到被引用对象所占空间的大小；<br> 对指针指向sizeof运算得到指针本身所占空间的大小；<br> 对解引用指针执行sizeof运算得到指针指向的对象所占的空间大小<br> 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。<br> 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多空间。</p> 
<h3><a id="410_542"></a>4.10逗号运算符</h3> 
<p>按照从左向右的顺序依次求值。逗号运算符真正的结果是右侧表达式的值，如果右侧运算对象是左值，那么最终求值的结果也是左值。</p> 
<h3><a id="411_544"></a>4.11类型转换</h3> 
<p>若两种类型可以互相转换，那么它们就是关联的。<br> 隐式转换：根据类型转换规则设法将运算对象的类型同一后求值。<br> 隐式转换发生的情况：<br> 1、比int类型小的整数值首先提升为较大的整数类型<br> 2、在条件中，非布尔值转成布尔类型<br> 3、初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型<br> 4、算术运算或者关系运算的运算对象有多种类型，需要转换成同一种类型<br> 5、函数调用时也会发生类型转换</p> 
<h4><a id="4111_553"></a>4.11.1算术转换</h4> 
<p>算术转换：把一种算术类型转换成另外一种算术类型，算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。<br> 当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型。<br> 整型提升：负责把小整数类型转换成较大的整数类型<br> bool,char,signed char,unsigned char,short,unsigned short能提升到int类型。<br> 无符号类型的运算对象：<br> 一个运算对象为无符号类型、另一个运算对象为带符号类型：<br> 1、无符号类型≥带符号类型，则带符号的运算对象转换成无符号的<br> 2、无符号类型&lt;带符号类型，（1）、若无符号能存入带符号中，则无符号转换成带符号（2）、若无符号不能转换成带符号，则带符号转换成无符号。</p> 
<h4><a id="4112_562"></a>4.11.2其它隐式类型转换</h4> 
<p>数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//定义了一个10元素数组</span>
<span class="token keyword">int</span> <span class="token operator">*</span>ip<span class="token operator">=</span>ia<span class="token punctuation">;</span><span class="token comment">//ia转换成指向数组首元素的指针</span>
</code></pre> 
<p>指针的转换：常量整数值0和字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*;指向任意对象的指针能转换成const void*.</p> 
<h4><a id="4113_569"></a>4.11.3显式转换</h4> 
<p>强制类型转换：一种显式的类型转换。<br> cast-name(expression);<br> type:转换的目标类型<br> expression：要转换的值<br> 若type是引用类型，则结果是左值。<br> cast-name(static_cast、dynamic_cast、const_cast、reinterpret_cast其中的一种)，dynamic_cast支持允许时的类型识别。<br> static_cast:任何具有明确定义的类型转换，只要不包含底层const,都可以使用static_cast。<br> const_cast:只能改变运算对象的底层const<br> reinterpret_cast:把运算对象的内容解释为另外一种类型。</p> 
<h2><a id="_579"></a>第五章：语句</h2> 
<p>c++提供了一组控制流语句以及支持更复杂的执行路径。</p> 
<h3><a id="53_581"></a>5.3条件语句</h3> 
<p>有两种按条件执行的语句：一种是if语句，它根据条件决定控制流；<br> 另外一种是switch语句，计算一个整型表达式，根据这个整型表达式的值从几条执行路径选一条。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">switch</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">case</span> <span class="token string">'a'</span><span class="token operator">:</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> <span class="token string">'b'</span><span class="token operator">:</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> <span class="token string">'c'</span><span class="token operator">:</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>break语句用来中断当前的控制流；此例中，break语句将控制权转移到switch语句外面。case分支后面的break语句不能省略。<br> default标签：若没有任何一个标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。<br> c++规定不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。</p> 
<h3><a id="54_599"></a>5.4迭代语句</h3> 
<h4><a id="541while_600"></a>5.4.1while语句：</h4> 
<p>当不确定到底要迭代多少次时，使用while循环比较合适；还有就是想在循环结束后访问循环控制变量。</p> 
<h4><a id="542for_602"></a>5.4.2for语句：</h4> 
<p>for(int i=0;i&lt;10;++i);<br> for运行的步骤：<br> 1、循环开始时，先执行int i=0;<br> 2、接下来判断是否i&lt;10,若条件为真，则执行for循环体的内容；否则循环终止。<br> 3、最后执行++i；第2、3步重复执行，直到不满足条件终止。</p> 
<h4><a id="543for_608"></a>5.4.3范围for语句</h4> 
<p>for(auto &amp;r:v)<br> {<!-- --></p> 
<p>}<br> auto 定义一个变量，序列中每个元素都能转换成该变量的类型；每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行语句块。</p> 
<h4><a id="544_do_while_614"></a>5.4.4 do while语句</h4> 
<p>do while 先执行依次循环，再检查条件。</p> 
<h3><a id="55_617"></a>5.5跳转语句</h3> 
<p>c++提供了4种跳转语句：break、continue、goto、return</p> 
<h4><a id="551break_619"></a>5.5.1break语句</h4> 
<p>break负责终止离它最近的while、do while、for或者switch语句，并从这些语句之后的第一条语句开始继续执行。</p> 
<h4><a id="552continue_621"></a>5.5.2continue语句</h4> 
<p>continue语句终止最近的循环中的当前迭代并立即开始下一次迭代；continue只能出现在for、while、do while 循环的内部。</p> 
<h4><a id="553goto_623"></a>5.5.3goto语句</h4> 
<p>语法形式：goto label;<br> 带标签语句是一种特殊的语句，在它之前有一个标识符以及一个冒号：<br> 如：end :return;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8eb930be458be20a2753a06edc04da49/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【洛谷算法1-7】【搜索DFS】习题解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94581f4675a8fa0f3d8e603aa1344a33/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图神经网络07-从零构建一个电影推荐系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>