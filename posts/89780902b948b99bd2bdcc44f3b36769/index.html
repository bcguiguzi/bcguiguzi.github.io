<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring bean的作用域 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring bean的作用域" />
<meta property="og:description" content="默认作用域 Spring IOC容器中，默认的bean作用域有两种：
singleton，这种作用域的bean一旦创建后bean的生命周期和容器同步，只有容器关闭时才会销毁这种bean，相同id的bean在容器的生命周期内只会被实例化一次，通过相同的id向容器请求时会返回相同的实例prototype，这种作用域的bean不会交给容器托管，创建之后不会注册到容器，它的生老病死完全由应用层决定，每次通过相同的id向容器请求bean时，容器都会创建一个不同的实例 自定义作用域 Spring框架提供了扩展机制让使用者自定义作用域，框架提供了两个关键的类实现自定义作用域
org.springframework.beans.factory.config.Scope接口，需要实现以下几个关键方法：
Object get(String name, ObjectFactory&lt;?&gt; objectFactory)，使用者可以通过调用这个方法获取该作用域的bean实例，实现的大致逻辑应该，先作用域范围查找是否存在相应name的bean，如果存在直接返回，如果不存在调用objectFactory参数的getObject方法创建bean并且缓存在该作用域内Object remove(String name)，使用者可以调用这个方法在该作用域下删除指定name的beanvoid registerDestructionCallback(String name, Runnable callback)，注册bean的析构回调，作用域对象需要保存这写回调并且在bean被销毁触发这些回调Object resolveContextualObject(String key) org.springframework.beans.factory.config.CustomScopeConfigurer，这是一个BFPP，它的职责是把作用域注册到容器中
示例代码 下面通过一个例子来演示怎么自定义作用域并且分析框架中的代码自定义作用域是怎么实现，这个自定义scope的功能是把bean缓存到一个LRU缓存中，当bean被踢出缓存时触发析构回调
实现Scope接口，LRU缓存中最多只能放两个bean，被踢掉的bean会触犯析构回调，在removeEldestEntry方法中，析构回调保存在destructionCallback哈希表中：
public class LRUCacheScope implements Scope { private class BeanCache extends LinkedHashMap&lt;String, Object&gt; { private static final long serialVersionUID = -887300667768355251L; @Override protected boolean removeEldestEntry(Entry&lt;String, Object&gt; eldest) { boolean flag = size() &gt; maxBeanNumber; if (flag) { executeDesCallback(eldest.getKey()); } return flag; } } private static final int DEFAULT_MAX_BEAN_NUMBER = 2; private Map&lt;String, Object&gt; beanCache = Collections ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/89780902b948b99bd2bdcc44f3b36769/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-03-01T22:17:37+08:00" />
<meta property="article:modified_time" content="2015-03-01T22:17:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring bean的作用域</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>默认作用域</h2> 
<p>Spring IOC容器中，默认的bean作用域有两种：</p> 
<p></p> 
<ul><li>singleton，这种作用域的bean一旦创建后bean的生命周期和容器同步，只有容器关闭时才会销毁这种bean，相同id的bean在容器的生命周期内只会被实例化一次，通过相同的id向容器请求时会返回相同的实例</li><li>prototype，这种作用域的bean不会交给容器托管，创建之后不会注册到容器，它的生老病死完全由应用层决定，每次通过相同的id向容器请求bean时，容器都会创建一个不同的实例</li></ul> 
<p></p> 
<h2>自定义作用域</h2> 
<p>Spring框架提供了扩展机制让使用者自定义作用域，框架提供了两个关键的类实现自定义作用域</p> 
<p>org.springframework.beans.factory.config.Scope接口，需要实现以下几个关键方法：<br> </p> 
<p></p> 
<ul><li>Object get(String name, ObjectFactory&lt;?&gt; objectFactory)，使用者可以通过调用这个方法获取该作用域的bean实例，实现的大致逻辑应该，先作用域范围查找是否存在相应name的bean，如果存在直接返回，如果不存在调用objectFactory参数的getObject方法创建bean并且缓存在该作用域内</li><li>Object remove(String name)，使用者可以调用这个方法在该作用域下删除指定name的bean</li><li>void registerDestructionCallback(String name, Runnable callback)，注册bean的析构回调，作用域对象需要保存这写回调并且在bean被销毁触发这些回调</li><li>Object resolveContextualObject(String key)</li></ul> 
<p></p> 
<p>org.springframework.beans.factory.config.CustomScopeConfigurer，这是一个BFPP，它的职责是把作用域注册到容器中<br> </p> 
<h3>示例代码</h3> 
<p>下面通过一个例子来演示怎么自定义作用域并且分析框架中的代码自定义作用域是怎么实现，这个自定义scope的功能是把bean缓存到一个LRU缓存中，当bean被踢出缓存时触发析构回调</p> 
<p>实现Scope接口，LRU缓存中最多只能放两个bean，被踢掉的bean会触犯析构回调，在removeEldestEntry方法中，析构回调保存在destructionCallback哈希表中：</p> 
<p></p> 
<pre><code class="language-java">public class LRUCacheScope implements Scope {

	private class BeanCache extends LinkedHashMap&lt;String, Object&gt; {

		private static final long serialVersionUID = -887300667768355251L;

		@Override
		protected boolean removeEldestEntry(Entry&lt;String, Object&gt; eldest) {
			boolean flag = size() &gt; maxBeanNumber;
			if (flag) {
				executeDesCallback(eldest.getKey());
			}
			return flag;
		}

	}

	private static final int DEFAULT_MAX_BEAN_NUMBER = 2;
	private Map&lt;String, Object&gt; beanCache = Collections
			.synchronizedMap(new BeanCache());
	private int maxBeanNumber;
	private Map&lt;String, Runnable&gt; destructionCallback = new HashMap&lt;String, Runnable&gt;();

	public LRUCacheScope() {
		this(DEFAULT_MAX_BEAN_NUMBER);
	}

	public LRUCacheScope(int maxBeanNumber) {
		super();
		this.maxBeanNumber = maxBeanNumber;
	}

	@Override
	public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {
		Object bean = beanCache.get(name);
		if (bean == null) {
			bean = objectFactory.getObject();
			beanCache.put(name, bean);
		}
		return bean;
	}

	@Override
	public Object remove(String name) {
		destructionCallback.remove(name);
		return beanCache.remove(name);
	}

	@Override
	public void registerDestructionCallback(String name, Runnable callback) {
		destructionCallback.put(name, callback);
	}

	@Override
	public Object resolveContextualObject(String key) {
		return null;
	}

	@Override
	public String getConversationId() {
		return null;
	}

	private void executeDesCallback(String beanName) {
		Runnable callBack = destructionCallback.get(beanName);
		if (callBack != null) {
			callBack.run();
		}
		destructionCallback.remove(beanName);
	}

}</code></pre>定义CustomScopeConfigurer注册Scope，并且定义其它的测试bean 
<p></p> 
<p></p> 
<pre><code class="language-java">&lt;bean id="scopedBean1" class="spring.beans.scope.ScopedBean"
	scope="lruCache"&gt;&lt;/bean&gt;
&lt;bean id="scopedBean2" class="spring.beans.scope.ScopedBean"
	scope="lruCache"&gt;&lt;/bean&gt;
&lt;bean id="scopedBean3" class="spring.beans.scope.ScopedBean"
	scope="lruCache"&gt;&lt;/bean&gt;
&lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt;
	&lt;property name="scopes"&gt;
		&lt;map&gt;
			&lt;entry key="lruCache"&gt;
				&lt;bean class="spring.beans.scope.LRUCacheScope"&gt;&lt;/bean&gt;
			&lt;/entry&gt;
		&lt;/map&gt;
	&lt;/property&gt;
&lt;/bean&gt;</code></pre>JUnit测试代码 
<p></p> 
<p></p> 
<pre><code class="language-java">@Test
public void test() {
	BeanFactory context = new ClassPathXmlApplicationContext(
			"spring/beans/scope/scope.xml");
	ScopedBean bean1 = (ScopedBean) context.getBean("scopedBean1");
	ScopedBean bean11 = (ScopedBean) context.getBean("scopedBean1");
	assertEquals(bean1, bean11);

	ScopedBean bean2 = (ScopedBean) context.getBean("scopedBean2");

	ScopedBean bean3 = (ScopedBean) context.getBean("scopedBean3");
	bean11 = (ScopedBean) context.getBean("scopedBean1");
	assertNotEquals(bean1, bean11);
}</code></pre> 
<br> 执行测试代码发现代码执行通过，可以发现最后一次取出的scopedBean1和前面的scopedBean1已经不是一个实例了。查看控制台日志发现有如下信息： 
<p></p> 
<p></p> 
<pre><code class="language-java">22:28:48,738 DEBUG DefaultListableBeanFactory:432 - Creating instance of bean 'scopedBean1'
22:28:48,738 DEBUG DefaultListableBeanFactory:460 - Finished creating instance of bean 'scopedBean1'
22:28:48,738 DEBUG DefaultListableBeanFactory:432 - Creating instance of bean 'scopedBean2'
22:28:48,738 DEBUG DefaultListableBeanFactory:460 - Finished creating instance of bean 'scopedBean2'
22:28:48,738 DEBUG DefaultListableBeanFactory:432 - Creating instance of bean 'scopedBean3'
22:28:48,738 DEBUG DefaultListableBeanFactory:460 - Finished creating instance of bean 'scopedBean3'
22:28:48,738 DEBUG DisposableBeanAdapter:227 - Invoking destroy() on bean with name 'scopedBean1'
destroy:spring.beans.scope.ScopedBean@18235ed
22:28:48,738 DEBUG DefaultListableBeanFactory:432 - Creating instance of bean 'scopedBean1'
22:28:48,738 DEBUG DefaultListableBeanFactory:460 - Finished creating instance of bean 'scopedBean1'
22:28:48,738 DEBUG DisposableBeanAdapter:227 - Invoking destroy() on bean with name 'scopedBean2'
destroy:spring.beans.scope.ScopedBean@1a28362</code></pre>从日志可以看出在创建完scopedBean3并且添加到缓存中之后scopedBean1被踢掉了并且触发了析构回调，我们ScopedBean实现了DisposableBean接口，它的destroy方法被调用了： 
<br> 
<br> 
<pre><code class="language-java">public class ScopedBean implements DisposableBean {

	@Override
	public void destroy() throws Exception {
		System.out.println("destroy:" + this);
	}

}
</code></pre> 
<h3>框架实现原理</h3> 
<p>现在大致分析一下自定义作用域时如何实现的</p> 
<p>首先看下CustomScopeConfigurer类，看下它的postProcessBeanFactory方法：<br> </p> 
<pre><code class="language-java">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
	if (this.scopes != null) {
		for (Map.Entry&lt;String, Object&gt; entry : this.scopes.entrySet()) {
			String scopeKey = entry.getKey();
			Object value = entry.getValue();
			if (value instanceof Scope) {
				beanFactory.registerScope(scopeKey, (Scope) value);
			}
			else if (value instanceof Class) {
				Class scopeClass = (Class) value;
				Assert.isAssignable(Scope.class, scopeClass);
				beanFactory.registerScope(scopeKey, (Scope) BeanUtils.instantiateClass(scopeClass));
			}
			else if (value instanceof String) {
				Class scopeClass = ClassUtils.resolveClassName((String) value, this.beanClassLoader);
				Assert.isAssignable(Scope.class, scopeClass);
				beanFactory.registerScope(scopeKey, (Scope) BeanUtils.instantiateClass(scopeClass));
			}
			else {
				throw new IllegalArgumentException("Mapped value [" + value + "] for scope key [" +
						scopeKey + "] is not an instance of required type [" + Scope.class.getName() +
						"] or a corresponding Class or String value indicating a Scope implementation");
			}
		}
	}
}</code></pre>在这个方法中把所有scope都注册到beanFactory中，来看看bean工厂的registerScope方法，在AbstractBeanFactory类中，在这个方法中把所有的作用域对象都存储到了scopes哈希表属性中，作用域名称作为哈希表的key： 
<p></p> 
<p></p> 
<pre><code class="language-java">public void registerScope(String scopeName, Scope scope) {
	Assert.notNull(scopeName, "Scope identifier must not be null");
	Assert.notNull(scope, "Scope must not be null");
	if (SCOPE_SINGLETON.equals(scopeName) || SCOPE_PROTOTYPE.equals(scopeName)) {
		throw new IllegalArgumentException("Cannot replace existing scopes 'singleton' and 'prototype'");
	}
	this.scopes.put(scopeName, scope);
}</code></pre>接下来看看bean的获取方法，在AbstractBeanFactory的doGetBean方法中，看doGetBean方法的代码片段： 
<pre><code class="language-java">if (mbd.isSingleton()) {
	
	...
	
}

else if (mbd.isPrototype()) {
	
	...
	
}

else {
	String scopeName = mbd.getScope();
	final Scope scope = this.scopes.get(scopeName);
	if (scope == null) {
		throw new IllegalStateException("No Scope registered for scope '" + scopeName + "'");
	}
	try {
		Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() {
			public Object getObject() throws BeansException {
				beforePrototypeCreation(beanName);
				try {
					return createBean(beanName, mbd, args);
				}
				finally {
					afterPrototypeCreation(beanName);
				}
			}
		});
		bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);
	}
	catch (IllegalStateException ex) {
		throw new BeanCreationException(beanName,
				"Scope '" + scopeName + "' is not active for the current thread; " +
				"consider defining a scoped proxy for this bean if you intend to refer to it from a singleton",
				ex);
	}
}</code></pre>可以看到获取自定义scope的bean调用了Scope的get方法，如果作用域没有缓存要找bean，那么会调用createBean来创建一个实例，这块创建bean实例的逻辑和prototype bean的是一样的。 
<p></p> 
<p>下面来看看注册析构回调的代码，在AbstractBeanFactory类的registerDisposableBeanIfNecessary方法中，在bean创建（AbstractAutowireCapableBeanFactory的doCreateBean方法）完成之后：</p> 
<pre><code class="language-java">protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
	AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
	if (!mbd.isPrototype() &amp;&amp; requiresDestruction(bean, mbd)) {
		if (mbd.isSingleton()) {
			// Register a DisposableBean implementation that performs all destruction
			// work for the given bean: DestructionAwareBeanPostProcessors,
			// DisposableBean interface, custom destroy method.
			registerDisposableBean(beanName,
					new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
		}
		else {
			// A bean with a custom scope...
			Scope scope = this.scopes.get(mbd.getScope());
			if (scope == null) {
				throw new IllegalStateException("No Scope registered for scope '" + mbd.getScope() + "'");
			}
			scope.registerDestructionCallback(beanName,
					new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
		}
	}
}</code></pre>代码中可以看到自定义scope的bean创建完成之后会注册一个DisposableBeanAdapter析构回调到到Scope，看看DisposableBeanAdapter这个类的代码，在scope中执行回调时调用run方法，而run方法会直接调用destroy方法，主要代码在destroy方法中，从代码中可以看出在destroy方法中执行了所有的bean的析构回调包括DestructionAwareBeanPostProcessor析构处理器、DisposableBean的destroy、bean定义中的destroy-method。 
<p></p> 
<p></p> 
<pre><code class="language-java">public void destroy() {
	if (this.beanPostProcessors != null &amp;&amp; !this.beanPostProcessors.isEmpty()) {
		for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) {
			processor.postProcessBeforeDestruction(this.bean, this.beanName);
		}
	}

	if (this.invokeDisposableBean) {
		if (logger.isDebugEnabled()) {
			logger.debug("Invoking destroy() on bean with name '" + this.beanName + "'");
		}
		try {
			if (System.getSecurityManager() != null) {
				AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() {
					public Object run() throws Exception {
						((DisposableBean) bean).destroy();
						return null;
					}
				}, acc);
			}
			else {
				((DisposableBean) bean).destroy();
			}
		}
		catch (Throwable ex) {
			String msg = "Invocation of destroy method failed on bean with name '" + this.beanName + "'";
			if (logger.isDebugEnabled()) {
				logger.warn(msg, ex);
			}
			else {
				logger.warn(msg + ": " + ex);
			}
		}
	}

	if (this.destroyMethod != null) {
		invokeCustomDestroyMethod(this.destroyMethod);
	}
	else if (this.destroyMethodName != null) {
		Method methodToCall = determineDestroyMethod();
		if (methodToCall != null) {
			invokeCustomDestroyMethod(methodToCall);
		}
	}
}</code></pre> 
<br> 
<h2>框架自定义作用域</h2> 
<p>在Spring框架中也定义了一些自定义作用域：<br> </p> 
<ul><li>web框架的request：bean在request范围内共享，实现类org.springframework.web.context.request.RequestScope</li><li>web框架的session：bean在session范围内共享，实现类org.springframework.web.context.request.SessionScope</li><li>web框架的application：ServletContextScope，bean在web应用共享，实现类org.springframework.web.context.support.ServletContextScope</li><li>org.springframework.context.support.SimpleThreadScope：bean在线程内共享</li></ul> 
<p></p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea958d0fde204e44a505c7a192448ab5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Unity3D技术之Unity3D中的协程（Coroutine）详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3fa67d4c2a5f64a1967a6a1c9a9f52f5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android程序安装后不显示图标的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>