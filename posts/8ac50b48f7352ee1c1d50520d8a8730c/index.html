<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣hot100题解（python版55-59题） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="力扣hot100题解（python版55-59题）" />
<meta property="og:description" content="55、全排列 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：
输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2：
输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3：
输入：nums = [1] 输出：[[1]] 提示：
1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同 思路解答： 递归生成排列： 通过递归函数 backtrack，在每一步尝试将当前位置的元素与后续位置的元素交换，然后递归处理下一个位置。交换元素： 在每一步尝试中，通过交换元素的位置来生成不同的排列，这样可以确保每个元素都出现在每个位置上。回溯： 在递归调用完成后，需要恢复元素的原始顺序，以便进行下一次尝试。这样可以确保不会遗漏任何可能的排列。终止条件： 当处理到列表的最后一个位置时（first == n-1），即已经生成了一个完整的排列，将该排列加入结果列表中。 def permute(nums: list[int]) -&gt; list[list[int]]: def backtrack(first): if first == n-1: res.append(list(nums)) return for i in range(first, n): nums[first], nums[i] = nums[i], nums[first] backtrack(first &#43; 1) nums[first], nums[i] = nums[i], nums[first] n = len(nums) res = [] backtrack(0) return res 56、子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/8ac50b48f7352ee1c1d50520d8a8730c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-08T21:22:11+08:00" />
<meta property="article:modified_time" content="2024-03-08T21:22:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣hot100题解（python版55-59题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="55_0"></a>55、全排列</h2> 
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = [0,1]
输出：[[0,1],[1,0]]

</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：nums = [1]
输出：[[1]]

</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul> 
<h3><a id="_40"></a>思路解答：</h3> 
<ol><li><strong>递归生成排列：</strong> 通过递归函数 <code>backtrack</code>，在每一步尝试将当前位置的元素与后续位置的元素交换，然后递归处理下一个位置。</li><li><strong>交换元素：</strong> 在每一步尝试中，通过交换元素的位置来生成不同的排列，这样可以确保每个元素都出现在每个位置上。</li><li><strong>回溯：</strong> 在递归调用完成后，需要恢复元素的原始顺序，以便进行下一次尝试。这样可以确保不会遗漏任何可能的排列。</li><li><strong>终止条件：</strong> 当处理到列表的最后一个位置时（<code>first == n-1</code>），即已经生成了一个完整的排列，将该排列加入结果列表中。</li></ol> 
<pre><code>def permute(nums: list[int]) -&gt; list[list[int]]:
    def backtrack(first):
        if first == n-1:
            res.append(list(nums))
            return
        for i in range(first, n):
            nums[first], nums[i] = nums[i], nums[first]
            backtrack(first + 1)
            nums[first], nums[i] = nums[i], nums[first]

    n = len(nums)
    res = []
    backtrack(0)
    return res

</code></pre> 
<h2><a id="56_69"></a>56、子集</h2> 
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p> 
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：nums = [0]
输出：[[],[0]]

</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul> 
<h3><a id="_103"></a>思路解答：</h3> 
<ol><li><strong>回溯生成子集：</strong> 使用回溯算法生成所有可能的子集。回溯算法的特点是尝试所有可能的选择，并在每一步都进行回溯，以便尝试其他选择。</li><li><strong>递归生成子集：</strong> 定义了一个内部函数 <code>backtrack(start, path)</code>，其中 <code>start</code> 表示当前处理的起始位置，<code>path</code> 表示当前的子集路径。</li><li><strong>添加子集：</strong> 在每次递归调用开始时，将当前的 <code>path</code> 子集加入到结果列表 <code>res</code> 中，这样可以确保不漏掉任何子集。</li><li><strong>遍历元素：</strong> 遍历从 <code>start</code> 到 <code>len(nums)</code> 的位置，将当前元素加入到 <code>path</code> 中，然后递归调用 <code>backtrack(i + 1, path)</code> 处理下一个位置。</li><li><strong>回溯操作：</strong> 在递归调用完成后，需要将最后一个加入的元素从 <code>path</code> 中移除，以便尝试其他选择。</li><li><strong>初始化及返回：</strong> 在函数主体中，初始化结果列表 <code>res</code> 为空列表，然后调用 <code>backtrack(0, [])</code> 开始生成子集。最后返回结果列表 <code>res</code>，其中包含了给定列表 <code>nums</code> 的所有子集。</li></ol> 
<pre><code>def subsets(nums: list[int]) -&gt; list[list[int]]:
    def backtrack(start, path):
        res.append(path[:])
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()

    res = []
    backtrack(0, [])
    return res

</code></pre> 
<h2><a id="57_131"></a>57、电话号码的字母组合</h2> 
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p> 
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p> 
<p><img src="https://images2.imgbox.com/64/c3/4ojZaPVo_o.png" alt="img"></p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]

</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：digits = ""
输出：[]

</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入：digits = "2"
输出：["a","b","c"]

</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li></ul> 
<h3><a id="_174"></a>思路解答：</h3> 
<ol><li><strong>递归实现</strong>：通过递归实现回溯算法，在每一步都遍历当前数字对应的所有字母，并递归调用下一层。</li><li><strong>遍历元素：</strong> 遍历当前数字对应的字符位置，将当前元素加入到 <code>path</code> 中，然后递归调用 <code>backtrack(index + 1, path)</code> 处理下一个位置。</li><li><strong>回溯操作：</strong> 在递归调用完成后，需要将最后一个加入的元素从 <code>path</code> 中移除，以便尝试其他选择。</li><li><strong>终止条件</strong>：当遍历完所有字符时，将当前的字符组合加入结果集中。</li></ol> 
<pre><code>def letterCombinations(digits: str) -&gt; list[str]:
    if not digits:
        return []

    phone = {
        '2': ['a', 'b', 'c'],
        '3': ['d', 'e', 'f'],
        '4': ['g', 'h', 'i'],
        '5': ['j', 'k', 'l'],
        '6': ['m', 'n', 'o'],
        '7': ['p', 'q', 'r', 's'],
        '8': ['t', 'u', 'v'],
        '9': ['w', 'x', 'y', 'z']
    }

    def backtrack(index, path):
        if index == len(digits):
            res.append(''.join(path))
            return

        for char in phone[digits[index]]:
            path.append(char)
            backtrack(index + 1, path)
            path.pop()

    res = []
    backtrack(0, [])
    return res

</code></pre> 
<h2><a id="58_217"></a>58、组合总和</h2> 
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p> 
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p> 
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。

</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]

</code></pre> 
<p><strong>示例 3：</strong></p> 
<pre><code>输入: candidates = [2], target = 1
输出: []

</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul> 
<h3><a id="_266"></a>思路解答：</h3> 
<ol><li> <p><strong>排序候选列表</strong>：首先对候选列表进行排序，这样可以在回溯的过程中更方便地控制搜索顺序。</p> </li><li> <p><strong>回溯函数</strong>：编写一个回溯函数 <code>backtrack(start, path, target)</code>，其中：</p> 
  <ul><li><code>start</code>：表示当前可以选择的候选元素的起始位置，避免重复组合；</li><li><code>path</code>：记录当前的组合；</li><li><code>target</code>：表示目标数值。</li></ul> </li><li> <p><strong>回溯过程</strong>：</p> 
  <ul><li>如果 <code>target == 0</code>，将当前的组合加入结果集；</li><li>如果 <code>target &lt; 0</code>，直接返回，不再继续向下搜索；</li><li>遍历候选列表中的元素： 
    <ul><li>将当前元素加入组合 <code>path</code> 中；</li><li>递归调用 <code>backtrack</code>，更新 <code>target</code> 为 <code>target - candidates[i]</code>，起始位置为 <code>i</code>；</li><li>在递归调用返回后，将当前元素从组合 <code>path</code> 中移除，继续下一个元素的搜索。</li></ul> </li></ul> </li></ol> 
<pre><code>def combinationSum(candidates: list[int], target: int) -&gt; list[list[int]]:

    def backtrack(start, path, target):
        if target == 0:
            res.append(path[:])
            return
        if target &lt; 0:
            return

        for i in range(start, len(candidates)):
            path.append(candidates[i])
            backtrack(i, path, target - candidates[i])
            path.pop()

    res = []
    candidates.sort()
    backtrack(0, [], target)
    return res

</code></pre> 
<h2><a id="59_311"></a>59、括号生成</h2> 
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p> 
<p><strong>示例 1：</strong></p> 
<pre><code>输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]

</code></pre> 
<p><strong>示例 2：</strong></p> 
<pre><code>输入：n = 1
输出：["()"]

</code></pre> 
<p><strong>提示：</strong></p> 
<ul><li><code>1 &lt;= n &lt;= 8</code></li></ul> 
<h3><a id="_341"></a>思路解答：</h3> 
<ol><li> <p><strong>递归函数设计</strong>：</p> 
  <ul><li>设计一个递归函数，函数参数包括左括号数量 <code>left</code>、右括号数量 <code>right</code>、当前组合 <code>path</code>。</li></ul> </li><li> <p><strong>终止条件</strong>：</p> 
  <ul><li>当当前组合长度达到 <code>2 * n</code> 时，将当前组合加入结果集。</li></ul> </li><li> <p><strong>递归过程</strong>：</p> 
  <ul><li>在递归过程中，考虑两种情况： 
    <ul><li>可以添加左括号的条件是 <code>left &lt; n</code>。</li><li>可以添加右括号的条件是 <code>right &lt; left</code>。</li></ul> </li></ul> </li><li> <p><strong>回溯过程</strong>：</p> 
  <ul><li>在回溯过程中，分别尝试添加左括号和右括号，并递归调用下一层。</li></ul> </li></ol> 
<pre><code>def generateParenthesis(n: int) -&gt; list[str]:

    def backtrack(left, right, path):
        if len(path) == 2 * n:
            res.append("".join(path))
            return
        if left &lt; n:
            path.append('(')
            backtrack(left + 1, right, path)
            path.pop()
        if right &lt; left:
            path.append(')')
            backtrack(left, right + 1, path)
            path.pop()

    res = []
    backtrack(0, 0, [])
    return res

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/79df1a6acff61af3353ef582dc455a79/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">html--心花怒放</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4f9f32db003bd0b35fb21b8f5aa54f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">@RequestMapping与@GetMapping和@PostMapping等注解的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>