<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《vtk9 book》 官方web版 第3章 - 计算机图形基础 （3 / 5） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《vtk9 book》 官方web版 第3章 - 计算机图形基础 （3 / 5）" />
<meta property="og:description" content="3.8 演员几何 我们已经看到了光照属性如何控制演员的外观，以及相机如何结合变换矩阵将演员投影到图像平面上。剩下的是定义演员的几何形状，以及如何将其定位在世界坐标系中。
建模
计算机图形学研究中的一个重要主题是建模或表示物体的几何形状。已经应用了各种数学技术，包括点、线、多边形、各种形式的曲线和样条线，甚至是隐式的数学函数的组合。
这个主题超出了本文的范围。这里重要的一点是，存在一个指定对象形状及其在模型坐标系中位置的基础几何模型。
在数据可视化中，建模扮演着不同的角色。与直接创建几何形状来表示对象不同，可视化算法计算这些形式。通常几何形状是抽象的（如等高线），与真实世界的几何关系不大。当我们描述可视化算法时，我们将看到这些模型是如何计算的，这将在第6章 - 基本算法和第9章 - 高级算法中介绍。
数据可视化的几何表示往往是简单的，尽管计算这些表示并不简单。这些形式通常是基本形状，如点、线和多边形，或者是体积数据等可视化数据。我们使用简单的形式是因为我们希望实现高性能和交互式系统。因此，我们利用计算机硬件（将在“图形硬件”中介绍）或者像体积渲染这样的特殊渲染技术。
演员的位置和方向
每个演员都有一个控制其在世界空间中位置和缩放的变换矩阵。演员的几何形状是在模型坐标中定义的模型。我们使用方向、位置和沿坐标轴的比例因子来指定演员的位置。此外，我们可以定义一个围绕其旋转的原点。这个特性很有用，因为我们可以围绕演员的中心或其他有意义的点旋转演员。
演员的方向由存储在方向向量（Ox，Roy，Oz）中的旋转确定。这个向量定义了一系列旋转变换矩阵。正如我们在前一节关于变换矩阵中所看到的，变换的应用顺序不是任意的。我们已经选择了一个基于我们认为对用户自然的固定顺序。变换的顺序是先围绕 y 轴旋转 O y，然后围绕 x 轴旋转 O x，最后围绕 z 轴旋转 O z。这个顺序是任意的，基于标准摄像机操作。这些操作（按顺序）是摄像机方位角，然后是仰角，最后是翻转（图3-15）。
所有这些旋转都发生在演员的原点周围。通常这被设置为其包围框的中心，但也可以设置为任何方便的点。有许多不同的方法可以改变演员的方向。RotateX()、RotateY() 和 RotateZ() 是常见的围绕各自轴旋转的方法。许多系统还包括围绕用户定义的轴旋转的方法。在可视化工具包中，RotateXYZ() 方法用于围绕通过原点的任意矢量旋转。
（图3-15）演员坐标系
3.9 图形硬件 前面我们提到，图形硬件的进步对渲染的执行方式产生了重大影响。现在我们已经介绍了场景渲染的基础知识，接下来我们将看一些硬件问题。首先，我们讨论了取代矢量显示器成为主要输出设备的光栅设备。然后，我们将研究程序如何与图形硬件进行通信。我们还将研究计算机图形中使用的不同坐标系、隐藏线/面消除和z缓冲。
光栅设备 计算机图形的结果在当今世界中无处不在——使用计算机图形生成的数字图像可能出现在手机上、显示在计算机监视器上、在电视上播放、在电影院展示，并在电子广告牌上呈现。所有这些，以及许多其他显示媒介都是光栅设备。光栅设备使用称为像素的图片元素的二维数组来表示图像。例如，单词“hello”可以被表示为一个像素数组，如图3-15所示。在这里，“hello”这个词是写在一个宽25像素、高10像素的像素数组中的。每个像素存储一位信息，无论是黑色还是白色。这就是黑白激光打印机的工作原理，对于纸张上的每个点，它要么打印一个黑点，要么保持纸张的颜色。由于硬件限制，光栅设备如激光打印机和计算机监视器实际上并不像图3-16中那样绘制精确的方形像素。相反，它们往往略微模糊并重叠。光栅设备的另一个硬件限制是它们的分辨率。这就是为什么300 dpi（每英寸点数）的激光打印机会产生比九针点阵打印机更详细的输出的原因。300 dpi的激光打印机的分辨率是每英寸300像素，而点阵打印机的分辨率大约为50 dpi。
彩色计算机显示器通常具有大约80像素每英寸的分辨率，使屏幕成为大约一千像素宽和高的像素阵列。这导致超过一百万个像素，每个像素都有一个值，指示它应该是什么颜色。由于彩色显示器中的硬件使用RGB系统，因此使用该系统来描述像素中的颜色是有意义的。不幸的是，每个像素都有红色、绿色和蓝色分量，可能会占用大量内存。这是市场上各种图形硬件之间差异的一部分。一些公司每个像素使用24位的存储空间，其他公司使用8位，一些高级系统每个像素使用超过100位的存储空间。通常，每个像素的位数越多，颜色就越准确。
在图形硬件中解决颜色限制的一种方法是使用一种称为抖动的技术。例如，假设您想使用一些不同的灰色调，但您的图形硬件只支持黑色和白色。抖动使您可以通过使用黑色和白色像素的混合来近似灰色调。在图3-17中，使用黑色和白色像素的混合绘制了七个灰色方块。从远处看，这七个方块看起来像不同的灰色调，即使在近处看，很明显它们只是不同的黑色和白色像素的混合。这种技术对其他颜色同样有效。例如，如果您的图形硬件支持主蓝色、主绿色和白色，但不支持淡海绿色，您可以通过对硬件支持的绿色、蓝色和白色进行抖动来近似这种颜色。
与硬件接口 现在我们已经讨论了显示硬件的基础知识，好消息是你很少需要担心它们。大多数图形编程都是使用比单个像素更高级的原语完成的。图3-18显示了一个典型的可视化程序布局。在层次结构的底部是我们已经讨论过的显示硬件；你的程序很可能不会直接与它交互。在硬件上面的三个层次是你可能需要关注的层次。
许多程序利用应用程序库作为系统图形功能的高级接口。本书附带的可视化工具包就是一个很好的例子。它允许你仅使用几个命令显示复杂对象或图形。还可以与许多不同的图形库进行接口，因为不同的库可能在不同的硬件平台上受支持。
图形库和图形硬件层都执行类似的功能。它们负责接收来自应用程序库或程序的高级命令，并执行它们。通过提供更复杂的原语，这使得编程变得更容易。我们可以绘制像多边形、三角形和线段这样的原语，而不必担心哪些像素设置为哪种颜色的细节。图3-19说明了所有主流图形库支持的一些高级原语。
这种功能被分为两个不同的层次，因为不同的机器可能具有非常不同的图形硬件。如果你编写一个绘制红色多边形的程序，图形库或图形硬件必须能够执行该命令。在高端系统上，这可能是在图形硬件中完成的，而在其他系统上，图形库会在软件中完成。因此，相同的命令可以在各种各样的机器上使用，而不必担心底层的图形硬件。
图3-19中原语的基本构建块是一个点（或顶点）。一个顶点有一个位置、法线和颜色，每个都是一个三元素向量。位置指定了顶点的位置，法线指定了顶点面向的方向，颜色指定了顶点的红色、绿色和蓝色分量。
多边形是通过连接一系列点或顶点构建的，如图3-20所示。你可能会想为什么每个顶点都有一个法线，而不是整个多边形只有一个法线。一个平面多边形无论其顶点的法线指示什么，只能面向一个方向。原因是有时多边形被用作其他东西的近似，比如曲线。图3-21显示了一个圆柱的俯视图。如你所见，它实际上不是一个圆柱，而是一个用灰色绘制的多边形近似圆柱。每个顶点被两个多边形共享，顶点的正确法线与多边形的法线不同。类似的逻辑解释了为什么每个顶点都有一个颜色，而不是整个多边形只有一个颜色。
当您限制自己使用上述描述的原始类型时，许多图形系统支持一些附加属性。边缘颜色和边缘可见性可用于突出显示构成演员的多边形原语。另一种方法是通过将表示从表面调整为线框或点来实现。这将分别用它们的边界边缘或点替换多边形等表面。虽然从物理角度来看这可能没有太多意义，但在某些插图中可能会有所帮助。在渲染CAD模型时使用边缘可见性可以帮助显示组成模型的不同部分。
光栅化 到目前为止，我们已经描述了如何使用渲染基元表示图形数据，以及如何使用光栅显示设备表示图像。问题是，我们如何将图形基元转换为光栅图像呢？这是我们在本节中要讨论的主题。虽然对这个主题进行详尽的论述超出了本文的范围，但我们会尽力提供一个高层次的概述。
光栅化或扫描转换是将几何表示转换为光栅图像的过程。在接下来的描述中，我们假设图形基元是三角形多边形。这并不像你想象的那样具有限制性，因为任何一般多边形都可以被分解成一组三角形。此外，其他表面表示如样条通常被图形系统分解成三角形或多边形。（这里描述的方法实际上适用于凸多边形。）
今天的大多数硬件都是基于对象顺序光栅化技术。正如我们在本章前面看到的那样，这意味着按顺序处理我们的角色。由于我们的角色由多边形基元表示，我们逐个处理多边形。因此，尽管我们描述了一个多边形的处理过程，请记住实际上会处理许多多边形，可能还有许多角色。
第一步是使用适当的变换矩阵变换多边形。我们还使用平行或正交投影将多边形投影到图像平面上。这个过程的一部分涉及对多边形进行裁剪。我们不仅使用前后裁剪平面来裁剪太近或太远的多边形，还必须裁剪穿过图像平面边界的多边形。裁剪穿过视景体边界的多边形意味着我们必须生成新的多边形边界。
图3-22。将凸多边形转换为光栅图像。像素在图像平面上以水平跨度（或扫描线）进行处理。点$p_i$处的数据值$d_i$沿着边缘插值，然后沿着扫描线使用增量数据值进行插值。典型的数据值是颜色的RGB分量。
将多边形剪裁并投影到图像平面后，我们可以开始扫描线处理（图3-22）。第一步是识别被投影多边形所交叉的初始扫描线。这是通过对顶点的y值进行排序来找到的。然后我们找到连接左侧和右侧顶点的两条边。利用边的斜率以及数据值，我们计算出增量数据值。这些数据通常是R、G和B颜色分量。其他数据值包括透明度值和z深度值。（如果我们使用z缓冲区，描述在下一节中。）多边形内的像素行（即从左侧和右侧边缘开始）称为跨度。数据值从跨度两侧的边插值以计算内部像素值。这个过程一直持续到整个多边形被填满。请注意，当遇到新的顶点时，需要重新计算增量数据值。
多边形的着色（即多边形上的颜色插值）取决于角色的插值属性。有三种可能性：平面着色、Gouraud着色或Phong着色。图3-7展示了平面着色和Gouraud着色之间的区别。平面着色通过将光照方程应用于多边形的一个法线（通常是表面法线）来计算多边形的颜色。Gouraud着色通过使用顶点的法线和标准光照方程在所有顶点处计算多边形的颜色。然后通过应用扫描线插值过程来填充多边形的内部和边缘。Phong着色是三者中最逼真的。它通过插值顶点法线在多边形上的每个位置计算法线。然后使用这些法线在光照方程中确定最终像素颜色。平面和Gouraud着色是常用的方法。Phong着色的复杂性使其难以在硬件中得到广泛支持。
Z缓冲 在我们之前对渲染过程的描述中，我们跟随光线从我们的眼睛穿过图像平面中的一个像素到演员，再返回到光源。光线追踪的一个好处是，观看光线会击中它们遇到的第一个演员，并忽略任何隐藏在其后面的演员。当使用上述多边形方法渲染演员时，我们没有一种方法来计算哪些多边形被隐藏了，哪些没有被隐藏。我们通常无法确定多边形是否被正确排序。相反，我们可以使用许多用于多边形渲染的隐藏表面方法。
一种方法是按照从后到前（沿着摄像机的视图向量）对所有多边形进行排序，然后按照那个顺序渲染它们。这被称为画家算法或画家排序，但它有一个主要弱点，如图3-23所示。无论我们以何种顺序绘制这三个三角形，我们都无法得到期望的结果，因为每个三角形既在另一个三角形的前面，又在其后面。有一些算法可以对多边形进行排序和分割，以处理这种情况[Carlson85]。这需要更多的初始处理来执行排序和分割。如果图像之间的几何原语发生变化或摄像机视图发生变化，则必须在每次渲染之前执行此处理。
画家算法的问题 另一个隐藏表面算法，Z缓冲，解决了这个问题，并且不需要排序。Z缓冲利用视图坐标系中的z值（即沿投影方向的深度值）。在绘制新像素之前，将比较其z值与该像素位置的当前z值。如果新像素将位于当前像素的前面，则绘制该像素并更新该像素位置的z值。否则，保持当前像素不变，新像素将被忽略。由于其简单性和稳健性，Z缓冲已被广泛实现在硬件中。Z缓冲的缺点是它需要大量内存，称为Z缓冲区，用于存储每个像素的z值。大多数系统使用深度为24或32位的Z缓冲区。对于一个1000乘1000的显示屏，这意味着仅用于Z缓冲区就需要三到四兆字节。Z缓冲的另一个问题是，它的精度受其深度的限制。24位Z缓冲区在视锥体的高度上提供了16777216分之一的精度。如果物体靠得很近，这种分辨率通常是不够的。如果遇到Z缓冲的精度问题，请确保前后裁剪平面尽可能靠近可见几何体。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/d4b5d99cee631375eb782ddfdfdcdd66/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-10T18:15:27+08:00" />
<meta property="article:modified_time" content="2024-03-10T18:15:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《vtk9 book》 官方web版 第3章 - 计算机图形基础 （3 / 5）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" height="417" src="https://images2.imgbox.com/c6/fa/ANZUTK3Q_o.png" width="992"><img alt="" height="397" src="https://images2.imgbox.com/1d/7e/MPOQA8ho_o.png" width="997"><img alt="" height="69" src="https://images2.imgbox.com/05/c3/vdhAg0vL_o.png" width="1001"></p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/1e/9d/RRAFyuN4_o.png" width="900"><img alt="" height="455" src="https://images2.imgbox.com/c1/99/YGa3nUPh_o.png" width="974"><img alt="" height="424" src="https://images2.imgbox.com/16/1a/EQTBtW6e_o.png" width="1005"></p> 
<h4>3.8 演员几何</h4> 
<p>        我们已经看到了光照属性如何控制演员的外观，以及相机如何结合变换矩阵将演员投影到图像平面上。剩下的是定义演员的几何形状，以及如何将其定位在世界坐标系中。</p> 
<p>        <strong>建模</strong><br>         计算机图形学研究中的一个重要主题是建模或表示物体的几何形状。已经应用了各种数学技术，包括点、线、多边形、各种形式的曲线和样条线，甚至是隐式的数学函数的组合。</p> 
<p>        这个主题超出了本文的范围。这里重要的一点是，存在一个指定对象形状及其在模型坐标系中位置的基础几何模型。</p> 
<p>        在数据可视化中，建模扮演着不同的角色。与直接创建几何形状来表示对象不同，可视化算法计算这些形式。通常几何形状是抽象的（如等高线），与真实世界的几何关系不大。当我们描述可视化算法时，我们将看到这些模型是如何计算的，这将在第6章 - 基本算法和第9章 - 高级算法中介绍。</p> 
<p>        数据可视化的几何表示往往是简单的，尽管计算这些表示并不简单。这些形式通常是基本形状，如点、线和多边形，或者是体积数据等可视化数据。我们使用简单的形式是因为我们希望实现高性能和交互式系统。因此，我们利用计算机硬件（将在“图形硬件”中介绍）或者像体积渲染这样的特殊渲染技术。</p> 
<p>        <strong>演员的位置和方向</strong></p> 
<p><br>         每个演员都有一个控制其在世界空间中位置和缩放的变换矩阵。演员的几何形状是在模型坐标中定义的模型。我们使用方向、位置和沿坐标轴的比例因子来指定演员的位置。此外，我们可以定义一个围绕其旋转的原点。这个特性很有用，因为我们可以围绕演员的中心或其他有意义的点旋转演员。</p> 
<p>        演员的方向由存储在方向向量（Ox，Roy，Oz）中的旋转确定。这个向量定义了一系列旋转变换矩阵。正如我们在前一节关于变换矩阵中所看到的，变换的应用顺序不是任意的。我们已经选择了一个基于我们认为对用户自然的固定顺序。变换的顺序是先围绕 y 轴旋转 O y，然后围绕 x 轴旋转 O x，最后围绕 z 轴旋转 O z。这个顺序是任意的，基于标准摄像机操作。这些操作（按顺序）是摄像机方位角，然后是仰角，最后是翻转（图3-15）。</p> 
<p>        所有这些旋转都发生在演员的原点周围。通常这被设置为其包围框的中心，但也可以设置为任何方便的点。有许多不同的方法可以改变演员的方向。RotateX()、RotateY() 和 RotateZ() 是常见的围绕各自轴旋转的方法。许多系统还包括围绕用户定义的轴旋转的方法。在可视化工具包中，RotateXYZ() 方法用于围绕通过原点的任意矢量旋转。</p> 
<p><img alt="" height="560" src="https://images2.imgbox.com/f4/92/O5Y0iUMT_o.png" width="890"></p> 
<p></p> 
<p></p> 
<p>                                                    （图3-15）演员坐标系</p> 
<h4><strong>3.9 图形硬件</strong></h4> 
<p><br>        前面我们提到，图形硬件的进步对渲染的执行方式产生了重大影响。现在我们已经介绍了场景渲染的基础知识，接下来我们将看一些硬件问题。首先，我们讨论了取代矢量显示器成为主要输出设备的光栅设备。然后，我们将研究程序如何与图形硬件进行通信。我们还将研究计算机图形中使用的不同坐标系、隐藏线/面消除和z缓冲。</p> 
<h5>     光栅设备</h5> 
<p><br>         计算机图形的结果在当今世界中无处不在——使用计算机图形生成的数字图像可能出现在手机上、显示在计算机监视器上、在电视上播放、在电影院展示，并在电子广告牌上呈现。所有这些，以及许多其他显示媒介都是光栅设备。光栅设备使用称为像素的图片元素的二维数组来表示图像。例如，单词“hello”可以被表示为一个像素数组，如图3-15所示。在这里，“hello”这个词是写在一个宽25像素、高10像素的像素数组中的。每个像素存储一位信息，无论是黑色还是白色。这就是黑白激光打印机的工作原理，对于纸张上的每个点，它要么打印一个黑点，要么保持纸张的颜色。由于硬件限制，光栅设备如激光打印机和计算机监视器实际上并不像图3-16中那样绘制精确的方形像素。相反，它们往往略微模糊并重叠。光栅设备的另一个硬件限制是它们的分辨率。这就是为什么300 dpi（每英寸点数）的激光打印机会产生比九针点阵打印机更详细的输出的原因。300 dpi的激光打印机的分辨率是每英寸300像素，而点阵打印机的分辨率大约为50 dpi。</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/6f/d3/Xl2PfMJP_o.png" width="667"></p> 
<p></p> 
<p><img alt="" height="444" src="https://images2.imgbox.com/10/c7/YrOFAsAw_o.png" width="704"></p> 
<p></p> 
<p>        彩色计算机显示器通常具有大约80像素每英寸的分辨率，使屏幕成为大约一千像素宽和高的像素阵列。这导致超过一百万个像素，每个像素都有一个值，指示它应该是什么颜色。由于彩色显示器中的硬件使用RGB系统，因此使用该系统来描述像素中的颜色是有意义的。不幸的是，每个像素都有红色、绿色和蓝色分量，可能会占用大量内存。这是市场上各种图形硬件之间差异的一部分。一些公司每个像素使用24位的存储空间，其他公司使用8位，一些高级系统每个像素使用超过100位的存储空间。通常，每个像素的位数越多，颜色就越准确。</p> 
<p>        在图形硬件中解决颜色限制的一种方法是使用一种称为抖动的技术。例如，假设您想使用一些不同的灰色调，但您的图形硬件只支持黑色和白色。抖动使您可以通过使用黑色和白色像素的混合来近似灰色调。在图3-17中，使用黑色和白色像素的混合绘制了七个灰色方块。从远处看，这七个方块看起来像不同的灰色调，即使在近处看，很明显它们只是不同的黑色和白色像素的混合。这种技术对其他颜色同样有效。例如，如果您的图形硬件支持主蓝色、主绿色和白色，但不支持淡海绿色，您可以通过对硬件支持的绿色、蓝色和白色进行抖动来近似这种颜色。</p> 
<h5>        与硬件接口</h5> 
<p><br>         现在我们已经讨论了显示硬件的基础知识，好消息是你很少需要担心它们。大多数图形编程都是使用比单个像素更高级的原语完成的。图3-18显示了一个典型的可视化程序布局。在层次结构的底部是我们已经讨论过的显示硬件；你的程序很可能不会直接与它交互。在硬件上面的三个层次是你可能需要关注的层次。</p> 
<p><img alt="" height="452" src="https://images2.imgbox.com/18/65/PCRT8YTT_o.png" width="700"></p> 
<p>        许多程序利用应用程序库作为系统图形功能的高级接口。本书附带的可视化工具包就是一个很好的例子。它允许你仅使用几个命令显示复杂对象或图形。还可以与许多不同的图形库进行接口，因为不同的库可能在不同的硬件平台上受支持。</p> 
<p>        图形库和图形硬件层都执行类似的功能。它们负责接收来自应用程序库或程序的高级命令，并执行它们。通过提供更复杂的原语，这使得编程变得更容易。我们可以绘制像多边形、三角形和线段这样的原语，而不必担心哪些像素设置为哪种颜色的细节。图3-19说明了所有主流图形库支持的一些高级原语。</p> 
<p>这种功能被分为两个不同的层次，因为不同的机器可能具有非常不同的图形硬件。如果你编写一个绘制红色多边形的程序，图形库或图形硬件必须能够执行该命令。在高端系统上，这可能是在图形硬件中完成的，而在其他系统上，图形库会在软件中完成。因此，相同的命令可以在各种各样的机器上使用，而不必担心底层的图形硬件。</p> 
<p>        图3-19中原语的基本构建块是一个点（或顶点）。一个顶点有一个位置、法线和颜色，每个都是一个三元素向量。位置指定了顶点的位置，法线指定了顶点面向的方向，颜色指定了顶点的红色、绿色和蓝色分量。</p> 
<p><img alt="" height="539" src="https://images2.imgbox.com/ee/95/LTgz9kvy_o.png" width="812"></p> 
<p>        多边形是通过连接一系列点或顶点构建的，如图3-20所示。你可能会想为什么每个顶点都有一个法线，而不是整个多边形只有一个法线。一个平面多边形无论其顶点的法线指示什么，只能面向一个方向。原因是有时多边形被用作其他东西的近似，比如曲线。图3-21显示了一个圆柱的俯视图。如你所见，它实际上不是一个圆柱，而是一个用灰色绘制的多边形近似圆柱。每个顶点被两个多边形共享，顶点的正确法线与多边形的法线不同。类似的逻辑解释了为什么每个顶点都有一个颜色，而不是整个多边形只有一个颜色。</p> 
<p>        当您限制自己使用上述描述的原始类型时，许多图形系统支持一些附加属性。边缘颜色和边缘可见性可用于突出显示构成演员的多边形原语。另一种方法是通过将表示从表面调整为线框或点来实现。这将分别用它们的边界边缘或点替换多边形等表面。虽然从物理角度来看这可能没有太多意义，但在某些插图中可能会有所帮助。在渲染CAD模型时使用边缘可见性可以帮助显示组成模型的不同部分。</p> 
<h5>光栅化</h5> 
<p><br>         到目前为止，我们已经描述了如何使用渲染基元表示图形数据，以及如何使用光栅显示设备表示图像。问题是，我们如何将图形基元转换为光栅图像呢？这是我们在本节中要讨论的主题。虽然对这个主题进行详尽的论述超出了本文的范围，但我们会尽力提供一个高层次的概述。</p> 
<p><img alt="" height="517" src="https://images2.imgbox.com/ed/d6/dPz73SUL_o.png" width="775"></p> 
<p>        光栅化或扫描转换是将几何表示转换为光栅图像的过程。在接下来的描述中，我们假设图形基元是三角形多边形。这并不像你想象的那样具有限制性，因为任何一般多边形都可以被分解成一组三角形。此外，其他表面表示如样条通常被图形系统分解成三角形或多边形。（这里描述的方法实际上适用于凸多边形。）</p> 
<p><img alt="" height="812" src="https://images2.imgbox.com/c1/65/jfsGmHYy_o.png" width="936"></p> 
<p>        今天的大多数硬件都是基于对象顺序光栅化技术。正如我们在本章前面看到的那样，这意味着按顺序处理我们的角色。由于我们的角色由多边形基元表示，我们逐个处理多边形。因此，尽管我们描述了一个多边形的处理过程，请记住实际上会处理许多多边形，可能还有许多角色。</p> 
<p>        第一步是使用适当的变换矩阵变换多边形。我们还使用平行或正交投影将多边形投影到图像平面上。这个过程的一部分涉及对多边形进行裁剪。我们不仅使用前后裁剪平面来裁剪太近或太远的多边形，还必须裁剪穿过图像平面边界的多边形。裁剪穿过视景体边界的多边形意味着我们必须生成新的多边形边界。</p> 
<p><img alt="" height="547" src="https://images2.imgbox.com/fd/bd/GDC1sHBz_o.png" width="972"></p> 
<p>图3-22。将凸多边形转换为光栅图像。像素在图像平面上以水平跨度（或扫描线）进行处理。点$p_i$处的数据值$d_i$沿着边缘插值，然后沿着扫描线使用增量数据值进行插值。典型的数据值是颜色的RGB分量。</p> 
<p>        将多边形剪裁并投影到图像平面后，我们可以开始扫描线处理（图3-22）。第一步是识别被投影多边形所交叉的初始扫描线。这是通过对顶点的y值进行排序来找到的。然后我们找到连接左侧和右侧顶点的两条边。利用边的斜率以及数据值，我们计算出增量数据值。这些数据通常是R、G和B颜色分量。其他数据值包括透明度值和z深度值。（如果我们使用z缓冲区，描述在下一节中。）多边形内的像素行（即从左侧和右侧边缘开始）称为跨度。数据值从跨度两侧的边插值以计算内部像素值。这个过程一直持续到整个多边形被填满。请注意，当遇到新的顶点时，需要重新计算增量数据值。</p> 
<p>        多边形的着色（即多边形上的颜色插值）取决于角色的插值属性。有三种可能性：平面着色、Gouraud着色或Phong着色。图3-7展示了平面着色和Gouraud着色之间的区别。平面着色通过将光照方程应用于多边形的一个法线（通常是表面法线）来计算多边形的颜色。Gouraud着色通过使用顶点的法线和标准光照方程在所有顶点处计算多边形的颜色。然后通过应用扫描线插值过程来填充多边形的内部和边缘。Phong着色是三者中最逼真的。它通过插值顶点法线在多边形上的每个位置计算法线。然后使用这些法线在光照方程中确定最终像素颜色。平面和Gouraud着色是常用的方法。Phong着色的复杂性使其难以在硬件中得到广泛支持。</p> 
<h5>Z缓冲</h5> 
<p><br>         在我们之前对渲染过程的描述中，我们跟随光线从我们的眼睛穿过图像平面中的一个像素到演员，再返回到光源。光线追踪的一个好处是，观看光线会击中它们遇到的第一个演员，并忽略任何隐藏在其后面的演员。当使用上述多边形方法渲染演员时，我们没有一种方法来计算哪些多边形被隐藏了，哪些没有被隐藏。我们通常无法确定多边形是否被正确排序。相反，我们可以使用许多用于多边形渲染的隐藏表面方法。</p> 
<p><img alt="" height="695" src="https://images2.imgbox.com/e0/0e/mv9wmQav_o.png" width="802"></p> 
<p>        一种方法是按照从后到前（沿着摄像机的视图向量）对所有多边形进行排序，然后按照那个顺序渲染它们。这被称为画家算法或画家排序，但它有一个主要弱点，如图3-23所示。无论我们以何种顺序绘制这三个三角形，我们都无法得到期望的结果，因为每个三角形既在另一个三角形的前面，又在其后面。有一些算法可以对多边形进行排序和分割，以处理这种情况[Carlson85]。这需要更多的初始处理来执行排序和分割。如果图像之间的几何原语发生变化或摄像机视图发生变化，则必须在每次渲染之前执行此处理。</p> 
<h5>画家算法的问题</h5> 
<p><br>         另一个隐藏表面算法，Z缓冲，解决了这个问题，并且不需要排序。Z缓冲利用视图坐标系中的z值（即沿投影方向的深度值）。在绘制新像素之前，将比较其z值与该像素位置的当前z值。如果新像素将位于当前像素的前面，则绘制该像素并更新该像素位置的z值。否则，保持当前像素不变，新像素将被忽略。由于其简单性和稳健性，Z缓冲已被广泛实现在硬件中。Z缓冲的缺点是它需要大量内存，称为Z缓冲区，用于存储每个像素的z值。大多数系统使用深度为24或32位的Z缓冲区。对于一个1000乘1000的显示屏，这意味着仅用于Z缓冲区就需要三到四兆字节。Z缓冲的另一个问题是，它的精度受其深度的限制。24位Z缓冲区在视锥体的高度上提供了16777216分之一的精度。如果物体靠得很近，这种分辨率通常是不够的。如果遇到Z缓冲的精度问题，请确保前后裁剪平面尽可能靠近可见几何体。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9b28e303e90a77ffcdf81eaba31ada9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《vtk9 book》 官方web版 第3章 - 计算机图形基础 （2 / 5）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da935013de546aa3a0855f4ec43e0f07/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">《vtk9 book》 官方web版 第3章 - 计算机图形基础 （4 / 5）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>