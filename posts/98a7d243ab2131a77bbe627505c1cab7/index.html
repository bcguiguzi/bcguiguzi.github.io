<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker host模式拿到nginx远程ip端口_docker网络模式实战 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker host模式拿到nginx远程ip端口_docker网络模式实战" />
<meta property="og:description" content="docker有四种网络模式，分别为Bridge、Host、Container、None。Bridge为docker的默认网络模式。这里我分享下Bridge、Host、Container模式下容器的创建及启动。
Bridge模式：当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。这样容器间就可以相互通信。
docker0
创建容器后，查看容器信息
容器信息
Bridge模式很好理解，而且在创建容器时，也不用指定，因为他是默认的。
Host模式：如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。这里我拿tomcat测试下
拉取tomcat8
由于host模式下使用的是宿主机的IP和端口，所以要注意宿主机有没有把端口开启的问题。如何打开端口，比如8080端口。
开启8080端口
firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload 通过host创建容器
docker run -d --net=host --name to1 94e31e5297d1 94e31e5297d1为tomcat8的镜像ID
host模式下创建容器
container模式：这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己网卡，配置自己的IP，而是和一个指定的容器共享IP，端口范围。
这里我拿nginx和tomcat为例，先创建一个nginx容器，并开启80、8080端口
docker run -d --name nginx -p 80:80 -p 8080:8080 7743d9092020 7743d9092020为nginx镜像ID
创建nginx容器
分别访问80和8080端口
80端口
8080端口
8080不好使，是因为我们还没有开启。使用container创建tomcat8容器。
docker run -d --name to1 --net=container:nginx 94e31e5297d1 nginx：是我上面nginx的名称
94e31e5297d1：是tomcat8镜像ID
container创建tomcat8容器
访问8080
以上就是3种模式的基本用法、后期分享更多docker方面的内容" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/98a7d243ab2131a77bbe627505c1cab7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-22T18:44:33+08:00" />
<meta property="article:modified_time" content="2020-11-22T18:44:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker host模式拿到nginx远程ip端口_docker网络模式实战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>docker有四种网络模式，分别为Bridge、Host、Container、None。<strong>Bridge为docker的默认网络模式</strong>。这里我分享下Bridge、Host、Container模式下容器的创建及启动。</p> 
 <p><strong>Bridge模式：</strong>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。这样容器间就可以相互通信。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/70/99/0Hi58LtT_o.png" alt="553b544c1cc361db01c1441545c159df.png"> 
  <p class="pgc-img-caption">docker0</p> 
 </div> 
 <p>创建容器后，查看容器信息</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/c1/d8/wRFVgYwP_o.png" alt="6cd5bca1ce83f19281781f509fcb6d8a.png"> 
  <p class="pgc-img-caption">容器信息</p> 
 </div> 
 <p>Bridge模式很好理解，而且在创建容器时，也不用指定，因为他是默认的。</p> 
 <p><strong>Host模式</strong>：如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。这里我拿tomcat测试下</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/86/47/F2lf1QDF_o.png" alt="d0c9823a42ca57be7aaceda7b4112547.png"> 
  <p class="pgc-img-caption">拉取tomcat8</p> 
 </div> 
 <p>由于host模式下使用的是宿主机的IP和端口，所以要注意宿主机有没有把端口开启的问题。如何打开端口，比如8080端口。</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/2f/c0/Ubgqe6ao_o.png" alt="e89fa9c2f0b84fbfa0604439ca615f74.png"> 
  <p class="pgc-img-caption">开启8080端口</p> 
 </div> 
 <pre class="has"><code>firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload</code></pre> 
 <p>通过host创建容器</p> 
 <pre class="has"><code>docker run -d --net=host --name to1 94e31e5297d1</code></pre> 
 <p>94e31e5297d1为tomcat8的镜像ID</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/b6/72/rv1M8QCT_o.png" alt="40c7c9e54278aec15962cb37dd76e0c7.png"> 
  <p class="pgc-img-caption">host模式下创建容器</p> 
 </div> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/a0/76/3qWuiPZ3_o.png" alt="05f0dd56019d174b44e55261b301cd1f.png"> 
 </div> 
 <p><strong>container模式：</strong>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己网卡，配置自己的IP，而是和一个指定的容器共享IP，端口范围。</p> 
 <p>这里我拿nginx和tomcat为例，先创建一个nginx容器，并开启80、8080端口</p> 
 <pre class="has"><code>docker run -d --name nginx -p 80:80 -p 8080:8080 7743d9092020</code></pre> 
 <p>7743d9092020为nginx镜像ID</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/25/c0/MuxqzMB0_o.png" alt="ea14058a79b84f0439c656c948b5a18b.png"> 
  <p class="pgc-img-caption">创建nginx容器</p> 
 </div> 
 <p>分别访问80和8080端口</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/ce/37/Hu8ac4Xf_o.png" alt="cbec6003cfb4bde5aa96ed5a55c6bf75.png"> 
  <p class="pgc-img-caption">80端口</p> 
 </div> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/8c/a1/7GMZrp1r_o.png" alt="fc34139960fea65c8ade14250c05d844.png"> 
  <p class="pgc-img-caption">8080端口</p> 
 </div> 
 <p>8080不好使，是因为我们还没有开启。使用container创建tomcat8容器。</p> 
 <pre class="has"><code>docker run -d --name to1 --net=container:nginx 94e31e5297d1</code></pre> 
 <p>nginx：是我上面nginx的名称</p> 
 <p>94e31e5297d1：是tomcat8镜像ID</p> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/54/58/RdmveF6Q_o.png" alt="01c5c47a64c3a9a07ccd8f108fe3afc0.png"> 
  <p class="pgc-img-caption">container创建tomcat8容器</p> 
 </div> 
 <div class="pgc-img"> 
  <img src="https://images2.imgbox.com/70/64/DrKZGNO9_o.png" alt="e0265a50913c7e7d7c6ccef2e8578741.png"> 
  <p class="pgc-img-caption">访问8080</p> 
 </div> 
 <p>以上就是3种模式的基本用法、后期分享更多docker方面的内容</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9eab57dec1c7c99d21247f0c57c20722/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用VLC 在PC端搭建RTP环境</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43f10264b06daba5560eeefd19d60fb5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Odoo14免费开源ERP：企业客户档案信息自动补全功能演示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>