<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go pprof 使用记录 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go pprof 使用记录" />
<meta property="og:description" content="Golang自带的一款开箱即用的性能监控和分析工具。真正分析时常用4种
CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况 做性能分析，第一步需要先获取数据，然后对数据进行分析。所以下面展示一下如何进行数据获取。
一、数据采集 1.1 runtime/pprof 手动调用 runtime.StartCPUProfile / runtime.StopCPUProfile 等API来进行数据的采集。
优点：灵活性高、按需采集。
使用场景：工具型应用（比如说定制化的分析小工具、集成到公司监控系统）
package main import ( &#34;fmt&#34; &#34;os&#34; &#34;runtime/pprof&#34; ) func sayHelloWorld() { var list []string for i := 0; i &lt; 100; i&#43;&#43; { list = append(list, &#34;Hello World&#34;) } fmt.Println(list) } func main() { //CPU Profile fc, err := os.Create(&#34;./cpu.prof&#34;) if err != nil { fmt.Println(err) return } defer fc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/59063206acc235e03d1030a9da5cf6c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-28T14:53:20+08:00" />
<meta property="article:modified_time" content="2022-06-28T14:53:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go pprof 使用记录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Golang自带的一款开箱即用的性能监控和分析工具。真正分析时常用4种</p> 
<ul><li>CPU Profiling：CPU 分析，按照一定的频率采集所监听的应用程序 CPU（含寄存器）的使用情况，可确定应用程序在主动消耗 CPU 周期时花费时间的位置</li><li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏</li><li>Block Profiling：阻塞分析，记录 goroutine 阻塞等待同步（包括定时器通道）的位置</li><li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</li></ul> 
<p>做性能分析，第一步需要先获取数据，然后对数据进行分析。所以下面展示一下如何进行数据获取。</p> 
<h3><a id="_8"></a>一、数据采集</h3> 
<h4><a id="11_runtimepprof_10"></a>1.1 runtime/pprof</h4> 
<p>手动调用 <code>runtime.StartCPUProfile</code> / <code>runtime.StopCPUProfile</code> 等API来进行数据的采集。</p> 
<p>优点：<strong>灵活性高</strong>、按需采集。</p> 
<p>使用场景：<strong>工具型应用</strong>（比如说定制化的分析小工具、集成到公司监控系统）</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"os"</span>
	<span class="token string">"runtime/pprof"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">sayHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> list <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{<!-- --></span>
		list <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token string">"Hello World"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//CPU Profile</span>
	fc<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token string">"./cpu.prof"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> fc<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pprof<span class="token punctuation">.</span><span class="token function">StartCPUProfile</span><span class="token punctuation">(</span>fc<span class="token punctuation">)</span>
	<span class="token keyword">defer</span> pprof<span class="token punctuation">.</span><span class="token function">StopCPUProfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">//Memory Profile</span>
	fm<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span><span class="token string">"./mem.prof"</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">defer</span> fm<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pprof<span class="token punctuation">.</span><span class="token function">WriteHeapProfile</span><span class="token punctuation">(</span>fm<span class="token punctuation">)</span>

	<span class="token function">sayHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>执行命令：<code>go run pprof.go</code> 然后会得到数据采集文件：<code>cpu.prof</code> 和 <code>mem.prof</code> （后边分析会用到）。</p> 
<h4><a id="12_httpnethttppprof_61"></a>1.2 http方式采集（net/http/pprof）</h4> 
<p>通过 http 服务来获取 Profile 采样文件。 <code>import _ "net/http/pprof"</code></p> 
<p>优点：<strong>简单易用</strong>。<br> 使用场景：在线服务（一直运行着的程序）<br> ( <code>net/http/pprof</code> 中只是使用 <code>runtime/pprof</code> 包来进行封装了一下，并在http端口上暴露出来)</p> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"net/http"</span>
	<span class="token boolean">_</span> <span class="token string">"net/http/pprof"</span>
	<span class="token string">"strings"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">helloServer</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	r<span class="token punctuation">.</span><span class="token function">ParseForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">//解析参数，默认是不会解析的</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">)</span> <span class="token comment">//这些信息是输出到服务器端的打印信息</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"scheme"</span><span class="token punctuation">,</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Scheme<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Form<span class="token punctuation">[</span><span class="token string">"url_long"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> r<span class="token punctuation">.</span>Form <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"key:"</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"val:"</span><span class="token punctuation">,</span> strings<span class="token punctuation">.</span><span class="token function">Join</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Hello World!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> helloServer<span class="token punctuation">)</span>        <span class="token comment">//设置访问的路由</span>
	err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">//设置监听的端口</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"ListenAndServe: %s"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行 <code>go run main.go</code> 服务启动以后就可以访问 http://127.0.0.1:8080/debug/pprof/ 查看到数据了，如图：<br> <img src="https://images2.imgbox.com/79/f3/lIFjXvnZ_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="13_go_test_105"></a>1.3 go test</h4> 
<p>通过命令 <code>go test -bench . -cpuprofile cpu.prof</code> 来进行采集数据。<br> 优点：<strong>针对性强</strong>、细化到函数<br> 使用场景：进行某函数的性能测试</p> 
<h3><a id="_111"></a>二、数据内容</h3> 
<p>不管是前文哪种方式获取，都可以进行分析。这里http的方式把可以看到的信息全部都列出来了。</p> 
<table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>allocs</td><td><strong>内存</strong>分配情况的采样信息</td></tr><tr><td>blocks</td><td><strong>阻塞</strong>操作情况的采样信息</td></tr><tr><td>cmdline</td><td>显示程序启动<strong>命令参数</strong>及其参数</td></tr><tr><td>goroutine</td><td>显示当前所有<strong>协程</strong>的堆栈信息</td></tr><tr><td>heap</td><td><strong>堆</strong>上的内存分配情况的采样信息</td></tr><tr><td>mutex</td><td><strong>锁</strong>竞争情况的采样信息</td></tr><tr><td>profile</td><td><strong>cpu</strong>占用情况的采样信息，点击会下载文件</td></tr><tr><td>threadcreate</td><td>系统<strong>线程</strong>创建情况的采样信息</td></tr><tr><td>trace</td><td>程序<strong>运行跟踪</strong>信息</td></tr></tbody></table> 
<h3><a id="_126"></a>三、数据分析</h3> 
<p>虽然我们生成了数据，这些数据可以存储到文件里、也可以展示在浏览器中。</p> 
<p>但是直接访问这些性能分析数据，我们是分析不过来什么的。Go在 <code>1.11</code> 版本后在它自带的工具集 <code>go tool</code> 里内置了 <code>pprof</code> 工具来分析由pprof库生成的数据文件。</p> 
<p>使用 <code>go tool pprof</code> 分析数据，主要有两种写法：</p> 
<ol><li>通过路径，如 <code>go tool pprof http://localhost:8080/debug/pprof/profile</code> （进入命令行交互模式）</li><li>通过下载的文件，如 <code>go tool pprof cpu.prof</code> （进入命令行交互模式）或者 <code>go tool pprof -http=:8081 cpu.prof</code>（进入web页面）</li></ol> 
<p>进入命令行交互模式后，可以使用 <code>help</code> 查看所有子命令，使用 <code>help &lt;cmd|option&gt;</code> 查看子命令使用方法。</p> 
<p><img src="https://images2.imgbox.com/33/30/FyfZYEuP_o.png" alt="在这里插入图片描述"><br> <strong>top 列出最耗时的地方</strong><br> <img src="https://images2.imgbox.com/ce/9c/AninrDgZ_o.png" alt="在这里插入图片描述"></p> 
<table><thead><tr><th>类型</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>flat</td><td>该函数占用CPU的耗时</td><td><code>net/url.shouldEscape</code> 占用CPU的耗时是440ms</td></tr><tr><td>flat%</td><td>该函数占用CPU的耗时的百分比</td><td><code>net/url.shouldEscape</code> 耗时：440ms，cpu总耗时：6330ms，440ms/6330ms=6.95%</td></tr><tr><td>sum%</td><td>top命令中排在它上面的函数以及本函数flat%之和</td><td><code>runtime.scanobject</code>：6.95%+6.95%+5.69%=19.59%</td></tr><tr><td>cum</td><td>当前函数加上该函数调用之前的累计CPU耗时</td><td>应该大于等于flat</td></tr><tr><td>cum%</td><td>当前函数加上该函数调用之前的累计CPU耗时的百分比</td><td>应该大于等于flat%</td></tr><tr><td>最后一列</td><td>当前函数名称</td><td></td></tr></tbody></table> 
<p>发现flat越大代表越有问题耗时越高，越可能存在问题。发现 <code>net/url.shouldEscape</code> 函数有点问题。此时通过命令：<code>list net/url.shouldEscape</code>，来进行查看具体的位置（图下图）。<br> <img src="https://images2.imgbox.com/cc/05/IX6Qotyr_o.png" alt="在这里插入图片描述"><br> <strong>可视化页面</strong><br> 两种方式可以支持浏览器打开web站：</p> 
<ol><li>执行命令：<code>go tool pprof -http=:8081 cpu.prof</code></li><li>或者在命令模式输入 <code>web</code> 自动生成svg文件，并跳转到浏览器，依赖安装：https://www.graphviz.org/download/source/。</li></ol> 
<p><img src="https://images2.imgbox.com/e8/02/cA6tru8x_o.png" alt="在这里插入图片描述">左上角方框内数据：表示显示的为cpu的画像。显示的节点在总共30.09s的抽样中，占6.33s，比例为 21.04%。</p> 
<p>图中每个方框对应应用程序运行的一个函数，方框越大代表函数执行的时间越久（函数执行时间会包含它调用的子函数的执行时间，但并不是正比的关系）；方框之间的箭头代表着调用关系，箭头上的数字代表被调用函数的执行时间。具体细节可以参考：https://github.com/google/pprof/tree/master/doc#interpreting-the-callgraph</p> 
<p><img src="https://images2.imgbox.com/5d/df/1MTCSoD6_o.png" alt="在这里插入图片描述"></p> 
<p>方框中显示的时间为总时间，gin(*Context)Next 的总执行时间为 3.42s，总时间占比为54.03%，只算函数自身执行时间为3.42s。<br> 通过函数调用图，可以很直观的看出哪个函数耗时严重。</p> 
<p><strong>分析函数代码</strong><br> 当确定出哪个函数耗时之后，可以用pprof分析函数中的哪一行导致的耗时，使用子命令：list 函数名。</p> 
<pre><code>(pprof) list net/url.shouldEscape
Total: 6.33s
ROUTINE ======================== net/url.shouldEscape in /usr/local/go/src/net/url/url.go
     440ms      440ms (flat, cum)  6.95% of Total
         .          .     97://
         .          .     98:// Please be informed that for now shouldEscape does not check all
         .          .     99:// reserved characters correctly. See golang.org/issue/5684.
         .          .    100:func shouldEscape(c byte, mode encoding) bool {
         .          .    101:	// §2.3 Unreserved characters (alphanum)
     220ms      220ms    102:	if 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z' || '0' &lt;= c &amp;&amp; c &lt;= '9' {
     200ms      200ms    103:		return false
         .          .    104:	}
         .          .    105:
      10ms       10ms    106:	if mode == encodeHost || mode == encodeZone {
         .          .    107:		// §3.2.2 Host allows
         .          .    108:		//	sub-delims = "!" / "$" / "&amp;" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
         .          .    109:		// as part of reg-name.
         .          .    110:		// We add : because we include :port as part of host.
         .          .    111:		// We add [ ] because we include [ipv6]:port as part of host.
         .          .    112:		// We add &lt; &gt; because they're the only characters left that
         .          .    113:		// we could possibly allow, and Parse will reject them if we
         .          .    114:		// escape them (because hosts can't use %-encoding for
         .          .    115:		// ASCII bytes).
         .          .    116:		switch c {
         .          .    117:		case '!', '$', '&amp;', '\'', '(', ')', '*', '+', ',', ';', '=', ':', '[', ']', '&lt;', '&gt;', '"':
         .          .    118:			return false
         .          .    119:		}
         .          .    120:	}
         .          .    121:
         .          .    122:	switch c {
      10ms       10ms    123:	case '-', '_', '.', '~': // §2.3 Unreserved characters (mark)
         .          .    124:		return false
         .          .    125:
         .          .    126:	case '$', '&amp;', '+', ',', '/', ':', ';', '=', '?', '@': // §2.2 Reserved characters (reserved)
         .          .    127:		// Different sections of the URL allow a few of
         .          .    128:		// the reserved characters to appear unescaped.
</code></pre> 
<p>可以看出，对于 <code>net/url.shouldEscape</code> 函数，耗时的位置主要在第 102 行，字符串比较的操作。</p> 
<p><strong>Memory Profiling</strong><br> 同CPU操作</p> 
<p>使用profile可以获取很多重要信息，cpu profiling、memory profiling使用也是最频繁的。分析的时候，需要先获取到数据，通过web发现耗时的函数，然后通过list找到具体位置。</p> 
<p>其它的数据的分析和CPU、Memory基本一致。下面列一下所有的数据类型：</p> 
<table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>http://localhost:8082/debug/pprof/</td><td>获取概况信息，即图一的信息</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/allocs</td><td>分析内存分配</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/block</td><td>分析堆栈跟踪导致阻塞的同步原语</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/cmdline</td><td>分析命令行调用的程序，web下调用报错</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/goroutine</td><td>分析当前 goroutine 的堆栈信息</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/heap</td><td>分析当前活动对象内存分配</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/mutex</td><td>分析堆栈跟踪竞争状态互斥锁的持有者</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/profile</td><td>分析一定持续时间内CPU的使用情况</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/threadcreate</td><td>分析堆栈跟踪系统新线程的创建</td></tr><tr><td>go tool pprof http://localhost:8082/debug/pprof/trace</td><td>分析追踪当前程序的执行状况</td></tr></tbody></table> 
<h3><a id="_228"></a>参考</h3> 
<p><a href="https://zhuanlan.zhihu.com/p/371713134" rel="nofollow">一文搞懂pprof</a><br> <a href="https://studygolang.com/articles/26918#reply0" rel="nofollow"> 一看就懂系列之Golang的pprof </a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31f793f7d41155b0c7af04859062c38f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一文搞定Http缓存-强制缓存与协商缓存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c86f0c57ef2562eeddfda8858847024/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python：No module named ‘tqdm’</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>