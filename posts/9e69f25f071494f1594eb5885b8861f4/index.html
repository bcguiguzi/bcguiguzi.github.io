<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【交叉编译踩坑指北（一）】windows10下Vscode与Cmake编译生成文件 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【交叉编译踩坑指北（一）】windows10下Vscode与Cmake编译生成文件" />
<meta property="og:description" content="1、工具链安装 工具链版本如下
C:\Users\Lenovo&gt;cmake -version
cmake version 3.24.2
C:\Users\Lenovo&gt;mingw32-make -v
GNU Make 4.2.1 Built for x86_64-w64-mingw32
若没有以上工具则进行安装，将bin文件加入到环境变量中，注意：有的交叉编译器在安装时选择自动加入环境变量可能并不会加入，还是需要手动加入环境变量，本章首先介绍MinGW编译器，其环境变量如图中所示，位于D盘bin目录下
该目录下包含了mingw的一系列工具链
包括mingw的make文件，mingw32-make（在运行makefile时要使用mingw32-make而不是make）
还有mingw的gcc文件，用于编译.c文件生成可执行文件
它们的关系是这样的：make用于执行Makefiles，Makefiles中包含了一系列的gcc语句用于编译连接，因此make相当于借助makefiles执行一系列gcc指令的指令。（这里的make代表了一系列的make工具，对于mingw是mingw32-make，对于其他工具可能是其他名字。gcc也同理，这里是x86_64-w64-mingw32-gcc）
一个小探究，这里发现mingw的bin文件夹下除了x86_64-w64-mingw32-gcc还有一个gcc文件，但当我们在cmd中查看他们各自的版本时发现提示是一样的
C:\Users\Lenovo&gt;gcc -v Using built-in specs. COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=D:/mingw64/bin/…/libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe
Target: x86_64-w64-mingw32
C:\Users\Lenovo&gt;x86_64-w64-mingw32-gcc -v Using built-in specs.
COLLECT_GCC=x86_64-w64-mingw32-gcc
COLLECT_LTO_WRAPPER=D:/mingw64/bin/…/libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe
Target: x86_64-w64-mingw32
应当是都被重定向到了同一个可执行文件
2、安装Vscode插件 C/C&#43;&#43;
Cmake
Cmake Tools
3、CMake介绍 CMake是一个跨平台的Makefile生成工具
依赖的文件是CMakeLists.txt，其作用简单归结为：
cmake执行CMakeLists.txt生成Makefiles，然后make执行Makefiles，调用Makefiles中一系列gcc编译生成可执行的目标文件
在这个过程中，make有不同的工具，gcc也有不同的工具，因此在整个工具链中需要进行配置。例如如果是生成windows可执行文件，Cmake就要配置生成MinGW Makefiles，执行Makefiles要选择mingw32-make，编译器要选择x86_64-w64-mingw32-gcc
4、VScode中CMake的使用 shift&#43;ctrl&#43;P:并输入如下指令
cmake:quick start
为本工程开启CMake tools 然后就会看到cmake tools在vscode中的UI
可以点击这里
来进行配置编译器的选择，比如mingw编译器或者arm交叉编译器
5、操作流程（简易版Cmake，无文件层次） 5.1创建文件夹并在VScode中打开 在桌面上新建了一个空文件夹test_hello，并在VScode中打开文件夹
5.2创建文件hello.c hello.c
#include&lt;stdio.h&gt; int main(){ printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/9e69f25f071494f1594eb5885b8861f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-17T14:46:54+08:00" />
<meta property="article:modified_time" content="2022-10-17T14:46:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【交叉编译踩坑指北（一）】windows10下Vscode与Cmake编译生成文件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1、工具链安装</h3> 
<p>  工具链版本如下</p> 
<blockquote> 
 <p>C:\Users\Lenovo&gt;cmake -version<br> cmake version 3.24.2</p> 
 <p>C:\Users\Lenovo&gt;mingw32-make -v<br> GNU Make 4.2.1 Built for x86_64-w64-mingw32</p> 
</blockquote> 
<p>  若没有以上工具则进行安装，将bin文件加入到环境变量中，<mark>注意：有的交叉编译器在安装时选择自动加入环境变量可能并不会加入，还是需要手动加入环境变量</mark>，本章首先介绍MinGW编译器，其环境变量如图中所示，位于D盘bin目录下<br> <img src="https://images2.imgbox.com/52/56/zr89upXT_o.png" alt="在这里插入图片描述">  该目录下包含了mingw的一系列工具链<br>   包括mingw的make文件，mingw32-make（在运行makefile时要使用mingw32-make而不是make）<br> <img src="https://images2.imgbox.com/c9/95/7pp15Wil_o.png" alt="在这里插入图片描述"><br>   还有mingw的gcc文件，用于编译.c文件生成可执行文件<br> <img src="https://images2.imgbox.com/91/62/I2sNpZ0c_o.png" alt="在这里插入图片描述"><br>   它们的关系是这样的：make用于执行Makefiles，Makefiles中包含了一系列的gcc语句用于编译连接，因此make相当于借助makefiles执行一系列gcc指令的指令。（这里的make代表了一系列的make工具，对于mingw是mingw32-make，对于其他工具可能是其他名字。gcc也同理，这里是x86_64-w64-mingw32-gcc）</p> 
<hr> 
<p><em>  一个小探究，这里发现mingw的bin文件夹下除了x86_64-w64-mingw32-gcc还有一个gcc文件，但当我们在cmd中查看他们各自的版本时发现提示是一样的</em></p> 
<blockquote> 
 <p>C:\Users\Lenovo&gt;gcc -v Using built-in specs. COLLECT_GCC=gcc<br> COLLECT_LTO_WRAPPER=D:/mingw64/bin/…/libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe<br> Target: x86_64-w64-mingw32</p> 
</blockquote> 
<blockquote> 
 <p>C:\Users\Lenovo&gt;x86_64-w64-mingw32-gcc -v Using built-in specs.<br> COLLECT_GCC=x86_64-w64-mingw32-gcc<br> COLLECT_LTO_WRAPPER=D:/mingw64/bin/…/libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe<br> Target: x86_64-w64-mingw32</p> 
</blockquote> 
<p><em>  应当是都被重定向到了同一个可执行文件</em></p> 
<hr> 
<h3><a id="2Vscode_30"></a>2、安装Vscode插件</h3> 
<p><strong>C/C++<br> Cmake<br> Cmake Tools</strong><br> <img src="https://images2.imgbox.com/f5/e2/KvXFvSDS_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3CMake_35"></a>3、CMake介绍</h3> 
<p>  CMake是一个跨平台的Makefile生成工具<br>   依赖的文件是CMakeLists.txt，其作用简单归结为：</p> 
<p><strong>cmake执行CMakeLists.txt生成Makefiles，然后make执行Makefiles，调用Makefiles中一系列gcc编译生成可执行的目标文件</strong></p> 
<p>  在这个过程中，make有不同的工具，gcc也有不同的工具，因此在整个工具链中需要进行配置。例如如果是生成windows可执行文件，Cmake就要配置生成MinGW Makefiles，执行Makefiles要选择mingw32-make，编译器要选择x86_64-w64-mingw32-gcc</p> 
<h3><a id="4VScodeCMake_43"></a>4、VScode中CMake的使用</h3> 
<p>shift+ctrl+P:并输入如下指令<br> <mark>cmake:quick start</mark></p> 
<pre><code>为本工程开启CMake tools
</code></pre> 
<p>然后就会看到cmake tools在vscode中的UI<br> <img src="https://images2.imgbox.com/47/2e/SbExyX2y_o.png" alt="在这里插入图片描述">可以点击这里<img src="https://images2.imgbox.com/0c/f4/tH8lfKps_o.png" alt="在这里插入图片描述"></p> 
<p>来进行配置编译器的选择，比如mingw编译器或者arm交叉编译器</p> 
<h3><a id="5Cmake_54"></a>5、操作流程（简易版Cmake，无文件层次）</h3> 
<h5><a id="51VScode_55"></a>5.1创建文件夹并在VScode中打开</h5> 
<p><img src="https://images2.imgbox.com/11/a9/VrQITOZz_o.png" alt="在这里插入图片描述"></p> 
<p>  在桌面上新建了一个空文件夹test_hello，并在VScode中打开文件夹</p> 
<h5><a id="52helloc_60"></a>5.2创建文件hello.c</h5> 
<p><mark>hello.c</mark></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"HELLO\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/78/13/7fyss4hK_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="53CMakeListstxt_71"></a>5.3创建文件CMakeLists.txt</h5> 
<p><mark>CMakeLists.txt</mark></p> 
<pre><code class="prism language-cmake">#cmake使用#注释
cmake_minimum_required(VERSION 3.0)#指定最低版本，不超过前面查看的当前版本
project(hello_simple)#指定当前项目名称
add_executable(hello hello.c)#指定生成目标、源文件
</code></pre> 
<p><img src="https://images2.imgbox.com/23/4d/4bPIkUL6_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="54VScodeCMakeTools_80"></a>5.4配置VScode插件CMakeTools选项</h5> 
<p>进入用户设置<br> <img src="https://images2.imgbox.com/8e/80/0KhrvPvz_o.png" alt="在这里插入图片描述"> <br>  <br>  </p> 
<p>选择CMakeTools设置<br> <img src="https://images2.imgbox.com/f5/4d/OC8VBOSa_o.png" alt="在这里插入图片描述"> <br>  <br>  <br> 可以看到生成文件的默认目录是会在当前文件夹下创建一个build文件夹，生成文件都生成在这个build文件夹中<br> <img src="https://images2.imgbox.com/38/e9/CIBJNALS_o.png" alt="在这里插入图片描述"> <br>  <br>  <br> 此外还有源代码目录选择，这个和build一样，都先默认不设置<br> <img src="https://images2.imgbox.com/e0/1c/bJNQjJtm_o.png" alt="在这里插入图片描述"></p> 
<p> <br>  <br>  <br> CMake生成器（Generator）配置。<br> <strong>CMake不编译或链接任何源文件，它使用生成器为构建系统创建配置文件。</strong><br> 相当于在终端（cmd或者powershell）中输入cmake -G后面的参数，例如cmake -G “MinGW Makefiles”<br> <img src="https://images2.imgbox.com/9b/6d/tPdYTt5o_o.png" alt="在这里插入图片描述"><br> 在终端输入</p> 
<pre><code>cmake -help
</code></pre> 
<p>可以看到-G可选参数，其中常见的有这几种。也就是说在上述Cmake:Generator中可选这些生成器，*号表示默认的生成器<br> <img src="https://images2.imgbox.com/be/be/c6fIjkqb_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="55CMakeToolsUI_110"></a>5.5开启CMakeTools的UI并选择编译器</h5> 
<pre><code>shift+ctrl+P
</code></pre> 
<p>弹出的窗口输入：</p> 
<pre><code>cmake:quick start
</code></pre> 
<p><img src="https://images2.imgbox.com/fa/d9/puxF4gCV_o.png" alt="在这里插入图片描述"> <br>  <br>  <br> 并点击,会弹出来如下选择<br> <img src="https://images2.imgbox.com/eb/65/dvQ7voev_o.png" alt="在这里插入图片描述">第一次使用时推荐第一个，这个会在本机中扫描编译器和交叉编译器（前提是必须先添加到系统环境变量中，详见本章第一节），特别是遇到BC没出现的情况时，点击A后UI会自动启动，然后在窗口底部的这个位置可以点击选择编译器。<br> <img src="https://images2.imgbox.com/0d/aa/30QUgU5z_o.png" alt="在这里插入图片描述">这里选择x86_64-w64-mingw32-gcc 构建windows系统的可执行文件，则生成文件是exe格式的。</p> 
<p> <br>  <br> 点击build进行构建，部分输出如下<br> <img src="https://images2.imgbox.com/4d/af/iIJtFGpj_o.png" alt="在这里插入图片描述">可以根据提示知道最后成功构建了可执行文件hello.exe（在build文件下）</p> 
<p>由此可知，VScode中的CMakeTools可以一步到位完成构建生成，而不是像终端中那样，先构建生成Makefile，然后再用make指令生产最终可执行文件。</p> 
<hr> 
<p><em>这里稍微拓展一下，如果要在终端进行构建的话，如果前面cmake -G参数选的是MinGw Makefiles，那么后面make指令就要选mingw工具链中的make，即mingw64-make（第一节中所介绍的）指令来执行Makefile，这体现了工具链的对应性和一致性</em></p> 
<hr> 
<h5><a id="56_136"></a>5.6执行生成文件，观察结果</h5> 
<p><img src="https://images2.imgbox.com/b3/2f/bItafVfM_o.png" alt="在这里插入图片描述"><br> 可以看到，生成文件都在build中，包含了中间文件Makefile，还有目标文件hello.exe等。<br> 直接在终端中cd到build下（输入E: 按下回车可以改变到对应盘符）输入</p> 
<pre><code>./hello.exe
</code></pre> 
<p>结果如下，这里用的是VScode内置powershell<br> <img src="https://images2.imgbox.com/5b/46/BmqtdHuV_o.png" alt="在这里插入图片描述">成功输出结果，圆满完成任务！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ec5b7e637dd3e4e3e6cfa9550f697ab7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">对于函数和的基础1（初学）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd4e76d75178d96c1b2dcae207480f84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pycharm 快捷键</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>