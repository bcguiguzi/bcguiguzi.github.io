<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Three.js--》探寻Cannon.js构建震撼的3D物理交互体验（二） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Three.js--》探寻Cannon.js构建震撼的3D物理交互体验（二）" />
<meta property="og:description" content="我们用three.js可以绘制出各种酷炫的画面，但是当我们想要一个更加真实的物理效果的话，这个时候我们就需要一个物理的库，接下来我们就讲解一下今天要学习的canon，它可以给我们提供一个更加真实的物理效果，像物体的张力、摩擦力、拉伸、反弹等等各种真实的物理效果。该库都能够有一个非常好的模拟。
PS：目前博主在一家互联网公司工作，该公司的编码风格是vue&#43;tsx，所以接下来的项目以该编码风格进行举例，详细了解参考我之前的文章：地址 。
目录
碰撞与碰撞事件
休眠与休眠事件
物体形状组合
物体施加作用力
碰撞与碰撞事件 在上一篇文章我们讲解到了碰撞的一些基本概念：地址 ，接下来我们开始学习如何监听和获取碰撞的事件和信息，如下：
得到的结果如下所示：
我们可以点击监听信息e查看一下，有如下重要的信息：
我们点击contact进入到里面，可以找到一个函数来查看当前物体碰撞的碰撞速度：
接下来通过函数来对当前物体的碰撞速度度进行一个监听：
// 监听立方体 boxBody.addEventListener(&#34;collide&#34;, (e) =&gt; { console.log(&#34;碰撞了&#34;, e) let impactStrength = e.contact.getImpactVelocityAlongNormal() console.log(&#34;当前的碰撞速度：&#34;, impactStrength) }) 可以看到，随着时间的流逝，碰撞的高度逐渐减小，物体相互之间的碰撞速度也在逐渐减少：
休眠与休眠事件 物体的休眠指的是当物体在物理世界中没有发生运动时，会进入休眠状态以减少计算负担。当物体处于休眠状态时，物理引擎会暂停对该物体的碰撞检测和运动模拟，从而节省计算资源。只有在物体被外力唤醒（如碰撞或施加力）时，物体才会从休眠状态中唤醒，重新参与物理模拟。休眠状态有助于提高物理引擎的性能并减少不必要的计算开销。
我们在开始的时候允许物理世界的物体可以进入休眠状态：
然后我们可以设置立方体可以进入休眠状态，以及进入休眠状态的一些条件：
如下可以看到我们已经实现了立方体休眠的效果：
当然如果想监听休眠事件的话可以通过如下的方式进行：
在最后的那一刻物体进入到了休眠的状态：
物体形状组合 接下来我们通过设置物体的位置，让物体之间相互组合在一起，如下：
// 创建由两个球加一个圆柱体组成的胶囊体 const capsuleBody = new CANNON.Body({ mass: 1, position: new CANNON.Vec3(0, 5, 0), material: boxMaterialCon, }) // 创建一个球的几何体 const sphereShape = new CANNON.Sphere(0.5) // 创建一个圆柱体几何体 const cylinderShape = new CANNON." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f9342658d57c8ea2eea26d0c8f399f56/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-06T22:32:16+08:00" />
<meta property="article:modified_time" content="2024-03-06T22:32:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Three.js--》探寻Cannon.js构建震撼的3D物理交互体验（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>我们用three.js可以绘制出各种酷炫的画面，但是当我们想要一个更加真实的物理效果的话，这个时候我们就需要一个物理的库，接下来我们就讲解一下今天要学习的canon，它可以给我们提供一个更加真实的物理效果，像物体的张力、摩擦力、拉伸、反弹等等各种真实的物理效果。该库都能够有一个非常好的模拟。</p> 
<blockquote> 
 <p>PS：目前博主在一家互联网公司工作，该公司的编码风格是vue+tsx，所以接下来的项目以该编码风格进行举例，详细了解参考我之前的文章：<a href="https://z5qyj5pyi.blog.csdn.net/article/details/130637168" rel="nofollow" title="地址">地址</a> 。</p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E7%A2%B0%E6%92%9E%E4%B8%8E%E7%A2%B0%E6%92%9E%E4%BA%8B%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E7%A2%B0%E6%92%9E%E4%B8%8E%E7%A2%B0%E6%92%9E%E4%BA%8B%E4%BB%B6" rel="nofollow">碰撞与碰撞事件</a></p> 
<p id="%E4%BC%91%E7%9C%A0%E4%B8%8E%E4%BC%91%E7%9C%A0%E4%BA%8B%E4%BB%B6-toc" style="margin-left:80px;"><a href="#%E4%BC%91%E7%9C%A0%E4%B8%8E%E4%BC%91%E7%9C%A0%E4%BA%8B%E4%BB%B6" rel="nofollow">休眠与休眠事件</a></p> 
<p id="%E7%89%A9%E4%BD%93%E5%BD%A2%E7%8A%B6%E7%BB%84%E5%90%88-toc" style="margin-left:80px;"><a href="#%E7%89%A9%E4%BD%93%E5%BD%A2%E7%8A%B6%E7%BB%84%E5%90%88" rel="nofollow">物体形状组合</a></p> 
<p id="%E7%89%A9%E4%BD%93%E6%96%BD%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%8A%9B-toc" style="margin-left:80px;"><a href="#%E7%89%A9%E4%BD%93%E6%96%BD%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%8A%9B" rel="nofollow">物体施加作用力</a></p> 
<hr id="hr-toc"> 
<h4 id="%E7%A2%B0%E6%92%9E%E4%B8%8E%E7%A2%B0%E6%92%9E%E4%BA%8B%E4%BB%B6">碰撞与碰撞事件</h4> 
<p>在上一篇文章我们讲解到了碰撞的一些基本概念：<a class="link-info" href="https://blog.csdn.net/qq_53123067/article/details/136437006?spm=1001.2014.3001.5501" title="地址">地址</a> ，接下来我们开始学习如何监听和获取碰撞的事件和信息，如下：</p> 
<p><img alt="" height="657" src="https://images2.imgbox.com/25/e9/GQqV969s_o.png" width="1200"></p> 
<p>得到的结果如下所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/59/fd/jl76DDWm_o.gif"></p> 
<p>我们可以点击监听信息e查看一下，有如下重要的信息：</p> 
<p><img alt="" height="213" src="https://images2.imgbox.com/62/3a/9ptsM8UK_o.png" width="996"></p> 
<p>我们点击contact进入到里面，可以找到一个函数来查看当前物体碰撞的碰撞速度：</p> 
<p><img alt="" height="447" src="https://images2.imgbox.com/a2/ba/PZ3C4ZUC_o.png" width="1140"></p> 
<p>接下来通过函数来对当前物体的碰撞速度度进行一个监听：</p> 
<pre><code class="language-javascript">// 监听立方体
boxBody.addEventListener("collide", (e) =&gt; {
    console.log("碰撞了", e)
    let impactStrength = e.contact.getImpactVelocityAlongNormal()
    console.log("当前的碰撞速度：", impactStrength)
})</code></pre> 
<p>可以看到，随着时间的流逝，碰撞的高度逐渐减小，物体相互之间的碰撞速度也在逐渐减少：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/5d/ca/2pFLoRwy_o.gif"></p> 
<h4 id="%E4%BC%91%E7%9C%A0%E4%B8%8E%E4%BC%91%E7%9C%A0%E4%BA%8B%E4%BB%B6">休眠与休眠事件</h4> 
<p>物体的休眠指的是当物体在物理世界中没有发生运动时，会进入休眠状态以减少计算负担。当物体处于休眠状态时，物理引擎会暂停对该物体的碰撞检测和运动模拟，从而节省计算资源。只有在物体被外力唤醒（如碰撞或施加力）时，物体才会从休眠状态中唤醒，重新参与物理模拟。休眠状态有助于提高物理引擎的性能并减少不必要的计算开销。</p> 
<p>我们在开始的时候允许物理世界的物体可以进入休眠状态：</p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/67/6f/oYKdjiWa_o.png" width="1200"></p> 
<p>然后我们可以设置立方体可以进入休眠状态，以及进入休眠状态的一些条件：</p> 
<p><img alt="" height="554" src="https://images2.imgbox.com/bf/4c/gLArL1fU_o.png" width="1200"></p> 
<p>如下可以看到我们已经实现了立方体休眠的效果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d8/e8/x0rMRc55_o.gif"></p> 
<p>当然如果想监听休眠事件的话可以通过如下的方式进行：</p> 
<p><img alt="" height="228" src="https://images2.imgbox.com/70/e4/XZtm4Iog_o.png" width="1200"></p> 
<p>在最后的那一刻物体进入到了休眠的状态：</p> 
<p><img alt="" height="622" src="https://images2.imgbox.com/1c/f2/SsVdUXqf_o.png" width="1200"></p> 
<h4 id="%E7%89%A9%E4%BD%93%E5%BD%A2%E7%8A%B6%E7%BB%84%E5%90%88">物体形状组合</h4> 
<p>接下来我们通过设置物体的位置，让物体之间相互组合在一起，如下：</p> 
<pre><code class="language-javascript">// 创建由两个球加一个圆柱体组成的胶囊体
const capsuleBody = new CANNON.Body({
    mass: 1,
    position: new CANNON.Vec3(0, 5, 0),
    material: boxMaterialCon,
})
// 创建一个球的几何体
const sphereShape = new CANNON.Sphere(0.5)
// 创建一个圆柱体几何体
const cylinderShape = new CANNON.Cylinder(0.5, 0.5, 1.5, 20)
// 将球体和圆柱体添加到body中
capsuleBody.addShape(sphereShape, new CANNON.Vec3(0, 0.75, 0))
capsuleBody.addShape(cylinderShape, new CANNON.Vec3(0, 0, 0))
capsuleBody.addShape(sphereShape, new CANNON.Vec3(0, -0.75, 0))
// 将body添加到物理世界中
world.addBody(capsuleBody)
phyMeshes.push(capsuleBody)

// 创建胶囊体网格
const capsuleGeometry =new THREE.CylinderGeometry(0.5, 0.5, 1.5, 20);
const capsuleMaterial=new THREE.MeshBasicMaterial({color: 0x00ff00 })
const capsuleMesh = new THREE.Mesh(capsuleGeometry, capsuleMaterial);
capsuleMesh.position.copy(capsuleBody.position);
capsuleMesh.quaternion.copy(capsuleBody.quaternion);
scene.add(capsuleMesh);
meshes.push(capsuleMesh);
//创建一个球体
const sphereGeometry = new THREE.SphereGeometry(0.5, 20, 20);
const sphereMaterial=new THREE.MeshBasicMaterial({ color: 0x0000ff })
const sphereMesh =new THREE.Mesh(sphereGeometry, sphereMaterial);
sphereMesh.position.set(0, 0.75, 0);
capsuleMesh.add(sphereMesh);
const sphereMesh2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
sphereMesh2.position.set(0, -0.75, 0);
capsuleMesh.add(sphereMesh2);
</code></pre> 
<p>得到的代码效果如下所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/41/DVNYrkzU_o.gif"></p> 
<p>接下来我们给胶囊添加一个水平的速度，然后减少弹性系数增加摩擦系数，看看胶囊会不会倒下</p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/9a/5b/ScZHuAZT_o.png" width="1200"></p> 
<p>得到的效果如下所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ca/99/vDgHixxe_o.gif"></p> 
<p>具体操作代码如下：</p> 
<pre><code class="language-javascript">import { defineComponent } from "vue";
import * as THREE from 'three'
import { OrbitControls }  from 'three/examples/jsm/controls/OrbitControls.js'
import * as CANNON from 'cannon-es'
import './index.scss'

export default defineComponent({
    setup() {
        // 初始化物理世界
        const world = new CANNON.World()
        // 初始化物理世界的重力
        world.gravity.set(0, -9.82, 0)
        // 设置物理世界允许休眠
        world.allowSleep = true
        
        // 初始化3D世界
        const scene = new THREE.Scene()
        // 初始化相机
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.z = 8
        camera.position.y = 5
        camera.position.x = 2
        // 初始化渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)
        // 初始化控制器
        const controls = new OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true

        // 创建网格数组
        let phyMeshes: any[] = [] // 物理世界
        let meshes: any[] = [] // 渲染世界

        // 设置立方体的材质
        const boxMaterialCon = new CANNON.Material("boxMaterial")
        boxMaterialCon.friction = 0.2
        boxMaterialCon.restitution = 0.1 // 设置弹性

        // 创建由两个球加一个圆柱体组成的胶囊体
        const capsuleBody = new CANNON.Body({
            mass: 1,
            position: new CANNON.Vec3(0, 5, 0),
            material: boxMaterialCon,
        })
        // 创建一个球的几何体
        const sphereShape = new CANNON.Sphere(0.5)
        // 创建一个圆柱体几何体
        const cylinderShape = new CANNON.Cylinder(0.5, 0.5, 1.5, 20)
        // 将球体和圆柱体添加到body中
        capsuleBody.addShape(sphereShape, new CANNON.Vec3(0, 0.75, 0))
        capsuleBody.addShape(cylinderShape, new CANNON.Vec3(0, 0, 0))
        capsuleBody.addShape(sphereShape, new CANNON.Vec3(0, -0.75, 0))
        // 将body添加到物理世界中
        world.addBody(capsuleBody)
        phyMeshes.push(capsuleBody)

        // 创建胶囊体网格
        const capsuleGeometry =new THREE.CylinderGeometry(0.5, 0.5, 1.5, 20);
        const capsuleMaterial=new THREE.MeshBasicMaterial({color: 0x00ff00 })
        const capsuleMesh = new THREE.Mesh(capsuleGeometry, capsuleMaterial);
        capsuleMesh.position.copy(capsuleBody.position);
        capsuleMesh.quaternion.copy(capsuleBody.quaternion);
        scene.add(capsuleMesh);
        meshes.push(capsuleMesh);

        // 给胶囊一个水平的速度
        capsuleBody.velocity.set(2, 0, 0)
        //创建一个球体
        const sphereGeometry = new THREE.SphereGeometry(0.5, 20, 20);
        const sphereMaterial=new THREE.MeshBasicMaterial({ color: 0x0000ff })
        const sphereMesh =new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphereMesh.position.set(0, 0.75, 0);
        capsuleMesh.add(sphereMesh);
        const sphereMesh2 = new THREE.Mesh(sphereGeometry, sphereMaterial);
        sphereMesh2.position.set(0, -0.75, 0);
        capsuleMesh.add(sphereMesh2);

        // 创建一个物理世界的平面
        // const planeShape = new CANNON.Plane()
        const planeShape = new CANNON.Box(new CANNON.Vec3(5, 0.1, 5))
        // 创建一个刚体
        const planeBody = new CANNON.Body({
            // mass: 0, // 设置质量为0，不受碰撞的影响
            shape: planeShape,
            position: new CANNON.Vec3(0, 0.1, 0),
            type: CANNON.Body.STATIC, // 设置物体为静态，不受碰撞的影响
            material: boxMaterialCon,
        })
        // 将刚体添加到物理世界当中
        world.addBody(planeBody)
        // 物理世界创建的东西不显示，所以我们要再通过three.js再创建一个平面
        // const planeGeometry = new THREE.PlaneGeometry(10, 10) // 因为渲染的东西不是无限衍生，这里给10x10
        const planeGeometry = new THREE.BoxGeometry(10, 0.2, 10)
        // 创建一个平面材质
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 })
        // 创建一个平面网格
        const planeMesh = new THREE.Mesh(planeGeometry, planeMaterial)
        // 旋转平面90度让其平铺
        // planeMesh.rotation.x = 0.1
        // 将网格添加到3D场景当中
        scene.add(planeMesh)
        
        // 渲染
        let clock = new THREE.Clock()
        const animate = () =&gt; {
            // 获取了两次渲染之间的时间差，通常用于控制动画和物理模拟。
            let delta = clock.getDelta()
            world.step(delta)
            // 使用时间差来推进物理世界的模拟
            for(let i = 0; i &lt; phyMeshes.length; i++) {
                meshes[i].position.copy(phyMeshes[i].position)
                meshes[i].quaternion.copy(phyMeshes[i].quaternion)
            }
            controls.update()
            renderer.render(scene, camera)
            requestAnimationFrame(animate)
        }
        animate()

        return () =&gt; {
            &lt;div&gt;&lt;/div&gt;
        }
    }
})</code></pre> 
<h4 id="%E7%89%A9%E4%BD%93%E6%96%BD%E5%8A%A0%E4%BD%9C%E7%94%A8%E5%8A%9B">物体施加作用力</h4> 
<p>在cannon中我们也可以给物体施加一些作用力，体验网站：<a class="link-info" href="https://pmndrs.github.io/cannon-es/examples/impulses" rel="nofollow" title="地址">地址</a> ，这里面动态的给我们显示了给物体施加作用力的效果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3b/b0/DCLZWczO_o.gif"></p> 
<p>接下来我们通过代码进行一个简单的实现，创建一个物理球：</p> 
<p><img alt="" height="632" src="https://images2.imgbox.com/f8/96/9PASmvkQ_o.png" width="1200"></p> 
<p>然后我们设置一个点击事件，当发生点击之后，球会沿着水平方向移动，并且会发生旋转：</p> 
<pre><code class="language-javascript">// 监听点击事件
window.addEventListener("click", () =&gt; {
    sphereBody.applyForce(new CANNON.Vec3(10, 0, 0), new CANNON.Vec3(0, 0.5, 0),)
})</code></pre> 
<p>效果如下，我不断的点击鼠标，小球就往前移动：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/19/45/Vg7ziLiy_o.gif"></p> 
<p>当然还有如下的操作方式，这里就不再一一赘述了，感兴趣的可以自行尝试：</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/e9/4b/mUrzXpTM_o.png" width="963"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/35cdf985e81c1d3bfde4eec5d5907e63/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ARM如何利用PMU（Performance Monitor Unit）量化L3 cache的cache eviction（估算cache eviction的概率）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c91453fb1655bf58293747c070dd8934/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux 错误编号使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>