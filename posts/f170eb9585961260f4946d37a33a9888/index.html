<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从源码读懂 Handler 的原理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从源码读懂 Handler 的原理" />
<meta property="og:description" content="文章目录 一、Handler 的工作原理二、Handler 中 postDelay 方法的原理为什么不采用延时发送消息的方式实现 postDelay 方法 三、在线程中新建 Handler 之前为什么要先调用 Looper.prepare()四、为什么在主线程新建 Handler 不需要先调用 Looper.prepare()五、主线程的 loop 是一个死循环，为什么不会发生 anr六、一个线程有两个 Handler 的时候，其中一个 Handler 调用 removeCallbacksAndEqualMessages() 是否会影响另一个 Handler七、一个线程有两个 Handler 的时候，Looper 在处理消息的时候如何进行分配八、为什么创建 Message 对象的时候推荐优先使用 obtain() 获取 一、Handler 的工作原理 Handler 的正常运作依赖于三个组件：MessageQueue，Handler，Looper。
MessageQueue 是一个消息队列，用于存放消息（Message），当我们创建 Handler 时，Handler 会持有一个 Looper，Looper 中有一个死循环 loop ，loop 会不断的从消息队列中取出消息并进行处理。
我们通过 Handler 的 sendMessage()，removeMessages() 等方法向消息队列添加或移除消息，通过 handleMessage() 对消息进行具体的处理。
Handler 构造函数：
public Handler(@Nullable Callback callback, boolean async) { ... mLooper = Looper.myLooper(); //Looper对象 if (mLooper == null) { throw new RuntimeException( &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f170eb9585961260f4946d37a33a9888/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-12T15:53:30+08:00" />
<meta property="article:modified_time" content="2022-03-12T15:53:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从源码读懂 Handler 的原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#Handler__3" rel="nofollow">一、Handler 的工作原理</a></li><li><a href="#Handler__postDelay__56" rel="nofollow">二、Handler 中 postDelay 方法的原理</a></li><li><ul><li><a href="#_postDelay__291" rel="nofollow">为什么不采用延时发送消息的方式实现 postDelay 方法</a></li></ul> 
   </li><li><a href="#_Handler__Looperprepare_295" rel="nofollow">三、在线程中新建 Handler 之前为什么要先调用 Looper.prepare()</a></li><li><a href="#_Handler__Looperprepare_343" rel="nofollow">四、为什么在主线程新建 Handler 不需要先调用 Looper.prepare()</a></li><li><a href="#_loop__anr_390" rel="nofollow">五、主线程的 loop 是一个死循环，为什么不会发生 anr</a></li><li><a href="#_Handler__Handler__removeCallbacksAndEqualMessages__Handler_394" rel="nofollow">六、一个线程有两个 Handler 的时候，其中一个 Handler 调用 removeCallbacksAndEqualMessages() 是否会影响另一个 Handler</a></li><li><a href="#_Handler_Looper__443" rel="nofollow">七、一个线程有两个 Handler 的时候，Looper 在处理消息的时候如何进行分配</a></li><li><a href="#_Message__obtain__496" rel="nofollow">八、为什么创建 Message 对象的时候推荐优先使用 obtain() 获取</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="Handler__3"></a>一、Handler 的工作原理</h3> 
<p>Handler 的正常运作依赖于三个组件：MessageQueue，Handler，Looper。</p> 
<p>MessageQueue 是一个消息队列，用于存放消息（Message），当我们创建 Handler 时，Handler 会持有一个 Looper，Looper 中有一个死循环 loop ，loop 会不断的从消息队列中取出消息并进行处理。</p> 
<p>我们通过 Handler 的 sendMessage()，removeMessages() 等方法向消息队列添加或移除消息，通过 handleMessage() 对消息进行具体的处理。</p> 
<p>Handler 构造函数：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//Looper对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>
            <span class="token string">"Can't create handler inside thread "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">+</span> <span class="token string">" that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>  <span class="token comment">//消息队列</span>
    mCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
    mAsynchronous <span class="token operator">=</span> async<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Handler 的 handleMessage 方法：</p> 
<pre><code class="prism language-java"><span class="token comment">/**
* Subclasses must implement this to receive messages.
*/</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Message msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>Looper 中的 loop 方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//loopOnce 会从消息队列中取出消息并处理</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">loopOnce</span><span class="token punctuation">(</span>me<span class="token punctuation">,</span> ident<span class="token punctuation">,</span> thresholdOverride<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Handler__postDelay__56"></a>二、Handler 中 postDelay 方法的原理</h3> 
<p>首先查看 Handler 中 postDelay() 方法的源码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postDelayed</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Runnable r<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接着看 sendMessageDelayed 方法中：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>delayMillis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        delayMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li>注意这里用的是 SystemClock.uptimeMillis()，这个值记录了系统启动到当前时刻经过的时间。但是系统深度睡眠(CPU睡眠，黑屏，系统等待唤醒)之中的时间不算在内。</li></ul> 
<p>继续看 sendMessageAtTime 方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        RuntimeException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>
            <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" sendMessageAtTime() called with no mQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token string">"Looper"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接着看 enqueueMessage 方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> MessageQueue queue<span class="token punctuation">,</span> <span class="token annotation punctuation">@NonNull</span> Message msg<span class="token punctuation">,</span>
            <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    msg<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    msg<span class="token punctuation">.</span>workSourceUid <span class="token operator">=</span> ThreadLocalWorkSource<span class="token punctuation">.</span><span class="token function">getUid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>mAsynchronous<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        msg<span class="token punctuation">.</span><span class="token function">setAsynchronous</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">enqueueMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>到这里可以看到，Handler 中并没有做什么延时操作，而是直接将消息放进了消息队列中，接下来看一下 MessageQueue 中 enqueueMessage 的具体实现：</p> 
<pre><code class="prism language-java"><span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> when<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>target <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Message must have a target."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">isInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>msg <span class="token operator">+</span> <span class="token string">" This message is already in use."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>mQuitting<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            IllegalStateException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>
                msg<span class="token punctuation">.</span>target <span class="token operator">+</span> <span class="token string">" sending message to a Handler on a dead thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            msg<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        msg<span class="token punctuation">.</span><span class="token function">markInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        msg<span class="token punctuation">.</span>when <span class="token operator">=</span> when<span class="token punctuation">;</span>
        Message p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> needWake<span class="token punctuation">;</span>     <span class="token comment">//注意此处的 needWake 变量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> when <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// New head, wake up the event queue if blocked.</span>
            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            mMessages <span class="token operator">=</span> msg<span class="token punctuation">;</span>
            needWake <span class="token operator">=</span> mBlocked<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span>
            <span class="token comment">// up the event queue unless there is a barrier at the head of the queue</span>
            <span class="token comment">// and the message is the earliest asynchronous message in the queue.</span>
            needWake <span class="token operator">=</span> mBlocked <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>target <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Message prev<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                prev <span class="token operator">=</span> p<span class="token punctuation">;</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    needWake <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// invariant: p == prev.next</span>
            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// We can assume mPtr != 0 because mQuitting is false.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">nativeWake</span><span class="token punctuation">(</span>mPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到 MessageQueue 中 enqueueMessage 也没有延时操作，只是按时间顺序将消息插入到消息队列中；由此我们可以得出一个结论，postDelay 并不是采用延时发送消息的方式实现的。</p> 
<p>既然不是在消息的发送上做延时，那接下来就看看处理消息的位置，Looper 中的 loopOnce 函数：</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">loopOnce</span><span class="token punctuation">(</span><span class="token keyword">final</span> Looper me<span class="token punctuation">,</span>
            <span class="token keyword">final</span> <span class="token keyword">long</span> ident<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> thresholdOverride<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Message msg <span class="token operator">=</span> me<span class="token punctuation">.</span>mQueue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// might block</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// No message indicates that the message queue is quitting.</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到 loopOnce 就是从消息队列取出消息并处理该消息，但是我们注意到 MessageQueue 的 next 方法这里有个可能阻塞的注释，看看next 方法做了什么：</p> 
<pre><code class="prism language-java">Message <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">int</span> nextPollTimeoutMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextPollTimeoutMillis <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            Binder<span class="token punctuation">.</span><span class="token function">flushPendingCommands</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">nativePollOnce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> nextPollTimeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Try to retrieve the next message.  Return if found.</span>
            <span class="token keyword">final</span> <span class="token keyword">long</span> now <span class="token operator">=</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Message prevMsg <span class="token operator">=</span> null<span class="token punctuation">;</span>
            Message msg <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span>target <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>
                <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
                    prevMsg <span class="token operator">=</span> msg<span class="token punctuation">;</span>
                    msg <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>msg<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&lt;</span> msg<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>
                    nextPollTimeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">// Got a message.</span>
                    mBlocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevMsg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        prevMsg<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                        mMessages <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    msg<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>DEBUG<span class="token punctuation">)</span> Log<span class="token punctuation">.</span><span class="token function">v</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"Returning message: "</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    msg<span class="token punctuation">.</span><span class="token function">markInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> msg<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// No more messages.</span>
                nextPollTimeoutMillis <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingIdleHandlerCount <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// No idle handlers to run.  Loop and wait some more.</span>
                mBlocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>   <span class="token comment">//不需要处理消息的时候设置为true</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这段代码中，我们主要关注 nativePollOnce 方法和 nextPollTimeoutMillis 变量，nativePollOnce 方法的作用类似于 object.wait()，作用就是阻塞：当队列中的消息需要处理时，设置 nextPollTimeoutMillis 值为 0，正常进行消息处理；当队列中的消息还没到达处理时间时，对 nextPollTimeoutMillis 进行赋值，设置定时器并阻塞；当队列中没有消息时，设置 nextPollTimeoutMillis 值为 -1 并阻塞。</p> 
<p>到这里 postDelay 的具体实现方式我们就已经了解了，但是这个消息处理机制还缺少一个唤醒步骤，刚才说到当队列中没有消息或者消息还没到达处理时间的时候线程会进入阻塞状态，有阻塞就会有唤醒，不然新消息到来时就没法继续处理了，根据这个推断我们重新看回消息的入队代码：</p> 
<pre><code class="prism language-java"><span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> when<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">boolean</span> needWake<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> when <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// New head, wake up the event queue if blocked.</span>
            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            mMessages <span class="token operator">=</span> msg<span class="token punctuation">;</span>
            needWake <span class="token operator">=</span> mBlocked<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span>
            <span class="token comment">// up the event queue unless there is a barrier at the head of the queue</span>
            <span class="token comment">// and the message is the earliest asynchronous message in the queue.</span>
            needWake <span class="token operator">=</span> mBlocked <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>target <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Message prev<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                prev <span class="token operator">=</span> p<span class="token punctuation">;</span>
                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    needWake <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment">// invariant: p == prev.next</span>
            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// We can assume mPtr != 0 because mQuitting is false.</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">nativeWake</span><span class="token punctuation">(</span>mPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到在将消息插入消息队列的队头时会将 mBlocked 赋值给 needWake，如果此时消息队列的 next 正在阻塞线程（即 mBlocked 为 true），就会通过 nativeWake 去唤醒线程。</p> 
<h4><a id="_postDelay__291"></a>为什么不采用延时发送消息的方式实现 postDelay 方法</h4> 
<p>因为如果采用延时发送消息的方式，需要对每一条延时消息都设置一个定时器，而采用这种设计方式最多只需要一个定时器，方便统一管理。</p> 
<h3><a id="_Handler__Looperprepare_295"></a>三、在线程中新建 Handler 之前为什么要先调用 Looper.prepare()</h3> 
<p>我们知道 Handler 的工具原理就是从通过一个死循环 loop 从消息队列中不断的取出消息并处理，而在默认情况下线程中是不存在 loop 的，因此如果我们想要在线程中使用 Handler，就必须先调用 Looper.prepare() 为线程创建一个循环，我们看一下 Looper 的 prepare 方法中做了什么：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到 prepare 方法的内容非常简单，就是为 sThreadLocal 设置了一个 Looper，即为线程创建一个循环，接下来我们看看创建 Handler 的方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>
            <span class="token string">"Can't create handler inside thread "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token operator">+</span> <span class="token string">" that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>
    mCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
    mAsynchronous <span class="token operator">=</span> async<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到在创建 Handler 的时候调用 Looper.myLooper() 去获取一个 Looper 对象，如果为空则抛出异常，我们看看这个 Looper.myLooper() 方法中做了什么：</p> 
<pre><code class="prism language-java"><span class="token comment">// sThreadLocal.get() will return null unless you've called prepare().</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token generics function"><span class="token punctuation">&lt;</span>Looper<span class="token punctuation">&gt;</span></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics function"><span class="token punctuation">&lt;</span>Looper<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token annotation punctuation">@Nullable</span> Looper <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到 myLooper 方法就是返回在 Looper.prepare() 方法中创建并设置给 sThreadLocal 对象的 Looper，在 sThreadLocal 的定义处我们也可以看到如果没有调用 prepare 方法为线程设置 Looper，则会返回一个 null 对象，此时 Handler 会抛出异常。因此在线程中使用 Handler 必须先调用 prepare 方法。</p> 
<h3><a id="_Handler__Looperprepare_343"></a>四、为什么在主线程新建 Handler 不需要先调用 Looper.prepare()</h3> 
<p>从上文的分析可以知道创建 Handler 之前是一定需要创建循环的，但在主线程中创建 Handler 时却没有这一步操作，那么只能是有人替我们完成了这一步操作。考虑 Handler 对于一个应用的重要性，我们推测 Looper 的初始化时机应该很早，所以我们从应用的入口：ActivityThread.java 的 main 方法看起：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    Looper<span class="token punctuation">.</span><span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ActivityThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActivityThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> startSeq<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainThreadHandler <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        sMainThreadHandler <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMessageLogging</span><span class="token punctuation">(</span><span class="token keyword">new</span>
                                            <span class="token class-name">LogPrinter</span><span class="token punctuation">(</span>Log<span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span> <span class="token string">"ActivityThread"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// End of event ActivityThreadMain.</span>
    Trace<span class="token punctuation">.</span><span class="token function">traceEnd</span><span class="token punctuation">(</span>Trace<span class="token punctuation">.</span>TRACE_TAG_ACTIVITY_MANAGER<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Main thread loop unexpectedly exited"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到在 main 方法中调用了 Looper.prepareMainLooper() 方法，看看这个方法做了什么：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Looper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainLooper <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"The main Looper has already been prepared."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sMainLooper <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到 prepareMainLooper 方法中替我们调用了 prepare 方法初始化了一个 Looper 对象，并且将这个 Looper 设置为了应用的 sMainLooper。因此我们可以用 Looper.getMainLooper() == Looper.myLooper() 来判断当前线程是否是主线程。</p> 
<h3><a id="_loop__anr_390"></a>五、主线程的 loop 是一个死循环，为什么不会发生 anr</h3> 
<p>回答此问题首先要明确 anr 的定义：anr 是指应用在一段时间内对用户的操作无响应，对于前台界面来说，5s 内没有响应用户的输入事件就会发生 anr。从定义可以知道，anr 的原因是对用户的操作无响应，而主线程中的 loop 并不会导致对用户操作无响应，相反，正是因为这个循环的存在，应用才能不断的处理事件，当循环退出时，应用就关闭了。</p> 
<h3><a id="_Handler__Handler__removeCallbacksAndEqualMessages__Handler_394"></a>六、一个线程有两个 Handler 的时候，其中一个 Handler 调用 removeCallbacksAndEqualMessages() 是否会影响另一个 Handler</h3> 
<p>首先看到 Handler 中的 removeCallbacksAndEqualMessages 方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">removeCallbacksAndEqualMessages</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Object token<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    mQueue<span class="token punctuation">.</span><span class="token function">removeCallbacksAndEqualMessages</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到该方法直接调用了 MessageQueue 的 removeCallbacksAndEqualMessages 方法，我们接着看 MessageQueue 中的 removeCallbacksAndEqualMessages 方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">removeCallbacksAndEqualMessages</span><span class="token punctuation">(</span>Handler h<span class="token punctuation">,</span> Object object<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Message p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>

        <span class="token comment">// Remove all messages at front.</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>target <span class="token operator">==</span> h <span class="token comment">//此处判断了消息的目标是哪一个Handler</span>
               <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null <span class="token operator">||</span> object<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            Message n <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            mMessages <span class="token operator">=</span> n<span class="token punctuation">;</span>
            p<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            p <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Remove all messages after front.</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            Message n <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>target <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null <span class="token operator">||</span> object<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    Message nn <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                    n<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> nn<span class="token punctuation">;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            p <span class="token operator">=</span> n<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到在移除消息的时候会判断消息的目标，因此两个 Handler 使用同一个消息队列的时候并不会互相影响。</p> 
<h3><a id="_Handler_Looper__443"></a>七、一个线程有两个 Handler 的时候，Looper 在处理消息的时候如何进行分配</h3> 
<p>我们看到实际处理消息的 loopOnce 函数：</p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">loopOnce</span><span class="token punctuation">(</span><span class="token keyword">final</span> Looper me<span class="token punctuation">,</span>
            <span class="token keyword">final</span> <span class="token keyword">long</span> ident<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token keyword">int</span> thresholdOverride<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
        msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用消息中储存的 Handler对象</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>observer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            observer<span class="token punctuation">.</span><span class="token function">messageDispatched</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        dispatchEnd <span class="token operator">=</span> needEndTime <span class="token operator">?</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>observer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            observer<span class="token punctuation">.</span><span class="token function">dispatchingThrewException</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> exception<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">throw</span> exception<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
        ThreadLocalWorkSource<span class="token punctuation">.</span><span class="token function">restore</span><span class="token punctuation">(</span>origWorkSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>traceTag <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            Trace<span class="token punctuation">.</span><span class="token function">traceEnd</span><span class="token punctuation">(</span>traceTag<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>再看到 Handler 的 dispatchMessage 方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatchMessage</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Message msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>callback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">handleCallback</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mCallback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>mCallback<span class="token punctuation">.</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> Message msg<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到在处理消息时通过消息中储存的 Handler 对象将消息直接分配给该 Handler 对象处理：</p> 
<h3><a id="_Message__obtain__496"></a>八、为什么创建 Message 对象的时候推荐优先使用 obtain() 获取</h3> 
<p>我们知道线程中有线程池的概念，在 message 中也有类似的概念，叫做消息池。在 Message 中定义了以下类变量和成员变量：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Message</span> <span class="token keyword">implements</span> <span class="token class-name">Parcelable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// sometimes we store linked lists of these things</span>
    Message next<span class="token punctuation">;</span>
    <span class="token comment">//消息池的链头</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Message sPool<span class="token punctuation">;</span>
    <span class="token comment">//消息池的大小</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> sPoolSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//消息池的最大上限</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAX_POOL_SIZE <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到消息池实际上是一条由消息组成的链表，接下来我们看到 obtain 方法的实现：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sPoolSync<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sPool <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            Message m <span class="token operator">=</span> sPool<span class="token punctuation">;</span>
            sPool <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            m<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
            m<span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// clear in-use flag</span>
            sPoolSize<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> m<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到当消息池不为空的时候，会返回消息池中已经创建好的消息，当消息池为空时才创建新消息，因此相对于直接创建消息可以提高对象的利用率。</p> 
<p>有从消息池取消息的操作，那当然就存在着往消息池放消息的操作，我们看到 recycleUnchecked 方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Mark the message as in use while it remains in the recycled object pool.</span>
    <span class="token comment">// Clear out all other details.</span>
    flags <span class="token operator">=</span> FLAG_IN_USE<span class="token punctuation">;</span>
    what <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    arg1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    arg2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    obj <span class="token operator">=</span> null<span class="token punctuation">;</span>
    replyTo <span class="token operator">=</span> null<span class="token punctuation">;</span>
    sendingUid <span class="token operator">=</span> UID_NONE<span class="token punctuation">;</span>
    workSourceUid <span class="token operator">=</span> UID_NONE<span class="token punctuation">;</span>
    when <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    target <span class="token operator">=</span> null<span class="token punctuation">;</span>
    callback <span class="token operator">=</span> null<span class="token punctuation">;</span>
    data <span class="token operator">=</span> null<span class="token punctuation">;</span>

    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sPoolSync<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sPoolSize <span class="token operator">&lt;</span> MAX_POOL_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            next <span class="token operator">=</span> sPool<span class="token punctuation">;</span>
            sPool <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
            sPoolSize<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以看到此方法会清楚 message 附带的信息，并将消息放进消息池中。我们调用 Handler 的 removeMessage 方法，或者 Looper 中处理过的消息都会通过 recycleUnchecked 回收到消息池中，从而提高对象的利用率。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0962ca881dc36c45d0c0c4a3ae44065e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">09_BatchNormal</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb0d5eab2c993ada3df9e383bd1e43a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">jwt实现登录验证</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>