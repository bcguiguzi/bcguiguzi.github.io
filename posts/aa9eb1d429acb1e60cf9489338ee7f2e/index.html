<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JAVA基础：线程池的使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JAVA基础：线程池的使用" />
<meta property="og:description" content="目录
1.概述
2.线程池的优势​​​​​​​
2.1.线程池为什么使用自定义方式？
2.2.封装的线程池工具类有什么好处？
3.线程池的七大参数
3.线程池的创建
3.1. 固定数量的线程池
3.2. 带缓存的线程池
3.3. 执⾏定时任务
3.4. 定时任务单线程
3.5. 单线程线程池
3.6. 根据当前CPU⽣成线程池
3.7. ThreadPoolExecutor★★★
4.使用线程池的最佳实践
4.1.拥有适当数量的线程
4.2.使用合适的工作队列
4.3.处理异常
4.4.使用线程池内置的监控和调试工具
5.线程池的使用案例
5.1.引入jar包
5.2.初始化线程池
5.3.测试案例
5.结论
6.鸣谢
1.概述 线程池是一种常见的多线程编程技术，它允许我们在系统中使用一个固定数量的线程来执行任务，以免过多的线程拉低了系统的性能。在本文中，我们将探讨线程池的使用和一些最佳实践，以便在您的代码中获得更好的性能和可维护性。
线程池是一种用于管理和调度多个线程的技术。线程池主要由三个部分组成：
线程管理器：负责启动、停止和管理线程池中的线程。工作队列：用于存储要执行的任务。线程池：包含线程管理器和工作队列。 线程池的工作原理如下：
1）当需要执行一个任务时，线程池会从工作队列中获取一个任务。
2）线程管理器会从线程池中获取一个可用的线程来执行任务。
3）任务执行完成后，线程会返回到线程池中，等待下一个任务的分配。
2.线程池的优势​​​​​​​ 2.1.线程池为什么使用自定义方式？ 因为 java 自带线程池都会有可能造成内存不足的问题。自定义线程池，根据服务器配置定制线程池核心线程、最大线程等，是最好的方式。
2.2.封装的线程池工具类有什么好处？ 扩展性高可注解形式实现执行可根据业务需要注册不同的线程池，区分业务模块使用可以执行无返回值线程任务，可以执行有返回值的线程任务 3.线程池的七大参数 核心线程数、最大线程数、多余线程存活时间、时间单位、线程工厂、阻塞队列、拒绝策略
/** * @param corePoolSize 核心线程数 -&gt; 线程池中保持的线程数量,即使它们是空闲的也不会销毁, * 除非设置了{@code allowCoreThreadTimeOut}核心线程超时时间 * @param maximumPoolSize 最大线程数 -&gt; 线程池中允许接收的最大线程数量 * 如果设定的数量比系统支持的线程数还要大时,会抛出OOM(OutOfMemoryError)异常 * @param keepAliveTime 最大存活时间 -&gt; 当前线程数大于核心线程数的时候, * 其他多余的线程接收新任务之前的最大等待时间,超过时间没有新任务就会销毁." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/aa9eb1d429acb1e60cf9489338ee7f2e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-25T10:34:08+08:00" />
<meta property="article:modified_time" content="2023-06-25T10:34:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JAVA基础：线程池的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#1.%E6%A6%82%E8%BF%B0" rel="nofollow">1.概述</a></p> 
<p id="2.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF-toc" style="margin-left:0px;"><a href="#2.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF" rel="nofollow">2.线程池的优势​​​​​​​</a></p> 
<p id="2.1.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%9F-toc" style="margin-left:40px;"><a href="#2.1.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%9F" rel="nofollow">2.1.线程池为什么使用自定义方式？</a></p> 
<p id="%E6%88%91%E5%B0%81%E8%A3%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E6%88%91%E5%B0%81%E8%A3%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F" rel="nofollow">2.2.封装的线程池工具类有什么好处？</a></p> 
<p id="3.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#3.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0" rel="nofollow">3.线程池的七大参数</a></p> 
<p id="%C2%A03.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%C2%A03.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">3.线程池的创建</a></p> 
<p id="3.1.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#3.1.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">3.1. 固定数量的线程池</a></p> 
<p id="3.2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#3.2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">3.2. 带缓存的线程池</a></p> 
<p id="3.3.%20%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1-toc" style="margin-left:40px;"><a href="#3.3.%20%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1" rel="nofollow">3.3. 执⾏定时任务</a></p> 
<p id="3.4.%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#3.4.%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B" rel="nofollow">3.4. 定时任务单线程</a></p> 
<p id="3.5.%20%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#3.5.%20%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">3.5. 单线程线程池</a></p> 
<p id="3.6.%20%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#3.6.%20%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">3.6. 根据当前CPU⽣成线程池</a></p> 
<p id="7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89-toc" style="margin-left:40px;"><a href="#7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89" rel="nofollow">3.7. ThreadPoolExecutor★★★</a></p> 
<p id="4.%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-toc" style="margin-left:0px;"><a href="#4.%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5" rel="nofollow">4.使用线程池的最佳实践</a></p> 
<p id="4.1.%E6%8B%A5%E6%9C%89%E9%80%82%E5%BD%93%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B-toc" style="margin-left:40px;"><a href="#4.1.%E6%8B%A5%E6%9C%89%E9%80%82%E5%BD%93%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B" rel="nofollow">4.1.拥有适当数量的线程</a></p> 
<p id="4.2.%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#4.2.%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97" rel="nofollow">4.2.使用合适的工作队列</a></p> 
<p id="4.3.%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8-toc" style="margin-left:40px;"><a href="#4.3.%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8" rel="nofollow">4.3.处理异常</a></p> 
<p id="4.4.%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E7%BD%AE%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7-toc" style="margin-left:40px;"><a href="#4.4.%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E7%BD%AE%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7" rel="nofollow">4.4.使用线程池内置的监控和调试工具</a></p> 
<p id="5.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B-toc" style="margin-left:0px;"><a href="#5.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" rel="nofollow">5.线程池的使用案例</a></p> 
<p id="5.1.%E5%BC%95%E5%85%A5jar%E5%8C%85-toc" style="margin-left:40px;"><a href="#5.1.%E5%BC%95%E5%85%A5jar%E5%8C%85" rel="nofollow">5.1.引入jar包</a></p> 
<p id="5.2.%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:40px;"><a href="#5.2.%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">5.2.初始化线程池</a></p> 
<p id="5.3.%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B-toc" style="margin-left:40px;"><a href="#5.3.%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B" rel="nofollow">5.3.测试案例</a></p> 
<p id="5.%E7%BB%93%E8%AE%BA-toc" style="margin-left:0px;"><a href="#5.%E7%BB%93%E8%AE%BA" rel="nofollow">5.结论</a></p> 
<p id="6.%E9%B8%A3%E8%B0%A2-toc" style="margin-left:0px;"><a href="#6.%E9%B8%A3%E8%B0%A2" rel="nofollow">6.鸣谢</a></p> 
<hr> 
<h2 id="1.%E6%A6%82%E8%BF%B0"><span style="color:#494949;">1.概述</span></h2> 
<p><span style="color:#494949;">线程池是一种常见的多线程编程技术，它允许我们在系统中使用一个固定数量的线程来执行任务，以免过多的线程拉低了系统的性能。在本文中，我们将探讨线程池的使用和一些最佳实践，以便在您的代码中获得更好的性能和可维护性。</span></p> 
<p><span style="color:#494949;">线程池是一种用于管理和调度多个线程的技术。线程池主要由三个部分组成：</span></p> 
<ul><li><span style="color:#494949;"><strong>线程管理器</strong>：负责启动、停止和管理线程池中的线程。</span></li><li><span style="color:#494949;"><strong>工作队列：</strong>用于存储要执行的任务。</span></li><li><span style="color:#494949;"><strong>线程池：</strong>包含线程管理器和工作队列。</span></li></ul> 
<p><span style="color:#494949;">线程池的工作原理如下：</span></p> 
<p><span style="color:#494949;">1）当需要执行一个任务时，线程池会从工作队列中获取一个任务。</span></p> 
<p><span style="color:#494949;">2）线程管理器会从线程池中获取一个可用的线程来执行任务。</span></p> 
<p><span style="color:#494949;">3）任务执行完成后，线程会返回到线程池中，等待下一个任务的分配。</span></p> 
<h2 id="2.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E5%8A%BF"><span style="color:#494949;">2.线程池的优势</span>​​​​​​​</h2> 
<h3 id="2.1.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F%EF%BC%9F">2.1.线程池为什么使用自定义方式？</h3> 
<p>因为 java 自带线程池都会有可能造成内存不足的问题。自定义线程池，根据服务器配置定制线程池核心线程、最大线程等，是最好的方式。</p> 
<h3 id="%E6%88%91%E5%B0%81%E8%A3%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F">2.2.封装的线程池工具类有什么好处？</h3> 
<ul><li>扩展性高</li><li>可注解形式实现执行</li><li>可根据业务需要注册不同的线程池，区分业务模块使用</li><li>可以执行无返回值线程任务，可以执行有返回值的线程任务</li></ul> 
<h2 id="3.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span style="color:#494949;"><strong>3.线程池的七大参数</strong></span></h2> 
<p><span style="color:#494949;">核心线程数、最大线程数、多余线程存活时间、时间单位、线程工厂、阻塞队列、拒绝策略</span></p> 
<p></p> 
<pre><code class="language-java"> /**
     * @param corePoolSize 核心线程数 -&gt; 线程池中保持的线程数量,即使它们是空闲的也不会销毁,
     *        除非设置了{@code allowCoreThreadTimeOut}核心线程超时时间
     * @param maximumPoolSize 最大线程数 -&gt; 线程池中允许接收的最大线程数量
     *        如果设定的数量比系统支持的线程数还要大时,会抛出OOM(OutOfMemoryError)异常
     * @param keepAliveTime 最大存活时间 -&gt; 当前线程数大于核心线程数的时候,
     *        其他多余的线程接收新任务之前的最大等待时间,超过时间没有新任务就会销毁.
     * @param unit {@code keepAliveTime}最大存活时间的单位.eg:TimeUnit.SECONDS
     * @param workQueue 工作队列 -&gt; 保存任务直到任务被提交到线程池的线程中执行.
     * @param threadFactory 线程工厂 -&gt; 当线程池需要创建线程得时候会从线程工厂获取新的实例.
     *        (自定义ThreadFactory可以跟踪线程池究竟何时创建了多少线程,也可以自定义线程的名称、
     *        组以及优先级等信息,甚至可以任性的将线程设置为守护线程.
     *        总之,自定义ThreadFactory可以更加自由的设置线程池中所有线程的状态。)
     * @param handler 当线程数量等于最大线程数并且工作队列已满的时候,再有新的任务添加进来就会进入这个handler,
     *        可以理解为设置拒绝策略（此处不清楚的可以看一下ThreadPoolExecutor中的execute方法的注释）
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
    }
</code></pre> 
<table border="1" cellpadding="1" cellspacing="1" style="width:669px;"><tbody><tr><td style="width:121px;"><strong><span style="color:#494949;">参数</span></strong></td><td style="width:520px;"><strong><span style="color:#494949;">说明</span></strong></td></tr><tr><td style="width:121px;"><span style="color:#494949;">corePoolSize</span></td><td style="width:520px;"><span style="color:#494949;">核心线程数量，线程池维护线程的最少数量</span></td></tr><tr><td style="width:121px;"><span style="color:#494949;">maximumPoolSize</span></td><td style="width:520px;"><span style="color:#494949;">线程池维护线程的最大数量</span></td></tr><tr><td style="width:121px;"><span style="color:#494949;">keepAliveTime</span></td><td style="width:520px;"><span style="color:#494949;">非核心线程的最长空闲时间，超过该时间的空闲线程会被销毁</span></td></tr><tr><td style="width:121px;"><span style="color:#494949;">unit</span></td><td style="width:520px;"><span style="color:#494949;">keepAliveTime的单位，有NANOSECONDS（纳秒）、MICROSECONDS（微秒）、MILLISECONDS（毫秒）、SECONDS（秒）</span></td></tr><tr><td style="width:121px;"><span style="color:#494949;">workQueue</span></td><td style="width:520px;"><span style="color:#494949;">任务缓冲队列（阻塞队列）</span></td></tr><tr><td style="width:121px;"><span style="color:#494949;">threadFactory</span></td><td style="width:520px;"><span style="color:#494949;">线程工厂，用于创建线程，一般用默认的即可</span></td></tr><tr><td style="width:121px;"><span style="color:#494949;">handler</span></td><td style="width:520px;"><span style="color:#494949;">线程池对拒绝任务的</span><strong>拒绝策略</strong></td></tr></tbody></table> 
<blockquote> 
 <p><strong>示例：</strong>创建一个核心线程数为5，最大线程数为10，任务队列容量为100的线程池</p> 
</blockquote> 
<p><img alt="" height="121" src="https://images2.imgbox.com/f3/2d/C87sZQBP_o.png" width="1200"></p> 
<p><strong><span style="color:#494949;">ThreadPoolExecutor的执行流程如下：</span></strong></p> 
<p>1、当线程池中新加入一个任务时，先判断核心线程数是否达到最大值，如果为false则创建一个核心线程执行任务，如果为true执行第二步；</p> 
<p>2、判断当前任务队列是否已满，如果为false，则将任务加入到队列中等待执行；如果为true，则判断当前线程数是否达到最大线程数；</p> 
<p>3、如果当前线程数没有达到最大线程数，则创建临时线程来执行任务，如果达到最大线程数，则执行拒绝策略。</p> 
<p><img alt="" height="637" src="https://images2.imgbox.com/ad/eb/ABgRZphL_o.png" width="1200"></p> 
<p><strong>拒绝策略</strong>指的是线程池中线程数量达到最大值，任务队列为满时，来了新任务的处理方式</p> 
<p> <span style="color:#494949;"><strong>ThreadPoolExecutor提供了四种拒绝策略：</strong></span></p> 
<blockquote> 
 <p><span style="color:#494949;"><strong>AbortPolicy:</strong>丢弃任务并抛出RejectedExecutionException异常（默认）</span></p> 
 <p><span style="color:#494949;"><strong>CallerRunsPolicy：</strong>由调用线程处理该任务（ 常用）</span></p> 
 <p><span style="color:#494949;"><strong>DiscardPolicy</strong>：丢弃任务，但是不抛出异常。</span></p> 
 <p><span style="color:#494949;"><strong>DiscardOldestPolicy：</strong>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</span></p> 
 <p><span style="color:#fe2c24;"><u>当然也可以自定义拒绝策略,只需要实现RejectedExecutionHandler接口即可</u></span></p> 
</blockquote> 
<h2 id="%C2%A03.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span style="color:#494949;">3.线程池的创建</span></h2> 
<p><span style="color:#494949;"><strong>线程池使用规范（阿里巴巴）</strong></span></p> 
<ol><li><span style="color:#494949;">创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</span></li><li><span style="color:#494949;">线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 自行创建线程，有可能造成系统创建大量同类线程而导致消耗完内存或者 “过度切换”的问题。</span></li><li><span style="color:#494949;">线程池不允许使用 Executors工厂类去创建（</span><span style="color:#fe2c24;"><strong>阿里的Java规范不推荐使用类<code>Executors</code>的静态方法创建线程池</strong></span><span style="color:#494949;">），而是通过new ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</span></li></ol> 
<p><span style="color:#494949;">线程池的创建⽅法总共有 7 种，但总体来说可分为 2 类：</span></p> 
<blockquote> 
 <p><span style="color:#494949;"><strong><em>        1. 通过 ThreadPoolExecutor 创建的线程池；</em></strong></span></p> 
 <p><span style="color:#494949;"><strong><em>        2. 通过 Executors 创建的线程池。</em></strong></span></p> 
</blockquote> 
<p><span style="color:#494949;">线程池的创建⽅式总共包含以下 7 种</span></p> 
<p><span style="color:#494949;">（其中 6 种是通过 Executors 创建的， 1 种是通过ThreadPoolExecutor 创建）</span></p> 
<blockquote> 
 <p><span style="color:#494949;">        1. Executors.newFixedThreadPool：创建⼀个固定⼤⼩的线程池，可控制并发的线程数，超出的线程会在队列中等待；</span></p> 
 <p><span style="color:#494949;">        2. Executors.newCachedThreadPool：创建⼀个可缓存的线程池，若线程数超过处理所需，缓存⼀段时间后会回收，若线程数不够，则新建线程；</span></p> 
 <p><span style="color:#494949;">        3. Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执⾏顺序；</span></p> 
 <p><span style="color:#494949;">        4. Executors.newScheduledThreadPool：创建⼀个可以执⾏延迟任务的线程池；</span></p> 
 <p><span style="color:#494949;">        5. Executors.newSingleThreadScheduledExecutor：创建⼀个单线程的可以执⾏延迟任务的线程池；</span></p> 
 <p></p> 
 <p><span style="color:#494949;">        6. Executors.newWorkStealingPool：创建⼀个抢占式执⾏的线程池（任务执⾏顺序不确定）【JDK1.8 添加】。</span></p> 
 <p><span style="color:#494949;">        7. ThreadPoolExecutor：最原始的创建线程池的⽅式，它包含了 7 个参数可供设置，后⾯会详细讲。</span></p> 
</blockquote> 
<h3 id="3.1.%20%E5%9B%BA%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span style="color:#494949;">3.1. 固定数量的线程池</span></h3> 
<p><a href="https://blog.csdn.net/m0_48273471/article/details/124145012?spm=1001.2014.3001.5501" title="线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客">线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客</a></p> 
<h3 id="3.2.%20%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span style="color:#494949;">3.2. 带缓存的线程池</span></h3> 
<p><a href="https://blog.csdn.net/m0_48273471/article/details/124145012?spm=1001.2014.3001.5501" title="​​​​​​线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客">​​​​​​线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客</a></p> 
<h3 id="3.3.%20%E6%89%A7%E2%BE%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span style="color:#494949;">3.3. 执⾏定时任务</span></h3> 
<p><a href="https://blog.csdn.net/m0_48273471/article/details/124145012?spm=1001.2014.3001.5501" title="线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客">线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客</a></p> 
<h3 id="3.4.%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8D%95%E7%BA%BF%E7%A8%8B"><span style="color:#494949;">3.4. 定时任务单线程</span></h3> 
<p><a href="https://blog.csdn.net/m0_48273471/article/details/124145012?spm=1001.2014.3001.5501" title="线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客">线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客</a></p> 
<h3 id="3.5.%20%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span style="color:#494949;">3.5. 单线程线程池</span></h3> 
<p><a href="https://blog.csdn.net/m0_48273471/article/details/124145012?spm=1001.2014.3001.5501" title="线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客">线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客</a></p> 
<blockquote> 
 <p><span style="color:#494949;">为什么不直接用线程？单线程的线程池又什么意义？</span></p> 
 <p><span style="color:#494949;">        1. 复用线程。</span></p> 
 <p><span style="color:#494949;">        2. 单线程的线程池提供了任务队列和拒绝策略（当任务队列满了之后（Integer.MAX_VALUE），新来的任务就会拒绝策略）</span></p> 
</blockquote> 
<h3 id="3.6.%20%E6%A0%B9%E6%8D%AE%E5%BD%93%E5%89%8DCPU%E2%BD%A3%E6%88%90%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span style="color:#494949;">3.6. 根据当前CPU⽣成线程池</span></h3> 
<p><a href="https://blog.csdn.net/m0_48273471/article/details/124145012?spm=1001.2014.3001.5501" title="线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客">线程池的使用（7种创建方法）_Youcan.的博客-CSDN博客</a></p> 
<h3 id="7.%C2%A0ThreadPoolExecutor%EF%BC%88%E7%9C%8B%E4%B8%8B%E4%B8%80%E7%AF%87%EF%BC%89"><span style="color:#fe2c24;">3.7. ThreadPoolExecutor★★★</span></h3> 
<p><span style="color:#494949;"><a href="https://blog.csdn.net/m0_48273471/article/details/124171220" title="线程池的使用（7种创建方法）">线程池的使用（7种创建方法）</a></span></p> 
<p><span style="color:#494949;"><strong>a. ThreadPoolExecutor 参数说明</strong></span></p> 
<p><span style="color:#494949;"><img alt="" height="452" src="https://images2.imgbox.com/23/be/EPthQtvO_o.png" width="1017"></span></p> 
<p><span style="color:#494949;"><strong>b. 线程池执⾏流程</strong></span></p> 
<p><span style="color:#494949;"><img alt="" height="462" src="https://images2.imgbox.com/65/b9/tjTmhkr0_o.png" width="519"></span></p> 
<h2 id="4.%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span style="color:#494949;">4.使用线程池的最佳实践</span></h2> 
<p><span style="color:#494949;">以下是使用线程池的一些最佳实践：</span></p> 
<h3 id="4.1.%E6%8B%A5%E6%9C%89%E9%80%82%E5%BD%93%E6%95%B0%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B"><span style="color:#494949;">4.1.拥有适当数量的线程</span></h3> 
<p>线程池中的线程数量应该根据应用程序的需求来确定。通常情况下，<span style="color:#fe2c24;"><strong>线程池中的线程数量应该等于处理器数量加一。</strong></span></p> 
<h3 id="4.2.%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97">4.2.使用合适的工作队列</h3> 
<p>线程池中的工作队列应该根据应用程序的需求来选择。如果需要执行大量的任务并且希望通过控制队列大小来限制系统的负载，则应该使用<strong>有界队列</strong>。如果希望系统能够保持高吞吐量并且不想限制队列大小，则应该使用<strong>无界队列</strong>。</p> 
<h3 id="4.3.%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">4.3.处理异常</h3> 
<p>线程池中的任务可能会抛出异常，因此我们应该在代码中处理这些异常。当任务抛出异常时，可以将异常记录到日志文件中或者通过线程池的回调函数进行处理。</p> 
<h3 id="4.4.%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E7%BD%AE%E7%9A%84%E7%9B%91%E6%8E%A7%E5%92%8C%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7">4.4.使用线程池内置的监控和调试工具</h3> 
<p>许多线程池都提供了监控和调试工具，这些工具可以帮助我们诊断线程池中的问题。例如，线程池可以提供有关线程数量、队列大小和任务执行速度的统计信息。</p> 
<h2 id="5.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B">5.线程池的使用案例</h2> 
<h3 id="5.1.%E5%BC%95%E5%85%A5jar%E5%8C%85">5.1.引入jar包</h3> 
<pre><code class="language-XML">&lt;!-- https://mvnrepository.com/artifact/concurrent/concurrent --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;concurrent&lt;/groupId&gt;
    &lt;artifactId&gt;concurrent&lt;/artifactId&gt;
    &lt;version&gt;1.3.4&lt;/version&gt;
&lt;/dependency&gt;
 &lt;dependency&gt;
     &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
     &lt;artifactId&gt;guava&lt;/artifactId&gt;
     &lt;version&gt;23.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<h3 id="5.2.%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%B1%A0">5.2.初始化线程池</h3> 
<pre><code class="language-java">
import org.springframework.context.annotation.Bean;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import org.springframework.stereotype.Component;
import java.util.concurrent.Executor;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * @ClassName: AsyncScheduledTaskConfig
 * @author: dyt
 * @since: 2023/06/16 下午 4:58
 */
@Component
public class AsyncScheduledTaskConfig {

    @Bean
    public Executor myAsync() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        //最大线程数
        executor.setMaxPoolSize(100);
        //核心线程数
        executor.setCorePoolSize(10);
        //任务队列的大小
        executor.setQueueCapacity(10);
        //线程前缀名
        executor.setThreadNamePrefix("dyt-thread-");
        //线程存活时间
        executor.setKeepAliveSeconds(30);

        /**
         * 拒绝处理策略
         * CallerRunsPolicy()：交由调用方线程运行，比如 main 线程。
         * AbortPolicy()：直接抛出异常。
         * DiscardPolicy()：直接丢弃。
         * DiscardOldestPolicy()：丢弃队列中最老的任务。
         */
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
        //线程初始化
        executor.initialize();
        return executor;
    }
}
</code></pre> 
<h3 id="5.3.%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B">5.3.测试案例</h3> 
<pre><code class="language-java">
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * @ClassName: ScheduleTask
 * @author: dyt
 * @since: 2023/06/19 下午 3:59
 */
@Component
@EnableAsync
public class ScheduleTask {

    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    @Async("myAsync")
    @Scheduled(fixedRate = 2000)
    public void testScheduleTask() {
        try{
            Thread.sleep(6000);
            System.out.println("SpringBoot的定时任务" + Thread.currentThread().getName() + sdf.format(new Date()));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

}

</code></pre> 
<p>运行</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/39/2a/1hsG0uFn_o.png" width="470"></p> 
<blockquote> 
 <p><strong>补充:</strong><br> 使用@Bean(“beanName”)定义线程池<br> 然后在@Async(“beanName”)中引用指定的线程池 </p> 
</blockquote> 
<h2 id="5.%E7%BB%93%E8%AE%BA">5.结论</h2> 
<p>线程池是一种重要的多线程编程技术，可以帮助我们提高代码的性能和可维护性。通过了解线程池的最佳实践和使用经验，我们可以更好地使用线程池来构建高效的、稳定的多线程应用程序。</p> 
<h2 id="6.%E9%B8%A3%E8%B0%A2">6.鸣谢</h2> 
<p>[1] <a href="https://blog.csdn.net/m0_48273471/article/details/124145012" title="https://blog.csdn.net/m0_48273471/article/details/124145012">https://blog.csdn.net/m0_48273471/article/details/124145012</a></p> 
<p>[2] <a href="https://blog.csdn.net/YQQAGH178/article/details/119828128" title="https://blog.csdn.net/YQQAGH178/article/details/119828128">https://blog.csdn.net/YQQAGH178/article/details/119828128</a></p> 
<p>[3] <a href="https://blog.csdn.net/qq_43681755/article/details/111057195" title="https://blog.csdn.net/qq_43681755/article/details/111057195">https://blog.csdn.net/qq_43681755/article/details/111057195</a></p> 
<p>[4] <a href="https://blog.csdn.net/weixin_48410604/article/details/119386267" title="https://blog.csdn.net/weixin_48410604/article/details/119386267">https://blog.csdn.net/weixin_48410604/article/details/119386267</a></p> 
<p>[5] <a href="https://blog.csdn.net/qq_42889280/article/details/123995250#t0" title="https://blog.csdn.net/qq_42889280/article/details/123995250#t0">https://blog.csdn.net/qq_42889280/article/details/123995250#t0</a></p> 
<p>[6] <a href="https://blog.csdn.net/qq_24983911/article/details/94722569" title="https://blog.csdn.net/qq_24983911/article/details/94722569">https://blog.csdn.net/qq_24983911/article/details/94722569</a></p> 
<p>[7] <a href="https://blog.csdn.net/qq_42889280/article/details/123995250#t0" title="https://blog.csdn.net/qq_42889280/article/details/123995250#t0">https://blog.csdn.net/qq_42889280/article/details/123995250#t0</a></p> 
<p>[8] <a href="https://blog.csdn.net/weixin_37686415/article/details/112549576" title="https://blog.csdn.net/weixin_37686415/article/details/112549576">https://blog.csdn.net/weixin_37686415/article/details/112549576</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7dd27510bdd93d3444a587c633ae17c8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">构建无锁的线程安全架构：掌握Java中ThreadLocal的原理灵活应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6bcf97f1ca1c6ea6f02d8a09620b7ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Wayland 和 X11 协议之间的主要区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>