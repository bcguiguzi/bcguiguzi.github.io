<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【ES6】let与const - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【ES6】let与const" />
<meta property="og:description" content="目录
let命令
作用域 无变量提升 不允许重复声明
暂时性死区
块级作用域 函数能否在块级作用域中声明 const命令
let命令 作用域 ES6 新增了let命令，用来声明变量。它的用法类似于var，但是作用域不同，let命令只在所在的代码块内有效。举个例子：
{ let a = 10 var b = 1 } console.log(a)//ReferenceError: a is not defined. console.log(b)//1 上面代码在代码块之中，分别用let和var声明了两个变量a和b。在代码块之外调用这两个变量，结果变量a报错，变量b返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。
所以for循环就很适合用let，而且for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。例：
for (let i = 0; i &lt; 3; i&#43;&#43;) { let i = &#39;abc&#39;; console.log(i); } // abc // abc // abc 上面代码正确运行，并且输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量）。
无变量提升 var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。
而let所声明的变量一定要在声明后使用，否则报错。 例：
console.log(foo); // 输出undefined var foo = 2; console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/237c87699d791fabb954333f027f085c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T11:13:14+08:00" />
<meta property="article:modified_time" content="2024-03-14T11:13:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【ES6】let与const</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="let%E5%91%BD%E4%BB%A4-toc" style="margin-left:0px;"><a href="#let%E5%91%BD%E4%BB%A4" rel="nofollow">let命令</a></p> 
<p id="%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0-toc" style="margin-left:40px;"><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0" rel="nofollow">作用域 </a></p> 
<p id="%E6%97%A0%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%C2%A0-toc" style="margin-left:40px;"><a href="#%E6%97%A0%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%C2%A0" rel="nofollow">无变量提升 </a></p> 
<p id="%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E-toc" style="margin-left:40px;"><a href="#%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E" rel="nofollow">不允许重复声明</a></p> 
<p id="%C2%A0%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA-toc" style="margin-left:40px;"><a href="#%C2%A0%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA" rel="nofollow"> 暂时性死区</a></p> 
<p id="%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0" rel="nofollow">块级作用域 </a></p> 
<p id="%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%9C%A8%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E5%A3%B0%E6%98%8E%C2%A0-toc" style="margin-left:40px;"><a href="#%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%9C%A8%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E5%A3%B0%E6%98%8E%C2%A0" rel="nofollow">函数能否在块级作用域中声明 </a></p> 
<p id="%C2%A0const%E5%91%BD%E4%BB%A4-toc" style="margin-left:0px;"><a href="#%C2%A0const%E5%91%BD%E4%BB%A4" rel="nofollow"> const命令</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2><span style="color:#0d0016;"><strong>let命令</strong></span></h2> 
<h3 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0"><span style="color:#7b7f82;">作用域 </span></h3> 
<p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是作用域不同，let命令只在所在的代码块内有效。举个例子：</p> 
<pre><code>{
  let a = 10
  var b = 1
}
console.log(a)//ReferenceError: a is not defined.
console.log(b)//1</code></pre> 
<p>上面代码在代码块之中，分别用<code>let</code>和<code>var</code>声明了两个变量a和b。在代码块之外调用这两个变量，结果变量a报错，变量b返回了正确的值。这表明，<code>let</code>声明的变量只在它所在的代码块有效。</p> 
<p>所以for循环就很适合用let，而且<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。例：</p> 
<pre><code>for (let i = 0; i &lt; 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc</code></pre> 
<p>上面代码正确运行，并且输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 <code>let</code> 重复声明同一个变量）。</p> 
<h3 id="%E6%97%A0%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%C2%A0"><span style="color:#7b7f82;">无变量提升 </span></h3> 
<p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。</p> 
<p>而let所声明的变量一定要在声明后使用，否则报错。 例：</p> 
<pre><code>console.log(foo); // 输出undefined
var foo = 2;

console.log(bar); // 报错ReferenceError
let bar = 2;</code></pre> 
<h3 id="%E4%B8%8D%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E5%A3%B0%E6%98%8E"><span style="color:#7b7f82;">不允许重复声明</span></h3> 
<p>简而言之就是不允许在相同作用域内，重复声明同一个变量。这个很好理解。例：</p> 
<pre><code>// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}</code></pre> 
<h3 id="%C2%A0%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA"><span style="color:#7b7f82;"> 暂时性死区</span></h3> 
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。也就是说，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。例：</p> 
<pre><code>if (true) {
  // TDZ开始
  tmp = 'bb'; // ReferenceError
  console.log(tmp); // ReferenceError
  let tmp; 
  // TDZ结束
  console.log(tmp); // undefined
  tmp = aa;
  console.log(tmp); // aa
}</code></pre> 
<p> 上面代码中，在<code>let</code>命令声明变量<code>tmp</code>之前，都属于变量<code>tmp</code>的“死区”。</p> 
<h2 id="%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%C2%A0">块级作用域 </h2> 
<p><code>let</code>为 JavaScript 新增了块级作用域，且ES6允许块级作用域的任意嵌套。 </p> 
<pre><code>{
  {
    let a = 'b'
    {
      let a = 'a'
      console.log(a) // a
    }
    console.log(a) // b
  } console.log(a) // 报错
}</code></pre> 
<p>上面代码有3层块级作用域，每一层都是一个单独的作用域，因此外面的作用域无法读取内部作用域的变量。但是内部作用域可以定义外部作用域变量。</p> 
<h3 id="%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%9C%A8%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E5%A3%B0%E6%98%8E%C2%A0"><span style="color:#7b7f82;">函数能否在块级作用域中声明 </span></h3> 
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，不会报错。</p> 
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</p> 
<h2 id="%C2%A0const%E5%91%BD%E4%BB%A4"> const命令</h2> 
<p>const命令有以下几个特点： </p> 
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p> 
<p><code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。 </p> 
<p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效。（参考上面let命令）</p> 
<p><code>const</code>命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 （参考上面let命令）</p> 
<p><code>const</code>声明的常量，也与<code>let</code>一样不可重复声明。 （参考上面let命令）</p> 
<p><span style="color:#fe2c24;">注：<code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</span> </p> 
<p>关于const命令就不举例说明了，建议自行尝试</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ea40acd51eb83ff3d31d381d9c40270/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">动态规划法解最长公共子序列问题(附带dp数组打印)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3072b1048bf9a1a614d3ac3037f94ae6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp微信小程序_拍照从相册选择</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>