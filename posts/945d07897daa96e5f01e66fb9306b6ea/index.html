<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面向初学者的指南：创建时间序列预测 (使用Python和R代码) - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面向初学者的指南：创建时间序列预测 (使用Python和R代码)" />
<meta property="og:description" content="概览： 学习创建时间预测序列的步骤额外关注 Dickey-Fuller test &amp; ARIMA(自回归移动平均) 模型从理论上学习这些概念，以及它们在python中的实现 介绍 时间序列(从现在开始称为TS)被认为是数据科学领域中不太为人所知的技能之一(就连我几天前也对它知之甚少)。我开始了一段新的学习旅程，学习解决时间序列问题的基本步骤，现在我和大家分享一下。这些绝对会帮助你在未来的项目中得到一个不错的模型！
在阅读本文之前，我强烈建议阅读关于R中的时间序列建模的完整教程，并学习自由时间序列预测课程。它侧重于基本概念，我将重点介绍如何使用这些概念来解决端到端问题，以及Python中的代码。R中有很多时间序列的资源，但是很少有Python的资源，所以我将在本文中使用Python。
我们的旅程将经过以下步骤:
是什么让时间序列如此特别?用 Pandas 记载并处理时间序列如何检验时间序列的平稳性?如何使时间序列平稳?预测时间序列 1. 是什么让时间序列如此特别? 顾名思义，TS是按固定的时间间隔收集的数据点的集合。这些分析是为了确定长期趋势，以便预测未来或进行其他形式的分析。但是TS和常规回归问题有什么不同呢?有两件事:
它与 时间 有关。所以线性回归模型的基本假设即观测值是独立的在这种情况下并不成立。随着增加或减少的趋势，大多数 TS 具有某种形式的 季节性(seasonality trends) 趋势，即特定于特定时间段的变化。例如，如果你看到一件羊毛夹克的销量随着时间的推移，你一定会发现冬季的销量更高。 由于 TS 的固有性质，分析它涉及到很多步骤。下面将详细讨论这些问题。让我们从用Python加载一个TS对象开始。我们将使用流行的航空乘客数据集，可以在这里下载。
2. 用 Pandas 加载并处理时间序列 Pandas有专门的库来处理TS对象，特别是 datatime64[ns] 类，它存储时间信息并允许我们快速执行某些操作。让我们从引入所需的库开始：
import pandas as pd import numpy as np import matplotlib.pylab as plt %matplotlib inline from matplotlib.pylab import rcParams rcParams[&#39;figure.figsize&#39;] = 15, 6 现在，我们可以加载数据集，看看列的一些初始行和数据类型:
data = pd.read_csv(&#39;AirPassengers.csv&#39;) print data.head(n = 10) # 默认 n为5 print &#39;\n Data Types:&#39; print data." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/945d07897daa96e5f01e66fb9306b6ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-22T16:44:59+08:00" />
<meta property="article:modified_time" content="2019-08-22T16:44:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面向初学者的指南：创建时间序列预测 (使用Python和R代码)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>概览：</h3> 
<ul><li>学习创建时间预测序列的步骤</li><li>额外关注 <strong>Dickey-Fuller test &amp; ARIMA(自回归移动平均)</strong> 模型</li><li>从理论上学习这些概念，以及它们在python中的实现</li></ul> 
<h3><a id="_5"></a>介绍</h3> 
<p><a href="http://courses.analyticsvidhya.com/courses/creating-time-series-forecast-using-python?utm_source=blog&amp;utm_medium=TimeSeriesForecastComprehensivearticle" rel="nofollow"><strong>时间序列</strong></a>(从现在开始称为TS)被认为是<a href="http://courses.analyticsvidhya.com/courses/introduction-to-data-science-2?utm_source=blog&amp;utm_medium=TimeSeriesForecastComprehensivearticle" rel="nofollow">数据科学领域</a>中不太为人所知的技能之一(就连我几天前也对它知之甚少)。我开始了一段新的学习旅程，学习解决时间序列问题的基本步骤，现在我和大家分享一下。这些绝对会帮助你在未来的项目中得到一个不错的模型！</p> 
<p>在阅读本文之前，我强烈建议阅读<a href="https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/" rel="nofollow">关于R中的时间序列建模的完整教程</a>，并学习<a href="http://courses.analyticsvidhya.com/courses/creating-time-series-forecast-using-python?utm_source=blog&amp;utm_medium=TimeSeriesForecastComprehensivearticle" rel="nofollow">自由时间序列预测课程</a>。它侧重于基本概念，我将重点介绍如何使用这些概念来解决端到端问题，以及<a href="http://courses.analyticsvidhya.com/courses/introduction-to-data-science-2?utm_source=blog&amp;utm_medium=TimeSeriesForecastComprehensivearticle" rel="nofollow">Python</a>中的代码。R中有很多时间序列的资源，但是很少有Python的资源，所以我将在本文中使用Python。</p> 
<p>我们的旅程将经过以下步骤:</p> 
<ol><li>是什么让时间序列如此特别?</li><li>用 <strong>Pandas</strong> 记载并处理时间序列</li><li>如何检验时间序列的平稳性?</li><li>如何使时间序列平稳?</li><li>预测时间序列</li></ol> 
<h4><a id="1__17"></a>1. 是什么让时间序列如此特别?</h4> 
<p>顾名思义，TS是按固定的时间间隔收集的数据点的集合。这些分析是为了确定长期趋势，以便预测未来或进行其他形式的分析。但是TS和常规回归问题有什么不同呢?有两件事:</p> 
<ol><li>它与 <strong>时间</strong> 有关。所以线性回归模型的基本假设即观测值是独立的在这种情况下并不成立。</li><li>随着增加或减少的趋势，大多数 TS 具有某种形式的 <strong>季节性(seasonality trends)</strong> 趋势，即特定于特定时间段的变化。例如，如果你看到一件羊毛夹克的销量随着时间的推移，你一定会发现冬季的销量更高。</li></ol> 
<p>由于 TS 的固有性质，分析它涉及到很多步骤。下面将详细讨论这些问题。让我们从用Python加载一个TS对象开始。我们将使用流行的航空乘客数据集，可以在这里<a href="https://www.analyticsvidhya.com/wp-content/uploads/2016/02/AirPassengers.csv" rel="nofollow">下载</a>。</p> 
<h4><a id="2__Pandas__24"></a>2. 用 <strong>Pandas</strong> 加载并处理时间序列</h4> 
<p>Pandas有专门的库来处理TS对象，特别是 <strong>datatime64[ns]</strong> 类，它存储时间信息并允许我们快速执行某些操作。让我们从引入所需的库开始：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pylab <span class="token keyword">as</span> plt
<span class="token operator">%</span>matplotlib inline
<span class="token keyword">from</span> matplotlib<span class="token punctuation">.</span>pylab <span class="token keyword">import</span> rcParams
rcParams<span class="token punctuation">[</span><span class="token string">'figure.figsize'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">6</span>
</code></pre> 
<p>现在，我们可以加载数据集，看看列的一些初始行和数据类型:</p> 
<pre><code class="prism language-python">data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'AirPassengers.csv'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span> data<span class="token punctuation">.</span>head<span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment"># 默认 n为5</span>
<span class="token keyword">print</span> <span class="token string">'\n Data Types:'</span>
<span class="token keyword">print</span> data<span class="token punctuation">.</span>dtypes
</code></pre> 
<p><img src="https://images2.imgbox.com/38/86/P0RgrPw7_o.png" alt="在这里插入图片描述"></p> 
<p>数据包含一个特定的月份和该月的乘客数量。但是由于数据类型是“object”和“int”，所以它仍然不是作为TS对象读取的。为了将数据读取为时间序列，我们必须将特殊参数传递给read_csv命令:</p> 
<pre><code class="prism language-python">dateparse <span class="token operator">=</span> <span class="token keyword">lambda</span> dates<span class="token punctuation">:</span> pd<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>strptime<span class="token punctuation">(</span>dates<span class="token punctuation">,</span> <span class="token string">'%Y-%m'</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">'AirPassengers.csv'</span><span class="token punctuation">,</span> parse_dates<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Month'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index_col<span class="token operator">=</span><span class="token string">'Month'</span><span class="token punctuation">,</span>date_parser<span class="token operator">=</span>dateparse<span class="token punctuation">)</span>
<span class="token keyword">print</span> data<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/1e/1b/Z2kh03Iw_o.png" alt="在这里插入图片描述"></p> 
<p>让我们一个一个的来理解这些参数:</p> 
<ol><li><strong>parse_dates</strong>:指定包含日期-时间信息的列。正如我们上面所说，列名是’ Month '。</li><li><strong>index_col</strong>:将panda用于TS数据背后的一个关键思想是，索引必须是描述日期-时间信息的变量。所以这个参数告诉熊猫使用“Month”列作为索引。</li><li><strong>date_parser</strong>:指定一个函数，该函数将输入字符串转换为datetime变量。默认情况下，熊猫读取的数据格式为“YYYY-MM-DD HH:MM:SS”。如果数据不是这种格式，则必须手动定义格式。类似于这里定义的dataparse函数可以用于此目的。</li></ol> 
<p>现在我们可以看到数据的索引是time对象，列是#passenger。我们可以用以下命令交叉检查索引的数据类型:</p> 
<pre><code class="prism language-python">data<span class="token punctuation">.</span>index
</code></pre> 
<p><img src="https://images2.imgbox.com/e8/9b/G7hXyjEp_o.png" alt="在这里插入图片描述"><br> 注意，<strong>dtype= 'datetime[ns] ’</strong> 确认它是一个datetime对象。作为个人偏好，我将把列转换成一个Series对象，以防止每次使用TS时引用列名。</p> 
<pre><code class="prism language-python">ts <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token string">'#Passengers'</span><span class="token punctuation">]</span> 
ts<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/16/b2/Z9QSymzP_o.png" alt="在这里插入图片描述"></p> 
<p>在进一步讨论之前，我将讨论一些用于TS数据的索引技术。让我们从选择Series对象中的一个特定值开始。这可以通过以下两种方式实现:</p> 
<pre><code class="prism language-python"><span class="token comment">#1. Specific the index as a string constant:</span>
ts<span class="token punctuation">[</span><span class="token string">'1949-01-01'</span><span class="token punctuation">]</span>

<span class="token comment">#2. Import the datetime library and use 'datetime' function:</span>
<span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime
ts<span class="token punctuation">[</span>datetime<span class="token punctuation">(</span><span class="token number">1949</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre> 
<p>两者都将返回值“112”，这也可以从以前的输出中确认。假设我们想要到1949年5月为止的所有数据。这可以通过两种方式实现:</p> 
<pre><code class="prism language-python"><span class="token comment">#1. Specify the entire range:</span>
ts<span class="token punctuation">[</span><span class="token string">'1949-01-01'</span><span class="token punctuation">:</span><span class="token string">'1949-05-01'</span><span class="token punctuation">]</span>

<span class="token comment">#2. Use ':' if one of the indices is at ends:</span>
ts<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token string">'1949-05-01'</span><span class="token punctuation">]</span>
</code></pre> 
<p>两者都会产生以下输出：<br> <img src="https://images2.imgbox.com/a9/b7/2n0j69bC_o.png" alt="在这里插入图片描述"></p> 
<p>这里有两件事需要注意:</p> 
<ol><li>与数字索引不同，这里 <strong>包含了结束索引</strong>。例如，如果我们将列表索引为[:5]，那么它将返回索引处的值-[0,1,2,3,4]。但是这里的输出中包含索引 ‘1949-05-01’。</li><li><strong>索引必须按照范围排序</strong>。如果随机打乱索引，这将不起作用。</li></ol> 
<p>考虑另一个需要1949年所有值的例子。可以这样做:</p> 
<pre><code class="prism language-python">ts<span class="token punctuation">[</span><span class="token string">'1949'</span><span class="token punctuation">]</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/52/26/zaCaUGFZ_o.png" alt="在这里插入图片描述"></p> 
<p>月份部分被省略了。同样，如果你把某一个月的所有日子都算上，则可以省略day部分。<br> 现在，我们继续分析TS。</p> 
<h4><a id="3_110"></a>3.如何检查时间序列的平稳性？</h4> 
<p>如果TS的 <strong>统计特性</strong> (如均值、方差) <strong>随时间保持不变</strong>，它就被称为平稳的。但是为什么它很重要呢?大多数的TS模型都假设TS是平稳的。直观地说，我们可以认为，如果TS随着时间的推移具有特定的行为，那么它很有可能在未来也会遵循同样的行为。与非平稳级数相比，平稳级数的相关理论更加成熟，易于实现。</p> 
<p>平稳性是用非常严格的准则来定义的。然而，在实际应用中，我们可以假设这个级数是平稳的，如果它在一段时间内具有恒定的统计特性。以下几点:</p> 
<ol><li>常数平均值</li><li>常数方差</li><li>不依赖于时间的自协方差。</li></ol> 
<p>我将跳过细节，因为它在<a href="https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/" rel="nofollow">本文</a>中定义得非常清楚。让我们继续测试平稳性的方法。首先也是最重要的是简单地绘制数据图并进行可视化分析。数据可以使用以下命令绘制:</p> 
<pre><code class="prism language-python">plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/24/5f/1WsosGAn_o.png" alt="在这里插入图片描述"></p> 
<p>很明显，数据中有一个总的 <strong>增长趋势</strong>，同时也有一些季节变化。然而，可能并不总是能够做出这样的视觉推断(我们稍后将看到这样的情况)。因此，更正式地说，我们可以使用以下方法检查平稳性:</p> 
<ol><li><strong>绘制滚动统计</strong>:我们可以绘制移动平均或移动方差，看看它是否随时间而变化。我说的移动平均/方差是指在任何时刻t，我们取去年的平均/方差，即过去12个月。但这更像是一种视觉技巧。</li><li><strong>Dickey-Fuller检验</strong>:这是检验平稳性的统计检验之一。这里零假设是 TS 是非平稳的。测试结果由 <strong>测试统计数据</strong> 和一些不同置信水平的<strong>临界值</strong>组成。如果“检验统计量”小于“临界值”，我们可以拒绝零假设，认为序列是平稳的。详情请参阅<a href="https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/" rel="nofollow">本文</a>。</li></ol> 
<p>在这一点上，这些概念听起来可能不是很直观。我建议阅读前传的文章(查阅相关资料进一步深入理解)。如果你对一些理论统计学感兴趣，你可以参考Brockwell和Davis的 <strong>时间序列导论和预测</strong>。这本书的统计数据有点多，但如果你有阅读字里行间的技巧，你就能理解其中的概念，并间接地接触到统计数据。</p> 
<p>回到检查平稳性，我们将经常使用滚动统计图和Dickey-Fuller测试结果，所以我定义了一个函数，它接受TS作为输入并为我们生成它们。请注意，我画的是标准差而不是方差来保持单位接近均值。</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> statsmodels<span class="token punctuation">.</span>tsa<span class="token punctuation">.</span>stattools <span class="token keyword">import</span> adfuller
<span class="token keyword">def</span> <span class="token function">test_stationarity</span><span class="token punctuation">(</span>timeseries<span class="token punctuation">)</span><span class="token punctuation">:</span>
    
    <span class="token comment">#Determing rolling statistics</span>
    rolmean <span class="token operator">=</span> pd<span class="token punctuation">.</span>rolling_mean<span class="token punctuation">(</span>timeseries<span class="token punctuation">,</span> window<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>
    rolstd <span class="token operator">=</span> pd<span class="token punctuation">.</span>rolling_std<span class="token punctuation">(</span>timeseries<span class="token punctuation">,</span> window<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>

    <span class="token comment">#Plot rolling statistics:</span>
    orig <span class="token operator">=</span> plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>timeseries<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'Original'</span><span class="token punctuation">)</span>
    mean <span class="token operator">=</span> plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>rolmean<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Rolling Mean'</span><span class="token punctuation">)</span>
    std <span class="token operator">=</span> plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>rolstd<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">,</span> label <span class="token operator">=</span> <span class="token string">'Rolling Std'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'best'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Rolling Mean &amp; Standard Deviation'</span><span class="token punctuation">)</span>
    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span>block<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
    
    <span class="token comment">#Perform Dickey-Fuller test:</span>
    <span class="token keyword">print</span> <span class="token string">'Results of Dickey-Fuller Test:'</span>
    dftest <span class="token operator">=</span> adfuller<span class="token punctuation">(</span>timeseries<span class="token punctuation">,</span> autolag<span class="token operator">=</span><span class="token string">'AIC'</span><span class="token punctuation">)</span>
    dfoutput <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>dftest<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Test Statistic'</span><span class="token punctuation">,</span><span class="token string">'p-value'</span><span class="token punctuation">,</span><span class="token string">'#Lags Used'</span><span class="token punctuation">,</span><span class="token string">'Number of Observations Used'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> key<span class="token punctuation">,</span>value <span class="token keyword">in</span> dftest<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        dfoutput<span class="token punctuation">[</span><span class="token string">'Critical Value (%s)'</span><span class="token operator">%</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token keyword">print</span> dfoutput
</code></pre> 
<p>代码非常简单。如果您在掌握代码方面遇到困难，请在评论中讨论代码。</p> 
<p>让我们运行输入序列:</p> 
<pre><code class="prism language-python">test_stationarity<span class="token punctuation">(</span>ts<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/51/33/GtYqMeg0_o.png" alt="在这里插入图片描述"><br> 虽然标准差的变化很小，但均值明显随时间增加，这不是一个平稳序列。此外，测试统计量远远超过临界值。注意，应该<strong>比较带符号的值</strong>，而不是绝对值。</p> 
<p>接下来，我们将讨论使TS趋于平稳性的技术。</p> 
<h4><a id="4__169"></a>4. 如何使时间序列平稳?</h4> 
<p>虽然在许多TS模型中采用了平稳性假设，但几乎没有一个实际的时间序列是平稳的。统计学家已经找到了使序列平稳的方法，我们现在就来讨论。实际上，让一个级数完全静止几乎是不可能的，但我们试着让它尽可能地接近。</p> 
<p>让我们来理解是什么使TS非平稳。TS不稳定的主要原因有两个:</p> 
<ol><li>随时间变化的趋势平均值。例如，在这个例子中，我们看到平均来说，乘客的数量随着时间在增长。</li><li>季节性——特定时间段的变化。由于工资的增加或节日的缘故，人们在特定的月份可能会有买车的倾向。</li></ol> 
<p>其基本原理是对序列中的趋势和季节性进行建模或估计，并将其从序列中去除，得到一个平稳序列。在此基础上，应用统计预测技术对该系列产品进行预测。最后一步是通过应用趋势和季节约束将预测值转换为原始规模。注意:我将讨论一些方法。有些可能在这种情况下工作得很好，而另一些则不然。但我们的想法是掌握所有的方法，而不是只关注手头的问题。让我们从趋势部分开始。</p> 
<h5><a id="_178"></a>估计和消除趋势</h5> 
<p>减少趋势的首要技巧之一是转变。例如，在这种情况下，我们可以清楚地看到，有一个显著的积极趋势。所以我们可以用变换来惩罚更大的值而不是更小的值。可以取对数，平方根，立方根，等等。为了简单起见，我们在这里做一个对数变换:</p> 
<pre><code class="prism language-python">ts_log <span class="token operator">=</span> np<span class="token punctuation">.</span>log<span class="token punctuation">(</span>ts<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts_log<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/71/84/6vVc1rTF_o.png" alt="在这里插入图片描述"><br> 在这个更简单的例子中，很容易看到数据中的正向趋势。但在有噪声的情况下，它不是很直观。因此，我们可以使用一些技术来估计或建模这种趋势，然后将其从系列中删除。有很多方法可以做到这一点，其中最常用的有:</p> 
<ol><li>汇总—取一段时间内的平均值，如月/周平均值</li><li>平滑——取滚动平均线</li><li>多项式拟合-拟合回归模型</li></ol> 
<p>我将在这里讨论平滑，您也应该尝试其他技术，这可能会解决其他问题。平滑是指采用滚动估计，即考虑过去的几个例子。有很多种方法，但我将在这里讨论其中的两种。</p> 
<h6><a id="_193"></a>移动平均数</h6> 
<p>在这种方法中，我们根据时间序列的频率取“k”连续值的平均值。这里我们可以取过去一年的平均值，也就是最近12个值。panda定义了用于确定滚动统计数据的特定函数。</p> 
<pre><code class="prism language-python">moving_avg <span class="token operator">=</span> pd<span class="token punctuation">.</span>rolling_mean<span class="token punctuation">(</span>ts_log<span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts_log<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>moving_avg<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/97/55/RQqxQFUD_o.png" alt="在这里插入图片描述"><br> 红线表示滚动平均值。从原级数中减去这个。注意，由于我们取最后12个值的平均值，所以前11个值没有定义滚动平均值。这可以观察到:</p> 
<pre><code class="prism language-python">ts_log_moving_avg_diff <span class="token operator">=</span> ts_log <span class="token operator">-</span> moving_avg
ts_log_moving_avg_diff<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/57/3b/ZJMqz5dK_o.png" alt="在这里插入图片描述"><br> 注意前11位是Nan。让我们删除这些NaN值，并检查这些图以测试平稳性</p> 
<pre><code class="prism language-python">ts_log_moving_avg_diff<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
test_stationarity<span class="token punctuation">(</span>ts_log_moving_avg_diff<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/51/ff/IO5dxNib_o.png" alt="在这里插入图片描述"><br> 这个级数看起来好多了。滚动值似乎略有变化，但没有特定的趋势。同时，检验统计量 <strong>小于5%的临界值</strong> 所以我们可以有95%的信心说这是一个平稳序列。</p> 
<p>然而，这种特殊方法的缺点是必须严格定义时间段。在这种情况下，我们可以取年平均水平，但在预测股票价格等复杂情况下，很难得出一个数字。因此，我们采用“加权移动平均”，即赋予较近期值较高的权重。可以有许多技术来分配权重。一种流行的方法是 <strong>指数加权移动平均法</strong>，它将权重分配给所有具有衰减因子的先前值。在这里找到详细信息。这可以在panda中实现为:</p> 
<pre><code class="prism language-python">expwighted_avg <span class="token operator">=</span> pd<span class="token punctuation">.</span>ewma<span class="token punctuation">(</span>ts_log<span class="token punctuation">,</span> halflife<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts_log<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>expwighted_avg<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a5/88/OeYZm0Vk_o.png" alt="在这里插入图片描述"><br> 注意，这里使用参数“半衰期”来定义指数衰减的数量。这只是一个假设，主要取决于业务领域。其他参数，如跨度和质心也可以用来定义衰减，这是讨论在上面共享的链接。现在，让我们把这个从级数中移除，并检查平稳性:</p> 
<pre><code class="prism language-python">ts_log_ewma_diff <span class="token operator">=</span> ts_log <span class="token operator">-</span> expwighted_avg
test_stationarity<span class="token punctuation">(</span>ts_log_ewma_diff<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/10/cc/Z8rcT8Cy_o.png" alt="在这里插入图片描述"><br> 这个TS在平均值和标准差上的变化更小。同时，测试统计量 <strong>小于1%的临界值</strong>，优于前一种情况。注意，在这种情况下，不会缺少值，因为从一开始所有的值都是给定权重的。所以即使没有之前的值，它也能工作。</p> 
<h6><a id="_235"></a>消除趋势和季节性</h6> 
<p>前面讨论的简单趋势减少技术并不是在所有情况下都有效，特别是那些具有高季节性的技术。让我们讨论两种消除趋势和季节性的方法:</p> 
<ol><li>差分-在特定的时间间隔内进行差分</li><li>分解——对趋势和季节性进行建模，并将它们从模型中移除。</li></ol> 
<p>区别：<br> 差分处理趋势和季节性的最常见方法之一。在这种方法中，我们取某一时刻的观测值与前一时刻的观测值之差。这在提高平稳性方面很有效。一阶差分可以在 Pandas 中运行:</p> 
<pre><code class="prism language-python">ts_log_diff <span class="token operator">=</span> ts_log <span class="token operator">-</span> ts_log<span class="token punctuation">.</span>shift<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a6/aa/UnYcXun1_o.png" alt="在这里插入图片描述"><br> 这似乎大大降低了趋势。让我们用我们的图来验证:</p> 
<pre><code class="prism language-python">ts_log_diff<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
test_stationarity<span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/a4/56/zwQiTKAt_o.png" alt="在这里插入图片描述"><br> 我们可以看到，平均值和std随时间的变化有很小的变化。此外，Dickey-Fuller检验统计量<strong>小于10%的临界值</strong>，因此TS是稳定的，有90%的置信度。我们也可以采取二阶或三阶的差异，这可能在某些应用中得到更好的结果。我把它们留给你去尝试。</p> 
<p><strong>分解</strong>：<br> 在这种方法中，趋势和季节性分别建模，并返回系列的其余部分。我将跳过统计数据，来看一下结果:</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> statsmodels<span class="token punctuation">.</span>tsa<span class="token punctuation">.</span>seasonal <span class="token keyword">import</span> seasonal_decompose
decomposition <span class="token operator">=</span> seasonal_decompose<span class="token punctuation">(</span>ts_log<span class="token punctuation">)</span>

trend <span class="token operator">=</span> decomposition<span class="token punctuation">.</span>trend
seasonal <span class="token operator">=</span> decomposition<span class="token punctuation">.</span>seasonal
residual <span class="token operator">=</span> decomposition<span class="token punctuation">.</span>resid

plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">411</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts_log<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Original'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'best'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">412</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>trend<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Trend'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'best'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">413</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>seasonal<span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'Seasonality'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'best'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">414</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>residual<span class="token punctuation">,</span> label<span class="token operator">=</span><span class="token string">'Residuals'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">'best'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f2/e9/rh8vfEOw_o.png" alt="在这里插入图片描述"><br> 这里我们可以看到趋势，季节性从数据中分离出来我们可以对残差进行建模。检验残差的平稳性:</p> 
<pre><code class="prism language-python">ts_log_decompose <span class="token operator">=</span> residual
ts_log_decompose<span class="token punctuation">.</span>dropna<span class="token punctuation">(</span>inplace<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
test_stationarity<span class="token punctuation">(</span>ts_log_decompose<span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/8f/eb/x0a1odvG_o.png" alt="在这里插入图片描述"><br> Dickey-Fuller检验统计量显著<strong>低于1%的临界值</strong>。所以这个TS非常接近于静止。您还可以尝试高级分解技术，这些技术可以生成更好的结果。另外，您应该注意，在这种情况下，将残差转换为未来数据的原始值并不十分直观。</p> 
<h4><a id="5_293"></a>5.预测时间序列</h4> 
<p>我们看到了不同的技术它们都能很好地使 TS 静止。让我们在差分后的TS上做模型，因为这是一种非常流行的技术。此外，在这种情况下，在预测残差中添加噪声和季节性因素也相对容易。执行趋势和季节估计技术后，可以出现两种情况:</p> 
<ol><li>一个严格平稳的序列，各值之间不依赖。这是一个简单的例子，我们可以把残差建模为白噪声。但这种情况非常罕见。</li><li>值之间具有显著相关性的序列。在这种情况下，我们需要使用一些统计模型，如ARIMA来预测数据。</li></ol> 
<p>让我给你简单介绍一下ARIMA。我不会详细介绍技术细节，但是如果您希望更有效地应用这些概念，您应该详细了解这些概念。ARIMA代表自回归综合移动平均线。平稳时间序列的ARIMA预测只不过是一个线性(类似于线性回归)方程。预测因子依赖于ARIMA模型的参数(p,d,q):AR(自回归)项数§:</p> 
<ol><li>AR项只是因变量的滞后。例如，如果p是5，那么x(t)的预测器将是x(t-1)……x(t-5)。</li><li>MA(移动平均)项数(q): MA项是预测方程中的滞后预测误差。例如，如果q是5,x(t)的预测因子将是e(t-1)…e(t-5)其中e(i)是第i个时刻的移动平均线与实际值之间的差值。</li><li>差异数量(d):这些是非季节性差异的数量，即在本例中我们取一阶差异。所以我们要么传递这个变量，让d=0，要么传递原始变量，让d=1。两者将产生相同的结果。</li></ol> 
<p>这里的一个重要问题是如何确定“p”和“q”的值。我们用两个图来确定这些数字。让我们先讨论一下。</p> 
<ol><li>自相关函数(ACF):它是一种度量TS与自身滞后版本之间相关性的方法。例如，在滞后5时，ACF会将瞬时“t1”…“t2”的序列与瞬时“t1-5”…“t2”的序列进行比较(t1-5和t2是端点)。</li><li>部分自相关函数(PACF):该函数测量TS与自身滞后版本之间的相关性，但在消除了已经由中间比较解释的变化之后。在滞后5时，它将检查相关性，但删除已经由滞后1到滞后4解释的影响。</li></ol> 
<p>经差分后的TS的ACF和PACF图可以绘制为:</p> 
<pre><code class="prism language-python"><span class="token comment">#ACF and PACF plots:</span>
<span class="token keyword">from</span> statsmodels<span class="token punctuation">.</span>tsa<span class="token punctuation">.</span>stattools <span class="token keyword">import</span> acf<span class="token punctuation">,</span> pacf

lag_acf <span class="token operator">=</span> acf<span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">,</span> nlags<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
lag_pacf <span class="token operator">=</span> pacf<span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">,</span> nlags<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">'ols'</span><span class="token punctuation">)</span>

<span class="token comment">#Plot ACF: </span>
plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">121</span><span class="token punctuation">)</span> 
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>lag_acf<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>axhline<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>axhline<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1.96</span><span class="token operator">/</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>axhline<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">1.96</span><span class="token operator">/</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Autocorrelation Function'</span><span class="token punctuation">)</span>

<span class="token comment">#Plot PACF:</span>
plt<span class="token punctuation">.</span>subplot<span class="token punctuation">(</span><span class="token number">122</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>lag_pacf<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>axhline<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>axhline<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1.96</span><span class="token operator">/</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>axhline<span class="token punctuation">(</span>y<span class="token operator">=</span><span class="token number">1.96</span><span class="token operator">/</span>np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>linestyle<span class="token operator">=</span><span class="token string">'--'</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'gray'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Partial Autocorrelation Function'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>tight_layout<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2d/58/i8yLerLE_o.png" alt="在这里插入图片描述"><br> 在这个图中，0两边的虚线是置信区间。这些可以用来确定“p”和“q”的值如下:</p> 
<ol><li>p - PACF图第一次越过上置信区间时的滞后值。如果你仔细观察，这里p=2。</li><li>q - ACF图第一次越过上置信区间时的滞后值。如果你仔细观察，这里q=2。</li></ol> 
<p>现在，让我们制作3种不同的ARIMA模型，考虑单独的和组合的效果。我还将为每个人打印RSS。请注意，这里的RSS用于残差值，而不是实际的系列。</p> 
<p>我们需要先加载ARIMA模型:</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> statsmodels<span class="token punctuation">.</span>tsa<span class="token punctuation">.</span>arima_model <span class="token keyword">import</span> ARIMA
</code></pre> 
<p>可以使用ARIMA的order参数指定p、d、q值，该参数接受一个元组(p、d、q)。让我们对这3种情况建模:</p> 
<p><strong>AR MODEL</strong></p> 
<pre><code class="prism language-python">model <span class="token operator">=</span> ARIMA<span class="token punctuation">(</span>ts_log<span class="token punctuation">,</span> order<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
results_AR <span class="token operator">=</span> model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>disp<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>results_AR<span class="token punctuation">.</span>fittedvalues<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'RSS: %.4f'</span><span class="token operator">%</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>results_AR<span class="token punctuation">.</span>fittedvalues<span class="token operator">-</span>ts_log_diff<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/e8/dc/Esec0o97_o.png" alt="在这里插入图片描述"></p> 
<p><strong>MA Model</strong></p> 
<pre><code class="prism language-python">model <span class="token operator">=</span> ARIMA<span class="token punctuation">(</span>ts_log<span class="token punctuation">,</span> order<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
results_MA <span class="token operator">=</span> model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>disp<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>results_MA<span class="token punctuation">.</span>fittedvalues<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'RSS: %.4f'</span><span class="token operator">%</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>results_MA<span class="token punctuation">.</span>fittedvalues<span class="token operator">-</span>ts_log_diff<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ca/a3/Ej5CKzUC_o.png" alt="在这里插入图片描述"></p> 
<p><strong>Combined Model</strong></p> 
<pre><code class="prism language-python">model <span class="token operator">=</span> ARIMA<span class="token punctuation">(</span>ts_log<span class="token punctuation">,</span> order<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  
results_ARIMA <span class="token operator">=</span> model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>disp<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts_log_diff<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>results_ARIMA<span class="token punctuation">.</span>fittedvalues<span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'RSS: %.4f'</span><span class="token operator">%</span> <span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>results_ARIMA<span class="token punctuation">.</span>fittedvalues<span class="token operator">-</span>ts_log_diff<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/2b/f5/v1bRhp7I_o.png" alt="在这里插入图片描述"></p> 
<p>在这里，我们可以看到AR和MA模型拥有几乎相同的RSS，但是合并起来要好得多。现在，我们只剩下最后一步，即将这些值恢复到原来的比例。</p> 
<h5><a id="_385"></a>回到原来的比例</h5> 
<p>由于组合模型给出了最佳结果，因此我们可以将其缩放回原始值并查看其在那里的表现。第一步是将预测结果存储为单独的系列并观察它。</p> 
<pre><code class="prism language-python">predictions_ARIMA_diff <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>results_ARIMA<span class="token punctuation">.</span>fittedvalues<span class="token punctuation">,</span> copy<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">print</span> predictions_ARIMA_diff<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/92/cf/7h9rkOyZ_o.png" alt="在这里插入图片描述"><br> 您可以使用以前的输出快速进行一些回溯计算，以检查这些计算是否正确。接下来我们要把它们加到底数上。为此，让我们创建一个以所有值为基数的系列，并将差异添加到其中。可以这样做:</p> 
<pre><code class="prism language-python">predictions_ARIMA_log <span class="token operator">=</span> pd<span class="token punctuation">.</span>Series<span class="token punctuation">(</span>ts_log<span class="token punctuation">.</span>ix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> index<span class="token operator">=</span>ts_log<span class="token punctuation">.</span>index<span class="token punctuation">)</span>
predictions_ARIMA_log <span class="token operator">=</span> predictions_ARIMA_log<span class="token punctuation">.</span>add<span class="token punctuation">(</span>predictions_ARIMA_diff_cumsum<span class="token punctuation">,</span>fill_value<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
predictions_ARIMA_log<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/41/fc/RObTVpIw_o.png" alt="在这里插入图片描述"><br> 这里第一个元素是基数本身，并且从那里累加的值。最后一步是取指数并与原始系列进行比较。</p> 
<pre><code class="prism language-python">predictions_ARIMA <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>predictions_ARIMA_log<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>ts<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>predictions_ARIMA<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'RMSE: %.4f'</span><span class="token operator">%</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>predictions_ARIMA<span class="token operator">-</span>ts<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token builtin">len</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/c8/50/uWvJympj_o.png" alt="在这里插入图片描述"></p> 
<p>这些都是用Python编写的。让我们学习如何在R中实现时间序列预测。<br> 第一步:读取数据并计算基本总结<br> 输出</p> 
<pre><code class="prism language-r">class(tsdata)
"ts"
&gt; #Observations of the time series data
&gt; tsdata
Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
1949 112 118 132 129 121 135 148 148 136 119 104 118
1950 115 126 141 135 125 149 170 170 158 133 114 140
1951 145 150 178 163 172 178 199 199 184 162 146 166
1952 171 180 193 181 183 218 230 242 209 191 172 194
1953 196 196 236 235 229 243 264 272 237 211 180 201
1954 204 188 235 227 234 264 302 293 259 229 203 229
1955 242 233 267 269 270 315 364 347 312 274 237 278
1956 284 277 317 313 318 374 413 405 355 306 271 306
1957 315 301 356 348 355 422 465 467 404 347 305 336
1958 340 318 362 348 363 435 491 505 404 359 310 337
1959 360 342 406 396 420 472 548 559 463 407 362 405
1960 417 391 419 461 472 535 622 606 508 461 390 432
&gt; #Summary of the data and missi

tsdata was converted to a data frame
Data Frame Summary 
tsdata 
Dimensions: 144 x 1 
Duplicates: 26

----------------------------------------------------------------------------------------------------
No Variable Stats / Values Freqs (% of Valid) Graph Valid Missing 
---- ---------- -------------------------- ----------------------- --------------------- -------- --
1 tsdata Mean (sd) : 280.3 (120) 118 distinct values . : . 144 0 
[ts] min &lt; med &lt; max: Start: 1949-01 : : . . : (100%) (0%) 
104 &lt; 265.5 &lt; 622 End : 1960-12 : : : : : 
IQR (CV) : 180.5 (0.4) : : : : : : : 
: : : : : : : : . . 
----------------------------------------------------------------------------------------------------
</code></pre> 
<p>步骤2:检查时间序列数据的循环，绘制原始数据<br> 输出</p> 
<pre><code class="prism language-r">cycle(tsdata)
Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
1949 1 2 3 4 5 6 7 8 9 10 11 12
1950 1 2 3 4 5 6 7 8 9 10 11 12
1951 1 2 3 4 5 6 7 8 9 10 11 12
1952 1 2 3 4 5 6 7 8 9 10 11 12
1953 1 2 3 4 5 6 7 8 9 10 11 12
1954 1 2 3 4 5 6 7 8 9 10 11 12
1955 1 2 3 4 5 6 7 8 9 10 11 12
1956 1 2 3 4 5 6 7 8 9 10 11 12
1957 1 2 3 4 5 6 7 8 9 10 11 12
1958 1 2 3 4 5 6 7 8 9 10 11 12
1959 1 2 3 4 5 6 7 8 9 10 11 12
1960 1 2 3 4 5 6 7 8 9 10 11 12
</code></pre> 
<p><img src="https://images2.imgbox.com/5a/4a/5tcqib1R_o.png" alt="在这里插入图片描述"><br> 步骤3:分解时间序列数据<br> 输出<br> <img src="https://images2.imgbox.com/65/d9/J3Md79iT_o.png" alt="在这里插入图片描述"><br> 步骤4:测试数据的平稳性</p> 
<pre><code class="prism language-r">Augmented Dickey-Fuller Test

data: tsdata
Dickey-Fuller = -7.3186, Lag order = 5, p-value = 0.01
alternative hypothesis: stationary
</code></pre> 
<p>p值为0.01，即&lt;0.05，因此我们拒绝零假设，因此时间序列是平稳的。</p> 
<p><img src="https://images2.imgbox.com/53/a9/7IodNpOe_o.png" alt="在这里插入图片描述"><br> 最大滞后时间为1个月或12个月，与12个月周期呈正相关。<br> 自动绘制排除NA值的7:138随机时间序列观测值<br> <img src="https://images2.imgbox.com/be/1c/bK0JOqgt_o.png" alt="在这里插入图片描述"><br> 第五步:模型拟合<br> <img src="https://images2.imgbox.com/03/de/l1LPrDPK_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-r">Series: tsdata 
ARIMA(2,1,1)(0,1,0)[12]

Coefficients:
ar1 ar2 ma1
0.5960 0.2143 -0.9819
s.e. 0.0888 0.0880 0.0292

sigma^2 estimated as 132.3: log likelihood=-504.92
AIC=1017.85 AICc=1018.17 BIC=1029.35
</code></pre> 
<p><img src="https://images2.imgbox.com/2d/62/3n7zOOea_o.png" alt="在这里插入图片描述"><br> 第六步:预测<br> <img src="https://images2.imgbox.com/03/f6/9fjb5abP_o.png" alt="在这里插入图片描述"><br> 最后给出了原尺度下的预测结果。我认为这不是一个很好的预测但是你的想法是对的?现在，我让您进一步完善方法并做出更好的解决方案。</p> 
<p>一些推荐的工程：<br> 现在，是时候大胆尝试一下，实际操作一些其他真实的数据集了。那么你准备好接受挑战了吗?测试这篇文章中讨论的技术，并通过以下实践问题加速时间序列分析的学习:</p> 
<table><thead><tr><th><img src="https://images2.imgbox.com/37/6e/Tm293xux_o.png" alt="在这里插入图片描述"></th><th><a href="https://datahack.analyticsvidhya.com/contest/genpact-machine-learning-hackathon-1/?utm_source=time-series-forecasting-codes-python&amp;utm_medium=blog" rel="nofollow">Practice Problem: Food Demand Forecasting Challenge</a> 对某外卖公司的餐饮需求进行预测</th></tr></thead><tbody><tr><td><img src="https://images2.imgbox.com/ba/b5/SiWq6aN4_o.png" alt="在这里插入图片描述"></td><td><a href="https://datahack.analyticsvidhya.com/contest/practice-problem-time-series-2/?utm_source=time-series-forecasting-codes-python&amp;utm_medium=blog" rel="nofollow">Practice Problem: Time Series Analyses</a> 预测城市轨道交通的客运量</td></tr></tbody></table> 
<h3><a id="_517"></a>写在最后</h3> 
<p>通过本文，我试图为您提供一种解决时间序列问题的标准方法。这是最好的时机，因为今天是我们的 <strong>Mini DataHack</strong>，它将挑战您解决一个类似的问题。我们讨论了平稳性的概念，如何用一个更接近平稳性的时间序列最后预测残差。这是一个漫长的旅程，我跳过了一些统计细节，我鼓励你使用建议的材料参考。如果不想复制粘贴，可以从我的<a href="https://github.com/aarshayj/Analytics_Vidhya/tree/master/Articles">GitHub</a>存储库下载包含所有代码的iPython笔记本。</p> 
<p>我希望本文能够帮助您在今天实现一个好的first solution。所有最好的人!</p> 
<p>你喜欢这篇文章吗?今天的黑客马拉松有什么用?有什么事困扰着你，你想进一步讨论吗?请随时发表评论，我将非常乐意讨论。</p> 
<p>Note – The discussions of this article are going on at AV’s Discuss portal. <a href="https://discuss.analyticsvidhya.com/t/discussions-for-article-a-comprehensive-beginners-guide-to-create-a-time-series-forecast-with-codes-in-python/65783?u=jalfaizy" rel="nofollow">Join here</a>!</p> 
<p>翻译自：<a href="https://www.analyticsvidhya.com/blog/2016/02/time-series-forecasting-codes-python/" rel="nofollow">A comprehensive beginner’s guide to create a Time Series Forecast (with Codes in Python and R)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/02ca750678048cb7748eeef118f26d40/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vc运行库合集 官方正式版 v2019.07.20</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/660c0c978cd6cc628dd73fa679e6ecec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">drop_duplicates去重详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>