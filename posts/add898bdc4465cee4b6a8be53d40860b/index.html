<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP的三次握手和4次挥手 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP的三次握手和4次挥手" />
<meta property="og:description" content="一、首先讲一下TCP的由来 最开始，人们考虑到将网络信息的呼唤与回应进行规范，达成一种公认的协议，就好像没有交通规则的路口设定交通规则。
人们设计出完美的OSI协议，这个协议包含七个层次由下到上分别是：
物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。
大家都觉得很完美但是现实总是会打破理想，十分现实。
人们发现在使用过程中，没有必要这么繁琐，很多层次也分的不必太清晰可以合并，于是在实践过程中，人们逐渐演变出更实用的TCP/IP协议。
二、三次握手连接，四次挥手断开 画图解释吧更形象
三、总结 3次握手的过程是双方都在准备资源，4次挥手的过程是让之前准备的资源释放。
这个时候可能会产生疑问为什么连接是三次挥手就要四次？
这是因为套接字是全双工的（同时收发数据无影响），所以关的时候要收发都关掉。
不知道有没有同学会跟我一样产生一个疑惑，为什么要客户端先调用close而不是服务器先调用close？
我经过查阅资料学习我们先来追溯一下收发信息原理的源头：TCP为了保证数据的可靠性，一般接收方在收到一个数据“请求断开连接”之后才会给发出方回应一个“收到，这边准备妥当不再接收”信息，但如果一直不回应，发送方就会一直等待回应，为了避免陷入这样一个循环，引入了超时时间机制，谁先调用close，发完消息之后等待一定时间，如果没有收到回应，发送方就再发送一次。但这个时候又出现一个问题，如果接收方给的回应迟了，超出了等待期限范畴，一边已经回应“收到，已准备妥当不再接收”，另一边因为等待时间内没有等到这条消息，会继续发送“请求断开连接”-等待（对方已经关闭接收了）-发-等待-发-等待…这就又陷入了一个循环，为了解决这个问题，我们引入了延时机制，也就是接收方接到断开请求，回复“收到，这边准备妥当不再接收”之后，让它等待约2MSL（MSL就是一个数据包在网络上传输的时间），确定收不到发送方再次发来的断开请求，再真正执行关闭接收操作。现实这段过程大概耗时为两分钟左右，在这段时间内接收方是不被允许释放资源的，这也就意味着这段时间内它所占用的端口不可以被其他程序所调用（程序虽然关了但是端口仍被占用，不利于资源的最大化利用）。这个时候，我们再来想，如果是服务器先调用close,这就意味着服务器先发出断开连接请求，也就意味着它要保留两分钟左右的资源的同时占用这个端口，但我们知道，服务端要绑定固定的端口，客户端不用呀，所以如果是客户端先调用close,它在等待保留资源的时候，操作系统再执行其他操作，分配资源时，端口是自由的，可以紧接着继续分配，达到对资源的最大化利用，刚刚好。所以客户端先调用close而不是服务器先调用close。
上码 import socket def service_client(new_socket): &#34;&#34;&#34;为这个客户端返回数据&#34;&#34;&#34; #1.接收浏览器发送过来的请求，即HTTP发送来的请求 #GET /HTTP/2.0 #... request=new_socket.recv(1024)#一般来说应该空间是够了 print(request) #2.返回HTTP格式的数据给浏览器 #2.1准备发送给浏览器的数据--head就是HTML那些 response=&#34;http/2.0 200 OK\r\n&#34;#浏览器不能解析换行符/n，必须使用/r/n的方式 response&#43;=&#34;\r\n&#34;#不可或缺的换行符，代表着body即将到来 #2.2准备一些--body部分内容，准备给浏览器送去 #response&#43;=&#34;&lt;h1&gt;xixizi&lt;/h1&gt;&#34; response&#43;=&#34;xixizi&#34; new_socket.send(response.encode(&#34;utf-8&#34;)) #关闭套接字 new_socket.close() def main(): &#34;用来完成整体的控制&#34; #1.创建套接字 tcp_server_socket=socket.socket(socket.AF_INET,socket.SOCK_STREAM) #2.绑定 tcp_server_socket.bind((&#34;&#34;,65534)) #3.变为监听套接字 tcp_server_socket.listen(128) while True: #4.等待新客户端的链接 new_socket,client_addr=tcp_server_socket.accept() #5.为这个客户端服务 service_client(new_socket) #关闭监听套接字 tcp_server_socket.close() if __name__==&#34;__main__&#34;: main() 最近很努力在找实习，把尘封已久的知识重新翻出来再温习温习，不问前程，但行脚下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/add898bdc4465cee4b6a8be53d40860b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-15T19:02:32+08:00" />
<meta property="article:modified_time" content="2024-03-15T19:02:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP的三次握手和4次挥手</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="TCP_5"></a>一、首先讲一下TCP的由来</h2> 
<p>最开始，人们考虑到将网络信息的呼唤与回应进行规范，达成一种公认的协议，就好像没有交通规则的路口设定交通规则。<br> 人们设计出完美的OSI协议，这个协议包含七个层次由下到上分别是：<br> 物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。<br> 大家都觉得很完美但是现实总是会打破理想，十分现实。<br> 人们发现在使用过程中，没有必要这么繁琐，很多层次也分的不必太清晰可以合并，于是在实践过程中，人们逐渐演变出更实用的TCP/IP协议。<br> <img src="https://images2.imgbox.com/26/cb/x5wMIIod_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="_14"></a>二、三次握手连接，四次挥手断开</h2> 
<p>画图解释吧更形象<br> <img src="https://images2.imgbox.com/70/58/r9ZQTHHu_o.jpg" alt="在这里插入图片描述"></p> 
<h2><a id="_17"></a>三、总结</h2> 
<p><strong>3次握手的过程是双方都在准备资源，4次挥手的过程是让之前准备的资源释放。</strong><br> <strong>这个时候可能会产生疑问为什么连接是三次挥手就要四次？</strong><br> 这是因为套接字是全双工的（同时收发数据无影响），所以关的时候要收发都关掉。<br> <strong>不知道有没有同学会跟我一样产生一个疑惑，为什么要客户端先调用close而不是服务器先调用close？</strong><br> 我经过查阅资料学习我们先来追溯一下收发信息原理的源头：TCP为了保证数据的可靠性，一般接收方在收到一个数据“请求断开连接”之后才会给发出方回应一个“收到，这边准备妥当不再接收”信息，但如果一直不回应，发送方就会一直等待回应，为了避免陷入这样一个循环，引入了超时时间机制，谁先调用close，发完消息之后等待一定时间，如果没有收到回应，发送方就再发送一次。但这个时候又出现一个问题，如果接收方给的回应迟了，超出了等待期限范畴，一边已经回应“收到，已准备妥当不再接收”，另一边因为等待时间内没有等到这条消息，会继续发送“请求断开连接”-等待（对方已经关闭接收了）-发-等待-发-等待…这就又陷入了一个循环，为了解决这个问题，我们引入了延时机制，也就是接收方接到断开请求，回复“收到，这边准备妥当不再接收”之后，让它等待约2MSL（MSL就是一个数据包在网络上传输的时间），确定收不到发送方再次发来的断开请求，再真正执行关闭接收操作。现实这段过程大概耗时为两分钟左右，在这段时间内接收方是不被允许释放资源的，这也就意味着这段时间内它所占用的端口不可以被其他程序所调用（程序虽然关了但是端口仍被占用，不利于资源的最大化利用）。这个时候，我们再来想，如果是服务器先调用close,这就意味着服务器先发出断开连接请求，也就意味着它要保留两分钟左右的资源的同时占用这个端口，但我们知道，服务端要绑定固定的端口，客户端不用呀，所以如果是客户端先调用close,它在等待保留资源的时候，操作系统再执行其他操作，分配资源时，端口是自由的，可以紧接着继续分配，达到对资源的最大化利用，刚刚好。所以客户端先调用close而不是服务器先调用close。</p> 
<h2><a id="_23"></a>上码</h2> 
<pre><code class="prism language-python"><span class="token keyword">import</span> socket

<span class="token keyword">def</span> <span class="token function">service_client</span><span class="token punctuation">(</span>new_socket<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""为这个客户端返回数据"""</span>

    <span class="token comment">#1.接收浏览器发送过来的请求，即HTTP发送来的请求</span>
    <span class="token comment">#GET /HTTP/2.0</span>
    <span class="token comment">#...</span>
    request<span class="token operator">=</span>new_socket<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment">#一般来说应该空间是够了</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    <span class="token comment">#2.返回HTTP格式的数据给浏览器</span>
    <span class="token comment">#2.1准备发送给浏览器的数据--head就是HTML那些</span>
    response<span class="token operator">=</span><span class="token string">"http/2.0 200 OK\r\n"</span><span class="token comment">#浏览器不能解析换行符/n，必须使用/r/n的方式</span>
    response<span class="token operator">+=</span><span class="token string">"\r\n"</span><span class="token comment">#不可或缺的换行符，代表着body即将到来</span>
    <span class="token comment">#2.2准备一些--body部分内容，准备给浏览器送去</span>
    <span class="token comment">#response+="&lt;h1&gt;xixizi&lt;/h1&gt;"</span>
    response<span class="token operator">+=</span><span class="token string">"xixizi"</span>
    new_socket<span class="token punctuation">.</span>send<span class="token punctuation">(</span>response<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">#关闭套接字</span>
    new_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">"用来完成整体的控制"</span>
    <span class="token comment">#1.创建套接字</span>
    tcp_server_socket<span class="token operator">=</span>socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span>socket<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span>socket<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">)</span>
    <span class="token comment">#2.绑定</span>
    tcp_server_socket<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token number">65534</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">#3.变为监听套接字</span>
    tcp_server_socket<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token comment">#4.等待新客户端的链接</span>
        new_socket<span class="token punctuation">,</span>client_addr<span class="token operator">=</span>tcp_server_socket<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">#5.为这个客户端服务</span>
        service_client<span class="token punctuation">(</span>new_socket<span class="token punctuation">)</span>
    <span class="token comment">#关闭监听套接字</span>
    tcp_server_socket<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">"__main__"</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/65/e2/SVKrcBAb_o.png" alt="在这里插入图片描述"><br> 最近很努力在找实习，把尘封已久的知识重新翻出来再温习温习，不问前程，但行脚下</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/98b8240a2a5a5cbd5995d7a5f58d6f47/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">nicetool--替代hutool和fastjson的工具库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ba3ed088ab047f289ba93b5c6684cc6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">http模块 之 如何创建一个http服务？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>