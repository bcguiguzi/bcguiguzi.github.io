<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VC&#43;&#43; 网络编程 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VC&#43;&#43; 网络编程" />
<meta property="og:description" content="看到一篇比较不错的总结：(53条消息) 孙鑫vc笔记——网络编程部分_至浊至愚-CSDN博客在此基础上，进行补充。
1. 七层模型
1） 对等层之间不允许直接通信，如两个通信实体的传输层不允许直接通信；
2） 上层使用下层提供的服务，如传输层使用网络层的服务；
3） 下层向上层提供服务；
4） 对等层之间有一个虚拟连接，看起来是直接通信，实际是通过下层来通信，最终的通信是通过物理层的线路完成。
2. OSI各层协议
1） 应用层。远程登录协议Telnet、文件传输协议FTP、超文本传输协议HTTP、域名服务DNS、简单邮件传输协议SMTP（发送邮件）、邮局协议POP3（收取邮件）。
2） 传输层。TCP，面向连接的可靠连接，三次握手建立连接，保证传输到对方；UDP，无连接不可靠，直接向某个IP发送数据，不保证收到，优点是实时性较高。对完整性要求不高的应用使用UDP，如视频点播；对完整性要求较高的应用要使用TCP，如下载安装程序，缺少少量数据就无法正常安装。
3） 网络层。IP、ICMP、IGMP
3．数据封装
一台计算机要发送数据到另一台计算机，数据首先必须打包，打包的过程成为封装。封装就是在数据前面加上特定的协议头部。
1） 在OSI模型中，对等层协议之间交换的信息单元成为协议数据单元（PDU）。
2） 下层把上层的PDU作为本层的数据封装，然后加入本层的头部（有的还要加入尾部，例如数据链路层），头部包含数据传输所需的控制信息，例如将信件包上信封。
3） 某一层只能识别对等层封装的“信封”，而对于信封内部的数据只是提交给上层，本层不作处理。
3. TCP/IP模型
1） 网络接口层对应物理层、数据链路层；
2） 网络层对应网络层；
3） 传输层对应传输层；
4） 应用层对应会话层、表示层和应用层。
4．端口
传输层提供应用程序通信的能力，为了标识通信实体中进行通信的应用程序，TCP/IP协议提出了端口的概念。
1） 应用程序通过系统调用与某端口建立连接后，传输层传给该端口的数据都被相应的应用程序接收，应用程序发给传输层的数据都通过该端口输出。
2） 端口号与协议有关，TCP和UDP各自的端口号相互独立。基于TCP和UDP的不同的网络程序可以有相同的端口号。
3） 端口号范围是0-65535，1024以下的端口号保留给预定的服务，如http使用80端口。因此我们编写网络程序时要使用1024以上的端口号。
5．Socket
由伯克利大学推出的一种应用程序访问通信协议的系统调用，最先在Unix上，之后引进到Windows。
套接字存在于通信区域中，通信区域又叫地址族，将通过套接字通信的进程的共有特效综合在一起，套接字通常只与同一地址族的套接字交换数据（也可跨区域通信，需要执行某种转换进程）。Windows Sockets只支持一个通信区域：网际域（AF_INET），这个域被使用网际协议族通信的进程使用。
6.网络字节顺序
有的计算机起始地址存放地位字节（地位先存），有的计算机在起始地址存放高位字节（高位先存），一般的PC都是低位先存，TCP/IP协议使用16位整数和32位整数的高位先存格式。通信时要采用网络字节顺序
7.套接字类型
1）流式套接字（SOCK_STREAM）。基于TCP实现，提供面向连接、可靠的数据传输服务，数据无差错、无重复的发送，且按发送顺序发送接收；
2）数据报式套接字（SOCK_DGRAM）。基于UDP实现，提供无连接服务，数据包以独立包形式发送，不保证无措，数据可能丢失，接收顺序混乱；
3）原始套接字（SOCK_RAW）。
8．基于TCP（面向连接）的socket编程
服务器端程序：
1） 创建套接字（socket）；
2） 将套接字绑定到一个本地地址和端口（bind）；
3） 将套接字设为监听模式，准备接收客户请求（listen）；
4） 当请求到来时，接受请求，返回一个新的对应于此次连接的套接字（accept）；
5） 用返回的套接字和客户端进行通信（send/recv）；
6） 返回，等待另一客户请求；" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/773307cd8566e58e4d01c963ba6d37d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-03T17:50:19+08:00" />
<meta property="article:modified_time" content="2021-06-03T17:50:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VC&#43;&#43; 网络编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>看到一篇比较不错的总结：<a href="https://blog.csdn.net/u011421608/article/details/43578549">(53条消息) 孙鑫vc笔记——网络编程部分_至浊至愚-CSDN博客</a>在此基础上，进行补充。</p> 
<p> </p> 
<p>1.      七层模型<br> 1）  对等层之间不允许直接通信，如两个通信实体的传输层不允许直接通信；</p> 
<p>2）  上层使用下层提供的服务，如传输层使用网络层的服务；</p> 
<p>3）  下层向上层提供服务；</p> 
<p>4）  对等层之间有一个虚拟连接，看起来是直接通信，实际是通过下层来通信，最终的通信是通过物理层的线路完成。</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/8e/b5/6xpaSChV_o.png" width="576"></p> 
<p>2.      OSI各层协议</p> 
<p>1）  应用层。远程登录协议Telnet、文件传输协议FTP、超文本传输协议HTTP、域名服务DNS、简单邮件传输协议SMTP（发送邮件）、邮局协议POP3（收取邮件）。</p> 
<p>2）  传输层。TCP，面向连接的可靠连接，三次握手建立连接，保证传输到对方；UDP，无连接不可靠，直接向某个IP发送数据，不保证收到，优点是实时性较高。对完整性要求不高的应用使用UDP，如视频点播；对完整性要求较高的应用要使用TCP，如下载安装程序，缺少少量数据就无法正常安装。</p> 
<p>3）  网络层。IP、ICMP、IGMP</p> 
<p>3．数据封装</p> 
<p>         一台计算机要发送数据到另一台计算机，数据首先必须打包，打包的过程成为封装。封装就是在数据前面加上特定的协议头部。</p> 
<p>1）  在OSI模型中，对等层协议之间交换的信息单元成为协议数据单元（PDU）。</p> 
<p>2）  下层把上层的PDU作为本层的数据封装，然后加入本层的头部（有的还要加入尾部，例如数据链路层），头部包含数据传输所需的控制信息，例如将信件包上信封。</p> 
<p>3）  某一层只能识别对等层封装的“信封”，而对于信封内部的数据只是提交给上层，本层不作处理。</p> 
<p>3.      TCP/IP模型</p> 
<p>1）  网络接口层对应物理层、数据链路层；</p> 
<p>2）  网络层对应网络层；</p> 
<p>3）  传输层对应传输层；</p> 
<p>4）  应用层对应会话层、表示层和应用层。</p> 
<p><img alt="" height="391" src="https://images2.imgbox.com/ea/b3/LeQSXqoY_o.png" width="586"></p> 
<p>4．端口</p> 
<p>传输层提供应用程序通信的能力，为了标识通信实体中进行通信的应用程序，TCP/IP协议提出了端口的概念。</p> 
<p>1）  应用程序通过系统调用与某端口建立连接后，传输层传给该端口的数据都被相应的应用程序接收，应用程序发给传输层的数据都通过该端口输出。</p> 
<p>2）  端口号与协议有关，TCP和UDP各自的端口号相互独立。基于TCP和UDP的不同的网络程序可以有相同的端口号。</p> 
<p>3）  端口号范围是0-65535，1024以下的端口号保留给预定的服务，如http使用80端口。因此我们编写网络程序时要使用1024以上的端口号。</p> 
<p>5．Socket</p> 
<p>         由伯克利大学推出的一种应用程序访问通信协议的系统调用，最先在Unix上，之后引进到Windows。</p> 
<p>套接字存在于通信区域中，通信区域又叫地址族，将通过套接字通信的进程的共有特效综合在一起，套接字通常只与同一地址族的套接字交换数据（也可跨区域通信，需要执行某种转换进程）。Windows Sockets只支持一个通信区域：网际域（AF_INET），这个域被使用网际协议族通信的进程使用。</p> 
<p>6.网络字节顺序</p> 
<p>         有的计算机起始地址存放地位字节（地位先存），有的计算机在起始地址存放高位字节（高位先存），一般的PC都是低位先存，TCP/IP协议使用16位整数和32位整数的高位先存格式。通信时要采用网络字节顺序</p> 
<p>7.套接字类型</p> 
<p>1）流式套接字（SOCK_STREAM）。基于TCP实现，提供面向连接、可靠的数据传输服务，数据无差错、无重复的发送，且按发送顺序发送接收；</p> 
<p>2）数据报式套接字（SOCK_DGRAM）。基于UDP实现，提供无连接服务，数据包以独立包形式发送，不保证无措，数据可能丢失，接收顺序混乱；</p> 
<p>3）原始套接字（SOCK_RAW）。</p> 
<p>8．基于TCP（面向连接）的socket编程</p> 
<p>服务器端程序：</p> 
<p>1）  创建套接字（socket）；</p> 
<p>2）  将套接字绑定到一个本地地址和端口（bind）；</p> 
<p>3）  将套接字设为监听模式，准备接收客户请求（listen）；</p> 
<p>4）  当请求到来时，接受请求，返回一个新的对应于此次连接的套接字（accept）；</p> 
<p>5）  用返回的套接字和客户端进行通信（send/recv）；</p> 
<p>6）  返回，等待另一客户请求；</p> 
<p>7）  关闭套接字。</p> 
<p>客户端程序：</p> 
<p>1）  创建套接字（socket）；</p> 
<p>2）  向服务器发出连接请求（connect）；</p> 
<p>3）  和服务器端通信（send/recv）；</p> 
<p>4）  关闭套接字。</p> 
<p>注意客户端不需要bind函数，因为当服务器端接受客户连接请求时保存了客户端的IP地址及端口信息，可利用返回套接字与客户端进行通信。</p> 
<p>9．基于UDP（面向无连接）的socket编程</p> 
<p>服务器端（接收端）程序：</p> 
<p>1）  创建套接字（socket）；</p> 
<p>2）  将套接字绑定到一个本地地址和端口（bind）；</p> 
<p>3）  等待接收数据（recvfrom）；</p> 
<p>4）  关闭套接字。</p> 
<p>客户端（发送端）程序：</p> 
<p>1）  创建套接字（socket）；</p> 
<p>2）  向服务器发送数据（sendto）；</p> 
<p>3）  关闭套接字。</p> 
<p>对于面向无连接的socket，服务器与客户机的概念不强，因此可叫作接收端和发送端，接收端即先启动的一端。</p> 
<p>10．编写网络程序</p> 
<p>11．WSAStartup函数</p> 
<p>1）加载套接字库WSAStartup，加载套接字库、确定套接字库版本；</p> 
<p>2）int WSAStartup(WORDwVersionRequested,LPWSADATA lpWSAData)，第一个参数指定准备加载的Winsock库版本，高位字节指定副版本，低位字节指定主版本，可用WORD wVersionRequested = MAKEWORD(x,y)获得，x是高位字节，y是低位字节；第二个参数是指向WSADATA结构的指针，WSAStartup加载的库版本信息填在这个结构中。返回值为0则成功。</p> 
<p>3) LOBYTE,HIBYTE分别取低字节与高字节</p> 
<p>4）每一个WSAStartup的成功调用（成功加载WinSock.DLL后），在最后都对应一个WSACleanUp调用，以便释放为该应用程序分配的资源；</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/c1/26/DX2Qp3wb_o.png" width="373"></p> 
<p>12．Socket函数</p> 
<p>1）SOCKET socket(intaf,int type,int protocol)；第一个参数指定地址族，只能是AF_INET或PF_INET（Windows中无区别）；第二个参数指定socket类型，1.1版本的Socket只支持流式套接字和数据报套接字；第三个参数指定与特定地址族相关协议，一般为0，自动选择合适协议。</p> 
<p>2）调用成功返回SOCKET数据类型的套接字描述符，调用失败返回INVALID_SOCKET（invalid中文是无效的意思），错误信息可通过WSAGetLastError函数返回</p> 
<p><img alt="" height="26" src="https://images2.imgbox.com/cd/48/HL7HgfWc_o.png" width="488"></p> 
<p>13．bind函数</p> 
<p>1）int bind(SOCKETs,const struct sockaddr FAR *name,int namelen)；第一个参数指定要绑定的套接字，第二个参数指定本地地址信息，这个结构可能随着网络协议不同而不同，因此要使用第三个参数来指定该地址的长度。Sockaddr结构体第一个成员指定地址族（AF_INEF）。TCP/IP中，用sockaddr_in结构代替sockaddr，以方便填写地址信息，在给参数时要使用强制转换。</p> 
<p>2）sockaddr_in结构体有4个参数，第一个是地址族，第二个第三个分别是端口和IP，必须为网络字节顺序，第四个作填充字段，以使sockaddr_in和sockaddr结构长度一样。</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/77/aa/pZ5yKFOD_o.png" width="428"></p> 
<p><img alt="" height="119" src="https://images2.imgbox.com/93/d8/DhCzwtpt_o.png" width="660"></p> 
<p>3）将IP地址指定为INADDR_ANY，允许套接字向本机的任何IP发送接收数据。</p> 
<p>4）htons将短整型转换为网络字节顺序，htonl将整型或long型转换为网络字节顺序，一般IP转换用htonl，端口转换用htons。</p> 
<p>5）返回值为0则绑定成功，失败则返回SOCKET_ERROR，错误信息可用WSAGetLastError返回。</p> 
<p><img alt="" height="147" src="https://images2.imgbox.com/94/52/RSQhMPbO_o.png" width="562"></p> 
<p>14．Listen函数</p> 
<p>两个参数，第一个参数即为监听的套接字，第二个参数为等 待连接队列的最大长度，比如此值为2时，如果有3个连接请求到来时，前两个会被放到连接队列。</p> 
<p><img alt="" height="27" src="https://images2.imgbox.com/a4/8a/n4WhTeAy_o.png" width="441"></p> 
<p>15．Accept函数</p> 
<p>1）放在一个死循环while(1)中,使之持续运行。</p> 
<p>2）三个参数，第一个参数是套接字，第二个参数保存客户端的地址信息，第三个参数保存客户端地址长度，后两个值都是要返回的，先定义参数再传入，注意接收客户端地址长度的变量必须赋初值，否则函数调用会失败。</p> 
<p>3）调用成功会返回一个<strong>新的socke用于通信</strong>，<span style="color:#956fe7;">原socket继续监听</span>。</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/19/34/HYDvwnVr_o.png" width="567"></p> 
<p>16．send函数</p> 
<p>四个参数，第一个为套接字，第二个参数包含了将被传送的数据，第三个参数是数据长度，第四个参数不深究，一般设为0。<br><img alt="" height="104" src="https://images2.imgbox.com/5e/db/Wt488xpN_o.png" width="343"></p> 
<p>17. recv函数</p> 
<p>不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。该函数的:</p> 
<p>第一个参数指定<strong>接收端套接字描述符</strong>；</p> 
<p>第二个参数指明一个<strong>缓冲区</strong>，该缓冲区用来<strong>存放recv函数接收到的数据</strong>；</p> 
<p>第三个参数指明<strong>buf的长度</strong>；</p> 
<p>第四个参数<strong>一般置0</strong>。</p> 
<p><img alt="" height="44" src="https://images2.imgbox.com/6b/0a/NCC88ZT4_o.png" width="228"></p> 
<p>18. 关闭套接字函数closesocket（关闭用于通信的套接字sockConn）</p> 
<p><img alt="" height="21" src="https://images2.imgbox.com/01/ee/nBEdcfXn_o.png" width="372"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/787bc853eb485af2a4c2f2682efe84e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多模态机器翻译 | (1) 简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f3789123e8cfb626d29fd684aa99555/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java面试题：讲一讲进程，线程，协程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>