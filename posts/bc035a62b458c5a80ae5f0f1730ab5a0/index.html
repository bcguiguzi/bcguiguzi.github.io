<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;笔试题汇总（5） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;笔试题汇总（5）" />
<meta property="og:description" content="//上海贝尔的面试题43 分即可进入复试 一、请填写BOOL , float, 指针变量与“零值”比较的if 语句。（10 分） 提示：这里“零值”可以是0, 0.0 , FALSE 或者“空指针”。例如int 变量n 与“零值”比较的if 语句 为： if ( n == 0 ) if ( n != 0 ) 以此类推。 请写出BOOL flag 与“零值”比较的if 语句： 请写出float x 与“零值”比较的if 语句： 请写出char *p 与“零值”比较的if 语句： 二、以下为Windows NT 下的32 位C&#43;&#43;程序，请计算sizeof 的值（10 分） char str[] = “Hello” ; char *p = str ; int n = 10; 请计算 sizeof (str ) = sizeof ( p ) = sizeof ( n ) =void Func ( char str[100]) { 请计算 sizeof( str ) = } void *p = malloc( 100 ); 请计算 sizeof ( p ) = 、简答题（25 分） 1、头文件中的ifndef/define/endif 干什么用？ 2、＃i nclude 和＃i nclude “filename." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/bc035a62b458c5a80ae5f0f1730ab5a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-04-10T00:30:00+08:00" />
<meta property="article:modified_time" content="2011-04-10T00:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;笔试题汇总（5）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>//上海贝尔的面试题43 分即可进入复试 <br>一、请填写BOOL , float, 指针变量与“零值”比较的if 语句。（10 分） <br>提示：这里“零值”可以是0, 0.0 , FALSE 或者“空指针”。例如int 变量n 与“零值”比较的if 语句 <br>为： <br>if ( n == 0 ) <br>if ( n != 0 ) <br>以此类推。 <br>请写出BOOL flag 与“零值”比较的if 语句： <br>请写出float x 与“零值”比较的if 语句： <br>请写出char *p 与“零值”比较的if 语句： <br>二、以下为Windows NT 下的32 位C++程序，请计算sizeof 的值（10 分） <br>char str[] = “Hello” ; <br>char *p = str ; <br>int n = 10; <br>请计算 <br>sizeof (str ) = <br>sizeof ( p ) = <br>sizeof ( n ) =void Func ( char str[100]) <br>{ <br>请计算 <br>sizeof( str ) = <br>} <br>void *p = malloc( 100 ); <br>请计算 <br>sizeof ( p ) = <br>、简答题（25 分） <br>1、头文件中的ifndef/define/endif 干什么用？ <br>2、＃i nclude 和＃i nclude “filename.h” 有什么区别？ <br>3、const 有什么用途？（请至少说明两种） <br>4、在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”声明？ <br>5、请简述以下两个for 循环的优缺点 <br>// 第一个 <br>for (i=0; i{ <br>if (condition) <br>DoSomething(); <br>else <br>DoOtherthing(); <br>}// 第二个 <br>if (condition) <br>{ <br>for (i=0; i DoSomething(); <br>} <br>else <br>{ <br>for (i=0; i DoOtherthing(); <br>优点：N 次中，每次都要对condition 进行判断 <br>缺点： 优点：一次判断condition 后，对something 或Otherthing 执行N 次 <br>缺点： <br>四、有关内存的思考题（20 分） <br>void GetMemory(char *p) <br>{ <br>p = (char *)malloc(100); <br>} <br>void Test(void) <br>{ <br>char *str = NULL; <br>GetMemory(str); <br>strcpy(str, "hello world"); <br>printf(str); <br>} <br>请问运行Test 函数会有什么样的结果？ <br>char *GetMemory(void) <br>{ <br>char p[] = "hello world"; <br>return p; <br>} <br>void Test(void) <br>{ <br>char *str = NULL; <br>str = GetMemory(); <br>printf(str); <br>} <br>请问运行Test 函数会有什么样的结果？ <br>Void GetMemory2(char **p, int num) <br>{ <br>*p = (char *)malloc(num); <br>} <br>void Test(void) <br>{ <br>char *str = NULL; <br>GetMemory(&amp;str, 100); <br>strcpy(str, "hello"); <br>printf(str); <br>} <br>请问运行Test 函数会有什么样的结果？ <br>void Test(void) <br>{ <br>char *str = (char *) malloc(100); <br>strcpy(str, “hello”); <br>free(str); <br>if(str != NULL) <br>{ <br>strcpy(str, “world”); <br>printf(str); <br>} <br>} <br>请问运行Test 函数会有什么样的结果？ <br>五、编写strcpy 函数（10 分） <br>已知strcpy 函数的原型是 <br>char *strcpy(char *strDest, const char *strSrc); <br>其中strDest 是目的字符串，strSrc 是源字符串。 <br>（1）不调用C++/C 的字符串库函数，请编写函数strcpy <br>char *strcpy(char *strDest,const char *strSrc){ <br>int n=0; <br>while(strSrc[n]!=NULL){ <br>n++: <br>} <br>*srtDest=new char[n]; <br>for(int i=0;i strDest=strSrc[i]; <br>i++; <br>} <br>return *strDest; <br>} <br>（2）strcpy 能把strSrc 的内容复制到strDest，为什么还要char * 类型的返回值？ <br>因为该函数的还可以把复制的字符串首地址指针给其他的指针，而且这种需要也是有用的。 <br>六、编写类String 的构造函数、析构函数和赋值函数（25 分） <br>已知类String 的原型为： <br>class String <br>{ <br>public: <br>String(const char *str = NULL);// 普通构造函数 <br>String(const String &amp;other); // 拷贝构造函数 <br>~ String(void); // 析构函数 <br>String &amp; operate =(const String &amp;other);// 赋值函数 <br>private: <br>char *m_data;// 用于保存字符串 <br>}; <br>请编写String 的上述4 个函数。 <br>//答案一并给出 <br>一、请填写BOOL , float, 指针变量与“零值”比较的if 语句。（10 分） <br>请写出BOOL flag 与“零值”比较的if 语句。（3 分） <br>标准答案： <br>if ( flag ) <br>if ( !flag )如下写法均属不良风格，不得分。 <br>if (flag == TRUE) <br>if (flag == 1 ) <br>if (flag == FALSE) <br>if (flag == 0) <br>请写出float x 与“零值”比较的if 语句。（4 分） <br>标准答案示例： <br>const float EPSINON = 0.00001; <br>if ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON) <br>不可将浮点变量用“==”或“！=”与数字比较，应该设法转化成“&gt;=”或“&lt;=”此类形式。 <br>如下是错误的写法，不得分。 <br>if (x == 0.0) <br>if (x != 0.0) <br>请写出char *p 与“零值”比较的if 语句。（3 分） <br>标准答案： <br>if (p == NULL) <br>if (p != NULL)如下写法均属不良风格，不得分。 <br>if (p == 0) <br>if (p != 0) <br>if (p) <br>if (!) <br>二、以下为Windows NT 下的32 位C++程序，请计算sizeof 的值（10 分） <br>char str[] = “Hello” ; <br>char *p = str ; <br>int n = 10; <br>请计算 <br>sizeof (str ) = 6 （2 分） <br>sizeof ( p ) = 4 （2 分） <br>sizeof ( n ) = 4 （2 分）void Func ( char str[100]) <br>{ <br>请计算 <br>sizeof( str ) = 4 （2 分） <br>} <br>void *p = malloc( 100 ); <br>请计算 <br>sizeof ( p ) = 4 （2 分） <br>三、简答题（25 分） <br>1、头文件中的ifndef/define/endif 干什么用？（5 分） <br>答：防止该头文件被重复引用。 <br>2、＃i nclude 和＃i nclude “filename.h” 有什么区别？（5 分） <br>答：对于＃i nclude ，编译器从标准库路径开始搜索filename.h <br>对于＃i nclude “filename.h” ，编译器从用户的工作路径开始搜索filename.h <br>3、const 有什么用途？（请至少说明两种）（5 分） <br>答：（1）可以定义const 常量 <br>（2）const 可以修饰函数的参数、返回值，甚至函数的定义体。被const 修饰的东西都受到强制保 <br>护，可以预防意外的变动，能提高程序的健壮性。 <br>4、在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？ （5 分） <br>答：C++语言支持函数重载，C 语言不支持函数重载。函数被C++编译后在库中的名字与C 语言的 <br>不同。假设某个函数的原型为： void foo(int x, int y); <br>该函数被C 编译器编译后在库中的名字为_foo，而C++编译器则会产生像_foo_int_int 之类的名 <br>字。 <br>C++提供了C 连接交换指定符号extern“C”来解决名字匹配问题。 <br>5、请简述以下两个for 循环的优缺点（5 分） <br>for (i=0; i{ <br>if (condition) <br>DoSomething(); <br>else <br>DoOtherthing(); <br>}if (condition) <br>{ <br>for (i=0; i DoSomething(); <br>} <br>else <br>{ <br>for (i=0; i DoOtherthing(); <br>} <br>优点：程序简洁 <br>缺点：多执行了N-1 次逻辑判断，并且打断了循环“流水线”作业，使得编译器不能对循环进行优化 <br>处理，降低了效率。优点：循环的效率高 <br>缺点：程序不简洁 <br>四、有关内存的思考题（每小题5 分，共20 分） <br>void GetMemory(char *p) <br>{ <br>p = (char *)malloc(100); <br>} <br>void Test(void) <br>{ <br>char *str = NULL; <br>GetMemory(str); <br>strcpy(str, "hello world"); <br>printf(str); <br>} <br>请问运行Test 函数会有什么样的结果？ <br>答：程序崩溃。 <br>因为GetMemory 并不能传递动态内存， <br>Test 函数中的str 一直都是NULL。 <br>strcpy(str, "hello world");将使程序崩溃。 <br>char *GetMemory(void) <br>{ <br>char p[] = "hello world"; <br>return p; <br>} <br>void Test(void) <br>{ <br>char *str = NULL; <br>str = GetMemory(); <br>printf(str); <br>} <br>请问运行Test 函数会有什么样的结果？ <br>答：可能是乱码。 <br>因为GetMemory 返回的是指向“栈内存”的指针，该指针的地址不是NULL，但其原现的内容已经 <br>被清除，新内容不可知。 <br>void GetMemory2(char **p, int num) <br>{ <br>*p = (char *)malloc(num); <br>} <br>void Test(void) <br>{ <br>char *str = NULL; <br>GetMemory(&amp;str, 100); <br>strcpy(str, "hello"); <br>printf(str); <br>} <br>请问运行Test 函数会有什么样的结果？ <br>答： <br>（1）能够输出hello <br>（2）内存泄漏 <br>void Test(void) <br>{ <br>char *str = (char *) malloc(100); <br>strcpy(str, “hello”); <br>free(str); <br>if(str != NULL) <br>{ <br>strcpy(str, “world”); <br>printf(str); <br>} <br>} <br>请问运行Test 函数会有什么样的结果？ <br>答：篡改动态内存区的内容，后果难以预料，非常危险。 <br>因为free(str);之后，str 成为野指针， <br>if(str != NULL)语句不起作用。</p> 
<p>27 费波那其数列，1，1，2，3，5……编写程序求第十项。可以用递归，也可以用其他方法，但要 <br>说明你选择的理由。 <br>------------------------------------------------------------------------------------- <br>＃i nclude <br>＃i nclude <br>int Pheponatch(int); <br>int Pheponatch2(int); <br>int main() <br>{ <br>printf("The 10th is %d",Pheponatch2(20)); <br>system("pause"); <br>return 0; <br>} <br>//递归算法 <br>int Pheponatch(int N) <br>{ <br>if( N == 1 || N == 2) <br>{ <br>return 1; <br>} <br>else <br>return Pheponatch( N -1 ) + Pheponatch( N -2 ); <br>} <br>//非递归算法 <br>int Pheponatch2(int N) <br>{ <br>int x = 1, y = 1, temp; <br>int i = 2; <br>while(true) <br>{ <br>temp = y; <br>y = x + y; <br>x = temp; <br>i++; <br>if( i == N ) <br>break; <br>} <br>return y; <br>} <br>25．完成下列程序 <br>* <br>*.*. <br>*..*..*.. <br>*...*...*...*... <br>*....*....*....*....*.... <br>*.....*.....*.....*.....*.....*..... <br>*......*......*......*......*......*......*...... <br>*.......*.......*.......*.......*.......*.......*.......*....... <br>＃i nclude <br>#define N 8 <br>int main() <br>{ <br>int i; <br>int j; <br>int k; <br>--------------------------------------------------------- <br>| | <br>| | <br>| | <br>--------------------------------------------------------- <br>return 0; <br>} <br>＃i nclude <br>＃i nclude <br>#define N 8 <br>int main() <br>{ <br>int i; <br>int j; <br>int k; <br>for(i=N; i&gt;=1; i--) <br>{ <br>for(j=0; j { <br>cout&lt;&lt;"*"; <br>for(k=1; k cout&lt;&lt;"."; <br>} <br>cout&lt;&lt;"/n"; <br>} <br>return 0; <br>} <br>"28 下列程序运行时会崩溃，请找出错误并改正，并且说明原因。" <br>// void append(int N) ; <br>//指针没有初始化： <br>//NewNode-&gt;left=NULL; <br>//NewNode-&gt;right=NULL; <br>＃i nclude <br>＃i nclude <br>typedef struct TNode{ <br>TNode* left; <br>TNode* right; <br>int value; <br>} TNode; <br>TNode* root=NULL; <br>void append(int N); <br>int main() <br>{ <br>append(63); <br>append(45); <br>append(32); <br>append(77); <br>append(96); <br>append(21); <br>append(17); // Again, 数字任意给出 <br>return 0; <br>} <br>void append(int N) <br>{ <br>TNode* NewNode=(TNode *)malloc(sizeof(TNode)); <br>NewNode-&gt;value=N; <br>NewNode-&gt;left=NULL; <br>NewNode-&gt;right=NULL; <br>if(root==NULL) <br>{ <br>root=NewNode; <br>return; <br>} <br>else <br>{ <br>TNode* temp; <br>temp=root; <br>while((N&gt;=temp-&gt;value &amp;&amp; temp-&gt;left!=NULL) || (Nvalue &amp;&amp; temp-&gt;right!=NULL)) <br>{ <br>while(N&gt;=temp-&gt;value &amp;&amp; temp-&gt;left!=NULL) <br>temp=temp-&gt;left; <br>while(Nvalue &amp;&amp; temp-&gt;right!=NULL) <br>temp=temp-&gt;right; <br>} <br>if(N&gt;=temp-&gt;value) <br>temp-&gt;left=NewNode; <br>else <br>temp-&gt;right=NewNode; <br>return; <br>} <br>} <br>算法： <br>1．什么是NPC，NP-Hard？ <br>2．起泡排序的时间复杂度是多少？ <br>说出至少一个比它更快的算法； <br>排序的极限时间复杂度是多少？ <br>3．有一个链表，如何判断它是一个循环链表？ <br>如果链表是单向的呢？ <br>如果出现循环的点可能在任意位置呢？ <br>如果缓存空间是有限的，比如是一个常数呢？ <br>如果只能使用2 个缓存呢？ <br>4．有一个文件，保存了若干个整数，如何以平均的概率随机得到其中的一个整数？ <br>如果整数的个数是未知的呢？ <br>如果整数是以字符串形式存放，如：（即如何得到随机的一个字符串） <br>123 <br>-456 <br>… <br>如果只允许便历文件一次呢？ <br>5．用两组数据，都在内存中，对它们排序分别需要1 和2 分钟；那么使用两个线程一起排序，大概 <br>需要多少时间？ <br>C/C++： <br>1．C 与C++的异同，优劣； <br>2．C，C++，VC，BC，TC 的区别； <br>3．C++中try…catch 关键字的用法与优点； <br>4．枚举的用法，以及它与宏的区别； <br>5．const 的用法，以及声明const 变量与宏的区别； <br>const 的用法有四种： <br>区别：const 常量有数据类型， 而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而 <br>对后者只能进行字符替换，没有类型 <br>安全检查。而且字符替换可能会带来料想不到的边界效应。 <br>有些集成化工具可以对const 常量进行调试， 但不能对宏量进行调试。 <br>6．C++中引用与指针的区别； <br>答：1 引用实际上是所引用的对象或变量的别名，而指针是包含所指向对象或变量的地址的变量。 <br>2 引用在定义时必须初始化，而指针在定义时不初始化。 <br>3 不可以有努NULL 的引用，而可以有指向NULL 的指针。 <br>4 引用在初始化后不可以改变引用关系，而指针可以随时指向其他对象（非const 指针）。 <br>7．C++中virtual 与inline 的含义分别是什么？ <br>答：在基类成员函数的声明前加上virtual 关键字，意味着将该成员函数声明为虚函数。 <br>inline 与函数的定义体放在一起，使该函数称为内联。inline 是一种用于实现的关键字，而不是用于 <br>声明的关键字。 <br>虚函数的特点；如果希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚方法，这样 <br>可以启用动态联编。 <br>内联函数的特点；使用内联函数的目的是为了提高函数的运行效率。内联函数体的代码不能过长，因 <br>为内联函数省去调用函数 <br>的时间是以代码膨胀为代价的。内联函数不能包含循环语句，因为执行循环语句要比调用函数的开销 <br>大。 <br>一个函数能否即是虚函数又是内联函数？ <br>8．以下关键字的含义与用法： <br>extern，extern “C”，static，explicit，register，#undef，#ifndef <br>9．什么是函数重载与覆盖？ <br>为什么C 不支持函数重载？ <br>为什么C++能支持函数重载？ <br>10．VC 中，编译工具条内的Debug 与Release 选项是什么含义？ <br>11．编写my_memcpy 函数，实现与库函数memcpy 类似的功能，不能使用任何库函数； <br>void* mymemcpy(void* pvTo, const char* pvFrom, size_t size) <br>{ <br>assert((dest != NULL) &amp;&amp; (src != NULL)); <br>byte* psTo = (byte*)pvTo; <br>byte* psFrom = (byte*)pvFrom; <br>while (size-- &gt; 0) <br>{ <br>*psTo++ = *psFrom++; <br>} <br>return pvTo; <br>} <br>12．编写my_strcpy 函数，实现与库函数strcpy 类似的功能，不能使用任何库函数； <br>答：char* my_strcpy(char* strdest, const char* strsrc) <br>{ <br>assert(strdest != NULL) &amp;&amp; (strsrc != NULL)) <br>char* address = strdest; <br>while((*strdest++ = *strsrc++) != NULL) <br>return address; <br>} <br>13．编写gbk_strlen 函数，计算含有汉字的字符串的长度，汉字作为一个字符处理； <br>已知：汉字编码为双字节，其中首字节&lt;0，尾字节在0~63 以外；（如果一个字节是-128~127） <br>14．函数assert 的用法? <br>答：断言assert 是仅在debug 版本起作用的宏，用于检查“不应该“发生的情况。程序员可以把assert <br>看成一个 <br>在任何系统状态下都可以安全使用的无害测试手段。 <br>15．为什么在头文件的最前面都会看到这样的代码： <br>#ifndef _STDIO_H_ <br>#define _STDIO_H_ <br>16．为什么数组名作为参数，会改变数组的内容，而其它类型如int 却不会改变变量的值？ <br>答：当数组名作为参数时，传递的实际上是地址。而其他类型如int 作为参数时，由于函数参数值实 <br>质上是实参的一份拷贝，被调 <br>函数内部对形参的改变并不影响实参的值。 <br>1．实现双向链表删除一个节点P，在节点P 后插入一个节点，写出这两个函数。 <br>2．写一个函数，将其中的/t 都转换成4 个空格。 <br>3．Windows 程序的入口是哪里？写出Windows 消息机制的流程。 <br>4．如何定义和实现一个类的成员函数为回调函数？ <br>5．C++里面是不是所有的动作都是main()引起的？如果不是，请举例。 <br>6．C++里面如何声明const void f(void)函数为C 程序中的库函数？ <br>7．下列哪两个是等同的 <br>int b; <br>A const int* a = &amp;b; <br>B const* int a = &amp;b; <br>C const int* const a = &amp;b; <br>D int const* const a = &amp;b; <br>8．内联函数在编译时是否做参数类型检查？ <br>void g(base &amp; b){ <br>b.play; <br>} <br>void main(){ <br>son s; <br>g(s); <br>return; <br>} <br>3、WinMain <br>while( (bRet = GetMessage( &amp;msg, NULL, 0, 0 )) != 0) <br>{ <br>if (bRet == -1) <br>{ <br>// handle the error and possibly exit <br>} <br>else <br>{ <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>} <br>} <br>MSRA Interview Written Exam（December 2003，Time：2.5 Hours） <br>1 写出下列算法的时间复杂度。 <br>(1)冒泡排序； <br>(2)选择排序； <br>(3)插入排序； <br>(4)快速排序； <br>(5)堆排序； <br>(6)归并排序； <br>2 写出下列程序在X86 上的运行结果。 <br>struct mybitfields <br>{ <br>unsigned short a : 4; <br>unsigned short b : 5; <br>unsigned short c : 7; <br>}test <br>void main(void) <br>{ <br>int i; <br>test.a=2; <br>test.b=3; <br>test.c=0; <br>i=*((short *)&amp;test); <br>printf("%d/n",i); <br>} <br>3 写出下列程序的运行结果。 <br>unsigned int i=3; <br>cout&lt; <br>4 写出下列程序所有可能的运行结果。 <br>int a; <br>int b; <br>int c; <br>void F1() <br>{ <br>b=a*2; <br>a=b; <br>} <br>void F2() <br>{ <br>c=a+1; <br>a=c; <br>} <br>main() <br>{ <br>a=5; <br>//Start F1,F2 in parallel <br>F1(); F2(); <br>printf("a=%d/n",a); <br>} <br>5 考察了一个CharPrev()函数的作用。 <br>6 对16 Bits colors 的处理，要求： <br>（1）Byte 转换为RGB 时，保留高5、6bits； <br>（2）RGB 转换为Byte 时，第2、3 位置零。 <br>7 一个链表的操作，注意代码的健壮和安全性。要求： <br>（1）增加一个元素； <br>（2）获得头元素； <br>（3）弹出头元素（获得值并删除）。 <br>8 一个给定的数值由左边开始升位到右边第N 位，如 <br>0010&lt;&lt;1 == 0100 <br>或者 <br>0001 0011&lt;&lt;4 == 0011 0000 <br>请用C 或者C++或者其他X86 上能运行的程序实现。 <br>附加题（只有在完成以上题目后，才获准回答） <br>In C++, what does "explicit" mean? what does "protected" mean? <br>2、解释1NF、2NF、3NF、BCNF <br>第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中 <br>的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体， <br>新的实体由重复的属性构成，新实体与原实体之间为一对多关系；简而言之，第一范式就是无重复的列。 <br>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范 <br>式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需 <br>要为表加上一个列，以存储各个实例的惟一标识。 <br>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不 <br>包含已在其它表中已包含的非主关键字信息。 <br>在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BCNF 。 <br>3、如何存储稀疏矩阵 <br>好几种吧，还要看矩阵的类型 <br>4、快排序在最好，最坏，平均情况下的时间复杂度与辅助空间复杂度 <br>最好复杂度O(nlog2n) 最坏O(n^2) 平均O(nlog2n) <br>空间：最好log2n 最坏n 平均log2^n <br>1、不用任何变量交换a，b 两个变量 <br>（看过...那个加减法吧） <br>2、用递归求最大公约数 <br>#include 
  
  <br>using namespace std; 
  <br>// 求两个整型数的最大公约数 
  <br>int gcd( int a, int b ) 
  <br>{ 
  <br>int temp = 2; // 公因子，从2 开始递增直到两个数中最小的一个 
  <br>while (temp &lt;= (a &lt; b ? a : b)) 
  <br>{ 
  <br>if (a % temp == 0 &amp;&amp; b % temp == 0) 
  <br>{ // 都能被整除时递归 
  <br>return temp * gcd( a / temp, b / temp ); 
  <br>} 
  <br>else 
  <br>{ // 有一个不能被整除则公因子加一 
  <br>temp++; 
  <br>} 
  <br>} 
  <br>return 1; // 最大公因子为1 
  <br>} 
  <br>3、举一个多态的例子 
  <br>（多态...是不是必须要有指针才行啊？） 
  <br>4、二叉平衡树 
  <br>（。。。) 
  <br>5、UNIX 进程包括那三个部分:... 
  <br>（程序,数据和进程控制块PCB） 
  <br>6、new 动态分配失败会抛出什么异常,C++中提供了那两个标准函数来设定异常处理HANLDER 
  <br>（不知道） 
  <br>7、EJB 都有那些Beans?区别 
  <br>（....） 
  <br>8、asp 和asp.net 的区别 
  <br>（除了编译和解释外...） 
  <br>9、JAVA 中的interface 和abstract class 区别 
  <br>（.....） 
  <br>10、logic thinking:如何证明一个电冰箱是否是好的。 
  <br>（.....） 
  <br>内联的定义，什么情况下选择内联。内连接与外连接的区别。 
  <br>... 
  <br>＝＝＝＝＝＝＝＝＝＝＝ 
  <br>1、100=9 9 9 9 9 9 
  <br>9×9＋9＋9＋9/9 
  <br>2、根据pseudo code 判断下列哪个x 打印"Text 2" 
  <br>If (x&gt;4) then print "Text 1" 
  <br>Else if (x&gt;9) then print "Text 2" 
  <br>Else print "Text 3") 
  <br>(1)less than 0,(2)less than 4,(3)between 4 and 9,(4)&gt;9,(5)none 
  <br>5 吧 
  <br>3、填bug report:a browser based software crashes when you type "-1" in a input field called ABC on 
  <br>secong html page after loggong on on WindowXP platfor 
  <br>m. And this happens every time you try typing "-1".You are not sure if any d 
  <br>atabase servers are being used or not. 
  <br>┏━━━━━━━━━━━━━━━━ 
  <br>┃ Serverity:┃ ┃Priority:┃ ┃ 
  <br>━━━━━━━━━━━━━━━━━ 
  <br>┃ ━━━━━━━━━━━━━━━━━━━┃ 
  <br>┃ Short Description┃ ┃ 
  <br>┃ ━━━━━━━━━┃━━━━━━━━━┃ 
  <br>┃ Reproducible? ┃ ┃ 
  <br>┃ ━━━━━━━━━┃━━━━━━━━━┃ 
  <br>┃ Recreate steps: ┃ ┃ 
  <br>┃ ━━━━━━━━━┃━━━━━━━━━┃ 
  <br>┃ Attachment: ┃ ┃ 
  <br>━━━━━━━━━━━━━━━━━━━━┃ 
  <br>┃ ━━━━━━━━━━━━━━━━━━━┃ 
  <br>┃ platform tested: ┃ ┃ 
  <br>┃ ━━━━━━━━━━━━━━━━━━━┃ 
  <br>┃ database server: ┃ ┃ 
  <br>┃ ━━━━━━━━━━━━━━━━━━━┃ 
  <br>┃ browser : ┃ ┃ 
  <br>━━━━━━━━━━━━━━━━━━━━┃ 
  <br>4、添加注释 
  <br>// 
  <br>// 
  <br>// 
  <br>// 
  <br>private static final int SHORT_COLUMN_WIDTH=5; 
  <br>private static final int INT_COLUMN_WIDTH=10; 
  <br>private static final int LONG_COLUMN_WIDTH=19; 
  <br>private static final int DOUBLE_COLUMN_WIDTH=23; 
  <br>…… 
  <br>int decimalDigits=DataTypeInfo.getScale(); 
  <br>int widthOfNumber=DataTypeInfo.getPrecision(); 
  <br>int dataType=DataTypeInfo.numberValue; 
  <br>// 
  <br>// 
  <br>// 
  <br>if (decimalDigits==0){ 
  <br>if (widthOfNumber&lt;=SHORT_COLUMN_WIDTH) {dataType=dataTypeInfo.signedInt16Value;} 
  <br>else if (widthOfNumber&lt;=INT_COLUMN_WIDTH) {dataType=dataTypeInfo.signedInt32Value;} 
  <br>else if (widthOfNumber&lt;=LONG_COLUMN_WIDTH) {dataType=dataTypeInfo.signedInt64Value;} 
  <br>else if (widthOfNumber&lt;=DOUBLE_COLUMN_WIDTH) {dataType=dataTypeInfo.numberValue;} 
  <br>else {dataType=dataTypeInfo.numberValue;} 
  <br>5、设计一个算法判断一个字符串是否是回文，并写出代码。 
  <br>"A man a plan a canal panama"是回文。 
  <br>6、定义函数，给出三个参数，从字符串inputString 中的下标indexOfChar 开始返回noOfChar 个字符。要 
  <br>求找出尽可能多的错误情形 
  <br>7、编一段代码，求两个int 的最大公约数 
  <br>8、给出一段c++代码（关于构建器和虚析构器的调用问题），要求（1）其输出，（2）说明virtual destructor 
  <br>的作用（role） 
  <br>9、英文阅读理解。 
  <br>写一个程序, 要求功能：求出用1，2，5 这三个数不同个数组合的和为100 的组合个数。 
  <br>如：100 个1 是一个组合，5 个1 加19 个5 是一个组合。。。。请用C++语言写。 
  <br>答案：最容易想到的算法是： 
  <br>设x 是1 的个数，y 是2 的个数，z 是5 的个数，number 是组合数注意到0&lt;=x&lt;=100，0&lt;=y&lt;=50，0&lt;=z=20， 
  <br>所以可以编程为： 
  <br>number=0; 
  <br>for (x=0; x&lt;=100; x++) 
  <br>for (y=0; y&lt;=50; y++) 
  <br>for (z=0; z&lt;=20; z++) 
  <br>if ((x+2*y+5*z)==100) 
  <br>number++; 
  <br>cout&lt; 
  
    &lt; 
    
    <br>上面这个程序一共要循环100*50*20 次，效率实在是太低了事实上，这个题目是一道明显的数学问题，而 
    <br>不是单纯的编程问题。我的解法如下： 
    <br>因为x+2y+5z=100 
    <br>所以x+2y=100-5z，且z&lt;=20 x&lt;=100 y&lt;=50 
    <br>所以(x+2y)&lt;=100，且(x+5z)是偶数 
    <br>对z 作循环，求x 的可能值如下： 
    <br>z=0, x=100, 98, 96, ... 0 
    <br>z=1, x=95, 93, ..., 1 
    <br>z=2, x=90, 88, ..., 0 
    <br>z=3, x=85, 83, ..., 1 
    <br>z=4, x=80, 78, ..., 0 
    <br>...... 
    <br>z=19, x=5, 3, 1 
    <br>z=20, x=0 
    <br>因此，组合总数为100 以内的偶数+95 以内的奇数+90 以内的偶数+...+5 以内的奇数+1， 
    <br>即为： 
    <br>(51+48)+(46+43)+(41+38)+(36+33)+(31+28)+(26+23)+(21+18)+(16+13)+(11+8)+(6+3)+1 
    <br>某个偶数m 以内的偶数个数（包括0）可以表示为m/2+1=(m+2)/2 
    <br>某个奇数m 以内的奇数个数也可以表示为(m+2)/2 
    <br>所以，求总的组合次数可以编程为： 
    <br>number=0; 
    <br>for (int m=0;m&lt;=100;m+=5) 
    <br>{ 
    <br>number+=(m+2)/2; 
    <br>} 
    <br>cout&lt; 
    
      &lt; 
      
      <br>这个程序,只需要循环21 次, 两个变量，就可以得到答案,比上面的那个程序高效了许多 
      <br>倍----只是因为作了一些简单的数学分析 
      <br>这再一次证明了：计算机程序=数据结构+算法，而且算法是程序的灵魂，对任何工程问 
      <br>题，当用软件来实现时，必须选取满足当前的资源限制，用户需求限制，开发时间限制等种 
      <br>种限制条件下的最优算法。而绝不能一拿到手，就立刻用最容易想到的算法编出一个程序了 
      <br>事——这不是一个专业的研发人员的行为。 
      <br>那么，那种最容易想到的算法就完全没有用吗？不，这种算法正好可以用来验证新算法 
      <br>的正确性，在调试阶段，这非常有用。在很多大公司，例如微软，都采用了这种方法：在调 
      <br>试阶段，对一些重要的需要好的算法来实现的程序，而这种好的算法又比较复杂时，同时用 
      <br>容易想到的算法来验证这段程序，如果两种算法得出的结果不一致（而最容易想到的算法保 
      <br>证是正确的），那么说明优化的算法出了问题，需要修改。 
      <br>可以举例表示为： 
      <br>#ifdef DEBUG 
      <br>int simple(); 
      <br>#end if 
      <br>int optimize(); 
      <br>...... 
      <br>in a function: 
      <br>{ 
      <br>result=optimize(); 
      <br>ASSERT(result==simple()); 
      <br>} 
      <br>这样,在调试阶段,如果简单算法和优化算法的结果不一致,就会打出断言。同时，在程 
      <br>序的发布版本，却不会包含笨重的simple()函数。——任何大型工程软件都需要预先设计良 
      <br>好的调试手段，而这里提到的就是一种有用的方法。 
      <br>一个学生的信息是：姓名，学号，性别，年龄等信息，用一个链表，把这些学生信息连在一起， 给出一个 
      <br>age, 在些链表中删除学生年龄等 
      <br>于age 的学生信息。 
      <br>#include "stdio.h" 
      <br>#include "conio.h" 
      <br>struct stu{ 
      <br>char name[20]; 
      <br>char sex; 
      <br>int no; 
      <br>int age; 
      <br>struct stu * next; 
      <br>}*linklist; 
      <br>struct stu *creatlist(int n) 
      <br>{ 
      <br>int i; 
      <br>//h 为头结点，p 为前一结点，s 为当前结点 
      <br>struct stu *h,*p,*s; 
      <br>h = (struct stu *)malloc(sizeof(struct stu)); 
      <br>h-&gt;next = NULL; 
      <br>p=h; 
      <br>for(i=0;i 
       
       <br>{ 
       <br>s = (struct stu *)malloc(sizeof(struct stu)); 
       <br>p-&gt;next = s; 
       <br>printf("Please input the information of the student: name sex no age /n"); 
       <br>scanf("%s %c %d %d",s-&gt;name,&amp;s-&gt;sex,&amp;s-&gt;no,&amp;s-&gt;age); 
       <br>s-&gt;next = NULL; 
       <br>p = s; 
       <br>} 
       <br>printf("Create successful!"); 
       <br>return(h); 
       <br>} 
       <br>void deletelist(struct stu *s,int a) 
       <br>{ 
       <br>struct stu *p; 
       <br>while(s-&gt;age!=a) 
       <br>{ 
       <br>p = s; 
       <br>s = s-&gt;next; 
       <br>} 
       <br>if(s==NULL) 
       <br>printf("The record is not exist."); 
       <br>else 
       <br>{ 
       <br>p-&gt;next = s-&gt;next; 
       <br>printf("Delete successful!"); 
       <br>} 
       <br>} 
       <br>void display(struct stu *s) 
       <br>{ 
       <br>s = s-&gt;next; 
       <br>while(s!=NULL) 
       <br>{ 
       <br>printf("%s %c %d %d/n",s-&gt;name,s-&gt;sex,s-&gt;no,s-&gt;age); 
       <br>s = s-&gt;next; 
       <br>} 
       <br>} 
       <br>int main() 
       <br>{ 
       <br>struct stu *s; 
       <br>int n,age; 
       <br>printf("Please input the length of seqlist:/n"); 
       <br>scanf("%d",&amp;n); 
       <br>s = creatlist(n); 
       <br>display(s); 
       <br>printf("Please input the age:/n"); 
       <br>scanf("%d",&amp;age); 
       <br>deletelist(s,age); 
       <br>display(s); 
       <br>return 0; 
       <br>} 
       <br>2、实现一个函数，把一个字符串中的字符从小写转为大写。 
       <br>#include "stdio.h" 
       <br>#include "conio.h" 
       <br>void uppers(char *s,char *us) 
       <br>{ 
       <br>for(;*s!='/0';s++,us++) 
       <br>{ 
       <br>if(*s&gt;='a'&amp;&amp;*s&lt;='z') 
       <br>*us = *s-32; 
       <br>else 
       <br>*us = *s; 
       <br>} 
       <br>*us = '/0'; 
       <br>} 
       <br>int main() 
       <br>{ 
       <br>char *s,*us; 
       <br>char ss[20]; 
       <br>printf("Please input a string:/n"); 
       <br>scanf("%s",ss); 
       <br>s = ss; 
       <br>uppers(s,us); 
       <br>printf("The result is:/n%s/n",us); 
       <br>getch(); 
       <br>} 
       <br>随机输入一个数，判断它是不是对称数（回文数）（如3，121，12321，45254）。不能用字符串库函数 
       <br>/*************************************************************** 
       <br>1. 
       <br>函数名称：Symmetry 
       <br>功能： 判断一个数时候为回文数(121,35653) 
       <br>输入： 长整型的数 
       <br>输出： 若为回文数返回值为1 esle 0 
       <br>******************************************************************/ 
       <br>unsigned char Symmetry (long n) 
       <br>{ 
       <br>long i,temp; 
       <br>i=n; temp=0; 
       <br>while(i) //不用出现长度问题,将数按高低位掉换 
       <br>{ 
       <br>temp=temp*10+i%10; 
       <br>i/=10; 
       <br>} 
       <br>return(temp==n); 
       <br>} 
       <br>方法一 
       <br>/* --------------------------------------------------------------------------- 
       <br>功能： 
       <br>判断字符串是否为回文数字 
       <br>实现： 
       <br>先将字符串转换为正整数，再将正整数逆序组合为新的正整数，两数相同则为回文数字 
       <br>输入： 
       <br>char *s：待判断的字符串 
       <br>输出： 
       <br>无 
       <br>返回： 
       <br>0：正确；1：待判断的字符串为空；2：待判断的字符串不为数字； 
       <br>3：字符串不为回文数字；4：待判断的字符串溢出 
       <br>---------------------------------------------------------------------------- */ 
       <br>unsigned IsSymmetry(char *s) 
       <br>{ 
       <br>char *p = s; 
       <br>long nNumber = 0; 
       <br>long n = 0; 
       <br>long nTemp = 0; 
       <br>/*判断输入是否为空*/ 
       <br>if (*s == /'//0/') 
       <br>return 1; 
       <br>/*将字符串转换为正整数*/ 
       <br>while (*p != /'//0/') 
       <br>{ 
       <br>/*判断字符是否为数字*/ 
       <br>if (*p 
       /'9/') 
       <br>return 2; 
       <br>/*判断正整数是否溢出*/ 
       <br>if ((*p-/'0/') &gt; (4294967295-(nNumber*10))) 
       <br>return 4; 
       <br>nNumber = (*p-/'0/') + (nNumber * 10); 
       <br>p++; 
       <br>} 
       <br>/*将数字逆序组合，直接抄楼上高手的代码，莫怪，呵呵*/ 
       <br>n = nNumber; 
       <br>while(n) 
       <br>{ 
       <br>/*判断正整数是否溢出*/ 
       <br>101 
       <br>if ((n%10) &gt; (4294967295-(nTemp*10))) 
       <br>return 3; 
       <br>nTemp = nTemp*10 + n%10; 
       <br>n /= 10; 
       <br>} 
       <br>/*比较逆序数和原序数是否相等*/ 
       <br>if (nNumber != nTemp) 
       <br>return 3; 
       <br>return 0; 
       <br>} 
       <br>方法二 
       <br>/* --------------------------------------------------------------------------- 
       <br>功能： 
       <br>判断字符串是否为回文数字 
       <br>实现： 
       <br>先得到字符串的长度，再依次比较字符串的对应位字符是否相同 
       <br>输入： 
       <br>char *s：待判断的字符串 
       <br>输出： 
       <br>无 
       <br>返回： 
       <br>0：正确；1：待判断的字符串为空；2：待判断的字符串不为数字； 
       <br>3：字符串不为回文数字 
       <br>---------------------------------------------------------------------------- */ 
       <br>unsigned IsSymmetry_2(char *s) 
       <br>{ 
       <br>char *p = s; 
       <br>int nLen = 0; 
       <br>int i = 0; 
       <br>/*判断输入是否为空*/ 
       <br>if (*s == /'//0/') 
       <br>return 1; 
       <br>/*得到字符串长度*/ 
       <br>while (*p != /'//0/') 
       <br>{ 
       <br>/*判断字符是否为数字*/ 
       <br>if (*p 
       /'9/') 
       <br>return 2; 
       
      
     
    
   
 </p> 
<p>nLen++; <br>p++; <br>} <br>/*长度不为奇数，不为回文数字*/ <br>if (nLen%2 == 0) <br>return 4; <br>/*长度为1，即为回文数字*/ <br>if (nLen == 1) <br>return 0; <br>/*依次比较对应字符是否相同*/ <br>p = s; <br>i = nLen/2 - 1; <br>while (i) <br>{ <br>if (*(p+i) != *(p+nLen-i-1)) <br>return 3; <br>i--; <br>} <br>return 0; <br>} <br>求2~2000 的所有素数.有足够的内存,要求尽量快 <br>答案： <br>int findvalue[2000]={2}; <br>static int find=1; <br>bool adjust(int value) <br>{ <br>assert(value&gt;=2); <br>if(value==2) return true; <br>for(int i=0;i&lt;=find;i++) <br>{ <br>if(value%findvalue[i]==0) <br>return false; <br>} <br>findvalue[find++]; <br>return true; <br>}</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8df46395feaa11b268e9f206d081688e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;笔试题汇总（4）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8bd953acae9481dce5c83ec765750e38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;笔试题汇总（6）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>