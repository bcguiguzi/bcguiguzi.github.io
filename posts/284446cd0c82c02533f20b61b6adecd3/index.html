<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ES6~ES13新特性整理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ES6~ES13新特性整理" />
<meta property="og:description" content="简单整理下ES6-13新特性的知识点
1.ES6 1.1 let和const
var会有变量提升，let和const不会；
let和const存在暂时性死区；
let和const不可重复声明；
var定义的变量为函数级作用域，let和const 块级作用域；
const声明一个只读的常量。一旦声明，常量的值就不能改变。
【const一旦声明变量，就必须立即初始化。】实际上是指变量指向的内存地址保存的数据不可改动。对象数组，变量指向的内存地址保存的只是指针并不是实际的数据，所以const声明对象的时候，该对象本身是可以改的，但是不能将这个对象指向另一个地址。严格模式下可以用Object.freeze()。
1.2 class类
一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。
类的方法内部如果含有this，它默认指向类的实例。
//以项目中使用为例 class Person { constructor(first, last) { this.firstName = first this.lastName = last } } export default Person //使用的时候引入 import Person from &#39;xxxxxx&#39; const person = new Person(&#39;kkkk&#39;, &#39;oooo&#39;) //打印出 Person {firstName: &#39;kkkk&#39;, lastName: &#39;oooo&#39;} ES6 规定，子类必须在constructor()方法中调用super()，否则就会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象。
class Person { constructor(first, last) { this.firstName = first this.lastName = last } play() { console.log(&#39;play&#39;) } } class LittlePerson extends Person { constructor(x, y, color) { super(x, y) // 调用父类的constructor(x, y) this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/284446cd0c82c02533f20b61b6adecd3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-29T21:41:02+08:00" />
<meta property="article:modified_time" content="2022-08-29T21:41:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ES6~ES13新特性整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>简单整理下ES6-13新特性的知识点</p> 
<h3 id="main-toc">1.ES6</h3> 
<p>1.1  let和const</p> 
<p>var会有变量提升，let和const不会；</p> 
<p>let和const存在暂时性死区；</p> 
<p>let和const不可重复声明；</p> 
<p>var定义的变量为函数级作用域，let和const 块级作用域；</p> 
<p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p> 
<p>【const一旦声明变量，就必须立即初始化。】实际上是指变量指向的内存地址保存的数据不可改动。对象数组，变量指向的内存地址保存的只是指针并不是实际的数据，所以const声明对象的时候，该对象本身是可以改的，但是不能将这个对象指向另一个地址。严格模式下可以用Object.freeze()。</p> 
<p>1.2  class类</p> 
<p>一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</p> 
<p>类的方法内部如果含有this，它默认指向类的实例。</p> 
<pre><code class="language-javascript">//以项目中使用为例
class Person {
  constructor(first, last) {
    this.firstName = first
    this.lastName = last
  }
}
export default Person   
//使用的时候引入
import Person from 'xxxxxx'

const person = new Person('kkkk', 'oooo')
//打印出 Person {firstName: 'kkkk', lastName: 'oooo'}
</code></pre> 
<p>ES6 规定，子类必须在constructor()方法中调用super()，否则就会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，添加子类自己的实例属性和方法。如果不调用super()方法，子类就得不到自己的this对象。</p> 
<pre><code class="language-javascript">class Person {
  constructor(first, last) {
    this.firstName = first
    this.lastName = last
  }
  play() {
    console.log('play')
  }
}
class LittlePerson extends Person {
  constructor(x, y, color) {
    super(x, y) // 调用父类的constructor(x, y)
    this.color = color
  }

  play() {
    super.play() // 调用父类的play()
  }
}
export default LittlePerson

//引用以后
const person = new LittlePerson('kkkk', 'oooo', 'pppp')
console.log(person) 
//LittlePerson {firstName: 'kkkk', lastName: 'oooo', color: 'pppp'}
person.play()//打印  play</code></pre> 
<p>1.3  解构赋值</p> 
<p>1.4  模板字符串</p> 
<p>1.5  字符串的几个常用方法</p> 
<pre><code class="language-javascript">const s = 'nanjing fuzi'
s.includes('a') //true
s.includes('a',3) //false
s.startsWith('na')//true
s.startsWith('na',1)//false
//includes和startsWith第二个参数都是指起始下标到字符串结束
s.endsWith('zi')//true
s.endsWith('zi', 8)//false
//endsWith第二个参数都是指从下标0到该下标位置

'na'.repeat(0) // ""
'na'.repeat(2) // "nana"
'na'.repeat(2.9) // "nana"
//参数是小于-1的负数或者Infinity报错
//0 到-1 之间的小数，则等同于 0,因为先取整为-0
'na'.repeat('2')//'nana'  参数是字符串，则会先转换成数字
</code></pre> 
<p>1.6  数值的常用方法</p> 
<pre><code class="language-javascript">Number.isFinite(9999)//true
Number.isNaN(9999)//true
//这两个新方法只对数值有效,所以参数为字符串返回false

</code></pre> 
<p>  </p> 
<p>1.7  箭头函数、函数参数默认值</p> 
<p>1.8  promise</p> 
<p>1.9  set</p> 
<p>1.10  map</p> 
<p>1.11  模块化(import    export)</p> 
<p>1.12  Proxy   Reflect</p> 
<h3>2. ES7</h3> 
<p>2.1  数组的includes</p> 
<pre><code class="language-javascript">const arr = ['111', '222', '333']
arr.includes('000')//false
arr.includes('111')//true</code></pre> 
<p>2.2  指数运算符**</p> 
<h4></h4> 
<h3>3. ES8</h3> 
<p>3.1  async  await</p> 
<p>3.2  Object.values()</p> 
<pre><code class="language-javascript"> const obj = Object.freeze({
     name: 'kkk',
     age: 18,
})
console.log(Object.values(obj)) //['kkk', 18]</code></pre> 
<p>3.3 Object.entries()</p> 
<pre><code class="language-javascript">const obj = Object.freeze({
        name: 'kkk',
        age: 18,
})
console.log(Object.entries(obj))//[['name', 'kkk'],['age', 18]]</code></pre> 
<p>3.4 Object.getOwnPropertyDescriptors()</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/16/72/Ld1pJpHr_o.png"></p> 
<p> </p> 
<p>3.5 padStart   padEnd</p> 
<pre><code class="language-javascript">
'x'.padStart(4, 'ab') // 'abax'
'x'.padEnd(4, 'ab') // 'xaba'</code></pre> 
<p>3.6 函数参数列表结尾允许逗号</p> 
<p>3.7 SharedArrayBuffer 对象</p> 
<p>3.8 Atomics 对象</p> 
<h3>4. ES9</h3> 
<p>4.1 异步迭代</p> 
<p>4.2 promise.finally()</p> 
<p>4.3 Rest/Spresd属性</p> 
<p>4.4 正则表达式命名捕获</p> 
<p>4.5 正则反向断言、正则dotAll、正则Unicode转义</p> 
<h3>5.ES10</h3> 
<p>5.1 Array.flat() 和flatMap()</p> 
<p>5.2 String.trimStart()和trimEnd()</p> 
<pre><code class="language-javascript">const s = '  abc  ';
s.trim() // "abc"
s.trimStart() // "abc  "
s.trimEnd() // "  abc"

</code></pre> 
<p>5.3 String.prototype.matchAll </p> 
<p>为所有匹配的匹配对象返回一个迭代器</p> 
<p>5.4 Symbol.prototype.description</p> 
<p>5.5  Object.fromEntries()</p> 
<pre><code class="language-javascript">//与Object.entries()相反
const obj = Object.freeze({
        name: 'kkk',
        age: 18,
      })
const a = Object.entries(obj)
console.log(a)
const obj1 = [
    ['name', 'kkk'],
    ['age', 9],
]
const b = Object.fromEntries(obj1)
console.log(b)</code></pre> 
<p>5.6  可选catch</p> 
<p>其实就是try...catch中可以省略catch绑定的参数和括号。</p> 
<p>5.7  稳定的排序算法Array.sort()</p> 
<pre><code class="language-javascript">const array = [
        { a: 1, b: 2 },
        { a: 2, b: 2 },
        { a: 1, b: 3 },
        { a: 2, b: 4 },
        { a: 5, b: 3 },
      ]
const arr = array.sort((a, b) =&gt; {
        return a.a - b.a
})
console.log(arr)</code></pre> 
<p>5.8   Function.toString()</p> 
<p>从头到尾返回源代码中的实际文本片段</p> 
<p>5.9  JSON.stringify() 加强格式转化</p> 
<h3>6. ES11</h3> 
<p>6.1 动态import</p> 
<p>6.2  ??</p> 
<pre><code class="language-javascript">const num = 0
const num1 = num || 8
const num2 = num ?? 8
console.log(num1, num2)//8  0</code></pre> 
<p>6.3 可选链接  ?.</p> 
<p>该使用方法虽然好用，但是不能滥用，有时候会把一些错误隐藏了</p> 
<p>6.4 bigInt</p> 
<p>6.5 promise.allSettled</p> 
<p>返回一个组合后的 promise，当所有 promise 全部切换为 fulfiled或 rejected状态时，该 promise 将切换为 fulfiled 状态；</p> 
<p>6.6 for-in结构，规范for-in语句顺序结构</p> 
<p>6.8  globalThis<br>  </p> 
<h3>7. ES12</h3> 
<p>7.1 replaceAll()</p> 
<pre><code class="language-javascript">
'aabbcc'.replaceAll('b', '_')// 'aa__cc'</code></pre> 
<p>7.2  promise.any()</p> 
<pre><code class="language-javascript">总结下：

promise.all() 

 返回一个组合后的 promise，当所有 promise 全部切换为fulfiled状态后，该 promise 切换为 fulfiled 状态；但若有任意一个 promise 切换为rejected 状态，该 promise 将立即切换为 rejected 状态。简而言之，需要全部fulfilled才会返回fulfilled

promise.race()  

返回一个组合后的 promise，当 promise 中有任意一个切换为fulfiled 或rejected状态时，该 promise 将立即切换为相同状态。

promise.allSettled()

返回一个组合后的 promise，当所有 promise 全部切换为 fulfiled或 rejected状态时，该 promise 将切换为 fulfiled 状态；

promise.any()

返回一个组合后的 promise，当 promise 中有任意一个切换为 fulfilled 状态时，该 promise 将立即切换为 fulfilled 状态，但只有所有 promise 全部切换为 rejected 状态时，该 promise 才切换为 rejected 状态。</code></pre> 
<p> 7.3  逻辑赋值操作符 ??=、&amp;&amp;=、 ||=</p> 
<p>ES11中的??用法赋值简写</p> 
<pre><code class="language-javascript">let num = 0
num ??= 9
console.log(num)//0
//等同于 num = num??9

let num = 0
num ||= 9
console.log(num)//9
//等同于 num = num||9

let num = 0
num &amp;&amp;= 9
console.log(num)//0
//等同于 num = num&amp;&amp;9</code></pre> 
<p>7.4  下划线分隔符</p> 
<p>7.5 WeakRef </p> 
<p>7.6  Intl.ListFormat   构造函数，用来处理和多语言相关的对象格式化操作。</p> 
<p>7.8  dateStyle 和 timeStyle</p> 
<pre><code class="language-javascript">const a = new Intl.DateTimeFormat('en', {
     timeStyle: 'short',
    dateStyle: 'short',
})
console.log(a.format(Date.now()))//8/29/22, 9:35 PM
const b = new Intl.DateTimeFormat('en', {
    timeStyle: 'medium',
    dateStyle: 'medium',
})
console.log(b.format(Date.now()))//Aug 29, 2022, 9:35:39 PM

const c = new Intl.DateTimeFormat('en', {
   timeStyle: 'long',
   dateStyle: 'long',
})
console.log(c.format(Date.now()))//August 29, 2022 at 9:35:39 PM GMT+8</code></pre> 
<h3>8. ES13</h3> 
<p>8.1  声明类的字段</p> 
<pre><code class="language-javascript">class Test {
  name='kkk'
}
//类字段可以在类的顶层被定义和初始化
//之前是在constrsuctor构造器中定义类的字段和初始化</code></pre> 
<p><br> 8.2  用#前缀来定义类的私有方法和字段</p> 
<p>8.3  增加了静态公共字段、静态私有方法和静态私有字段的特性<br> 8.4  使用 Object.hasOwn(object, property)替代 Object.prototype.hasOwnProperty.call(object, property)</p> 
<p>8.5  用in检测私有字段</p> 
<p>8.6  at()</p> 
<pre><code class="language-javascript">const str = 'hello';
str.at(1) // "e"
str.at(-1) // "o"
const array = [
        { a: 1, b: 2 },
        { a: 2, b: 2 },
        { a: 1, b: 3 },
        { a: 2, b: 4 },
        { a: 5, b: 3 },
      ]
const r = array.at(-1)
console.log(r) //{ a: 5, b: 3 }</code></pre> 
<p>8.7 正则索引/d</p> 
<pre><code class="language-javascript">const reg = /test(\d)/g
const reg1 = /test(\d)/dg
const str = 'test1test2'
const arr = [...str.matchAll(reg)]
const arr1 = [...str.matchAll(reg1)]</code></pre> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/21/83/J2e5LmTy_o.png"> </p> 
<p> 打印出来的结果差距就还挺大的。</p> 
<p>8.8  Error Cause</p> 
<p>大致就是以上，有些具体详细的地方懒得写了。。。。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2947849695dc5b8d9f4672b38bf6f208/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">谷歌Xswitch插件下载及安装失败原因</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8e4fa1a3005879a4559634a80edeb34f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux网络编程--select()和pselect()函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>