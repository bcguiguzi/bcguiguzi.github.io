<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【微信小程序】组件的生命周期及自定义组件 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【微信小程序】组件的生命周期及自定义组件" />
<meta property="og:description" content="文章目录 组件的生命周期自定义组件的生命周期函数执行顺序组件常用的生命周期函数lifetimes节点 组件所在页面的生命周期函数pageLifetimes节点 自定义组件创建自定义组件创建组件定义组件使用组件 父组件向子组件传递数据子组件向父组件传递数据其他定义段与示例方法 组件的生命周期 组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。
其中，最重要的生命周期是 created、attached、 detached ，包含一个组件实例生命流程的最主要时间点。
自定义组件的生命周期函数 小程序组件可用的全部生命周期如下表所示:
生命周期函数参数描述说明created无在组件实例刚刚被创建时执行attached无在组件实例进入页面节点树时执行ready无在组件在视图层布局完成后执行moved无在组件实例被移动到节点树另一个位置时执行detached无在组件实例被从页面节点树移除时执行errorObject Error每当组件方法抛出错误时执行 执行顺序 从该图中可以看出组件的 ready 与 detached 执行顺序并没有明确的先后关系。
组件常用的生命周期函数 在小程序组件中，最重要的生命周期函数有3个，分别是created、attached.
detached。它们各自的特点。如下︰
组件实例刚被创建好的时候，created生命周期函数会被触发
此时还不能调用setData，通常在这个生命周期函数中，只应该用于给组件的this添加一些自定义的属性字段在组件完全初始化完毕、进入页面节点树后，attached生命周期函数会被触发
此时, this.data已被初始化完毕。这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据)在组件离开页面节点树后，detached生命周期函数会被触发
退出一个页面时，会触发页面内每个自定义组件的detached生命周期函数此时适合做一些清理性质的工作 lifetimes节点 在小程序组件中，生命周期函数可以直接定义在Component构造器的第一级参数中，可以在 lifetimes字段内进行声明（这是推荐的方式，其优先级最高）。如下:
Component({ lifetimes:{ created(){ console.log(&#39;created&#39;); }, attached(){ console.log(&#39;attached&#39;); } } )} 注意：若不写在lifetime节点中且同时存在lifetime节点，优先执行lifetime节点中的生命周期函数，并覆盖掉节点之外的生命周期函数。
组件所在页面的生命周期函数 有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。
在自定义组件中，组件所在页面的生命周期函数有如下3个，分别是:
生命周期函数参数描述show无组件所在的页面被展示时执行hide无组件所在的页面被隐藏时执行resizeobject Size组件所在的页面尺寸变化时执行 pageLifetimes节点 组件所在页面的生命周期函数，需要定义在pageLifetimes节点中，如下:
Component({ pageLifetimes:{ show(){ console.log(&#34;show!!&#34;); }, hide(){ console.log(&#34;hide!!&#34;); }, resize(){ console.log(&#34;resize&#34;); }	}	)} 当页面显示和隐藏时触发
自定义组件 类似vue或者react中的自定义组件。
微信小程序也 允许我们使用自定义组件的方式来构建页面。
当我们在开发小程序页面时，少不了哪些重复或类似的板块，需要我们复制粘贴一份源码进行编写，而组件恰恰解决了这个问题，它能让我们的代码复用率更高。开发更如鱼得水。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e81cd4f73d825c7ee2f7a96cfa3e39b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-11T17:05:24+08:00" />
<meta property="article:modified_time" content="2022-09-11T17:05:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【微信小程序】组件的生命周期及自定义组件</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">组件的生命周期</a></li><li><ul><li><a href="#_7" rel="nofollow">自定义组件的生命周期函数</a></li><li><ul><li><a href="#_19" rel="nofollow">执行顺序</a></li><li><a href="#_23" rel="nofollow">组件常用的生命周期函数</a></li><li><a href="#lifetimes_35" rel="nofollow">lifetimes节点</a></li></ul> 
   </li><li><a href="#_54" rel="nofollow">组件所在页面的生命周期函数</a></li><li><ul><li><a href="#pageLifetimes_65" rel="nofollow">pageLifetimes节点</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_90" rel="nofollow">自定义组件</a></li><li><ul><li><ul><li><a href="#_96" rel="nofollow">创建自定义组件</a></li><li><ul><li><a href="#_99" rel="nofollow">创建组件</a></li><li><a href="#_106" rel="nofollow">定义组件</a></li><li><a href="#_111" rel="nofollow">使用组件</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_121" rel="nofollow">父组件向子组件传递数据</a></li><li><a href="#_130" rel="nofollow">子组件向父组件传递数据</a></li><li><a href="#_146" rel="nofollow">其他定义段与示例方法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>组件的生命周期</h2> 
<p>组件的生命周期，指的是<strong>组件自身</strong>的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。<br> 其中，最重要的生命周期是 created、attached、 detached ，包含一个组件实例生命流程的最主要时间点。</p> 
<h3><a id="_7"></a>自定义组件的生命周期函数</h3> 
<p>小程序组件可用的全部生命周期如下表所示:</p> 
<table><thead><tr><th>生命周期函数</th><th>参数</th><th>描述说明</th></tr></thead><tbody><tr><td>created</td><td>无</td><td>在组件实例刚刚被创建时执行</td></tr><tr><td>attached</td><td>无</td><td>在组件实例进入页面节点树时执行</td></tr><tr><td>ready</td><td>无</td><td>在组件在视图层布局完成后执行</td></tr><tr><td>moved</td><td>无</td><td>在组件实例被移动到节点树另一个位置时执行</td></tr><tr><td>detached</td><td>无</td><td>在组件实例被从页面节点树移除时执行</td></tr><tr><td>error</td><td>Object Error</td><td>每当组件方法抛出错误时执行</td></tr></tbody></table> 
<h4><a id="_19"></a>执行顺序</h4> 
<p><img src="https://images2.imgbox.com/24/3f/8jlqnn5R_o.png" alt="在这里插入图片描述"></p> 
<p>从该图中可以看出组件的 ready 与 detached 执行顺序并没有明确的先后关系。</p> 
<h4><a id="_23"></a>组件常用的生命周期函数</h4> 
<p>在小程序组件中，最重要的生命周期函数有3个，分别是<code>created</code>、<code>attached</code>.<br> <code>detached</code>。它们各自的特点。如下︰</p> 
<ul><li>组件实例刚被创建好的时候，<mark>created</mark>生命周期函数会被触发<br> 此时还不能调用setData，通常在这个生命周期函数中，只应该用于给组件的this添加一些自定义的属性字段在组件</li><li>完全初始化完毕、进入页面节点树后，<mark>attached</mark>生命周期函数会被触发<br> 此时, this.data已被初始化完毕。这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据)</li><li>在组件离开页面节点树后，<mark>detached</mark>生命周期函数会被触发<br> 退出一个页面时，会触发页面内每个自定义组件的detached生命周期函数此时适合做一些清理性质的工作</li></ul> 
<h4><a id="lifetimes_35"></a>lifetimes节点</h4> 
<p>在小程序组件中，生命周期函数可以直接定义在<strong>Component构造器</strong>的第一级参数中，可以在 lifetimes字段内进行声明（这是推荐的方式，其优先级最高）。如下:</p> 
<pre><code class="prism language-javascript"><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
	<span class="token literal-property property">lifetimes</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
	   <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'created'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	   <span class="token punctuation">}</span><span class="token punctuation">,</span>
	   <span class="token function">attached</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	       console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'attached'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	   <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre> 
<p>注意：若不写在lifetime节点中且同时存在lifetime节点，优先执行lifetime节点中的生命周期函数，并覆盖掉节点之外的生命周期函数。</p> 
<h3><a id="_54"></a>组件所在页面的生命周期函数</h3> 
<p>有时，自定义组件的行为依赖于页面状态的变化，此时就需要用到组件所在页面的生命周期。<br> 在自定义组件中，组件所在页面的生命周期函数有如下3个，分别是:</p> 
<table><thead><tr><th>生命周期函数</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>show</td><td>无</td><td>组件所在的页面被展示时执行</td></tr><tr><td>hide</td><td>无</td><td>组件所在的页面被隐藏时执行</td></tr><tr><td>resize</td><td>object Size</td><td>组件所在的页面尺寸变化时执行</td></tr></tbody></table> 
<h4><a id="pageLifetimes_65"></a>pageLifetimes节点</h4> 
<p>组件所在页面的生命周期函数，需要定义在<strong>pageLifetimes</strong>节点中，如下:</p> 
<pre><code class="prism language-javascript"><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span>
	<span class="token literal-property property">pageLifetimes</span><span class="token operator">:</span><span class="token punctuation">{<!-- --></span>
      	<span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"show!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hide!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"resize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>						
   <span class="token punctuation">}</span>				
<span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre> 
<p>当页面显示和隐藏时触发<br> <img src="https://images2.imgbox.com/81/ef/Ja47rL6v_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_90"></a>自定义组件</h2> 
<p>类似vue或者react中的自定义组件。<br> 微信小程序也 允许我们使用自定义组件的方式来构建页面。</p> 
<p>当我们在开发小程序页面时，少不了哪些重复或类似的板块，需要我们复制粘贴一份源码进行编写，而组件恰恰解决了这个问题，它能让我们的代码复用率更高。开发更如鱼得水。</p> 
<h4><a id="_96"></a>创建自定义组件</h4> 
<p>类似于页面，一个自定义组件由 <code>.json</code> <code>.wxml</code> <code>.wxss</code> <code>.js</code> 4个文件组成。</p> 
<h5><a id="_99"></a>创建组件</h5> 
<p>可以在微信开发者工具中快速创建组件的文件结构。如图<br> <img src="https://images2.imgbox.com/04/5b/apD3IbFl_o.png" alt="在这里插入图片描述"><br> 创建好之后，便出现四个文件：如图<br> <img src="https://images2.imgbox.com/15/e6/hSZcXdZq_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_106"></a>定义组件</h5> 
<p>此时我们新建一个页面-demo，在demo.json中可以使用刚才我们创建好的组件。<br> <img src="https://images2.imgbox.com/f0/29/eF01zQIk_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_111"></a>使用组件</h5> 
<p>首先让效果更明显，我们在组件的wxml文件中写入一些东西：<br> <img src="https://images2.imgbox.com/f8/61/efcGSjRH_o.png" alt="在这里插入图片描述"><br> 之后我们在页面demo.wxml中使用我们的组件：<br> <img src="https://images2.imgbox.com/41/28/RPFts4Od_o.png" alt="在这里插入图片描述"></p> 
<p>出现如上效果则说明我们声明的组件已经被使用了</p> 
<h3><a id="_121"></a>父组件向子组件传递数据</h3> 
<ol><li> <p>父组件(页面)向子组件传递数据通过标签属性的方式来传递<br> <img src="https://images2.imgbox.com/92/d0/vZytDgks_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在子组件的.js文件上进行接收<br> <img src="https://images2.imgbox.com/57/34/hL3bmjvJ_o.png" alt="在这里插入图片描述"><br> 注意：若父组件给子组件不传值时则使用value中定义的值。</p> </li><li> <p>在SuHeader.wxml中接收数据即可<br> <img src="https://images2.imgbox.com/6a/22/mwU9dguk_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<h3><a id="_130"></a>子组件向父组件传递数据</h3> 
<ol><li> <p>给地址绑定鼠标单击事件<br> <img src="https://images2.imgbox.com/7a/35/l4wNaO0l_o.png" alt="在这里插入图片描述"></p> </li><li> <p>当单击事件被触发。给通过<code>this.triggerEvent</code>绑定父组件的自定义事件并且给父组件传递数据<br> <img src="https://images2.imgbox.com/c5/4a/Ipri3bNa_o.png" alt="在这里插入图片描述"></p> </li><li> <p>父组件的自定义事件<br> <img src="https://images2.imgbox.com/17/25/4Sn0hsfN_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在demo.js文件中触发父组件的自定义事件，注意与data配置项平级。<br> <img src="https://images2.imgbox.com/d4/a7/mCueALSg_o.png" alt="在这里插入图片描述"></p> </li><li> <p>触发单击响应事件<br> <img src="https://images2.imgbox.com/e1/db/CzSgJrhz_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<h3><a id="_146"></a>其他定义段与示例方法</h3> 
<table><thead><tr><th>定义段</th><th>类型</th><th>是否必填</th><th>描述</th></tr></thead><tbody><tr><td>properties</td><td>object Map</td><td>否</td><td>组件的对外属性，是属性名到属性设置的映射表</td></tr><tr><td>data</td><td>object</td><td>否</td><td>组件的内部数据，和 properties一同用于模板渲染</td></tr><tr><td>observers</td><td>object</td><td>否</td><td>组件数据字段监听器，用于监听 properties和data的变化</td></tr><tr><td>methods</td><td>object</td><td>否</td><td>组件的方法，包括事件响应函数和任意的自定义方法</td></tr><tr><td>created</td><td>function</td><td>否</td><td>组件生命周期函数，在组件实例刚刚被创建时执行，注意此时不能调用setDat</td></tr><tr><td>attached</td><td>function</td><td>否</td><td>组件生念周期函数，在组件实例进入页面节点树时执行</td></tr><tr><td>ready</td><td>Function</td><td>否</td><td>组件生命周期函数，在组件布局完成后执行</td></tr><tr><td>moved</td><td>Function</td><td>否</td><td>组件生命周期函数，在组件实例被移动到节点树另一个位置时执行</td></tr><tr><td>detached</td><td>Function</td><td>否</td><td>组件生命周期函数，在组件实例被从页面节点树移除时执行</td></tr></tbody></table> 
<p>详情可见官方文档：<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html" rel="nofollow">Component(Object object)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f7194625e858742299c1d1837eb43de9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">TypeError: __init__() takes 1 positional argument but 2 were given</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88882ddef885e15f568ae7a3c900d6fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NNDL 实验二 pytorch入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>