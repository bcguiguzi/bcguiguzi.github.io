<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RSA签名和验签说明 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RSA签名和验签说明" />
<meta property="og:description" content="最近遇到一个项目，需要进行RSA的验签，RSA的密钥为2048位即256个字节长。
上游是先对一个文件进行SHA256做hash，得到32字节的摘要，然后进行填充，填充规则为前面两个字节为0x00,0x01，然后填充全FF，接下来是32字节的摘要数据，这样填充之后的总数据长度为256字节，然后使用RSA的私钥对这256字节进行签名，下发下来，下游需要对这个签名进行处理，得到原始摘要，然后跟自己计算的摘要比对，验证通过则合法。
涉及的知识点如下：
一、RSA签名算法的填充方式，常用的有如下三种
1、RSA/ECB/PKCS1Padding 填充模式，最常用的模式
要求:
输入：必须 比 RSA 密钥长度 短至少11个字节, 否则会报错，数据不足时由接口自动进行随机填充
如果输入的明文过长，必须切割，　然后填充
输出：和RSA密钥长度一样长
根据这个要求，对于2048bit的密钥，　block length = 2048/8 – 11 = 245字节
注意：加密的时候会在你的明文中随机填充一些数据，所以会导致对同样的明文每次加密后的结果都不一样。
对加密后的密文，服务器使用相同的填充方式都能解密。解密后的明文也就是之前加密的明文。
如果是私钥签名，那么填充的前面两个字节为0x00和0x01(表示私钥签名)，如果是公钥签名，那么填充的签名的两个字节为0x00和0x02(表示公钥签名)，然后填充全FF，在填充最后的有效数据之前，会填充一个00，然后后面就全部是有效数据，所以使用RSA签名的数据再解密之后得到的数据在真是数据之前一定有00，否则就是输入没有严格遵守RSA/ECB/PKCS1Padding填充方式
2.RSA_PKCS1_OAEP_PADDING
输入：必须 比 RSA 密钥长度 短至少41个字节, 否则会报错，数据不足时由接口自动进行随机填充
输出：和RSA密钥长度一样长
3.RSA/ECB/NoPadding　不填充
输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充，这种方式需要自己手动进行填充好输入数据
输出：和RSA密钥长度一样长
跟DES，AES一样，　RSA也是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。
但跟AES等不同的是，　block length是跟key length有关的。
每次RSA加密的明文的长度是受RSA填充模式限制的，但是RSA每次加密的块长度就是密钥长度
具体代码片段如下：
/**
* RSA签名
* * @param key RSA的密钥 公钥用X.509编码；私钥用PKCS#8编码
* @param data 输入数据
* @param mode 0-加密，1-解密
* @param type 0-私钥加密，公钥解密 1-公钥加密，私钥解密" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/64114c9884e2995253394db3d7abc29b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-08T10:08:35+08:00" />
<meta property="article:modified_time" content="2020-09-08T10:08:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RSA签名和验签说明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近遇到一个项目，需要进行RSA的验签，RSA的密钥为2048位即256个字节长。</p> 
<p>上游是先对一个文件进行SHA256做hash，得到32字节的摘要，然后进行填充，填充规则为前面两个字节为0x00,0x01，然后填充全FF，接下来是32字节的摘要数据，这样填充之后的总数据长度为256字节，然后使用RSA的私钥对这256字节进行签名，下发下来，下游需要对这个签名进行处理，得到原始摘要，然后跟自己计算的摘要比对，验证通过则合法。</p> 
<p>涉及的知识点如下：</p> 
<p>一、RSA签名算法的填充方式，常用的有如下三种</p> 
<p>1、RSA/ECB/PKCS1Padding 填充模式，最常用的模式</p> 
<p>要求:<br> 输入：必须 比 RSA 密钥长度 短至少11个字节, 否则会报错，数据不足时由接口自动进行随机填充<br> 如果输入的明文过长，必须切割，　然后填充</p> 
<p>输出：和RSA密钥长度一样长</p> 
<p>根据这个要求，对于2048bit的密钥，　block length = 2048/8 – 11 = 245字节</p> 
<p>注意：加密的时候会在你的明文中随机填充一些数据，所以会导致对同样的明文每次加密后的结果都不一样。</p> 
<p>对加密后的密文，服务器使用相同的填充方式都能解密。解密后的明文也就是之前加密的明文。</p> 
<p>如果是私钥签名，那么填充的前面两个字节为0x00和0x01(表示私钥签名)，如果是公钥签名，那么填充的签名的两个字节为0x00和0x02(表示公钥签名)，然后填充全FF，在填充最后的有效数据之前，会填充一个00，然后后面就全部是有效数据，所以使用RSA签名的数据再解密之后得到的数据在真是数据之前一定有00，否则就是输入没有严格遵守RSA/ECB/PKCS1Padding填充方式</p> 
<p>2.RSA_PKCS1_OAEP_PADDING<br> 输入：必须 比 RSA 密钥长度 短至少41个字节, 否则会报错，数据不足时由接口自动进行随机填充</p> 
<p>输出：和RSA密钥长度一样长</p> 
<p>3.RSA/ECB/NoPadding　　不填充</p> 
<p>输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充，这种方式需要自己手动进行填充好输入数据</p> 
<p>输出：和RSA密钥长度一样长</p> 
<p>跟DES，AES一样，　RSA也是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。</p> 
<p>但跟AES等不同的是，　block length是跟key length有关的。</p> 
<p>每次RSA加密的明文的长度是受RSA填充模式限制的，但是RSA每次加密的块长度就是密钥长度</p> 
<p> </p> 
<p>具体代码片段如下：</p> 
<p>/**<br>      * RSA签名<br>      * <br>      * @param key RSA的密钥 公钥用X.509编码；私钥用PKCS#8编码<br>      * @param data 输入数据<br>      * @param mode 0-加密，1-解密<br>      * @param type 0-私钥加密，公钥解密 1-公钥加密，私钥解密<br>      * @return 签名后的数据 为null表示操作失败<br>      */<br>     public static String generateRSA(String key, String data, int mode, int type) {<!-- --><br>         try {<!-- --><br>             // 判断加密还是解密<br>             int opmode = (mode == 0) ? Cipher.ENCRYPT_MODE<br>                     : Cipher.DECRYPT_MODE;</p> 
<p>            KeyFactory keyFactory = KeyFactory.getInstance("RSA");</p> 
<p>            Key strkey = null;<br>             if (mode != type) { // 生成公钥<br>                 KeySpec keySpec = new X509EncodedKeySpec(<br>                         Base64.decodeBase64(key)); // X.509编码<br>                 strkey = keyFactory.generatePublic(keySpec);<br>             } else { // 生成私钥<br>                 KeySpec keySpec = new PKCS8EncodedKeySpec(<br>                         Base64.decodeBase64(key)); // PKCS#8编码<br>                 strkey = keyFactory.generatePrivate(keySpec);<br>             }</p> 
<p>            // 获得一个RSA的Cipher类，使用私钥加密<br>             // RSA/ECB/NoPadding表示无填充，待加密数据长度必须跟密钥长度一致，填充需要自己完成<br>             // RSA/ECB/PKCS1Padding表示PKCS#1填充，前面填充0x00,0x01(私钥加密，公钥加密是02)，然后填充0xFF，在数据之前再填充一个0x00，接下来是真正传入的数据，待加密数据需要小于密钥数据-11，这个是自动填充<br>             Cipher cipher = Cipher.getInstance("RSA/ECB/NoPadding"); // ,<br>             // 初始化<br>             cipher.init(opmode, strkey);<br>             byte[] byteData = str2bytes(data);<br>             System.out.println("generateRSA doFinal字节长度为： " + byteData.length);<br>             // 返回加解密结果<br>             return (bytesToHexString(cipher.doFinal(byteData)))<br>                     .toUpperCase(Locale.getDefault());// 开始计算<br>         } catch (Exception e) {<!-- --><br>             e.printStackTrace();<br>             System.out.println(e.getMessage());<br>         }<br>         return null;<br>     }</p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96148b825bc7d34198c6ed57346d1526/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">PyQt5之信号与槽介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/06589287a709bdd70316365df5f44b8c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Elsevier 期刊模板</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>