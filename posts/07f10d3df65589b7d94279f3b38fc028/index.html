<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue配置项---watch的使用 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue配置项---watch的使用" />
<meta property="og:description" content="watch有四种常用用法 情况一：基础监听，比如监听data中定义的某个数据。 data() { return { msg: &#34;hello&#34;, }; }, watch: { msg(newmsg, oldmsg) { console.log(newmsg); }, }, 直接写一个监听处理函数，默认参数第一个是新值，第二个是旧值。每次监听到msg变化都会执行这个函数。
情况二：使用handle方法immediate与deep属性。 data() { return { msg: { name: &#34;liu&#34;, age: &#34;18&#34;, }, }; }, watch: { msg: { handler(newmsg, oldmsg) { console.log(newmsg); }, immediate: true, deep: true, }, } 一般情况下，在数据第一次绑定时不会执行监听函数，只有当值变化时才会执行监听函数。此时将immediate设置为true可以实现首次监听。
当监听对象的改变时普通的watch方法无法监听对象内部属性的变化，需要设置deep属性，开启深度监听deep为true时则改对象中的所有属性都会被监听，对象中每个属性改变都会执行handler函数。如果只想监听对象中某个属性的变化可以用如下写法...（情况三）
情况三：只监听对象中的某个属性 data() { return { msg: { name: &#34;liu&#34;, age: &#34;18&#34;, }, }; }, watch: { &#34;msg.name&#34;: { //键路径必须加上引号 handler(newmsg, oldmsg) { console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/07f10d3df65589b7d94279f3b38fc028/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-10T15:13:35+08:00" />
<meta property="article:modified_time" content="2022-08-10T15:13:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue配置项---watch的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="watch%E6%9C%89%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%86%99%E6%B3%95">watch有四种常用用法</h2> 
<h4 id="%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9B%91%E5%90%AC"><span style="color:#ff9900;">情况一</span>：基础监听，比如监听data中定义的某个数据。</h4> 
<pre><code class="language-javascript">    data() {
        return {
            msg: "hello",
        };
    },
    watch: {
        msg(newmsg, oldmsg) {
            console.log(newmsg);
        },
    },</code></pre> 
<blockquote> 
 <p>直接写一个监听处理函数，默认参数第一个是新值，第二个是旧值。每次监听到msg变化都会执行这个函数。</p> 
</blockquote> 
<p></p> 
<h4><span style="color:#ff9900;">情况二</span>：使用handle方法immediate与deep属性。</h4> 
<pre><code class="language-javascript">    data() {
        return {
            msg: {
                name: "liu",
                age: "18",
            },
        };
    },
    watch: {
        msg: {
            handler(newmsg, oldmsg) {
                console.log(newmsg);
            },
            immediate: true,
            deep: true,
        },
    }</code></pre> 
<blockquote> 
 <p>    一般情况下，在数据第一次绑定时不会执行监听函数，只有当值变化时才会执行监听函数。此时将immediate设置为true可以实现首次监听。</p> 
 <p>    当监听对象的改变时普通的watch方法无法监听对象内部属性的变化，需要设置deep属性，开启深度监听deep为true时则改对象中的所有属性都会被监听，对象中每个属性改变都会执行handler函数。如果只想监听对象中某个属性的变化可以用如下写法...（情况三）</p> 
</blockquote> 
<h4><span style="color:#ff9900;">情况三：</span>只监听对象中的某个属性</h4> 
<pre><code class="language-javascript">    data() {
        return {
            msg: {
                name: "liu",
                age: "18",
            },
        };
    },
    watch: {
        "msg.name": {   //键路径必须加上引号
            handler(newmsg, oldmsg) {
                console.log(newmsg);
            },
            immediate: true,
            deep: true,
        },
    },</code></pre> 
<p>也可以使用函数的形式</p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/3e/42/KbNAMW7u_o.png" width="666"></p> 
<h4><span style="color:#ff9900;"> 情况四：</span>监听路由变化</h4> 
<pre><code class="language-javascript">    watch: {
        $route(to, from) {
            var toName = to.name;
            var toIndex = to.meta.index;
            var fromIndex = from.meta.index;
            this.transitionName = toIndex &lt; fromIndex ? "slide-right" : "slide-left";
        },
    },</code></pre> 
<blockquote> 
 <p>监听路由$route有两个默认参数，to、form</p> 
 <p>to：存放跳转后改变的数据</p> 
 <p>form：跳转前的数据</p> 
</blockquote> 
<p>举个例子：</p> 
<p>这里我携带了query参数分别是 categoryName="图书、音像、电子书刊" category1Id=1</p> 
<p><img alt="" src="https://images2.imgbox.com/d5/c9/DMC8q9HM_o.png"> 那么我开始跳转到如果我携带的query参数发生改变是否能触发watch的监视呢</p> 
<p><img alt="" src="https://images2.imgbox.com/76/d6/JZpgDwRj_o.png"> 让我们证明一下</p> 
<p>我的query参数已经修改了，那么控制台一定会输出to和from</p> 
<p>我们由控制台可以看出</p> 
<p>to里面的这个query是我们跳转过后的query参数</p> 
<p>而from里面的query是上一个的query参数</p> 
<p><img alt="" src="https://images2.imgbox.com/92/d0/D4Dlgnru_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2cc9f19e96370b8df74e6bc508b89116/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数字信号处理笔记01：离散时间信号与系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f5b8509824120f4bfde166aa1f1c0fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vuex中的...mapState与...mapMutations的使用以及mapGetters存在的意义</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>