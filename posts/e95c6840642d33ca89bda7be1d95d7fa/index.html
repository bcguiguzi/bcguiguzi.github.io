<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>matlab 取图像一部分 微分算子,Matlab实现：图像边缘提取 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="matlab 取图像一部分 微分算子,Matlab实现：图像边缘提取" />
<meta property="og:description" content="1、 边缘提取算法
方法一：一阶微分算子
Sobel算子
Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，Sobel算子对边缘定位不是很准确，图像的边缘不止一个像素。
Roberts算子
Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确。
Prewitt算子
Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多。
Canny算子
Canny算子是目前边缘检测最常用的算法，效果也是最理想的。
Canny边缘检测算法不是简单的模板卷积而已，通过梯度方向和双阈值法来检测边缘点，具体算法可以参考：http://www.cnblogs.com/AndyJee/p/3734805.html；
Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。
方法二：二阶微分算子
Laplacian算子
Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区。
2、 实验结果分析
一、边缘提取：
Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，sobel算子对边缘定位不是很准确，图像的边缘不止一个像素；
Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确；
Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多；
Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区；
Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。
二、边缘复合增强
Sobel、Robert、Prewitt算子的增强效果并不是很明显，尤其是Robert算子，因为它提取的边缘点过于稀疏和离散；
Laplacian算子和canny算子的增强效果都比较理想，
将边缘叠加上去后，整个手的轮廓和边缘都很清晰，直观上看，canny算子实现的效果比Laplacian算子好，最明显的地方就是手指尖的边缘。
3、程序实现
下面的程序就实现上面效果的完整Matlab代码：
clear;clc;
I=imread(‘x1.tif‘);
% I=rgb2gray(I);
% gray transform
J=imadjust(I,[0.1 0.9],[0 1],1);
% Edge detection
% Sobel
BW1=edge(I,‘sobel‘);
sobelBW1=im2uint8(BW1)&#43;J;
figure;
%imshow(BW1);
subplot(1,2,1);
imshow(J);
title(‘original image‘);
subplot(1,2,2);
imshow(sobelBW1);
title(‘Sobel augmented image‘);
% Roberts
BW2=edge(I,‘roberts‘);
robertBW2=im2uint8(BW2)&#43;J;
figure;
%imshow(BW2);
subplot(1,2,1);
imshow(J);
title(‘original image‘);
subplot(1,2,2);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/e95c6840642d33ca89bda7be1d95d7fa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-17T18:42:29+08:00" />
<meta property="article:modified_time" content="2021-03-17T18:42:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">matlab 取图像一部分 微分算子,Matlab实现：图像边缘提取</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>1、 边缘提取算法</p> 
 <p>方法一：一阶微分算子</p> 
 <p>Sobel算子</p> 
 <p align="center"><img src="https://images2.imgbox.com/f7/c8/8gjedsUp_o.png" alt="20180930151531018643.png"></p> 
 <p>Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，Sobel算子对边缘定位不是很准确，图像的边缘不止一个像素。</p> 
 <p align="center"><img src="https://images2.imgbox.com/b3/d0/jCjl1Yb0_o.jpg" alt="20180930151531299904.jpg"></p> 
 <p align="center"><img src="https://images2.imgbox.com/50/46/xSUtkXCF_o.jpg" alt="20180930151531592884.jpg"></p> 
 <p>Roberts算子</p> 
 <p align="center"><img src="https://images2.imgbox.com/0f/01/c4wABCRo_o.png" alt="20180930151531911256.png"></p> 
 <p>Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确。</p> 
 <p align="center"><img src="https://images2.imgbox.com/6c/e9/SmcZtFad_o.jpg" alt="20180930151532178844.jpg"></p> 
 <p align="center"><img src="https://images2.imgbox.com/7f/af/BPXCP9Vg_o.jpg" alt="20180930151532258925.jpg"></p> 
 <p>Prewitt算子</p> 
 <p align="center"><img src="https://images2.imgbox.com/1f/a1/yuOXkBVt_o.png" alt="20180930151533633001.png"></p> 
 <p>Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多。</p> 
 <p align="center"><img src="https://images2.imgbox.com/7f/11/CVqYL1t6_o.jpg" alt="20180930151534765857.jpg"></p> 
 <p align="center"><img src="https://images2.imgbox.com/a9/98/PFGzryKb_o.jpg" alt="20180930151534810781.jpg"></p> 
 <p>Canny算子</p> 
 <p>Canny算子是目前边缘检测最常用的算法，效果也是最理想的。</p> 
 <p>Canny边缘检测算法不是简单的模板卷积而已，通过梯度方向和双阈值法来检测边缘点，具体算法可以参考：http://www.cnblogs.com/AndyJee/p/3734805.html；</p> 
 <p>Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。</p> 
 <p align="center"><img src="https://images2.imgbox.com/db/fc/GcCAECjB_o.jpg" alt="20180930151535133059.jpg"></p> 
 <p align="center"><img src="https://images2.imgbox.com/70/3a/AyEoyd5I_o.jpg" alt="20180930151535461197.jpg"></p> 
 <p>方法二：二阶微分算子</p> 
 <p>Laplacian算子</p> 
 <p align="center"><img src="https://images2.imgbox.com/9c/c5/3sN14oUe_o.png" alt="20180930151535594014.png"><img src="https://images2.imgbox.com/c2/5c/z4GOdfCE_o.png" alt="20180930151535845977.png"></p> 
 <p>Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区。</p> 
 <p align="center"><img src="https://images2.imgbox.com/a4/4e/b5WIphpk_o.jpg" alt="20180930151535924105.jpg"></p> 
 <p align="center"><img src="https://images2.imgbox.com/dc/5d/CYlrTSdr_o.jpg" alt="20180930151536208296.jpg"></p> 
 <p>2、 实验结果分析</p> 
 <p>一、边缘提取：</p> 
 <p align="center"><img src="https://images2.imgbox.com/45/a6/QpF3FTvN_o.jpg" alt="20180930151536662415.jpg"></p> 
 <p>Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，sobel算子对边缘定位不是很准确，图像的边缘不止一个像素；</p> 
 <p>Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确；</p> 
 <p>Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多；</p> 
 <p>Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区；</p> 
 <p>Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。</p> 
 <p>二、边缘复合增强</p> 
 <p align="center"><img src="https://images2.imgbox.com/71/2c/y2vid9zA_o.jpg" alt="20180930151537019850.jpg"></p> 
 <p>Sobel、Robert、Prewitt算子的增强效果并不是很明显，尤其是Robert算子，因为它提取的边缘点过于稀疏和离散；</p> 
 <p>Laplacian算子和canny算子的增强效果都比较理想，</p> 
 <p>将边缘叠加上去后，整个手的轮廓和边缘都很清晰，直观上看，canny算子实现的效果比Laplacian算子好，最明显的地方就是手指尖的边缘。</p> 
 <p>3、程序实现</p> 
 <p>下面的程序就实现上面效果的完整Matlab代码：</p> 
 <p align="center"><img src="https://images2.imgbox.com/df/ac/0r1z49kS_o.gif" alt="fcecaa27ea5212ceb9bf034c36bfbf34.gif">clear;clc;</p> 
 <p>I=imread(‘x1.tif‘);</p> 
 <p>% I=rgb2gray(I);</p> 
 <p>% gray transform</p> 
 <p>J=imadjust(I,[0.1 0.9],[0 1],1);</p> 
 <p>% Edge detection</p> 
 <p>% Sobel</p> 
 <p>BW1=edge(I,‘sobel‘);</p> 
 <p>sobelBW1=im2uint8(BW1)+J;</p> 
 <p>figure;</p> 
 <p>%imshow(BW1);</p> 
 <p>subplot(1,2,1);</p> 
 <p>imshow(J);</p> 
 <p>title(‘original image‘);</p> 
 <p>subplot(1,2,2);</p> 
 <p>imshow(sobelBW1);</p> 
 <p>title(‘Sobel augmented image‘);</p> 
 <p>% Roberts</p> 
 <p>BW2=edge(I,‘roberts‘);</p> 
 <p>robertBW2=im2uint8(BW2)+J;</p> 
 <p>figure;</p> 
 <p>%imshow(BW2);</p> 
 <p>subplot(1,2,1);</p> 
 <p>imshow(J);</p> 
 <p>title(‘original image‘);</p> 
 <p>subplot(1,2,2);</p> 
 <p>imshow(robertBW2);</p> 
 <p>title(‘robert augmented image‘);</p> 
 <p>% prewitt</p> 
 <p>BW3=edge(I,‘prewitt‘);</p> 
 <p>prewittBW3=im2uint8(BW3)+J;</p> 
 <p>figure;</p> 
 <p>%imshow(BW3);</p> 
 <p>subplot(1,2,1);</p> 
 <p>imshow(J);</p> 
 <p>title(‘original image‘);</p> 
 <p>subplot(1,2,2);</p> 
 <p>imshow(prewittBW3);</p> 
 <p>title(‘Prewitt augmented image‘);</p> 
 <p>% log</p> 
 <p>BW4=edge(I,‘log‘);</p> 
 <p>logBW4=im2uint8(BW4)+J;</p> 
 <p>figure;</p> 
 <p>%imshow(BW4);</p> 
 <p>subplot(1,2,1);</p> 
 <p>imshow(J);</p> 
 <p>title(‘original image‘);</p> 
 <p>subplot(1,2,2);</p> 
 <p>imshow(logBW4);</p> 
 <p>title(‘Laplacian augmented image‘);</p> 
 <p>% canny</p> 
 <p>BW5=edge(I,‘canny‘);</p> 
 <p>cannyBW5=im2uint8(BW5)+J;</p> 
 <p>figure;</p> 
 <p>%imshow(BW5);</p> 
 <p>subplot(1,2,1);</p> 
 <p>imshow(J);</p> 
 <p>title(‘original image‘);</p> 
 <p>subplot(1,2,2);</p> 
 <p>imshow(cannyBW5);</p> 
 <p>title(‘Canny augmented image‘);</p> 
 <p>% gaussian &amp; canny</p> 
 <p>% h=fspecial(‘gaussian‘,5);</p> 
 <p>% fI=imfilter(I,h,‘replicate‘);</p> 
 <p>% BW6=edge(fI,‘canny‘);</p> 
 <p>% figure;</p> 
 <p>% imshow(BW6);</p> 
 <p>figure;</p> 
 <p>subplot(2,3,1), imshow(BW1);</p> 
 <p>title(‘sobel edge detect‘);</p> 
 <p>subplot(2,3,2), imshow(BW2);</p> 
 <p>title(‘roberts edge detect‘);</p> 
 <p>subplot(2,3,3), imshow(BW3);</p> 
 <p>title(‘prewitt edge detect‘);</p> 
 <p>subplot(2,3,4), imshow(BW4);</p> 
 <p>title(‘log edge detect‘);</p> 
 <p>subplot(2,3,5), imshow(BW5);</p> 
 <p>title(‘canny edge detect‘);</p> 
 <p>% subplot(2,3,6), imshow(BW6);</p> 
 <p>% title(‘gasussian&amp;cannyedge detect‘);</p> 
 <p>figure;</p> 
 <p>subplot(2,3,1), imshow(sobelBW1);</p> 
 <p>title(‘sobel edge detect‘);</p> 
 <p>subplot(2,3,2), imshow(robertBW2);</p> 
 <p>title(‘roberts edge detect‘);</p> 
 <p>subplot(2,3,3), imshow(prewittBW3);</p> 
 <p>title(‘prewitt edge detect‘);</p> 
 <p>subplot(2,3,4), imshow(logBW4);</p> 
 <p>title(‘laplacian edge detect‘);</p> 
 <p>subplot(2,3,5), imshow(cannyBW5);</p> 
 <p>title(‘canny edge detect‘);</p> 
 <p align="center"><img src="https://images2.imgbox.com/a2/77/tsJx4q8e_o.gif" alt="fcecaa27ea5212ceb9bf034c36bfbf34.gif"></p> 
 <p>下面的Matlab程序是精简的边缘提取实现：</p> 
 <p align="center"><img src="https://images2.imgbox.com/32/87/ecNnQsIj_o.gif" alt="fcecaa27ea5212ceb9bf034c36bfbf34.gif">clear;clc;</p> 
 <p>I=imread(‘lena.bmp‘);</p> 
 <p>I=rgb2gray(I);</p> 
 <p>imshow(I,[]);</p> 
 <p>title(‘Original Image‘);</p> 
 <p>sobelBW=edge(I,‘sobel‘);</p> 
 <p>figure;</p> 
 <p>imshow(sobelBW);</p> 
 <p>title(‘Sobel Edge‘);</p> 
 <p>robertsBW=edge(I,‘roberts‘);</p> 
 <p>figure;</p> 
 <p>imshow(robertsBW);</p> 
 <p>title(‘Roberts Edge‘);</p> 
 <p>prewittBW=edge(I,‘prewitt‘);</p> 
 <p>figure;</p> 
 <p>imshow(prewittBW);</p> 
 <p>title(‘Prewitt Edge‘);</p> 
 <p>logBW=edge(I,‘log‘);</p> 
 <p>figure;</p> 
 <p>imshow(logBW);</p> 
 <p>title(‘Laplasian of Gaussian Edge‘);</p> 
 <p>cannyBW=edge(I,‘canny‘);</p> 
 <p>figure;</p> 
 <p>imshow(cannyBW);</p> 
 <p>title(‘Canny Edge‘);</p> 
 <p align="center"><img src="https://images2.imgbox.com/3b/cd/3aF0p1SZ_o.gif" alt="fcecaa27ea5212ceb9bf034c36bfbf34.gif"></p> 
 <p>原文：http://www.cnblogs.com/AndyJee/p/3737325.html</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8488bd61345032a9224ef8d7e2c6d63e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小程序根据经纬度计算两点之间的距离km</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4711ccf6c6ae1243149acb8385d5f23f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Codeforces Round #653 (Div. 3) E1. Reading Books (easy version)（思维）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>