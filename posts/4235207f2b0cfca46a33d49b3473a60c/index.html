<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mysql 数据仓库 元数据_002.hive数据仓库建模和元数据备份 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mysql 数据仓库 元数据_002.hive数据仓库建模和元数据备份" />
<meta property="og:description" content="1.数据建模
装逼的解释：
是指 对现实世界各类数据的抽象组合，确定数据库需管辖的范围、数据的组织形式等直至转化成现实的数据库。
通俗的说：
1.概念建模阶段： 就是对业务的梳理和理解(1.客户交流 2.需求理解 3.形成实体)
2.逻辑建模阶段： 对实体进行细化，细化成具体的表，同时丰富表结构(表／列／索引／约束／视图／存储过程 等等)
3.物理建模阶段： 对逻辑建模建模阶段的各种数据库对象 生成 相应的SQL代码，运行来创建相应具体数据库对象。
2.多维数据模型的模式
这个的确需要很丰富的经验，对于我来说这个仅仅只是局限在大致了解。
1.星型
一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度，所以数据有一定的冗余。
￼ 2.雪花型
雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的 &#34;层次 &#34; 区域，这些被分解的表都连接到主维度表而不是事实表，通过最大限度地减少数据存储量以及联合较小的维表来改善查询性能。雪花型结构去除了数据冗余。
￼ 3.事实星座
又称星系模式，复杂的应用可能需要多个事实表共享维表。这种模式可以看作星形模式集。
￼ 3.元数据：MetaStore
1.相关概念
元数据服务组件，这个组件存储hive的元数据，hive的元数据存储在关系数据库里，hive支持的关系数据库有derby、mysql。元数据对于hive十分重要，因此hive支持把metastore服务独立出来，安装到远程的服务器集群里，从而解耦hive服务和metastore服务，保证hive运行的健壮性。
2.表介绍
￼ 其中主要涉及到的表如下：
表名
说明
关联键
TBLS
所有hive表的基本信息(表名，创建时间，所属者等)
TBL_ID,SD_ID
TABLE_PARAM
表级属性，(如是否外部表，表注释，最后修改时间等)
TBL_ID
COLUMNS
Hive表字段信息(字段注释，字段名，字段类型，字段序号)
SD_ID
SDS
所有hive表、表分区所对应的hdfs数据目录和数据格式
SD_ID,SERDE_ID
SERDE_PARAM
序列化反序列化信息，如行分隔符、列分隔符、NULL的表示字符等
SERDE_ID
PARTITIONS
Hive表分区信息(所属表，分区值)
PART_ID,SD_ID,TBL_ID
PARTITION_KEYS
Hive分区表分区键(即分区字段)
TBL_ID
PARTITION_KEY_VALS
Hive表分区名(键值)
PART_ID
3.Hive 将元数据存储在 RDBMS 中，有三种模式可以连接到数据库
1.Single User Mode： 此模式连接到一个 In-memory 的数据库 Derby，一般用于 Unit Test。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4235207f2b0cfca46a33d49b3473a60c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-07T18:39:43+08:00" />
<meta property="article:modified_time" content="2021-02-07T18:39:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mysql 数据仓库 元数据_002.hive数据仓库建模和元数据备份</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>1.数据建模</p> 
 <p>装逼的解释：</p> 
 <p>是指 对现实世界各类数据的抽象组合，确定数据库需管辖的范围、数据的组织形式等直至转化成现实的数据库。</p> 
 <p>通俗的说：</p> 
 <p>1.概念建模阶段： 就是对业务的梳理和理解(1.客户交流 2.需求理解 3.形成实体)</p> 
 <p>2.逻辑建模阶段： 对实体进行细化，细化成具体的表，同时丰富表结构(表／列／索引／约束／视图／存储过程 等等)</p> 
 <p>3.物理建模阶段： 对逻辑建模建模阶段的各种数据库对象 生成 相应的SQL代码，运行来创建相应具体数据库对象。</p> 
 <p>2.多维数据模型的模式</p> 
 <p>这个的确需要很丰富的经验，对于我来说这个仅仅只是局限在大致了解。</p> 
 <p>1.星型</p> 
 <p>一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度，所以数据有一定的冗余。</p> 
 <p align="center"><img src="https://images2.imgbox.com/45/e4/DVxoM115_o.png" alt="8a14c8da66222aae2c12bd0c2a108b9b.png">￼ </p> 
 <p>2.雪花型</p> 
 <p>雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的 "层次 " 区域，这些被分解的表都连接到主维度表而不是事实表，通过最大限度地减少数据存储量以及联合较小的维表来改善查询性能。雪花型结构去除了数据冗余。</p> 
 <p align="center"><img src="https://images2.imgbox.com/8b/fc/pEx0JfbY_o.png" alt="d487bdefc49bd6844bb0e359609c33e6.png">￼ </p> 
 <p>3.事实星座</p> 
 <p>又称星系模式，复杂的应用可能需要多个事实表共享维表。这种模式可以看作星形模式集。</p> 
 <p align="center"><img src="https://images2.imgbox.com/d7/84/yo5yucAs_o.png" alt="bba7745ae5daef6ed7bb96785ef24eea.png">￼ </p> 
 <p>3.元数据：MetaStore</p> 
 <p>1.相关概念</p> 
 <p>元数据服务组件，这个组件存储hive的元数据，hive的元数据存储在关系数据库里，hive支持的关系数据库有derby、mysql。元数据对于hive十分重要，因此hive支持把metastore服务独立出来，安装到远程的服务器集群里，从而解耦hive服务和metastore服务，保证hive运行的健壮性。</p> 
 <p>2.表介绍</p> 
 <p align="center"><img src="https://images2.imgbox.com/8f/d8/fXRQ2jxv_o.png" alt="dcff6fad28cef24779b8ce80a24a8d14.png">￼ </p> 
 <p>其中主要涉及到的表如下：</p> 
 <p>表名</p> 
 <p>说明</p> 
 <p>关联键</p> 
 <p>TBLS</p> 
 <p>所有hive表的基本信息(表名，创建时间，所属者等)</p> 
 <p>TBL_ID,SD_ID</p> 
 <p>TABLE_PARAM</p> 
 <p>表级属性，(如是否外部表，表注释，最后修改时间等)</p> 
 <p>TBL_ID</p> 
 <p>COLUMNS</p> 
 <p>Hive表字段信息(字段注释，字段名，字段类型，字段序号)</p> 
 <p>SD_ID</p> 
 <p>SDS</p> 
 <p>所有hive表、表分区所对应的hdfs数据目录和数据格式</p> 
 <p>SD_ID,SERDE_ID</p> 
 <p>SERDE_PARAM</p> 
 <p>序列化反序列化信息，如行分隔符、列分隔符、NULL的表示字符等</p> 
 <p>SERDE_ID</p> 
 <p>PARTITIONS</p> 
 <p>Hive表分区信息(所属表，分区值)</p> 
 <p>PART_ID,SD_ID,TBL_ID</p> 
 <p>PARTITION_KEYS</p> 
 <p>Hive分区表分区键(即分区字段)</p> 
 <p>TBL_ID</p> 
 <p>PARTITION_KEY_VALS</p> 
 <p>Hive表分区名(键值)</p> 
 <p>PART_ID</p> 
 <p>3.Hive 将元数据存储在 RDBMS 中，有三种模式可以连接到数据库</p> 
 <p>1.Single User Mode： 此模式连接到一个 In-memory 的数据库 Derby，一般用于 Unit Test。</p> 
 <p align="center"><img src="https://images2.imgbox.com/29/19/OpZCoGa7_o.png" alt="edb74351bb986be92b597bdeadca68bd.png">￼ </p> 
 <p>2.Multi User Mode：通过网络连接到一个数据库中，是最经常使用到的模式。</p> 
 <p align="center"><img src="https://images2.imgbox.com/29/1d/EGV6IZGH_o.png" alt="a0a3b7f6d78339048f9e0868335f0151.png">￼ </p> 
 <p>3.Remote Server Mode：用于非 Java 客户端访问元数据库，在服务器端启动一个 MetaStoreServer，客户端利用 Thrift 协议通过 MetaStoreServer 访问元数据库。</p> 
 <p align="center"><img src="https://images2.imgbox.com/11/f9/h0TK87OO_o.png" alt="7c9dc7084e0e650d8f286034eb96ace8.png">￼ </p> 
 <p>4.元数据MetaStore的备份机制</p> 
 <p>节点数据误删恢复问题:</p> 
 <p>1.按照时间:</p> 
 <p>mysqlbinlog --start-datetime="2010-04-16 00:00:00" --stop-datetime="2010-04-16 01:00:00" /usr/local/mysql/var/mysql-bin.0000001 &gt; test.sql</p> 
 <p>2.按照position恢复(show slave status\G;这里能看到position值是多少)</p> 
 <p>mysqlbinlog --start-position=001 --stop-position=006 /usr/local/mysql/var/mysql-bin.0000001 &gt; test.sql</p> 
 <p>注意，以上都是重定向，而非真正的恢复，如果需要恢复，那么可以去掉&gt;test.sql.</p> 
 <p>mysql主从同步常见异常及恢复方法</p> 
 <p>1. 一般的异常只需要跳过一步即可恢复</p> 
 <p>&gt;slave stop;</p> 
 <p>&gt;SET GLOBAL sql_slave_skip_counter = 1;</p> 
 <p>&gt;slave start;</p> 
 <p>2.断电导致主从不能同步时，通主库的最后一个bin-log日志进行恢复</p> 
 <p>在主库服务器上，mysqlbinlog mysql-bin.xxxx &gt; binxxxx.txt</p> 
 <p>tail -n 100000  binxxxx.txt &gt; tail-binxxxx.txt</p> 
 <p>vim tail-binxxxx.txt 打开tail-binxxxx.txt文件找到最后一个postion值</p> 
 <p>然后在从库上，change host to 相应正确的值</p> 
 <p>&gt;slave stop;</p> 
 <p>&gt;change master to master_host='ip', master_user='username', master_password='password', master_log_file='mysql-bin.xxxx', master_log_pos=xxxx;</p> 
 <p>&gt;slave start;</p> 
 <p>&gt;show slave status\G;</p> 
 <p>3.主键冲突、表已存在等错误代码如1062,1032,1060等，可以在mysql主配置文件指定</p> 
 <p>略过此类异常并继续下条sql同步，这样也可以避免很多主从同步的异常中断</p> 
 <p>[mysqld]</p> 
 <p>slave-skip-errors = 1062,1032,1060</p> 
 <p>3.mysql主从同步: 主节点机器宕机，所有数据丢失，如何恢复？</p> 
 <p>知道的朋友，留言给一下解决方案。(dump这种方案，我总感觉不太靠谱，不知道是不是我想多咯)</p> 
 <p>刚刚朋友说： 主从交换身份，然后进行同步操作，感觉好像很有道理的样子。</p> 
 <p>你们觉得呢？</p> 
 <p>可以用mysqldump工具</p> 
 <p>简单用例说明：</p> 
 <p>1.导入、导出数据库</p> 
 <p>导出：mysqldump -uroot db1 &gt; db1.sql  (注db1为database名)</p> 
 <p>导入：mysql -uroot test &lt; db1.sql (注test为database名，将db1中所有的表及数据导入到test数据库)</p> 
 <p>2.导入、导出表</p> 
 <p>导出：mysqldump -uroot db1 tb1 tb2&gt;tables.sql(注db1为database名，tb1 tb2为要导出的表列表，中间用空格隔开)</p> 
 <p>导入：mysql -uroot test &lt; tables.sql(将db1数据库中的tb1和tb2表导入到test数据库)</p> 
 <p>主从架构</p> 
 <p align="center"><img src="https://images2.imgbox.com/cf/58/oadp7kfW_o.png" alt="cc250b8b44587a2318a8a96179aa86b9.png">￼</p> 
 <p align="center"><img src="https://images2.imgbox.com/e4/e2/DvNr5Vl2_o.png" alt="8b7703ed9e44725db7c7f0b7984e43bb.png">￼ </p> 
 <p>主主架构</p> 
 <p align="center"><img src="https://images2.imgbox.com/a8/04/CmcPEJsr_o.png" alt="aa6570311b9c2d58cbc7b49bfe14abb2.png">￼</p> 
 <p align="center"><img src="https://images2.imgbox.com/aa/57/0Z3jq4zD_o.png" alt="1146a3a42a346c327c2de84727fc1c99.png">￼</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4574f12f6bea4eca823aaa431b4ab5b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JDK1.8中英文官方文档</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/49f338e0f21b230474c214a95619ad10/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用 XAML 格式化工具：XAML Styler</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>