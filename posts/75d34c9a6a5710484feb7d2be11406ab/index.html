<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>buildroot快速入门 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="buildroot快速入门" />
<meta property="og:description" content="本文约定：以字符‘$’符号开头的为命令，其后以字符‘#’开始的部分为命令说明。
一、Buildroot是什么？ 简述 buildroot是一个嵌入式系统构建工具，可以帮助我们快速构建系统映像文件，如rootfs.tar、uImage、uboot.imx以及设备树，同时也可以帮助我们构建对应的应用开发环境(交叉编译工具链以及第三方库，如Qt)。buildroot工程组织方式跟内核类似，即Config.in文件中描述执行make menuconfig时显示的配置菜单，Makefile根据Conifg.in和配置文件*.mk中定义的变量和规则编译整个工程。buildroot构建过程可以概括为下载、解压、配置、编译、安装。同时，buildroot也提供了多种源码下载方式，以提供灵活的定制方式，例如，支持从官方网站下载，从git库下载，从svn库下载或者简单的从本地拷贝。对第三方库包的种类支持也比较广泛，如普通包(Makefile组织)、cmake包(由Cmake组织)、python包(python脚本)等。为了支持更灵活的定制，buildroot提供了参考目录架构(所谓的br2-external tree)，即定制部分放在buildroot工程目录的外面，通过变量设置存放位置的方式来连接到buildroot工程。
buildroot工程目录结构 board: 一些典型板子的配置文件或说明文档
output：输出目录，其中有目标映像uboot.imx、uImage、rootfs.tar.gz、xxx.dtb; 编译时源码主目录build; 主机环境host
dl：下载的源码存放目录
support：支持脚本
configs：配置文件，make xxx_defconfig
arch: 架构配置文件，arm、mips、powerpc、x86 etc. 配置选项Target options ---&gt;
system：构建rootfs基本目录结构
toolchain：编译器配置目录，支持buildroot自带的，第三方的，自定义的。
fs：各种文件系统，squashfs、yaffs2、ext2 etc
package：rootfs中用到的各种库或命令工具包，如qt、ssh、mplayer、busybox、python etc.
linux: 内核配置目录
二、buildroot可以帮解决哪些问题？ 轻松构建嵌入式系统（rootfs）把系统各库之间繁杂的依赖关系交给工具处理，解放自己自动部署第三方库，减少体力劳动优化程序启动，根据不同启动等级启动程序，方便程序启动、终止以及重启。(需要添加debian扩展工具包)解决root权限问题，无法上外网和非root权限下服务器上构建rootfs规范rootfs目录和权限管控，自动管理用户及各目录权限 三、如何使用buildroot构建嵌入式系统 获取buildroot工程 一般是从官网Index of /downloads (buildroot.org) 或GitHub下载。但我们的服务器不能上网，所以将buildroot工程及第三方库部署到了自己用的服务器192.168.x.x上，此处简述从192.168.x.x服务器上获取buildroot工程及相关代码的步骤。
将自己账户的密钥拷贝到远程服务器192.168.x.x上（若已操作的话可省去此步骤） $ ssh-copy-id git@192.168.x.x
获取引导脚本repo（若没有bin目录，创建之） $ scp git@192.168.x.x:/home/git/tools/repo ~/bin/
$ chmod a&#43;x ~/bin/repo
获取repo脚本及表单文件 $ repo init -u git@192.168.x.x:/home/git/tools/manifests --no-repo-verify
获取buildroot工程及相关文件 $ repo sync
注：下载完成后，当前目录下会有一个.repo隐藏文件夹和project文件夹，project/buildroot即为buildroot工程目录。
配置和编译buildroot工程 配置工程 进入buildroot工程目录 $ cd project/buildroot" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/75d34c9a6a5710484feb7d2be11406ab/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-08T18:17:36+08:00" />
<meta property="article:modified_time" content="2023-08-08T18:17:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">buildroot快速入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:.0001pt;text-align:justify;">本文约定：以字符‘$’符号开头的为命令，其后以字符‘#’开始的部分为命令说明。</p> 
<h2 style="text-align:justify;"><strong><strong><strong>一</strong></strong><strong><strong>、Buildroot</strong></strong><strong><strong>是</strong></strong><strong><strong>什么？</strong></strong></strong></h2> 
<h3 style="text-align:justify;"><strong><strong><strong>简述</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">buildroot是一个嵌入式系统构建工具，可以帮助我们快速构建系统映像文件，如rootfs.tar、uImage、uboot.imx以及设备树，同时也可以帮助我们构建对应的应用开发环境(交叉编译工具链以及第三方库，如Qt)。buildroot工程组织方式跟内核类似，即Config.in文件中描述执行make menuconfig时显示的配置菜单，Makefile根据Conifg.in和配置文件*.mk中定义的变量和规则编译整个工程。buildroot构建过程可以概括为下载、解压、配置、编译、安装。同时，buildroot也提供了多种源码下载方式，以提供灵活的定制方式，例如，支持从官方网站下载，从git库下载，从svn库下载或者简单的从本地拷贝。对第三方库包的种类支持也比较广泛，如普通包(Makefile组织)、cmake包(由Cmake组织)、python包(python脚本)等。为了支持更灵活的定制，buildroot提供了参考目录架构(所谓的br2-external tree)，即定制部分放在buildroot工程目录的外面，通过变量设置存放位置的方式来连接到buildroot工程。</p> 
<h3 style="text-align:justify;"><strong><strong><strong>buildroot工程目录结构</strong></strong></strong></h3> 
<p style="margin-left:.0001pt;text-align:justify;">board: 一些典型板子的配置文件或说明文档</p> 
<p style="margin-left:.0001pt;text-align:justify;">output：输出目录，其中有目标映像uboot.imx、uImage、rootfs.tar.gz、xxx.dtb; 编译时源码主目录build; 主机环境host</p> 
<p style="margin-left:.0001pt;text-align:justify;">dl：下载的源码存放目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">support：支持脚本</p> 
<p style="margin-left:.0001pt;text-align:justify;">configs：配置文件，make xxx_defconfig</p> 
<p style="margin-left:.0001pt;text-align:justify;">arch: 架构配置文件，arm、mips、powerpc、x86 etc. 配置选项Target options ---&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">system：构建rootfs基本目录结构</p> 
<p style="margin-left:.0001pt;text-align:justify;">toolchain：编译器配置目录，支持buildroot自带的，第三方的，自定义的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">fs：各种文件系统，squashfs、yaffs2、ext2 etc</p> 
<p style="margin-left:.0001pt;text-align:justify;">package：rootfs中用到的各种库或命令工具包，如qt、ssh、mplayer、busybox、python etc.</p> 
<p style="margin-left:.0001pt;text-align:justify;">linux: 内核配置目录</p> 
<h2 style="text-align:justify;"><strong><strong><strong>二</strong></strong><strong><strong>、</strong></strong><strong><strong>buildroot</strong></strong><strong><strong>可以帮</strong></strong><strong><strong>解决哪些</strong></strong><strong><strong>问题？</strong></strong></strong></h2> 
<ul><li>轻松构建嵌入式系统（rootfs）</li><li>把系统各库之间繁杂的依赖关系交给工具处理，解放自己</li><li>自动部署第三方库，减少体力劳动</li><li>优化程序启动，根据不同启动等级启动程序，方便程序启动、终止以及重启。(需要添加debian扩展工具包)</li><li>解决root权限问题，无法上外网和非root权限下服务器上构建rootfs</li><li>规范rootfs目录和权限管控，自动管理用户及各目录权限</li></ul> 
<h2 style="text-align:justify;"><strong><strong><strong>三</strong></strong><strong><strong>、</strong></strong><strong><strong>如何</strong></strong><strong><strong>使用buildroot构建</strong></strong><strong><strong>嵌入式</strong></strong><strong><strong>系统</strong></strong></strong></h2> 
<ol><li style="text-align:justify;"><strong><strong><strong>获取</strong></strong><strong><strong>buildroot工程</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">一般是从官网<a href="https://buildroot.org/downloads/" rel="nofollow" title="Index of /downloads (buildroot.org)">Index of /downloads (buildroot.org)</a> 或<a href="https://github.com/buildroot/buildroot" title="GitHub">GitHub</a>下载。但我们的服务器不能上网，所以将buildroot工程及第三方库部署到了自己用的服务器192.168.x.x上，此处简述从192.168.x.x服务器上获取buildroot工程及相关代码的步骤。</p> 
<ol><li>将自己账户的密钥拷贝到远程服务器192.168.x.x上（若已操作的话可省去此步骤）</li></ol> 
<p style="margin-left:60pt;">$ ssh-copy-id git@192.168.x.x</p> 
<ol><li>获取引导脚本repo（若没有bin目录，创建之）</li></ol> 
<p style="margin-left:60pt;">$ scp git@192.168.x.x:/home/git/tools/repo ~/bin/</p> 
<p style="margin-left:60pt;">$ chmod a+x ~/bin/repo</p> 
<ol><li>获取repo脚本及表单文件</li></ol> 
<p style="margin-left:60pt;">$ repo init -u git@192.168.x.x:/home/git/tools/manifests --no-repo-verify</p> 
<ol><li>获取buildroot工程及相关文件</li></ol> 
<p style="margin-left:60pt;">$ repo sync</p> 
<p style="margin-left:.0001pt;text-align:justify;">注：下载完成后，当前目录下会有一个.repo隐藏文件夹和project文件夹，project/buildroot即为buildroot工程目录。</p> 
<ol><li style="text-align:justify;"><strong><strong><strong>配置和</strong></strong><strong><strong>编译buildroot工程</strong></strong></strong></li></ol> 
<ol><li>配置工程</li></ol> 
<ol><li>进入buildroot工程目录</li></ol> 
<p style="margin-left:60pt;">$ cd project/buildroot</p> 
<ol><li>配置并编译buildroot工程</li></ol> 
<p style="margin-left:60pt;">$ make xxx_defconfig BR2_EXTERNAL=../external</p> 
<ol><li>编译工程，构建rootfs</li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">执行make进行编译，编译期间出现的问题及处理方法如下。</p> 
<ol><li>一开始提示如下类似的信息，均键入y回车即可。</li></ol> 
<p style="margin-left:60pt;">unzip (BR2_PACKAGE_UNZIP) [N/y/?] (NEW) y</p> 
<p style="margin-left:60pt;">libuuid (BR2_PACKAGE_LIBUUID) [N/y/?] (NEW) y</p> 
<ol><li>出现如下提示：</li></ol> 
<p style="margin-left:60pt;">You have PERL_MM_OPT defined because Perl local::lib</p> 
<p style="margin-left:60pt;">is installed on your system. Please unset this variable</p> 
<p style="margin-left:60pt;">before starting Buildroot, otherwise the compilation of</p> 
<p style="margin-left:60pt;">Perl related packages will fail</p> 
<p style="margin-left:60pt;">解决方法：</p> 
<p style="margin-left:60pt;">$ unset PERL_MM_OPT</p> 
<ol><li>选择Qt库版本提示和协议提示</li></ol> 
<p style="margin-left:60pt;">Type 'c' if you want to use the Commercial Edition.</p> 
<p style="margin-left:60pt;">Type 'o' if you want to use the Open Source Edition.</p> 
<p style="margin-left:60pt;">处理方法：</p> 
<p style="margin-left:60pt;">键入o，然后回车即可，出现协议</p> 
<p style="margin-left:60pt;">Do you accept the terms of the license? y</p> 
<p style="margin-left:60pt;">键入y，回车即可。</p> 
<ol><li style="text-align:justify;"><strong><strong><strong>生成</strong></strong><strong><strong>文件说明</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">生成的文件主要有目标映像文件output/images/*和主机开发环境目录../host。</p> 
<p style="margin-left:.0001pt;text-align:justify;">注意事项：</p> 
<ol><li>buildroot工程中不要使用make –j选项进行多线程编译，若要加快编译速度，可以进行如下配置</li></ol> 
<p style="margin-left:60pt;">$ make menuconfig</p> 
<p style="margin-left:60pt;">选择Build options  ---&gt; (8) Number of jobs to run simultaneously (0 for auto)，此处的8表示8线程编译，同-j8</p> 
<ol><li>在buildroot工程中使用make clean会清楚生成目录output和外部编译器所在目录../host，若使用了，只需要切换到.repo所在目录并执行repo sync即可。</li><li>若下载中出现问题，请先删除.repo目录，再重新操作。</li></ol> 
<ol><li style="text-align:justify;"><strong><strong><strong>如何</strong></strong><strong><strong>重新编译安装</strong></strong><strong><strong>包</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">buildroot完成每个流程后都会在对应的工作目录下建立标志文件，如uboot：</p> 
<p style="margin-left:.0001pt;text-align:justify;">编译安装完成后在output/build/uboot-custom/目录下会有以下标志文件：</p> 
<p style="margin-left:.0001pt;text-align:justify;">.stamp_rsynced</p> 
<p style="margin-left:.0001pt;text-align:justify;">.stamp_configured</p> 
<p style="margin-left:.0001pt;text-align:justify;">.stamp_built</p> 
<p style="margin-left:.0001pt;text-align:justify;">.stamp_target_installed</p> 
<p style="margin-left:.0001pt;text-align:justify;">.stamp_images_installed</p> 
<p style="margin-left:.0001pt;text-align:justify;">因此，若要重新执行有两种方法：</p> 
<ol><li>对于make show-targets列表中存在的包，可以执行make &lt;pkg&gt;-reconfigure或make &lt;pkg&gt;-rebuild进行重新配置或编译</li><li>对于对于make show-targets列表中不存在的包，可以手动删除output/build/&lt;pkg&gt;目录中的对应标志文件，然后执行make，buildroot会重新启动操作，并建立标志文件。</li></ol> 
<ol><li style="text-align:justify;"><strong><strong><strong>如何</strong></strong><strong><strong>编译</strong></strong><strong><strong>安装</strong></strong><strong><strong>单个</strong></strong><strong><strong>包</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">buildroot本身不支持单个包安装，但有时候编译和安装单个包又为必须工作，此处提供一种方式。</p> 
<ol><li>编译整个buildroot工程。</li><li>进入output/build/&lt;pkg&gt;目录中</li><li>执行命令make DESTDIR=&lt;distdir&gt; install</li></ol> 
<p style="margin-left:60pt;">distdir为将要安装包&lt;pkg&gt;的目录。</p> 
<h2 style="text-align:justify;"><strong><strong><strong>四</strong></strong><strong><strong>、</strong></strong><strong><strong>如何</strong></strong><strong><strong>自定义自己的buildroot工程</strong></strong></strong></h2> 
<ol><li style="text-align:justify;"><strong><strong><strong>推荐</strong></strong><strong><strong>的目录结构</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">为了适用于自己的项目，buildroot工程支持高度自定义，但为了结构清晰，buildroot推荐将自定义的部分单独放到buildroot工程外部，而不是与buildroot工程本身混杂起来，即buildroot中所谓的br2-external架构目录，以下是推荐的目录结构。</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/4b/be/QrWwxd0c_o.png"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">本项目中的目录结构如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;">├── buildroot    # buildroot主目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── configs</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── downloads</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── output</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── package</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   └── ...</p> 
<p style="margin-left:.0001pt;text-align:justify;">├── external    # br2-external架构目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── Config.in</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── external.desc</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── external.mk</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── board</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   │   └── xxx_imx6qp</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   │       ├── local.mk    # package override file定义目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   │       ├── rootfs_overlay</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   │       ├── scripts</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   │       └── users_table</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   ├── configs</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   │   └── xxx_imx6qp_defconfig</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   └── package</p> 
<p style="margin-left:.0001pt;text-align:justify;">│       ├── Config.in</p> 
<p style="margin-left:.0001pt;text-align:justify;">│       ├── libuuid</p> 
<p style="margin-left:.0001pt;text-align:justify;">│       └── ...  </p> 
<p style="margin-left:.0001pt;text-align:justify;">├── host    # 选项Build options ---&gt; (${TOPDIR}/../host)Host dir</p> 
<p style="margin-left:.0001pt;text-align:justify;">│   └── opt    # 外部编译器所在目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">│       └── gcc-linaro-arm-linux-gnueabihf</p> 
<p style="margin-left:.0001pt;text-align:justify;">└── source    # local.mk中所定义的本地包目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">    ├── kernel</p> 
<p style="margin-left:.0001pt;text-align:justify;">    └── uboot</p> 
<ol><li style="text-align:justify;"><strong><strong><strong>自定义</strong></strong><strong><strong>外部编译器</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">buildroot自己带有编译器，也支持外部编译器（本地编译器）</p> 
<p style="margin-left:.0001pt;text-align:justify;">当配置为buildroot内部编译器时，构建过程中会从相关网站上下载编译器，并先编译编译器，再利用编译器构建系统；当配置为外部编译器时，会下载其他编译器或拷贝本地编译器到buildroot工程。</p> 
<p style="margin-left:.0001pt;text-align:justify;">Buildroot编译器的配置选项如下：</p> 
<p style="margin-left:.0001pt;text-align:justify;">Toolchain ---&gt; Toolchain type (External toolchain) ---&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">Toolchain ---&gt; Toolchain (Custom toolchain) ---&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">Toolchain ---&gt; (${TOPDIR}/../host/opt/gcc-linaro-arm-linux-gnueabihf)Toolchain path</p> 
<p style="margin-left:.0001pt;text-align:justify;">Toolchain ---&gt; ($(ARCH)-linux-gnueabihf)Toolchain prefix</p> 
<p style="margin-left:.0001pt;text-align:justify;">此处配置为本地编译器，并使用buildroot工程上层目录中host目录中的编译器。</p> 
<ol><li style="text-align:justify;"><strong><strong><strong>自定义</strong></strong><strong><strong>uboot和内核</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">uboot和内核的定义使用buildroot的&lt;pkg&gt;_OVERRIDE_SRCDIR机制来实现。uboot和内核源码使用git管控，在配置文件local.mk中指定变量uboot_OVERRIDE_SRCDIR的值为uboot的实际路径，linux_OVERRIDE_SRCDIR变量的值为linux路径，并在buildroot的配置选项中指定local.mk的路径和uboot和内核的获取方式即可，具体配置自定义步骤如下：</p> 
<ol><li>新建文件$(BR2_EXTERNAL)/ board/xxx_imx6qp/local.mk</li></ol> 
<p style="margin-left:18pt;">其内容为：</p> 
<p style="margin-left:18pt;">UBOOT_SITE_METHOD := local</p> 
<p style="margin-left:18pt;">UBOOT_OVERRIDE_SRCDIR = $(BR2_EXTERNAL)/../source/uboot</p> 
<p style="margin-left:18pt;">LINUX_SITE_METHOD := local</p> 
<p style="margin-left:18pt;">LINUX_OVERRIDE_SRCDIR = $(BR2_EXTERNAL)/../source/kernel</p> 
<ol><li>配置buildroot选项</li></ol> 
<p style="margin-left:18pt;">Build options --&gt;($(BR2_EXTERNAL)/board/xxx_imx6qp/local.mk) location of a package override file</p> 
<p style="margin-left:18pt;">Kernel  ---&gt; Kernel version (Local directory)  ---&gt;</p> 
<p style="margin-left:18pt;">($(TOPDIR)/../source) Path to the local directory</p> 
<p style="margin-left:18pt;">Bootloaders ---&gt; U-Boot Version (Local directory)  ---&gt;</p> 
<p style="margin-left:18pt;">($(TOPDIR)/../source) Path to the local directory</p> 
<ol><li style="text-align:justify;"><strong><strong><strong>自定义</strong></strong><strong><strong>rootfs</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">rootfs自定义方式比较灵活，大概有以下几种：</p> 
<ol><li>通过基本目录架构定制（不推荐）</li></ol> 
<p style="margin-left:60pt;">buildroot会从一个基础的系统目录架构开始构建rootfs，这个基础目录架构默认为system/skeleton目录，可以通过修改该目录达到定制的目的。相关配置选项如下：</p> 
<p style="margin-left:60pt;">System configuration ---&gt; Root FS skeletoon (custom target skeleton) ---&gt;</p> 
<p style="margin-left:60pt;">System configuration ---&gt; (your rootfs path)custom target skeleton path</p> 
<ol><li>通过rootfs覆盖目录机制</li></ol> 
<p style="margin-left:60pt;">buildroot提供在最终打包rootfs之前添加文件到rootfs中的机制，可以通过该机制添加文件到rootfs中。相关配置选项如下：</p> 
<p style="margin-left:60pt;">System configuration ---&gt; ($(BR2_EXTERNAL)/board/xxx_mx6qp/overlay-rootfs) Root filesystem overlay directories</p> 
<p style="margin-left:60pt;">这样，在最终打包之前，buildroot会先拷贝$(BR2_EXTERNAL)/board/xxx_mx6qp/overlay-rootfs文件夹中的内容到rootfs，然后再打包。</p> 
<ol><li>通过自定义脚本</li></ol> 
<p style="margin-left:60pt;">buildroot提供在rootfs打包前和打包后执行脚本的机制，只需要通过以下配置方式指定要执行的脚本即可：</p> 
<p style="margin-left:60pt;">System configuration ---&gt; ($(BR2_EXTERNAL)/scripts/before-create-rootfs-tar.sh) Custom scripts to run before creating filesystem</p> 
<p style="margin-left:60pt;">System configuration ---&gt; ($(BR2_EXTERNAL)/scripts/after-create-rootfs-tar.sh) Custom scripts to run after creating filesystem</p> 
<p style="margin-left:60pt;">此种方式中，自定义脚本中可能需要使用buildroot本身的一些变量(如文件路径)，可以通过以下配置传递变量到自定义脚本中：</p> 
<p style="margin-left:60pt;">System configuration ---&gt; (TARGET_DIR HOST_DIR BASE_DIR) Extra post-{build,image} arguments</p> 
<ol><li style="text-align:justify;"><strong><strong><strong>添加</strong></strong><strong><strong>自定义外部包</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">buildroot包含了绝大多数包（第三方库或工具），尽管如此，你也可以添加自己的包到buildroot工程中，步骤如下：</p> 
<ol><li>添加包目录external/package/&lt;pkg&gt;</li><li>拷贝buildroot/package目录下某个包中的Config.in和*.mk到目录external/package/&lt;pkg&gt;下，并按规则修改。</li></ol> 
<p style="margin-left:60pt;">注：根据包的类型和所属系统(包将在target中使用，还是在host中使用，或者两者都有)选择对应的模板文件</p> 
<p style="margin-left:60pt;">包的种类有：</p> 
<p style="margin-left:60pt;">$(eval $(generic-package))    # make</p> 
<p style="margin-left:60pt;">$(eval $(autotools-package))</p> 
<p style="margin-left:60pt;">$(eval $(cmake-package))</p> 
<p style="margin-left:60pt;">$(eval $(python-package))</p> 
<p style="margin-left:60pt;">buildroot会根据包的类型选择编译工具</p> 
<p style="margin-left:60pt;">所属系统有：</p> 
<p style="margin-left:60pt;">$(eval $(generic-package))</p> 
<p style="margin-left:60pt;">$(eval $(host-generic-package))</p> 
<p>                添加hash文件到目录external/package/&lt;pkg&gt;下</p> 
<p>注：内核模块也可以添加为外部包，参考[buildroot文档](<a href="https://buildroot.org/downloads/manual/manual.html#_infrastructure_for_packages_building_kernel_modules" rel="nofollow" title="The Buildroot user manual">The Buildroot user manual</a>)</p> 
<h2 style="text-align:justify;"><strong><strong><strong>五</strong></strong><strong><strong>、</strong></strong><strong><strong>附录</strong></strong></strong></h2> 
<ol><li style="text-align:justify;"><strong><strong><strong>参考</strong></strong><strong><strong>文档</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">[1] <a href="https://buildroot.org/downloads/manual/manual.html" rel="nofollow" title="The Buildroot user manual">The Buildroot user manual</a></p> 
<p style="margin-left:.0001pt;text-align:justify;">[2] buildroot-slides.pdf</p> 
<p style="margin-left:.0001pt;text-align:justify;">[3] buildroot-xxx/docs/*</p> 
<p style="margin-left:.0001pt;text-align:justify;">[4] <a href="https://blog.csdn.net/haimo_free/article/details/108137489" title="Buildroot用户手册-将软件包添加到Buildroot_buildroot添加软件包">Buildroot用户手册-将软件包添加到Buildroot_buildroot添加软件包</a></p> 
<ol><li style="text-align:justify;"><strong><strong><strong>buildroot</strong></strong><strong><strong>命令</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">配置：</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make xxx_defconfig     # 拷贝一个已有的配置</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make menuconfig    # 配置buildroot</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make uboot-menuconfig    # 配置uboot，自己添加</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make linux-menuconfig    # 配置内核</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make busybox-menuconfig    # 配置busybox</p> 
<p style="margin-left:.0001pt;text-align:justify;">编译：</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make show-targets    # 显示可单独编译的包</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make uboot    # 单独编译uboot</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make linux    # 单独编译linux</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make rootfs-tar    # 构建rootfs-tar</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make &lt;pkg&gt;-rebuild    # 重新编译包pkg</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make &lt;package&gt;-reconfigure    # 重新配置包package</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make source    # 只下载包源码</p> 
<p style="margin-left:.0001pt;text-align:justify;">执行流：</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make source    # 获取源码</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make extract    # 解包到output/build目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make pactch    # 应用补丁，如果有的话</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make configure    # 运行配置命令</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make build    # 运行编译命令</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make install-target    # 运行target目录的安装包</p> 
<p style="margin-left:.0001pt;text-align:justify;">依赖图：</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make show-depends    # 显示依赖关系, 需要先编译</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make graph-depends    #生成已经编译的全系统依赖图, 存储在output/graph目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ make &lt;pkg&gt;-graph-depends    #生成pkg包的依赖图</p> 
<p style="margin-left:.0001pt;text-align:justify;">$ BR2_GRAPH_OUT=svg/png make pulseaudio-graph-depends    #生成svg格式或png格式的依赖图</p> 
<p style="margin-left:.0001pt;text-align:justify;">这两个命令要求在系统中已经安装了dot 工具</p> 
<ol><li style="text-align:justify;"><strong><strong><strong>注意</strong></strong><strong><strong>事项</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">1、buildroot-2018版本中external/Config.in中</p> 
<p style="margin-left:.0001pt;text-align:justify;">变量引用为source "$BR2_EXTERNAL_xxx_PATH/package/Config.in"</p> 
<p style="margin-left:.0001pt;text-align:justify;">变量引用没有括号，也不能直接写成相对路径"package/Config.in"</p> 
<p style="margin-left:.0001pt;text-align:justify;">原因：buildroot主目录下Config.in中的相对路径是相对于主目录而言，即便是在package目录下；</p> 
<p style="margin-left:.0001pt;text-align:justify;">2、external中的Config.in中的相对路径也是相对于buildroot主目录而言的，因此即便是在external目录下的Config.in文件中包含本目录下的Config.in也必须加$BR2_EXTERNAL_xxx_PATH指定时external目录</p> 
<p style="margin-left:.0001pt;text-align:justify;">3、make clean会清空output下的所有内容，谨慎使用</p> 
<ol><li style="text-align:justify;"><strong><strong><strong>一个</strong></strong><strong><strong>buildroot配置例子</strong></strong></strong></li></ol> 
<p style="margin-left:.0001pt;text-align:justify;">$ make menuconfig</p> 
<p style="margin-left:.0001pt;text-align:justify;">Build options</p> 
<p style="margin-left:.0001pt;text-align:justify;">--&gt;Host dir--&gt;$(TOPDIR)/../host</p> 
<p style="margin-left:.0001pt;text-align:justify;">--&gt;(8)Numbers of jobs...</p> 
<p style="margin-left:.0001pt;text-align:justify;">Toolchain</p> 
<p style="margin-left:.0001pt;text-align:justify;">--&gt;Toolchain type (External toolchain) --&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">Toolchain (custom toolchain) --&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">($(TOPDIR)/../host/opt/gcc-linaro-arm-linux-gnueabihf)Toolchain path</p> 
<p style="margin-left:.0001pt;text-align:justify;">($(ARCH)-linux-gnueabihf) Toolchain prefix</p> 
<p style="margin-left:.0001pt;text-align:justify;">External toolchain gcc version (4.8.x) --&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">External toolchain kernel headers series (3.1.x) --&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">External toolchain C library (glibc/eglibc) --&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">[*] Toolchain has SSP support?</p> 
<p style="margin-left:.0001pt;text-align:justify;">[*] Toolchain has RPC support?</p> 
<p style="margin-left:.0001pt;text-align:justify;">[*] Toolchain has C++ support? #QT依赖此选项</p> 
<p style="margin-left:.0001pt;text-align:justify;">($(TOPDIR)/../host/opt/gcc-linaro-arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib) \</p> 
<p style="margin-left:.0001pt;text-align:justify;">Extra toolchain libraries to be copied to target</p> 
<p style="margin-left:.0001pt;text-align:justify;">[*] Copy gdb server to the Target</p> 
<p style="margin-left:.0001pt;text-align:justify;">System configuration</p> 
<p style="margin-left:.0001pt;text-align:justify;">(root) System hostname</p> 
<p style="margin-left:.0001pt;text-align:justify;">(Welcome to root) System banner</p> 
<p style="margin-left:.0001pt;text-align:justify;">Kernel</p> 
<p style="margin-left:.0001pt;text-align:justify;">(3.14.52) Kernel version</p> 
<p style="margin-left:.0001pt;text-align:justify;">(0x10008000)load address (for 3.7+ multi-platform image)</p> 
<p style="margin-left:.0001pt;text-align:justify;">(imx6q-sabresd imx6q-sabrelite) In-tree Device Tree Source file names</p> 
<p style="margin-left:.0001pt;text-align:justify;">[*] Install kernel image to /boot in target</p> 
<p style="margin-left:.0001pt;text-align:justify;">Bootloaders</p> 
<p style="margin-left:.0001pt;text-align:justify;">(mx6qsabresd) U-Boot board name</p> 
<p style="margin-left:.0001pt;text-align:justify;">(2015.04) U-Boot version</p> 
<p style="margin-left:.0001pt;text-align:justify;">U-Boot binary format --&gt;[*]u-boot.imx</p> 
<p style="margin-left:.0001pt;text-align:justify;">[] Install U-Boot SPL binary image</p> 
<p style="margin-left:.0001pt;text-align:justify;">Filesystem images--&gt;</p> 
<p style="margin-left:.0001pt;text-align:justify;">Compression method (gzip)--&gt;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8889f2d22caf20e70e29e9d6ae1af5fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Zabbix监控系统详解及配置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ee70fe0e44dac7d160485757543c1644/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">49 张图 26 个问题详解 WiFi</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>