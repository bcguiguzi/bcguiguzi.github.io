<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Python笔记-设计模式】模板方法模式 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Python笔记-设计模式】模板方法模式" />
<meta property="og:description" content="一、说明 模板方法模式是一种行为设计模式，就是继承和多态的使用，将通用操作在父类中实现，不同操作的细节在子类中具体实现，父类只声明接口。
(一) 解决问题 减少相似逻辑的重复代码，提高代码复用性提高代码逻辑性，使其易于维护 (二) 使用场景 当有一些操作具有相同的步骤，但具体实现步骤不同时当需要控制子类的扩展时 二、结构 抽象类（Abstract­Class）会声明作为算法步骤的方法，以及依次调用它们的实际模板方法。算法步骤可以被声明为抽象类型，也可以提供一些默认实现。具体类（Concrete­Class）可以重写所有步骤，但不能重写模板方法自身。 三、伪代码 #!/usr/bin/env python # -*- coding: UTF-8 -*- __doc__ = &#34;&#34;&#34; 模板方法模式 例：使用模板方法定义饮料制作流程，子类实现或重写具体的制作步骤 &#34;&#34;&#34; from abc import ABC, abstractmethod class BeverageTemplate(ABC): &#34;&#34;&#34;抽象类（Abstract Class）&#34;&#34;&#34; def prepare_beverage(self): self.boil_water() self.brew() self.pour_in_cup() if self.customer_wants_condiments(): self.add_condiments() def boil_water(self): print(&#34;烧水&#34;) @abstractmethod def brew(self): pass def pour_in_cup(self): print(&#34;将水倒进杯子里&#34;) @abstractmethod def add_condiments(self): pass def customer_wants_condiments(self): return True class Coffee(BeverageTemplate): &#34;&#34;&#34;具体类（Concrete Class）&#34;&#34;&#34; def brew(self): print(&#34;将咖啡滴过滤网&#34;) def add_condiments(self): print(&#34;加糖和牛奶&#34;) def customer_wants_condiments(self): return False class Tea(BeverageTemplate): &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/44bf4374a434362282f50acea210ca8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-01T09:32:22+08:00" />
<meta property="article:modified_time" content="2024-03-01T09:32:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Python笔记-设计模式】模板方法模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="400" id="EVlgv" src="https://images2.imgbox.com/8f/81/3ULCaIm8_o.png" width="640"></p> 
<h2 id="s8I9W">一、说明</h2> 
<p id="u42609cc9"><strong>模板方法模式</strong>是一种行为设计模式，就是继承和多态的使用，将通用操作在父类中实现，不同操作的细节在子类中具体实现，父类只声明接口。</p> 
<h3 id="sdvNt">(一) 解决问题</h3> 
<ol><li id="u4cd14bae">减少相似逻辑的重复代码，提高代码复用性</li><li id="u9687a77d">提高代码逻辑性，使其易于维护</li></ol> 
<h3 id="Qryzd">(二) 使用场景</h3> 
<ul><li id="u52baeb8c">当有一些操作具有相同的步骤，但具体实现步骤不同时</li><li id="uc9751433">当需要控制子类的扩展时</li></ul> 
<h2 id="AhQ3U">二、结构</h2> 
<p class="img-center"><img alt="" height="400" id="Dwne5" src="https://images2.imgbox.com/97/e5/sCCWW7bn_o.png" width="368"></p> 
<ol><li id="u876f0350"><strong>抽象类（Abstract­Class）</strong>会声明作为算法步骤的方法，以及依次调用它们的实际模板方法。算法步骤可以被声明为抽象类型，也可以提供一些默认实现。</li><li id="uafddee39"><strong>具体类（Concrete­Class）</strong>可以重写所有步骤，但不能重写模板方法自身。</li></ol> 
<h2 id="lQBqe">三、伪代码</h2> 
<pre id="YfvBU"><code class="language-python">#!/usr/bin/env python
# -*- coding: UTF-8 -*-
__doc__ = """
模板方法模式

例：使用模板方法定义饮料制作流程，子类实现或重写具体的制作步骤
"""

from abc import ABC, abstractmethod


class BeverageTemplate(ABC):
    """抽象类（Abstract Class）"""
    def prepare_beverage(self):
        self.boil_water()
        self.brew()
        self.pour_in_cup()
        if self.customer_wants_condiments():
            self.add_condiments()

    def boil_water(self):
        print("烧水")

    @abstractmethod
    def brew(self):
        pass

    def pour_in_cup(self):
        print("将水倒进杯子里")

    @abstractmethod
    def add_condiments(self):
        pass

    def customer_wants_condiments(self):
        return True


class Coffee(BeverageTemplate):
    """具体类（Concrete Class）"""
    def brew(self):
        print("将咖啡滴过滤网")

    def add_condiments(self):
        print("加糖和牛奶")

    def customer_wants_condiments(self):
        return False


class Tea(BeverageTemplate):
    """具体类（Concrete Class）"""
    def brew(self):
        print("倒入茶叶")

    def add_condiments(self):
        print("加柠檬")


if __name__ == "__main__":
    """
        煮咖啡...
        烧水
        将咖啡滴过滤网
        将水倒进杯子里
        ==============================
        泡茶...
        烧水
        倒入茶叶
        将水倒进杯子里
        加柠檬
    """
    print("煮咖啡...")
    coffee = Coffee()
    coffee.prepare_beverage()

    print("=" * 30)

    print("泡茶...")
    tea = Tea()
    tea.prepare_beverage()
</code></pre> 
<h2 id="hvieN">四、优缺点</h2> 
<h3>优点</h3> 
<ul><li id="u68d81569"><strong>提高代码复用性：</strong>将公共部分抽取到父类中</li><li id="ue99e4b08"><strong>便于维护：</strong>只需修改父类即可影响所有子类</li><li id="u3005b7df"><strong>符合开闭原则：</strong>通过增加子类扩展功能，而不修改原有代码</li></ul> 
<h3>缺点</h3> 
<ul><li id="u6928a3cd">可能导致类的数量增加，增加系统复杂性</li><li id="ucc6128c9">父类定义了实现框架，子类实现具体步骤，导致子类必须遵循父类的约束，灵活性受限</li></ul> 
<hr> 
<p><a href="https://blog.csdn.net/weixin_44904331/article/details/135881751?spm=1001.2014.3001.5502" title="【Python笔记】设计模式-CSDN博客">【Python笔记】设计模式-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c11e659b00f63db496903a6c84b301ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Python笔记-设计模式】访问者模式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/631a88b98ef9daae9171bd5d9655c46d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">74HC165D/74HC165PW中文资料规格书产品手册PDF档文件图片引脚图价格</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>