<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>const关键字不同使用场景 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="const关键字不同使用场景" />
<meta property="og:description" content="const关键字它主要用于声明常量，这意味着一旦一个变量被声明为常量，其值就“不能被改变”，这个“不能被改变”也不是绝对的不能发生任何变化，具体场景如下：
1.声明常量变量： 常量变量在编译时赋值，并且在其生命周期内不能发生改变。
int main() { const int const_val = 1; const_val = 2; // 错误，不能对常量const_val修改 return 0; } 2.指针和常量： 1.指向常量的指针： 这样的指针不能修改它所指向的值，但可以更改指针本身所指向的地址。
int val = 1; const int* p = &amp;val; // 这种情况下，可以理解为，const修饰的是“值” // *p = 2; // 错误，不能修改p所指向的值 int new_val = 2; p = &amp;new_val; // 正确，可以更改p的指向 2.常量指针： 这样的指针的值（即它所指向的地址）在初始化后不能更改，但可以通过该指针修改它所指向的值（除非该值本身也是常量）。
int val = 1; int* const p = &amp;val; // 这种情况下，const修饰的是指针，所以指针指向的地址不能改变 *p = 2; // 正确，可以修改所指向的值 int val2 = 2; p = &amp;val2; // 错误，不能更改指针p的地址指向 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/0ab2f628354c580be2f9f91bd5f9b761/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-09T19:36:40+08:00" />
<meta property="article:modified_time" content="2024-03-09T19:36:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">const关键字不同使用场景</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="u296ffd4c">const关键字它主要用于声明常量，这意味着一旦一个变量被声明为常量，其值就“不能被改变”，这个“不能被改变”也不是绝对的不能发生任何变化，具体场景如下：</p> 
<h2 id="KTOCw">1.声明常量变量：</h2> 
<p id="u82b8d76b">常量变量在编译时赋值，并且在其生命周期内不能发生改变。</p> 
<pre id="uYvKg"><code>int main() {
	const int const_val = 1;
	const_val = 2;  // 错误，不能对常量const_val修改
	return 0;
}</code></pre> 
<h2 id="zHMwZ">2.指针和常量：</h2> 
<h3 id="vwueG">1.指向常量的指针：</h3> 
<p id="u60e73ca5">这样的指针不能修改它所指向的值，但可以更改指针本身所指向的地址。</p> 
<pre id="WshZA"><code>int val = 1;
const int* p = &amp;val;  // 这种情况下，可以理解为，const修饰的是“值”

// *p = 2;  // 错误，不能修改p所指向的值

int new_val = 2;
p = &amp;new_val;  // 正确，可以更改p的指向</code></pre> 
<h3 id="tiJz8">2.常量指针：</h3> 
<p id="ud4e4ea7e">这样的指针的值（即它所指向的地址）在初始化后不能更改，但可以通过该指针修改它所指向的值（除非该值本身也是常量）。</p> 
<pre id="EiPqe"><code>int val = 1;
int* const p = &amp;val;  // 这种情况下，const修饰的是指针，所以指针指向的地址不能改变

*p = 2;  // 正确，可以修改所指向的值

int val2 = 2;
p = &amp;val2;  // 错误，不能更改指针p的地址指向</code></pre> 
<h3 id="ZO5MT">3.指向常量的常量指针：</h3> 
<p id="uee1d4f59">这种指针既不能修改它所指向的值，也不能更改它所指向的地址。</p> 
<pre id="TRPRn"><code>int val = 1;
const int* const p = &amp;val;  // const既修饰了指针地址，又修饰了“值”

*p = 2;  // 错误，不能改变p的值

int val2 = 2;
p = &amp;val2;  // 错误，不能改变p所指向的地址</code></pre> 
<h2 id="SofYn">3.函数参数中的 const</h2> 
<p id="u3c1ee7e7">在函数参数中使用 const 可以防止函数内部修改传入参数的值。</p> 
<pre id="Xyl2Y"><code>void test(const int val) {
	//val = 2;  // 错误，不能对val的值进行修改
	cout &lt;&lt; val;
}</code></pre> 
<h2 id="UuXtv">4.函数返回值的 const</h2> 
<p id="uf6c6e53b">如果一个函数的返回值是 const，那么它不能被修改。</p> 
<pre id="RGwRI"><code>const int test() {
	int val = 2;
	return val;
}
int main() {
	cout &lt;&lt; test()++ &lt;&lt; endl;  // 错误，不能对test函数的返回值进行修改。
    return 0;
}</code></pre> 
<h2 id="hOHxL">5.类成员函数的 const</h2> 
<p id="u69b3e60f">在类的成员函数声明后面加上 const 关键字（称该函数为常函数），表示该函数不会修改类的任何成员变量（除非这些变量被声明为 mutable）。</p> 
<pre id="b2dmB"><code>class MyClass {
public:
	int getValue() const {
		value_++;   // 错误，不能修改成员变量
        value2_++;  // 正确，被mutable修饰，可以修改
		return value_; // 可以读取value_，但不能修改它
	}

private:
	int value_;
	mutable int value2_;
};</code></pre> 
<h2 id="KBkvS">6.数组中的 const</h2> 
<p id="uf4df922e">const 可以用于数组的声明，表示数组的内容不能被修改。</p> 
<pre id="Zir74"><code>const int arr[] = { 1, 2, 3, 4, 5 };
arr[0] = 6; // 错误：不能修改const数组的内容</code></pre> 
<h2 id="oG9f2">7.在函数体内声明 const：</h2> 
<p id="u7f393be4">在函数体内，可以使用 const 来定义临时常量，有助于增加代码的可读性和安全性。</p> 
<pre id="ckLgX"><code>void test() {
	const int tmp = 1;
	tmp = 2;  // 错误，tmp不能被修改
}</code></pre> 
<h2 id="TIz6e">扩展</h2> 
<p id="u7ac2b0d4">const和define的区别和优缺点。</p> 
<blockquote> 
 <p id="uc5c94e81"><strong>const：</strong></p> 
 <p id="u29a3c310">- const是C++中的关键字，用于定义常量。</p> 
 <p id="ua739b6b8">- const定义的常量具有类型，可以进行类型检查。</p> 
 <p id="ue6e3837b">- const常量在编译时分配内存，并且有作用域限制，只在定义的作用域内有效。</p> 
 <p id="u9085cfcb">- const常量可以通过地址获取，可以取得其指针。</p> 
 <p id="u164c3e34">- const常量可以用于函数参数和返回值类型，以及类的成员变量和成员函数。</p> 
 <p id="u15d78d81">优点：类型安全、可读性好、可以进行编译器优化。</p> 
 <p id="u1054336b">缺点：不能用于定义复杂的常量表达式，只能定义简单的常量。</p> 
</blockquote> 
<blockquote> 
 <p id="u802c4f4f"><strong>define：</strong></p> 
 <p id="u07cf38f4">- define是C/C++中的预处理指令，用于定义宏常量。</p> 
 <p id="uf9236182">- define定义的常量没有类型，不进行类型检查。</p> 
 <p id="u351a1953">- define常量在预处理阶段进行简单的文本替换，没有内存分配和作用域限制。</p> 
 <p id="u070ae08a">- define常量不能获取其地址，也不能取得其指针。</p> 
 <p id="u6788ff2c">- define常量只是简单的文本替换，不会进行任何计算。</p> 
 <p id="u3c7db469">优点：可以定义复杂的常量表达式，可以用于任何地方。</p> 
 <p id="u86ced284">缺点：没有类型安全性、可读性差、可能会导致预期外的替换错误。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e83bbc9cd5531196a801dfab99192a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机软件文档编制规范GB_T 8567-2006</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8e6bfe1f883622ff86473329ecc63db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python——http/https文件传输</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>