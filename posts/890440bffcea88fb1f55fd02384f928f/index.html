<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>100台电脑无盘服务器配置,100台机子建立一个无盘工作站，用什么结构什么配置..... 爱问知识人... - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="100台电脑无盘服务器配置,100台机子建立一个无盘工作站，用什么结构什么配置..... 爱问知识人..." />
<meta property="og:description" content="一、无盘工作站启动原理无盘工作站之所以能够启动，是由硬件(工作站端)和软件(服务器端)共同配合的结果。软件上，就是服务器上的远程启动相关服务和无盘系统软件；硬件上，则是工作站网卡上的BootROM芯片。当然，对于不是很老的主板，其BIOS中空闲较多并支持写入，可以将BootROM芯片代码写入主板BIOS中，节省了一个芯片。
较常用的无盘启动芯片有RPL和PXE两种。这两种较为通用，其它还有一些厂商开发的专用芯片，不是很普及，以下的讨论中均以RPL和PXE为主。RPL芯片可用于10M和100M的网卡，有针对NT(2000)的，有针对NetWare的。不同的网卡用的也不一样，需要配套。
所以做无盘时不是任何网卡都能做的。10M的NE2000和8029网卡、100M的8139网卡等都支持RPL芯片，并且也都容易找到相应的RPL芯片。PXE芯片一般用于100M的网卡，以在8139网卡上的应用最为成熟和典型，甚至很容易就可找到用于8139网卡的PXE芯片代码(用于写入主板或空白BOOT片)。
现在较常见的是那种RPL/PXE双启动的BootROM芯片，价格在6元左右。1、RPL芯片的启动原理。(1)发现阶段。当Client启动后，其网卡上的BootROM会向Server广播一个引导请求帧，即FIND帧，该帧包含有Client的网卡号(MAC地址)，网络上所有Server都会发现这个FIND帧。
(2)提供阶段。Server远程启动服务收到Client广播的FIND帧，根据帧中所带的ID号，检查远程启动数据库中是否有该卡号的配置记录，如果不存在，则引导过程不能继续；如果存在，远程启动服务发送一个FOUND帧，这个帧中包含了服务器的岗卡ID(即Server的MAC地址)，然后就调用BOOTP(Boot Protocol)或者DHCP(Dynamic Host Configuration Protocol)。
(3)选择阶段。Client收到第一个响应后(因为可能网络中不止一个服务器在运行远程启动服务，Client只对收到的第一个FOUND帧回应，包括：分配给Client的机器名称、IP地址、Server的IP地址、BOOT所需的映像文件等)，则发送一个SEND。
FILE。REQUEST Frame给第一个回应的远程启动服务器，请求传送启动所需的文件。
4)确认阶段。当远程启动服务器收到SEND。FILE。REQUEST Frame的请求后，根据其远程启动数据库的Client记录查找对应的BOOT BLOCK，将Client启动所需的文件传送给Client，即给工作站一个FILE。
DAT。RESPONSE帧，这个帧 包含了Client启动所需的BOOT BLOCK。(5)启动阶段。Client接收到完整的启动文件后，开始执行文件中的程序，将执行点转向启动块的入口，启动Client，同时使用另外一个INTERNET协议：TFTP(Trivial Transfer Protocol)。
然后引导不同的OS。2、PXE芯片的启动原理。PXE是RPL的升级品，它是Preboot Execution Environment的缩写。它们的不同之处为：一个是静态路由，一个动态路由。不难理解：RPL是根据网卡上的ID号加上其它的记录组成的Frame向server发出请求，而server那里早已经有了这个ID数据，匹配成功则进行远程启动；PXE是则是根据服务器端收到的工作站MAC地址(就是网卡号)，使用DHCP服务给这个MAC地址指定一个IP地址，每次重启动可能同一台工作站有与上次启动有不同的IP，动态分配地址。
下面以工作站引导过程说明PXE的启动原理：
(1)用户端电脑开机后, PXE Boot ROM 获得控制权之前先做自我测试，然后以广播形式发出一个请求FIND帧。
(2)如果服务器收到个人电脑所送出的要求, 就会送回 DHCP 回应, 内容包括用户端的 IP 地址, 预设通讯通道, 及开机映像文件。
否则, 服务器会忽略这个要求。
(3)工作站收到服务器发回的响应后则会回应一个FRAME，以请求传送启动所需文件。
(4)之后，将有更多的讯息在用户端与服务器之间作应答, 用以决定启动参数。 BootPROM 由 TFTP 通讯协议从服务器下载开机映像档, 这个映像档就是软盘的映象文件。
(5)工作站使用TFTP 协议接收启动文件后，将控制权转交启动块，引导操作系统，完成远程启动。
全部" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/890440bffcea88fb1f55fd02384f928f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-05T13:41:05+08:00" />
<meta property="article:modified_time" content="2021-08-05T13:41:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">100台电脑无盘服务器配置,100台机子建立一个无盘工作站，用什么结构什么配置..... 爱问知识人...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>一、无盘工作站启动原理无盘工作站之所以能够启动，是由硬件(工作站端)和软件(服务器端)共同配合的结果。软件上，就是服务器上的远程启动相关服务和无盘系统软件；硬件上，则是工作站网卡上的BootROM芯片。当然，对于不是很老的主板，其BIOS中空闲较多并支持写入，可以将BootROM芯片代码写入主板BIOS中，节省了一个芯片。</p> 
 <p>较常用的无盘启动芯片有RPL和PXE两种。这两种较为通用，其它还有一些厂商开发的专用芯片，不是很普及，以下的讨论中均以RPL和PXE为主。RPL芯片可用于10M和100M的网卡，有针对NT(2000)的，有针对NetWare的。不同的网卡用的也不一样，需要配套。</p> 
 <p>所以做无盘时不是任何网卡都能做的。10M的NE2000和8029网卡、100M的8139网卡等都支持RPL芯片，并且也都容易找到相应的RPL芯片。PXE芯片一般用于100M的网卡，以在8139网卡上的应用最为成熟和典型，甚至很容易就可找到用于8139网卡的PXE芯片代码(用于写入主板或空白BOOT片)。</p> 
 <p>现在较常见的是那种RPL/PXE双启动的BootROM芯片，价格在6元左右。1、RPL芯片的启动原理。(1)发现阶段。当Client启动后，其网卡上的BootROM会向Server广播一个引导请求帧，即FIND帧，该帧包含有Client的网卡号(MAC地址)，网络上所有Server都会发现这个FIND帧。</p> 
 <p>(2)提供阶段。Server远程启动服务收到Client广播的FIND帧，根据帧中所带的ID号，检查远程启动数据库中是否有该卡号的配置记录，如果不存在，则引导过程不能继续；如果存在，远程启动服务发送一个FOUND帧，这个帧中包含了服务器的岗卡ID(即Server的MAC地址)，然后就调用BOOTP(Boot Protocol)或者DHCP(Dynamic Host Configuration Protocol)。</p> 
 <p>(3)选择阶段。Client收到第一个响应后(因为可能网络中不止一个服务器在运行远程启动服务，Client只对收到的第一个FOUND帧回应，包括：分配给Client的机器名称、IP地址、Server的IP地址、BOOT所需的映像文件等)，则发送一个SEND。</p> 
 <p>FILE。REQUEST Frame给第一个回应的远程启动服务器，请求传送启动所需的文件。</p> 
 <p>4)确认阶段。当远程启动服务器收到SEND。FILE。REQUEST Frame的请求后，根据其远程启动数据库的Client记录查找对应的BOOT BLOCK，将Client启动所需的文件传送给Client，即给工作站一个FILE。</p> 
 <p>DAT。RESPONSE帧，这个帧 包含了Client启动所需的BOOT BLOCK。(5)启动阶段。Client接收到完整的启动文件后，开始执行文件中的程序，将执行点转向启动块的入口，启动Client，同时使用另外一个INTERNET协议：TFTP(Trivial Transfer Protocol)。</p> 
 <p>然后引导不同的OS。2、PXE芯片的启动原理。PXE是RPL的升级品，它是Preboot Execution Environment的缩写。它们的不同之处为：一个是静态路由，一个动态路由。不难理解：RPL是根据网卡上的ID号加上其它的记录组成的Frame向server发出请求，而server那里早已经有了这个ID数据，匹配成功则进行远程启动；PXE是则是根据服务器端收到的工作站MAC地址(就是网卡号)，使用DHCP服务给这个MAC地址指定一个IP地址，每次重启动可能同一台工作站有与上次启动有不同的IP，动态分配地址。</p> 
 <p>下面以工作站引导过程说明PXE的启动原理：</p> 
 <p>(1)用户端电脑开机后, PXE Boot ROM 获得控制权之前先做自我测试，然后以广播形式发出一个请求FIND帧。</p> 
 <p>(2)如果服务器收到个人电脑所送出的要求, 就会送回 DHCP 回应, 内容包括用户端的 IP 地址, 预设通讯通道, 及开机映像文件。</p> 
 <p>否则, 服务器会忽略这个要求。</p> 
 <p>(3)工作站收到服务器发回的响应后则会回应一个FRAME，以请求传送启动所需文件。</p> 
 <p>(4)之后，将有更多的讯息在用户端与服务器之间作应答, 用以决定启动参数。 BootPROM 由 TFTP 通讯协议从服务器下载开机映像档, 这个映像档就是软盘的映象文件。</p> 
 <p>(5)工作站使用TFTP 协议接收启动文件后，将控制权转交启动块，引导操作系统，完成远程启动。</p> 
 <p>全部</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2e852a28d0eefdcc756f31a31819ce0b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ajax解析properties,AJAX result.d实例解释</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/db2922cfd16d1408311538d558ed0bbd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">javascript ajax for,通过javascript中的ajax保护JSON响应（for（;;）;）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>