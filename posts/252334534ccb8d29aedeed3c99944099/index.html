<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux之shell脚本初始 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux之shell脚本初始" />
<meta property="og:description" content="华子目录 为什么学习和使用shell编程shell起源查看当前系统支持的shell查看当前系统默认的shellshell概念shell程序设计语言shell也是一种脚本语言用途 如何学号shell熟练掌握shell编程基础知识 建议shell脚本的基本元素基本元素构成shell脚本中的注释和风格 shell脚本编写规范脚本开头脚本自动增加注释版权信息示例（shell脚本文件必须以.sh结尾） 脚本中尽量不用中文注释多使用内部命令没有必要使用cat命令仔细阅读出错信息文件名以.sh结尾代码缩进示例：编写九九乘法表 shell脚本执行方法方法1方法2方法3方法4注意： bash shell基本功能echo打印命令printf命令示例 history历史命令命令与文件名补全：tab命令别名命令执行顺序管道符exit退出程序常见状态码 为什么学习和使用shell编程 简单易学解释性语言，不需要编译即可执行对于一个合格的系统管理员来说，学习和掌握shell编程是非常重要的，通过shell程序，可以在很大程度上简化日常的维护工作，使得管理员从简单的重复劳动中解脱出来 shell起源 1964年，美国AT&amp;T公司的贝尔实验室、麻省理工学院及美国通用电气公司共同参与开始研发一套可以安装在大型主机上的多用户、多任务的操作系统，该操作系统的名称为Multics。1970年，丹尼斯•里奇和汤普逊启动了另外一个新的多用户、多任务的操作系统的项目，他们把这个项目称之为UNICS。1973年，使用C语言重写编写了Unix。通过这次编写，使得Unix得以移植到其他的小型机上面。1979年，第一个重要的标准UNIX Shell在Unix的第7版中推出，并以作者史蒂夫•伯恩（StephenBourne）的名字命名，叫做Bourne Shell，简称为sh。20世纪70年代末，C Shell作为2BSD UNIX的一部分发布，简称csh。之后又出现了许多其他的Shell程序，主要包括Tenex C Shell（tcsh）、Korn Shell（ksh）以及GNU Bourne-Again shell（bash）。 查看当前系统支持的shell [root@server ~]# cat /etc/shells /bin/sh /bin/bash /usr/bin/sh #相当于/bin/sh的备份 /usr/bin/bash #相当于/bin/bash的备份 查看当前系统默认的shell [root@server ~]# echo $SHELL /bin/bash shell概念 shell（外壳）：是一种命令解释器程序，它能识别用户输入的各种命令，并传递给操作系统结构图真正能够控制计算机硬件（CPU、内存、显示器等）的只有操作系统内核（Kernel），图形界面和命令行只是架设在用户和内核之间的一座桥梁，由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；该程序的作用就是接收用户的操作（点击图标、输入命令），并进行简单的处理，然后再传递给内核，这样用户就能间接地使用操作系统内核用户界面和命令行就是这个另外开发的程序，就是这层“代理”。在Linux下，这个命令行程序叫做 Shell，Shell 是一个应用程序，它连接了用户和 Linux 内核，让用户能够更加高效、安全、低成本地使用 Linux 内核，这就是 Shell 的本质。Shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 QQ、迅雷、Firefox 等其它软件没有什么区别。然而 Shell 也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 Shell 来使用 Linux，不启动 Shell 的话，用户就没办法使用 Linux。 shell程序设计语言 shell也是一种脚本语言 任何代码最终都要被 “翻译”成二进制的形式才能在计算机中执行。有的编程语言，如 C/C&#43;&#43;、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都翻译成二进制形式，也就是生成可执行文件，用户拿到的是最终生成的可执行文件，看不到源码。这个过程叫做编译（Compile），这样的编程语言叫做编译型语言，完成编译过程的软件叫做编译器（Compiler）。有的编程语言，如 Shell、JavaScript、Python、PHP等，需要一边执行一边翻译，不会生成任何可执行文件，用户必须拿到源码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。这个过程叫做解释，这样的编程语言叫做解释型语言或者脚本语言（Script），完成解释过程的软件叫做解释器。编译型语言的优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等。脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合 Web 开发以及小工具的制作。Shell 就是一种脚本语言，我们编写完源码后不用编译，直接运行源码即可。 用途 shell脚本的优势在于处理操作系统底层的业务 （linux系统内部的应用都是shell脚本完成）因为有大量的linux系统命令为它做支撑。2000多个命令都是shell脚本编程的有力支撑，特别是grep、awk、sed等。例如：一键软件安装、优化、监控报警脚本，常规的业务应用，shell开发更简单快速，符合运维的简单、易用、高效原则。PHP、Python优势在于开发运维工具以及web界面的管理工具，web业务的开发等。处理一键软件安装、优化，报警脚本。常规业务的应用等php/python也是能够做到的。但是开发效率和复杂比用shell就差很多了。 如何学号shell 熟练掌握shell编程基础知识 熟练使用vi（vim）编辑器熟练掌握Linux基本命令熟练掌握文本三剑客工具（grep、sed、awk）熟悉常用服务器部署、优化、日志及排错 建议 掌握shell脚本基本语法形成自己的脚本开发风格从简单做起，简单判断，简单循环多模仿，多参考资料练习，多思考学会分析问题，逐渐形成编程思维编程变量名字要规范，采用驼峰语法表示不要拿来主义，特别是新手 shell脚本的基本元素 基本元素构成 第1行的&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/252334534ccb8d29aedeed3c99944099/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-14T01:15:14+08:00" />
<meta property="article:modified_time" content="2024-03-14T01:15:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux之shell脚本初始</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>华子目录</h4> 
 <ul><li><a href="#shell_1" rel="nofollow">为什么学习和使用shell编程</a></li><li><a href="#shell_6" rel="nofollow">shell起源</a></li><li><a href="#shell_13" rel="nofollow">查看当前系统支持的shell</a></li><li><a href="#shell_22" rel="nofollow">查看当前系统默认的shell</a></li><li><a href="#shell_28" rel="nofollow">shell概念</a></li><li><a href="#shell_36" rel="nofollow">shell程序设计语言</a></li><li><ul><li><a href="#shell_37" rel="nofollow">shell也是一种脚本语言</a></li><li><a href="#_45" rel="nofollow">用途</a></li></ul> 
  </li><li><a href="#shell_49" rel="nofollow">如何学号shell</a></li><li><ul><li><a href="#shell_50" rel="nofollow">熟练掌握shell编程基础知识</a></li></ul> 
  </li><li><a href="#_56" rel="nofollow">建议</a></li><li><a href="#shell_65" rel="nofollow">shell脚本的基本元素</a></li><li><ul><li><a href="#_66" rel="nofollow">基本元素构成</a></li><li><a href="#shell_71" rel="nofollow">shell脚本中的注释和风格</a></li></ul> 
  </li><li><a href="#shell_93" rel="nofollow">shell脚本编写规范</a></li><li><ul><li><a href="#_94" rel="nofollow">脚本开头</a></li><li><a href="#_106" rel="nofollow">脚本自动增加注释版权信息</a></li><li><ul><li><a href="#shellsh_128" rel="nofollow">示例（shell脚本文件必须以.sh结尾）</a></li></ul> 
   </li><li><a href="#_150" rel="nofollow">脚本中尽量不用中文注释</a></li><li><a href="#_156" rel="nofollow">多使用内部命令</a></li><li><a href="#cat_160" rel="nofollow">没有必要使用cat命令</a></li><li><a href="#_169" rel="nofollow">仔细阅读出错信息</a></li><li><a href="#sh_175" rel="nofollow">文件名以.sh结尾</a></li><li><a href="#_179" rel="nofollow">代码缩进</a></li><li><ul><li><a href="#_182" rel="nofollow">示例：编写九九乘法表</a></li></ul> 
  </li></ul> 
  </li><li><a href="#shell_225" rel="nofollow">shell脚本执行方法</a></li><li><ul><li><a href="#1_226" rel="nofollow">方法1</a></li><li><a href="#2_242" rel="nofollow">方法2</a></li><li><a href="#3_260" rel="nofollow">方法3</a></li><li><a href="#4_283" rel="nofollow">方法4</a></li><li><ul><li><a href="#_292" rel="nofollow">注意：</a></li></ul> 
  </li></ul> 
  </li><li><a href="#bash_shell_296" rel="nofollow">bash shell基本功能</a></li><li><ul><li><a href="#echo_297" rel="nofollow">echo打印命令</a></li><li><a href="#printf_355" rel="nofollow">printf命令</a></li><li><ul><li><a href="#_362" rel="nofollow">示例</a></li></ul> 
   </li><li><a href="#history_388" rel="nofollow">history历史命令</a></li><li><a href="#tab_421" rel="nofollow">命令与文件名补全：tab</a></li><li><a href="#_422" rel="nofollow">命令别名</a></li><li><a href="#_444" rel="nofollow">命令执行顺序</a></li><li><a href="#_461" rel="nofollow">管道符</a></li><li><a href="#exit_480" rel="nofollow">exit退出程序</a></li><li><ul><li><a href="#_486" rel="nofollow">常见状态码</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="shell_1"></a>为什么学习和使用shell编程</h2> 
<ul><li>简单易学</li><li><mark>解释性语言</mark>，<mark>不需要编译即可执行</mark></li><li>对于一个合格的系统管理员来说，学习和掌握shell编程是非常重要的，通过shell程序，可以在很大程度上<mark>简化日常的维护工作</mark>，使得管理员从简单的重复劳动中解脱出来</li></ul> 
<h2><a id="shell_6"></a>shell起源</h2> 
<ul><li>1964年，美国AT&amp;T公司的贝尔实验室、麻省理工学院及美国通用电气公司共同参与开始研发一套可以安装在大型主机上的多用户、多任务的操作系统，该操作系统的名称为Multics。</li><li>1970年，丹尼斯•里奇和汤普逊启动了另外一个新的多用户、多任务的操作系统的项目，他们把这个项目称之为UNICS。</li><li>1973年，使用C语言重写编写了Unix。通过这次编写，使得Unix得以移植到其他的小型机上面。</li><li>1979年，第一个重要的标准UNIX Shell在Unix的第7版中推出，并以作者史蒂夫•伯恩（StephenBourne）的名字命名，叫做Bourne Shell，简称为sh。</li><li>20世纪70年代末，C Shell作为2BSD UNIX的一部分发布，简称csh。之后又出现了许多其他的Shell程序，主要包括Tenex C Shell（tcsh）、Korn Shell（ksh）以及GNU Bourne-Again shell（bash）。</li><li><img src="https://images2.imgbox.com/6c/0c/5mbADp8D_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="shell_13"></a>查看当前系统支持的shell</h2> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/shells</span>
/bin/sh
/bin/bash
/usr/bin/sh      <span class="token comment">#相当于/bin/sh的备份</span>
/usr/bin/bash    <span class="token comment">#相当于/bin/bash的备份</span>
</code></pre> 
<h2><a id="shell_22"></a>查看当前系统默认的shell</h2> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># echo $SHELL</span>
/bin/bash
</code></pre> 
<h2><a id="shell_28"></a>shell概念</h2> 
<ul><li><mark>shell（外壳</mark>）：是一种<mark>命令解释器程序</mark>，它能<mark>识别用户输入的各种命令</mark>，并<mark>传递给操作系统</mark></li><li>结构图</li><li><img src="https://images2.imgbox.com/cd/e0/JlPSgAwS_o.png" alt="在这里插入图片描述"></li><li><mark>真正能够</mark>控制<mark>计算机硬件</mark>（CPU、内存、显示器等）的只有<mark>操作系统内核</mark>（Kernel），<mark>图形界面和命令行</mark>只是架设在<mark>用户</mark>和<mark>内核</mark>之间的一座<mark>桥梁</mark>，由于安全、复杂、繁琐等原因，用户不能直接接触内核（也没有必要），需要另外再开发一个程序，让用户直接使用这个程序；该<mark>程序的作用</mark>就是<mark>接收用户的操作</mark>（点击图标、输入命令），并进行<mark>简单的处理</mark>，然后再传递给<mark>内核</mark>，这样用户就能<mark>间接</mark>地<mark>使用操作系统内核</mark></li><li><mark>用户界面</mark>和<mark>命令行</mark>就是这个另外开发的<mark>程序</mark>，就是<mark>这层“代理”</mark>。在<mark>Linux下</mark>，这个<mark>命令行程序</mark>叫做 <mark>Shell</mark>，<mark>Shell 是一个应用程序</mark>，它连接了<mark>用户和 Linux 内核</mark>，让<mark>用户能够更加高效、安全、低成本地使用 Linux 内核</mark>，这<mark>就是 Shell 的本质。</mark></li><li><mark>Shell 本身并不是内核的一部分</mark>，它<mark>只是站在内核的基础上编写的一个应用程序</mark>，<mark>它和 QQ、迅雷、Firefox 等其它软件没有什么区别</mark>。然而 Shell 也有着它的特殊性，就是<mark>开机立马启动</mark>，并呈现在用户面前；<mark>用户通过 Shell 来使用 Linux</mark>，<mark>不启动 Shell 的话，用户就没办法使用 Linux。</mark></li></ul> 
<h2><a id="shell_36"></a>shell程序设计语言</h2> 
<h3><a id="shell_37"></a>shell也是一种脚本语言</h3> 
<ul><li><mark>任何代码</mark>最终都要被 <mark>“翻译”成二进制</mark>的形式<mark>才能在计算机中执行。</mark></li><li><mark>有的编程语言</mark>，如 <mark>C/C++、Pascal、Go语言、汇编等</mark>，<mark>必须在程序运行之前</mark>将<mark>所有代码</mark>都翻译成<mark>二进制形式</mark>，也<mark>就是生成可执行文件</mark>，用户拿到的是<mark>最终生成的可执行文件</mark>，看不到源码。这个过程叫做<mark>编译</mark>（Compile），这样的<mark>编程语言</mark>叫做<mark>编译型语言</mark>，<mark>完成编译过程的软件叫做编译器（Compiler）。</mark></li><li>有的编程语言，如 <mark>Shell、<a href="http://c.biancheng.net/js/" rel="nofollow">JavaScript</a>、Python、<a href="http://c.biancheng.net/php/" rel="nofollow">PHP</a>等</mark>，需要<mark>一边执行一边翻译</mark>，<mark>不会生成任何可执行文件</mark>，用户必须拿到<mark>源码</mark>才能<mark>运行程序</mark>。程序运行后会<mark>即时翻译</mark>，<mark>翻译完一部分执行一部分</mark>，<mark>不用等到所有代码都翻译完</mark>。<mark>这个过程叫做解释</mark>，<mark>这样的编程语言叫做解释型语言</mark>或者<mark>脚本语言（Script</mark>），<mark>完成解释过程</mark>的<mark>软件</mark>叫做<mark>解释器。</mark></li><li><mark>编译型语言</mark>的优点是<mark>执行速度快</mark>、对<mark>硬件要求低、保密性好，适合开发操作系统</mark>、<mark>大型应用程序、数据库等。</mark></li><li><mark>脚本语言</mark>的优点是<mark>使用灵活、部署容易、跨平台性好，非常适合 Web 开发以及小工具的制作。</mark></li><li><mark>Shell 就是一种脚本语言</mark>，我们编写完源码后<mark>不用编译</mark>，<mark>直接运行源码即可。</mark></li></ul> 
<h3><a id="_45"></a>用途</h3> 
<ul><li><mark>shell脚本的优势</mark>在于<mark>处理操作系统底层的业务</mark> （<mark>linux系统内部的应用都是shell脚本完成</mark>）因为<mark>有大量的linux系统命令为它做支撑</mark>。2000多个命令都是shell脚本编程的有力支撑，<mark>特别是grep、awk、sed等</mark>。例如：一键软件安装、优化、监控报警脚本，常规的业务应用，<mark>shell开发更简单快速，符合运维的简单、易用、高效原则。</mark></li><li><mark>PHP、Python优势在于开发运维工具</mark>以及<mark>web界面的管理工具</mark>，<mark>web业务的开发等</mark>。处理一键软件安装、优化，报警脚本。常规业务的应用等<mark>php/python也是能够做到的</mark>。但是<mark>开发效率和复杂比用shell就差很多了。</mark></li></ul> 
<h2><a id="shell_49"></a>如何学号shell</h2> 
<h3><a id="shell_50"></a>熟练掌握shell编程基础知识</h3> 
<ul><li>熟练使用<mark>vi（vim）编辑器</mark></li><li>熟练掌握<mark>Linux基本命令</mark></li><li>熟练掌握<mark>文本三剑客工具</mark>（<mark>grep、sed、awk</mark>）</li><li><mark>熟悉常用服务器部署、优化、日志及排错</mark></li></ul> 
<h2><a id="_56"></a>建议</h2> 
<ul><li>掌握<mark>shell脚本基本语法</mark></li><li><mark>形成自己的脚本开发风格</mark></li><li>从简单做起，简单判断，简单循环</li><li><mark>多模仿，多参考资料练习，多思考</mark></li><li><mark>学会分析问题，逐渐形成编程思维</mark></li><li>编程变量名字要规范，采用<mark>驼峰语法</mark>表示</li><li>不要拿来主义，特别是新手</li></ul> 
<h2><a id="shell_65"></a>shell脚本的基本元素</h2> 
<h3><a id="_66"></a>基本元素构成</h3> 
<ul><li>第1行的"<mark>#!/bin/bash</mark>"</li><li><mark>注释</mark>：说明某些代码的功能</li><li><mark>可执行语句</mark>：实现程序的功能</li></ul> 
<h3><a id="shell_71"></a>shell脚本中的注释和风格</h3> 
<ul><li>作用：通过在代码中增加注释可以提高程序的可读性</li><li><mark>传统的shell只支持单行注释</mark>，其表示方法是一个<mark>井号"#"</mark>，从该符号开始一直到行尾都属于注释的内容，如</li></ul> 
<pre><code class="prism language-bash"><span class="token comment">#comment1</span>
<span class="token comment">#comment2</span>
<span class="token comment">#comment3</span>
<span class="token punctuation">..</span>.
</code></pre> 
<ul><li>多行注释：使用 <mark>冒号":"</mark> 配合，语法如下</li></ul> 
<pre><code class="prism language-bash">:<span class="token operator">&lt;&lt;</span><span class="token string">'xxxx'
comment1
comment2
comment3
……
xxxx</span>
</code></pre> 
<p><code>xxxx可以是字符或数字，单引号可以不加，但以防出现莫名其妙的意外发生，最好加上</code></p> 
<h2><a id="shell_93"></a>shell脚本编写规范</h2> 
<h3><a id="_94"></a>脚本开头</h3> 
<ul><li><mark>开头指定脚本解释器</mark>：<mark>#!/bin/sh</mark>或 <mark>#!/bin/bash</mark></li><li><mark>其他行#表示注释</mark></li><li><mark>程序段开头需要加版权等信息</mark>，如：</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># Date:创建日期</span>
<span class="token comment"># Author:作者</span>
<span class="token comment"># Mail:联系方式</span>
<span class="token comment"># Function:功能</span>
<span class="token comment"># Version:版本</span>
</code></pre> 
<h3><a id="_106"></a>脚本自动增加注释版权信息</h3> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># vim  ~/.vimrc  # 新建配置文件</span>
autocmd BufNewFile *.py,*.cc,*.sh,*.java <span class="token builtin class-name">exec</span> <span class="token string">":call SetTitle()"</span>
 
func SetTitle<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> expand<span class="token punctuation">(</span><span class="token string">"%:e"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'sh'</span>
        call setline<span class="token punctuation">(</span><span class="token number">1</span>,<span class="token string">"#!/bin/bash"</span><span class="token punctuation">)</span>
        call setline<span class="token punctuation">(</span><span class="token number">2</span>,<span class="token string">"##############################################################"</span><span class="token punctuation">)</span>
        call setline<span class="token punctuation">(</span><span class="token number">3</span>, <span class="token string">"# File Name: "</span>.expand<span class="token punctuation">(</span><span class="token string">"%"</span><span class="token punctuation">))</span>
        call setline<span class="token punctuation">(</span><span class="token number">4</span>, <span class="token string">"# Version: V1.0"</span><span class="token punctuation">)</span>
        call setline<span class="token punctuation">(</span><span class="token number">5</span>, <span class="token string">"# Author: Andy_Sun"</span><span class="token punctuation">)</span>
        call setline<span class="token punctuation">(</span><span class="token number">6</span>, <span class="token string">"# Email: Andy_Sun@163.com"</span><span class="token punctuation">)</span>
        call setline<span class="token punctuation">(</span><span class="token number">7</span>, <span class="token string">"# Organization: http://www.cnblogs.com/Andy_Sun/"</span><span class="token punctuation">)</span>
        call setline<span class="token punctuation">(</span><span class="token number">8</span>, <span class="token string">"# Created Time : "</span>.strftime<span class="token punctuation">(</span><span class="token string">"%F %T"</span><span class="token punctuation">))</span>
        call setline<span class="token punctuation">(</span><span class="token number">9</span>, <span class="token string">"# Description:"</span><span class="token punctuation">)</span>
        call setline<span class="token punctuation">(</span><span class="token number">10</span>,<span class="token string">"##############################################################"</span><span class="token punctuation">)</span>
        call setline<span class="token punctuation">(</span><span class="token number">11</span>, <span class="token string">""</span><span class="token punctuation">)</span>
    endif
endfunc
</code></pre> 
<h4><a id="shellsh_128"></a>示例（shell脚本文件必须以.sh结尾）</h4> 
<p><mark>创建一个标准的脚本，实现有注释信息，版权信息，内容任意，并执行</mark></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># vim  cmatrix.sh   #写入以下内容</span>
<span class="token function">wget</span> http://archive.ubuntu.com/ubuntu/pool/universe/c/cmatrix/cmatrix_1.2a.orig.tar.gz
<span class="token function">tar</span> xvf cmatrix_1.2a.orig.tar.gz
<span class="token builtin class-name">cd</span> cmatrix-1.2a
yum <span class="token function">install</span> <span class="token parameter variable">-y</span>  ncurses-devel
yum <span class="token function">install</span> <span class="token parameter variable">-y</span>  gcc
./configure <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Program installation complete !"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Program installation complete !"</span>
<span class="token builtin class-name">echo</span> <span class="token string">"Program installation complete !"</span>


<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># bash  cmatrix.sh  #执行脚本</span>
<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># cmatrix</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ca/98/1TnSklwl_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/68/f4/EwlHnf6u_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_150"></a>脚本中尽量不用中文注释</h3> 
<ul><li>别吝啬添加注释，必要的注释方便自己别人理解脚本逻辑和功能</li><li><mark>尽量用英文注释</mark>，<mark>防止本机或切换系统环境后中文乱码的困扰</mark></li><li>单行注释，可以放在代码行的尾部或代码行的上部</li><li>多行注释，用于注解复杂的功能说明，可以放在程序体中，也可以放在代码块的开始部分 代码修改时，对修改的内容</li></ul> 
<h3><a id="_156"></a>多使用内部命令</h3> 
<ul><li>无论碰到哪种情况，请尽量考虑使用内部命令而不是外部命令</li><li>内部命令执行的效率高，性能好</li></ul> 
<h3><a id="cat_160"></a>没有必要使用cat命令</h3> 
<ul><li>这是我们经常在论坛里讨论的话题之一。没有必要使用cat命令指的是在有些时候，我们会发现<mark>根本没有必要使用cat命令</mark>。使用了<mark>多余的cat命令</mark>会让你的代码<mark>看起来很丑陋</mark>，而且<mark>还会带来性能上的问题</mark></li><li>例如：以下两条命令的结果一样</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/passwd | grep root </span>

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># grep root /etc/passwd  </span>
</code></pre> 
<h3><a id="_169"></a>仔细阅读出错信息</h3> 
<ul><li>程序员常犯的一个错误是：<mark>当我们敲入的命令报错后，我们中的大多数人只是对错误信息一瞥而过，而不会去认真的读一读，很多时候，错误信息里就包含了解决办法</mark></li><li>有时候我们修改了某个错误并再次运行后，系统依旧会报错。然后我们再次修改，但系统再次报错。这可能会持续很长时间。但实际上，旧的错误可能已经被纠正，只是由于出现了其它一些新错误才导致系统再次报错。而我们依旧在怀疑为什么修改好的代码依然不能正常运行。</li><li><mark>因此，请你养成仔细阅读错误信息的习惯。</mark></li></ul> 
<h3><a id="sh_175"></a>文件名以.sh结尾</h3> 
<ul><li>shell脚本文件名应见名知义，<mark>扩展名为.sh，如：backup_mysql.sh</mark></li></ul> 
<h3><a id="_179"></a>代码缩进</h3> 
<ul><li><mark>shell没有强制要求，但建议缩进</mark>，这样可以<mark>提高阅读性，程序更有层次感</mark></li></ul> 
<h4><a id="_182"></a>示例：编写九九乘法表</h4> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># vim  99.sh</span>

<span class="token comment">#!/bin/bash</span>

<span class="token keyword">for</span><span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
        <span class="token builtin class-name">echo</span>  <span class="token parameter variable">-ne</span>  <span class="token string">"<span class="token variable">$i</span><span class="token entity" title="\t">\t</span>"</span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span>
<span class="token keyword">for</span><span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">70</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
        <span class="token builtin class-name">echo</span>  <span class="token parameter variable">-n</span>  <span class="token string">"="</span>
<span class="token keyword">done</span>
<span class="token builtin class-name">echo</span>
<span class="token keyword">for</span><span class="token variable"><span class="token punctuation">((</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">))</span></span>
<span class="token keyword">do</span>
        <span class="token keyword">for</span><span class="token variable"><span class="token punctuation">((</span>j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">))</span></span>
        <span class="token keyword">do</span>
                <span class="token builtin class-name">echo</span>  <span class="token parameter variable">-en</span>  <span class="token string">"<span class="token variable">$i</span>*<span class="token variable">$j</span>=$[i*j]<span class="token entity" title="\t">\t</span>"</span>
        <span class="token keyword">done</span>
        <span class="token builtin class-name">echo</span>
<span class="token keyword">done</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4c/2c/qzIpeSm1_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># bash 99.sh</span>
<span class="token number">1</span>       <span class="token number">2</span>       <span class="token number">3</span>       <span class="token number">4</span>       <span class="token number">5</span>       <span class="token number">6</span>       <span class="token number">7</span>       <span class="token number">8</span>       <span class="token number">9</span>
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>
<span class="token number">1</span>*1<span class="token operator">=</span><span class="token number">1</span>
<span class="token number">2</span>*1<span class="token operator">=</span><span class="token number">2</span>   <span class="token number">2</span>*2<span class="token operator">=</span><span class="token number">4</span>
<span class="token number">3</span>*1<span class="token operator">=</span><span class="token number">3</span>   <span class="token number">3</span>*2<span class="token operator">=</span><span class="token number">6</span>   <span class="token number">3</span>*3<span class="token operator">=</span><span class="token number">9</span>
<span class="token number">4</span>*1<span class="token operator">=</span><span class="token number">4</span>   <span class="token number">4</span>*2<span class="token operator">=</span><span class="token number">8</span>   <span class="token number">4</span>*3<span class="token operator">=</span><span class="token number">12</span>  <span class="token number">4</span>*4<span class="token operator">=</span><span class="token number">16</span>
<span class="token number">5</span>*1<span class="token operator">=</span><span class="token number">5</span>   <span class="token number">5</span>*2<span class="token operator">=</span><span class="token number">10</span>  <span class="token number">5</span>*3<span class="token operator">=</span><span class="token number">15</span>  <span class="token number">5</span>*4<span class="token operator">=</span><span class="token number">20</span>  <span class="token number">5</span>*5<span class="token operator">=</span><span class="token number">25</span>
<span class="token number">6</span>*1<span class="token operator">=</span><span class="token number">6</span>   <span class="token number">6</span>*2<span class="token operator">=</span><span class="token number">12</span>  <span class="token number">6</span>*3<span class="token operator">=</span><span class="token number">18</span>  <span class="token number">6</span>*4<span class="token operator">=</span><span class="token number">24</span>  <span class="token number">6</span>*5<span class="token operator">=</span><span class="token number">30</span>  <span class="token number">6</span>*6<span class="token operator">=</span><span class="token number">36</span>
<span class="token number">7</span>*1<span class="token operator">=</span><span class="token number">7</span>   <span class="token number">7</span>*2<span class="token operator">=</span><span class="token number">14</span>  <span class="token number">7</span>*3<span class="token operator">=</span><span class="token number">21</span>  <span class="token number">7</span>*4<span class="token operator">=</span><span class="token number">28</span>  <span class="token number">7</span>*5<span class="token operator">=</span><span class="token number">35</span>  <span class="token number">7</span>*6<span class="token operator">=</span><span class="token number">42</span>  <span class="token number">7</span>*7<span class="token operator">=</span><span class="token number">49</span>
<span class="token number">8</span>*1<span class="token operator">=</span><span class="token number">8</span>   <span class="token number">8</span>*2<span class="token operator">=</span><span class="token number">16</span>  <span class="token number">8</span>*3<span class="token operator">=</span><span class="token number">24</span>  <span class="token number">8</span>*4<span class="token operator">=</span><span class="token number">32</span>  <span class="token number">8</span>*5<span class="token operator">=</span><span class="token number">40</span>  <span class="token number">8</span>*6<span class="token operator">=</span><span class="token number">48</span>  <span class="token number">8</span>*7<span class="token operator">=</span><span class="token number">56</span>  <span class="token number">8</span>*8<span class="token operator">=</span><span class="token number">64</span>
<span class="token number">9</span>*1<span class="token operator">=</span><span class="token number">9</span>   <span class="token number">9</span>*2<span class="token operator">=</span><span class="token number">18</span>  <span class="token number">9</span>*3<span class="token operator">=</span><span class="token number">27</span>  <span class="token number">9</span>*4<span class="token operator">=</span><span class="token number">36</span>  <span class="token number">9</span>*5<span class="token operator">=</span><span class="token number">45</span>  <span class="token number">9</span>*6<span class="token operator">=</span><span class="token number">54</span>  <span class="token number">9</span>*7<span class="token operator">=</span><span class="token number">63</span>  <span class="token number">9</span>*8<span class="token operator">=</span><span class="token number">72</span>  <span class="token number">9</span>*9<span class="token operator">=</span><span class="token number">81</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/9a/df/rncAmLVW_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="shell_225"></a>shell脚本执行方法</h2> 
<h3><a id="1_226"></a>方法1</h3> 
<ul><li><mark>使用sh或bash命令执行脚本</mark>，<mark>不需要执行权限</mark>（<mark>建议使用</mark>）（<mark>为什么不需要权限，因为：脚本文件名会作为参数，传递给脚本解释器去执行，只要解释器本省有权限就可以了</mark>）</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># vim  test.sh</span>
<span class="token comment">#!/bin/bash</span>
<span class="token builtin class-name">echo</span>  <span class="token string">"china"</span>

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># bash  test.sh</span>
china
<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># sh  test.sh</span>
china
</code></pre> 
<ul><li><code>可以使用bash -n 脚本名 ，进行语法检测，且不执行脚本</code></li><li><code>可以使用bash -x 脚本名 ，进行脚本执行跟踪，逐条语句的跟踪执行</code></li></ul> 
<h3><a id="2_242"></a>方法2</h3> 
<ul><li><mark>切换到脚本所在目录</mark>使用 <mark>./脚本文件</mark>，需要该脚本文件执行权限（需要配合cd进行目录切换 ，因为是在当前目录下）</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ll -d test.sh</span>
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">334</span>  <span class="token number">3</span>月 <span class="token number">14</span> 00:00 test.sh

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ./test.sh</span>
-bash: ./test.sh: 权限不够

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># chmod +x test.sh</span>

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ll -d test.sh</span>
-rwxr-xr-x <span class="token number">1</span> root root <span class="token number">334</span>  <span class="token number">3</span>月 <span class="token number">14</span> 00:00 test.sh

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ./test.sh</span>
china
</code></pre> 
<h3><a id="3_260"></a>方法3</h3> 
<ul><li><mark>绝对路径执行脚本</mark>，<mark>需要执行权限</mark></li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># vim /t1.sh</span>
<span class="token comment">#!/bin/bash</span>
<span class="token builtin class-name">echo</span>  <span class="token string">"china"</span>


<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># /t1.sh</span>
-bash: /t1.sh: 权限不够

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ll -d /t1.sh</span>
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">333</span>  <span class="token number">3</span>月 <span class="token number">14</span> 00:07 /t1.sh

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># chmod +x /t1.sh</span>

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ll -d /t1.sh</span>
-rwxr-xr-x <span class="token number">1</span> root root <span class="token number">333</span>  <span class="token number">3</span>月 <span class="token number">14</span> 00:07 /t1.sh

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># /t1.sh</span>
china
</code></pre> 
<h3><a id="4_283"></a>方法4</h3> 
<ul><li>使用<mark>点(.)或者source</mark>执行脚本，<mark>不需要执行权限</mark></li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># source /t1.sh</span>
china
<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># . test.sh</span>
china
</code></pre> 
<h4><a id="_292"></a>注意：</h4> 
<ul><li><mark>法1，2，3</mark>都是<mark>启动一个子shell</mark>，在<mark>子shell中</mark>执行<mark>此脚本</mark>，<mark>脚本中设置的变量</mark>在脚本<mark>执行完毕后不会保存</mark></li><li><mark>法4</mark>都是在<mark>当前shell进程中</mark>执行<mark>此脚本</mark>，而<mark>不是重新启动</mark>一个shell <mark>在子shell进程中</mark> 执行此脚本，<mark>并且脚本中设置的变量在脚本执行完毕后会保存下来</mark></li></ul> 
<h2><a id="bash_shell_296"></a>bash shell基本功能</h2> 
<h3><a id="echo_297"></a>echo打印命令</h3> 
<ul><li> <p>格式：<code>echo -参数 内容</code></p> </li><li> <p>参数：</p> 
  <ul><li>-n：<mark>取消输出后行未得换行符号</mark></li><li>-e：<mark>启用转义字符</mark></li></ul> </li><li> <p>可以输出带颜色得字体：</p> </li><li> <p>格式：<code>echo -e "\e[字体控制；字体颜色或背景色 字符串内容 \e[0m"</code></p> </li><li> <p>\e[表示控制开始，\e[0m表示控制结束</p> </li><li> <p>字体控制选项：<mark>1</mark>表示<mark>高亮</mark>，<mark>4</mark>表示<mark>下划线</mark>，<mark>5</mark>颜色<mark>闪烁</mark></p> </li><li> <p>颜色如下：<mark>字颜色：30-37</mark> , <mark>背景色：40-47</mark></p> </li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># vim color.sh</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[30m 黑色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[1;31m 紅色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[32m 綠色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[33m 黃色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[34m 藍色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[35m 紫色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[36m 天藍字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[37m 白色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[40;37m 黑底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[41;37m 紅底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[42;37m 綠底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[43;37m 黃底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[44;37m 藍底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[45;37m 紫底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[46;37m 天藍底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[47;30m 白底黑字<span class="token entity" title="\e">\e</span>[0m"</span>

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># bash color.sh </span>

<span class="token comment">#!/bin/bash</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[30m 黑色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[1;31m 紅色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[32m 綠色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[33m 黃色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[34m 藍色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[35m 紫色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[36m 天藍字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[37m 白色字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[40;37m 黑底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[41;37m 紅底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[42;37m 綠底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[43;37m 黃底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[44;37m 藍底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[45;37m 紫底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[46;37m 天藍底白字<span class="token entity" title="\e">\e</span>[0m"</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"<span class="token entity" title="\e">\e</span>[47;30m 白底黑字<span class="token entity" title="\e">\e</span>[0m"</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d7/68/WURpoVho_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># bash color.sh </span>
</code></pre> 
<p><img src="https://images2.imgbox.com/31/85/pCsDA9hc_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="printf_355"></a>printf命令</h3> 
<ul><li>printf 命令模仿 C 程序库（library）里的 printf() 程序， 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好，printf 使用引用文本或空格分隔的参数，<mark>外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等</mark>。<mark>默认 printf 不会像 echo 自动添加换行符</mark>，我们<mark>可以手动添加 \n</mark></li><li>格式</li></ul> 
<pre><code class="prism language-bash"><span class="token builtin class-name">printf</span>   格式控制字符串   参数列表
</code></pre> 
<h4><a id="_362"></a>示例</h4> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># echo "hello world"</span>
hello world

<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># printf "hello, shell\n"</span>
hello, shell


<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># printf "%d %s\n" 1 'abc'</span>
<span class="token number">1</span> abc


<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># printf "%-10s %-8s %-4s\n" '华子' '男' '130'</span>
华子     男      <span class="token number">130</span>

<span class="token comment"># %s %c %d %f 都是格式替代符，％s 输出一个字符串，％d 整型输出，％c 输出一个字符，％f 输出实数，以小数形式输出。</span>
<span class="token comment"># %-10s 指一个宽度为 10 个字符（- 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</span>


<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># printf "%-10s %-8s %-4.2f\n" '郭靖' '男' 66.1234</span>
郭靖     男      <span class="token number">66.12</span>

<span class="token comment"># %-4.2f 指格式化为小数，其中 .2 指保留2位小数</span>
</code></pre> 
<h3><a id="history_388"></a>history历史命令</h3> 
<ul><li>格式</li></ul> 
<pre><code class="prism language-bash"><span class="token function">history</span> <span class="token punctuation">[</span>参数<span class="token punctuation">]</span> <span class="token punctuation">[</span>历史命令保存文件<span class="token punctuation">]</span>
</code></pre> 
<ul><li> <p>参数</p> 
  <ul><li>-c：<mark>清空历史命令记录</mark></li><li>-w：把<mark>缓存中的历史命令</mark>写入<mark>历史命令保存文件</mark>。如果不手工指定历史命令保存文件，则放入<mark>默认历史命令保存文件~/.bash_history 中</mark></li></ul> </li><li> <p><mark>修改默认记录历史命令条数：</mark></p> </li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># vim  /etc/profile   （重启生效）</span>
<span class="token assign-left variable"><span class="token environment constant">HISTSIZE</span></span><span class="token operator">=</span><span class="token number">1000</span>     <span class="token comment">#储存历史命令记录条数</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/68/cb/f7vHhG32_o.png" alt="在这里插入图片描述"></p> 
<ul><li>面试题：显示history历史命令出现次数最高的top10</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server /<span class="token punctuation">]</span><span class="token comment"># history  |  tr  -s  " " | cut -d " "  -f3  | sort |  uniq -c | sort -nr  |  head -10</span>

<span class="token comment"># 浏览历史命令 | 压缩为1个空格 | 截取以空格为间隔的第3列 | 排序 | 统计并去重 | 以次数为依据进行降序排序 | 取前10个</span>
</code></pre> 
<ul><li>面试题：<mark>增加history显示的信息</mark>，如：<mark>历史命令的执行时间</mark></li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server /<span class="token punctuation">]</span><span class="token comment"># vim   ~/.bashrc  # 编辑bash的配置文件，最后一行后添加：</span>
<span class="token builtin class-name">export</span>  <span class="token assign-left variable">HISTTIMEFORMAT</span><span class="token operator">=</span><span class="token string">"%Y-%m-%d %H:%M:%S: "</span>

<span class="token punctuation">[</span>root@server /<span class="token punctuation">]</span><span class="token comment"># source  ~/.bashrc  # 刷新配置</span>
<span class="token punctuation">[</span>root@server /<span class="token punctuation">]</span><span class="token comment"># history            # 查看结果</span>
</code></pre> 
<h3><a id="tab_421"></a>命令与文件名补全：tab</h3> 
<h3><a id="_422"></a>命令别名</h3> 
<ul><li>格式：<code>alias 别名=原命令</code></li><li>例：</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># alias  hi=history  #重启无效</span>
<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># hi</span>
</code></pre> 
<ul><li>注意：别名的优先级比命令高，命令执行时的顺序如下：</li></ul> 
<pre><code class="prism language-bash">第一顺位：执行用绝对路径或相对路径执行的命令。
第二顺位：执行别名。
第三顺位：执行 Bash 的内部命令。
第四顺位：执行按照 <span class="token environment constant">$PATH</span> 环境变量定义的目录查找顺序找到的第一个命令。
</code></pre> 
<ul><li>为了让这个<mark>别名永久生效</mark>，可以把<mark>别名写入环境变量配置文件"~/.bashrc"</mark></li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># vim   ~/.bashrc  # 在最下面增加</span>
<span class="token builtin class-name">alias</span>  <span class="token assign-left variable">hi</span><span class="token operator">=</span>history
</code></pre> 
<h3><a id="_444"></a>命令执行顺序</h3> 
<ul><li>顺序执行（<mark>用分号分隔</mark>）</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># date ; ls -l /etc/passwd</span>
</code></pre> 
<ul><li>前面命令执行不成功，后面的命令不执行： &amp;&amp;</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># mkdir /mnt/iso &amp;&amp; mount /dev/sr0 /mnt/iso</span>
</code></pre> 
<ul><li>前面命令成功，后面就不执行，如果前面不成功后面就执行： ||</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># mkdir  tt  ||  ls  /</span>
<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># mkdir  tt  ||  ls  /  # 可以再次执行</span>
</code></pre> 
<h3><a id="_461"></a>管道符</h3> 
<ul><li>符号：| ,当在两个命令之间设置管道时，管道符|左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道</li><li><mark>面试题：获取服务器的IP地址</mark></li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ip  a  |  grep  ens160 | grep  inet | tr  -s " " | cut -d " " -f3</span>
<span class="token number">192.168</span>.48.130/24
<span class="token comment"># 查看IP信息 | 过滤包含esn160行 | 过滤包含inet行 | 压缩空格为1个 | 列向截取列</span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ip  a  |  grep  ens160 | grep  inet | cut -d  "/"  -f1 | cut -d " " -f6</span>
<span class="token number">192.168</span>.48.130
</code></pre> 
<ul><li><mark>面试题：显示内存的剩余容量</mark></li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># free -h | grep  Mem | tr  -s  " " | cut -d " " -f4</span>
</code></pre> 
<h3><a id="exit_480"></a>exit退出程序</h3> 
<ul><li>作用：终止Shell程序的执行</li><li><mark>格式：exit 状态码</mark></li><li><mark>状态码：该参数是一个整数值，其取值范围为0~255</mark></li><li>注意：<mark>Shell程序的退出状态码</mark>储存在 <mark>系统变量$?中</mark>，因此，用户可以通过该变量取得Shell程序返回给父进程的退出状态码</li></ul> 
<h4><a id="_486"></a>常见状态码</h4> 
<pre><code class="prism language-bash">	<span class="token number">0</span>----------------命令运行成功
    <span class="token number">1</span>----------------通知未知错误
    <span class="token number">2</span>----------------误用shell命令
    <span class="token number">126</span>-------------命令不可执行
    <span class="token number">127</span>-------------没有找到命令
    <span class="token number">128</span>-------------无效退出参数
    <span class="token number">128</span>+x-----------linux信号x的严重错误
    <span class="token number">130</span>--------------命令通过Ctrl+C终止
    <span class="token number">255</span>--------------退出状态码越界
</code></pre> 
<ul><li>演示在不同的情况下，程序返回不同的状态码</li></ul> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># echo 'china'</span>
china
<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># echo $?</span>
<span class="token number">0</span>
<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># ehco 'china'</span>
bash: ehco: <span class="token builtin class-name">command</span> not found<span class="token punctuation">..</span>.
Similar <span class="token builtin class-name">command</span> is: <span class="token string">'echo'</span>
<span class="token punctuation">[</span>root@server ~<span class="token punctuation">]</span><span class="token comment"># echo $?</span>
<span class="token number">127</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/12ecb118e3e706207663734c145fd6ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">最全面的Windows 11原版系统镜像下载（不断完善更新中……）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9da5867e99f906b7ec9363477043708a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数字图像预处理的理论分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>