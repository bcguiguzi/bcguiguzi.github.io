<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hadoop中MapReduce程序的本地IDEA测试（及org.apache.hadoop.io.nativeio问题） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hadoop中MapReduce程序的本地IDEA测试（及org.apache.hadoop.io.nativeio问题）" />
<meta property="og:description" content="目录
一、配置Hadoop环境
二、编写MapReduce程序
三、本地测试
1.run——&gt;Edit Configurations
2.Create a new configuration
3.修改以下内容
4.在Driver类中运行程序
5.运行成功
一、在IDEA中配置Hadoop环境 1.创建一个maven工程后，修改pom.xml文件
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;project xmlns=&#34;http://maven.apache.org/POM/4.0.0&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&#34;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.atguigu&lt;/groupId&gt; &lt;artifactId&gt;mr-0529&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 2.在项目的src/main/resources目录下，新建一个文件，命名为“log4j.properties”
log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.logfile=org.apache.log4j.FileAppender log4j.appender.logfile.File=target/spring.log log4j.appender.logfile.layout=org.apache.log4j.PatternLayout log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n 二、编写MapReduce程序 分别编写Mapper、Reducer和Driver类，其中Driver类是主类" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/4f1f09c2411baa8a8d146afd47b5c93a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-02T16:46:44+08:00" />
<meta property="article:modified_time" content="2020-12-02T16:46:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hadoop中MapReduce程序的本地IDEA测试（及org.apache.hadoop.io.nativeio问题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E9%85%8D%E7%BD%AEHadoop%E7%8E%AF%E5%A2%83-toc" style="margin-left:40px;"><a href="#%E4%B8%80%E3%80%81%E9%85%8D%E7%BD%AEHadoop%E7%8E%AF%E5%A2%83" rel="nofollow">一、配置Hadoop环境</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99MapReduce%E7%A8%8B%E5%BA%8F-toc" style="margin-left:40px;"><a href="#%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99MapReduce%E7%A8%8B%E5%BA%8F" rel="nofollow">二、编写MapReduce程序</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95-toc" style="margin-left:40px;"><a href="#%E4%B8%89%E3%80%81%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95" rel="nofollow">三、本地测试</a></p> 
<p id="1.run%E2%80%94%E2%80%94%3EEdit%20Configurations-toc" style="margin-left:80px;"><a href="#1.run%E2%80%94%E2%80%94%3EEdit%20Configurations" rel="nofollow">1.run——&gt;Edit Configurations</a></p> 
<p id="2.Create%20a%20new%20configuration-toc" style="margin-left:80px;"><a href="#2.Create%20a%20new%20configuration" rel="nofollow">2.Create a new configuration</a></p> 
<p id="3.%E4%BF%AE%E6%94%B9%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9-toc" style="margin-left:80px;"><a href="#3.%E4%BF%AE%E6%94%B9%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9" rel="nofollow">3.修改以下内容</a></p> 
<p id="4.%E5%9C%A8Driver%E7%B1%BB%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-toc" style="margin-left:80px;"><a href="#4.%E5%9C%A8Driver%E7%B1%BB%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F" rel="nofollow">4.在Driver类中运行程序</a></p> 
<p id="5.%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F-toc" style="margin-left:80px;"><a href="#5.%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F" rel="nofollow">5.运行成功</a></p> 
<hr id="hr-toc"> 
<h3 id="%E4%B8%80%E3%80%81%E9%85%8D%E7%BD%AEHadoop%E7%8E%AF%E5%A2%83">一、在IDEA中配置Hadoop环境</h3> 
<p><strong>1.创建一个maven工程后，修改pom.xml文件</strong></p> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.atguigu&lt;/groupId&gt;
    &lt;artifactId&gt;mr-0529&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
            &lt;version&gt;2.8.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;
            &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;
            &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;
            &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;
            &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;
            &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;
            &lt;version&gt;2.7.3&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;</code></pre> 
<p><strong>2.在项目的src/main/resources目录下，新建一个文件，命名为“log4j.properties”</strong></p> 
<pre><code>log4j.rootLogger=INFO, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n
log4j.appender.logfile=org.apache.log4j.FileAppender
log4j.appender.logfile.File=target/spring.log
log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n</code></pre> 
<h3 id="%E4%BA%8C%E3%80%81%E7%BC%96%E5%86%99MapReduce%E7%A8%8B%E5%BA%8F">二、编写MapReduce程序</h3> 
<p><strong>分别编写Mapper、Reducer和Driver类，其中Driver类是主类</strong></p> 
<h3 id="%E4%B8%89%E3%80%81%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95">三、本地测试</h3> 
<p><strong>在IDEA中进行本地测试，案例有3个类。（其实MapReduce程序都是这3个类：Mapper、Reducer、Driver）</strong></p> 
<h4 id="1.run%E2%80%94%E2%80%94%3EEdit%20Configurations"><strong>1.run——&gt;Edit Configurations</strong></h4> 
<p><img alt="" height="381" src="https://images2.imgbox.com/d0/87/uRKtCDyf_o.png" width="348"></p> 
<h4 id="2.Create%20a%20new%20configuration"><strong>2.Create a new configuration</strong></h4> 
<p><img alt="" height="441" src="https://images2.imgbox.com/a7/89/mXWKIQwa_o.png" width="692"></p> 
<h4 id="3.%E4%BF%AE%E6%94%B9%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9">3.修改以下内容</h4> 
<p><img alt="" height="436" src="https://images2.imgbox.com/f4/15/7mMUFrqE_o.png" width="687"></p> 
<p><span style="color:#f33b45;"><strong>注意：修改Program arguments时，前面是输入数据的路径，后面是输出数据的路径，输出数据的路径是一个文件夹，这个文件夹不能在程序执行前被创建好，否则会报错</strong></span></p> 
<pre><code>Exception in thread "main" org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory file:/E:/IDEA/exercise_project/mr-0529/output already exists</code></pre> 
<h4 id="4.%E5%9C%A8Driver%E7%B1%BB%E4%B8%AD%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><strong>4.在Driver类中运行程序</strong></h4> 
<p><strong>当在Driver类中执行程序的时候，极有可能出现报错，但是不要慌，这是因为在新版本的windows系统中，会取消部分文件，某些功能无法支持。本地的NativeIO无法写入，我们需要再写一个NativeIO的类，放入代码片段的包中。</strong></p> 
<pre><code>Exception in thread "main" java.lang.UnsatisfiedLinkError: org.apache.hadoop.io.nativeio.NativeIO$Windows.access0(Ljava/lang/String;I)Z
	at org.apache.hadoop.io.nativeio.NativeIO$Windows.access0(Native Method)
	at org.apache.hadoop.io.nativeio.NativeIO$Windows.access(NativeIO.java:609)
	at org.apache.hadoop.fs.FileUtil.canRead(FileUtil.java:977)
	at org.apache.hadoop.util.DiskChecker.checkAccessByFileMethods(DiskChecker.java:187)
	at org.apache.hadoop.util.DiskChecker.checkDirAccess(DiskChecker.java:174)
	at org.apache.hadoop.util.DiskChecker.checkDir(DiskChecker.java:108)
	at org.apache.hadoop.fs.LocalDirAllocator$AllocatorPerContext.confChanged(LocalDirAllocator.java:285)
	at org.apache.hadoop.fs.LocalDirAllocator$AllocatorPerContext.getLocalPathForWrite(LocalDirAllocator.java:344)
	at org.apache.hadoop.fs.LocalDirAllocator.getLocalPathForWrite(LocalDirAllocator.java:150)
	at org.apache.hadoop.fs.LocalDirAllocator.getLocalPathForWrite(LocalDirAllocator.java:131)
	at org.apache.hadoop.fs.LocalDirAllocator.getLocalPathForWrite(LocalDirAllocator.java:115)
	at org.apache.hadoop.mapred.LocalDistributedCacheManager.setup(LocalDistributedCacheManager.java:125)
	at org.apache.hadoop.mapred.LocalJobRunner$Job.&lt;init&gt;(LocalJobRunner.java:163)
	at org.apache.hadoop.mapred.LocalJobRunner.submitJob(LocalJobRunner.java:731)
	at org.apache.hadoop.mapreduce.JobSubmitter.submitJobInternal(JobSubmitter.java:240)
	at org.apache.hadoop.mapreduce.Job$10.run(Job.java:1290)
	at org.apache.hadoop.mapreduce.Job$10.run(Job.java:1287)
	at java.security.AccessController.doPrivileged(Native Method)
	at javax.security.auth.Subject.doAs(Subject.java:422)
	at org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1698)
	at org.apache.hadoop.mapreduce.Job.submit(Job.java:1287)
	at org.apache.hadoop.mapreduce.Job.waitForCompletion(Job.java:1308)
	at com.atguigu.mr.wordcount.WordcountDriver.main(WordcountDriver.java:39)

Process finished with exit code 1
</code></pre> 
<p><strong>解决办法：</strong></p> 
<p><strong>①方法一：</strong></p> 
<p><strong> 拷贝hadoop.dll(此文件在hadoop/bin 目录下)文件到Windows目录C:\Windows\System32。</strong></p> 
<p><br><strong>②方案二:</strong></p> 
<p><strong>在项目下创建org.apache.hadoop.io.nativeio 并创建NativeIO类:</strong></p> 
<p><img alt="" height="550" src="https://images2.imgbox.com/19/02/g7X2ow9K_o.png" width="452"></p> 
<pre><code>/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.hadoop.io.nativeio;

import java.io.File;
import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Field;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import org.apache.hadoop.classification.InterfaceAudience;
import org.apache.hadoop.classification.InterfaceStability;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.CommonConfigurationKeys;
import org.apache.hadoop.fs.HardLink;
import org.apache.hadoop.io.IOUtils;
import org.apache.hadoop.io.SecureIOUtils.AlreadyExistsException;
import org.apache.hadoop.util.NativeCodeLoader;
import org.apache.hadoop.util.Shell;
import org.apache.hadoop.util.PerformanceAdvisory;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import sun.misc.Unsafe;

import com.google.common.annotations.VisibleForTesting;

/**
 * JNI wrappers for various native IO-related calls not available in Java.
 * These functions should generally be used alongside a fallback to another
 * more portable mechanism.
 */
@InterfaceAudience.Private
@InterfaceStability.Unstable
public class NativeIO {
    public static class POSIX {
        // Flags for open() call from bits/fcntl.h
        public static final int O_RDONLY   =    00;
        public static final int O_WRONLY   =    01;
        public static final int O_RDWR     =    02;
        public static final int O_CREAT    =  0100;
        public static final int O_EXCL     =  0200;
        public static final int O_NOCTTY   =  0400;
        public static final int O_TRUNC    = 01000;
        public static final int O_APPEND   = 02000;
        public static final int O_NONBLOCK = 04000;
        public static final int O_SYNC   =  010000;
        public static final int O_ASYNC  =  020000;
        public static final int O_FSYNC = O_SYNC;
        public static final int O_NDELAY = O_NONBLOCK;

        // Flags for posix_fadvise() from bits/fcntl.h
        /* No further special treatment.  */
        public static final int POSIX_FADV_NORMAL = 0;
        /* Expect random page references.  */
        public static final int POSIX_FADV_RANDOM = 1;
        /* Expect sequential page references.  */
        public static final int POSIX_FADV_SEQUENTIAL = 2;
        /* Will need these pages.  */
        public static final int POSIX_FADV_WILLNEED = 3;
        /* Don't need these pages.  */
        public static final int POSIX_FADV_DONTNEED = 4;
        /* Data will be accessed once.  */
        public static final int POSIX_FADV_NOREUSE = 5;


        /* Wait upon writeout of all pages
           in the range before performing the
           write.  */
        public static final int SYNC_FILE_RANGE_WAIT_BEFORE = 1;
        /* Initiate writeout of all those
           dirty pages in the range which are
           not presently under writeback.  */
        public static final int SYNC_FILE_RANGE_WRITE = 2;

        /* Wait upon writeout of all pages in
           the range after performing the
           write.  */
        public static final int SYNC_FILE_RANGE_WAIT_AFTER = 4;

        private static final Log LOG = LogFactory.getLog(NativeIO.class);

        private static boolean nativeLoaded = false;
        private static boolean fadvisePossible = true;
        private static boolean syncFileRangePossible = true;

        static final String WORKAROUND_NON_THREADSAFE_CALLS_KEY =
                "hadoop.workaround.non.threadsafe.getpwuid";
        static final boolean WORKAROUND_NON_THREADSAFE_CALLS_DEFAULT = true;

        private static long cacheTimeout = -1;

        private static CacheManipulator cacheManipulator = new CacheManipulator();

        public static CacheManipulator getCacheManipulator() {
            return cacheManipulator;
        }

        public static void setCacheManipulator(CacheManipulator cacheManipulator) {
            POSIX.cacheManipulator = cacheManipulator;
        }

        /**
         * Used to manipulate the operating system cache.
         */
        @VisibleForTesting
        public static class CacheManipulator {
            public void mlock(String identifier, ByteBuffer buffer,
                              long len) throws IOException {
                POSIX.mlock(buffer, len);
            }

            public long getMemlockLimit() {
                return NativeIO.getMemlockLimit();
            }

            public long getOperatingSystemPageSize() {
                return NativeIO.getOperatingSystemPageSize();
            }

            public void posixFadviseIfPossible(String identifier,
                                               FileDescriptor fd, long offset, long len, int flags)
                    throws NativeIOException {
                POSIX.posixFadviseIfPossible(identifier, fd, offset,
                        len, flags);
            }

            public boolean verifyCanMlock() {
                return NativeIO.isAvailable();
            }
        }

        /**
         * A CacheManipulator used for testing which does not actually call mlock.
         * This allows many tests to be run even when the operating system does not
         * allow mlock, or only allows limited mlocking.
         */
        @VisibleForTesting
        public static class NoMlockCacheManipulator extends CacheManipulator {
            public void mlock(String identifier, ByteBuffer buffer,
                              long len) throws IOException {
                LOG.info("mlocking " + identifier);
            }

            public long getMemlockLimit() {
                return 1125899906842624L;
            }

            public long getOperatingSystemPageSize() {
                return 4096;
            }

            public boolean verifyCanMlock() {
                return true;
            }
        }

        static {
            if (NativeCodeLoader.isNativeCodeLoaded()) {
                try {
                    Configuration conf = new Configuration();
                    workaroundNonThreadSafePasswdCalls = conf.getBoolean(
                            WORKAROUND_NON_THREADSAFE_CALLS_KEY,
                            WORKAROUND_NON_THREADSAFE_CALLS_DEFAULT);

                    initNative();
                    nativeLoaded = true;

                    cacheTimeout = conf.getLong(
                            CommonConfigurationKeys.HADOOP_SECURITY_UID_NAME_CACHE_TIMEOUT_KEY,
                            CommonConfigurationKeys.HADOOP_SECURITY_UID_NAME_CACHE_TIMEOUT_DEFAULT) *
                            1000;
                    LOG.debug("Initialized cache for IDs to User/Group mapping with a " +
                            " cache timeout of " + cacheTimeout/1000 + " seconds.");

                } catch (Throwable t) {
                    // This can happen if the user has an older version of libhadoop.so
                    // installed - in this case we can continue without native IO
                    // after warning
                    PerformanceAdvisory.LOG.debug("Unable to initialize NativeIO libraries", t);
                }
            }
        }

        /**
         * Return true if the JNI-based native IO extensions are available.
         */
        public static boolean isAvailable() {
            return NativeCodeLoader.isNativeCodeLoaded() &amp;&amp; nativeLoaded;
        }

        private static void assertCodeLoaded() throws IOException {
            if (!isAvailable()) {
                throw new IOException("NativeIO was not loaded");
            }
        }

        /** Wrapper around open(2) */
        public static native FileDescriptor open(String path, int flags, int mode) throws IOException;
        /** Wrapper around fstat(2) */
        private static native Stat fstat(FileDescriptor fd) throws IOException;

        /** Native chmod implementation. On UNIX, it is a wrapper around chmod(2) */
        private static native void chmodImpl(String path, int mode) throws IOException;

        public static void chmod(String path, int mode) throws IOException {
            if (!Shell.WINDOWS) {
                chmodImpl(path, mode);
            } else {
                try {
                    chmodImpl(path, mode);
                } catch (NativeIOException nioe) {
                    if (nioe.getErrorCode() == 3) {
                        throw new NativeIOException("No such file or directory",
                                Errno.ENOENT);
                    } else {
                        LOG.warn(String.format("NativeIO.chmod error (%d): %s",
                                nioe.getErrorCode(), nioe.getMessage()));
                        throw new NativeIOException("Unknown error", Errno.UNKNOWN);
                    }
                }
            }
        }

        /** Wrapper around posix_fadvise(2) */
        static native void posix_fadvise(
                FileDescriptor fd, long offset, long len, int flags) throws NativeIOException;

        /** Wrapper around sync_file_range(2) */
        static native void sync_file_range(
                FileDescriptor fd, long offset, long nbytes, int flags) throws NativeIOException;

        /**
         * Call posix_fadvise on the given file descriptor. See the manpage
         * for this syscall for more information. On systems where this
         * call is not available, does nothing.
         *
         * @throws NativeIOException if there is an error with the syscall
         */
        static void posixFadviseIfPossible(String identifier,
                                           FileDescriptor fd, long offset, long len, int flags)
                throws NativeIOException {
            if (nativeLoaded &amp;&amp; fadvisePossible) {
                try {
                    posix_fadvise(fd, offset, len, flags);
                } catch (UnsupportedOperationException uoe) {
                    fadvisePossible = false;
                } catch (UnsatisfiedLinkError ule) {
                    fadvisePossible = false;
                }
            }
        }

        /**
         * Call sync_file_range on the given file descriptor. See the manpage
         * for this syscall for more information. On systems where this
         * call is not available, does nothing.
         *
         * @throws NativeIOException if there is an error with the syscall
         */
        public static void syncFileRangeIfPossible(
                FileDescriptor fd, long offset, long nbytes, int flags)
                throws NativeIOException {
            if (nativeLoaded &amp;&amp; syncFileRangePossible) {
                try {
                    sync_file_range(fd, offset, nbytes, flags);
                } catch (UnsupportedOperationException uoe) {
                    syncFileRangePossible = false;
                } catch (UnsatisfiedLinkError ule) {
                    syncFileRangePossible = false;
                }
            }
        }

        static native void mlock_native(
                ByteBuffer buffer, long len) throws NativeIOException;

        /**
         * Locks the provided direct ByteBuffer into memory, preventing it from
         * swapping out. After a buffer is locked, future accesses will not incur
         * a page fault.
         *
         * See the mlock(2) man page for more information.
         *
         * @throws NativeIOException
         */
        static void mlock(ByteBuffer buffer, long len)
                throws IOException {
            assertCodeLoaded();
            if (!buffer.isDirect()) {
                throw new IOException("Cannot mlock a non-direct ByteBuffer");
            }
            mlock_native(buffer, len);
        }

        /**
         * Unmaps the block from memory. See munmap(2).
         *
         * There isn't any portable way to unmap a memory region in Java.
         * So we use the sun.nio method here.
         * Note that unmapping a memory region could cause crashes if code
         * continues to reference the unmapped code.  However, if we don't
         * manually unmap the memory, we are dependent on the finalizer to
         * do it, and we have no idea when the finalizer will run.
         *
         * @param buffer    The buffer to unmap.
         */
        public static void munmap(MappedByteBuffer buffer) {
            if (buffer instanceof sun.nio.ch.DirectBuffer) {
                sun.misc.Cleaner cleaner =
                        ((sun.nio.ch.DirectBuffer)buffer).cleaner();
                cleaner.clean();
            }
        }

        /** Linux only methods used for getOwner() implementation */
        private static native long getUIDforFDOwnerforOwner(FileDescriptor fd) throws IOException;
        private static native String getUserName(long uid) throws IOException;

        /**
         * Result type of the fstat call
         */
        public static class Stat {
            private int ownerId, groupId;
            private String owner, group;
            private int mode;

            // Mode constants
            public static final int S_IFMT = 0170000;      /* type of file */
            public static final int   S_IFIFO  = 0010000;  /* named pipe (fifo) */
            public static final int   S_IFCHR  = 0020000;  /* character special */
            public static final int   S_IFDIR  = 0040000;  /* directory */
            public static final int   S_IFBLK  = 0060000;  /* block special */
            public static final int   S_IFREG  = 0100000;  /* regular */
            public static final int   S_IFLNK  = 0120000;  /* symbolic link */
            public static final int   S_IFSOCK = 0140000;  /* socket */
            public static final int   S_IFWHT  = 0160000;  /* whiteout */
            public static final int S_ISUID = 0004000;  /* set user id on execution */
            public static final int S_ISGID = 0002000;  /* set group id on execution */
            public static final int S_ISVTX = 0001000;  /* save swapped text even after use */
            public static final int S_IRUSR = 0000400;  /* read permission, owner */
            public static final int S_IWUSR = 0000200;  /* write permission, owner */
            public static final int S_IXUSR = 0000100;  /* execute/search permission, owner */

            Stat(int ownerId, int groupId, int mode) {
                this.ownerId = ownerId;
                this.groupId = groupId;
                this.mode = mode;
            }

            Stat(String owner, String group, int mode) {
                if (!Shell.WINDOWS) {
                    this.owner = owner;
                } else {
                    this.owner = stripDomain(owner);
                }
                if (!Shell.WINDOWS) {
                    this.group = group;
                } else {
                    this.group = stripDomain(group);
                }
                this.mode = mode;
            }

            @Override
            public String toString() {
                return "Stat(owner='" + owner + "', group='" + group + "'" +
                        ", mode=" + mode + ")";
            }

            public String getOwner() {
                return owner;
            }
            public String getGroup() {
                return group;
            }
            public int getMode() {
                return mode;
            }
        }

        /**
         * Returns the file stat for a file descriptor.
         *
         * @param fd file descriptor.
         * @return the file descriptor file stat.
         * @throws IOException thrown if there was an IO error while obtaining the file stat.
         */
        public static Stat getFstat(FileDescriptor fd) throws IOException {
            Stat stat = null;
            if (!Shell.WINDOWS) {
                stat = fstat(fd);
                stat.owner = getName(IdCache.USER, stat.ownerId);
                stat.group = getName(IdCache.GROUP, stat.groupId);
            } else {
                try {
                    stat = fstat(fd);
                } catch (NativeIOException nioe) {
                    if (nioe.getErrorCode() == 6) {
                        throw new NativeIOException("The handle is invalid.",
                                Errno.EBADF);
                    } else {
                        LOG.warn(String.format("NativeIO.getFstat error (%d): %s",
                                nioe.getErrorCode(), nioe.getMessage()));
                        throw new NativeIOException("Unknown error", Errno.UNKNOWN);
                    }
                }
            }
            return stat;
        }

        private static String getName(IdCache domain, int id) throws IOException {
            Map&lt;Integer, CachedName&gt; idNameCache = (domain == IdCache.USER)
                    ? USER_ID_NAME_CACHE : GROUP_ID_NAME_CACHE;
            String name;
            CachedName cachedName = idNameCache.get(id);
            long now = System.currentTimeMillis();
            if (cachedName != null &amp;&amp; (cachedName.timestamp + cacheTimeout) &gt; now) {
                name = cachedName.name;
            } else {
                name = (domain == IdCache.USER) ? getUserName(id) : getGroupName(id);
                if (LOG.isDebugEnabled()) {
                    String type = (domain == IdCache.USER) ? "UserName" : "GroupName";
                    LOG.debug("Got " + type + " " + name + " for ID " + id +
                            " from the native implementation");
                }
                cachedName = new CachedName(name, now);
                idNameCache.put(id, cachedName);
            }
            return name;
        }

        static native String getUserName(int uid) throws IOException;
        static native String getGroupName(int uid) throws IOException;

        private static class CachedName {
            final long timestamp;
            final String name;

            public CachedName(String name, long timestamp) {
                this.name = name;
                this.timestamp = timestamp;
            }
        }

        private static final Map&lt;Integer, CachedName&gt; USER_ID_NAME_CACHE =
                new ConcurrentHashMap&lt;Integer, CachedName&gt;();

        private static final Map&lt;Integer, CachedName&gt; GROUP_ID_NAME_CACHE =
                new ConcurrentHashMap&lt;Integer, CachedName&gt;();

        private enum IdCache { USER, GROUP }

        public final static int MMAP_PROT_READ = 0x1;
        public final static int MMAP_PROT_WRITE = 0x2;
        public final static int MMAP_PROT_EXEC = 0x4;

        public static native long mmap(FileDescriptor fd, int prot,
                                       boolean shared, long length) throws IOException;

        public static native void munmap(long addr, long length)
                throws IOException;
    }

    private static boolean workaroundNonThreadSafePasswdCalls = false;


    public static class Windows {
        // Flags for CreateFile() call on Windows
        public static final long GENERIC_READ = 0x80000000L;
        public static final long GENERIC_WRITE = 0x40000000L;

        public static final long FILE_SHARE_READ = 0x00000001L;
        public static final long FILE_SHARE_WRITE = 0x00000002L;
        public static final long FILE_SHARE_DELETE = 0x00000004L;

        public static final long CREATE_NEW = 1;
        public static final long CREATE_ALWAYS = 2;
        public static final long OPEN_EXISTING = 3;
        public static final long OPEN_ALWAYS = 4;
        public static final long TRUNCATE_EXISTING = 5;

        public static final long FILE_BEGIN = 0;
        public static final long FILE_CURRENT = 1;
        public static final long FILE_END = 2;

        public static final long FILE_ATTRIBUTE_NORMAL = 0x00000080L;

        /**
         * Create a directory with permissions set to the specified mode.  By setting
         * permissions at creation time, we avoid issues related to the user lacking
         * WRITE_DAC rights on subsequent chmod calls.  One example where this can
         * occur is writing to an SMB share where the user does not have Full Control
         * rights, and therefore WRITE_DAC is denied.
         *
         * @param path directory to create
         * @param mode permissions of new directory
         * @throws IOException if there is an I/O error
         */
        public static void createDirectoryWithMode(File path, int mode)
                throws IOException {
            createDirectoryWithMode0(path.getAbsolutePath(), mode);
        }

        /** Wrapper around CreateDirectory() on Windows */
        private static native void createDirectoryWithMode0(String path, int mode)
                throws NativeIOException;

        /** Wrapper around CreateFile() on Windows */
        public static native FileDescriptor createFile(String path,
                                                       long desiredAccess, long shareMode, long creationDisposition)
                throws IOException;

        /**
         * Create a file for write with permissions set to the specified mode.  By
         * setting permissions at creation time, we avoid issues related to the user
         * lacking WRITE_DAC rights on subsequent chmod calls.  One example where
         * this can occur is writing to an SMB share where the user does not have
         * Full Control rights, and therefore WRITE_DAC is denied.
         *
         * This method mimics the semantics implemented by the JDK in
         * {@link FileOutputStream}.  The file is opened for truncate or
         * append, the sharing mode allows other readers and writers, and paths
         * longer than MAX_PATH are supported.  (See io_util_md.c in the JDK.)
         *
         * @param path file to create
         * @param append if true, then open file for append
         * @param mode permissions of new directory
         * @return FileOutputStream of opened file
         * @throws IOException if there is an I/O error
         */
        public static FileOutputStream createFileOutputStreamWithMode(File path,
                                                                      boolean append, int mode) throws IOException {
            long desiredAccess = GENERIC_WRITE;
            long shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
            long creationDisposition = append ? OPEN_ALWAYS : CREATE_ALWAYS;
            return new FileOutputStream(createFileWithMode0(path.getAbsolutePath(),
                    desiredAccess, shareMode, creationDisposition, mode));
        }

        /** Wrapper around CreateFile() with security descriptor on Windows */
        private static native FileDescriptor createFileWithMode0(String path,
                                                                 long desiredAccess, long shareMode, long creationDisposition, int mode)
                throws NativeIOException;

        /** Wrapper around SetFilePointer() on Windows */
        public static native long setFilePointer(FileDescriptor fd,
                                                 long distanceToMove, long moveMethod) throws IOException;

        /** Windows only methods used for getOwner() implementation */
        private static native String getOwner(FileDescriptor fd) throws IOException;

        /** Supported list of Windows access right flags */
        public static enum AccessRight {
            ACCESS_READ (0x0001),      // FILE_READ_DATA
            ACCESS_WRITE (0x0002),     // FILE_WRITE_DATA
            ACCESS_EXECUTE (0x0020);   // FILE_EXECUTE

            private final int accessRight;
            AccessRight(int access) {
                accessRight = access;
            }

            public int accessRight() {
                return accessRight;
            }
        };

        /** Windows only method used to check if the current process has requested
         *  access rights on the given path. */
        private static native boolean access0(String path, int requestedAccess);

        /**
         * Checks whether the current process has desired access rights on
         * the given path.
         *
         * Longer term this native function can be substituted with JDK7
         * function Files#isReadable, isWritable, isExecutable.
         *
         * @param path input path
         * @param desiredAccess ACCESS_READ, ACCESS_WRITE or ACCESS_EXECUTE
         * @return true if access is allowed
         * @throws IOException I/O exception on error
         */
        public static boolean access(String path, AccessRight desiredAccess)
                throws IOException {
            //return access0(path, desiredAccess.accessRight());
            return true;
        }

        /**
         * Extends both the minimum and maximum working set size of the current
         * process.  This method gets the current minimum and maximum working set
         * size, adds the requested amount to each and then sets the minimum and
         * maximum working set size to the new values.  Controlling the working set
         * size of the process also controls the amount of memory it can lock.
         *
         * @param delta amount to increment minimum and maximum working set size
         * @throws IOException for any error
         * @see POSIX#mlock(ByteBuffer, long)
         */
        public static native void extendWorkingSetSize(long delta) throws IOException;

        static {
            if (NativeCodeLoader.isNativeCodeLoaded()) {
                try {
                    initNative();
                    nativeLoaded = true;
                } catch (Throwable t) {
                    // This can happen if the user has an older version of libhadoop.so
                    // installed - in this case we can continue without native IO
                    // after warning
                    PerformanceAdvisory.LOG.debug("Unable to initialize NativeIO libraries", t);
                }
            }
        }
    }

    private static final Log LOG = LogFactory.getLog(NativeIO.class);

    private static boolean nativeLoaded = false;

    static {
        if (NativeCodeLoader.isNativeCodeLoaded()) {
            try {
                initNative();
                nativeLoaded = true;
            } catch (Throwable t) {
                // This can happen if the user has an older version of libhadoop.so
                // installed - in this case we can continue without native IO
                // after warning
                PerformanceAdvisory.LOG.debug("Unable to initialize NativeIO libraries", t);
            }
        }
    }

    /**
     * Return true if the JNI-based native IO extensions are available.
     */
    public static boolean isAvailable() {
        return NativeCodeLoader.isNativeCodeLoaded() &amp;&amp; nativeLoaded;
    }

    /** Initialize the JNI method ID and class ID cache */
    private static native void initNative();

    /**
     * Get the maximum number of bytes that can be locked into memory at any
     * given point.
     *
     * @return 0 if no bytes can be locked into memory;
     *         Long.MAX_VALUE if there is no limit;
     *         The number of bytes that can be locked into memory otherwise.
     */
    static long getMemlockLimit() {
        return isAvailable() ? getMemlockLimit0() : 0;
    }

    private static native long getMemlockLimit0();

    /**
     * @return the operating system's page size.
     */
    static long getOperatingSystemPageSize() {
        try {
            Field f = Unsafe.class.getDeclaredField("theUnsafe");
            f.setAccessible(true);
            Unsafe unsafe = (Unsafe)f.get(null);
            return unsafe.pageSize();
        } catch (Throwable e) {
            LOG.warn("Unable to get operating system page size.  Guessing 4096.", e);
            return 4096;
        }
    }

    private static class CachedUid {
        final long timestamp;
        final String username;
        public CachedUid(String username, long timestamp) {
            this.timestamp = timestamp;
            this.username = username;
        }
    }
    private static final Map&lt;Long, CachedUid&gt; uidCache =
            new ConcurrentHashMap&lt;Long, CachedUid&gt;();
    private static long cacheTimeout;
    private static boolean initialized = false;

    /**
     * The Windows logon name has two part, NetBIOS domain name and
     * user account name, of the format DOMAIN\UserName. This method
     * will remove the domain part of the full logon name.
     *
     * @param Fthe full principal name containing the domain
     * @return name with domain removed
     */
    private static String stripDomain(String name) {
        int i = name.indexOf('\\');
        if (i != -1)
            name = name.substring(i + 1);
        return name;
    }

    public static String getOwner(FileDescriptor fd) throws IOException {
        ensureInitialized();
        if (Shell.WINDOWS) {
            String owner = Windows.getOwner(fd);
            owner = stripDomain(owner);
            return owner;
        } else {
            long uid = POSIX.getUIDforFDOwnerforOwner(fd);
            CachedUid cUid = uidCache.get(uid);
            long now = System.currentTimeMillis();
            if (cUid != null &amp;&amp; (cUid.timestamp + cacheTimeout) &gt; now) {
                return cUid.username;
            }
            String user = POSIX.getUserName(uid);
            LOG.info("Got UserName " + user + " for UID " + uid
                    + " from the native implementation");
            cUid = new CachedUid(user, now);
            uidCache.put(uid, cUid);
            return user;
        }
    }

    /**
     * Create a FileInputStream that shares delete permission on the
     * file opened, i.e. other process can delete the file the
     * FileInputStream is reading. Only Windows implementation uses
     * the native interface.
     */
    public static FileInputStream getShareDeleteFileInputStream(File f)
            throws IOException {
        if (!Shell.WINDOWS) {
            // On Linux the default FileInputStream shares delete permission
            // on the file opened.
            //
            return new FileInputStream(f);
        } else {
            // Use Windows native interface to create a FileInputStream that
            // shares delete permission on the file opened.
            //
            FileDescriptor fd = Windows.createFile(
                    f.getAbsolutePath(),
                    Windows.GENERIC_READ,
                    Windows.FILE_SHARE_READ |
                            Windows.FILE_SHARE_WRITE |
                            Windows.FILE_SHARE_DELETE,
                    Windows.OPEN_EXISTING);
            return new FileInputStream(fd);
        }
    }

    /**
     * Create a FileInputStream that shares delete permission on the
     * file opened at a given offset, i.e. other process can delete
     * the file the FileInputStream is reading. Only Windows implementation
     * uses the native interface.
     */
    public static FileInputStream getShareDeleteFileInputStream(File f, long seekOffset)
            throws IOException {
        if (!Shell.WINDOWS) {
            RandomAccessFile rf = new RandomAccessFile(f, "r");
            if (seekOffset &gt; 0) {
                rf.seek(seekOffset);
            }
            return new FileInputStream(rf.getFD());
        } else {
            // Use Windows native interface to create a FileInputStream that
            // shares delete permission on the file opened, and set it to the
            // given offset.
            //
            FileDescriptor fd = Windows.createFile(
                    f.getAbsolutePath(),
                    Windows.GENERIC_READ,
                    Windows.FILE_SHARE_READ |
                            Windows.FILE_SHARE_WRITE |
                            Windows.FILE_SHARE_DELETE,
                    Windows.OPEN_EXISTING);
            if (seekOffset &gt; 0)
                Windows.setFilePointer(fd, seekOffset, Windows.FILE_BEGIN);
            return new FileInputStream(fd);
        }
    }

    /**
     * Create the specified File for write access, ensuring that it does not exist.
     * @param f the file that we want to create
     * @param permissions we want to have on the file (if security is enabled)
     *
     * @throws AlreadyExistsException if the file already exists
     * @throws IOException if any other error occurred
     */
    public static FileOutputStream getCreateForWriteFileOutputStream(File f, int permissions)
            throws IOException {
        if (!Shell.WINDOWS) {
            // Use the native wrapper around open(2)
            try {
                FileDescriptor fd = POSIX.open(f.getAbsolutePath(),
                        POSIX.O_WRONLY | POSIX.O_CREAT
                                | POSIX.O_EXCL, permissions);
                return new FileOutputStream(fd);
            } catch (NativeIOException nioe) {
                if (nioe.getErrno() == Errno.EEXIST) {
                    throw new AlreadyExistsException(nioe);
                }
                throw nioe;
            }
        } else {
            // Use the Windows native APIs to create equivalent FileOutputStream
            try {
                FileDescriptor fd = Windows.createFile(f.getCanonicalPath(),
                        Windows.GENERIC_WRITE,
                        Windows.FILE_SHARE_DELETE
                                | Windows.FILE_SHARE_READ
                                | Windows.FILE_SHARE_WRITE,
                        Windows.CREATE_NEW);
                POSIX.chmod(f.getCanonicalPath(), permissions);
                return new FileOutputStream(fd);
            } catch (NativeIOException nioe) {
                if (nioe.getErrorCode() == 80) {
                    // ERROR_FILE_EXISTS
                    // 80 (0x50)
                    // The file exists
                    throw new AlreadyExistsException(nioe);
                }
                throw nioe;
            }
        }
    }

    private synchronized static void ensureInitialized() {
        if (!initialized) {
            cacheTimeout =
                    new Configuration().getLong("hadoop.security.uid.cache.secs",
                            4*60*60) * 1000;
            LOG.info("Initialized cache for UID to User mapping with a cache" +
                    " timeout of " + cacheTimeout/1000 + " seconds.");
            initialized = true;
        }
    }

    /**
     * A version of renameTo that throws a descriptive exception when it fails.
     *
     * @param src                  The source path
     * @param dst                  The destination path
     *
     * @throws NativeIOException   On failure.
     */
    public static void renameTo(File src, File dst)
            throws IOException {
        if (!nativeLoaded) {
            if (!src.renameTo(dst)) {
                throw new IOException("renameTo(src=" + src + ", dst=" +
                        dst + ") failed.");
            }
        } else {
            renameTo0(src.getAbsolutePath(), dst.getAbsolutePath());
        }
    }

    public static void link(File src, File dst) throws IOException {
        if (!nativeLoaded) {
            HardLink.createHardLink(src, dst);
        } else {
            link0(src.getAbsolutePath(), dst.getAbsolutePath());
        }
    }

    /**
     * A version of renameTo that throws a descriptive exception when it fails.
     *
     * @param src                  The source path
     * @param dst                  The destination path
     *
     * @throws NativeIOException   On failure.
     */
    private static native void renameTo0(String src, String dst)
            throws NativeIOException;

    private static native void link0(String src, String dst)
            throws NativeIOException;

    /**
     * Unbuffered file copy from src to dst without tainting OS buffer cache
     *
     * In POSIX platform:
     * It uses FileChannel#transferTo() which internally attempts
     * unbuffered IO on OS with native sendfile64() support and falls back to
     * buffered IO otherwise.
     *
     * It minimizes the number of FileChannel#transferTo call by passing the the
     * src file size directly instead of a smaller size as the 3rd parameter.
     * This saves the number of sendfile64() system call when native sendfile64()
     * is supported. In the two fall back cases where sendfile is not supported,
     * FileChannle#transferTo already has its own batching of size 8 MB and 8 KB,
     * respectively.
     *
     * In Windows Platform:
     * It uses its own native wrapper of CopyFileEx with COPY_FILE_NO_BUFFERING
     * flag, which is supported on Windows Server 2008 and above.
     *
     * Ideally, we should use FileChannel#transferTo() across both POSIX and Windows
     * platform. Unfortunately, the wrapper(Java_sun_nio_ch_FileChannelImpl_transferTo0)
     * used by FileChannel#transferTo for unbuffered IO is not implemented on Windows.
     * Based on OpenJDK 6/7/8 source code, Java_sun_nio_ch_FileChannelImpl_transferTo0
     * on Windows simply returns IOS_UNSUPPORTED.
     *
     * Note: This simple native wrapper does minimal parameter checking before copy and
     * consistency check (e.g., size) after copy.
     * It is recommended to use wrapper function like
     * the Storage#nativeCopyFileUnbuffered() function in hadoop-hdfs with pre/post copy
     * checks.
     *
     * @param src                  The source path
     * @param dst                  The destination path
     * @throws IOException
     */
    public static void copyFileUnbuffered(File src, File dst) throws IOException {
        if (nativeLoaded &amp;&amp; Shell.WINDOWS) {
            copyFileUnbuffered0(src.getAbsolutePath(), dst.getAbsolutePath());
        } else {
            FileInputStream fis = null;
            FileOutputStream fos = null;
            FileChannel input = null;
            FileChannel output = null;
            try {
                fis = new FileInputStream(src);
                fos = new FileOutputStream(dst);
                input = fis.getChannel();
                output = fos.getChannel();
                long remaining = input.size();
                long position = 0;
                long transferred = 0;
                while (remaining &gt; 0) {
                    transferred = input.transferTo(position, remaining, output);
                    remaining -= transferred;
                    position += transferred;
                }
            } finally {
                IOUtils.cleanup(LOG, output);
                IOUtils.cleanup(LOG, fos);
                IOUtils.cleanup(LOG, input);
                IOUtils.cleanup(LOG, fis);
            }
        }
    }

    private static native void copyFileUnbuffered0(String src, String dst)
            throws NativeIOException;
}
</code></pre> 
<h4 id="5.%E8%BF%90%E8%A1%8C%E6%88%90%E5%8A%9F">5.运行成功</h4> 
<pre><code>	File System Counters
		FILE: Number of bytes read=740
		FILE: Number of bytes written=564403
		FILE: Number of read operations=0
		FILE: Number of large read operations=0
		FILE: Number of write operations=0
	Map-Reduce Framework
		Map input records=7
		Map output records=10
		Map output bytes=95
		Map output materialized bytes=121
		Input split bytes=119
		Combine input records=0
		Combine output records=0
		Reduce input groups=7
		Reduce shuffle bytes=121
		Reduce input records=10
		Reduce output records=7
		Spilled Records=20
		Shuffled Maps =1
		Failed Shuffles=0
		Merged Map outputs=1
		GC time elapsed (ms)=0
		Total committed heap usage (bytes)=510656512
	Shuffle Errors
		BAD_ID=0
		CONNECTION=0
		IO_ERROR=0
		WRONG_LENGTH=0
		WRONG_MAP=0
		WRONG_REDUCE=0
	File Input Format Counters 
		Bytes Read=60
	File Output Format Counters 
		Bytes Written=66

Process finished with exit code 0
</code></pre> 
<p><strong>在outputr下生成多个文件，点击红框中的文件，可查看结果数据。</strong></p> 
<p><img alt="" height="236" src="https://images2.imgbox.com/cd/60/ttSUQeM5_o.png" width="922"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8eb88637a00c347260ba1bc388e19159/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">记录mysql 使用role赋予user权限</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cf4cd3887de40cbeb4e6e152c4dc1367/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自己配置微擎/微赞的的nginx负载均衡&#43;redis &#43;mysql</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>