<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GameFramework框架 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GameFramework框架" />
<meta property="og:description" content="官网
Game Framework | 基于 Unity 引擎的游戏框架
介绍
对常用模块封装，规范开发过程，保证产品质量，内置19个模块。
组成
框架主要分两部分：GameFramework(简称GF)，UnityGameFramework（简称UGF）。框架各模块主要实现在GF且完全不依赖unity。依赖unity的部分在UGF，具体逻辑实现如GameObject、AssetBundle、Editor。
目标
在项目中使用到GF大部分模块。
作者
ellan做事风格非常低调，属于实干派，几乎没有宣传过框架，但是多年持续维护更新，框架实际是提炼于知名的商业项目。虽然框架文档十分匮乏，新人上手相对困难，但是GF依然靠着过硬的代码质量吸引开发者使用和学习。
每个模块的xxxManager都会实现对应的IxxxManager接口，UGF只会直接引用接口，不会直接引用Manager
GF层
框架中各个模块的具体实现
各个模块若需引擎传递参数，可通过UGF层的component在初始化时传入
如果需要调用依赖于引擎实现的接口，可以定义对应的IHelper接口并在UGF层实现接口，GF层只管调用不管具体实现
UGF层
实现框架中需要依赖unity的逻辑，把框架与引擎解耦
作为Game层与GF层之间的桥梁
实例化并初始化框架的各个模块
借助unity的editor扩展，实现各个模块的可视化配置
Game层
游戏逻辑，只与UGF层直接接触
我是看了B站沉寂轩梦的视频，只尝试了几个。
做完打了几个包链接：https://pan.baidu.com/s/1WmY5gza4rpWxVqaVoalsyQ?pwd=5t7r 第一课：
1替换源码操作
a（这样不行）：
导入UGF，删掉dll，报错GF文件夹里的GameFrame文件夹拖到unity里，在里面新建一个Assembly Definition--GameFramework，应用不安全代码在UGF里找到Scripts里Runtime里的UnityGameFramework.Runtime，在里面指定好创建的，应用不安全代码在UGF里找到Scripts里Editor里的UnityGameFramework.Editor，在里面指定好创建的，应用不安全代码报错消失创建GF文件夹，把GF和UGF两部分放进去 b（这个可以）：
GameFramework：GameFramework.dll替换GF源码_gameframework替换dll_谢谢希望的博客-CSDN博客
2使用框架操作：
新建空物体GameEntry,把预制体GameFramework放到下面去创建Scripts文件夹，创建GameEntry.Init.cs脚本。把官网Game Framework | 基于 Unity 引擎的游戏框架第三章的GameEntry代码给他粘过来，（去掉.Init，加partial关键字），把命名空间Tutorial去掉在Scripts文件夹下，创建GameEntry.cs脚本。加partial关键字，在Start()方法里初始化GameEntry.Init.cs里的InitBuiltinComponents()方法找到GameEntry.cs脚本，点击Execution Order脚本排序，加上GameEntry.cs脚本脚本给他改成-108的顺序，Applyprocedure流程组件是游戏框架的核心，流程是贯穿游戏生命周期的有线状态机，通过流程能够对同一场景的不同逻辑进行解耦。在Scripts文件夹下，创建ProcedureStart.cs流程开始脚本继承ProcedurBase.cs脚本，using GameFramework.Procedure;既然ProcedureStart.cs继承ProcedureBase.cs，就重写ProcedureBase.cs生命周期方法，重写OnInit()方法 using GameFramework.Fsm;再执行一句话 Log.Debug(&#34;瑶瑶游戏开始啦&#34;); using UnityGameFramework.Runtime;这时候Procedure组件下面就有了一个 □ ProcedureStart，给他勾选上。Entrance Procedure流程入口选择ProcedureStart然后运行他妈的就是不打印啊，他妈的就是不打印，换了版本他妈的也不打印 第二课：
3加载UI
在UI组件下创建canvas，然后把EventSystem放到画布下面，在画布下新建射线机，设置只渲染UI，颜色和-5 5 ，正交；修改模式指定相机新建一个panel名字改为UITestForm，在底下创建一个900*100大小的button，text改为切换流程，size50新建UI文件夹，把UITestForm做成预制体放到UI文件夹里,删掉Hierarchy视图里的就可以了UI组件下面游一个Instance Root实例根目录，把画布指定过来；UI groups 分组size先给1组，Name名字随便起一个Normal,Depth深度给一个10在Scripts文件夹下创建UITestFormLogic.cs脚本，继承UIFormLogic using UnityGameFramework.Runtime; private Button m_BtnChange;给按钮注册事件，然后打印Log.Debug(&#34;收到UI按钮&#34;); 点击按钮之后打印的语句。ProcedureStart.cs脚本里 OnEnter()方法里执行语句：UIComponent ui = UnityGameFramework." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1b9e3679bbb43956b99708856ddea4b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-19T18:02:38+08:00" />
<meta property="article:modified_time" content="2023-05-19T18:02:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GameFramework框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>官网</strong></p> 
 <p><a href="http://gameframework.cn/" rel="nofollow" title="Game Framework | 基于 Unity 引擎的游戏框架">Game Framework | 基于 Unity 引擎的游戏框架</a></p> 
 <p><strong>介绍</strong></p> 
 <p>对常用模块封装，规范开发过程，保证产品质量，内置19个模块。</p> 
 <p><strong>组成</strong></p> 
 <p>框架主要分两部分：GameFramework(简称GF)，UnityGameFramework（简称UGF）。框架各模块主要实现在GF且完全不依赖unity。依赖unity的部分在UGF，具体逻辑实现如GameObject、AssetBundle、Editor。</p> 
 <p><strong>目标</strong></p> 
 <p>在项目中使用到GF大部分模块。</p> 
 <p><strong>作者</strong></p> 
 <p>ellan做事风格非常低调，属于实干派，几乎没有宣传过框架，但是多年持续维护更新，框架实际是提炼于知名的商业项目。虽然框架文档十分匮乏，新人上手相对困难，但是GF依然靠着过硬的代码质量吸引开发者使用和学习。</p> 
 <p>每个模块的xxxManager都会实现对应的IxxxManager接口，UGF只会直接引用接口，不会直接引用Manager</p> 
 <p><strong>GF层</strong></p> 
 <p>框架中各个模块的具体实现</p> 
 <p>各个模块若需引擎传递参数，可通过UGF层的component在初始化时传入</p> 
 <p>如果需要调用依赖于引擎实现的接口，可以定义对应的IHelper接口并在UGF层实现接口，GF层只管调用不管具体实现</p> 
 <p><strong>UGF层</strong></p> 
 <p>实现框架中需要依赖unity的逻辑，把框架与引擎解耦</p> 
 <p>作为Game层与GF层之间的桥梁</p> 
 <p>实例化并初始化框架的各个模块</p> 
 <p>借助unity的editor扩展，实现各个模块的可视化配置</p> 
 <p><strong>Game层</strong></p> 
 <p>游戏逻辑，只与UGF层直接接触</p> 
</blockquote> 
<p> 我是看了B站沉寂轩梦的视频，只尝试了几个。</p> 
<p>做完打了几个包链接：https://pan.baidu.com/s/1WmY5gza4rpWxVqaVoalsyQ?pwd=5t7r </p> 
<p>第一课：</p> 
<p>1替换源码操作</p> 
<p>a（这样不行）：</p> 
<ol><li>导入UGF，删掉dll，报错</li><li>GF文件夹里的GameFrame文件夹拖到unity里，在里面新建一个Assembly Definition--GameFramework，应用不安全代码</li><li>在UGF里找到Scripts里Runtime里的UnityGameFramework.Runtime，在里面指定好创建的，应用不安全代码</li><li>在UGF里找到Scripts里Editor里的UnityGameFramework.Editor，在里面指定好创建的，应用不安全代码</li><li>报错消失</li><li>创建GF文件夹，把GF和UGF两部分放进去</li></ol> 
<p>b（这个可以）：</p> 
<p><a href="https://blog.csdn.net/weixin_39081932/article/details/126538950" title="GameFramework：GameFramework.dll替换GF源码_gameframework替换dll_谢谢希望的博客-CSDN博客">GameFramework：GameFramework.dll替换GF源码_gameframework替换dll_谢谢希望的博客-CSDN博客</a></p> 
<p>2使用框架操作：</p> 
<ol><li>新建空物体GameEntry,把预制体GameFramework放到下面去</li><li>创建Scripts文件夹，创建GameEntry.Init.cs脚本。把官网<a href="https://gameframework.cn/" rel="nofollow" title="Game Framework | 基于 Unity 引擎的游戏框架">Game Framework | 基于 Unity 引擎的游戏框架</a>第三章的GameEntry代码给他粘过来，（去掉.Init，加partial关键字），把命名空间Tutorial去掉</li><li>在Scripts文件夹下，创建GameEntry.cs脚本。加partial关键字，在Start()方法里初始化GameEntry.Init.cs里的InitBuiltinComponents()方法</li><li>找到GameEntry.cs脚本，点击Execution Order脚本排序，加上GameEntry.cs脚本脚本给他改成-108的顺序，Apply</li><li>procedure流程组件是游戏框架的核心，流程是贯穿游戏生命周期的有线状态机，通过流程能够对同一场景的不同逻辑进行解耦。</li><li>在Scripts文件夹下，创建ProcedureStart.cs流程开始脚本继承ProcedurBase.cs脚本，using GameFramework.Procedure;</li><li>既然ProcedureStart.cs继承ProcedureBase.cs，就重写ProcedureBase.cs生命周期方法，重写OnInit()方法 using GameFramework.Fsm;再执行一句话 Log.Debug("瑶瑶游戏开始啦"); using UnityGameFramework.Runtime;</li><li>这时候Procedure组件下面就有了一个 □ ProcedureStart，给他勾选上。Entrance Procedure流程入口选择ProcedureStart</li><li>然后运行他妈的就是不打印啊，他妈的就是不打印，换了版本他妈的也不打印</li></ol> 
<p>第二课：</p> 
<p>3加载UI</p> 
<ol><li>在UI组件下创建canvas，然后把EventSystem放到画布下面，在画布下新建射线机，设置只渲染UI，颜色和-5 5 ，正交；修改模式指定相机</li><li>新建一个panel名字改为UITestForm，在底下创建一个900*100大小的button，text改为切换流程，size50</li><li>新建UI文件夹，把UITestForm做成预制体放到UI文件夹里,删掉Hierarchy视图里的就可以了</li><li>UI组件下面游一个Instance Root实例根目录，把画布指定过来；UI groups 分组size先给1组，Name名字随便起一个Normal,Depth深度给一个10</li><li>在Scripts文件夹下创建UITestFormLogic.cs脚本，继承UIFormLogic using UnityGameFramework.Runtime; private Button m_BtnChange;给按钮注册事件，然后打印Log.Debug("收到UI按钮"); 点击按钮之后打印的语句。</li><li>ProcedureStart.cs脚本里 OnEnter()方法里执行语句：UIComponent ui = UnityGameFramework.Runtime.GameEntry.GetComponent(); ui.OpenUIForm("Assets/UI/UITestForm.prefab", "Normal");</li><li>到unity里运行即可加载出UITestForm预制体了</li></ol> 
<p>4切换流程</p> 
<ol><li>新建脚本ProcedureInit.cs，继续继承ProcedurBase.cs脚本，using GameFramework.Procedure;</li><li>在Hierarchy视图的Procedure组件下勾选 □ ProcedureInit</li><li>在ProcedureStart.cs脚本的OnEnter()方法里，执行切换流程的代码 ChangeState(procedureOwner); 后面再OnUpdate()里面判断就把这一句注释掉就可以了</li><li>在ProcedureStart.cs脚本里定义变量private bool m_IsChangeProcedure=false; 在OnUpdate()里判断if (m_IsChangeProcedure)ChangeState(procedureOwner);</li><li>定义一个方法ChangeProcedure()，把变量设为true：m_IsChangeProcedure= true; 把打开UI传入这个脚本this：ui.OpenUIForm("Assets/UI/UITestForm.prefab", "Normal",this);</li><li>在UITestFormLogic.cs脚本里，private ProcedureStart m_ProcedureStart; OnInit()方法里m_ProcedureStart = (ProcedureStart)userData;</li><li>在OnChangeClick()方法里，调用ProcedureStart.cs里的方法就可以了。m_ProcedureStart.ChangeProcedure();</li></ol> 
<p>5实体的使用</p> 
<ol><li>创建文件夹Prefabs，新建一个Cube把它做成预制体加载它</li><li>创建控制cube的脚本CubeEntityLogic.cs继承EntityLogic.cs,private Vector3 m_Rot=new Vector3(0,5,0); onUpdate()方法里transform.Rotate(m_Rot); using UnityGameFramework.Runtime;</li><li>在ProcedureInit.cs里 OnEnter()方法里 EntityComponent entityComponent=UnityGameFramework.Runtime.GameEntry.GetComponent(); entityComponent.ShowEntity(1, "Assets/Prefabs/Cube.prefab", "Prefabs"); 创建cube预制体</li><li>Entity组件下面Entity groups 分组size先给1组，Name名字起脚本里的组名Prefabs</li></ol> 
<p>第三课：</p> 
<p>6加载配置表</p> 
<p>a(这样不行)</p> 
<ol><li>新建EntityYao.xlsx文件，另存为文本文件（制表符分割）（*.txt）保存 确定 是</li><li>新建GameMain文件夹，把prefabs 和 UI 啥的文件夹放进去，省的乱七八糟的</li><li>创建DREntityYao.cs继承自DataRowBase.cs using UnityGameFramework.Runtime;</li><li>在ProcudeStart.cs脚本的OnEnter()方法里去创建我们的配置表GameEntry.DataTable.CreateDataTable();</li><li>实现抽象类 public override int Id =&gt; throw new System.NotImplementedException();</li><li>在ProcudeStart.cs脚本OnEnter()方法里 变量接收一下创建的配置表 DataTableBase dataTableBase=(DataTableBase) GameEntry.DataTable.CreateDataTable(); dataTableBase.ReadData("Assets/GameMain/DataTables/EntityYao.txt"); using GameFramework.DataTable;</li><li>由于这套框架的所有东西都是异步的，所以加载完之后下面是没有办法调用的，这个时候有可能还没加完呢，就通过事件系统GameEntry.Event里面有个专门读取dataTable成功的一个事件，加载的时候更新的事件，以成功为例GameEntry.Event.Subscribe(LoadDataTableSuccessEventArgs.EventId, OnLoadDataTableSucc); 生成方法到回调里已经是加载完了，因为是派发的所以接收的可能不一定是加载的表就再把表给他传过去</li><li>在回调里判断是不是当前加载的表LoadDataTableSuccessEventArgs ne= (LoadDataTableSuccessEventArgs)e; if (ne.UserData==this)//就加载到这个表了</li><li>在调用dataTableBase.ReadData的时候，就会把这一些列从表中读到的数据传到DREntityYao.cs中的一个方法里public override bool ParseDataRow(string dataRowString, object userData)</li><li>string dataRowString就是配置表中每一行的数据，因为配置表是用制表符分隔的，string [] colString=dataRowString.Split('\t');给它分隔一下int index = 1;m_Id=int.Parse(colString[index++]);Name = colString[index++];Attack = colString[index++];Hp = colString[index++];return true; 注意有多少个数据就做多少个读取，不然是会报错的</li><li>if (ne.UserData==this)IDataTable dt= GameEntry.DataTable.GetDataTable();foreach (DREntityYao entity in dt){Log.Debug($"{entity.Id}=={entity.Name}=={entity.Attack}=={entity.Hp}");}</li></ol> 
<p>b（这个可以）</p> 
<p><a href="https://www.boy3d.com/post/149.html" rel="nofollow" title="【unity game framework 学习分享】6.读取配置表 - Unity Game Framework - 熊猫自有仙人">【unity game framework 学习分享】6.读取配置表 - Unity Game Framework - 熊猫自有仙人</a></p> 
<p>第四课：</p> 
<p>7资源打包Resource</p> 
<ol><li>Game Framework 🐯Resource Tools 🐯 Resource Editor 然后就能看到Asset List下面的路径是Assets/GameMain文件夹</li><li>为什么路径是这个呢，Config文件夹里有一个ResourceEditor.xml，这个文件就是打包的配置文件，来控制路径文件夹的</li><li>配完xml还是看不见，得再在GameFrameConfig.cs里把路径给它配置过来，就能在Resource Editor 面板看到Asset List路径了</li><li>Resource Editor 面板左下角Add加一个Entity的AB包，在Resource List显示，选中Entity后下方□ Packed勾选就是后续给它更新[Packed]Entity，基本上每个后续都要有更新吧所以都要勾选上</li><li>Load From File就是从文件中加载，如果是发布webgl就选择Load From Memory因为webgl不支持文件读写的</li><li>在Resource List选择一个AB包，右侧AssetList也勾选对应的资源就会再Resource Content把资源挪到对应的AB包中去了</li><li>保存之后会看到一个文件ResourceCollection.xml，这里面就是我们刚刚打包的资源了</li><li>可以在ResourceCollection.xml里追加一个属性[ResourceEditorConfigPath] public static string ResourceCollectionConfig=Unility.Path.GetRegularPath(Path.Combine(Application.dataPath,"GameMain/Configs/ResourceCollection.xml"));</li><li>设置完之后就可以通过第一个工具进行打包了Game Framework 🐯Resource Tools 🐯 Resource Bulider 选择平台；Browser路径:AssetBundles;Compression Helper选择上 Start Build Resources</li><li>分组策略从官网上找一找</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/163605ed1ed810673d6a1bbda209ca23/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">H5、jquery实现滚动加载下一页&#43;瀑布流布局</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6767e24c795f595598ef011d043608ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">word插入图片之后，上半部分被文字遮挡</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>