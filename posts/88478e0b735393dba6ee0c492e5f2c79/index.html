<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python任务四 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python任务四" />
<meta property="og:description" content="Task4（2day）
1.函数关键字
python中一共含有32个关键字：‘false’, ‘none’, ‘true’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’,
‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’,
‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’
关键字-是Python内置的、具有特殊意义的表示符
使用时关键字后面不需要括号
2.函数的定义
函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。可以自己定义一个函数。
函数-封装了独立功能，可以直接调用
函数名(参数)
函数创建
#自定义函数
def function_name (str):
“打印传入的字符串”
print(str)
return(0);
#调用自定义函数
function_name(“自定义函数”)
function_name(“调用自定义函数”)
3.函数参数与作用域
函数传递参数时的一些简要的关键点:
1）参数的传递是通过自动将对象赋值给本地变量名来实现的。所有的参数实际上都是通过指针进行传递的，作为参数被传递的对象从来不自动拷贝。
2）对于numbers,Strings,元祖这种不可改变值的类型，在函数内部的参数名的赋值不会影响调用者。原因就是这种类型会在改变值的时候，重新指向新地址，那么之前的对象执行地址值不会变，就等同于copy.(传递值就是传递指针的指向)
3）改变函数的可变对象参数的值会对调用者有影响。（直接在指向地址处修改值，不再重现创建新的地址作为指向）
匹配模型的大纲:
位置:从左至右进行匹配。
关键字参数:通过参数名进行匹配。(调用者可以定义哪一个函数接受这个值，通过在调用时使用参数的变量名，使用name=value这种语法。)
默认参数:为没有传入值的参数定义参数值。
可变参数:搜集任意多基于位置或关键字的参数。
可变参数解包:传递任意多的基于位置或关键字的参数。
Keyword-only参数:参数必须按照名称传递。(只存在于Python3.0中)
作用域
在一个Python程序只用变量名时，Python创建、改变或查找变量名都是在所谓的命名空间(一个保存变量名的地方)中进行的。也就是说，在代码中变量名被赋值的位置决定了这个变量名能被访问到的范围,也即决定了它存在于哪个命名空间中。
4.函数返回值
函数需要先定义后调用，函数体中 return 语句的结果就是返回值。如果一个函数没有 reutrn 语句，其实它有一个隐含的 return 语句，返回值是 None，类型也是 ‘NoneType’。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/88478e0b735393dba6ee0c492e5f2c79/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-17T21:31:49+08:00" />
<meta property="article:modified_time" content="2019-05-17T21:31:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python任务四</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Task4（2day）<br> 1.函数关键字<br> python中一共含有32个关键字：‘false’, ‘none’, ‘true’, ‘and’, ‘as’, ‘assert’, ‘break’, ‘class’, ‘continue’, ‘def’,<br> ‘del’, ‘elif’, ‘else’, ‘except’, ‘finally’, ‘for’, ‘from’, ‘global’, ‘if’, ‘import’, ‘in’, ‘is’, ‘lambda’, ‘nonlocal’, ‘not’,<br> ‘or’, ‘pass’, ‘raise’, ‘return’, ‘try’, ‘while’, ‘with’, ‘yield’<br> 关键字-是Python内置的、具有特殊意义的表示符<br> 使用时关键字后面不需要括号<br> 2.函数的定义<br> 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。可以自己定义一个函数。<br> 函数-封装了独立功能，可以直接调用<br> 函数名(参数)<br> 函数创建<br> #自定义函数<br> def function_name (str):<br> “打印传入的字符串”<br> print(str)<br> return(0);<br> #调用自定义函数<br> function_name(“自定义函数”)<br> function_name(“调用自定义函数”)<br> 3.函数参数与作用域<br> 函数传递参数时的一些简要的关键点:<br> 1）参数的传递是通过自动将对象赋值给本地变量名来实现的。所有的参数实际上都是通过指针进行传递的，作为参数被传递的对象从来不自动拷贝。<br> 2）对于numbers,Strings,元祖这种不可改变值的类型，在函数内部的参数名的赋值不会影响调用者。原因就是这种类型会在改变值的时候，重新指向新地址，那么之前的对象执行地址值不会变，就等同于copy.(传递值就是传递指针的指向)<br> 3）改变函数的可变对象参数的值会对调用者有影响。（直接在指向地址处修改值，不再重现创建新的地址作为指向）<br> 匹配模型的大纲:<br> 位置:从左至右进行匹配。<br> 关键字参数:通过参数名进行匹配。(调用者可以定义哪一个函数接受这个值，通过在调用时使用参数的变量名，使用name=value这种语法。)<br> 默认参数:为没有传入值的参数定义参数值。<br> 可变参数:搜集任意多基于位置或关键字的参数。<br> 可变参数解包:传递任意多的基于位置或关键字的参数。<br> Keyword-only参数:参数必须按照名称传递。(只存在于Python3.0中)<br> 作用域<br> 在一个Python程序只用变量名时，Python创建、改变或查找变量名都是在所谓的命名空间(一个保存变量名的地方)中进行的。也就是说，在代码中变量名被赋值的位置决定了这个变量名能被访问到的范围,也即决定了它存在于哪个命名空间中。</p> 
<p>4.函数返回值<br> 函数需要先定义后调用，函数体中 return 语句的结果就是返回值。如果一个函数没有 reutrn 语句，其实它有一个隐含的 return 语句，返回值是 None，类型也是 ‘NoneType’。<br> return 语句的作用：<br> 结束函数调用、返回值<br> <img src="https://images2.imgbox.com/38/47/VXCzOeWy_o.png" alt="在这里插入图片描述"><br> 函数体中 return 语句有指定返回值时返回的就是其值<br> <img src="https://images2.imgbox.com/0e/d7/vcvtHJ4p_o.png" alt="在这里插入图片描述"><br> 函数体中没有 return 语句时，函数运行结束会隐含返回一个 None 作为返回值，类型是 NoneType，与 return 、return None 等效，都是返回 None。</p> 
<p>无论定义的是返回什么类型，return 只能返回单值，但值可以存在多个元素。<br> return [1,3,5] 是指返回一个列表，是一个列表对象，1,3,5 分别是这个列表的元素<br> return 1,3,5 看似返回多个值，隐式地被Python封装成了一个元祖返回。</p> 
<p>内部函数不能被外部直接调用，会抛异常 NameError。</p> 
<p>5.File<br> 1）打开文件方式（读写两种方式）<br> open函数打开文件进行读写，使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。<br> open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。<br> open(file, mode=‘r’)<br> 完整的语法格式为：<br> open(file, mode=‘r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</p> 
<p>2）文件对象的操作方法<br> <img src="https://images2.imgbox.com/6a/dd/cdubODFn_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/52/84/DshRGowP_o.png" alt="在这里插入图片描述"><br> 3）学习对Excel及CSV文件进行操作<br> python读写excle文件需要先用python pip命令安装xlrd , xlwt库~</p> 
<p>import xlrd, xlwt #xlwt只能写入xls文件<br> #读取xlsx文件内容<br> rows = [] #create an empty list to store rows<br> book = xlrd.open_workbook(‘testdata.xlsx’) #open the Excel spreadsheet as workbook<br> sheet = book.sheet_by_index(0) #get the first sheet<br> for user in range(1, sheet.nrows): #iterate 1 to maxrows<br> rows.append(list(sheet.row_values(user, 0, sheet.ncols))) #iterate through the sheet and get data from rows in list<br> print(rows)</p> 
<p>#写入xls文件<br> rows1 = [[‘Name’, ‘Age’],[‘fengju’, ‘26’],[‘wuxia’, ‘25’]]<br> book1 = xlwt.Workbook() #create new book1 excle<br> sheet1 = book1.add_sheet(‘user’) #create new sheet<br> for i in range(0, 3):<br> for j in range(0, len(rows1[i])):<br> sheet1.write(i, j, rows1[i][j])<br> book1.save(‘testdata1.xls’) #sava as testdata1.xls</p> 
<p>python读写csv文件</p> 
<p>import csv<br> #读取csv文件内容方法1<br> csv_file = csv.reader(open(‘testdata.csv’,‘r’))<br> next(csv_file, None) #skip the headers<br> for user in csv_file:<br> print(user)</p> 
<p>#读取csv文件内容方法2<br> with open(‘testdata.csv’, ‘r’) as csv_file:<br> reader = csv.reader(csv_file)<br> next(csv_file, None)<br> for user in reader:<br> print(user)</p> 
<p>#从字典写入csv文件<br> dic = {‘fengju’:25, ‘wuxia’:26}<br> csv_file = open(‘testdata1.csv’, ‘w’, newline=’’)<br> writer = csv.writer(csv_file)<br> for key in dic:<br> writer.writerow([key, dic[key]])<br> csv_file.close() #close CSV file</p> 
<p>csv_file1 = csv.reader(open(‘testdata1.csv’,‘r’))<br> for user in csv_file1:<br> print(user)<br> 6.Os模块<br> #OS模块</p> 
<p>#os模块就是对操作系统进行操作，使用该模块必须先导入模块：<br> import os</p> 
<p>#getcwd() 获取当前工作目录(当前工作目录默认都是当前文件所在的文件夹)<br> result = os.getcwd()<br> print(result)</p> 
<p>#chdir()改变当前工作目录<br> os.chdir(’/home/sy’)<br> result = os.getcwd()<br> print(result)</p> 
<p>open(‘02.txt’,‘w’)</p> 
<p>#操作时如果书写完整的路径则不需要考虑默认工作目录的问题,按照实际书写路径操作<br> open(’/home/sy/下载/02.txt’,‘w’)</p> 
<p>#listdir() 获取指定文件夹中所有内容的名称列表<br> result = os.listdir(’/home/sy’)<br> print(result)</p> 
<p>#mkdir() 创建文件夹<br> #os.mkdir(‘girls’)<br> #os.mkdir(‘boys’,0o777)</p> 
<p>#makedirs() 递归创建文件夹<br> #os.makedirs(’/home/sy/a/b/c/d’)</p> 
<p>#rmdir() 删除空目录<br> #os.rmdir(‘girls’)</p> 
<p>#removedirs 递归删除文件夹 必须都是空目录<br> #os.removedirs(’/home/sy/a/b/c/d’)</p> 
<p>#rename() 文件或文件夹重命名<br> #os.rename(’/home/sy/a’,’/home/sy/alibaba’<br> #os.rename(‘02.txt’,‘002.txt’)</p> 
<p>#stat() 获取文件或者文件夹的信息<br> #result = os.stat(’/home/sy/PycharmProject/Python3/10.27/01.py)<br> #print(result)</p> 
<p>#system() 执行系统命令(危险函数)<br> #result = os.system(‘ls -al’) #获取隐藏文件<br> #print(result)<br> 7.Datetime模块<br> datatime模块重新封装了time模块，提供更多接口，提供的类有：date,time,datetime,timedelta,tzinfo。</p> 
<p>1、date类</p> 
<p>datetime.date(year, month, day)</p> 
<p>静态方法和字段</p> 
<p>date.max、date.min：date对象所能表示的最大、最小日期；<br> date.resolution：date对象表示日期的最小单位。这里是天。<br> date.today()：返回一个表示当前本地日期的date对象；<br> date.fromtimestamp(timestamp)：根据给定的时间戮，返回一个date对象；</p> 
<p>d1 = date(2011,06,03)#date对象<br> d1.year、date.month、date.day：年、月、日；<br> d1.replace(year, month, day)：生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性。（原有对象仍保持不变）<br> d1.timetuple()：返回日期对应的time.struct_time对象；<br> d1.weekday()：返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此类推；<br> d1.isoweekday()：返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此类推；<br> d1.isocalendar()：返回格式如(year，month，day)的元组；<br> d1.isoformat()：返回格式如’YYYY-MM-DD’的字符串；<br> d1.strftime(fmt)：和time模块format相同。<br> datetime相当于date和time结合起来。<br> datetime.datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )</p> 
<p>静态方法和字段<br> datetime.today()：返回一个表示当前本地时间的datetime对象；<br> datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间；<br> datetime.utcnow()：返回一个当前utc时间的datetime对象；#格林威治时间<br> datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息；<br> datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象；<br> datetime.combine(date, time)：根据date和time，创建一个datetime对象；<br> datetime.strptime(date_string, format)：将格式字符串转换为datetime对象；</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/093ebdcfa37ff5ff63ee82ddf42b9d7e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">整理了八个开源的 Spring Boot 学习资源</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e1594685cfc36042b38128073efed657/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[数字逻辑]  全加器的多种电路设计方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>