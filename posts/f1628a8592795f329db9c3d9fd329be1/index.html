<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java语言----二叉树 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java语言----二叉树" />
<meta property="og:description" content="目录
一、二叉树
1.1 二叉树概念
1.2 两种特殊的二叉树
1.3二叉树的性质
二 、二叉树的实现
2.1第一种 使用数组
2.2第二种 使用链表实现
2.2.1二叉树代码构建
2.2.2二叉树的基本操作
三、二叉树的三种遍历
3.1递归方法实现 前、中、后遍历
3.2非递归方法实现 前、中、后遍历
总结
😽个人主页： 博客-专业IT技术发表平台 (csdn.net)
🌈梦的目标：努力学习，向Java进发，拼搏一切，让自己的未来不会有遗憾。
🎁欢迎各位→点赞👍 &#43; 收藏⭐ &#43; 评论📝&#43;关注✨
本章讲解内容：二叉树
来源于百度 使用编译器：IDEA
一、二叉树 1.1 二叉树概念 二叉树：一种 非线性 的数据结构，为结点的一个有限集合。
有限集合分类：1、或者为空 2、由一个根节点加上两棵别称为 左子树 和 右子树 的二叉树组成
重要知识：
1、树的深度或高度：树的最大层次。如上图：该二叉树高度为3。
2、结点的度：1个结点含有的子树个数。如上图：结点1的度为2，分别为2和4的左右子树。
3、父亲结点：拥有子树的结点。如上图：1便有2和4的子树，所以为父亲结点。
4、孩子结点：一个结点的的子树结点便为孩子结点。如上图：2是1的孩子结点。
5、叶子结点：无子树的结点。如上图：3、5、6的结点无子树，为叶子结点。
6、根结点：最开始的结点。如上图：1为根结点，每个二叉树只有一个根结点。
1.2 两种特殊的二叉树 1. 满二叉树 : 一棵二叉树，如果 每层的结点数都达到最大值，则这棵二叉树就是满二叉树 。也就是说， 如果一棵 二叉树的层数为K，且结点总数是 2^k-1 ，则它就是满二叉树。 2. 完全二叉树 : 一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，从0开始编号，编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同。 红色数字，代表的是结点序号，数组实现时使用 完全二叉树更为重要，因为堆便是在此基础上实现的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/f1628a8592795f329db9c3d9fd329be1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-28T15:50:57+08:00" />
<meta property="article:modified_time" content="2023-05-28T15:50:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java语言----二叉树</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">一、二叉树</a></p> 
<p id="1.1%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.1%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5" rel="nofollow">1.1 二叉树概念</a></p> 
<p id="1.2%20%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-toc" style="margin-left:40px;"><a href="#1.2%20%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91" rel="nofollow">1.2 两种特殊的二叉树</a></p> 
<p id="1.3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8-toc" style="margin-left:40px;"><a href="#1.3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8" rel="nofollow">1.3二叉树的性质</a></p> 
<p id="1.4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#1.4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">二 、二叉树的实现</a></p> 
<p id="1.4.1%E7%AC%AC%E4%B8%80%E7%A7%8D%20%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84-toc" style="margin-left:40px;"><a href="#1.4.1%E7%AC%AC%E4%B8%80%E7%A7%8D%20%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84" rel="nofollow">2.1第一种 使用数组</a></p> 
<p id="1.4.2%E7%AC%AC%E4%BA%8C%E7%A7%8D%20%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#1.4.2%E7%AC%AC%E4%BA%8C%E7%A7%8D%20%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0" rel="nofollow">2.2第二种 使用链表实现</a></p> 
<p id="%C2%A02.2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA-toc" style="margin-left:80px;"><a href="#%C2%A02.2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA" rel="nofollow"> 2.2.1二叉树代码构建</a></p> 
<p id="2.2.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-toc" style="margin-left:80px;"> <a href="#2.2.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" rel="nofollow">2.2.2二叉树的基本操作</a></p> 
<p id="%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86" rel="nofollow">三、二叉树的三种遍历</a></p> 
<p id="3.1%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%20%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#3.1%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%20%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E9%81%8D%E5%8E%86" rel="nofollow">3.1递归方法实现 前、中、后遍历</a></p> 
<p id="3.2%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%C2%A0%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E9%81%8D%E5%8E%86-toc" style="margin-left:40px;"><a href="#3.2%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%C2%A0%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E9%81%8D%E5%8E%86" rel="nofollow">3.2非递归方法实现 前、中、后遍历</a></p> 
<p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<blockquote> 
 <p>😽个人主页：<a href="https://blog.csdn.net/nav/arch" title=" 博客-专业IT技术发表平台 (csdn.net)"> 博客-专业IT技术发表平台 (csdn.net)</a><br>  🌈梦的目标：努力学习，向Java进发，拼搏一切，让自己的未来不会有遗憾。<br>  🎁欢迎各位→点赞👍 + 收藏⭐ + 评论📝+关注✨<br>   本章讲解内容：二叉树</p> 
 <div class="img-center"> 
  <figure class="image"> 
   <img alt="来源百度" height="335" src="https://images2.imgbox.com/2e/df/FBBvrNRr_o.png" width="471"> 
   <figcaption>
     来源于百度 
   </figcaption> 
  </figure> 
 </div> 
 <p>  使用编译器：IDEA</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E4%BA%8C%E5%8F%89%E6%A0%91">一、二叉树</h2> 
<h3 id="1.1%20%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5">1.1 二叉树概念</h3> 
<blockquote> 
 <p>二叉树：一种 <strong>非线性</strong> 的数据结构，为结点的一个有限<span style="background-color:#ffd900;">集合</span>。</p> 
 <p>              有限集合分类：1、或者为空     </p> 
 <p>                                        2、由一个根节点加上两棵别称为 <strong>左子树 </strong>和 <strong>右子树 </strong>的二叉树组成</p> 
 <p><img alt="" height="385" src="https://images2.imgbox.com/37/b7/WpcdnnZD_o.png" width="882"></p> 
</blockquote> 
<p>重要知识：</p> 
<p>1、<strong>树的深度或高度</strong>：树的最大层次。如上图：该二叉树<span style="color:#0d0016;"><span style="background-color:#ffd900;">高度为3</span></span>。</p> 
<p>2、<strong>结点的度</strong>：1个结点含有的子树个数。如上图：<span style="color:#0d0016;"><span style="background-color:#ffd900;">结点1的度为2</span></span>，分别为2和4的左右子树。</p> 
<p>3、<strong>父亲结点</strong>：拥有子树的结点。如上图：<span style="background-color:#ffd900;">1便有2和4的子树</span>，所以为父亲结点。</p> 
<p>4、<strong>孩子结点</strong>：一个结点的的子树结点便为孩子结点。如上图：<span style="background-color:#ffd900;">2是1的孩子结点</span>。</p> 
<p>5、<strong>叶子结点</strong>：无子树的结点。如上图：3、5、6的结点无子树，为叶子结点。</p> 
<p>6、<strong>根结点：</strong>最开始的结点。如上图：<span style="background-color:#ffd900;">1为根结点</span>，每个二叉树只有一个根结点。</p> 
<h3></h3> 
<h3 id="1.2%20%E4%B8%A4%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91">1.2 两种特殊的二叉树</h3> 
<blockquote> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;"><strong>满二叉树</strong></span> 
  <span style="color:#333333;"><strong>: </strong></span> 
  <span style="color:#333333;">一棵二叉树，如果</span> 
  <span style="color:#333333;">每层的结点数都达到最大值，则这棵二叉树就是满二叉树</span> 
  <span style="color:#333333;">。也就是说，</span> 
  <span style="color:#333333;">如果一棵</span> 
  <span style="color:#333333;">二叉树的层数为K，且<span style="background-color:#ffd900;">结点总数是</span></span> 
  <span style="background-color:#ffd900;"> 2^k-1</span> 
  <span style="color:#333333;"><strong>，</strong>则它就是满二叉树。 </span> 
 </div> 
 <p></p> 
 <div></div> 
 <div> 
  <span style="color:#333333;">2. </span> 
  <span style="color:#333333;"><strong>完全二叉树</strong></span> 
  <span style="color:#333333;"><strong>: </strong>一棵深度为k的有n个结点的二叉树，对树中的结点按<strong>从上至下、从左到右</strong>的顺序进行编号，从0开始编号，编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同。</span> 
 </div> 
 <div> 
  <img alt="" height="511" src="https://images2.imgbox.com/8f/b8/7v4INSC9_o.png" width="1200"> 
 </div> 
 <p><strong>红色数字，代表的是结点序号，数组实现时使用 </strong></p> 
</blockquote> 
<p>完全二叉树更为重要，因为<strong>堆</strong>便是在此基础上实现的。</p> 
<p><img alt="" height="1083" src="https://images2.imgbox.com/70/d3/o92t6mbV_o.png" width="1200"></p> 
<hr> 
<p></p> 
<p></p> 
<h3 id="1.3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8">1.3二叉树的性质</h3> 
<div> 
 <span style="color:#333333;">1. </span> 
 <span style="color:#333333;">若规定</span> 
 <span style="color:#333333;"><strong>根结点的层数为</strong></span> 
 <span style="color:#333333;"><strong>1</strong></span> 
 <span style="color:#333333;">，则一棵</span> 
 <span style="color:#333333;"><strong>非空二叉树的第</strong></span> 
 <span style="color:#333333;"><strong>i</strong></span> 
 <span style="color:#333333;"><strong>层上最多有 </strong></span> 
 <span style="color:#333333;"><strong>(i&gt;0)</strong></span> 
 <span style="color:#333333;"><strong>个结点 </strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">2. </span> 
 <span style="color:#333333;">若规定只有</span> 
 <span style="color:#333333;"><strong>根结点的二叉树的深度为</strong></span> 
 <span style="color:#333333;"><strong>1</strong></span> 
 <span style="color:#333333;">，则</span> 
 <span style="color:#333333;"><strong>深度为</strong></span> 
 <span style="color:#333333;"><strong>K</strong></span> 
 <span style="color:#333333;"><strong>的二叉树的最大结点数是 </strong>(k&gt;=0) </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">3. </span> 
 <span style="color:#333333;">对任何一棵二叉树</span> 
 <span style="color:#333333;">, </span> 
 <span style="color:#333333;">如果其</span> 
 <span style="color:#333333;"><strong>叶结点个数为</strong></span> 
 <span style="color:#333333;"><strong> n0, </strong></span> 
 <span style="color:#333333;"><strong>度为</strong></span> 
 <span style="color:#333333;"><strong>2</strong></span> 
 <span style="color:#333333;"><strong>的非叶结点个数为</strong></span> 
 <span style="color:#333333;"><strong> n2,</strong></span> 
 <span style="color:#333333;"><strong>则有</strong></span> 
 <span style="color:#333333;"><strong>n0</strong></span> 
 <span style="color:#333333;"><strong>＝</strong></span> 
 <span style="color:#333333;"><strong>n2</strong></span> 
 <span style="color:#333333;"><strong>＋</strong></span> 
 <span style="color:#333333;"><strong>1 </strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">4. </span> 
 <span style="color:#333333;">具有</span> 
 <span style="color:#333333;"><strong>n</strong></span> 
 <span style="color:#333333;"><strong>个结点的完全二叉树的深度k为 log2(n+1)</strong></span> 
 <span style="color:#333333;"><strong> 上取整 </strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">5. </span> 
 <span style="color:#333333;">对于具有</span> 
 <span style="color:#333333;"><strong>n</strong></span> 
 <span style="color:#333333;"><strong>个结点的完全二叉树</strong></span> 
 <span style="color:#333333;">，如果按照</span> 
 <span style="color:#333333;"><strong>从上至下从左至右的顺序对所有节点从</strong></span> 
 <span style="color:#333333;"><strong>0</strong></span> 
 <span style="color:#333333;"><strong>开始编号，</strong></span> 
 <span style="color:#333333;">则对于</span> 
 <span style="color:#333333;"><strong>序号为</strong></span> 
 <span style="color:#333333;"><strong>i </strong></span> 
 <span style="color:#333333;"><strong>的结点有</strong></span> 
 <span style="color:#333333;">： </span> 
</div> 
<div> 
 <span style="color:#333333;">        若i&gt;0</span> 
 <span style="color:#333333;">，</span> 
 <span style="color:#333333;"><strong>双亲序号：</strong></span> 
 <span style="color:#333333;"><strong>(i-1)/2</strong></span> 
 <span style="color:#333333;">；</span> 
 <span style="color:#333333;"><strong>i=0</strong></span> 
 <span style="color:#333333;"><strong>，</strong></span> 
 <span style="color:#333333;"><strong>i</strong></span> 
 <span style="color:#333333;"><strong>为根结点编号</strong></span> 
 <span style="color:#333333;">，无双亲结点 </span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>        若2i+1&lt;n</strong></span> 
 <span style="color:#333333;"><strong>，左孩子序号：</strong></span> 
 <span style="color:#333333;"><strong>2i+1</strong></span> 
 <span style="color:#333333;"><strong>，否则无左孩子 </strong></span> 
</div> 
<div> 
 <span style="color:#333333;"><strong>        若2i+2&lt;n</strong></span> 
 <span style="color:#333333;"><strong>，右孩子序号：</strong></span> 
 <span style="color:#333333;"><strong>2i+2</strong></span> 
 <span style="color:#333333;"><strong>，否则无右孩子</strong></span> 
</div> 
<hr> 
<h3></h3> 
<h2 id="1.4%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span style="color:#333333;"><strong>二 、二叉树的实现</strong></span></h2> 
<blockquote> 
 <div>
   实现方法为2种。 
 </div> 
 <div>
           
  <strong>第一种</strong>： 
  <span style="background-color:#ffd900;">使用数组，顺序存储二叉树结点。</span> 
 </div> 
 <div>
           
  <strong>第二种</strong>： 
  <span style="background-color:#ffd900;">使用链表的链式存储。</span> 
 </div> 
 <div>
            此处我们使用链表实现 
 </div> 
</blockquote> 
<h3 id="1.4.1%E7%AC%AC%E4%B8%80%E7%A7%8D%20%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84">2.1第一种 使用数组</h3> 
<blockquote> 
 <p><img alt="" height="337" src="https://images2.imgbox.com/47/4b/wi2AuovI_o.png" width="616"></p> 
 <p> 红色标注的是结点的下标值，一层一层放入array数组里。</p> 
 <p> 特点：<span style="color:#fe2c24;">父结点=（孩子结点-1) / 2   </span><span style="color:#0d0016;">此时的结点 等于 数组的下标值。</span></p> 
</blockquote> 
<h3></h3> 
<h3 id="1.4.2%E7%AC%AC%E4%BA%8C%E7%A7%8D%20%E4%BD%BF%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0">2.2第二种 使用链表实现</h3> 
<blockquote> 
 <p class="img-center"><img alt="" height="310" src="https://images2.imgbox.com/dc/ef/nRZ0VSDp_o.png" width="507"></p> 
 <p><strong> 二叉树的链式存储</strong>：通过一个一个的节点引用起来的，因此可以通过链表的方式实现。</p> 
</blockquote> 
<h4 id="%C2%A02.2.1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA"> 2.2.1二叉树代码构建</h4> 
<pre><code class="language-java">public class BinaryTree{
    // 孩子表示法
    class Node {
      int val; // 数据域，代表结点的值
      Node left; // 左孩子的引用，常常代表左孩子为根的整棵左子树
      Node right; // 右孩子的引用，常常代表右孩子为根的整棵右子树
      Node(){}
      Node(int num)
     {
        this.val=num;
     }
  }

private Node root;

//构建二叉树
public void createBinaryTree(){
Node node1 = new Node(1);
Node node1 = new Node(2);
Node node1 = new Node(3);
Node node1 = new Node(4);
Node node1 = new Node(5);
Node node1 = new Node(6);
root = node1;
node1.left = node2;
node2.left = node3;
node1.right = node4;
node4.left = node5;
node5.right = node6;
}
// 获取树中节点的个数
public int size(Node root);
// 获取叶子节点的个数
public int getLeafNodeCount(Node root);
// 获取第K层节点的个数
public int getKLevelNodeCount(Node root,int k);
// 获取二叉树的高度
public int getHeight(Node root);
// 检测值为value的元素是否存在
public Node find(Node root, int val);
//层序遍历
public void levelOrder(Node root);
// 判断一棵树是不是完全二叉树
public boolean isCompleteTree(Node root);

}</code></pre> 
<h4 id="2.2.2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">2.2.2二叉树的基本操作</h4> 
<blockquote> 
 <p>获取二叉树结点个数：</p> 
 <pre><code class="language-java">public int size(Node root)
{
   if(root==null)
  return 0;
  return size(root.left)+size(root.right)+1;
}</code></pre> 
</blockquote> 
<blockquote> 
 <p>获取叶子结点个数：</p> 
 <pre><code class="language-java">// 获取叶子节点的个数
    public int getLeafNodeCount(Node root)
    {
        if(root==null)
        {
            return 0;
        }
        if(root.left==null&amp;&amp;root.right==null)
            return 1;
        return getLeafNodeCount(root.left)+getLeafNodeCount(root.right);
    }</code></pre> 
</blockquote> 
<blockquote> 
 <p> 获取第k层结点个数：</p> 
 <pre><code class="language-java">public int getKLevelNodeCount(TreeNode root, int k) {
        if(root == null) {
            return 0;
        }
        if(k == 1) {
            return 1;
        }
        return getKLevelNodeCount(root.left,k-1)
                + getKLevelNodeCount(root.right,k-1);
    }
</code></pre> 
</blockquote> 
<blockquote> 
 <p> 获取二叉树高度：</p> 
 <pre><code class="language-java">public  int getHeight(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int leftH = getHeight(root.left);
        int rightH = getHeight(root.right);

        return (leftH &gt; rightH ? leftH :rightH) + 1;
    }
</code></pre> 
</blockquote> 
<blockquote> 
 <p>检测是否存在value值：</p> 
 <pre><code class="language-java"> public TreeNode find(TreeNode root,int val) {
        if(root == null) return null;
        if(root.val == val) {
            return root;
        }
        TreeNode leftL = find(root.left,val);
        if(leftL != null) {
            return leftL;
        }
        TreeNode leftLR = find(root.right,val);
        if(leftLR != null) {
            return leftLR;
        }
        return null;
    }</code></pre> 
</blockquote> 
<blockquote> 
 <p>层序遍历：</p> 
 <pre><code class="language-java"> public void levelOrder(TreeNode root) {
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
       if(root != null) {
           queue.offer(root);
       }
       while (!queue.isEmpty()) {
           TreeNode top = queue.poll();
           System.out.print(top.val+" ");
           if(top.left != null) {
               queue.offer(top.left);
           }
           if(top.right != null) {
               queue.offer(top.right);
           }
       }

    }</code></pre> 
</blockquote> 
<blockquote> 
 <p> 是否为完全二叉树：</p> 
 <pre><code class="language-java"> public boolean isCompleteTree(TreeNode root) {
        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        if(root != null) {
            queue.offer(root);
        }
        while (!queue.isEmpty()) {
            Node cur = queue.poll();
            if(cur != null) {
                queue.offer(cur.left);
                queue.offer(cur.right);
            }else {
                break;
            }
        }
        while (!queue.isEmpty()) {
           Node cur = queue.poll();
            if(cur != null) {
                return false;
            }
        }
        return true;
    }</code></pre> 
</blockquote> 
<h3></h3> 
<h2 id="%E4%B8%89%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86">三、二叉树的三种遍历</h2> 
<blockquote> 
 <p>二叉树有四种遍历方法：<span style="background-color:#ffd900;">前序遍历、中序遍历、后序遍历已经层序遍历。</span></p> 
 <p><strong>前序遍历</strong>：访问根结点---&gt;根的左子树---&gt;根的右子树         <span style="background-color:#ffd900;">（根-左-右）</span></p> 
 <p><strong>中序遍历</strong>：根的左子树---&gt;根节点---&gt;根的右子树                <span style="background-color:#ffd900;">（左-根-右）</span></p> 
 <p><strong>后序遍历</strong>：根的左子树---&gt;根的右子树---&gt;根节点                <span style="background-color:#ffd900;">（左-右-根）</span></p> 
</blockquote> 
<p id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="1059" src="https://images2.imgbox.com/d4/47/qoT7BpPu_o.png" width="1200"></p> 
<p></p> 
<h3 id="3.1%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%20%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E9%81%8D%E5%8E%86">3.1递归方法实现 前、中、后遍历</h3> 
<blockquote> 
 <p>前序遍历：</p> 
 <pre><code class="language-java"> public void preOrder(TreeNode root) {
        if(root == null) return;
        System.out.print(root.val+" ");
        preOrder(root.left);
        preOrder(root.right);
    }</code></pre> 
</blockquote> 
<blockquote> 
 <p>中序遍历：</p> 
 <pre><code class="language-java"> public void inOrder(TreeNode root) {
        if(root == null) return;
        inOrder(root.left);
        System.out.print(root.val+" ");
        inOrder(root.right);
    }</code></pre> 
</blockquote> 
<blockquote> 
 <p>后序遍历：</p> 
 <pre><code class="language-java"> public void postOrder(TreeNode root) {
        if(root == null) return;
        postOrder(root.left);
        postOrder(root.right);
        System.out.print(root.val+" ");
    }</code></pre> 
</blockquote> 
<h3 id="3.2%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%C2%A0%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E9%81%8D%E5%8E%86">3.2非递归方法实现 前、中、后遍历</h3> 
<blockquote> 
 <p>前序遍历：</p> 
 <pre><code class="language-java">public void preOrderIteration(TreeNode head) {
    if(head==null){
       return;
    }
Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();
stack.push(head);
    while(！stack.isEmpty())
    {
        TreeNOde node=stack.pop();
        System.out.print(node.val+" ");
        if(node.right!=null)
        {
            stack.push(node.left);
        }
        if(node.left!=null){
            stack.push(node.right);
        }
    }
}</code></pre> 
 <p>利用栈的原理</p> 
</blockquote> 
<blockquote> 
 <p>中序遍历：</p> 
 <pre><code class="language-java"> public void inOrderIteration(TreeNode head) {
    if(head==null){
       return;
    }
    Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();
    TreeNode cur=head;
    while(!stack.isEmpty())
    {
        while(cur!=null)
        {
          stack.push(cur);
          cur=cur.left;
        }
        TreeNode node=stack.pop();
        System.out.print(node.val+"");
        if(node.right!=null)
        {
            cur=node.right;
        }
    }
}</code></pre> 
</blockquote> 
<blockquote> 
 <p>后序遍历：</p> 
 <pre><code class="language-java">public static void postOrderIteration(TreeNode head) {
        if (head == null) {
            return;
        }
        Stack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;();
        Stack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;();
        stack1.push(head);
        while (!stack1.isEmpty()) {
            TreeNode node = stack1.pop();
            stack2.push(node);
            if (node.left != null) {
                stack1.push(node.left);
            }
            if (node.right != null) {
                stack1.push(node.right);
            }
        }
        while (!stack2.isEmpty()) {
            System.out.print(stack2.pop().val + " ");
        }
    }</code></pre> 
 <p></p> 
</blockquote> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<p>         无论是链表实现，还是数组实现，各有其优势，不同情况使用，而不是代表链表实现比数组更好。二叉树里最重要的是完全二叉树，而在它基础上又实现了另一个数据结构，<span style="background-color:#ffd900;">堆</span>。在Java中更含有对应的实现类 <span style="background-color:#ffd900;">PriorityQueue</span> 。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f99924dfd5e7ff1ce1a7d90eed952b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用DirBuster寻找敏感文件和目录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3724a5c942c01d418ae9c00ca073385b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ES6—ES13新语法解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>