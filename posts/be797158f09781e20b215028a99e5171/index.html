<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java中的四种引用详解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java中的四种引用详解" />
<meta property="og:description" content="Java中的四种引用 Java中有四种引用类型：强引用、软引用、弱引用、虚引用。
强引用 强引用是最常见的一种引用类型，在实际开发中，几乎都是强引用类型。
Object obj = new Object(); 当我们的对象有强引用的时候，即使内存不足，JVM宁愿抛出OOM，也不会把该对象回收掉。如果需要让垃圾回收器回收此对象，需要将强引用关系打破，最简单的方式就是将对象赋值为null。下面写个例子做个简单说明：
创建一个Order对象，为了更好的知晓垃圾回收的情况，这里重写 finalize() 方法，因为对象被垃圾回收时都会调用此方法。
/** * 订单对象 */ public class Order { @Override protected void finalize() throws Throwable { System.out.println(&#34;order对象被垃圾回收&#34;); } } 当对象的强引用关系被打破时，显式调用垃圾回收器 /** * 强引用类型垃圾回收 */ public class NormalReferenceTest { public static void main(String[] args) throws IOException { Order order = new Order(); // 破坏引用关系 order = null; // 调用垃圾回收器，进行垃圾回收 System.gc(); System.out.println(order); ​ // 阻塞Main主线程 System.in.read(); ​ } } 输出结果： null order对象被垃圾回收 根据输出结果，可知Order对象被垃圾回收掉了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/be797158f09781e20b215028a99e5171/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-15T11:21:24+08:00" />
<meta property="article:modified_time" content="2022-08-15T11:21:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java中的四种引用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>Java中的四种引用</h3> 
<p>Java中有四种引用类型：强引用、软引用、弱引用、虚引用。</p> 
<h3>强引用</h3> 
<p>强引用是最常见的一种引用类型，在实际开发中，几乎都是强引用类型。</p> 
<pre><code class="language-java">Object obj = new Object();</code></pre> 
<p>当我们的对象有强引用的时候，即使内存不足，JVM宁愿抛出OOM，也不会把该对象回收掉。如果需要让垃圾回收器回收此对象，需要将强引用关系打破，最简单的方式就是将对象赋值为null。下面写个例子做个简单说明：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/89/4a/tk2CJyQN_o.png"></p> 
<p>创建一个Order对象，为了更好的知晓垃圾回收的情况，这里重写 <code>finalize()</code> 方法，因为对象被垃圾回收时都会调用此方法。</p> 
<pre><code class="language-java">/**
 * 订单对象
 */
public class Order {
    @Override
    protected void finalize() throws Throwable {
        System.out.println("order对象被垃圾回收");
    }
}</code></pre> 
<pre>当对象的强引用关系被打破时，显式调用垃圾回收器</pre> 
<pre><code class="language-java">/**
 * 强引用类型垃圾回收
 */
public class NormalReferenceTest {
    public static void main(String[] args) throws IOException {
        Order order = new Order();
        // 破坏引用关系
        order = null;
        // 调用垃圾回收器，进行垃圾回收
        System.gc();
        System.out.println(order);
​
        // 阻塞Main主线程
        System.in.read();
​
    }
}</code></pre> 
<pre>输出结果：</pre> 
<pre><code class="language-java">null
order对象被垃圾回收</code></pre> 
<p>根据输出结果，可知Order对象被垃圾回收掉了。</p> 
<p>注意：</p> 
<p>在生产环境上，一定不要去重写 <code>finalize()</code> 方法，有内存溢出的风险。由于每个对象在进行垃圾回收时都会去调用该对象的 <code>finalize()</code> 方法，该方法默认是空的，啥都没做，执行效率是非常快的。但是如果重写后就会影响垃圾回收的效率，假设此时业务上还有大量的对象产生，垃圾回收的效率小于对象产生的效率，时间一长就会内存溢出。</p> 
<h3>软引用</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/71/23/DJBGOnvM_o.png"></p> 
<p>软引用就是用 <code>SoftReference</code> 将引用对象包装一下，通过 <code>get()</code> 方法获取包装的对象，使用方式如下：</p> 
<pre><code class="language-javascript">SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;&gt;(new byte[1024 * 1024 * 10]);
softReference.get();//获取软引用对象</code></pre> 
<p>这里用一个例子说明软引用的特点</p> 
<pre><code class="language-java">-Xmx20M
SoftReference
get()
get()
get()</code></pre> 
<p>代码如下：</p> 
<pre><code class="language-java">public class SoftReferenceTest {
    public static void main(String[] args) {
        SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;&gt;(new byte[1024 * 1024 * 10]);// 10M
        // 获取软引用对象
        System.out.println(softReference.get());
        // 调用垃圾回收
        System.gc();
        // 睡眠一下，给与垃圾回收时间
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 再次获取软引用对象
        System.out.println(softReference.get());
​
        // 再new一个字节数组，堆内存不够，会触发垃圾回收，如果内存空间还不够，就会把软引用引用的对象回收掉
        byte[] bytes = new byte[1024 * 1024 * 12];// 12M
        // 再次获取软引用对象,此时将会获取为null
        System.out.println(softReference.get());
        
    }
}</code></pre> 
<p>运行结果：</p> 
<pre><code class="language-java">[B@677327b6
[B@677327b6
null</code></pre> 
<p>说明：</p> 
<p>第一次获取软引用对象是有值的，接着调用GC，GC垃圾回收后，第二次获取也是有值的，说明垃圾回收时先不会回收软引用对象。随后，继续往内存里面new一个12M的byte数组，显然，我们堆内存是20M，最开始的软引用对象占10M，这里在new 一个，内存是装不下的，所以触发了垃圾回收器回收10M的软引用对象，第三次获取软引用对象时为null，因为都已被垃圾回收器回收掉了。</p> 
<p>软引用的特点：当JVM进行垃圾回收时，如果第一次回收后内存足够，那么不会回收软引用对象；如果第一次回收后内存依旧不够，那么就会回收掉软引用对象。根据这个特点，软引用可以用来做缓存，当系统内存足够时，通过缓存获取值，如果内存不够时，先回收掉缓存，释放一定的内存空间，延迟OOM。</p> 
<h3>弱引用</h3> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ba/bb/gIoqm34E_o.png"></p> 
<p>弱引用就是通过 <code>WeakReference</code> 包装了一下，使用如下：</p> 
<pre><code class="language-java">WeakReference&lt;Order&gt; weakReference = new WeakReference&lt;&gt;(new Order());
// 获取弱引用的值
System.out.println(weakReference.get());</code></pre> 
<p>弱引用和软引用最大的区别就是无论内存是否足够，弱引用都会被GC回收</p> 
<pre><code class="language-java">/**
 * 弱引用
 */
public class WeakReferenceTest {
    public static void main(String[] args) {
        WeakReference&lt;Order&gt; weakReference = new WeakReference&lt;&gt;(new Order());
        // 获取弱引用的值
        System.out.println(weakReference.get());
        // 垃圾回收
        System.gc();
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 获取弱引用的值
        System.out.println(weakReference.get());
    }
}</code></pre> 
<pre>运行结果：</pre> 
<pre><code class="language-java">com.test.soft.Order@677327b6
order对象被垃圾回收
null</code></pre> 
<pre>弱引用在 <code>WeakHashMap</code> ， <code>ThreadLocal</code> 中有使用到。</pre> 
<h3>虚引用</h3> 
<p>Phantom 虚幻的</p> 
<ul><li>英[ˈfæntəm]</li></ul> 
<p>虚引用又叫做幻影引用，它需要配合一个队列来使用，但是我们 <strong>无法通过虚引用来获取一个对象的真实引用</strong> ，我们来看下面的代码</p> 
<pre><code class="language-java">ReferenceQueue&lt;Order&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
​
// 虚引用在垃圾回收的时候，会被放到一个队列里，这个队列供垃圾回收器做特殊处理
PhantomReference&lt;Order&gt; phantomReference = new PhantomReference&lt;&gt;(new Order(), referenceQueue);
System.out.println(phantomReference.get());// 这里输出结果为null</code></pre> 
<p>上述代码第五行的输出结果居然为null，进入到源码里面会发现</p> 
<pre><code class="language-java">public class PhantomReference&lt;T&gt; extends Reference&lt;T&gt; {
​
    /**
     * Returns this reference object's referent.  Because the referent of a
     * phantom reference is always inaccessible, this method always returns
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  &lt;code&gt;null&lt;/code&gt;
     */
    public T get() {
        return null;
    }
}</code></pre> 
<p>这居然直接返回的null，虚引用不能通过get()方法获取到值，那到底有何存在的意义呢？</p> 
<p>我们来看下面的代码：</p> 
<ol><li>为了演示效果，还是把堆内存大小设置为20M，添加JVM参数 <code>-Xmx20M</code></li><li>new 一个 <code>ReferenceQueue</code> 队列，创建虚引用，将 <code>new Order()</code> , <code>referenceQueue</code> 作为参数传入</li><li>开启一个线程，不断的往 <code>list</code> 集合中放入数据，时间长了堆内存会满，触发垃圾回收</li><li>再开启一个线程，循环读取 <code>ReferenceQueue</code> 队列里面的值</li></ol> 
<pre><code class="language-java">/**
 * 虚引用
 */
public class PhantomReferenceTest {
​
    public static void main(String[] args) {
        List&lt;Object&gt; list = new ArrayList&lt;&gt;();
        ReferenceQueue&lt;Order&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
​
        // 虚引用在垃圾回收的时候，会被放到一个队列里，这个队列供垃圾回收器做特殊处理
        PhantomReference&lt;Order&gt; phantomReference = new PhantomReference&lt;&gt;(new Order(), referenceQueue);
        System.out.println(phantomReference.get());
​
        new Thread(() -&gt; {
            while (true) {
                // 不断往list添加数据。内存会满，此时会进行垃圾回收，虚引用就会被放在队列里面
                list.add(new byte[1024 * 1024]);
                System.out.println(phantomReference.get());
            }
        }).start();
​
        new Thread(() -&gt; {
            while (true){
                // 从队列里面读数据
                Reference&lt;? extends Order&gt; poll = referenceQueue.poll();
                if (poll != null){
                    System.out.println("虚引用对象被JVM回收" + poll);
                }
            }
        }).start();
​
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
​
    }
}
​
复制代码
输出结果：

null
null
null
null
null
null
null
null
null
null
null
null
null
order对象被垃圾回收
null
null
null
null
null
虚引用对象被JVM回收java.lang.ref.PhantomReference@12bc0828
Exception in thread "Thread-0" java.lang.OutOfMemoryError: Java heap space
    at com.test.soft.PhantomReferenceTest.lambda$main$0(PhantomReferenceTest.java:29)
    at com.test.soft.PhantomReferenceTest$$Lambda$1/1831932724.run(Unknown Source)
    at java.lang.Thread.run(Thread.java:748)
​</code></pre> 
<p>虚引用特点：</p> 
<p>当垃圾回收器准备回收一个对象，如果发现它还有虚引用，那么就会在回收该对象之前，把这个虚引用加入到与之关联的 <code>ReferenceQueue</code> 中。在 <code>NIO</code> 中，就用了虚引用来管理堆外内存。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67401cc3ef3db0d4139070add477b757/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CentOS下JDK的安装配置过程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53ab78ed5d8cd31f7cb7203704152256/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lidar_imu自动标定</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>