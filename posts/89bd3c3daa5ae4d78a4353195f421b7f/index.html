<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>详细讲解axios封装与api接口封装管理 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="详细讲解axios封装与api接口封装管理" />
<meta property="og:description" content="一、前言 axios的封装和api接口的统一管理，其实主要目的就是在帮助我们简化代码和利于后期的更新维护。
在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库
二、axios封装步骤 安装axios npm install axios -S; // 安装axios复制代码 1.目录创建
一般我会在项目的src目录中，新建一个network文件夹,作为我们的网络请求模块，然后在里面新建一个http.js和一个api.js文件和一个reques.js。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口url, request.js对外暴露我们放在的api方法。
// 在http.js中引入axios import axios from &#39;axios&#39;; // 引入axios import router from &#39;../router&#39;; // vant的toast提示框组件，大家可根据自己的ui组件更改。 import { Toast } from &#39;vant&#39;; 环境的切换 我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。
创建config目录。 目录下创建env.development.js&#43;env.production.js&#43;env.test.js
env.development.js内容如下：
module.exports={ baseUrl:&#39; http://www.devele.com:4456&#39; //开发环境用到的baseurl } // 环境的切换 const {baseUrl}=require(&#39;../config/env.&#39;&#43;process.env.NODE_ENV); //同时 package.json的scripts需指定测试环境的模式 --mode test &#34;scripts&#34;: { &#34;serve&#34;: &#34;vue-cli-service serve&#34;, &#34;build&#34;: &#34;vue-cli-service build&#34;, &#34;test&#34;: &#34;vue-cli-service build --mode test&#34;, &#34;lint&#34;: &#34;vue-cli-service lint&#34; } const service = axios." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/89bd3c3daa5ae4d78a4353195f421b7f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-02T10:05:13+08:00" />
<meta property="article:modified_time" content="2023-06-02T10:05:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">详细讲解axios封装与api接口封装管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、前言</h2> 
<hr> 
<p>axios的封装和api接口的统一管理，其实主要目的就是在帮助我们简化代码和利于后期的更新维护。</p> 
<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库</p> 
<h3 id="%E4%BA%8C%E3%80%81axios%E5%B0%81%E8%A3%85%E6%AD%A5%E9%AA%A4">二、axios封装步骤</h3> 
<ol><li>安装axios</li></ol> 
<pre><code>    npm install axios -S; // 安装axios复制代码</code></pre> 
<p>1.目录创建</p> 
<p>一般我会在项目的src目录中，新建一个network文件夹,作为我们的网络请求模块，然后在里面新建一个http.js和一个api.js文件和一个reques.js。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口url, request.js对外暴露我们放在的api方法。</p> 
<pre><code>// 在http.js中引入axios
import axios from 'axios'; // 引入axios
import router from '../router';
// vant的toast提示框组件，大家可根据自己的ui组件更改。
import { Toast } from 'vant'; </code></pre> 
<p></p> 
<ol><li>环境的切换</li></ol> 
<p>我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。</p> 
<p>创建config目录。 目录下创建<code>env.development.js+env.production.js+env.test.js</code></p> 
<p><code>env.development.js</code>内容如下：</p> 
<pre><code>module.exports={
    baseUrl:' http://www.devele.com:4456' //开发环境用到的baseurl
}</code></pre> 
<p></p> 
<pre><code>// 环境的切换
const {baseUrl}=require('../config/env.'+process.env.NODE_ENV);
//同时 package.json的scripts需指定测试环境的模式  --mode test
 "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "test": "vue-cli-service build --mode test",
    "lint": "vue-cli-service lint"
  }
const service = axios.create({
  baseURL: baseUrl, // url = base api url + request url
  withCredentials: false, // send cookies when cross-domain requests
  timeout: 1000*12 // 请求超时
})</code></pre> 
<p></p> 
<p>4.如上 设置请求超时</p> 
<p>通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等。</p> 
<ol><li>post请求头的设置 post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为<code>application/x-www-form-urlencoded;charset=UTF-8</code></li></ol> 
<pre><code>// 设置post请求头
service.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';</code></pre> 
<p></p> 
<ol><li>请求拦截</li></ol> 
<p>我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。</p> 
<pre><code>// 先导入vuex,因为我们要使用到里面的状态对象
// vuex的路径根据自己的路径去写
import store from '@/store/index';
// 请求拦截器
service.interceptors.request.use(
  config =&gt; {
    // 不传递默认开启loading
    if (!config.hideloading) {
      // 请求是是否开启loading
      Toast.loading({
        forbidClick: true
      })
    }
      // 每次发送请求之前判断vuex中是否存在token        
        // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况
        // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 
    if (store.state.token) {
      config.headers.token = store.state.token;
      //有些接口是 config.headers.Authorization = token
    }
    return config
  },
  error =&gt; {
    // do something with request error
    console.log(error) // for debug
    return Promise.reject(error)
  }
)</code></pre> 
<p></p> 
<p>这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊！</p> 
<ol><li>响应的拦截</li></ol> 
<pre><code>// 响应拦截器
service.interceptors.response.use(
    response =&gt; {   
        // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据     
        // 否则的话抛出错误
        if (response.status === 200) {            
            return Promise.resolve(response);        
        } else {            
            return Promise.reject(response);        
        }    
    },    
    // 服务器状态码不是2开头的的情况
    // 这里可以跟你们的后台开发人员协商好统一的错误状态码    
    // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等
    // 下面列举几个常见的操作，其他需求可自行扩展
    error =&gt; {            
        if (error.response.status) {            
            switch (error.response.status) {                
                // 401: 未登录
                // 未登录则跳转登录页面，并携带当前页面的路径
                // 在登录成功后返回当前页面，这一步需要在登录页操作。                
                case 401:                    
                    router.replace({                        
                        path: '/login',                        
                        query: { 
                            redirect: router.currentRoute.fullPath 
                        }
                    });
                    break;
                // 403 token过期
                // 登录过期对用户进行提示
                // 清除本地token和清空vuex中token对象
                // 跳转登录页面                
                case 403:
                     Toast({
                        message: '登录过期，请重新登录',
                        duration: 1000,
                        forbidClick: true
                    });
                    // 清除token
                  store.dispatch('FedLogOut').then(() =&gt; {
                    // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 
                 router.replace({                            
                            path: '/login',                            
                            query: { 
                                redirect:router.currentRoute.fullPath 
                            }      
                  })      })       
                    break; 
                // 404请求不存在
                case 404:
                    Toast({
                        message: '网络请求不存在',
                        duration: 1500,
                        forbidClick: true
                    });
                    break;
                // 其他错误，直接抛出错误提示
                default:
                    Toast({
                        message: error.response.data.message,
                        duration: 1500,
                        forbidClick: true
                    });
            }
            return Promise.reject(error.response);
        }else {
            // 处理断网的情况
            // eg:请求超时或断网时，更新state的network状态
            // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏
            // 关于断网组件中的刷新重新获取数据，会在断网组件中说明
            store.commit('changeNetwork', false);
        }    
});
//最后导出实例
export default service;</code></pre> 
<p></p> 
<p>响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了<code>错误的统一处理</code>和<code>没登录</code>或<code>登录过期</code>后调整登录页的一个操作。</p> 
<p>到此处, axios的封装基本就完成了,下面再简单说下api的统一管理</p> 
<h3 id="%E4%B8%89%E3%80%81api%E6%8E%A5%E5%8F%A3%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86">三、api接口统一管理</h3> 
<p>新建了一个api文件夹，里面有一个index.js，以及多个根据模块划分的接口js文件。index.js是一个api的出口，其他js则用来管理各个模块的接口。</p> 
<p><strong>例如下面的article.js:</strong></p> 
<pre><code>/**
 * article模块接口列表
 */
import request from '@/network/http'; // 导入http中创建的axios实例
import qs from 'qs'; // 根据需求是否导入qs模块 
const article = {    
    // 新闻列表    
    articleList () {        
       return request({
       url: '/artical',
       method: 'get',
       params,
       hideloading: false //设置不隐藏加载loading
    })  
    },    
    // 新闻详情,演示    
    articleDetail (id, params) {        
         return request({
		      url: '/detail',
		      method: 'get',
		      params:{
		        goodsId
		      },
		      hideloading: true
		    })
    },
    // post提交    
    login (data) {        
      return request({
      url:'/adduser',
      method:'post',
      data:qs.stringify(data), //注意post提交用data参数
      hideloading: true
     })   
    }
    // 其他接口…………
}
export default article;</code></pre> 
<p></p> 
<p><strong>index.js代码：</strong></p> 
<pre><code>/** 
 * api接口的统一出口
 */
// 文章模块接口
import article from '@/api/article';
// 其他模块的接口…… 
// 导出接口
export default {    
    article,
    // ……
}</code></pre> 
<p></p> 
<h4 id="%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E6%8C%89%E9%9C%80%E5%AF%BC%E5%85%A5%EF%BC%89">在组件中的使用（按需导入）</h4> 
<pre><code>import {article} from '@/api/index'
created(){
   article.articleList().then(info=&gt;{
       if(info.code==200)
     this.num=info.data
  }
     })
}</code></pre> 
<p></p> 
<h4 id="api%E6%8C%82%E8%BD%BD%E5%88%B0vue.prototype%E4%B8%8A%E7%9C%81%E5%8E%BB%E5%BC%95%E5%85%A5%E7%9A%84%E6%AD%A5%E9%AA%A4">api挂载到vue.prototype上省去引入的步骤</h4> 
<p>为了方便api的调用，我们需要将其挂载到vue的原型上。在main.js中：</p> 
<pre><code>import Vue from 'vue'
import App from './App'
import router from './router' // 导入路由文件
import store from './store' // 导入vuex文件
import api from './api' // 导入api接口
Vue.prototype.$api = api; // 将api挂载到vue的原型上复制代码</code></pre> 
<p></p> 
<p>然后我们在组件中可以这么用</p> 
<pre><code>//无需导入
methods: {    
    onLoad(id) {      
        this.$api.article.articleDetail(id, {        
            api: 123      
        }).then(res=&gt; {
            // 执行某些操作      
        })    
    }  
}</code></pre> 
<p><br> 断网情况处理</p> 
<p>如下app.vue新增</p> 
<pre><code>&lt;template&gt;  
    &lt;div id="app"&gt;    
        &lt;div v-if="!network"&gt;      
            &lt;h3&gt;我没网了&lt;/h3&gt;      
            &lt;div @click="onRefresh"&gt;刷新&lt;/div&gt;      
        &lt;/div&gt;    
        &lt;router-view/&gt;      
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import { mapState } from 'vuex';
    export default {  
        name: 'App',  
        computed: {    
            ...mapState(['network'])  
        },  
        methods: {    
            // 通过跳转一个空页面再返回的方式来实现刷新当前页面数据的目的
            onRefresh () {      
                this.$router.replace('/refresh')    
            }  
        }
    }
&lt;/script&gt;</code></pre> 
<p></p> 
<p>这是app.vue，这里简单演示一下断网。在http.js中介绍了，我们会在断网的时候，来更新vue中network的状态，那么这里我们根据network的状态来判断是否需要加载这个断网组件。断网情况下，加载断网组件，不加载对应页面的组件。当点击刷新的时候，我们通过跳转refesh页面然后立即返回的方式来实现重新获取数据的操作。因此我们需要新建一个refresh.vue页面，并在其beforeRouteEnter钩子中再返回当前页面。</p> 
<pre><code>// refresh.vue
beforeRouteEnter (to, from, next) {
    next(vm =&gt; {            
        vm.$router.replace(from.fullPath)        
    })    
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/41602ea151a7448b72a8710e8b90eb4d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安装ubuntu分区设置</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b12e241c4bd687611f3c207f916be809/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java使用AOP操作日志，傻瓜版</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>