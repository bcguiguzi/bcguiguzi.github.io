<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Wireshark（四）：网络性能排查之TCP重传与重复ACK - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Wireshark（四）：网络性能排查之TCP重传与重复ACK" />
<meta property="og:description" content="Wireshark（四）：网络性能排查之TCP重传与重复ACK 原文出处： EMC中文支持论坛 作为网络管理员，很多时间必然会耗费在修复慢速服务器和其他终端。但用户感到网络运行缓慢并不意味着就是网络问题。
解决网络性能问题，首先从TCP错误恢复功能（TCP重传与重复ACK）和流控功能说起。之后阐述如何发现网络慢速之源。最后，对网络各组成部分上的数据流进行概况分析。这几张内容将会帮助读者识别，诊断，以及排查慢速网络。
更多信息
接下来的内容，较多是黑白图片了。虽然看起来有点不爽，但还是很值得一看。
TCP错误恢复功能：
TCP的错误恢复功能是定位，诊断及修复网络延时的最佳工具。延时可以在单程也可以往返方向测量。高延时是网络管理员的头号大敌。本节我们讨论TCP高延时是如何导致序列号和确认号乱序的。
TCP重传：
主机报文重传是TCP最基本的错误恢复功能，它的目的是防止报文丢失。
报文丢失的可能因素有很多种，包括应用故障，路由设备过载，或暂时的服务宕机。报文级别速度是很高的，而通常报文丢失是暂时的，因此TCP能够发现和恢复报文丢失显得尤为重要。
决定报文是否有必要重传的主要机制是重传计时器（retransmission timer），它的主要功能是维护重传超时（RTO）值。当报文使用TCP传输时，重传计时器启动，收到ACK时计时器停止。报文发送至接收到ACK的时 间称为往返时间（RTT）。对若干次时间取平均值，该值用于确定最终RTO值。在最终RTO值确定之前，确定每一次报文传输是否有丢包发生使用重传计时 器，下图说明了TCP重传过程。
当报文发送之后，但接收方尚未发送TCP ACK报文，发送方假设源报文丢失并将其重传。重传之后，RTO值加倍；如果在2倍RTO值到达之前还是没有收到ACK报文，就再次重传。如果仍然没有收 到ACK，那么RTO值再次加倍。如此持续下去，每次重传RTO都翻倍，直到收到ACK报文或发送方达到配置的最大重传次数。
最大重传次数取决于发送操作系统的配置值。默认情况下，Windows主机默认重传5次。大多数Linux系统默认最大15次。两种操作系统都可配置。
示例如下图：
TCP重传过程发送的第一个报文如下图所示（图片不很清楚，已经尽力了）：
这是一个TCP PSH/ACK报文①，包含648字节数据②，从10.3.30.1发送至10.3.71.7。这是一个典型的数据报文。
在通常情况下，第一个报文发送之后很快会收到TCP ACK报文。然而，在这个case里，第二个是重传报文。可以在Packet list面板里看到。Info栏清楚的标明“TCP Retransmission”，报文以黑色背景红色字体标出。下图是Packet List面板中的重传示例（仍然不清楚，但可参见上图）：
也可以在Packet Details和Packet Bytes面板中查看来确定是否是重传报文，如下图所示：
注意此报文与源报文相同（除了IP标识和checksum字段）。要验证这一点，比较两个报文的Packet Bytes①。
在Packet Details面板，注意到重传报文在SEQ/ACK Analysis下面有些额外的信息②。这些信息是由Wireshark提供的而并非报文本身。SEQ/ACK Analysis告诉我们这确实是一个重传报文，RTO值是0.206秒，此时的RTO是基于报文1的时间增量。
检查剩下的报文会得到类似的结果，不同之处只有IP标识和checksum，以及RTO值。要使报文之间的时间间隔形象化，在Packet List面板中查看Time栏，如下图所示。这里可以看到RTO值的翻倍增长关系。
TCP重复ACK以及快速重传：
重复ACK是指在接收方收到乱序报文时，所发出的一类TCP报文。TCP使用报文头的序列号和确认号以有效保证数据按照发送的顺序接收和重组。
当TCP连接建立以后，握手过程中交换的一个最重要的信息是初始序列号（ISN）。一旦连接双方设定了ISN之后，接下来发送的报文所包含的序列号增加一个数据载荷值。
假设有个主机ISN是5000，发送500字节报文至接收方。一旦报文接收之后，接收端回复一个ACK号为5500的TCP ACK报文，基于以下公式：
Sequence Number In &#43; Bytes of Data Received = Acknowledgment Number Out
按照上述计算结果，返回发送端的确认编号实际上是接收端希望收到的序列号。示例如下图：
数据接收方通过序列号来检查报文丢失。接收方通过追踪接收到的序列号，能够确认序列号是否乱序。当接收方收到一个不正常的序列号，它会假设传输过程中有报 文丢失。为了正确重传数据，接收方必须拥有丢失报文，所以它发送包含有丢失报文正确序列号的ACK报文，以便发送方重传此报文。
当重传主机从发送端接收到3个重复ACK时，它会假设此报文确实在传送中丢失，并且立即发送一个快速重传。一旦触发了快速重传，所有正在传输的其他报文都被放入队列中，直到快速重传报文发送为止。过程如下图所示：
承接上文的彩图：
本例中第一个报文如下图：
这是一个TCP ACK报文，从数据接收端（172.31.136.85）发给发送端（195.81.202.68）①，确认前一个报文所发送的数据。
此报文中的确认编号是1310973186②，应当是下一个接收报文的序列号，如下图所示：
不幸的是接收端的序列号是1310984130①，并不是所期望的值。这意味着报文在传送中丢失。接收端注意到报文乱序，并且在第三个报文中发送重复ACK，如下图所示：
可以通过以下两种方式之一来确认这是一个重复ACK：
在Packet Detaisl面板中的Info栏。报文呈现黑色背景红色字体。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/5198a44f71623ab7f9ac9338cf7e5525/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-13T14:31:29+08:00" />
<meta property="article:modified_time" content="2021-09-13T14:31:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Wireshark（四）：网络性能排查之TCP重传与重复ACK</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a href="https://www.cnblogs.com/stephen-init/p/3833009.html" rel="nofollow" id="cb_post_title_url" title="Wireshark（四）：网络性能排查之TCP重传与重复ACK">Wireshark（四）：网络性能排查之TCP重传与重复ACK</a></h2> 
<p>原文出处： <a href="https://community.emc.com/message/819924#819924" rel="nofollow" title="EMC中文支持论坛">EMC中文支持论坛</a>   <br>  </p> 
<p>作为网络管理员，很多时间必然会耗费在修复慢速服务器和其他终端。但用户感到网络运行缓慢并不意味着就是网络问题。</p> 
<p>解决网络性能问题，首先从TCP错误恢复功能（TCP重传与重复ACK）和流控功能说起。之后阐述如何发现网络慢速之源。最后，对网络各组成部分上的数据流进行概况分析。这几张内容将会帮助读者识别，诊断，以及排查慢速网络。</p> 
<p>更多信息<br> 接下来的内容，较多是黑白图片了。虽然看起来有点不爽，但还是很值得一看。</p> 
<p>TCP错误恢复功能：</p> 
<p>TCP的错误恢复功能是定位，诊断及修复网络延时的最佳工具。延时可以在单程也可以往返方向测量。高延时是网络管理员的头号大敌。本节我们讨论TCP高延时是如何导致序列号和确认号乱序的。</p> 
<p>TCP重传：</p> 
<p>主机报文重传是TCP最基本的错误恢复功能，它的目的是防止报文丢失。</p> 
<p>报文丢失的可能因素有很多种，包括应用故障，路由设备过载，或暂时的服务宕机。报文级别速度是很高的，而通常报文丢失是暂时的，因此TCP能够发现和恢复报文丢失显得尤为重要。</p> 
<p>决定报文是否有必要重传的主要机制是重传计时器（retransmission timer），它的主要功能是维护重传超时（RTO）值。当报文使用TCP传输时，重传计时器启动，收到ACK时计时器停止。报文发送至接收到ACK的时 间称为往返时间（RTT）。对若干次时间取平均值，该值用于确定最终RTO值。在最终RTO值确定之前，确定每一次报文传输是否有丢包发生使用重传计时 器，下图说明了TCP重传过程。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/84/e5/04DMDK4f_o.png"></p> 
<p>当报文发送之后，但接收方尚未发送TCP ACK报文，发送方假设源报文丢失并将其重传。重传之后，RTO值加倍；如果在2倍RTO值到达之前还是没有收到ACK报文，就再次重传。如果仍然没有收 到ACK，那么RTO值再次加倍。如此持续下去，每次重传RTO都翻倍，直到收到ACK报文或发送方达到配置的最大重传次数。</p> 
<p>最大重传次数取决于发送操作系统的配置值。默认情况下，Windows主机默认重传5次。大多数Linux系统默认最大15次。两种操作系统都可配置。<br> 示例如下图：</p> 
<p style="text-align:center;"><img alt="" id="pic" src="https://images2.imgbox.com/2c/a7/2acAXcC2_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ce/57/Zj0spGZv_o.png"></p> 
<p>TCP重传过程发送的第一个报文如下图所示（图片不很清楚，已经尽力了）：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c0/d3/wAzHas9J_o.png"></p> 
<p>这是一个TCP PSH/ACK报文①，包含648字节数据②，从10.3.30.1发送至10.3.71.7。这是一个典型的数据报文。</p> 
<p>在通常情况下，第一个报文发送之后很快会收到TCP ACK报文。然而，在这个case里，第二个是重传报文。可以在Packet list面板里看到。Info栏清楚的标明“TCP Retransmission”，报文以黑色背景红色字体标出。下图是Packet List面板中的重传示例（仍然不清楚，但可参见上图）：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/06/23/ugib2Xs8_o.png"></p> 
<p>也可以在Packet Details和Packet Bytes面板中查看来确定是否是重传报文，如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2e/20/s3oVYRNd_o.png"></p> 
<p>注意此报文与源报文相同（除了IP标识和checksum字段）。要验证这一点，比较两个报文的Packet Bytes①。</p> 
<p>在Packet Details面板，注意到重传报文在SEQ/ACK Analysis下面有些额外的信息②。这些信息是由Wireshark提供的而并非报文本身。SEQ/ACK Analysis告诉我们这确实是一个重传报文，RTO值是0.206秒，此时的RTO是基于报文1的时间增量。</p> 
<p>检查剩下的报文会得到类似的结果，不同之处只有IP标识和checksum，以及RTO值。要使报文之间的时间间隔形象化，在Packet List面板中查看Time栏，如下图所示。这里可以看到RTO值的翻倍增长关系。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ea/21/YXAj1Xsx_o.png"></p> 
<p>TCP重复ACK以及快速重传：</p> 
<p>重复ACK是指在接收方收到乱序报文时，所发出的一类TCP报文。TCP使用报文头的序列号和确认号以有效保证数据按照发送的顺序接收和重组。</p> 
<p>当TCP连接建立以后，握手过程中交换的一个最重要的信息是初始序列号（ISN）。一旦连接双方设定了ISN之后，接下来发送的报文所包含的序列号增加一个数据载荷值。</p> 
<p>假设有个主机ISN是5000，发送500字节报文至接收方。一旦报文接收之后，接收端回复一个ACK号为5500的TCP ACK报文，基于以下公式：</p> 
<p><strong>Sequence Number In + Bytes of Data Received = Acknowledgment Number Out</strong></p> 
<p>按照上述计算结果，返回发送端的确认编号实际上是接收端希望收到的序列号。示例如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4e/79/EhdSj6Fl_o.png"></p> 
<p><br> 数据接收方通过序列号来检查报文丢失。接收方通过追踪接收到的序列号，能够确认序列号是否乱序。当接收方收到一个不正常的序列号，它会假设传输过程中有报 文丢失。为了正确重传数据，接收方必须拥有丢失报文，所以它发送包含有丢失报文正确序列号的ACK报文，以便发送方重传此报文。</p> 
<p>当重传主机从发送端接收到3个重复ACK时，它会假设此报文确实在传送中丢失，并且立即发送一个快速重传。一旦触发了快速重传，所有正在传输的其他报文都被放入队列中，直到快速重传报文发送为止。过程如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/72/71/JOLOFjXH_o.png"></p> 
<p>承接上文的彩图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/73/92/zfg6YKL1_o.png"></p> 
<p>本例中第一个报文如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/cc/ff/B9LBtFeo_o.png"></p> 
<p><br> 这是一个TCP ACK报文，从数据接收端（172.31.136.85）发给发送端（195.81.202.68）①，确认前一个报文所发送的数据。<br> 此报文中的确认编号是1310973186②，应当是下一个接收报文的序列号，如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/34/d5/J7nENBXW_o.png"></p> 
<p><br> 不幸的是接收端的序列号是1310984130①，并不是所期望的值。这意味着报文在传送中丢失。接收端注意到报文乱序，并且在第三个报文中发送重复ACK，如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8c/fe/q6SzkB4X_o.png"></p> 
<p>可以通过以下两种方式之一来确认这是一个重复ACK：</p> 
<p>在Packet Detaisl面板中的Info栏。报文呈现黑色背景红色字体。</p> 
<p>SEQ/ACK Analysis下的Packet Deatails面板。扩展这一栏会发现报文显示为duplicate ACK。接下来几个报文重复此过程。如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fe/c9/6g9Susgk_o.png"></p> 
<p><br> 此文件中的第四个报文是发送端所发出具有错误序列号①的另一个数据块。因此，接收端发送第二个重复ACK②。接收端又收到一个乱序报文③。从而触发了第三以及最后一个重复ACK④.</p> 
<p>一旦发送方接收到接收方所发来的第三个重复ACK，它就会暂停所有传输报文并且重传丢失报文，下图显示了快速重传过程：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8b/eb/uSdRZvWH_o.png"></p> 
<p>重传报文同样可以通过Packet List面板的Info栏观察到。报文呈现黑色背景红色字体。这个报文的SEQ/ACK Analysis截面告诉我们这可能是一个快速重传帧。（标识报文为快速重传的信息不是报文本身所包含的内容，而是Wireshark的功能）。最后一个 报文是接收到快速重传的ACK。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4d21f49694cc5f4508353dcf3036e9da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot学习(五十八) springboot中使用SseEmitter推送消息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0d8f29533d32cbd33c603028065d48d5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常见YUV格式（YUV444/YUV422/YUV420）解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>