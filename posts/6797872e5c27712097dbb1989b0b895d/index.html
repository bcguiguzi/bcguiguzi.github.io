<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用Axios网络请求（三） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用Axios网络请求（三）" />
<meta property="og:description" content="1.引入 首先，你需要引入 Axios。这里有两种方式将 Axios 引入你的项目。
第一种，你可以使用 npm 进行安装:
npm install axios --save
然后你需要引入它: import axios from &#39;axios&#39;
第二种，你可以使用 CDN 来引入 axios： &lt;script src=&#34;https://unpkg.com/axios/dist/axios.min.js&#34;&gt;&lt;/script&gt;
2.介绍 axios（ajax i/o system）不是一种新技术，本质上也是对原生XHR（XMLHttpReques）的封装，只不过它是基于Promise的，是Promise的实现版本，符合最新的ES规范。
axios有以下特性： 从浏览器创建 XMLHttpRequests
从 node.js 创建 http 请求
支持 Promise API
拦截请求和响应
转换请求和响应数据
取消请求
自动转换JSON数据
客户端支持防御XSRF
axios可以请求的方法： get：获取数据，请求指定的信息，返回实体对象
post：向指定资源提交数据（例如表单提交或文件上传）
put：更新数据，从客户端向服务器传送的数据取代指定的文档的内容
patch：更新数据，是对put方法的补充，用来对已知资源进行局部更新
delete：请求服务器删除指定的数据
head：获取报文首部
请求方法别名 为了方便起见，axios为所有支持的请求方法提供了别名:
axios(config)
axios.request(config)
axios.get(url [,config])
axios.post(url [,data [,config]])
axios.put(url [,data [,config]])
axios.delete(url [,config])
axios.patch(url [,data [,config]])
axios.head(url [,config])" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/6797872e5c27712097dbb1989b0b895d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-13T13:57:37+08:00" />
<meta property="article:modified_time" content="2024-03-13T13:57:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用Axios网络请求（三）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<h6>1.引入</h6> 
<hr> 
<p> </p> 
<p>首先，你需要引入 Axios。这里有两种方式将 Axios 引入你的项目。</p> 
<p><strong>第一种，你可以使用 npm 进行安装:</strong></p> 
<blockquote> 
 <p>npm install axios --save</p> 
</blockquote> 
<p><strong>然后你需要引入它: </strong></p> 
<blockquote> 
 <p>import axios from 'axios'</p> 
</blockquote> 
<p></p> 
<p><strong>第二种，你可以使用 CDN 来引入 axios： </strong></p> 
<blockquote> 
 <p>&lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;</p> 
</blockquote> 
<p> </p> 
<h6>2.介绍</h6> 
<hr> 
<p> </p> 
<p>axios（ajax i/o system）不是一种新技术，本质上也是对原生XHR（XMLHttpReques）的封装，只不过它是基于Promise的，是Promise的实现版本，符合最新的ES规范。</p> 
<h6 id="slide-2">axios有以下特性：</h6> 
<p>从浏览器创建 XMLHttpRequests</p> 
<p>从 node.js 创建 http 请求</p> 
<p>支持 Promise API</p> 
<p>拦截请求和响应</p> 
<p>转换请求和响应数据</p> 
<p>取消请求</p> 
<p>自动转换JSON数据</p> 
<p>客户端支持防御XSRF</p> 
<h6 id="slide-3">axios可以请求的方法：</h6> 
<p>get：获取数据，请求指定的信息，返回实体对象</p> 
<p>post：向指定资源提交数据（例如表单提交或文件上传）</p> 
<p>put：更新数据，从客户端向服务器传送的数据取代指定的文档的内容</p> 
<p>patch：更新数据，是对put方法的补充，用来对已知资源进行局部更新</p> 
<p>delete：请求服务器删除指定的数据</p> 
<p>head：获取报文首部</p> 
<h6 id="slide-4">请求方法别名</h6> 
<p>为了方便起见，axios为所有支持的请求方法提供了别名:</p> 
<p>axios(config)</p> 
<p>axios.request(config)</p> 
<p>axios.get(url [,config])</p> 
<p>axios.post(url [,data [,config]])</p> 
<p>axios.put(url [,data [,config]])</p> 
<p>axios.delete(url [,config])</p> 
<p>axios.patch(url [,data [,config]])</p> 
<p>axios.head(url [,config])</p> 
<p> </p> 
<h6>3、创建axios实例</h6> 
<hr> 
<p> </p> 
<p>axios.create([config])</p> 
<p>可以同时创建多个axios实例。</p> 
<p>示例演示：</p> 
<pre><code class="language-javascript">const instance = axios.create({
baseURL: 'https://some-domain.com/api/',
timeout: 1000,
headers: {'X-Custom-Header': 'foobar'}
});</code></pre> 
<h6> 4.配置方法</h6> 
<hr> 
<p>配置对象常用的配置项：</p> 
<p>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 GET 方法。更多配置项请查看官方文档</p> 
<p> </p> 
<p> </p> 
<pre><code class="language-javascript">{
  // 路径url
  url: '/user',
 
  // 请求方法，默认get
  method: 'get', 
 
  //基础url，最终请求的url是 baseURL+url拼接，所以再全局设置默认，可以使得发送请求时的url变得简洁
  baseURL: 'https://some-domain.com/api/',
 
  //设置请求头
  headers: {'X-Requested-With': 'XMLHttpRequest'},
 
  //设置请求url的query参数，可以使得url简洁。
  //比如url是https://some-domain.com/api/user  然后params如下设置，那么最终的url是：
  //https://some-domain.com/api/user?ID=12345&amp;name=Jack
  params: {
  ID: 12345,
  name:"Jack"
  },
 
 //设置请求体
  data: {
  firstName: 'Fred'
  },
 
  //设置请求的另外一种格式，不过这个是直接设置字符串的
  data: 'Country=Brasil&amp;City=Belo Horizonte',
 
 //请求超时，单位毫秒，默认0，不超时。
  timeout: 1000,
 
  //响应数据类型，默认json
  responseType: 'json', 
 
  //响应数据的编码规则，默认utf-8
  responseEncoding: 'utf8',
 
  //响应体的最大长度 
  maxContentLength: 2000,
 
  // 请求体的最大长度
  maxBodyLength: 2000,
 
  //设置响应状态码为多少时是成功，调用resolve，否则调用reject失败
  //默认是大于等于200，小于300
  validateStatus: function (status) {
  return status &gt;= 200 &amp;&amp; status &lt; 300; 
  },</code></pre> 
<p>默认配置</p> 
<p>可以设置全局默认配置，是为了避免多种重复配置在不同请求中重复，比如baseURL、timeout等，这里设置baseURL。</p> 
<p>全局 axios 默认值</p> 
<pre><code class="language-javascript">axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;
axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';
"""
自定义实例默认值
"""
// 创建实例时配置默认值
const instance = axios.create({
  baseURL: 'https://api.example.com'
});
 
// 创建实例后修改默认值
instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;</code></pre> 
<p>配置的优先级</p> 
<p>配置将会按优先级进行合并。它的顺序是：在 lib/defaults.js 中找到的库默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后面的优先级要高于前面的。</p> 
<h6><strong> </strong></h6> 
<h6><strong>5.拦截器</strong></h6> 
<hr> 
<p> </p> 
<p> 在请求或响应被 then 或 catch 处理前拦截它们，自定义的axios实例也可添加拦截器，如：</p> 
<pre><code class="language-javascript">const instance = axios.create();
instance.interceptors.request.use(function () {/*...*/});</code></pre> 
<p>请求拦截器</p> 
<p>示例代码</p> 
<pre><code class="language-javascript">// 添加请求拦截器
axios.interceptors.request.use(function (config) {
  // 在发送请求之前做些什么
  return config;
  }, function (error) {
  // 对请求错误做些什么
  return Promise.reject(error);
  });</code></pre> 
<p> 响应拦截器</p> 
<p>示例代码</p> 
<pre><code class="language-javascript">// 添加响应拦截器
axios.interceptors.response.use(function (response) {
  // 2xx 范围内的状态码都会触发该函数。
  // 对响应数据做点什么
  return response;
  }, function (error) {
  // 超出 2xx 范围的状态码都会触发该函数。
  // 对响应错误做点什么
  return Promise.reject(error);
  });</code></pre> 
<p>取消拦截器</p> 
<p>示例代码</p> 
<pre><code class="language-javascript">const myInterceptor = axios.interceptors.request.use(function () {/*...*/});
axios.interceptors.request.eject(myInterceptor);</code></pre> 
<h6>6.取消请求 </h6> 
<hr> 
<p> </p> 
<p>注意：从 v0.22.0 开始，Axios 支持以 fetch API 方式—— AbortController 取消请求，CancelToken API被弃用</p> 
<p>这里我们两种方法都介绍一下，使用过程中能用 AbortController 就尽量别用 CancelToken</p> 
<h5 id="slide-10">AbortController</h5> 
<pre><code class="language-javascript">const controller = new AbortController();
 
axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// 取消请求
controller.abort()</code></pre> 
<p><strong> CancelToken</strong></p> 
<pre><code class="language-javascript">let source = axios.CancelToken.source();
 
axios.get('/users/12345',{
        cancelToken: source.token
      }).then(res=&gt;{
        console.log(res)
      }).catch(err=&gt;{
        //取消请求后会执行该方法
        console.log(err)
      })
 
//取消请求，参数可选，该参数信息会发送到请求的catch中
source.cancel('取消后的信息');</code></pre> 
<p>也可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建一个 cancel token</p> 
<pre><code class="language-javascript">const CancelToken = axios.CancelToken;
let cancel;
 
axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
  // executor 函数接收一个 cancel 函数作为参数
  cancel = c;
  })
});
 
// 取消请求
cancel();</code></pre> 
<p>注意: 可以使用同一个 cancel token 或 signal 取消多个请求</p> 
<h6>7.axios封装</h6> 
<hr> 
<p>先设计我们想要这个通用请求能达到什么样的效果：</p> 
<p>优化配置，设置默认配置项（responseType、跨域携带cookie、token、超时设置）</p> 
<p>统一设置请求头</p> 
<p>根据环境设置 baseURL</p> 
<p>通过 Axios 方法直接发起请求</p> 
<p>添加请求拦截器</p> 
<p>添加响应拦截器</p> 
<p>导出 Promise 对象</p> 
<p>封装 Post 方法，精简 post 请求方式</p> 
<p>封装 Get 方法，精简 get 请求方式</p> 
<p>请求成功，配置业务状态码</p> 
<p>全局的loading配置</p> 
<h6>7.1 VUE中axios的封装</h6> 
<p>在vue项目中，和后台交互获取数据这块，我们通常使用的是axios库，它是基于promise的http库，可运行在浏览器端和node.js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。所以我们的尤大大也是果断放弃了对其官方库vue-resource的维护，直接推荐我们使用axios库。如果还对axios不了解的，可以移步axios文档。</p> 
<p>安装 <code>npm install axios //=&gt; 安装axios</code></p> 
<p>引入</p> 
<p>一般我会在项目的src目录中，新建一个request文件夹，然后在里面新建一个http.js和一个api.js文件。http.js文件用来封装我们的axios，api.js用来统一管理我们的接口。</p> 
<pre><code class="language-javascript">// 在http.js中引入axios
import axios from 'axios'; // 引入axios
import QS from 'qs'; // 引入qs模块，用来序列化post类型的数据，后面会提到
// vant的toast提示框组件，大家可根据自己的ui组件更改。
import { Toast } from 'vant';</code></pre> 
<p>环境的切换</p> 
<p>我们的项目环境可能有开发环境、测试环境和生产环境。我们通过node的环境变量来匹配我们的默认的接口url前缀。axios.defaults.baseURL可以设置axios的默认请求地址就不多说了。</p> 
<pre><code class="language-javascript">// =&gt; 环境的切换
if (process.env.NODE_ENV == 'development') {    
  axios.defaults.baseURL = 'https://www.baidu.com';} 
else if (process.env.NODE_ENV == 'debug') {    
  axios.defaults.baseURL = 'https://www.ceshi.com';
} 
else if (process.env.NODE_ENV == 'production') {    
  axios.defaults.baseURL = 'https://www.production.com';
}</code></pre> 
<p>设置请求超时</p> 
<p>通过axios.defaults.timeout设置默认的请求超时时间。例如超过了10s，就会告知用户当前请求超时，请刷新等。</p> 
<pre><code class="language-javascript">axios.defaults.timeout = 10000;</code></pre> 
<p>post请求头的设置</p> 
<p>post请求的时候，我们需要加上一个请求头，所以可以在这里进行一个默认的设置，即设置post的请求头为application/x-www-form-urlencoded;charset=UTF-8</p> 
<pre><code class="language-javascript">axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';</code></pre> 
<p>请求拦截</p> 
<p>我们在发送请求前可以进行一个请求的拦截，为什么要拦截呢，我们拦截请求是用来做什么的呢？比如，有些请求是需要用户登录之后才能访问的，或者post请求的时候，我们需要序列化我们提交的数据。这时候，我们可以在请求被发送之前进行一个拦截，从而进行我们想要的操作。</p> 
<pre><code class="language-javascript">请求拦截
// 先导入vuex,因为我们要使用到里面的状态对象
// vuex的路径根据自己的路径去写
import store from '@/store/index';
 
// 请求拦截器axios.interceptors.request.use(    
  config =&gt; {        
    // 每次发送请求之前判断vuex中是否存在token        
    // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况
    // 即使本地存在token，也有可能token是过期的，所以在响应拦截器中要对返回状态进行判断 
    const token = store.state.token;        
    token &amp;&amp; (config.headers.Authorization = token);        
    return config;    
  },    
  error =&gt; {        
    return Promise.error(error);    
})</code></pre> 
<p>这里说一下token，一般是在登录完成之后，将用户的token通过localStorage或者cookie存在本地，然后用户每次在进入页面的时候（即在main.js中），会首先从本地存储中读取token，如果token存在说明用户已经登陆过，则更新vuex中的token状态。然后，在每次请求接口的时候，都会在请求的header中携带token，后台人员就可以根据你携带的token来判断你的登录是否过期，如果没有携带，则说明没有登录过。这时候或许有些小伙伴会有疑问了，就是每个请求都携带token，那么要是一个页面不需要用户登录就可以访问的怎么办呢？其实，你前端的请求可以携带token，但是后台可以选择不接收啊！</p> 
<p>响应的拦截</p> 
<pre><code class="language-javascript">// 响应拦截器
axios.interceptors.response.use(    
  response =&gt; {   
    // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据     
    // 否则的话抛出错误
    if (response.status === 200) {            
      return Promise.resolve(response);        
    } else {            
      return Promise.reject(response);        
    }    
  },    
  // 服务器状态码不是2开头的的情况
  // 这里可以跟你们的后台开发人员协商好统一的错误状态码    
  // 然后根据返回的状态码进行一些操作，例如登录过期提示，错误提示等等
  // 下面列举几个常见的操作，其他需求可自行扩展
  error =&gt; {            
    if (error.response.status) {            
      switch (error.response.status) {                
        // 401: 未登录
        // 未登录则跳转登录页面，并携带当前页面的路径
        // 在登录成功后返回当前页面，这一步需要在登录页操作。                
        case 401:                    
          router.replace({                        
            path: '/login',                        
            query: { 
              redirect: router.currentRoute.fullPath 
            }
          });
          break;
 
            // 403 token过期
            // 登录过期对用户进行提示
            // 清除本地token和清空vuex中token对象
            // 跳转登录页面                
            case 403:
                 Toast({
                    message: '登录过期，请重新登录',
                    duration: 1000,
                    forbidClick: true
                });
                // 清除token
                localStorage.removeItem('token');
                store.commit('loginSuccess', null);
                // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 
                setTimeout(() =&gt; {                        
                    router.replace({                            
                        path: '/login',                            
                        query: { 
                            redirect: router.currentRoute.fullPath 
                        }                        
                    });                    
                }, 1000);                    
                break; 
 
            // 404请求不存在
            case 404:
                Toast({
                    message: '网络请求不存在',
                    duration: 1500,
                    forbidClick: true
                });
                break;
            // 其他错误，直接抛出错误提示
            default:
                Toast({
                    message: error.response.data.message,
                    duration: 1500,
                    forbidClick: true
                });
        }
        return Promise.reject(error.response);
    }
}    
});</code></pre> 
<p>响应拦截器很好理解，就是服务器返回给我们的数据，我们在拿到之前可以对他进行一些处理。例如上面的思想：如果后台返回的状态码是200，则正常返回数据，否则的根据错误的状态码类型进行一些我们需要的错误，其实这里主要就是进行了错误的统一处理和没登录或登录过期后调整登录页的一个操作。</p> 
<p>要注意的是，上面的Toast()方法，是我引入的vant库中的toast轻提示组件，你根据你的ui库，对应使用你的一个提示组件。</p> 
<h6>7.2 封装get方法和post方法</h6> 
<p>我们常用的ajax请求方法有get、post、put等方法，相信小伙伴都不会陌生。axios对应的也有很多类似的方法，不清楚的可以看下文档。但是为了简化我们的代码，我们还是要对其进行一个简单的封装。下面我们主要封装两个方法：get和post。</p> 
<p>get方法：我们通过定义一个get函数，get函数有两个参数，第一个参数表示我们要请求的url地址，第二个参数是我们要携带的请求参数。get函数返回一个promise对象，当axios其请求成功时resolve服务器返回 值，请求失败时reject错误值。最后通过export抛出get函数。</p> 
<pre><code class="language-javascript">/**
 * get方法，对应get请求
 * @param {String} url [请求的url地址]
 * @param {Object} params [请求时携带的参数]
 */
export function get(url, params){    
  return new Promise((resolve, reject) =&gt;{        
    axios.get(url, {            
      params: params        
    }).then(res =&gt; {
      resolve(res.data);
    }).catch(err =&gt;{
      reject(err.data)        
  })    
});}</code></pre> 
<p>post方法：原理同get基本一样，但是要注意的是，post方法必须要使用对提交从参数对象进行序列化的操作，所以这里我们通过node的qs模块来序列化我们的参数。这个很重要，如果没有序列化操作，后台是拿不到你提交的数据的。这就是文章开头我们import QS from ‘qs’;的原因。如果不明白序列化是什么意思的，就百度一下吧，答案一大堆。</p> 
<pre><code class="language-javascript">/** 
 * post方法，对应post请求 
 * @param {String} url [请求的url地址] 
 * @param {Object} params [请求时携带的参数] 
 */
export function post(url, params) {
  return new Promise((resolve, reject) =&gt; {
     axios.post(url, QS.stringify(params))
    .then(res =&gt; {
      resolve(res.data);
    })
    .catch(err =&gt;{
      reject(err.data)
    })
  });
}</code></pre> 
<p>这里有个小细节说下，axios.get()方法和axios.post()在提交数据时参数的书写方式还是有区别的。区别就是，get的第二个参数是一个{}，然后这个对象的params属性值是一个参数对象的。而post的第二个参数就是一个参数对象。两者略微的区别要留意哦！axios的封装基本就完成了。</p> 
<p>以上就是axios一些简单的介绍，axios库很灵活，可以配置很多参数，根据自己项目的需要可以封装，axios和Promise，await ，async配合使用，效果很优美，也会为自己带来简便。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/caf024385f22be888cf1a145f5faec3f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【论文阅读】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c4a54ba8acafadca686ea056c652f6de/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c/c&#43;&#43;| 常规 |sizeof 、strlen</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>