<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Boot单元测试入门实战 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Boot单元测试入门实战" />
<meta property="og:description" content="一、关于JUnit的一些东西
在我们开发Web应用时，经常会直接去观察结果进行测试。虽然也是一种方式，但是并不严谨。作为开发者编写测试代码来测试自己所写的业务逻辑是，以提高代码的质量、降低错误方法的概率以及进行性能测试等。经常作为开发这写的最多就是单元测试。引入spring-boot-starter-testSpringBoot的测试依赖。该依赖会引入JUnit的测试包，也是我们用的做多的单元测试包。而Spring Boot在此基础上做了很多增强，支持很多方面的测试，例如JPA，MongoDB，Spring MVC（REST）和Redis等。
接下来主要是测试业务逻辑层的代码，REST和Mock测试。
1.1 JUnit介绍
JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个。 JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。
JUnit相关概念含义测试一个以@Test注释的方法定义一个测试，运行这个方法，JUnit会创建一个包含类的实例，然后再调用这个被注释的方法。测试类包含多个@Test方法的一个类Assert定义想测试的条件，当条件成立时，assert 方法保持沉默，条件不成立时，则抛出异常SuiteSuite允许将测试类归类成一组RunnerRunner类用于运行测试，JUnit4是向后兼容的，可以运行JUnit3的测试实例 这里使用的是JUnit4.x版本，JUnit中有两个重要的类Assume&#43;Assert，以及重要的注解：BeforeClass、AfterClass、After、Before、Test和Ignore。BeforeClass和AfterClass在每个类的开始和结束的时候运行，需要static修饰方法。而Before和After则是在每个测试方法的开始和结束的时候运行。
代码片段：TestDeployApplication.class是自己编写的Spring Boot启动类。
@RunWith(SpringRunner.class)
@SpringBootTest(classes = {TestDeployApplication.class})
public class UnitTest1 {
@BeforeClass
public static void beforeClass() {
System.out.println(&#34;=================BeforeClass================&#34;);
}
@AfterClass
public static void afterClass() {
System.out.println(&#34;=================AfterClass================&#34;);
}
@Before
public void beforeTest() {
System.out.println(&#34;before test&#34;);
}
@After
public void afterTest() {
System.out.println(&#34;after test&#34;);
}
@Test
public void test1() {
System.out.println(&#34;test1&#34;);
}
@Test
public void test2() {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/04a5422374ae45d7410132656a9e1c4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-13T21:05:20+08:00" />
<meta property="article:modified_time" content="2024-03-13T21:05:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Boot单元测试入门实战</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、关于JUnit的一些东西</p> 
<p>在我们开发Web应用时，经常会直接去观察结果进行测试。虽然也是一种方式，但是并不严谨。作为开发者编写测试代码来测试自己所写的业务逻辑是，以提高代码的质量、降低错误方法的概率以及进行<a href="https://so.csdn.net/so/search?q=%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95&amp;spm=1001.2101.3001.7020" title="性能测试">性能测试</a>等。经常作为开发这写的最多就是单元测试。引入spring-boot-starter-testSpringBoot的测试依赖。该依赖会引入JUnit的测试包，也是我们用的做多的单元测试包。而Spring Boot在此基础上做了很多增强，支持很多方面的测试，例如JPA，MongoDB，Spring MVC（REST）和Redis等。<br> 接下来主要是测试业务逻辑层的代码，REST和Mock测试。</p> 
<p>1.1 JUnit介绍</p> 
<p>JUnit是一个Java语言的<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95&amp;spm=1001.2101.3001.7020" title="单元测试">单元测试</a>框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中最为成功的一个。 JUnit有它自己的JUnit扩展生态圈。多数Java的开发环境都已经集成了JUnit作为单元测试的工具。</p> 
<table><thead><tr><th>JUnit相关概念</th><th>含义</th></tr></thead><tbody><tr><td>测试</td><td>一个以@Test注释的方法定义一个测试，运行这个方法，JUnit会创建一个包含类的实例，然后再调用这个被注释的方法。</td></tr><tr><td>测试类</td><td>包含多个@Test方法的一个类</td></tr><tr><td>Assert</td><td>定义想测试的条件，当条件成立时，assert 方法保持沉默，条件不成立时，则抛出异常</td></tr><tr><td>Suite</td><td>Suite允许将测试类归类成一组</td></tr><tr><td>Runner</td><td>Runner类用于运行测试，JUnit4是向后兼容的，可以运行JUnit3的测试实例</td></tr></tbody></table> 
<p>这里使用的是JUnit4.x版本，JUnit中有两个重要的类Assume+Assert，以及重要的注解：BeforeClass、AfterClass、After、Before、Test和Ignore。BeforeClass和AfterClass在每个类的开始和结束的时候运行，需要static修饰方法。而Before和After则是在每个测试方法的开始和结束的时候运行。<br> 代码片段：TestDeployApplication.class是自己编写的Spring Boot启动类。</p> 
<pre></pre> 
<ol><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@SpringBootTest(classes = {TestDeployApplication.class})</code></p> </li><li> <p><code>public class UnitTest1 {<!-- --></code></p> </li><li><li> <p><code>@BeforeClass</code></p> </li><li> <p><code>public static void beforeClass() {<!-- --></code></p> </li><li> <p><code>System.out.println("=================BeforeClass================");</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>@AfterClass</code></p> </li><li> <p><code>public static void afterClass() {<!-- --></code></p> </li><li> <p><code>System.out.println("=================AfterClass================");</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>@Before</code></p> </li><li> <p><code>public void beforeTest() {<!-- --></code></p> </li><li> <p><code>System.out.println("before test");</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>@After</code></p> </li><li> <p><code>public void afterTest() {<!-- --></code></p> </li><li> <p><code>System.out.println("after test");</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test1() {<!-- --></code></p> </li><li> <p><code>System.out.println("test1");</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test2() {<!-- --></code></p> </li><li> <p><code>System.out.println("test2");</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p></p> 
<h5><a name="t0"></a>1.2 JUnit的Assert类</h5> 
<p>Assert类中常用的方法：</p> 
<ul><li>assertEquals(“提示信息”,A,B)：当判断A是否等于B，不等于就抛出错误。比较对象是调用的是equals()方法。</li><li>assertSame(“提示信息”,A,B)：判断对象是否相同。</li><li>assertTrue(“提示信息”,A)：判断条件A是否为真。</li><li>assertFalse(“提示信息”,A)：判断条件是否为假。</li><li>assertNotNull(“提示信息”,A)：判断对象是否不为空。</li><li>assertNull(“提示信息”,A)：判断对象是否不为空。</li><li>assertArrayEqual(“提示信息”,A,B)：判断数组A和数组B是否相等。</li></ul> 
<h5><a name="t1"></a>1.3 JUnit的Suite</h5> 
<p>JUnit的Suite设计就是一次性运行一个或多个测试用例，Suite可以看作是一个容器，用来把测试类归类在一起，并把他们作为一个集合来运行，运行器启动Suite。</p> 
<pre></pre> 
<ol><li> <p><code>@RunWith(Suite.class)</code></p> </li><li> <p><code>@SuiteClasses({UnitTest1.class,UnitTest2.class})</code></p> </li><li> <p><code>public class MainTest{<!-- --></code></p> </li><li><li> <p><code>}</code></p> </li></ol> 
<h5><a name="t2"></a>二、Spring Boot单元测试</h5> 
<p>添加需要的依赖</p> 
<pre></pre> 
<ol><li> <p><code>&lt;dependency&gt;</code></p> </li><li> <p><code>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</code></p> </li><li> <p><code>&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</code></p> </li><li> <p><code>&lt;scope&gt;test&lt;/scope&gt;</code></p> </li><li> <p><code>&lt;/dependency&gt;</code></p> </li></ol> 
<h4><a name="t3"></a>2.1 Spring Boot测试依赖提供的测试范围</h4> 
<p>引入了<a href="https://so.csdn.net/so/search?q=spring-boot&amp;spm=1001.2101.3001.7020" title="spring-boot">spring-boot</a>-starter-test继承了很多的测试库：</p> 
<ul><li>JUnit，标准的单元测试Java程序。</li><li>Spring Test和Spring Boot Test，对Spring Boot应用的单元测试。</li><li>Mockito，Java Mock测试框架，用于模拟任何Spring管理的Bean。例如在- - 单元测试中，模拟一个第三方系统接口返回的数据，而不用真正地去请求第三方接口。</li><li>AssertJ，一个assertion库，同时提供了更加多的期望值与测试返回值的比较方式。</li><li>Hamcrest，库的匹配对象。</li><li>JSONassert，对JSON对象或者JSON字符串断言的库。</li><li>JSONPath，提供向XPath那样的符号来获取JSON字段。</li></ul> 
<h4><a name="t4"></a>2.2 Spring Boot单元测试的脚手架</h4> 
<p>在使用spring.io创建的Spring Boot工程中，就默认常见了一个单元测试的类。<br>  </p> 
<pre></pre> 
<ol><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@SpringBootTest</code></p> </li><li> <p><code>public class UnitTest1 {<!-- --></code></p> </li><li> <p><code>@Test</code></p> </li><li> <p><code>public void contextLoads(){<!-- --></code></p> </li><li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>@RunWith是JUnit中的注解，用来通知JUnit单元测试框架不要使用内置的方式进行单元测试，向上面的写法，就是指定使用SpringRunner类来提供单元测试。</p> 
<p>@SpringBootTest注解则是用于Spring Boot应用的测试，默认会分局报名逐级往上查找Spring Boot主程序，也就是@SpringBootApplocation注解，并在单元测试启动的时候启动该类来创建Spring上下文。所以我们在对Spring Boot应用进行单元测试的时候，在日志输出都可以看到Spring Boot应用的启动日志。</p> 
<h5><a name="t5"></a>2.3 对Service层代码测试</h5> 
<pre></pre> 
<ol><li> <p><code>import static org.mockito.BDDMockito.given;</code></p> </li><li> <p><code>import static org.mockito.Mockito.*;</code></p> </li><li><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@SpringBootTest</code></p> </li><li> <p><code>@Transactional</code></p> </li><li> <p><code>public class ServiceUnitTest {<!-- --></code></p> </li><li><li> <p><code>@MockBean</code></p> </li><li> <p><code>private ThirdSystemService thirdSystemService;</code></p> </li><li><li> <p><code>@Autowired</code></p> </li><li> <p><code>private ISysUserService userService;</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test1() {<!-- --></code></p> </li><li> <p><code>Long expectResult = 100L;</code></p> </li><li> <p><code>given(thirdSystemService.develop()).willReturn(expectResult);</code></p> </li><li> <p><code>SysUser sysUser = userService.findById(expectResult);</code></p> </li><li> <p><code>System.out.println(sysUser.toString());</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p></p> 
<p>@MockBean可以获取在Spring下上文管理的Bean，但是thirdSystemService这个Bean并不是真的实列，而是通过Mockito工具创建的测试实例。通过@MockBean注解模拟出来的Bean，调用方法是不会真正的调用真正的方法，适用于在依赖了第三方的系统，然而第三方的系统的对接并没有实现完成，自己可以单独测试自己的业务代码。willReturn(expectResult)说明结果永远返回100L。</p> 
<h5><a name="t6"></a>2.5 测试MVC代码</h5> 
<p>Spring Boot中还能单独测试Controller的代码，例如测试Controller中方法的参数绑定和校验之类的逻辑。可以通过@WebMvcTest注解来完成单元测试。</p> 
<pre></pre> 
<ol><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@WebMvcTest(SysUserController.class)</code></p> </li><li> <p><code>public class ServiceUnitTest {<!-- --></code></p> </li><li><li> <p><code>@Autowired</code></p> </li><li> <p><code>private MockMvc mockMvc;</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test2() throws Exception {<!-- --></code></p> </li><li> <p><code>MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.get("/hello/{id}", 1L);</code></p> </li><li> <p><code>mockMvc.perform(requestBuilder)</code></p> </li><li> <p><code>.andExpect(MockMvcResultMatchers.status().isOk())</code></p> </li><li> <p><code>.andDo(MockMvcResultHandlers.print());</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p>像Get方法传递参数</p> 
<pre></pre> 
<ol><li> <p><code>MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders</code></p> </li><li> <p><code>.get("/hello/{id}", 1L) // path变量</code></p> </li><li> <p><code>.param("name", "hello"); // @RequestParam 获取变量。post请求也适用</code></p> </li></ol> 
<p>文件上传</p> 
<pre></pre> 
<ol><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@WebMvcTest(SysUserController.class)</code></p> </li><li> <p><code>public class ServiceUnitTest {<!-- --></code></p> </li><li><li> <p><code>@Autowired</code></p> </li><li> <p><code>private MockMvc mockMvc;</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test3() throws Exception {<!-- --></code></p> </li><li> <p><code>// 获取文件</code></p> </li><li> <p><code>FileInputStream fileInputStream = new FileInputStream("文件路径");</code></p> </li><li> <p><code>// 构建文件上传对象</code></p> </li><li> <p><code>MockMultipartFile mockMultipartFile = new MockMultipartFile("file", fileInputStream);</code></p> </li><li> <p><code>// 构建mock文件上传请求</code></p> </li><li> <p><code>MockMultipartHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders.multipart("/upload").file(mockMultipartFile);</code></p> </li><li> <p><code>// 发送请求</code></p> </li><li> <p><code>mockMvc.perform(requestBuilder)</code></p> </li><li> <p><code>.andExpect(MockMvcResultMatchers.status().isOk())</code></p> </li><li> <p><code>.andDo(MockMvcResultHandlers.print());</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p></p> 
<pre></pre> 
<ol><li> <p><code>模拟Cookie和Session</code></p> </li><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@WebMvcTest(SysUserController.class)</code></p> </li><li> <p><code>public class ServiceUnitTest {<!-- --></code></p> </li><li><li> <p><code>@Autowired</code></p> </li><li> <p><code>private MockMvc mockMvc;</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test4() throws Exception {<!-- --></code></p> </li><li> <p><code>MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders</code></p> </li><li> <p><code>.get("index.html")</code></p> </li><li> <p><code>.sessionAttr("name", "hello")</code></p> </li><li> <p><code>.cookie(new Cookie("token", "123345"));</code></p> </li><li> <p><code>mockMvc.perform(requestBuilder)</code></p> </li><li> <p><code>.andExpect(MockMvcResultMatchers.status().isOk())</code></p> </li><li> <p><code>.andDo(MockMvcResultHandlers.print());</code></p> </li><li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p></p> 
<p>设置请求头</p> 
<pre></pre> 
<ol><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@WebMvcTest(SysUserController.class)</code></p> </li><li> <p><code>public class ServiceUnitTest {<!-- --></code></p> </li><li><li> <p><code>@Autowired</code></p> </li><li> <p><code>private MockMvc mockMvc;</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test5() throws Exception {<!-- --></code></p> </li><li> <p><code>MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders</code></p> </li><li> <p><code>.get("index.html")</code></p> </li><li> <p><code>.content(MediaType.APPLICATION_JSON_VALUE) // 期望返回类型</code></p> </li><li> <p><code>.contentType(MediaType.APPLICATION_JSON_VALUE) // 提交的内容类型</code></p> </li><li> <p><code>.header("token", 1235); // 设置请求头</code></p> </li><li> <p><code>mockMvc.perform(requestBuilder)</code></p> </li><li> <p><code>.andExpect(MockMvcResultMatchers.status().isOk())</code></p> </li><li> <p><code>.andDo(MockMvcResultHandlers.print());</code></p> </li><li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p></p> 
<h5><a name="t7"></a>2.6 比较返回结果</h5> 
<p>MockMvc类的perform方法会返回一个ResultAction类，可以对结果进行一些操作(andExpect、andDo和andReturn)。</p> 
<pre></pre> 
<ol><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@WebMvcTest(SysUserController.class)</code></p> </li><li> <p><code>public class ServiceUnitTest {<!-- --></code></p> </li><li><li> <p><code>@Autowired</code></p> </li><li> <p><code>private MockMvc mockMvc;</code></p> </li><li><li> <p><code>@Test</code></p> </li><li> <p><code>public void test2() throws Exception {<!-- --></code></p> </li><li> <p><code>MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders</code></p> </li><li> <p><code>.get("/hello/{id}", 1L)</code></p> </li><li> <p><code>.param("name", "hello");</code></p> </li><li><li> <p><code>mockMvc.perform(requestBuilder)</code></p> </li><li> <p><code>.andExpect(MockMvcResultMatchers.jsonPath("$.id", "id").value(2L));</code></p> </li><li> <p><code>.andDo(MockMvcResultHandlers.print());</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p></p> 
<p>例如上面获取返回的JSON结果中的id字段的值，value是期望值，如果期望值与实际值不一样测试就会报错。<br> 也可以断言测试返回结果的View(视图)和Model(数据模型)是否是期望值</p> 
<pre></pre> 
<ol><li> <p><code>@RunWith(SpringRunner.class)</code></p> </li><li> <p><code>@WebMvcTest(SysUserController.class)</code></p> </li><li> <p><code>public class ServiceUnitTest {<!-- --></code></p> </li><li><li> <p><code>@Autowired</code></p> </li><li> <p><code>private MockMvc mockMvc;</code></p> </li><li><li> <p><code>MockHttpServletRequestBuilder requestBuilder = MockMvcRequestBuilders</code></p> </li><li> <p><code>.get("/hello/{id}", 1L)</code></p> </li><li> <p><code>.param("name", "hello");</code></p> </li><li><li> <p><code>mockMvc.perform(requestBuilder)</code></p> </li><li> <p><code>// 断言返回的试图</code></p> </li><li> <p><code>.andExpect(MockMvcResultMatchers.view().name("index.html"))</code></p> </li><li> <p><code>// 断言返回的数据模型中的数据</code></p> </li><li> <p><code>.andExpect(MockMvcResultMatchers.model().attribute("id",1L))</code></p> </li><li> <p><code>.andDo(MockMvcResultHandlers.print());</code></p> </li><li> <p><code>}</code></p> </li></ol> 
<p></p> 
<p>更多的结果断言可以在<code>MockMvcResultMatchers</code>类中找到，该类是请求结果的匹配的一个工具类。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a7e29b4fff114a5f6dc0312331af2bec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vscode 之 vue项目如何使用ctrl&#43;鼠标左键跳转对应文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f3ea5aac8bfcd67635ba28cd6c16e6e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML、CSS、JavaScript</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>