<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库基础之视图 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库基础之视图" />
<meta property="og:description" content="目录
1、视图
1.1、为什么使用视图
1.2、视图的规则和限制
2、创建视图
2.1、利用视图简化复杂的联结 2.2、用视图重新格式化检索出的数据
2.3、用视图过滤不想要的数据
2.4、使用视图与计算字段
1、视图 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。
说明：DBMS支持 Microsoft Access不支持视图，没有与SQL视图一致的工作方式。因此，本次的内容不适用Microsoft Access。 MySQL从版本5起开始支持视图，因此，本次的内容不适用较早版本的MySQL。 SQLite仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。
理解视图的最好方法是看例子。用下面的SELECT语句从三个表中检索数据：
输入: SELECT cust_name, cust_contact FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num AND prod_id = &#39;RGAN01&#39;; 此查询用来检索订购了某种产品的顾客。任何需要这个数据的人都必须理解相关表的结构，知道如何创建查询和对表进行联结。检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。
现在，假如可以把整个查询包装成一个名为ProductCustomers的虚拟表，则可以如下轻松地检索出相同的数据：
输入:
SELECT cust_name, cust_contact FROM ProductCustomers WHERE prod_id = &#39;RGAN01&#39;; 这就是视图的作用。ProductCustomers是一个视图，作为视图，它不包含任何列或数据，包含的是一个查询（与上面用以正确联结表的相同查询）。
提示：DBMS的一致支持 所有DBMS非常一致地支持视图创建语法。
1.1、为什么使用视图 我们已经看到了视图应用的一个例子。下面是视图的一些常见应用。
重用SQL语句。简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。使用表的一部分而不是整个表。 、保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 创建视图之后，可以用与表基本相同的方式使用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至添加和更新数据（添加和更新数据存在某些限制，关于这个内容稍后做介绍）。
重要的是，要知道视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。
注意：性能问题 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。
1.2、视图的规则和限制 创建视图前，应该知道它的一些限制。不过，这些限制随不同的DBMS而不同，因此在创建视图时应该查看具体的DBMS文档。 下面是关于视图创建和使用的一些最常见的规则和限制。
与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。对于可以创建的视图数目没有限制。创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予。视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。许多DBMS禁止在视图查询中使用ORDER BY子句。有些DBMS要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。视图不能索引，也不能有关联的触发器或默认值。有些DBMS把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表。详情请参阅具体的DBMS文档。有些DBMS允许创建这样的视图，它不能进行导致行不再属于视图的插入或更新。例如有一个视图，只检索带有电子邮件地址的顾客。如果更新某个顾客，删除他的电子邮件地址，将使该顾客不再属于视图。这是默认行为，而且是允许的，但有的DBMS可能会防止这种情况发生。 提示：参阅具体的DBMS文档 上面的规则不少，而具体的DBMS文档很可能还包含别的规则。因此，在创建视图前，有必要花点时间了解必须遵守的规定。
2、创建视图 理解了什么是视图以及管理它们的规则和约束后，我们来创建视图。 视图用CREATE VIEW语句来创建。与CREATE TABLE一样，CREATE VIEW只能用于创建不存在的视图。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/15c3b4fc87d8734603c42d4cabf28a69/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-01T10:20:21+08:00" />
<meta property="article:modified_time" content="2022-05-01T10:20:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库基础之视图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1%E3%80%81%E8%A7%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#1%E3%80%81%E8%A7%86%E5%9B%BE" rel="nofollow">1、视图</a></p> 
<p id="1.1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE-toc" style="margin-left:80px;"><a href="#1.1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE" rel="nofollow">1.1、为什么使用视图</a></p> 
<p id="1.2%E3%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E8%A7%84%E5%88%99%E5%92%8C%E9%99%90%E5%88%B6-toc" style="margin-left:80px;"><a href="#1.2%E3%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E8%A7%84%E5%88%99%E5%92%8C%E9%99%90%E5%88%B6" rel="nofollow">1.2、视图的规则和限制</a></p> 
<p id="2%E3%80%81%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE-toc" style="margin-left:40px;"><a href="#2%E3%80%81%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE" rel="nofollow">2、创建视图</a></p> 
<p id="2.1%E3%80%81%E5%88%A9%E7%94%A8%E8%A7%86%E5%9B%BE%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%9A%84%E8%81%94%E7%BB%93%C2%A0-toc" style="margin-left:80px;"><a href="#2.1%E3%80%81%E5%88%A9%E7%94%A8%E8%A7%86%E5%9B%BE%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%9A%84%E8%81%94%E7%BB%93%C2%A0" rel="nofollow">2.1、利用视图简化复杂的联结 </a></p> 
<p id="2.2%E3%80%81%E7%94%A8%E8%A7%86%E5%9B%BE%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#2.2%E3%80%81%E7%94%A8%E8%A7%86%E5%9B%BE%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">2.2、用视图重新格式化检索出的数据</a></p> 
<p id="2.3%E3%80%81%E7%94%A8%E8%A7%86%E5%9B%BE%E8%BF%87%E6%BB%A4%E4%B8%8D%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#2.3%E3%80%81%E7%94%A8%E8%A7%86%E5%9B%BE%E8%BF%87%E6%BB%A4%E4%B8%8D%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE" rel="nofollow">2.3、用视图过滤不想要的数据</a></p> 
<p id="2.4%E3%80%81%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5-toc" style="margin-left:80px;"><a href="#2.4%E3%80%81%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5" rel="nofollow">2.4、使用视图与计算字段</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h3>1、视图</h3> 
<p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p> 
<blockquote> 
 <p><strong>说明：DBMS支持 </strong></p> 
 <p>Microsoft Access不支持视图，没有与SQL视图一致的工作方式。因此，本次的内容不适用Microsoft Access。 MySQL从版本5起开始支持视图，因此，本次的内容不适用较早版本的MySQL。 SQLite仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。</p> 
</blockquote> 
<p>理解视图的最好方法是看例子。用下面的SELECT语句从三个表中检索数据：</p> 
<p><strong>输入: </strong></p> 
<pre><code class="language-sql">SELECT cust_name, cust_contact FROM 
Customers, Orders, OrderItems 
WHERE 
Customers.cust_id = Orders.cust_id  AND OrderItems.order_num = Orders.order_num  AND prod_id = 'RGAN01'; </code></pre> 
<p>此查询用来检索订购了某种产品的顾客。任何需要这个数据的人都必须理解相关表的结构，知道如何创建查询和对表进行联结。检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。</p> 
<p>现在，假如可以把整个查询包装成一个名为ProductCustomers的虚拟表，则可以如下轻松地检索出相同的数据：</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">SELECT cust_name, cust_contact FROM ProductCustomers WHERE prod_id = 'RGAN01'; </code></pre> 
<p>这就是视图的作用。ProductCustomers是一个视图，作为视图，它不包含任何列或数据，包含的是一个查询（与上面用以正确联结表的相同查询）。</p> 
<blockquote> 
 <p><strong>提示：DBMS的一致支持 </strong></p> 
 <p>所有DBMS非常一致地支持视图创建语法。</p> 
</blockquote> 
<h4 id="1.1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE">1.1、为什么使用视图</h4> 
<p>我们已经看到了视图应用的一个例子。下面是视图的一些常见应用。</p> 
<ol><li>重用SQL语句。</li><li>简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。</li><li>使用表的一部分而不是整个表。 、</li><li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ol> 
<p>创建视图之后，可以用与表基本相同的方式使用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至添加和更新数据（添加和更新数据存在某些限制，关于这个内容稍后做介绍）。</p> 
<p>重要的是，要知道视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。</p> 
<blockquote> 
 <p><strong>注意：性能问题 </strong></p> 
 <p>因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</p> 
</blockquote> 
<h4 id="1.2%E3%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E8%A7%84%E5%88%99%E5%92%8C%E9%99%90%E5%88%B6"><strong>1.2、视图的规则和限制</strong></h4> 
<p>创建视图前，应该知道它的一些限制。不过，这些限制随不同的DBMS而不同，因此在创建视图时应该查看具体的DBMS文档。 下面是关于视图创建和使用的一些最常见的规则和限制。</p> 
<ol><li>与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。</li><li>对于可以创建的视图数目没有限制。</li><li>创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予。</li><li>视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。</li><li>许多DBMS禁止在视图查询中使用ORDER BY子句。</li><li>有些DBMS要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。</li><li>视图不能索引，也不能有关联的触发器或默认值。</li><li>有些DBMS把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表。详情请参阅具体的DBMS文档。</li><li>有些DBMS允许创建这样的视图，它不能进行导致行不再属于视图的插入或更新。例如有一个视图，只检索带有电子邮件地址的顾客。如果更新某个顾客，删除他的电子邮件地址，将使该顾客不再属于视图。这是默认行为，而且是允许的，但有的DBMS可能会防止这种情况发生。</li></ol> 
<blockquote> 
 <p><strong>提示：参阅具体的DBMS文档 </strong></p> 
 <p>上面的规则不少，而具体的DBMS文档很可能还包含别的规则。因此，在创建视图前，有必要花点时间了解必须遵守的规定。</p> 
</blockquote> 
<h3 id="2%E3%80%81%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE">2、创建视图</h3> 
<p>理解了什么是视图以及管理它们的规则和约束后，我们来创建视图。 视图用CREATE VIEW语句来创建。与CREATE TABLE一样，CREATE VIEW只能用于创建不存在的视图。</p> 
<blockquote> 
 <p><strong>说明：视图重命名 </strong></p> 
 <p>删除视图，可以使用DROP语句，其语法为DROP VIEW viewname;。 覆盖（或更新）视图，必须先删除它，然后再重新创建。</p> 
</blockquote> 
<h4 id="2.1%E3%80%81%E5%88%A9%E7%94%A8%E8%A7%86%E5%9B%BE%E7%AE%80%E5%8C%96%E5%A4%8D%E6%9D%82%E7%9A%84%E8%81%94%E7%BB%93%C2%A0">2.1、利用视图简化复杂的联结 </h4> 
<p>一个最常见的视图应用是隐藏复杂的SQL，这通常涉及联结。请看下面的例子：</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">CREATE VIEW ProductCustomers 
AS 
SELECT cust_name, cust_contact, prod_id FROM 
Customers, Orders, OrderItems 
WHERE 
Customers.cust_id = Orders.cust_id  AND OrderItems.order_num = Orders.order_num; </code></pre> 
<p>这条语句创建一个名为ProductCustomers的视图，它联结三个表，返回已订购了任意产品的所有顾客的列表。如果执行SELECT * FROM ProductCustomers，将列出订购了任意产品的顾客。 检索订购了产品RGAN01的顾客，可如下进行：</p> 
<p><strong>输入：</strong></p> 
<pre><code class="language-sql">SELECT cust_name, cust_contact FROM ProductCustomers 
WHERE 
prod_id = 'RGAN01'; </code></pre> 
<p>这条语句通过WHERE子句从视图中检索特定数据。当DBMS处理此查询时，它将指定的WHERE子句添加到视图查询中已有的WHERE子句中，以便正确过滤数据。</p> 
<p>可以看出，视图极大地简化了复杂SQL语句的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。</p> 
<blockquote> 
 <p><strong>提示：创建可重用的视图 </strong></p> 
 <p>创建不绑定特定数据的视图是一种好办法。例如，上面创建的视图返回订购所有产品而不仅仅是RGAN01的顾客（这个视图先创建）。扩展视图的范围不仅使得它能被重用，而且可能更有用。这样做不需要创建和维护多个类似视图。</p> 
</blockquote> 
<h4 id="2.2%E3%80%81%E7%94%A8%E8%A7%86%E5%9B%BE%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A3%80%E7%B4%A2%E5%87%BA%E7%9A%84%E6%95%B0%E6%8D%AE"><strong>2.2、用视图重新格式化检索出的数据</strong></h4> 
<p>视图的另一常见用途是重新格式化检索出的数据。下面的SELECT语句在单个组合计算列中返回供应商名和位置：</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')'  AS vend_title 
FROM Vendors 
ORDER BY vend_name; </code></pre> 
<p>下面是相同的语句，但使用了||语法</p> 
<p><strong>输入：</strong></p> 
<pre><code class="language-sql">SELECT RTRIM(vend_name) || ' (' || RTRIM(vend_country) || ')'  AS vend_title 
FROM Vendors 
ORDER BY vend_name; </code></pre> 
<p>现在，假设经常需要这个格式的结果。我们不必在每次需要时执行这种拼接，而是创建一个视图，使用它即可。把此语句转换为视图，可按如下进行：</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">CREATE VIEW VendorLocations AS 
SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')'  AS vend_title 
FROM Vendors; </code></pre> 
<p>这条语句使用与以前SELECT语句相同的查询创建视图。要检索数据，创建所有的邮件标签，可如下进行：</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">SELECT * FROM VendorLocations; </code></pre> 
<blockquote> 
 <p><strong>说明：SELECT约束全部适用</strong></p> 
 <p>在这一课的前面提到，各种DBMS中用来创建视图的语法相当一致。那么，为什么会有多种创建视图的语句版本呢？因为视图只包含一个SELECT语句，而这个语句的语法必须遵循具体DBMS的所有规则和约束，所以会有多个创建视图的语句版本。</p> 
</blockquote> 
<h4 id="2.3%E3%80%81%E7%94%A8%E8%A7%86%E5%9B%BE%E8%BF%87%E6%BB%A4%E4%B8%8D%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE">2.3、用视图过滤不想要的数据</h4> 
<p>视图对于应用普通的WHERE子句也很有用。例如，可以定义CustomerEMailList视图，过滤没有电子邮件地址的顾客。为此，可使用下面的语句：</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">CREATE VIEW CustomerEMailList AS SELECT cust_id, cust_name, cust_email 
FROM Customers 
WHERE cust_email IS NOT NULL; </code></pre> 
<p>显然，在将电子邮件发送到邮件列表时，需要排除没有电子邮件地址的用户。这里的WHERE子句过滤了cust_email列中具有NULL值的那些行，使它们不被检索出来。 现在，可以像使用其他表一样使用视图CustomerEMailList。</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">SELECT * FROM CustomerEMailList; </code></pre> 
<blockquote> 
 <p><strong>说明：WHERE子句与WHERE子句 </strong></p> 
 <p>从视图检索数据时如果使用了一条WHERE子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p> 
</blockquote> 
<h4 id="2.4%E3%80%81%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE%E4%B8%8E%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5">2.4、使用视图与计算字段</h4> 
<p>在简化计算字段的使用上，视图也特别有用。、它检索某个订单中的物品，计算每种物品的总价格：</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">SELECT prod_id,  quantity,  item_price,  quantity*item_price AS expanded_price 
FROM OrderItems WHERE order_num = 20008; </code></pre> 
<p>要将其转换为一个视图，如下进行：</p> 
<p><strong>输入:</strong></p> 
<pre><code class="language-sql">CREATE VIEW OrderItemsExpanded
AS SELECT order_num,  prod_id,  quantity, item_price,  quantity*item_price AS expanded_price 
FROM OrderItems; </code></pre> 
<p>检索订单20008的详细内容（上面的输出），如下进行：</p> 
<pre><code class="language-sql">SELECT * FROM OrderItemsExpanded WHERE order_num = 20008; </code></pre> 
<p>可以看到，视图非常容易创建，而且很好使用。正确使用，视图可极大地简化复杂数据的处理。</p> 
<p>视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可用来简化数据处理，重新格式化或保护基础数据。 </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/464f7c4122978d9818a2699705170468/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue报错——[vue/require-v-for-key]Elements in iteration expect to have ‘v-bind:key‘ directives.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/41c87d45cf86f5a286d859a73b06a46f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Latex中嵌入bib参考文件，完整使用bib的方法听语音</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>