<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>poj 1061 青蛙的约会&#43;拓展欧几里得&#43;题解 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="poj 1061 青蛙的约会&#43;拓展欧几里得&#43;题解" />
<meta property="og:description" content="青蛙的约会&#43;拓展欧几里得&#43;题解 纵有疾风起
题意 两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。
我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。
输入
输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt; 2100000000。
输出
输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行&#34;Impossible&#34;
前话-拓展欧几里得（下方高能！！！） 扩展欧几里德算法是用来在已知a, b求解一组整数解x，y，使它们满足贝祖等式（具体不是很清楚是啥意思，反正就那样）： \(ax&#43;by = gcd(a, b) =d\)（解一定存在，根据数论中的相关定理）。扩展欧几里德常用在求解模线性方程及方程组中。
对于普通的公式\(ax&#43;by = c\)有整数解的条件是\(c=k*gcd(a, b)\)，k为任意常数。
对于公式\(ax&#43;by = gcd(a, b) =d\)，求解其中一个x，y的方法及其证明
显然当 \(b=0,gcd(a,b)=a\)时，此时 \(x=1, y=0\)；
\(a&gt;b&gt;0\) 时，设 \(ax_1&#43; by_1= gcd(a,b)\);
\(bx_2&#43; (a\ mod\ b)*y_2= gcd(b,\ a\ mod\ b)\);
根据朴素的欧几里德原理有 \(gcd(a,b) = gcd(b,a\ mod\ b)\);
则:\(ax_1&#43; by_1= bx_2&#43; (a\ mod\ b)y_2\);
即:\(ax_1&#43; by_1= bx_2&#43; (a - [a / b] * b)y_2=ay_2&#43; bx_2- [a / b] * by_2\)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/724eb45b573f16e6448de17e71398950/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-23T10:20:00+08:00" />
<meta property="article:modified_time" content="2019-07-23T10:20:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">poj 1061 青蛙的约会&#43;拓展欧几里得&#43;题解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown"> 
 <h2 id="青蛙的约会拓展欧几里得题解">青蛙的约会+拓展欧几里得+题解</h2> 
 <blockquote> 
  <p>纵有疾风起</p> 
 </blockquote> 
 <h3 id="题意">题意</h3> 
 <blockquote> 
  <p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。<br> 我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。</p> 
  <p><strong>输入</strong></p> 
  <p>输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt; 2100000000。</p> 
  <p><strong>输出</strong></p> 
  <p>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行"Impossible"</p> 
 </blockquote> 
 <h3 id="前话-拓展欧几里得下方高能">前话-拓展欧几里得（下方高能！！！）</h3> 
 <blockquote> 
  <p>扩展欧几里德算法是用来在已知a, b求解一组整数解x，y，使它们满足贝祖等式（具体不是很清楚是啥意思，反正就那样）： <span class="math inline">\(ax+by = gcd(a, b) =d\)</span>（解一定存在，根据数论中的相关定理）。扩展欧几里德常用在求解模线性方程及方程组中。</p> 
  <ul><li><p>对于普通的公式<span class="math inline">\(ax+by = c\)</span>有整数解的条件是<span class="math inline">\(c=k*gcd(a, b)\)</span>，k为任意常数。</p></li><li><p>对于公式<span class="math inline">\(ax+by = gcd(a, b) =d\)</span>，求解其中一个x，y的方法及其证明</p> 
    <ol><li><p>显然当 <span class="math inline">\(b=0,gcd(a,b)=a\)</span>时，此时 <span class="math inline">\(x=1, y=0\)</span>；</p></li><li><p><span class="math inline">\(a&gt;b&gt;0\)</span> 时，设 <span class="math inline">\(ax_1+ by_1= gcd(a,b)\)</span>;</p> <p><span class="math inline">\(bx_2+ (a\ mod\ b)*y_2= gcd(b,\ a\ mod\ b)\)</span>;</p> <p>根据朴素的欧几里德原理有 <span class="math inline">\(gcd(a,b) = gcd(b,a\ mod\ b)\)</span>;</p> <p>则:<span class="math inline">\(ax_1+ by_1= bx_2+ (a\ mod\ b)y_2\)</span>;</p> <p>即:<span class="math inline">\(ax_1+ by_1= bx_2+ (a - [a / b] * b)y_2=ay_2+ bx_2- [a / b] * by_2\)</span>。</p> <p><strong><em>说明： <span class="math inline">\(a-[a/b]b\)</span>即为mod运算。<span class="math inline">\([a/b]\)</span>代表取小于<span class="math inline">\(a/b\)</span>的最大整数，下面同样适用。</em></strong></p> <p>也就是<span class="math inline">\(ax_1+ by_1 == ay_2+ b(x_2- [a / b] *y_2)\)</span>;</p> <p>根据恒等定理，对应项的系数相等得：</p> <p><strong><span class="math inline">\(x_1=y_2\)</span></strong>; <strong><span class="math inline">\(y_1=x_2- [a / b] *y_2\)</span></strong>;</p> <p>这样我们就得到了求解 <span class="math inline">\(x_1,y_1\)</span> 的方法：<span class="math inline">\(，x_1，y_1\)</span> 的值基于<span class="math inline">\(， x_2，y_2\)</span>。使用递归的话，上一层的值，取决于下一层。</p> <p>上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。</p> <p>递归边界：<span class="math inline">\(（）gcd（a,\ 0）=1*a-0*0=a\)</span>。</p></li></ol></li><li><p>对于公式<span class="math inline">\(ax+by = c\)</span>，求解x，和y的方法</p> 
    <ol><li>如果<span class="math inline">\(c\ \%\ gcd( a , b) != 0\)</span>，即c不是gcd的整数倍，则无解。</li><li>如果<span class="math inline">\(c\ \%\ gcd(a,b) == 0\)</span> ，则<span class="math inline">\(c\ /\ gcd(a,b) = t\)</span>，那么求出方程 <span class="math inline">\(a * x + b * y = gcd(a,b)\)</span>的所有解x,y，将x,y乘上t，对应的x’,y’即是方程<span class="math inline">\(a * x + b * y = t * gcd(a,b)\)</span>的一个解</li></ol></li><li><p>如何求<span class="math inline">\(ax+by = gcd(a, b) =d\)</span>最小整数解，<em>对于<span class="math inline">\(ax+by = c\)</span>，c为常数，也适用。</em></p> 
    <ol><li>我们可以用扩展欧几里得算法得出</li></ol><p><span class="math display">\[ ax+by=gcd(a,b) \]</span></p> <p>​ 的一组解<span class="math inline">\(（x_1,\ y_1）\)</span>，那么其他解呢？任取另一组解<span class="math inline">\(（x_2,\ y_2）\)</span>,则<br><span class="math display">\[ ax_1+by_1=ax_2+by_2 \]</span><br> ​ （因为它们都等于<span class="math inline">\(gcd(a,b)\)</span> ），变形得<br><span class="math display">\[ a(x_1-x_2)=b(y_2-y_1) \]</span><br> ​ 假设<span class="math inline">\(gcd(a,\ b)=g\)</span>，方程左右两边同时除以g（如果g=0，说明a或b等于0，可以特殊判断），得<br><span class="math display">\[ a'(x_1-x_2)=b'(y_2-y_1) \]</span><br> ​ 其中<span class="math inline">\(，a'=a/g，b'=b/g\)</span>。</p> <p>​ 注意，此时a'和b'互素（想想分数的化简）<br><span class="math display">\[ x_1-x_2=\frac{b'}{a'}*(y_2-y_1) \]</span><br> ​ 则因此<span class="math inline">\(x_1-x_2\)</span>一定是b'的整数倍（因为a'中不包含b'，所以<span class="math inline">\(x_1-x_2\)</span>一定包含b'）。</p> <p>​ 设它为<span class="math inline">\(x_1-x_2=k*b'\)</span>，计算得<span class="math inline">\(y_2-y_1=k*a'\)</span>。注意，上述的推导过程并没有用到<span class="math inline">\(ax+by\)</span>的右边是什 么，因此得出以下结论：</p> <p>​ 设a,b,c为任意整数，若方程<span class="math inline">\(ax+by=c\)</span>的一组解是<span class="math inline">\((x_0,y_0)\)</span>，则它的任意整数解都可以写</p> <p>​ <span class="math inline">\((x_0+k*b',y_0-k*a')\)</span>，其中<span class="math inline">\(a'=[a/gcd(a,b)]\)</span>，<span class="math inline">\(b'=[b/gcd(a,b)]\)</span>，<strong>k取任意整数</strong>。</p> <p>​ 这样我们就可以求出来最小的整数解了。（先用扩展欧几里得算法求出一组解，然后进行变换）</p></li></ul> 
 </blockquote> 
 <h3 id="解题思路">解题思路</h3> 
 <p>根据题意，两只青蛙需要在同一时间到达用一个点上才算相遇，易得(设t就是所求的答案)<br><span class="math display">\[ (m*t+x)\%L=(n*t+y)\%L \]</span><br> 因为<span class="math inline">\((m*t+x)=w*L+v\)</span>，<span class="math inline">\((n*t+y)=s*L+v\)</span></p> 
 <p>两边相减得<br><span class="math display">\[ (n-m)*t+(w-s)*L=x-y \]</span><br> 令<span class="math inline">\(a=n-m\)</span>，<span class="math inline">\(b=L\)</span>，<span class="math inline">\(c=x-y\)</span>， <span class="math inline">\(X=t\)</span>， <span class="math inline">\(Y=w-s\)</span></p> 
 <p>然后就是拓展欧几里得的处理了</p> 
 <h3 id="代码">代码</h3> 
 <pre><code class="language-cpp"><code>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include&lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long ll;

void extended_gcd(ll a,ll b,ll &amp;x,ll &amp;y) //注意参数，后两个是c++里面的引用
{
    ll r,t;
    if(b==0)
    {
        x=1;
        y=0;
        return ;
    }
    extended_gcd(b,a%b,x,y);
    t=x;
    x=y;
    y=t-a/b*y;
}
int main()
{
    ll x,y,m,n,L,g,c,a,b;
    scanf("%lld%lld%lld%lld%lld", &amp;x, &amp;y, &amp;m, &amp;n, &amp;L);
    a=n-m;
    c=x-y;
    b=L;
    g=__gcd(a, b);
    if(c%g!=0)
        printf("Impossible\n");
    else
    {
        extended_gcd(a,b,x,y);
        x=x*c/g;
        ll t=b/g;
        if(x&gt;=0) //如果最初求的解大于零，后面就直接模b/g就行
            x=x%t;
        else
            x=x%t+t;//如果小于零，就先模，然后加上b/g后就一定大于0了
        printf("%lld\n",x);
    }
    return 0;
}</code></code></pre> 
 <h3 id="end">END</h3> 
</div> 
<p>转载于:https://www.cnblogs.com/alking1001/p/11230134.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8eaa7adf251c8da5724f061529bd747/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Program type already present</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/15df26f8550bd13d2139d17636371fb3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tftp命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>