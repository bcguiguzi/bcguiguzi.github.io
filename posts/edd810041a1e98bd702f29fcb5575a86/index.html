<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>wpf自定义控件之依赖属性 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="wpf自定义控件之依赖属性" />
<meta property="og:description" content="这篇文章的意义是，为wpf自定义控件，定义它的专属属性，这个属性不仅仅可以在c#中使用，也可以在xaml中使用，在xaml中赋值或者绑定。
在wpf开发过程中，总会用到格式各样的控件，但是原生控件远远不能满足实际开发的需要，这时候wpf强大之处就能体现出来了。根据实际需求自定义各种不同的控件满足不同的业务需求。
首先说需求吧：
一：根据某个绑定的int值，控制一个圆形控件显示或者不显示某种颜色。
分析：
一：需求就一句话，但是根据这一句话，就能得到一些必要的信息。
1.控件绑定的值是个int型。
2.圆形控件。
3.根据传进来的int值做逻辑处理。
分析完需求之后就要开始思考怎么实现了，仔细想想，其实wpf中的Ellipse控件可以画出带颜色的圆形，问题就在于如何根据绑定的值显示某种颜色。
如果对代码要求不高，没什么复用性要求的话，可以直接写在xaml对应的.cs文件中，按照bool值来给控件赋值颜色，但是如果对这个圆形复用性很高，或者代码分离，不允许在.cs文件中写代码，那就只能想其他办法了。
啰嗦到现在，实现这个控件有三个方式：1.写在xaml对应的.cs中。2.写一个convert类来转换。3.自定义一个圆形控件。
本文着重说一下自定义圆形控件，另外两种方式不赘述。
实现：
一.新建wpf引用程序，名为LedTest,新建一个名为LED的用户控件，用来写自定义的控件，项目结构为下图：
二.在用户控件中的界面上先画好带颜色的圆形：
三.重头戏来了，接下来就是依赖属性了。
首先，什么是依赖属性？为什么要用依赖属性？
完整的依赖属性解释百度上有，我就说一下我的理解：依赖属性是wpf提供的一种为丰富控件属性，使依赖属性可以依赖于控件绑定的值，并可以对这些值进行一些逻辑处理的东西。
了解了什么是依赖属性后就知道了为什么要用依赖属性，因为依赖属性能够拓展控件的属性，譬如给button增加一个新的属性，使button绑定值的时候能达到某种效果。
废话不说了，直接上代码：
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Shapes;
namespace LedTest
{
/// &lt;summary&gt;
/// LED.xaml 的交互逻辑
/// &lt;/summary&gt;
public partial class LED : UserControl
{
/// &lt;summary&gt;
/// 构造函数
/// &lt;/summary&gt;
public LED()
{
InitializeComponent();
}
/// &lt;summary&gt;
/// 定义属性
/// &lt;/summary&gt;
public int Colors
{
get { return (int)GetValue(ColorsProperty); }" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/edd810041a1e98bd702f29fcb5575a86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-25T08:59:20+08:00" />
<meta property="article:modified_time" content="2020-08-25T08:59:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">wpf自定义控件之依赖属性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这篇文章的意义是，为wpf自定义控件，定义它的专属属性，这个属性不仅仅可以在c#中使用，也可以在xaml中使用，在xaml中赋值或者绑定。</p> 
<p> </p> 
<p>在wpf开发过程中，总会用到格式各样的控件，但是原生控件远远不能满足实际开发的需要，这时候wpf强大之处就能体现出来了。根据实际需求自定义各种不同的控件满足不同的业务需求。</p> 
<p>首先说需求吧：</p> 
<p>一：根据某个绑定的int值，控制一个圆形控件显示或者不显示某种颜色。</p> 
<p>分析：</p> 
<p>一：需求就一句话，但是根据这一句话，就能得到一些必要的信息。</p> 
<p>　　1.控件绑定的值是个int型。</p> 
<p>　　2.圆形控件。</p> 
<p>　　3.根据传进来的int值做逻辑处理。</p> 
<p>分析完需求之后就要开始思考怎么实现了，仔细想想，其实wpf中的Ellipse控件可以画出带颜色的圆形，问题就在于如何根据绑定的值显示某种颜色。</p> 
<p>如果对代码要求不高，没什么复用性要求的话，可以直接写在xaml对应的.cs文件中，按照bool值来给控件赋值颜色，但是如果对这个圆形复用性很高，或者代码分离，不允许在.cs文件中写代码，那就只能想其他办法了。</p> 
<p>啰嗦到现在，实现这个控件有三个方式：1.写在xaml对应的.cs中。2.写一个convert类来转换。3.自定义一个圆形控件。</p> 
<p>本文着重说一下自定义圆形控件，另外两种方式不赘述。</p> 
<p>实现：</p> 
<p>一.新建wpf引用程序，名为LedTest,新建一个名为LED的用户控件，用来写自定义的控件，项目结构为下图：</p> 
<p><img alt="" src="https://images2.imgbox.com/5c/7e/SWCPlNGJ_o.png"></p> 
<p>二.在用户控件中的界面上先画好带颜色的圆形：</p> 
<p><img alt="" src="https://images2.imgbox.com/5f/32/HLHtphh9_o.png"></p> 
<p>三.重头戏来了，接下来就是依赖属性了。</p> 
<p>首先，什么是依赖属性？为什么要用依赖属性？</p> 
<p>完整的依赖属性解释百度上有，我就说一下我的理解：依赖属性是wpf提供的一种为丰富控件属性，使依赖属性可以依赖于控件绑定的值，并可以对这些值进行一些逻辑处理的东西。</p> 
<p>了解了什么是依赖属性后就知道了为什么要用依赖属性，因为依赖属性能够拓展控件的属性，譬如给button增加一个新的属性，使button绑定值的时候能达到某种效果。</p> 
<p>废话不说了，直接上代码：</p> 
<p><img alt="" src="https://images2.imgbox.com/4b/a7/pdLyd1N8_o.png"></p> 
<p> </p> 
<p> </p> 
<p>using System.Windows;<br> using System.Windows.Controls;<br> using System.Windows.Media;<br> using System.Windows.Shapes;</p> 
<p>namespace LedTest<br> {<!-- --><br> /// &lt;summary&gt;<br> /// LED.xaml 的交互逻辑<br> /// &lt;/summary&gt;<br> public partial class LED : UserControl<br> {<!-- --><br> /// &lt;summary&gt;<br> /// 构造函数<br> /// &lt;/summary&gt;<br> public LED()<br> {<!-- --><br> InitializeComponent();<br> }<br> /// &lt;summary&gt;<br> /// 定义属性<br> /// &lt;/summary&gt;<br> public int Colors<br> {<!-- --><br> get { return (int)GetValue(ColorsProperty); }<br> set { SetValue(ColorsProperty, value); }<br> }</p> 
<p>// Using a DependencyProperty as the backing store for Colors. This enables animation, styling, binding, etc...<br> /// &lt;summary&gt;<br> /// 依赖属性注册<br> /// 参数1:Colors，标定了控件中的属性名<br> /// 参数2：typeof(int),确定了参数1的值类型<br> /// 参数3：typeof(LED)，指定了参数作用的域/界面<br> /// 参数4：new UIPropertyMetadata(1, ChangeColor)，1是指定了参数1的默认值（默认值的设定根据需要自己确定），<br> /// ChangeColor为回调函数，根据界面绑定的值执行某些逻辑处理<br> /// &lt;/summary&gt;<br> public static readonly DependencyProperty ColorsProperty =<br> DependencyProperty.Register("Colors", typeof(int), typeof(LED), new UIPropertyMetadata(1, ChangeColor));</p> 
<p>//ps：Register方法有几个不同的重载，可不要回调函数</p> 
<p>/// &lt;summary&gt;<br> /// 回调函数，根据绑定的值做逻辑处理<br> /// &lt;/summary&gt;<br> /// &lt;param name="obj"&gt;&lt;/param&gt;<br> /// &lt;param name="r"&gt;&lt;/param&gt;<br> private static void ChangeColor(DependencyObject obj, DependencyPropertyChangedEventArgs r)<br> {<!-- --><br> LED led = (LED)obj;<br> Ellipse ellipse = led.LedControl;<br> if (r.NewValue.Equals(0))<br> {<!-- --><br> ellipse.Fill = new SolidColorBrush(System.Windows.Media.Colors.Gray);<br> }<br> }</p> 
<p><br> }<br> }</p> 
<p>至此，这个圆形的控件就算封装好了，接下来就算在界面上使用了。</p> 
<p>四.主界面使用自定义的控件</p> 
<p>控件封装好，用就简单了，下面就是用法。</p> 
<p><img alt="" src="https://images2.imgbox.com/df/6b/eeVKa1aN_o.png"></p> 
<p> </p> 
<p> 五.到这里呢，自定义控件、依赖属性注册就结束了。本例子非常非常的基础，仅仅适合不了解wpf自定义控件的伙伴属性代码用。需用自取，无用不喷。谢谢</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d68cb2841989e9601085458e8c1d7c92/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;11新增类型转换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2d5aa87ca7e476052bdfe9b6d8acb0d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PE Tools</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>