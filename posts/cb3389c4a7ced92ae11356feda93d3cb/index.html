<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;八股文 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;八股文" />
<meta property="og:description" content="游戏客户端开发常见八股文 c&#43;&#43;篇
文章目录 游戏客户端开发常见八股文前言一、C&#43;&#43;内存管理常考察点1. C&#43;&#43;的构造函数，复制构造函数，和析构函数2. 什么是深复制和浅复制3.构造函数和析构函数哪个能写成虚函数，为什么4.C&#43;&#43;数组，链表，二叉树的内存排列是什么样的5.结构体占多大内存如何计算，类占用多大空间如何计算，空类的空间是多少，为什么5.虚函数和虚表的原理是什么（重点）6.内存泄漏出现的时机和原因，如何避免7.指针的工作原理8.函数的传值和传址9.new和delete使用解释一下，和malloc和free的区别10.C&#43;&#43;内存区域划如何分说一下（栈，堆那些） 二、C&#43;&#43;11 新特性1.常见的c&#43;&#43;11新特性有哪些2.智能指针用过吗，有哪些，他们的区别和各自的优缺点3.auto关键字知道吗，如果全部都用auto声明变量行不行4.lambda表达式会用吗5.override关键字必须吗6.右值引用 总结 前言 看到了一些关于游戏开发c&#43;&#43;笔试、面试题，但是有题目没有答案，作为一个只会一点点c&#43;&#43;的小菜鸡就记录一下，以下问题答案都是chatGPT回答以及百度答案
面试问题来源：游戏开发岗面试总结
一、C&#43;&#43;内存管理常考察点 1. C&#43;&#43;的构造函数，复制构造函数，和析构函数 构造函数（Constructor）：C&#43;&#43;中的构造函数用于初始化对象的数据成员。构造函数的名称与类名相同，没有返回类型，包括参数列表和函数体。构造函数在创建对象时自动调用，并且可以重载，即可以有多个构造函数。
复制构造函数（Copy Constructor）：复制构造函数用于通过已有对象创建一个新对象。复制构造函数的参数是一个同类的对象引用，它用于初始化新对象的数据成员。如果没有显式定义复制构造函数，C&#43;&#43;会自动生成一个默认的复制构造函数。复制构造函数通常使用深拷贝（deep copy）来避免浅拷贝（shallow copy）带来的问题。
析构函数（Destructor）：析构函数用于在对象销毁时释放资源和做一些清理工作。析构函数的名称与类名相同，前面加上一个波浪号(~)作为前缀。析构函数没有返回类型，没有参数。当对象超出作用域、被删除或程序结束时，析构函数会被自动调用。如果没有显式定义析构函数，C&#43;&#43;会自动生成一个默认的析构函数。
代码如下（示例）：
#include &lt;iostream&gt; class MyClass { public: // 默认构造函数 MyClass() { std::cout &lt;&lt; &#34;Default constructor called&#34; &lt;&lt; std::endl; } // 带参数的构造函数 MyClass(int value) { std::cout &lt;&lt; &#34;Parameterized constructor called with value: &#34; &lt;&lt; value &lt;&lt; std::endl; } // 复制构造函数 MyClass(const MyClass&amp; other) { std::cout &lt;&lt; &#34;Copy constructor called&#34; &lt;&lt; std::endl; } // 析构函数 ~MyClass() { std::cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/cb3389c4a7ced92ae11356feda93d3cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-22T09:33:35+08:00" />
<meta property="article:modified_time" content="2023-09-22T09:33:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;八股文</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>游戏客户端开发常见八股文</h2> 
<p>c++篇</p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_0" rel="nofollow">游戏客户端开发常见八股文</a></li><li><a href="#_11" rel="nofollow">前言</a></li><li><a href="#C_18" rel="nofollow">一、C++内存管理常考察点</a></li><li><ul><li><a href="#1_C_22" rel="nofollow">1. C++的构造函数，复制构造函数，和析构函数</a></li><li><a href="#2__81" rel="nofollow">2. 什么是深复制和浅复制</a></li><li><a href="#3_88" rel="nofollow">3.构造函数和析构函数哪个能写成虚函数，为什么</a></li><li><a href="#4C_95" rel="nofollow">4.C++数组，链表，二叉树的内存排列是什么样的</a></li><li><a href="#5_103" rel="nofollow">5.结构体占多大内存如何计算，类占用多大空间如何计算，空类的空间是多少，为什么</a></li><li><a href="#5_132" rel="nofollow">5.虚函数和虚表的原理是什么（重点）</a></li><li><a href="#6_141" rel="nofollow">6.内存泄漏出现的时机和原因，如何避免</a></li><li><a href="#7_155" rel="nofollow">7.指针的工作原理</a></li><li><a href="#8_164" rel="nofollow">8.函数的传值和传址</a></li><li><a href="#9newdeletemallocfree_173" rel="nofollow">9.new和delete使用解释一下，和malloc和free的区别</a></li><li><a href="#10C_202" rel="nofollow">10.C++内存区域划如何分说一下（栈，堆那些）</a></li></ul> 
  </li><li><a href="#C11__222" rel="nofollow">二、C++11 新特性</a></li><li><ul><li><a href="#1c11_223" rel="nofollow">1.常见的c++11新特性有哪些</a></li><li><a href="#2_351" rel="nofollow">2.智能指针用过吗，有哪些，他们的区别和各自的优缺点</a></li><li><a href="#3autoauto_396" rel="nofollow">3.auto关键字知道吗，如果全部都用auto声明变量行不行</a></li><li><a href="#4lambda_407" rel="nofollow">4.lambda表达式会用吗</a></li><li><a href="#5override_430" rel="nofollow">5.override关键字必须吗</a></li><li><a href="#6_447" rel="nofollow">6.右值引用</a></li></ul> 
  </li><li><a href="#_483" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_11"></a>前言</h2> 
<p>看到了一些关于游戏开发c++笔试、面试题，但是有题目没有答案，作为一个只会一点点c++的小菜鸡就记录一下，以下问题答案都是chatGPT回答以及百度答案<br> 面试问题来源：<a href="https://zhuanlan.zhihu.com/p/157355850" rel="nofollow">游戏开发岗面试总结</a></p> 
<hr> 
<h2><a id="C_18"></a>一、C++内存管理常考察点</h2> 
<h3><a id="1_C_22"></a>1. C++的构造函数，复制构造函数，和析构函数</h3> 
<ul><li> <p>构造函数（Constructor）：C++中的构造函数用于初始化对象的数据成员。构造函数的名称与类名相同，没有返回类型，包括参数列表和函数体。构造函数在创建对象时自动调用，并且可以重载，即可以有多个构造函数。</p> </li><li> <p>复制构造函数（Copy Constructor）：复制构造函数用于通过已有对象创建一个新对象。复制构造函数的参数是一个同类的对象引用，它用于初始化新对象的数据成员。如果没有显式定义复制构造函数，C++会自动生成一个默认的复制构造函数。复制构造函数通常使用深拷贝（deep copy）来避免浅拷贝（shallow copy）带来的问题。</p> </li><li> <p>析构函数（Destructor）：析构函数用于在对象销毁时释放资源和做一些清理工作。析构函数的名称与类名相同，前面加上一个波浪号(~)作为前缀。析构函数没有返回类型，没有参数。当对象超出作用域、被删除或程序结束时，析构函数会被自动调用。如果没有显式定义析构函数，C++会自动生成一个默认的析构函数。</p> </li></ul> 
<blockquote> 
 <p>代码如下（示例）：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 默认构造函数</span>
    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Default constructor called"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 带参数的构造函数</span>
    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Parameterized constructor called with value: "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 复制构造函数</span>
    <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Copy constructor called"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 析构函数</span>
    <span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Destructor called"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    MyClass obj1<span class="token punctuation">;</span> <span class="token comment">// 调用默认构造函数</span>
    MyClass <span class="token function">obj2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用带参数的构造函数</span>
    MyClass obj3 <span class="token operator">=</span> obj1<span class="token punctuation">;</span> <span class="token comment">// 调用复制构造函数</span>
    obj3 <span class="token operator">=</span> obj2<span class="token punctuation">;</span> <span class="token comment">// 调用赋值运算符（非复制构造函数）</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>输出结果：</p> 
</blockquote> 
<pre><code class="prism language-cpp">Default constructor called
Parameterized constructor called with value<span class="token operator">:</span> <span class="token number">10</span>
Copy constructor called
Destructor called
Destructor called
Destructor called
</code></pre> 
<h3><a id="2__81"></a>2. 什么是深复制和浅复制</h3> 
<p>深复制（deep copy）和浅复制（shallow copy）是在编程中常用的两种对象复制方法。</p> 
<ul><li>浅复制是指创建一个新的对象，新对象的属性值与原对象相同，但对象内部的引用类型数据（如数组、对象等）仍然指向原对象的引用。也就是说，浅复制只是复制了对象的引用，而不是实际的数据。因此，修改新对象的属性值可能会影响到原对象。</li><li>深复制是指创建一个全新的对象，新对象的属性值和原对象相同，但是对象内部的引用类型数据也会被复制，而不是简单的引用。这意味着，深复制创建的新对象是完全独立于原对象的，对新对象的修改不会影响原对象。</li></ul> 
<p>简而言之，浅复制只复制对象的引用，而深复制复制对象的内容。</p> 
<h3><a id="3_88"></a>3.构造函数和析构函数哪个能写成虚函数，为什么</h3> 
<p>析构函数可以被写成虚函数，而构造函数不能被写成虚函数。</p> 
<ul><li>虚函数是用于实现多态的概念，能够在运行时根据对象的实际类型来确定调用的方法。而构造函数在对象创建时被调用，此时对象的实际类型还不确定，因此无法使用虚函数。</li><li>析构函数是用于释放对象占用的资源，包括内存、文件句柄等。在继承关系中，当基类指针指向派生类对象时，如果析构函数不是虚函数，那么在调用delete操作时只会调用基类的析构函数，而不会调用派生类的析构函数。这会导致派生类对象中的资源无法被正确释放，可能会造成内存泄漏等问题。因此，为了确保派生类对象的析构函数能够正确调用，通常会将基类的析构函数声明为虚函数。</li></ul> 
<p>总结：由于构造函数在对象创建时被调用，对象的实际类型还不确定，无法使用虚函数；而析构函数在对象销毁时被调用，对象的实际类型已经确定，可以使用虚函数实现多态。</p> 
<h3><a id="4C_95"></a>4.C++数组，链表，二叉树的内存排列是什么样的</h3> 
<ul><li> <p>数组的内存排列是连续的，即所有元素在内存中是相邻存储的。</p> </li><li> <p>链表的内存排列是非连续的，每个节点包含数据和指向下一个节点的指针，节点在内存中可以分布在不同的位置。</p> </li><li> <p>二叉树的内存排列是通过指针链接的，每个节点包含数据以及指向左右子节点的指针。</p> </li></ul> 
<h3><a id="5_103"></a>5.结构体占多大内存如何计算，类占用多大空间如何计算，空类的空间是多少，为什么</h3> 
<ol><li>结构体的大小是由其成员变量的大小之和决定的，可以使用sizeof运算符来计算结构体的大小。</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> y<span class="token punctuation">;</span>		<span class="token comment">//char类型，1字节</span>
	<span class="token keyword">char</span><span class="token operator">*</span> z<span class="token punctuation">;</span>	<span class="token comment">//指针类型，在 32 位系统上为 4 字节，在 64 位系统上为 8 字节</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>		<span class="token comment">//int类型，4字节</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> 

因此，整个结构体 A 的大小为 <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">9</span> 字节。但是，由于内存对齐的原因，编译器会将结构体的大小调整为 <span class="token number">12</span> 字节，以确保每个成员的地址都能够对齐到合适的内存边界。
这里是假设在<span class="token number">32</span>位系统上，所以为<span class="token keyword">char</span><span class="token operator">*</span> z为<span class="token number">4</span>字节，取所有成员变量中占内存最大的计算偏移量
<span class="token keyword">char</span><span class="token operator">*</span>（<span class="token number">4</span>字节）<span class="token operator">==</span> <span class="token keyword">int</span>（<span class="token number">4</span>字节），所以偏移量为<span class="token number">4</span>
所以
<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">char</span> y<span class="token punctuation">;</span>		<span class="token comment">//偏移量：0</span>
	<span class="token keyword">char</span><span class="token operator">*</span> z<span class="token punctuation">;</span>	<span class="token comment">//偏移量：4</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>		<span class="token comment">//偏移量：8</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
结构体大小 <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">8</span>
因此，输出语句 cout<span class="token operator">&lt;&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> 将会输出 <span class="token number">12</span>。
</code></pre> 
<p><a href="https://blog.csdn.net/weixin_37864269/article/details/91384850">不同类型变量对应的字节数</a></p> 
<ol start="2"><li>类的大小也是由其成员变量的大小之和决定的，可以使用sizeof运算符来计算类的大小。和结构体一样，类的大小可能会受到内存对齐的影响。</li><li>空类的大小为1字节。这是因为C++要保证每个对象在内存中都有一个独一无二的地址，即使是空类也需要占用一个字节的空间。这样做的目的是为了确保每个对象在内存中的地址都是唯一的，以便于区分不同的对象。</li></ol> 
<h3><a id="5_132"></a>5.虚函数和虚表的原理是什么（重点）</h3> 
<p>虚函数的原理是通过虚函数表（vtable）来实现的。</p> 
<ul><li>当一个类中声明了虚函数时，编译器会为该类生成一个虚函数表（vtable），其中存储了虚函数的地址。每个对象都会有一个指向虚函数表的指针，被称为虚函数表指针（vptr）。</li><li>当通过基类指针或引用调用虚函数时，实际上会通过对象的虚函数表指针找到对应的虚函数表，然后再根据函数的索引（偏移量）找到具体的虚函数地址，最终执行相应的函数。</li><li>这种机制实现了动态绑定的多态性，即在运行时根据对象的实际类型来确定调用的虚函数，而不是根据指针或引用的静态类型。</li><li>需要注意的是，虚函数表是每个类的独立的，因此每个类都有自己的虚函数表。当派生类覆盖了基类的虚函数时，派生类将会在自己的虚函数表中存储新的函数地址。这样，在通过派生类对象调用虚函数时，会根据派生类的虚函数表找到相应的函数地址。</li></ul> 
<p>总结：虚函数通过虚函数表和虚函数表指针实现动态绑定，能够在运行时根据对象的实际类型来确定调用的虚函数。</p> 
<h3><a id="6_141"></a>6.内存泄漏出现的时机和原因，如何避免</h3> 
<p>内存泄漏通常发生在动态分配内存后没有正确释放的情况下，导致程序无法再次访问和释放这块内存。内存泄漏的原因可能有以下几种：</p> 
<ol><li>忘记调用delete或free：在使用new、malloc等动态分配内存的时候，应该在不再使用该内存时调用对应的delete或free函数进行释放，如果忘记调用，就会导致内存泄漏。</li><li>异常抛出导致未释放：如果在动态分配内存后发生了异常，而没有在异常处理代码中进行释放，就会导致内存泄漏。</li><li>对象生命周期管理不当：如果对象的生命周期超出了其所分配的内存块的范围，就会导致内存泄漏。比如将对象的指针保存在容器中，但没有在合适的时机从容器中删除，就会导致内存泄漏。</li></ol> 
<p>为了避免内存泄漏，可以采取以下几种方法：</p> 
<ol><li>使用智能指针：C++11引入了std::shared_ptr和std::unique_ptr等智能指针，它们能够自动管理内存的释放，避免内存泄漏。</li><li>遵循资源获取即初始化（RAII）原则：通过在构造函数中申请资源，在析构函数中释放资源，可以确保在对象生命周期结束时自动释放内存。</li><li>注意异常安全性：在发生异常时，确保已经分配的资源能够正确释放，可以使用RAII技术或异常安全的编程范式来处理。</li><li>使用工具进行内存泄漏检测：可以使用一些专门的工具（如Valgrind、Dr. Memory等）来检测程序中的内存泄漏问题。</li></ol> 
<h3><a id="7_155"></a>7.指针的工作原理</h3> 
<p>指针是一个变量，其值为另一个变量的内存地址。在计算机中，每个变量都存储在内存中的某个位置，而指针则指向这个位置。通过指针，可以直接访问和修改存储在内存中的数据。</p> 
<p>指针的工作原理可以简单描述为以下几个步骤：</p> 
<ol><li>定义指针变量，并为其分配内存空间。</li><li>将要指向的变量的地址赋值给指针变量。</li><li>使用指针变量访问和修改指向的变量的值。</li></ol> 
<h3><a id="8_164"></a>8.函数的传值和传址</h3> 
<p>函数的参数传递方式有两种：传值和传址。</p> 
<ol><li>传值：传值是指将实际参数的值复制给形式参数，函数内部对形式参数的修改不会影响到实际参数。在函数调用时，会创建形式参数的副本，函数操作的是这个副本而不是原始数据。<br> 传值的优点是简单、安全，不会影响到原始数据，但如果参数较大，会占用较多的内存。</li><li>传址： 传址是指将实际参数的地址传递给形式参数，函数内部通过指针操作实际参数所在的内存地址，对形式参数的修改会影响到实际参数。<br> 传址的优点是可以节省内存，因为不需要创建副本，同时对形式参数的修改可以直接影响到实际参数，但需要注意指针的安全性，防止指针悬空或越界访问。</li></ol> 
<p>传值和传址的选择取决于具体的需求和情况。一般来说，对于简单的数据类型和较小的数据量，可以选择传值；而对于复杂的数据类型和较大的数据量，可以选择传址。</p> 
<h3><a id="9newdeletemallocfree_173"></a>9.new和delete使用解释一下，和malloc和free的区别</h3> 
<p>new和delete是C++中用于动态内存管理的操作符，用于在堆上分配和释放内存。</p> 
<ol><li>new：<br> new是C++中用于在堆上分配内存的操作符。它的基本语法是：<code>new 类型名</code> 或 <code>new 类型名[数组大小]</code>。</li></ol> 
<ul><li>对于单个对象的分配，new会返回分配的对象的指针。</li><li>对于数组的分配，new会返回数组的首元素的指针。</li></ul> 
<ol start="2"><li>delete：<br> delete是C++中用于释放通过new分配的内存的操作符。它的基本语法是：<code>delete 指针</code> 或 <code>delete[] 指针</code>。</li></ol> 
<ul><li>对于通过new分配的单个对象的内存，delete会释放该对象的内存。</li><li>对于通过new分配的数组的内存，delete会释放整个数组的内存。</li></ul> 
<p>与malloc和free的区别：<br> malloc和free是C语言中的函数，用于动态内存管理。与new和delete相比，它们有以下几个区别：</p> 
<ol><li>语法：</li></ol> 
<ul><li>malloc的语法是：<code>void* malloc(size_t size)</code>，返回一个void指针。</li><li>free的语法是：<code>void free(void* ptr)</code>，接受一个void指针作为参数。</li></ul> 
<ol start="2"><li>类型安全性：</li></ol> 
<ul><li>new和delete是C++的操作符，可以自动计算所需的内存大小，并在分配和释放内存时自动调用构造函数和析构函数。它们提供了更高的类型安全性。</li><li>malloc和free是C语言的函数，不会自动调用构造函数和析构函数，需要手动管理内存的分配和释放。对于复杂的对象，可能会导致内存泄漏或出现未定义的行为。</li></ul> 
<ol start="3"><li>内存分配方式：</li></ol> 
<ul><li>new和delete是基于C++的运算符重载实现的，它们会调用运算符重载的函数，使用操作符new和delete在堆上分配和释放内存。</li><li>malloc和free是C语言的函数，直接调用操作系统的内存分配函数，使用malloc和free在堆上分配和释放内存。</li></ul> 
<p>综上所述，new和delete是C++中用于动态内存管理的操作符，提供了更高的类型安全性和便利性；而malloc和free是C语言中的函数，需要手动管理内存的分配和释放。在C++中，推荐使用new和delete来进行动态内存的分配和释放。</p> 
<h3><a id="10C_202"></a>10.C++内存区域划如何分说一下（栈，堆那些）</h3> 
<p>C++程序在运行时使用的内存可以划分为以下几个区域：</p> 
<ol><li> <p>栈（Stack）：<br> 栈是用于存储局部变量、函数参数、函数返回地址等短期数据的一块内存区域。栈是由编译器自动分配和释放的，具有自动管理的特性。每当函数被调用时，会在栈上分配存储函数的参数、局部变量和返回地址的内存空间；当函数调用结束时，这些内存空间会被自动释放。</p> </li><li> <p>堆（Heap）：<br> 堆是用于存储动态分配的内存的一块内存区域。堆是由程序员手动分配和释放的，具有手动管理的特性。通过new操作符在堆上分配内存，通过delete操作符释放堆上的内存。堆上分配的内存可以在程序的任何地方使用，并且在不同的函数调用之间保持有效。</p> </li><li> <p>全局/静态存储区（Global/Static Storage）：<br> 全局存储区用于存储全局变量和静态变量，这些变量在整个程序的执行过程中都是存在的。全局变量在程序启动时分配内存，在程序结束时释放内存；静态变量在定义时分配内存，在程序结束时释放内存。</p> </li><li> <p>常量区（Constant Area）：<br> 常量区用于存储字符串常量和其他常量数据。这些常量数据在程序运行期间是不可修改的，并且存储在只读内存区域。</p> </li><li> <p>代码区（Code Area）：<br> 代码区存储程序的执行代码，包括函数的二进制代码和其他指令。代码区也是只读的，程序无法修改自身的代码。</p> </li></ol> 
<p>这些内存区域在程序运行期间可以根据需要进行动态分配和释放，其中栈和堆是最常用的内存管理方式。栈用于存储函数的局部变量和函数调用的上下文信息，而堆用于存储动态分配的内存，供程序在需要时进行使用和释放。全局/静态存储区、常量区和代码区则用于存储程序的静态数据和执行代码，不会在程序运行期间进行动态的内存分配和释放。</p> 
<h2><a id="C11__222"></a>二、C++11 新特性</h2> 
<h3><a id="1c11_223"></a>1.常见的c++11新特性有哪些</h3> 
<p>C++11引入了许多新特性，以下是其中一些常见的特性：</p> 
<ol><li>自动类型推断（auto）：<br> 使用auto关键字可以让编译器根据变量的初始值自动推断出变量的类型，简化类型声明的过程。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// x被推断为int类型</span>
<span class="token keyword">auto</span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span> <span class="token comment">// str被推断为const char*类型</span>
</code></pre> 
<ol start="2"><li>范围for循环（Range-based for loop）：<br> 范围for循环可以方便地遍历容器（如数组、容器类等）中的元素，不再需要通过迭代器或索引来访问容器的元素。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> num <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    num <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>初始化列表（Initializer list）：<br> 通过初始化列表可以在创建对象时直接用一组值进行初始化，简化了对象的初始化过程。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> map <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">{<!-- --></span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string">"banana"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span><span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="4"><li>空指针常量（nullptr）：<br> nullptr是一个新的空指针常量，可以用于代替NULL或0来表示空指针。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 指针为空</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="5"><li>强类型枚举（Scoped enums）：<br> 强类型枚举引入了新的enum类，可以将枚举值限定在枚举类型的作用域内，避免了命名冲突和隐式类型转换。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Color</span> <span class="token punctuation">{<!-- --></span>
    RED<span class="token punctuation">,</span>
    GREEN<span class="token punctuation">,</span>
    BLUE
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Color color <span class="token operator">=</span> Color<span class="token double-colon punctuation">::</span>GREEN<span class="token punctuation">;</span>
</code></pre> 
<ol start="6"><li>Lambda表达式（Lambda expressions）：<br> Lambda表达式是一种用于创建匿名函数的简洁语法，可以在需要函数对象的地方直接使用，并且可以捕获上下文中的变量。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">for_each</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>sum<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    sum <span class="token operator">+=</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<ol start="7"><li>并发编程支持（Concurrency support）：<br> C++11引入了线程库（std::thread）、原子操作（std::atomic）和互斥量（std::mutex）等并发编程的支持，使得编写多线程程序更加方便和安全。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">printHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello from thread!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>printHello<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="8"><li>移动语义（Move semantics）：<br> 通过移动语义，可以实现对临时对象的高效移动而不是复制，提高了对象的性能和效率。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> source <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> destination <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// source的内容被移动到destination</span>
</code></pre> 
<ol start="9"><li>智能指针（Smart pointers）：<br> C++11引入了shared_ptr和unique_ptr等智能指针，可以自动管理动态分配的内存，避免内存泄漏和手动释放内存的问题。</li></ol> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> uptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>四个智能指针： <strong>auto_ptr, shared_ptr, weak_ptr, unique_ptr</strong> 其中后三个是</p> 
<p>10.右值引用：<br> 右值引用是一种新的引用类型，可以绑定到临时对象或被移动的对象上，支持高效的移动语义。</p> 
<blockquote> 
 <p>代码如下：</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token comment">//使用两个 &amp;&amp; 表示这是一个右值引用的类型</span>
<span class="token keyword">void</span> <span class="token function">processData</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 对右值引用的data进行处理</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>
    <span class="token comment">// 获取数据</span>
    <span class="token keyword">return</span> vec<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">processData</span><span class="token punctuation">(</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 传递getData()的返回值（右值）给processData函数</span>


</code></pre> 
<h3><a id="2_351"></a>2.智能指针用过吗，有哪些，他们的区别和各自的优缺点</h3> 
<p>C++语言提供了几种智能指针，包括：<code>std::unique_ptr</code>、<code>std::shared_ptr</code>和<code>std::weak_ptr</code>。</p> 
<ol><li><code>std::unique_ptr</code>： 
  <ul><li>它是一种独占式智能指针，不能进行复制或共享。</li><li>只能有一个<code>std::unique_ptr</code>指向同一个对象，当它过期（超出作用域）或被手动释放时，它自动删除所管理的对象。</li><li>适合用于具有独占所有权的场景，例如管理单个资源。</li></ul> </li></ol> 
<pre><code class="prism language-cpp">unique_ptr <span class="token function">p3</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">string</span> <span class="token punctuation">(</span>“<span class="token keyword">auto</span>”<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
unique_ptr p4；
p4 <span class="token operator">=</span> p3<span class="token punctuation">;</span>                  <span class="token comment">//此时会报错！！</span>
<span class="token comment">//可以用</span>
unique_ptr ps1<span class="token punctuation">,</span> ps2<span class="token punctuation">;</span> 
ps1 <span class="token operator">=</span> <span class="token function">demo</span><span class="token punctuation">(</span>“hello”<span class="token punctuation">)</span><span class="token punctuation">;</span>
ps2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>ps1<span class="token punctuation">)</span><span class="token punctuation">;</span> 
ps1 <span class="token operator">=</span> <span class="token function">demo</span><span class="token punctuation">(</span>“alexia”<span class="token punctuation">)</span><span class="token punctuation">;</span> 
cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ps2 <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>ps1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
</code></pre> 
<ol start="2"><li><code>std::shared_ptr</code>： 
  <ul><li>它是一种共享式智能指针，可以被多个<code>std::shared_ptr</code>共享同一个对象。</li><li>内部维护引用计数，只有当最后一个<code>std::shared_ptr</code>过期时，才会自动删除所管理的对象。</li><li>具备线程安全的引用计数机制，可以在多线程环境中使用。</li><li>适合用于需要多个智能指针共享同一个对象的场景。</li></ul> </li></ol> 
<table><thead><tr><th>成员函数</th><th>含义</th></tr></thead><tbody><tr><td>use_count</td><td>返回引用计数的个数</td></tr><tr><td>unique</td><td>返回是否是独占所有权( use_count 为 1)</td></tr><tr><td>swap</td><td>交换两个 shared_ptr 对象(即交换所拥有的对象)</td></tr><tr><td>reset</td><td>放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少</td></tr><tr><td>get</td><td>返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr sp(new int(1)); sp 与 sp.get()是等价的</td></tr></tbody></table> 
<ol start="3"><li><code>std::weak_ptr</code>： 
  <ul><li>它是一种弱引用智能指针，可以共享对象，但不增加引用计数。</li><li>它不能直接访问被管理的对象，需要通过<code>std::shared_ptr</code>来访问或转换。</li><li>避免了循环引用问题，可以解决<code>std::shared_ptr</code>之间的循环引用导致内存泄漏的情况。</li></ul> </li></ol> 
<p>这些智能指针各自有不同的优缺点：</p> 
<ul><li><code>std::unique_ptr</code>的优点是轻量级且性能高，不需要维护引用计数；缺点是不能共享资源。</li><li><code>std::shared_ptr</code>的优点是可以共享资源，线程安全，适用于复杂的拥有关系；缺点是增加了额外的开销，包括引用计数的维护和原子操作等。</li><li><code>std::weak_ptr</code>的优点是避免了循环引用的内存泄漏问题；缺点是不能直接访问被管理的对象，需要转换为<code>std::shared_ptr</code>使用。</li></ul> 
<p>选择智能指针应根据具体的需求和场景来决定。如果你需要独占所有权并且不需要资源共享，则可以使用<code>std::unique_ptr</code>。如果你需要共享资源，则可以使用<code>std::shared_ptr</code>。如果你需要解决循环引用问题，则可以考虑使用<code>std::weak_ptr</code>。</p> 
<h3><a id="3autoauto_396"></a>3.auto关键字知道吗，如果全部都用auto声明变量行不行</h3> 
<p>在使用auto声明变量时，编译器会根据变量的初始化表达式推断出其类型，并将其替换为具体的类型。这样可以简化代码，减少类型的显式声明，提高代码的可读性和可维护性。</p> 
<p>虽然使用auto声明变量可以方便地进行类型推断，但并不意味着应该全部都使用auto来声明变量。以下情况不建议过度使用auto：</p> 
<ol><li> <p>可读性：显式声明变量可以更清晰地传达代码的意图和目的。如果变量的类型对于代码的理解很重要，或者可以提高代码的可读性，建议显式声明变量。</p> </li><li> <p>复杂表达式：在一些复杂的表达式中，类型推断可能会导致难以理解的推断结果。在这种情况下，显式声明变量可以提高代码的可读性和可维护性。</p> </li><li> <p>模板编程：在模板编程中，由于模板的参数可能具有多种类型，使用auto可能无法满足需要。在这种情况下，需要显式指定类型。</p> </li></ol> 
<h3><a id="4lambda_407"></a>4.lambda表达式会用吗</h3> 
<p>lambda表达式是一种匿名函数，允许我们在需要函数对象的地方提供一个简洁、灵活和内联的函数定义。</p> 
<p>使用lambda表达式可以带来以下好处：</p> 
<ol><li> <p>简洁性：lambda表达式可以在不定义独立函数的情况下，直接在代码中定义函数功能。这样可以减少定义函数的代码量，并且更清晰地表达特定的功能。</p> </li><li> <p>内联性：lambda表达式是内联定义的，可以直接在需要的位置使用，无需额外的函数声明和定义。这对于某些仅在局部范围内使用的函数非常方便。</p> </li><li> <p>可读性：由于lambda表达式在使用时紧随其后，它们可以直接展示函数的功能和意图，使代码更加易读和易理解。</p> </li><li> <p>高度灵活性：lambda表达式可以自包含地捕获所需的变量，并且可以在需要时更改捕获方式。这使得lambda表达式在编写回调函数、排序算法、STL算法等场景中特别有用。</p> </li></ol> 
<p>以下是一个lambda表达式的示例：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">auto</span> sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用lambda表达式计算结果为7</span>
</code></pre> 
<p>lambda表达式使用方括号来指定捕获列表，可以选择按值或按引用来捕获变量。在括号内部，定义了函数参数和函数体。</p> 
<p>需要注意的是，在某些情况下，lambda表达式可能会使代码变得复杂和难以理解。在这种情况下，考虑将其提取为命名函数可能更合适。合理地使用lambda表达式可以提高代码的灵活性和可读性。</p> 
<h3><a id="5override_430"></a>5.override关键字必须吗</h3> 
<p>不，override关键字并非必需，但在特定情况下使用它可以提高代码的清晰性和可维护性。</p> 
<p>在C++中，override关键字用于显式地指示派生类中的成员函数覆盖基类中的虚函数。当我们希望确保派生类中的函数确实是对基类函数的重写时，使用override关键字是一个好的实践。</p> 
<p>使用override关键字的好处包括：</p> 
<ol><li> <p>明确表明意图：使用override关键字可以清楚地表示我们有意重写了基类中的函数。这可以提醒其他开发人员，并且可以在编译时检测到一些潜在的错误，比如函数签名不匹配或遗漏了const修饰符。</p> </li><li> <p>错误检测：当使用override关键字时，编译器会在派生类中检查是否存在与基类中的虚函数匹配的函数。如果没有找到匹配的函数，或者函数签名不正确，编译器将产生错误。这有助于捕获潜在的错误，避免在派生类中错误地定义了一个新的函数而不是重写基类函数。</p> </li><li> <p>可读性和可理解性：使用override关键字可以使代码更加清晰和易读。它提供了一种方式来快速识别哪些函数是虚函数的重写，从而提高代码的可维护性和可理解性。</p> </li></ol> 
<p>需要注意的是，在以下情况下使用override关键字是无效或不必要的：</p> 
<ul><li>如果基类中的函数不是虚函数，不应该使用override关键字。</li><li>如果函数在派生类中是新定义的函数，并不是对基类函数的重写，则不应使用override关键字。</li></ul> 
<h3><a id="6_447"></a>6.右值引用</h3> 
<p>右值引用是C++11引入的一种新特性，它提供了一种高效的方式来管理临时对象和避免不必要的复制。</p> 
<p>右值引用的语法是使用&amp;&amp;符号来定义一个引用，例如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> rvalue_ref <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用绑定字面量</span>
</code></pre> 
<p>右值引用最常见的应用场景是将临时对象传递给函数，从而避免不必要的复制或移动：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;&amp;</span> str<span class="token punctuation">)</span> <span class="token comment">// 右值引用参数</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 对str的操作，通常会将其转移（move）到其他地方</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传递临时字符串，避免了复制</span>
    std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将str转移为右值引用，避免了复制</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在这个例子中，我们可以看到右值引用的两种应用方式。首先，在函数foo中，我们将参数定义为一个右值引用，以接收一个临时对象。由于该对象只是暂时存在，并且我们不需要保留它的状态，因此使用右值引用可以更有效地处理它。</p> 
<p>另外，在调用foo函数时，我们可以使用一个临时对象或通过std::move函数将一个左值对象转换为右值引用来传递参数。这样可以避免在传递参数时进行额外的复制，从而提高代码的效率。</p> 
<p>除了上述示例中的用法之外，右值引用还有其他实际应用场景。例如：</p> 
<ul><li> <p>移动语义：右值引用是实现移动语义的关键。通过允许对象的状态转移到新的对象中，移动语义可以避免不必要的复制，提高代码效率。</p> </li><li> <p>完美转发：右值引用也是实现完美转发的核心技术之一。通过在函数模板中使用右值引用，可以将参数按原样转发到另一个函数，从而实现参数类型的完全转移。</p> </li></ul> 
<p>总之，右值引用是C++11中非常重要的一个特性，它可以帮助我们管理临时对象、提高代码效率和实现完美转发等。理解和掌握右值引用的使用方式对于编写高效和可维护的C++代码非常重要。</p> 
<h2><a id="_483"></a>总结</h2> 
<p>这里只是文章的一部分问题答案，不一定正确，我对C++的了解有限，如果有错误，会有后续修改</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38a801c58db4ac2515654ead21eea07d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何批量为文件夹命名</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/534a5d0545cea9f5a9ce9924055b4e45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ORA-03113：通信通道的文件结尾-完美解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>