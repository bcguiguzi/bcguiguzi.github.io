<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>排序算法——快速排序（Quicksort）基准值的三种选取和优化方法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="排序算法——快速排序（Quicksort）基准值的三种选取和优化方法" />
<meta property="og:description" content="目录 1 快速排序的基本原理1.1快速排序的基本思路： 2 举例说明总结： 3 代码演示4 关于快排的基准值的选取4.1 固定位置选取基准值测试数据： 4.2 随机选取基准值测试数据 4.3 三数取中法，选取基准元 5 四种优化方式优化1：当待排序序列的长度分割到一定大小后，使用插入排序优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。 参考链接： 1 快速排序的基本原理 关于快速排序，它的基本思想就是选取一个基准，一趟排序确定两个区间，一个区间全部比基准值小，另一个区间全部比基准值大，接着再选取一个基准值来进行排序，以此类推，最后得到一个有序的数列。
1.1快速排序的基本思路： 1.选取基准值，通过不同的方式挑选出基准值。
2.用分治的思想进行分割，通过该基准值在序列中的位置，将序列分成两个区间，在准值左边的区间里的数都比基准值小（默认以升序排序），在基准值右边的区间里的数都比基准值大。
3.递归调用快速排序的函数对两个区间再进行上两步操作，直到调用的区间为空或是只有一个数。
2 举例说明 假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个 10 个数进行排序。首先在这个序列中随便找一个数作为基准数（就是一个用来参照的数）。为了方便，就让第一个数 6 作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 6 的右边，比基准数小的数放在 6 的左边，类似下面这种排列。
3 1 2 5 4 6 9 7 10 8 在初始状态下，数字 6 在序列的第 1 位。我们的目标是将 6 挪到序列中间的某个位置，假设这个位置是 k。现在就需要寻找这个 k，并且以第 k 位为分界点，左边的数都小于等于 6，右边的数都大于等于 6。
方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序列的最右边（即 j=10），指向数字 8。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/1f4a7ce560bd6e6c46a6be50896a134c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-27T20:43:07+08:00" />
<meta property="article:modified_time" content="2022-02-27T20:43:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">排序算法——快速排序（Quicksort）基准值的三种选取和优化方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#1___2" rel="nofollow">1 快速排序的基本原理</a></li><li><ul><li><a href="#11_4" rel="nofollow">1.1快速排序的基本思路：</a></li></ul> 
   </li><li><a href="#2__9" rel="nofollow">2 举例说明</a></li><li><ul><li><a href="#_49" rel="nofollow">总结：</a></li></ul> 
   </li><li><a href="#3__54" rel="nofollow">3 代码演示</a></li><li><a href="#4__125" rel="nofollow">4 关于快排的基准值的选取</a></li><li><ul><li><a href="#41__126" rel="nofollow">4.1 固定位置选取基准值</a></li><li><ul><li><ul><li><a href="#_137" rel="nofollow">测试数据：</a></li></ul> 
    </li></ul> 
    </li><li><a href="#42__141" rel="nofollow">4.2 随机选取基准值</a></li><li><ul><li><ul><li><a href="#_158" rel="nofollow">测试数据</a></li></ul> 
    </li></ul> 
    </li><li><a href="#43__162" rel="nofollow">4.3 三数取中法，选取基准元</a></li></ul> 
   </li><li><a href="#5__255" rel="nofollow">5 四种优化方式</a></li><li><ul><li><ul><li><ul><li><a href="#1_256" rel="nofollow">优化1：当待排序序列的长度分割到一定大小后，使用插入排序</a></li><li><a href="#2Keykey_272" rel="nofollow">优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。</a></li></ul> 
    </li></ul> 
   </li></ul> 
   </li><li><a href="#_375" rel="nofollow">参考链接：</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1___2"></a>1 快速排序的基本原理</h3> 
<p>关于快速排序，它的基本思想就是选取一个基准，一趟排序确定两个区间，一个区间全部比基准值小，另一个区间全部比基准值大，接着再选取一个基准值来进行排序，以此类推，最后得到一个有序的数列。</p> 
<h4><a id="11_4"></a>1.1快速排序的基本思路：</h4> 
<p>1.选取基准值，通过不同的方式挑选出基准值。<br> 2.用分治的思想进行分割，通过该基准值在序列中的位置，将序列分成两个区间，在准值左边的区间里的数都比基准值小（默认以升序排序），在基准值右边的区间里的数都比基准值大。<br> 3.递归调用快速排序的函数对两个区间再进行上两步操作，直到调用的区间为空或是只有一个数。</p> 
<h3><a id="2__9"></a>2 举例说明</h3> 
<p>假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个 10 个数进行排序。首先在这个序列中随便找一个数作为基准数（就是一个用来参照的数）。为了方便，就让第一个数 6 作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在 6 的右边，比基准数小的数放在 6 的左边，类似下面这种排列。</p> 
<pre><code class="prism language-cpp"><span class="token number">3</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
</code></pre> 
<p>在初始状态下，数字 6 在序列的第 1 位。我们的目标是将 6 挪到序列中间的某个位置，假设这个位置是 k。现在就需要寻找这个 k，并且以第 k 位为分界点，左边的数都小于等于 6，右边的数都大于等于 6。</p> 
<p>方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序列的最右边（即 j=10），指向数字 8。<br> <img src="https://images2.imgbox.com/5c/53/TKjF2VqM_o.png" alt="在这里插入图片描述"><br> 首先哨兵 j 开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵 j 先出动，这一点非常重要（请自己想一想为什么）。哨兵 j 一步一步地向左挪动（即 j–），直到找到一个小于 6 的数停下来。接下来哨兵 i 再一步一步向右挪动（即 i++），直到找到一个数大于 6 的数停下来。最后哨兵 j 停在了数字 5 面前，哨兵 i 停在了数字 7 面前。<br> <img src="https://images2.imgbox.com/40/7a/I33j2knf_o.png" alt="在这里插入图片描述"><br> 第二次交换结束，“探测”继续。哨兵 j 继续向左挪动，他发现了 3（比基准数 6 要小，满足要求）之后又停了下来。哨兵 i 继续向右移动，糟啦！此时哨兵 i 和哨兵 j 相遇了，哨兵 i 和哨兵 j 都走到 3 面前。说明此时“探测”结束。我们将基准数 6 和 3 进行交换。交换之后的序列如下。</p> 
<pre><code class="prism language-cpp"><span class="token number">3</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/4f/e6/f7267cns_o.png" alt="在这里插入图片描述"><br> 到此第一轮“探测”真正结束。此时以基准数 6 为分界点，6 左边的数都小于等于 6，6 右边的数都大于等于 6。回顾一下刚才的过程，其实哨兵 j 的使命就是要找小于基准数的数，而哨兵 i 的使命就是要找大于基准数的数，直到 i 和 j 碰头为止。<br> OK，解释完毕。现在基准数 6 已经归位，它正好处在序列的第 6 位。此时我们已经将原来的序列，以 6 为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“ 9 7 10 8 ”。接下来还需要分别处理这两个序列。因为 6 左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理 6 左边和右边的序列即可。现在先来处理 6 左边的序列现吧。</p> 
<p>左边的序列是“3 1 2 5 4”。请将这个序列以 3 为基准数进行调整，使得 3 左边的数都小于等于 3，3 右边的数都大于等于 3。好了开始动笔吧。</p> 
<p>调整完毕之后的序列的顺序应该是。</p> 
<pre><code class="prism language-cpp"><span class="token number">2</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">4</span>
</code></pre> 
<p>OK，现在 3 已经归位。接下来需要处理 3 左边的序列“ 2 1 ”和右边的序列“5 4”。对序列“ 2 1 ”以 2 为基准数进行调整，处理完毕之后的序列为“1 2”，到此 2 已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“ 2 1 ”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下。</p> 
<pre><code class="prism language-cpp"><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
</code></pre> 
<p>对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下。</p> 
<pre><code class="prism language-cpp"><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span>
</code></pre> 
<h4><a id="_49"></a>总结：</h4> 
<p>快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。<br> <img src="https://images2.imgbox.com/db/55/J07zNP3Q_o.png" alt="在这里插入图片描述"><br> 上述内容来自：<a href="https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html" rel="nofollow">最常用的排序——快速排序</a><br> 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 <strong>O(N2)</strong>，它的平均时间复杂度为 <strong>O(NlogN)</strong></p> 
<h3><a id="3__54"></a>3 代码演示</h3> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">]</span><span class="token punctuation">,</span>n<span class="token punctuation">;</span><span class="token comment">//定义全局变量，这两个变量需要在子函数中使用</span>
<span class="token keyword">void</span> <span class="token function">quicksort</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>t<span class="token punctuation">,</span>temp<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">&gt;</span>right<span class="token punctuation">)</span>
       <span class="token keyword">return</span><span class="token punctuation">;</span>
    temp<span class="token operator">=</span>a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//temp中存的就是基准数</span>
    i<span class="token operator">=</span>left<span class="token punctuation">;</span>
    j<span class="token operator">=</span>right<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">!=</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
       <span class="token comment">//顺序很重要，要先从右边开始找</span>
       <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;=</span>temp <span class="token operator">&amp;&amp;</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
       <span class="token comment">//再找右边的</span>
       <span class="token keyword">while</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span>temp <span class="token operator">&amp;&amp;</span> i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
       <span class="token comment">//交换两个数在数组中的位置</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>
       <span class="token punctuation">{<!-- --></span>
            t<span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//最终将基准数归位</span>
    a<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>

    <span class="token function">quicksort</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//继续处理左边的，这里是一个递归的过程</span>
    <span class="token function">quicksort</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//继续处理右边的 ，这里是一个递归的过程</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>t<span class="token punctuation">;</span>
    <span class="token comment">//读入数据</span>
    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">quicksort</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//快速排序调用</span>

    <span class="token comment">//输出排序后的结果</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f1/8b/wjq0Ect7_o.png" alt="在这里插入图片描述"><br> 下面是程序执行过程中数组 a 的变化过程，带下划线的数表示的已归位的基准数。</p> 
<pre><code class="prism language-cpp"><span class="token number">1</span> <span class="token number">2</span> <span class="token number">7</span> <span class="token number">9</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">10</span> <span class="token number">8</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
<span class="token number">1</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
<span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
<span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
<span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
<span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token number">10</span> <span class="token number">8</span>
<span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">9</span> <span class="token number">10</span>
<span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span>
<span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span>
<span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7b/77/rsgb6Dpr_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4__125"></a>4 关于快排的基准值的选取</h3> 
<h4><a id="41__126"></a>4.1 固定位置选取基准值</h4> 
<p>基本思想：选取第一个或最后一个元素作为基准值。<br> <img src="https://images2.imgbox.com/72/91/RdWdVe7P_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">SelectPivot</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span>  
<span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//选择选取序列的第一个元素作为基准  </span>
<span class="token punctuation">}</span>  
</code></pre> 
<p>注意：基本的快速排序选取第一个或最后一个元素作为基准。但是，这是一个很不好的处理方法。</p> 
<h6><a id="_137"></a>测试数据：</h6> 
<p><img src="https://images2.imgbox.com/9f/73/912NCMZy_o.png" alt="在这里插入图片描述"><br> 测试数据分析：如果输入序列是随机的，处理时间可以接受的。如果数组已经有序时，此时的分割就是一个非常不好的分割。因为每次划分只能使待排序序列减一，此时为最坏情况，快速排序沦为起泡排序，时间复杂度为Θ(n^2)。而且，输入的数据是有序或部分有序的情况是相当常见的。因此，使用第一个元素作为枢纽元是非常糟糕的，为了避免这个情况，就引入了下面两个获取基准的方法。</p> 
<h4><a id="42__141"></a>4.2 随机选取基准值</h4> 
<p>基本思想：选取待排序列中任意一个数作为基准值。<br> 引入的原因：在待排序列是部分有序时，固定选取枢轴使快排效率底下，要缓解这种情况，就引入了随机选取枢轴</p> 
<pre><code class="prism language-cpp"><span class="token comment">/*随机选择枢轴的位置，区间在low和high之间*/</span>  
<span class="token keyword">int</span> <span class="token function">SelectPivotRandom</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span>  
<span class="token punctuation">{<!-- --></span>  
    <span class="token comment">//产生枢轴的位置  </span>
    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> pivotPos <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> low<span class="token punctuation">;</span>  

    <span class="token comment">//把枢轴位置的元素和low位置元素互换，此时可以和普通的快排一样调用划分函数  </span>
    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>pivotPos<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
</code></pre> 
<h6><a id="_158"></a>测试数据</h6> 
<p><img src="https://images2.imgbox.com/12/10/2coojeV3_o.png" alt="在这里插入图片描述"><br> 测试数据分析：:这是一种相对安全的策略。由于枢轴的位置是随机的，那么产生的分割也不会总是会出现劣质的分割。在整个数组数字全相等时，仍然是最坏情况，时间复杂度是O(n<sup>2）。实际上，随机化快速排序得到理论最坏情况的可能性仅为1/(2</sup>n）。所以随机化快速排序可以对于绝大多数输入数据达到O(nlogn）的期望时间复杂度。</p> 
<h4><a id="43__162"></a>4.3 三数取中法，选取基准元</h4> 
<p>基本思想:取第一个数，最后一个数，第（N/2）个数即中间数，三个数中数值中间的那个数作为基准值。举个例子，对于int a[] = { 2,5,4,9,3,6,8,7,1,0};，‘2’、‘3’、‘0’，分别是第一个数，第（N/2）个是数以及最后一个数，三个数中3最大，0最小，2在中间，所以取2为基准值。</p> 
<p>引入的原因：虽然随机选取枢轴时，减少出现不好分割的几率，但是还是最坏情况下还是O(n^2），要缓解这种情况，就引入了三数取中选取枢轴</p> 
<p>分析：最佳的划分是将待排序的序列分成等长的子序列，最佳的状态我们可以使用序列的中间的值，也就是第N/2个数。可是，这很难算出来，并且会明显减慢快速排序的速度。这样的中值的估计可以通过随机选取三个元素并用它们的中值作为枢纽元而得到。事实上，随机性并没有多大的帮助，因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。显然使用三数中值分割法消除了预排序输入的不好情形，并且减少快排大约14%的比较次数</p> 
<pre><code class="prism language-cpp"><span class="token comment">/*函数作用：取待排序序列中low、mid、high三个位置上数据，选取他们中间的那个数据作为枢轴*/</span>  
<span class="token keyword">int</span> <span class="token function">SelectPivotMedianOfThree</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span>  
<span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//计算数组中间的元素的下标  </span>

    <span class="token comment">//使用三数取中法选择枢轴  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//目标: arr[mid] &lt;= arr[high]  </span>
    <span class="token punctuation">{<!-- --></span>  
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">//目标: arr[low] &lt;= arr[high]  </span>
    <span class="token punctuation">{<!-- --></span>  
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//目标: arr[low] &gt;= arr[mid]  </span>
    <span class="token punctuation">{<!-- --></span>  
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token comment">//此时，arr[mid] &lt;= arr[low] &lt;= arr[high]  </span>
    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token comment">//low的位置上保存这三个位置中间的值  </span>
    <span class="token comment">//分割时可以直接使用low位置的元素作为枢轴，而不用改变分割函数了  </span>
<span class="token punctuation">}</span> 
</code></pre> 
<p><img src="https://images2.imgbox.com/53/f5/dirqnSYU_o.png" alt="在这里插入图片描述"><br> 测试数据分析：使用三数取中选择枢轴优势还是很明显的，<strong>但是还是处理不了重复数组</strong></p> 
<pre><code class="prism language-cpp"><span class="token comment">//交换子表的记录，使枢轴记录到位，并返回枢轴所在的位置</span>
<span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
 
	<span class="token comment">/*三数中值分割法*/</span>
	<span class="token keyword">int</span> m <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//数组中间元素的下标</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&gt;</span>array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//保证左端较小</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">//保证中间较小</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> high<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&gt;</span> array<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> m<span class="token punctuation">,</span> low<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//保证左端最小</span>
	<span class="token comment">//此时array[low]已经为整个序列左中右三个关键字的中间值</span>
	<span class="token keyword">int</span> pivotkey <span class="token operator">=</span> array<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>
 
	<span class="token comment">/*固定基准元
	 int pivotkey = array[low];
	 */</span>
 
	<span class="token comment">/*随机基准元
	int randomIndex = rand() % (high - low) + low;//取数组中随机下标
	swap(array, randomIndex, low);                //与第一个数交换
	int pivotkey = array[low];
	*/</span>
 
	<span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> high<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span> <span class="token comment">//从表的两端交替向中间扫描,当没有相遇</span>
	<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> pivotkey<span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			j<span class="token operator">--</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivotkey<span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			i<span class="token operator">++</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>
			<span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>	
	<span class="token punctuation">}</span>
	<span class="token comment">//最终将基准数归位</span>
	<span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> i<span class="token punctuation">;</span>              <span class="token comment">//返回枢轴所在的位置</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">QSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> pivot<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
		pivot <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//算出枢轴值</span>
		<span class="token function">QSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//对低子表递归排序</span>
		<span class="token function">QSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//对高子表递归排序</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//对array做快速排序</span>
<span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token function">QSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="5__255"></a>5 四种优化方式</h3> 
<h6><a id="1_256"></a>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</h6> 
<p>原因：对于很小和部分有序的数组，快排不如插排好。当待排序序列的长度分割到一定大小后，继续分割的效率比插入排序要差，此时可以使用插排而不是快排</p> 
<p>截止范围：待排序序列长度N = 10，虽然在5~20之间任一截止范围都有可能产生类似的结果，这种做法也避免了一些有害的退化情形。摘自《数据结构与算法分析》Mark Allen Weiness 著</p> 
<pre><code class="prism language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>  
<span class="token punctuation">{<!-- --></span>  
    <span class="token function">InsertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token comment">//else时，正常执行快排  </span>
</code></pre> 
<p>测试数据：<br> <img src="https://images2.imgbox.com/bd/22/frvy4jvV_o.png" alt="在这里插入图片描述"><br> 测试数据分析：针对随机数组，使用三数取中选择枢轴+插排，效率还是可以提高一点，真是针对已排序的数组，是没有任何用处的。因为待排序序列是已经有序的，那么每次划分只能使待排序序列减一。此时，插排是发挥不了作用的。所以这里看不到时间的减少。另外，三数取中选择枢轴+插排还是不能处理重复数组</p> 
<h6><a id="2Keykey_272"></a>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割。</h6> 
<p>举例：</p> 
<p>待排序序列 1 4 6 7 6 6 7 6 8 6</p> 
<p>三数取中选取枢轴：下标为4的数6</p> 
<p>转换后，待分割序列：6 4 6 7 1 6 7 6 8 6</p> 
<pre><code>     枢轴key：6
</code></pre> 
<p>第一步，在划分过程中，把与key相等元素放入数组的两端<br> 结果为：6 4 1 6(枢轴) 7 8 7 6 6 6</p> 
<p>此时，与6相等的元素全放入在两端了</p> 
<p>第二步，划分结束后，把与key相等的元素移到枢轴周围</p> 
<p>结果为：1 4 66(枢轴) 6 6 6 7 8 7</p> 
<p>此时，与6相等的元素全移到枢轴周围了</p> 
<p>之后，在1 4 和 7 8 7两个子序列进行快排</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">QSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span>  
<span class="token punctuation">{<!-- --></span>  
    <span class="token keyword">int</span> first <span class="token operator">=</span> low<span class="token punctuation">;</span>  
    <span class="token keyword">int</span> last <span class="token operator">=</span> high<span class="token punctuation">;</span>  

    <span class="token keyword">int</span> left <span class="token operator">=</span> low<span class="token punctuation">;</span>  
    <span class="token keyword">int</span> right <span class="token operator">=</span> high<span class="token punctuation">;</span>  

    <span class="token keyword">int</span> leftLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> rightLen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  

    <span class="token keyword">if</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{<!-- --></span>  
        <span class="token function">InsertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  

    <span class="token comment">//一次分割  </span>
    <span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token function">SelectPivotMedianOfThree</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用三数取中法选择枢轴  </span>

    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span>  
    <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span>high <span class="token operator">&gt;</span> low <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> key<span class="token punctuation">)</span>  
        <span class="token punctuation">{<!-- --></span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span><span class="token comment">//处理相等元素  </span>
            <span class="token punctuation">{<!-- --></span>  
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                right<span class="token operator">--</span><span class="token punctuation">;</span>  
                rightLen<span class="token operator">++</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            high<span class="token operator">--</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span>high <span class="token operator">&gt;</span> low <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span>  
        <span class="token punctuation">{<!-- --></span>  
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>  
            <span class="token punctuation">{<!-- --></span>  
                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
                left<span class="token operator">++</span><span class="token punctuation">;</span>  
                leftLen<span class="token operator">++</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            low<span class="token operator">++</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>  

    <span class="token comment">//一次快排结束  </span>
    <span class="token comment">//把与枢轴key相同的元素移到枢轴最终位置周围  </span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> low <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token keyword">int</span> j <span class="token operator">=</span> first<span class="token punctuation">;</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> left <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span>  
    <span class="token punctuation">{<!-- --></span>  
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        i<span class="token operator">--</span><span class="token punctuation">;</span>  
        j<span class="token operator">++</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    i <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    j <span class="token operator">=</span> last<span class="token punctuation">;</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> key<span class="token punctuation">)</span>  
    <span class="token punctuation">{<!-- --></span>  
        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        i<span class="token operator">++</span><span class="token punctuation">;</span>  
        j<span class="token operator">--</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token function">QSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>first<span class="token punctuation">,</span>low <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> leftLen<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token function">QSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>low <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> rightLen<span class="token punctuation">,</span>last<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
</code></pre> 
<p><img src="https://images2.imgbox.com/fb/3c/5FwlPA4t_o.png" alt="在这里插入图片描述"><br> 测试数据分析：三数取中选择枢轴+插排+聚集相等元素的组合，效果竟然好的出奇。</p> 
<p>原因：在数组中，如果有相等的元素，那么就可以减少不少冗余的划分。这点在重复数组中体现特别明显啊。<br> 其实这里，插排的作用还是不怎么大的。</p> 
<p><img src="https://images2.imgbox.com/44/f6/qTgEvg4x_o.png" alt="在这里插入图片描述"><br> 概括：这里效率最好的快排组合 是：三数取中+插排+聚集相等元素,它和STL中的Sort函数效率差不多</p> 
<h3><a id="_375"></a>参考链接：</h3> 
<p><a href="https://blog.csdn.net/lvyibin890/article/details/79044068?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.edu_weight">快速排序的三种方式以及快排的优化</a><br> <a href="https://blog.csdn.net/hacker00011000/article/details/52176100">三种快排及四种优化方式</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4579e61249903a4cc40019d4bd0567e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">maven多模块打包,package失败</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1d1e660f6fa5469cb7b10138be3fc20/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IPS和WAF区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>