<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何使用Fluent Assertions进行多个断言？ - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何使用Fluent Assertions进行多个断言？" />
<meta property="og:description" content="目录
介绍
背景
使用代码
兴趣点
介绍 许多代码返回一个复杂的对象。就像其他代码一样，它需要进行单元测试。从逻辑上讲，这只需在测试中添加多个断言行即可完成。这听起来合乎逻辑，但对维护来说是一个问题。每增加一行都需要维护。此外，每条线路都可能导致单独的故障。
在本文中，我将更详细地解释该问题，并演示如何处理此问题。
背景 必须具备一些.NET中的单元测试经验，最好是xUnit和 Fluent断言。
使用代码 下面是要进行单元测试的代码。它是一个拥有关于人类健康的属性的类。由于无法测量BMI，因此对其进行计算。
public class HealthDescription { public decimal LengthInM { get; } public decimal WeightInKg { get; } public decimal Bmi { get; } public HealthDescription(decimal weightInKg, int lengthInCm) { WeightInKg = weightInKg; LengthInM = (decimal)lengthInCm / 100; Bmi = Math.Round(weightInKg / (LengthInM * LengthInM), 2); } } 要演示的第一个单元测试是这样的：
[Theory] [InlineData(70.01, 180, 1.80, 21.61)] public void RegularTest(decimal weightInKg, int lengthInCm, decimal expectedLengthInM, decimal expectedBmi) { var instance = new HealthDescription(weightInKg, lengthInCm); instance." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/09669accdf064136404cfaeb5539901a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-12T19:00:00+08:00" />
<meta property="article:modified_time" content="2024-03-12T19:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何使用Fluent Assertions进行多个断言？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#%E4%BB%8B%E7%BB%8D" rel="nofollow">介绍</a></p> 
<p id="%E8%83%8C%E6%99%AF-toc" style="margin-left:0px;"><a href="#%E8%83%8C%E6%99%AF" rel="nofollow">背景</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81" rel="nofollow">使用代码</a></p> 
<p id="%E5%85%B4%E8%B6%A3%E7%82%B9-toc" style="margin-left:0px;"><a href="#%E5%85%B4%E8%B6%A3%E7%82%B9" rel="nofollow">兴趣点</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%BB%8B%E7%BB%8D" style="margin-left:0px;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#ff9900;">介绍</span></span></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">许多代码返回一个复杂的对象。就像其他代码一样，它需要进行单元测试。从逻辑上讲，这只需在测试中添加多个断言行即可完成。这听起来合乎逻辑，但对维护来说是一个问题。每增加一行都需要维护。此外，每条线路都可能导致单独的故障。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">在本文中，我将更详细地解释该问题，并演示如何处理此问题。</span></span></p> 
<h2 id="%E8%83%8C%E6%99%AF" style="margin-left:0px;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#ff9900;">背景</span></span></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">必须具备一些</span><span style="color:#111111;">.NET</span><span style="color:#111111;">中的单元测试经验，最好是</span><span style="color:#111111;">xUnit</span><span style="color:#111111;">和</span> <span style="color:#000000;"><a href="https://fluentassertions.com/" rel="nofollow" title="Fluent断言">Fluent断言</a></span><span style="color:#111111;">。</span></span></p> 
<h2 id="%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%A0%81" style="margin-left:0px;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#ff9900;">使用代码</span></span></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">下面是要进行单元测试的代码。它是一个拥有关于人类健康的属性的类。由于</span><span style="color:#000000;"><a href="https://en.wikipedia.org/wiki/Body_mass_index" rel="nofollow" title="无法测量BMI">无法测量BMI</a></span><span style="color:#111111;">，因此对其进行计算。</span></span></p> 
<pre><code class="language-cs">public class HealthDescription
{
    public decimal LengthInM { get; }
    public decimal WeightInKg { get; }
    public decimal Bmi { get;  }
    public HealthDescription(decimal weightInKg, int lengthInCm)
    {
        WeightInKg = weightInKg;
        LengthInM = (decimal)lengthInCm / 100;
        Bmi = Math.Round(weightInKg / (LengthInM * LengthInM), 2);
    }
}</code></pre> 
<div> 
 <p style="margin-left:0;text-align:left;"></p> 
</div> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">要演示的第一个单元测试是这样的：</span></span></p> 
<pre><code class="language-cs">[Theory]
[InlineData(70.01, 180, 1.80, 21.61)]
public void RegularTest(decimal weightInKg, int lengthInCm, 
       decimal expectedLengthInM, decimal expectedBmi)
{
    var instance = new HealthDescription(weightInKg, lengthInCm);
    instance.LengthInM.Should().Be(expectedLengthInM);
    instance.Bmi.Should().Be(expectedBmi);
    instance.WeightInKg.Should().Be(weightInKg);
}</code></pre> 
<div> 
 <p style="margin-left:0;text-align:left;"></p> 
</div> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">上面显示的这个测试有两个问题：</span></span></p> 
<ol><li style="text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">有多条线路需要维护。</span></span></li><li style="text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">如果第一个或第二个断言失败，则并非所有断言都会执行。</span></span></li></ol> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">最后一个问题很容易解决。这里有一种方法可以做到这一点：</span></span></p> 
<pre><code class="language-cs">[Theory]
[InlineData(70.01, 180, 1.80, 21.61)]
public void ScopeTest(decimal weightInKg, int lengthInCm, 
       decimal expectedLengthInM, decimal expectedBmi)
{
    var instance = new HealthDescription(weightInKg, lengthInCm);
    using (new AssertionScope())
    {
        instance.LengthInM.Should().Be(expectedLengthInM);
        instance.Bmi.Should().Be(expectedBmi);
        instance.WeightInKg.Should().Be(weightInKg);
    }
}</code></pre> 
<div> 
 <p style="margin-left:0;text-align:left;"></p> 
</div> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">我们只需将多行包装到一个断言作用域中，以确保执行所有验证（因为这些是同一作用域的一部分）。但是，提到的第一个问题是行数。这只会使情况变得更糟。</span></span></p> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">因此，我们需要进一步寻找解决这两个问题的真正解决方案。这里有一个解决方案：使用值元组。</span></span></p> 
<pre><code class="language-cs">[Theory]
[InlineData(70.01, 180, 1.80, 21.61)]
public void ValueTupleTest(decimal weightInKg, int lengthInCm, 
                           decimal expectedLengthInM, decimal expectedBmi)
{
    var instance = new HealthDescription(weightInKg, lengthInCm);
    (instance.LengthInM, instance.Bmi, instance.WeightInKg).Should()
        .Be((expectedLengthInM, expectedBmi, weightInKg));
}</code></pre> 
<div> 
 <p style="margin-left:0;text-align:left;"></p> 
</div> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">此代码背后的思想是将要验证的属性包装到一个对象中。然后，只需要一个验证（行）。此外，还有一个额外的解决方案，即将</span><span style="color:#111111;"> <a href="https://github.com/fluentassertions/fluentassertions.json" title="FluentAssertions.Json">FluentAssertions.Json</a> </span><span style="color:#111111;">与</span><span style="color:#111111;"><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/#raw-string-literals" rel="nofollow" title="文本字符串">文本字符串</a></span><span style="color:#111111;">组合在一起。这样，具有要验证的属性的</span><span style="color:#111111;">json</span><span style="color:#111111;">对象就会被验证为一个对象。</span></span></p> 
<pre><code class="language-cs">[Theory]
[InlineData(70.01, 180, """
                        {
                        "Bmi" : 21.61,
                        "WeightInKg": 70.01,
                        "LengthInM" : 1.80 
                        }
                        """)]
public void RegularJsonTest(decimal weightInKg, int lengthInCm, string expectedResult)
{
    var instance = new HealthDescription(weightInKg, lengthInCm);
    JToken.FromObject(instance).Should().BeEquivalentTo(JToken.Parse(expectedResult));
}</code></pre> 
<div> 
 <p style="margin-left:0;text-align:left;"></p> 
</div> 
<h2 id="%E5%85%B4%E8%B6%A3%E7%82%B9" style="margin-left:0px;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#ff9900;">兴趣点</span></span></h2> 
<p style="margin-left:0;text-align:left;"><span style="background-color:#FFFFFF;"><span style="color:#111111;">在研究如何进行多个断言的可能性时，我发现很多人一直在使用他们多年来一直使用的方式。由于这些方法仍然有效，他们继续使用它。但是，最近添加的</span><span style="color:#111111;">C#</span><span style="color:#111111;">功能为以更有效的方式解决同一问题创造了新的可能性。本文中使用的源代码可以</span><span style="color:#000000;"><a href="https://github.com/ConnectingApps/FluentAssertionsDemo" title="在这里">在这里</a></span><span style="color:#111111;">找到。</span></span></p> 
<p style="margin-left:0;text-align:justify;"><a class="link-info" href="https://www.codeproject.com/Tips/5366616/How-to-do-Multiple-Assertions-with-Fluent-Assertio" rel="nofollow" title="https://www.codeproject.com/Tips/5366616/How-to-do-Multiple-Assertions-with-Fluent-Assertio">https://www.codeproject.com/Tips/5366616/How-to-do-Multiple-Assertions-with-Fluent-Assertio</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f93a9bf868cc852c4f29447e813064bc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">利用百度竞价排名推广增加转化率-华媒舍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26a63c8db0b460144fc284f413d4ccc0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp实现点击标签文本域中显示标签内容</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>