<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ip校验和 及 udp校验和 的计算方法 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ip校验和 及 udp校验和 的计算方法" />
<meta property="og:description" content="一、ip校验和的计算:
计算方法:
1. ip包头(共20个字节)按照每16个bit作为一个值依次进行相加
2. 将计算结果的进位加到低16位上
3. 将结果取反
ip包头的内存内容
eg:
45 00 00 20 0F B8 00 00
80 11 00 00 C0 A8 0A 9F
C0 A8 0A C7
将 0x4500 0x0020 0x0FB8 0x0000 0x8011 0x0000 0xC0A8 0x0A9F 0xC0A8 0x0AC7 依次相加 所得结果为0x26B9F 然后将 0x0002 &#43; 0x6B9F = 0x6BA1
然后将 0x6BA1 取反得 0x945E
要注意两点:
1 在给ip_header计算校验和之前 首先把ip_header的checksum字段置为0 2 计算得到checksum之后 赋值时要转换为网络字节序: ip_header.checksum = htons(checksum); struct ip_header //小端模式__LITTLE_ENDIAN { unsigned char ihl:4; //ip header length unsigned char version:4; //version u_char tos; //type of service u_short tot_len; //total length u_short id; //identification u_short frag_off; //fragment offset u_char ttl; //time to live u_char protocol; //protocol type u_short check; //check sum u_int saddr; //source address u_int daddr; //destination address }; // 计算ip数据包的checksum // 将20个字节的ip数据包每16位组成一个字 依次相加 设所得结果为 0x34ACE // 将 进位的3与 0x4ACE相加 得 0x4AD1 // 将 0x4AD1取反得到checksum u_short get_ip_checksum(char* ip_hdr) { char * pkt = ip_hdr; u_long checksum = 0; u_long sum = 0; for (int i = 0; i &lt; 20; i &#43;= 2) sum &#43;= ((pkt[i] &lt;&lt; 8) &amp; 0xFF00) | pkt[i&#43;1]; checksum = (sum &amp; 0x0000FFFF) &#43; (sum &gt;&gt; 16); checksum &#43;= (checksum &gt;&gt; 16); return (u_short)~checksum; } 二、udp校验和" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/950538aaa866c6df1da44ebb8880d1e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-15T11:06:06+08:00" />
<meta property="article:modified_time" content="2022-06-15T11:06:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ip校验和 及 udp校验和 的计算方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong>一、ip校验和的计算:</strong><br> 计算方法:<br> 1. ip包头(共20个字节)按照每16个bit作为一个值依次进行相加<br> 2. 将计算结果的进位加到低16位上<br> 3. 将结果取反<br> ip包头的内存内容<br> eg:<br> 45 00 00 20 0F B8 00 00<br> 80 11 00 00 C0 A8 0A 9F<br> C0 A8 0A C7</p> 
<p>将 0x4500 0x0020 0x0FB8 0x0000 0x8011 0x0000 0xC0A8 0x0A9F 0xC0A8 0x0AC7 依次相加 所得结果为0x26B9F 然后将 0x0002 + 0x6B9F = 0x6BA1<br> 然后将 0x6BA1 取反得 0x945E</p> 
<p>要注意两点:</p> 
<pre><code>1 在给ip_header计算校验和之前   首先把ip_header的checksum字段置为0
2 计算得到checksum之后   赋值时要转换为网络字节序:
  ip_header.checksum = htons(checksum); 

struct ip_header  //小端模式__LITTLE_ENDIAN  
{   
    unsigned char ihl:4;       //ip   header   length      
    unsigned char version:4;   //version     
    u_char        tos;         //type   of   service     
    u_short       tot_len;     //total   length     
    u_short       id;          //identification     
    u_short       frag_off;    //fragment   offset     
    u_char        ttl;         //time   to   live     
    u_char        protocol;    //protocol   type     
    u_short       check;       //check   sum     
    u_int         saddr;       //source   address     
    u_int         daddr;       //destination   address     
};  

// 计算ip数据包的checksum
// 将20个字节的ip数据包每16位组成一个字  依次相加  设所得结果为 0x34ACE
// 将 进位的3与 0x4ACE相加   得  0x4AD1
// 将 0x4AD1取反得到checksum
u_short get_ip_checksum(char* ip_hdr)
{
    char * pkt = ip_hdr;
    u_long checksum = 0;
    u_long sum = 0;
    for (int i = 0; i &lt; 20; i += 2) 
        sum += ((pkt[i] &lt;&lt; 8) &amp; 0xFF00) | pkt[i+1];
    checksum = (sum &amp; 0x0000FFFF) + (sum &gt;&gt; 16);
    checksum += (checksum &gt;&gt; 16);
    return (u_short)~checksum;
}
</code></pre> 
<p><strong>二、udp校验和</strong></p> 
<pre><code>
// udp的checksum计算是用到的结构体
// udp中, 参与计算checksum的数据包括三部分: 亚头部 + UDP头部 + 数据部分
// 亚头部: 4 byte源ip地址 + 4 byte目的ip地址 + 0x00 + 1 byte协议 + UDP 长度(2byte)(udp包头长度+数据长度)
// UDP包头: 2 byte源端口 + 2 byte目的端口 + 2 byte UDP包长(此处是udp包头自带的值不用变) + 0x0000 (checksum)
// 数据部分
// 计算方法同get_ip_checksum一样
typedef struct udp_check_subhdr         // udp计算checksum时的 亚头部: 4 byte源ip地址 + 4 

byte目的ip地址 + 0x00 + 1 byte协议 + UDP 长度(2byte)
{
    u_long   src_ip; 
    u_long   dst_ip; 
    char     mbz;           // must be zero
    char     protocol; 
    u_short  len;           // 这里的长度是指  udp packet中  udp头部和数据部分的总长度
} udp_check_subhdr;


// pudp_pkt: udp的整个packet
// pkt_len: 整个packet的长度(以太网数据帧头 ip头 udp头)
u_short get_udp_checksum(char* pudp_pkt, int pkt_len) 
{
    ether_header *eth_hdr = (ether_header *)pudp_pkt; 
    ip_header    *ip_hdr  = (ip_header*)( pudp_pkt+sizeof(ether_header) ); 
    udphdr       *udp_hdr = (udphdr*)( (char*)ip_hdr+sizeof(ip_header) ); 

    u_short udp_part_len = pkt_len-sizeof(ether_header)-sizeof(ip_header);    // 亚包头中的len: =udp包头长度+数据长度(udp包总长度-ethernet包头长度-ip包头长度); 

    udp_check_subhdr udp_subhdr; 
    udp_subhdr.protocol = ip_hdr-&gt;protocol; 
    udp_subhdr.dst_ip = ip_hdr-&gt;daddr; 
    udp_subhdr.src_ip = ip_hdr-&gt;saddr; 
    udp_subhdr.mbz = 0x00; 
    udp_subhdr.len = htons(udp_part_len); 

    int subhdr_len = sizeof(udp_check_subhdr); 
    int buf_size = udp_part_len + subhdr_len;         // 亚包头 + udp包头 + 数据部分的总长度
    if (pkt_len &lt; buf_size)
        return 0; 
    u_char* buffer = (u_char*)malloc(buf_size); 
    memset(buffer, 0x00, buf_size); 

    memcpy(buffer, (char*)&amp;udp_subhdr, subhdr_len); 
    memcpy(buffer + subhdr_len, (char*)udp_hdr, udp_part_len); 


    unsigned char* ptr_data = buffer; 
    u_long  tmp = 0; 
    u_long  sum = 0; 
    for (int i=0; i&lt;buf_size; i+=2)
    {
        tmp += (u_char)ptr_data[i] &lt;&lt; 8; 
        tmp += (u_char)ptr_data[i+1]; 
        sum += tmp; 
        tmp = 0; 
    }
    ptr_data = NULL;
    free(buffer);
    
    u_long checksum = (sum &amp; 0x0000FFFF) + sum &gt;&gt; 16; 
    checksum += (checksum &gt;&gt; 16);
    return (u_short)~checksum;  
}

</code></pre> 
<p><strong>最后:</strong> ip校验和还有udp校验和的查看是在接收端查看的,从源端查看是没有计算的值(ip校验和是0x00 udp校验和不清楚什么意义) 用pcap发送自定义数据包时 调用pcap_sendpacket时是直接发送定义好的数据包 就是将定义好的包直接通过网卡发送 不会经过电脑上的ip层和链路层 所以 校验和要自己计算</p> 
<p>从两个网页处学到计算方法:<br> http://www.360doc.com/content/12/0511/15/621500_210332306.shtml<br> http://blog.csdn.net/maeom/article/details/6065203</p> 
<p>*注: 仅作为笔记之用 如有错误或不妥之处还望指正。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/11ce7326afe912f28f8135f82a4c1aa7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker 安装redis集群配置3主3从，实现hash槽分配存储数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/134a5dfadf478c06c40f5620dc118f94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu18.04安装部署openvion</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>