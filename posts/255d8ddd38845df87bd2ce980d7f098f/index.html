<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>flink （一） - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="flink （一）" />
<meta property="og:description" content="随着互联网的不断发展，行业内对于数据的处理能力和计算的实时性要求都在不断增加，随之而来的是计算框架的升级。经过了十余年开源社区的不断演进，现在计算框架已经从第一代的雅虎开源的Hadoop体系进化到目前主流的Spark框架，这两套框架的计算主要是从强依赖硬盘存储能力的计算发展到了内存计算，大大增强了计算力。随着5G时代的到来，未来都将会是万物互联，各种各样的设备都会与网络连接起来，会有大量的数据产生。以后这些数据都将需要做实时分析，下一代计算引擎，也就是第三代计算引擎，将会从计算实时性的角度突破，也就是Flink框架。
1.什么是 Flink Apache Flink 是一个分布式大数据处理引擎，可对1.有限数据流和2.无线数据流进行有状态计算。可部署在各种集群环境，对各种大小的数据规模进行快速计算。
名词解释：
有限数据流：即数据已经产生，数据大小已经确定。数据有限，可以做离线计算；无限数据流：即数据流一旦产生，不知道什么时候结束。比如：数据实时写入到Kafka。数据无限，可以做实时计算。 1.1.Flink设计初衷 Flink 设计之初，就是为实时计算而设计的。但是因为其计算引擎过于强大，所以也可以做离线计算。它可以部署在各种各样的集群中，比如 Flink自己的 standalone 集群，flink on yarn部署，Flink 还可以跑在K8S上，Flink 还可以跑在各种各样的集群上。Flink为了开发测试比较方便，还可以使用单机模式。可以对各种大小规模的数据进行快速计算。特点就是：快。
2.Flink特点 批流统一支持高吞吐、低延迟、高性能的流处支持带有事件事件的窗口（Window）操作支持有状态计算的 Exactly-once 语义支持高度灵活的窗口（Window）操作，支持基于 time、count、session 窗口操作支持具有 Backpressure 功能的持续流模型支持基于轻量级分布式快照（Snapshot）实现的容错支持迭代计算Flink 在 JVM内部实现了自己的内存管理支持程序自动优化：避免特定情况下 Shuffle、排序等昂贵操作，中间结果有必要进行缓存。 3.Flink 与其他框架的对比 框架优点缺点Storm低延迟吞吐量第一、不能保证 exactly-once、编程 API 不丰富Spark Streaming吞吐量高、可以保证 exactly-once、编程 API 丰富延迟较高Storm低延迟、吞吐量高、可以保证 exactly-once、编程API丰富(具有Storm&#43;Spark优势)快速迭代中，API 变化比较快 Spark Spark 就是为离线计算而设计的，在Spark生态体系中，不论是流处理还是批处理，底层引擎都是Spark Core。Spark Streaming 将微批次小任务不停地提交到 Spark 引擎，从而实现准实时计算，Spark Streaming 只不过是一种特殊的批处理而已。
Flink Flink 就是为实时计算而设计的，Flink 可以同时实现批处理和流处理，Flink 将批处理（即有界数据/离线处理）视作一种特殊的流处理。
Flink 部署，可以使用本地Local模式，也可以使用Cluster集群模式(可以部署 standalone，yarn上，也可以部署在cloud 云上)。
4.Flink 架构体系简介 Flink 真正用来做执行操作的，叫做 Worker。进程在不同的环境模式下运行，进程名称不同。如：使用 Standalone集群模式启动，JobManager 叫做 StandaloneSessionClusterEntrypoint，TaskManager叫做 TaskManagerRunner,使用 yarn 集群启动，进程名称又会有所不同。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/255d8ddd38845df87bd2ce980d7f098f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-08T21:06:50+08:00" />
<meta property="article:modified_time" content="2021-12-08T21:06:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">flink （一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>随着互联网的不断发展，行业内对于数据的处理能力和计算的实时性要求都在不断增加，随之而来的是计算框架的升级。经过了十余年开源社区的不断演进，现在计算框架已经从第一代的雅虎开源的Hadoop体系进化到目前主流的Spark框架，这两套框架的计算主要是从强依赖硬盘存储能力的计算发展到了内存计算，大大增强了计算力。随着5G时代的到来，未来都将会是万物互联，各种各样的设备都会与网络连接起来，会有大量的数据产生。以后这些数据都将需要做实时分析，下一代计算引擎，也就是第三代计算引擎，将会从计算实时性的角度突破，也就是Flink框架。</p> 
<h2>1.什么是 Flink</h2> 
<p>       Apache Flink 是一个<code><strong>分布式大数据处理引擎</strong></code>，可对<code><strong>1.有限数据流</strong></code>和<code><strong>2.无线数据流</strong></code>进行有状态计算。可部署在各种集群环境，对各种大小的数据规模进行快速计算。</p> 
<p style="text-align:center;"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a9/c3/YQHwamNL_o.png"></p> 
<p></p> 
<p><strong>名词解释：</strong></p> 
<ol><li><code><strong>有限数据流</strong></code>：即数据已经产生，数据大小已经确定。数据有限，可以做离线计算；</li><li><code><strong>无限数据流</strong></code>：即数据流一旦产生，不知道什么时候结束。比如：数据实时写入到Kafka。数据无限，可以做实时计算。</li></ol> 
<h3>1.1.Flink设计初衷</h3> 
<p>       Flink 设计之初，就是为实时计算而设计的。但是因为其计算引擎过于强大，所以也可以做离线计算。它可以部署在各种各样的集群中，比如 <code>Flink自己的 standalone 集群</code>，<code>flink on yarn部署</code>，Flink 还可以跑在<code>K8S</code>上，Flink 还可以跑在各种各样的集群上。Flink为了开发测试比较方便，还可以使用<code><strong>单机模式</strong></code>。可以对各种大小规模的数据进行快速计算。特点就是：快。</p> 
<h2></h2> 
<h2>2.Flink特点</h2> 
<ul><li>批流统一</li><li>支持高吞吐、低延迟、高性能的流处</li><li>支持带有事件事件的窗口（Window）操作</li><li>支持有状态计算的 Exactly-once 语义</li><li>支持高度灵活的窗口（Window）操作，支持基于 time、count、session 窗口操作</li><li>支持具有 Backpressure 功能的持续流模型</li><li>支持基于轻量级分布式快照（Snapshot）实现的容错</li><li>支持迭代计算</li><li>Flink 在 JVM内部实现了自己的内存管理</li><li>支持程序自动优化：避免特定情况下 Shuffle、排序等昂贵操作，中间结果有必要进行缓存。</li></ul> 
<h2></h2> 
<h2>3.Flink 与其他框架的对比</h2> 
<table><thead><tr><th>框架</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Storm</td><td>低延迟</td><td>吞吐量第一、不能保证 exactly-once、编程 API 不丰富</td></tr><tr><td>Spark Streaming</td><td>吞吐量高、可以保证 exactly-once、编程 API 丰富</td><td>延迟较高</td></tr><tr><td>Storm</td><td>低延迟、吞吐量高、可以保证 exactly-once、编程API丰富(具有Storm+Spark优势)</td><td>快速迭代中，API 变化比较快</td></tr></tbody></table> 
<p></p> 
<p style="text-align:center;"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/9d/ea/RS4Wigrr_o.png"></p> 
<p></p> 
<h3>Spark</h3> 
<p>        <code><strong>Spark 就是为离线计算而设计的</strong></code>，在Spark生态体系中，不论是<code>流处理</code>还是<code>批处理</code>，底层引擎都是<code><strong>Spark Core</strong></code>。Spark Streaming 将微批次小任务不停地提交到 Spark 引擎，从而实现准实时计算，Spark Streaming 只不过是一种特殊的批处理而已。</p> 
<p style="text-align:center;"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d8/38/u28MO4oc_o.png"></p> 
<h3>Flink</h3> 
<p>        <code><strong>Flink 就是为实时计算而设计的</strong></code>，Flink 可以同时实现<code>批处理</code>和<code>流处理</code>，Flink 将批处理（即有界数据/离线处理）视作一种特殊的流处理。<br>         Flink 部署，可以使用<code><strong>本地Local模式</strong></code>，也可以使用<code><strong>Cluster集群模式</strong></code>(可以部署 standalone，yarn上，也可以部署在cloud 云上)。</p> 
<p></p> 
<p></p> 
<h2>4.Flink 架构体系简介</h2> 
<p style="text-align:center;"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a1/62/zSYAp3Pl_o.png"></p> 
<p><br>       Flink 真正用来做执行操作的，叫做 <code><strong>Worker</strong></code>。进程在不同的环境模式下运行，进程名称不同。<code><strong>如：使用 Standalone集群模式启动，JobManager 叫做 StandaloneSessionClusterEntrypoint，TaskManager叫做 TaskManagerRunner</strong></code>,使用 yarn 集群启动，进程名称又会有所不同。</p> 
<p><strong>JobManager介绍：</strong></p> 
<p>      也称之为 <code>Master</code>，用于协调分布式执行，它用来调度 Task，协调检查点，协调失败时恢复等。Flink 运行时至少存在一个 Master，如果配置高可用模式则会存在多个 Master，他们其中有一个是 Leader，而其他的都是 Standby。</p> 
<p><strong>TaskManager介绍：</strong></p> 
<p>       也称之为 <code>Worker</code>，用于执行一个 dataflow 的 Task、数据缓冲 和 Data Stream 的数据交换，Flink 运行时至少会存在一个 TaskManager。JobManager 和 TaskManager 可以直接运行在物理机上，或者运行在 yarn 这样的资源调度框架。TaskManager 通过网络连接到JobManager，通过 RPC 通信告知自身的可用性进而获得任务分配。</p> 
<p><strong>Flink架构流程介绍：</strong></p> 
<p>       用于工作的叫做 <code><strong>TaskManager</strong></code>（又叫：<code>Worker</code>）。TaskManager 里面以后运行着<code><strong>Task</strong></code>（又叫：<code>subTask</code>）。TaskSlot 中就会运行着真正计算的任务 Task。</p> 
<p>       TaskManager 相当于用来给 Task 提供执行环境。JobManager相当于是主节点，TaskManager相当于是从节点。JobManager用来负责管理，TaskManager用来负责执行具体的Task，他们之间也要通过网络进行RPC通信。RPC通信，底层使用的是Akka。 我们还会用到一个客户端。这个客户端用来提交任务(左图中的Client)。</p> 
<p>       客户端提交任务，首先会与 JobManager 进行通信。我们在本地写程序。程序中会构建成一个类似于 Spark 的 DAG(Flink 中叫做Dataflow graph)，将 Dataflow graph 提交到 JobManager。JobManager 会把这个Dataflow graph 切分成多个 Task。将 Task 调度到TaskManager中进行执行。(和Spark很相似)</p> 
<p>       使用客户端提交任务，①<code><strong>可以通过命令来提交</strong></code> ②<code><strong>也可以通过 Web 页面提交</strong></code>。</p> 
<p></p> 
<h2>5.Sprak 和 Flink角色对比</h2> 
<table><thead><tr><th>含义</th><th>Spark</th><th>Flink</th></tr></thead><tbody><tr><td>离散流</td><td>DStream</td><td>DataStream</td></tr><tr><td>算子</td><td>Transformation</td><td>Transformation</td></tr><tr><td>Action类算子(xxxx预留)</td><td>Action</td><td>Sink</td></tr><tr><td>任务</td><td>Task</td><td>SubTask</td></tr><tr><td>流水线</td><td>Pipeline</td><td>Oprator chains</td></tr><tr><td>有向无环图(Directed Acyclic Graph)</td><td>DAG</td><td>DataFlow Graph</td></tr><tr><td>xxxx预留</td><td>Master + Driver</td><td>JobManager</td></tr><tr><td>xxxx预留</td><td>Worker+ Executor</td><td>TaskManager</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9919e58fd9b098a9368233d419624d2f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【看课必备】MOOC C语言进阶——翁恺 链表笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55e9115b18949e8f54ac8863675c0e40/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021-12-8数字通信的过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>