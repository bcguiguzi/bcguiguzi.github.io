<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基类的指针 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基类的指针" />
<meta property="og:description" content="基类的指针指向它派生出来的子类实例时，可以用这个指针来操作这个子类实例。由于子类可以继承基类的成员函数和数据成员，因此这个指针可以访问基类和子类共有的成员函数和数据成员，但不能访问子类独有的成员函数和数据成员。
基类的指针的常见用法之一是在面向对象编程中实现多态。在多态中，基类的指针可用来访问派生类对象，使代码更灵活、通用、可扩展。通过使用指向基类的指针，可以让程序更具有可扩展性和维护性。
以下是一个简单的基类指针示例：
class Shape { public: virtual double area() const { return 0; } // 基类函数，可被子类覆盖 }; class Circle : public Shape { public: Circle(double r) : radius(r) {} virtual double area() const override { return 3.14*radius*radius; } // 子类覆盖了基类的area函数，实现了多态 private: double radius; }; class Rectangle : public Shape { public: Rectangle(double w, double h) : width(w), height(h) {} virtual double area() const override { return width*height; } // 子类覆盖了基类的area函数，实现了多态 private: double width; double height; }; int main() { Shape* shape1 = new Circle(5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/76c4af77562daa663d480dd0680101be/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-24T14:53:12+08:00" />
<meta property="article:modified_time" content="2023-05-24T14:53:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基类的指针</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>基类的指针指向它派生出来的子类实例时，可以用这个指针来操作这个子类实例。<span style="color:#ff9900;">由于子类可以继承基类的成员函数和数据成员，因此这个指针可以访问基类和子类共有的成员函数和数据成员，但不能访问子类独有的成员函数和数据成员。</span></p> 
<p>基类的指针的常见用法之一是在面向对象编程中实现多态。在多态中，基类的指针可用来访问派生类对象，使代码更灵活、通用、可扩展。通过使用指向基类的指针，可以让程序更具有可扩展性和维护性。</p> 
<p>以下是一个简单的基类指针示例：</p> 
<pre><code class="language-cpp">class Shape {
public:
    virtual double area() const { return 0; }  // 基类函数，可被子类覆盖
};

class Circle : public Shape {
public:
    Circle(double r) : radius(r) {}
    virtual double area() const override { return 3.14*radius*radius; }  // 子类覆盖了基类的area函数，实现了多态
private:
    double radius;
};

class Rectangle : public Shape {
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    virtual double area() const override { return width*height; }  // 子类覆盖了基类的area函数，实现了多态
private:
    double width;
    double height;
};

int main() {
    Shape* shape1 = new Circle(5.0);  // 基类指针可以指向派生类对象
    Shape* shape2 = new Rectangle(3.0, 4.0);
    std::cout &lt;&lt; "circle area = " &lt;&lt; shape1-&gt;area() &lt;&lt; std::endl;  // 输出 Circle::area()
    std::cout &lt;&lt; "rectangle area = " &lt;&lt; shape2-&gt;area() &lt;&lt; std::endl; // 输出 Rectangle::area()
    return 0;
}</code></pre> 
<p>在上面的示例代码中，定义了一个基类Shape和派生类Circle和Rectangle。基类Shape中包含了一个名为area的虚函数，可以被子类覆盖。在主函数中，首先使用基类指针shape1和shape2分别指向派生类的对象Circle和Rectangle。然后通过shape1-&gt;area()和shape2-&gt;area()调用基类Shape中的area虚函数，实现了多态。根据不同的实例类型，进行了不同的计算，最终输出圆的面积和矩形的面积。</p> 
<p>需要注意的是，基类指针在使用时需要注意记得用虚函数实现多态，即将基类函数声明为虚函数，并在派生类中进行正确的重载。否则，基类指针只能访问基类中的成员函数和数据成员，不能访问子类的成员函数和数据成员，失去多态性的优势。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ee52c000a5b1f96d461221ef049f545/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">QEMU CAN总线</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/56f777ab13e4befcebe3345b6e3b34c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Unity】(Socket)TCP 实现同一局域网 一台主机控制多台主机</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>