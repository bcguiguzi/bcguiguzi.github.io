<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>力扣由浅至深 每日一题.05 合并两个有序列表 - 编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="力扣由浅至深 每日一题.05 合并两个有序列表" />
<meta property="og:description" content="神明渡我，我将所有苦难都放过
—— 24.3.13
21. 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1：
输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2：
输入：l1 = [], l2 = [] 输出：[] 示例 3：
输入：l1 = [], l2 = [0] 输出：[0] 提示：
两个链表的节点数目范围是 [0, 50]-100 &lt;= Node.val &lt;= 100l1 和 l2 均按 非递减顺序 排列 方法一：递归
思路 我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：
也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。
算法 我们直接将以上递归过程建模，同时需要考虑边界情况。
如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。
class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bcguiguzi.github.io/posts/59c3fd6a7d1e0b0e33db86d8d7137532/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-13T21:34:25+08:00" />
<meta property="article:modified_time" content="2024-03-13T21:34:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">力扣由浅至深 每日一题.05 合并两个有序列表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><span style="color:#1a439c;"><strong>神明渡我，我将所有苦难都放过</strong></span></p> 
 <p><span style="color:#1a439c;"><strong>                               —— 24.3.13</strong></span></p> 
</blockquote> 
<h2><a href="https://leetcode.cn/problems/merge-two-sorted-lists/" rel="nofollow" title="21. 合并两个有序链表">21. 合并两个有序链表</a></h2> 
<blockquote> 
 <p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p> 
 <p><strong>示例 1：</strong></p> 
 <p class="img-center"><img alt="" height="302" src="https://images2.imgbox.com/ad/dc/ZU6MThFD_o.jpg" width="662"></p> 
 <pre><strong>输入：</strong>l1 = [1,2,4], l2 = [1,3,4]
<strong>输出：</strong>[1,1,2,3,4,4]
</pre> 
 <p><strong>示例 2：</strong></p> 
 <pre><strong>输入：</strong>l1 = [], l2 = []
<strong>输出：</strong>[]
</pre> 
 <p><strong>示例 3：</strong></p> 
 <pre><strong>输入：</strong>l1 = [], l2 = [0]
<strong>输出：</strong>[0]
</pre> 
 <p><strong>提示：</strong></p> 
 <ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul> 
</blockquote> 
<h3>方法一：递归<br> 思路</h3> 
<blockquote> 
 <p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：</p> 
 <p><img alt="" height="49" src="https://images2.imgbox.com/ba/a8/2UNe7rfP_o.png" width="457"><br>  <br> 也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</p> 
</blockquote> 
<h4>算法</h4> 
<blockquote> 
 <p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p> 
 <p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) {
            return l2;
        } else if (l2 == null) {
            return l1;
        } else if (l1.val &lt; l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}</code></pre> 
<h4>复杂度分析</h4> 
<blockquote> 
 <p>时间复杂度：O(n+m)O(n + m)O(n+m)，其中 nnn 和 mmm 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 O(n+m)O(n+m)O(n+m)。</p> 
 <p>空间复杂度：O(n+m)O(n + m)O(n+m)，其中 nnn 和 mmm 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+mn+mn+m 次，因此空间复杂度为 O(n+m)O(n+m)O(n+m)。</p> 
</blockquote> 
<h3>方法二：迭代<br> 思路</h3> 
<blockquote> 
 <p>我们可以用迭代的方法来实现上述算法。当 l1 和 l2 都不是空链表时，判断 l1 和 l2 哪一个链表的头节点的值更小，将较小值的节点添加到结果里，当一个节点被添加到结果里之后，将对应链表中的节点向后移一位。</p> 
</blockquote> 
<h4>算法</h4> 
<blockquote> 
 <p>首先，我们设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前节点的值小于等于 l2 ，我们就把 l1 当前的节点接在 prev 节点的后面同时将 l1 指针往后移一位。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都需要把 prev 向后移一位。</p> 
 <p>在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表即可。</p> 
</blockquote> 
<pre><code class="language-java">class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode(-1);

        ListNode prev = prehead;
        while (l1 != null &amp;&amp; l2 != null) {
            if (l1.val &lt;= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;

        return prehead.next;
    }
}
</code></pre> 
<h4>复杂度分析</h4> 
<blockquote> 
 <p>时间复杂度：O(n+m)O(n + m)O(n+m)，其中 nnn 和 mmm 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)O(n+m)O(n+m)。</p> 
 <p>空间复杂度：O(1)O(1)O(1)。我们只需要常数的空间存放若干变量。</p> 
</blockquote> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f3ea5aac8bfcd67635ba28cd6c16e6e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HTML、CSS、JavaScript</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8481ffc174ae53a7d37b3b384d2c80b9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python脚本使用pyinstaller打包运行时，报get_handles OSError: [WinError 6] 句柄无效的解决方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>