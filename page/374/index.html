<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ebf66349216993b9d3f201d0a084f2/" rel="bookmark">
			数电之半加器全加器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、半加器 将两个1位二进制数相加，称为半加。
真值表 跟据真值表
写出方程： 根据表达式画出逻辑图 如果是用与非门搭电路 则将表达式化为与非形式
S=A'B+AB'=(A'B+AB')''=(A'B)'(AB')' (非门可以将与非门的两个输入端连接)
二、全加器 在将两个多位二进制数相加时，除了最低位以外，每一位都应该考虑来自低位的进位，即将两个对应位的加数和来自低位的进位3个数相加。这种运算称为全加，所用的电路称为全加器。
真值表 表达式： S=A'BCI'+AB'CI'+A'B'CI+ABCI
与非表达式:S=(A'BCI'+AB'CI'+A'B'CI+ABCI)''=((A'BCI')'(AB'CI')'(A'B'CI)'(ABCI)')'
再按与非门搭电路就行了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69fba2dac20a2cf50f094e61b9fc1e67/" rel="bookmark">
			如何把自己的项目打包成第三方库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		把自己写的项目打包成第三方库需要打三个包：
1：把自己的项目打包成 JAR(库)
2：把自己的项目打包出源码JAR
3：把自己的项目打包出帮助文档JAR
以maven项目为例：
1.首先 创建maven项目。
2.在src/main/java中创建包在创建Testing.java,在main方法中输出hello,在开头添加文档注释
3.右键点击mvn项目 Run as-&gt;Maven build.在Goals中输入 package指令，在该项目的target文件夹下查看打包的jar包
4.复制jar包，粘贴在需要该jar包的项目中(这里用java项目)，并右键点击jar包选择Build path -&gt;add to Build path.
5.在这个项目中就可以调用maven项目中的方法等。可以调用，但是不能查看源码文档等
6.查看源码文档需要把maven项目的源码文档都打包
7.Windows+r 输入cmd 切换到maven项目的目录，运行mvn source:jar 和 mvn javadoc:jar打包出源码和帮助文档，在target文件夹中
8.点击Java项目alt+enter打开属性 在java Build Path-&gt;Libraries-&gt;刚添加的jar包，编辑Source attachment 和 javadoc location。( Source-&gt;External File… javadoc -&gt; javadoc in archive -&gt; Archive path) 选中源码和帮助文档的jar包。在调用maven项目的方法时就可看到源码和文档了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac7ba53650cc0c5e28683ab9a5556fd/" rel="bookmark">
			JAVAEE分布式开发——Java概述与环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVAEE分布式开发——Java概述与环境搭建 Java语言特点：计算机执行机制：java执行机制：标识符命名：约定俗成：类的阐述名词解释dir查看目录下的文件文件夹 del删除文件 rd删除文件夹安装配置工作空间： Java语言特点： ​ 面向对象（贴近人类思维模式，模拟现实世界，解决现实问题）
​ 简单性（自动内存管理机制，不易造成内存溢出，简化流程处理，语义清晰）
​ 跨平台（操作系统，服务器等）
计算机执行机制： ​ 编译执行：将源文件编译成平台相关的码文件，一次编译，多次执行。执行效率高，不可跨平台
​ 解释执行：奖源文件交给不同平台独有的解释器。执行效率低，可跨平台。
java执行机制： ​ 先编译，后执行：将源文件编译成平台中立字节码文件(.class)，再将字节码文件进行解释执行
Javac HelloWorld.java 把文件编译为字节码文件 .class 再Java HelloWorld执行；
标识符命名： ​ 可以由字母、数字、_ $组成，但不能以数字开头。
​ 不能与关键字、保留字重名。
约定俗成： ​ 望文生义、见名知义。
​ 类名由一个或多个单词组成，每个单词首字母大写。
​ 函数名、变量名由一个或多个单词组成，首单词首字母小写，拼接词首字母大写。
​ 包名全小写，只可以使用特殊字符杉 “.” 。 并且不以 “.” 开头或结尾。
​ 常量全大写，多个单词用 _拼接。
错误：
编译错误；自己解决，不能百度
运行错误；java开头的错误。自己解决，其他结合经验解决
逻辑错误；运行结果与自己想要的不符。调试J解决
类的阐述 ​ 同一个源文件中可以定义多个类。
​ 编译后，每个类都会生成独立的.class文件。
​ 一个类中，只能有一个主方法，每个类都可以有自己的主方法。
​ public修饰的类称为公开类，要求类名必须与文件名称完全相同，包括大小写。
​ 一个源文件中，只能有一个公开类。
包名： 域名.公司/项目.模块/层。。 （纯小写，用 . 隔开）
带包编译: javac -d .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac7ba53650cc0c5e28683ab9a5556fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cdf5c086a5e6e5ac274b4116509522a/" rel="bookmark">
			简单聊聊Betaflight的三种飞行模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大概查了一下网上介绍Betaflight飞行模式的文章很多，讲了很多很全面，但这里我们去粗取精，只谈常用的三种模式Angle，Horizon和Acro模式。
下面的内容全部翻译自这个英文网站
1.Angle和Horizon模式 当使用Angle和Horizon模式时，我们的多旋翼会通过使用加速度计和陀螺仪来保持自稳，自问模式对新手来说很好飞。
在Horizon模式下你可以翻滚（我的理解是类似于固定翼的筋斗）、滚转（副翼方向）。因为限制了倾斜角度为45°，所以你在Angle模式下无法做到上述动作，这是Angle和Horizon模式的唯一区别之处。
2.Acro模式 然而，对于花飞和竞速飞行来说，Acro模式是最终模式。我强烈建议新手尽早开始练习这个模式。
我有一篇文章来讨论为什么你要练习Acro模式。（注：原英文作者文章，后面有机会我会翻译）
Acro模式在哪？
你可能会注意到Acro模式在模式栏中找不到。那是因为Acro模式在你解锁飞机后就自动启动了。当诸如Angle和Horizon模式被激活时，它会被它们所取代。
Angle和Horizon模式不见了？
如果Angle和Horizon模式在模式栏中不见了，这是因为在Betaflight中加速度计被禁用了。有些人禁用加速度计是因为他们只飞Acro模式，通过禁用加速度计可以降低处理器负载。在“配置”选项卡中启用/禁用加速度计的复选框。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93d385a5f6ae6d984af4500b852b8978/" rel="bookmark">
			OpenMMLab重磅升级！为计算机视觉不同方向建立的统一代码库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注“迈微AI研习社”，内容首发于公众号
来源｜陈恺@知乎，https://zhuanlan.zhihu.com/p/160966882
7 月 10 号 OpenMMLab 在 WAIC 2020 世界人工智能大会上发布了重磅升级，给大家带来了更丰富的 OpenMMLab 大礼包，1 个架构，10+ 个研究方向，100+ 种算法，600+ 预训练模型，是深度学习时代最完整的计算机视觉算法开源体系。
总体介绍 链接：https://open-mmlab.github.io/
从2018年年中开始，MMLab 和商汤科技就联合启动了 OpenMMLab 计划，为计算机视觉的不同方向建立统一而开放的代码库。这两年内，我们陆续开源了多个算法框架，包括：
MMDetection（物体检测）：在一个统一而灵活的架构上，高效实现了20多种典型检测算法。(https://github.com/open-mmlab/mmdetection)
MMAction（行为理解）：支持视频行为理解中的动作识别、时序检测、和时空检测等多种基本任务，复现了多种流行的算法，并支持常见的各种数据集。(https://github.com/open-mmlab/mmaction)
MMSkeleton（基于人体骨骼的理解）：以人体骨骼为核心的视频理解框架，基于时空图模型（ST-GCN）支持行为理解、姿态估计、动作生成等任务。(https://github.com/open-mmlab/mmskeleton)
MMSR（图像与视频超分辨率）：在统一的架构上，实现了一系列先进的超分辨率算法。
MMFashion（时尚分析）：专注于时尚服饰领域的视觉分析，覆盖识别、检索、属性预测、检测、分割、推荐等主流任务。(https://github.com/open-mmlab/mmfashion)
这些框架为学术社区提供了丰富而高质量的算法实现，开创了 OpenMMLab 的生态。
经过小伙伴们的加班加点，我们这个月初开源了 MMSegmentation、MMDetection3D、MMEditing、MMAction2、MMClassification、和 MMPose 这6个新的算法框架，并对 MMCV和 MMDetection 进行了全面更新。上述的这些框架都是基于 MMCV 的统一架构支持。它们在算法规模、训练效率和模型精度上都达到了开源社区的优秀水平，并且具有以下特性：
完善的文档和入门教程，丰富的代码注释，不再对着代码一头雾水
规范的开发流程，严谨的代码审核和单元测试，不再忍受 bug 缠身之痛
分布式训练框架，高效算子和逻辑实现，不再为跑不满的GPU干着急
有道是自从 star 了 OpenMMLab，一不愁算法复现挠秃头，二不愁从头造轮子几春秋，三不愁新方向框架难上手。
框架特点 MMCV（基础支持）
https://github.com/open-mmlab/mmcv
更完善的训练流程支持，文件读取多后端支持，图片处理多后端支持，更丰富的 CNN 模块，20 种常用算子的高效 CUDA 实现。
MMDetection（目标检测）
https://github.com/open-mmlab/mmdetection
支持算法多达 40 个，300+ 预训练模型，速度和精度相比 1.0 版本有很大提升。通过更细粒度的模块化设计，MMDetection 的任务拓展性大大增强，成为了检测相关项目的基础平台。
MMSegmentation（语义分割）
https://github.com/open-mmlab/mmsegmentation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93d385a5f6ae6d984af4500b852b8978/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f01dbf720a60f06e9de001cb1e472e3d/" rel="bookmark">
			Apollo启动报Config service failed to start in 120 seconds! Please check ./service/apollo-ser
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 阿波罗启动不起来，一直报错：Config service failed to start in 120 seconds! Please check ./service/apollo-ser
解决方案：延长启动时间 改成600s
修改demo.sh
declare -i max_counter=120 # 120*5=600s 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ca95471e77f39ed158a18e6252ebc2/" rel="bookmark">
			解决已安装opencv后还是不能识别cv2的问题：ModuleNotFoundError: No module named ‘cv2‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux环境下python3.6安装了opencv后报No moudle named ‘cv2’，百度大多解决方法是pip install opencv-python我就是这样安装的opencv但还是不能识别试了好久才找到解决方法
conda install opencv 原因是pip安装可能安装的包漏了，用conda在安装一边就ok了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0819783ec8619186aa2b0a11560729f/" rel="bookmark">
			三种基本排序（直接插入，直接选择，直接交换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：直接插入排序
将一串数分成两部分，前部分是已经排序好的，后部分是未排序的。
开始将第一个数作为已排序的第一个数，未排序数在已排序中找插入的位置即完成排序。
for (i = 1; i &lt; count; i++) { tmp = data[i]; for (j = 0; j &lt; i &amp;&amp; tmp &gt;= data[j]; j++) { } for (t = i; t &gt; j; t--) { data[t] = data[t - 1]; } data[j] = tmp; }	从第二个元素开始，在已排序部分找到插入位置后，将其后数后移，再插入
二：直接选择排序
开始假设第一个数为最小数，遍历一次数组寻找最小数。
遍历一次后将最小数和未排序部分第一个元素交换位置。
for (i = 0; i &lt; count - 1; i++) { minIndex = i; for (j = i; j &lt; count; j++) { if (data[j] &lt; data[minIndex]) { minIndex = j; } } if (minIndex !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0819783ec8619186aa2b0a11560729f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/083b3c5b98d3cfa4b56bb66891406039/" rel="bookmark">
			Mybatis generator的简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例环境:Eclipse+Springboot+Mybatis+Mysql
一，pom.xml引入相关依赖
&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt; &lt;/dependency&gt; 二，测试数据库表
CREATE TABLE `m_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `sex` varchar(5) DEFAULT NULL, `address` varchar(100) DEFAULT NULL, `birthday` datetime NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; CREATE TABLE `student` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(200) COLLATE utf8_bin DEFAULT NULL, `age` tinyint(3) unsigned DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_bin; 三，数据库连接配置(application.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/083b3c5b98d3cfa4b56bb66891406039/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9fd1d1918b5d3a77dd1e840e54f601e/" rel="bookmark">
			动手学机器学习(第二版) 第三章分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三章 分类 import numpy as np 本章使用MNIST数据集，该数据集包含70,000张由美国的高中生和人口调查局手写数字的图像，使用Scikit-Learn提供的函数可以很方便第下载这些数据集
from sklearn.datasets import fetch_openml mnist = fetch_openml('mnist_784', version=1) mnist.keys() dict_keys(['data', 'target', 'frame', 'categories', 'feature_names', 'target_names', 'DESCR', 'details', 'url']) 由Scikit-Learn下载的数据集通常有相似的数据结构：
DESCR: 描述数据集的基本信息data: 每个实例用一行数组表示，每列表示一个特征target: 包含标签的数组 X, y = mnist["data"], mnist["target"] X.shape (70000, 784) y.shape (70000,) 总共有70,000张图片，每张图片有784个特征。这是因为每一张图片是 28 × 28 28\times28 28×28 的分辨率，每个特征简单的代表像素点的强度，从0(白)到255(黑)。查看数据集中的手写数字，只需要选择实例的一个特征向量，然后将其重新变为 28 × 28 28\times28 28×28 的数组，再用Matplotlib’s imshow()函数画图显示
import matplotlib as mpl import matplotlib.pyplot as plt import random # 随机选择一张图片 # random_ind = random.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9fd1d1918b5d3a77dd1e840e54f601e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1614b162f3e471f1f3f60a6d0d7b5a41/" rel="bookmark">
			激光SLAM之NDT算法（2）-建图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近的项目里用到了室外激光SLAM进行定位，所以我总结一下项目经验，顺便根据项目最终效果说一下自己对于算法源码中这段代码的理解。
首先，算法框架中用到了不止一种传感器，包括IMU，odometry和GPS等。所有的传感器数据都是为了能构造一个合理且较好的激光里程计。
这段代码很好理解，我大致讲一下流程吧，首先当第一帧点云输入时，我们构造一个位姿向量，x=0,y=0,z=0，旋转角初始化为0，存入map)中,并将其设置为ndt的target参数。当第二针点云进来时，进行点云匹配得到这堆点云的位姿（以lidar为坐标系），由于设置有shift值来判断这帧点云是否距上一帧点云位移了1m，所以我们会根据得到的位姿进行计算，如果小于1m,丢弃，用下一帧点云重复这个过程，如果大于1m，则存入map,并重置它为ndt的target参数，以此类推 ，对下一帧点云重复这个动作。代码如下：
void ndt_mapping::points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input) { pcl::PointCloud&lt;pcl::PointXYZI&gt; tmp, scan; pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;()); pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;()); tf::Quaternion q; Eigen::Matrix4f t_localizer(Eigen::Matrix4f::Identity()); Eigen::Matrix4f t_base_link(Eigen::Matrix4f::Identity()); //static tf::TransformBroadcaster br; tf::Transform transform; pcl::fromROSMsg(*input, tmp); double r; Eigen::Vector3d point_pos; pcl::PointXYZI p; for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++) { if(use_imu_){ // deskew(TODO:inplement of predicting pose by imu) point_pos.x() = (double)item-&gt;x; point_pos.y() = (double)item-&gt;y; point_pos.z() = (double)item-&gt;z; double s = scan_rate_ * (double(item-&gt;intensity) - int(item-&gt;intensity)); point_pos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1614b162f3e471f1f3f60a6d0d7b5a41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd4e2bd4bf333f5221ffc09ace1cc05/" rel="bookmark">
			jquery ajax返回值result接收解析，以及javascript与jquery传递json格式/多个数据的方法，以及jquery，js post方法后，sendRedirect不跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们将input传递给服务器，除了使用form表单的post，还可以使用js或jquery
1.js传递json格式数据 传递一个参数，我们用
xhr.send("tel="+tel)这样的格式，但多个参数，就需要添加&amp;，但需要注意，这个&amp;要添加在下一个变量名的双引号中，而不是在外面。
xmlHttpRequsts.open("post","/login",true); //设置post方式的头信息 xmlHttpRequsts.setRequestHeader("Content-Type","application/x-www-form-urlencoded"); xmlHttpRequsts.send("tel="+tel+"&amp;password="+password); 2.jquery传递json jquery的传递方式与js相同，可以添加一个dataType声明
&lt;script type="text/javascript"&gt; function login() { var $tel = $("#inputPhone").val(); var $password = $("#inputPassword").val(); $.ajax({ url: "/login", type: "post", data: "tel=" + $tel + "&amp;password=" + $password, dataType: "JSON", success: function (result) { if (result === 1) { alert("登陆成功~"); } else if (result === 2) { alert("登陆失败！"); } } }); } &lt;/script&gt; 3.result接收返回值 先看我们servlet的返回值，我们根据数据库中是否有tel和密码组合判断是否登陆成功，然后返回给jsp进行操作，但发现result接收servlet中的返回值，但并不是接收字符串，在这方面调试了很久，比方说out数字，result的type会是num，out “true”，“false”，result会是布尔值而非字符
之前一直错写为,苦苦想了半天，结果就是不弹出，下面是错误写法
if (result === "true") { alert("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd4e2bd4bf333f5221ffc09ace1cc05/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a044ac57ab41ac0c8a968f96dcc742/" rel="bookmark">
			【unity基础】点乘和叉乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、点乘
定义：a*b=|a||b|cos&lt;a,b&gt;
几何意义：一条边向另一条边的投影乘以另一条边的长度
运算：x1*x2+y1*y2+z1*z2.结果是一个标量不是一个变量。
应用：
1、根据点乘计算两个向量的夹角
2、根据点乘的结果得到夹角的大小范围，判断某一个角色是在镜头前还是镜头后。如果点乘结果&gt;0 表示夹角是0-90度，是在镜头前，否则在镜头后。
3、根据点乘的结果判断两个向量的长度大小关系
2、叉乘
定义：axb=c，三个都是向量
几何意义：结果是一个于这两个向量都垂直的向量，这个向量的模是以两个向量为边的平行四边形的面积
运算：（y1*z2-y2*z1）*i+（x2*z1-x1*z2）*j+（x1*y1-x2*y1），思考题：如何演算出来的结果？
性质：
1、向量c和ab所在平面垂直
2、|c|=|a||b|*sin&lt;a,b&gt;
3、axb = -bxa，叉乘的的方向右手定则确定。可以用来判断a向量是在b向量的左边或者是右边，或者是顺/逆时针方向
右手定则：右手的四指方向指向第一个矢量,屈向叉乘矢量的夹角方向（两个矢量夹角方向取小于180°的方向）,那么此时大拇指方向就是叉乘所得的叉乘矢量的方向.
区别：
1、点乘判断角度，叉乘判断方向
2、得到a，b夹角的正弦值，计算向量的夹角（0,90），可以配合点乘和Angle方法计算出含正负的方向。
3、根据叉乘大小，得到a，b向量所形成的平行四边形的面积大小，根据面积大小得到向量的相对大小。
代码
//点积
private void TestDot(Vector3 a, Vector3 b)
{
// 计算 a、b 点积结果
float result = Vector3.Dot(a, b);
// 通过向量直接获取两个向量的夹角（默认为 角度）， 此方法范围 [0 - 180]
float angle = Vector3.Angle(a, b);
// 计算 a、b 单位向量的点积,得到夹角余弦值,|a.normalized|*|b.normalized|=1;
result = Vector3.Dot(a.normalized, b.normalized);
// 通过反余弦函数获取 向量 a、b 夹角（默认为 弧度）
float radians = Mathf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a044ac57ab41ac0c8a968f96dcc742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0d9c38cf06e15f966ab15d71592d0be/" rel="bookmark">
			虚拟DOM 之 Snabbdom 二、源码解析(h函数，虚拟DOM对比，Diff算法)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Snabbdom 源码解析 核心源码解析 如何学习源码 先宏观了解：学习库的核心执行过程带着目标看源码，比如： VNode是如何创建的VNode是如何渲染成真实DOM的 看源码的过程要不求甚解 看源码的过程要围绕核心目标因为一个开源项目的功能会非常的多，代码分支逻辑会非常的多，分支会干扰看源码要先把主线逻辑走通，涉及分支的部分可以先不看这样可以提高源码的阅读速度 调试 一旦主线逻辑走通，可以写一个小Demo，对代码进行调试，加深理解 参考资料 在看源码之前，可以看别人写的文章，帮助更好理解，以提升源码阅读效率 vscode看源码快捷键 右键-转到定义：快速跳转到定义 或 导入变量的位置 当定义在当前文件中，会跳转到定义的位置当定义不在当前文件中，会弹出展示定义的小窗口 窗口顶部是定义所在的文件，点击可以快速跳转 当操作时鼠标/光标就是定义 或 导入的位置，同样会弹出定义的小窗口 Ctrl + 鼠标左键：效果同【转到定义】F12：效果同【转到定义】Alt + 左右方向键：在跳转历史中前进后退 可用于查看完定义后，快速回到之前的位置 Snabbdom 的核心 使用h()函数创建 Javascript 对象（VNode） 描述真实DOMinit() 设置模块，创建patch()patch()根据diff算法比较新旧两个VNode把变化的内容更新到真实 DOM 树上 Diff 算法 百度百科：
虚拟DOM中采用的算法
把树形结构按照层级分解，只比较同级元素。不同层级的节点只有创建和删除操作。
把列表结构的每个单元添加唯一的key属性，方便比较。
虚拟DOM的目的是实现最小更新。
Diff算法是用于对比虚拟DOM树并更新视图的优化算法。
对比包括两个过程：
判断新旧节点是否是相同节点根据对比结果，将差异更新到视图 完整对比一个树结构数据，时间复杂度是O(n^2)。
n是树的层级。
对于两个树结构的变化，若要达到最小更新，首先要对比每个节点是否相同，也就是：
for (var x = 0; x &lt; n; x++ ) { // 遍历旧节点树的层级：n var oldVnode = oldTree[x] // 获取该层的某个节点 for (var y = 0; y &lt; n; y++) { // 遍历新节点树的层级：n^2 var newVnode = newTree[y] // 判断oldVnode 和 newVnode 是否相同 if (oldVnode == newVnode) { // .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0d9c38cf06e15f966ab15d71592d0be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca5b0ebbc924fd328b02c02823c93b1/" rel="bookmark">
			Shell脚本：循环语句（for，while,until)；函数；数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 循环语句：for语句结构for语句示例 While语句结构while示例 双重循环双重循环示例 until语句until语句示例 Shell函数：Shell函数示例：调用函数的方法函数的作用范围递归函数： Shell数组：应用场景数组的概括调用数组的方法数组示例获取数组长度 循环语句： for语句结构 for循环：指定次数循环 遍历 ：将集合当中每一个元素都读取一遍
读取不同的变量值，用来逐个执行同一组命令
语法先写for ,每一个都要加done；变量名从取值列表中去拿
结构形式：遍历集合
for 变量名 in 取值列表 do 命令序列 done 结构形式：指定次数
for ((i=1;i&lt;=5;i++)) do 命令序列 done for循环语句的结构图
for语句示例 遍历集合：
批量添加用户将用户名存放在users.txt文件中，每行一个，初始密码均设为123456
示例二：
IP地址存放在ipadds.txt文件中，每行一个
使用ping命令检测各主机的连通性
-c 发几个包 -i 间隔几秒 -w等待几秒
#!/bin/bash #定义一个集合list，赋值是否查看到的文件中的IP地址 list=$(cat /root/ip.txt) #遍历集合中的IP地址 for ip in $list do ping -c 3 -s 0.2 -w 3 $ip if [ $? -eq 0 ];then echo "主机${ip}存活" fi done 示例三：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca5b0ebbc924fd328b02c02823c93b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5e59861c6caadb0b3642cf9515c8003/" rel="bookmark">
			shell循环语句及函数和数组使用（for、while、until循环语句的解释及范例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一：循环语句1.1：for循环语句1.1.1：for语句结构1.1.2：使用for批量添加用户1.1.3：示例–根据IP地址检查主机状态1.1.4：用循环语句输出1-10的数字的四种办法1.1.5：shell中let命令 1.2：while循环语句1.2.1：while语句结构1.2.2：while语句应用示例1.2.3：while死循环1.2.4：使用while批量添加用户1.2.5：猜商品价格游戏 1.3：continue和break1.3.1：continue1.3.2：break1.3.3：break和continue的区别 1.5：untli循环语句1.5.1：until语句的结构1.5.2：until语句应用11.5.3：until语句应用2 二：shell函数2.1：shell函数概述2.2：shell函数定义2.3：调用函数的方法2.4：shell函数应用12.5：shell函数应用2 三：shell数组3.1：数组应用场景3.2：数组定义方法（推荐方法一）3.3：数组包括的数据类型与数组操作3.3.1：数组包括的数据类型 3.4：求数组最大值 一：循环语句 1.1：for循环语句 1.1.1：for语句结构 ● 读取不同的变量值，用来逐个执行同一组命令
语句结构 for 变量名 in 取值列表 do 命令序列 done 语句结构举例 for 收件人 in 邮件地址列表 do 发送邮件 done 1.1.2：使用for批量添加用户 用户名存放在users.txt文件中，每行一个
初始密码均设为123456
[root@localhost opt]# vim user.txt zhangsan lisi wangermazi zhaoliu tianji wangba [root@localhost opt]# vim useradd.sh #!/bin/bash Lists=$(cat /opt/user.txt) for bb in $Lists do useradd $bb echo "123456" | passwd --stdin $bb echo "$bb添加成功" done [root@localhost opt]# chmod +x useradd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5e59861c6caadb0b3642cf9515c8003/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9400c9cd03c180aa27592526b87ffe4a/" rel="bookmark">
			ArrayList和LinkedList、Vector的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1 ArrayList和LinkedList的区别： （1）相同点：
LinkedeList和ArrayList都实现了List接口。ArrayList和LinkedList是两个集合类，用于存储一系列的对象引用(references)。 （2）不同点：
ArrayList底层的实现数组，而LinkedList是双向链表。ArrayList进行随机访问所消耗的时间是固定的，因此随机访问时效率比较高。
LinkedList是不支持快速的随机访问的，但是在插入删除时效率比较高。 2 ArrayList和Vector的区别： （1）相同点：
ArrayList和Vector都是用数组实现的。默认初始化大小都是10 （2）不同点
Vector多线程是安全的，而ArrayList不是。Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同的。（ArrayList每次存储时会检查空间大小，不够时会扩充为原来的1.5倍，Vector会扩充为原来空间的2倍） //capacityIncrement——增长因子 public Vector(int initialCapacity, int capacityIncrement) { super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; } private int newCapacity(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); Vector可以设置增长因子，而ArrayList不可以。ArrayList有三个构造方法，Vector有四个构造方法。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/162a34f7fd0d4b9a177ae4d2d0791231/" rel="bookmark">
			Matlab 结构体数组批量赋值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		老实说，不是很懂，但确实可以用
代码
clear;clc; Cncs=struct('past_time', {1,1,1,1,1,1,1,1}); [Cncs.past_time] A = mat2cell(1:8,1,ones(1,8)); [Cncs.past_time] = A{:}; [Cncs.past_time] 输出结果
ans = 1 1 1 1 1 1 1 1 ans = 1 2 3 4 5 6 7 8 参考网页
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39b7430836ee9d80627ca50cb3c4a1d/" rel="bookmark">
			问题 | GPU上训练时，显存占满，但是GPU利用率大部分情况为0%
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用了网上很多方法都没有解决我的问题，比如修改batch_size，num_workers等，都没有解决我的问题。
修改超参的这些方法都是针对GPU利用率动态波动的情况
（动态查看GPU利用率的方法：watch -n 0.1 nvidia-smi）
但是基本一直为0的情况，并且在修改超参无果的情况下，就要考虑本身的代码问题了，要知道程序员必须谨记的一条规则就是（机器是不可能出错的，不要怀疑，一定是你的代码的问题）
而能跑，但是GPU利用率为0，说明是修改的数据集部分的bug，比如train_set，val_set的大小设置，我就是按开源代码的设置改成输入自己的数据集，结果自己的数据集大小非常小，导致按原来的设置，只有80个train_samples，所以出现该问题。
谨记：
出现该问题，第一步调整batch_size，num_workers，无果，进入第二步。第二步查看自己数据集的各种设计
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd2b8cb0f7ec481cd1bed1f381c3f6f/" rel="bookmark">
			电脑 | 电脑睡眠后无法键盘鼠标唤醒（实测可行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近实验室给配备了一台IWin10 2TB 的Dell台式机，心里美滋滋，可中午出去吃饭，电脑睡眠，回来后怎么也唤不醒，只能按电源键唤醒。
搜了很多资料后，有用的办法是
第一步：
搜索出控制面板
点击系统和安全，再点击电源选项进入到下面界面,点击当前计划的更改计划设置选项
再点击更改高级电源设置选项
将睡眠选项下的允许混合睡眠关闭。
第二步：修改BIOS设置（非常重要）
重新启动电脑，并快速按（F2）键进入到BIOS界面。因为那个界面没法截图演示，所以以文字的方式呈现。
进入界面之后，点击Power Management，再点击USB Wake Support，选择打开USB Wake Support这一功能，最后点击apply应用，然后exit退出即可。
本人猜想键鼠等设备是直接接在了USB接口上，所以该功能必须开启，才能通过鼠标或键盘唤醒睡眠中的电脑
本文解决的是电脑能睡眠，然后键鼠没法唤醒的情况。
针对电脑没法睡眠，或者进入了休眠，等情况，不适合用本文来解决。
谢谢大家！
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/373/">«</a>
	<span class="pagination__item pagination__item--current">374/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/375/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>