<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c882f844d50f1d699e0ee97d675b0056/" rel="bookmark">
			Ubuntu18.04分区方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于Ubluntu18.04安装和16.04基本一样，因此就没什么好说的，主要记录一下分区方案。
硬盘总容量：500G
分区方案： EFI分区 逻辑分区，空间起始位置，1024MB
该分区最小为512MB，但不用太大
SWAP分区 逻辑分区，空间起始位置 ，16GB
相当于虚拟内存，大小等同于物理你内存
/分区 逻辑分区，空间起始位置 ，150G
相当于WIn10的系统盘
/home分区 逻辑分区，空间起始位置 ，300G
平时资料存储的地方
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0204dd4d0c5f973f7f3d1932684ef9f1/" rel="bookmark">
			机器学习算法背后的数学原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同的机器学习算法是如何从数据中学习并预测未知数据的呢?
​ 机器学习算法的设计让它们从经验中学习，当它们获取越来越多的数据时，性能也会越来越高。每种算法都有自己学习和预测数据的思路。在本文中，我们将介绍一些机器学习算法的功能，以及在这些算法中实现的有助于它们学习的一些数学方程。
机器学习算法的类型 机器学习算法大致可以分为以下四类:
**监督学习：**用于预测的目标是已知的情况。这些算法生成一个函数，该函数将输入映射到输出变量。回归和分类算法都属于这一类。在回归中，输出变量是连续的，而在分类中，输出变量包含两个或更多的离散值。监督学习算法包括线性回归，逻辑回归，随机森林，支持向量机，决策树，朴素贝叶斯，神经网络。
**无监督学习：**目标或输出变量是未知的情况。这些算法通常对数据进行分析并生成数据簇。关联、聚类和维数约简算法属于这一类。K-means聚类、PCA(主成分分析)、Apriori算法等也都是非监督学习算法。
**半监督学习：**它是监督和非监督学习方法的结合。它使用已知数据来训练自己，然后标记未知数据。
**强化学习：**机器从“试错”过程中学习的方法。机器从过去的决策经验中学习，并利用它的学习来预测未来决策的结果。强化学习算法的例子有Q-Learning, Temporal Difference等。
线性回归 ​ 线性回归是通过拟合数据点上的最佳直线来预测连续变量的结果。最佳拟合线定义了因变量和自变量之间的关系。该算法试图找到最适合预测目标变量值的直线。通过使数据点与回归线之间的差的平方和最小达到最佳拟合线。
线性回归(来源:onlinestatbook) Equation: Y = c + m₁X₁ + m₂X₂ + …… +mnXn
Y → Dependent Variable or Target Variable
m → Slope
c → Intercept
X → Independent Variables
逻辑回归 ​ 逻辑回归是一种基于自变量估计分类变量结果的分类算法。它通过将数据拟合到logistic函数来预测某一事件发生的概率。通过最大化似然函数，对logistic函数中自变量的系数进行优化。优化决策边界，使成本函数最小。利用梯度下降法可以使代价函数最小化。
逻辑回归的s型曲线 Logistic回归的成本函数 logistic回归方程 朴素贝叶斯算法 ​ 朴素贝叶斯是一种基于贝叶斯定理的分类算法。该算法假设自变量之间不存在相关性。也就是说，一个类中某个特性的出现与同一类中另一个特性的出现是没有关系的。我们针对类为所有预测器创建一个频率表(目标变量的不同值)，并计算所有预测器的可能性。利用朴素贝叶斯方程，计算所有类别的后验概率。朴素贝叶斯分类器的结果将是所有类概率中概率最高的类。
决策树 ​ 决策树主要用于分类问题，但它们也可以用于回归。在该算法中，我们根据有效性划分数据集的属性，将数据集划分为两个或多个同构集。选择将分割数据集的属性的方法之一是计算熵和信息增益。熵反映了变量中杂质的数量。信息增益是父节点的熵减去子节点的熵之和。选择提供最大信息增益的属性进行分割。我们也可以使用基尼指数作为杂质标准来分割数据集。为了防止过度分割，我们优化了max_features、min_samples_split、max_depth等决策树的超参数。
信息熵, c → No. of classes 基尼系数 随机森林 ​ 随机森林由多个决策树组成，作为一个集合来运行。在随机森林中，每棵决策树预测一个类结果，投票最多的类结果成为随机森林的预测项。为了做出准确的预测，决策树之间的相关性应该最小。有两种方法可以确保这一点，即使用Bagging和特性选择。Bagging是一种从数据集中选择随机观察样本的技术。特征选择允许决策树仅在特征的随机子集上建模。这就防止决策树使用相同的特性进行预测的情况。
随机森林(来源:victorzhou) k-NN (k - Nearest Neighbors) ​ 该算法也可用于回归和分类。该算法通过计算数据点与所有数据点的距离来找到k个数据点的最近邻。数据点被分配给k个邻居中点数最多的类(投票过程)。在回归的情况下，它计算k个最近邻居的平均值。距离度量可以使用欧几里得距离，曼哈顿距离，闵可夫斯基距离等。为了消除距离相等的可能，k的值必须是一个奇数。由于每个数据点与其他数据点的距离都需要计算，因此该算法的计算时间开销较大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0204dd4d0c5f973f7f3d1932684ef9f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0a6354b6de1407be73955cf4872f02/" rel="bookmark">
			思科基础命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天把之前学习的一些基础的思科命令整理一下。
路由添加远程连接 telnet： configure terminal //进入全局配置模式 username abc privileg 15 secret abc123 //设置远程登陆账号和密码 end //退出到特权模式 configure terminal //进入全局配置模式 line vty 0 4	//设置远程连接数5 login local	//这个登录要进行身份验证 end 电脑登录：telnet 192.168.10.1 //telnet连接 no ip domain-lookup //关闭解析 路由器基本配置命令： 路由接口添加IP地址： int g0/0 //进入接口 ip add 192.168.1.2 255.255.255.0 //添加接口ip地址 no shut //打开接口 int g0/1 ip add 192.168.1.3 255.255.255.0 no shut //打开接口 int g0/2 ip add 192.168.1.4 255.255.255.0 no shut //打开接口 路由默认配置： ip route 0.0.0.0 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d0a6354b6de1407be73955cf4872f02/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d732e77cd2cd9b04f7d87d4d1b4b0b27/" rel="bookmark">
			windows下查看系统证书（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 做的项目涉及把证书导入系统，记录一下如何查看windows系统下安装的证书
1.快捷键win+r，调出运行窗口，输入mmc，回车确定 2.进入windows的管理控制台，选择文件→添加/删除管理单元 3.可用的管理单元列表拉到底，选择证书→添加 4.选择我的用户账户，选择完成 5.在所选管理单元列表就显示我们刚刚添加的证书，选择确定 6.这时候就添加完成了，左边可以选择不同的证书类型，中间的是证书 7.选择退出的时候会提示要不要保存到控制台1，选择是 8.保存到桌面，命名为证书，保存 9.这时候桌面就会生成证书的控制台快捷方式，点击就可以快速进入，不用再另外配置了 结语 这是其中一个查看证书的方法，还有其他的方法，整个步骤就是这样，配置好之后就可以随时查看了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671151c17667b7787ea30ba57b31a2a1/" rel="bookmark">
			判断点是否在扇形内解法探究 C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试时遇到了这个问题，在游戏开发中，类似于检测扇形技能是否命中了敌人。
我当时的第一想法是先通过扇形半径平方和玩家和敌人的距离平方大小比较，提前检测出一批不符合条件的敌人。如果玩家和敌人的距离平方小于扇形半径平方的话，再通过一些算法判断。
算法判断的第一想法是求出与x轴的夹角，然后判断夹角是否在扇形的两个边的夹角内。然后想了想觉得可以类比判断点是否在三角形内，通过叉乘判断。
下来以后参考了别人的一些思路，又自己进行了一些总结，并用C++测试了一下，希望帮到读者，有任何问题欢迎批评指正。
首先是最经典的通过给定玩家朝向（即扇形的中心向量）和技能的角度大小来判断是否命中。为了简化问题，我们假设扇形角度大小小于180度。同时为了不在扇形半径平方和玩家和敌人的距离平方大小比较时就筛选了过多的点，而导致之后的判断算法运行时间不易比较，将扇形的半径设置大一点。
#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; const int n = 100, m = 100; // 用离散点模拟敌人，n行m列 bool table[n][m]; void func(int x, int y, int r, int orieX, int orieY, float angle) { float len = sqrt(orieX * orieX + orieY * orieY); int rPow = r * r; for (int ex = 0; ex &lt; n; ex++) for (int ey = 0; ey &lt; m; ey++) { int dx = ex - x; int dy = ey - y; int lenPow2 = dx * dx + dy * dy; if (lenPow2 &gt; rPow) continue; int dotRes = orieX * dx + orieY * dy; // 获取点乘 if (dotRes &lt; 0) continue; float angle2 = acos(dotRes / (len * sqrt(lenPow2))); // 通过点乘获取夹角 if (angle2 * 2 &gt; angle) continue; table[ex][ey] = true; } } int main() { int x, y, r; // 玩家位置（x,y）技能半径r int orieX, orieY; // 玩家朝向（orieX，orieY） float angle; // 技能总角度 cin &gt;&gt; x &gt;&gt; y &gt;&gt; r; // eg: 20 20 100 1 1 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/671151c17667b7787ea30ba57b31a2a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33bedc810495c55d268cfc5c92b4b557/" rel="bookmark">
			二层主机通信与三层主机通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天记一下二层主机通信过程，三层主机通信过程。
1、二层主机通信
(1)PC0向PC1通信，首先会查看自己的arp缓存。如果没有，pc0就会广播arp请求，pc1收到请求之后就会单播回复mac地址，同时pc1自己也会把pc0的mac地址存储在arp缓存中，pc0收到pc1的arp回复后，把pc1的mac地址写入到自己的arp缓存中，并封装帧转发给交换机。
(2)如果缓存中有pc1的mac地址，则pc0会把自己要发的数据封装成帧，帧格式为【目的mac地址 源mac地址 源IP地址 目的IP地址 数据】，帧到交换机之后，交换机就会学习pc0的mac地址，然后检擦mac地址表中是否有目的mac地址，如果有，那么交换机就单播把帧转发给pc1。
(3)如果没有就会，交换机就会广播arp请求，pc1收到请求后就会把自己的mac地址发给交换机，交换机会把pc1的mac地址放入自己的mac地址缓存表中，然后在转发帧到pc1。
2、三层主机通信
(1)PC0向PC1通信，首先查看自己的arp缓存是否有三层交换机的mac地址。如果没有,pc0就广播arp请求，三层交换机就会把自己的mac地址单播回复给pc0，pc0就会把三层交换机的mac地址写入arp缓存，并封装成帧。
(2)如果有，就会构造一个帧，帧内容为【三层交换机的目的mac地址 源mac地址 源IP地址 pc1的目的IP地址 数据】发给三层交换机。
(3)三层交换机收到这个帧之后，检查发现是发给自己的，就去掉了帧头和帧尾，查看路由表是否有目的IP地址。如果没有，就丢弃这个数据包，并发送目标主机不可达。
(4)如果有，就把这个数据包转到能到目的IP地址I的接口，然后查看自己的arp缓存是否有PC1的mac地址。如果有，就会把这个数据包封装成帧，转发给PC1。
(4)如果没有就广播arp请求，pc1回复三层交换机自己的mac地址，三层交换机就会把pc1的mac地址写入arp缓存，并封装成帧。
在这些过程中，我忽略了与二层交换机的通信过程，但是其过程其实与二层主机通信过程很像，所以我就不再描述。
结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b38fb0c6c696d84301afefc834ba5ea/" rel="bookmark">
			TCP/IP协议簇——数据封装过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天学习了osi七层模型和tcp/ip协议簇，今天写一下前几天学习的数据封装内容。
1974年，ISO组织发布了iso模型，全称为开放的通信系统互联参考模型。里面一共有七层，即应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
tcp/ip五层模型是应用层、传输层、网络层、数据链路层、物理层。也就是把iso七层模型中的表示层和会话层放入了应用层中。
物理层：确保原始数据可在各种物理媒体上传输。
数据链路层：为网络层提供可靠的数据传输。
网络层：进行路由选择，实现拥塞控制、网际互连。
传输层：将上层数据分段并提供端到端、可靠或不可靠传输以及端到端的差错控制和流量控制。
会话层：管理主机之间的会话进程，在数据中插入校验点来实现数据的同步。
表示层：数据转换
应用层：为操作系统或网络应用程序提供访问网络服务的接口。
下面是TCP/IP的封装过程，还有一些每层的应用。还有一句重点就是，下层为上层服务。
下面是TCP/IP的一些协议还有协议之间的关联。 注：
1Byte = 8bit
一汉字为两字节
一字母为一字节
结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ddb5fe1737b9602c27854582e12982/" rel="bookmark">
			Js -- 最长公共子串（算法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 先比较s1、s2的长度，如果是s1比s2长则交换位置取较短的字符串作为。substr(idex, len)，所以拿较短的串取其子串，然后判断它是否在较长的字符串中存在，如果存中则直接返回，否则再取下一位。
const findSubStr = (str1, str2) =&gt; { if (str1.length &gt; str2.length) { [str1, str2] = [str2, str1] } let result = ""; const len = str1.length; for(let j = len; j &gt; 0; j --) { for(let i = 0; i&lt;= len -j; i++) { result = str1.substr(i, j); if (str2.includes(result)) return result } } } console.log(findSubStr('aabbcc11', 'ppooiiuubcc123')) // bcc1 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b1c104a86880d47fadd50dbf5dc6073/" rel="bookmark">
			算法比赛复习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		陆陆续续四个多月的学习小总结，具体题目和题解在下方：
写了这个总结后，又做了一些真题，结果发现是一些特性不符合比赛的编译器版本，所以有些基础的转换还不太行，还有一些奇怪的输入，其他的都还好，我寻思着，这比赛不考多点算法的东西，整这么多奇葩的输入干啥。
字串问题 和 并查集 和 大数问题（以及进制） 需要补充 容器以及algorithm算法部分 对以下容器和不同类型数组的使用有一定的理解
string,
vector,list,deque,
queue,stack,
priority_queue
set,unorder_set,
map,unorder_map
father数组，树状数组
a[] a[][] a[][][]
algorithm库的使用 max,min
*max_element,*min_element
sort,heap_sort
next_permutation
fill memset
swap
reverse
lower_bound,upper_bound
算法部分 总结链接
1.递归{ ①1.92. 递归实现指数型枚举 ②. 93. 递归实现组合型枚举 ③. 94. 递归实现排列型枚举 }
。
2.dfs{ ①迷宫问题 ②固定方向路径数问题 ③皇后问题 （dfs+回溯） }
。
3.bfs与逆向bfs{ ①迷宫问题 ②单源到单源单位长读最短路径 }
。
4.回溯（dfs+回溯）{ ①全排列问题 ②括号生成与括号配对问题 ③皇后问题 ④岛屿问题 }
。
5.最小生成树(kruscal+并查集){ ①抽象成点的连接的最小代价问题 ②村庄（城市）通路问题 }
。
6.单源到多源最短路(dijkstra){ 从某个点i到其他任一点的最短距离 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b1c104a86880d47fadd50dbf5dc6073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3d1936c00cef1293985dfa00c0108b8/" rel="bookmark">
			a(n) = n^3 &amp; a(n) = n^ 2 数列求和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		a(n) = n ^ 2;
S(n) = n * (n + 1) * (2 * n + 1) / 6;
a(n) = n ^ 3;
S(n) = n * n * (n + 1) * (n + 1) / 4;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edb69c5f6b6bafec840e721e487968df/" rel="bookmark">
			html标签（列表标签和表单标签以及表单控件）-小白学习中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html-6 14.列表标签
14.1无序列表
&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; &lt;/ul&gt; 注： &lt;ul&gt;中只能放&lt;li&gt; &lt;li&gt;中可以放任何元素，相当于一个容器 14.2有序列表
&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; &lt;/ol&gt; 注：&lt;ol&gt;中只能放&lt;li&gt; 14.3
&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; &lt;/dl&gt; 注： &lt;dl&gt;定义列表 &lt;dt&gt;定义项目 &lt;dd&gt;描述每一个项目 例如：
&lt;body&gt; &lt;!--无序列表--&gt; &lt;h4&gt;你喜欢的菜&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;鱼香肉丝&lt;/li&gt; &lt;li&gt;锅包肉&lt;/li&gt; &lt;li&gt;宫保鸡丁&lt;/li&gt; &lt;li&gt;过油肉土豆片&lt;/li&gt; &lt;/ul&gt; &lt;!--有序列表--&gt; &lt;h4&gt;热爱的游戏&lt;/h4&gt; &lt;ol&gt; &lt;li&gt;和平精英&lt;/li&gt; &lt;li&gt;铁甲雄兵&lt;/li&gt; &lt;li&gt;骑马与砍杀&lt;/li&gt; &lt;li&gt;CS GO&lt;/li&gt; &lt;/ol&gt; &lt;!--自定义列表--&gt; &lt;dl&gt; &lt;dt&gt;娱乐&lt;/dt&gt; &lt;dd&gt;qq&lt;/dd&gt; &lt;dd&gt;微信&lt;/dd&gt; &lt;dt&gt;电影&lt;/dt&gt; &lt;dd&gt;快把我哥带走&lt;/dd&gt; &lt;dd&gt;拯救不开心&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt; 你喜欢的菜 鱼香肉丝锅包肉宫保鸡丁过油肉土豆片 热爱的游戏 和平精英铁甲雄兵骑马与砍杀CS GO 娱乐 qq 微信 电影 快把我哥带走 拯救不开心 15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edb69c5f6b6bafec840e721e487968df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/801b00ad4d5ee417c0a18b343ebd0e1f/" rel="bookmark">
			【皮皮哥资源网】jQuery&#43;Ajax请求本地数据加载商品列表页并跳转详情页的实现方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、 json文件2、 商品列表页goodsList.js3、商品详情页goodsDetail.js 1、 json文件 { "books":[ {"id":1,"imgUrl":"images/ly.jpg","price":"45.00","title":"论语","publish":"人民文学出版社","num":"303","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"}, {"id":2,"imgUrl":"images/zy.jpg","price":"45.00","title":"中庸","publish":"人民教育出版社","num":"403","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"}, {"id":3,"imgUrl":"images/dx.png","price":"45.00","title":"大学","publish":"机械工业出版社","num":"503","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"}, {"id":4,"imgUrl":"images/mz.jpg","price":"45.00","title":"孟子","publish":"人民邮电出版社","num":"320","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"}, {"id":5,"imgUrl":"images/sj.jpg","price":"45.00","title":"诗经","publish":"人民文学出版社","num":"308","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"}, {"id":6,"imgUrl":"images/ss.jpg","price":"45.00","title":"尚书","publish":"人民文学出版社","num":"603","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"}, {"id":7,"imgUrl":"images/lj.jpg","price":"45.00","title":"礼记","publish":"上海人民出版社","num":"703","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"}, {"id":8,"imgUrl":"images/yj.jpg","price":"45.00","title":"易经","publish":"人民文学出版社","num":"803","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"}, {"id":9,"imgUrl":"images/cq.jpg","price":"45.00","title":"春秋","publish":"电子工业出版社","num":"903","desc":"崇贤馆始置唐代太宗朝。1999年，李克先生及志同道合者复兴其宗旨。以积累、传播中华优秀传统文化，提供全新国学体验馆为宏愿。"} ] } 2、 商品列表页goodsList.js //请求json数据拼接字符串，并在URL传参数id跳转 $(function() { $.ajax({ type: "get", url: "data/data.json", dataType: "json", success: function(res) { var str = "&lt;ul class='con_ul'&gt;"; $.each(res.books, function(idx, val) { str += "&lt;li class=\"sec_li\"&gt;&lt;a href='goodsDetail.html?booksId=" + val.id + "' class='lp_li_a'&gt;&lt;div class='lp_li_imgWrap'&gt;&lt;img src='" + val.imgUrl + "'/&gt;&lt;/div&gt;&lt;p class='lp_li_name'&gt;" + val.title + "&lt;/p&gt;&lt;p class='lp_li_price'&gt;" + '￥' + val.price + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/801b00ad4d5ee417c0a18b343ebd0e1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253c66f8b500038ffc4d187c3c49e228/" rel="bookmark">
			如何pycharm添加扩展工具 --学习pyqt5如何将ui文件转成py文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何pycharm添加扩展工具 --学习pyqt5如何将ui文件转成py文件 我是以学习pyqt5如何将ui文件转成py文件为例，记录自己学习如何pycharm添加扩展工具。
1.首先使用命令行实现将ui文件转成py文件
方式1：
python -m PyQt5.uic.pyuic demo.ui -o demo.py 方式2：
pyuic5 demo.ui -o demo.py 2.如何将其转换成扩展工具呢？
2.1 打开pycharm 找到以下位置
2.2 点击 圈住的加号位置，在生成的对话框中填写
2.3
Name： 自己想设定的名称，如PyUIC
Group：不需要改动，默认为External Tools
Descripion：自己想设定的描述，如PyUIC
Programs：为自己电脑中python的路径，如D:\ProgramData\Anaconda3\python.exe
Arguments：是输入的指令，
-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py
其中，为默认当前文件，生成具有相同名字的.py文件
Working directory：$FileDir$，为工作目录
测试
运行后实现如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26049f89d8c6f8d917697fb971cc1aa8/" rel="bookmark">
			还在手工生成数据库文档？3个步骤自动完成了解一下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自动化生成数据库文档，简单的3个步骤即可完成，了解一下。
1 前言 平时工作中，大家应该都会遇到需要导出数据库说明文档（也叫数据字典）的情况，即把各数据表的字段信息整理成一个个的表说明，然后用 excel/word/html/md 等文档格式进行保存。很多小伙伴还在用原始的手工方式，复制粘贴数据库的字段说明（名称、类型、长度、注释等），不得不说这种方式效率实在太低。作为程序员，能用编程解决的问题，就不是问题。下面介绍的方法很简单，只需要3个步骤。本文将对这3个步骤使用 python 进行编码实现，把数据表信息说明输出到 excel 文档中。因此，主要包含以下内容：
生成数据库文档的3步骤说明获取数据库表元信息获取数据表列的元信息生成数据库说明 excel 文档（可选）设置 excel 文档格式 2 生成数据库说明文档的3步骤 由于数据库都会保存相应的元数据信息（即描述数据库、数据表、数据字段本身的信息，如表名，字段表、类型等等），因此，总的来说，生成数据库说明文档的思路很简单，分为3步：
1）根据数据库名，从数据库中获取数据表元信息，主要是表名，表注释等2）根据数据表名，获取数据字段的元信息，主要是字段名、字段类型、是否可空、字段注释等3）根据元数据信息生成文档 根据这个思路，把这3个步骤通过编码即可自动生成文档。获取元数据信息，各种数据库会有不同的查询语句，具体可以查询相关官方文档，下面简单列一下 mysql 及 oracle 的：
# mysql 查询表信息及字段信息 SELECT * FROM information_schema.`TABLES` WHERE TABLE_SCHEMA = %db_name% SELECT * FROM information_schema.`COLUMNS` WHERE TABLE_SCHEMA = %db_name% AND TABLE_NAME = %table_name% # oracle 查询表信息及字段信息 SELECT * FROM all_tables WHERE where owner= %db_name% SELECT * FROM all_COL_COMMENTS WHERE owner = %db_name% and TABLE_NAME=%table_name% 实现方式也可以根据各人喜欢的编程语言来实现。在本文中，以 MySQL 为例，使用 python 编程实现，把数据信息输出到 excel 文档（具体 excel 操作，可参考我上一篇文章《 Python 处理 Excel 文件》）。输出效果如下所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26049f89d8c6f8d917697fb971cc1aa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/768975b1e19af01eb48cbb9c2cebe98f/" rel="bookmark">
			B站直播画中画设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因B站直播没有画中画的选项，所以一番查找下，发现了一个插件
下载地址
chrome下载安装后即可开启直播画中画
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64821600f5fff53717687f45ba894332/" rel="bookmark">
			华为8_26机试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		华为8.26第一题：位转换：没有任何技巧，纯c++代码 * 题目描述：题目中提示，每个数字的二进制为32bit） * 1.输入n个无符号整数 * 2.给每个数字增加干扰措施。 * 2.1 干扰1：让每个整数的二进制位置上的数字交换，即(2*i）与（2*i+1）交换，i=0：15。以下讨论说的都是二进制数。 * 2.2 干扰2：假设三个数a,b,c，a（XXXXXXXXXXa2a1）的最后两位弹出a1,a2；a1,a2进入b的头,同时b的最后两位b1b2弹出，此时b变为（a2a1XXXXXXXXXXXX），c同理，变为（b2b1XXXXXXXXXXXX），将c的尾巴c1c2弹入a的头，a变为（c2c1XXXXXXXXXXXXX）。 * 最终效果：(干扰2：再把每个数向右移动两位，溢出的部分依次像下一个整数的最高位移动，末尾的右移两位到第一个数的最高两位) * a（XXXXXXXXXXXXa2a1）-&gt;（c2c1XXXXXXXXXXXXX）； * b（XXXXXXXXXXXXb2b1）-&gt;（a2a1XXXXXXXXXXXX）； * c（XXXXXXXXXXXXc2c1）-&gt;（b2b1XXXXXXXXXXXX）； * 。。。。。。应该叙述清楚了。倘若只有一个数a，这个应该好分析 * 3.输出每个***扰后的数字（十进制的，同空格隔开） 主要思路：
按照题目要求来，本题的思路是用unsigned int转二进制，再转字符串做翻转进行相应操作
后续这种转换，我感觉要直接用移位来，这是c++的优势 小的tricks:我之前也遇到过字符串输入带空格。。。用getline(cin,s)。。。
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;unordered_map&gt; #include &lt;algorithm&gt; using namespace std; // 将数转换为32位数的二进制 string zhuanhuan1(unsigned int a) { string temp; int t = 0; for (int i = 0; i &lt; 32; i++) { // 转换成二进制，完全按照我们的数学公式来的 t = a % 2; temp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64821600f5fff53717687f45ba894332/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23eb717e053a253eb90b5423e0435f98/" rel="bookmark">
			Public Key Infrastructure——公钥基础设施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天做一篇关于PKI的笔记，PKI是目前来说信息安全领域很流行的技术，它的应用已经很广泛了。
PKI是指公钥基础设施，它是通过公钥加密技术和数字签名服务保证传输数据的安全。它最重要的几个部分是公钥加密算法，数字证书，CA证书颁发机构，RA注册机构。PKI应用最多的一般是SSL/HTTPS，还有就是VPN。
公钥加密技术实现对信息的加密，一般是用hash算法。数字签名一般是发送者用自己的私钥对摘要加密，保证信息的完整性。CA颁发的证书是为了验证发送方与接收方两者交换的公钥就是两者自己的，没有被掉包。RA可以看做为CA的一个子功能，一般CA自己就能完成整个功能，不需要RA。
在网络中有些数据是保密的，不能进行明文传输，所以就会用到加密算法。接下来我讲一下对称加密算法和非对称加密算法。常用的对称加密算法有：3DES、AES、IDEA、RC6等等。常用的非对称加密算法有：RSA、ECC、DH等等。
对称加密算法就是通信双方使用加密和解密的公钥是一致的。非对称加密是通信双方各自生成属于自己的公钥和私钥，公钥加密数据只能用自己的私钥可以解密，私钥加密数据只能用自己的公钥解密，在通信时双方交换属于自己的公钥，并且只知道公钥或者是只知道私钥是不能互相推算对应的私钥或公钥。
接下来我要详细讲解一下非对称加密算法的过程。
（1）通信双方交换公钥，为了验证公钥的身份是否正确，所以需要由CA颁发证书。发送方首先向CA发送自己的个人信息比如自己的国家、电话、电子邮件等等，还会发送自己的公钥，CA在接收到这些信息之后会向发送方颁发证书，证书的内容就是有效期、发送者的公钥、发送方的标识信息和CA的数字签名等等，数字签名就是CA会用自己的私钥加密。然后发送方就会把自己从CA申请的证发送给接收方，接收方会从CA那里申请CA的公钥（前提是接收方信任CA），用于解密证书里的数字签名，验证解密后得到的公钥和发送过来的公钥做对比是否一致，一致的话说明公钥身份正确。最后两者就可以进行数据的传输了。
（2）发送方用接收方的公钥加密传输的数据，并且在加上自己的数字签名（也就是上图中的加密的摘要），发送给接收方。
（3）接收方对传过来数据验证，验证通过就用自己的私钥解密，这就得到发送方发送的数据。
在上图中有一个hash算法，它也叫哈希算法，它是把任意长度的数据转化为固定的的长度输出，这个过程是不可逆的。常用的哈希算法有MD5、SHA、HAVAL等。哈希算法的应用有很多，比如在下载大内容的文件时可以通过哈希值来验证文件是否完整，windows系统的账户密码也是通过哈希算法保存的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23d03e975160383d23477bda89d3a5f6/" rel="bookmark">
			koa2接收post请求参数formdata和json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单提交时的请求类型为 `application/x-www-form-urlencoded`
原生的 HTML 表单 &lt;form&gt; 是没有 JSON 类型的，其总共有三种默认的格式，
application/x-www-form-urlencodedmultipart/form-datatext/plain 默认为 application/x-www-form-urlencoded，可通过 &lt;form&gt; 表单的 enctype 指定。
所以真正意义上以 JSON 格式提交，需要借助 JavaScript，真实场景下表单也大多会走代码提交而非原生 submit 类型的 &lt;button&gt;。
首页更新表单代码添加 onsubmit 方法：
- &lt;form action="/save" method="POST"&gt; + &lt;form action="/save" method="POST" οnsubmit="submitForm(event)" id="myForm"&gt; 添加以下代码到页面以提交表单：
&lt;script&gt; function submitForm(event) { event.preventDefault(); var formData = new FormData(myForm); let data = {}; for (var [key, value] of formData.entries()) { if (key.startsWith("hobbies")) { data["hobbies"] ? data["hobbies"].push(value) : (data["hobbies"] = [value]); } else { data[key] = value; } } fetch("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23d03e975160383d23477bda89d3a5f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8efa3d7d8eabe33b11ab7f19f1d7fad/" rel="bookmark">
			neo4j 程序连接端口_使用Neo4j向PHP应用程序添加社交网络功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		neo4j 程序连接端口
In the last part, we learned about Neo4j and how to use it with PHP. In this post, we’ll be using that knowledge to build a real Silex-powered social network application with a graph database.
在最后一部分中，我们了解了Neo4j以及如何在PHP中使用它。 在本文中，我们将利用这些知识来构建一个真正的由Silex支持的带有图形数据库的社交网络应用程序。 引导应用程序 (Bootstrapping the application) I’ll use Silex, Twig, Bootstrap and NeoClient to build the application.
我将使用Silex ， Twig ， Bootstrap和NeoClient来构建应用程序。 Create a directory for the app. I named mine spsocial.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8efa3d7d8eabe33b11ab7f19f1d7fad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed75775addd587f61c4cec5bf98e9b43/" rel="bookmark">
			数据结构与算法_栈和队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		栈 概念 正如标题所述，栈是一种被约束的线性结构。我们在一个线性结构上给出了一个规定：第一个进去的最后一个出来。这就像有一摞书放在地面上，不允许从中间抽出来，只能从上面一本一本拿一样。这样的线性就是栈。
所谓栈：限定仅在表头进行插入删除的线性结构。因为是后进先出（Last In First Out）
不像普通的线性结构有CRUD（增删改查）那样丰富的操作。栈仅仅只有进和出两个操作。
栈的顺序存储 压栈Push bool Push(T data){ if (IsFull() == true) return false; array[++top] = data; return true; } 出栈Pop bool Pop() { if (IsEmpty() == true) return false; this-&gt;temp = array[top--]; return true; } 完整代码 #pragma once using namespace std; /* 栈的基本操作(C语言实现) Stack CreateStack(int MaxSize); //生产堆栈，其最大长度是MaxSize int IsFul(Stack S, int MaxSize); //判断栈S是否以满 void Push(Stack S, ElementType item); // 将元素item压入栈 int IsEmpty(Stack S); //判断栈S是否为空 ElementType Pop(Stack S); // 删除并栈顶返回元素 */ template &lt;class T&gt; class Stack { public: T * array;//数组实现的静态栈 int maxSize;//数组最大长度 int top;//栈指针 T temp;//暂存变量 Stack(const int maxSize) { //有参构造函数 this-&gt;maxSize = maxSize; array = new T[maxSize]; top = -1; //top指针等于-1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed75775addd587f61c4cec5bf98e9b43/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/368/">«</a>
	<span class="pagination__item pagination__item--current">369/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/370/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>