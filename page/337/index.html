<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/353cfb9ab5cc2f07e40eb592e8f377a7/" rel="bookmark">
			单核，多核，线程，进程的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2、
线程：Cpu调度和分配的基本单位
进程：一个进程中会有多个线程。（多个线程分别做不同的事情）由进程控制块，程序段，数据段三部分组成。由操作系统调度。
单核多线程：单核cpu轮流执行多个线程，通过给每个线程分配cpu时间片来实现
多核多线程：多个线程分配给多个核心处理，相当于多个线程并行执行
3、多核cpu和单核Cpu的区别
单核：cpu只有1个独立的cpu核心单元，运行的线程数少，不利于同时运行多个程序，执行速度慢
多核：cpu只有多个独立的cpu核心单元，运行的线程数多，有利于同时运行多个程序，执行速度快
4、手机多核对游戏是否有影响
多核在处理单个程序时无法体现，但是在同时运行多个程序时，多核的流畅度要远高于单核
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e63fdcae3ccfa73ac099714ee134a1a2/" rel="bookmark">
			vim显示行号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux平台上做开发，vim编辑器显示行号很有必要，可以让我们很直观的看到当前行是在当前文件的具体的多少行，但是在默认情况下，vim编辑器是不给我们提供显示行号的功能的。那我们怎么可以让vim编辑器显示行号呢？
vim编辑器显示行号，可以分为临时显示和永久显示。
临时显示
临时显示，只需要在当前通过vim编辑器打开的文件中，执行:set number 或者 :set nu就可以显示了，如默认如下图：
这个时候我们想确认某行代码在什么位置很不方便，只需要根据上面的提示在当期这个文件中执行:set number 或者 :set nu就可以显示行号了，这是临时的显示方法：
输入命令后回车，就可以显示行号了：
永久显示
永久显示就需要更改系统的配置文件了。
这里说的该系统配置文件，主要是vim编辑器的配置文件，可以分为两种情况：
系统级修改
在/etc目录下，修改.vimrc配置文件，如果没有该文件，就新建一个，vim .vimrc，然后在文件中输入set number或者set nu即可， 保存退出，然后在通过vim编辑器打开的文件都会显示行号了。
这种修改方法针对该系统的所有用户都生效，谨慎使用。
当前用户的修改
这种方法使用的比较多，方法和系统级的修改方式相同，只是修改了不同目录下的.vimrc文件，当前用户只需要修改当前用户目录下的.vimrc即可，也只对当前用户生效，该系统的其他用户登录系统无效，使用的较多。
需要注意的地方也是一样的，有.vimrc直接修改即可，没有该文件新建一个，键入命令后保存退出。
取消行号显示
如果是用户的行号显示方法设置的显示行号，如果是系统级设置的显示，那么只需要把/etc目录下的.vimrc文件中的set number 或者 set nu指令移除掉即可；如果是当前用户级别设置的永久显示行号，那么只需要将~/.vimrc文件中的set number 或者 set nu指令移除即可。
如果是在通过vim编辑器打开的文件中临时显示的行号，那么只需要在当前vim编辑器中，执行:set nonumber或者:set nonu指令即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d094db5095d7aa66d6c8e44d8446d64d/" rel="bookmark">
			MySQL高级——Explain信息中Extra字段解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Explain信息中Extra字段解释二、Using filesort（重要指标）三、Using temporary（重要指标）四、Using index（重要指标）五、Using where（一般重要指标）六、Using join buffer（一般重要指标）七、impossible where（一般重要指标）八、select tables optimized away（不常用指标）九、distinct（不常用指标） 一、Explain信息中Extra字段解释 包含不适合在其他列中显示但十分重要的额外信息。主要包括: Using filesort 、Using temporary 、Using index、Using where、Using join buffer、impossible where、select tables optimized away、distinct 二、Using filesort（重要指标） 1、Using filesort解释
说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序” 2、示例1
建立了col1、col2、col3三个字段的复合索引，排序也是按照索引的顺序。
排序时没有按照建立复合索引字段col1、col2、col3的顺序进行，因此产生了外部的索引排序。效率低。
3、示例2
建立了col1、col2、col3三个字段的复合索引，排序也是按照索引的顺序。
排序时按照建立复合索引字段col1、col2、col3的顺序进行，因此没有外部的索引排序。效率高
三、Using temporary（重要指标） 1、Using temporary解释
使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。 2、示例1
建立了col1、col2两个字段的复合索引，排序也是按照索引的顺序。
分组时没有按照建立复合索引字段col1、col2的顺序进行，因此产生了临时表和外部的索引排序。效率低
3、示例2
建立了col1、col2两个字段的复合索引，排序也是按照索引的顺序。
分组时按照建立复合索引字段col1、col2的顺序进行，因此没有产生临时表并且也没有使用外部的索引排序，因此效率高。
四、Using index（重要指标） 1、Using index解释
表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。 2、示例1
3、示例2
4、覆盖索引(Covering Index)
推荐理解方式一
理解方式一：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说查询列要被所建的索引覆盖。理解方式二：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据;当能通过读取索引就可以得到想要的数据，那就不需要读取行了。 覆盖索引示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d094db5095d7aa66d6c8e44d8446d64d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a68c2cb9a463d4aa838eea327081d6/" rel="bookmark">
			Boilsoft Video Joiner(视频无损拼接)V9.1.3开心版 全网独一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Boilsoft Video Joiner是强大的视频合并工具，可将AVI，MPEG，MPG，VOB，RM/RMVB，3GP，ASF，WMV，WMA，MP4，MP4A，​​MKV或FLV文件等连接到一个“不间断”的较大文件中。Boilsoft视频拼接器为您提供直接流模式和编码模式，以更有效地合并视频，并支持以超快的速度将不同格式的视频连接在一起。
直接加入视频文件，无需重新编码
直接流克隆模式无需重新编码即可连接相同类型的文件，非常快速且没有任何质量损失。输出文件质量与源视频/音频质量相同。
加入不限数量的不同格式的视频文件
编码模式支持将任何格式，任何类型的文件连接在一起，并根据需要输出到任何格式的文件。支持几乎所有类型的视频格式。
支持多种视频格式
该视频拼接器支持许多视频格式，包括AVI，DivX，MPEG-1，MPEG-2，MPEG-4 VOB，RM，RMVB，ASF，WMV，WMA，3GP（.3gp\.3g2），MP4（.mp4\.m4a\.m4v），MKV，FLV，MTS，MPEG音频和Windows Media音频。
简单的GUI和非常容易使用
支持视频预览
支持“拖放”
通过调整比特率，宽高比，编解码器，帧速率，帧大小等来创建完美的定制视频。
下载地址：http://www.91apps.cn/tag/boilsoft
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c07305ef61fe4582e69e09c763e35f0/" rel="bookmark">
			Codeforces Round #702 (Div. 3) A—G
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. Dense Array 直接模拟即可。
#include &lt;bits/stdc++.h&gt; #define inf 0x3f3f3f3f #define INF 0x3f3f3f3f3f3f3f3f #define ll long long #define ull unsigned long long #define PII pair&lt;int, int&gt; #define PLL pair&lt;ll, ll&gt; #define PIL pair&lt;int, ll&gt; #define endl '\n' #define lson l, m, rt &lt;&lt; 1 #define rson m + 1, r, rt &lt;&lt; 1 | 1 #define IOS std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0) #define debug(x) cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl #define debug2(x, y) cerr &lt;&lt; #x &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c07305ef61fe4582e69e09c763e35f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d201e6c181beb3ca1f29d9b0de970198/" rel="bookmark">
			java maven清理打包运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clean.bat
@echo off echo. echo [信息] 清理生成路径。 echo. %~d0 cd %~dp0 cd .. call mvn clean pause 首先本机得已安装maven，并在命令窗口可执行
注：
%~d0
cd %~dp0 ：更改当前目录为批处理本身的目录
比如你有个批处理a.bat在D:\qq文件夹下 a.bat内容为 cd /d %~dp0 在这里 cd /d %~dp0的意思就是cd /d d:\qq %0代表批处理本身 d:\qq\a.bat ~dp是变量扩充 d既是扩充到分区号 d: p就是扩充到路径 \qq dp就是扩充到分区号路径 d:\qq 扩展阅读： %~dp0 “d”为Drive的缩写，即为驱动器，磁盘、“p”为Path缩写，即为路径，目录 cd是转到这个目录，不过我觉得cd /d %~dp0 还好些 选项语法: ~0 - 删除任何引号(")，扩充 %0 %~f0 - 将 %0 扩充到一个完全合格的路径名(“f”是file，即文件) %~d0 - 仅将 %0 扩充到一个驱动器号 %~p0 - 仅将 %0 扩充到一个路径 %~n0 - 仅将 %0 扩充到一个文件名(“n”是name 文件名) %~x0 - 仅将 %0 扩充到一个文件扩展名 %~s0 - 扩充的路径只含有短名(“s”为Short，短的) %~a0 - 将 %0 扩充到文件的文件属性(“a”为attribute，即属性) %~t0 - 将 %0 扩充到文件的日期/时间(“t”time) %~z0 - 将 %0 扩充到文件的大小(Size 大小) %~$PATH:0 - 查找列在路径环境变量的目录，并将 %0 扩充 到找到的第一个完全合格的名称。如果环境变量名 未被定义，或者没有找到文件，此组合键会扩充到 空字符串 可以组合修饰符来得到多重结果: %~dp0 - 仅将 %0 扩充到一个驱动器号和路径 %~nx0 - 仅将 %0 扩充到一个文件名和扩展名 %~fs0 - 仅将 %0 扩充到一个带有短名的完整路径名 %~dp$PATH:0 - 查找列在路径环境变量的目录，并将 %I 扩充 到找到的第一个驱动器号和路径。 %~ftza0 - 将 %0 扩充到类似输出线路的 DIR %0为当前批处理文件 如果0换成1为第一个文件，2为第2个 package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d201e6c181beb3ca1f29d9b0de970198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0065ea7cef68c2d0ffc07bf96f6c8dc/" rel="bookmark">
			qemu 规范路径,qemu KVM内核模块没有这样的文件或目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I am currently taking an operating systems class and I need to use qemu to run a small operating system that my professor provided. I am trying to use qemu within an ubuntu 12.04 virtual machine on virtualbox on my macbook air 5.2. I know the problems I am having probably have to do with nested virtualization but the specific error I get when I try to run qemu is:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0065ea7cef68c2d0ffc07bf96f6c8dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d0a7175ec17f4bf8081748996dfb317/" rel="bookmark">
			Promise 实现原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这篇文章主要是探究 Promise 的实现原理，对于使用方法，这里不做过多概述，如果还有对 Promise 使用方式不太了解的，可以先看 阮一峰老师的 Promise 教程
Promise 是什么,为什么会出现 Promise？ 抽象表达： Promise 是一门新的技术（ES6规范）Promise 是js 中进行异步变成的新解决方案,在没有 Promise 之前，旧方案是单纯使用回调函数 具体表达： 从语法上来说： promise 是一个构造函数从功能上来说：promise 对象用来封装一个异步操作并可以获取其成功/失败的结果值 作用： Promise 主要是用来解决回调地狱的问题，在没有Promise 之前，如果异步任务比较多，并且有相互依赖的作用，就只能使用回调函数的方式来处理，这样就会形成回调地狱，代码可读性和可维护性会很差。Promise 的 then 方法支持链式调用，很好的解决了之前使用回调函数的书写方式，使代码逻辑很有条理但是Promise 也是有缺点的，首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 Promise 的状态改变 promise 有三种状态
pending (初始状态，或者说是执行中的状态),resolved || fulfilled (已成功，下文中将使用 fulfilled 作为已成功的状态)rejected (已失败)
状态的改变只有两种方式 pending =&gt; fulfilled 或者 pending =&gt; rejected, 并且状态一经改变完成，就不可逆。成功的结果数据一般称为 value 失败的结果数据一般称为 reason Promise 的基本流程如下图 以上对 Promise 做了一个简单的概述，下边我们来实现一个自己的 Promise
Promise 手动实现 首先我们先看下 原生的 Promise 实例对象中都包含的内容：
通过打印看到实例对象的原型上 包含 catch、finally、then、和 constructor 构造函数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d0a7175ec17f4bf8081748996dfb317/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/315941f75150b394776fdd717785829c/" rel="bookmark">
			java创建list对象_java – 创建一个包含多个对象类型的arraylist？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用户定义的类阵列列表示例
import java.util.*;
public class UserDefinedClassInArrayList {
public static void main(String[] args) {
//Creating user defined class objects
Student s1=new Student(1,"AAA",13);
Student s2=new Student(2,"BBB",14);
Student s3=new Student(3,"CCC",15);
ArrayList al=new ArrayList();
al.add(s1);
al.add(s2);
al.add(s3);
Iterator itr=al.iterator();
//traverse elements of ArrayList object
while(itr.hasNext()){
Student st=(Student)itr.next();
System.out.println(st.rollno+" "+st.name+" "+st.age);
}
}
}
class Student{
int rollno;
String name;
int age;
Student(int rollno,String name,int age){
this.rollno=rollno;
this.name=name;
this.age=age;
}
}
节目输出：
1 AAA 13
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/315941f75150b394776fdd717785829c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/813737bb6e4e2ebcaf95bee6e597b8b5/" rel="bookmark">
			【零基础学爬虫】第四章：selenium模块使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、初识selenium
二、selenium使用前准备
三、selenium的使用
1.实例化selenium对象
2.编写基于浏览器自动化的操作代码
四、动作链与iframe
五、iframe总结
六、无头浏览和规避检测
一、初识selenium ①selenium是基于浏览器自动化的一个模块，便捷的获取网站中动态加载的数据（之前文章中使用的ajax方法，很麻烦），便捷实现模拟登录（自动打开网页，进行一系列的点击操作）。
二、selenium使用前准备 ①安装selenium
由于我使用的是anaconda，因此自带selenium。
②下载一个浏览器的驱动程序（谷歌浏览器）
下载路径：http://chromedriver.storage.googleapis.com/index.html
驱动程序和浏览器的映射关系：https://blog.csdn.net/weixin_45532870/article/details/112036377?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161390536416780261967275%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161390536416780261967275&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-112036377.first_rank_v2_pc_rank_v29&amp;utm_term=chromedriver%E4%B8%8Echrome%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%E8%A1%A8
③关于版本选择的说明：
一般直接按照浏览器版本去找对应的driver就行了。
（如果不能一一对应，就找大版本号对应的或者比浏览器版本号稍大的都行）
对于windows的用户来说，win64的操作系统用win32的即可。
所有Chromedriver均可在下面链接找到
④我的驱动版本
可以在谷歌浏览器中输入chrome://version/，查看浏览器版本
⑤将驱动器放置在代码文件中即可 ，稍后使用。
三、selenium的使用 1.实例化selenium对象 from selenium import webdriver #实例化一个浏览器对象（传入浏览器的驱动成） bro = webdriver.Chrome(executable_path='./chromedriver') 2.编写基于浏览器自动化的操作代码 ①发起请求
#让浏览器发起一个指定url对应请求 bro.get('http://scxk.nmpa.gov.cn:81/xk/') 案例一完整代码：
需求：存储动态加载的信息
from selenium import webdriver from lxml import etree from time import sleep #实例化一个浏览器对象（传入浏览器的驱动成） bro = webdriver.Chrome(executable_path='./chromedriver') #让浏览器发起一个指定url对应请求 bro.get('http://scxk.nmpa.gov.cn:81/xk/') #page_source获取浏览器当前页面的页面源码数据 page_text = bro.page_source #解析企业名称 tree = etree.HTML(page_text) li_list = tree.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/813737bb6e4e2ebcaf95bee6e597b8b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5408706172f9a21d7d99aad3b044c227/" rel="bookmark">
			【零基础学爬虫】第五章：scrapy框架的使用（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、安装scrapy
二、创建scrapy工程
三、执行工程
一、安装scrapy ①我使用anaconda安装，步骤如下：
注意：如果手动pip安装，需要安装很多依赖包，所以用anaconda很方便
twisted：为scrapy提供异步下载相关操作
pywin32：①捕获窗口 ②模拟鼠标键盘动作 ③自动获取某路径下文件列表 ④PIL截屏功能
conda install scrapy ②输入scrapy，检测安装成功！
二、创建scrapy工程 1.点击pycharm左下角的terminal，在终端中输入如下命令：
scrapy startproject firsttest（工程名） 2.创建爬虫文件
创建成功后，目录下就会出现创建的工程文件。
—spiders文件夹叫爬虫文件夹，或爬虫目录，在spiders的子目录中要创建一个爬虫文件。相关操作如下：
首先要进入该工程中： cd firsttest 然后输入如下命令：（爬虫文件名字不能和工程名相同，后面的url可以临时写一个，在文件中还可以改） scrapy genspider spiderName www.xxx.com —settings.py是我们当前工程的配置文件。（经常使用）
3.分析爬虫文件（first.py）
点开文件，有一个类，类名就是创建的文件名+Spider，该类的父类是Spider，Spider属于scrapy中的一个类，它是scrapy中所有爬虫类的父类。
文件中有三个属性和一个方法，解释见代码：
import scrapy class FirstSpider(scrapy.Spider): # 爬虫文件的名称：就是爬虫源文件的一个唯一标识 name = 'first' # 允许的域名：用来限定start_urls列表中，哪些url可以进行请求发送。但是通常不会用它 #allowed_domains = ['www.baidu.com'] # 起始的url列表：该列表中存放的url会被scrapy自动进行请求的发送，可以放多个url start_urls = ['http://www.baidu.com/','http://www.sogou.com/'] # 用作于数据解析：response参数表示的就是请求成功后对应的响应对象。parse调用的次数由start_urls列表中元素的个数决定。 def parse(self, response): print(response) # 之后可以执行代码，不要直接run，要在终端中执行。见下面的命令。 三、执行工程 1.编写完代码后，在终端中输入如下命令，即可进行数据的爬取：
scrapy crawl spiderName 2.输出的是日志信息，如果运行中出现了错误，也会显示出来，但是输出中没有我们想要的response，原因如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5408706172f9a21d7d99aad3b044c227/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37bda9ae9c9a6774524a0f14af3d650b/" rel="bookmark">
			python语言中最基本的概念_python基本概念-关键要素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 要素1： 数据类型
Python提供了几种内置的数据类型，现在我们只关注其中两种。Python使用int类型表示整数(正整数或负整数)，使用str类型表示字符串(Unicode字符序列)。
如果需要将一个数据项从某种类型转换为另一种类型，可以使用语法datatype(item),例如：
int()转换可以允许头尾处带有空格，因此，int(‘ 45 ‘)也是正确的。srt()转换计划可以以应用于所有数据项。
2. 要素2：对象引用
定义了数据类型之后，接下来要做的事情就是定义存储某种类型数据的变量，但Python咩有这样的变量，而是使用“对象引用”。对固定对象(比如intS与strS)而言，变量与对象引用之间没有可察觉的差别。对于可变对象，则存在差别，但是在实际工作中很少有影响。如
x = ‘blue’
y = ‘green‘
z = x
执行上面第一条语句时，python会创建一个str对象，其文本内容为“blue”，同时还创建一个名为x的对象引用，x引用的就事这个str对象。通俗说变量x已经被分配了blue这一字符串。
在其他语言中，操作符“=”与变量分配操作符是不一致的。在python中，‘=’的作用是将对象引用于内存中的某种对象进行绑定。
3.要素3：组合数据类型
python提供了几种组合数据类型，包括关联数组与集合等类型，这里我们只讨论其中两种：元组与列表
Python元组与列表可用于存储任意数量、任意类型的数据项；元组是固定的，创建之后救急不能改变；列表是可变的，在需要的时候，可以插入或移除数据项。
实质上，列表与元组并不真正存储数据项，而是存放对象引用。创建列表与元组时(以及在列表中插入数据项时)，实际上是使用其给定的对象引用的副本。在字面意义项(比如整数或字符串)的情况下，会在内存中创建适当数据类型的对象，而存放在列表或元组中的才是对象引用。
元组、列表以及字符串等数据类型是“有大小的”，也就是说，对这些数据类型而言，长度或大小等度量是有意义的，将这些数据类型的数据项做完参数传递给len()函数是有意义的。
所以python数据项都是某种特定数据类型(也称之为“类”)的“对象”(也称之为“实例”)。对象与有些其他语言提供的数据项的关键区别在于，对于可以有“方法”。方法就是某特定对象可以调用的函数。比如数据类型list有一个append()方法，借助于该方法，可以以如下方式添加对象：
在过程型程序设计语言中，以如下的方式(完全有效的python语法)使用列表的append()方法可以完成同样的功能：
list 类型有很多其他方法，包括insert()方法，在某给定的索引位置插入数据项；remove()方法，该方法用于移除某给定索引位置上的数据项。
insert()语法：
list.insert(index,obj)
index -- 对象 obj 需要插入的索引位置。
obj -- 要插入列表中的对象。
remove()语法：
list.remove(obj)
obj -- 列表中要移除的对象
4. 要素4：逻辑操作符
4.1 身份操作符
由于所有的python变量实际上都是对象引用，有时，询问两个货更多的对象引用是否都指向相同的对象是有意义的。is 操作符是一个二元操作符，如果其左端的而对象引用与右端的对象引用指向的而是同一个对象，则会返回true。
需要注意，通常，对intS、strS 以及很多其他数据类型进行比较是没有意义的。
身份比较的一个好处是速度非常快，这是因为，并不必须对进行比较的对象本身进行检查，is 操作符只需要对对象所在的内存地址进行比较--同样的地址存储的而是同样的对象。
最常见的使用is的情况是将数据项与内置的空对象None进行比较，None通常用作位置标记值，指示“未知”或“不存在”，如下
上面使用is not 是对身份测试的反向测试
4.2 比较操作符
、&lt;=、==、!=、&gt;=、
python比较操作符的一个特别好用的特性是可以进行结链比较，如;
4.3 成员操作符
对序列或集合这一数据类型，比如字符串、列表或元组，我们可以使用操作符in 来测试成员关系，用not in 来测试非成员关系。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37bda9ae9c9a6774524a0f14af3d650b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153ca232ea37bab68c63ab5cd72fa79d/" rel="bookmark">
			探究CSS3中的transition和transform属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开门见山的说，transition、transform和translate这三者经常有人搞混，先把这三者做一个简单解释：
transform是 转换，指的是改变所在元素的外观，它有很多种手段(转换函数)来改变外观，例如 位移、缩放、旋转 等，而其中的位移的函数名就叫translate，所以说，translate是transform的一部分。transition是 过渡，指的是某个CSS属性值如何平滑的进行改变，就是平常说的 动效。而transform是没有动画效果，你改变了它的值，元素的样子就唰的改变了。 transition 过渡 基本用法 好，接下来看一下transition的基本用法：
transition: [属性名] [持续时间] [速度曲线] [延迟时间]; 我们可以很方便的用这个过渡来给某一个属性加上好看的动效。例如，高度属性的值改变时，延迟 0.5 秒后以 ease 曲线进行过渡，持续2秒：
transition: height 2s ease .5s; 或者一个属性不够，想要监听所有属性。
transition: all 2s ease .5s; 注意，这里的所有属性是指能进行动画过渡的属性，有很多属性是不能进行过渡的，比如display，你不能让一个div的显示模式慢悠悠的发生过渡。
有了上面的认识时候搭配:hover等可以引起属性值变化的伪类时就可以很轻松的做出一个动画效果：
.box { width: 10px; transition: width 0.4s ease; } .box:hover { width: 50px; } 给多个属性指定同一个过渡 接下来深入一点，如果你想给多个属性指定同一个过渡的时候该怎么做？如下：同时监听宽度和高度进行过渡
transition-property: width, height; transition-duration: 2s; transition-timing-function: ease; transition-delay: .5s; 场面有点控制不住了，其实这四条就是transition属性的四个值，也就是如下写法是等同的：
transition: width 2s ease .5s // 等同于 transition-property: width; transition-duration: 2s; transition-timing-function: ease; transition-delay: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/153ca232ea37bab68c63ab5cd72fa79d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/721e0a1cadc0aa00af717cb07e931909/" rel="bookmark">
			java把excel导入数据库中_Java将Excel表格导入数据库，将数据库中的数据导出到Excel表...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结一下Java将.xls格式的Excel表格导入到Oracle11g数据库。
一、开发环境：
1、jdk "1.8.0_101"
2、Oracle11g
3、eclipse
4、jar包：jxl.jar、ojdbc5.jar
5、Excel表：
6、创建T_USER表：
CREATE TABLE
T_USER
(
id INTEGER PRIMARY KEY,--用户编号
username VARCHAR2(20),--用户名称
password VARCHAR2(15),--密码
email VARCHAR2(30),--邮箱
phone VARCHAR2(15),--电话
address VARCHAR2(50)--地址
);
二、Java代码实现将user.xls文件导入到数据库
1、新建工程toolsUtil，导入jar包
2、新建T_USER实体类：
1 packagecom.Tools.entity;2
3 public classT_USER {4
5 privateString id;6 privateString username;7 privateString password;8 privateString email;9 privateString phone;10 privateString address;11
12 publicT_USER() {13 super();14 }15
16 publicT_USER(String id, String username, String password, String email, String phone, String address) {17 super();18 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/721e0a1cadc0aa00af717cb07e931909/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b09987568e3c42d9dd8ef3dee1cdf417/" rel="bookmark">
			华为机试 java_华为机试练习---java实现电话号码本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package huawei;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.Set;
/**
* java实现电话号码本
* @author USER
*
*/
public class Telephone {
public static void main(String[] args) {
HashMap map = new LinkedHashMap();
String[] info = null;
Scanner in = new Scanner(System.in);
String string = null;
while ((string = in.nextLine()) != null) {
info = string.split(" ");
String command = null;
String name = null;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b09987568e3c42d9dd8ef3dee1cdf417/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bafd0287231c0082fa5aca880b7ba404/" rel="bookmark">
			【硬件】显示器显示超出工作频率范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 开机的时候显示器一直黑屏，显示超出工作频率范围
网上搜了一圈说什么调分辨率，一点用都没有，我桌面都进不去怎么调分辨率。。。无语
解决办法 很简单，很可能是你开机的时候，显示器和电脑的数据线没插好就开机了，所以GPU默认的频率大于你显示器的频率
但是如果GPU和显示器之间有数据线连接的话，GPU是会自动调节频率的，所以把数据线插好后，再重启即可~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5f9e75672cf7b0edc6548ffd18a9af/" rel="bookmark">
			java获取扩展名_Java获取文件扩展名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有时在处理文件时，需要根据文件类型对它们进行不同的处理。 java.io.File没有任何获取文件扩展名的方法，这里提供了一个实用工具方法来获取文件扩展名。
Java获取文件扩展名
在句点(.)之后，文件的扩展名是文件名称的最后一部分。 例如，Java源文件扩展名为java，件名始终以.java结尾。
可以使用此文件名和扩展逻辑来检索文件名的最后部分并获取文件的扩展名。
import java.io.File;
public class GetFileExtension {
/**
* 获取文件名称的Java程序
* @param args
*/
public static void main(String[] args) {
File file = new File("D:/maxsu/java.txt");
System.out.println("File extension is: "+getFileExtension(file));
//文件名没有扩展名
file = new File("D:/maxsu/temp");
System.out.println("File extension is: "+getFileExtension(file));
// 带点的文件名
file = new File("D:/maxsu/java.util.txt");
System.out.println("File extension is: "+getFileExtension(file));
// 隐藏文件没有扩展名
file = new File("D:/maxsu/.htaccess");
System.out.println("File extension is: "+getFileExtension(file));
}
private static String getFileExtension(File file) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b5f9e75672cf7b0edc6548ffd18a9af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4367f60c549bbcbce6a7d00f0b8097e8/" rel="bookmark">
			python中re模块的安装_python库之re模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先：re库中有
__all__ = [ "match", "search", "sub", "subn", "split", "findall",
"compile", "purge", "template", "escape", "I", "L", "M", "S", "X",
"U", "IGNORECASE", "LOCALE", "MULTILINE", "DOTALL", "VERBOSE",
"UNICODE", "error" ]
1.match：
这个函数的意思是从头开始匹配，如果有将匹配上的数据返回，但只返回第一个，如果没有匹配上将返回None,注意，这个函数的弊端就是如果你要找的数据在中间的某个部分，它是不会返回值的，返回None。
pattern = re.compile('\d+')
str = 'bbb1234aaa5678'
m = pattern.match(str)
m=
None
2.search：
为了解决上面的弊端，就出现了这个函数，这个函数可以从任何位置开始匹配，如果匹配上返回第一个数值，否则返回None。
pattern = re.compile('\d+')
str = 'bbb1234aaa5678'
n = pattern.search(str)
print n.group()
# n=
# 1234
3.sub
这个方法是被称作"替换"就是将你要替换的字段用其它的字段进行替换。pattern为匹配规则，strs使我们要进行替换的字符串，m中的hello word 是我们用它去替换我们匹配的东西。
pattern = re.compile('(\w+) (\w+)')
strs = 'hello 123, hello 456'
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4367f60c549bbcbce6a7d00f0b8097e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffae868e35c797e6cb7e1c7ce6ec64f3/" rel="bookmark">
			STL算法 | 查找函数 find()、二分查找binary_search/upper_bound、子序列查找search
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、find系列函数（单个元素顺序查找）1. find 搜索等于 value 的元素。2. find_if 搜索谓词 p 对其返回 true 的元素3. find_if_not 搜索谓词 q 对其返回 false 的元素。测试用例 一、二分查找系列函数（单个元素二分查找）1. lower_bound 二分查找大于等于2. upper_bound 二分查找大于3. equal_range 二分查找等价区间4. binary_search 二分查找是否存在元素value测试用例 三、子序列查找 search1. 使用operator== 比较2. 用给定的二元谓词 p 比较3. 在序列 [first, last) 中搜索 searcher 构造函数中指定的模式测试用例 参考：执行策略：cppreference.com
一、find系列函数（单个元素顺序查找） 该算法提供范围内查找对象的算法，在&lt;algorithm&gt;头文件中定义。
指向首个满足条件的迭代器，或若找不到这种元素则为 last 。
参考自：《https://zh.cppreference.com/w/cpp/algorithm/find》
1. find 搜索等于 value 的元素。 // 在范围 [first, last) 中满足特定判别标准的首个元素 template&lt; class InputIt, class T &gt; constexpr InputIt find( InputIt first, InputIt last, const T&amp; value ); template&lt; class ExecutionPolicy, class ForwardIt, class T &gt; ForwardIt find( ExecutionPolicy&amp;&amp; policy, ForwardIt first, ForwardIt last, const T&amp; value ); 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffae868e35c797e6cb7e1c7ce6ec64f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824df605c1020db2873da44a1b4ff8f5/" rel="bookmark">
			java获取response地址与参数_HttpServletResponse获取请求参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		![](https://box.kancloud.cn/33de5fd7d0e5041bb6452107d8bcc4a0_491x243.png)
HelloServlet.java
~~~
package zyw.servlet;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
public class HelloServlet extends HttpServlet {
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
//System.out.println("接收到get请求");
//获取请求行
/* System.out.println("请求方式："+req.getMethod());
System.out.println("URI："+req.getRequestURI());
System.out.println("发出请求客户端IP地址："+req.getRemoteAddr());
System.out.println("服务点接收请求的IP地址："+req.getLocalAddr());
System.out.println("访问客户端的端口号："+req.getRemotePort());
System.out.println("web应用路径："+req.getContextPath());
System.out.println("http协议和版本："+req.getProtocol());*/
//获取请求头
// Enumeration枚举类型
/* Enumeration headerNames = req.getHeaderNames();//自动补全变量名称 : Ctrl + Alt + v
while (headerNames.hasMoreElements()){
String element = headerNames.nextElement();
System.out.println(element+":"+req.getHeader(element));
}*/
//获取请求参数
String name = req.getParameter("name");
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824df605c1020db2873da44a1b4ff8f5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/336/">«</a>
	<span class="pagination__item pagination__item--current">337/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/338/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>