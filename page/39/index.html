<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b99b7ccc4b8168f1c3c9998713fa7bd/" rel="bookmark">
			如何用Jmeter对数据库执行压力测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在我看来压力测试的压测对象可以分为UI，接口及数据库三个部分吧，对界面及接口进行压测还算熟悉，
定位性能瓶颈，对数据库SQL执行压测也是需要做的。工具呢？还是Jmeter
1、将需要用到的链接Oracle的架包放到jmeter中 在数据库服务器安装路径下，找到ojdbc5.jar，D:\app\Administrator\product\11.2.0\dbhome_1\jdbc\lib
拷贝到jmeter/lib中
2、配置Jmeter （1）新建线程组
鼠标右击测试计划，选择 添加--Thread--线程组
（2）添加JDBC Connection Configuration （3） 配置JDBC Connection Configuration （4）从取样器sampler中添加 JDBC Request
（5）添加监听器 查看结果树、设置断言
（6） 运行测试，查看查询结果
（7）设置集合点、线程数、循环控制器循环次数即可执行压测试，不必多说
3、常用数据库驱动类及数据库地址配置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78285364df47319392a6b51bdc64eda8/" rel="bookmark">
			python request Session机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发送一个 HTTP请求的过程 TCP建立链接
1.请求行= 请求方式(get/post) + URL+ HTTP/1.1 协议
2.请求头 request header
3.Request body
发送一个HTTP请求头
返回一个请求头的response
如果有request body
再次发送(第二次自动发送)request body
再接收一个request body的响应体
1.响应行 = HTTP/1.1 200响应码 OK描述
2.响应头 data-type contend-lens
3.响应体 data
Requests
Url =’’
Headers={}
Data = {}
Requests.get(url,headers,data)
Request.headers Response.encoding=’utf8’
Response.headers
Response.text 直接文本信息
response.content 字节串内容
response.content.decode(‘utf8’) 如果乱码则使用解码utf8显示中文
Request中的 Session机制
Session =request.Session()
Session.post(url,headers,data)
这时使用的是同一个session,那么直接就可以把cookie的sessionid自动装入request header
Session.get(url,headers,data)
Request.get和 session.get方法一样
Response body:
Content-Type: application/json; charset=utf-8
Date: Mon, 11 Mar 2024 07:55:35 GMT
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78285364df47319392a6b51bdc64eda8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3652f3071826e61150fd3b836f0f09bd/" rel="bookmark">
			HTTP相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.http协议有哪几种常用请求方式？ GET, POST , PUT, DELETE
2.get和post请求区别是什么? 根据HTTP协议，原则上,
get: 拼接url, 长度很有限，切相对安全性差
post: request body,相对安全性好
原则上, get只有请求头部分，发送一次就结束了
post请求带request body，第一次发送reques header,还要第二次发送requestbody 才把所有内容发送完成。
3.常见的 POST 提交数据方式 ①Json ②url encoding ③XML application/x-www-form-urlencoded
multipart/form-data
application/json
text/xml
4.cookies机制和session机制的区别，HTTP无状态协议变为HTTP有状态协议 都是解决登录后持续访问的问题：
客户端浏览器第一次发起请求提交登录信息给服务器后端，
建立一个唯一sessionid，保存在服务器，并返回响应Set-Cookie，
在客户端浏览器存储下这个sessionid，当端浏览器第二次通过这个url下发起HTTP请求时，请求头中自动携带这个Cookie存放的sessionid发送到服务器，服务器通过这个session唯一标识一个用户信息。
5.发送一个 HTTP请求报文的过程 TCP建立链接
请求报文
1.请求行= 请求方式(get/post) + URL+ HTTP/1.1 协议
2.请求头 request header
3.Request body
发送一个HTTP请求头
返回一个请求头的response
如果有request body
再次发送(第二次自动发送)request body
再接收一个request body的响应体
响应报文
1.响应行 = HTTP/1.1 200响应码 OK描述
2.响应头 data-type contend-lens
3.响应体 data
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3652f3071826e61150fd3b836f0f09bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644278fef7f318e1b394fa94ad52a027/" rel="bookmark">
			LM2904DT运算放大器中文资料规格书PDF数据手册引脚图参数图片功能概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品概述：
该电路由两个独立的高增益运算放大器（运算放大器）组成，内部实现了频率补偿。它们专为汽车和工业控制系统而设计。该电路采用单电源供电，工作电压范围很广。低功耗与电源电压的大小无关。
应用领域包括传感器放大器、直流增益模块和所有传统的运算放大器电路，这些电路现在可以更容易地在单电源系统中实现。例如，这些电路可直接由逻辑系统中使用的标准5 V供电，无需任何额外电源即可轻松提供所需的电子接口。
在线性模式下，输入共模电压范围包括地电位，输出电压也可以摆动至地，即使采用单电源供电也是如此。
产品功能：
内部实现频率补偿大直流电压增益：100 dB宽带宽（单位增益）：1.1 MHz（温度补偿）极低的电源电流/放大器，基本上与电源电压无关低输入偏置电流：20nA（温度补偿）低输入失调电流：2nA输入共模电压范围包括负电源轨差分输入电压范围等于电源电压大输出电压摆幅 0 V 至 [（V抄送 +） -1.5 伏] 规格书参数：
引脚图：
元件封装尺寸图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39f6c7c404f85aa6a21af9fca6456e1d/" rel="bookmark">
			Linux第75步_pinctrl子系统驱动和gpio子系统的常用函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、STM32MP1的pinctrl子系统驱动
pinctrl子系统源码目录为drivers/pinctrl，一个PIN最好只能被一个外设使用。
“stm32mp151.dtsi”中有一个“pin-controller节点标签”叫pinctrl
pinctrl: pin-controller@50002000 {
#address-cells = &lt;1&gt;;
/*定义子节点的reg和ranges的addres长度为32个位*/
#size-cells = &lt;1&gt;; /*定义子节点的reg和ranges的length长度为32个位*/
compatible = "st,stm32mp157-pinctrl";
/*compatible属性用于将设备和驱动绑定起来*/
ranges = &lt;0 0x50002000 0xa400&gt;; /*子节点寄存器起始地址为0*/
/*父节点寄存器起始地址为0x50002000*/
/*寄存器最大偏移地址为0xa400*/
interrupt-parent = &lt;&amp;exti&gt;;
st,syscfg = &lt;&amp;exti 0x60 0xff&gt;;
hwlocks = &lt;&amp;hsem 0 1&gt;;
pins-are-numbered;
gpioa: gpio@50002000 { /*子节点gpio起始地址为0x50002000*/
gpio-controller;
#gpio-cells = &lt;2&gt;;
/*定义描述使用一个gpio口需要提供2个指定的参数*/
interrupt-controller;
#interrupt-cells = &lt;2&gt;;
reg = &lt;0x0 0x400&gt;; /*reg属性的值:当前节点寄存器起始地址为0，长度为0x400*/
clocks = &lt;&amp;rcc GPIOA&gt;;
st,bank-name = "GPIOA";
status = "disabled";
};
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39f6c7c404f85aa6a21af9fca6456e1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/521f8ee1de1287655ee0e1dfc69b33f9/" rel="bookmark">
			Linux第76步_“gpio子系统”下的LED驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用新字符设备驱动的一般模板和“gpio子系统”，以及设备树，驱动LED。
1、添加“gpio_led”节点
打开虚拟机上“VSCode”，点击“文件”，点击“打开文件夹”，点击“zgq”，点击“linux”，点击“atk-mp1”，点击“linux”，点击“my_linux”，点击“stm32mp157d-atk.dts”。
stm32mp157d-atk.dts文件如下：
/dts-v1/;
#include "stm32mp157.dtsi"
#include "stm32mp15xd.dtsi"
#include "stm32mp15-pinctrl.dtsi"
#include "stm32mp15xxaa-pinctrl.dtsi"
#include "stm32mp157-m4-srm.dtsi"
#include "stm32mp157-m4-srm-pinctrl.dtsi"
#include "stm32mp157d-atk.dtsi"
/ {
model = "STMicroelectronics STM32MP157D eval daughter";
/*model属性用于描述开发板的名字或设备模块的信息*/
compatible = "st,stm32mp157d-ed1", "st,stm32mp157";
/*compatible属性用于将设备和驱动绑定起来*/
chosen { /*chosen子节点*/
stdout-path = "serial0:115200n8";
};
aliases { /*aliases子节点*/
serial0 = &amp;uart4;
/*给&amp;uart4起个别名叫“serial0”*/
};
reserved-memory {
gpu_reserved: gpu@f6000000 { /*gpu节点标签为gpu_reserved*/
reg = &lt;0xf6000000 0x8000000&gt;;
no-map;
};
optee_memory: optee@fe000000 {
reg = &lt;0xfe000000 0x02000000&gt;;
no-map;
};
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/521f8ee1de1287655ee0e1dfc69b33f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b3c0c2241eed4c01bcdf93a1754179/" rel="bookmark">
			C#请假加班案例（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		增加id输入框，用来进行多人管理。增加了一个Person类，请假和加班可以视为该类的方法。多人用Person数组表示, id-1等于数组的索引。
class Person { public int id; public int days; public void qingjia(int qjDays) { this.days -= qjDays; } public void jiaban(int jbDays) { this.days += jbDays; } } ... Person p1=new Person(); Person p2=new Person(); Person[] arr=new Person[2]; private void InitializeComponent() { this.p1.id = 1; this.p1.days = 10; this.p2.id=2; this.p2.days = 20; this.arr[0] = p1; this.arr[1] = p2; } 请假按钮点击事件处理方法： private void button1_Click(object sender, EventArgs e) { //请假 if (String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b3c0c2241eed4c01bcdf93a1754179/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc446de26738396da1de0fefc3b3a735/" rel="bookmark">
			SQL 优化实践：关于增强 OceanBase本地索引性能的案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文通过一个案例，帮用户了解在Oracle迁移Oceanbase时，应该如何选择全局索引和本地索引以带来更好的SQL性能。
作者：胡呈清，爱可生的DBA团队成员，擅长故障分析和性能优化。本文约 5000 字，预计阅读需要 15 分钟。 数据库版本：OceanBase V3.2.3.3 案例的问题描述 在进行 Oracle 到 OceanBase的迁移过程中，有张表无法关闭 row movement 功能，导致无法使用 OMS直接迁移数据。为了解决这个问题，在割接窗口期之前，采用 dbcat 工具单独迁移该表结构，在窗口期内，通过数据导入的方式特别处理了这张表。
这是一张分区表，在 Oracle 数据库中，其主键约束并未包含分区键。然而OceanBase数据库要求主键必须包含分区键。因此，在进行Oracle数据迁移至 OceanBase 的过程中，我们有两种不同的处理方式：
OMS 工具：迁移时会将主键转成 全局唯一索引 +NOT NULL 约束，等价 Oracle 的主键约束。表没有显示主键，但会有一个隐式主键（分区键+隐藏自增列）；dbcat 工具：迁移时会把分区键加入到主键中，这是个本地索引。 这里最主要的区别是：Oracle 上的主键是全局索引，用 dbcat 迁移到 OB 时会变成本地索引，用 OMS 迁移则还是全局索引。然后以下 SQL 做 nested-loop join 时关联字段是主键字段，每次到被驱动表上使用主键查找，需要对所有分区执行，因此慢了。
注：OMS、dbcat 都是迁移工具，不用深究，只需理解为什么会有这种区别即可，下面会做解释。 select * from ( SELECT a.act_Id as actId, a.data_Id as dataId, ... from T1 a, T2 b where a.data_Id = b.data_Id and a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc446de26738396da1de0fefc3b3a735/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b4fbadfa3a16b2ef03bf46968fe9d46/" rel="bookmark">
			Suervisor http://localhost:9001 refused connection
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(desk_env) root@vdi:/opt/pyenv/desk_env/bin# supervisorctl http://localhost:9001 refused connection 当后台启动supervisord后，使用supervisorctl命令进行任务管理时，
一、报错原因：
http://localhost:9001 refused connection
显示拒绝连接
二、问题原因分析：
因为supervisor通常有以下两种方式通信：
1、本地socket
2、http连接
在supervisor.conf配置文件中，启用socket连接，注释http方式，supervisorctl配置项也使用unix socket
[unix_http_server]
file=/var/run/supervisor.sock ; the path to the socket file
;chmod=0700 ; socket file mode (default 0700)
;chown=nobody:nogroup ; socket file uid:gid owner
;username=user ; default is no username (open server)
;password=123 ; default is no password (open server)
;[inet_http_server] ; inet (TCP) server disabled by default
;port=127.0.0.1:9001 ; ip_address:port specifier, *:port for all iface
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b4fbadfa3a16b2ef03bf46968fe9d46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75b7f5eee437ef6fbdbaf31e6cfa7829/" rel="bookmark">
			郭炜老师mooc第十一章数据分析和展示(numpy,pandas, matplotlib)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多维数组库numpy numpy创建数组的常用函数 # numpy数组 import numpy as np #以后numpy简写为np print(np.array([1,2,3])) #&gt;&gt;[1 2 3] print(np.arange(1,9,2)) #&gt;&gt;[1 3 5 7] 不包括9 print(np.linspace(1,10,4)) #&gt;&gt;[ 1. 4. 7. 10.] # linespace(x,y,n)，创建一个由区间[x,y]的n-1等分点构成的一维数组，包含x和y print(np.random.randint(10,20,[2,3])) #&gt;&gt;[[12 19 12] #&gt;&gt; [19 13 10]] print(np.random.randint(10,20,5)) #&gt;&gt;[12 19 19 10 13] a = np.zeros(3) print(a) #&gt;&gt;[ 0. 0. 0.] print(list(a)) #&gt;&gt;[0.0, 0.0, 0.0] # 列表每个元素之间有一个逗号隔开 a = np.zeros((2,3),dtype=int) #创建一个2行3列的元素都是整数0的数组 print(a) numpy数组常用属性和函数 # numpy数组常用属性和函数 import numpy as np b = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75b7f5eee437ef6fbdbaf31e6cfa7829/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/577e09b3e6259287c77a25ccee0ccd00/" rel="bookmark">
			【Java】main方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在Java中，main方法是程序的入口点。当你运行一个Java应用程序时，Java虚拟机（JVM）会寻找并调用该类的main方法作为程序执行的开始。下面，我将详细解释Java main方法的使用。
main方法的签名
main方法具有特定的签名，它必须被声明为public，返回类型必须是void，并且它必须接受一个String数组作为参数。这是main方法的标准定义：
public static void main(String[] args) { // 程序执行的代码放在这里 } public：这意味着这个方法可以从任何其他类中被访问。static：这意味着这个方法属于类本身，而不是类的任何特定实例。因此，你可以在没有创建类的实例的情况下调用它。void：这表示该方法不返回任何值。String[] args：这是传递给main方法的参数，它是一个字符串数组。这个数组包含了从命令行传递给Java应用程序的参数。
使用main方法 当你编写一个Java应用程序时，你需要在某个类中包含一个main方法作为程序的入口点。下面是一个简单的示例，展示了如何使用main方法：
public class HelloWorld { public static void main(String[] args) { // 输出"Hello, World!"到控制台 System.out.println("Hello, World!"); // 如果命令行参数被提供，打印它们 for (String arg : args) { System.out.println("Argument: " + arg); } } } 要运行这个程序，你需要将其保存为一个名为HelloWorld.java的文件，然后使用Java编译器编译它：
javac HelloWorld.java 这将生成一个名为HelloWorld.class的字节码文件。然后，你可以使用java命令来运行程序：
java HelloWorld 这将在控制台上输出“Hello, World!”。如果你还希望在运行时传递一些参数给程序，你可以在命令后面加上它们：
java HelloWorld arg1 arg2 arg3 在上面的例子中，arg1、arg2和arg3将被作为字符串存储在args数组中，并可以在main方法内部被访问和处理。
注意事项：
main方法必须放在公共类中，并且这个类必须与包含它的文件名相同（公共类的名称必须与文件名相同）。你可以在一个Java文件中定义多个类，但只有一个类可以有main方法，并且这个类应该是公共类。main方法是程序的入口点，它是JVM启动应用程序时首先调用的方法。你可以通过命令行参数来向main方法传递数据，这在配置应用程序行为或处理用户输入时非常有用。 总结：
main方法由java虚拟机调用java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是publicjava寻积极在执行main()方法是不必创建对象，所以该方法必须是staticmain方法接收String类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数java 执行的程序 参数1 参数2 参数3main方法（静态方法）可以直接访问本类中的静态成员，但不能访问本类中的非静态成员，如果要访问非静态成员必须实例化一个对象，通过本类的实例去调用非静态成员 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3236de53819ef1003aed0d3c4256131b/" rel="bookmark">
			在jupyternotebook中，如何解决作图时负号无法显示的问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入以下代码即可。
import matplotlib as mpl mpl.rcParams['axes.unicode_minus'] = False 原文链接：在jupyternotebook中，如何解决作图时负号无法显示的问题？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d8d78cc1855ba0c2d3de3150753c4ea/" rel="bookmark">
			【Java】类变量和类方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java语言中，类变量（也称为静态变量）和类方法（也称为静态方法）都是使用static关键字来定义的。类变量属于类本身，而不是类的任何特定实例。类方法也是属于类本身，而不是类的实例。它们可以在没有创建类的实例的情况下被访问。
类变量（静态变量） 类变量定义在类体中，但在任何方法之外，并且使用static关键字声明。类变量在类被加载到JVM时初始化，并且只存在一份，被类的所有实例共享。
public class MyClass { // 这是一个类变量（静态变量） public static int classVariable; // 其他类成员... } 类方法（静态方法） 类方法也是使用static关键字声明的，并且它们可以直接通过类名来调用，而不需要创建类的实例。类方法只能直接访问类变量和其他类方法，如果要访问实例变量或实例方法，则需要通过类的实例来访问。
public class MyClass { // 类变量 public static int classVariable = 42; // 这是一个类方法（静态方法） public static void classMethod() { System.out.println("This is a class method."); System.out.println("The value of classVariable is: " + classVariable); } // 其他类成员... } 使用示例
类变量和类方法的使用如下所示：
public class Main { public static void main(String[] args) { // 直接通过类名访问类变量 System.out.println(MyClass.classVariable); // 输出：42 // 直接通过类名调用类方法 MyClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d8d78cc1855ba0c2d3de3150753c4ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153a1eb14272cc0edc1d86b99085e245/" rel="bookmark">
			Qt的信号槽机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是元对象编译器和元对象系统？ 在开始讲信号槽之前，我们先了解下Qt的框架的核心组成部分，Qt的元对象编译器（MOC）和元对象系统是Qt框架的核心组成部分，它们使得Qt拥有了信号与槽机制、反射（introspection）和属性系统等强大的特性。下面分别解释这两个概念：
1.1 元对象编译器（MOC） 元对象编译器是Qt特有的一个预处理器，它不是标准C++的一部分。MOC会处理使用了Qt的特殊宏（如`Q_OBJECT`、`signals`、`slots`等）的C++头文件。它的主要任务是为使用了这些宏的类生成额外的C++源代码文件。这个生成的源文件包含了元信息以及信号和槽机制所需的实现代码。
MOC生成的代码包括但不限于：
- 类的元信息（类名、父类、信号和槽的名称等）。
- 用于实现信号和槽机制的函数，包括信号发射的存根和用于槽调用的代码。
- 用于动态属性系统的代码。
- 实现Qt的反射机制的代码，允许在运行时查询对象的类型信息和成员函数。
1.2 元对象系统 元对象系统是Qt运行时环境的一部分，它使用MOC生成的代码来提供动态特性，如：
- 信号与槽：一个高级的事件订阅和通知机制，用于对象间的通信。
- 对象反射：允许在运行时查询对象的类型信息（如它的类名、它继承的基类、它拥有的信号和槽）。
- 属性系统：允许在运行时查询和修改对象的属性。
- 动态方法调用：允许在运行时调用对象的方法。
每个通过`Q_OBJECT`宏声明的类，都能在运行时通过其元对象(`QMetaObject`)来访问这些特性。`QMetaObject`实例包含了关于其对应类的所有信息，包括信号、槽、属性等。这种机制使得Qt的对象可以在运行时进行更多动态操作。
简而言之，元对象编译器为元对象系统生成必需的胶水代码，而元对象系统则利用这些代码，在运行时提供动态的、反射式的特性。这两个元素共同构成了Qt框架中对象间通信和动态类型管理的基础。
2. 信号槽机制 2.1 元对象编译器（MOC）: MOC扫描通过`Q_OBJECT`宏标记的类，并为这些类生成附加的C++代码。这个代码包括信号和槽的定义，以及类的元信息（如类名、信号/槽列表、属性等）。 假设有如下类定义：
class MyClass : public QObject { Q_OBJECT public: MyClass(QObject *parent = nullptr) : QObject(parent) signals: void mySignal(int); public slots: void mySlot(int); }; MOC将为此类生成一个名为`moc_myclass.cpp`的源文件，其中包含了用于信号和槽的实现细节。这个文件通常包括：
- 信号的存根（stub）函数
- 类的元信息（元对象代码）
- 用于调用槽的静态函数
2.1.1 信号的存根（stub）函数是什么？ 在Qt的信号和槽机制中，信号的存根（stub）函数是MOC生成的一段代码，它充当信号的实现。在Qt中，信号函数本身是不包含用户定义的实现的；你只需要在类的头文件中声明它们。当你在代码中发射（emit）一个信号时，实际上是调用了这个存根函数。
存根函数的主要职责是通知Qt元对象系统有信号发生，并传递任何相关的参数。然后，元对象系统负责调用和这个信号相关联的所有槽函数。
这里是一个信号存根函数的简化示例（伪代码）：
// MyClass 类中的信号声明部分 class MyClass : public QObject { Q_OBJECT public: .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/153a1eb14272cc0edc1d86b99085e245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2d057fc21195b1e489d00fe4cf53e42/" rel="bookmark">
			msql检索包含中文的记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于业务中需要检索包含中文的条目
SELECT * FROM ptstrategy_table WHERE length(`name`)!=char_length(`name`) 这个SQL用了MySQL中字符串长度函数 LENGTH() 和 CHAR_LENGTH() 的不同。
在 MySQL 中：
LENGTH() 函数返回字符串的字节数。CHAR_LENGTH() 函数返回字符串的字符数。 对于大多数英文字符或数字，一个字符占用一个字节。但对于一些特殊字符，特别是中文字符，一个字符可能占用多个字节。
当一个字段包含中文时，它的 LENGTH() 和 CHAR_LENGTH() 就会不相等，因为中文字符所占的字节数大于1。
所以，这个 SQL 语句 SELECT * FROM ptstrategy_table WHERE LENGTH(name) != CHAR_LENGTH(name) 就是在找出字段 name 中包含有多字节字符的行，从而达到了检索字段中是否含有中文的目的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb0814324539750ad1780c72ff08c763/" rel="bookmark">
			【点云】激光点云建图评测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		处理工具 Pcap合并软件 sudo apt install wireshark-common 合并Pcap文件，路径为数据文件夹下， #mergecap -w &lt;输出的新Pcap&gt; &lt;输入的Pcap&gt; mergecap -w lidar_output.pcap slice2099-06-01/LIDAR/lidar.pcap slice2099-06-02/LIDAR/lidar.pcap 可视化软件
Meshlab、禾赛Pandar View 点云3D重建的评测 1. 平面特征厚度 从点云LAS文件提取地面厚度指标：输入采样点坐标文件，输出各个采样点为中心 X m 2 Xm^2 Xm2最大厚度、90%最大厚度、厚度标准差与RMS等，类似标志牌的点云厚度评测。
2. 控制点精度 控制点绝对精度评测 3. 世界坐标点云重投影图像帧匹配精度 基本过程描述：某一时刻图像，查询INS位姿，利用Tci计算相机位姿，
点云从世界坐标转换到相机坐标，利用齐次坐标表达，
T c i ∗ T i w ∗ P w T_{ci}*T_{iw}*P_w Tci​∗Tiw​∗Pw​
相机重投影
p = K [ R ∣ t ] X p=K[R|t]X p=K[R∣t]X
问题：重投影点云与图像特征距离偏大。
分析：LiDAR与INS的外参或INS与相机的外参误差过大。
验证方法：LiDAR与INS采用连续时间系统标定，与依靠INS定位的标定参数比对；标定Camera-LiDAR外参作真值，检验外参标定结果。
解决：相机与INS的外参Tci中的Z轴加0.3度，平移量z轴减去0.1m,使得某设备某次的建图重投影OK；建议LiDAR与INS的标定方法与相机和INS的标定在原理保持一致。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c36d3f253017621c309bcb5aafc99194/" rel="bookmark">
			Mybatis操作sql报错ibatis.binding.BindingException: Parameter ‘empId‘ not found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 你们好，我是金金金。
场景 在使用Mybatis操作sql语句过程当中，更新操作，报错信息如下：Caused by: org.apache.ibatis.binding.BindingException: Parameter ‘empId’ not found. Available parameters are [arg1, arg0, param1, param2]，未找到参数“empId”。 可用参数为 [arg1, arg0, param1, param2] 附上代码
mapper接口
mapper.xml文件
test
排查 从报错信息得知：可用参数为[arg1, arg0, parma1, param2]，mybatis底层是做了处理的，这种写法是识别不到你自定义写的字段的，可以使用arg0，或者parma1来替代使用，arg0代表的是第一个参数，parima则是从1开始。 我这里就测试arg0和arg1这种方式了。
可以看到没有任何问题，但是不推荐上面这种写法，参数多了容易混淆，导致蒙蔽，以下有一种更好的写法，请继续往下看
解决 使用@Param注解标记方法参数，明确指定参数的名称，这样xml文件就可以识别到了 测试 没毛病！！！
编写有误还请大佬指正，万分感谢。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fd8c39f27f52b6a5eee3adc53840ff6/" rel="bookmark">
			【MySQL】-MVCC多版本并发控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、当前读 select 不加锁状态，当前读=快照读
2、快照读 在select加锁下，读取数据后，形成快照。每个事务都会形成自己的快照内容
SELECT * FROM xx_table LOCK IN SHARE MODE; SELECT * FROM xx_table FOR UPDATE; INSERT INTO xx_table ... DELETE FROM xx_table ... UPDATE xx_table ... 仅RC、RR支持快照读
3、RC级别 在事务中，每次select 都会读取最新记录，形成快照，产生不可重复读问题
4、RR级别 在事务中，只有第一次select读取最新数据，形成快照。
在该事务中更新内容，然后更新快照。后面直接读取快照内容。
5、行记录存在隐藏字段 1、db_row_id：如果表中没有主键索引，则创建默认主键ID
2、db_trx_id：当前数据最近一次修改的事务ID
3、roll_prt：回滚指针，记录上一次的版本，引用 undolog 的上一个版本的快照地址
6、Read View 多事务下
用于解决本次事务应该看到哪个快照，不应该看到哪个快照。
主要属性说明：
●trx_ids，系统当前未提交的事务 ID 的列表。
●low_limit_id，应该分配给下一个事务的id 值。
●up_limit_id，未提交的事务中最小的事务 ID。
●creator_trx_id，创建这个 Read View 的事务 ID。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19014c9bbef6bda89f24d39ba1e459b1/" rel="bookmark">
			【Python】一文详细介绍 plt.rcParamsDefault 在 Matplotlib 中的原理、作用、注意事项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Python】一文详细介绍 plt.rcParamsDefault 在 Matplotlib 中的原理、作用、注意事项
🌈 个人主页：高斯小哥
🔥 高质量专栏：Matplotlib之旅：零基础精通数据可视化、Python基础【高质量合集】、PyTorch零基础入门教程👈 希望得到您的订阅和支持~
💡 创作高质量博文(平均质量分92+)，分享更多关于深度学习、PyTorch、Python领域的优质内容！（希望得到您的关注~）
🌵文章目录🌵 📚 一、plt.rcParamsDefault 的基本概念🎨 二、plt.rcParamsDefault 的作用🔍 三、plt.rcParamsDefault 的注意事项💡 四、plt.rcParamsDefault 的高级用法💻 五、plt.rcParamsDefault 的代码示例🤝 六、期待与你共同进步🔍 关键词 📚 一、plt.rcParamsDefault 的基本概念 在 Matplotlib 这个强大的 Python 数据可视化库中，plt.rcParamsDefault 是一个非常重要的属性，它存储了 Matplotlib 的默认配置参数。这些参数决定了图表的各种外观属性，比如线条的颜色、宽度、类型，字体的大小、样式，坐标轴的标签、刻度等。通过修改这些默认参数，我们可以轻松地定制出符合自己需求的图表样式。
要了解 plt.rcParamsDefault 的工作原理，首先需要明白 Matplotlib 是如何根据这些参数来绘制图表的。当我们调用 Matplotlib 的绘图函数时，它会根据当前的配置参数来渲染图表。而 plt.rcParamsDefault 就是这些配置参数的默认集合，它包含了 Matplotlib 在没有用户干预的情况下会使用的所有默认设置。
🎨 二、plt.rcParamsDefault 的作用 plt.rcParamsDefault 的作用主要体现在以下几个方面：
提供统一的图表风格：通过设置默认的参数值，plt.rcParamsDefault 确保了在没有用户自定义样式的情况下，所有使用 Matplotlib 绘制的图表都具有统一的外观风格。
简化图表定制过程：通过修改 plt.rcParamsDefault 中的参数值，我们可以一次性地改变多个图表的样式，而无需在每个绘图函数中单独设置。这大大简化了图表定制的过程，提高了工作效率。
保持代码的一致性：使用 plt.rcParamsDefault 可以确保我们的代码在样式设置上保持一致，避免因为不同人使用不同的样式设置而导致的图表外观差异。
🔍 三、plt.rcParamsDefault 的注意事项 在使用 plt.rcParamsDefault 时，需要注意以下几点：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19014c9bbef6bda89f24d39ba1e459b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839ec9f46c66b875f85185edc0792913/" rel="bookmark">
			Vue3：watch监视的5种情况
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、情景说明 在Vue2中，watch的用法如下
https://blog.csdn.net/Brave_heart4pzj/article/details/135604394
这一篇，来学习Vue3中的watch用法
二、案例 1、监视ref定义的数据【基本类型】 引入函数
import {ref,watch} from 'vue' 定义变量
// 数据 let sum = ref(0) watch监视变量
注意：
1、监视的ref变量，不可以写成sum.value
2、这里居然可以递归调用哦！！！
// 监视，情况一：监视【ref】定义的【基本类型】数据 const stopWatch = watch(sum,(newValue,oldValue)=&gt;{ console.log('sum变化了',newValue,oldValue) if(newValue &gt;= 10){ stopWatch() } }) 2、监视ref定义的数据【对象类型】 引入函数
import {ref,watch} from 'vue' 定义变量
// 数据 let person = ref({ name:'张三', age:18 }) watch监视变量
监视的是对象的地址值
若想监视对象内部属性的变化，需要手动开启深度监视
watch的第一个参数是：被监视的数据
watch的第二个参数是：监视的回调
watch的第三个参数是：配置对象（deep、immediate等等…）
注意：
如果这里不配置deep项，则修改person里面的属性，不会触发监视。
watch(person,(newValue,oldValue)=&gt;{ console.log('person变化了',newValue,oldValue) },{deep:true}) 3、监视reactive定义的数据 引入函数
import {reactive,watch} from 'vue' 定义变量
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/839ec9f46c66b875f85185edc0792913/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/38/">«</a>
	<span class="pagination__item pagination__item--current">39/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/40/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>