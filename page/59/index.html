<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6a01ba55c555d31368bec4602096a4/" rel="bookmark">
			react学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、react基础 5.loadsh使用排序8.ref获取DOM对象10.props使用*13.UseEffect17. UseMemouseCallbackuseRequest 二、 react使用redux三、美团外卖项目完成页面制作使用redux渲染页面使用react-router-dom重定向默认路由 查看评价封装request请求Token管理 一、react基础 jsx
大括号的作用
{count} {userLlist.map((item)=&gt;{return &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;}) } key是用于react内部渲染处理的 基础条件渲染 {flag &amp;&amp; &lt;p&gt;{"显示"}&lt;/p&gt;} 复杂条件渲染 function getItem(){ if(type==1) return &lt;p&gt;有图模式&lt;p/&gt; else if(type==2) return &lt;&gt;无图&lt;/&gt; } 2、useState使用
state是状态变量，数据变化视图变化
const [userList,setUserList]=useState([{id:1,name:"z"}]) 3.map,filter函数使用
4.tab切换功能实现
const tab={{type:" ",text:" "}} //将type设为class高亮 5.loadsh使用排序 import * as _ from 'lodash' setCommentList(_.orderby(commentList,'star'//字段名，'desc')) //不改变原数组 6.classnames优化类名控制
7.受控绑定表单
&lt;input value={value} onChange={(e)=&gt;{ setValue(e.target.value); //显示输入 }} type='text' /&gt; 8.ref获取DOM对象 const inputRef=useRef(null); &lt;input ref={inputRef}/&gt; //使用inputRef.current获取DOM对象 9.uuid和dayjs库的使用
10.props使用 用于父传子组件消息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6a01ba55c555d31368bec4602096a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74856e474d82589099851b8a0334c9ba/" rel="bookmark">
			MQTT通信协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：MQTT协议介绍 MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，它是一种轻量级的、基于代理的“发布/订阅”模式的消息传输协议。其具有协议简洁、小巧、可扩展性强、省流量、等优点。可在不可靠的网络环境中进行扩展，适用于设备硬件存储空间或网络带宽有限的场景。使用MQTT协议，消息发送者与接收者不受时间和空间的限制。物联网平台支持设备使用MQTT协议接入。
二：MQTT协议的主要特点 1、使用发布/订阅消息模式，提供一对多的消息发布，解除应用程序耦合
2、使用 TCP/IP 提供网络连接
3、有三种级别的消息发布服务质量QoS(Quality of Service)
“至多一次”(Qos = 0)，消息发布完全依赖底层 TCP/IP 网络。会发生消息丢失或重复。这一级别可用于如下情况，环境传感器数据，丢失一次读记录无所谓，因为不久后还会有第二次发送。
“至少一次”(Qos = 1)，确保消息到达，但消息重复可能会发生。
“只有一次”(Qos = 2)，确保消息到达一次。消息丢失和重复都是不可接受的，使用这个服务质量等级会有额外的开销。
三：MQTT协议的核心角色 MQTT 协议主要有三大核心角色：发布者（Publisher）、Broker代理服务器（转发者） 、订阅者（Subscriber） 。其中消息的发布者和订阅者都是客户端(Client)角色，消息代理是服务器，消息发布者可以同时是订阅者。 当Client发布某个主题的消息时，Broker会将该消息分发给任何已订阅该主题的Client。
MQTT服务器 MQTT服务端通常是一台服务器。它是MQTT信息传输的枢纽，负责将MQTT客户端发送来的信息传递给MQTT客户端。MQTT服务端还负责管理MQTT客户端。确保客户端之间的通讯顺畅，保证MQTT消息得以正确接收和准确投递。
MQTT客户端 MQTT客户端可以向服务端发布信息，也可以从服务端收取信息。我们把客户端发送信息的行为成为“发布”信息。而客户端要想从服务端收取信息，则首先要向服务端“订阅”信息。“订阅”信息这一操作很像我们在微信中订阅的公众号，当公众号更新时，微信会向订阅了该公众号的用户发送信息，告诉他们有文章更新了。
MQTT主题 刚刚我们在讲解MQTT客户端订阅信息时，使用了用户在微信中订阅公众号的这个例子。在MQTT通讯中，客户端所订阅的肯定不是一个个公众号，而是一个个“主题”。MQTT服务端在管理MQTT信息通讯时，就是使用“主题”来控制的。
四：连接MQTT服务端 MQTT客户端要想通讯，必须经过MQTT服务端。因此MQTT客户端无论是发布消息还是订阅消息，首先都要连接MQTT服务端。下面我们看一下MQTT客户端连接服务端的详细过程。
1、首先MQTT客户端将会向服务端发送连接请求。该请求实际上是一个包含有连接请求信息的数据包。这个数据包的官方名称为CONNECT
2、MQTT服务端收到客户端连接请求后，会向客户端发送连接确认。同样的，该确认也是一个数据包。这个数据包官方名称为CONNACK。
以上就是MQTT客户端在连接服务端的两步操作。接下来，我们一起来了解一下客户端在连接服务端时所发送的CONNECT报文内容。
clientId – 客户端ID
ClientId是MQTT客户端的标识。MQTT服务端用该标识来识别客户端。因此ClientId必须是独立的。如果两个MQTT客户端使用相同ClientId标识，服务端会把它们当成同一个客户端来处理。通常ClientId是由一串字符所构成的
username(用户名)和password（密码）
这里的用户名和密码是用于客户端连接服务端时进行认证需要的。有些MQTT服务端需要客户端在连接时提供用户名和密码。只有客户端正确提供了用户名和密码后，才能连接服务端。否则服务端将会拒绝客户端连接，那么客户端也就无法发布和订阅消息了。
username(用户名)和password（密码）是可选的CONNECT信息。也就是说，有些服务端开启了客户端用户密码认证，这种服务端需要客户端在连接时正确提供认证信息才能连接。当然，那些没有开启用户密码认证的服务端无需客户端提供用户名和密码认证信息
cleanSession – 清除会话
要说明cleanSession的具体含义，首先要从MQTT网络环境讲起。MQTT客户端与服务端的连接可能不是非常稳定，在不稳定的网络环境下，要想保证所有信息传输都能够做到准确无误，这是非常困难的。
为了保证重要的MQTT报文可以被客户端准确无误的收到。在服务端向客户端发送报文后，客户端会向服务端返回一个确认报文。如果服务端没有收到客户端返回的确认报文，那么服务端就会认为刚刚发送给客户端的报文没有被准确无误的送达。在这种情况下，服务端将会执行以下两个操作：
1、将尚未被客户端确认的报文保存起来
2、再次尝试向客户端发送报文，并且再次等待客户端发来确认信息。
如果 cleanSession 被设置为“true”。那么服务端不需要客户端确认收到报文，也不会保存任何报文。在这种情况下，即使客户端错过了服务端发来的报文，也没办法让服务端再次发送报文。 反过来，如果我们将 cleanSession 设置为”false”。那么服务端就知道，后续通讯中，客户端可能会要求我保存没有收到的报文。
keepAlive – 心跳时间间隔
MQTT服务端运行过程中，当有客户端因为某种原因断开了与服务端的连接，服务端需要实时了解这一情况。KeepAlive正是用于服务端了解客户端连接情况的。
客户端在没有向服务端发送信息时，可以定时向服务端发送一条消息。这条用于心跳机制的消息也被称作心跳请求。
心跳请求的作用正是用于告知服务端，当前客户端依然在线。服务端在收到客户端的心跳请求后，会回复一条消息。这条回复消息被称作心跳响应。
客户端在心跳间隔时间内，如果有消息发布，那就直接发布消息而不发布心跳请求，但是在心跳间隔时间内，客户端没有消息发布，那么它就会发布一条心跳请求给服务端，这个心跳请求的目的就是为了告诉服务端，我还在线。
五： SUBSCRIBE – 订阅主题 当客户端连接到服务端后，除了可以发布消息，也可以接收消息。所有MQTT消息都有主题。客户端要想接收消息，首先要订阅该消息的主题。这样，当有客户端向该主题发布消息后，订阅了该主题的客户端就能接收到消息了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74856e474d82589099851b8a0334c9ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/761bd675fd4eb82a6b05790aa5f7afe4/" rel="bookmark">
			【Java】备忘录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java中的分代垃圾回收算法 Java中的分代垃圾回收算法是针对不同生命周期的对象采取不同的回收策略，主要将堆内存分为新生代和老年代两部分，分别采用不同的回收算法。
1. 新生代（Young Generation）的垃圾回收算法： 新生代主要存放新创建的对象，其特点是对象的生命周期较短。因此，针对新生代的垃圾回收算法主要考虑了尽快回收新生代中的短命对象，以提高内存利用率和降低垃圾回收的成本。
1.1 复制算法（Copying Algorithm）： 新生代采用的主要垃圾回收算法是复制算法，也称为标记-复制算法。这种算法将新生代的内存空间划分为两个相等的区域：Eden区、From区和To区。当对象被分配到Eden区时，当Eden区满了之后，触发Minor GC，将存活的对象复制到To区，同时清空Eden区和From区。对象经过多次Minor GC仍然存活的，会被移到老年代中。 1.2 优点： 适用于新生代中对象生命周期短的情况，可以高效地回收短命对象。简单高效，内存分配连续，减少了碎片化。 1.3 缺点： 由于需要复制存活的对象，所以内存开销较大。需要额外的空间来存放复制后的对象。 2. 老年代（Old Generation）的垃圾回收算法： 老年代主要存放对象生命周期较长的对象，由于对象存活时间较长，采用复制算法将会浪费大量的空间。因此，老年代通常采用其他类型的垃圾回收算法。
2.1 标记-清除算法（Mark-Sweep Algorithm）： 首先，标记阶段对所有存活的对象进行标记。然后，在清除阶段，清理掉未标记的对象，即将未标记的对象所占用的内存释放掉。但这种方法可能会产生内存碎片，降低了内存分配的效率。 2.2 标记-整理算法（Mark-Compact Algorithm）： 类似于标记-清除算法，但在清除阶段之后，会对存活的对象进行整理，将它们向内存的一端移动，从而消除了内存碎片，提高了内存的利用率。 2.3 优点： 适用于老年代中存活对象较多的情况。能够避免内存碎片化，提高内存利用率。 2.4 缺点： 清除阶段的效率较低，需要遍历所有对象进行标记。需要额外的内存空间来存放标记信息。 总的来说，Java的分代垃圾回收算法将堆内存分为新生代和老年代两部分，并针对不同生命周期的对象采用不同的垃圾回收算法，以提高垃圾回收的效率和内存利用率。
IDEA 目录如何平铺 勾选Compact Middle Packages
Idea单一个窗口同时打开不同文件夹下的多个maven项目依赖导不进来问题解决 第一步：idea打开多个文件夹的父级文件夹
第二步： 把你想要的项目添加为Maven项目（右键单机pom.xml，将其add as Maven Project即可 ）
第三步：重复第二步添加第二个、第三个、第四个、、、、项目
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd22b894eb2b26d44aceca800de7ecd2/" rel="bookmark">
			轻松爬取跨境电商商品数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		跨境电商商品数据集爬取方案 在之前写过一篇关于网页爬取的文章，使用的是亮数据这个工具，并且带领大家进行了注册，介绍了一些相关的功能。现在我们来探索一下如何爬取某大型电商商品数据集
亮数据成立于2014年，是一家以技术驱动的公司，致力于通过各种高效的数据收集服务帮助企业获取互联网上的公开数据。通过实时的数据处理和分析技术，该公司帮助用户从网络世界中提取价值，服务众多行业包括电商、金融、市场调研、安全和广告等。
产品线包括：
覆盖全球195个国家，7200万IP的商用代理网络
外网大数据集(如亚马逊,领英,TikTok, Ins等等）
出境电商数据情报洞察
Web Scraper IDE　网络爬虫IDE
亮数据爬虫浏览器：批量爬取动态网页数据
我们需要使用到的功能就是外网大数据集以及出境电商数据情报洞察。
使用亮数据辅助跨境电商 跨境电商是一个涉及多个国家和法律管辖区的复杂业务。为了在跨境电商领域取得成功， 通常会有以下的关键策略：
了解市场和消费者：研究目标市场的文化、习惯、购买行为和法规。为每个市场定制市场进入策略和营销计划。多语言和本地化：提供多语言网站并对产品描述和客户服务进行本地化，以更好地与当地消费者沟通。合规和法规遵从：确保遵守目标市场的法律和规定，包括但不限于隐私政策、税收、进口关税和产品标准。支付和货币：提供多种支付选项并支持不同的货币结算，简化消费者的支付过程。供应链与物流：建立高效的供应链，选择合适的物流合作伙伴，优化配送时效和成本，确保产品的快速、可靠送达。客户服务：提供优质的客户服务，包括多时区的客户支持和退货政策，以建立顾客信任和忠诚度。产品选择和定价策略：根据不同市场的需求调整产品组合，制定有竞争力的定价策略。数字营销和社交媒体：利用SEO、社交媒体、内容营销等手段提高品牌在目标市场的可见度和吸引力。技术平台和安全：建立稳定安全的电商平台，保障用户数据的安全，并提供流畅的购物体验。数据分析：运用数据分析工具监控市场表现，了解消费者行为和偏好，持续调整策略。战略合作：与当地或国际品牌建立合作，通过合作伙伴的市场知识和渠道更高效地拓展市场。品牌建设：培养品牌故事和价值主张，与目标市场的消费者建立情感联结。可持续性与社会责任：实施可持续发展实践并强调社会责任，以赢得消费者的心，并应对日益严格的国际法规。 使用亮数据主要从产品选择、定价策略、消费者群体、爆款品牌建设这几个方面对跨境电商进行辅助。
跨境电商数据集介绍 我们就以电商商品的数据集作为依托，从而来了解什么是数据集，可以通过什么方式来进行数据集的获取。
什么是数据集 电商商品数据集通常是指收集自电子商务平台的商品信息的结构化数据集合。这些数据包括但不限于商品名称、价格、描述、用户评价、分类标签、卖家信息、销售量、库存量、图片链接等。数据集可以由电商平台公开提供，也可以通过网络爬虫等技术手段获得，并且经常会用于机器学习、市场分析、竞争情报和消费者行为研究。
数据集的获取 使用电商商品数据集通常遵循以下步骤：
数据收集：通过公开API、网络爬虫或合作等方式收集电商平台的商品数据。数据清洗：由于原始数据可能包含不完整、错误或不相关的信息，因此需要进行清洗，去除噪声数据以确保分析的准确性。数据整理：将数据按一定的格式（如CSV、JSON或数据库表）组织起来，方便后续的处理和分析。数据分析：使用统计分析和数据挖掘技术来提取数据的特征和趋势，比如价格分布、用户评价情绪分析、热门商品识别等。机器学习：对选择的特征进行模型训练，用来进行销量预测、推荐系统优化、用户需求预测等。可视化展示：将分析结果通过图表、报告等形式展现出来，帮助决策者理解市场状况和消费者行为。应用实施：根据数据分析和机器学习的结果，执行如价格调整、库存管理、营销策略优化等具体操作。 轻松爬取电子商务数据集步骤 1、进入到亮数据首页，点击查看数据产品。
2、进入到数据集商城
3、点击eCommerce Data （电子商务数据集），可以看到非常多的电商网站数据集
4、我们以亚马逊为列，上面这张图片就可以看到，亚马逊商品、亚马逊评分超过4.5的商品、亚马逊在USA的评论商品，以及下面展示的亚马逊畅销商品、最受好评的产品。从这几个地方，我们一下就解决了产品选择、爆款商品选取的策略。
5、通过分析这些数据，我们可以快速定位自己的定价策略、消费者群体，你只需要跟着最火爆的那几个商家模仿去做，我们可以下载对应的CSV或者JSON格式的数据集，通过python进行数据分析去筛选。
6、对于这些数据你在下载的时候还可以直接进行筛选。
7、下载好的CSV格式数据集展示如下
8、你也可以通过Initiate Scraping对数据进行重新获取
curl -H "Authorization: Bearer API_TOKEN" -H "Content-Type: application/json" -d '[{"asin":"https://www.amazon.com/dp/B08BX7FV5L","url":"https://www.amazon.com/dp/B08BX7FV5L","origin_url":"https://www.amazon.ca/Best-Sellers-generic/zgbs/?ref_=nav_cs_bestsellers"}]' "https://api.brightdata.com/datasets/request_collection?dataset_id=gd_l7q7dkf244hwjntr0&amp;type=url_collection" 使用数据集采集器爬取电商信息 除了上面用现成的数据集，我们还可以通过亮数据的Web Scraper IDE进行数据采集。
使用Web Scraper IDE 还是以亚马逊为例，我们可以直接使用他的template代码
填入目标网址 在input里面，你可以把你需要爬取的亚马逊目标网址填入进去
运行代码 之后点击开始按钮就可以运行代码了
日志中可以看到爬取进度。
结果展示 爬取完成之后会生成对应的爬取数据
在output那个位置，下面的内容就是你给的目标网址爬取的相关信息啦。
更多内容直接注册亮数据即可免费试用：点此注册
也可以点击原文链接进行注册哦 ~
注：注册完需要联系中文客服领取免费试用哦 ~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/991eb8007a07344d59ef1918de2ed0c0/" rel="bookmark">
			union all sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNION ALL 是一种SQL语句，用于将两个或多个SELECT语句的结果集合并成一个结果集。它返回所有的行，包括重复的行。
以下是一个使用 UNION ALL 的示例：
SELECT column1, column2 FROM table1 UNION ALL SELECT column1, column2 FROM table2; 在上面的示例中，我们将两个SELECT语句的结果集合并到一起。每个SELECT语句都从不同的表中选择相同数量和类型的列。
table1 和 table2 是要查询的不同表的名称。column1 和 column2 是要选择的列的名称。 使用 UNION ALL 时，结果集将包含两个来源表中的所有行，并且不会进行去重操作。如果你希望去除重复行，可以使用 UNION 运算符，它会自动去除重复的行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddcce6217186ce3174da1b115412517/" rel="bookmark">
			【探索AI】七-AI（人工智能）数据挖掘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据挖掘是指从大规模数据集中发现未知的、先前不可预测的信息和知识的过程。它涉及使用各种技术和算法来分析数据，以揭示其中隐藏的模式、关联、趋势和规律。通过数据挖掘，人们可以进行预测、分类、聚类、关联分析等操作，从而为决策制定、业务优化、市场营销等提供支持和指导。 数据挖掘的主要目标包括：
发现模式和规律：通过数据挖掘技术，可以发现数据中存在的复杂模式和规律，这些模式可能对业务运营、市场趋势、客户行为等方面具有重要意义。
预测和分类：基于历史数据的分析，数据挖掘可以用来预测未来事件的可能发生情况或对数据进行分类，例如预测销售额、客户流失率，或者对文档进行自动分类。
聚类分析：通过聚类分析，可以将数据集中的实体分组成不同的类别，帮助人们理解数据的内在结构和特点。
关联分析：关联分析用于发现数据中的项之间的相关性和关联规则，例如购物篮分析可以揭示一起购买的商品之间的关联关系。
数据挖掘技术通常涉及统计学、机器学习、人工智能等领域的知识和方法，常用的算法包括决策树、支持向量机、神经网络、聚类算法等。数据挖掘在商业、科学研究、医疗保健、金融等领域有着广泛的应用，帮助人们理解数据、做出更明智的决策，并发现新的商业机会和科学发现。
基本概念、原理和常用算法
基本概念：数据挖掘是一种自动化的、非显式的、发现性的数据分析过程，其目的是通过检索和处理大量数据来发现有用的知识。数据挖掘的过程包括数据清洗、数据集成、数据选择、数据变换、数据挖掘、模式评价和知识表示等步骤。 原理：数据挖掘的原理包括统计学、机器学习、人工智能等领域的知识和方法。其中，机器学习是数据挖掘的核心内容之一，其主要思想是通过构建模型来描述数据的内在规律，进而对未知数据进行预测和分类。
常用算法：数据挖掘的常用算法包括分类、聚类、关联规则挖掘等。其中，决策树、神经网络、支持向量机等是常用的分类算法；K均值、层次聚类等是常用的聚类算法；Apriori、FP-growth等是常用的关联规则挖掘算法。此外，还有基于回归分析、时间序列分析、文本挖掘等的数据挖掘算法。
数据挖掘工具：数据挖掘工具主要有Python中的Scikit-learn、TensorFlow、Keras、PyTorch等库，还有R语言中的Caret、MLR、RandomForest、XGBoost等库。这些工具提供了丰富的数据挖掘算法和可视化功能，可以帮助数据挖掘从业者进行高效的数据分析和挖掘工作
数据挖掘在实际应用中的作用和效果
市场营销数据分析：通过分析大型零售商的销售数据，展示如何利用数据挖掘技术来识别潜在的顾客群体、预测产品销售趋势、制定个性化营销策略等。这样的案例可以帮助学生理解数据挖掘在市场营销领域中的应用，以及其对企业决策的影响。 社交网络信息挖掘：通过分析社交媒体平台上的用户行为数据，展示如何利用数据挖掘技术来识别热门话题、发现潜在的社交网络影响者、预测用户行为等。这样的案例可以帮助学生了解数据挖掘在社交网络分析和推荐系统中的应用。
医疗健康数据分析：通过医疗机构的病例数据和医学影像数据，展示如何利用数据挖掘技术来辅助医生进行疾病诊断、预测病情发展趋势、个性化治疗方案等。这样的案例可以帮助学生了解数据挖掘在医疗健康领域中的重要性和应用前景。
金融风控数据分析：通过银行或金融机构的交易数据和信用数据，展示如何利用数据挖掘技术来识别风险客户、建立信用评分模型、防范欺诈行为等。这样的案例可以帮助学生理解数据挖掘在金融风控领域中的关键作用。
数据挖掘工具的实际操作
当使用Python中的Scikit-learn库进行数据挖掘任务时，通常可以按照以下步骤进行： 数据准备：首先需要加载数据集并进行数据预处理，包括数据清洗、特征选择、特征编码等操作。
模型选择：根据任务需求选择合适的数据挖掘模型，例如分类、回归、聚类等。
模型训练：使用Scikit-learn提供的模型训练接口对选定的模型进行训练，得到训练好的模型。
模型评估：通过交叉验证、ROC曲线、混淆矩阵等方法对训练好的模型进行评估，了解模型的性能表现。
模型预测：使用训练好的模型对新的数据进行预测或分类。
下面是一个简单的示例，演示如何使用Scikit-learn库进行数据挖掘任务的实现。假设我们要对鸢尾花数据集进行分类：
# 导入所需的库 import numpy as np from sklearn import datasets from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.svm import SVC from sklearn.metrics import accuracy_score # 加载鸢尾花数据集 iris = datasets.load_iris() X = iris.data y = iris.target # 数据预处理 scaler = StandardScaler() X = scaler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cddcce6217186ce3174da1b115412517/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5984a01378bc5140546222f2e88870a3/" rel="bookmark">
			Mac 安装 cocoapods 教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装cocoapods
1、使用gem安装（网上有教程，不赘述了）
2、使用homebrew安装
终端命令：
brew reinstall cocoapods brew link --overwrite cocoapods 我使用的第二条命令，pod命令恢复了，但是当执行pod install时，找不到最新版本的第三方库，猜想应该是之前装的pod版本太旧了，于是更新pod
pod repo update --verbose 报错了，网上查找原因，应该是 pod 的版本太旧了
于是从gem开始更新 使用新的源 gem sources -a https://gems.ruby-china.com/ 检查 gem 版本号 sudo gem -v 升级gem sudo gem update —system 安装CocoaPods (1)sudo gem install -n /usr/local/bin cocoapods 输入电脑密码， 回车等待. (2) pod setup 需要一段时间. 如果安装失败 ~/.cocoapods 里面是空的，就需要重新setup. 命令如下: pod repo remove master pod setup 如果安装成功,~/.cocoapods下文件夹会有几百M. 更新CocoaPods版本: sudo gem update cocoapods
二、在项目中添加pod
在这里笔者使用Cocoapods安装ReactiveCocoa,在项目中创建podfile文件,使用的是2.5版本.
platform :ios, '8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5984a01378bc5140546222f2e88870a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9d9fb3d5ef0aeda49e93494127740d/" rel="bookmark">
			【探索AI】六-AI（人工智能）-强化学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概念：强化学习是一种机器学习方法，通过智能体(agent)与环境(environment)的交互作用，学习如何在特定环境下做出最优决策。在强化学习中，智能体根据环境的反馈（奖励信号）来调整自己的行为，以使得长期累积的奖励最大化。 下面是强化学习中的一些关键概念：
智能体(agent)：强化学习的学习和决策主体，它与环境进行交互并根据环境状态选择合适的动作。
环境(environment)：智能体所处的外部环境，对智能体的动作做出响应，并提供奖励信号来评价智能体的行为。
状态(state)：描述环境的特定状态或情况，智能体根据状态来选择动作。
动作(action)：智能体可以执行的操作，每个动作会导致智能体从一个状态转移到另一个状态。
奖励信号(reward signal)：用来评价智能体行为的反馈信号，智能体的目标是通过获得最大化的长期奖励。
策略(policy)：描述智能体在特定状态下选择动作的方式，可以是确定性策略或概率性策略。
值函数(value function)：用来估计状态或状态-动作对的价值，帮助智能体判断选择最优动作。
探索与利用(Exploration and Exploitation)：智能体需要在探索未知领域和利用已知信息之间取得平衡，以寻找最优策略。
总的来说，强化学习通过智能体不断与环境交互、尝试和学习，使得智能体能够在复杂环境中做出最优决策。这种学习方式类似于人类通过尝试和错误学习新技能或行为。强化学习在许多领域都有广泛的应用，如游戏领域、机器人控制、自然语言处理等。
强化学习的基本原理可以简要概括为智能体通过与环境的交互学习，以最大化长期奖励为目标。以下是强化学习的基本原理： 奖励信号驱动：在强化学习中，智能体通过与环境的交互行为来获得奖励信号。奖励信号用于评估智能体的行为，指导智能体学习选择能够带来最大长期奖励的策略。
延迟奖励：强化学习关注的是长期累积奖励的最大化，而不是单次行为的即时奖励。智能体需要考虑当前动作的长期影响，以做出最优决策。
探索与利用：在强化学习中，智能体需要在探索未知领域和利用已知信息之间取得平衡。通过探索未知状态和动作，智能体可以发现更优的策略，避免陷入局部最优解。
价值函数估计：强化学习通过价值函数来估计状态或状态-动作对的价值，帮助智能体评估每个状态或动作的好坏。值函数可以是状态值函数（评估状态的价值）或动作值函数（评估状态-动作对的价值）。
策略优化：强化学习的目标是通过优化策略来最大化长期累积奖励。策略可以是确定性策略或概率性策略，描述智能体在每个状态下选择动作的方式。
学习与调整：智能体通过不断尝试和学习来改进自己的策略，根据奖励信号对行为进行调整。强化学习算法会根据环境反馈的奖励信号来更新值函数和策略，使得智能体逐渐学习到最优策略。
强化学习有许多算法和方法，下面介绍几种常见的强化学习算法和方法： Q-Learning：Q-Learning是一种基于值函数的强化学习算法。它通过学习一个动作值函数（Q函数），在每个状态下选择具有最高Q值的动作。Q-Learning使用了贝尔曼方程来更新Q值，并通过不断探索和利用来优化策略。
Deep Q Network (DQN)：DQN是一种结合了深度神经网络和Q-Learning的强化学习算法。DQN使用深度神经网络来逼近Q函数，可以处理高维状态空间问题。DQN还引入了经验回放机制和目标网络来提高学习的稳定性和效率。
Policy Gradient：策略梯度方法是一类直接优化策略的强化学习方法。它通过对策略的参数求取梯度来更新策略，以最大化长期累积奖励。常见的策略梯度算法包括REINFORCE、Actor-Critic等。
Proximal Policy Optimization (PPO)：PPO是一种近端策略优化算法，旨在解决策略梯度方法中的样本效率和稳定性问题。PPO通过使用近似目标函数和限制策略更新的幅度，来优化策略。它在训练过程中保持了较高的采样效率和稳定性。
Model-Based Methods：模型基于方法是一类利用环境动态模型进行规划和学习的强化学习方法。这些方法通过构建环境的模型来学习环境的状态转移和奖励函数，然后使用规划算法或模型预测来优化策略。
Multi-Agent Reinforcement Learning (MARL)：多智能体强化学习是一种处理多个智能体相互作用的框架。MARL方法可以有合作、竞争或混合等不同类型，它们致力于学习智能体之间的协作策略或对抗策略。
强化学习实际应用的案例，包括AlphaGo在围棋中的应用以及机器人控制等领域： AlphaGo在围棋中的应用：
AlphaGo是由DeepMind团队开发的人工智能程序，采用了深度强化学习算法。在2016年，AlphaGo与围棋世界冠军李世石进行了一系列对决，并最终以4比1的比分获胜。这一突破表明强化学习在复杂策略游戏中的潜力，展示了机器在思维上挑战人类的能力。
机器人控制：
强化学习在机器人控制领域的应用非常广泛。通过强化学习算法，可以训练机器人执行各种任务，如导航、物体抓取、路径规划等。机器人可以通过与环境交互来学习最佳动作策略，提高自主决策能力。
智能交通信号优化：
强化学习可用于优化城市交通信号系统。通过学习交通流量数据和环境变化，智能信号灯可以根据实时交通情况调整信号时序，以减少拥堵并提高车辆通行效率。这种应用可以帮助改善城市交通状况，减少交通拥堵问题。
推荐系统：
强化学习在个性化推荐系统中也有应用。通过学习用户的反馈和行为，系统可以动态调整推荐内容，以提高用户满意度和点击率。这种应用可以帮助提升电商平台、社交媒体等网站的用户体验和盈利能力。
以下是一个伪代码示例，展示了AlphaGo在围棋中的简化实现： # 伪代码示例：AlphaGo在围棋中的简化实现 # 导入必要的库 import numpy as np # 定义围棋盘大小 BOARD_SIZE = 19 # 定义随机策略函数 def random_policy(board): # 在空白位置随机选择一个动作 empty_positions = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca9d9fb3d5ef0aeda49e93494127740d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbb03124844865713e3b7230b0288d09/" rel="bookmark">
			第 3 章 ROS通信机制(自学二刷笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		重要参考：
课程链接:https://www.bilibili.com/video/BV1Ci4y1L7ZZ
讲义链接:Introduction · Autolabor-ROS机器人入门课程《ROS理论与实践》零基础教程
3.1.3 回旋函数 C++ 在ROS程序中，频繁的使用了 ros::spin() 和 ros::spinOnce() 两个回旋函数，可以用于处理回调函数。
1.spinOnce() /** * \brief 处理一轮回调 * * 一般应用场景: * 在循环体内，处理所有可用的回调函数 * */ ROSCPP_DECL void spinOnce(); 2.spin() /** * \brief 进入循环处理回调 */ ROSCPP_DECL void spin(); 3.二者比较 相同点:二者都用于处理回调函数；
不同点:ros::spin() 是进入了循环执行回调函数，而 ros::spinOnce() 只会执行一次回调函数(没有循环)，在 ros::spin() 后的语句不会执行到，而 ros::spinOnce() 后的语句可以执行。
Python def spin(): """ 进入循环处理回调 """ 3.1.4 时间 ROS中时间相关的API是极其常用，比如:获取当前时刻、持续时间的设置、执行频率、休眠、定时器...都与时间相关。
C++ 1.时刻 获取时刻，或是设置指定时刻:
ros::init(argc,argv,"hello_time"); ros::NodeHandle nh;//必须创建句柄，否则时间没有初始化，导致后续API调用失败 ros::Time right_now = ros::Time::now();//将当前时刻封装成对象 ROS_INFO("当前时刻:%.2f",right_now.toSec());//获取距离 1970年01月01日 00:00:00 的秒数 ROS_INFO("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbb03124844865713e3b7230b0288d09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ec8a751a4d7d0ba1200a242f0a80bd6/" rel="bookmark">
			部首礻和衤的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“礻”（shì）和"衤"（yī）是两个不同的汉字部首，它们在视觉上相似，但各自有不同的含义和用途：
礻（shì）：
这个部首通常与宗教或祭祀相关的汉字有关。它是一些汉字的左边部分，如“神”（shén，意为“god”或“spirit”），“祖”（zǔ，意为“ancestor”）等。这个部首来源于“示”字，本身与表示神、祭祀的概念有关。 衤（yī）：
这个部首与衣服或覆盖相关的汉字有关。它出现在一些与衣物或覆盖相关的字的左边，如“衣”（yī，意为“clothes”），“裤”（kù，意为“pants”）等。这个部首来源于“衣”字，与衣物或覆盖有关。 视觉上，这两个部首非常相似，都有两个横线和一个垂直的下划线，但它们的上半部分有所不同：在“礻”，上半部分是类似“乍”的形状，而在“衤”，上半部分是类似“亠”的形状。这个小差异是它们的主要区别，它们所属的字和含义也因此不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8064e59dc3e3a78c3288dc322abea710/" rel="bookmark">
			ElasticSearch 8.x 创建父子文档，用Join类型字段以及用has_child、has_parent 检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch 1、ElasticSearch学习随笔之基础介绍
2、ElasticSearch学习随笔之简单操作
3、ElasticSearch学习随笔之java api 操作
4、ElasticSearch学习随笔之SpringBoot Starter 操作
5、ElasticSearch学习随笔之嵌套操作
6、ElasticSearch学习随笔之分词算法
7、ElasticSearch学习随笔之高级检索
8、ELK技术栈介绍
9、Logstash部署与使用
10、ElasticSearch 7.x 版本使用 BulkProcessor 实现批量添加数据
11、ElasticSearch 8.x 弃用了 High Level REST Client，移除了 Java Transport Client，推荐使用 Elasticsearch Java API
12、ElasticSearch 8.x 使用 snapshot（快照）进行数据迁移
13、ElasticSearch 8.x 版本如何使用 SearchRequestBuilder 检索
14、ElasticSearch 8.x 使用 High Level Client 以 HTTPS 方式链接，SSL 证书、主机名验证器 各是什么，如何忽略
15、ElasticSearch 8.x 创建父子文档，用Join类型字段以及用has_child、has_parent 检索
ElasticSearch，创始人 Shay Banon（谢巴农）
本文主要讲解ElasticSearch 父子文档实战，来满足复杂的业务场景，还是用 Kibana 来操作。
文章目录 ElasticSearch前言一、Kibana 中操作1.1 Join 类型字段1.2、写入关联数据1.3、数据检索1.3.1 has_child 检索1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8064e59dc3e3a78c3288dc322abea710/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199b501271f99b84b9e8faab60875fbb/" rel="bookmark">
			Linux第66步_linux字符设备驱动_挂载和卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、了解linux中的驱动类型:
1)、字符设备驱动
字符设备是limnux驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。如：GPIO输入输出、UART、I2C、SPI、USB、LCD、音频等都属于字符设备驱动。
2)、块设备驱动
块设备驱动就是存储器设备的驱动，比如EMMC、NAND、SD卡和U盘等存储设备，因为这些存储设备的特点是以存储块为基础,因此叫做“块设备”。
3)、网络设备驱动网络设备就是网络驱动，不管是有线的，还是无线的，都属于网络设备驱动的范畴。
注意：
一个设备可以属于多种设备驱动类型，比如：USB WIFI，其使用USB接口，所以属于字符设备，但是其又能上网，所以它又属于网络设备驱动。
2、了解Limux应用程序调用驱动程序的流程
在Linux中一切皆为文件。驱动加载成功以后会在“/dev”目录下生成一个相应的驱动文件，如“xxx”的驱动文件名。应用程序通过对“/dev/xxx”的文件进行相应的操作，就可实现对硬件的操作。比如：现在有个叫做“/dev/led ”的驱动文件，它是1ed灯的驱动文件。应用程序使用“open函数”打开驱动文件“/dev/led ”,然后使用“close函数”关闭驱动文件“/dev/led”。open和close 就是打开和关闭led驱动的函数，如果要点亮或关闭1ed，那么就使用write函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开led的控制参数。如果要获取led灯的状态，就用read函数从驱动中读取相应的状态。应用程序运行在用户空间，而limux驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核进行操作，比如使用open函数打开/dev/led这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。open、close、write和read等这些函数是由C库提供的，在Limux系统中，系统调用作为C库的一部分。
我们重点关注的时应用程序调用的函数和驱动调用的函数，至于C库和内核调用的函数，我们不用去关心。
3、了解“file_operations”结构体
打开虚拟机上“VSCode”，点击“文件”，点击“打开文件夹”，点击“zgq”，点击“linux”，点击“atk-mp1”，点击“linux”，点击“my_linux”，点击“linux-5.4.31”，见下图：
点击“确定”
点击“查看”，点击“搜索”，输入“struct file_operations”
随便点击其中一个“struct file_operations”，得到下面的界面：
在“file_operations”点击“鼠标右键”，点击“转到定义”，见下图：
得到下图：
字符设备驱动重点是“file_operations”结构体
“fs.h”定义“file_operations”结构体如下：
struct file_operations {
struct module *owner;
loff_t (*llseek) (struct file *, loff_t, int);
ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/199b501271f99b84b9e8faab60875fbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a581e83c50270969649b16b90d1cca5/" rel="bookmark">
			AOSP并发编程案例之ConditionVariable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		packages/modules/Connectivity/service-t/src/com/android/server/ethernet/EthernetNetworkFactory.java static class NetworkInterfaceState { ... private @Nullable EthernetIpClientCallback mIpClientCallback; ... private class EthernetIpClientCallback extends IpClientCallbacks { private final ConditionVariable mIpClientStartCv = new ConditionVariable(false); private final ConditionVariable mIpClientShutdownCv = new ConditionVariable(false); @Override public void onIpClientCreated(IIpClient ipClient) { mIpClient = mDeps.makeIpClientManager(ipClient); mIpClientStartCv.open(); } private void awaitIpClientStart() { mIpClientStartCv.block(); } private void awaitIpClientShutdown() { mIpClientShutdownCv.block(); } private boolean isCurrentCallback() { return this == mIpClientCallback; } private void handleIpEvent(final @NonNull Runnable r) { mHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a581e83c50270969649b16b90d1cca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a6e9877df153745c2ff2f09ccf9910b/" rel="bookmark">
			elasticsearch中设置查询的请求超时时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://www.phpmianshi.com/?id=251
背景
因为我们的项目是用的php，为了防止调用搜索时，请求处理时间太长，导致php-fpm占满，所以需要对外部接口设置请求的超时时间，避免过多的超时请求，我们可以用过对es的参数限制，设置超时时间
search 请求参数
from
从索引的第几条数据开始返回，默认是 0；
size
返回多少条数据，默认是 10。
注意：Elasticsearch 集群实际是需要给 coordinate node 返回 shards number * (from + size) 条数据，然后在单机上进行排序，最后给客户端返回这个 size 大小的数据的。所以请谨慎使用 from 和 size 参数。
此外，Elasticsearch 2.x 还新增了一个索引级别的动态控制配置项：index.max_result_window，默认为 10000。即 from + size 大于 10000 的话，Elasticsearch 直接拒绝掉这次请求不进行具体搜索，以保护节点。
另外，Elasticsearch 2.x 还提供了一个小优化：当设置 "size":0 时，自动改变 search_type 为 count。跳过搜索过程的 fetch 阶段。
timeout
coordinate node 等待超时时间。到达该阈值后，coordinate node 直接把当前收到的数据返回给客户端，不再继续等待 data node 后续的返回了。
注意：这个参数只是为了配合客户端程序，并不能取消掉 data node 上搜索任务还在继续运行和占用资源。
terminate_after
各 data node 上，扫描单个分片时，找到多少条记录后，就认为足够了。这个参数可以切实保护 data node 上搜索任务不会长期运行和占用资源。但是也就意味着搜索范围没有覆盖全部索引，是一个抽样数据。准确率是不好判断的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a6e9877df153745c2ff2f09ccf9910b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c887fef3e631b152f9ca98909bc7d6b6/" rel="bookmark">
			Linux I/O 基本原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：arraywang，腾讯 CSIG
我们先看一张图：
这张图大体上描述了 Linux 系统上，应用程序对磁盘上的文件进行读写时，从上到下经历了哪些事情。
这篇文章就以这张图为基础，介绍 Linux 在 I/O 上做了哪些事情。
文件系统 什么是文件系统 文件系统，本身是对存储设备上的文件，进行组织管理的机制。组织方式不同，就会形成不同的文件系统。比如常见的 Ext4、XFS、ZFS 以及网络文件系统 NFS 等等。
但是不同类型的文件系统标准和接口可能各有差异，我们在做应用开发的时候却很少关心系统调用以下的具体实现，大部分时候都是直接系统调用 open, read, write, close 来实现应用程序的功能，不会再去关注我们具体用了什么文件系统（UFS、XFS、Ext4、ZFS），磁盘是什么接口（IDE、SCSI，SAS，SATA 等），磁盘是什么存储介质（HDD、SSD）
应用开发者之所以这么爽，各种复杂细节都不用管直接调接口，是因为内核为我们做了大量的有技术含量的脏活累活。开始的那张图看到 Linux 在各种不同的文件系统之上，虚拟了一个 VFS，目的就是统一各种不同文件系统的标准和接口，让开发者可以使用相同的系统调用来使用不同的文件系统。
文件系统如何工作（VFS） Linux 系统下的文件 在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。
用 ls -l 命令看最前面的字符可以看到这个文件是什么类型 brw-r--r-- 1 root root 1, 2 4月 25 11:03 bnod // 块设备文件 crw-r--r-- 1 root root 1, 2 4月 25 11:04 cnod // 符号设备文件 drwxr-xr-x 2 wrn3552 wrn3552 6 4月 25 11:01 dir // 目录 -rw-r--r-- 1 wrn3552 wrn3552 0 4月 25 11:01 file // 普通文件 prw-r--r-- 1 root root 0 4月 25 11:04 pipeline // 有名管道 srwxr-xr-x 1 root root 0 4月 25 11:06 socket.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c887fef3e631b152f9ca98909bc7d6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a51ac6426fc7303ca503d1dd0dd7e168/" rel="bookmark">
			安装淘宝镜像cnpm报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		npm 安装淘宝镜像报错
npm install -g cnpm --registry=https://registry.npm.taobao.org
安装报
The operation was rejected by your operating system.
npm ERR! It's possible that the file was already in use (by a text editor or antivirus),
npm ERR! or that you lack permissions to access it.
npm ERR!
-4048
解决办法 把这句命令
npm install -g cnpm --registry=https://registry.npm.taobao.org
改成指定版本就好了（版本号可以根据自己需求来）
npm install -g cnpm@7.1.1 --registry=https://registry.npm.taobao.org
就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/934bf03c69f3508a3fa6db7f5bc4a9ef/" rel="bookmark">
			【自然语言处理四-从矩阵操作角度看 自注意self attention】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自然语言处理四-从矩阵操作角度看 自注意self attention 从矩阵角度看self attention获取Q K V矩阵注意力分数softmax注意力的输出再来分析整体的attention的矩阵操作过程从矩阵操作角度看，self attention如何解决问题的？W^q^ W^k^ W^v^这三个矩阵怎么获得？ 从矩阵角度看self attention 上一篇文章，【自然语言处理三-自注意self attention】介绍了如何实现selft attention，但没有介绍，为何自注意力就能解决参数扩张、无法并行等问题，仅仅用语言描述太过干涩，从矩阵操作的角度则可以清晰的了解，self attention的运作机制以及它如何解决这些问题的。
首先，还是先给出self attention的整体流程图
中间这个attention层，从输入到attention层的输出，就是我们是实现的目标，下面是一个简单的图示：
下面我们就从矩阵操作的角度来描述，具体如何实现中间这个self attention层。
获取Q K V矩阵 首先是根据输入乘上矩阵,获取qi,ki,vi
当我们将(ai,…an)整合成一个矩阵的时候，实际上这个操作是这样的：
这样我们的Q K V矩阵就是针对整个输入的了。
注意力分数 a1对于ai的注意力分数，是q1和ki的点乘，当然这个点乘操作在上文介绍过，可以有别的方法。
这个过程同样可以合并成一个矩阵操作，如下图：A矩阵中的每一列，就是ai对于其他输入的注意力分数
softmax 上述获取的A矩阵执行softmax操作
注意力的输出 softmax后的注意力分数，与其他输入的vi做乘法操作，获取最终注意力层的一个输出。
这个过程同样可以合并矩阵操作，如下：
最终的的这个O矩阵就是注意力的输出。
再来分析整体的attention的矩阵操作过程 这个总体的过程，可以用下面更简略的图来表示：
从矩阵操作角度看，self attention如何解决问题的？ 1.解决参数可能急剧扩张的问题
我们从上面整体的矩阵操作过程来看，实际上只有三个矩阵Wq Wk Wv的参数需要学习，其他都是经过矩阵运算。
参数不会出现剧增
2.解决无法并行的问题
矩阵对于每个输入的操作，是并行的，不再像seq2seq架构一样，是按照时间步，一步步操作。
3.解决记忆能力的问题
attention的分数是基于全体输入的，且没有经过时间步的传播，因此记忆是基于全句子的，且信息没有丢失
Wq Wk Wv这三个矩阵怎么获得？ 从整体流程来看，要实现attention，最关键的就是找到合适的Wq Wk Wv矩阵，那么这三个矩阵是怎么获得的呢？
它们是靠学习获得的，初始化后，经过模型输出，然后经过反向传播，通过调整误差，一步步的精确化了这三个矩阵
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9ef0298108606191c72c0444e7d148a/" rel="bookmark">
			Redis探秘：十大最佳应用场景揭示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 强烈推荐前言：应用场景:缓存:示例 会话管理:示例 队列:示例 计数器和统计:示例 发布/订阅:示例 分布式锁:示例 实时数据处理:示例 限流和速率控制:示例 会话存储和缓存:示例 地理位置应用:示例 总结：强烈推荐专栏集锦写在最后 强烈推荐 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站:人工智能
前言： 在当今的软件开发和系统架构中，Redis 已经成为了不可或缺的重要组件之一。
其快速、灵活以及丰富的功能使得它在各种场景下都能发挥重要作用。
本文将深入探讨工作中最常见的 10 种 Redis 应用场景，帮助读者更好地理解如何利用 Redis 解决实际问题，提高系统的性能、可伸缩性和可靠性。
应用场景: 缓存: 将频繁访问的数据存储在 Redis 中，以加速数据检索和响应速度。
​
示例 import redis.clients.jedis.Jedis; Jedis jedis = new Jedis("localhost", 6379); jedis.set("cache_key", "cache_value"); 会话管理: 将用户会话数据存储在 Redis 中，以支持会话状态共享和快速访问。
示例 import redis.clients.jedis.Jedis; Jedis jedis = new Jedis("localhost", 6379); jedis.hset("user_session:123", "id", "123"); jedis.hset("user_session:123", "username", "example_user"); 队列: 使用 Redis 的列表数据结构作为消息队列，用于异步任务处理、事件驱动等场景。
示例 import redis.clients.jedis.Jedis; Jedis jedis = new Jedis("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9ef0298108606191c72c0444e7d148a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc611d838f0c75a31ea95f2c42a491c0/" rel="bookmark">
			【数据结构与算法】(25)高级数据结构与算法设计之 单调队列和栈问题 代码示例与详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 4.7 Leetcode 单调队列和栈单调递减队列最大滑动窗口-Leetcode 239单调递减栈接雨水-Leetcode 42 4.7 Leetcode 单调队列和栈 单调递减队列 public class MonotonicStack&lt;T extends Comparable&lt;T&gt;&gt; { private final LinkedList&lt;T&gt; stack = new LinkedList&lt;&gt;(); public void push(T t) { while (!stack.isEmpty() &amp;&amp; stack.peek().compareTo(t) &lt; 0) { stack.pop(); } stack.push(t); } public void pop() { stack.pop(); } public T peek() { return stack.peek(); } @Override public String toString() { return stack.toString(); } public static void main(String[] args) { MonotonicStack&lt;Integer&gt; stack = new MonotonicStack&lt;&gt;(); for (int i : new int[]{0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1}) { stack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc611d838f0c75a31ea95f2c42a491c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94946cb41bd355f0fc47c13bb64b05d4/" rel="bookmark">
			【数据结构与算法】(24)高级数据结构与算法设计之 双指针问题 代码示例与详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 4.6 Leetcode 双指针移动零-Leetcode 283两数之和 II-Leetcode 167三数之和-Leetcode 15四数之和-Leetcode 18盛最多水的容器-Leetcode 11反转字符数组-Leetcode 344 4.6 Leetcode 双指针 下面是的题目都会涉及双指针，除此外，还有
Leetcode3 最长不重复子串，在 hash 表部分讲过了快排中二分中… 移动零-Leetcode 283 public class MoveZeroesLeetcode283 { static void moveZeroes(int[] nums) { int i = 0; int j = 0; while (j &lt; nums.length) { if (nums[j] != 0) { int t = nums[i]; nums[i] = nums[j]; nums[j] = t; i++; } j++; } } public static void main(String[] args) { int[] nums = {0, 1, 0, 3, 12}; moveZeroes(nums); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94946cb41bd355f0fc47c13bb64b05d4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/58/">«</a>
	<span class="pagination__item pagination__item--current">59/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/60/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>