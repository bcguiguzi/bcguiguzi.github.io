<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c7db454e3220a3404c727b5a8e4384/" rel="bookmark">
			编译Latex遇到File ended while scanning use of \frac
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		标注重点时，\frac{}，少了一个}。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c408162fb0ec5bd2655fedea042a6017/" rel="bookmark">
			python 1行代码解决算法 回文数 问题（多一行都不行）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class Solution: def isPalindrome(self, x: int) -&gt; bool: #int转换成字符串，反转字符串 进行比较 OK return str(x)==str(x)[::-1] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c63bd329b5293dde74fac7f13641b24b/" rel="bookmark">
			DataX更换python3，File “datax.py“, line 114 print readerRef
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		datax 报错 File “datax.py”, line 114 print readerRef 报错： File "datax.py", line 114 print readerRef 解决方案：更换安装目录下bin的对应文件
datax.py, dxprof.y, perftrace.py
我们去查看datax.py的bin目录
解决方案 参考网址：
https://github.com/WeiYe-Jing/datax-web/tree/master/doc/datax-web/datax-python3 或者复制下面的源码替换bin对应的py文件
注意：需要全部复制，包括编码的设定
datax.py
#!/usr/bin/env python # -*- coding:utf-8 -*- """ Life's short, Python more. """ import sys import os import signal import subprocess import time import re import socket import json from optparse import OptionParser from optparse import OptionGroup from string import Template import codecs import platform def isWindows(): return platform.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c63bd329b5293dde74fac7f13641b24b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890e9f910a6b6ebb0304d5b0981faff8/" rel="bookmark">
			Debian10二进制安装MySQL5.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载mysql5.7二进制包 略
安装依赖 apt install psmisc libaio1 libnuma1 libatomic1 libmecab2 libncurses5
安装mysql useradd -s /sbin/nologin -M mysql
tar -zxf mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz -C /usr/local/
mv /usr/local/mysql-5.7.35-linux-glibc2.12-x86_64 /usr/local/mysql
配置环境变量 vim /etc/profile
source /etc/profile
配置mysql参数 cat /etc/mysql/my.cnf
[mysqld_multi]
mysqld=/usr/local/mysql/bin/mysqld_safe
mysqladmin=/usr/local/mysql/bin/mysqladmin
log=/usr/local/mysql/mysqld_multi.log
[mysqld]
user=mysql
basedir=/usr/local/mysql
character_set_server=utf8mb4
collation_server=utf8mb4_general_ci
log_error=error.log
socket=mysqld.sock
[mysqld3306]
port=3306
datadir=/data/mysqld_3306
初始化实例 mkdir -p /data/mysqld_3306
bin/mysqld --user=mysql --datadir=/data/mysqld_3306 --initialize-insecure
启动实例 mysqld_multi report mysqld_multi start 3306
连接实例 mysql -S /data/mysqld_3306/mysqld.sock
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7101e42eac19a885ab03461d3e7e1b94/" rel="bookmark">
			2022年第十三届蓝桥杯JAVA B组 试题 B: 山
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试题 B: 山
本题总分：5 分
【问题描述】
这天小明正在学数数。
他突然发现有些正整数的形状像一座“山”，比如 123565321、145541，它
们左右对称（回文）且数位上的数字先单调不减，后单调不增。
小明数了很久也没有数完，他想让你告诉他在区间 [2022, 2022222022] 中有
多少个数的形状像一座“山”。
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。
答案：3138
package lanqiao13; /** * 杨亚磊 * 试题 B: 山 * * 本题总分：5 分 * 【问题描述】 * 这天小明正在学数数。 * 他突然发现有些正整数的形状像一座“山”，比如 123565321、145541，它 * 们左右对称（回文）且数位上的数字先单调不减，后单调不增。 * 小明数了很久也没有数完，他想让你告诉他在区间 [2022, 2022222022] 中有 * 多少个数的形状像一座“山”。 * 【答案提交】 * 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一 * 个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 * * 答案：3138 */ public class B { public static void main(String[] args) { long l = 2022; int num = 0; for(;l &lt;= 2022222022L;++l) { if(isShan(l)) { //验证代码!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7101e42eac19a885ab03461d3e7e1b94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f70479cf8f8c241de2660b908414af3/" rel="bookmark">
			supertypes of the following classes cannot be resolved. make sure you have the required dependencies
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、问题2、出现这个问题的原因3、解决办法 1、问题 Android Studio 编译报错： Supertypes of the following classes cannot be resolved. Please make sure you have the required dependencies in the classpath : class X, unresolved supertypes: Y重启且清除Android Studio缓存没用，clean后重新build也没用。 2、出现这个问题的原因 咱翻译一下Android Studio 的这个报错信息： 下列类的父类找不到，请确保添加了必要的依赖：类X，未找到的父类Y。
为什么找不到类X的父类Y呢？下面举例说明，参考下图：
假设现在有3个module，module A、module B 和 moduleC。你在module B里定义了类X，在moduleC里定义了类Y，类X的父类是Y，所以你在module B的build.gradle里写上了implementation “moduleC”，这样module B就依赖上了moduleC。你在module A里想使用类X，所以你在module A的build.gradle里写上了implementation “module B”，这样module A就依赖上了moduleB现在编译报错了，在module A中，找不到类X的父类Y 下面说说implementation 和 api的区别：
让 A 依赖 B (implementation、api 都可以)若B implementation C，A 不能调用 C 的方法若 B api C，A 可以调用 C 的方法(同 compile) 所以，虽然你让module A implementation “module B”，module B implementation “moduleC”，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f70479cf8f8c241de2660b908414af3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3087faf821ed617f510326c160450b5/" rel="bookmark">
			Ajax是什么以及Ajax交互原理（详，图文并茂，原理篇）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 Ajax技术与原理 1.1 Ajax简介 Ajax = Asynchronous JavaScript and XML (翻译成人话就是，异步的 javascript 和 XML 相结合的一种技术 )
需要澄清的是，Ajax不是新的编程语言，而是一种 使用现有标准的新方法，还是一种 与服务器交换数据并实现只更新网页局部的艺术（也就是在，不重新加载整个页面就能实现数据的动态变化）
1.2 Ajax所包含的技术 需要强调的是，Ajax并非一种新的技术，而是几种原有技术的结合体。 以下便是Ajax所包含的技术
1.使用CSS和XHTML来表示
2.使用DOM模型来交互和动态显示
3.使用XMLHttpRequest来和服务进行异步通信
4.使用javascript来绑定和调用
Ajax的核心，使用的 XMLHttpRequest 对象，但是需要注意的是——不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的
​ 如：IE浏览器使用 ActiveXObject，而其他浏览器则使用 XMLHttpRequest的 javascript 的内建对象
1.3 Ajax的工作原理 Ajax的工作原理相当于在用户和服务器之间加了一个中间层（Ajax引擎），使用户操作和服务器响应异步化。
可以先问问自己，Ajax技术与传统方式 在具体的工作上 有什么区别呢？
图一讲解： 首先客户端先发送一个HTTP请求，HTTP请求发送之后再将其发送给服务器，接下来再去调取数据库，然后再去返回
图二讲解： Ajax技术会使你和用户，以及服务器之间多了一个Ajax引擎，通过这个引擎就可以实现一些异步操作。那这意味着什么呢？
意味着，用户在客户端发送请求时，这个方式是JS请求。再由Ajax引擎将其转换成HTTP请求，后台接收到这个请求之后再进行处理。
需要注意的是，服务器本身是没有变化的。数据处理完成之后，就会返回给客户端。
而传统方式返回的是HTML+CSS这样一种
固定的结构，但是现在呢则是先返回一个XML数据或是文本文档数据给Ajax引擎，通过Ajax引擎，再把返回的内容渲染成最后要的一个结果。
总结：Ajax实际上是在其中扮演着一个 媒介的作用，这个媒介呢，既可以发送请求又可以 给服务器返回数据。
1.3.1 接下来再看看他们各自的交互： 首先是，浏览器的普通交互方式
最后是，Ajax的交互方式
通过分析对比我们发现，Ajax其实就像是去食堂打饭，每个窗口都能打。而传统的则像是小饭店，只能一个一个顾客排队点菜。
总结一下优点： 用户体验的提升。在创建Web站点时，在客户端执行屏幕更新的时候，相较于传统方式，能为用户提供更好的体验、更好的灵活性。
处理速度的提升
1.1 在实践中的应用： 如动态更新购物车的物品总数，无需等待用户单机Update并等待服务器重新发送整个页面
提升站点的性能，这个呢则是通过减少从服务器下载的数据量而实现的。 例如：Amazon的购物车页面，当用户更新篮子中的一项物品的数量时，会重新载入整个页面，而这，就必须下载32k的数据。 但若使用Ajax计算新的总量，服务器就只会返回新的总量值，因此所需的宽带仅为原来的百分之一。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3087faf821ed617f510326c160450b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91f172a1c579d9f0e7a292af633483dd/" rel="bookmark">
			学习笔记5-MPU6050模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录 一、相关介绍二、相关图解2.1模块电路图2.2系统结构图 三、MPU6050初始化四、寄存器配置1、电源管理寄存器1（0x6B）2、电源管理寄存器2（0x6C）3、陀螺仪配置寄存器（0X1B）4、加速度传感器配置寄存器（0X1C）5、FIFO使能寄存器（0X23）6、陀螺仪采样率分频寄存器（0X19）7、配置寄存器（0X1A）8、加速度传感器数据输出寄存器（0X3B~0X40）9、陀螺仪数据输出寄存器（0X43~0X48）10、温度传感器数据输出寄存器（0X41~0X42） 总结 一、相关介绍 MPU-60X0是世界上第一款集成 6 轴MotionTracking设备。它集成了3轴MEMS陀螺仪，3轴MEMS加速度计，以及一个可扩展的数字运动处理器 DMP（ DigitalMotion Processor），可用I2C接口连接一个第三方的数字传感器，比如磁力计。扩展之后就可以通过其 I2C或SPI接口输出一个9轴的信号（ SPI接口仅在MPU-6000可用）。 MPU-60X0也可以通过其I2C接口连接非惯性的数字传感器，比如压力传感器。
二、相关图解 2.1模块电路图 2.2系统结构图 三、MPU6050初始化 初始化I2C接口。
复位MPU6050（电源管理寄存器1-0x6B）。
设置角速度传感器和加速度传感器的满量程范围（陀螺仪采样率——采样率分频寄存器0x19；设置数字低通滤波器——配置寄存器0x1A）。
设置系统时钟（电源管理寄存器1-0x6B）。
使能角速度传感器（陀螺仪）和加速度传感器（电源管理寄存器2-0x6C）。
四、寄存器配置 1、电源管理寄存器1（0x6B） DEVICE_RESE=1，复位MPU6050，复位完成后，自动清零。
SLEEP=1，进入睡眠模式；SLEEP=0，正常工作模式。
TEMP_DIS，用于设置是否使能温度传感器，设置为0，则使能CLKSEL[2:0]，用于选择系统时钟源。
2、电源管理寄存器2（0x6C） 该寄存器的LP_WAKE_CTRL用于控制低功耗时的唤醒频率剩下的6位，分别控制加速度和陀螺仪的x/y/z轴是否进入待机模式，全部设置为：0 （全部都不进入待机模式）。
3、陀螺仪配置寄存器（0X1B） 只需要关心FS_SEL[1:0]这两个位；一般设置为3（即±2000°/S），因为陀螺仪的ADC为16位分辨率，所以得到灵敏度为：65536/4000=16.4LSB/(°/S)。
4、加速度传感器配置寄存器（0X1C） 只关心AFS_SEL[1:0]这两个位；一般设置为0（即±2g），因为加速度传感器的ADC也是16位，所以得到灵敏度为：65536（2^16）/4000（2000*2）=16384LSB/g。
5、FIFO使能寄存器（0X23） 该寄存器用于控制FIFO使能，在简单读取传感器数据的时候，可以不用FIFO，设置对应位为：0，即可禁止FIFO，设置为1，则使能FIFO。
注意：加速度传感器的3个轴，全由1个位（ACCEL_FIFO_EN）控制，只要该位置1，则加速度传感器的三个通道都开启FIFO。陀螺仪的各自控制（位4-6）。
6、陀螺仪采样率分频寄存器（0X19） 该寄存器用于设置MPU6050的陀螺仪采样频率，计算公式为：
采样频率 = 陀螺仪输出频率 / (1+SMPLRT_DIV)
这里陀螺仪的输出频率，是1KHz或者8KHz，与数字低通滤波器（DLPF）的设置有关，当DLPF_CFG=0/7的时候，频率为8KHz，其他情况是1KHz。而且DLPF滤波频率一般设置为采样率的一半。采样率，我们假定设置为50Hz，那么：SMPLRT_DIV=1000/50-1=19。
7、配置寄存器（0X1A） 重点看数字低通滤波器（DLPF）的设置位，即：DLPF_CFG[2:0]，加速度计和陀螺仪，都是根据这三个位的配置进行过滤的，如下表：
设置：带宽=1/2采样率
DLPF_CFG为4时较为合理。
8、加速度传感器数据输出寄存器（0X3B~0X40） 该寄存器总共由6个寄存器组成，输出X/Y/Z三个轴的加速度传感器值，高字节在前，低字节在后。
9、陀螺仪数据输出寄存器（0X43~0X48） 该寄存器总共由6个寄存器组成，输出X/Y/Z三个轴的陀螺仪传感器数据，高字节在前，低字节在后。
10、温度传感器数据输出寄存器（0X41~0X42） 通过读取0X41（高8位）和0X42（低8位）寄存器得到，温度换算公式为：
Temperature = 36.53 + regval/340
其中，Temperature为计算得到的温度值，单位为℃，regval为从0X41和0X42读到的温度传感器值。
参考自1、。
总结 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c784340d0dc3ada8360b6de940d0c396/" rel="bookmark">
			Kubernets基本介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Kubernetes是一个容器编排引擎，主要用于容器自动化部署，自动扩容和容器化应用（如docker）的管理。
不同的部署方式 传统方式： 所有的应用程序共用所有的硬件资源。如果某一个应用占用资源比较多的话，另外的应用程序就会减少到占用相同资源的机会。
虚拟部署方式：在同一个机器上部署多个不同的虚拟机，这些虚拟机之间互相不影响资源的占用。每个虚拟机都有一个自己独立的操作系统，所有这种部署方式虚拟机本身对资源的占用就比较多，而且同一个物理机器上能部署的虚拟机数量也是有限的。
容器化部署：所有的容器共享机器本身的操作系统，每个容器本身都有自身的一套文件系统，容器之间互相不影响，这种方式相对于虚拟部署方式就会更轻量。
为什么需要kubernets？ 由于容器化部署越来越受到青睐，但是如果手动部署和管理这些容器，容器就会存在宕机事件，这样是不能接受的。同时手动部署也容易出现人为错误，所有kubernetes就出现了，他可以帮我们解决这些问题。
Kubernetes主要能做下面这些事情：
服务发现和负载均衡存储编排：允许自动挂载所需的存储系统，如本地储存，公共云提供商等。自动部署和回滚自动完成装箱计算：允许指定每个容器所需的CPU和内存（RAM）自我修复密钥与配置管理：可以存储和管理敏感信息。 kubernetes组件 kubernetes都是以集群方式存在的，一旦部署Kubernets，就部署了一个Kubernets集群。
Kubernetes集群主要有三个部分组成：控制平台组件，节点（Node）组件和插件（Addons）
控制平面组件 组件描述kube-apiserverkubernetes API服务器，是Kubernetes控制平面的前端。etcd是kubernetes集群所有数据的后台键值数据库，具有一致性和高可用的特点kube-scheduler负责监视新创建的，未指定运行节点（node）的Pods，选择节点让Pod在上面运行kube-controller-manager主要负责运行控制器进程。主要包括节点控制器（负责节点出现故障时进行通知和响应），任务控制器（监控代表一次性任务的Job对象，然后创建Pods来运行这些任务），断点控制器（填充断点对象）， 服务账户和令牌控制器：为新的命名空间创建默认账号和API访问令牌）cloud-controller-manager指嵌入特定云的控制管理器 Node（节点）组件 节点组件在每个节点上运行，维护运行的Pod并提供Kubernetes运行环境
组件描述kubelet每个节点上运行的代理。kube-proxy集群种每个节点上运行的网络代理，实现kubernetes服务（service）概念的一部分容器运行时（Container Runtime）负责运行容器的软件，如Docker， containerd， CRI-O等其他任何实现 插件（Addons） 插件使用Kubernetes资源（DamonSet、Deployment等）实现集群功能。插件种命令空间域的资源所有kube-system命令空间）
插件类型描述DNS集群DNS是一个DNS服务器，和环境中的其他DNS服务器一起工作，它为Kubernetes服务提供DNS记录Web界面（仪表盘）Dashboard是Kubernetes集群的通用的、基于Web的用户界面容器资源监控将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中集群层面日志负责将容器的日志数据保存到一个集中的日志存储中 各种资源 kubernetes的资源对象主要分为4类，分别是资源对象，存储对象，策略对象和身份对象，如下
类别名称资源对象Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling、Node、Namespace、Service、Ingress、Label、CustomResourceDefinition存储对象Volume、PersistentVolume、Secret、ConfigMap策略对象SecurityContext、ResourceQuota、LimitRange身份对象ServiceAccount、Role、ClusterRole 每个kubernetes资源对象包含两个嵌套的对象字段：对象spec和对象status。其中spec描述对象的期望状态，status描述了对象的实际状态，由kubernetes系统提供和更新。
命令行工具 kubernetes提供了4个常用的命令行工具：kubectl、kind、minikube和kubeadm
工具介绍kubectl可以对Kubernetes集群运行命令，主要可以做部署应用、监控和管理集群资源以及查看日志kind使用该工具可以让你在本地计算机运行Kubernetesminikube与kind类似，能让你在本地运行kuberneteskubeadm可以用来创建和管理Kubernetes集群 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b016be04c09c590de43c7958907f89dd/" rel="bookmark">
			蓝桥杯——车的放置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述
在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
输入格式
包含一个正整数n
输出格式
一个整数，表示放置车的方法数
样例输入
2
样例输出
7
数据规模和约定
n&lt;=8
【样例解释】一个车都不放为1种，放置一个车有4种，放置2个车有2种。
思路分析
直接用深搜解决最为简单，用一个变量表示行，因为车之间不能进行攻击，所以一行最多放一个车。用一个变量表示行，最多n行，然后用一维数组进行遍历做标记，一行最多摆放一个，然后记录摆放种数；最后输出结果即可；
#include &lt;stdio.h&gt; int n; int cont=1;	//什么都不放也是一种 int a[100]; //深搜算法，用变量表示行，然后直接用一维数组表示各列进行遍历 int dfs(int stap) { int i; if(stap&gt;n) return; for(i=1;i&lt;=n;i++)	//判断这一列有没有放车 { if(a[i]==0)	//用1做标记，标记已经放了 { a[i]=1; cont++; dfs(stap+1); a[i]=0; } } dfs(stap+1);	//跳向下一行 } int main() { scanf("%d",&amp;n); dfs(1); printf("%d",cont); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/241e43acbc02f31ea8ce8ce16ff8f2c8/" rel="bookmark">
			9. Palindrome Number回文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 class Solution: def isPalindrome(self, x: int) -&gt; bool: s=str(x) if s==s[::-1]: return True else: return False 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0b0ebcd4a660709e04b083c37d98afd/" rel="bookmark">
			基于双任务一致性的半监督医学图像分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文总结：
基于双任务一致性的半监督医学图像分割
背景：大多数现有的半监督学习（SSL）算法都倾向于通过扰动网络和/或数据来规范模型训练。观察到多/双任务学习关注具有固有预测扰动的不同级别的信息。
目的：这篇论文主要致力于“明确的构建任务级正则化”。
解决方法：首次提出了一种新的“双任务一致性半监督框架”。
具体来说就是使用了一个双任务深度网络，它联合预测了一个像素级的分割地图和一个目标的几何感知水平集表示。通过一个可微的任务变换层，将水平集表示法转换为一个近似的分割映射。同时，我们引入了一种在水平集衍生的分割映射和直接预测的分割映射之间的双任务一致性正则化方法。
主要思想：是建立全局水平集函数回归任务和像素级分类任务之间的一致性，以考虑几何约束并利用未标记数据。
框架由三个部分组成：第一部分是双任务分割网络。具体地说，我们将一个分割问题建模为两种不同的表示（任务）：预测一个像素级的分类图和获得一个全局水平的水平集函数，其中零水平让是分割轮廓。我们使用一个双分支网络来预测这两种表示，并使用一个CNN来预测水平集函数。将全局信息和几何约束嵌入到网络中，以获得更好的性能。该框架的第二部分是一个可微的任务转换层。我们使用平滑的透明质层层(Xue等。以可微的方式将水平集函数转换为分割概率映射。第三部分是一个组合损失函数监督和无监督学习，我们设计一个双任务一致性损失函数最小化的差异预测像素分割概率地图和概率地图转换从水平集函数，可以用来提高完全监督学习的性能，也可以用于利用无监督学习。
框架应用实践：提出的框架已应用于两种不同的半监督医学图像分割任务：MRI的左心房分割和CT的胰腺分割。
优点：1)在完全监督设置下，我们的双任务一致性正则化优于双任务的单独和联合监督。
在半监督设置下，所提出的框架在几个临床数据集上优 于最先进的半监督医学图像分割框架 3）与现有的方法相比，所提出的框架需要更少的训练时间和计算成本。同时，它还直接适用于任何半监督的医学图像分割场景。如果任务之间存在可微的转换，则很容易扩展到使用其他任务。
结论：总的来说，我们提出了一种简单而有效的具有双任务一致性的半监督医学图像分割方法，该方法通过鼓励对不同任务下相同输入的一致预测来利用未标记数据。
大量实验表明，我们的方法可以通过合并未标记数据来极大地提高性能。同时，我们的框架优于最先进的半监督学习方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553e05e3d086767aa9327fc8a9003f7c/" rel="bookmark">
			DDOS高防IP的用途
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDOS高防IP是为了应对互联网的DDOS攻击而产生的一款付费增值产品。
那么该怎么使用呢？
DDOS高防IP根据不同的业务接入的方法也不同，在开通这款DDOS高防IP时服务商会给到对应的高防IP作为对外IP和业务IP使用。
游戏业务就需要将之前配置在服务端的服务器IP修改成高防IP（网站业务只需要把之前的域名解析掉高防IP上就可以了），并且在服务商给到的后台填写上需要转发回的服务器IP和端口，当全部配置完成后，即可隐藏掉之前的服务器IP，使对外IP显示为高防IP。
如此攻击也只能经过高防IP了，而高防IP配备有专门的硬件防火墙，当流量经过高防IP时，高防IP会将恶意流量也就是攻击流量过滤掉，只转发正常的流量返回源站，保障业务在攻击中还可以正常开展。
除了防止DDOS攻击以外，德迅云安全还专门研发了更多的安全功能添加到DDOS高防IP上，使之前单一防御DDOS攻击的高防IP在面对市场上更多繁杂的攻击时，也可以从容应对。
1、APP签名防御
APP专用防CC策略，通过配置通信密钥、请求头标示名称以及HASH算法。同时将信息部署到APP应用程序中，对访问请求进行请求签名，将签名结果配置到请求头中，同请求一起发出。如校验通过，则放行回源，如未通过，则进行拦截，从而达到零误封，彻底解决了APP应对CC攻击时的无拦截的痛点。
2、全协议防护
支持UDP/TCP/HTTP/HTTPS/WSS等各种协议接入，支持网站和非网站业务的DDOS防护，覆盖金融、电商、游戏等各类业务的防护策略，充分满足用户不同业务的安全防护需求。
3、端口监控
分布式全国多线检测节点，实时对使用端口进行延迟监测和故障监测，让用户能了解自身业务在全国范围内的网络延迟情况，减少运维工作量。
4、WEB应用安全
建立自学习安全WEB样本库防火墙，对访问进行特征匹配，有效抵御SQL注入、XSS攻击、本地文件包含等各类WEB攻击，实时保护用户源站。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b8a34a53fec52c51b9b941e5695ce6/" rel="bookmark">
			QT-CSV文件读写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT-CSV文件读写 前言一、CSV文件初始化二、CSV写入三、CSV读取四、程序链接 前言 csv文件之所以被用户推荐使用，我觉得即可以用excel打开，同时也是可以用文本编辑器打开，而且文本内容的显示也是比较有规律，用户查看起来也是能清晰看的明白，所以这里其实就是已经讲得出来了，csv的操作，其实就是你平时使用txt文件操作，只是我们按照csv的格式（xxx，xxx 列与列直接用英文逗号分开）进行文本保存，同时将文本的后缀名修改成csv罢了，接下来我们就进行读写的操作具体的了解。
一、CSV文件初始化 那如果我们本地盘符就是不存在csv文件，通常我们都是会先创建一个csv文件，看下下面的程序吧，这样直接点。
// 我们都放C：//CSV文件夹里面吧 QString strDir = QString("%1/%2").arg("C://").arg("CSV"); // 先检查有没有文件夹存在，没有就让程序创建文件夹先 QDir dirCSV; if (!dirCSV.exists(strDir)) dirCSV.mkpath(strDir); // 使用时间格式进行csv文件命名吧 m_strFilePath = strDir + "/" + QString("csv%1.csv").arg(QDateTime::currentDateTime().toString("yyyy-MM-dd")); // 因为是文件操作，安全一些都是加个锁 static QMutex mutex; mutex.lock(); QFile fileCSV; // 判断文件是否不存在 if (!fileCSV.exists(m_strFilePath)) { QFile file(m_strFilePath); if (file.open(QIODevice::WriteOnly | QIODevice::Append | QIODevice::Text)) { QTextStream in(&amp;file); QString strText(""); // 文件不存在，第一次，我们就给他写个列表名字，这样csv文件打开时候查看的时候就比较清晰 strText = QString("DateTime,") + QString("Info"); in &lt;&lt; strText &lt;&lt; '\n'; file.close(); } } mutex.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b8a34a53fec52c51b9b941e5695ce6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8757635953ea60d5cd215c1b521da6b8/" rel="bookmark">
			[sitemap 索引情况提示] 根据 sitemap 的规则[0]，当前页面 [pages/index/index] 将被索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题如下:
解决：
在微信开发者工具找到project.config.json文件
在setting中找到checkSiteMap设置为false即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dd791938330f27096dee6515c002def/" rel="bookmark">
			u-boot分析（三）：main函数分析、uboot自拷贝和重定位
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uboot分析三 1、main函数1.1 board_init_f_alloc_reserve函数1.2 board_init_f_init_reserve函数1.3 board_init_f函数1.3.1 initcall_run_list函数 1.4 relocate_code函数1.5 relocate_vectors函数1.6 c_runtime_cpu_setup 函数1.7 board_init_r 函数1.7.1 init_sequence_r 1、main函数 main函数代码如下。sp = CONFIG_SYS_INIT_SP_ADDR = 0X0091FF00, 未定义CONFIG_CPU_V7M，sp 8字节对齐，r0 = sp，执行 board_init_f_alloc_reserve函数。
ENTRY(_main) /* * Set up initial C runtime environment and call board_init_f(0). */ #if defined(CONFIG_SPL_BUILD) &amp;&amp; defined(CONFIG_SPL_STACK) ldr	sp, =(CONFIG_SPL_STACK) #else ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR) #endif #if defined(CONFIG_CPU_V7M)	/* v7M forbids using SP as BIC destination */ mov	r3, sp bic	r3, r3, #7 mov	sp, r3 #else bic	sp, sp, #7	/* 8-byte alignment for ABI compliance */ #endif mov	r0, sp bl	board_init_f_alloc_reserve mov	sp, r0 /* set up gd here, outside any C code */ mov	r9, r0 bl	board_init_f_init_reserve mov	r0, #0 bl	board_init_f #if !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2dd791938330f27096dee6515c002def/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ce6e5c2c37582b68209ec645ea5a63/" rel="bookmark">
			Rust安装(windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows安装Rust开发环境指南 Rust的安装非常简单，官网下载安装包双击就能安装，但是在windows上使用总是能遇到一些问题，今天我们就来踩踩坑。
设置安装路径 当你安装Rust的时候会发现没法选安装路径，对于强迫症来说，还没开始就劝退了。其实Rust是可以执行安装路径的，只不过需要通过环境变量来指定。首先说怎么操作，后面再看为什么。
Rust需要安装两个东西，一个是rustup，一个是cargo。所以你需要设置两个环境变量来分别指定他们的安装目录。
通过RUSTUP_HOME指定rustup的安装目录。
通过CARGO_HOME指定cargo的按钻过目录。
这两个环境变量既可以放在用户环境变量下，也可以放在系统环境变量下。
当我们打开Rust安装程序，选择y继续安装时，可以先把鼠标网上滚一滚，看看Rust都打印了什么信息。
注意看划红线的地方，如果你没设置过环境变量，那么默认会安装到C:\User\用户名\.rust下。
没有C++环境 Rust编译需要C++环境，如果你没有，Rust也能安装成功，只是无法编译代码。下面我们分几种情况来谈论。
已经安装了Rust 如果你已经在没有C++环境的情况下安装了Rust，此时你可以选择去安装visual studio code，然后就能使用Rust了。但是如果你不想安装这么个大家伙，而且你本身也不是做C/C++开发的，那么你可以使用下面的命令挽救。
rustup toolchain install stable-x86_64-pc-windows-gnu rustup default stable-x86_64-pc-windows-gnu 然后在你的rustup的安装目录的toolchain目录下会出现stable-x86_64-pc-windows-gnu这样一个目录，它下面有个bin目录，你需要确认下这个bin目录已经添加到path。然后就能使用Rust编译了。
关于第二个命令我们稍微解释下。C++的编译工具有两个，一个是msvc，也就是visual studio code会安装的，另一个是mingw。在没有安装visual studio code单数又需要C++环境时，我们会首选安装mingw。上面的第二行命令其实就是把Rust用到的C++工具设置为mingw。因为它默认选择的是x86_64-pc-windows-msvc。
如果你之前已经安装过mingw，但是安装Rust选的是默认的x86_64-pc-windows-msvc。那么其实你只需要执行上面的第二条命令就可以了，但是要注意你的mingw要加到path。
还没安装Rust 如果你还没有安装Rust，那么可以在输入y以后选择2，进入自定义安装。然后在需要输入host triple的时候输入x86_64-pc-windows-gnu，后面都默认。当再次回到上图的界面是，你会发现default host triple那一行已经变成了x86_64-pc-windows-gnu，此时再选择1进行安装。
安装完成后执行下rustup toolchain install stable，装完收工。
要验证Rust安装成功可以执行下rustup --version。
要更新Rust可以执行rustup update。
卸载请执行rustup self uninstall。
关于rustup命令更多内容，可以看rustup官方文档。
IDE Rust并没有专用的IDE，推荐使用vscode，安装下Rust插件，有只能提示和文档，还是蛮爽的。
另外你用vscode打开.rs文件时会提示你安装Rust扩展，直接点安装就完了，装完就可以爽了。再奉送一个vscode小技巧，如果你习惯用命令行的话，输入code .就能打开vscode并且已打开当前目录。
不知道有没有人好奇我的vscode的毛玻璃效果，它是Vibrancy这个插件，不过只能用于vscode默认的黑色主题。
最后再奉上一个例子，是力扣题库的第一题：两数之和。需要一点基础，刷题其实也是快速熟悉一门语言语法比较好的方式。
use std::collections::HashMap; fn main() { let res = tow_sum(vec![3,2,4], 6); println!("{:?}", res); } fn tow_sum(nums:Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; { let mut map = HashMap::new(); for (i,v) in nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4ce6e5c2c37582b68209ec645ea5a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d061eede075eb698b70be9cf70f718b0/" rel="bookmark">
			Vue双向绑定：原理篇（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言什么是响应式数据劫持发布者-订阅者模式模式简介发布者 Observer订阅器 dep订阅者 Watcher 整体流程初始化datadata变为响应式数据解析模板收集依赖数据变化—视图更新视图更新—数据变化 更新的粒度更细的粒度更新中等粒度更新 Vue3的Proxy数据劫持理解Proxy特点兼容性问题 总结 前言 提起Vue的双向绑定或数据响应式，很多人都知道是数据劫持和发布者-订阅者模式，这里具体分析一下这两部分具体是怎么实现。
（最近看了相关资料，对原来不足的地方进行修改完善，还增加了更新的粒度和Vue3的Proxy内容）
什么是响应式 如果经常使用Vue或React等框架开发，对响应式更新这个词并不陌生，简单来说就是视图会自动更新。
原生JS实现就需要先找到DOM，再修改DOM ​ 比如
const clockDom = document.getElementById clockDom.innerText = '修改文本内容' 现在使用响应式框架，修改数据的时候，我们不需要关注DOM。在Vue中，this.xxx就可以实现页面数据更新。我们从数据劫持开始了解。 数据劫持 数据劫持其实就是数据响应式基础，当获取数据或者修改数据的时候，能够被我们知道，然后触发响应操作，在Vue2中是通过Object.defineProperty()实现的。 比如，下面这个对象
let person = { name:'tom', age:15 } 我们可以person.name获取到tom，但是我想在获取到tom的时候，还要进行其他操作，就要使用Object.defineProperty() Object.defineProperty(person,'name',{ get(){ console.log('name属性被读取了...'); }, set(newVal){ console.log('name属性被修改了...'); } }) 当访问name属性的时候，会调用get方法，而修改name属性的时候，会调用set方法，可以去执行相应的操作。
但是，这个时候访问被拦截了，我们获取不到name的属性值，所以需要在get方法里面return一个值，上面代码修改如下：
let person = {} let val = 'tom' Object.defineProperty(person,'name',{ get(){ console.log('name属性被读取了...'); return val; }, set(newVal){ console.log('name属性被修改了...'); val = newVal; } }) 因为属性值可以由对象直接提供，不会单独声明，所以传入对象的时候，可以传入键和值。所以将val变量和defineProperty方法提取到一个函数中，就形成defineReactive函数 function defineReactive(obj, key, val) { // 这里相当于let val= val（传入的参数） Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d061eede075eb698b70be9cf70f718b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50a6577d2fd6de45ee4d0cf551471aaa/" rel="bookmark">
			Vue双向绑定：实现篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 创建项目MVVM类Observer类Dep类Compiler类Watcher类$set 和 $delete总结 前面一篇已经将双向绑定原理讲了基本知识，这里通过代码实现一下，会有更深入的了解。 如果对双向绑定或响应式原理不够了解，可以先查看原理分析那篇。 Vue双向绑定（原理篇） 创建项目 新建项目文件夹
在文件夹中npm init 初始化项目
安装webpack（3个包）
"devDependencies": { "webpack": "^5.71.0", "webpack-cli": "^4.9.2", "webpack-dev-server": "^4.8.1" } 配置webpack.config.js
入口和出口
const path = require('path'); module.exports = { entry: path.join(__dirname, "/src/index.js"), // 入口文件 output: { path: path.join(__dirname, "/dist"), //打包后的文件存放的地方 filename: "bundle.js" //打包后输出文件的文件名 } } src文件夹
新建src文件夹，用来放置创建的文件，结构如下：
src(文件夹) index.js utils.js mvvm（文件夹） dep.js mvvm.js watcher.js compiler（文件夹） compiler.js directiveCompiler.js textCompiler.js observer（文件夹） observer.js array.js 下面开始撸代码。
MVVM类 在MVVM.js文件中
初始化
前面介绍过，vue是Vue类的实例，Vue类在constructor中接收参数进行实例化。这里使用MVVM类模拟一下
export default class MVVM { constructor(options) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50a6577d2fd6de45ee4d0cf551471aaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68f93579f69eb37c167ec1da9e2c637f/" rel="bookmark">
			快递物流查询接口查询类API接口介绍_快递鸟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快递物流查询接口是指快递查询网对外开放的应用程序接口，开发人员能够通过调用该接口与快递查询网进行交互，并基于该接口开发自己的快递查询应用程序。目前比较常用的接口有快递鸟、菜鸟、快递100等。 1、应用场景
电商网站用户打开“我的订单”时调用此API显示物流信息详情；或者是电商管理后台的物流系统，客服在对账前查询所有运单的签收状态，并追踪问题。
​
2、快递查询接口分类
物流轨迹查询接口有即时查询和订阅查询两种，即时是请求即返回数据，订阅则是订阅快递单号到接口，有物流轨迹更新则全量返回数据。 快递鸟即时接口可以查询3000次，3000以上接订阅接口，统一接口模式接入，常用快递均支持查询，还有订阅接口、在线下单接口、电子面单接口，接口均不收取费用， 没有要求用户添加外链，支持600家国内外快递物流查询。
快递100每天可以免费查询2000次，超过2000次收费，每次0.06~0.1元不等，如果查询的量大的话可以降低费用，免费的接口有几家常用快递不支持接口模式，只支持 htmlAPI，要求用户添加外链，支持300多家国内外快递物流查询。
快递网每天可以免费查询500次，超过500次收费，每次0.05元，只有即时查询和订阅推送接口，要求用户添加外链，支持395家国内外快递物流查询。
3、对接说明
不同公司的快递查询接口接入类似，都需要注册 ，申请账号获取KEY和ID，如果是订阅接口需要技术联调。以快递鸟及时查询接口接入为例。
根据快递单号和快递公司编码查询物流轨迹信息。接口需要指定快递单号的快递公司编码，格式不对或则编码错误都会返失败的信息。如：EMS物流单号应选择快递公司编码（EMS返回的物流跟踪信息按照发生的时间升序排列。
快递查询接口类API技术文档地址：http://www.kdniao.com/api-all
5款热门产品：在途监控、快递查询、电子面单、轨迹地图、国际版在途监控“ 0元免费试用 ”活动地址：http://www.kdniao.com/v2/activity/try.aspx?from=CSDN
接口支持的消息接收方式为HTTP POST
3.1请求系统级参数
参数名称
类型
说明
必须要求
RequestData
String
请求内容需进行URL(utf-8)编码。请求内容JSON或XML格式，须和DataType一致。
R
EBusinessID
String
商户ID，请在我的服务页面查看。
R
RequestType
String
请求指令类型：1002
R
DataSign
String
数据内容签名：把(请求内容(未编码)+AppKey)进行MD5加密，然后Base64编码，最后进行URL(utf-8)编码。详细过程请查看Demo。
R
DataType
String
请求、返回数据类型：1-xml,2-json；默认为xml格式
O
3.2请求内容字段定义
参数
类型
说明
必须要求
OrderCode
String
订单编号
O
ShipperCode
String
快递公司编码
R
LogisticCode
String
物流单号
R
3.3返回参数定义
参数名称
类型
说明
必须要求
EBusinessID
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68f93579f69eb37c167ec1da9e2c637f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/247/">«</a>
	<span class="pagination__item pagination__item--current">248/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/249/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>