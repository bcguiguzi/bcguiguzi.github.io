<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99eeef2abc881a17848e130766a476d1/" rel="bookmark">
			C&#43;&#43;算法题 # 9 高精度乘法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个非负整数（不含前导 0） A 和 B，请你计算 A×B 的值。
输入格式
共两行，第一行包含整数 A，第二行包含整数 B。
输出格式
共一行，包含 A×B 的值。
数据范围
1≤A的长度≤100000,
0≤B≤10000
输入样例：
2 3 输出样例：
6 思路
这里因为B是一个小的int型变量，所以这里计算乘法算式时，只需要考虑A的每一位与B进行相乘然后进位和取余保留当前位的值，和加法类似。
代码示例
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; mul(vector&lt;int&gt; A, int b) { vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size() || t; i ++)//这里的t代表的是到高位后需要退出，即低一位的计算没有进位 { if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; }	while (C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99eeef2abc881a17848e130766a476d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b81d5e248aa85f0cadf0349c7d4a3584/" rel="bookmark">
			手写 call、apply 及 bind 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前在bind和apply以及call函数使用中详解总结过bind和apply以及call函数的使用，下面手写一下三个函数。
一、首先call函数
Function.prototype.MyCall = function (thisArg, ...args) { let fn = this //this指的是当前函数 thisArg = (thisArg === undefined || thisArg === null) ? window : Object(thisArg) thisArg.fn = fn args = args || [] //如果arg不存在，就将其设置为[],方便结构 let res = thisArg.fn(...args) delete thisArg.fn //执行完之后就删除该对象上的属性 return res } 二、手写apply函数
Function.prototype.MyApply = function (obj, arg) { let fn = this //this表示函数 // 如果要是obj为undefined或者null时，设置其为window, // 如果是基本数据类型，则将其设置为对象类型 let thisArg = (obj === undefined || obj === null) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b81d5e248aa85f0cadf0349c7d4a3584/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0cc220b3670dd2f142d0fdbdeaa9b42/" rel="bookmark">
			Django项目笔记(七)——匹配系统的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Django上课笔记(七)——匹配系统的实现 也欢迎大家光临我另外项目课的其他博客： Django上课笔记(一)——环境配置与项目创建(过程十分详细） - AcWing
(更新版)Django上课笔记(二)——菜单模块的实现， 含自动创建项目的脚本
Django上课笔记(三)——简单游戏的实现(模块拆分化详解) - AcWing
Django上课笔记(四)——(用户系统的实现) - AcWing
pycharm连接服务器同步写代码(图文详细过程)
linux基础课thrift详细开发过程 - AcWing
项目地址 https://git.acwing.com/codeRokie/acapp
前置知识 linux基础课thrift详细开发过程 - AcWing
思路 因为匹配过程是一个长时间等待响应的过程，如果把这个过程放在游戏服务器的"主机"上，将会及其消耗资源。因此要再创建一个主机，实现匹配功能，匹配主机和游戏主机间用thrift进行通信。
由于只有一台服务器，所以两台主机实际上是两个进程实现的。
流程图 实现 创建匹配服务主机 1.在项目文件夹下创建match_system/src和match_system/thrift
2.编写接口文件match_system/thrift/match.thrift
namespace py match_service service Match { i32 add_player(1: i32 score, 2: string uuid, 3: string username, 4: string photo, 5: string channel_name), } 4.由接口文件，在match_system/src下，用thrift官方命令，生成框架代码
thrift -r --gen &lt;语言名&gt; &lt;.thrift文件的路径&gt; thrift -r --gen py ../thrift/match.thrift 这样，就会生成match_system/src/gen-py文件夹，将该文件夹重命名为match_server
5.完善acapp/asgi.py
#导入django支持 import django #启动django django.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0cc220b3670dd2f142d0fdbdeaa9b42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83260b3e5e783dcd84ac47f2aa04a107/" rel="bookmark">
			忽略 ESLint 中的行和文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ESLint 根据预定义的规则分析代码以发现问题。然而，有时你需要打破 ESLint 规则。ESLint 支持两种机制来忽略代码中的规则冲突：
使用注释，可以禁用行或代码块的某些规则。使用 .eslintignore 文件。 使用注释禁用 ESLint ESLint 允许您使用 /* eslint */ 注释禁用单个 lint 规则。例如，许多 ESLint 规则不允许使用 JavaScript 的 eval() 函数，因为 eval() 有几个安全问题。但是，如果您确实确定要允许 eval()，可以按如下方式禁用 lint 规则：
const res = eval('42') // eslint-disable-line no-eval // eslint-disable-line 注释仅对该行禁用 no-eval 规则。
您还可以使用 /* eslint-disable */，禁用整个功能块的 no-eval 规则。
function usesEval() { /* eslint-disable no-eval */ const res = eval('42') const res2 = eval('test') return res2 + res } 如果将 /* eslint-disable no-eval */ 放在 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83260b3e5e783dcd84ac47f2aa04a107/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1da962734f375fd5e2defcded1ef0c1/" rel="bookmark">
			分享一个鼠标宏软件（XMouseButtonControl）用于替换logitech option等软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 为什么要替换？2 XMouseButtonControl的优势？3 使用3.1 设置语言3.2 配置按键宏 3.3 设置自启动4 安装包 1 为什么要替换？ 我的鼠标是logi M590, 最近其鼠标宏管理软件logitech option打不开，导致鼠标定义的宏无法使用，严重影响写代码的体验。
2 XMouseButtonControl的优势？ XMouseButtonControl ：
轻量化。自由度高。支持中文 3 使用 3.1 设置语言 我使用的是免安装版本，软件中的设置语言不能生效，需要改变其XMouseButtonControl.exe文件对应路径下的配置文件XMBCSettings.xml的Language字段，选中简体中文配置文件：Simplified_Chinese.xmbclp
3.2 配置按键宏 我需要把鼠标侧键改成vscode快捷键 F3（向下搜索）以及 SHIFT+F3（向上搜索），配置为：
下面就有教程，很方便。
3.3 设置自启动 创建XMouseButtonControl.exe的快捷方式到C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp 自启动文件夹即可。
4 安装包 链接：https://pan.baidu.com/s/1fyTswyBlMPw4TGyt2rG_Tg
提取码：nice
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f570b7754f4d1a43b8f4aead92e4916d/" rel="bookmark">
			flutter学习-主题风格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主题风格 1. Theme主题的使用1.1 全局Theme1.2 局部Theme 2. 黑暗Theme适配2.1 darkTheme2.2 开发中适配 在Flutter开发中，我们可以通过定义主题（Theme），复用颜色和子体，从而让整个APP的设计看起来更一致
1. Theme主题的使用 Theme分为：全局Theme和局部Theme
主题有两个作用：
设置了主题之后，某些Widget会自动使用主题的样式（比如AppBar的颜色）将某些样式放到主题中统一管理，在应用程序的其它地方直接引用 1.1 全局Theme 全局Theme会影响整个app的颜色和字体样式。
使用起来非常简单，只需要想MaterialApp构造器中传入ThemeData即可
如果没有设置Theme，Flutter将会使用预设的样式。当然我们可以对它进行定制 import 'package:flutter/cupertino.dart'; import 'package:flutter/material.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { // TODO: implement build return MaterialApp( title: "Flutter Theme", //全局主题 theme: ThemeData( // 亮度 ： light：整个屏幕都白色 dark： 整个屏幕都是黑色 brightness: Brightness.dark, //2.primarySwatch传入不是Color, 而是MaterialColor(包含了primaryColor和accentColor) primarySwatch: Colors.purple, //主题颜色：导航/底部的TabBar primaryColor: Colors.orange, // 4.accentColor(次要颜色): 单独设置FloatingActionButton\Switch accentColor: Colors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f570b7754f4d1a43b8f4aead92e4916d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3a0c8ae26dc2499e0069dcdfc6133e9/" rel="bookmark">
			Visual Studio Code安装教程（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网盘自取：https://pan.baidu.com/s/1BQDyf7uqQopJ3UUZnQ0E6g 提取码：2022
点击VSCodeSetup-x64进行安装
弹出安装向导，勾选我同意，点击下一步
选择安装目录，点击下一步
选择开始菜单文件夹，点击下一步
创建快捷方式，点击下一步
点击安装
软件正在安装，请稍等
软件安装完成！
中文设置教程 打开软件，使用快捷键Ctrl+Shift+P，在弹出的命令窗口输入“configure language”回车
选择如图所示的选项
会出现语言下载页面，选择中文，点击install
右下角会提示重启软件，点击重启即可
Visual Studio Code软件功能 代码目录功能：快捷键Ctrl+B全局搜索功能：可搜索文件或者目录，快捷键Ctrl+Shift+FGithub，管理代码，必须要在你的电脑上装了git才可使用Debug，用于调试代码，同样需要编译环境支持git分支，显示当前代码所属git分支错误警告，显示当前文件中的语法错误窗口分割，最多支持三个窗口同时浏览文件本地搜索，用于当前文件中内容查找，快捷键Ctrl+FTab长度，显示Tab键对应的长度，一般是4个空格，点击可修改光标状态，显示当前光标位置还有选中的字符数换行字符，CRLF是Windows的回车换行，Unix是则只有换行LF Visual Studio Code软件特色 提供智能感知的自动补全功能内置支持代码调试内置的侧边栏 Git 命令支持多个实例的集成终端通过扩展和主题实现自定义功能使用 VS Code Insiders，可以获取每日构建的最新版本 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769d1f9b480d0b73b8946b58c62f6200/" rel="bookmark">
			jsp学习2(jsp的指令)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 jsp的指令jsp中的九大内置对象: jsp的指令 jsp中有三大指令，分别是:
page指令，最复杂，也是最常用的include —&gt;静态包含，这个和requestDispatcher.include区别是后者是动态包含taglib --&gt;导入标签库 在jsp文件中使用指令的格式为：&lt;%@指令名 属性名=属性值 %&gt;,这里主要重点讲解page指令的常用属性：
1、pageEncoding和contentType pageEncoding表示用来设置当前的jsp文件的编码，也即服务端将当前的jsp文件编译成为.java文件的编码。 而contentType则是设置当前的jsp文件的编码，同时会设置响应头Context-Type的编码为这个属性对应的值。 两者的关系是互为补充的，即只要我们设置其中一个属性的值，例如我们设置了pageEncoding的值为utf-8，那么即使我们没有写contentType，那么就会自动设置contentType的值为pageEncoding的值。 如果我们两个属性都没有设置，那么就会默认为iso编码。 2、isErrorPage和errorPage errorPage的值用来表示如果当前的jsp文件发生了异常，那么就会转发到这个属性对应的jsp文件中。 而isErrorPage则是用来判断当前的jsp文件是否是处理异常的，如果为true，那么当前的jsp文件是处理异常的，此时这个jsp文件就可以使用exception内置对象,但是如果为false，那么这个jsp文件不可以使用exception内置对象。 值得注意的是，如果我们在errorPage值对应的jsp文件中设置了isErroPage属性的值为true，那么运行设置errorPage属性的jsp文件的时候，就会发现接收到的状态码为500,否则，如果errorPage值对应的jsp文件中并没有设置isErrorPage或者值为false，那么运行设置errorPage属性的jsp文件的时候，就会发现接收到的状态码为200。 3、autoFlush和buffer autoFlush:表示当前的jsp文件的缓冲池满的时候是否会自动刷新，如果为true，则会自动刷新，否则不会，此时满的时候会抛出异常. buffer:设置jsp文件的缓冲池，默认情况下是8kB. 4、isELIgnore:判断当前的jsp文件是否忽略EL表达式，如果为false，那么不会忽略，即支持EL表达式 5、import:用来导包的，可以在指令中设置多个import属性，也可以将多个import的值写到同一个import中，此时各个值需要用逗号分开。 6、其他: language:表示当前的jsp文件支持的语言 info:表示信息 isThreadSafe:判断是否支持并发，如果为false，说明不是线程安全，也即支持并发，否则为true，说明线程安全，支持的是单线程。 extends:表示这个jsp文件生成的java文件将会继承extends的值。 这里主要验证errorPage和isErrorPage:
&lt;!-- error1.jsp --&gt; &lt;%@ page contentType="text/html;charset=UTF-8" errorPage="error2.jsp" language="java"%&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;验证errorPage属性&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% /* 值得注意的是，如果在处理异常的jsp文件中有设置isErrorPage属性为true的时候， 那么这时候发送500的状态码. 但是如果我们没有设置isErrorPage的属性，或者值为false的时候，那么就会将发送 200的状态码。 所以说明了，某个jsp文件作为errorPage属性的值的时候(即error2.jsp)，这个jsp文件并不一定要求 设置isErrorPage属性的。但是如果设置了isErrorPage属性为true，那么就可以使用 jsp中的exception内置对象，否则，如果为false，是不可以使用exception内置对象的。 */ int a = 10 / 0;//出现异常，将根据errorPage属性，转发导对应的jsp文件 %&gt; &lt;/body&gt; &lt;/html&gt; &lt;!-- error2.jsp --&gt; &lt;%@ page contentType="text/html;charset=UTF-8" language="java" isErrorPage="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769d1f9b480d0b73b8946b58c62f6200/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64ee98d6ed434e441fc637fa3cd10ff9/" rel="bookmark">
			Android 开机流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 开机流程 Android 系统启动流程 1.启动电源即系统启动： 当电源键按下时引导芯片代码从预定义的地方（固化在ROM）开始执行。加载引导程序BootLoader到RAM中，然后执行。
2. 引导程序BootLoader： 引导程序BootLoader是在Android操作系统开始运行前的一个小程序，它的主要作用是把系统OS拉起来并运行。
3. Linux Kernel 启动： 当Kernel启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成系统设置时，它首先在文件系统中寻找init.rc文件并启动init进程。
4. init进程启动： init进程是Android系统中用户控件的第一个进程，进程号为1。 主要作用：初始化和启动属性服务，并且启动Zygote进程。
可分为三个部分：
创建和挂载启动所需的文件目录初始化和启动属性服务解析init.rc配置文件并启动Zygote进程 对于init进程的功能分为4部分：
解析并运行所有的init.rc相关文件根据rc文件，生成相应的设备驱动节点处理子进程的终止(signal方式)提供属性服务的功能 下面是init.cpp中部分代码，可以看到parser.ParseConfig("/system/etc/init/hw/init.rc")此处对init.rc进行了解析。
static void LoadBootScripts(ActionManager&amp; action_manager, ServiceList&amp; service_list) { Parser parser = CreateParser(action_manager, service_list); std::string bootscript = GetProperty("ro.boot.init_rc", ""); if (bootscript.empty()) { parser.ParseConfig("/system/etc/init/hw/init.rc"); if (!parser.ParseConfig("/system/etc/init")) { late_import_paths.emplace_back("/system/etc/init"); } // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64ee98d6ed434e441fc637fa3cd10ff9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112ed7d7fb9a3155d5cef843a939cc69/" rel="bookmark">
			Java8 常用的Stream流操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.按照条件过滤集合 //type相同的则加入到新的集合 List&lt;User&gt; newList = list.stream().filter(User -&gt; User.getType().equals(request.getType())).collect(Collectors.toList()); //删除元素 list.removeIf(s -&gt; s.getType() == 3); 2.从集合中取出某个字段封装到新的集合 //写法一 List&lt;String&gt; names = list.stream().map(User::getName).collect(Collectors.toList()); //写法二 List&lt;String&gt; names = list.stream().map(s -&gt; s.getName()).collect(Collectors.toList()); 3.在list对象中取某两个属性转成map //key无重复值 Map&lt;Integer, String&gt; map = list.stream().collect(Collectors.toMap(Entity::getId, Entity::getType)); //key有重复值的情况下 Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1)); 4.转换集合中的对象 //将List&lt;Commission&gt;转换成List&lt;CommissionVo&gt; List&lt;Commission&gt; list = new ArrayList&lt;&gt;(); List&lt;CommissionVo&gt; commissionVos = list.stream().map(value -&gt; { CommissionVo commissionVo = new CommissionVo(); BeanUtils.copyProperties(value, commissionVo); return commissionVo; }).collect(Collectors.toList()); 5.计算list对象中的某个属性 //集合中某个属性的和(BigDecimal类型) BigDecimal couponMoneyTotal = redPackageCoupons.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/112ed7d7fb9a3155d5cef843a939cc69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89bc32348e71e75e7231b7578dd535cc/" rel="bookmark">
			Fritzing软件绘制Arduino面包板接线图传感器模块库文件101
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、硬件材料 1*Arduino UNO R3开发板
1*4*4矩阵键盘模块
1*0.96寸OLED显示模块
二、硬件接线图 CSDN@ 赤鱼科技 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d169350ba6dce70dd9cd932a21ae1af/" rel="bookmark">
			H5页面获取微信用户openid极简攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 之前每次写到获取openid 就觉得特别麻烦，网上很多代码段会把一部分功能分开写，确实相对合理，但是对于复制粘贴代码来说依赖越少越方便，所以根据自己的经验做了一个极简的复用代码
前置条件 1.公众号已认证，否则会出现“Scope 参数错误或没有 Scope 权限”
2.公众号后台设置安全域名
【公众号设置】=》【功能设置】=》【JS接口安全域名
】&amp;【网页授权域名】
代码 前端 getOpenId(){ const code = getUrlParam('code') // 截取路径中的code, if (code == null || code === '' || code === false) { const local = window.location.href let appid='&lt;公众号appid&gt;' window.location.href = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid='+appid+'&amp;redirect_uri=' + encodeURIComponent(local) + '&amp;response_type=code&amp;scope=snsapi_base&amp;state=1#wechat_redirect'; } else { let that=this; axios.post('/index/active/getUserInfo?code='+code).then((r)=&gt;{ console.log(r.data) }) } } 后端 此处以php 为例
如果只是需要获取到openid,不需要其他信息
public function getOpenid(){ $appid = '&lt;公众号appid&gt;'; $secret = '&lt;公众号secret&gt;'; $code = $_GET["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d169350ba6dce70dd9cd932a21ae1af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1590650479954a53ce4c3afdb9fe48eb/" rel="bookmark">
			FPGA学习记录-Vivado工程创建、仿真、编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言工程创建工程仿真引脚配置编译 前言 本系列文章作为对特权同学《深入浅出玩转FPGA》课程学习的记录，对课程内容进行总结，比记录遇到的问题与解决办法，以此见证个人FPGA学习历程。这篇文章主要对工程的创建、仿真、编译、烧录过程进行总结，不足之处，还请各位在评论区指出，谢谢！
开发板：SF-AT7
软件平台：Vivado 2016.2
工程创建 在创建工程之前建立一个新的文件夹用于存放之后建立的工程，注意路径中不要出现中文、标点符号等，英文、下划线允许出现。如图所示，在myfpga_test下建立at7002的文件夹 - 打开之前安装好的vivado，点击create new project
在弹出的对话框中修改工程名与工程存放的路径，这里将工程路径直接定位到之前新建立的文件夹即可，然后点击next
下一步选择创建RTL project，即为正常的FPGA逻辑设计工程，RTL全拼为Register Transfer Level，为寄存器转换级。在RTL级，集成电路是由一组寄存器和寄存器之间的逻辑操作构成，RTL是用硬件描述语言（Verilog 或VHDL）描述理想达到的功能，不同于门电路，所以我们选择创建RTL 级工程。
下一步是添加HDL源文件，如果已经设计好源文件，点击add source可以直接添加，若没有直接next；
接着添加IP核、约束文件，如果都没有直接跳过点击next（后续可以在工程界面直接添加）；
其次，添加FPGA的型号，这要根据自己手中已有板子型号进行添加，一般型号的确定在板子提供的原理图上有，以本次工程使用的a7板子为例，打开原理图，找到FPGA的型号：XC7A35TFTG256
在搜索框中搜索该型号：（后面的-1、-2表示速度等级，A7速度等级为1，所以选择最下面的FPGA型号）
最后，点击finish，完成工程创建，创建后vivado页面如下：
注意源文件名称要与工程名称保持一致，因为该源文件作为顶层文件，在源文件中完成相应功能描述
工程仿真 当设计文件按照功能要求编写完毕后，进行工程的仿真，在仿真开始之前要有仿真文件，仿真文件对当前设计做验证。若没有仿真文件，右键sim_1,选择add source即可添加，添加方式和添加源文件一样。仿真文件的编写这里不赘述。
源文件和仿真文件准备好后，进行仿真设置，主要是保证仿真顶层模块名称与工程中仿真文件顶层模块名称一致。
右键相应的信号，可以将波形添加到窗口，具体如图所示
点击run all 进行仿真，即可查看波形。
引脚配置 通过仿真观察波形符合功能要求是，就要开始工程综合，将代码烧录到FPGA开发板中看实际的运行效果。首先要进行引脚分配。Vivado中通过xdc文件实现引脚配置，在文件中规定引脚的电平规范与分配对应开发板中实际的引脚，添加约束文件的方式如下图所示。点击【constrain】-》【constrs_1】右键选择add source 即可添加约束文件。引脚分配一定要对照原理图，确保该引脚空闲且满足电平规范。
编译 Vivado的编译主要分为三步。分别为Run Synthesis（综合编译）、Run Implementation（实现编译）、Generate Bitestream（生成bit流），直接点击Generate Bitstreams会顺序执行综合编译与实现编译，生成的bit流可以利用JTEG直接烧录到板子中进行板级调试。
显示编译成功完成，生成bit流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a37f41c42f2bc18fe4686203353a08b6/" rel="bookmark">
			动态规划问题经典例题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、字符串分割二、三角矩阵的最小路径和三、路径总数四、最小路径和五、背包问题六、 回文串分割七、编辑距离八、不同的子序列 前言 DP（Dynamic Programming）定义：
动态规划是分治思想的延伸，通俗一点来说就是大事化小，小事化无的艺术。在将大问题化解为小问题的分治过程中，保存对这些小问题已经处理好的结果，并供后面处理更大规模的问题时直接使用这些结果。
动态规划具备了以下三个特点：
把原来的问题分解成了几个相似的子问题。所有的子问题都只需要解决一次。储存子问题的解 动态规划的本质，是对问题状态的定义和状态转移方程的定义(状态以及状态之间的递推关系)。
动态规划问题一般从以下四个角度考虑：
状态定义状态间的转移方程定义状态的初始化返回结果 状态定义的要求：定义的状态一定要形成递推关系。
一句话概括：三特点四要素两本质
适用场景：最大值/最小值, 可不可行, 是不是，方案个数；
一、字符串分割 牛客链接
状态：
子状态：前1，2，3，…,n个字符能否根据词典中的词被成功分词
F(i): 前i个字符能否根据词典中的词被成功分词
状态递推：
F(i): true{j &lt; i &amp;&amp; F(j) &amp;&amp; substr[j+1,i]能在词典中找到} OR false
在j小于i中，只要能找到一个F(j)为true，并且从j+1到i之间的字符能在词典中找到，则F(i)为true。
初始值：
对于初始值无法确定的，可以引入一个不代表实际意义的空状态，作为状态的起始；
空状态的值需要保证状态递推可以正确且顺利的进行，到底取什么值可以通过简单的例子进行验证，这里取F(0) = true；
返回结果：F(n)；
import java.util.*; public class Solution { public boolean wordBreak(String s, Set&lt;String&gt; dict) { boolean[] canBreak = new boolean[s.length() + 1]; canBreak[0] = true; for(int i = 1;i &lt;= s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a37f41c42f2bc18fe4686203353a08b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/292baca8fc1f15dac56b348af3cac867/" rel="bookmark">
			Go语言操作MySQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL是业界常用的关系型数据库，本文介绍了Go语言如何操作MySQL数据库。
Go操作MySQL 连接 Go语言中的database/sql包提供了保证SQL或类SQL数据库的泛用接口，并不提供具体的数据库驱动。使用database/sql包时必须注入（至少）一个数据库驱动。
我们常用的数据库基本上都有完整的第三方实现。例如：MySQL驱动
下载依赖 go get -u github.com/go-sql-driver/mysql 使用MySQL驱动 func Open(driverName, dataSourceName string) (*DB, error) Open打开一个dirverName指定的数据库，dataSourceName指定数据源，一般至少包括数据库文件名和其它连接必要的信息。
import ( "database/sql" _ "github.com/go-sql-driver/mysql" ) func main() { // DSN:Data Source Name dsn := "user:password@tcp(127.0.0.1:3306)/dbname" db, err := sql.Open("mysql", dsn) if err != nil { panic(err) } defer db.Close() // 注意这行代码要写在上面err判断的下面 } 思考题： 为什么上面代码中的defer db.Close()语句不应该写在if err != nil的前面呢？
初始化连接 Open函数可能只是验证其参数格式是否正确，实际上并不创建与数据库的连接。如果要检查数据源的名称是否真实有效，应该调用Ping方法。
返回的DB对象可以安全地被多个goroutine并发使用，并且维护其自己的空闲连接池。因此，Open函数应该仅被调用一次，很少需要关闭这个DB对象。
接下来，我们定义一个全局变量db，用来保存数据库连接对象。将上面的示例代码拆分出一个独立的initDB函数，只需要在程序启动时调用一次该函数完成全局变量db的初始化，其他函数中就可以直接使用全局变量db了。（注意下方的注意）
// 定义一个全局对象db var db *sql.DB // 定义一个初始化数据库的函数 func initDB() (err error) { // DSN:Data Source Name dsn := "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/292baca8fc1f15dac56b348af3cac867/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2dd53849c3e3dafde6132e258bd60d2/" rel="bookmark">
			anaconda配置h5py===2.10.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一般在anaconda下直接在prompt窗口输入下面中一个就行
conda install h5py pip install h5py 但是，如果想配置 h5py==2.10.0，可以直接输入rcd
conda install h5py==2.10.0 #或者 pip install h5py==2.10.0 如果直接在存在h5py的情况下配置h5py==2.10.0一般会报错，输入下面代码可解决
conda uninstall h5py conda install h5py==2.10.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c92c51c1fc2aa5d029fc7e79e733b767/" rel="bookmark">
			vs2019修改代码时覆盖和插入设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、解决1.最开始打开【VS】就可以单击菜单栏【GIT】下的【设置】2.然后就可以看到【文本编辑器】单击按下3.右边看到插入和覆盖，勾选上 方法2：总结快捷键介绍 前言 Microsoft Visual Studio（简称VS）是美国微软公司的开发工具包系列产品。VS是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等等。所写的目标代码适用于微软支持的所有平台，包括[Microsoft Windows](https://baike.baidu.com/item/Microsoft Windows)、Windows Mobile、[Windows CE](https://baike.baidu.com/item/Windows CE)、[.NET Framework](https://baike.baidu.com/item/.NET Framework)、.NET Compact Framework和Microsoft Silverlight 及Windows Phone。Visual Studio是最流行的Windows平台应用程序的集成开发环境，目前最新版本为 Visual Studio 2019 版本，这里以Visual Studio 2019为例。
2018年6月，微软宣布开发新一代集成开发环境（integrated development environment，IDE）Visual Studio 2019，至今Visual Studio 2019已经发布了四个公开预览版，分别是2018年12月的Preview 1、2019年1月的Preview 2、2019年2月13日推出的Preview 3 和2019年3月1日推出的Preview 4。
Visual studio 2019具有良好的性能和更快运行速度和简洁的启动窗口
vs2019修改代码时覆盖和插入设置
右下角红色方框内没有覆盖和插入的提示
一、解决 1.最开始打开【VS】就可以单击菜单栏【GIT】下的【设置】 2.然后就可以看到【文本编辑器】单击按下 3.右边看到插入和覆盖，勾选上 如果取消勾选插入和覆盖
方法2： 键盘上设置shift+insert
vs修改代码时候覆盖之后代码是因为默认使用ovr模式覆盖书写，可以直接按键盘上的Ins键切换为插入模式即可。
总结 设置过程很简单
快捷键介绍 注释1：双斜线//注释：Ctrl+K，C，取消注释： Ctrl+K，U；
注释2：双斜线//注释：Ctrl+K，/，取消注释： Ctrl+K，/；
注释3：双斜线//或其他：Alt+左键向下（上）拖动鼠标画线“|”，然后输入//，当然也可以批量输入其他字符
注释4：/* */：Shift+Ctrl+/，取消注释： Shift+Ctrl+/；
将一行的代码大写转小写：Ctrl+K，U+U；
代码对齐：Ctrl+k+d（代码对齐的前提必须没有语法错误）
撤销（返回上一步操作）：Ctrl+z
快速保存：Ctrl+s
调转代码段头/尾：Shift+HOME / Shift+END
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c92c51c1fc2aa5d029fc7e79e733b767/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d9db1e0374561d9ae3495b7b0e252d/" rel="bookmark">
			前端常见的安全问题及防范措施
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python微信订餐小程序课程视频 https://edu.csdn.net/course/detail/36074
Python实战量化交易理财系统 https://edu.csdn.net/course/detail/35475
前言 随着互联网的高速发展，信息安全问题已经成为行业最为关注的焦点之一。总的来说安全是很复杂的一个领域，在移动互联网时代，前端人员除了传统的 XSS、CSRF 等安全问题之外，还时常遭遇网络劫持、非法调用 Hybrid API 等新型安全问题。这篇文章会介绍一些常见的安全问题及如何防范的内容，在当下其实安全问题越来越重要，已经逐渐成为前端开发必备的技能了。
如果这篇文章有帮助到你，❤️关注+点赞❤️鼓励一下作者，文章公众号首发，关注 前端南玖 第一时间获取最新的文章～
前端安全问题 跨站脚本攻击（XSS） Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。
为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。
一般可以通过三种方式来注入恶意脚本：
反射型XSS攻击 顾名思义，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又将这部分返回给用户，恶意脚本在页面中被执行。一般发生在前后端一体的应用中，服务端逻辑会改变最终的网页代码。
反射型 XSS 的攻击步骤：
攻击者构造出特殊的 URL，其中包含恶意代码。用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 基于DOM的XSS攻击 目前更流行前后端分离的项目，反射型 XSS 无用武之地。 但这种攻击不需要经过服务器，我们知道，网页本身的 JavaScript 也是可以改变 HTML 的，黑客正是利用这一点来实现插入恶意脚本。
基于DOM 的 XSS 攻击步骤：
攻击者构造出特殊的 URL，其中包含恶意代码。用户打开带有恶意代码的 URL。用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 存储型XSS攻击 又叫持久型 XSS，顾名思义，黑客将恶意 JavaScript 脚本长期保存在服务端数据库中，用户一旦访问相关页面数据，恶意脚本就会被执行。常见于搜索、微博、社区贴吧评论等。
存储型 XSS 的攻击步骤：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d9db1e0374561d9ae3495b7b0e252d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fb208033203889c2ec3755b3b28f1b/" rel="bookmark">
			IDEA java出现无效的源发行版14解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是jdk部分出现问题 打开project structure修改project，将jdk改为当前电脑装的jdk版本，下面的语言也改为jdk对应的版本。例：jdk版本为1.8，就将语言改为8修改modules，将SDK改为同样版本的jdk点击下方的apply，再点击ok
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f0f8aba6edbbe2e03090ff649077ca7/" rel="bookmark">
			Flutter中的点击事件和回调
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不同于Android中所有的View可以通过设置点击setOnClickListener { }方法，在Flutter有些widget是不支持直接添加onPress事件的，用法和原生区别很大，列举了常用两种方式。
一、InkWell InkWell中点击事件分为来管理点击回调和水波动画。
onTap: () // 单击
onDoubleTap: () // 双击
onLongPress: ()// 长按
InkWell( onTap: (){}, child: Container() ) 二、GestureDetector onTap: () // 单击
onDoubleTap: () // 双击
onLongPress: () // 长按
onTapCancel:() //取消
onTapUp:(e) //松开
onTapDown:(e) //按下
拖动手势主要由
onPanDown //手指按下
onPanUpdate //手指滑动
onPanEnd //滑动结束
onScaleUpdate:(ScaleUpdateDetails e) //缩放
GestureDetector( child: Text("点击"), onTap: () {} ) 如果没有特殊要求，只相应onTap的话，尽可能用InkWell,，开发中InkWell,反应比较灵敏一点弹出的软键盘无法关闭，尽可能使用GestureDetector。
三、点击事件的回调 在Android中经常定义接口，使用接口回调的方式，在Flutter中也有类似的实现。
1、定义接口
abstract class OnDialogClickListener { void onConfirm(); void onCancel(); } 2、初始化接口数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f0f8aba6edbbe2e03090ff649077ca7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/262/">«</a>
	<span class="pagination__item pagination__item--current">263/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/264/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>