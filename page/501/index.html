<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd4769615fddc54d17ad00a8700a1006/" rel="bookmark">
			hive：MoveTask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运行SQL时出了个错：
SQL： INSERT OVERWRITE DIRECTORY 'result/testConsole' select count(1) from nutable; 错误信息：
Failed with exception Unable to rename: hdfs://indigo:8020/tmp/hive-root/hive_2013-08-22_17-35-05_006_3570546713731431770/-ext-10000 to: result/testConsole FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.MoveTask 另一个SQL的错误，这是日志中的： 1042 2013-08-22 17:08:54,411 INFO exec.Task (SessionState.java:printInfo(412)) - Moving data to: result/userName831810250/54cbcd2980a64fe78cf54abb3116d2dc from hdfs://indigo:8020/tmp/hive-hive/hive_2013-08-22_17-08-40_062_3976325306495167351/-ext-10000 1043 2013-08-22 17:08:54,414 ERROR exec.Task (SessionState.java:printError(421)) - Failed with exception Unable to rename: hdfs://indigo:8020/tmp/hive-hive/hive_2013-08-22_17-08-40_062_3976325306495167351/-ext-10000 to: result/userName831810250/54cbcd2980a64fe78cf54abb3116d2dc 下面看看出现异常的地方。
执行SQL时，最后一个任务是MoveTask,它的作用是将运行SQL生成的Mapeduce任务结果文件放到SQL中指定的存储查询结果的路径中，具体方法就是重命名
下面是 org.apache.hadoop.hive.ql.exec.MoveTask 中对结果文件重命名的一段代码：
[java] view plain copy print ? //这个sourcePath参数就是存放Mapeduce结果文件的目录，所以它的值可能是 //hdfs://indigo:8020/tmp/hive-root/hive_2013-08-22_18-42-03_218_2856924886757165243/-ext-10000 if (fs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd4769615fddc54d17ad00a8700a1006/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/914e6c4d78d29efcbeb8aa5973c2723f/" rel="bookmark">
			Python在函数中使用全局变量的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本博客已迁往http://coredumper.cn 在函数中定义的局部变量如果和全局变量同名，则它会隐藏该全局变量。如果想在函数中使用全局变量，则需要使用global进行声明。举例说明如下：
x = 1 def func(): x = 2 print x print x func() print x 执行结果为：
1 2 1 x = 1 def func(): global x print x x = 2 print x print x func() print x执行结果为： 1 1 2 2 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/559c2492373c5dfc66fa85b875e5ac72/" rel="bookmark">
			lexical or preprocessor issue file not found in Xcode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The very last suggestion is all I needed to fix this issue. Close &amp; re-open Xcode.
转载于:https://www.cnblogs.com/yinghuochong/p/3530634.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8c7d74942e8727aaa335acb215f2807/" rel="bookmark">
			why use assertions in code
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		why?
they make debugging easier.
The time consuming part of debugging is tracing a problem from the symptom you first notice back to the error in the code. Well written assertions will make the symptom you notice much closer to the actual code problem.
A very simple example would be a bug where you index past the end of an array and cause memory corruption which eventually causes a crash.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8c7d74942e8727aaa335acb215f2807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8593684718e9da57dd167f0f5abdde7d/" rel="bookmark">
			CISCO 1841 升级ios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天一台1841在配置VPN时输入 crypto isakmp policy 2时老是提示 Invalid input detected at '^' marker .最后通过show version 查看ios版本时才发现IOS跟其它正常配置的IOS不一样，原IOS不支持该命令导致的，最后决定通过tftp升级IOS
准备工具：
1、IOS文件
2、tftpd32.exe
首先将IOS文件复制到tftpd32.exe目录下
启动tftpd
登陆路由器后：
config t
copy tftp flash
Address or name of remote host []? #此处输入tftp服务器ip地址
Source filename[] #输入ios完整文件名
Do you want to over write? [confirm] #回车确认等待升级完成
注意：根据网上其它网站的教程， 一般都会有Do you want to over write? [confirm] 如果出现的话直接回车等待升级完成即可，但本人在升级1841时并没有提示，文件复制完成后用show flash 可以看到有两个ios文件，reload后路由器后依然从旧的ios启动，要确定路由器从新复制的IOS启动，需进行以下操作(假设新ios文件名为c1841-new.bin,旧ios文件名为c1841-old.bin)：
Router# config t
Router(config)#boot system flash:c1841-new.bin #首先设置系统从新的IOS启动
Router(config)#end
Router#delete flash #再删除旧IOS，经确认如果不删除旧IOS的话，reload后路由器依旧从原IOS启动
Delete filename [flash]? c1841-old.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8593684718e9da57dd167f0f5abdde7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12fe6fffabf44b62b9cb41f988a8f93c/" rel="bookmark">
			输入包括两行，第一行是一个正整数N（N&lt;=1000000），表示理工大共N个美女。第二行有N个正整数分别表示N位美女的身高，每个正整数的值不会超过10^9。 （输入数据之间会用空格隔开）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;stdio.h&gt;int a[1100001];int pp(int low,int h){int key=a[low];while(low &lt; h){while(key &lt;= a[h] &amp;&amp; low &lt; h) h--;a[low]=a[h];while(key &gt;= a[low] &amp;&amp; low &lt; h) low++;a[h]=a[low];}a[low]=key;return low;}void paixu(int low, int h){if(low&gt;=h)return ;int mid=pp(low,h);paixu(low,mid-1);paixu(mid+1,h);}int main(){int i;int n;scanf("%d",&amp;n);for(i=0;i&lt;n;i++){scanf("%d",&amp;a[i]);}paixu(0,n-1);for(i=n-1; i&gt;=0; i--){printf("%d", a[i]);if(i&gt;0)printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12fe6fffabf44b62b9cb41f988a8f93c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f15d06bd616acefd6782796524337f/" rel="bookmark">
			eclipse界面语言切换的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ICode联盟
1、利用快捷方式启动，在快捷方式的属性中的目标后面加上“-nl en_US”。
2、在eclipse.ini文件中的-product后加入如下内容（注意要换行）如：
-product org.eclipse.epp.package.jee.product -nl en_US --launcher.defaultAction 3、configuration\config.ini文件添加：osgi.nl=en_US。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b511b21fa218b8d36ffc4b83350a3d06/" rel="bookmark">
			onvif 客户端发现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、解压：unzip -X gsoap_2.8.10.zip 编译
2、下载：
wget http://www.onvif.org/onvif/ver10/network/wsdl/remotediscovery.wsdl
3、复制：
cp gsoap-2.8/gsoap/typemap.dat .
4、在typemap.dat 中添加：
[cpp] view plain copy print ? #Use gSOAP 2.8.10 and up. In the typemap.dat file used by wsdl2h, add: # ONVIF recommended prefixes tds = "http://www.onvif.org/ver10/device/wsdl" tev = "http://www.onvif.org/ver10/events/wsdl" tls = "http://www.onvif.org/ver10/display/wsdl" tmd = "http://www.onvif.org/ver10/deviceIO/wsdl" timg = "http://www.onvif.org/ver20/imaging/wsdl" trt = "http://www.onvif.org/ver10/media/wsdl" tptz = "http://www.onvif.org/ver20/ptz/wsdl" trv = "http://www.onvif.org/ver10/receiver/wsdl" trc = "http://www.onvif.org/ver10/recording/wsdl" tse = "http://www.onvif.org/ver10/search/wsdl" trp = "http://www.onvif.org/ver10/replay/wsdl" tan = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b511b21fa218b8d36ffc4b83350a3d06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/523b0968c3f9a26a8ccbdf8fcab73519/" rel="bookmark">
			Onvif开发之Linux下gsoap的使用及移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一直以来都是在CSDN上面学习别人的东西，很多次想写点什么但是又无从写起。由于公司项目需要，最近一段时间在研究onvif，在网上找了很多资料，发现资料是非常多，但是很少有比较全的资料，或者资料太多无从下手。我打算从做项目开始，用CSDN博客记录我的项目笔记，同时希望能帮助到需要帮助的人，以感谢这么多年来CSDN上各位高手对我的帮助。onvif的开发从gsoap的移植开始！今天完成了gsoap的移植，生成了代码。
一、 开发环境
本人开发环境为：
1. 电脑主频2.6G，内存4G；
2. 虚拟机：Product: VMware® Workstation; Version: 7.1.3 build-324285
3. linux操作系统版本：
[root@localhost ~]# cat /proc/version
Linux version 2.6.25-14.fc9.i686 (mockbuild@) (gcc version 4.3.0 20080428 (Red Hat 4.3.0-8) (GCC) ) #1 SMP Thu May 1 06:28:41 EDT 2008
[root@localhost ~]#
4. linux编译环境：海思交叉编译器arm-hisiv100nptl-linux-g++
二、必备网址
1. Onvif官网：http://www.onvif.org/
2. gsoap官网：http://www.cs.fsu.edu/~engelen/soap.html
三、操作步骤详解
1. 下载gsoap
根据以上提供的地址，登陆gsoap官网下载最新的安装包和相关文档；截止今天(2013年8月5日)，官网发布的最新版本的gsoap工具为2.8.15版本；最新版本的使用，可以参考文档：《gSOAP 2.8.15 User Guide .pdf》，该文档有非常详细的说明，现在网络上的大部分的demo都是copy这里的；该文档值得研究；该文档在其官网上可以下载，下载地址为：http://www.cs.fsu.edu/~engelen/soap.html；也可以在官网在线查看；或者，可以在gsoap安装包里面找到该文档，路径为：gsoap_2.8.15/gsoap-2.8/gsoap/doc, 名字为soapdoc2.pdf的文件。
2. 安装
将下载的安装包解压，并拷贝到linux的操作目录，本人操作目录为： $: /home/samba/onvif-2013.08.05/ 以上面的目录为例：（注意以下操作均在root用户权限下进行）
首先进入目录cd /home/samba/onvif-2013.08.05/ gsoap_2.8.15/gsoap-2.8/
然后，配置编译环境:
命令：$:./configure
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/523b0968c3f9a26a8ccbdf8fcab73519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2003143bf4a95f9a191b0fea000d0567/" rel="bookmark">
			onvif开发之设备发现功能的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		忙了一个多月，onvif总算告一段落了。这几个星期忙着其他的项目，也没有好好整理一下onvif的东西。接下来得好好整理一下自己的项目思路和项目经验，同时将自己的一些心得写出来，希望对人有所帮助。
相信大多数兄弟和我一样，onvif开发，最开始做的就是发现功能。这两天登录onvif的官网看才发现，onvif版本在八月份有更新，已经更新到V2.4了，于是下载最新的版本来进行。代码的生成可以详见我的前一篇文章。V2.4版本新增了一个wsdl文件，现在用于生成源码的文件一共有18个。为了保证全功能，最好一次性生成包含所有功能的源码。然后根据最新生成的源码来实现onvif客户端和服务端的发现功能。
1. 创建onvif_test目录。以下这些源码由最新的gsoap（2.8.16）和最新的onvif的wsdl文件（2.4）生成。（截止2013.09.16）
onvif.h
soapClientLib.c
soapServerLib.c
soapC.c
soapClient.c
soapH.h
soapServer.c
soapStub.h
2.以下文件来自gsoap_2.8.16\gsoap-2.8\gsoap
stdsoap2.c
stdsoap2.h
3.以下文件来自gsoap_2.8.16\gsoap-2.8\gsoap\custom
duration.c
4.生成的soapClientLib.c和soapServerLib.c无实际作用，可直接删除。
5.增加自定义文件：
onvif_server.c onvif服务端实现代码
onvif_client.c onvif客户端实现代码
onvif_server_interface.c onvif服务端接口实现
onvif_function.c onvif实现函数，公用
onvif_function.h onvif实现函数，公用
onvif_server.c为服务端的实现代码，主要是定义main函数，服务端主要是监听，并处理和应答消息。
Main函数定义如下：
[cpp] view plain copy print ? int main(int argc,char ** argv) { printf("[%s][%d][%s][%s] start \n", __FILE__, __LINE__, __TIME__, __func__); int count = 0; struct soap ServerSoap; struct ip_mreq mcast; soap_init1(&amp;ServerSoap, SOAP_IO_UDP | SOAP_XML_IGNORENS); soap_set_namespaces(&amp;ServerSoap, namespaces); printf("[%s][%d][%s][%s] ServerSoap.version = %d \n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2003143bf4a95f9a191b0fea000d0567/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2f02d5aa7a4fcf01c3a83f364982a2c/" rel="bookmark">
			Perl的缘起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Perl was originally developed by Larry Wall in 1987 as a general-purpose Unix scripting language to make report processing easier.[7]
According to Wall, Perl has two slogans. The first is "There's more than one way to do it", commonly known as TMTOWTDI. The second slogan is "Easy things should be easy and hard things should be possible".[9]
The design of Perl can be understood as a response to three broad trends in the computer industry: falling hardware costs, rising labor costs, and improvements in compiler technology.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2f02d5aa7a4fcf01c3a83f364982a2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d5436c950845a67145c1506adb97f83/" rel="bookmark">
			TFTP和FTP的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：xchuaii
原作网址：http://blog.163.com/xchuaii@126/blog/static/133060217201256115524125/
TFTP：Trivial File Transfer Protocol,简单文件传输协议，它基于UDP协议而实现，但是我们也不能确定有些TFTP协议是基于其它传输协议完成的。
FTP：File Transfer Protocol,文件传输协议，FTP 使用TCP 生成一个虚拟连接用于控制信息，然后再生成一个单独的 TCP 连接用于数据传输。
FTP通信过程
服务器首先运行一个本地主服务进程，当客户端用户输入open和ftp命令后，客户指定一个远程计算机，建立一个客户控制进程，本地应用成为一个FTP客户，建立了自己的半相关。
然后，客户用TCP建立与指定FTP服务器之间的控制连接。客户与服务器在控制连接进行通信时使用FTP协议。
服务器接收到客户连接请求后，开启一个服务器控制进程，该进程与客户控制进程建立起控制连接，即相关，双方进入会话状态。
通过控制连接，客户控制进程向服务器发出客户数据传输请求，服务器控制进程接收到后，开启一个服务器数据传输进程，该进程建立一个自己的半相关，并向客户控制进程发出连接请求。
客户控制进程接收到请求后，开启一个客户数据传输进程，并与服务器数据传输进程建立相关，双方建立数据传输。
数据传输结束后，关闭数据连接，双方的数据传输进程生命结束，但控制进程仍然存在，以后可以再重新发起新的数据传输服务。
TFTP用于从服务器请求文件然后传输文件。使用TFTP与使用电子邮件非常相似：首先由客户发出一个请求文件的消息，然后服务器把文件返回到本地客户系统上。
1、TFTP协议的优势
尽管与FTP相比TFTP的功能要弱得多，但是TFTP具有两个优点：
1)TFTP能够用于那些有UDP而无TCP的环境；
2)TFTP代码所占的内在要比FTP小。
尽管这两个优点对于普通计算机来说并不重要，但是对于那些不具备磁盘来存储系统软件的自举硬件设备来说TFTP特别有用。
2、TFTP协议与FTP协议的相同点
TFTP协议的作用和我们经常使用的FTP大致相同，都是用于文件传输，可以实现网络中两台计算机之间的文件上传与下载。可以将TFTP协议看作是FTP协议的简化版本。
3、TFTP协议与FTP协议的不同点
1)TFTP协议不需要验证客户端的权限，FTP需要进行客户端验证；
2)TFTP协议一般多用于局域网以及远程UNIX计算机中，而常见的FTP协议则多用于互联网中；
3)FTP客户与服务器间的通信使用TCP，而TFTP客户与服务器间的通信使用的是UDP；
4)TFTP只支持文件传输。也就是说，TFTP不支持交互，而且没有一个庞大的命令集。最为重要的是，TFTP不允许用户列出目录内容或者与服务器协商来决定哪些是可得到的文件。
FTP 是完整、面向会话、常规用途文件传输协议。而 TFTP 用作 bones bare - 特殊目的文件传输协议。
交互使用 FTP。 TFTP 允许仅单向传输的文件。
FTP 提供身份验证。而TFTP 不。
FTP 使用已知 TCP 端口号： 20 的数据和 21 用于连接对话框。 TFTP 用于 UDP 端口号 69 其文件传输活动。
因为 TFTP 不支持验证 WindowsNT ，所以FTP 服务器服务不支持 TFTP。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d5436c950845a67145c1506adb97f83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f4ccd134e77066bfc07fde8bff51ff1/" rel="bookmark">
			利用HandVu进行手部动作识别分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者：gnuhpc 出处：http://www.cnblogs.com/gnuhpc/
程序的流程是： 1）先进行配置文件的读取和配置参数的载入 2）初始化摄像头或者指定的视频文件 3）显示屏显提示 4）设定采集图像大小 5）获取一帧 6）初始化要分析的图像大小 7）装载参数 8）开始识别 9）设置识别的覆盖区级别 10）设置同步／异步识别 11）设置鼠标事件的回调参数，若有鼠标事件确定区域大小 12）打开相关窗口，进入主处理循环，显示处理过的帧，并且时刻准备相应键盘事件。
/** * HandVu - a library for computer vision-based hand gesture * recognition. * Copyright (C) 2004 Mathias Kolsch, matz@cs.ucsb.edu * * This program is free software; you can redistribute it and/or * modify it under the terms of the GNU General Public License * as published by the Free Software Foundation; either version 2 * of the License, or (at your option) any later version.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f4ccd134e77066bfc07fde8bff51ff1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbbfed2107cc7805182c0efc1d889ff/" rel="bookmark">
			C#中的委托与事件（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道，C#中有“接口”这个概念，所谓的“接口”就是定义一套标准，然后由实现类来具体实现其中的方法，所以说“接口，是一组类的抽象”。同样道理，我们可以将“委托”理解为“方法的抽象”，也就是说定义一个方法的模板，至于这个方法具体是怎么样的，就由方法自己去实现。 我们知道接口的最大好处就是可以实现多态，同理，“委托”是可以实现方法的多态，当我们想调用某个具体方法的时候，我们不直接调用这个方法，而是去调用这个委托。当然，我们必须在具体方法和委托之间建立某种关联。 定义和使用委托分三个步骤： 1、委托声明。2、委托实例化。3、委托调用。 一、定义委托 定义委托的语法如下： &lt;访问修饰符&gt; delegate 返回类型 委托名(); 定义委托和定义方法很相似，委托没有具体的实现体，由关键字delegate声明，直接以分号结束。委托能够代表什么样的方法，由它的返回值类型和参数列表决定。如下定义如下委托： public delegate void MyDelegate(string name); 那么使用MyDelegate委托代表的只可以是没有返回值，参数为一个字符串的方法。 二、实例化委托 定义了委托之后，如何使用委托代表方法执行呢？首先要实例化委托。实例化委托就是将其指向某个方法，即调用委托的构造函数，并将相关联的方法作为参数传递。 如：如一个方法 private int Add(int num1,int num2) { return(num1+num2); } 委托声明了以后，就可以象类一样进行实例化，实例化时把要引用的方法（如：Add）做为参数，这样委托和方法就关联了起来，就可以用委托来引用方法了。 委托和所引用的方法必须保持一致： 1、参数个数、类型、顺序必须完全一致。 2、返回值必须一致。 3、传入的方法中不能带参数，只写方法名。 三、调用委托 要调用委托的方法用委托的对象加参数，如果参数为空，也要加小括号。 为方法创建一个委托，然后立即通过这个委托调用该方法并没有太大意义，因为直接调用方法更简单。动态调用方法时，委托才真正显示出它的效用。 using System; delegate int Operand(int a, int b); //第一步:委托声明 class Class1 { static void Main(string[]args) { Class1 c1 = new Class1(); Operand ope = new Operand(c1.Add); //委托实例化,注意参数是要使用的参数名,且不带括号 Console.WriteLine(ope(10, 20)); //委托调用,调用委托的方法用 委托的对象加参数 Console.ReadLine(); } //定义一个方法，求两个加数的和 private int Add(int num1, int num2) { return (num1 + num2); } }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbbbfed2107cc7805182c0efc1d889ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6f4c4cdaef4d7040d993c4fcb3a702d/" rel="bookmark">
			.net - dispatcher vs thread
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dispatcher
Multiple tasks inone thread.
you can't update any UI controls from a thread that doesn'town the control. very Visual (Button, Textbox, Combobox, etc.) inherits from DispacterObject. Thisobject is what allows you to get a hold of the UI thread's Dispatcher.
the Dispatcher gives us the ability to Invoke onto itsthread.
http://www.switchonthecode.com/tutorials/working-with-the-wpf-dispatcher
SynchronizationContext
To find a UI thread
SynchronizationContext. MSDN says:
“Provides the basicfunctionality for propagating a synchronization context in varioussynchronization models.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6f4c4cdaef4d7040d993c4fcb3a702d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8bea9a6fec4bd94f9aa554398229fe6/" rel="bookmark">
			2013，我的大学。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用坚持去证明自己的价值------------题记
不知道什么时候开始喜欢仰望星空，大概生活的累了， 偶尔望望星空让自己内心得到片刻的安宁，不知道什么时候上了大学开始变得感性，不知道该说感性还是说自己心理承受能力变弱了，偶尔休闲的时候看看温情一点的电影，自己眼泪会不自觉的就流了下来，有人说仰望星空30度，是我想念她的角度，是为了不让我的眼泪掉下来。可是我的那个她呢？大学三年是跟计算机一起度过的，每天不是跟代码打交道，就是跟游戏谈心，每天晚上活动就开始了，白天就是睡觉的时间，渐渐的三年过去了，我失去了自我，我迷失了，就像走在满是大雾的森林，没有指路灯，没有人帮我，我只能自己靠自己，但是这三年我自己也在浪费着自己的青春，刚进大学给自己定了无数个目标，想要去实现，想要去超越，如今感叹自己的现在，高中那三年的所有努力，就像泡沫一样破碎了，没有留下一点痕迹，挥一挥衣袖，没有带走一片云彩。
现在已渐进大四，毕业论文要开始了，找工作开始了，投简历开始了，想想自己在大学做的，感叹后悔悔恨没有一点作用，我唯一能做的就是抓住现在，不再浪费。不再回忆过去，不再活在过去，慢慢的我开始喜欢仰望着星空，寂寞的时候望望星空，因为星空下，是寂静的，没有社会的冷漠，没有冷言嘲讽，在这里我还能够找到一点自己存在的价值，累的时候望望星空，因为星空下没有喧嚣，迷茫的时候望望星空，在这里我能够找到答案。我相信自己能够用坚持告诉自己我的梦想还在，我的抱负还有希望，也许自己在最后一年的时光的坚持，能够带来转机，是的我坚信着
感谢爸爸妈妈，能够生我出来，我这里向你们道歉，我挥霍了你们对我的信任，浪费了你们对我的期望，我现在不在是任性的孩子了，我不想多说些什么，至少此时此刻我会用坚持来证明一切，不过结局怎么样，我一定不会让自己后悔。希望爸爸妈妈能够身体健康，永远长命百岁。
希望有一天我能够带着笑脸回首寒暄。
-----------------后悔的骚年
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5740c3a3733cc135fefdcdbcc06e9436/" rel="bookmark">
			Cadence 信号完整性（一）-- 仿真步骤4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出自《基于Cadence的信号完整性仿真步骤.pdf》
SI Audit 功能允许确认一个特殊的网络或一群网络是否能够被提取来分析。
（1）单击“SI Audit”，弹出“Net Audit”窗口，如图2-18 所示：
图 2-18 Net Audit 对话框
（2）在“Net filter”栏中输入要“A15”→按下“Tab”（如图2-19 所示）→单击“Audit selected net”，弹出“SigNoise Setup Report”窗口，如图2-20 所示：
图 2-19 Net Audit 对话框
图 2-20 SigNoise Setup Report 窗口
这个报告显示了选择的网络的名称等信息。分配缓冲模型列表报告哪一个I0 模型已经分配给驱动端和接收端。元件列表报告与这个网络有关的元件的CLASS 属性和分配给每个元件的信号模型的名称。注意：在报告中有个错误信息，即U45 的G15 管脚没有缓冲模型。在提取拓扑结构时，会有提示信息出现。 2.8 完成参数设置 在“Database Setup Advisor-SI Audit”窗口中单击“Finish”， 完成设置。然后在PCB SI 610 中选择“File”→“Save”，保存所做的设置。 3.进行信号完整性仿真（反射）
3.1 开始仿真
在PCB SI 610 中选择“Analyze”→“SI/EMI Sim”→“Probe”或直接单击快捷键（如图3-1 所示）出现”Signal Analysis”窗口，如图3-2 所示：
图 3-1 Signal Analysis 快捷键
图 3-2 Signal Analysis 窗口
3.2 选择所要仿真的网络
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5740c3a3733cc135fefdcdbcc06e9436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f0f9f00d954e17e149a0f98bda5f25/" rel="bookmark">
			Cadence 信号完整性（一）-- 仿真步骤1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出自《基于Cadence的信号完整性仿真步骤.pdf》
目录
1.仿真前的准备工作 1.1 找到需要仿真的芯片的IBIS 模型 1.2 模型转换（IBIS→DML） 1.3 添加模型到Cadence 的模型库中 2.对电路板进行设置（Setup Advisor） 2.1 准备好要仿真的电路板 2.2 调用参数设置向导 2.3 叠层设置 2.4 设置DC 电压值 2.5 器件设置（Device Setup） 2.6 SI 模型分配 2.7 SI 检查（SI Audit） 2.8 完成参数设置 3.进行信号完整性仿真（反射） 3.1 开始仿真 3.2 选择所要仿真的网络 3.3 提取网络的拓扑结构 3.4 给驱动端U8 添加激励信号 3.5 设置激励信号的参数 3.6 执行反射仿真 3.7 仿真结果 1.仿真前的准备工作
1.1 找到需要仿真的芯片的IBIS 模型
一般可以从芯片制造商网站上找到，如果没有，可能要通过其它途径获得如从SPICE 模型中提取。
1.2 模型转换 （IBIS→DML）
将IBIS 模型转换为DML 模型，运用Cadence 的Model Integrity 工具将IBIS 模型转化为Cadence 能识别的DML 模型，并验证仿真模型。
（1）单击“开始”按钮→“所有程序”→“Allegro SPB 15.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f0f9f00d954e17e149a0f98bda5f25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/582a012c49f0be3484d41cc4805ebd79/" rel="bookmark">
			1218养兔子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 一对成熟的兔子每天能且只能产下一对小兔子，每次都生一公一母，每只小兔子的成熟期是一天。某人领养了一对小兔子，一公一母，请问第N天以后，他将会得到多少对兔子。 输入 测试数据包括多组，每组一行，为整数n(1≤n≤90)。 输入以0结束。 输出 对应输出第n天有几对兔子(假设没有兔子死亡现象，而且是一夫一妻制)。 示例输入 1 2 0 示例输出 1 2 提示 #include&lt;stdio.h&gt; int main() { long int f1,f2,f3; int n,i; while(scanf("%d",&amp;n)&amp;&amp;(n&gt;=1)&amp;&amp;(n&lt;=90)) { f1=1;f2=2; if(n==1) printf("1\n"); else if(n==2) printf("2\n"); else { for(i=3;i&lt;=n;i++) { f3=f1+f2; f1=f2; f2=f3; } printf("%ld\n",f3); } } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8f2c53036fbd5248e656f3058aafad/" rel="bookmark">
			http://en.wikipedia.org/wiki/List_of_IP_protocol_numbers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://en.wikipedia.org/wiki/List_of_IP_protocol_numbers
Decimal Hex Keyword Protocol References00x00HOPOPTIPv6 Hop-by-Hop OptionRFC 246010x01ICMPInternet Control Message ProtocolRFC 79220x02IGMPInternet Group Management ProtocolRFC 111230x03GGPGateway-to-Gateway ProtocolRFC 82340x04IPv4IPv4 (encapsulation)RFC 79150x05STInternet Stream ProtocolRFC 1190, RFC 181960x06TCPTransmission Control ProtocolRFC 79370x07CBTCore-based treesRFC 218980x08EGPExterior Gateway ProtocolRFC 88890x09IGPInterior Gateway Protocol (any private interior gateway (used by Cisco for their IGRP)) 100x0ABBN-RCC-MONBBN RCC Monitoring 110x0BNVP-IINetwork Voice ProtocolRFC 741120x0CPUPXerox PUP 130x0DARGUSARGUS 140x0EEMCONEMCON 150x0FXNETCross Net DebuggerIEN 158160x10CHAOSChaos 170x11UDPUser Datagram ProtocolRFC 768180x12MUXMultiplexingIEN 90190x13DCN-MEASDCN Measurement Subsystems 200x14HMPHost Monitoring ProtocolRFC 869210x15PRMPacket Radio Measurement 220x16XNS-IDPXEROX NS IDP 230x17TRUNK-1Trunk-1 240x18TRUNK-2Trunk-2 250x19LEAF-1Leaf-1 260x1ALEAF-2Leaf-2 270x1BRDPReliable Datagram ProtocolRFC 908280x1CIRTPInternet Reliable Transaction ProtocolRFC 938290x1DISO-TP4ISO Transport Protocol Class 4RFC 905300x1ENETBLTBulk Data Transfer ProtocolRFC 998310x1FMFE-NSPMFE Network Services Protocol 320x20MERIT-INPMERIT Internodal Protocol 330x21DCCPDatagram Congestion Control ProtocolRFC 4340340x223PCThird Party Connect Protocol 350x23IDPRInter-Domain Policy Routing ProtocolRFC 1479360x24XTPXpress Transport Protocol 370x25DDPDatagram Delivery Protocol 380x26IDPR-CMTPIDPR Control Message Transport Protocol 390x27TP++TP++ Transport Protocol 400x28ILIL Transport Protocol 410x29IPv6IPv6 EncapsulationRFC 2473420x2ASDRPSource Demand Routing ProtocolRFC 1940430x2BIPv6-RouteRouting Header for IPv6RFC 2460440x2CIPv6-FragFragment Header for IPv6RFC 2460450x2DIDRPInter-Domain Routing Protocol 460x2ERSVPResource Reservation ProtocolRFC 2205470x2FGREGeneric Routing EncapsulationRFC 2784, RFC 2890480x30MHRPMobile Host Routing Protocol 490x31BNABNA 500x32ESPEncapsulating Security PayloadRFC 4303510x33AHAuthentication HeaderRFC 4302520x34I-NLSPIntegrated Net Layer Security ProtocolTUBA530x35SWIPESwIPeIP with Encryption540x36NARPNBMA Address Resolution ProtocolRFC 1735550x37MOBILEIP Mobility (Min Encap)RFC 2004560x38TLSPTransport Layer Security Protocol (using Kryptonet key management) 570x39SKIPSimple Key-Management for Internet ProtocolRFC 2356580x3AIPv6-ICMPICMP for IPv6RFC 4443, RFC 4884590x3BIPv6-NoNxtNo Next Header for IPv6RFC 2460600x3CIPv6-OptsDestination Options for IPv6RFC 2460610x3D Any host internal protocol 620x3ECFTPCFTP 630x3F Any local network 640x40SAT-EXPAKSATNET and Backroom EXPAK 650x41KRYPTOLANKryptolan 660x42RVDMIT Remote Virtual Disk Protocol 670x43IPPCInternet Pluribus Packet Core 680x44 Any distributed file system 690x45SAT-MONSATNET Monitoring 700x46VISAVISA Protocol 710x47IPCVInternet Packet Core Utility 720x48CPNXComputer Protocol Network Executive 730x49CPHBComputer Protocol Heart Beat 740x4AWSNWang Span Network 750x4BPVPPacket Video Protocol 760x4CBR-SAT-MONBackroom SATNET Monitoring 770x4DSUN-NDSUN ND PROTOCOL-Temporary 780x4EWB-MONWIDEBAND Monitoring 790x4FWB-EXPAKWIDEBAND EXPAK 800x50ISO-IPInternational Organization for Standardization Internet Protocol 810x51VMTPVersatile Message Transaction ProtocolRFC 1045820x52SECURE-VMTPSecure Versatile Message Transaction ProtocolRFC 1045830x53VINESVINES 840x54TTPTTP 840x54IPTMInternet Protocol Traffic Manager 850x55NSFNET-IGPNSFNET-IGP 860x56DGPDissimilar Gateway Protocol 870x57TCFTCF 880x58EIGRPEIGRP 890x59OSPFOpen Shortest Path FirstRFC 1583900x5ASprite-RPCSprite RPC Protocol 910x5BLARPLocus Address Resolution Protocol 920x5CMTPMulticast Transport Protocol 930x5DAX.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c8f2c53036fbd5248e656f3058aafad/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/500/">«</a>
	<span class="pagination__item pagination__item--current">501/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/502/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>