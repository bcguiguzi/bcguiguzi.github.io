<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf8059714d31e1c84e955db6ed4188f/" rel="bookmark">
			最新微信投票平台系统源码 一键创建各种投票活动 盈利模式强大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着社交媒体的普及，微信已经成为人们日常生活中不可或缺的一部分。而微信投票平台源码，作为一种基于微信平台的投票工具，以其简单易用、功能强大的特点，在各种活动和竞赛中被广泛应用。今天给大家分享一款可商用的微信投票平台系统源码，可以一键创建各种投票活动。
一、微信投票平台源码的优势
微信投票平台源码是基于微信平台开发的一种应用，其最大的优势在于利用了微信的社交属性，实现了快速传播和用户参与。通过微信投票平台源码，用户可以轻松创建各种投票活动，如评选、调研、打分等，同时可以方便地分享到微信朋友圈和好友，实现快速传播。此外，微信投票平台源码还具有以下优势：
用户粘性高：微信作为中国最大的社交媒体平台，拥有庞大的用户基数。通过微信投票平台源码创建的投票活动可以方便地分享到微信好友和朋友圈，吸引大量用户参与，提高用户粘性。操作简单：微信投票平台源码具有简单易用的界面和功能，用户无需复杂的设置和操作即可轻松创建和管理投票活动。数据统计和分析功能强大：微信投票平台源码提供了详细的数据统计和分析功能，用户可以通过数据了解投票活动的参与情况、用户行为等信息，为后续活动的策划和执行提供有力支持。 二、一键创建各种投票活动
微信投票平台源码具有强大的功能和易用性，用户可以通过一键式操作轻松创建各种类型的投票活动。以下是春哥团队微信投票平台源码支持的一些常见投票活动：
评选活动：通过微信投票平台源码，用户可以轻松创建各种评选活动，如最美家庭、最佳员工等。用户可以在平台上设置评选规则、奖项和时间等参数，同时可以上传图片、视频等素材以丰富评选内容。调研活动：通过微信投票平台源码，用户可以开展各种调研活动，如市场调查、用户满意度调查等。用户可以在平台上设置调研问题、选项和样本量等参数，同时可以自定义调研主题和问卷样式。打分活动：微信投票平台源码支持各种打分活动，如美食评选、旅游景点评分等。用户可以在平台上设置打分规则、评分标准和评委数量等参数，同时可以设置不同的评分项目和权重。其他活动：除了上述常见的投票活动类型外，微信投票平台源码还支持其他各种类型的投票活动，如知识竞赛、游戏竞技等。用户可以根据实际需求在平台上选择相应的功能模块进行自定义设置。 后台部分截图：
投票系统源码下载地址：春哥技术博客或帮企商城
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a03aaa35f9c32e4210d4d7115b76cc0f/" rel="bookmark">
			微信小程序运行机制分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 setData渲染机制 Native就是微信客户端，逻辑层JsCore（js文件）通过setdata把数据送到渲染层Webview（小程序页面，wxml文件），渲染层接收到数据后就会改变对应的元素值。用户在小程序页面进行操作可以触发event，event传给Native再重新路由到逻辑层JsCore
生命周期 小程序的生命周期：
onLaunch：启动onShow：显示onHide：隐藏 页面生命周期：
页面路由
框架以栈的形式维护了当前的所有页面。 当发生路由切换的时候，页面栈的表现如下：
路由方式页面栈表现初始化新页面入栈打开新页面新页面入栈页面重定向当前页面出栈，新页面入栈页面返回页面不断出栈，直到目标返回页Tab 切换页面全部出栈，只留下新的 Tab 页面重加载页面全部出栈，只留下新的页面 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074187c200a21c402f4babe6106ded2a/" rel="bookmark">
			Anolis8/centos8/龙蜥8 升级glibc 2.30
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： Anolis8/centos8/龙蜥8 系统自带的glibc是2.28版本，已经无法满足项目需要，所以将glibc版本升级到2.30。
编译升级安装 wget https://mirrors.aliyun.com/gnu/glibc/glibc-2.30.tar.gz tar -xvf glibc-2.30.tar.gz #查看glibc需要的gcc,make,python,camke等等库是否满足要求 cat INSTALL |grep -E "later|newer" cd glibc-2.30 mkdir -p build &amp;&amp; cd build ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin --disable-sanity-checks --disable-werror make -j32 make install #最后使用ldd 查看版本 ldd --version 当然也遇到了问题。。。
Q&amp;A 1、configure 阶段报错LD_LIBRARY_PATH
configure: WARNING: *** These auxiliary programs are missing or incompatible versions: makeinfo *** some features or tests will be disabled. *** Check the INSTALL file for required versions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/074187c200a21c402f4babe6106ded2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa9177e6d8adba595deee29e382c180d/" rel="bookmark">
			软件测试之自动化测试框架（超详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是自动化测试框架 在了解什么是自动化测试框架之前，先了解一下什么叫框架？框架是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。 从框架的定义可以了解，框架可以是被重用的基础平台；框架也可以是组织架构类的东西。其实后者更为贴切，因为框和架本来就是组织和归类所用的。所以自动化测试框架的定义为：由一个或多个自动化测试基础模块、自动化测试管理模块、自动化测试统计模块等组成的工具集合。也可以是一种思想和方法的集合。
框架分类：
按框架的定义来分 自动化测试框架可以分为：基础功能测试框架、管理执行框架。按不同的测试类型来分 可以分为：功能自动化测试框架、性能自动化测试框架。按测试阶段来分 可以分为：单元自动化测试框架、接口自动化测试框架、系统自动化测试框架。按组成结构来分 可以分为：单一自动化测试框架、综合自动化测试框架。按部署方式来分 可以分为：单机自动化测试框架、分布式自动化测试框架。 二、自动化测试框架 1、模块化思想
就是将一个测试用例中的几个不同的测试点拆分并且将其单个点的测试步骤进行了封装，形成了一个模块。
例如：一个测试用例要对一个登录程序进行测试，其中包括：用户名输入、密码输入、以及确定登录；那么就可以将用户名输入、密码输入、确定登录、取消登录四个操作分别封装在四个不同的模块中。测试时，只需调用其模块即可。这样的话，当一个模块有变化，你只需单独维护那个模块即可，也可以根据模块的不同组合成不同的测试用例。
2、测试库思想
就是模块化思想的升华，其为应用程序的测试创造了库文件（可以是APIs、DLLs等），这些库文件为一系列函数的集合。其与模块化思想不同的是，其拓展了接口思想，即可以通过接口去传递参数，而不是一个封死的模块，可以说是一个多了一个“门”的交互型模块。
例如：还是以上那个测试用例，只是将用户名输入、密码输入、确定登录、取消登录封装成一个库，这个库含有一个函数Login，这个函数Login接收两个参数“用户名、密码”，对输入不同的用户名和密码可以进行不同的测试用例。
3、数据驱动思想
从数据文件读取输入数据，通过变量的参数化，将测试数据传入测试脚本，不同的数据文件对应不同的测试用例。
关键是其思想能够好的应用到你的框架中。就是变量不变，数据驱动结果，不同的数据导致了不同的结果的产生。而对于数据的导入，可以通过很多方式，例如：EXCLE表、XML（用在WEB中）、数据库（DB）、CSV文件、TXT等都可以。
4、关键字思想
关键字驱动或者一个关键字，对对象的抓取，其测试对象就是一种面向对象的思想，例如：QTP、RFT中，对象可以为一个数据封装为一个关键字（即可以将gui元素封装成了一个个关键字），这样可以对其关键对象进行各种操作了，不同的对象可以驱动不同的测试流向与结果。
关键字驱动测试是数据驱动测试的一种改进类型，它将测试逻辑按照关键字进行分解，形成数据文件，关键字对应封装的业务逻辑。 关键字主要包括：被操作对象（Item）、操作（Operation）和值（value），依据不同对象还有其它对应参数。关键字驱动的主要思想是：脚本与数据分离、界面元素名与测试内部对象名分离、测试描述与具体实现细节分离。可根据界面的变化更新对应的关键字对象，而不用重新录制脚本。
同时，在这我也准备了一份软件测试视频教程（含接口、自动化、性能等），需要的可以直接在下方观看就行，希望对你有所帮助！【公众号：互联网杂货铺】免费领取软件测试资料！
2024年Python自动化测试全套保姆级教程，70个项目实战，3天练完，永久白嫖...
三、自动化框架设计原则 关键字驱动的自动化测试框架是对数据驱动的逻辑扩展，用关键字的形式将测试逻辑封装在数据文件中，测试工具只要能够解释这些关键字即可对其应用自动化，它的核心思想可以概括为三个分离。
界面元素名与测试内部对象名的分离 在被测应用程序和录制生成的测试脚本之间增加一个抽象层，它可以将界面上的所有元素映射成相对应的一个逻辑对象，测试针对这些逻辑对象进行，界面元素的改变只会影响映射表，而不会影响测试。
测试描述与具体实现细节的分离 测试描述只说明软件测试要做什么以及期待什么样的结果，而不管怎样执行测试或怎样证实结果。这样做是因为测试的实现细节通常与特定的平台以及特定的测试执行工具有着密切的联系。这种分离使得测试描述对于应用实现细节是不敏感的，而且有利于测试在工具和平台间的移植。
脚本与数据的分离 最后，可以把测试执行过程中所需的测试数据从脚本中提取出来，在运行时测试脚本再从数据存放处读取预先定制好的数据，这样脚本和数据可以独立维护。
四、Robot Framework+Selenium2框架 Robot Framework 的架构是一个通用的验收测试和验收测试驱动开发的自动化测试框架（ATDD）。它具有易于使用的表格来组织测试过程和测试数据。
Selenium2 是用于测试 Web 应用程序用户界面 (UI) 的常用框架。它是一款用于运行端到端功能测试的工具。拥有简洁的API，WebDriver和WebElement对象，更好的抽象。且支持多中操作系统，多语言，多浏览器。
Robot Framework+Selenium2：基于Selenium2提供的测试库，通过Robot Framework以关键字编写、组织测试用例，执行并收集分析结果，形成一套web应用自动化测试的解决方案（即以关键字驱动的自动化测试框架）。
环境安装
pythonwxpythonRobot FrameworkRIDESelenium2Library （为了python良好的兼容性、以及robot framework扩展库的更好支持，推荐使用ubuntu系统）
使用RIDE编写第一个测试用例
1、新建测试项目、测试套件，并引入所用到的库
2、查询提供的关键字及使用方法
3、根据库提供的关键字编写测试用例
4、测试结果查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1db6f474e5503e84754cd5c62861836/" rel="bookmark">
			DDP分布式训练的官方demo及相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接
''' 1.分布式训练：并行化，跨进程和跨集群的计算 2.torch.distributed.init_process_group() 来初始化进程组,需要指定worker的通信机制, 一般为nccl(NVIDIA推出)，1个进程对应1个gpu. nccl是nvidia的显卡通信方式，用于把模型参数、梯度传递到训练的每个节点上。 3.DDP让进程组的所有worker进行通信 4.torch.utils.data.DataLoader中的batch_size指的是每个进程下的batch_size。也就是说， 总batch_size是这里的batch_size再乘以并行数(world_size)。 ######################################################################### rank是指在整个分布式任务中进程的序号；local_rank是指在一个node上进程的相对序号 nnodes是指物理节点数量 (node:物理节点，可以是一台机器也可以是一个容器，节点内部可以有多个GPU ) node_rank是物理节点的序号 nproc_per_node是指每个物理节点上面进程的数量 ######################################## 上一个运算题： 每个node包含16个GPU，且nproc_per_node=8，nnodes=3，机器的node_rank=5，请问word_size是多少？ 答案：word_size = 3*8 = 24 结论：word_size = nproc_per_node * nnodes ########################################################################## 多进程组启动方法：torch.distributed.launch 或 torchrun 常用启动方法示例：python3 -m torch.distributed.launch --nproc_per_node 2 main.py ''' import torch import torch.nn as nn import torch.optim as optim import torch.distributed as dist from torch.nn.parallel import DistributedDataParallel as DDP class ToyModel(nn.Module): def __init__(self): super().__init__() self.fc1 = nn.Linear(10, 10) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1db6f474e5503e84754cd5c62861836/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e86ab0b3bda52a83fd44bb381336a6a5/" rel="bookmark">
			简单快速把本地的工程上传到gitlab/github新建的工程的主分支/已存在工程的其他分支中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 上传到新建工程的主分支
git clone 新建工程的ssh地址 cd 下载下来的文件夹A # 然后把本地工程所有的文件拷贝到文件夹A git add . git commit -m '一些说明' git push 上传到已存在的工程的其他分支，如develop分支
# 先在gitlab上为已有的工程新建一个分支，命名为develop git clone 该工程的ssh地址 cd 下载下来的文件夹A git switch develop # 切换到develop分支 # 然后把本地工程所有的文件拷贝到文件夹A，并解决冲突 git add . git commit -m '一些说明' git push 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/962702cb370aa567f26241ba62b91d38/" rel="bookmark">
			利用格式工厂，做视频的剪辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接到一个工作，一段视频中，需要抠除其中某一段
其实 剪映、苹果手机的视频编辑功能，都可以轻松搞定
只是清晰度会有损伤
而且对于太大的视频，苹果手机就没法处理了。
很多软件在导出高清视频时，需要会员收费，很是麻烦。
公布最后的做法：
视频：头-----第一切点-----第二切点-----尾
目标：第一切点和第二切点之间要剪切掉
Step1：
格式工厂-- 快速剪辑，定位 头–第一切点 【我们只要定位第一切点就好】
输出设置中，
视频编码 选 MPEG4（DivX) 格式 【此前选HEVC格式，发现没法自由拖放】
码率 选到 20M
每秒帧数 选到 60
这样，以保证最大化信息输出。
导出。
Step2：
格式工厂-- 快速剪辑，定位 第二切点–尾 【只需定位第二切点，尾部系统会自动定位】
同步注意一下 输出设置。
导出。
Step3：
格式工厂–视频合并&amp;混流
将Step1和Step2的结果合并，也顺便检查一下合并时的输出格式。
至此，大功告成！
视频能够实现任意点的拖放！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21859838b8d88daab442dfce99defa7b/" rel="bookmark">
			CUDA动态并行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简介 1. 综述 动态并行是 CUDA 编程模型的扩展，使 CUDA 内核能够直接在 GPU 上创建新工作并与其同步。 在程序中任何需要的地方动态创建并行性都提供了令人兴奋的功能。
直接从 GPU 创建工作的能力可以减少在主机和设备之间传输执行控制和数据的需要，因为现在可以由在设备上执行的线程在运行时做出启动配置决策。 此外，可以在运行时在内核内内联生成依赖于数据的并行工作，动态利用 GPU 的硬件调度程序和负载平衡器，并根据数据驱动的决策或工作负载进行调整。 以前需要修改以消除递归、不规则循环结构或其他不适合平面、单级并行性的构造的算法和编程模式可以更透明地表达。
本文档描述了支持动态并行性的 CUDA 扩展功能，包括利用这些功能所需的对 CUDA 编程模型的修改和添加，以及利用这种附加功能的指南和最佳实践。
动态并行仅受计算能力 3.5 及更高版本的设备支持。
2. 术语 网格 网格是线程的集合，网格中的线程执行内核函数并被划分为线程块。
线程块 线程块是在同一多处理器 (SM) 上执行的一组线程，线程块中的线程可以访问共享内存并且可以显式同步。
内核函数 内核函数是一个隐式并行子例程，它在 CUDA 执行和内存模型下为网格中的每个线程执行。
主机 主机是指最初调用CUDA的执行环境，通常是在系统的 CPU 处理器上运行的线程。
父 父线程、线程块或网格是启动新网格（子网格）的线程。 在所有启动的子网格也完成之前，父网格才被视为完成。
子 子线程、块或网格是由父网格启动的线程、块或网格。 子网格必须在父线程、线程块或网格被视为完成之前完成。
线程块作用域 具有线程块作用域的对象具有单个线程块的生命周期。 它们仅在由创建对象的线程块中的线程操作时具有定义的行为，并在创建它们的线程块完成时被销毁。
设备运行时 设备运行时是指可用于使内核函数使用动态并行性的运行时系统和 API。
二、执行环境和内存模型 1. 执行环境 CUDA 执行模型基于线程、线程块和网格的原语，其中内核函数定义由线程块和网格内的各个线程执行的程序。 当调用内核函数时，网格的属性由执行配置描述，该执行配置在 CUDA 中具有特殊语法。 CUDA 中对动态并行性的支持扩展了在新网格上配置、启动和隐式同步到设备上运行的线程的能力。
（1）父网格和子网格 配置和启动新网格的设备线程属于父网格，被调用创建的网格是子网格。
父网格在其线程创建的所有子网格全部都完成之后才被视为完成，并且运行时保证父网格和子网格之间的隐式同步。
（2）CUDA原语范围 在主机和设备上，CUDA 运行时都提供了一个 API，用于启动内核并通过流和事件跟踪启动之间的依赖关系。 在主机系统上，启动状态以及引用流和事件的 CUDA 原语由进程内的所有线程共享； 然而进程独立执行并且不能共享 CUDA 对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21859838b8d88daab442dfce99defa7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deebdf1e09132acf8e2e438d9601b021/" rel="bookmark">
			CompletableFuture 详解（一）：基本概念及用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、为什么叫CompletableFuture?
2、创建CompletableFuture
2.1 构造函数创建
2.2 supplyAsync创建
2.3 runAsync创建
3、常见的使用方式
3.1 thenApply / thenAccept / thenRun
3.2 thenCombine
3.3 thenCompose
3.4 whenComplete
3.5 handle
CompletableFuture是java.util.concurrent库在java 8中新增的主要工具，同传统的Future相比，其支持流式计算、函数式编程、完成通知、自定义异常处理等很多新的特性。由于函数式编程在java中越来越多的被使用到，熟练掌握CompletableFuture，对于更好的使用java 8后的主要新特性很重要。简单起见，本文使用的CompletableFuture版本为java 8（java 11的CompletableFuture新增了一些方法）。
1、为什么叫CompletableFuture? CompletableFuture字面翻译过来，就是“可完成的Future”。同传统的Future相比较，CompletableFuture能够主动设置计算的结果值（主动终结计算过程，即completable），从而在某些场景下主动结束阻塞等待。而Future由于不能主动设置计算结果值，一旦调用get()进行阻塞等待，要么当计算结果产生，要么超时，才会返回。
下面的示例，比较简单的说明了，CompletableFuture是如何被主动完成的。在下面这段代码中，由于调用了complete方法，所以最终的打印结果是“manual test”，而不是"test"。
CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(()-&gt;{ try{ Thread.sleep(1000L); return "test"; } catch (Exception e){ return "failed test"; } }); future.complete("manual test"); System.out.println(future.join()); 2、创建CompletableFuture 2.1 构造函数创建 最简单的方式就是通过构造函数创建一个CompletableFuture实例。如下代码所示。由于新创建的CompletableFuture还没有任何计算结果，这时调用join，当前线程会一直阻塞在这里。
CompletableFuture&lt;String&gt; future = new CompletableFuture(); String result = future.join(); System.out.println(result); 此时，如果在另外一个线程中，主动设置该CompletableFuture的值，则上面线程中的结果就能返回。
future.complete("test"); 这展示了CompletableFuture最简单的创建及使用方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/deebdf1e09132acf8e2e438d9601b021/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48f7c9fa9edf499c280c9e8dc0b12b41/" rel="bookmark">
			SpringBoot&#43;AOP&#43;Redis 防止重复请求提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文项目基于以下教程的代码版本： https://javaxbfs.blog.csdn.net/article/details/135224261
代码仓库: springboot一些案例的整合_1: springboot一些案例的整合
1、实现步骤 2.引入依赖 我们需要redis、aop的依赖。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt; &lt;/dependency&gt; redis的访问参数，默认的就行，不需要特别配置。
3、定义拦截注解 我们最终希望的效果是，你想要哪个方法有防止重复提交的功能，直接加上@RepeatSubmit注解即可。 代码如下：
@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface RepeatSubmit { /** * 加锁过期时间，默认是5秒 * @return */ long lockTime() default 5L; } 这段代码定义了一个Java注解（Annotation）叫做RepeatSubmit。注解是Java提供的一种元数据机制，它可以被用于为代码提供附加的信息，这些信息可以被编译器用于生成代码、生成文档、代码检查等。
下面是对这段代码的详细解释：
@Target(ElementType.METHOD): 这个注解指定RepeatSubmit只能被用于方法上。ElementType.METHOD表示这个注解只能用于方法。
@Retention(RetentionPolicy.RUNTIME): 这个注解指定了RepeatSubmit的保留策略是RUNTIME。这意味着在运行时，这个注解仍然可以被读取。
@Documented: 这个注解表明RepeatSubmit应当被Java文档生成器包含在生成文档中。
public @interface RepeatSubmit: 定义了一个名为RepeatSubmit的公共注解。
long lockTime() default 5L: 这是RepeatSubmit注解的一个元素，名为lockTime。这个元素返回一个长整型值，并且有一个默认值5秒（5L表示5秒）。
这个注解是为了防止方法的重复提交，并提供了一个默认的加锁过期时间为5秒。如果一个方法被这个注解标记，那么在特定的加锁过期时间内，这个方法只会被执行一次。
4、实现防止重复提交切面 关于Spring Aop切面，可以看我之前的文章。
NoRepeatSubmitAspect
package com.it.demo.aspect; import cn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48f7c9fa9edf499c280c9e8dc0b12b41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f41fb961ec2dd80d19a6113be6b0087/" rel="bookmark">
			基于SSM的中学课内小说阅读与学习系统的设计论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于SSM的中学课内小说阅读与学习系统的设计与实现 摘要
随着信息互联网购物的飞速发展，一般有能力的机构管理系统。本文介绍了中学课内小说阅读与学习系统的开发全过程。通过分析企业对于中学课内小说阅读与学习系统的需求，创建了一个计算机管理中学课内小说阅读与学习系统的方案。文章介绍了中学课内小说阅读与学习系统的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本中学课内小说阅读与学习系统有管理员，教师，学生。
管理员功能有个人中心，学生管理，老师管理，小说管理，小说类型管理，作业管理，班级管理，作业完成信息管理，作业批改信息管理，留言板管理，我的收藏管理，系统管理等。
老师功能有个人中心，小说管理，作业管理，作业完成信息管理，作业批改信息管理等。
学生功能有个人中心，小说管理，作业管理，作业完成信息管理，作业批改信息管理，我的收藏管理等。因而具有一定的实用性。
本站是一个B/S模式系统，采用SSM框架作为开发技术，MYSQL数据库设计开发，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得中学课内小说阅读与学习系统管理工作系统化、规范化。
关键词：中学课内小说阅读与学习系统；SSM框架；MYSQL数据库
Abstract
With the rapid development of information Internet shopping, there is generally a competent institutional management system. This article introduces the whole process of the development of the novel reading and learning system in the middle school class. By analyzing the needs of enterprises for the reading and learning system of the novel in the middle school class, a program of computer management of the reading and learning system of the novel in the middle school was created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f41fb961ec2dd80d19a6113be6b0087/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1bb4a02e0ba3226f0e80deaee68e409/" rel="bookmark">
			uniapp实现微信小程序分享、保存图片、收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 微信小程序分享 （识别图中二维码不会，有会的评论发一下文章链接）
// #ifdef MP-WEIXIN // 显示弹窗，提供“转发”、“保存图片”、“收藏”等选项 wx.showActionSheet({ itemList: ['转发', '保存图片', '收藏'], // itemList: ['转发', '保存图片', '收藏', '识别图中二维码'], success: (res) =&gt; { // 用户选择了一个选项后的处理逻辑 console.log('用户选择了：', res.tapIndex); switch (res.tapIndex) { case 0:// 转发 onShareImgClick() break; case 1:// 保存图片 wx.saveImageToPhotosAlbum({ filePath: imgPath.value, // 传入获取到的临时文件路径 success: function () { // 保存成功后的回调函数，可以在这里进行相应的处理 console.log('保存图片成功'); proxy.$API(proxy).Toast("保存图片成功"); }, fail: function (err) { // 保存失败的处理逻辑，可以在这里进行相应的处理 console.error('保存图片失败：', err); proxy.$API(proxy).Toast("保存图片失败"); } }); break; case 2://收藏 wx.addFileToFavorites({ filePath: imgPath.value, success: function () { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1bb4a02e0ba3226f0e80deaee68e409/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/086e2b85656575aa35cfbd52913b6562/" rel="bookmark">
			uniapp 抖音小程序授权登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//抖音登录点击 const onDyLoginClick = () =&gt; { dyLogin() } //抖音三方登录 const dyLogin = () =&gt; { uni.login({ provider: 'toutiao', success: function (loginRes) { console.log("loginRes", loginRes); uni.getUserInfo({ provider: 'toutiao', success(res) { console.log("getUserInfo = ", res) uni.setStorageSync('authInfo', res.userInfo); if (res) { let params = { code: loginRes.code, anonymous_code: loginRes.anonymousCode } // result.tt_data.openid } }, fail(err) { getUserAuth() console.log("getUserInfo fail = ", err) } }) } }); } //校验授权状态，正常授权后才能去登录 const getUserAuth = () =&gt; { // 获取用户的当前设置 uni.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/086e2b85656575aa35cfbd52913b6562/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d978d478e668d0a950c62b557ab6e39/" rel="bookmark">
			uniapp使用高德地图二次开发h5（显示和搜索周边并拿到经纬度和地址名称等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;template&gt; &lt;view class="map-container"&gt; &lt;view class="map" id="map"&gt; &lt;image class="backIcon" @click="onBackClick" src="../../static/image/pulice/arrow_right.png" mode="scaleToFill"&gt;&lt;/image&gt; &lt;view class="pin"&gt;&lt;/view&gt; &lt;view class="btnCommit" @click="onCommitClick"&gt;确定&lt;/view&gt; &lt;/view&gt; &lt;!--搜索内容--&gt; &lt;view class="searchLayout"&gt; &lt;view class="inputLayout"&gt; &lt;u-input fontSize="26rpx" placeholder=" 搜索地点" v-model="searchTxt" @change="onInputChage"&gt;&lt;/u-input&gt; &lt;view class="cancelTxt" @click="onCancelSearchClick"&gt;取消&lt;/view&gt; &lt;/view&gt; &lt;view class="searchContent"&gt; &lt;scroll-view id="panel" scroll-y @scrolltolower="onScrolltolower" lower-threshold="100"&gt; &lt;view :class="item.isChecked?'listItemSelect':'listItem'" v-for="(item,index) in poiList" :key="index" @click="onItemClick(item)"&gt; &lt;u-image width="120rpx" height="120rpx" :src="item.photos[0]&amp;&amp;item.photos[0].url?item.photos[0].url:'../../static/image/pulice/loadingIcon.png'" mode="scaleToFill" loadingIcon="../../static/image/pulice/loadingIcon.png" radius="10rpx"&gt;&lt;/u-image&gt; &lt;view class="txtLayout"&gt; &lt;view&gt;{{ item.name }}&lt;/view&gt; &lt;view&gt;地址：{{ item.pname }}{{ item.cityname }}{{ item.adname }}{{ item.address }}&lt;/view&gt; &lt;view v-if="item.id !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d978d478e668d0a950c62b557ab6e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5bfd3e410112bb446e56329f2fb7bd5/" rel="bookmark">
			python，爬虫突破登录校验之获取手机短信验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		逻辑如下
执行以下步骤：
1、手机下载SmsForwarder-短信转发器
2、进入应用通用设置进行配置与授权
3、配置发送通道
4、配置转发规则
5、编写接收短信信息接口
开始实践
一、下载APP并安装，授权电话与短信权限
二、通用设置
授权短信权限与卡信息
三、配置发送通道
点击右上角添加 icon，选择Webhook，设置调用地址接口和请求方式（Webhook Server：接口请求地址）
四、配置转发规则
点击添加icon，选择刚才配置的发送通道，如下配置即可（注意短信的匹配规则）
五、编写接收接口api并运行python程序
import json import flask server = flask.Flask(__name__) @server.route('/sms', methods=['post']) def receive(): res = flask.request.json print(res) print(res['msg']) return res server.run(port=8888, debug=True) 注：作者已配置了内网穿透域名，若无配置，设置具体ip即可
测试效果
（1）测试通道
（2）测试转发规则
（3）测试真实的短信验证
作者使用个人的短信验证，各位可自行去服务商开通购买短信服务
短信已发送至手机
手机与转发app已拦截到发送的短信
接口api收到发送过来的短信信息
解析到验证码之后就可以拿去登录界面填充了！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02996a725e15bb0bedef996cb35f68dc/" rel="bookmark">
			vue-element-admin前端项目 执行npm install报错 code 128 using --force Recommended protections disabled
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面内容仅供参考 我认为这个问题是git的仓库连不上， 直接将git卸载了，重新装了一次
我参考 Git教程(快速上手，超详细)
然后就出现了另一个错误 。npm ERR! npm WARN using --force Recommended protections disabled.
解决办法
转载自阿莨去爬山了，非常感谢。
1.删除package.json中tui-editor:1.3.3 2.修改\src\components\MarkdownEditor\index.vue文件 将全部import换成下面几个 import 'codemirror/lib/codemirror.css' import '@toast-ui/editor/dist/toastui-editor.css' import Editor from '@toast-ui/vue-editor' import defaultOptions from './default-options' 并将该文件下的getValue和setValue分别换成getMarkdown和setMarkdown 3.单独安装tui-editor npm install --save @toast-ui/vue-editor 4.安装其他依赖 npm install 5.运行程序 npm run dev	虽然我这里报了3个errors【是上面import的那几个导入报错】 但是程序还是成功跑起来了
提醒一下CMD需要用管理员方式打开
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd52944f4a89c3fa3af034fa6cdfeac3/" rel="bookmark">
			玩转MYSQL|详细分析mysql-MGR集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、简介
2、环境准备
2.1 数据库服务器规划
2.2 安装mysql5.7.20
2.3 设置hostname和ip映射
3、创建复制环境
3.1 服务器host68.cn
3.1.1 配置/etc/my.cnf
3.1.2 服务器host68.cn上建立复制账号：
3.1.3 在mysql服务器host68.cn上安装group replication插件
3.1.4 启动服务器host68.cn上mysql的group replication
3.1.5 查看mgr的状态
3.1.6 测试服务器host68.cn上的mysql
3.2 复制组添加新实例host69.cn
3.2.1 修改/etc/my.cnf 配置文件，方法和之前相同
3.2.2 用户授权
3.2.3 把实例添回到之前的复制组
3.2.4 在host68.cn上查看复制组状态
3.3 以同样方法添加host70.cn
3.4 查看复制组状态
1、简介 MySQL Group Replication（简称MGR）是MySQL官方于2016年12月推出的一个全新的高可用与高扩展的解决方案。MySQL组复制提供了高可用、高扩展、高可靠的MySQL集群服务。
高一致性，基于原生复制及paxos协议的组复制技术，并以插件的方式提供，提供一致数据安全保证；高容错性，只要不是大多数节点坏掉就可以继续工作，有自动检测机制，当不同节点产生资源争用冲突时，不会出现错误，按照先到者优先原则进行处理，并且内置了自动化脑裂防护机制；高扩展性，节点的新增和移除都是自动的，新节点加入后，会自动从其他节点上同步状态，直到新节点和其他节点保持一致，如果某节点被移除了，其他节点自动更新组信息，自动维护新的组信息；高灵活性，有单主模式和多主模式，单主模式下，会自动选主，所有更新操作都在主上进行；多主模式下，所有server都可以同时处理更新操作。 2、环境准备 2.1 数据库服务器规划 ip地址主机名数据库端口号server Id10.10.10.68host68mysql-5.7.20330610010.10.10.69host69mysql-5.7.20330610110.10.10.70host70mysql-5.7.203306102 2.2 安装mysql5.7.20 在这里就不详细介绍。
2.3 设置hostname和ip映射 10.10.10.68 host68.cn 10.10.10.69 host69.cn 10.10.10.70 host70.cn 注意;在三台数据库服务器上都设置。
3、创建复制环境 3.1 服务器host68.cn 3.1.1 配置/etc/my.cnf vim /etc/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd52944f4a89c3fa3af034fa6cdfeac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3da1f0f1d731ce5598b0e9b67796023/" rel="bookmark">
			win10安装最新nexus-3.x及maven简单配置介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Nexus下载 目前版本已经更新到了3.X 下载地址： https://www.sonatype.com/download-oss-sonatyp 点击打开链接 下载文件名：nexus-3.2.1-01-win64.zip（ nexus-3.7.1-02-win64 的安装相同 ） 下载完成后直接解压到想要的目录，例如：C:\Nexus，解压后会有两个目录： sonatype-work （工作目录） nexus-3.2.1-01 （安装文件目录） 2.环境准备 （1）Windows 10 x64系统 （2）JDK1.8 （3）Maven3 3.安装 1.打开命令行，切换到 nexus-3.2.1-01 /bin目录下，回车。例：C:\Nexus\nexus-3.2.1-01\bin 2.输入： nexus.exe/run ，并回车 3.执行后出现以下信息表示安装成功: 4.打开浏览器，输入：localhost:8081，完成 PS:Nexus的默认端口为8081，想修改默认端口可打开nexus-3.2.1-01\etc目录下的nexus-default.properties文件，修改为想要的端口号即可。 5.登录 访问nexus，即http://localhost:8081
出现上述页面，说明配置nexus成功！
点击右上角“Log in”，
输入默认用户名(admin)和默认密码（admin123）登录
可以点击上面的“设置”图标，在“设置”里可以添加用户、角色，对接LDAP等的设置，如下：
可以在“管理”里查看nexus的系统信息
注意下面几点说明：
1.component name的一些说明： 1）maven-central：maven中央库，默认从https://repo1.maven.org/maven2/拉取jar 2）maven-releases：私库发行版jar 3）maven-snapshots：私库快照（调试版本）jar 4）maven-public：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置settings.xml中使用。
2.Nexus默认的仓库类型有以下四种：
1）group(仓库组类型)：又叫组仓库，用于方便开发人员自己设定的仓库；
2）hosted(宿主类型)：内部项目的发布仓库（内部开发人员，发布上去存放的仓库）；
3）proxy(代理类型)：从远程中央仓库中寻找数据的仓库（可以点击对应的仓库的Configuration页签下Remote Storage Location属性的值即被代理的远程仓库的路径）；
4）virtual(虚拟类型)：虚拟仓库（这个基本用不到，重点关注上面三个仓库的使用）；
3.Policy(策略):表示该仓库为发布(Release)版本仓库还是快照(Snapshot)版本仓库；
4.Public Repositories下的仓库 1）3rd party: 无法从公共仓库获得的第三方发布版本的构件仓库，即第三方依赖的仓库，这个数据通常是由内部人员自行下载之后发布上去；
2）Apache Snapshots: 用了代理ApacheMaven仓库快照版本的构件仓库 3）Central: 用来代理maven中央仓库中发布版本构件的仓库 4）Central M1 shadow: 用于提供中央仓库中M1格式的发布版本的构件镜像仓库 5）Codehaus Snapshots: 用来代理CodehausMaven 仓库的快照版本构件的仓库 6）Releases: 内部的模块中release模块的发布仓库，用来部署管理内部的发布版本构件的宿主类型仓库；release是发布版本；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3da1f0f1d731ce5598b0e9b67796023/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fc3b03ae3b4390f91a31e2fcb3204a0/" rel="bookmark">
			单例模式的双重检查锁定是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		单例模式的双重检查锁定是什么？ 单例模式是一种常见的设计模式，用于确保一个类只有一个实例，并提供一个全局访问点。双重检查锁定（Double-Checked Locking）是一种在单例模式中使用的性能优化技术。
在传统的单例模式实现中，我们通常通过将构造函数设为私有，再提供一个静态方法来返回类的唯一实例。而双重检查锁定则是在这个基础上增加了线程安全的考虑，避免在多线程环境下出现性能问题和错误结果。
双重检查锁定的基本思想是在获取单例对象时进行双重检查，即先检查实例是否已经创建，如果尚未创建，再进行同步操作来确保只有一个线程创建实例。这样可以在不必要时避免同步开销，提高性能。
具体实现如下：
public class Singleton { private volatile static Singleton uniqueInstance; private Singleton() {} public static Singleton getInstance() { if (uniqueInstance == null) { synchronized (Singleton.class) { if (uniqueInstance == null) { uniqueInstance = new Singleton(); } } } return uniqueInstance; } } 尽管双重检查锁定可以提高性能，但在某些情况下也可能存在问题，例如在一些旧版本的JVM中会由于编译器优化而导致失效。因此，在使用双重检查锁定时，务必谨慎考虑各种因素，并在确保其正确性的前提下才使用该技术。
双重检查锁定触发的机制有哪些？ 双重检查锁定（Double-Checked Locking）是一种在多线程环境中保证单例模式实例化的常用机制，但它存在一些问题，可能会触发一些不期望的行为。这些问题包括：
指令重排序：在某些情况下，JVM可能会对代码进行指令重排序，导致在多线程环境下初始化过程中的操作顺序被改变，从而可能返回一个尚未完全初始化的实例。可见性问题：在旧版本的Java规范中，由于缓存一致性的问题，有可能导致一个线程看到的uniqueInstance不是最新的。并发问题：尽管双重检查锁定可以在一定程度上解决并发性能问题，但是在某些情况下，仍然可能存在并发问题，例如在构造函数中可能出现的竞态条件。 因此，在使用双重检查锁定时，需要特别小心地处理这些问题，并且最好结合volatile关键字、静态内部类等其他机制来确保线程安全和正确性。在Java 5及之后的版本中，还可以考虑使用基于类初始化的解决方案，如使用静态内部类等方式来实现延迟初始化，以规避双重检查锁定机制可能带来的问题。
双重检查锁定的原理是什么？ 双重检查锁定（Double-Checked Locking）是一种在多线程环境下使用的单例模式实现技术，旨在在保证线程安全的同时提高性能。其基本原理可以简要概括如下：
第一层检查：在获取单例对象时，首先检查实例是否已经创建，如果已经创建则直接返回实例，不需要进行后续的同步操作。同步块：如果第一层检查发现实例尚未创建，才进入同步块。在同步块内部进行第二次检查，以确保只有一个线程创建实例。实例化：在同步块中，再次检查实例是否已经创建，避免多个线程同时通过第一层检查，然后都进入同步块进行实例化。 双重检查锁定的目的是在尽量减少同步操作的情况下，保证在多线程环境中只有一个实例被创建。这样可以避免性能下降，同时保证线程安全。
需要特别注意的是，在实现双重检查锁定时，需要使用volatile关键字修饰实例变量，以确保其可见性，避免指令重排序导致的问题。此外，由于不同版本的JVM和编译器对指令重排序的处理方式可能不同，因此在使用双重检查锁定时，需要仔细考虑各种因素，确保其正确性和可靠性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39701bc8aae4edbe5737012072dff4c3/" rel="bookmark">
			分享74个Python爬虫源码总有一个是你想要的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享74个Python爬虫源码总有一个是你想要的
学习知识费力气，收集整理更不易。
知识付费甚欢喜，为咱码农谋福利。
链接：https://pan.baidu.com/s/1GHl3518e3tq8TOe-LwLm4g?pwd=6666 提取码：6666
项目名称
1024爬虫小说下载
163严选爬虫
58同城 zhilian hao123 163云课堂 中国大学排名 等的python的一些爬虫
A web crawlerfor Sina, search and retrieve microblogs that contain certain keywords 一个简单的python爬虫实践，爬取包含关键词的新浪微博
apple_python 官网自动监控爬虫
BaiduSpider，一个爬取某度搜索结果的爬虫，目前支持某度网页搜索，某度图片搜索，某度知道搜索，某度视频搜索，某度资讯搜索，某度文库搜索，某度经验搜索和某度百科搜索
B站弹幕、评论爬虫+词云生成
EroCool 漫画图集网站爬虫
mt爬虫Python程序，用于爬取美tuan网站上的商铺及用户信息
python django 美女图片爬虫站
Python 关于期货数据爬虫
Python 爬虫基金
python+Selenium爬虫：模拟登录+自动点击
Python-jmtt爬虫，可下载每个分类下的所有漫画，已经打包成EXE文件并放入Releases里，喜欢就点个Watched和Star
Python实现的LeetCode爬虫
python实现的数据爬虫和数据接口
python某度文库爬虫
Python爬虫实战：将网页转换为pdf电子书
Python爬虫框架：PySpider，既简单易用又功能强大且带图形界面
python爬虫模拟zhihu登录
python爬虫爬取某度百科页面
python爬虫获取双色球和大乐透数据，并做数据分析与统计
Python爬虫，抓取“mzitu.com”网站上的美女图片
Python爬虫，某东自动登录，指定商品自动加购物车，自动下单，指定时间抢购商品
python编写的爬虫代理ip池
Python队列+多线程爬虫（起点小说网、豆瓣、某东订单、某度贴吧、某宝优惠券6W数据、糗事百科）
Selenium×Firefox自动化爬虫模板
Simple And EasyPython Crawler Framework，支持抓取javascript渲染的页面的简单实用高效的python网页爬虫抓取模块
Tcat爬虫（大量注释，readme有思路分析）
zhihu爬虫和v2ex爬虫的实现
zhihu用户公开个人信息爬虫, 能够爬取用户关注关系，基于Python、使用代理、多线程
一个基于Scrapy的数据采集爬虫代码库
一个用PYQT5写的图形化的多功能电商爬虫小工具
一个简单的 Python 爬虫系统示例
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39701bc8aae4edbe5737012072dff4c3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/82/">«</a>
	<span class="pagination__item pagination__item--current">83/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/84/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>