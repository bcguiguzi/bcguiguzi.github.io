<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec338aa575440df1e09269418a53d2c7/" rel="bookmark">
			WMI Provider Host
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WMI 即 Windows Management Instrumentation（Windows 管理规范）的简写，是 Windows 操作系统的一项内置功能，它为软件和管理脚本提供了一种标准化方法，可以用于请求有关 Windows 操作系统状态和其它数据信息。WMI Provider 则在有相关请求时提供、返回这些信息。
例如，通过软件或脚本代码可以查询有关 BitLocker 驱动器加密状态的信息、查看事件日志中的条目，或者通过 WMI Provider 调用当前系统中已安装的应用程序，等等操作。
微软官网上列出了包含 WMI Provider 的列表。
对于集中管理 Windows PC 的企业或团体来说，WMI 这是一个特别有用的功能，IT Pro 可以通过脚本请求信息并在管理控制台中以标准方式输出显示。即便在个人用户的家用电脑上，某些软件也会通过 WMI 接口来请求有关操作系统的信息。
当然，你也可以自己使用 WMI 来查找有用的信息，例如获取电脑的序列号、查看主板型号，或是硬盘的 SMART 运行状况等。具体使用方法，此文不作介绍，大家可以自学 WMI 的命令行工具——WMIC。
WMI Provider Host为什么占用很高CPU 前面已经说过，WMI Provider Host 通常情况下不会使用太多的 CPU 资源，因为它在决大多数时间都处于空闲（闲置）状态。只有当一个应用程序或脚本通过 WMI 查询信息时，才偶尔使用一些 CPU 资源，这都属于正常情况。
但如果 WMI Provider Host (WmiPrvSE.exe) 进程长时间占用很高 CPU 使用率的话，这就不正常了，WMI Provider Host 在正常情况下不应该一直占用大量的 CPU 资源。
如果你遇到上述不正常情况，可以执行 Services.msc 打开「服务」，尝试重启「Windows Management Instrumentation」服务，可能会有所帮助。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec338aa575440df1e09269418a53d2c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac0ffef616629d78c7b70344a18337ac/" rel="bookmark">
			利用FCN-32s,FCN-16s和FCN-8s训练自己制作的数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 之前写过一篇博客是制作自己的数据集利用FCN-32s模型训练，对FCN-16s和FCN-8s训练写的比较粗略，所以写这篇博客主要是补充FCN-16s和FCN-8s训练过程。
训练前准备 在使用fcn之前需要配置caffe环境，可以参考win10+vs2013+caffe+gpu+python环境配置这篇博客，对如何制作自己的数据集以及FCN-32s训练过程可以参考FCN制作自己的数据集并训练和测试这篇博客
训练过程 训练FCN-16s
如果你的fcn-32s模型训练好之后，会在路径D:\caffe\caffe-master\fcn-master\voc-fcn32s\snapshot（这是我fcn-master代码的路径）中看到train_iter_100000.caffemodel文件，这个文件就是FCN-32s模型权重。如果你的fcn-32s模型训练好之后，会在路径D:\caffe\caffe-master\fcn-master\voc-fcn32s\snapshot（这是我fcn-master代码的路径）中看到train_iter_100000.caffemodel文件，这个文件就是FCN-32s模型权重。
接着在fcn-master目录下找到所有py文件复制到voc-fcn16s文件夹中，同时新建文件夹snapshot
你的文件夹中可能没有deploy.prototxt文件，这里给出下载地址deploy，里面有两个文件，将deploy_fcn16.prototxt重命名为deploy.prototxt并复制到到voc-fcn16s文件夹中
用vs打开solver.prototxt文件，这里面是一些参数配置，由于我的图片较少，所以我把test_iter参数改为2,这个参数是指在测试时一次测试多少张图片。其他参数默认就行。
对于train.prototxt，val.prototxt和voc_layers.py三个文件修改的方法和训练fcn-32s时一模一样，所以参考上述的FCN制作自己的数据集并训练和测试的博客就行。
打开solve.py文件，修改代码为下
import caffe import surgery, score import numpy as np import os import sys sys.path.append('D:/caffe/caffe-master/python') try: import setproctitle setproctitle.setproctitle(os.path.basename(os.getcwd())) except: pass weights = 'D:/caffe/caffe-master/fcn-master/voc-fcn32s/snapshot1/train_iter_100000.caffemodel' # init #caffe.set_device(int(sys.argv[1])) caffe.set_mode_gpu() caffe.set_device(0) solver = caffe.SGDSolver('solver.prototxt') solver.net.copy_from(weights) # surgeries interp_layers = [k for k in solver.net.params.keys() if 'up' in k] surgery.interp(solver.net, interp_layers) # scoring val = np.loadtxt('D:/caffe/caffe-master/fcn-master/data/pascal/VOCdevkit/VOC2012/ImageSets/Segmentation/seg11valid.txt', dtype=str) for _ in range(25): solver.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac0ffef616629d78c7b70344a18337ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9479d7c0b282cb1c7a74cd7568631d6/" rel="bookmark">
			JS中对于for循环中点击事件的理解（通俗版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习JS时遇到了一个问题，就是如果有多个按钮时，我们可以通过document.getElementByTagName（“button”）的方式来获取事件数组，在获取后我们需要监听每一个按钮是否被点击。最简单的方式就是分开写，一个按钮对应一个点击事件函数，这样虽然通俗易懂，但是这样的代码量是十分大的，既然我们获得的是一个事件的数组，为什么不用一个for循环来解决呢，于是就有了下面这一种写法（本代码是通过点击按钮实现图片的切换）：
for(var i=0; i&lt;allLi.length; i++){ var sLi = allLi[i]; sLi.index = i+1; sLi.onclick = function () { box.style.background = 'url("images/0'+ this.index +'big.jpg") no-repeat'; } } 刚开始看到这个也是一脸懵逼，因为之前一直做的是ACM，对于程序执行过程十分敏感，感觉这不合常理啊，一直不知道他这是怎么执行的，for循环执行完了以后，应该再去点击的时候就没用了啊，但是这里依旧可以，说明在JS中，事件的监听的执行不是按照严格的执行先后顺序来的，而是随时点，随时执行，这种写法只是简化了上面所提到的最直接的书写方式，通过for循环去实现后，其实和把他们展开的写法是一模一样的，但是要确定你点的究竟是哪个按钮，就要通过this来实现。
另一个就是需要通过改变其背景属性来实现背景的切换，那就是要改名字，名字要更改一个数字，但是我们不能通过i去实现，因为在for循环执行完毕后，i就变成了5，那么就无法去改变了，所以我们可以通过改变它的index属性来实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eed7686abc9182a7186be65a4856151d/" rel="bookmark">
			【Spark内核源码】SparkContext中的组件和初始化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
SparkContext概述
SparkContext组件概述
SparkContext初始化过程
第一步：确保当前线程中没有SparkContext在运行
第二步：版本反馈
第三步：真正的初始化
第四步：确认启动成功
SparkContext概述 在【Spark内核源码】Word Count程序的简单分析 当中使用Spark Shell编写了简单的Word Count程序，在进入Spark Shell的时候，Spark Shell为我们自动创建了SparkContext sc。
Spark应用程序的第一步就是创建并初始化SparkContext，SparkContext的初始化过程包含了内部组件的创建和准备，主要涉及网络通信、分布式、消息、存储、计算、调度、缓存、度量、清理、文件服务和UI等方面。它是Spark主要功能的入口点，链接Spark集群，创建RDD、累加器和广播变量，一个线程只能运行一个SparkContext。SparkContext在应用程序中将外部数据转换成RDD，因此建立了第一个RDD，也就是说SparkContext建立了RDD血缘关系的根，是DAG的根源。
SparkContext组件概述 SparkContext的组件如下图所示：
各组件的说明如下：
listenerBus：Spark事件总线，接收各个使用方的事件，以异步的方式对事件进行匹配和处理。
_ui:Spark用户界面,间接依赖于计算引擎、调度系统、存储体系、作业、阶段、存储、执行器等组件的监控数据，以SparkListenerEnvent的形式投递给LiveListener，SparkUI从SparkListener中读取数据。
_taskScheduler:任务调度器，调度系统中最重要的组件之一，按照调度算法对集群管理器已经分配给应用程序的资源进行二次调度后分配任务,TaskScheduler调度的task是DAGScheduler创建的，因此DAGScheduler是TaskScheduler的前置调度器。
_statusTracker：状态跟踪器，提供对作业、stage等的监控信息。
_shutdownHookRef：任务退出时执行清理任务。
_schedulerBackend：用于对接不同的资源管理系统。
_progressBar：进度条，利用SparkStatusTracker的API，在控制台展示Stage的进度。
_jobProgressListener：作业进度监听器，会注册到LiveListenerBus中作为时间监听器使用。
_cleaner：上下文清理器，用异步方式清理超出应用程序范围的RDD、ShuffleDependency和BroadCast。
_conf：Spark配置，以k-v的形式保存着Spark应用程序的配置信息。
_dagScheduler：DAG调度器，调度系统中最重要的组件之一，负责创建job，将DAG的RDD划分为不同的stage，提交stage。
_env：Spark运行时环境。
_eventLogger：将事件日志的监听器，Spark可选组件，spark.eventLog.enabled=true时启动。
_executorAllocationManager：Executor动态分配管理器，根据工作负载动态调整Executor的数量，在spark.dynamicAllocation.enabled=true的前提下，和非local模式下或者spark.dynamicAllocation.testing=true时启动。
_hadoopConfiguration：hadoop的配置信息，如果使用的是系统SPARK_YARN_MODE=true或者环境变量SPARK_YARN_MODE=true时，启用yarn配置，否则启用hadoop配置。
_heartbeatReceiver：心跳接收器，Executor都会向heartbeatReceiver发送心跳信息，heartbeatReceiver接收到信息后，更新executor最后的可见时间，然后传递给taskScheduler做进一步处理。
SparkContext初始化过程 在将SparkContext初始化过程之前，需要先了解SparkContext伴生对象中的两个变量，它们分别是activeContext: AtomicReference[SparkContext]和contextBeingConstructed: Option[SparkContext]。
activeContext: AtomicReference[SparkContext]记录了当前SparkContext是否处于活跃状态，当活跃的时候activeContext的value就是当前SparkContext，否则value就是null。
contextBeingConstructed: Option[SparkContext]则是SparkContext正在启动时的一个标识，SparkContext初始化时有很多组件需要进行初始化设置，需要消耗一些时间，同时又要保证一个线程中只运行一个SparkContext，通过设置SparkContext启动时的表示，来保证一个线程中只运行一个SparkContext，当SparkContext正在启动时，contextBeingConstructed=Some(sc)，否则contextBeingConstructed=None。
下面来看看SparkContext启动的具体步骤，
第一步：确保当前线程中没有SparkContext在运行 markPartiallyConstructed方法中当assertNoOtherContextIsRunning方法执行通过之后，设置contextBeingConstructed = Some(sc)，表示当前线程中正在建立SparkContext，如果这个线程中再建立SparkContext，就要出问题了，assertNoOtherContextIsRunning就是做这个检验用的。
assertNoOtherContextIsRunning方法中确保一个线程中吃运行一个SparkContext，如果检测到右其他的SparkContext在运行，就抛出异常。如果其他线程在构建SparkContext，就提出一个警告，这个警告是为了当SparkContext构建过程中出现错误，可以很清楚的区分开是哪个线程的SparkContext出的错误。
第二步：版本反馈 输出Spark版本，检验java和scala版本，spark 2.1.0需要使用java7和scala2.10会有警告
第三步：真正的初始化 初始化过程分为十几个步骤：
/**
* SparkConext初始化第三步：
* 通过克隆的方式获取sparkconf，在sparkContext初始化的过程中做了以下几件事：
* 1、会对conf中的配置信息进行校验（部署模式、appName、yarn模式校验等等）
* 2、处理或设置参数：
* 2.1、driver的IP、端口号和ID
* 2.2、处理jar路径和文件路径
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eed7686abc9182a7186be65a4856151d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44902a112da36166eac6eeffee41160d/" rel="bookmark">
			Map 与 Json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人觉得map与json很有意思呢，map与json可以实现互转
1、map是无序的，等同的数据，存储在map中、存储在json中，序列化json与序列化map是有不同结果的，举个栗子：
package MapByOrder import ( "encoding/base64" "fmt" "reflect" "encoding/json" ) type Person struct{ Name string `json:"name"` Phone string `json:"phone"` Number int64 `json:"number"` } func MapOrder(){ var Persons []Person Persons = append(Persons,Person{ Name:"lisa", Phone:"135000000000", Number:111, }) Persons = append(Persons,Person{ Name:"Michel", Phone:"137000000000", Number:222, }) StrP_json, _:= json.Marshal(Persons) encodeString := base64.StdEncoding.EncodeToString(StrP_json) fmt.Printf("%v - %v\n encodeString: %v\n\n",reflect.TypeOf(Persons),Persons,string(encodeString)) var MapPersons []interface{} var MapPerson1 = make(map[string]interface{}) MapPerson1["name"] = "lisa" MapPerson1["phone"] = "135000000000" MapPerson1["number"] = 111 var MapPerson2 = make(map[string]interface{}) MapPerson2["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44902a112da36166eac6eeffee41160d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0366869d689e0b4328f969ac8cc2327f/" rel="bookmark">
			MVC案例之查询学习：HTTP状态500 - java.lang.NullPointerException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天都在看servlet和jsp的视频，早上看完MVC案例的查询，没想到一个小小的错误搞了我差不多一个下午，还是得多点记录总结，以后绝不再犯同样的错误！
这个查询主要是通过点击 test.jsp 页面的超链接来查看数据库里面的数据信息。
1.首先有一个 test.jsp 用来显示链接并点击链接发送请求：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt; &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="listAllStudentsServlet"&gt;List All Students Servlet&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 2.创建一个学生类 Student.java，里面的信息要和数据库里面的一一对应。
package com.smc.javaweb.mvc; public class Student { private Integer id; private String userName; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return userName; } public void setUsername(String userName) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0366869d689e0b4328f969ac8cc2327f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021359f18051e6f0713b7d7eb4e20f46/" rel="bookmark">
			TensorFlow 实现矩阵[n,*]的各行乘以另一个[1,n]矩阵的对应元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个问题真的研究了好久，这个是个小技巧，很实用。
用到的函数主要有
tf.transpose(a, perm=None, name=’transpose’) 调换tensor的维度顺序
按照列表perm的维度排列调换tensor顺序，
如为定义，则perm为(n-1…0)
# ‘x’ is [[1 2 3],[4 5 6]]
tf.transpose(x) ==&gt; [[1 4], [2 5],[3 6]]
# Equivalently
tf.transpose(x, perm=[1, 0]) ==&gt; [[1 4],[2 5], [3 6]
tf.multiply（x, y） 实现过程
import tensorflow as tf a = tf.constant([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], shape=(2, 2, 3)) a_new = tf.reshape(a, shape=[3, 4]) a_trans = tf.transpose(a_new) # 转置[3,4] to [4,3] b = tf.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/021359f18051e6f0713b7d7eb4e20f46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9eb8b093ffdfa18f8fdf8a5c2fb5806/" rel="bookmark">
			Java 去掉bean对象里面各String类型参数两端空格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处： 原文首发于： http://www.zhangruibin.com 本文出自 RebornChang的博客 厚颜打广告，博主个人博客地址传送门 ，欢迎来访 在做功能的时候我们经常会将前台传过来的查询条件字段的两端空格去除，通常的写法是这样的
``
// 去掉查询条件的空格(订单id) if (query.getOrderId() != null) { query.setOrderId(query.getOrderId().trim()); } // 手机号 if(query.getPhoneNum()!= null){ query.setPhoneNum(query.getPhoneNum().trim()); } ... ``
那如果是几十个属性，一个一个这样trim()不得写到手抽筋，所以就想着有没有那么一个Util，来传个对象，根据反射把里面每个String类型的全trim（）了，然后就出现了下面的这个工具类：
``
import java.lang.reflect.Field; import java.lang.reflect.Method; /* * @ClassName BeanHelper *@Description TODO 去掉bean对象里面各String类型参数两端空格 *@Author zhangrui *@Date 10:46 10:46 *@Version * */ public class BeanHelper { /** * 去掉bean中所有属性为字符串的前后空格 * * @param bean * @throws Exception */ public static void beanAttributeValueTrim(Object bean) throws Exception { if (bean !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9eb8b093ffdfa18f8fdf8a5c2fb5806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9863d615cc5d2750bc0df15d2182bf72/" rel="bookmark">
			嵌入式小白到大神学习全攻略（学习路线&#43;课程&#43;学习书籍&#43;练习项目）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章较长，希望耐心阅读，读完相信会对你的学习一定有帮助~
嵌入式工程师需要掌握的内容非常广泛，嵌入式可以说是当下最有前途的IT应用领域，小到电子词典、手机，大到航空航天设备都是典型的嵌入式系统，因此，通过嵌入式技术人才的职业发展空间是非常大的。要快速学习掌握技术我们要学会抓住重点，学会取舍，达到一通百通，事半功倍的学习效果。
近几年，嵌入式系统产品渐渐完善，并在全世界各行业得到广泛应用。2004年，全球嵌入式系统产品的产值已达2000亿美元，国内嵌入式软件的产值也达到600亿人民币。目前，嵌入式系统产品的研制和应用已经成为我国信息化带动工业化、工业化促进信息化发展的新的国民经济增长点。随着消费家电的智能化，嵌入式更显重要，像我们平常见到的手机、PDA、电子字典、可视电话、VCD/DVD/MP3 Player、数字相机（DC）、数字摄像机 （DV）、U-Disk、机顶盒（Set Top Box）、高清电视（HDTV）、游戏机、智能玩具、交换机、路由器、数控设备或仪表、汽车电子、家电控制系统、医疗仪器、航天航空设备等等，都是典型的嵌入式系统。据预测，随着Internet的迅速发展和廉价微处理器的出现，嵌入式系统将在日常生活里形成更大的应用领域。
嵌入式软件工程师学习路线详解及书籍推荐：
一、嵌入式软件编程的基础 这一阶段重点打好嵌入式软件编程的基础，包括学习Linux系统的基本应用，Linux的常用命令、C语言编程基础、常用的数据结构。
特别是C语言中对指针的理解和应用。这一阶段的主要目的是学习编程语言、开发环境、和培养自己的编程思维，为进一步学习嵌入式开发打下良好的基础。 必学内容有：Linux Ubuntu操作系统安装、使用、Linux常用命令、samba服务器、SSH远程登录GCC编译器、GDB调试器、VI编辑器
1、嵌入式C语言高级编程
1、C数据类型、控制语句
2、C程序结构设计、数组、函数、预处理:
3、指针及字符串操作
4、结构体、共用体、宏、枚举
5、文件I/O操作
推荐的嵌入式学习书籍：
《C程序设计语言》
《C语言核心技术》
《数据结构与算法分析－－C语言描述》
《C和指针》
《C陷阱与缺陷》
《C＋＋ Primer》 二、嵌入式设备及GUI开发
操作系统的嵌入式系统的构建，包括系统的启动流程熟悉使用。编写嵌入式环境配置与开发工具学习。这一阶段的主要目的是掌握带有操作系统的嵌入式系统的构建和烧写过程，以及对嵌入式系统软件的总体构成有个整体认识，为我们接下来学习嵌入式应用和驱动开发打下坚实的基础。
1、Linux下项目管理工具Make以及Makefile工作原理及其编写
2、Linux下shell脚本相关知识及其编写
3、嵌入式开发环境的基本概念及其搭建
4、A53开发板介绍、设备使用、A53开发板与电脑通信、交叉编译
GUI图形界面开发
1、常用控件——button、label、text edit等
2、常用布局方式——水平布局、垂直布局、固定布局、网格布局、相对布局等
3、常用事件及信号处理技术——信息回调、鼠标、键盘事件等
4、时间编程、数据存储、绘图机制、定时器处理、多任务处理等
这一阶段推荐的嵌入式学习书籍：
1、《Linux与Unix Shell 编程指南》 2、《嵌入式Linux应用程序开发详解》 三、嵌入式Linux高级程序设计
这一阶段主要学习上层的嵌入式Linux应用程序开发，包括基于Linux多进程、多线程、网络、文件与目录和QT编程。掌握嵌入式Linux环境下应用程序开发技术。嵌入式Linux系统编程。
1、Linux系统调用概念
2、进程相关概念、多进程实现多任务开发
3、进程间通信:无名管道、命名管道、信号、消息队列、共享内存等
4、多线程实现多任务开发
5、多任务的同步互斥开发：互斥锁、信号量
四、Linux高级网络程序设计
Linux高级网络编程
1、网络相关概念及网络发展
2、TCP/IP协议
3、socket编程、TCP网络编程、UDP网络编程、Web编程开发等
4、Linux网络应用程序开发，Linux网络编程相关API
5、TCP协议服务器的编程方法和并发服务器的实现
6、HTTP协议及其实现方法，熟悉UDP广播、多播的原理及编程方法，掌握混合C/S架构网络通信系统的设计
7、IPv6与IPv4协议，及其编程接口
8、网络数据通信过程
9、网络原始套接字概念及编程接口
这一阶段推荐的书籍： 《UNIX环境高级编程》
《Unix网络编程》
《Qt Creatｏｒ快速入门》
《精通Qt4编程》
《Linux设备驱动程序》
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9863d615cc5d2750bc0df15d2182bf72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82ed18c554ec6ca0b6b3138db0cbc4b8/" rel="bookmark">
			[Bug集合]terminate called after throwing an instance of &#39;std::bad_alloc&#39; what(): std::bad_alloc
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		terminate called after throwing an instance of 'std::bad_alloc’what(): std::bad_alloc
超内存了兄dei,我出现这个问题是因为读入了大量图片，结果系统提示这个信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c8e1cb882c6a13aa038263c5b118c60/" rel="bookmark">
			FCN制作自己的数据集并训练和测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这篇博客记录的是如何制作自己的数据集，并使用FCN模型训练数据，前提要搭建caffe框架，可以参考这篇博客，我制作的数据集是仿照voc2012数据集来在做的
制作图像标签 这一部分是最难的部分，在制作标签之前要搞清楚你的图像共分为几类
调整图像尺寸
将图像尺寸改为256*256，其实这一步可以不用操作，但是很多教程都有这一步，为了避免出错，所以最好执行这一步骤。 addpath('dealImg'); addpath('Img'); ListName=dir('Img\*.jpg'); [Pm,Pn]=size(ListName); for iPm=1:1:Pm %读取文件夹所有图片循环 oriImg=imread(ListName(iPm).name); %readImg cutImg=imresize(oriImg,[256,256]); %把ai转成256x256的大小 iDealName=ListName(iPm).name; iDealAddress='dealImg\'; iDealAll=strcat(iDealAddress,iDealName); ID=imresize(cutImg,1); imwrite(ID,iDealAll); end 制作索引图（即标签）
这就是最难也是最烦的部分，很多博客都说用labelme工具制作标签，这工具确实方便，但是我试了之后才发现会出现问题，比如说第一张图片有汽车，有小猫，这是两个不同的类将会标注为两个不同的颜色，如果第二张图片没有汽车只有小猫的话，那这张图片小猫将会和汽车标注成同一张颜色。可能我这样解释会有点蒙，你可以参考labelme安装和json批量转化数据两篇博客试试，有人解释说是因为labelme的版本变高自动生成颜色，但是并没有给出解决办法，于是在这一步的操作我选择了使用photoshop工具。
对应的voc数据集颜色类别为：
类别名称 R G B
background 0 0 0 背景
aeroplane 128 0 0 飞机
bicycle 0 128 0
bird 128 128 0
boat 0 0 128
bottle 128 0 128 瓶子
bus 0 128 128 大巴
car 128 128 128
cat 64 0 0 猫
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c8e1cb882c6a13aa038263c5b118c60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87a07b01fa364040e1282528e410644e/" rel="bookmark">
			Spring-Session基于Redis管理Session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在上文Tomcat Session管理分析介绍了使用tomcat-redis-session-manager来集中式管理session，其中一个局限性就是必须使用tomcat容器；本文介绍的spring-session也能实现session的集中式管理，并且不局限于某种容器；
spring-session管理session实战 1.maven依赖的jar &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.3.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;biz.paluch.redis&lt;/groupId&gt; &lt;artifactId&gt;lettuce&lt;/artifactId&gt; &lt;version&gt;3.5.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2.准备spring-session.xml配置文件 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--支持注解 --&gt; &lt;context:annotation-config /&gt; &lt;bean class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration" /&gt; &lt;bean class="org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory"&gt; &lt;property name="hostName" value="localhost" /&gt; &lt;property name="port" value="6379" /&gt; &lt;/bean&gt; &lt;/beans&gt; session同样是使用redis来做集中式存储，为了方便测试使用本地的6379端口redis，LettuceConnectionFactory是redis连接工厂类；
RedisHttpSessionConfiguration可以简单理解为spring-session使用redis来存储session的功能类，此类本身使用了@Configuration注解，@Configuration注解相当于把该类作为spring的xml配置文件中的，此类中包含了很多bean对象同样也是注解@Bean；
3.准备servelt类 public class SSessionTest extends HttpServlet { private static final long serialVersionUID = 1L; public SSessionTest() { super(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87a07b01fa364040e1282528e410644e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/651d7e70184bbe1971230190d96a92a2/" rel="bookmark">
			Android studio 3 添加ButterKnife
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android studio 3 添加ButterKnife 当Android studio 升级到3.0以上的时候，原先的添加ButterKnife的方式就不行了。今天将新的添加方式记载一下，虽然有时效性，但是记录是最好的复习方式。ps：终于有时间将自己一段时间内遇到的问题或者学习到的东西记录分享了。
项目gradle中的配置 在buildscript中的dependencies中添加
classpath "com.jakewharton:butterknife-gradle-plugin:8.8.1"
buildscript { repositories { google() jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.2.1' classpath "com.jakewharton:butterknife-gradle-plugin:8.8.1" // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } 在app里面的build.gradle中添加 implementation 'com.jakewharton:butterknife:8.8.1' implementation 'com.jakewharton:butterknife-compiler:8.8.1' 在app里面的build.gradle中配置 defaultConfig { applicationId "com.topwise.database" minSdkVersion 15 targetSdkVersion 27 versionCode 1 versionName "1.0" /*添加配置*/ testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" javaCompileOptions { annotationProcessorOptions { includeCompileClasspath = true } } } 最后Sync就可以了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f013818f246c9ea1b05fbbf0534e84c2/" rel="bookmark">
			centos7 firewall(防火墙)常用设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 firewall设置
1.关闭：systemctl stop firewalld 或者systemctl stop firewalld.service（之后的.service方式略）
开启（重启）：systemctl start(restart) firewalld 状态查看：systemctl status firewalld 或者 firewall-cmd --state
设置为开机自启：systemctl enable firewalld
禁用防火墙：systemctl disablefirewalld
是否开机自启：systemctl is-disabledfirewalld
2 firewalld开放，关闭端口
开启了防火墙之后，你会发现不能再访问部署到服务器上的网站了。这时需要我们开放服务器的端口。centosh 7新特性引入了zone的概念。
查看开放的端口：firewall-cmd --zone=public --list-ports
添加开放端口：firewall-cmd --zone=public --add-port=3306/tcp --permanent （添加成功显示success）
注：--permanent加上之后是永久有效不会重启失效
重载起效：firewall-cmd --reload
关闭端口：firewall-cmd --zone=public --remove-port=3306/tcp --permanent
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8f17623a2f08b886e5872cfb2dbc73/" rel="bookmark">
			以太坊虚拟机EVM执行原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以太坊虚拟机简介 以太坊虚拟机（environment virtual machine，简称EVM），作用是将智能合约代码编译成可在以太坊上执行的机器码，并提供智能合约的运行环境。它是一个对外完全隔离的沙盒环境，在运行期间不能访问网络、文件，即使不同合约之间也有有限的访问权限。
尽管区块链是可编程的，但是由于其脚本系统支持的功能有限，基于区块链做应用开发是一件很有难度的事情。而以太坊是基于区块链底层技术进行封装，完善，其中很重要的一个革新就是以太坊虚拟机及面向合约的高级编程语言solidity，这使得开发者可以专注于应用本身，更方便、快捷的开发去中心化应用程序，同时也大大降低了开发难度。
以太坊EVM的特点 EVM是一种基于栈的虚拟机（区别于基于寄存器的虚拟机），用于编译、执行智能合约EVM是图灵完备的（图灵完备是指：具有无限存储能力的通用物理机器或编程语言，简单来说就是可以解决一切可计算的问题）EVM是一个完全隔离的环境，在运行期间不能访问网络、文件，即使不同合约之间也有有限的访问权限操作数栈调用深度为1024机器码长度一个字节，最多可以有256个操作码 什么是基于栈的虚拟机 以太坊虚拟机是一种基于栈的虚拟机，所以要弄清以太坊虚拟机原理，我们就必须了解什么是基于栈的虚拟机。首先我们来介绍下虚拟机需要实现的功能：
取指令，其中指令来源于内存译码，决定指令类型（执行何种操作）。另外译码的过程要包括从内存中取操作数执行。指令译码后，被虚拟机执行（其实最终都会借助于物理机资源） 虚拟机分为两种：基于栈的虚拟机和基于寄存器的虚拟机。基于栈的虚拟机有几个重要的特性：实现简单、可移植，这也是为什么以太坊选择了基于栈的虚拟机。
在基于栈的虚拟机中，有个重要的概念：操作数栈，数据存取为先进先出。所有的操作都是直接与操作数栈直接交互，例如：取数据、存数据、执行操作等。这样有一个好处：可以无视具体的物理机器架构，特别是寄存器，但是缺点也很明显，速度慢，无论什么操作都需要经过操作数栈。
我们举个简单的例子来说明基于栈的虚拟机是如何执行操作的，例如我们需要执行a = b + c的运算，那么在基于栈的虚拟机上会编译生成类似于下面的字节码指令：
I2: LOAD b I1: LOAD c I3: ADD I4: STORE a 具体的执行流程为：
从内存中加载变量b到操作数栈从内存中加载变量c到操作数栈从操作数栈弹出前两个元素，执行累加将计算后的数值压入栈顶将栈顶的数值取出放入内存中 以太坊虚拟机如何执行智能合约 上面我们简单介绍了基于栈的虚拟机是如何执行操作的，以太坊虚拟机的执行过程也是类似，我们来详细介绍下。以如下的智能合约为例
pragma solidity ^0.4.0; contract test { uint public c; function add(uint a) public returns (uint){ uint b = 100; c = a + b; return c; } } 使用solc编译编译该文件，执行命令为：solc --asm test.sol，生成的字节码如下，示例使用的solc版本为0.4.25，solc版本不同编译后的字节码也可能会有所差异
接下来我们使用stack:[]表示操作数栈，左侧是栈顶，store:{}表示局部变量表。这里我们以add函数为例，来解析EVM执行过程，由于编译后的内容很多，我们只截取add函数对应的字节码
======= test.sol:test ======= EVM assembly: /* "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e8f17623a2f08b886e5872cfb2dbc73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1b38a2b90ec20f6152d0f532d128261/" rel="bookmark">
			贝叶斯分析：抛硬币的概率真的是1/2吗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
前面两文介绍了贝叶斯学派的思想和先验分布、后验分布的相关知识，古典频率学派认为抛硬币的概率是常数，本文从贝叶斯学派的角度看待抛硬币的概率问题。本文详细介绍了 β分布，重述贝叶斯思想，对于抛硬币的概率问题作各种情况的分析，最后总结本文。
目录
1、为什么选择β分布作为先验分布
2、重述贝叶斯思想
3、抛硬币问题的多情况分析
4、总结
1、为什么选择β分布作为先验分布
本节详细介绍β分布的定义及解释选择β分布作为先验分布的原因。
1、β分布
β函数的定义：
其中α，β &gt; 0，对等式两边各除以B(α,β)，字母p代替x，得：
选积分项作为β分布函数，由积分项可知β分布已完成标准化（总积分等于1）。
因此，β分布：
β分布的期望和方差：
2、β分布作为先验分布的原因
由β分布定义可知，β分布是概率分布的分布，β分布常作为先验分布的原因：
（1）、贝叶斯对参数的估计与先验分布的选择有很重要的关系，先验分布不同，贝叶斯对参数的估计也不同。先验分布往往是人们根据以往经验去设计，β分布是概率分布的分布，涵盖了所有参数空间出现的概率大小，并通过设置参数α和β，可以使先验分布与你的先验经验基本符合。
i) α=1，β=1
由上图可知，α=1，β=1，β分布符合均匀分布，即参数空间所有取值的概率相等。
因此，当你对参数没有任何的先验知识时，建议你假设先验参数符合均匀分布，参数的后验分布由你的实际观测数据决定。
ii) α=10，β=10
由上图可知，α=10，β=10时，β分布符合高斯分布，且在概率为0.5取得最大值，由β分布期望和方差的公式可知期望和方差分别等于0.5和0.01。
假设参数的先验分布是高斯分布，设置参数α和β相等（α&gt;1）使β分布成为高斯分布，α越大方差越小。
因此，设置α和β使参数的先验分布符合你对参数的先验认知。
（2）、上节已提到，参数的先验分布是β分布时，则先验分布和后验分布形式一样，且可以形成先验链，方便分析问题。
2、重述贝叶斯思想
因人而异，因阅历而异
关于频率学派和贝叶斯学派对频率的理解可以参考我前面的文章《浅谈频率学派和贝叶斯学派》。
贝叶斯思想是量化事件发生的不确定性，是主观评价。不同人评价同一事件发生的概率不同，因为不同人的生活经历不同，对某一事件的先验知识很可能不同，比如一个博士生和一个小学生对某一事件的看法可能不同；同一个人对同一事件发生的概率也随着自身阅历的增加而不同，例如某个人做了九件好事，你评估他是好人的概率为0.9，当他做了一件大逆不道的事情后，你评估他是好人的概率降到了0.1。贝叶斯评价事件发生的概率带有主观性，因人而异，因阅历而异。
凡事要讲数据
我们根据自己的阅历对某一事件作一个先验假设，先验假设是否正确需要经过时间的检验，即是否有足够多的观测数据符合先验假设。先验假设和观测数据是影响后验假设的两个因素，若观测数据不符合先验假设，则后验假设在先验假设的基础上开始向观测的数据偏斜，若观测的数据为无穷大时，则先验假设可以忽略不计，直接通过观测数据来估计后验假设。因此，贝叶斯思想评价事件发生概率的准则是凡事要讲数据。
PS：有点绕口，希望大家看完笔者介绍抛硬币的例子，再来悟一悟这几句话，若还有疑问请微信我
3、抛硬币问题的多情况分析
抛硬币问题的公式说明
由于《浅谈先验分布和后验分布》已经通过例子推导了抛硬币正面向上的后验概率，因此，本文不做推论，具体可参考上篇文章，若有疑问请微信我。本文只引用一些结论性的公式。
假设硬币正面向上的概率为u，正面向上记为1，反面向上记为0。
则硬币正面向上的先验分布如下：
硬币正面向上的期望：
其中a，b表示虚拟的硬币正面向上的次数和反面向上的次数，根据自己的先验知识来设置a，b值。
若后续的观测结果为m次正面向上，l次反面向上，共N次。
则硬币正面向上的后验分布如下：
硬币为正面向上的概率：
多情况的抛硬币问题
（1）第1次抛硬币为正面向上的概率；
（2）9次硬币正面向上，1次反面向上，第十一次硬币正面向上的概率；
（3）90次硬币正面向上，10次硬币反面向上，求101次正面向上的概率；
（4）900次硬币正面向上，100次硬币反面向上，求第1001次硬币正面向上的概率。
解：
贝叶斯的后验分布受先验分布的影响，不同的先验分布会有不同的后验分布。请参考第一节，假设硬币正面向上的分布符合高斯分布（a=10，b=10），高斯分布符合大部分人的思想，认为硬币为正面向上的概率在0.5达到最大，方差表示先验分布的确定程度，若你坚信硬币向上的概率肯定是0.5，那么可以调大a和b值。
作者就先验分布为高斯分布来解答抛硬币的四个问题。其他先验分布可通过调节a，b的值来实现，后面的计算过程一致。
正面向上的后验概率：
a，b，m，l分别表示先验分布的正面向上次数，反面向上次数，已观测数据的正面向上次数，反面向上次数。
先验分布为高斯分布：
（1）由于没有任何观测数据，因此第一次正面向上的分布为先验分布，先验分布在在参数为0.5时，概率最大，即正面向上的概率为0.5。
（2）正面向上的概率为：
（3）计算过程与（2）一样，正面向上的概率：0.83
（4）正面向上的概率：0.89
讨论：
频率学派认为硬币向上的概率是0.5，与观测数据无关。贝叶斯学派是通过数据来主观评价硬币向上的概率，由例子可知，即使先验分布符合高斯分布且正面向上的概率在0.5达到最大，但是如果观测数据倾向于正面向上，则最终的判断结果会倾向于正面向上，贝叶斯思想有点像是风往哪边吹树就往哪边倒的意思。当观测结果的正面向上次数远远大于正面向下次数，也远远大于先验分布的正面向下次数，则判断下次为正面向上的概率无限接近1（若不理解请参考公式）。
4、总结
本文首先详细介绍了β分布，通过调节参数a和b使β分布符合假设的先验分布，β分布使后验分布和先验分布为共轭分布，形成先验链，便于分析问题。后面讲的内容是贝叶斯思想，贝叶斯是主观评价事件发生的概率，根据先验知识来假设先验分布，若观测的数据符合先验分布，则后验分布与先验分布类似；若观测的数据不符合先验分布，则后验分布开始向观测数据倾斜，若观测数据为无穷大时，那么前验分布可以忽略不计，最大似然函数估计参数与后验分布估计参数相同，直接可以用最大似然函数来估计参数。
参考：
Christopher M.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1b38a2b90ec20f6152d0f532d128261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cecf78fbe79c062a771ae109878ca32a/" rel="bookmark">
			浅谈先验分布和后验分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【前言】
上文提到贝叶斯定理是先验分布和后验分布转换的桥梁，贝叶斯学派计算参数后验分布的难点在于如何选择参数的先验分布，本文通过二项式分布的例子来形象的表达如何选择先验分布和计算后验分布，并阐述了先验分布和后验分布是如何转换的，最后对本文进行总结。
共轭先验分布
定义
当先验分布和后验分布相同时，先验分布和后验分布为共轭先验。
条件
为了满足共轭先验这一条件，先验分布和似然函数分布应相同。
目的
先验分布和后验分布按照人的直观来说应是相同的，且可以形成一个先验链，即随着新观测数据的增加，当前参数的后验分布成为前验分布，新观测数据下的参数分布为后验分布。
先验分布和后验分布的转化过程
连续采样新的观测数据时，当前参数的概率分布为先验分布，计算新采集的数据（可能是一个或一组）的似然函数，计算先验分布和似然函数的乘积，并对该乘积结果进行归一化，得到参数的后验分布，若又有新的观测数据时，则重复以上过程，更新参数的后验分布。
先验分布和后验分布关系的应用举例
【例】用一个二值随机变量x表示抛硬币的结果，1表示正面，0表示反面。假设该硬币的正反两面的概率不相同，且正面概率为参数u，若抛掷N次，正面向上的次数为m，反面向上的此时为l。求（1）参数u的后验概率分布，（2）若连续抛掷硬币，求先验分布和后验分布参数的关系，（3）正面向上的概率
解：（1）多次抛硬币符合二项式分布，正面向上次数为m的概率为：
为了满足共轭先验的条件，参数u的先验分布也应与似然函数的分布相同。即选择参数u的先验分布为beta分布，如下：
等式右边的系数部分是为了满足先验分布的标准化，即：
参数u的先验分布的期望：
后验分布等于前验分布和似然函数的乘积，并对该结果进行标准化，得到该参数的后验分布。
后验分布形式：
标准化后的结果：
（2）连续抛掷硬币时，当前的参数分布为先验分布，与新采样数据的似然函数进行乘积，再对该结果进行标准化。容易知道，后验分布的形式保持不变，指数发生变化。
比较数据集似然函数的二项式分布和beta分布，可知a表示正面向上的次数，b表示反面向上的次数，由（1）的后验概率分布可知，当新数据的抛掷结果为m次正面向上，l次反面向上，那么后验概率分布的指数表示m+a次正面向上，l+b次反面向上，以此递推。
若a=1，b=1，参数u的先验分布为：
当观测新数据为1次正面向上(m=1)，2次反面向上(l=2)，则后验分布的指数表示2次正面向上，3次反面向上。
后验分布如下图：
（3）根据贝叶斯的求和准则与求积准则，参数u的分布采用后验分布，得：
参考先验分布的参数u的期望，可得后验分布：
总结
后验分布等于先验分布与似然函数乘积的标准化，共轭先验的目的在于使先验分布和后验分布保持同一形式，形成先验链，当有新的观测数据时，当前的分布成为先验分布，重新计算参数的后验分布。
参考：
Christopher M.Bishop &lt;&lt;Pattern Reconition and Machine Learning&gt;&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df764dfb3be111f0ecea57569cb0c6c6/" rel="bookmark">
			偏度与峰度的正态性分布判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们应用统计方法对数据进行分析时，会发现许多分析方法如T检验、方差分析、相关分析以及线性回归等等，都要求数据服从正态分布或近似正态分布，正态分布在机器学习的重要性后期会讲述。上一篇文章用Q-Q图来验证数据集是否符合正态分布，本文首先介绍了偏度与峰度的定义，然后用偏度与峰度检测数据集是否符合正态分布，最后分析该检测算法的适用条件以及SPSS的结果分析。
1、 偏度与峰度
（1） 偏度（Skewness）
偏度衡量随机变量概率分布的不对称性，是相对于平均值不对称程度的度量，通过对偏度系数的测量，我们能够判定数据分布的不对称程度以及方向。
具体来说，对于随机变量X，我们定义偏度为其的三阶标准中心距:
对于样本的偏度，我们一般记为SK，我们可以基于矩估计，得到有：
偏度的衡量是相对于正态分布来说，正态分布的偏度为0，即若数据分布是对称的，偏度为0。若偏度大于0，则分布右偏，即分布有一条长尾在右；若偏度小于0，则分布为左偏，即分布有一条长尾在左（如下图）；同时偏度的绝对值越大，说明分布的偏移程度越严重。
【注意】数据分布的左偏或右偏，指的是数值拖尾的方向，而不是峰的位置。
（2） 峰度（Kurtosis）
峰度，是研究数据分布陡峭或平滑的统计量，通过对峰度系数的测量，我们能够判定数据相对于正态分布而言是更陡峭还是平缓。比如正态分布的峰度为0，均匀分布的峰度为-1.2（平缓），指数分布的峰度为6（陡峭）。
峰度，定义为四阶中心距除以方差的平方减3。
若峰度≈0，分布的峰态服从正态分布；
若峰度&gt;0，分布的峰态陡峭（高尖）；
若峰度&lt;0，分布的峰态平缓（矮胖）；
2、 正态性检验
利用变量的偏度和峰度进行正态性检验时，可以分别计算偏度和峰度的Z评分（Z-score）。
偏度Z-score = 偏度值 ÷偏度值的标准差
峰度Z-score = 峰度值 ÷峰度值的标准差
在α=0.05的检验水平下，偏度Z-score和峰度Z-score是否满足假设条件所限制的变量范围，若都满足则可认为服从正态分布，若一个不满足则认为不服从正态分布。
3、 正态性检验的适用条件
样本的增加会减小偏度值和峰度值的标准差，相应的Z-score会变大，最终会拒绝条件假设，会给正确判断样本数据的正态性情况造成一定的干扰。因此，当样本量小于100时，用偏度和峰度来判断样本的正态分布性比较合理。
4、 SPSS结果分析
峰度Z-score = 5.166/0.425 &gt; Z(α)，α=0.05；因此该特征不符合正态分布。
参考：
https://www.sohu.com/a/125526669_609133
https://www.sohu.com/a/140979052_489312
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa3659df9aa78a72ebf02b68982b8fe3/" rel="bookmark">
			5.6.3 高通滤波（理想高通滤波&#43;巴特沃斯高通滤波）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.理想高通滤波器
高通滤波与低通滤波正好相反，是频域图像的高频部分通过而抑制低频部分。在图像中图像的边缘对应高频分量，因此高通滤波的效果是图像锐化。同样最简单的高通滤波器是理想高通滤波器。通过设置一个频率阈值，将高于该阈值的频率部分通过，而低于阈值的低频部分设置为0。
VTK中理想高通滤波的实例如下：
/* ******理想高通滤波********** */ #include &lt;vtkSmartPointer.h&gt; #include &lt;vtkJPEGReader.h&gt; #include &lt;vtkImageFFT.h&gt; #include &lt;vtkImageIdealHighPass.h&gt; #include &lt;vtkImageRFFT.h&gt; #include &lt;vtkImageCast.h&gt; #include &lt;vtkImageExtractComponents.h&gt; #include &lt;vtkRenderer.h&gt; #include &lt;vtkImageActor.h&gt; #include &lt;vtkRenderWindow.h&gt; #include &lt;vtkRenderWindowInteractor.h&gt; #include &lt;vtkInteractorStyleImage.h&gt; int main() { vtkSmartPointer&lt;vtkJPEGReader&gt; reader =vtkSmartPointer&lt;vtkJPEGReader&gt;::New(); reader-&gt;SetFileName("data\\lena-gray.jpg"); reader-&gt;Update(); vtkSmartPointer&lt;vtkImageFFT&gt; fftFilter = vtkSmartPointer&lt;vtkImageFFT&gt;::New();//将图像域转换到频域空间 fftFilter-&gt;SetInputConnection(reader-&gt;GetOutputPort()); fftFilter-&gt;Update(); vtkSmartPointer&lt;vtkImageIdealHighPass&gt; highPassFilter = vtkSmartPointer&lt;vtkImageIdealHighPass&gt;::New(); highPassFilter-&gt;SetInputConnection(fftFilter-&gt;GetOutputPort());//定义图像高通滤波对象 highPassFilter-&gt;SetXCutOff(0.1);//设置X和Y方向的截止频率 highPassFilter-&gt;SetYCutOff(0.1); highPassFilter-&gt;Update(); vtkSmartPointer&lt;vtkImageRFFT&gt; rfftFilter = vtkSmartPointer&lt;vtkImageRFFT&gt;::New();//将处理后的图像转换到空域中 rfftFilter-&gt;SetInputConnection(highPassFilter-&gt;GetOutputPort()); rfftFilter-&gt;Update(); vtkSmartPointer&lt;vtkImageExtractComponents&gt; ifftExtractReal = vtkSmartPointer&lt;vtkImageExtractComponents&gt;::New(); ifftExtractReal-&gt;SetInputConnection(rfftFilter-&gt;GetOutputPort()); ifftExtractReal-&gt;SetComponents(0);//提取实部分量 vtkSmartPointer&lt;vtkImageCast&gt; castFilter = vtkSmartPointer&lt;vtkImageCast&gt;::New();//数据类型转换 castFilter-&gt;SetInputConnection(ifftExtractReal-&gt;GetOutputPort()); castFilter-&gt;SetOutputScalarTypeToUnsignedChar(); castFilter-&gt;Update(); / vtkSmartPointer&lt;vtkImageActor&gt; originalActor = vtkSmartPointer&lt;vtkImageActor&gt;::New(); originalActor-&gt;SetInputData(reader-&gt;GetOutput()); vtkSmartPointer&lt;vtkImageActor&gt; erodedActor = vtkSmartPointer&lt;vtkImageActor&gt;::New(); erodedActor-&gt;SetInputData(castFilter-&gt;GetOutput()); / double leftViewport[4] = { 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa3659df9aa78a72ebf02b68982b8fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/174753c785bbc66158c7988f7227f3ac/" rel="bookmark">
			int()是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天读代码读到这么一条代码datum = std::vector&lt;int&gt;(size, int());一开始我是看不懂的，为什么int后面要加括号？
结果上网查阅，才明白原来int()的意思是调用了int的默认构造函数，所以返回值应该是0. 这个可以类比一个类，类名 +（）就是调用这个类的默认构造函数。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/442/">«</a>
	<span class="pagination__item pagination__item--current">443/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/444/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>