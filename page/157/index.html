<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92fdae3cf132bdaf5e318c3dbe153d16/" rel="bookmark">
			base64和在线url链接转为MultipartFile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.base64转为MultipartFile
import org.apache.commons.codec.binary.Base64; import org.springframework.web.multipart.MultipartFile; import java.io.*; public class Base64ToMultipartFileConverter { public static MultipartFile base64ToMultipartFile(String base64) { //base64编码后的图片有头信息所以要分离出来 [0]data:image/png;base64, 图片内容为索引[1] String[] baseStrs = base64.split(","); //取索引为1的元素进行处理 byte[] b = Base64.decodeBase64(baseStrs[1]); for (int i = 0; i &lt; b.length; ++i) { if (b[i] &lt; 0) { b[i] += 256; } } //处理过后的数据通过Base64DecodeMultipartFile转换为MultipartFile对象 return new Base64DecodeMultipartFile(b, baseStrs[0]); } } class Base64DecodeMultipartFile implements MultipartFile { private final byte[] imgContent; private final String header; public Base64DecodeMultipartFile(byte[] imgContent, String header) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92fdae3cf132bdaf5e318c3dbe153d16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34821b25d25448c29cb8abe8b134354e/" rel="bookmark">
			202203 word中的表格 实现 外框线粗 内部线细
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		被自己蠢爆了，研究了好久，终于搞出来了
word中的表格 实现 外框线粗内部线细
先在word中选中单元格
右击–边框和底纹
1 边框选项卡-方框 （表示上下左右），把宽度设置成 1磅，然后可以先确定，看下效果
2. 边框选项卡-自定义，把宽度减小，然后 附加选中 横线 和 竖线 （所有线，都是0.5）
特此记录。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b18894cb66d895d892fd7c542f0d2167/" rel="bookmark">
			antd RangePicker组件结合Form每次打开（onOpenChange）并未清除组件中的日期、关闭后也不能正确赋值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.onOpenChange打开后不能清空组件中的日期
原因：虽然RangePicker中的值清空，但是form中RangePicker的值未清空
解决：form.setFieldsValue({ date: [null, null] });
2.onOpenChange关闭时，赋不上最新的值，导致每次关闭后都赋上一次的value值；
解决：form.setFieldsValue({ date: value }); 方法一：const date = form.getFieldValue('date');
if (!date || !date[0]) form.setFieldsValue({ date: value });
方法二：setTimeout(()=&gt;{
form.setFieldsValue({ date: value });
},1)
链接：选择不超过七天的范围 - antd@4.24.8 - StackBlitz
import React, { useState, useEffect } from 'react'; import 'antd/dist/antd.css'; import './index.css'; import { DatePicker, Form } from 'antd'; import { Moment } from 'moment'; const { RangePicker } = DatePicker; const App: React.FC = () =&gt; { const [dates, setDates] = useState(null); const [value, setValue] = useState(null); const [form] = Form.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b18894cb66d895d892fd7c542f0d2167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/588c859d1f7facbf83e9e1e10350a882/" rel="bookmark">
			TypeScript 介绍及使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Typescript 它不是一门语言，是js的超集，它包含了目前的es5标准，也包含了未来的es6\7\8的标准
还提供了很多后端的功能，比如静态类型检查，接口，泛型等。
主要给js带来了强类型定义的实际功能，相当于在原生js上加了一层类型定义
它不能直接运行在浏览器，需要通过tsc编译成js
ts的编译器叫tsc,就像es6的编译器叫babel
扩展 es3\es5目前支持所有浏览器 es6=es2015，es7=es2016，es8=2017，目前浏览器不支持，需要转换 Typescript作用好处 可以提供静态类型检查，对IDE有友好提示，规范代码编写，在代码编译阶段就能及时发现错误
比如：最常见的加法运算，当我们传入字符串类型代码也能正常运行，只是结果变成了字符串拼接而不是加法运算，这就是js的缺点，如果有了Ts的存在，就会检查类型，如果不是数字类型就会报错
配置TS运行环境 通过npm安装 命令：npm install -g typescript
ts官方文档中强调，要使用let const 去声明变量，避免使用var关键字
理论基础 TS变量：数字 字符串 数组 元组联合枚举（enum）any unknown void never类型适配(类型断言) 函数类型泛型 class interface module 实际演示 基本数据类型
function add (num1: number, num2: number) =&gt;{} let isTrue:boolean = true let name:string = "" 数组
他们表示数组类型，并且数组里的元素都是数字
let list1:number[] = [1,2,3,4] 这种是泛型的写法
let list2:Array&lt;number&gt; = [1,2,3,4] let list3:any[] = [1,'3', [1]] 元祖 tuple
元祖是，固定长度，固定类型，固定位置，的特殊数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/588c859d1f7facbf83e9e1e10350a882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d14fb89125f56ff8f4764f717cc17db/" rel="bookmark">
			CentOS 7配置NFS文件共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NFS文件共享 实验环境：两台Centos7 Centos7服务端IP地址:192.168.10.1 Centos7客户端IP地址:192.168.10.2 服务端配置：
安装服务
yum install rpcbind -y #安装rpcbind服务 yum install nfs-utils.x86_64 -y #安装nfs服务 修改配置文件
mkdir /data/share #创建共享文件 vim /etc/exports #修改配置文件 /data/share 192.168.10.*(rw,sync,root_squash) 配置文件 /data/share是共享文件夹 192.168.10.*是共享的网断 rw是读写 sync是同时将数据写入到内存与硬盘中，保证不丢失数据 root_squash是NFS客户端以root管理员访问时，映射为NFS服务器的root管理员 配置文件格式为:[文件共享路径]+[共享网断]+[共享权限] 重启服务：重启服务的顺序是先rpcbind后nfs服务
systemctl restart rpcbind.service #重启rpcbind服务 systemctl restart nfs-server.service nfs.service #重启nfs服务 客户端配置:
yum install showmount -y #安装测试命令 mkdir /gzs #创建挂载点文件 chmod 777 /gzs #给所有权限 vim /etc/fstab #写入开机自启文件 192.168.10.1:/data/share /gzs nfs defaults 0 0 开机自启挂载文件格式为: [服务端IP地址][共享文件夹]+[挂载文件夹] [文件系统格式] [默认挂载] 域名挂载
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d14fb89125f56ff8f4764f717cc17db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b068522ce2f3ee45fc3a1326b2367d8d/" rel="bookmark">
			【超详细】初探FME--获取等时圈
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在规划分析过程中，往往会涉及等时圈的概念。什么是等时圈呢？小编帮你百度过了，网上的说法是：等时圈是指从某点出发，以某种交通方式在特定时间内能到达的距离覆盖的范围。比如我们在规划设计中接触到的15分钟生活圈就是等时圈的一个具象应用。说到这里有朋友就疑惑了，我们怎么去获取等时圈呢？获取等时圈的方法有很多种，最常见的就是以下几种：
（一）无中生有，自给自足。
自给自足，很明显就是自己生成。当然，巧妇难为无米之炊，因此我们必须要准备一些 基础数据，包括道路矢量数据以及我们的设施点，而煮饭的工具小编推荐用ArcGIS网络分析工具中的服务区分析。具体步骤可以参考这一篇文章（设施服务区分析——5分钟服务范围）。但这种方法对数据基础的要求很高，路网构建得越接近现实，分析结果越精确，但在实际过程中很难保证我们的路网能百分百模拟真实路况，因此我们需要借助大数据平台的算法，来尽可能获取最接近实际的结果，例如百度地图、高德地图、mapbox等在线地图平台。
（二）站在巨人的肩膀上，拿来吧你。
今天小编主要介绍一下用FME来获取高德地图等时圈的思路和具体步骤，主要参考这一篇博客https://blog.csdn.net/fmechina/article/details/105566627，这篇博客的思路非常清晰，但是很多细节都没有展现出来，本期小编就帮大家翻译一下，让这篇推文变得更加的通俗易懂。悄悄告诉你，后台回复“等时圈”获取模板。
进入主题
【整体思路】
1.构建起点坐标对并创建用户参数；
2.构建终点坐标对；
3.发送调用服务请求并解析JSON
4.创建等时圈并导出为shp 【具体步骤】
接下来我们以长沙火车站15分钟等时圈为例，来具体认识一下FME在获取网络数据中的魅力。本篇教程主要针对的是像我一样的小白，所以我会在流程中先讲解每一步的思路，再一一介绍我们用到的转换器，因此篇幅稍微长一点。
1
构建起点坐标和创建用户参数
首先新建几个必要的用户参数。用户参数（user parameters）是FME为用户提供的参数，是为最终用户使用工作空间提供的输入接口。通俗一点讲，这些参数是贯穿整个程序的，因此我们提前准备好。我们只需右键导航窗口（Navigator）下的用户参数（user parameters），在弹出窗口中填入参数名称、别名、勾选必填，设置默认值为500（也可不设，不设的情况下在运行程序时会提醒设置）。依次添加OriginLonLat（起点经纬度）、Radius（预估半径）、Grid（网格密度）、Amap_Key（高德密钥）、Transportation（出行方案）等必填参数。其中，Amap_Key（高德密钥）需要去高德地图API控制台申请。
其次在高德地图坐标拾取器https://lbs.amap.com/tools/picker中搜索我们的分析对象坐标，比如长沙火车站，将获取到的坐标复制到OriginLonLat（起点经纬度）参数中去。
【Creator】用提供的参数来创建要素，并将这些要素发送到工作空间中进行处理。
【ParameterFetcher】给要素添加一个属性并用先前发布的参数赋值。这里我们主要是为了获取用户参数到要素中。
【AttributeSplitter】把选择的属性分离成一个属性列表。列表中的每一项都包含一个从列表中分离出的单个令牌。例如，你可以用这个转换器，把一个含有分隔逗号列表的属性分离成其组件。这一步主要是为了将起始点坐标对隔开存入列表中备用。
【VertexCreator】将坐标附加到空（Null）、点、文本、线和弧等几何对象上，或者用点对象替换现有图形对象。这一步就是为了创建起点要素。
2
构建终点坐标对
构建终点坐标对的思路是基于我们的起点创建一个大致的缓冲区作为预估范围，缓冲区半径是根据我们分析需求来确定（比如我们想要获取15分钟骑行等时圈，则根据15分钟骑行大约3000米的标准来确定阈值），其次是在这个缓冲区范围内创建一个网格，提取其网格中心点作为出行的终点，网格的大小决定了等时圈的精度，但受调用次数的限制，我们退而求其次尽量取合适的精度。
【EsriReprojector】使用ESRI重投影库，把要素的坐标系重投影到另一个坐标系统。这里是因为后面创建缓冲区和网格的时候需要在平面坐标系下进行。
【Bufferer】在输入几何对象周围或内部创建指定大小的缓冲区。
【2DGridCreator转换器】用一个由二维点或者矩形形成的网格取代原来的输入要素，这些网格有指定的间距且覆盖所有进入此转换器的要素的整体外接区域。这里我们主要用于创建网格。
【SpatialFilter】根据空间关系过滤点、线、面或文字等要素。每个输入候选（CANDIDATE）要素与所有过滤（FILTER）要素进行比较，基于给定的空间测试条件来判断是否满足。这里主要用于提取缓冲区范围内的网格，可大幅减少后面调用高德服务的次数。
这一步将投影转换回WGS84是为了提取十进制度坐标值（高德地图采用的是火星坐标，火星坐标系是在GSP原始定位数据的基础上经过加密算法加密之后的定位数据所属坐标系，GSP原始定位数据所属坐标系叫WGS－84坐标系，WGS－84坐标系是美国国防制图局于1984建立的世界大地坐标系(World Geodetic System)的简称，出于安全考虑，我国国家测绘局规定国内必须对原始GSP数据进行加密，加密之后的坐标系就是GCJ-02坐标系，又叫火星坐标系。）
【CenterPointReplacer】用几何要素的中心点替换几何要素，该点或者位于要素范围的中心，或者位于要素的质心。这一步是为了生成网格中心点，将其作为路径的终点。
【CoordinateRounder】将要素坐标舍入到指定的小数位数。由于舍入而成为重复的任何连续点都将通过删除多余的点来细化。这一步是为了满足高德地图调用服务的条件（经纬度小数点不超过6位）。
【CoordinateExtractor】按指定的索引检索坐标点XYZ值存储到属性字段中。这里是为了将终点的XY值提取到属性表中。到此完成终点构建。
3
构建URL、调用服务并解析结果
完成起点和终点的构建后，就可以开始正式请求高德地图的服务了，模板如下。
【AttributeCreator】给要素添加若干属性，并通过常量、属性值、表达式为属性赋值。属性值可以参考相邻的要素。这里我们主要用于构建URL（URL：统一资源定位符是WWW的统一资源定位标志，就是指网络地址）。
参照高德API调用示例将其属性值设置为：
“@Value(_transportation)origin=@Value(_OriginLonLat)&amp;destination=@Value(destination{0}.x),@Value(destination{0}.y)&amp;key=@Value(_Amap_Key)”。
【HTTPCaller】通过HTTP或HTTPS访问URL，执行一个GET，PUT，POST，DELETE或HEAD操作。通过这一步去调用服务。请求URL设置为：
“https://restapi.amap.com/v4/direction/@Value(_URL)”，结果保留至属性即可。
上一步跑完后，如果成功的返回的值就会保存在“_response_body”字段中，这时我们需要对其进行解析，用到【JSONFragmenter】转换器，提取部分JSON格式化文本到新的FME的要素中。从示例中可以分析出，我们需要的时间藏在了“data”下面的“paths”中，因此，“JSON Query”的值设置为“json["data"]["paths"][*]["duration"]”，运行后，“_response_body”的值直接会被替换为"duration"（总用时）。到此就完成了数据的获取。
【AttributeRemover】从要素中删除选定的属性和列表属性。这一步是为了删除冗余的字段，提高运行速度。
4
构建等时圈并导出shp
完成数据获取后，我们得到了起点到每个终点对应的出行时间，但网格点是离散的，因此我们需要将其模拟成连续的表面，再来提取等值线作为等时圈，这就跟高程点生成等高线一个道理，模板如下：
【3DForcer】通过给每个坐标添加z值，把二维数据转换为三维数据。这里是为了将“duration”赋值给网格点的z值，使其具有三维属性。
这一步是为了将其投影至平面坐标系，方便模拟运算。
【SurfaceModeller】基于输入的点和断裂线构建Delaunay三角格网。当需要同一模型多个表达形式时这个转换器很有效。这里就是生成连续表面的过程，有几种输出结果，我们需要其中的“contour”，也就是等值线。
【AreaBuilder】获取一系列拓扑上连接的线，当线形成首尾闭合时创建拓扑正确的多边形要素。这一步是为了将封闭的等值线筛选出来并转换成面要素。到这一步我们已经得到了预估范围内的所有等时圈。
【Tester】执行要素的一个或多个测试条件，根据测试的结果决定要素的输出。判断可由任何FME允许的操作符组成。这一步是为了筛选出我们所需要的等时圈，比如15分钟（900秒），我们只需筛选出“_elevation”小于等于900的即可。
最后通过写模块将结果输出为shp，大功告成，打完收工
最后看一看效果，可以直观地了解火车站的15分钟骑行圈。
再次悄悄告诉你，后台回复“等时圈”可以获取模板
点个在看你最好看
另外我悄悄地创建了一个知识星球供大家交流学习，本知识星球致力于分享GIS软件知识干货，并结合实际案例，让小白上手快。日常分享规划知识，并结合GIS在规划场景中的应用案例，不管是规划中的GISER，还是GIS路上的规划人，永远不迷路。
在这里你将有3大收获：
1.系统全面地了解和学习GIS软件操作及应用； 2.可个性化定制专属服务; 3.与广大同行朋友进行深入交流，交换知识。
还有限量大额优惠券限时供应，冲冲冲！
更有来自不同领域的嘉宾为您现场解答，还在等什么，快加入进来和大佬们一起探索吧！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c529e665014d32aab338abe024830b6b/" rel="bookmark">
			前端发送请求获取后端文件，并且前端实现下载文件功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个需求，就是前端发送post请求获取后端的excel文件，并且前端实现下载导出到本地的功能。
前端页面就长上面那样，一个批量导出功能，用户勾选之后，前端通过接口把id和其他的参数传给后端，接口调用方法这里需要注意的是，这里必须设置responseType: ‘blob’
，后端返回来一个文件流，然后前端通过封装的方法实现下载导出，前端导出方法如下：
这里前端通过blobDownloads实现下载：
前端需要引入这个js
import localDownloadUtil from "@/utils/localDownloadUtil.js"; 然后我们看看这个js里封装了两个下载方法，一种是iframe下载，一种是二进制文件下载，这里我们选择了二进制文件下载：
/** * 本地下载一个文本文件。 * @link https://ourcodeworld.com/articles/read/189/how-to-create-a-file-and-generate-a-download-with-javascript-in-the-browser-without-a-server * @param filename {string} * @param text {string} */ // function download (filename, text) { // const element = document.createElement('a') // element.setAttribute('href', `data:text/plain;charset=utf-8,${encodeURIComponent(text)}`) // element.setAttribute('download', filename) // element.style.display = 'none' // document.body.appendChild(element) // element.click() // document.body.removeChild(element) // } // iframe下载文件，没又身份验证的get接口可以使用 function iframeDownloads(lastUrl){ var downloadFileUrl = window.g.API_URL + lastUrl var elemIF = document.createElement("iframe"); elemIF.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c529e665014d32aab338abe024830b6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa1295fb67740ceee848e10cbf6310d/" rel="bookmark">
			git 查看 stash 记录的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 git stash show -p stash@{1} 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/176c58af68cb03c7ad434f14894d6599/" rel="bookmark">
			linux驱动开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一.字符设备驱动开发1.1 Linux 应用程序对驱动程序的调用1.2 字符设备驱动开发步骤1.3 新字符设备驱动1.4 嵌入式 Linux LED 驱动原理1.5 驱动编写 二.linux设备树2.1 设备树简介2.2 DTS 语法2.3 获取设备树节点信息 OF 操作函数2.4 设备树插件 三.pinctrl 子系统与GPIO子系统3.1 主要工作内容3.2 PIN 配置信息详解3.3 PIN 驱动程序讲解3.4 I.MX6ULL 的 gpio 子系统驱动3.5 gpio子系统API函数3.6 与 gpio 相关的 OF 函数3.7 设备树的修改 四.linux驱动并发与竟态4.1 原子操作函数4.2 自旋锁相关函数4.3 信号量操作函数（宏定义）4.5 互斥体操作函数（宏定义） 五.中断子系统5.1 中断信息5.2 Linux 中断 API 函数5.3 中断的上半部分和下半部分5.4 设备树中断信息节点5.5 获取中断号 六.platform 设备驱动实验6.1 设备与驱动6.2 Linux 的设备模型6.3 attribute 属性文件6.4 platform 平台驱动模型简介6.5 设备树下的 platform 驱动简介6.6 编程思路 七.input输入子系统7.1 注册input_dev 结构体 (内核源码/include/linux/input.h)7.2 input_dev 结构体的申请和释放7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/176c58af68cb03c7ad434f14894d6599/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1e131918454105e361421c31732f64f/" rel="bookmark">
			虚拟机下Ubuntu系统的Docker部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		虚拟机下Ubuntu系统的微服务项目Docker部署 文章目录 虚拟机下Ubuntu系统的微服务项目Docker部署1、Ubuntu安装 Docker2、修改后端微服务的配置2.1 修改 MySQL 的配置2.2 修改 Redis 的配置2.3 修改 Nacos 的配置 3、生成微服务镜像4、拉取远程镜像5、生成前端镜像5.1 准备文件5.2 构建前端镜像 6、基于镜像生成并运行容器6.1 MySQL6.2 Redis6.3 Nacos6.4 三个后端微服务和网关服务6.5 前端服务 7、最终镜像和容器情况展示7.1 镜像展示7.2 容器展示 8、访问本系统 1、Ubuntu安装 Docker 在Ubuntu18.04系统中使用root账户来安装Docker ，并拉取OpenJDK的镜像
sudo apt-get update sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository "deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable" sudo apt-get -y update sudo apt-get -y install docker-ce docker pull openjdk:8 2、修改后端微服务的配置 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1e131918454105e361421c31732f64f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d111bef54eaaa4e07cd0fe2d370b39f3/" rel="bookmark">
			yolov5-7.0 训练自己的数据集之检测数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv5是一种单阶段目标检测算法，有很高的精度和速度，因为项目需求，需要利用yolov5-7.0训练自己的目标检测数据集。
假设，环境已经配置完成！
1）准备数据集 在D:\Graduation_Project_Coding\network_classify\yolov5-7.0\data文件夹下创建mydata_detect文件夹，存放的是
images里存放的是图像，labels存放的是yolo格式的txt文件。
3）准备mydata_detect.yaml文件 在data文件夹下创建mydata_detect.yaml文件，文件内容如下
path： #mydata_detect文件夹的绝对路径
train: #mydata_detect文件夹里images/train文件夹
val: #mydata_detect文件夹里images/val文件夹
test: #mydata_detect文件夹里images/test文件夹，我没弄，test时才能用到
names: #全部类名
nc: #多少个类，不算背景类
3）开始训练 打开yolov5-7.0/train.py文件，修改：红框内文件，改为自己创建的yaml文件
运行演示：
运行成功！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f0de350890af46fc4a81bda1be7e552b/" rel="bookmark">
			yolov5-7.0 训练自己的数据集之分类数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolov5是一个非常强大的目标检测模型，随着深度学习的发展，yolov5在6.1和7.2版本里集成了目标识别、图像分类和分割模块，这篇博客的主题是利用yolov5训练自己的分类数据集。
官方仓库地址：https://github.com/ultralytics/yolov5
假设，已经完成了环境配置
1）准备数据集 在yolov5-7.0文件同目录下创建datasets文件夹。
在datasets文件夹里存放着自己的数据集，例如，我得数据集文件夹 mydata 其格式如下
每个train文件夹下的每个文件夹名就是类名，每个类名文件夹下包含着每个类的图像
至此，数据集准备完毕
2）开始训练 打开yolov5-7.0/classify/train.py，在yolov5环境下，运行。
修改：
只需要修改红框内容即可，我的数据是mydata，直接写上mydata 即可。
3）运行演示 箭头处开始跑就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac856be1fe668ead62c16e1d420fe2a5/" rel="bookmark">
			相量的加减乘除计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相量的加减乘除计算
矢量是物理学中的术语，是指具有大小（magnitude）和方向的量。如速度、加速度、力等等就是这样的量。向量是数学中的术语，也称为欧几里得向量、几何向量、矢量。与向量对应的量叫做数量，在物理学中称为标量，数量只有大小，没有方向。
相量是电子工程学中用以表示正弦量大小和相位的矢量。它仅用来表示具有正弦波的电压和电流，将电压电流用一个复数形式表示，以方便计算。为了让这两个相量相乘具有功率的意义，在极坐标系中，使用电压和电流的有效值来表示相量的大小表示，相量的角度使用电压电流的初相角。不再象直角坐标系，采用幅值和正弦函数的乘积来表示。
由于电压和电流同频，我们将电压相量和电流相量画在同一个复平面中（极坐标系），称为相量图。
在上图中：
相量U = a + jb = U * [cos(α)+ jsin(α)]
相量I = c + jd = I * [cos(β)+ jsin(β)]
相量U1 = a + jb = U1 * [cos(α)+ jsin(α)]
相量U2 = c + jd = U2 * [cos(β)+ jsin(β)]
采用有效值表示相量的大小，是因为考虑到功率计算，如果继续使用幅值表示相量的大小，会导致电压电流相量的乘积就失去了功率的意义，因此，这里采用有效值表示相量的大小。采用初相角表示方向，是因为电压电流相量同频。
相量加法
相量U1 + 相量U2 = U1 * [cos(α)+ jsin(α)] + U2 * [cos(β)+ jsin(β)]
= [U1 * cos(α)+ U2 * cos(β)] + j[U1 * sin(α)+ U2 * sin(β)]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac856be1fe668ead62c16e1d420fe2a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01801c986e22d1027f399fe0787f8d01/" rel="bookmark">
			C&#43;&#43;入门(命名空间和std)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于初学C++的老铁来说，本文可以让你熟知C++中的命名空间和std的概念，希望对读者有所帮助。
目录
一、命名空间
1、全局域与局部域
2、命名空间域(namespace)
3、命名空间嵌套
4、命名空间的合并
二、std
一、命名空间 我们都知道C++是从C语言发展来的，在C语言中经常会出现命名冲突的问题(库冲突and人与人)，我们的祖师爷受够了这种冲突，所以定义了一个命名空间。
1、全局域与局部域 我们先来看下面一段代码
在上面的代码段中，定义了一个全局的a和一个局部的a，我们都知道局部变量优先，所以肯定打印的是局部a的值也就是5，但是如果我就想要访问全局的a怎么办呢？这个时候我们需要在a的前面加上::(域作用限定)，这个符号可以访问全局的a
2、命名空间域(namespace) 在公司里项目都是多个人写的， 如果我是另外1个人，我也想定义一个a，我也想要用a这个名字，这个时候怎么办？这个时候就要用到命名空间(namespace)了。
命名空间会把里面定义变量的和外面的变量隔离开来，编译器是不会主动访问命名空间的。
如果我们想要访问命名空间里面的a如何访问呢？
a.在::(域作用限定)前面加上命名空间的名字即可访问
b.展开命名空间，展开命名空间之后就不需要指定访问了
那么接下来就有个问题了，如果我创建了一个全局变量a，又把在命名空间创建了一个a，并且把命名空间展开了，会优先访问哪一个a？答案是会报错。
为什么呢？因为展开的意思就是暴露到全局，也就是和全局冲突了，编译器也不知道访问哪个了，所以using namespace不要轻易去用，因为命名空间就是为了解决命名冲突，结果你把它暴露到全局那不就毫无意义了吗，我们从上面能发现一个什么结论呢？优先访问局部域，然后是全局域、展开命名空间或者指定访问域。
局部域-&gt; 全局域 -&gt; 展开了命名空间域or指定访问域
3、命名空间嵌套 命名空间是可以嵌套的，并且如果两个命名空间里面定义相同名字的变量，这两个变量名是不冲突的。如果我们要访问命名空间里嵌套的命名空间如何访问呢？
4、命名空间的合并 如果我们在多个文件里面定义同一个命名空间，会自动合成一个命名空间。
但是如果定义同名的变量，会发生冲突。
二、std using namespace std; 有些人写C++的时候会写上面一段代码，那这个代码是什么意思呢？很显然，展开了名为std的命名空间，C++库里面的东西都在std这个命名空间里面，展开之后加上头文件才可以使用C++库里面的东西，但是我们把它们全都展开了好不好？答案是不好，因为这样容易发生命名冲突，所以我建议如果写项目不要全展开，指定展开。用什么展开什么，比如我要用cout就展开cout。
using std::cout; 在日常练习可以全部展开。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf490ca0c8c1b4c1f729f760f88c22ed/" rel="bookmark">
			Python 运行报错 UnicodeDecodeError 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：
在使用 Jupyter Notebook 进行深度学习模型导入的时候报错UnicodeDecodeError
model = keras.models.load_model('20220113_L=16_model.47-0.1436.h5') UnicodeDecodeError Traceback (most recent call last) Cell In[16], line 1 ----&gt; 1 model = keras.models.load_model(‘20220113_L=16_model.47-0.1436.h5’) # load the model (L=4) File ~\anaconda3\envs\tf\Lib\site-packages\keras\saving\saving_api.py:212, in load_model(filepath, custom_objects, compile, safe_mode, **kwargs) 204 return saving_lib.load_model( 205 filepath, 206 custom_objects=custom_objects, 207 compile=compile, 208 safe_mode=safe_mode, 209 ) 211 # Legacy case. –&gt; 212 return legacy_sm_saving_lib.load_model( 213 filepath, custom_objects=custom_objects, compile=compile, **kwargs 214 ) File ~\anaconda3\envs\tf\Lib\site-packages\keras\utils\traceback_utils.py:70, in filter_traceback.&lt;locals&gt;.error_handler(*args, **kwargs) 67 filtered_tb = _process_traceback_frames(e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf490ca0c8c1b4c1f729f760f88c22ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a016bbde6f4cec158354fea393127508/" rel="bookmark">
			webpack plugin源码解析(六) CompressionWebpackPlugin
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 作用涉及 webpack API处理 asset 钩子compilation.hooks.processAssets返回或新建缓存：compilation.getCache返回 asset 文件信息：compilation.getAsset文件名匹配函数：compiler.webpack.ModuleFilenameHelpers.matchObject模版字符串替换：compilation.getPath 实现constructorapply生成输出压缩文件 作用 压缩打包后的文件，可以配置是否删除源文件 const CompressionPlugin = require("compression-webpack-plugin"); new CompressionPlugin() 涉及 webpack API 处理 asset 钩子compilation.hooks.processAssets PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER：优化已有 asset 的转换操作阶段，例如对 asset 进行压缩，并作为独立的 assetadditionalAssets: true 会多次调用回调，一次是在指定 stage 添加资产时触发回调，另一次是后来由插件添加资产时，这里为 CompressionWebpackPlugin 添加的压缩文件后触发 compiler.hooks.thisCompilation.tap(pluginName, compilation =&gt; { compilation.hooks.processAssets.tapPromise({ name: pluginName, // 优化已有 asset 的转换操作，例如对 asset 进行压缩，并作为独立的 asset stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER, additionalAssets: true // true会多次调用回调，一次是在指定 stage 添加资产时触发回调，另一次是后来由插件添加资产时 }, assets =&gt; this.compress(compiler, compilation, assets)); }); 返回或新建缓存：compilation.getCache 具体查看 copy-webpack-plugin 解析文章 返回 asset 文件信息：compilation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a016bbde6f4cec158354fea393127508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac8be79bd1f1a6104af6ae8c95a6a0a/" rel="bookmark">
			计算机毕设答辩前必看干货
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位同学，临近计算机毕设答辩分享几个答辩必须准备的干货。
1 熟悉自己的项目一定要走几遍系统主流程，形成闭环，出现错误的尽量规避，不要在主流程出现404、500等报错情况
2 项目中数据，一定要把更新时间、新增时间改成自己毕设周期时间
3 尽量熟悉代码，最好能找到对应功能的模块代码（不会了可以找我讲代码哦，尽量用通俗易懂方式让你明白，形式是讲价大代码+答疑+录屏，后续也可以问我，需要看我给其他同学的讲解视频可以踢我，最后我主要攻java还，其他小伙伴有py，有计算机网络一些）
4 多练习几遍答辩流程，避免紧张（也可以找我进行模拟答辩哦，也就是根据你们学校规定，带你走一遍答辩流程，然后用老师的口吻，提问题）
5 如果有创新点，记得后面再讲，毕竟最后才打分。
6 态度谦卑，不要吹牛！
最后关注我，回头总结去年带的同学他们答辩问题总结
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9769ac8933c59690cfcc0cca987b834/" rel="bookmark">
			ChatGPT聊天软件开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ChatGPT聊天软件是一款基于OpenAI技术训练的智能AI对话软件，具有自然语言处理、问答系统、语音交互等多种功能。用户可以通过输入文字或语音与ChatGPT进行互动，询问问题，获取信息以及进行娱乐和休闲。ChatGPT聊天软件支持多语言，为用户提供更加便捷和私密的使用体验，并且可以适用于各个领域，例如智能客服、智能家居等等。
ChatGPT聊天软件开发需要以下步骤：
确定需求：确定聊天软件的功能和特点，包括用户界面、交互方式、语音识别、自然语言处理等方面的要求。
设计架构：根据需求设计聊天软件的整体架构和模块，例如前端UI设计、后端服务器搭建、算法模型选择等。
开发代码：在上述架构和模块的基础上进行编码开发，使用相关技术和工具，例如Python、TensorFlow、Flask等，实现聊天软件的各项功能和特性。
测试验收：对聊天软件进行测试和验收，包括单元测试、集成测试、系统测试等，确保软件的质量和稳定性。
发布部署：将聊天软件发布到各个应用市场或自己的官网上，并进行部署和维护，以便用户可以正常使用。
总之，ChatGPT聊天软件开发需要多方面的技术支持和团队协作，同时也需要不断地更新和优化，以提供更好的用户体验和服务。
版权声明：本文作者由漫云科技原创文章，著作权归作者所有，转载请告知作者并注明出处
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/096122908eb4e174a3b2c87ba3b54ea2/" rel="bookmark">
			RabbitMQ路由模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🍁博客主页：👉不会压弯的小飞侠
✨欢迎关注：👉点赞👍收藏⭐留言✒
✨系列专栏：👉Linux专栏
🔥欢迎大佬指正，一起学习！一起加油！
目录 🍁模式说明🍁路由模式完成消息传递 🍁模式说明 使用同一绑定绑定多个队列是完全合法的 .key。在我们的示例中，我们可以在 X 和 Q1 之间添加一个绑定 绑定键黑色。在这种情况下，直接交换将表现良好 像扇出一样，会将消息广播到所有匹配 队列。路由密钥为黑色的消息将同时传递到 Q1 和 Q2。
需要设置类型为direct的交换机，交换机和队列进行绑定，并且指定routing key，当发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列
Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。
图解：
• P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。
• X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列
• C1：消费者，其所在队列指定了需要routing key 为 error 的消息
• C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息
路由模式特点：
• 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）
• 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。
• Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息
🍁路由模式完成消息传递 编写生产者发送消息 编写消息生产者 Producter public class Producer { public static void main(String[] args) throws Exception { Connection connection = ConnectionUtil.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/096122908eb4e174a3b2c87ba3b54ea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18fa181209caf3fd0872fc215ff2a2d4/" rel="bookmark">
			ubuntu 22.04右上角找不到wifi图标，有线网络也失效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因是我将显示驱动由默认的nouveau换成了nvidia，然后重启后在右上角就看不到wifi图标了。
执行`sudo lshw -c network`显示：
*-network UNCLAIMED 执行sudo dpkg -s linux-modules-extra-$(uname -r) | grep Status后显示：
dpkg-query: 系统没有安装软件包 linux-modules-extra-5.19.0-38-generic，因而没有相关的信息 使用 dpkg --info (= dpkg-deb --info) 来检测打包好的文件， 因此，解决方法是安装linux-modules-extra. 具体步骤：
1. 用uname -a找到自己kernel的版本，比如我的是5.19.0-38-generic
Linux jason-G1-Sniper-Z97 5.19.0-38-generic #39~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Mar 17 21:16:15 UTC 2 x86_64 x86_64 x86_64 GNU/Linux 2. 用bing或其他搜索引擎搜索"packages.ubuntu.com 5.19.0-38-generic"，结果应该是https://packages.ubuntu.com/kinetic/kernel/linux-image-5.19.0-38-generic，然后下载deb文件，最后用sudo dpkg -i安装、重启系统即可。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/156/">«</a>
	<span class="pagination__item pagination__item--current">157/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/158/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>