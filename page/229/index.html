<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74f9d38e8edcdf693ae98a885b95521/" rel="bookmark">
			vector及vector迭代器问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1 vector介绍 1.2 vector使用 1.2.1vector 的构造函数声明 1.2.2 vector迭代器的使用 1.2.3vector 的空间相关 1.2.4 vector的增删查改 2.1 vector迭代器问题 1.1 vector介绍： 1. vector是表示可变大小数组的序列容器。意思是，vecotr本质上类似一个数组，是一串连续的空间。
2.vector也采用的连续存储空间来存储元素，可以采用下标对vector的元素进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自动处理。
3.vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小
为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。
4.vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，这样就不用每次都要开辟空间，只有当额外的空间被占满，才会再次开辟更大的空间。 不同的库采用不同的策略权衡空间的使用和重新分配。
5.与其它动态序列容器相比（deques, lists and forward_lists）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起lists和forward_lists统一的迭代器和引用更好。
1.2 vector的使用 1.2.1vector 的构造函数声明 1.2.2 vector迭代器的使用 如下图
1.2.3vector 的空间相关 size()计算的是有效数据个数，capacity()是计算ve开辟的空间大小，不断增添数据，size()就慢慢增大知道size()==capacity()，就会进行增容，vector的增容为两倍；
resize\resver的使用 通过ve.size()改变ve的有效数据个数，ve.reserve()改变空间大小；
也可以使用ve.size()来增容，并且初始化新增的空间；原本有效数据为5，现在增加到10，新增的被初始化为2.
1.2.4 vector的增删查改 删除操作，不会导致缩容，对于系统而言，时间优先于空间，如果要缩容，必然会进行开辟空间，复制数据，交换地址等操作，这些操作会浪费时间，所以即使开辟的空间被删除到只剩一个数据，capacity依然不会变。
在第一个迭代器位置放两个2。
在第三个迭代器位置放一个3。
用ve.empty()判断是否ve为空，空则返回0，不为空返回1。
2.1 vector迭代器问题 举例，在v中偶数数据前放一个110，但结果却是错误，原因就在于迭代器出现了问题。
当迭代器到2的位置时，要插入110，所以将后面的数据都后移了一位，插入数据后，pos++正好又来到2的位置，这时it迭代器失效，它的地址不在第一个迭代器和最后一个迭代器之间。
解决方案是，每次插入迭代器都有++一下；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09452efa30f68fced3349208803b6874/" rel="bookmark">
			【存储】Raid系列技术详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念
Raid（Redundant Array of Indepent Disk ）即独立冗余磁盘阵列，也就是硬件中的磁盘阵列设备，实质上是用多个独立的磁盘组成在一起，作为一个大容量磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。Raid有多种磁盘阵列组合，常用的有raid0、raid1、raid3、raid5和raid10，每种磁盘阵列都有它的优势。
二、Raid 0
Raid 0 技术是把多块（至少两块）物理硬盘通过工具绑在一起，组成一个大的虚拟存储设备，并将数据分成几块分别依次写入到各个物理硬盘中。如图1所示，数据被分成多段分别写入到不同的硬盘中，即数据分别保存到disk1和disk2中，最终实现提升读取、写入的速度。
优势：数据读取写入最快，最大优势提高硬盘容量，比如3快80G的硬盘做raid0 可用总容量为240G。速度是一样。
缺点：无冗余能力，如果任意中的一块硬盘发生故障，将会导致整个系统的数据都受到破坏。
三、raid 1
Raid 1 是磁盘阵列中单位成本最高的一种方式。因为它的原理是在往磁盘写数据的时候，将同一份数据无差别的写两份到磁盘，分别写到工作磁盘和镜像磁盘，那么它的实际空间使用率只有50%了，两块磁盘当做一块用，这是一种比较昂贵的方案。
RAID1其实与RAID0效果刚好相反。RAID1 这种写双份的做法，就给数据做了一个冗余备份。这样的话，任何一块磁盘损坏了，都可以再基于另外一块磁盘去恢复数据，数据的可靠性非常强，但性能就没那么好了。
四、Raid 3
将数据按照RAID0的形式，分成多份同时写入多块磁盘，但是还会另外再留出一块磁盘用于写「奇偶校验码」。例如总共有N块磁盘，那么就会让其中额度N-1块用来并发的写数据，第N块磁盘用记录校验码数据。一旦某一块磁盘坏掉了，就可以利用其它的N-1块磁盘去恢复数据。
但是由于第N块磁盘是校验码磁盘，因此有任何数据的写入都会要去更新这块磁盘，导致这块磁盘的读写是最频繁的，也就非常的容易损坏。
五、Raid 5
这是目前用的最多的一种方式。
因为 RAID5 是一种将 存储性能、数据安全、存储成本 兼顾的一种方案。RAID5的方式可以说是对RAID3进行了改进。
RAID5模式中，不再需要用单独的磁盘写校验码了。它把校验码信息分布到各个磁盘上。例如，总共有N块磁盘，那么会将要写入的数据分成N份，并发的写入到N块磁盘中，同时还将数据的校验码信息也写入到这N块磁盘中（数据与对应的校验码信息必须得分开存储在不同的磁盘上）。一旦某一块磁盘损坏了，就可以用剩下的数据和对应的奇偶校验码信息去恢复损坏的数据。
RAID5校验位算法原理：P = D1 xor D2 xor D3 … xor Dn （D1,D2,D3 … Dn为数据块，P为校验，xor为异或运算）
RAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。
六、Raid 10
鉴于Raid5技术是因为磁盘设备的成本问题，对读写速度和数据的安全性能而又一定的妥协，但是在企业里更在乎的还是数据本身的价值而非硬盘的价格，因此在生产环境中推荐使用raid10技术。
Raid10是Raid1和Raid0的组合体，如图所示，Raid10技术至少需要4块硬盘来组建，其中先分别两两制成Raid1磁盘阵列，以保证数据的安全性。然后再对两个Raid1磁盘按阵列实施Raid0技术，进一步提高硬盘设备的读写速度。这样从理论上讲，只要坏的不是同一组中的所有磁盘，那么最多可以损坏50%的硬盘设备而不丢失数据。由于Raid10技术击继承了Raid0的高速写速度和Raid1的数据安全性，在不考虑成本的情况下Raid10的性能都超过了Raid5，因此当前成为广泛使用的一种存储技术。
但也可以看出RAID10模式是有一半的磁盘空间用于存储冗余数据的，浪费的很严重。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea860c9d07d3f60e13632826afd3a470/" rel="bookmark">
			【python-opencv入门笔记】5 -HSV颜色模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RGB模型： 在计算机体系中，最常用的颜色空间是RGB模型，常用于颜色显示和图像处理，三维坐标的模型形式，主要是易于实现RGB三原色的组合表达各种颜色方便屏幕显示。
HSV模型： 而HSV模型，是针对用户观感的一种颜色模型，侧重于色彩表示，什么颜色、深浅度、明暗度。
色调（H），饱和度（S），明度（V）
H：Hue即色相，就是我们平时所说的红、绿，如果你分的更细的话可能还会有洋红、草绿等等；在HSV模型中，用度数来描述色相，其中红色对应0度，绿色对应120度，蓝色对应240度。S：Saturation即饱和度，色彩的深浅度(0-100%) ，对于一种颜色比如红色，我们可以用浅红——大红——深红——红得发紫等等语言来描述它（请原谅一个纯理科生的匮乏的颜色系统），对应在画水彩的时候即一种颜料加上不同分量的水形成不同的饱和度。V：Value即色调，纯度，色彩的亮度(0-100%) ，这个在调整屏幕亮度的时候比较常见。
需要注意的是在OpenCV中 HSV的取值范围分别是 H:(0-180)，S:(0-255)，V:(0-255)。 import cv2 import numpy as np def nothing(x): pass #通过Opencv读取图片信息 #src = cv2.imread('image.jpg') img = cv2.imread('hsv.jpg') rows,cols,channels = img.shape cv2.imshow("src", img) cv2.namedWindow('img2',1) #cv2.resizeWindow("img2", 400, 200) #创建一个500*500大小的窗口 # 创建6个滑条用来操作HSV3个分量的上下截取界限 cv2.createTrackbar('Hlow','img2',62,180,nothing) cv2.createTrackbar('Hup','img2',99,180,nothing) cv2.createTrackbar('Slow','img2',198,255,nothing) cv2.createTrackbar('Sup','img2',255,255,nothing) cv2.createTrackbar('Vlow','img2',150,255,nothing) cv2.createTrackbar('Vup','img2',255,255,nothing) # lower_red = np.array([55,30,30]) # upper_red = np.array([99,255,255]) hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) while(1): # mask = cv2.inRange(hsv, lower_red, upper_red) #将制定像素点的数据设置为0, 要注意的是这三个参数对应的值是Blue, Green, Red。 hlow = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea860c9d07d3f60e13632826afd3a470/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9522f34f2e754c26e110c7452ef1dfc8/" rel="bookmark">
			判断点在直线的左侧和右侧的方法及原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应用场景：
1.判断某一个点是否在线的指定的一侧。
2.判断一个点在线的左侧还是右侧。
给定的条件：三个点(最原始的数据)
已知三个点，a = (px,py),b=(qx,qy),c = (lx,ly)，求相对于由a和b两点确定的一条直线，点c位于左侧还右侧。
方法一：无向线段的判断逻辑。
原理：主要利用直线的斜率k。
求出直线ab的斜率k，假设存在点D=(m,n)在ab直线上，且D的y值等于c的y值，即n = ly。此时可以通过斜率算出m，比较m与lx的大小，如果m&gt;lx说明点在线的左边，小于则在右边，等于则在线上。
代码如下：
bool LeftOfLine(const ZCoord2D&amp; p, const ZCoord2&amp; p1, const ZCoord2D&amp; p2) { double tmpx = (p1.x - p2.x) / (p1.y - p2.y) * (p.y - p2.y) + p2.x; if (tmpx &gt; p.x)//当tmpx&gt;p.x的时候，说明点在线的左边，小于在右边，等于则在线上。 return true; return false; } 方法二：利用行列式进行判断。
原理：利用三阶行列式的几何意义，判断点的方位。
具体原理：行列式的几何意义
利用面积的方向性，知道点在线的左右端。
D=|1,px,py| = (py – qy) * lx + (qx – px) * ly + px * qy – qx * py
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9522f34f2e754c26e110c7452ef1dfc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79f4ec47f96a92ff3f651c01bbc8ecc5/" rel="bookmark">
			Redis最佳实践--键值设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、优雅的key结构 Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：
遵循基本格式：[业务名称]:[数据名]:[id]长度不超过44字节不包含特殊字符 例如：我们的登录业务，保存用户信息，其key是这样的：
login:user:10 优点： 可读性强避免key冲突方便管理更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小 2、拒绝BigKey BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：
Key本身的数据量过大：一个String类型的Key，它的值为5 MB。
Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。
Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。
推荐：
单个key的value小于10KB对于集合类型的key，建议元素数量小于1000 1、BigKey的危害 网络阻塞
对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢
数据倾斜
BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡
Redis阻塞
对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞
CPU压力
对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用
2、如何发现BigKey redis-cli --bigkeys
利用redis-cli提供的–bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key
scan扫描
自己编程，利用scan扫描Redis中的所有key，利用strlen、hlen等命令判断key的长度（此处不建议使用MEMORY USAGE）
第三方工具
利用第三方工具，如 Redis-Rdb-Tools 分析RDB快照文件，全面分析内存使用情况
网络监控
自定义工具，监控进出Redis的网络数据，超出预警值时主动告警
3、如何删除BigKey BigKey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。
redis 3.0 及以下版本：如果是集合类型，则遍历BigKey的元素，先逐个删除子元素，最后删除BigKeyRedis 4.0以后：Redis在4.0后提供了异步删除的命令：unlink 3、恰当的数据类型 数据存储到Redis当中，如何选择恰当的类型呢？举例说明一下
例1：比如存储一个User对象，我们有三种存储方式：
方式一：json字符串
user:1{“name”: “Jack”, “age”: 21}**优点：**实现简单粗暴
**缺点：**数据耦合，不够灵活
方式二：字段打散
user:1:nameJackuser:1:age21**优点：**可以灵活访问对象任意字段
**缺点：**占用空间大、没办法做统一控制
方式三：hash
user:1nameJack（其实第一列的单元格是合并的）jack21
**优点：**底层使用ziplist，空间占用小，可以灵活访问对象的任意字段
**缺点：**代码相对复杂
PS：总的来说，还是哈希比较好一点，空间小且灵活，代码其实也复杂不到哪去，多那几行代码，一下就完事了
例2：假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？
方案一：hash存储
如果还使用hash来存储的话，会存在以下问题：
hash的entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多。可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题 *
方案二：采用String类型存储，拆分为String
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79f4ec47f96a92ff3f651c01bbc8ecc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd152d8368cd71d26d9830602c4b4db8/" rel="bookmark">
			Java实验：编写网络聊天程序（图形界面）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课程名称 高级Java程序设计
实验项目 Java网络编程 实验目的：
使用客户机/服务器模式、基于TCP协议编写一对多“群聊”程序。其中客户机端单击“连接服务器”或“断开连接”按钮，均能即时更新服务器和所有客户机的在线人数和客户名。
实验要求：
设计一对多的网络聊天程序，要求：
基于TCP/IP设计聊天程序采用图形界面设计能够进行一对多聊天 项目截图 服务器端代码： import javax.swing.*; import javax.swing.border.TitledBorder; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.ArrayList; import java.util.Vector; public class Server extends JFrame { // TODO 该图形界面拥有三块区域，分别位于上、中、下 （up、middle、down）。 private JPanel panUp = new JPanel(); private JPanel panMid = new JPanel(); private JPanel panDown = new JPanel(); // panUp 区域的子节点定义，标签、输入框、按钮 private JLabel lblLocalPort = new JLabel("本机服务器监听端口:"); protected JButton butStart = new JButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd152d8368cd71d26d9830602c4b4db8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc99216bf5bd215f67fe19750ba06b71/" rel="bookmark">
			AndroidStudio-实现登录界面（数据存储在SQLite）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要求：每种错误信息采用Toast进行提示
（1）未注册的用户不能进行登录；
（2）用户名和密码不能为空；
（3）用户名不能重复；
一、创建新工程
点击next
修改名字 ，language看自己情况修改，sdk最好选21，这样21之后的都可以用，location自己改，点击finish
点击左上角的Android，切换成project
创建新的activity 修改名字，点击finish，同样的，再创建一个注册Activity
在AndroidMainfest.xml文件中将登录界面设为主界面
&lt;application android:allowBackup="true" android:dataExtractionRules="@xml/data_extraction_rules" android:fullBackupContent="@xml/backup_rules" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/Theme.MyLogin" tools:targetApi="31"&gt; &lt;activity android:name=".Register" android:exported="false" /&gt; &lt;activity android:name=".Login" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".MainActivity" android:exported="false"/&gt; &lt;/application&gt; 二、UI界面设计
插入图片，名字只能是小写
Login：ps：复制的时候得把注释去掉
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout//线性布局 xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/img"//界面背景图 android:orientation="vertical"&gt;//布局方式，vertical为垂直布局，horizontal为水平布局 &lt;LinearLayout android:layout_marginLeft="30dp"//容器中的左边距 android:layout_marginRight="30dp"//容器中的右边距 android:layout_width="match_parent"//和父容器一样大小 android:layout_height="0dp"//按比例分配大小 android:layout_weight="1" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content"//大小包裹内容 android:orientation="horizontal"&gt; &lt;TextView android:layout_width="0dp" android:layout_height="wrap_content" android:text="用户名：" android:layout_marginTop="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc99216bf5bd215f67fe19750ba06b71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/112106dd30d00460f684bd8edd0bbdf7/" rel="bookmark">
			Python类中的继承——super（包含super(子类, self).__init__()以及其他父类的方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0. 引言 Python中对象方法的定义很怪异，第一个参数一般都命名为self（相当于其它语言的this），用于传递对象本身，而在调用的时候则不必显式传递，系统会自动传递。
今天我们介绍的主角是super(), 在类的继承里面super()非常常用， 它解决了子类调用父类方法的一些问题， 父类多次被调用时只执行一次， 优化了执行逻辑，下面我们就来详细看一下。
0.1 定义一个类 class A: def method_1(self, msg): print(msg) return msg a = A() a.method_1(msg="Hello, class!") """ Hello, class! """ 0.2 在子类中调用父类的方法 当存在继承关系的时候，有时候需要在子类中调用父类的方法，此时最简单的方法是把对象调用转换成类调用，需要注意的是这时self参数需要显式传递。
语法：
class 子类(父类): def 子类的方法(self, 参数): 父类.父类的方法(self, 参数) 例子：
class A: def method_parent(self, msg): print(msg) return msg class B(A): def method_child(self, msg): # 父类.父类的方法(self, 参数) A.method_parent(self, msg=msg) # self必须写 b = B() b.method_child(msg="Hello, class!") """ Hello, class! """ 这样做有一些缺点，比如说如果修改了父类名称，那么在子类中会涉及多处修改，另外，Python是允许多继承的语言，如上所示的方法在多继承时就需要重复写多次，显得累赘。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/112106dd30d00460f684bd8edd0bbdf7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9844fc9a9cb2942ace2274a6e15dd4f/" rel="bookmark">
			CentOS7安装vmware
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载VMWare
到官网https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html，下载了vm15，400多M
2.安装VMware
将VMware-Workstation-Full-15.1.0-13591040.x86_64.bundle放到centos某个目录下，
将目录权限设置成可读写 sudo chmod -R 777 /opt/module
在命令行输入
# /opt/module/VMware-Workstation-Full-15.1.0-13591040.x86_64.bundle 3.启动VMware
在命令行输入
# vmware 4.安装虚拟机
将windows server 安装到虚拟机。
用ftps传送windows server （5.6G），
安装是，出现VMware 启动报错"Please make sure that the kernel module `vmmon' is loaded，
后面直接
Disable Secure Boot in my BIOS.
进入电脑的bios 关掉 secure boot重启就OK
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43484a470d2e085a8a5b6901d4627cd1/" rel="bookmark">
			凯斯西储大学轴承数据介绍及处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 轴承故障诊断一般使用美国凯斯西储大学的数据集进行标准化检测算法的优劣。以下几种实验数据提取和使用方法为我在论文中所看到的。进行以下陈述
一、基于 RA-LSTM 的轴承故障诊断方法 实验数据采用美国凯斯西储大学的SKF型轴承的DE（drive end accelerometer data 驱动端加速度数据）端加速度数据，转速为1730r/min，样本采用频率为48kHz。实验所选轴承单点直径损伤分别为0.007mm、0.014mm、0.021mm的故障，每种故障直径内含有滚动体故障、内圈故障以及外圈故障共三种故障类型。实验数据集由九种故障数据集以及一种正常数据组成，生成数据集的截取方法如图5所示，通过设置一个定值的窗口对数据进行截取，并对窗口按照指定步幅移动，进行下一次截取。将截取后的数据集的70%作为训练集，30%作为测试集。
二、残差网络和注意力机制相结合的滚动轴承故障诊断模型 实验采用凯斯西储大学的滚动轴承振动数据，选用SKF-6205驱动端轴承，其转速为1797r/min，信号采样频率为12kHz，对应有正常（N）、外圈故障（OR）、内圈故障（IR）和滚动体故障（RB）这4种状态，其振动信号如图5所示。图5中N和RB信号有较强的随机性，而IR和OR信号则具备一定的周期性特征，难以直接进行轴承状态的区分。
选择轴承故障的3种损伤尺寸（0.017 78cm、0.035 56cm、0.053 34cm），将轴承状态划分为10种状态标签。同时按照工程实际取5~7转的振动信号，即取每段样本长度为2048点，采用如图6所示的滑动窗重叠采样的方法进行数据增广扩充，将总样本扩充至10的4次方量级。具体数据划分及样本量如下表所示。
三、基于卷积神经网络的轴承故障诊断算法研究 数据集增强： 增强机器学习模型泛化能力最好办法是使用更多的训练样本。数据集增强技术即通过增加训练样本，以达到增强深度网络泛化性能的目的。在计算机视觉领域，数据集增强的方式有图片镜像，旋转，平移，修剪缩放，调整对比度等方法。然而，目前在故障诊断领域，并没有专门提出数据集增强技术，部分诊断算法的训练样本量很少[1,25]，这样很容易造成过拟合。对于一维故障诊断信号，由于其特有时序性和周期性，图片的数据集增强技术并不完全适用。
本文提出的数据增强方式是重叠采样，即对于训练样本，从原始信号进行采集训练样本时，每一段信号与其后一段信号之间是有重叠的，采样方式如图 2-6 所示。对于测试样本，采集时没有重叠。假设一段故障诊断信号有 60000 个数据点，每次采集的训练样本长度为 2048，偏移量为 1，那么最多可以制作 57953 个训练样本，可以很好的满足深度神经网络的训练需求。
数据集介绍：
本文的试验数据来自于凯斯西储大学（CWRU）滚动轴承数据中心。CWRU数据集是世界公认的轴承故障诊断标准数据集。截止到 2015 年，仅机械故障诊断领域顶级期刊《Mechanical Systems and Signal Processing》就发表过 41 篇使用CWRU 轴承数据进行故障诊断的文章。在基于深度学习的轴承故障诊断领域，目前被引用数最高的两篇文章[25,26]的试验数据也均来自 CWRU 轴承数据库。当下，轴承故障诊断算法更新较快，为了评价被提出算法的优越性，最客观的方式就是使用第三方标准数据库与当下主流算法比较。因此，本文的所有试验均采用 CWRU
轴承数据。 CWRU 轴承中心数据采集系统如图 2-7 所示。本试验的试验对象为图中的驱动端轴承，被诊断的轴承型号为深沟球轴承 SKF6205，有故障的轴承由电火花加工制作而成，系统的采样频率为 12kHz。被诊断的轴承一共有 3 种缺陷位置，分别是滚动体损伤，外圈损伤与内圈损伤，损伤直径的大小分别为包括 0.007inch, 0.014inch 和 0.021inch，共计 9 种损伤状态。试验中，每次使用 2048 个数据点进行诊断。为了便于训练卷积神经网络，对每段信号𝑥均做归一化处理，归一化处理的公式如式（2-22）所示： 试验一共准备了 4 个数据集，如表 2-3 所示。数据集 A、B 和 C 分别是在负载为 1hp、2hp 和 3hp 下的数据集。每个数据集各包括 6600 个训练样本与 250 个测试样本，其中训练样本采用数据集增强技术，测试样本之间无重叠。数据集 D 是数据集 A、B 和 C 的并集，即包括了 3 种负载状态，一共有 19800 个训练样本与750 个测试样本。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19aa19e0e0412372fd25cf41c0f5d456/" rel="bookmark">
			Java项目:进销存管理系统(java&#43;Springboot&#43;jpa&#43;maven&#43;jQuery&#43;Mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码获取：俺的博客首页 "资源" 里下载！ 项目介绍 本系统基本完成了一个基于spring boot + JPA的进销存管理系统，包括manager管理员与employee雇员两种角色。
主要实现采购管理、库存管理、销售管理、查询统计、资料管理和系统管理功能。
本系统的实现使用了很多计算机技术，包括Java语言、Spring boot框架、
JPA持久层框架和MySQL数据库。带文档
环境需要 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA;
3.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS；
4.数据库：MySql 5.7版本；
5.是否Maven项目：是；
技术栈 springboot+jpa+mysql+maven+jquery
使用说明 1. 使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件；
2. 使用IDEA/Eclipse/MyEclipse导入项目，导入成功后请执行maven clean;maven install命令，然后运行；
3. 将项目中application.properties配置文件中的数据库配置改为自己的配置;
4. 运行项目，项目运行成功后在浏览器中访问：
管理员登录地址：http://localhost:8080/
manager管理员账号密码：admin/123456
employee雇员账号密码：test/123456
用户管理控制层： @RestController @RequestMapping("/user") public class UserController { @Autowired private UserService userService; @Autowired private RoleService roleService; /** * 登录 * * @param username 用户名 * @param password 密码 * @param request * @return */ @SysLog("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19aa19e0e0412372fd25cf41c0f5d456/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553e76fc42268387f0f2de95d0bc6ca2/" rel="bookmark">
			上海电信路由器有ipv6，电脑无法获取ipv6问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前用的移动网络，openwrt的ipv6基本没怎么设置就可以直接使用了。现在换成了电信，只有路由器的wan6有ipv6，电脑则无法获取ipv6。查找一些资料，最终根据该帖子解决了该问题：
https://www.right.com.cn/forum/thread-8077577-1-1.html
主要就是修改了wan6的dhcp server如下：
然后lan的dhcp server如下：
之前应该是server mode，现在修改为relay mode后，我的电脑也可以获取ipv6了。
查了下，好像是电信没下发pd，那我的openwrt路由器连接到电信光猫上获得ipv6没问题，但是它下面挂的设备就无法获取ipv6地址了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b901a197dc06634c3a9e66f221e9f0f9/" rel="bookmark">
			夜光遥感学习摘录二
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、NPP VIIRS数据获取（年平均、月平均、单日） （一）访问网站VIIRS - Payne Institute for Public Policy（该VIIRS数据由Colorado School of Mines代理发布）
（二）下拉界面到Data Download数据框选择自己想要的数据（假设需要夜间灯光数据，点击VIIES DNB Nighttime Lights）
（三）进入界面后注册账号即可获取数据
二、NPP VIIRS数据的类型（此处可以直接根据自己需要进入数据选择界面） （一）VIIRS DNB Nighttime Lights（仅展示基础数据，若需知识数据自行了解获取）
1、Monthly Cloud-free DNB Composite
该数据分为vcm与vcmsl两个版本。vcm版本是排除了受到零散杂光影响的数据并保留未被零散杂光影响的数据（直接将受杂散光影响的像元剔除，这部分像元亮度的缺失导致像元亮度在时空上不连续）；vcmsl版本是对受杂散光影响的像元进行了校正，尽可能的保留了受杂散光影响的像元。两类数据覆盖范围受到日长极大影响。
2、Annual VNL V1
该数据基于vcm数据合成并进一步筛选出了短暂的灯光与无光背景。
3、Annual VNL V2
该数据基于Annual VNL V1基础上做了改进。其初步过滤除去了阳光、月光和多云影响的像素，粗略合成了包含灯光、火焰、极光和背景，继而采用异常值去除生物量燃烧像素，同时过滤掉大部分火灾并隔离背景。
（二）VIIRS Nightfire-Nighttime Detection and Characterization of Combustion Sources (VNF)
该数据利用六个光谱波段检测和表征亚像元的红外辐射值，提供热源像素检测的位置、时间以及热源温度和热源大小的估计。
（三）VIIRS Boat Detections (VBD)
VIIRS日/夜波段在夜间检测明亮船只的数据，数据以CSV和KMZ格式提供。在GeoTiff格式中，月、年度世界总和格网数据为15弧秒分辨率。
三、NPP VIIRS数据的预处理方法 （一）依据研究区的特征及处理需求对VIIRS数据进行投影、裁剪操作，将VIIRS数据的投影坐标系转换为对应投影坐标系(保持数据源一致性)。
ENVI操作：
Toolbox -&gt; raster management -&gt; masking -&gt; reproject raster -&gt;select output coordinate -&gt;选择对应的投影坐标系 -&gt;ok；(此处导出文件应该注意到原VIIRS的DN值范围，设置其背景值应该设置在其DN值范围之外)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b901a197dc06634c3a9e66f221e9f0f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65dc33bdfd99e780ded12ec586b10eb7/" rel="bookmark">
			Nginx配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、nginx实现负载均衡和任务转发 通过在upstream参数中添加的应用服务器IP后添加指定参数即可实现，如：
http{ #开启gzip gzip on; #低于1kb的资源不压缩 gzip_min_length 1k; #压缩级别1-9，越大压缩率越高，同时消耗cpu资源也越多，建议设置在5左右。 gzip_comp_level 5; #需要压缩哪些响应类型的资源，多个空格隔开。不建议压缩图片. gzip_types text/plain application/javascript application/x-javascript text/javascript text/xml text/css; #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持） gzip_disable "MSIE [1-6]\."; #是否添加“Vary: Accept-Encoding”响应头 gzip_vary on; #配置跨域 add_header Access-Control-Allow-Origin *; #add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; upstream myserver{ server 192.168.60.49:8080 weight=3; server 192.168.60.49:8081; } server { listen 8000; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://myserver; index index.html index.htm; } } } 通过以上配置，便可以实现，在访问localhost这个网站时，由于配置了proxy_pass地址，所有请求都会先通过nginx反向代理服务器，在服务器将请求转发给目的主机时，读取upstream为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65dc33bdfd99e780ded12ec586b10eb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcb8427e395da610a9fd3abc55c146cf/" rel="bookmark">
			Django配置HTTPS（SSL安全证书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 django配置https 1.安装第三方库
pip install django-extensions pip install django-werkzeug-debugger-runserver pip install pyOpenSSL 2.修改settings.py配置文件
INSTALLED_APPS=[ 'werkzeug_debugger_runserver', 'django_extensions', ] 3.运行启动文件
python manage.py runserver_plus --cert server.crt 0.0.0.0:8000 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb2fc587ef5f25d7d66dcf3f9782dad7/" rel="bookmark">
			网络基础-二层通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读懂文本需要对IP、MAC地址有基础的认识
网络基础-二层通信 二层通信IP地址是什么MAC地址是什么ARP表MAC表二层通信的过程 二层通信 首先我们需要知道，流量数据的互访都是通过收发数据包的形式进行的
那么数据包是怎么知晓自己该去往何方的呢？我们先来了解几个概念
IP地址是什么 相信192.168.1.1这种类型的地址大家经常能看到，这个就称为一个IP地址，它用于标识网络上的某个终端。
MAC地址是什么 MAC地址用于标识一个设备的物理地址，一般来说，MAC地址是唯一的。在windows上，通常标识为F4-46-33-90-EC-5C这种形式
ARP表 记录IP地址与MAC地址的映射关系，arp表项一般用来指导数据包的封装
MAC表 交换机上记录MAC地址与端口的映射关系，mac表项一般用来指导交换机如何转发数据包
二层通信的过程 注：对于本文中提到的是否同网段的判定方法，在此不做详细解释，若没有这个基础，请自行百度解决
了解了IP地址与MAC地址的基础后，我们来研究一下二层的通信过程
环境介绍：
A、B为同网段的主机，仅配置了IP地址与24位掩码（主机为何没有配置网关地址，我会在之后三层的讲解中说明），二层交换机上无任何配置
主机A ping 主机B 的详细过程逐步说明如下
1、在A主机上执行ping 10.1.1.2
2、A主机查看自身的ARP表项是否存在10.1.1.2的MAC，检查后发现无对应ARP表项
3、A主机先判定目的IP 10.1.1.2是否为自己的同网段IP，使用掩码255.255.255.0去掩10.1.1.2这个地址。得出自身地址、对端地址的网络位均为10.1.1.0，因此判定为同网段互访，也就是二层互访
4、确认为二层互访后，A开始封装数据包，当前A自己的IP、MAC地址、B的IP是已知的。但A并不知道B的MAC地址，也就无法完成封装，所以A需要发送ARP广播请求去问B的MAC地址。我们不难发现，ARP实际上就是拿IP地址去解析MAC地址
在交换机的E0/0/1口抓包，我们可以看到
ARP的广播请求包：
三层信息：Sender IP（源IP）为A的IP，Target IP（目的IP）为B的IP
二层信息：源MAC为A、目的MAC为全F，也就是发送给任何同网段的设备，一般我们称为广播
为什么需要广播呢？因为A并不知道对方的MAC，只能发给所有同网段的设备，以找到10.1.1.2对应的设备，并让设备回复它的MAC地址给A
在交换机收到A发来的ARP广播请求包以后，它会查看ARP包中的MAC信息，发现源MAC是A，且该数据包是从E0/0/1接口接收到的
因此，交换机会在自己的MAC表中新增一条：A的MAC地址——E0/0/1
注：该条MAC表项的默认存活时间为300S
生成MAC表项后，交换机发现目的MAC是全F，为广播包，因此将该数据包向除接收端口（E0/0/1）的所有端口泛洪
B收到ARP请求包以后，发现该请求包目的IP是自己，便封装ARP单播回应包进行发送
ARP的单播回应包：
IP层信息：Sender IP（源IP）为B的IP，Target IP（目的IP）为A的IP
二层信息：源MAC为B、目的MAC为A
此处为什么回应的是单播呢？
因为在A发送ARP请求包时，里面就封装了A的MAC，因此B知晓了A的MAC，直接采用单播回复
交换机在收到B的回应包之后，同样的查看包中的源MAC，并生成一条MAC表项：B的MAC——E0/0/2
此处我们不难发现：交换机根据数据包中的源MAC地址学习并生成MAC表项、根据目的MAC进行转发
生成完MAC表项后，交换机会查看包的目的MAC，并在自己的MAC表项中查询该MAC对应的接口。匹配到MAC表中的：A的MAC——E0/0/1
因此，交换机将ARP回应包从E0/0/1口转发出去
A收到来自B的ARP回应
5、经过ARP解析，A已经得知了B的MAC地址，并将B的IP与MAC对应关系缓存在本地的ARP表中，为这一条目附加一个生存时间，在生存时间内再次访问B，无需发送ARP请求，直接通过表项来封装
6、A封装ICMP报文，其中包含源目IP、源目MAC，发送给交换机
7、交换机收到的报文如下：
8、交换机查看数据包中的目的MAC，并查看自身的MAC表项中是否存在对应的表项
交换机查询到目的MAC对应着E0/0/2端口，因此将数据包通过E0/0/2口转发出去
9、B收到数据包
10、B回复数据包的过程与A发送给B的类似，不做赘述
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dfe8a9b3d39692583ba5a246a8bd4b3/" rel="bookmark">
			配置环境变量时Path单行显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10环境变量Path单行显示问题 出现的问题：之前配置环境变量的时候，由于把其他变量移到了最顶端，导致环境变量 Path 变成了单行显示，后序配置其他环境变量的时候会很不方便。
解决方案： 将 %SystemRoot%\system32; 放到最前边即可解决。
%SystemRoot% 即是 C:\Windows
加上后恢复为多行显示，保持在最上方。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e93cb7e4433b63f9dc05b6fe803d509e/" rel="bookmark">
			ACL基础配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、首先搭建好一个简单的三层网络拓扑
二、为终端和路由器进行基础参数配置
三、在二层交换机上配置Vlan和接口
四、进行内网ping测
五、配置ACL访问控制列表并进行流控
六、再次进行ping测
ACL已经成功拦截了终端一号机对服务器的访问，而二号机正常通过
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05a473fa5ea81fa62ccbf3ad7fcbcb44/" rel="bookmark">
			vector容器遍历三种方式 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;iostream&gt; using namespace std; #include&lt;vector&gt; #include&lt;algorithm&gt; void myPrint(int val) { cout&lt;&lt;val&lt;&lt;endl; } void test(){ //创建一个vector容器，数组 vector&lt;int &gt; v; //向容器中插入数据 v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); //通过迭代期访问容器中的数据 // vector&lt;int&gt;::iterator itBegin=v.begin();//起始迭代器 指向容器中第一个元素 // vector&lt;int&gt;::iterator itEnd=v.end();//结束迭代器 指向容器中最后一个元素的下一个位置 // //第一种遍历方式 // while(itBegin!=itEnd){ // cout&lt;&lt;*itBegin&lt;&lt;endl; // itBegin++; // } // //第二种遍历方式(常用) // for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++){ // cout&lt;&lt;*it&lt;&lt;endl; // } //第三种遍历方式 for_each(v.begin(),v.end(),myPrint); } int main(){ test(); return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c649e8518785793be94e5c21433d630e/" rel="bookmark">
			修改表字段相关的sql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		修改表：
给表中添加一个新的列名
alter table 表名 add 类名 字段类型；
mysql&gt; alter table stu add sex varchar(2);
Query OK, 0 rows affected (0.02 sec)
Records: 0 Duplicates: 0 Warnings: 0
mysql&gt; desc stu;
+----------+-------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+----------+-------------+------+-----+---------+-------+
| id | int(11) | YES | | NULL | |
| name | varchar(10) | YES | | NULL | |
| age | int(11) | YES | | NULL | |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c649e8518785793be94e5c21433d630e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/228/">«</a>
	<span class="pagination__item pagination__item--current">229/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/230/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>