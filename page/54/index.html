<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a3f0f287a448982aac520cffe4779a/" rel="bookmark">
			Promise
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Promise简介 Promise是ES6新增类，用来解决异步的回调地狱问题，为异步提供更强大的性能支持，一个promise实例对象会存在三种状态，分别是pedding，fulfilled，rejected。创建实例的时候需要给Promise类传入一个回调函数，该回调函数可以传入两个参数，两个参数是两个函数，分别是resolve，reject函数。当触发resolve函数之后，promise的状态值变成fulfilled，之后会执行promise实例的then函数；当触发reject函数之后，promise的状态值会变成rejected，之后会执行promise实例的catch函数。
常见用法 const promise1 = new Promise((resolve, reject) =&gt; { // resolve(); reject(); }); promise1.then(() =&gt; { console.log("触发then函数") }).catch(() =&gt; { console.log("触发catch函数") }) 常用方法 then函数 当promise的状态从pedding变为fulfilled，会触发then函数，then函数接收一个函数作为参数，可以接收resolve函数传递过来的参数。
catch函数 当promise的状态从pedding变成rejected，会触发catch函数，catch函数也接收一个函数作为参数，可以接收reject函数传递过来的参数。
all函数 Promise.all([promise1, promise2]).then(() =&gt; { console.log("触发then函数"); }).catch(() =&gt; { console.log("触发catch函数"); }) race函数 Promise.race([promise1, promise2]).then(() =&gt; { console.log("触发then函数"); }).catch(() =&gt; { console.log("触发catch函数"); }) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc368e9b99469e4f1edf35aecfc8e6c8/" rel="bookmark">
			C#屏幕截取、保存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private Bitmap CaptureScreen1()
{
int screenWidth = Screen.PrimaryScreen.Bounds.Width;
int screenHeight = Screen.PrimaryScreen.Bounds.Height;
System.Drawing.Rectangle bounds = GetScreenBounds();
Bitmap bitmap=new Bitmap(bounds.Width, bounds.Height);
using (Graphics graphics = Graphics.FromImage(bitmap))
{
graphics.CopyFromScreen(System.Drawing.Point.Empty, System.Drawing.Point.Empty,bounds.Size);
}
return bitmap;
}
private Bitmap CaptureScreen2()
{
//处理分辨率问题
System.Drawing.Rectangle bounds =Screen.PrimaryScreen.Bounds;
float dpiX,dpiY;
using (Graphics graphics = Graphics.FromHwnd(IntPtr.Zero))
{ dpiX = graphics.DpiX / 96f;
dpiY = graphics.DpiY / 96f;
}
int screenWidth = (int)(bounds.Width * dpiX);
int screenHeight = (int)(bounds.Height * dpiY);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc368e9b99469e4f1edf35aecfc8e6c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04110322ea8c1395847b2001d5f63e8a/" rel="bookmark">
			C#操作网页WebBorowser和Selenium方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
方法一：使用Winform 的WebBorowser控件操控网页
方法二：使用Selenium操控网页
方法一：使用Winform 的WebBorowser控件操控网页 page_load
{
webBrowser1.DocumentCompleted += WebBorowser1_DocumentCompleted;
//Load web
webBrowser1.Navigate("https://website/test.com");
}
private void WebBorowser1_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)
{
System.Drawing.Rectangle screenSize = Screen.PrimaryScreen.Bounds;
webBrowser1.Width = screenSize.Width;
webBrowser1.Height =screenSize.Height;
// //webBrowser1.Width = webBrowser1.Document.Body.ScrollRectangle.Width;
// //webBrowser1.Height = webBrowser1.Document.Body.ScrollRectangle.Height;
HtmlElement element = webBrowser1.Document.GetElementsByTagName("a")[0];
if (element != null)
{
string elementContent = element.InnerText;
MessageBox.Show(elementContent);
}
else
{
MessageBox.Show("Not Found.");
}
//HtmlElementCollection elements = webBrowser1.Document.GetElementsByTagName("input"); // 替换为你要查找的元素标签名 //foreach (HtmlElement element in elements)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04110322ea8c1395847b2001d5f63e8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eafa505e9e7e512fe87da7ef56944f29/" rel="bookmark">
			如何实现一款功能强大的条形码二维码打印工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一款功能强大的条形码、二维码打印工具，适用于：防伪标签、物流标签、商品标签、超市价签、糖果食品标签、医药标签、珠宝标签、图书管理标签、吊牌、证卡、名片、胸牌等的设计制作及批量打印工作。
软件支持多种国家及国际标准的条码格式，并且支持扫描枪识别。
其超级易用及强大的标签设计器可以让用户快速设计制作出自己所需要的标签样式。 该软件操作简便灵活，支持各种类型纸张和打印机，并且无需购买昂贵的专用设备和耗材，大大降低了成本。此外，它还自带强大的编辑器，在快速编辑方面表现出色
该软件具有以下特点：
1. 支持普通喷墨、激光、专用条形码、二维码打印机、蓝牙打印机
2. 支持Code39、Code128等标准的条码格式,自定义标准备二维码； 3. 独创的超级易用及强大的标签设计器，条码/二维码尺寸任意设置，完全矢量，做到高精度条码打印；
4. 标签可以自定义大小；文字可以任意布局，设置大小颜色字体粗体斜体等；可添加图片。 5. 条码/二维码/流水序列号/生产日期标签打印，导入Excel表格批量打印标签
6. 页面操作简洁，0经验小白用户也可快速上手
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e9ca730e65e5c56d49e4ee800e6220b/" rel="bookmark">
			看看技术大佬是如何把ls命令玩到飞起
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号：“DevOps实战派”，获取更多DevOps和运维的精彩内容。
Linux中一个基本命令是ls，没有这个命令，我们会在浏览目录条目时会遇到困难。
ls命令用于列出文件和目录，默认上，它会列出当前目录的内容。而在带上参数后，我们可以用ls做更多的事情。
1. 不带参数运行ls 不带参数运行ls会只列出文件或者目录。看不到其他信息输出。
$ ls 2. 使用长清单模式 使用-l字符(小写L字符)，会显示当前目录内容的长列表。在接下来的例子中，我们会结合-l参数(这个参数经常使用)来得到更好的结果。
$ ls -l 这里是如何读取输出 :
第1列
第一个字母d意味着内容是目录或者文件。在上面的截图中，Desktop、 Documents、 Downloads 和 lynis-1.3.8是目录。如果是’-‘(减号)，这意味着它的内容是文件。当它是l(小写l字符)，意味这内容是链接文件。
下面的9个字符是关于文件权限。前3个rwx字符是文件的拥有者的权限，第二组3rwx是文件的所有组的权限，最后的rwx是对其他人访问文件的权限。
第2列 这行告诉我们有多少链接指向这个文件。
第3列 这行告诉我们谁是这个文件/文件夹的所有者。
第4列 这行告诉我们谁是这个文件/文件夹的所有组。
第5列 这行告诉我们这个文件/文件夹的以字节为单位的大小。目录的大小总是4096字节。
第6列 这告诉我们文件最后的修改时间。
第7列 这告诉我们文件名或者目录名。
3. 显示文件大小 以字节为单位看大小可能会不方便。6.5M读起来比6727680字节更简单。要这么做，我们可以使用-h与-l结合的参数。
$ ls -lh 另外一个可以这么做的参数是–si。这个参数和-h参数类似，但是-si以1000为单位，而-h以1024为单位。
$ ls -si 4. 排序文件大小 在我们可以显示文件大小之后，我们希望以文件大小排序。我们可以使用-S参数来这么做。这列表会从大到校排序。
$ ls -lhS 5. 测量大小 ls可以通过使用-block-size=SIZE改单位大小。这里的SIZE是：
K = Kilobyte
M = Megabyte
G = Gigabyte
T = Terabyte
P = Petabyte
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e9ca730e65e5c56d49e4ee800e6220b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff41067225ab09caebef27cbdb0f57b1/" rel="bookmark">
			SpringBoot 引入 SPEL 模板字符串替换的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring 表达式语言 (SpEL) 官方文档：https://docs.spring.io/spring-framework/docs/6.0.x/reference/html/core.html#expressions
文章目录 Spring 表达式语言 (SpEL)模板占位符 替换 {$name}common-text 方式：模板字符转替换 ${} 模板占位符 替换 {$name} import org.springframework.context.expression.MapAccessor; import org.springframework.expression.spel.support.StandardEvaluationContext; import org.springframework.util.PropertyPlaceholderHelper; import java.text.MessageFormat; import java.util.HashMap; import java.util.Map; /** * 内容占位符 替换 * &lt;p&gt; * 模板占位符格式{$name} */ public class ContentHolderUtil { /** * 占位符前缀 */ private static final String PLACE_HOLDER_PREFIX = "{$"; /** * 占位符后缀 */ private static final String PLACE_HOLDER_SUFFIX = "}"; private static final StandardEvaluationContext EVALUATION_CONTEXT; private static final PropertyPlaceholderHelper PROPERTY_PLACEHOLDER_HELPER = new PropertyPlaceholderHelper( PLACE_HOLDER_PREFIX, PLACE_HOLDER_SUFFIX); static { EVALUATION_CONTEXT = new StandardEvaluationContext(); EVALUATION_CONTEXT.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff41067225ab09caebef27cbdb0f57b1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b602ea18e66dd3b2fab30af20b2db25d/" rel="bookmark">
			Linux—watch命令详解– 周期性执行命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言语法格式常用参数参考实例 前言 watch命令以周期性的方式执行给定的指令，指令输出以全屏方式显示。watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。
语法格式 watch [参数] [命令]
常用参数 -n/–intervalwatch默认每2秒运行一下程序，可以用-n或-interval来指定间隔的时间-d/–differences用-d或–differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来-t/–no-title关闭watch命令在顶部的时间间隔、命令、当前时间的输出-h/–help查看帮助文档 参考实例 实时查看显存占用情况：(0.1秒刷新一次)
[root@linuxcool ~]# watch -n 0.1 nvidia-smi 重复执行uptime命令：
[root@linuxcool ~]# watch uptime 每隔一秒高亮显示网络链接数的变化情况：
[root@linuxcool ~]# watch -n 1 -d netstat -ant 每10秒一次输出系统的平均负载：
[root@linuxcool ~]# watch -n 10 'cat /proc/loadavg' 监测磁盘inode和block数目变化情况：
[root@linuxcool ~]# watch -n 1 "df -i;df" 监测当前目录中test.txt文件的变化：
[root@linuxcool ~]# watch -d 'ls -l|grep test.txt' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d657dbeb2ef28bb03319b727e33aab20/" rel="bookmark">
			牛客SQL大厂面试真题 知识点总结 （二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
1.窗口函数与聚合函数 1.1窗口函数 1.1.1 窗口函数的作用及常见的窗口函数
1.2 聚合函数
1.2.1聚合函数常见的作用
1.3窗口函数与聚合函数的关系 ：
2.常见的窗口函数（与聚合函数相结合）
2.1常见的与聚合函数结合的窗口函数 2.2sum()over
2.2.1sum()over()用法解析:
2.2.2具体案例:
2.3avg()over()
2.3.1avg()over()用法解析:AVG() OVER() 是 SQL 中用于进行窗口函数计算的语法，允许在结果集的每一行上计算指定列的累积平均值。
2.3.2具体案例:
2.4min()over和max()over()
2.4.1min()over()和max()over()用法解析:
2.4.2具体案例 ：
结尾致谢：
前言： 当面对牛客SQL大厂面试真题，我们需要对SQL的各种知识点有全面的了解和掌握。这些知识点涵盖了SQL的各个方面 ，在面试中，能够熟练运用这些知识点，并且能够根据实际业务场景进行灵活应用，将会极大地提升我们的竞争力。
通过对这些知识点的系统总结和学习，我们将能够更加深入和全面地理解SQL，为未来在面试和实际工作中的应用打下坚实的基础。让我们一起努力，掌握SQL的精髓，展现出我们的技术实力和解决问题的能力！
1.窗口函数与聚合函数 窗口函数和聚合函数在数据库中常常一起使用，它们之间有一定的关系，但也有明显的区别
1.1窗口函数 1.1.1 窗口函数的作用及常见的窗口函数 窗口函数是一种特殊的SQL函数，可以用来对查询结果集中的某个子集进行计算。
窗口函数可以用来计算每一行与其相关联的行的聚合值，而不是整个结果集的聚合值。
窗口函数通常与OVER子句一起使用，以定义窗口的范围和排序方式。通过窗口的定义，可以灵活地控制窗口函数的计算范围。
一些常见的窗口函数包括ROW_NUMBER、RANK、DENSE_RANK、SUM、AVG等。
1.2 聚合函数 1.2.1聚合函数常见的作用 聚合函数是对数据集进行计算并返回单个值的函数，如SUM、AVG、COUNT等。
聚合函数通常用于对整个结果集进行计算，返回一个汇总值。
聚合函数会将结果集中的多行数据合并为一个值，例如计算总和、平均值、最大值、最小值等。
聚合函数通常与GROUP BY子句一起使用，用于按照指定的列对数据进行分组计算。
1.3窗口函数与聚合函数的关系 ： 窗口函数可以在聚合函数内部使用，用于对聚合函数的结果进行进一步的处理或筛选。
在某些情况下，窗口函数和聚合函数可以实现类似的功能，但窗口函数更加灵活，可以提供更多的操作方式。
在实际使用中，可以根据需求选择使用窗口函数、聚合函数或它们的组合来实现所需的数据处理和分析操作。
2.常见的窗口函数（与聚合函数相结合） 2.1常见的与聚合函数结合的窗口函数 sum() over() min()over() avg()over() max()over()
2.2sum()over
2.2.1sum()over()用法解析: 当使用SUM() OVER()时，可以计算指定列的累积总和。
2.2.2具体案例: 假设我们有一个名为 sales 的表，包含销售数据，其中包括商品名称、销售日期和销售额。我们想要计算每个销售日期的销售额累积总和。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d657dbeb2ef28bb03319b727e33aab20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f08d9f38e5a17b3d8218225800672b3/" rel="bookmark">
			vue中导入外部资源传统方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 created () { const oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = 'https://res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js'; document.body.appendChild(oScript); }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f726308eff12d996f90cd8217c7318/" rel="bookmark">
			Python中按指定数量分割列表字符串的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 处理列表数据时，有时我们需要将一个包含长字符串的列表分割成按照特定长度的小字符串的多个列表。这在文本处理、批量数据处理或者当我们需要将数据分块进行并行处理时非常常见。Python作为一个强大的编程语言，提供了很多方便的方法来实现这一功能。本文将探讨如何在Python中实现按一定数量分割列表里的字符串，并提供实用的代码示例。
基本方法 我们将使用Python的列表推导式和切片操作来实现这一功能。首先创建一个函数，它接受一个字符串列表和一个数字，这个数字指定了每个分割块的大小。
def split_strings_in_list(string_list, chunk_size): # 对列表中的每个字符串元素进行处理 return [ # 对单个字符串进行切片，分割成指定大小的子串 [string[i:i + chunk_size] for i in range(0, len(string), chunk_size)] for string in string_list ] 使用示例 考虑到我们有一个包含几个长字符串的列表，并且我们想要将每个字符串都分割成长度为5的子串。
# 原始字符串列表 string_list = ["hellopythonworld", "listcomprehensionisuseful", "splittingstrings"] # 调用函数，指定每个分割块的大小为5 split_list = split_strings_in_list(string_list, 5) # 输出结果查看 for sublist in split_list: print(sublist) 输出结果将是：
['hello', 'pytho', 'nworl', 'd'] ['listc', 'ompre', 'hensi', 'onisu', 'seful'] ['splitt', 'ingst', 'rings'] 处理不均等长度的字符串 如果字符串长度不能被分割块大小整除，最后一个块可能会比其他块小。上面的方法已经处理了这种情况，不需要额外修改。
代码优化 在某些情况下，我们可能需要对这个函数进行优化。比如，如果我们知道列表中所有字符串长度都很相近，我们可以一次性处理整个列表，而不是对列表中的每个字符串逐一处理。
def split_string_list_optimized(string_list, chunk_size): # 先将所有的字符串连接在一起 joined_string = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3f726308eff12d996f90cd8217c7318/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4bc18c4bc168e35acf3e204c31e947e/" rel="bookmark">
			Docker之数据卷&amp;自定义镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、数据卷
二、Dockerfile
1. 作用
2. 自定义centos
3. 自定义tomcat8
一、数据卷 #数据卷 将宿主机的目录与容器的目录进行挂载，实现数据共享
docker run -di --name c2 -v /home/lijie/data/:/home/lijie/data/ centos:7
结论：不管宿主机、容器在指定目录创建文件夹还是文件，都会被共享
#数据卷容器
容器与容器共享目录
docker run -di -v /home/lijie/data/c4 --name c4 centos:7
docker run -di --volumes-from c4 --name c6 centos:7
其中c4为数据卷容器，c6为普通容器，其中c4就起到一个桥接作用，我们可以通过docker inspect查看容器的详细情况
会发现c4、c6目录挂载情况是一样的
结论：不管c4、c6在指定目录创建文件夹还是文件，都会会被共享
二、Dockerfile 1. 作用 用来制作镜像的文件
2. 自定义centos #编辑Dockerfile文件
vim MyCentosDockerfile
#Dockerfile文件中的内容
FROM centos:7 MAINTAINER lijie"lijie@qq.com" RUN yum -y install vim
RUN yum install net-tools.x86_64 -y
CMD /bin/bash
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4bc18c4bc168e35acf3e204c31e947e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f350dc2035bd31c21d4285f57b24b8ec/" rel="bookmark">
			【wpf】关于绑定的一点明悟
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景简介 软件功能为，读取一个文件夹下的所有子文件夹，每个文件夹对自动对应生成 一组 “按键+四个勾选”
按键点击触发，可以发送与其对应文件夹中的一些内容。这个绑定的过程我在之前的文章有过详细的介绍，非常的简单。
这里回顾一下，贴一段代码：
&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height="auto"/&gt; &lt;RowDefinition/&gt; &lt;/Grid.RowDefinitions&gt; &lt;DockPanel&gt; &lt;Label DockPanel.Dock="Right" Content="{Binding BtnName}"/&gt; &lt;Button DockPanel.Dock="Right" Command="{Binding NextCmd}"&gt;下一个&lt;/Button&gt; &lt;Button DockPanel.Dock="Right" Command="{Binding FliesReloadCmd}"&gt;文件重载&lt;/Button&gt; &lt;hc:TextBox Text="{Binding saveInfo.BaseDirectoryPath}" hc:TitleElement.Title="路径：" hc:TitleElement.TitlePlacement="Left" hc:TitleElement.HorizontalAlignment="Center" hc:TitleElement.TitleWidth="50"/&gt; &lt;/DockPanel&gt; &lt;ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Visible" HorizontalScrollBarVisibility="Visible" &gt; &lt;ItemsControl ItemsSource="{Binding ButtonList}"&gt; &lt;ItemsControl.ItemsPanel&gt; &lt;ItemsPanelTemplate&gt; &lt;UniformGrid Columns="4"/&gt; &lt;/ItemsPanelTemplate&gt; &lt;/ItemsControl.ItemsPanel&gt; &lt;ItemsControl.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;Grid Margin="5"&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition/&gt; &lt;ColumnDefinition/&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Button Content="{Binding Name}" Command="{Binding RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type UserControl}}, Path=DataContext.TestCmd}" CommandParameter="{Binding Path=Content, RelativeSource={RelativeSource Mode=TemplatedParent}}"/&gt; &lt;StackPanel Grid.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f350dc2035bd31c21d4285f57b24b8ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9caeccc4f06471d8e767c7e5b25cf69d/" rel="bookmark">
			java系列之 复制原始目录文件到新的 目录文件【Windows 和 Linux 均可使用】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我 | 在这里
✈️公众号 | 热爱技术的小郑 。文章底部有个人公众号二维码。回复 Java全套视频教程 或 前端全套视频教程 即可获取 300G+ 教程资料及项目实战案例
🚀 邮箱 | 2977429967@qq.com
文章目录 前言案例Demo注意点 前言 将一个目录下的文件 复制一份到新的 文件目录。如果原始文件带有权限。
案例Demo import java.io.IOException; import java.nio.file.*; import java.nio.file.attribute.BasicFileAttributes; public class CopyMoveDirectoryWithPermissions { public static void main(String[] args) { Path sourceDirectory = Paths.get("path/to/source/directory"); Path destinationDirectory = Paths.get("path/to/destination/directory"); try { // 删除目标目录下的所有内容 deleteDirectory(destinationDirectory); // 复制整个目录 copyDirectory(sourceDirectory, destinationDirectory); // 或者移动整个目录 // moveDirectory(sourceDirectory, destinationDirectory); System.out.println("Directory copied/moved successfully."); } catch (IOException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9caeccc4f06471d8e767c7e5b25cf69d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/893f8ad1abcb9a396e787f608d9d5913/" rel="bookmark">
			ffmpeg使用amix混合多个音频时音量变小或音量不一致问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 最近工作中遇到一个音频混合后，导出文件播放音量不一致问题。
问题描述 例如，7个音频混合起来，发现第一个音频的音量变得很小，第2个稍大一点，直到第7个最大（等于原音频）。
ffmpeg -i 24281_1.mp3 -i 24281_2.mp3 -i 24281_3.mp3 -i 24281_4.mp3 \ -i 24281_5.mp3 -i 24281_6.mp3 -i 24281_7.mp3 \ -filter_complex "[0:a][1:a][2:a][3:a][4:a][5:a][6:a]amix=inputs=7:duration=longest[Audio]" \ -map "[Audio]" -acodec mp3 -y amix.mp3 结果amix.mp3的音量是一开始最小，逐渐变大，直到最后一段变成和源文件一样大。
原因分析 尝试了多种方法无法解决。最终发现stackover关于该问题有一个讨论：stackoverflow。
知乎也有人讨论过：如何解决FFmpeg合并多个音频并解决声音变小的问题？ - JJ Chan的回答 - 知乎。
这个是因为ffmpeg叠加音频的机制导致的。使用amix的时候每个引入的视频会以1/n的音量播放，其中n是活动的inputs的数量。例如一共18个音频的话，这时候处理第一个音频的时候就是一共有18个活动的inputs，音频会以1/18的音量播放。处理第二个的时候，第一个音频已经不活动了， 就剩17个inputs，音频会以1/17的音量播放。所以导致越到后面的声音越大。
解决方法 方法1 知道了原因，可以把amix 缩小的声音给放大回来，修改上面的命令：
ffmpeg -i 24281_1.mp3 -i 24281_2.mp3 -i 24281_3.mp3 -i 24281_4.mp3 \ -i 24281_5.mp3 -i 24281_6.mp3 -i 24281_7.mp3 \ -filter_complex "\ [0:a]volume=7[a0];\ [1:a]volume=6[a1];\ [2:a]volume=5[a2];\ [3:a]volume=4[a3];\ [4:a]volume=3[a4];\ [5:a]volume=2[a5];\ [6:a]volume=1[a6];\ [a0][a1][a2][a3][a4][a5][a6]amix=inputs=7:duration=longest[Audio]"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/893f8ad1abcb9a396e787f608d9d5913/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f43d5cbda7546c7d1b482994c607792/" rel="bookmark">
			Linux/Docker 修改系统时区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. Linux 系统1.1 通过 timedatectl 命令操作1.2 直接修改 /etc/localtime 文件 2. Docker 容器中的 Linux 操作环境：
CentOS / AlmaOSMySQL Docker 镜像 1. Linux 系统 1.1 通过 timedatectl 命令操作 使用 timedatectl list-timezones 命令列出可用的时区列表，以便选择要设置的时区。
使用 timedatectl set-timezone 命令设置所选的时区。
例如，要将时区设置为 “Asia/Shanghai”，您可以执行以下命令：
sudo timedatectl set-timezone Asia/Shanghai 使用 timedatectl 命令验证时区设置是否已经生效：
timedatectl 将看到类似以下输出：
Local time: Tue 2024-02-20 16:36:57 CST Universal time: Tue 2024-02-20 08:36:57 UTC RTC time: Tue 2024-02-20 08:36:57 Time zone: Asia/Shanghai (CST, +0800) System clock synchronized: yes NTP service: active RTC in local TZ: no 这表明时区已经成功设置为 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f43d5cbda7546c7d1b482994c607792/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8530a37b852c9a3ecec1d990c2697943/" rel="bookmark">
			Mybatis-Plus 5分钟快速上手，10分钟熟练使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小伙伴们好，欢迎关注，一起学习，无限进步
以下为学习 mybatis-plus 过程中的笔记
mybatis-plus 官网地址：https://mp.baomidou.com/
文章目录 特性快速开始mybatis-plus 配置插入测试及雪花算法主键生成策略查询更新删除查询指定字段子查询 自动填充乐观锁通用枚举代码自动生成器方式一（新版）方式二（旧版） 分页插件测试分页 多数据源简介特性约定使用方法添加相关依赖修改配置使用 **@DS** 切换数据源相关代码多数据源最全配置 特性 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 快速开始 1、创建数据库 mybatisplus
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8530a37b852c9a3ecec1d990c2697943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb1deea24767b64294a11a5e178245e5/" rel="bookmark">
			bert 相似度任务训练完整版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务 之前写了一个相似度任务的版本：bert 相似度任务训练简单版本,faiss 寻找相似 topk-CSDN博客
相似度用的是 0，1，相当于分类任务，现在我们相似度有评分，不再是 0,1 了，分数为 0-5，数字越大代表两个句子越相似，这一次的比较完整，评估，验证集，相似度模型都有了。
数据集
链接：https://pan.baidu.com/s/1B1-PKAKNoT_JwMYJx_zT1g 提取码：er1z 原始数据好几千条，我训练数据用了部分 2500 条，验证，测试 300 左右，使用 cpu 也用了好几个小时
train.py import torch import os import time from torch.utils.data import Dataset, DataLoader from transformers import BertTokenizer, BertModel, AdamW, get_cosine_schedule_with_warmup from sklearn.metrics.pairwise import cosine_similarity import numpy as np # 设备选择 # device = torch.device("cuda" if torch.cuda.is_available() else "cpu") device = 'cpu' # 定义文本相似度数据集类 class TextSimilarityDataset(Dataset): def __init__(self, file_path, tokenizer, max_len=128): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb1deea24767b64294a11a5e178245e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27ac6d2b0ad33f95eea8855773502679/" rel="bookmark">
			TypeScript 实现的轻量级内存数据库 warehouse
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为要实现 HexoPress，我不得不去研究 hexo 的源代码，只有这样，才能更好地以两边都兼容的方式去操作 hexo 内的对象。本文将介绍 hexo 引用的一个库 warehouse，这个库实现了一个内存级数据库，还支持持久化到本地磁盘。这个组件在 hexo 系统中，充当着缓存的角色。
一、简介 Hexo 是一个静态站点生成器，支持将各种格式的源码文件（常用的是 html 和 markdown 格式）静态化成网页，在生成器运转的过程中，为了处理网页上的一些关系型数据，不得不将一些数据缓存到内存中进行操作，比如分类、标签、上一篇、下一篇链接等等。
于是，作者开发了这个内存级数据库 warehouse ，作为 Hexo 的内部组件使用。也开源在了 GitHub 上了。这个数据库成为我能够开发 HexoPress 的重要设施基础。因为HexoPress 的立意，就是让创作者去“有机地”去处理自己的整个博客的数据，但是 Markdown 文件在磁盘上是线性存储的，一个一个的文件。分类、标签这种高度共享的元数据信息，就不能有效地去管理了。
所以，在开发过程中，我持续去阅读 Hexo 的源码，并且了解它的 API，学习到了不少 js 和 typescript 开发的知识和技巧。也学习到了不少 js 软件代码组织的技巧。这里就分享一下 warehouse 的代码构造，希望给大家一点启发。
二、数据库抽象 不知道是作者的情怀使然，还是格局使然，整个软件的命名，或者说定义的各种抽象，概念都大得不得了。如果你按照自己的常识去理解，反倒会增加困难。比如项目叫 warehouse，这是数据仓库的意思，不过这个东西远远不能充当数据仓库，哈哈哈。
1. SchemaType 这个是整个系统的最基本的抽象，是对基本数据类型的封装，并抽象了所有数据类型的基本操作，比如比较之类的东西。充分利用了 TypeScript 的泛型特性。
class SchemaType&lt;T&gt; { options: { required: boolean; default?: (() =&gt; T) | T; }; default: () =&gt; T; /** * SchemaType constructor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/27ac6d2b0ad33f95eea8855773502679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847fe74c31999ba6df0e2b947aad369d/" rel="bookmark">
			C与C&#43;&#43;的内存管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、C/C++的内存分布 1. 栈又叫堆栈--非静态局部变量/函数参数/返回值等等，栈是向下增长的。
2. 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。
3. 堆用于程序运行时动态内存分配，堆是可以上增长的。
4. 数据段--存储全局数据和静态数据。
5. 代码段--可执行的代码/只读常量。
二、C语言中动态内存管理方式 malloc/calloc/realloc/free
void Test () { int* p1 = (int*) malloc(sizeof(int)); free(p1); int* p2 = (int*)calloc(4, sizeof (int)); int* p3 = (int*)realloc(p2, sizeof(int)*10); free(p3 ); } 三、C++内存管理方式 C语言内存管理方式在C++中可以继续使用，但有些地方就无能为力，而且使用起来比较麻烦，因此C++又提出了自己的内存管理方式：通过new和delete操作符进行动态内存管理。
1.new/delete操作内置类型 void Test() { // 动态申请一个int类型的空间 int* ptr4 = new int; // 动态申请一个int类型的空间并初始化为10 int* ptr5 = new int(10); // 动态申请10个int类型的空间 int* ptr6 = new int[3]; delete ptr4; delete ptr5; delete[] ptr6; } 注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]，注意：匹配起来使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847fe74c31999ba6df0e2b947aad369d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68689810c6cf3c9dad09425b747e2f57/" rel="bookmark">
			前端实现排序数组的合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组的排序与合并都是极为常见的操作。其中，排序的实现有着非常多的现成代码，这里就不再赘述了；对于无序数组的合并与排序，可以先合并，再排序。
这里要分享的则是前端实现将两个升序数组合并成一个升序数组，并支持自定义数组元素的比较函数，以及是否需要对相同元素进行去重。
export function mergeSortedArray&lt;T = any&gt;( array1: T[], array2: T[], compare?: { // 自定义前者是否小于后者的判断函数，默认为小于操作符 less?: (value1: T, value2: T) =&gt; boolean, // 自定义去重的判断函数，默认为undefined，即不去重 same?: (value1: T, value2: T) =&gt; boolean, } ) { if (!array1.length) { return array2; } if (!array2.length) { return array1; } const less = compare?.less || ((value1: T, value2: T) =&gt; value1 &lt; value2); if (less(array1.at(-1)!, array2[0])) { // 如果array1最后一个元素比array2第一个元素小，直接拼接 return array1.concat(array2); } if (less(array2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68689810c6cf3c9dad09425b747e2f57/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/53/">«</a>
	<span class="pagination__item pagination__item--current">54/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/55/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>