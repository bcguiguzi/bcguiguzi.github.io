<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e7e7b8d3bf18c76a86a95b4946e0d15/" rel="bookmark">
			2021第12届蓝桥杯省赛c组java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.2021c组java https://blog.csdn.net/qq_43652327/article/details/115913757
https://blog.csdn.net/qq_43449564/article/details/115876990
https://zhuanlan.zhihu.com/p/368789485
https://ydlin.blog.csdn.net/article/details/116541595
https://blog.csdn.net/m0_46260869/article/details/115908148?spm=1001.2014.3001.5501
1.卡片 public class T3卡片 { static int[] arr = new int[10]; public static void main(String[] args) { for (int i = 0; i &lt; arr.length; i++) { arr[i] = 3; } for (int i = 1; i &lt; 50000; i++) { if (isZero(i)) { System.out.println(--i); break; } } } private static boolean isZero(int x) { while (x&gt;0) { arr[x%10]--; if (arr[x%10] &lt; 0) { return true; } x = x/10; } return false; } } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e7e7b8d3bf18c76a86a95b4946e0d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a3ee57def48921b623b31208f47528/" rel="bookmark">
			You are using the runtime-only build of Vue where the template compiler is not available. Either pre
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在升级脚手架到vue-cli3.0版本的时候出现了这个报错：
[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.
我在这里大概说一下出现这个报错的原因在哪里和解决办法
原因 vue有两种形式的代码 compiler（模板）模式和runtime模式（运行时），vue模块的package.json的main字段默认为runtime模式， 指向了"dist/vue.runtime.common.js"位置。
这是vue升级到2.0之后就有的特点。
而我的main.js文件中，初始化vue却是这么写的，这种形式为compiler模式的，所以就会出现上面的错误信息
// compiler new Vue({ el: '#app', router: router, store: store, template: '&lt;App/&gt;', components: { App } }) 解决办法 将main.js中的代码修改如下就可以
//runtime new Vue({ router, store, render: h =&gt; h(App) }).$mount("#app") 到这里我们的问题还没完，那为什么之前是没问题的，之前vue版本也是2.x的呀？
这也是我要说的第二种解决办法
因为之前我们的webpack配置文件里有个别名配置，具体如下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a3ee57def48921b623b31208f47528/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47b0c8294e745fb227122ab2899d401e/" rel="bookmark">
			html5新加入的内容,10个html5增加的重要新特性和内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章开篇之前我们先了解一下什么是 html5，百度上是这样定义 html5 的：万维网的核心语言、标准通用标记语言下的一个应用超文本标记语言(HTML)的第五次重大修改。
其实说白了 html5 也就是人为定义的一些规则和新的 api 的集合。下面我就介绍一些开发常用的 html5 新特性：
一：canvas 标签
your browser does not support the canvas tag var canvas=document.getElementById('myCanvas');
var ctx=canvas.getContext('2d');
ctx.fillStyle='#FF0000';
ctx.fillRect(0,0,80,100);
渲染结果：
通过这个元素你可以绘制你想要的图案。
二：video标签​​
your browser does not support the video tag //可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。
video 标签具有以下属性：
1.autoplay:如果出现该属性，则视频在就绪之后马上播放
2.controls:如果出现该属性，则向用户显示控件，比如播放按钮
3.height：设置视频播放器高度
4.loop：如果出现该属性，则会重复播放
5.preload：如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用“autoplay”，则忽略该属性。
6.src：视频地址
7.width：设置视频播放器宽度
三：localStorage 和 sessionStorage
Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽，另外 cookie 还需要指定作用域，不可以跨域调用。
1.localStorage: 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
2.sessionStorage: 用于本地存储一个会话(session)中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。
Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie。sessionStorage.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47b0c8294e745fb227122ab2899d401e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ad3c01435ea5c304e51a2004b72fba/" rel="bookmark">
			记一次esp01s小度语音控制灯实现(小白记录)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、网上购买低价模块。包括（esp01s、继电器模块、AC-DC模块）全部下来在15元以下
2、arduino
下载esp8266最新库
1）设置-附加开发板管理网址：http://arduino.esp8266.com/stable/package_esp8266com_index.json
2）管理库增加8266最新库
3）开发板选择‘Generic ESP8266 Module’
3、注册点灯科技，并下载app,进行添加设备操作
4、代码
#define BLINKER_WIFI #define BLINKER_DUEROS_OUTLET #include &lt;Blinker.h&gt; char auth[] = "**"; char ssid[] = "**"; char pswd[] = "**"; BlinkerButton Button1("btn-abc"); #define LED_BUILTIN_LIGHT 0 void button1_callback(const String &amp; state) { BLINKER_LOG("get button state: ", state); if (state == BLINKER_CMD_ON) { Button1.print("on"); } else if (state == BLINKER_CMD_OFF) { Button1.print("off"); } digitalWrite(LED_BUILTIN_LIGHT, !digitalRead(LED_BUILTIN_LIGHT)); digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); } void duerPowerState(const String &amp; state) { if (state == BLINKER_CMD_ON) { digitalWrite(LED_BUILTIN_LIGHT, 1); BlinkerDuerOS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98ad3c01435ea5c304e51a2004b72fba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb95230c05c0a9f6bfd295e44baec436/" rel="bookmark">
			java 把一个大的数组按照元素数量拆分为多个小的数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如需要把数组
['a','b','c','d','f']，按照每3个为一组拆分为多个数组，如下 ['a','b','c'],['a','b','d'],['a','b','f'],['a','c','d'],['a','c',''f],['a','d','f'] ['b','c','d'], ['b','c','f'], ['b','d','f'] ['c','d','f'] 直接上代码
/* * @Author gao * @Description //把一个集合中的元素，按照指定传入的needNum的数量再拆分为多个小的集合 * ['a','b','c','d','f'],假设传入的needNum为3，则结果为 * ['a','b','c'],['a','b','d'],['a','b','f'],['a','c','d'],['a','c',''f],['a','d','f'] * ['b','c','d'], ['b','c','f'], ['b','d','f'] * ['c','d','f'] * @Param [addlist, begin, needNum, strings, result] * @return void **/ public static void sortCompareData(List&lt;String&gt; addlist, int begin, int needNum, String [] strings, List&lt;List&lt;String&gt;&gt; result){ for (int i = begin; i &lt; strings.length; i++) { addlist.add(strings[i]); if (addlist.size() == needNum) { //放到新集合中，防止下面的集合操作影响已存储数据 result.add(new ArrayList&lt;&gt;(addlist)); //移除掉当前位置的元素 addlist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb95230c05c0a9f6bfd295e44baec436/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69744db1134bed5981079275ec56bb4a/" rel="bookmark">
			蛇形矩阵，找规律
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 描述
蛇形矩阵是由1开始的自然数依次排列成的一个矩阵上三角形。 例如，当输入5时，应该输出的三角形为： 1 3 6 10 15 2 5 9 14 4 8 13 7 12 11 请注意本题含有多组样例输入。
输入描述：
输入正整数N（N不大于100）
输出描述：
输出一个N行的蛇形矩阵。
#include&lt;stdio.h&gt; int n; int i; int j; int main(void) { scanf("%d",&amp;n); int a[n][n]; a[0][0] = 1; for(i=1;i&lt;n;i++) { a[i][0]=a[i-1][0]+i; } for(i=0;i&lt;n;i++) { printf("%d ",a[i][0]); for(j=1;j&lt;n-i;j++) { a[i][j]=a[i][j-1]+j+1+i; printf("%d ",a[i][j]); } printf("\n"); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/819f60cafcf9d705cf28e3bbeea583b7/" rel="bookmark">
			用html语言编写彩虹雨流动代码,前端H5 canvas 爱心和彩虹雨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/p&gt;
var canvas = document.getElementById(‘canvas’),
ctx = canvas.getContext(‘2d’),
canvasW = canvas.width = window.innerWidth,
canvasH = canvas.height = window.innerHeight,
canvasWHalf = canvasW / 2,
canvasHHalf = canvasH / 2,
xoff = canvasWHalf – 306,
yoff = 50,
bg = ‘00061a’,
id = 0,
raindrops = [],
minSize = 1,
maxSize = 4,
minSpeed = 5,
maxSpeed = 20,
minHue = 0,
maxHue = 360,
maxAmount = 50;
function random(min, max) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/819f60cafcf9d705cf28e3bbeea583b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed6994a50fd0d1bff1ecdd39223bfe01/" rel="bookmark">
			【开发经验】mybatis-plus雪花算法自动生成机器id原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、雪花算法原理2、自动生成唯一机器号源码 1、雪花算法原理 雪花算法使用一个 64 bit 的 long 型的数字作为全局唯一 id。这 64 个 bit 中，其中 1 个 bit 是不用的，然后用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。
1bit，不用，因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0。41bit-时间戳，用来记录时间戳，毫秒级。10bit-工作机器id，用来记录工作机器id。12bit-序列号，序列号，用来记录同毫秒内产生的不同id。即可以用0、1、2、3、…4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号。 SnowFlake可以保证：
所有生成的id按时间趋势递增整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分） 如上大概了解了雪花算法的原理，而且也知道机器号对于雪花算法的重要性。如果机器号一样，可能会出现id重复的情况。
mybatis-plus自3.3.0开始,默认使用雪花算法+UUID(不含中划线)，但是它并没有强制让开发者配置机器号。这一点很是疑惑，这样可能会让不了解雪花算法的人埋下了一个坑。
但是这么强大的一个框架难道真的没有做优化吗？带着问题，查看了下mybatis-plus雪花算法源码com.baomidou.mybatisplus.core.toolkit.Sequence。最终发现在没有设置机器号的情况下，会通过当前物理网卡地址和jvm的进程ID自动生成。这真的是一个较好的解决方案。一般在一个集群中，MAC+JVM进程PID一样的几率非常小。
2、自动生成唯一机器号源码 核心代码。有两个构造方法，一个无参构造，一个有参构造。
public Sequence() { //通过当前物理网卡地址获取datacenterId this.datacenterId = getDatacenterId(maxDatacenterId); //物理网卡地址+jvm进程pi获取workerId this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); } /** * 有参构造器 * * @param workerId 工作机器 ID * @param datacenterId 序列号 */ public Sequence(long workerId, long datacenterId) { Assert.isFalse(workerId &gt; maxWorkerId || workerId &lt; 0, String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed6994a50fd0d1bff1ecdd39223bfe01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc1592fe15a88a0857c823cfc9ae2193/" rel="bookmark">
			切片上传（秒传、断点续传）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结果展示 每个方块都代表一个文件切片的上传状态。绿色表示此文件切片已经上传成功；蓝色高度代表正在上传的文件切片的上传进度；红色代表上传失败。
前端实现 1. 文件切片 将文件分割成指定大小的chunk，存储到数组中
createFileChunk(file, size=CHUNK_SIZE) { const chunks = [] let cur = 0 while (cur &lt; this.file.size) { chunks.push({index: cur, file: this.file.slice(cur, cur+size)}) cur+=size } return chunks } 2.计算文件hash 采用md5算法计算hash，作为文件唯一标识。
如果文件太大，md5算法会比较耗时，所以对文件进行抽样，然后再计算。
md5算法插件：spark-md5
async calculateHashSimple () { const file = this.file return new Promise(async (resolve) =&gt; { const offset = 0.1 * 1024 * 1024 const size = file.size let cur = offset // 取第一段内容 let chunks = [file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc1592fe15a88a0857c823cfc9ae2193/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0df5332e8177b1e228b290e0c0893a49/" rel="bookmark">
			java面试题：讲一讲synchronized
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. synchronized用法2. synchronized重量级锁原理3. synchronized锁升级过程4. 可重入锁 1. synchronized用法 可修饰静态方法可修饰实例方法可修饰代码块 2. synchronized重量级锁原理 synchronized对应的锁信息存储在对象头，对象头中会保存锁标志，线程ID等信息。 锁标志则标识当前是偏向锁，轻量级锁还是重量级锁。 先讲重量级锁：
synchronized的重量级锁在字节码的层次表现为两条指令，分别是monitorenter和monitorexit。即在修饰代码块的前面加monitorenter，代码块的最后加monitorexit。每执行一次monitorenter，对象头中的锁计数器就会加1，每执行一次monitorexit，锁计数器就会减1。只有锁计数器为0的时候，线程才可以获取当前的锁。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。 3. synchronized锁升级过程 1.偏向锁
线程第一次获取的时候会通过CAS操作将对象头的锁标志位变成偏向锁，并将对象头中的ThreadID改成自己的ID。锁就进入偏向模式之后如果没有其他的线程来争夺，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程。直到第二个线程也开始获取当前对象锁，并且当前线程没有释放锁的时候，就会升级为轻量级锁。 2.轻量级锁
当前线程使用CAS将对象头的mark Word锁标记位替换为锁记录指针,如果成功,当前线程获得锁。如果失败，表示其他线程竞争锁,当前线程尝试通过自旋获取锁如果自旋成功则依然处于轻量级状态如果自旋失败,升级为重量级锁 3.重量级锁
刚刚已经讲过了原理过程
4. 可重入锁 synchronized是可重入锁，允许当前获取锁的线程再次获取，但是每次获取锁计数器都会加1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f3789123e8cfb626d29fd684aa99555/" rel="bookmark">
			java面试题：讲一讲进程，线程，协程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文仅仅是梳理面试遇到这个题目的答题过程梳理
文章目录 1. 进程和线程的区别2. 进程切换和线程切换的区别3. 协程和线程的区别 1. 进程和线程的区别 1）进程是资源分配的基本单位，线程是任务调度的基本单位。
2）从包含关系来看，一个进程中可以包含多个线程。
3）从内存分配来看，一个进程拥有自己一套独立地址空间和内存，不同进程之间的资源独立。而一个进程中的多个线程共享虚拟地址空间和部分资源。
4）从健壮性来看，一般不同进程之间的影响较小，而线程之间的影响较大，某个线程挂掉可能会导致该进程或线程挂掉，因此进程的健壮性更好。
5）从资源开销来看，进程的切换比线程的切换开销较大。
这里就要注意一个点了，开始可以详细讲一下为什么进程的切换比线程的切换开销大。
2. 进程切换和线程切换的区别 进程切换的三个步骤：
从用户态转内核态切换新的页表，然后使用新的虚拟地址空间上下文的切换，指的是栈，寄存器中的数据替换等操作。 线程切换的一个步骤：
从用户态转内核态上下文切换，指的是栈，寄存器中的数据替换等操作。 这里要注意的是进程和线程的切换都需要转到内核态进行操作，因此线程切换之所以消耗资源较小的原因就在于多线程共享虚拟地址空间，不需要进行页表的切换。而往往页表的切换比较消耗资源。
3. 协程和线程的区别 一般认为一个线程包含多个协程，但是实际上协程可以看做用户态的线程，因此协程的切换比线程切换消耗的资源更小，不涉及用户态和内核态的转换。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/773307cd8566e58e4d01c963ba6d37d2/" rel="bookmark">
			VC&#43;&#43; 网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看到一篇比较不错的总结：(53条消息) 孙鑫vc笔记——网络编程部分_至浊至愚-CSDN博客在此基础上，进行补充。
1. 七层模型
1） 对等层之间不允许直接通信，如两个通信实体的传输层不允许直接通信；
2） 上层使用下层提供的服务，如传输层使用网络层的服务；
3） 下层向上层提供服务；
4） 对等层之间有一个虚拟连接，看起来是直接通信，实际是通过下层来通信，最终的通信是通过物理层的线路完成。
2. OSI各层协议
1） 应用层。远程登录协议Telnet、文件传输协议FTP、超文本传输协议HTTP、域名服务DNS、简单邮件传输协议SMTP（发送邮件）、邮局协议POP3（收取邮件）。
2） 传输层。TCP，面向连接的可靠连接，三次握手建立连接，保证传输到对方；UDP，无连接不可靠，直接向某个IP发送数据，不保证收到，优点是实时性较高。对完整性要求不高的应用使用UDP，如视频点播；对完整性要求较高的应用要使用TCP，如下载安装程序，缺少少量数据就无法正常安装。
3） 网络层。IP、ICMP、IGMP
3．数据封装
一台计算机要发送数据到另一台计算机，数据首先必须打包，打包的过程成为封装。封装就是在数据前面加上特定的协议头部。
1） 在OSI模型中，对等层协议之间交换的信息单元成为协议数据单元（PDU）。
2） 下层把上层的PDU作为本层的数据封装，然后加入本层的头部（有的还要加入尾部，例如数据链路层），头部包含数据传输所需的控制信息，例如将信件包上信封。
3） 某一层只能识别对等层封装的“信封”，而对于信封内部的数据只是提交给上层，本层不作处理。
3. TCP/IP模型
1） 网络接口层对应物理层、数据链路层；
2） 网络层对应网络层；
3） 传输层对应传输层；
4） 应用层对应会话层、表示层和应用层。
4．端口
传输层提供应用程序通信的能力，为了标识通信实体中进行通信的应用程序，TCP/IP协议提出了端口的概念。
1） 应用程序通过系统调用与某端口建立连接后，传输层传给该端口的数据都被相应的应用程序接收，应用程序发给传输层的数据都通过该端口输出。
2） 端口号与协议有关，TCP和UDP各自的端口号相互独立。基于TCP和UDP的不同的网络程序可以有相同的端口号。
3） 端口号范围是0-65535，1024以下的端口号保留给预定的服务，如http使用80端口。因此我们编写网络程序时要使用1024以上的端口号。
5．Socket
由伯克利大学推出的一种应用程序访问通信协议的系统调用，最先在Unix上，之后引进到Windows。
套接字存在于通信区域中，通信区域又叫地址族，将通过套接字通信的进程的共有特效综合在一起，套接字通常只与同一地址族的套接字交换数据（也可跨区域通信，需要执行某种转换进程）。Windows Sockets只支持一个通信区域：网际域（AF_INET），这个域被使用网际协议族通信的进程使用。
6.网络字节顺序
有的计算机起始地址存放地位字节（地位先存），有的计算机在起始地址存放高位字节（高位先存），一般的PC都是低位先存，TCP/IP协议使用16位整数和32位整数的高位先存格式。通信时要采用网络字节顺序
7.套接字类型
1）流式套接字（SOCK_STREAM）。基于TCP实现，提供面向连接、可靠的数据传输服务，数据无差错、无重复的发送，且按发送顺序发送接收；
2）数据报式套接字（SOCK_DGRAM）。基于UDP实现，提供无连接服务，数据包以独立包形式发送，不保证无措，数据可能丢失，接收顺序混乱；
3）原始套接字（SOCK_RAW）。
8．基于TCP（面向连接）的socket编程
服务器端程序：
1） 创建套接字（socket）；
2） 将套接字绑定到一个本地地址和端口（bind）；
3） 将套接字设为监听模式，准备接收客户请求（listen）；
4） 当请求到来时，接受请求，返回一个新的对应于此次连接的套接字（accept）；
5） 用返回的套接字和客户端进行通信（send/recv）；
6） 返回，等待另一客户请求；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/773307cd8566e58e4d01c963ba6d37d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787bc853eb485af2a4c2f2682efe84e7/" rel="bookmark">
			多模态机器翻译 | (1) 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘录自 机器翻译 基础与模型 东北大学
文章目录 1. 背景2. 机器翻译需要更多的上下文3. 图像翻译4. 基于图像增强的文本翻译4.1 基于特征融合的方法4.2 基于联合模型的方法 5. 参考文献 1. 背景 基于上下文的翻译是机器翻译的一个重要分支。传统方法中，机器翻译通常被 定义为对一个句子进行翻译的任务。但是，现实中每句话往往不是独立出现的。比 如，人们会使用语音进行表达，或者通过图片来传递信息，这些语音和图片内容都 可以伴随着文字一起出现在翻译场景中。此外，句子往往存在于段落或者篇章之中， 如果要理解这个句子，也需要整个段落或者篇章的信息，而这些上下文信息都是机 器翻译可以利用的。
本节在句子级翻译的基础上将问题扩展为更大的上下文中的翻译，具体包括语音翻译、图像翻译、篇章翻译三个主题。这些问题均为机器翻译应用中的真实需求。 同时，使用多模态等信息也是当下自然语言处理的热点研究方向之一。（本博客重点关注图像翻译，语音翻译和篇章翻译请参见原书。）
2. 机器翻译需要更多的上下文 长期以来，机器翻译都是指句子级翻译。主要原因在于，句子级的翻译建模可 以大大简化问题，使得机器翻译方法更容易被实践和验证。但是人类使用语言的过 程并不是孤立地在一个个句子上进行的。这个问题可以类比于人类学习语言的过程: 小孩成长过程中会接受视觉、听觉、触觉等多种信号，这些信号的共同作用使得他 们产生对客观世界的“认识”，同时促使他们使用“语言”进行表达。从这个角度说， 语言能力并不是由单一因素形成的，它往往伴随着其他信息的相互作用，比如，当 人们翻译一句话的时候，会用到看到的画面、听到的语调、甚至前面说过的句子中 的信息。
广义上，当前句子以外的信息都可以被看作一种上下文。比如，下图中，需要 把英语句子“A girl jumps off a bank .”翻译为汉语。但是，其中的“bank”有多个含 义，因此仅仅使用英语句子本身的信息可能会将其翻译为“银行”，而非正确的译文“河床”。但是，图17.1中也提供了这个英语句子所对应的图片，显然图片中直接展示 了河床，这时“bank”是没有歧义的。通常也会把这种使用图片和文字一起进行机器翻译的任务称作多模态机器翻译(Multi-Modal Machine Translation)。
模态(Modality)是指某一种信息来源。例如，视觉、听觉、嗅觉、味觉都可以被 看作是不同的模态。因此视频、语音、文字等都可以被看作是承载这些模态的媒介。 在机器翻译中使用多模态这个概念，是为了区分某些不同于文字的信息。除了图像 等视觉模态信息，机器翻译也可以利用听觉模态信息。比如，直接对语音进行翻译， 甚至直接用语音表达出翻译结果。
除了不同信息源所引入的上下文，机器翻译也可以利用文字本身的上下文。比 如，翻译一篇文章中的某个句子时，可以根据整个篇章的内容进行翻译。显然这种 篇章的语境是有助于机器翻译的。在本章接下来的内容中，会对机器翻译中使用不同上下文(多模态和篇章信息)的方法展开讨论。
3. 图像翻译 在人类所接受的信息中，视觉信息的比重往往不亚于语音和文本信息，甚至更 多。视觉信息通常以图像的形式存在，近几年，结合图像的多模态机器翻译受到了 广泛的关注。多模态机器翻译(下图 (a))简单来说就是结合源语言和其他模态(例如图像等)的信息生成目标语言的过程。这种结合图像的机器翻译还是一种狭义上的“翻译”，它本质上还是从源语言到目标语言或者说从文本到文本的翻译。事实上从图像到文本(下图(b))的转换，即给定图像，生成与图像内容相关的描述， 也可以被称为广义上的“翻译”。例如，图片描述生成(Image Captioning)就是一种 典型的图像到文本的翻译。当然，这种广义上的翻译形式不仅仅包括图像到文本的转换，还可以包括从图像到图像的转换(图©)，甚至是从文本到图像的转换(下图(d))等等。这里将这些与图像相关的翻译任务统称为图像翻译。
本博客重点关注多模态机器翻译，即基于图像增强的文本翻译，其他有关图像翻译的内容参见原书。
4. 基于图像增强的文本翻译 在文本翻译中引入图像信息是最典型的多模态机器翻译任务。虽然多模态机器 翻译还是一种从源语言文本到目标语言文本的转换，但是在转换的过程中，融入了 其他模态的信息减少了歧义的产生。例如前文提到的通过与源语言相关的图像信息， 将“A girl jumps off a bank .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/787bc853eb485af2a4c2f2682efe84e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0739e238d8303d16b8b65fac04703504/" rel="bookmark">
			LTE 核心 MME SGW PGW作用：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		含义
(1) MME是一个信令实体，主要负责移动性管理、承载管理、用户的鉴权认证、SGW和PGW的选择等功能；
(2) SGW终结和E-UTRAN的接口，主要负责用户面处理，负责数据包的路由和转发等功能，支持3GPP不同接入技术的切换，发生切换时作为用户面的锚点；对每一个与EPS相关的UE，在一个时间点上，都有一个SGW为之服务。SGW和PGW可以在一个物理节点或不同物理节点实现。
(3) PGW终结和外面数据网络（如互联网、IMS等）的SGi接口，是EPS锚点，即是3GPP与non-3GPP网络间的用户面数据链路的锚点，负责管理3GPP和non-3GPP间的数据路由，管理3GPP接入和non-3GPP接入（如WLAN、WiMAX等）间的移动，还负责DHCP、策略执行、计费等功能；如果UE访问多个PDN，UE将对应一个或多个PGW。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fe411239d38726d8fb0df2a8ffd9582/" rel="bookmark">
			＜记录＞ windows“ping“设备指定端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		tcping工具的使用 简介一、安装tcping二、tcping的使用总结 简介 windows平台下只支持ping操作来检验是否可以到达指定设备。
例如我们有一个路由器网关192.168.1.1，使用cmd命令ping 192.168.1.1，可以查看我们的电脑能否与其连通。
但在一些特殊情况下，我们需要测试设备某个端口是否可以到达，比如我们有一个web服务器，架设在路由上，使用的是80端口。那么直接使用ping命令是不能够检测80端口是否能够到达的。因为ping命令使用的是ICMP协议，不指定对应的端口。
tcping就可以实现该功能。
一、安装tcping 首先要下载tcping工具：https://elifulkerson.com/projects/tcping.php
这里直接下载tcping.exe文件，tcping-src.zip文件为源码 ，感兴趣的小伙伴也可以去看下是如何实现的。
下载完之后，就是一个.exe可执行文件，直接执行是没有任何效果的，需要在cmd命令中调用。
有3种可以调用的方法：
方法1：进入cmd命令，进入tcping所在路径，然后调用。 方法2：添加tcping路径到环境变量中，任意路径打开cmd都可以调用 现在把tcping工具放置在F:\00.工具\23.TCPing\路径下,复制该路径。
添加环境变量
新建一个选项，把路径黏贴到选项中，点击确定保存即可。
然后我们重新打开一个cmd，测试是否可以正常使用。
方法3：添加到已有环境变量位置中 我们可以将tcping直接复制到已经有的环境变量位置中，比如复制到跟ping命令同一位置下。
打开一个cmd，使用where命令查找ping的位置，可以看到ping命令所在的位置。
将tcping命令，复制到ping命令所在的位置下：
复制完成后，我们再次在cmd命令下输入tcping，查看是否可以正常使用。
到这里就完成了tcping的安装了。
二、tcping的使用 详细的使用教程可以在下载页面查看，或者直接在cmd下输入tcping，就会出现使用介绍。
这里只用介绍简单的端口ping测试
命令格式：tcping ip地址 端口 如：tcping 192.168.1.1 80
总结 1.tcping可以对设备某个端口进行连通测试，非常的方便。
2.熟悉windows环境变量的作用与配置
3.熟悉了cmd的where命令的作用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77aa3e8c10012bfd7f2b71a462424975/" rel="bookmark">
			mysql的NULL导致的5个坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.distinct 数据丢失 当使用 count(distinct col1, col2) 查询时，如果其中一列为 NULL，那么即使另一列有不同的值，那么查询的结果也会将数据丢失，如下 SQL 所示：
select count(distinct name,mobile) from person; 查询执行结果如下：
数据库的原始数据如下：
从上述结果可以看出手机号一列的 10 条数据都是不同的，但查询的结果却为 8。
3.select 数据丢失 如果某列存在 NULL 值时，如果执行非等于查询（&lt;&gt;/!=）会导致为 NULL 值的结果丢失。比如以下这个数据：
我需要查询除 name 等于“Java”以外的所有数据，预期返回的结果是 id 从 2 到 10 的数据，但当执行以下查询时：
select * from person where name&lt;&gt;'Java' order by id; -- 或 select * from person where name!='Java' order by id; 查询结果均为以下内容：
可以看出为 NULL 的两条数据凭空消失了，这个结果并不符合我们的正常预期。
解决方案 要解决以上的问题，只需要在查询结果中拼加上为 NULL 值的结果即可，执行 SQL 如下：
select * from person where name&lt;&gt;'Java' or isnull(name) order by id; 最终的执行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77aa3e8c10012bfd7f2b71a462424975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4783a0da935b6b68d527816ef0c7d9e9/" rel="bookmark">
			spring cloud 知识点汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、Spring Cloud 综述（一）Spring Cloud 是什么（二）Spring Cloud 解决什么问题（三）Spring Cloud 架构1、Spring Cloud 核心组件2、Spring Cloud 体系结构（组件协同⼯作机制） （四）Spring Cloud 与 Dubbo 对比（五）Spring Cloud 与 Spring Boot 的关系 二、第一代 Spring Cloud 核心组件（一）Eureka服务注册中心1、关于服务注册中心①服务注册中心一般原理②主流服务中心对比 2、服务注册中心组件 Eureka①Eureka 基础架构②Eureka 交互流程及原理 3、实例演示 （二）Ribbon负载均衡（三）Hystrix熔断器（四）Feign远程调用组件（五）GateWay网关组件（六）Spring Cloud Config 分布式配置中心（七）Spring Cloud Stream消息驱动组件 三、常见问题及解决方案（一）Eureka 服务发现慢的原因1、服务端缓存2、客户端缓存①Eureka Client 缓存②Ribbon 缓存 （二）Spring Cloud 各组件超时1、Ribbon2、Hystrix3、Feign 四、Spring Cloud⾼级进阶（一）微服务监控之 Turbine 聚合监控（二）微服务监控之分布式链路追踪技术 Sleuth + Zipkin1、 分布式链路追踪技术适用场景（问题场景）①场景描述②分布式链路追踪技术③市场上的分布式链路追踪方案 2、分布式链路追踪技术核心思想3、Sleuth + Zipkin （三）微服务统一认证方案 Spring Cloud OAuth2 + JWT1、微服务架构下统一认证思路①基于Session的认证方式②基于token的认证方式 2、OAuth2开放授权协议/标准3、Spring Cloud OAuth2 + JWT 实现 五、 第二代 Spring Cloud 核心组件（SCA）（一）Nacos注册中心和配置中心（二）sentinel分布式系统的流量防卫兵（三）Nacos + Sentinel + Dubbo 三剑合璧 六、源码 一、Spring Cloud 综述 （一）Spring Cloud 是什么 Spring Cloud是一系列框架的有序集合（Spring Cloud是一个规范）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4783a0da935b6b68d527816ef0c7d9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cd44f3883b607b361d4a523ebf7a0f2/" rel="bookmark">
			经典SQL五十题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 表结构题目1.2.3.45678910 1、查询“01”课程比“02”课程成绩高的所有学生的学号；
2、查询平均成绩大于60分的同学的学号和平均成绩；
3、查询所有同学的学号、姓名、选课数、总成绩
4、查询姓“李”的老师的个数；
5、查询没学过“张三”老师课的同学的学号、姓名；
6、查询学过编号“01”并且也学过编号“02”课程的同学的学号、姓名；
7、查询学过“张三”老师所教的课的同学的学号、姓名；
8、查询课程编号“01”的成绩比课程编号“02”课程低的所有同学的学号、姓名；
9、查询所有课程成绩小于60分的同学的学号、姓名；
10、查询没有学全所有课的同学的学号、姓名；
11、查询至少有一门课与学号为“01”的同学所学相同的同学的学号和姓名；
12、查询和"01"号的同学学习的课程完全相同的其他同学的学号和姓名
13、把“SC”表中“张三”老师教的课的成绩都更改为此课程的平均成绩；
14、查询没学过"张三"老师讲授的任一门课程的学生姓名
15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩
16、检索"01"课程分数小于60，按分数降序排列的学生信息
17、按平均成绩从高到低显示所有学生的平均成绩
18、查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率
19、按各科平均成绩从低到高和及格率的百分数从高到低顺序
20、查询学生的总成绩并进行排名
21、查询不同老师所教不同课程平均分从高到低显示
22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩
23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比
24、查询学生平均成绩及其名次
25、查询各科成绩前三名的记录
26、查询每门课程被选修的学生数
27、查询出只选修了一门课程的全部学生的学号和姓名
28、查询男生、女生人数
29、查询名字中含有"风"字的学生信息
30、查询同名同性学生名单，并统计同名人数
31、查询1990年出生的学生名单(注：Student表中Sage列的类型是datetime)
32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列
37、查询不及格的课程，并按课程号从大到小排列
38、查询课程编号为"01"且课程成绩在60分以上的学生的学号和姓名；
40、查询选修“张三”老师所授课程的学生中，成绩最高的学生姓名及其成绩
42、查询每门功课成绩最好的前两名
43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列
44、检索至少选修两门课程的学生学号
45、查询选修了全部课程的学生信息
46、查询各学生的年龄
47、查询本周过生日的学生
48、查询下周过生日的学生
49、查询本月过生日的学生
50、查询下月过生日的学生
表结构 学生表：student
教师表：teacher
课程表：
成绩表：
题目 1. 查询"01"课程比"02"课程成绩高的学生的信息及课程分数
解：
SELECT s.s_id, s.s_name, b.cid1, b.score1, b.cid2, b.score2 FROM student s JOIN ( SELECT a.s_id as id, a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cd44f3883b607b361d4a523ebf7a0f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd7a312cf5f13691f12030a09815320c/" rel="bookmark">
			idea上使用Struts2出现工件部署问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单的方法，降低Tomcat的等级。
起初我使用的是Tomcat 10.0.6，使用的Struts2的版本是struts-2.5.26，运行会发现有找不到servelt.filter的问题，也有架包冲突的问题，总之就是找不到解决的办法。
之后，我发现，Tomcat 10.0.6中的Servlet所在包在servlet-api.jar里面的jakarta.servlet中，可以看到，servlet的前缀是jakarta
而在struts-2.5.26中，可以看到，对应的servlet在servlet-api.jar里面的javax.servlet中。因此两个版本的servlet会发生冲突。
唯一的办法就是，降低Tomcat的版本，Tomcat 8一系列的版本中都是javax.servelt，所以就不会再发生工件部署的问题了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/839f181bb0a8ad970967408c59acc048/" rel="bookmark">
			SSH协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		建连过程 第一阶段：协议版本协商
如果能一起工作，进入下一阶段，如不能，服务器断开 TCP 连接，会话结束明文传输 第二阶段：算法协商
公钥算法列表、加密算法列表、消息验证码算法列表、压缩算法列表等通过DH秘钥交换算法生成并传递会话秘钥，以后的通信数据都通过该秘钥使用对称加密算法加密（例如AES算法） DH算法虽然也是非对称算法，但是专门用来交换秘钥，不用于加密双方利用自己的私钥，对方公钥和原始共享素数来计算共享密钥。虽然这个过程各自独立，都使用自己私钥和对方公钥，所以能生成相同共享密钥 此后的通信都已经被加密了 第三阶段：认证阶段
服务器会发送公钥给客户端 客户端会和保存在~/.ssh/known_hosts中的公钥对比，以验证服务端的合法性 密码登陆 认证协议中密码以明文的形式存在，其安全性依赖于传输层通过协商的秘钥进行加密来实现 公钥认证登陆 首先要手动将客户端的公钥复制到服务端的~/.ssh/authorized_keys 文件中原理 服务端用客户端的公钥加密一个 256 位的随机字符串客户端接收后使用自己的私钥解密，然后将这个字符串和会话 id 合并在一起，对结果应用 MD5 散列函数并把散列值返回给服务器服务器进行相同的 MD5 散列函数处理，如果客户端和该值可以匹配，那么认证成功，允许登陆 重放攻击 如果有人窃听了第三阶段的数据进行重放攻击，会造成非法登录吗？ 每次建连前都会交换会话秘钥用于加密，而每次会话秘钥都不一样，所以重放攻击无效 如果有人对于一次操作指令进行重放攻击，会造成非法操作吗？ 一般会通过时间戳+随机nonce来防御 中间人攻击 SSH没有采取第三方CA来认证身份，因此理论上存在中间人攻击的风险 如果攻击者插在用户与远程主机之间（比如在公共的 wifi 区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么 SSH 的安全机制就荡然无存了 虽然 SSH 从原理上不能抵御中间人攻击，但 SSH 首次连接会下载服务端的公钥，并提示服务器的公钥指纹，用户可以核对此指纹与服务器公钥生成的指纹是否一致 下次访问时客户端将会核对服务端发来的公钥和本地保存的是否相同，不同就发出中间人攻击的警告拒绝连接结论：如果首次连接没有中间人，之后的连接就无需担心中间人
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/316/">«</a>
	<span class="pagination__item pagination__item--current">317/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/318/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>