<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ae187b9533e9b52d9fce58f0e2d3e74/" rel="bookmark">
			c&#43;&#43;作业8-A(1394)求图形的面积和体积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem A: 求图形的面积和体积 Time Limit: 1 Sec Memory Limit: 128 MB
Submit: 7378 Solved: 4620
[Submit][Status]
Description 根据不同的图形，求面积或体积输出。圆周率取3.14。
main()函数中使用多态的思想，用派生树上最早祖先类Graphic的指针创建和访问其孩子类的对象。
图形（Graphic类）分作平面图形（Shape类）和立体图形（Solid类）两种。
正方形（Square类）是一种平面图形，圆形（Circle）也是。
球体（Ball类）是一种立体图形，也是圆形的扩充。
立方体（Cube类）是一种立体图形，也是正方形的扩充。
-----------------------------------------------------------------------------
你设计一系列类，满足上述派生树的要求，使得main()函数能够正确运行。
函数调用格式见append.cc。
append.cc中已给出main()函数。
-----------------------------------------------------------------------------
Input 输入的第一个整数n（n&lt;100），表示有n组测试数据。每组测试数据由两部分组成：一是图形的类型，有“square”、“cube”、“ball”、“circle”四种，分别表示正方形、立方体、球体、圆形；二是这种图形的边长或者半径，用double类型存储。
Output 每组测试数据给出一行输出。
对应这四种不同的图形，分别产生四种输出：
正方形输出：“Square, side:x, area:y.”，x为输入的边长，y为面积。
立方体输出：“Cube, side:x, area:y, volume:z.”，x为输入的边长，y为表面积，z为体积。
球体输出：“Ball, radius:x, area:y, volume:z.”，x为输入的半径，y为表面积，z为体积。
圆形输出：“Circle, radius:x, area:y.”，x为输入的半径，y为面积。
Sample Input 6 square 3 cube 3 ball 4 circle 4 cube 2 circle 1
Sample Output Square, side:3, area:9. Cube, side:3, area:54, volume:27.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ae187b9533e9b52d9fce58f0e2d3e74/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9630d786ba4ee722ff162bdb65d44a33/" rel="bookmark">
			c&#43;&#43;作业2-D(1330)平面上的点和线——Point类、Line类 (IV)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem D: 平面上的点和线——Point类、Line类 (IV) Time Limit: 1 Sec Memory Limit: 128 MB
Submit: 8574 Solved: 5899
[Submit][Status]
Description 在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。
根据“append.cc”，完成Point类和Line类的构造方法和show()方法，输出各Line对象和Point对象的构造和析构次序。
接口描述：
Point::show()方法：按格式输出Point对象。
Line::show()方法：按格式输出Line对象。
Input 输入的第一行为N，表示后面有N行测试样例。
每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。
Output 输出为多行，每行为一条线段，起点坐标在前终点坐标在后，每个点的X坐标在前，Y坐标在后，Y坐标前面多输出一个空格，用括号包裹起来。输出格式见sample。
C语言的输入输出被禁用。
Sample Input 4 0,0 1,1 1,1 2,3 2,3 4,5 0,1 1,0
Sample Output(一句一行) Point : (1, -2) is created. Point : (2, -1) is created. Point : (0, 0) is created. Point : (0, 0) Point : (0, 0) is created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9630d786ba4ee722ff162bdb65d44a33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec05981075af3f513547126494d9f7bf/" rel="bookmark">
			c&#43;&#43;作业2-C（1329）平面上的点和线——Point类、Line类 (III)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem C: 平面上的点和线——Point类、Line类 (III) Time Limit: 1 Sec Memory Limit: 128 MB
Submit: 11684 Solved: 5974
[Submit][Status]
Description 在数学上，平面直角坐标系上的点用X轴和Y轴上的两个坐标值唯一确定，两点确定一条线段。现在我们封装一个“Point类”和“Line类”来实现平面上的点的操作。
根据“append.cc”，完成Point类和Line类的构造方法和show()方法，输出各Line对象和Point对象的构造和析构次序。
接口描述：
Point::show()方法：按格式输出Point对象。
Line::show()方法：按格式输出Line对象。
Input 输入的第一行为N，表示后面有N行测试样例。每行为两组坐标“x,y”，分别表示线段起点和终点的x坐标和y坐标，两组坐标间用一个空格分开，x和y的值都在double数据范围内。
Output 输出为多行，每行为一条线段，起点坐标在前终点坐标在后，每个点的X坐标在前，Y坐标在后，Y坐标前面多输出一个空格，用括号包裹起来。输出格式见sample。
C语言的输入输出被禁用。
Sample Input 4 0,0 1,1 1,1 2,3 2,3 4,5 0,1 1,0
Sample Output Point : (1, -2) is created. Point : (2, -1) is created. Point : (0, 0) is created. Point : (0, 0) ========================= Point : (0, 0) is created.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec05981075af3f513547126494d9f7bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5e5cb4cfa56cd9a63358d3744dfd320/" rel="bookmark">
			c&#43;&#43;实验2-B(1279)重载函数：max
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem B: 重载函数：max Time Limit: 1 Sec Memory Limit: 128 MB
Submit: 8891 Solved: 6979
[Submit][Status]
Description 编写两个名为max的函数，它们是重载函数 ，用于求两个整数或实数的最大值。它们的原型分别是：
int max(int a,int b);
double max(double a,double b);
返回值是a和b的最大值。
Input 输入4个数，前两个数是int类型的整数，后2个数是double类型的实数。
Output 输出2个数，每个数占一行。第一个数对应于输入的两个整数的最大值，第二个数对应于输入的两个实数的最大值。
Sample Input 1 2 1.4 1.3
Sample Output 2 1.4
HINT Append Code append.cc,
int main() { int a,b; double c,d; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;max(a,b)&lt;&lt;endl; cin&gt;&gt;c&gt;&gt;d; cout&lt;&lt;max(c,d)&lt;&lt;endl; return 0; } 答案：
#include &lt;iostream&gt; using namespace std; int max(int a,int b) { if(a&gt;b) return a; else return b; } double max(double a,double b) { if(a&gt;b) return a; else return b; } int main() { int a,b; double c,d; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;max(a,b)&lt;&lt;endl; cin&gt;&gt;c&gt;&gt;d; cout&lt;&lt;max(c,d)&lt;&lt;endl; return 0; } 分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5e5cb4cfa56cd9a63358d3744dfd320/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19133ee3fb7eadc2f9ff16342e4118bf/" rel="bookmark">
			format()使用,格式化,填充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 昨天简单的使用了 format()实现对字符串的格式化,这篇对format()的使用进行一些补充,主要是点号的使用和对字符串的填充
1.对内容进行填充
j = 1234 print(f'j={j}') # 正常输出 print(f'j={j:6d}') # 6位,不够在左边填充空格 ,默认空格 print(f'j={j:06d}') # 6位,不够的在左边填充0 print(f'j={j:*&gt;6d}') # 6位,不够的在左边填充* print(f'j={j:*&lt;6d}') # 6位,不够的在右边填充* print(f'j={j:*^6d}') # 6位,不够的在两边填充*,也是居中 print(f'j={j:,}') # 千位分隔符,多用于金额 """ 输出结果: j=1234 j= 1234 j=001234 j=**1234 j=1234** j=*1234* j=1,234 """ 点号. 的使用 # 格式化浮点数 .后是小数点后的位数,多余的根据四舍五入,不够的补0 i = 0.31415926 print(f'i={i}') print(f'i={i:.9f}') print(f'i={i:.4f}') print(f'i={i:.2%}') print(f'i={i:.2%}') """ 输出结果: i=0.31415926 i=0.314159260 i=0.3142 i=31.42% """ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cae223894c6ff17bac4db297ceb16c2/" rel="bookmark">
			7-2两个有序链表序列的合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
已知两个非降序链表序列S1与S2，设计函数构造出S1与S2合并后的新的非降序链表S3。
输入格式: 输入分两行，分别在每行给出由若干个正整数构成的非降序序列，用−1表示序列的结尾（−1不属于这个序列）。数字用空格间隔。
输出格式: 在一行中输出合并后新的非降序链表，数字间用空格分开，结尾不能有多余空格；若新链表为空，输出NULL。
输入样例: 1 3 5 -1 2 4 6 8 10 -1 输出样例: 1 2 3 4 5 6 8 10 答案1：
#include&lt;bits/stdc++.h&gt; using namespace std; typedef struct LNode { int data; struct LNode *next; }LNode,*LinkList; LinkList createlist() { LinkList L=(LinkList)malloc(sizeof(LinkList)); L-&gt;next=NULL; LinkList q=L; int e; while((cin&gt;&gt;e)&amp;&amp;e!=-1) { LinkList p=(LinkList)malloc(sizeof(LinkList)); p-&gt;next=NULL; p-&gt;data=e; q-&gt;next=p; q=p; } return L; } LinkList Merge(LinkList L1,LinkList L2) { L1=L1-&gt;next; L2=L2-&gt;next; LinkList L=(LinkList)malloc(sizeof(LinkList)); L-&gt;next=NULL; LinkList q=L; while(L1||L2) { LinkList p=(LinkList)malloc(sizeof(LinkList)); p-&gt;next=NULL; if(L1==NULL||L1-&gt;data&gt;L2-&gt;data) { p-&gt;data=L2-&gt;data; L2=L2-&gt;next;//不要忘记移动指针 q-&gt;next=p; q=p; } else { p-&gt;data=L1-&gt;data; L1=L1-&gt;next;//不要忘记移动指针 q-&gt;next=p; q=p; } } return L; } void print(LinkList L3) { L3=L3-&gt;next; if(L3==NULL) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cae223894c6ff17bac4db297ceb16c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32066bebc8acf4044fd3c09917bab760/" rel="bookmark">
			Python新年烟花代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pygame 绘制烟花的基本原理
1，发射阶段：在这一阶段烟花的形状是线性向上，通过设定一组大小不同、颜色不同的点来模拟“向上发射” 的运动运动，运动过程中 5个点被赋予不同大小的加速度，随着时间推移，后面的点会赶上前面的点，最终所有点会汇聚在一起，处于 绽放准备阶段。
2，烟花绽放：烟花绽放这个阶段，是由一个点分散多个点向不同方向发散，并且每个点的移动轨迹可需要被记录，目的是为了追踪整个绽放轨迹。
3，烟花凋零，此阶段负责描绘绽放后烟花的效果，绽放后的烟花，而在每一时刻点的下降速度和亮度（代码中也叫透明度）是不一样的，因此在代码里，将烟花绽放后将每个点赋予两个属性：分别为重力向量和生命周期，来模拟烟花在不同时期时不同的展现效果。
# @Author : 小红牛 # 微信公众号：WdPython import math from random import randint, uniform, choice import pygame vector = pygame.math.Vector2 gravity = vector(0, 0.3) DISPLAY_WIDTH = 1100 DISPLAY_HEIGHT = 700 trail_colours = [(45, 45, 45), (60, 60, 60), (75, 75, 75), (125, 125, 125), (150, 150, 150)] dynamic_offset = 1 static_offset = 5 class Firework: def __init__(self): self.colour = (randint(0, 255), randint(0, 255), randint(0, 255)) self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32066bebc8acf4044fd3c09917bab760/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07694defd2ea04f93cf3d4548ab80b61/" rel="bookmark">
			【华为OD机试 C卷】出租车计费
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 程序员小明打了一辆出租车去上班。出于职业敏感，他注意到这辆出租车的计费表有点问题，总是偏大
出租车司机解释说他不喜欢数字4，所以改装了计费表，任何数字位置遇到数字4就直接跳过，其余功能都正常
比如
23再多一块钱就交为25
39再多一块钱变为50
399再多一块钱交为500
小明识破了司机的使俩，准备利用自己的学识打败司机的阴谋
给出计费表的表面读数，返回实际产生的费用。
输入描述 第一行为输入为N 表示里程表的读数
1&lt;=N&lt;=888888888
输出描述 一个数字 代表实际产生的费用 以回车结束
用例
输入 5
输出 4
输入 17
输出 15
题解代码 int 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1329392fa7fef4eb785a5f1b4d01ba48/" rel="bookmark">
			Vite开启https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装Chocolatey
（1）以管理员身份运行PowerShell
（2）设置Chocolatey安装位置
$env:ChocolateyInstall='E:\Program_Files\Chocolatey' （3）安装Chocolatey
[Environment]::SetEnvironmentVariable('ChocolateyInstall',$env:ChocolateyInstall,'Machine') Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 2、安装mkcert
choco install mkcert 3、生成https证书
（1）新建文件夹来存放证书（这步可不做，但是生成的证书会在c盘中）
cd D:/证书 （2）执行命令生成证书
mkcert localhost 127.0.0.1 4、Vite配置https证书
server: { host: true, port: 8886, cors: true, open: true, https: { key: fs.readFileSync("keys/localhost+1-key.pem"), // 读取我们上面生成的公钥 cert: fs.readFileSync("keys/localhost+1.pem"),	// 读取我们上面生成的证书 }, proxy: {}, }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d3056c90fd4ecc5e824d61ba19258d8/" rel="bookmark">
			「从ES到CK 06」clickhouse的数据可视化工具clickvisual
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导航 在完成将公司日志数据从Elasticsearch(下称ES)转战到Clickhouse后，个人认为有必要将过程记录分享。限于篇幅及便于分类组织，我会以一个系列文章的形式记录：
01 《Elasticsearch vs Clickhouse》02 《Clickhouse的基础知识扫盲》03 《​Clickhouse多分片多副本集群部署​》04 《​​Clickhouse表引擎选择和表结构设计​》05 《​clickhouse高效数据处理工具vector​》06 《​​​​​​​​​clickhouse的数据可视化工具clickvisual​》07 《kibana自定义插件跳转clickvisual》08 《妙用clickvisual api实现用户自动管理》（敬请期待） 一、常见的clickhouse数据可视化工具 根据clickhouse官方文档推荐，以下的比较常见的clickhouse数据开源可视化工具：
名称
简述
特点/主要功能
Tabix
ClickHouse Web 界面
浏览器直接连接 ClickHouse，不需要安装其他软件。高亮语法的编辑器。自动命令补全。查询命令执行的图形分析工具。配色方案选项。 HouseOps
一个交互式 UI/IDE 工具，可以运行在 OSX, Linux and Windows 平台中
查询高亮语法提示，可以以表格或 JSON 格式查看数据。支持导出 CSV 或 JSON 格式数据。支持查看查询执行的详情，支持 KILL 查询。图形化显示，支持显示数据库中所有的表和列的详细信息。快速查看列占用的空间。服务配置。 灯塔
ClickHouse的轻量级Web界面
包含过滤和元数据的表列表。带有过滤和排序的表格预览。只读查询执行。 DBeaver
通用的桌面数据库客户端
使用语法高亮显示查询开发。表格预览。自动完成。 clickvisual
轻量级的开源日志查询、分析、报警的可视化平台
支持分析日志库一键创建支持日志采集配置管理支持自定义索引配置支持报警配置支持权限粒度到库和表的权限配置 二、什么是clickvisual ClickVisual 是一个轻量级的开源日志查询、分析、报警的可视化平台，致力于提供一站式应用可靠性的可视化的解决方案。既可以独立部署使用，也可作为插件集成到第三方系统。目前是市面上唯一一款支持 ClickHouse 的类 Kibana 的业务日志查询平台，其具有如下特性：
√ 支持可视化的查询面板，可查询命中条数直方图和原始日志。
√ 支持设置日志索引功能，分析不同索引的占比情况。
√ 支持可视化的 VS Code 风格配置中心，能够便捷地将 logagent 配置同步到 Kubernetes 集群 ConfigMap 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d3056c90fd4ecc5e824d61ba19258d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c4b2d204bf853fefd61c2fc481c94e/" rel="bookmark">
			电磁波散射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、电磁散射概念和雷达截面（RCS） 1. 电磁散射概念 入射场和
散射场和
总场和
物质外部：
2. 雷达截面 （1）截获功率 在距离散射体距离r趋向于无限远处某观测点被观测到的散射场功率流密度乘以球面积
（2）雷达截面 散射体从入射波中所截获的功率与入射功率流密度成正比，这个比例系数定义为雷达截面
一般认为，入射波的波源和散射波的观察点距离散射体都很远，所以
对于三维和二维散射体，散射远场存在以下形式
因此，散射截面与波的入射方向和散射方向有关。
二、雷达方程 1. 传输方程 （1）发射信号功率流密度 ：发射机功率
：发射天线输入端的反射率
：发射天线增益
计算发射天线产生的功率流密度为：
（2）接收天线有效面积 天线的最大有效面积
有效面积
接收天线的有效面积：
（3）接收到的功率 (4) 接收功率与入射功率之比 最大值：
2. 距离方程 设散射体散射截面为，散射体截获的入射波功率为
截获功率被散射体各向均匀散射，接收天线处的功率流密度
接收天线的有效面积
接收功率
接收功率与入射功率之比
对于后向散射，如果发射天线和接收天线使用同一个天线，没有极化损失和匹配损失，则接收到的功率为
3. 雷达搜索方程 4. 雷达跟踪方程 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da50503dfe0a74b8c7979fbeaf50322/" rel="bookmark">
			端口基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		端口可以区分同一主机上的不同服务，做到多个服务复用同一个IP地址端口是运输层关注的东西，出现在TCP/UDP的首部 UDP和TCP可以同时使用同一端口而互不干扰 端口在首部中占据16bit，所以端口的取值范围为1 ~ 65535 小于 1024 的端口号通常和 Linux 系统内置服务关联 一般需要 root 才能开启 1024 ~ 49151 的端口，被认为是 registered，通常特定的服务可以向 IANA来申请使用49152 ~ 65535 之间的端口不能被注册使用，并且推荐作为私有用途 http client一般使用这段地址的端口作为源端口自己写的服务一般也推荐绑定50000以上的端口 常见端口对应的服务可以通过 less /etc/services查看
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dd7b10c7fa0abab155b0106eee8c713/" rel="bookmark">
			C&#43;&#43;睡眠函数：Windows平台下的Sleep函数和Linux平台的usleep函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C/C++睡眠函数：Windows平台下的Sleep函数和Linux平台的usleep函数 WinAPI Sleep Sleep函数属于Windows API，使用它需要先包含synchapi.h。
void Sleep(DWORD dwMilliseconds); 函数仅有一个参数（睡眠时长），单位是毫秒。
参考Microsoft Docs
UNIX usleep 仅在Linux平台可用，使用它需要先包含unistd.h。
int usleep(useconds_t usec); 函数仅有一个参数（睡眠时长），单位是微秒。该数值最大不超过1000000微秒（也就是1秒）。
参考Linux and UNIX Man Pages
C++11引入的跨平台通用睡眠函数sleep_for template &lt;class Rep, class Period&gt; void sleep_for02(const chrono::duration&lt;Rep,Period&gt;&amp; rel_time); 函数sleep_for与前两个函数一样，都只有一个参数指明睡眠时长。稍显复杂的是，这个参数rel_time的单位取决于用户。
看官方例程：
// this_thread::sleep_for example #include &lt;iostream&gt; // std::cout, std::endl #include &lt;thread&gt; // std::this_thread::sleep_for #include &lt;chrono&gt; // std::chrono::seconds int main() { std::cout &lt;&lt; "countdown:\n"; for (int i=10; i&gt;0; --i) { std::cout &lt;&lt; i &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); } std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dd7b10c7fa0abab155b0106eee8c713/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5749f7d65dda1163930c4b149f3bfa12/" rel="bookmark">
			python代码画动态烟花,python画烟花绽放出字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 这篇文章主要介绍了python代码画动态烟花，具有一定借鉴价值，需要的朋友可以参考下。希望大家阅读完这篇文章后大有收获，下面让小编带着大家一起了解一下。
当然可以！这是一份简单的烟花代码：
import turtle import random # 设置画布大小 turtle.screensize(800, 600) # 隐藏海龟形状 turtle.hideturtle() # 设置画笔速度 turtle.speed(0) # 定义颜色列表 colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'] # 循环绘制烟花效果 for i in range(20): # 设置画笔颜色 turtle.pencolor(random.choice(co 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7d1f46f3997c2695039ce92ed0ecfbf/" rel="bookmark">
			【Simulink】电池双向DC/DC&#43;PI&#43;无差拍直流母线稳压
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前写过【Simulink】电池双向DC/DC+PI双环直流母线稳压，控制部分均采用PI，本篇博客将电流环的PI控制改成无差拍控制，无差拍控制原理可参考之前的博客：【Simulink】基于无差拍的单相L型滤波并网逆变器电流控制
1. 控制原理 电压环控制采用PI控制，输出电感电流参考值 i r i_r ir​。
电流环控制采用无差拍控制。
设输入端的电池电压为 v i v_i vi​，输出端的直流母线电压为 v o v_o vo​，电感值为 L L L，电容为 C C C，开关周期为 T s T_s Ts​，占空比为 D D D，可控开关为 V V V，二极管为 V D VD VD。
假设在 t = [ 0 , D T s ] t=[0, DT_s] t=[0,DTs​] 阶段，V导通，VD关断，电池向电感L充电，此时电路方程为： v i = L d i / d t v_i=L di/dt vi​=Ldi/dt
在 t = [ D T s , T s ] t=[DT_s, T_s] t=[DTs​,Ts​] 阶段，V关断，VD导通，电池向电感L充电，此时电路方程为： v i = L d i / d t + v o v_i=L di/dt +v_o vi​=Ldi/dt+vo​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7d1f46f3997c2695039ce92ed0ecfbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e114e77b66385b6d6913316fa1a78617/" rel="bookmark">
			7-1 jmu-ds-顺序表区间元素删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
若一个线性表L采用顺序存储结构存储，其中所有的元素为整数。设计一个算法，删除元素值在[x,y]之间的所有元素，要求算法的时间复杂度为O(n)，空间复杂度为O(1)。
输入格式: 三行数据，第一行是顺序表的元素个数，第二行是顺序表的元素，第三行是x和y。
输出格式: 删除元素值在[x,y]之间的所有元素后的顺序表。
输入样例: 10 5 1 9 10 67 12 8 33 6 2 3 10 输出样例: 1 67 12 33 2 答案：
#include&lt;bits/stdc++.h&gt; using namespace std; typedef int Status; typedef int ElemType; typedef struct//定义顺序表 { ElemType data[101]; int length; }List; typedef List *SqList;//定义为指针，故下面用-&gt; void creatlist(SqList &amp;l,int n)//输入元素，建立表 { l=new List;//? l-&gt;length=n; for(int i=0;i&lt;l-&gt;length;++i) { cin&gt;&gt;l-&gt;data[i]; } } Status deletelist(SqList &amp;l,int x,int y)//删除元素，更新表 { int j=0; for(int i=0;i&lt;l-&gt;length;++i) { if((l-&gt;data[i]&lt;x)||(l-&gt;data[i]&gt;y)) { l-&gt;data[j]=l-&gt;data[i]; j++; } } l-&gt;length=j; return 1; } void printlist(SqList l)//输出元素，输出新表 { for(int i=0;i&lt;l-&gt;length;++i) { cout&lt;&lt;l-&gt;data[i]; if(i&lt;l-&gt;length-1) cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e114e77b66385b6d6913316fa1a78617/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4a8adbe20c19e01996312261cb7baf/" rel="bookmark">
			每日OJ题_算法_滑动窗口③_力扣1004. 最大连续1的个数 III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
力扣1004. 最大连续1的个数 III
解析及代码
力扣1004. 最大连续1的个数 III 1004. 最大连续1的个数 III - 力扣（LeetCode）
难度 中等
给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。
示例 1：
输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2 输出：6 解释：[1,1,1,0,0,1,1,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 6。 示例 2：
输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 输出：10 解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1] 粗体数字从 0 翻转到 1，最长的子数组长度为 10。 提示：
1 &lt;= nums.length &lt;= 10^5nums[i] 不是 0 就是 10 &lt;= k &lt;= nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4a8adbe20c19e01996312261cb7baf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6aaf52db8c260c25a54d9097c26708d1/" rel="bookmark">
			矩阵理论基本知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、矩阵范数、算子范数 矩阵无穷范数是非自相容范数，矩阵1-范数、矩阵2-范数是自相容范数矩阵2-范数：Frobenius范数，是向量2-范数的自然推广。 ∥ A ∥ m 2 = ∥ A ∥ F = ∑ a ˉ i j a i j \|A\|_{m2}=\|A\|_{F}=\sqrt{\sum \bar a_{ij}a_{ij}} ∥A∥m2​=∥A∥F​=∑aˉij​aij​ ​ ∥ A ∥ m 2 = t r ( A H A ) = A 的正奇异值的平方和 \|A\|_{m2} = \sqrt{tr(A^HA)} = \sqrt{A的正奇异值的平方和} ∥A∥m2​=tr(AHA) ​=A的正奇异值的平方和 ​ ∥ A ∥ m 2 = ∥ U H A V ∥ m 2 = ∥ U A V H ∥ m 2 \|A\|_{m2} = \|U^HAV\|_{m2}=\|UAV^H\|_{m2} ∥A∥m2​=∥UHAV∥m2​=∥UAVH∥m2​ 酉等价保F范数 ∥ A ∥ m 2 = ∥ U A ∥ m 2 = ∥ A V ∥ m 2 = ∥ U A V ∥ m 2 \|A\|_{m2} = \|UA\|_{m2}=\|AV\|_{m2} = \|UAV\|_{m2} ∥A∥m2​=∥UA∥m2​=∥AV∥m2​=∥UAV∥m2​ 若矩阵范数是相容范数：则必存在向量范数与之相容。 ∣ ∣ A x ∣ ∣ ≤ ∣ ∣ A ∣ ∣ m ∣ ∣ x ∣ ∣ ||Ax||\le||A||_m ||x|| ∣∣Ax∣∣≤∣∣A∣∣m​∣∣x∣∣ 证明过程：构造 ∣ ∣ x ∣ ∣ = ∣ ∣ x a H ∣ ∣ m ||x|| = ||xa^H||_m ∣∣x∣∣=∣∣xaH∣∣m​矩阵的特征值一定小于等于该矩阵的相容矩阵范数。反过来说，如果矩阵的特征值大于了某个矩阵范数，则该矩阵范数一定不相容。 任意向量范数：则必存在矩阵范数与之相容，其中放大效果的最大值称为算子范数。 算子范数再大，不过向量范数的上确界，鸡头始终是鸡和向量范数相容的矩阵范数，终归是矩阵范数，始终有 ∣ ∣ A x ∣ ∣ ≤ ∣ ∣ A ∣ ∣ m ∣ ∣ x ∣ ∣ ||Ax||\le||A||_m ||x|| ∣∣Ax∣∣≤∣∣A∣∣m​∣∣x∣∣，所以矩阵范数会大于等于算子范数。换句话说，和向量范数相容的矩阵范数的下确界是算子范数。算子范数是自相容矩阵范数。 ∣ ∣ A k ∣ ∣ ≤ ∣ ∣ A ∣ ∣ k ||A^k||\le ||A||^k ∣∣Ak∣∣≤∣∣A∣∣k 常见算子范数： 从属于向量1-范数的算子范数称为算子1范数：极大绝对列和范数；从属于向量2-范数的算子范数称为算子2范数：谱范数= r ( A H A ) \sqrt{r(A^HA)} r(AHA) ​；从属于向量∞-范数的算子范数称为算子无穷范数：极大绝对行和范数；证明思路：存在上界，上界可达。 算子范数的性质： ∣ ∣ ⋅ ∣ ∣ ||\cdot|| ∣∣⋅∣∣是算子范数 ∣ ∣ E ∣ ∣ = 1 ||E||=1 ∣∣E∣∣=1 ∣ ∣ A − 1 ∣ ∣ ≥ ∣ ∣ A ∣ ∣ − 1 ||A^{-1}||\ge ||A||^{-1} ∣∣A−1∣∣≥∣∣A∣∣−1； ∣ ∣ A ∣ ∣ ≥ ∣ ∣ A − 1 ∣ ∣ − 1 ||A||\ge ||A^{-1}||^{-1} ∣∣A∣∣≥∣∣A−1∣∣−1 ∣ ∣ A − 1 ∣ ∣ − 1 = inf ⁡ ∣ ∣ A x ∣ ∣ ∣ ∣ x ∣ ∣ = m i n x ≠ 0 ∣ ∣ A x ∣ ∣ ∣ ∣ x ∣ ∣ ≤ ∣ ∣ A ∣ ∣ ||A^{-1}||^{-1} = \inf \frac{||Ax||}{||x||} = min_{x\ne0} \frac{||Ax||}{||x||}\le||A|| ∣∣A−1∣∣−1=inf∣∣x∣∣∣∣Ax∣∣​=minx=0​∣∣x∣∣∣∣Ax∣∣​≤∣∣A∣∣ ∣ λ ∣ ≤ ∣ ∣ A ∣ ∣ |\lambda|\le ||A|| ∣λ∣≤∣∣A∣∣； ∣ λ k ∣ ≤ ∣ ∣ A k ∣ ∣ |\lambda^k|\le ||A^k|| ∣λk∣≤∣∣Ak∣∣ HÖlder 范数：p-范数。可以p取1和无穷。HÖlder不等式： ∣ X H Y ∣ ≤ ∑ ∣ x i ∣ ∣ y j ∣ ≤ ∥ X ∥ q ∥ Y ∥ p , 1 / q + 1 / p = 1 |X^HY|\le \sum|x_i||y_j| \le\|X\|_q\|Y\|_p, 1/q+1/p=1 ∣XHY∣≤∑∣xi​∣∣yj​∣≤∥X∥q​∥Y∥p​,1/q+1/p=1 2、矩阵分解 已经写过一期了，见：矩阵理论–矩阵分解
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6aaf52db8c260c25a54d9097c26708d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72fed80fa9b539b06fa92fcabb2697cb/" rel="bookmark">
			如何使WPF在处理图像时表现得像Windows（解决DPI问题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
介绍
如何在WPF中显示图像
旁注
WPF位图类继承
使WPF行为类似于Windows的第一种方法
第二种失败的方法
最终解决方案
结语
介绍 当Windows在“照片”中显示类似.jpg文件的图片时，它不关心文件的dpi（每英寸点数）设置。具有不同dpi设置但相同像素数的文件以相同的大小显示。以下是三个文件，它们都使用500 x 500像素，但dpi设置不同：
WPF显示相同的图片，如下所示：
如果编写的应用采用Windows程序生成的图像文件，更改图像中的某些内容，然后将其作为新的图像文件写回，则用户希望WPF应用的行为类似于传统的Windows应用，即以与Windows相同的大小显示图像。
显示器的dpi设置也存在类似的差异。Windows对图像使用相同数量的“像素”，而不考虑监视器的dpi设置。请注意，用户可以在Windows中更改用于显示一个“像素”的监视器像素数。
另一方面，WPF使用图像文件的dpi信息。如果该文件的宽度为96像素，DPI为96，则WPF会尝试在1 dpi监视器和96 dpi监视器上显示它192英寸长。在第一种情况下，它使用96个显示器像素，在第二种情况下使用192个显示器像素。
不幸的是，在许多情况下，用户并不关心实际尺寸，而是希望看到整个图像，无论用户是看小手机屏幕、笔记本电脑屏幕还是巨大的电视屏幕。在1英寸电视上显示100英寸的图像有什么用？
本文介绍如何编写代码，以便WPF像Windows一样处理图像。解决方案确实很简单，但我花了一个月的时间才弄清楚。
如何在WPF中显示图像 显示图像文件的最简单的WPF代码是这样的：
&lt;Image Source="SomePath\SomeImageFile.jpg"/&gt; 当图形命令（矢量图形）中定义图形时，WPF图形系统效果最佳，例如使用特定粗细和颜色从A点到B点绘制一条线。
旁注 绘制黑色1显示器像素线几乎是不可能的。问题在于，显示图形的控件被包含图形的其他Control定位，并且图像边框通常放置在2个监视器像素之间。其效果是将线条涂在2个像素上，并以灰色而不是黑色绘制。还涉及一个问题。许多人认为，当他们set StrokeThickness = 1时，他们会在监视器上获得1个像素。但根据显示器的dpi，1DIP可能会转换为多个像素或仅转换为像素的一部分。有一些属性，如SnapsToDevicePixels或GuidelineSet，应该会有所帮助，但我从未设法获得正确的黑色1像素线。
但是，图像文件是面向像素的，这是WPF不太喜欢的。它将图像的像素值存储在位图中，该位图是一个名为BitmapSource的类，该类将像素存储在二维数组中，但该数组是隐藏的。如果要读取和写入像素，则需要使用继承自BitmapSource的WriteableBitmap。 Image使用派生自BitmapSource的内部类来存储像素。然后，它将位图的像素缩放为屏幕像素。
要允许在显示位图之前对其进行处理，最好先将图像文件读入继承自BitmapSource的BitmapImage，然后将其分配给Image.Source。
&lt;Image Stretch="None"&gt; &lt;Image.Source&gt; &lt;BitmapImage UriSource="SomePath\SomeImageFile.jpg" /&gt; &lt;/Image.Source&gt; &lt;/Image&gt; 通常，我更喜欢在XAML中仅定义与UI相关的控件，并在代码隐藏中执行所有其他操作：
&lt;Image Name="MyImage"/&gt; var bitmapImage= new BitmapImage(new Uri("SomePath\SomeImageFile.jpg")); MyImage.Source = bitmapSource; 图像是DIP中定义的FrameworkElement，并且具有Width和Height定义，并且可以是可视化树的一部分。BitmapImage不继承自Visual，因此不能在可视化树中使用。一些BitmapImage属性，它们都是readonly：
PixelWidth、PixelHeight：位图的大小（以图像像素为单位）DpiX、DpiY：图像文件中指示的每英寸点数Width、Height：在设备无关像素中位图的大小。Width=96/DpiX*PixelWidth。它们通常具有与Image.ActualWidth和Image.ActualHeight不同的值。DecodePixelWidth，DecodePixelHeight：可以在读取图像文件之前使用，以指示生成的位图应该有多大。当您已经知道只需要图片的一个小版本（如缩略图）时，这会最小化位图大小。但是，当您想要处理图像并稍后在Windows中使用结果时，请不要给DecodeXxx一个值，这意味着位图将为每个像素包含与图像文件相同的值。 WPF位图类继承 在尝试理解WPF中的位图时，一个挑战是实际上存在相当多的位图类。以下是最重要的：
Image是一个FrameworkElement。它不是位图，但在其Source属性中包含位图或矢量图形。ImageSource是位图或矢量图形的基类。它只有几个属性，基本上是使用DIP的图像的Height和Width。DrawingImage用于矢量图形，不属于本文的一部分。BitmapSource是所有其他位图类的基类。我认为它将位图的实际数据保存在二维数组中，这对程序员来说是不可见的。可以从包含像素值的整数数组创建一个BitmapSource，并将位图导出为整数数组。 这三个类用于创建位图：
BitmapImage：读取图像文件BitmapFrame：用于存储可能具有多个帧（图像）的GIF文件RenderTargetBitmap：将WPF Visual呈现为位图 这三个类用于处理位图。它们将BitmapSource作为输入，并提供更改后的位图作为输出：
TransformedBitmap：缩放和旋转BitmapSourceCroppedBitmap：只剪掉BitmapSource一部分WriteableBitmap：提供更改位图像素的方法 使WPF行为类似于Windows的第一种方法 起初，我认为这个问题很容易解决。如果WPF显示的图像是Windows中的两倍，则只需调整Image控件的大小即可。这可以通过如下布局转换轻松完成：
//correct the monitor dpi var dpi = VisualTreeHelper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72fed80fa9b539b06fa92fcabb2697cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e13d1413ca78dbbd63877575abb37ff/" rel="bookmark">
			rollup 源码解析 - watch 监听
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 rollup watch 实现流程watchWatchEmitter 实现 watchInternalWatcher 管理整个 watch 阶段Task 运行任务FileWatcher 实现文件监听 rollup watch 实现流程 每一个配置了 watch 的配置项都会变成一个 Task 任务，每个任务通过 FileWatcher 即 chokidar 进行监听，需要监听的文件依赖有两种 一种是文件自身 import 的依赖，会被放进 dependencies 属性里一种是文件在被插件处理的过程中通过 this.addWatchFile 时，watch 的文件会放进该模块的 transformDependencies 属性里 插件里调用 this.emitFile 生成的文件会放进该模块的 transformFiles 属性里 每个 Task 通过 Watcher 进行管理 rollup 打包结果其中一个文件数据结构：
{ "assertions": {}, "ast": { // 当前模块 ast }, "code": "import _createClass from \"@babel/runtime/helpers/createClass\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport \"core-js/modules/es7.array.includes.js\";\nimport a from \"a-test\";\nimport foo from \"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e13d1413ca78dbbd63877575abb37ff/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/81/">«</a>
	<span class="pagination__item pagination__item--current">82/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/83/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>