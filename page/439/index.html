<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df360bd183ca6af8c5d68d437070413/" rel="bookmark">
			shell中循环数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个数组，用小括号括起来，内容用空格分割即可。
循环数组时候一个关键点是要在数组后面增加 [@] 符号，表示获取数组全部内容，如果不加，则只能获取到第一个元素。
也可以通过下标的方式获取数组元素 array[index]
#!/bin/bash ips=('192.168.149.160' '192.168.149.161' '192.168.149.162') for ip in ${ips[@]} do echo ${ip} done echo "通过下标获取数组元素" i=0 until [ ! $i -lt 3 ] do echo "通过下标 $i 获取到的数组元素 ${ips[$i]}" i=`expr $i + 1` done 执行shell文件 sh foreach.sh ，结果如下：
192.168.149.160
192.168.149.161
192.168.149.162
通过下标获取数组元素
通过下标0获取到的数组元素192.168.149.160
通过下标1获取到的数组元素192.168.149.161
通过下标2获取到的数组元素192.168.149.162
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ac1e02ede26ed59dd8ba35c3ad95ebc/" rel="bookmark">
			wpa_supplicant、wpa_cli的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		wpa_supplicant工具包含wpa_supplicant和wpa_cli这2个程序，其中wpa_supplicant程序作为服务端在后台运行，服务wpa_cli客户端的请求，从而实现WiFi的配置连接。wpa_supplicant工具支持wep、wpa、wpa2等加密认证方式。本文接下来介绍如何使用wpa_supplicant、wpa_cli这2个程序进行WiFi的配置。
一、wpa_supplicant的使用 运行wpa_supplicant，wpa_supplicant程序作为wpa_cli的服务端，必须先启动后，才能给wpa_cli访问使用。
wpa_supplicant的手册说明：
wpa_supplicant
usage:
wpa_supplicant [-BddhKLqqtvW] [-P&lt;pid file&gt;] [-g&lt;global ctrl&gt;] \
[-G&lt;group&gt;] \
-i&lt;ifname&gt; -c&lt;config file&gt; [-C&lt;ctrl&gt;] [-D&lt;driver&gt;] [-p&lt;driver_param&gt;] \
[-b&lt;br_ifname&gt;] [-e&lt;entropy file&gt;] \
[-o&lt;override driver&gt;] [-O&lt;override ctrl&gt;] \
[-N -i&lt;ifname&gt; -c&lt;conf&gt; [-C&lt;ctrl&gt;] [-D&lt;driver&gt;] \
[-p&lt;driver_param&gt;] [-b&lt;br_ifname&gt;] [-I&lt;config file&gt;] ...]
drivers:
nl80211 = Linux nl80211/cfg80211
wext = Linux wireless extensions (generic)
wired = Wired Ethernet driver
options:
-b = optional bridge interface name
-B = run daemon in the background
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ac1e02ede26ed59dd8ba35c3ad95ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b71784050415cfe723c260001fd3b29/" rel="bookmark">
			2018年个人成长总结及2019年个人成长计划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2018年是国家值得纪念的一年，因为2018年是改革开放40周年，虽然并未完全经历改革的四十年，好歹我也为祖国奋斗了6年；这些年的变化实在是太大了，明显感受到了祖国的强大、经济的发展、法制的健全、人民的幸福、社会的安定，各行各业都取得了举世瞩目的成就。与我个人来说，2018年也是值得纪念的一年，因为这一年我收获颇多；在2018年即将逝去的日子里，我总结下这一年来的点点滴滴，并展望下2019年，希望能收获的更大。
这一年来，我的大事记：
1、博客重新开通：4月18日，这是一个值得纪念的日子，因为我重新开通了两年前建立的博客，并坚持写了159篇原创文章。本篇是第159篇，159象征着“要我永久”，我也会坚持着写下去，直到感觉实在累的那一天。写作对我个人各方面的提高真的非常大，我也因此养成了深度思考和持续记录的习惯，感谢写作，让我重新塑造了自我。
2、微信公众号开通：4月16日，我开通了自己的微信公众号，限于微信公众号每天只能发一篇文章，感觉限制太大，当天只更新了一篇文章就放弃了；两年没写了，这期间积累的东西好多，更有好多文章要发，博客每天可以更新的文章更多，所以当时的情况下选择了博客。直到8月6号，我又重新开始在微信公众号里更新文章，一直到了现在，基本与博客同步；这是因为手机微信阅读的方式更好，呈现的方式更加直接，排版及布局比博客更好，加上移动互联网的发展，大家更喜欢手机阅读的模式。虽然开通公号的时间很晚，也跟不上很多热门公号的发展，但是我的原则就是你喜欢的话就可以关注我，我想把自己的收获和进步分享给大家，这样可以一起学习、一起进步。
3、阅读书籍：测试技术类书籍大部分都是重读，并写了读后感和读书笔记，主要有“测试价值提升之路”、“测试架构师修炼之道”、“探索式测试”、“软件测试实战”、“软件测试经验与教训”、“用户体验与可用性测试“、”软件测评师教程“，一共7本书；管理类书籍，部分也是重读，主要有”华为工作法“、”高效能人士的七个行为习惯“、”管理就是定制度走流程“、”不会讲故事，怎么带团队“、”管理学“，一共5本书；修身类书籍，主要有”道德经“、”历史的教训“、”如何有效阅读一本书“，一共3本书；质量管理类，主要有”人人都是首席质量官“、”质量免费“、”质量总监成长记“、”质与量的战争“、”第一次把事情做对“、”戴明的新经济观“、”转危为安“，一共7本书；整个一年读了22本书，其实离我的目标还比较远，因为我买的书实在是太多了，还有很多没有读完。
4、文章收纳：我每天阅读的文章平均算下应该在15篇以上，绝大多数都是技术类文章，直到7月份我才知道印象笔记可以收纳微信上的文章，从七月份一直到现在我积累了近一千篇文章，所有的文章都是我觉得很不错且值得收藏的。由于互联网的存在，知识获取的渠道发生了翻天覆地的变化，微信上有很多不错的公众号，可以利用碎片化的时间去学习。
5、极客时间：极客时间是我在七月份的时候发现的一个不错的学习平台，当时是”左耳朵耗子“也就是耗子叔给我的链接，至此买了七八个专栏，学习效果极佳，尤其是”技术管理36讲“、”技术领导力300讲“、”趣谈网络协议“、”软件测试52讲“等等。我还专门围绕技术管理写了管理系列博客专栏，全面立体的思考和总结了这三年的管理经验，成长非常大，再次感谢建国老师的分享。
6、家庭旅游：这是第一次单独带老婆一起出去旅行，工作五六年来第一次，也是我们结婚三年来的第一次，之前经济实在是太紧张了。今年年初的时候立下的心愿，所以一定要实现这个愿望。我们一起去的地方是张家界，非常特殊的地貌及环境，游玩的非常开心。
7、因公出国：这是第一次出国，哈萨克斯坦。第一次踏上他国的土地，刚开始还挺兴奋的；不过从第二天开始就烦躁了，主要是吃喝很不习惯（面包、肉类，蔬菜很少，面食基本没有，饭菜的口味也很不一样，不太习惯），沟通交流也不畅快（人家主要说哈萨克语和俄语）；出去了才真的体会到了还是祖国好，还是家乡的美食好；老外的生活方式与习惯与我们的差异还是比较明显的，但是哈萨克真的非常的美，环境好，人口少，你会感觉整个大地都属于你。
8、商业思维：今年是我自己商业思维逐渐培养和活跃的第一年，紧跟着刘润老师、宁南山老师、猫叔、辉哥等的微信公众号，学到了非常多的知识；我也会刻意研究下一些企业的商业模式，非常的有收获；我认为商业知识的积累对于你未来有非常重要的意义。
9、管理思维：我学习管理，主要是通过三个途径，一个是读书，一个是微信公众号，一个是极客时间；学习只是管理思维建立的一种途径，此外不断的思考和持续的实践是非常重要的，博客文章的输出就是思考的结果，对于测试部和部门的管理实践就是我的实践基础；学习、思考、实践这三者缺一不可，必须协同。
10、财商思维：十月份的时候，参加了长投学堂的小白训练营，对我的影响非常的大。之前我对股票、基金、保险基本上没有什么概念；我更不了解的是财商竟然是智商、情商、逆商之外的第四商；我也不了解财商思维是可以从小培养的，是决定人生高度的重要思维模式之一；相对于股票和基金，保险是当务之急，是家庭的基本保障，为此我全面的了解了保险的知识，并为家庭购买了合适的保险；至于股票和基金，等知识积累到一定程度的时候再考虑入手，老话说的好，”股市有风险，投资需谨慎“，加上2018整个经济压力其实是非常的大，股市整体也比较低迷，不适合入手。
总之，我觉得写作、读书、学习平台、思维模式都对我产生了巨大的影响，将会持续伴随我很多年；量变的积累一定会带来质变。
至于即将到来的2019年，我有如下几点计划，希望与大家一起分享，大家也顺带做一个见证：
1、建立自己的管理体系：经过三年时间管理的积累，逐渐产生了一些小的质变，但是整个管理知识还没有成为一个体系，希望2019年的持续积累可以完成这个目标，建立自己相对完善的管理体系。
2、博客及公众号文章更新：坚持每周至少更新五篇文章，目标是每周更新七篇文章，目前我自己的积累还比较有限，加上一些不错的方式正在探索和尝试，希望多方面成长之后，对自己的写作能有比较大的帮助，这样写作的速度就可以加快，这样每周完成七篇应该不是问题。
3、思维模式的积累：商业思维、管理思维、财商思维等的持续积累，为自己长期的成长蓄力；我觉得思维模式的积累非常的重要，这个可以作为一生的目标去追逐。
4、阅读书籍：读书真的非常有用，2019年我会探索比较好的读书模式，提炼出更有效的读书模式，目标呢则是读50本书，范围可以非常的广泛，这觉得这个目标还是可以完成的；因为我现在的阅读速度可以达到每周1-2本书。
5、文章积累：以平均每天8篇文章来算，一年算下来会有2500篇左右文章，所以我的目标是收纳3000篇文章。
6、学习平台：目前的学习平台很多，我熟悉的主要有微信公众号、极客时间、喜马拉雅等等，这些平台文章的学习我都会利用碎片的时间进行；我们每个人每天碎片化的时间其实很多，早上醒来、中午休息的时间、晚上下班的时间、睡觉前、周末、地铁上、会议期间等等，只要你好好利用，会有无数的时间来阅读。
7、企业研究：这一年计划开启一些企业的研究，不管是商业模式、还是管理模式、还是财务报表，都是我研究的目标，我想把学习的知识立体的串起来，从企业研究入手，积累比较整体的经验，目标是一个月研究3个企业，一年算下来有36个；因为是入手，所以会慢一些，待之后找到思路之后，再加快一些进度。
8、其它计划：家庭旅游一次，地点未定；积累炒股的知识，尝试入手；提高自己的养生知识，因为身体是革命的本钱；与更多上层人士接触，他们是真正的榜样；多参加行业峰会，与业内人士多多交流；践行一切所计划的、感兴趣的。
总之，我相信2019年一定是不平凡的一年，因为这一年是祖国成立70周年；因为这一年是改革攻坚最难的一年；因为这一年是企业涅磐重生的一年。对于我个人来说，即将步入工作的第七个年头，对于工作、对于生活、对于未来，都有了比较清晰的规划，希望自己不忘初心，努力前行，为自己书写2019年的新篇章，同时持续的创作文章分享给大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/383535768803df05a3ad1b5789367497/" rel="bookmark">
			opencv python 轮廓特征/凸包/外接矩形/外接圆/拟合矩形/拟合直线/拟合圆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.图像的矩 cv2.moments()
图像的矩可以帮助计算物体的某些特征，如对象的质心，对象的区域等.
import cv2 import numpy as np img = cv2.imread('img7.png',0) ret,thresh = cv2.threshold(img,127,255,0) im2,contours,hierarchy = cv2.findContours(thresh, 1, 2) cnt = contours[0] M = cv2.moments(cnt) print( M ) 输出：{'m00': 283.0, 'm10': 8260.666666666666, 'm01': 34747.666666666664, 'm20': 251349.8333333333, 'm11': 1008063.0, 'm02': 4274513.166666666, 'm30': 7941981.4, 'm21': 30484543.9, 'm12': 123258620.46666667, 'm03': 526819846.70000005, 'mu20': 10223.989595602674, 'mu11': -6208.702394974302, 'mu02': 8080.874165684916, 'mu30': 8302.495426246896, 'mu21': -14552.154961312423, 'mu12': 11791.528133469663, 'mu03': -3268.923251092434, 'nu20': 0.12765785058625623, 'nu11': -0.07752253611575, 'nu02': 0.10089867729257346, 'nu30': 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/383535768803df05a3ad1b5789367497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/463acc33d513b96173a8a56995e5451e/" rel="bookmark">
			半监督深度学习小结：类协同训练和一致性正则化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作者丨陈家铭
学校丨中山大学硕士生
研究方向丨半监督深度图像分类
协同训练 Co-training Co-training 是基于分歧的方法，其假设每个数据可以从不同的角度（view）进行分类，不同角度可以训练出不同的分类器，然后用这些从不同角度训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。
由于这些分类器从不同角度训练出来的，可以形成一种互补，而提高分类精度；就如同从不同角度可以更好地理解事物一样。
该方法虽然理论很强，但却有一定的假设条件（事实上半监督学习都是在一定的假设条件下进行的），引用周志华大大《基于分歧的半监督学习》中的描述：
协同训练法要求数据具有两个充分冗余且满足条件独立性的视图：
1. “充分（Sufficient）” 是指每个视图都包含足够产生最优学习器的信息, 此时对其中任一视图来说，另一个视图则是“冗余（Redundant）” 的；
2. 对类别标记来说这两个视图条件独立。
这个数据假设就很强力了，既要求数据信息充分还冗余，你还要找到两个独立互补的视图。但是，在一定程度上满足条件的情况下，co-training 的效果也是非常给力。 那么，在半监督深度学习里，co-training 会以什么方式呈现呢？问题的关键自然在于，如何去构建两个（或多个）近似代表充分独立的视图的深度模型，两个比较直观的方法就是：
使用不同的网络架构（据我看过的论文 [1] [2] 中指出，哪怕是对同一个数据集，不同的网络架构学习到的预测分布是不一样的）；
使用特殊的训练方法来得到多样化的深度模型。
注：以下工作的推荐，是我自认为其思想类似于 co-training，因此称为类协同训练，不是说下面的工作就一定是 co-training。
这是一篇 ECCV 2018 的文章，论文首先指出，直接对同一个数据集训练两个网络，会有两个弊端：
对同一个数据集训练两个网络，并不能保证两个网络具有不同的视图，更不能保证具有不同且互补的信息；
协同训练会使得两个网络在训练过程中趋于一致，会导致 collapsed neural networks，进而使得协同训练失效。
为了解决上述问题，论文主要做了两个工作：
1. 提出了一个新的代价函数，进行协同训练，其形式如下：
信息论学得不好请多见谅，大概就是均匀分布的熵最大，当两个预测分布不一致时，这两个预测分布求和取平均会使得熵增大。相反，如果预测一致熵就不会增加多少。
论文中还明确强调，该代价函数只用在无标签数据上，因为有标签数据的监督代价函数（论文用的交叉熵）已经使得预测趋于一致（趋于真实标签），用在有标签数据上没有必要，但是好像没说明也用在有标签数据上的后果。
2. （关键）提出了 View Difference Constraint。其思路是：我们只有一个数据集 D，但我们不能再同一个数据集上训练两个网络，因此需要从 D 中派生出另一个数据集 D'，而这个派生方法就是计算 D 的对抗样本。具体即使用对方的对抗样本来训练自己：
其中， g1(x) 表示网络 p1 的对抗样本， H(·) 是某种代价函数（KL 散度），该约束的设计期望是使得两个网络具备不同却互补信息。我个人觉得这是一个 very amazing 的想法。尽管我不知道理论上是否能保证两个网络不同却互补，但直观上……
实验效果非常好，两个（或多个）网络使用的是同一种架构，就是感觉没有和集成方法比较感觉有点遗憾，毕竟论文用了多个网络。
Tri-net 是 IJCAI 2018 的论文，挂着周志华大大的名字，用的思想也是周志华提出来的 tri-training，可谓阵容豪华。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/463acc33d513b96173a8a56995e5451e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c902f2075877fe9e5b8b02cbaaa1af0/" rel="bookmark">
			浅显易懂的GCC使用教程——初级篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅显易懂的GCC使用教程——初级篇 2018-12-17天气暖，属于冬日里出太阳。最近在学习使用gvim，想着抛弃对IDE的依赖同时也是想了解编译的过程，但除了学习gvim繁多的指令外还得先学习使用gcc编译程序。这篇文章将会用浅显易懂的方式记录下gcc的基本使用，同时也不忘扩展探究。
——Author：Calm
什么是GCC，它能干什么？
GCC、gcc、g++三者有何关系？
开始开发前该做什么准备？
gcc常用指令讲解？
什么是gcc，它能干什么？ GCC(GNU Compiler Collection)即GNU编译器套件，属于一种编程语言编译器，其原名为GCC（GNU C Compiler）即GNU c语言编译器，虽然缩写一样但是功能上区别很大。GCC的初衷是为GNU操作系统专门编写的一款编译器，原本的GNU是专用于编译C代码，现如今已扩展为可以编译C、C++、Java、Objective-C等多种编程语言的编译器集合了。这篇文章主要介绍gcc或g++的使用。
GCC、gcc、g++三者有何关系？ gcc（GUN C Compiler）是GCC中的c编译器，而g++（GUN C++ Compiler）是GCC中的c++编译器。
gcc和g++两者都可以编译c和cpp文件，但存在差异。gcc在编译cpp时语法按照c来编译但默认不能链接到c++的库（gcc默认链接c库，g++默认链接c++库）。g++编译.c和.cpp文件都统一按cpp的语法规则来编译。所以一般编译c用gcc，编译c++用g++。后文有时间会继续深入探讨区别。
开始开发前该做什么准备？ 软件安装教程：
直接去官网上下载MinGW的包管理器（下载链接：https://osdn.net/projects/mingw/releases/）
下载好后安装包管理器并运行它，可以看到如下界面：
左侧选择“Basic Setup”选项，右侧勾选（点击“Mark for Installation”）需要安装的组件“mingw32-gcc-g++”。假设你也需要使用MinGW编译Fortran、Object-C、Ada语言的话也可以勾上相应的选项。选择好后点击左上角的Installation菜单中的Apply changes选项即开始在线下载安装相关组件。
安装好后最好配置下环境变量，把MinGw的bin目录加入到环境变量的path中，这样dos在任意目录下都可以调用bin目录下的可执行文件，其他一些软件也能找到gcc的位置。cmd中输入gcc -v查看版本号。
gcc常用指令讲解？ 用gcc在Windows上编译*.c文件并非直接生成*.exe文件（Linux上为*.out），中间还经历了预处理、编译和汇编几个过程，好在gcc提供了生成中间文件的指令，虽然平时开发的时候很少关注编译过程中生成的这些*.i和*.s文件，但对其有一定的了解总归是好的。
【指令】 gcc
使用gcc指令编译*.c文件可以生成*exe可执行文件。下面我们用一段简单的c代码来讲解，Demo.c内源码如下：
#include&lt;stdio.h&gt; int main(void) { printf("nihao\n"); return 0; } 打开cmd,需要注意的是cmd默认路径一般是c盘，而Demo.c文件可能并不在cmd的默认路径下，我们需要使用dos指令cd到Demo.c所在目录下才能对文件进行操作，示例：
对Demo.c文件执行gcc指令后会在该目录下生成可执行文件a.exe，由于没有制定exe的文件名所以默认为a.exe。
当然也不一定要cd进Demo.c的目录，使用gcc指令时给出Demo.c的绝对路径也可以成功编译，命令如下：
gcc E:\WorkSpace\Test_gcc\Demo.c
【指令】 -o
指令-o（小写）用来指定生成的文件名。
结果如下：
生成的文件不一定要在.c所在目录，可以给出路径指定。
gcc Demo.c -o ..\Demo.exe
该指令指定将exe生成到上一级目录。
生成exe后我们试者执行一下看看结果。
【指令】 -E（预处理（Preprocessing））
指令 -E（大写）将执行预处理操作也即生成*.i文件,gcc编译器将对#开头的指令进行解析。我们修改Demo.c中的代码为如下：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c902f2075877fe9e5b8b02cbaaa1af0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b980fc4349272e305aaa258590a56cc/" rel="bookmark">
			String的两种初始化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：String的创建和初始化有两种方法，既可以用String str = new String("abc")创建一个字符串，也可以用String str = "abc"的形式创建。
1： String str = "abc"创建一个字符串的过程
首先在常量池（方法区）中查找是否存在内容为"abc"的字符串对象如果不存在则在常量池中创建一个"abc"的字符串对象，并让str引用该对象如果存在则直接让str引用该对象 2： String str = new String("abc")创建一个字符串的过程
首先定义一个str的String类型的引用并存放在栈中在字符串常量池中查看是否存在内容为"abc"字符串对象 若存在则跳过这个步骤，若不存在，则在字符串常量池中创建一个内容为"abc"的字符串对象。（前三步都是在编译时完成的）执行new操作，在堆中创建一个指定的对象"abc"，这里堆的对象是字符串常量池“abc”对象的一个拷贝对象。让str指向堆中“abc”这个对象（也就是存储这个对象的在堆中的地址） 有时会问 String str = new String("abc")创建一个字符串的过程会创建几个对象？
答：一个或两个（因为编译时会检查方法区常量池中是否已经存在需要创建的字符串对象。若存在直接将引用指向常量池的对象，此时只会在随后的运行时堆中创建一个对象。而如果不存在，会先在常量池中创建一个对象，在随后的运行时还会在堆中再创建一个对象，所以此时会创建两个对象）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc15e385386095909117afa16ff78185/" rel="bookmark">
			Android 6.0 wifi一个LOST_PROVISIONING断开连接的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android6.0系统设置wifi修改保持连接了，但是偶尔会断开连接。查看log，发现如下内容：
04-09 15:09:27.569 2181 22861 D NetlinkSocketObserver: NeighborEvent{elapsedMs=2512360, 192.168.1.1, [(null)], RTM_NEWNEIGH, NUD_FAILED}
04-09 15:09:27.569 2181 22861 W NetlinkSocketObserver: ALERT: NeighborEvent{elapsedMs=2512360, 192.168.1.1, [(null)], RTM_NEWNEIGH, NUD_FAILED}
04-09 15:09:27.569 2181 22861 W IpReachabilityMonitor: FAILURE: LOST_PROVISIONING, NeighborEvent{elapsedMs=2512360, 192.168.1.1, [(null)], RTM_NEWNEIGH, NUD_FAILED}
04-09 15:09:27.584 2181 2784 D IpReachabilityMonitor: clear: iface{wlan0/9}, v{4}, ntable=[]
04-09 15:09:27.593 2947 2947 I wpa_supplicant: wlan0: CTRL-EVENT-DISCONNECTED bssid=d0:c7:c0:d3:a0:e6 reason=3 locally_generated=1
04-09 15:09:27.598 2181 2784 D WifiStateMachine: WifiStateMachine: Leaving Connected state
Adnroid6.0以上系统存在Android- IP LOST_PROVISIONING 的机制
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc15e385386095909117afa16ff78185/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cacd203678f18fffea75ba65bf2b5e69/" rel="bookmark">
			创建安装程序Visual Studio Installer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 在vs2010 选择“新建项目”----“其他项目类型”----“Visual Studio Installer“安装项目”： 命名为：Setup1 。
这是在VS2010中将有三个文件夹，
1.“应用程序文件夹”表示要安装的应用程序需要添加的文件；
2.“用户的‘程序’菜单”表示：应用程序安装完，用户的“开始菜单”中的显示的内容，一般在这个文件夹中，需要再创建一个文件用来存放：应用程序.exe和卸载程序.exe；
3.“用户桌面”表示：这个应用程序安装完，用户的桌面上的创建的.exe快捷方式。
2、 应用程序文件夹中点右键添加文件 将需要打包的文件添加进来；
添加的文件一般是已经编译过应用程序的debug或者release目录下的文件；
如果debug 下面有子文件夹则需要“添加文件夹”，例如：data
然后把对应的子文件里的内容添加到此文件夹中；
把需要创建程序快捷方式的图标也添加进来：后缀名为：ico
3、 设置安装文件的目录（路径）： 创建的项目名称（setup1）点击左键（不是右 键），在属性中设置参数如下图：
其中Author 为作者；Manufacturer为公司名称；ProductName为应用程序的名字；例如我们设置为：BeyondKKO；Manufacturer：自由公司；ProductName：串口测试。把InstallAllUsers 设置为True 。（这样在“控制面板”程序中会显示公司的名称；在安装时会默认为“任何人”，否则默认为“只有我”）
在应用程序上点击左键，如下图：第一个[ProgramFilesFolder]为系统主目录（默认C:\Program Files(x86)），第二个为公司名[Manufacturer]），第三个为应用程序名称，这样在安装时就会创建两层的文件路径。需要删除DefaultLocation中的：[Manufacturer] 。删除后只有应用程序的名称。如果想更改[ProgramFilesFolder],则可以替换为要替换的 盘符，如：D:\[Manufacturer]\[ProductName]
4、 创建应用程序图标与卸载程序： “在应用程序文件夹”中的.exe文件中，点击右键，创建快捷方式：
重命名“串口测试程序”，然后点击右键属性：选择Icon
双击进入选择我们之前添加的“MiXer.ico”
确定后，拖动此快捷方式到“用户桌面”
“用户的‘程序’菜单”中添加一个文件夹，命名为：“串口程序”
然后同样的方式创建TEXTCOM.exe一个快捷方式（“串口测试程序”），拖动到“串口程序”中；
然后给.NET应用程序创建一个卸载程序：
在“应用程序文件夹”中添加：C：Windows\System32\Msiexec.exe
右键创建快捷方式，重命名为：卸载，把此快捷方式拖动到“串口程序”；
点击项目名称（Setup1），在属性中找到：ProductCode
复制此ProductCode ，粘贴到“卸载”快捷方式的Arguments属性，前面加/x空格
5、 完成以上步骤，就可以生成解决方案了。 6、生成解决方案后，在debug文件夹中就是我们需要的安装包. 7、 安装完在开始菜单中有“串口程序”的文件夹，里面有我们创建的两个快捷方式； 桌面上也会有快捷方式。
---------------------------------------------------------------------------------------------------
Vs2013 用Install Shield 2013创建安装程序
Vs2013好像不能用旧版的installer了。所以只能用新版的，但是新版的需要注册码，不缴费的话也能做，但是在安装过程会提示试用版，并且只能生成一个exe文件，不提供msi文件了。
其实这个exe只不过是把msi打包了一下而已，在生成项目的时候会先生成msi，然后过了大概10秒的时间再生成exe，同时msi会自动删除，手快的可以尝试把msi拷贝出来。当然我觉得exe用着也是一样的。
右击vs解决方案，添加——新建项目——其他项目类型——安装部署
此时如果之前没用过的，会提示下载软件“installshield2013limitededition”。
然后操作步骤我就一一详述了，看这个博客就好了：
http://www.cnblogs.com/wuhuacong/p/4438761.html
需要注意的是，如果允许用户自定义安装目录，则在“Installation Interview”页勾选第三个选项为yes。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ac1cf8bad059e707ec14e28fed1a5c6/" rel="bookmark">
			通过输入年份和月份输出该年该月的日历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C代码如下
#include &lt;stdio.h&gt; int main() { int m,d,monthmax,y,i,j; while(1) { printf("请输入年份y:"); scanf("%d", &amp;y); printf("请输入月份m:"); scanf("%d", &amp;m); if(y%4==0||(y%100==0&amp;&amp;y%400==0)) { if(m==1||m==3||m==5||m==7||m==8||m==10||m==12) monthmax=31; if(m==2) monthmax=29; if(m==4||m==6||m==9||m==11) monthmax=30; } if(y%4!=0) { if(m==1||m==3||m==5||m==7||m==8||m==10||m==12) monthmax=31; if(m==2) monthmax=28; if(m==4||m==6||m==9||m==11) monthmax=30; } //基姆拉尔森计算公式取得一号周几 if(m==1||m==2) { m+=12; y--; } d=(2+2*m+3*(m+1)/5+y+y/4-y/100+y/400)%7; if(d==0) { d=7; } { { if(m==13) { printf("公元%d+1年 第1月日历\n",y); } if(m==14) { printf("公元%d+1年 第2月日历\n",y); } if(m!=13&amp;&amp;m!=14) { printf("公元%d年 第%d月日历\n",y,m); } } printf(" 7 1 2 3 4 5 6\n"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ac1cf8bad059e707ec14e28fed1a5c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6e39d7fde3cd1d794bc306600452a1e/" rel="bookmark">
			滑动窗口的最大值（剑指offer第65 题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、题目描述
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。
例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，
那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}，
{2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
二、 解题思路
直接AC，思路见代码。
三、java代码
public class Solution_65 { /** * 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。 * 例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3， * 那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； * 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： * {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， * {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 */ public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) { ArrayList&lt;Integer&gt; resList = new ArrayList&lt;Integer&gt;(); if(num==null || num.length==0 || size == 0){ return resList; } int [] window = new int [size]; //窗口数组 for(int i=0;i&lt;num.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6e39d7fde3cd1d794bc306600452a1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b69973956b529fc124e3ea5e4aba4cec/" rel="bookmark">
			JDK1.8发现无法引入javax.servlet包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误代码 解决办法: 一、IDEA File – &gt; Project Structure --&gt; Modules。 将Tomcat 添加到项目中即可。如下图所示。
二、Eclipse / MyEclipse 项目点右键选择属性properties --&gt;Java Build Path --&gt; 选择Libiaries选项卡 --&gt;点击Add Library --&gt;MyEclipse Server Library --&gt;选择安装的tomcat。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82e15cf9e0b7c451be6be7b49061ad7d/" rel="bookmark">
			Flutter Widgets 之 Dialog 对话框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：无特殊说明，Flutter版本及Dart版本如下：
Flutter版本： 1.12.13+hotfix.5Dart版本： 2.7.0 当应用程序进行重要操作时经常需要用户进行2次确认，以避免用户的误操作，比如删除文件时，一般会弹出提示“是否要删除当前文件”，用户点击确认后才会进行删除操作，这时我们可以使用提示框（AlertDialog或者CupertinoAlertDialog）。
根据设计的不同，我们可以选择Material风格的AlertDialog或者Cupertino（ios）风格的CupertinoAlertDialog，
Material风格基础用法如下：
RaisedButton( child: Text('切换'), onPressed: () { showDialog( context: context, builder: (context) { return AlertDialog( title: Text('提示'), content: Text('确认删除吗？'), actions: &lt;Widget&gt;[ FlatButton(child: Text('取消'),onPressed: (){},), FlatButton(child: Text('确认'),onPressed: (){},), ], ); }); }, ) Material风格效果：
Cupertino（ios）风格基础用法如下：
RaisedButton( child: Text('切换'), onPressed: () { showCupertinoDialog( context: context, builder: (context) { return CupertinoAlertDialog( title: Text('提示'), content: Text('确认删除吗？'), actions: &lt;Widget&gt;[ CupertinoDialogAction(child: Text('取消'),onPressed: (){},), CupertinoDialogAction(child: Text('确认'),onPressed: (){},), ], ); }); }, ) Cupertino（ios）风格效果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82e15cf9e0b7c451be6be7b49061ad7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64e43c178e334d1497b2b3bdf96585f9/" rel="bookmark">
			springboot整合shiro-实现自己的登出(十六)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址，转载请注明出处： https://blog.csdn.net/qq_34021712/article/details/84722252 ©王赛超 前面所有的博客登出都是使用的shiro默认自带的登出,使用方式也很简单，不用我们去实现退出功能，只要去访问一个退出的url（该 url是可以不存在），由LogoutFilter拦截住，清除session。(如果没有什么特殊需求,我建议直接使用shiro的登出) 具体如下：
只要拦截到访问/logout的请求,就会被走logout对应的 LogoutFilter，自动登出。
为什么要实现自定义登出? shiro的默认登出也会清理用户的session信息,并且也会清理掉 redis中缓存的用户 身份认证和 权限认证的相关信息，但是为什么还要实现自定义登出呢？
但是有时候,我们还有自己的一些业务需要处理,比如说前面做的 限制用户的登录次数 和 并发登录的人数,使用shiro默认登出这些key是不会被删除的,假如我们想要删除这些key呢？ 或者说 在用户登出时,要记录日志 当前用户在线时长,这个时候 我们就需要自定义登出。
登出的两种实现方式 第一种是 不配置 默认的logout,自己写一个Controller方法对外提供http接口,在该Controller方法中实现 登出的逻辑。 /** * 登出 这个方法没用到,用的是shiro默认的logout * @param session * @param model * @return */ @RequestMapping("/logout") public String logout(HttpSession session, Model model) { Subject subject = SecurityUtils.getSubject(); subject.logout(); model.addAttribute("msg","安全退出！"); return "login"; } 第二种是 继承LogoutFilter过滤器，并重写preHandle方法。 第一步：自定义实现LogoutFilter
package com.springboot.test.shiro.config.shiro; import org.apache.shiro.SecurityUtils; import org.apache.shiro.subject.PrincipalCollection; import org.apache.shiro.subject.Subject; import org.apache.shiro.web.filter.authc.LogoutFilter; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64e43c178e334d1497b2b3bdf96585f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/815b65cd35b8097c5ed96f28329b448e/" rel="bookmark">
			字母索引定位，仿联系人列表功能，实现字母A-Z排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的联系人列表 A—Z排序功能，获取数据首字母，仿照联系人实现A-Z字母排序，实现字母索引定位功能；监听字母滑动，使recycleview滑动到指定位置；
先上效果图：
下面介绍实现逻辑：
自定义 SideBar + Recycleview 实现此功能，
第一步 自定义SideBar：onDraw()方法里 画出字母 sidebar:
获取画布高度于宽度，计算每个字母的高度，for循环画字母，此时，计算每个字母所对应的位置：
protected void onDraw(Canvas canvas) { super.onDraw(canvas); int height = getHeight();// 获取对应高度 int width = getWidth();// 获取对应宽度 int singleHeight = height / 28;// 获取每一个字母的高度 这儿可以是动态获取字母长度letterList.size() for (int i = 0; i &lt; letterList.size(); i++) { paint.setColor(Color.parseColor("#ffffff")); //paint.setTypeface(Typeface.DEFAULT_BOLD); paint.setAntiAlias(true); paint.setTextSize(30); // 选中的状态 if (i == choose) { paint.setColor(Color.parseColor("#ff0000")); paint.setFakeBoldText(true); } // x坐标等于中间-字符串宽度的一半. float xPos = width / 2 - paint.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/815b65cd35b8097c5ed96f28329b448e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b064b783b3a72eeaa6185516e1adf450/" rel="bookmark">
			Python 远程控制Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 导入paramiko库 ： pip install paramiko
import paramiko #创建SSHClient实例对象 ssh = paramiko.SSHClient() #调用方法，表示没有存储远程机器的公钥，允许访问 ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy()) #连接远程服务器地址、端口、用户名密码 ssh.connect(hostname="101.132.xxx.xxx",port=22,username="ctt",password="ctt") #cmd变量里放命令 cmd = 'pwd' #exec_command 执行命令 #每次执行exec_command 执行命令，都是登录的用户根目录下执行，没有环境的依赖关系 ssh.exec_command(cmd) cmd = ''' echo '1234 5678 90abc' &gt; myfile ''' ssh.exec_command(cmd) cmd = 'cat myfile' stdin, stdout, stderr = ssh.exec_command(cmd) #读取输出内容和错误日志，并用utf8编码 output = stdout.read()+stderr.read() print(output.decode('utf8')) ssh.close() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8871b33efb4f689f8a00ec4bcff45c8a/" rel="bookmark">
			分页插件PageHelper（需要配合Mybatis）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.介绍 如果你也在用Mybatis，建议尝试该分页插件，这个一定是最方便使用的分页插件。该插件目前支持Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库分页。
2.使用步骤 把PageHelper依赖的jar包添加到工程中。官方提供的代码对逆向工程支持的不好，使用参考资料中的pagehelper-fix。（我是淘宝买的黑马的视频）
并使用参考资料中的工程 ，将其导入到eclipse 使用maven 安装到本地仓库。如图
在Mybatis的全局文件中配置SqlMapConfig.xml中配置拦截器插件:
&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor="com.github.pagehelper.PageHelper"&gt; &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库--&gt; &lt;property name="dialect" value="mysql"/&gt; &lt;/plugin&gt; &lt;/plugins&gt; 如图：
在代码中使用（下面是个测试方法） @Test public void testhelper(){ /* //设置分页信息（设置了这个之后，查询出来的东西会根据这个分页信息显示（注：*这句代码写出来之后查询就直接分页了，下面的那行代码也只是简单的获取分页信息） PageHelper.startPage(1, 3);(页码,每页显示数量) //取分页信息(这个类中有许多方法可以取分页信息)（下面这个也是取分页信息，但是推荐使用这个） PageInfo&lt;TbItem&gt; info = new PageInfo&lt;&gt;(list);（参数为查询出来的内容） //注意这个Page类，它是com.github.pagehelper.Page，不要选错了，这个类是分页工具中的类，page返回值里面什么都有 Page&lt;TbBrand&gt; page = (Page&lt;TbBrand&gt;) brandMapper.selectByExample(null); */ //1.初始化spring 容器 ApplicationContext context = new ClassPathXmlApplicationContext("classpath:spring/applicationContext-dao.xml"); //2.获取mapper的代理对象 TbItemMapper itemMapper = context.getBean(TbItemMapper.class); //3.设置分页信息 PageHelper.startPage(1, 3);//(页码,每页显示数量)3行 紧跟着的第一个查询才会被分页 //4.调用mapper的方法查询数据 TbItemExample example = new TbItemExample();//设置查询条件使用 List&lt;TbItem&gt; list = itemMapper.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8871b33efb4f689f8a00ec4bcff45c8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b1ac73e67ef0ca2e40c432d46777623/" rel="bookmark">
			如何使用Docker轻松集成OnlyOffice和NextCloud--快速搭建私有云办公系统/私有云盘/私有OfficeOnline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原作者: XiaoGuo An 转载来源：https://www.linuxbabe.com/docker/onlyoffice-nextcloud-integration-docker
如何使用Docker轻松集成OnlyOffice和NextCloud 以前我写过关于将OnlyOffice和NextCloud集成到传统方式的过程，这是一个漫长的过程。现在，您可以使用Docker轻松集成OnlyOffice和NextCloud。
有一个由OnlyOffice开发团队创建的新Github存储库，用于帮助集成OnlyOffice文档服务器和NextCloud，后者允许用户直接从NextCloud创建和编辑Office文档。事实上，它还支持OnlyOffice和OwnCloud的集成。由于我们大多数人都是NextCloud用户，因此我将只关注NextCloud。
使用此方法，OnlyOffice文档服务器和NextCloud都将作为Docker容器应用程序安装，Nginx将用作Web服务器。我将向您展示如何集成这两个以及如何使用Let的加密启用HTTPS。
先决条件 要学习本教程，您需要
端口80和443可用的服务器，至少1GB的RAM，最好是2GB的RAM。我推荐Linode，你可以在这里获得高性能的2GB RAM Linux VPS，每月只需10美元。域名。我从NameCheap购买了我的域名。他们的价格不仅低于Godaddy，而且还免费提供whois隐私保护。 在您的服务器上安装Docker 首先，我们需要安装Docker和Docker Compose，其最新版本可以从Docker的官方存储库安装。以下步骤适用于Ubuntu 16.04。其他Linux发行版的用户可以查看官方安装说明。
为Docker存储库创建源列表文件。
sudo nano /etc/apt/sources.list.d/docker.list 复制以下行并将其粘贴到文件中。
deb [arch=amd64] https://download.docker.com/linux/ubuntu xenial stable 保存并关闭文件。然后通过运行以下命令导入Docker的PGP密钥。
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 由于此存储库使用HTTPS连接，我们还需要安装apt-transport-https和 ca-certificates打包。
sudo apt install apt-transport-https ca-certificates 接下来，更新软件包索引并安装最新版本的Docker CE（Community Edition）。
sudo apt update sudo apt install docker-ce 要安装最新版本的Docker Compose，请运行以下命令。
sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` -o / usr / local / bin / docker-撰写 sudo chmod + x / usr / local / bin / docker-compose 检查Docker版本。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b1ac73e67ef0ca2e40c432d46777623/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd1c93dbd54c5e073b28d079ab38b3c/" rel="bookmark">
			第m大的身份证号码（局部排序代全局、结构体排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第m大的身份证号码（点击） 时间限制: 1 Sec 内存限制: 128 MB
提交: 392 解决: 143
[提交] [状态] [讨论版] [命题人:admin]
题目描述
身份证号是我国公民的唯一识别码，它由18位数字或字母组成（只可能最后一位是字母）。18位身份证号码各位的含义如下：第1-2位为省、自治区、直辖市代码；第3-4位为地级市、盟、自治州代码；第5-6位为县、县级市、区代码。第7-14位为出生年月日，比如19970401代表1997年4月1日；第15-16位为顺序号，第17位代表性别，男为单数，女为双数；第18位为校验码，0-9和X。作为尾号的校验码，是把前十七位数字代入统一
的公式计算出来的，解答本题你不用关心是如何计算出来的。现在给你n个身份证号码，请你按照出生年月日的字典序（年龄从大到小）输出第m个人的身份证号。
输入
第一行包含两个正整数n和m，两数间用一个空格分隔，接下来的n行每行为一个形如上述格式的身份证号码（不需要关心校验码的正确性，不影响本题解答）。
输出
仅包含一行，为题目要求的一个身份证号码。
样例输入 复制样例数据
4 2 110108196004063022 13021119640203652X 420333197902112718 210222200012036512 样例输出
13021119640203652X 思路： 开始以为必须要将全部内容排序 然后想到了用 结构体+sort 排序 但后来写了一下cmp函数 由于从第7-14位 都需要考虑 所以cmp函数不好写 后来就放弃了这种想法。（如果用冒泡加判断每一位更是不容易）
比赛完了 和同学商量 知道原来身份证年龄可以看成一个数字 这个数字越小 代表他的年龄越大 想了想确实是这样 而且还是挺简单的 难怪 好多人都做出来了 。
代码： #include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() { int sum[1005][5],n,m,i,j,temp; char a[1005][25]; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++){ //输入每组的字符（身份证号码） scanf("%s",a[i]); } for(i=0;i&lt;n;i++){ sum[i][0]=i+1; //开二维数组 [0]位放这个省份证号码原来的顺组（不然下面排完序根本不知道要输出哪个身份证号了） sum[i][1]=((a[i][6]-'0')*pow(10,7)+(a[i][7]-'0')*pow(10,6)+(a[i][8]-'0')*pow(10,5)+(a[i][9]-'0')*pow(10,4)+(a[i][10]-'0')*pow(10,3)+(a[i][11]-'0')*pow(10,2)+(a[i][12]-'0')*pow(10,1)+(a[i][13]-'0')); } //将出生年月日 总共转换成一个数字 准备排序 for(i=0;i&lt;n-1;i++){ for(j=0;j&lt;n-i-1;j++){ if(sum[j][1]&gt;sum[j+1][1]){ temp=sum[j][1]; sum[j][1]=sum[j+1][1]; // 这一步可以使用结构体排序 比赛的时候也有点忘记了 sum[j+1][1]=temp; //先就用冒泡替代一下吧 temp=sum[j][0]; sum[j][0]=sum[j+1][0]; sum[j+1][0]=temp; } } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bd1c93dbd54c5e073b28d079ab38b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b872f9418600d87f06b160804b73c35b/" rel="bookmark">
			湘潭大学Java练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java练习题 第22题 编写程序：斐波那契图形
编写一个求斐波那契数列的递归函数，输入n值，使用该递归函数，输出如样例输出的斐波那契数列。
输入：
一个整型数n
输出：
题目可能有多组不同的测试数据，对于每组输入数据，
按题目的要求输出相应的斐波那契图形。
注意输出换行前不能有多余的空格。
样例输入：
6
样例输出：
0
0 1 1
0 1 1 2 3
0 1 1 2 3 5 8
0 1 1 2 3 5 8 13 21
0 1 1 2 3 5 8 13 21 34 55
import java.util.Scanner; public class Main { //递归方法求斐波那契数列 public static int fun(int n) { if(n==1) return 0; if(n==2) return 1; else return fun(n-2)+fun(n-1); } public static void main(String[] args) { Scanner s=new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b872f9418600d87f06b160804b73c35b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/438/">«</a>
	<span class="pagination__item pagination__item--current">439/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/440/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>