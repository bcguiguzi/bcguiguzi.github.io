<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e1a8a7bdaad79605db4dfab03ca92f0/" rel="bookmark">
			IDEA主题设置，自定义主题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1|0▾ 系统主题设置 首先进到设置里：File➞Settings➞Appearance&amp;Behavior➞Appearance。
这里默认提供了三套主题：IntelliJ,Darcula，high contrast。这里可以根据个人爱好进行设置。
IntelliJ样式
Darcula样式
high constract样式
系统字体样式
2|0▾ 导入其他IDEA主题 IDEA默认主题
IDEA默认提供了三个编辑区主题，可以通过如下的方式进行选择。
更多IDEA主题
如果想要更多主题效果就需要下载主题包，这里提供几个IDEA主题下载的网站：
➣ IDEA Theme官网: ☛ 传送门https://plugins.jetbrains.com/search?headline=164-theme&amp;isPaid=false&amp;tags=Theme
➣ riaway官网: ☛ 传送门https://www.riaway.com/
➣ easycolor官网: ☛ 传送门http://easycolor.cc/index.php
➣ Color Themes官网: ☛ 传送门http://color-themes.com/?view=index
这里给大家提供几个比较好看的主题
One Dark theme样式
One Dark theme - IntelliJ IDEs Plugin | Marketplace
Hiberbee theme
Hiberbee Theme - IntelliJ IDEs Plugin | Marketplace
Monokai_2样式
https://www.riaway.com/themeshow.php?tid=52$cid=1
导入主题：（方式一）
file → import settings → 选中下载的主题jar文件 → 按提示确认 → 重启程序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e1a8a7bdaad79605db4dfab03ca92f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4220455a1d0dbb3cafa2ffd09eca0dd7/" rel="bookmark">
			比较Hive，Spark，Impala和Presto (转载)简单了解它们都是干什么的而已（转载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：如何比较Hive，Spark，Impala和Presto？ - 知乎
原文的翻译多少有点瑕疵
Spark，Hive，Impala和Presto是基于SQL的引擎，Impala由Cloudera开发和交付。在选择这些数据库来管理数据库时，许多Hadoop用户会感到困惑。Presto是一个开放源代码的分布式SQL查询引擎，旨在运行甚至PB级的SQL查询，它是由Facebook人设计的。
Spark SQL是一个分布式内存计算引擎，它的内存处理能力很高。Hive也由Apache作为查询引擎引入，这使数据库工程师的工作更加轻松，他们可以轻松地在结构化数据上编写ETL作业。在发布Spark之前，Hive被认为是最快速的数据库之一。
现在，Spark还支持Hive，也可以通过Spike对其进行访问。就Impala而言，它也是一个基于Hadoop设计的SQL查询引擎。Impala查询不会转换为mapreduce作业，而是本地执行。
这是对Hive，Spark，Impala和Presto的简要介绍。在本文中，我们会讲解这些SQL查询引擎的功能描述，并根据它们的属性介绍这些引擎之间的差异。
Hive，Spark，Impala和Presto之间的区别 让我们看一下所有这些功能特性的描述：
什么是Hive？ 用于查询和管理大型数据集的Apache Hive数据仓库软件设施将分布式存储用作其后端存储系统。它建立在Apache之上。该工具是在Hadoop文件系统或HDFS的顶部开发的。Hadoop可简化以下任务：
临时查询数据封装庞大的数据集和分析 Hive特征 在Hive中，首先创建数据库表，然后将数据加载到这些表中Hive旨在管理和查询存储表中的结构化数据Map Reduce没有可用性和优化功能，但是Hive具有这些功能。查询优化可以高效地执行查询Hive的灵感语言降低了Map Reduce编程的复杂性，并重用了其他数据库概念，例如行、列、模式等。Hive使用目录结构进行数据分区并提高性能。Hive的大多数交互都是通过CLI或命令行界面进行的，并且HQL或Hive查询语言用于查询数据库Hive支持四种文件格式，即TEXTFILE，ORC，RCFILE和SEQUENCEFILE Hive的三个核心部分 Hive客户Hive服务Hive存储和计算 通过不同的驱动程序，Hive与各种应用程序进行通信。与基于Java的应用程序一样，它使用JDBC驱动程序，对于其他应用程序，它使用ODBC驱动程序。Hive客户端和驱动程序然后再次与Hive服务和Hive服务器通信。Hive客户端可以通过Hive服务解决其查询。
CLI或命令行界面在这里就像Hive服务一样，用于数据定义语言操作。来自不同应用程序的请求由驱动程序处理，并转发到不同的Meta数据库模块和系统进行进一步处理
Hive服务（如作业客户端，文件系统和元存储）与Hive存储进行通信，并用于执行以下操作：
在Hive中创建并存储了表的元数据信息，也称为“元存储数据库”数据和查询结果加载到表中，这些表以后存储在HDFS上的Hadoop集群中 对于大量数据或用于多节点处理，则使用Hive的Map Reduce模式，以提供更好的性能。
什么是Impala？ Impala是一个大规模并行处理引擎，是一个开源引擎。它要求将数据库存储在运行Apache Hadoop的计算机群集中。这是一个SQL引擎，由Cloudera在2012年推出。
Hadoop程序员可以以出色的方式在Impala上运行其SQL查询，它被认为是一种高效的引擎，因为它在处理之前不会移动或转换数据，该引擎可以轻松实现
它具有Hadoop的所有特质，还可以支持多用户环境。以下列出了使Impala非常有用的两个最有用的品质：
Impala的一些流行功能： 支持Apache HBase存储和HDFS或Hadoop分布式文件系统支持Kerberos身份验证或Hadoop安全性它可以轻松读取Apache Hive的元数据，SQL语法和ODBC驱动程序它可以识别Hadoop文件格式，RCFile，Parquet，LZO和SequenceFileApache Sentry基于角色的授权。 Impala在2年内崛起，已成为最重要的SQL引擎之一。现在，甚至Amazon Web Services和MapR都已列出了对Impala的支持。
什么是Spark？ Apache Spark是最受欢迎的QL引擎之一，它是通用数据处理引擎，在core-sprak数据处理引擎的内部还有很多其他库，例如图形计算、机器学习和流处理，这些库可以在应用程序中一起使用。Spark支持以下语言，例如Spark、Java和R应用程序开发。
Spark可以处理PB级的数据，并以分布式方式在成千上万个群集中进行处理，这些群集分布在几个物理和虚拟群集之间。Spark被用于多种应用，例如：
流处理机器学习互动分析资料整合 什么是Presto？ Presto是一个分布式的开源SQL查询引擎，用于运行交互式分析查询。它可以处理从GB到PB的任何大小的查询。Presto是由Facebook人设计的。它旨在加速商业数据仓库查询处理。
Presto在一组机器上运行。Presto设置包括多个Worker和协调器进程。Presto查询由其客户提交给协调器。然后，Presto协调器分析查询并创建其执行计划。稍后，处理过程将分配给Worker
在处理PB级或TB级数据时，用户将不得不使用大量工具与HDFS和Hadoop进行交互。Presto可以帮助用户通过Hive和Pig等MapReduce作业管道查询数据库。Presto可以帮助用户处理不同类型的数据源，例如Cassandra和许多其他传统数据源 Presto的功能 可以帮助从其驻留位置查询数据，例如Hive，Cassandra，专有数据存储或关系数据库。可以合并来自多个数据源的单个查询的数据Presto的响应时间非常快，通过昂贵的商业解决方案，他们可以快速解决查询它使用矢量化的柱状处理Presto具有流水线执行其架构简单 Facebook每天都使用Presto在一天中运行PB级数据。这可能包括几个内部数据存储。它还支持为查询提供数据的可插拔连接器。Presto支持以下连接器：
TPC-HCassandraHadoop /Hive 就Presto应用程序而言，它支持Facebook，Teradata和Airbnb等许多工业应用程序。Presto支持标准的ANSI SQL，这对于数据分析人员和开发人员而言非常容易。Presto是用Java开发和编写的，但没有与Java代码相关的问题，例如：
内存分配和垃圾回收。Presto具有Hadoop友好的连接器体系结构
推荐用法
就这些查询引擎的用途而言，您可以考虑以下几点：
对于任何类似BI的交互式工作负载，Impala可能是您的最佳选择。由于Impala查询的延迟最低，如果是为了减少查询延迟，您可以果断选择Impala，尤其是对于并发执行。
但对于低延迟和多用户支持要求，Hive也是不错的选择。选择Hive，仅出于您的ETL或批处理要求。但Hive不会减少太多查询处理所需的时间，因此它可以成为BI的合适选择。
Spark SQL，用户可以有选择地使用SQL构造为Spark管道编写查询。Spark SQL重用Hive元存储和前端，与现有的Hive查询，数据和UDF完全兼容。通过基于成本的查询优化器，代码生成器和列式存储Spark查询的执行速度得以提高。
Presto在BI类型查询中处于领先地位，与主要用于性能丰富查询的Spark不同，Presto对并发查询工作负载的支持至关重要。因此从并发查询执行和增加的工作量的角度出发，您可以使用它。
选择合适的数据库或SQL引擎完全取决于您的要求。在这里，我们列出了所有SQL引擎的一些常用和有益的功能。您可以选择Presto或Spark或Hive或Impala。数据库的选择取决于技术规格和功能的可用性
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4167efd7af36458c3148c6f7a772b7b3/" rel="bookmark">
			计算机本科毕设答辩经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、写在前面
5月28号下午终于结束大学里的最后一项任务–毕业答辩，大学四年就这样结束了。青春才几年，疫情占三年啊！很庆幸我们大一那时候没有疫情，不然大学四年都要被疫情所困。昨天晚上也收到为我毕设老师的微信，说我答辩通过了，没有推荐上校优（我这个菜鸡哪里感想优秀毕设，让我顺利毕业就已经谢天谢地了！）。真得特别感谢我们毕设导师，真的为我们操碎了心。在答辩的前一天晚上十点半找我，问我要不要再查重一次。因为我第一次查重时是11%，他怕我这个太高会影响我最终的评分，因为大部分人查重率都在5%以下（我只能说一个个都是卷王！）。然后我就再查重了一次，还好降下来了只有4.5%。昨天又听说，他在我们组的一个同学求情，让她不用二辩，真得我感觉我们专业其他老师绝对不会这样，我真得觉得他太好了。
二、关于答辩的碎碎念
1、格式一定要严格按照学校发的格式来修改，我们学校对格式要求非常严格。如果格式太差，直接二辩。我有个同学，答辩结束时老师说他第五章实现部分粘贴太多了代码，让他第五章全部重写，可太惨了。我们当时毕设导师的意思就是：哪怕你做的系统功能差了点，也要把你的论文写漂亮一点，增加点印象分。以下我们老师对格式的要求：
一、按照目录把论文内容填充完整。正文部分（包括绪论、…结论、致谢）不少于40页。
二、论文摘要言简意赅不要重复啰嗦，字数以300字左右为宜，且都应该具有以下几个部分：
1、目的。简要指出此项工作的目的,研究的范围。（50字左右）
2、方法。简要说明研究课题的基本做法,包括对象和方法。（50字左右）
3、结果。简要列出主要结果、主要功能、数据等,并说明其价值和局限性。（150字左右）
4、结论。简要说明该项研究结果取得的理论意义或实用价值、推广前景。（50字左右）
备注：结论和摘要往往是答辩老师关注的重点，所以语言表达一定要具科学性，在用词上也要够准确。
三、英文摘要不要为了省事而用在线翻译，否则语法不通或存在很多不专业的词汇。可以借助在线翻译，但自己要逐句更改。
四、论文目录需按照软件工程的步骤对问题进行调研，写出需求分析进而对系统进行设计。一定要有开发工具介绍、数据库设计、整体设计、详细设计，系统调试等几部分。其中：
1、功能需求分析最好采用建模的描述工具配合文字说明：如用例图、DFD（Data Flow Diagram，数据流图）、数据字典。
2、在进行数据库设计时要突出为什么要这样设计，与通常的设计有什么不同，有什么优点，有什么不足。一定要有ER图和具体的数据库表。
3、在整体设计中要重点对系统的特点和实现的关键技术以及原理进行论述。要有层次方框图。功能的分析主要从两方面入手：业务场景和系统界面。
4、在详细设计即系统具体实现时，用于论述的语言不能太少，不要只靠粘贴代码或者截系统图充篇幅。结合每一张图，每一段代码都要求有说明问题的文字。详细设计中的代码只能附上主要核心代码，切不可大面积、大幅度粘贴代码充页数。所有代码可以附在论文最后附录中。
5、在系统调试中不要只限于代码是否正确，功能能否实现，对功能的可扩展性，系统的安全性也要考虑。
五、结论不要只写自己开发系统的感想，还要有对系统开发过程的总结（可参考摘要，并展开）。结论和摘要往往是答辩老师关注的重点，所以语言表达一定要具科学性，在用词上也要够准确。
六、论文的格式一定严格参照学校论文的规范（页面设置、字体、字号，段间距、行间距、各级标题大小、页眉页脚），所有的图表（数据库表、模块表）一定要自己绘制，不能截图。图的背景色都采用传统的黑色白底，以免纸质文档打印时不除了运行结果展示可以截图，所有图表一定要自己利用软件visio绘制，不要用在线绘图，一定要保证图片打印出来是清晰的。
七、结论、致谢部分如果出现了非本校的名称以及非本校指导老师的名字，在正式答辩时凡是一眼看上去不是本校本科毕业设计格式的，直接论文不通过。
2、查重率尽可能低，其实计算机专业查重重复最多的部分可能就是第一章的绪论和第二章的核心技术介绍，那些计算机专业名词不可避免重复。我们专业要求查重率10%以下（其实20%以下就可以答辩），但最终结果是大部分人的查重率都降到了5%以下，我只能说太卷了。
大部分学校采用的都是知网查重，个人感觉只要贴了代码就会报红，我第一次查重就是因为代码报红才达到11%的。据我了解很多学校可能不允许贴代码截图，可是大家动个脑筋，可以查重时贴代码图，给老师看就直接贴源代码。
另外一个忠告是：自己的论文不要给任何同级同学（特别是那些有些混的同学），不然你的校内互检一定会很高。我把毕设论文给我室友了，而且他比我先交学校系统，然后我的校内互检直接干到10%，拜他所赐。
3、对于答辩PPT，计算机专业风格简洁就行。PPT第一页写好毕设题目、姓名、学号、指导老师；PPT最后一页可以感谢老师和恳请老师批评指正。
最重要的一点，一定要在PPT上打上自己学校的图标。具体讲述部分，对于背景部分一笔带过，主要讲解自己的系统设计和系统实现部分，基本上贴图（答辩时我们老师直接让我们跳过背景介绍和需求分析部分，主要讲自己的主要工作。）。系统功能强大的同学可以在PPT上贴展示视频，边放边展示，效果更佳。下面是我当时的PPT风格和目录（学校图标和个人信息都已经省去）：
4、答辩提问环节，先说明一点，不要相信小红书上有些人的发的答辩问题总结，基本上用不到。所有问题都是基于你的论文内容所问的，问得基本上都有点深度，不要以为道歉就完了，要尽可能去回答问题。
我们组有个同学就回答问题不好二辩了，本科生的毕设（大家懂得都懂），估计没有好好思考如何实现的，被问自闭了。我的毕设题目是基于Python的个性化新闻推荐系统，与推荐算法有关，一个劲问我推荐算法，我在尽力回答，答辩老师还是说我没有完全清楚，可能我太菜了吧。
需要提醒大家的一句：今年是卢雷元年，成功把我们这些工科毕设推上了风口浪尖，我感觉那些淘宝和闲鱼的代做人可能要失业了，平台可能会打击这些，以后本科生的毕设都没有那么好水的了，望大家珍重！
5、答辩答辩，疯狂道歉，相信我这只是玩笑话，啥也答不出来肯定二辩。最好每一位答辩老师都准备一份论文，表示尊重，不要在乎那几块钱。老师提的问题一定要想办法回答，回答问题时态度一定要谦和，对于一些明确需要修改的地方，就说离提交材料还有一些时间，接下来一定会按照老师的要求修改到位。
最后说一个好玩的事，我有个同学答完辩下来时，我们专业有个老师说，大家尽量不要再本科毕业论文里感谢女朋友，一般只要在硕士博士论文里感谢男女朋友和家属，整个教室都笑翻了。最后的最后，希望我们都顺利答辩，顺利毕业！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/298148da8873e75710735c462d9b8ea9/" rel="bookmark">
			股票量化交易进阶003_回测框架backtrader（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、技能要点1.如何获取一个line的长度2. line的延迟索引3. backtrader的运算符4.添加绘图指标5.绘图报错 总结 前言 通过一些技能更深一步掌握backtrader框架
一、技能要点 1.如何获取一个line的长度 有两种不同的line的长度，一种是len，这个是backtrader已经处理过的数据的长度；一种是buflen(),这个是backtrader预先加载的数据的长度。
len(line):计算出backtrader已经处理(运行)的长度，如prenext,next等运行的长度
line.buflen()计算的是backtrader加载的line的总的数目
一般情况下，是buflen大于len,如果两者想等了，可能是这个bar是最后一个bar；也有可能是某些情况下的实盘交易造成的。
可以自行添加打印代码，看下实际情况：
def next(self): self.bar_all = self.datas[0].close.buflen() self.bar_executed = len(self) print('===总共处理%s条bar，目前已处理了%s条' % (self.bar_all, self.bar_executed)) 打印结果：
===总共处理1555条bar，目前已处理了1553条
2022-05-25, Close, 14.39
===总共处理1555条bar，目前已处理了1554条
2022-05-26, Close, 14.19
===总共处理1555条bar，目前已处理了1555条
2022-05-27, Close, 14.18
Final Portfolio Value: 513.35
2. line的延迟索引 self.data[0].close[-1] 操作符用于在next逻辑阶段提取值。
self.data[0].close(-1) 还代表什么呢？
Lines支持通过延迟索引来访问延时的Lines对象。
例如我们考虑一个策略，它对比前一收盘价和当前简单移动平均线值。除了可以在next迭代中手动执行，还可以在__init__阶段生成预处理的线对象：
class MyStrategy(bt.Strategy): params = dict(period=20) def __init__(self): self.movav = btind.SimpleMovingAverage(self.data, period=self.p.period) self.cmpval = self.data.close(-1) &gt; self.sma def next(self): if self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/298148da8873e75710735c462d9b8ea9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e4e8c9274a890ff96381ea134937b9/" rel="bookmark">
			Ubuntu驱动安装------官方指导版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu驱动安装------官方指导版 前言方法一方法二方法三参考资料 前言 看了不少教程，都没成功，最后参考官方教程，一步到位。原版教程是英文版，提出了三种方法，我使用的是第一种方法，最简单也是最推荐的，第三种方法是最复杂的，很多中文教程都是将第三种方法的某些步骤和方法一或二缝合。下面将原本英文内容简单翻译下，以方便大家使用
方法一 第一步：使用以下命令，确定显卡型号和推荐的驱动版本
$ ubuntu-drivers devices == /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 == modalias : pci:v000010DEd00001180sv00001458sd0000353Cbc03sc00i00 vendor : NVIDIA Corporation model : GP106 [GeForce GTX 1060 6GB] driver : nvidia-304 - distro non-free driver : nvidia-340 - distro non-free driver : nvidia-390 - distro non-free recommended driver : xserver-xorg-video-nouveau - distro free builtin == cpu-microcode.py == driver : intel-microcode - distro free 从上方输出可知，目前的显卡型号为GTX 1060，推荐的驱动版本为390
第二步：自动安装驱动推荐版本：
$ sudo ubuntu-drivers autoinstall 或安装驱动指定版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16e4e8c9274a890ff96381ea134937b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/540f512a0227b568743aa6f23d23815a/" rel="bookmark">
			‘nvidia-smi‘ 不是内部或外部命令,也不是可运行的程序 或批处理文件解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先找到nvidia-smi.exe所在位置。一般在C:\Program Files\NVIDIA Corporation\NVSMI
或者使用everything搜索
右键“此电脑”，选择属性，找到高级系统设置
找到环境变量，在系统变量path中添加nvidia-smi所在的路径即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d765c3d35355b7fc82c92d5224d0281/" rel="bookmark">
			使用 Ingress 实现金丝雀发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 Ingress 实现金丝雀发布 一、基本介绍二、Ingress 使用介绍1.安装2.基本使用3.实现金丝雀发布 一、基本介绍 Service 是基于四层协议来实现的路由转发，常用于 NodePort 方式来对外提供服务，但是 当我们的业务模块较多时，使用 NodePort 的方式便不利于管理。 所以，我们可以使用 Ingress Controller 来通过匹配 URL 的方式实现 HTTP/HTTPS 代理。
Ingress 特点：
通过配置 Ingress，可以实现对内部服务提供可访问的 URL、负载均衡、终止 SSL/TLS，并且可以提供基于域名的虚拟主机。 Ingress 支持的调度方式：
URL 路径映射调度：通过配置 Ingress 中的 path 实现。主机调度：通过配置 Ingress 中的 host 实现。 Ingress 常见配置方式： 用户通过访问域名，域名解析到 SLB 的 IP 地址上，接着 SLB 将请求代理到当前正在监听的端口上，我们这里绑定的是 Ingress 映射出来的端口号。Ingress 通过匹配 URL 的方式找到绑定的 Service，最后 Service 将请求转发到后端 Pod 应用中。
二、Ingress 使用介绍 1.安装 [root@k8s-master01 ~]# wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.48.1/deploy/static/provider/cloud/deploy.yaml [root@k8s-master01 ~]# sed -i 's/LoadBalancer/NodePort/' deploy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d765c3d35355b7fc82c92d5224d0281/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abe290d41168da1957657392dfa921dd/" rel="bookmark">
			前端性能和加载体验优化实践（附：PWA、离线包、内存优化、预渲染）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景：页面为何会卡？ 1.1 等待时间长（性能） 项目本身包/第三方脚本比较大。JavaScript 执行阻塞页面加载。图片体积大且多。 特别是对于首屏资源加载中的白屏时间，用户等待的时间就越长，用户感知到页面的速度就越慢。麻省理工学院的 Richard Larson 在讲话中指出，“人类将被动等待高估了 36%”（https://mazey.cn/t/em）。这意味着用户感觉到的等待时间比开发工具记录的长得多。
1.2 看起来卡（体验） 页面结构不断调整，不连贯。抖动的页面往往让用户感觉很卡。
二、优化性能 2.1 构建缩包，按需加载 2.1.1 NPM 首先通过 Webpack 插件 webpack-bundle-analyzer 分析出项目中用到的 NPM 包及大小。
结合项目可以分析出哪些包可以去除，哪些包可以有更好的替代品。
名称体积大小（Parsed）说明mint-ui96.05KB目前引入全部组件，需要按需加载moment95.51KB时间戳格式化的库，因为无法按需加载，目标是替换为可按需加载的 date-fnsquill213.31KB富文本编辑器whatwg-fetch9.25KB原生 fetch 的垫片，已存在 axios，需要统一ua-device148.48KB使用 Navigator 代替assets546.11KB整个项目的小体积图片，大部分需要替换成链接引入或者分模块按需加载 然后在项目中移除或替换无用包，以及部分包的按需加载。
mint-ui 按需加载示例：
import { Swipe, SwipeItem, Progress, Navbar, TabItem, TabContainer, TabContainerItem, Lazyload } from 'mint-ui'; Vue.use(Lazyload); Vue.component(Swipe.name, Swipe); Vue.component(SwipeItem.name, SwipeItem); Vue.component(Progress.name, Progress); Vue.component(Navbar.name, Navbar); Vue.component(TabItem.name, TabItem); Vue.component(TabContainer.name, TabContainer); Vue.component(TabContainerItem.name, TabContainerItem); 2.1.2 外链 不影响页面主逻辑的外链往往不是很稳定，一定要等首屏加载完成以后按需加载。
示例：
// 加载其它资源 if (canLoad()) { let s = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abe290d41168da1957657392dfa921dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b14be41f4e4a73ba2db3f8eda837f93e/" rel="bookmark">
			Android Studio 全局查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记住这个方法，不怕快捷键变化。
在edit栏里找到Find-----Find in path,就可以全局查找了。。。
2022年5月27日夜，更新一下。其实，一般我们都是需要快速找activity，xml，类等文件，用快捷键Ctrl+N，一般就可以满足，上面的截图我之前使用好像不是太好使，今天更新的快捷键更好用，请根据需要选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43587a149412c5a82713816d134b4a1/" rel="bookmark">
			【C&#43;&#43;动态规划学习总结】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.动态规划：初识 动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。
实际上是对暴力递归的一种优化，把已经计算过的信息保存起来，下次要用时不用重复计算，并且通过求解动态数组的方式代替了函数的递归调用。
第一步优化在于对计算结果的存储，避免重复计算。可以优化成下面描述的记忆化搜索方法。
第二步优化在于对递归函数调用的优化，直接从bace case 反推，而不是从上往下调用。
2.例子： 1.1机器人走路问题 机器人在有N个位置的路上走，开始机器人在M位置，机器人可左右移动，到1位置时只能右移，到N位置时只能左移，机器人从起始位置M到目标位置P,共走K步，求移动的方法数
参靠左神代码编写：
#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; /* 原始暴力递归 * N:总位置数 cur:当前位置 rest:剩余步数 aim:目标位置 * 返回: 从cur到 aim 的方法数 */ int way1(const int N, int rest, int cur, const int aim) { //第一步,返回边界 if (rest == 0) // base case { return (cur == aim ? 1 : 0); } //第二步，看当前位置的分指数个数(分普通情况和特殊情况) //特殊情况,来到最左边时 if (cur == 1) { return way1(N, rest - 1, 2, aim); } //来到最右端时 if (cur == N) { return way1(N, rest - 1, N - 1, aim); } //来到中间位置时 return way1(N, rest - 1, cur + 1, aim) + way1(N, rest - 1, cur - 1, aim); } //傻缓存法改进(记忆化搜素) int way2(const int N, int rest, int cur, const int aim, vector&lt;vector&lt;int&gt;&gt; &amp;dp) //注意传引用 { if (dp[cur][rest] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c43587a149412c5a82713816d134b4a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e64a39afae011a369b1ae2f9cbf9a1f/" rel="bookmark">
			Flask&#43;Gunicorn&#43;Nginx&#43;Ubuntu&#43;腾讯云&#43;Https部署总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 环境说明： 腾讯云轻量应用服务器，系统是ubuntu20.04
登录腾讯云服务器的方法：1）下载putty登录linux系统。2）下载winscp上传文件到linux系统。
通过pip install flask，gunicorn来安装flask和funicorn
通过apt安装nginx（nginx： Linux 软件包），然后用ps -ef | grep nginx 来查看nginx的安装位置，一般来说在/etc/nginx/。（使用方法可参考如何在 Ubuntu 20.04 上安装 Nginx - 知乎 (zhihu.com)）
2. 部署 写好flask程序（注意：如果要采用https，那么所有url请求的地址请写完整，如https://ip地址:端口/路径），写完程序用python 文件名.py 运行一下试试看对不对（用Screen命令创建新屏幕(14条消息) ubuntu远程连接退出后程序继续运行之screen 命令_敬我岁月无波澜的博客-CSDN博客）用gunicorn来部署，如gunicorn -w 4 -b 127.0.0.1:5000 boot:app（其中boot是指你的py文件名，app是该py文件中的App类）（想外网访问的话0.0.0.0：5000）。使用ps -ef | grep gunicorn命令找出gunicorn所有进程，然后使用 kill -9 进程ID 命令来杀掉进程，注意，我们找到主进程杀掉即可，子进程会随之结束。输入命令sudo nano /etc/nginx/sites-available/default打开默认nginx配置文件， server { listen 443; //Https的默认端口号，也可以改成别的 server_name your_domain.com; //域名 ​ location / { proxy_pass http://127.0.0.1:5000; //转发到5000端口 } } 4. 配置Https证书文件过程中其他要改的部分详见：SSL 证书 域名型（DV）免费 SSL 证书申请流程 - 证书申请 - 文档中心 - 腾讯云 (tencent.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e64a39afae011a369b1ae2f9cbf9a1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36d089046ca7f3f64ebfe38479e59b60/" rel="bookmark">
			一、Linux常用命令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这些命令基本上都是需要掌握的
pwd cd ls du mkdir touch ln cp rm rmdir mv tree which
find type cat more less head tail sort sort uniq wc grep gzip
gunzip bzip2 bunzip2 zip unzip tar cut
目录
1.目录和文件的基本操作
（1）pwd命令
（2）cd命令
（3）ls命令
（4）du命令
2.创建目录和文件
（1）mkdir命令
（2）touch命令
（3）ln命令
3.复制、删除、移动目录和文件
（1）cp命令
（2）rm命令
（3）rmdir命令
（4）mv命令
（5）tree命令
4.查找目录和文件
（1）which命令
（2）find命令
5.查看文件内容
（1）cat命令
（2）nl命令
（3）more和less命令
（4）head和tail命令
（5）sort命令
（6）uniq命令
（7）file命令
（8）md5sum命令
（9）diff命令
6.统计和检索文件内容
（1）wc命令
（2）grep命令
7.备份与恢复文档
（1）gzip和gunzip命令
（2）bzip2和bunzip2命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36d089046ca7f3f64ebfe38479e59b60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef50ba8c52544d2ef722149ce29080b1/" rel="bookmark">
			pycharm无法install package了怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想学爬虫，需要import bs4，但install package时，出错了，错误如下：
查了几个帖子，内容不少，总之就是版本问题，权限问题，但是介绍的方法都没解决我的问题，还是回到错误信息自己找办法吧。进命令行，把pycharm给出的错误解决方案中的命令复制出来。
按照pycharm的提示安装，果然搞定，但提示pip需要升级。
那就一起升级了吧。
升完级还让升级，那就在升一次。
pip终于不再让升级了。
回到pycharm，问题都解决了。
总结：错误提示对解决问题很重要，遇到问题应先看错误提示。不同的人有不同的应用环境，能解决别人问题的方案，不见得就一定适合你，但给你的错误提示往往是最有针对性的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f0add2f780a3960543936b3fcfe67a/" rel="bookmark">
			程序员编程抢挂九价HPV疫苗号，牟利40余万后被警方抓获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为首个能预防宫颈癌的疫苗，九价HPV疫苗凭借能预防最多的病毒亚型一举成为疫苗界的“顶流”。但因其只适用于16-26岁的女性，还经常出现“一苗难求”的现象，这也让许多年轻人十分焦虑。
同时，这种供不应求的现状还引来了黄牛的“关注”，甚至还有人通过编写程序来代抢疫苗，从而走上违法犯罪的道路。
CSDN付费下载自视觉中国
近日，浙江湖州公安报道了一起涉嫌破坏计算机信息系统罪的案件。一名程序员因编写抢挂九价HPV疫苗号脚本，并倒卖给黄牛牟利，从而被警方抓捕归案。
非法抢到挂号后，倒卖给黄牛牟利 今年4月初，浙江省湖州市长兴县一家医院发布公众号文章，宣布将面向社会开放HPV疫苗挂号服务。本以为此次放苗活动可以缓解市场对HPV疫苗的需求压力，但没想到，等来的却是网友“预约挂号平台始终进不去，挂不了号”的抱怨。
在发现异常后，医院选择向警方报案。公安部门迅速展开调查，并对预约平台后台的服务器进行取证，结果发现，有一个固定IP对预约疫苗的接口有超高频率的访问。
在一步步地侦查后，警方将目光锁定在了广东深圳一家智慧物流公司的程序员李某彬身上。据了解，他是公司研发部的一名技术人员，主要负责智能物流体系的平台建设和开发维护，算是前后端开发运维非常资深的计算机人才。
5月9日，李某彬被警方抓捕。据查，李某彬通过编写计算机脚本等方式，实现对在线平台预约接口的高频率访问，以此对九价HPV疫苗进行抢挂号。抢号成功后，李某彬便将每个挂号600元至800元不等的价格倒卖给线上黄牛，以此牟利。自今年1月至5月初，李某彬已在多省市医院的九价HPV疫苗预约平台抢号500余个，非法获利40余万元。目前，犯罪嫌疑人李某彬被依法采取刑事强制措施，案件正在进一步办理中。
研究生男友为爱抢九价后开启“发财”之路 其实，这并不是首个因编程抢九价疫苗而被采取刑事强制措施的案例。今年1月我们曾报道过，江西南昌某大学的研究生刘某被曝出写代码帮人代抢，从而涉嫌破坏计算机信息系统罪。
事情是这样的。和大多数人一样，刘某的女朋友也一直因约不上HPV九价疫苗而感到烦恼。刘某得知后，他决定试试手气，登录南昌某医院APP帮女友代抢。没想到，女友抢了大半年都没中的疫苗，他一次就约上了。
随后，刘某在某红书上炫耀了自己的事迹，没想到引来了很多同城网友的代抢邀请。在高额佣金的诱惑下，刘某便利用起自己的计算机专业能力，使用编码程序编写了代码，并在各大平台发布代抢信息。
图源：公安部网安局（代码脚本和代抢信息）
但“发财”没多久，医院方面就发现，很多九价疫苗预约成功的人都是通过黄牛途径取得挂号的，而且医院系统存在被破坏干扰的痕迹。
在医院报案后，警方经侦查锁定了刘某。经过警方工作，刘某投案自首，并对其违法行为供认不讳。随后，刘某因涉嫌破坏计算机信息系统罪被依法采取刑事强制措施。
网友：高科技犯罪之从入门到入狱 5月26日，话题#程序员编程抢挂HPV疫苗号牟利40万#登上微博热搜，阅读量达1亿，也引起了网友们的热烈讨论。大家的观点大致分为两派：
一部分网友对黄牛的行为“深恶痛绝”：
“果然不是公平竞争，能不能把黄牛全抓起来”
“都是这样的人让我抢不到号吗？”
“这种事情就应该严惩，还靠这种事来牟利”
另一部分网友则对李某彬将技术用于“高科技犯罪”的做法表达了惋惜：
“从入门到入狱”
“挣钱也要遵纪守法啊”
“有这样的技术却不做正经事，可惜了，浪费了自己的聪明。”
最后，还是那句老话，技术本无罪，但利用技术做违法犯罪的事，不仅得不偿失，还毁了自己的人生。
参考链接：
https://mp.weixin.qq.com/s/Wiwd-u_GsqF6jp8ZpGUc6g
https://weibo.com/7467277921/LuErjezLO
https://mp.weixin.qq.com/s/Umq6UjeKD0kwgyZgVA28zA
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc001e15aa10339f9a48a0aa27c81099/" rel="bookmark">
			【转】Mysql千万级别数据优化方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：Mysql千万级别数据优化方案 - 知乎 千万级大表如何优化，这是一个很有技术含量的问题，通常我们直觉思维都会 跳转到拆分或者数据分区。在此我想做一些补充和梳理，想和大家做一下这方面的经验总结和交流。
当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化：
单表优化 除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量：
字段 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNEDVARCHAR的长度只分配真正需要的空间使用枚举或整数代替字符串类型尽量使用TIMESTAMP而非DATETIME，单表不要有太多字段，建议在20以内避免使用NULL字段，很难查询优化且占用额外索引空间用整型来存IP 索引 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段字符字段只建前缀索引字符字段最好不要做主键不用外键，由程序保证约束尽量不用UNIQUE，由程序保证约束使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引 查询SQL 可通过开启慢查询日志来找出较慢的SQL不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库不用SELECT *OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内不用函数和触发器，在应用程序实现避免%xxx式查询少用JOIN使用同类型进行比较，比如用'123'和'123'比，123和123比尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大 引擎 目前广泛使用的是MyISAM和InnoDB两种引擎：
MyISAM MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：
不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁不支持事务不支持外键不支持崩溃后的安全恢复在表有读取查询的同时，支持往表中插入新纪录支持BLOB和TEXT的前500个字符索引，支持全文索引支持延迟更新索引，极大提升写入性能对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用 InnoDB InnoDB在MySQL 5.5后成为默认索引，它的特点是：
支持行锁，采用MVCC来支持高并发支持事务支持外键支持崩溃后的安全恢复不支持全文索引 总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表
系统调优参数 可以使用下面几个工具来做基准测试：
sysbench：一个模块化，跨平台以及多线程的性能测试工具iibench-mysql：基于 Java 的 MySQL/Percona/MariaDB 索引进行插入性能测试工具tpcc-mysql：Percona开发的TPC-C测试工具 具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：
back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时max_user_connection: 最大连接数，默认为0无上限，最好设一个合理上限thread_concurrency：并发线程数，设为CPU核数的两倍skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询show status like 'key_read%'，保证key_reads / key_read_requests在0.1%以下最好innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询show status like 'Innodb_buffer_pool_read%'，保证 (Innodb_buffer_pool_read_requests – Innodb_buffer_pool_reads) / Innodb_buffer_pool_read_requests越高越好innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MBquery_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在Query Cache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用Query Cache可能会得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大.
可以通过命令show status like 'Qcache_%'查看目前系统Query catch使用大小read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM 升级硬件 Scale up，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc001e15aa10339f9a48a0aa27c81099/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd282903944979740f205fd3516022bf/" rel="bookmark">
			Android R开机流程跟踪-----init.rc和启动Zygote
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 init.rc是非常重要的配置文件，它是由Android 初始化语言（Android Init Language）编写的脚本，这种语言主要包含5种类型语句：Action、Command、Service、Option和Import。
具体语法可以查阅README.md，位于：Android11\system\core\init，在这里语法不具体发散，详情网上查阅，有很多资料。
nit.rc有两个，分别位于：
Android11/system/core/rootdir/init.rc
Android11/bootable/recovery/etc/init.rc
在Android11/system/core/rootdir/init.rc中，关注一句：import /system/etc/init/hw/init.${ro.zygote}.rc
一个是设备文件路径（机器里面的路径），一个是代码文件路径，不要搞混了。
查询机器的系统属性getprop ro.zygote 得：zygote32，所以RT51R是32位系统。
在机器路径/system/etc/init/hw，ls得：init.rc处的import /system/etc/init/hw/init.${ro.zygote}.rc，就是init.zygote32.rc。
init启动Zygote `class_start &lt;serviceclass&gt;` &gt; Start all services of the specified class if they are not already running. See the start entry for more information on starting services. command是action的命令列表中的命令，或者是service中的选项 onrestart 的参数命令,命令将在所属事件发生时被一个个地执行. 列举常用的命令 class_start &lt;service_class_name&gt;： 启动属于同一个class的所有服务； class_stop &lt;service_class_name&gt; : 停止指定类的服务 start &lt;service_name&gt;： 启动指定的服务，若已启动则跳过； stop &lt;service_name&gt;： 停止正在运行的服务 setprop &lt;name&gt; &lt;value&gt;：设置属性值 mkdir &lt;path&gt;：创建指定目录 symlink &lt;target&gt; &lt;sym_link&gt;： 创建连接到&lt;target&gt;的&lt;sym_link&gt;符号链接； write &lt;path&gt; &lt;string&gt;： 向文件path中写入字符串； exec： fork并执行，会阻塞init进程直到程序完毕； exprot &lt;name&gt; &lt;name&gt;：设定环境变量； loglevel &lt;level&gt;：设置log级别 hostname &lt;name&gt; : 设置主机名 import &lt;filename&gt; ：导入一个额外的init配置文件 init.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd282903944979740f205fd3516022bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a142d0b8bbfaf5c5a1d7c14884c8c55/" rel="bookmark">
			Ubuntu下HoiTransformer复现pytorch环境搭建&#43;解决问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备工作 论文：End-to-End Human Object Interaction Detection with HOI Transformer
代码：GitHub - bbepoch/HoiTransformer: This is the code for HOI Transformer 二、环境搭建 硬件/系统：服务器GPU3090，Ubuntu20.。。（忘记了），CUDA11.2
虚拟环境：python3.6，torch1.10.0+cu113，torchaudio0.10.0+cu113，torchvision0.11.1+cu113 虚拟环境创建过程略
三、复现过程 1.克隆代码（github难以直接克隆于是去gitee克隆了，最好克隆不要直接下载压缩包）
git clone https://gitee.com/hoi_xd/HoiTransformer 2.下载预训练模型
cd data/detr_coco &amp;&amp; bash download_model.sh 3.下载注释文件
cd data &amp;&amp; bash download_annotations.sh 4. 下载数据集
cd data &amp;&amp; bash download_images.sh 5.安装相关依赖
pip install -r requirements.txt 6.可以把数据移到服务器机械硬盘上，只在目录下映射一个地址（可省略）
mv data /home/hoi/ ln -s /home/hoi/data data 7.训练模型
# Train on HICO-DET. python3 -m torch.distributed.launch --nproc_per_node=8 --use_env main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a142d0b8bbfaf5c5a1d7c14884c8c55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5174f5f4731ea18668715ce906ec70b/" rel="bookmark">
			关于python中占用内存的主要原因分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		```python import sys class Point: def __init__(self,x,y,z): self.x = x self.y = y self.z = z test1 = {"x":1,"y":2,"z":3} test2 = [1,2,3] test3 = Point(1,2,3) test4 = (1,2,3) print("test1占用内存:",sys.getsizeof(test1)) print("test2占用内存:",sys.getsizeof(test2)) print("test3占用内存:",sys.getsizeof(test3)) print("test4占用内存:",sys.getsizeof(test4)) 输出结果
```python test1占用内存:240 test2占用内存:88 test3占用内存:64 test4占用内存:72 由此可见使用字典时所产生的内存是很庞大的，使用类时的内存最小，在一些大项目中的内存往往是很巨大的消耗，所以在重构代码时更偏向面向对象。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd7249067984dec381de9425096389fb/" rel="bookmark">
			为什么大部分企业面试官都会问GMV，GMV是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创 Jalenxr 数据运营与数据分析https://mp.weixin.qq.com/s?__biz=MzI1NTEyODAxOA==&amp;mid=2247484602&amp;idx=1&amp;sn=4a6f80a7a044f9f9228395f40b62f536&amp;chksm=ea3bfc07dd4c75111e541ada4aaa062a62cfd700923dd0131ea877003c53b8e48a7599c9618f&amp;token=1574959386&amp;lang=zh_CN#rd
GMV是什么？ GMV：Gross Merchandise Volume，是(一定时间内)的成交总额。多用于电商行业，通常包含拍下未支付订单金额。如淘宝、京东、天猫很多知名电商，常用GMV代指网站的成交金额，主要包括付款金额和未付款。
GMV怎么计算？ GMV(成交总额)是用来衡量平台竞争力(市场占有率)的指标。通常电商平台的GMV=销售额+取消订单金额+拒收订单金额+退货订单金额，即GMV为已付款订单和未付款订单之和。
GMV和营业收入有何区别？ 营业收入一般对应的是实际流水，而电商gmv成交总金额订单金额(包含付款和未付款)。故而GMV是大于营业收入的。
为什么需要GMV指标？ gmv用来研究顾客的购买意愿，顾客买了之后发生退单的比率，gmv与实际成交额的比率。实际成交金额/gmv 的值偏小时，说明顾客对产品的喜好度不高，即使我们通过各种营销手段让顾客购买了产品，但还是有较多客户对产品不是很钟意。
gmv反应了平台的竞争力，所以作为平台方用于做报道是非常好的一个指标。比如A平台第3季度的营业收入是5000万，平台的gmv是10000万，而B平台营业收入有7000万，平台gmv是9000万，那么商家选择入职平台的时候往往会优先选择A平台。
GMV真的可信吗？ 说到这个问题电商行业的小伙伴就非常清楚了。由于淘宝、天猫、京东等知名电商对GMV的定义中是允许商家刷单的，只要不超出平台的GMV计算规则，所以GMV的结果是存在水分的。在实际工作中有的平台内部核算的GMV和报道公开的也是有差异的，但数据并不是虚假的，故而gmv只是相对可信的。
面试官为什么会问gmv? 面试官考察我们对gmv的认知，也就是你是否有决策建议能力。因为gmv指标计算非常简单，而且日常中经常会计算，但我们往往会忽略这个名词的存在，如果你对这个指标不了解，则面试官潜意识里就会觉得你之前做的更多只是执行上级领导安排的工作，即使用统计过这方面的数据，但你并没有这方面的意识，同时也默认你并不关注竞争对手的情况。
面试官有时会问你上一家公司的上个季度GMV达到多少，年度GMV是多少。这个就是想大概知道你上一家公司或平台的大概实力，变相的了解你在这家公司的所处的工作大致情况。
面试如何回答GMV的问题？ 如果你面试数据分析，数据运营等相关岗位的工作，尤其是电商行业，这个问题的回答也是非常简单的。1.回答GMV是(一定时间内)的成交总额,包含了拍下未支付订的单金额。它等于销售额+取消订单金额+拒收订单金额+退货订单金额。如果之前有类似工作经验，再回答一下上家公司的GMV大概情况，月度/季度/年度。
有人说我并没有真正计算我们之前公司的gmv啊，现在都离职了，也没有数据计算了呀，没关系，你干了那么久，公司大概的营销情况你应该是知道的，随机应变回答一个适当的值即可。如某化妆品公司7月的产品售卖总价是3000万左右，则大概的回答gmv是3500-4000万左右，电商活动月(6、11、12月)可以再增加2-3倍。
喜欢，请关注作者扫码关注作者哦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c280c602e6350c64c3e493a55b4ba34c/" rel="bookmark">
			C语言必背代码大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于刚学计算机编程的同学来说，每一个编程知识都觉得很重要。下面小编为大家整理了c语言必背代码，希望大家喜欢。
1、/*输出9*9口诀。共9行9列，i控制行，j控制列。*/
#include "stdio.h" main() {int i,j,result; for (i=1;i&lt;10;i++) { for(j=1;j&lt;10;j++) { result=i*j; printf("%d*%d=%-3d",i,j,result);/*-3d表示左对齐，占3位*/ } printf("\n");/*每一行后换行*/ } } 2、/*古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？
兔子的规律为数列1,1,2,3,5,8,13,21....*/
main() { long f1,f2; int i; f1=f2=1; for(i=1;i&lt;=20;i++) { printf("%12ld %12ld",f1,f2); if(i%2==0) printf("\n");/*控制输出，每行四个*/ f1=f1+f2; /*前两个月加起来赋值给第三个月*/ f2=f1+f2; /*前两个月加起来赋值给第三个月*/ } } 3、/*判断101-200之间有多少个素数，并输出所有素数及素数的个数。
程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，
则表明此数不是素数，反之是素数。*/
#include "math.h" main() { int m,i,k,h=0,leap=1; printf("\n"); for(m=101;m&lt;=200;m++) { k=sqrt(m+1); for(i=2;i&lt;=k;i++) if(m%i==0) {leap=0;break;} if(leap) /*内循环结束后，leap依然为1，则m是素数*/ {printf("%-4d",m);h++; if(h%10==0) printf("\n"); } leap=1; } printf("\nThe total is %d",h); } 4、/*一个数如果恰好等于它的因子之和，这个数就称为"完数"。例如6=1＋2＋3.编程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c280c602e6350c64c3e493a55b4ba34c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/237/">«</a>
	<span class="pagination__item pagination__item--current">238/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/239/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>