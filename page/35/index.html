<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76d81771b9beade4c6bcf19c457c08ea/" rel="bookmark">
			【OJ】任意日期是星期几
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; class Solution { public: string dayOfTheWeek(int day, int month, int year) { int num_of_day = GetDayBetweenYears(1971, year) + GetDayBetweenMonths(year, 1, month) + day - 1; return WEEKDAY[num_of_day % 7]; } private: int GetDayBetweenYears(const int first, const int second) { int sum = 0; for (int i = first; i &lt; second; i++) { if (IsLeapYear(i)) { sum += days_leap; } else { sum += days_common; } } return sum; } int GetDayBetweenMonths(const int year, const int first, const int second) { int sum = 0; for (int i = first; i &lt; second; i++) { sum += month_day[i]; } if (second &gt; 2 &amp;&amp; IsLeapYear(year)) { sum += 1; } return sum; } bool IsLeapYear(const int i) { return (i % 400 == 0 || (i % 4 == 0 &amp;&amp; i % 100 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76d81771b9beade4c6bcf19c457c08ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d778d64e635565bc0e18fe88a931c4b/" rel="bookmark">
			C--树的常见案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二叉树
二叉树（Binary Tree）是树形结构的一个重要类型。它的特点是每个节点最多有两个子节点，通常被称为左子节点和右子节点。这种结构在计算机科学中非常常见，被广泛应用于各种算法和数据结构中。
二叉树的基本性质 非空二叉树只有一个根节点。每个节点最多有两个子节点，通常称为左子节点和右子节点。节点的子树分左右，左子树上所有节点的值均小于它的根节点的值，右子树上所有节点的值均大于或等于它的根节点的值。二叉树的第i层上的节点数目最多为 2^(i-1) 个(i&gt;=1)。深度为k的二叉树最多有 2^k - 1 个节点(k&gt;=1)。 二叉树的类型 满二叉树：每一层的节点数都达到最大值。也就是说，如果一个二叉树的层数为K，且节点总数是(2^k) -1 ，则它就是满二叉树。完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层有节点，并且所有节点从左向右连续紧密排列，这样的二叉树被称为完全二叉树。 二叉树的遍历 遍历二叉树是指按照某种规则访问二叉树的每个节点，使得每个节点被访问且仅被访问一次。常见的遍历方式有四种：前序遍历、中序遍历、后序遍历和层次遍历。
前序遍历：根节点 -&gt; 左子树 -&gt; 右子树中序遍历：左子树 -&gt; 根节点 -&gt; 右子树后序遍历：左子树 -&gt; 右子树 -&gt; 根节点层次遍历：按照树的层次，从上到下、从左到右遍历节点。 二叉树的应用 二叉树在许多领域都有广泛的应用，例如：
搜索：二叉搜索树是一种特殊的二叉树，它允许我们以对数时间复杂度进行搜索、插入和删除操作。表达式树：在编译器设计中，表达式通常以二叉树的形式表示，其中叶子节点是操作数，非叶子节点是操作符。优先队列：堆（一种特殊的完全二叉树）是实现优先队列的有效数据结构。数据压缩：霍夫曼编码等压缩算法使用二叉树来存储编码信息。 二叉树不仅是数据结构课程中的重要内容，也是解决实际问题时常用的工具。通过学习和掌握二叉树，你可以更好地理解树形结构的概念，并将其应用于实际编程中。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; // 定义二叉树节点结构体 typedef struct TreeNode { int value; // 节点的值 struct TreeNode* left; // 指向左子节点的指针 struct TreeNode* right; // 指向右子节点的指针 } TreeNode; // 创建新节点 TreeNode* createNode(int value) { TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode)); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d778d64e635565bc0e18fe88a931c4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4c50a2921d0b81f8f15572e8c5f683f/" rel="bookmark">
			Vits2.3-Extra-v2:中文特化，如何训练及推理（新手教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： Vits2.3-Extra-v2:中文特化修复版
auto_DataLabeling
干声10分钟左右.wav
问题描述： Vits2.3-Extra-v2:中文特化，如何训练及推理（新手教程）
解决方案： 一、准备数据集
切分音频
本次音频数据自己录制干声10分钟左右
1.运行auto_DataLabeling\slicer-gui\slicer-gui.exe
2.点击左上角Add Audio Files，导入源音频文件
静音检测 本应用根据 RMS（均方根）来测量音频的安静度并检测静音部分，计算每个帧的 RMS 值（帧长度设为 hop size（跳跃步长）），RMS 低于 threshold（阈值）的所有帧都将被视为静默帧。 音频切片 一旦检测到自上次切片以来的有效（声音）部分达到 min length （最小长度），且长度超过 min interval（最小间距）的静音部分，该音频将从静音区域内 RMS 值最低的帧脱离出来。长时间静音的部分可能会被删除。 参数 Threshold（阈值） 以 dB 表示的 RMS 阈值。所有 RMS 值都低于此阈值的区域将被视为静音。如果音频有噪音，请增加此值。默认值为 -40。 Minimum Length（最小长度） 每个切片音频剪辑所需的最小长度，以毫秒为单位。默认值为 5000。 Minimum Interval（最小间距） 要切片的静音部分的最小长度，以毫秒为单位。如果音频仅包含短暂的中断，请将此值设置得更小。此值越小，此应用程序可能生成的切片音频剪辑就越多。请注意，此值必须小于 min length 且大于 hop size。默认值为 300。 Hop Size（跳跃步长） 每个 RMS 帧的长度，以毫秒为单位。增加此值将提高切片的精度，但会降低处理速度。默认值为 10。 Maximum Silence Length（最大静音长度） 在切片音频周围保持的最大静音长度，以毫秒为单位。根据需要调整此值。请注意，设置此值并不意味着切片音频中的静音部分具有完全给定的长度。如上所述，该算法将搜索要切片的最佳位置。默认值为 1000。 性能 此应用程序在 Intel i7 8750H CPU 上的运行速度超过 400 倍于实时。速度可能因 CPU 和磁盘而异。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4c50a2921d0b81f8f15572e8c5f683f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1938ceff5847f7637511c8c7edd312d/" rel="bookmark">
			零基础小白也行，只用一行命令在自己的电脑跑大模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Ollama Ollama是一款免费开源的工具，拥有开箱即用的大模型，省去安装环境和下载模型的步骤，让零基础的人也能用起大模型。
项目地址
下载方法 通过下载链接可以找到对应的操作系统的下载版本，而且访问该网站不受限制，不需要神秘力量。
对于Mac和Win，可以直接通过点击下载桌面客户端，非常方便。
而Linux也可以通过一条命令完成安装。
# linux系统安装 curl -fsSL https://ollama.com/install.sh | sh 使用方法 下载完客户端并安装成功之后，打开命令行终端，就会显示ollama命令已经可以使用了。以后无需再打开客户端软件，只需要在命令行输入相关命令即可。
# 参数说明 Large language model runner Usage: ollama [flags] ollama [command] Available Commands: serve Start ollama create Create a model from a Modelfile show Show information for a model run Run a model pull Pull a model from a registry push Push a model to a registry list List models cp Copy a model rm Remove a model help Help about any command Flags: -h, --help help for ollama -v, --version Show version information Use "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1938ceff5847f7637511c8c7edd312d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a4e3d52e53fea3de0fbc925a29783df/" rel="bookmark">
			数据结构中的平衡搜索树 --- AVL树是怎样进行旋转处理的？（平衡因子版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
搜索二叉树
AVL树
节点的定义
插入
旋转
前言
搜索二叉树 搜索二叉树 又称 二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:
若它的左子树不为空，则左子树上所有节点的值都小于根节点的值若它的右子树不为空，则右子树上所有节点的值都大于根节点的值它的左右子树也分别为二叉搜索树 示例：
具体可以查看搜索二叉树
但是二叉搜索树有其自身的缺陷，假如往树中插入的元素有序或者接近有序，二叉搜索树就会退化成单支树（或接近单只树），二叉搜索树的性能就失去了，并且 时间复杂度会退化成O(N)，因此需要对底层结构进行平衡处理，即采用平衡树（AVL树、红黑树）来实现，使二叉搜索树的性能都能达到最优. AVL树 AVL树的概念 二叉搜索树虽可以缩短查找的效率，但如果数据有序或接近有序二叉搜索树将退化为单支树，查 找元素相当于在顺序表中搜索元素，效率低下 。因此，两位俄罗斯的数学家 G.M.Adelson-Velskii和E.M.Landis 在 1962 年发明了一种解决上述问题的方法：当向二叉搜索树中插入新结点后，如果能保证每个结点的左右 子树高度之差的绝对值不超过 1( 需要对树中的结点进行调整 ) ，即可降低树的高度，从而减少平均搜索长度。 一棵 AVL 树或者是空树，或者是具有以下性质的二叉搜索树： 它的左右子树都是AVL树 左右子树高度之差(简称平衡因子)的绝对值不超过1(-1/0/1） --- 一般是右子树减去左子树等于根 如果一棵二叉搜索树是高度平衡的，它就是 AVL 树。如果它有 n 个结点，其高度可保持在 $O(log_2 n)$ ，搜索时间复杂度 O($log_2 n$) 。 AVL树节点的定义 template&lt;class K, class V&gt; class AVLTreeNode { AVLTreeNode&lt;K,V&gt;* _left;	//左子树节点 AVLTreeNode&lt;K, V&gt;* _right;	//右子树节点 AVLTreeNode&lt;K, V&gt;* _parent;	//父节点 pair&lt;K, V&gt; _kv; int _bf; //balance factor :平衡因子 AVLTreeNode(const pair&lt;K, V&gt;&amp; kv) :_left(nullptr) , _right(nullptr) , _parent(nullptr) ,_kv(kv) ,_bf(0) {} }; AVL树的插入 AVL 树就是在二叉搜索树的基础上引入了平衡因子，因此 AVL 树也可以看成是二叉搜索树。那么AVL树的插入过程可以分为两步： 按照二叉搜索树的方式插入新节点 调整节点的平衡因子 template&lt;class K,class V&gt; class AVLTree { typedef AVLTreeNode&lt;K, V&gt; Node; public: bool insert(const pair&lt;K, V&gt;&amp; kv) { //_root为空 if (_root == nullptr) { _root = new Node(kv); return true; } //_root不为空 Node* cur = _root; Node* parent = nullptr; //记录cur的父节点，方便进行链接 while (cur) { if (kv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a4e3d52e53fea3de0fbc925a29783df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac4b4a5c2d6915f80fa59d5128a44051/" rel="bookmark">
			Ubuntu 14.04：PaddleOCR基于PaddleServing的在线服务化部署（失败）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 二、安装 注：
安装 PaddleOCR 2.3 。
因为 PaddleOCR 2.4 的 推荐环境 PaddlePaddle &gt;= 2.1.2。
https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.4/doc/doc_ch/environment.md
安装前的环境准备 在使用Paddle Serving之前，需要完成如下任务：
（1）安装python 3.8 具体安装方法请参见 Ubuntu 14.04：安装PaddlePaddle（Conda安装）-CSDN博客 （2）安装paddlepaddle 2.0.0
具体安装方法请参见 Ubuntu 14.04：安装PaddlePaddle（Conda安装）-CSDN博客 参考资料：https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.3/doc/doc_ch/environment.md
安装时的运行环境准备 准备 PaddleOCR 的运行环境链接 下载 PaddleOCR 2.3
https://codeload.github.com/PaddlePaddle/PaddleOCR/zip/refs/heads/release/2.3
上传到目标位置，解压
unzip PaddleOCR-release-2.3.zip
注：
官方文档中，是 clone。
因为我 clone 时有异常，偷懒不想处理，就直接下载包，然后安装。
查看 github 中的 PaddleOCR 版本 GitHub - PaddlePaddle/PaddleOCR
准备 PaddleServing 的运行环境 参考资料：https://github.com/PaddlePaddle/Serving/blob/v0.9.0/doc/Latest_Packages_EN.md
查看版本：
https://github.com/PaddlePaddle/Serving
切换到 PaddleOCR 的运行环境中的 pdserving 目录 /home/xxx/PaddleOCR-release-2.3/deploy/pdserving
paddle-serving-server：paddle_serving_server-0.9.0-py3-none-any.whl 安装server，用于启动服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac4b4a5c2d6915f80fa59d5128a44051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cd35d57b8c7075379316e469590e568/" rel="bookmark">
			探索TikTok云手机在社交媒体营销的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，TikTok作为全球短视频平台之一，其用户基数呈现持续增长的趋势。伴随社交媒体的蓬勃发展，企业和个人纷纷涌入TikTok平台，追求更广泛的曝光和用户互动。为满足这一需求，TikTok云手机应运而生。本文将深度剖析TikTok云手机的定义及其在社交媒体营销中的关键作用。
什么是TikTok云手机？
TikTok云手机是一项基于云计算技术的虚拟手机服务。用户可通过云手机服务，在云端模拟并使用一个虚拟的Android手机系统，从而远程操作和控制这个虚拟手机。这项服务的推出为用户提供了更灵活、便捷的社交媒体运营方式。
TikTok云手机的核心原理
通过虚拟化技术，TikTok云手机将完整的Android手机系统部署在云服务器上。用户可通过专用应用或在线平台模拟和控制这个虚拟手机，实现对多个TikTok账号的同时运营。这项技术为用户带来更高的灵活性，特别适用于需要管理多个账号的用户。
TikTok云手机的多重作用
提升曝光度：
通过TikTok云手机，用户得以同时运营多个TikTok账号，发布更多内容，从而提高在平台上的曝光度。这对企业和个人来说是拓展品牌知名度和吸引更多关注的有效途径。
解决地理限制：
TikTok云手机助力用户绕过地理限制，在全球范围内操作TikTok账号。对于希望在不同地区推广产品或服务的企业而言，这尤为重要，拓展了目标受众的范围。
提高运营效率：
对于社交媒体运营者而言，TikTok云手机能够提升运营效率。用户可在同一界面上管理多个账号，避免频繁切换账号的繁琐，更高效地进行社交媒体营销。
降低设备成本：
相较于购买多台物理手机，使用TikTok云手机显著降低设备成本。企业和个人可更经济地进行多账号运营，无需购买大量手机设备。
提供虚拟测试环境：
TikTok云手机可用作虚拟测试环境，用户可以在虚拟手机上测试TikTok广告、观察用户反应，更好地制定营销策略。
然而，尽管TikTok云手机在社交媒体运营中具备多项优势，使用时仍需遵守相关法规和平台规定，确保操作的合规性，避免因违规行为导致封禁或处罚的风险。
总体而言，TikTok云手机作为一种创新的虚拟手机服务，为用户提供了更灵活、高效的社交媒体运营方式。通过提升曝光度、解决地理限制、提高运营效率、降低设备成本等作用，TikTok云手机成为社交媒体营销领域的一项强大工具，为用户创造更多可能性。在使用时务必谨慎遵守相关规定，确保操作的合法性和合规性。
如果您对tiktok云手机感兴趣，不妨联系Ogcloud进行进一步了解！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4dbf6889cb1328b62e3a79c9bda24e9/" rel="bookmark">
			cad怎么转换成黑白的pdf图纸？分享3个常用的软件！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在工程设计、建筑、机械制造等领域，CAD图纸的应用非常广泛。然而，有时出于某些需要，我们可能需要将CAD图纸转换为黑白的PDF格式。那么，如何实现这一转换呢？本文将为您详细介绍几种常用的转换软件及其操作步骤。
迅捷CAD转换器 迅捷CAD转换器以其强大的功能和简洁的操作界面，赢得了众多设计师的青睐。它的CAD转PDF功能更是凭借其高效、准确的转换效果，成为市场上的一股清流。接下来，我们将详细介绍迅捷CAD转换器的CAD转PDF功能，带您领略其魅力所在。
以下是使用迅捷CAD转换器将CAD图纸转换为黑白PDF的详细步骤：
在软件界面的右侧，点击“CAD转PDF”选项，进入转换功能界面。 在选择完CAD文件后，您可以根据需要在设置区域调整转换参数。设置好参数后，点击“开始转换”按钮，迅捷CAD转换器将立即开始将CAD文件转换为PDF格式。转换完成后，您可以点击“打开”按钮，直接查看生成的PDF文件。 二、在线转换工具：Online2PDF网站
除了专业的转换软件，您还可以选择使用在线转换工具。Online2PDF网站是一个简单易用的在线CAD转PDF工具。以下是使用它的步骤：
打开Online2PDF网站。在网站上，找到并选择“CAD转PDF”功能。上传您要转换的CAD文件。在设置选项中，找到“输出格式”或“输出类型”，选择PDF格式。如果有选项可以选择输出色彩，请确保选择“黑白”或“灰度”。点击“开始转换”按钮，等待转换完成。转换后的PDF文件可以直接下载到您的电脑上。 三、其他软件推荐
除了上述两种软件，还有一些其他的CAD转换工具也支持将CAD文件转换为黑白PDF，例如：
PDFCreator：这是一款虚拟打印机软件，可以将任何可打印的文件转换为PDF格式。虽然它本身不支持直接从CAD文件转换，但您可以先将CAD文件打印为黑白图像，然后使用PDFCreator将其转换为PDF。 总之，无论您选择使用哪种软件或工具，转换CAD文件为黑白PDF的过程都相对简单。只需按照软件的提示步骤进行操作，注意选择正确的输出格式和色彩设置，即可完成转换。希望本文的介绍能对您有所帮助！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf04ac8dfb7310e2605b9e83e15e3046/" rel="bookmark">
			深入SOCKS5代理、代理IP、HTTP与网络安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名软件工程师，探索网络通信的深层原理不仅仅是一项技术挑战，更是深入了解现代网络安全的必经之路。在这篇文章中，我们将探讨四个关键概念：SOCKS5代理、代理IP、HTTP协议以及网络安全，它们如何共同构成了我们日常网络交互的基础，并揭示这些技术背后的深奥性与实用性。
SOCKS5代理：更高级的网络隐身术 SOCKS5代理作为一个网络协议，提供了一种中间层服务，使得客户端与服务器之间的通信可以通过一个代理服务器进行。与其前身SOCKS4相比，SOCKS5增加了对IPv6的支持、用户名和密码的认证机制，以及更加灵活的错误处理和数据包转发机制。它能够处理更复杂的网络请求，包括UDP协议和IPv6地址，使得SOCKS5代理成为了实现网络匿名和绕过地理限制的强大工具。
代理IP：掩盖身份的关键 代理IP，顾名思义，是指通过代理服务器进行网络请求时所使用的IP地址。它的作用不仅仅是隐藏用户的真实IP地址，更在于它能够帮助用户绕过IP基础的访问控制，比如地理位置的限制或是IP黑名单的封锁。在网络安全领域，使用代理IP也是一种保护个人隐私和增加网络访问安全性的手段。
HTTP：万维网的通信基石 超文本传输协议（HTTP）是互联网上应用最广泛的协议之一，它定义了客户端和服务器之间交换信息的方式。HTTP是一个基于请求-响应模式的无状态协议，意味着每次交互都是独立的，不会保留之前的状态。虽然HTTP本身不加密，容易受到中间人攻击，但它的安全版本HTTPS通过SSL/TLS加密，为数据传输提供了保护，是现代网络安全的基础之一。
网络安全：守护数字世界的防线 网络安全涵盖了保护计算机网络和数据免受未经授权访问或破坏的各种技术和实践。在使用SOCKS5代理、代理IP和HTTP进行网络通信时，网络安全措施变得尤为重要。这包括使用加密技术保护数据传输，采取身份验证措施防止未授权访问，以及定期更新软件来修补安全漏洞。了解和实施这些网络安全措施，是每位软件工程师的基本职责。
结语 在这个信息快速发展的时代，作为软件工程师，深入理解SOCKS5代理、代理IP、HTTP协议及网络安全的重要性不言而喻。它们不仅是构建安全、高效网络应用的基石，更是我们在数字世界中导航和探索的灯塔。通过本文的探讨，希望能够激发更多技术人员对网络底层原理和安全实践的兴趣，共同努力守护这个数字时代的安全与隐私
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ba45239f0f4afc4f2f9ebf26c857fc7/" rel="bookmark">
			MongoDB聚合运算符：$divide
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 语法举例 $divide聚合运算符返回两个表达式相除的结果，参数通过数组传递给$divide运算符。
语法 { $divide: [ &lt;expression1&gt;, &lt;expression2&gt; ] } 数组的第一个元素是被除数，第二个元素是除数，就是第一个元素除以第二个元素。&lt;expression&gt;可以是任何可以被解析为数值的表达式。 举例 使用下面的脚本创建planning集合：
db.planning.insertMany( [ { "_id" : 1, "city" : "New York", "hours" : 80, "tasks" : 7 }, { "_id" : 2, "city" : "Singapore", "hours" : 40, "tasks" : 4 } ] ) 下面的聚合使用$divide表达式使用hours字段除以常量8，计算工作天数：
db.planning.aggregate( [ { $project: { city: 1, workdays: { $divide: [ "$hours", 8 ] } } } ] ) 操作返回的结果如下：
{ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ba45239f0f4afc4f2f9ebf26c857fc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9319114af0909e7be3294be45574a23f/" rel="bookmark">
			【每日一题】45. 跳跃游戏2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
0 &lt;= j &lt;= nums[i]
i + j &lt; n
返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
示例 1:
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:
输入: nums = [2,3,0,1,4]
输出: 2
在这里插入图片描述
解题思路
此题我使用的贪心算法的思路,确保每一步都为最优解
有三个概念:1.当前位置2.当前覆盖范围3.最大覆盖范围
在循环中进行比较,如果最大范围比数组长度长则退出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9319114af0909e7be3294be45574a23f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0797b0b47ac345c6c396b94ff2736022/" rel="bookmark">
			鸿蒙开发实战：【ylong_http】解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 ylong_http 构建了完整的 HTTP 能力，支持用户使用 HTTP 能力完成通信场景的需求。
ylong_http 使用 Rust 编写，为 OpenHarmony 的 Rust 能力构筑提供支持。
ylong_http 在 OpenHarmony 中的位置 ylong_http 向 OpenHarmony 系统服务层中的网络协议栈模块提供 HTTP 协议支持，经由网络协议栈模块帮助上层应用建立 HTTP 通信能力。
以下是对于上图关键字段的描述信息：
APP：需要使用上传下载能力的直接面向用户的上层应用。
request：提供上传下载能力的系统组件。
netstack：提供网络协议栈功能的系统组件。
ylong_http：提供 HTTP 能力的系统组件。
ylong_http_client：ylong_http 下的模块之一，提供 HTTP 客户端能力。ylong_http:ylong_http 下的模块之一，提供 HTTP 的基础能力。 ylong_runtime：ylong 提供的 Rust 异步运行时库。
tokio：业界常用的第三方 Rust 异步运行时库。
OpenSSL：业界常用的第三方 TLS 实现库。
ylong_http 的内部架构: ylong_http 内部当前分为两个主要模块：ylong_http_client 客户端模块和 ylong_http 协议组件模块。
ylong_http_client 模块负责提供 HTTP 客户端功能，能够支持用户发送 HTTP 请求，并接收 HTTP 响应，内部又分为三个主要部分:
sync_impl：同步的 HTTP 客户端实现，该客户端实现不依赖于任何运行时，可以直接在线程模型上运行，但是整体使用同步阻塞策略。async_impl：异步的 HTTP 客户端实现，该客户端实现需要使用 Rust 的异步运行时组件。异步 HTTP 客户端利用 Rust 的异步能力，具有优异的性能表现。Util：同步和异步的 HTTP 客户端部分实现共通，例如自动重定向、HTTP 代理等。 sync_impl 和 async_impl 接口原型基本一致（主要是 Rust 异步语法与同步语法的差异），所以用户可以在较小的代码改动量下完成同步和异步逻辑的切换。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0797b0b47ac345c6c396b94ff2736022/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286b39672c4e6109bbab84585a5ef61b/" rel="bookmark">
			Hbase集群搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、引言
二、简介
三、下载&amp;解压安装包
四、hbase配置&amp;验证
五、启动并验证Hbase集群
官网：Apache HBase – Apache HBase Downloads
一、引言 适用人群：了解Hbasede程序猿.
文章目的：给部署Hbase的开发者，提供参考。
二、简介 HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群。
三、下载&amp;解压安装包 集群使用三台服务器分别为A、B、C，一般单台把公用配置完成后，传输到其他机器，可简化步骤。下面在A服务器上面上操作。
进入官网或相关网址下载Hbase安装包，http://www-us.apache.org/dist/hbase/1.2.4/，下载后解压缩到A服务器文件夹/opt/tpapp/。
四、hbase配置&amp;验证 创建用户，因为Hbase依赖于Hadoop以及Zookeeper所以在安装好Hadoop环境后，使用hadoop用户即可（参见hadoop集群安装文档），以及下面第2条的hosts文件配置也可以是一样的。首先需要在hosts文件中配置部署服务器对应域名（如果Hbase部署的机器和Hadoop相同可以不用配置，直接使用hadoop配置的域名即可），以A、B、C三台机器为例；在hosts文件中添加以下内容： 10.100.40.12 master 10.100.40.13 node1 10.100.40.14 node2 修改hbase-env.sh文件，修改其中的java 地址： # export JAVA_HOME=/usr/java/jdk1.6.0/ export JAVA_HOME=/opt/tpapp/jdk1.7.0_25 修改hbase-site.xml文件，在文件中添加以下信息（因为hbase依赖于hadoop和zookeeper,配置中的rootdir和zookeeper配置需要对应已经装好的服务器位置）： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt; &lt;value&gt;9527&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zoopkeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/opt/tpapp/zookeeper&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;master,node1,node2&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 修改regionservers的内容为(regionserver 指的是是文件存储服务器)： node1 node2 配置备份master(实现高可用，防止在master宕机情况下，node1能够及时接管master的工作，维持集群的运作),在/opt/tpapp/hbase/conf 文件夹下面创建backup-master文件并写入以下内容： node1 传输配置好的文件夹/opt/tpapp/hbase 至B、C服务器。 scp -r /opt/tpapp/hbase hadoop@node1:/opt/tpapp/ scp -r /opt/tpapp/hbase hadoop@node1:/opt/tpapp/ 修改文件夹所属关系 chown -R hadoop:hadoop /opt/tpapp/hbase 配置各服务器的Hbase环境变量并使之生效，进入/etc/profile添加以下内容： export HBASE_HOME=/opt/tpapp/habse export PATH=$PATH:$HBASE_HOME/bin 修改完成后使用source /etc/profile 使其生效 五、启动并验证Hbase集群 启动Hbase前，需要先启动Hadoop集群、Zookeeper集群，最后启动Hbase集群（请使用之前设置的Hadoop账户，只需要在Hbase集群的master节点启动即可启动其他机器），命令： 启动： /opt/tpapp/hbase/bin/start-hbase.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/286b39672c4e6109bbab84585a5ef61b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72bb6cc298234dc77eeee3bae7abefcd/" rel="bookmark">
			跟着Google学-Hilt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hilt最详细教程 by google
1. 简介 在本 Codelab 中，您将了解在打造可靠且能够顺利发展为大型项目的应用时，依赖项注入 (DI) 的重要性。我们将使用 Hilt 作为依赖项注入工具来管理依赖项。
依赖项注入是一种在编程中运用广泛的技术，非常适用于 Android 开发。遵循依赖项注入的原则可以为良好的应用架构奠定基础。
实现依赖项注入可为您带来以下优势：
重用代码易于重构易于测试 Hilt 是 Android 颇具特色的依赖项注入库，可减少在项目中使用手动依赖项注入时产生的样板代码。手动依赖项注入要求您手动构造每个类及其依赖项，并借助容器来重复使用和管理依赖项。
Hilt 通过为项目中的每个 Android 组件提供容器并自动为您管理容器生命周期，提供了一种在应用中执行依赖项注入的标准方法。这通过利用热门依赖项注入库 Dagger 实现。
如果在此 Codelab 的操作过程中遇到任何问题（代码错误、语法错误、措辞含义不明等），欢迎通过 Codelab 左下角的“报告错误”链接向我们报告相应问题。
前提条件 您有 Kotlin 语法经验。您了解依赖项注入为什么对应用至关重要。 如需详细了解依赖项注入，请参阅以下资源：
依赖项注入基础知识Android 中的手动依赖项注入 学习内容 如何在 Android 应用中使用 Hilt。与打造可持续发展的应用相关的 Hilt 概念。如何使用限定符为同一类型添加多个绑定。如何使用 @EntryPoint 从 Hilt 不支持的类访问容器。如何使用单元测试和插桩测试来测试使用 Hilt 的应用。 所需条件 Android Studio 4.0 或更高版本。 2. 准备工作 获取代码 从 GitHub 获取 Codelab 代码：
$ git clone https://github.com/googlecodelabs/android-hilt
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72bb6cc298234dc77eeee3bae7abefcd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b873a0a5eee0df7eca4f7cc655dfc0a/" rel="bookmark">
			测试用例的设计(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.前言
2.正交排列(正交表)
2.1什么是正交表
2.2正交表的例子
2.3正交表的两个重要性质
3.如何构造一个正交表
3.1下载工具
3.1构造前提
4.场景设计法
5.错误猜测法
1.前言 我们在前面的文章里讲了测试用例的几种设计方法,分别是等价类发,把测试例子划分成不同的类型,在每个类型中选取一个.这样可以解决软件测试不能穷举的问题.还有边界值法.该方法可以完善等价类划分法,我们把测试用例中的范围划分成.上点(边界上的点),内点(边界内的点),还有离点(如果是开区间,就是边界内离得最近的一个点,如果是闭区间,就是边界外离得最近的一个点). 还有因果图,通过它来画判定表,把测试的条件都全面考虑到来细致的测.
实际开发过程中,我们需要掌握的设计测试用例的方法远远不止这些.今天我们来讲述一下其它的划分测试用例的方法.
2.正交排列(正交表) 前面我们介绍了判定表这种设计测试用例的思路,但是如果我们的因素如果很多的话,那么就很不好通过手动的去设计,我们可以借助工具来设计正交表.(后面会提到工具的安装和使用),
2.1什么是正交表 最简单的正交表(L4(2 3) 其中L 表示正交表,L右下角的数字4 表示有四行,即要做四次实验,括号内的指数3代表了 列 ,即最多允许安排的因素是3个,括号内的2 代表了主要部分只有2种数字,即因素有两种水平1和2,正交表的特点是其安排的实验方式具有均衡搭配特性
2.2正交表的例子 我们先科普两个简单的点.即什么是因素 ,什么是水平. 因素通俗易懂的讲就是输入变量.而水平则是每一个输入变量的取值.比如我们有三个因素,则会有三个变量,水平有0和1 那么我们就可以先做出以下的表格
我们可以得到以下的正交表
这就是一个简单的正交表
2.3正交表的两个重要性质 1.每一列中的数字出现的次数一样多
2.任何两列中各有序树对出现的次数都一样对
我们随便观察一列,比如第一列,发现0和1都是只出现了2次,我们来看看第一列和第三列,发现 00和11都是出现了一次.
3.如何构造一个正交表 3.1下载工具 我们可以在这个链接AllPairs download | SourceForge.net 下载我们需要的工具,allpairs.
下载好以后,我会 举例子告诉大家怎么使用这个.
3.1构造前提 在构造一个正交表的时候,我们需要以下的步骤, 充分理解需求-&gt;确定因素-&gt;确定水平-&gt;画正交表-&gt;补充正交表-&gt;将正交表转化为测试用例
比如我们在注册一个用户信息的时候,需要以下因素: 姓名,邮箱,确定密码,验证码 必须全部输入,我们才能成功注册. 填写和不填写是两个水平,那么我们就可以根据以上的需求.画出我们的正交表.(在这里我们使用一个工具来画(allpairs)
首先我们把上述分析出来的需求和水平写到表格里.
把表格中的文字复制到txt文件中,并保存到 allpairs这个软件的目录中,
打开命令行 通过 d:和 cd 目录路径 找到 allpairs这个软件的路径
然后使用dir这个命令查看该文件下的所有目录
可以看到我们刚刚保存在这里面的txt文件还在.
然后使用命令 allpairs.exe Test.txt &gt; Test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b873a0a5eee0df7eca4f7cc655dfc0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f2c3755dd6099a90eba0b32284a524a/" rel="bookmark">
			在Dart中，读取文件有两种常见的方式：使用 Stream 和使用 Future
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用 Stream 读取文件： import 'dart:io'; void main() { Stream&lt;List&lt;int&gt;&gt; stream = File("example.txt").openRead(); stream.listen((List&lt;int&gt; event) { // 处理文件内容 print(event); }); } 异步处理： Stream 适用于处理大文件或需要异步处理的文件读取操作。它允许你通过监听事件的方式来处理文件内容，这在处理大型文件时可以提供更好的性能和响应性。适用于大文件： Stream 适用于读取大文件，因为它可以逐块读取而不是一次性加载整个文件到内存中。 劣势： 相对复杂： 使用 Stream 读取文件相对于 Future 可能会显得稍微复杂一些，尤其是对于简单的文件读取操作。 使用 Future 读取文件： import 'dart:io'; void main() { Future&lt;List&lt;int&gt;&gt; future = File("example.txt").readAsBytes(); future.then((List&lt;int&gt; content) { // 处理文件内容 print(content); }); } 优势： 简单明了： Future 提供了更直观、更简单的方式来读取文件内容。适用于相对简单的文件读取场景。适用于小文件： 对于小文件，一次性加载到内存中可能更为方便。 劣势： 不适用于大文件： 使用 Future 读取大文件可能会导致内存占用较高，不适用于处理大文件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55d59a1e9b8ff9e111aef6c1b64f9d4/" rel="bookmark">
			突破编程_C&#43;&#43;_面试（STL 编程 set 与 multiset）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面试题 1 ：解释一下 set 和 multiset 在 STL 中的区别。 在 C++ 的 STL（Standard Template Library）中，set 和 multiset 都是关联容器，它们存储的元素都是唯一的，并且默认按照升序对元素进行排序。然而，它们在处理重复元素时存在关键的区别。
set：
（1）唯一性： set中的元素是唯一的，即每个元素只能出现一次。如果尝试向set中插入一个已经存在的元素，操作将不会成功，且容器的内容不会改变。
（2）插入和查找： 由于set内部使用了红黑树（一种自平衡的二叉搜索树）作为底层数据结构，因此插入和查找操作的平均时间复杂度都是O(log n)，其中n是容器中元素的数量。
（3）用途： set通常用于需要快速查找唯一元素的情况，比如检查一个值是否存在于某个集合中。
multiset：
（1）允许重复： 与 set 不同，multiset 允许存储重复的元素。可以多次插入相同的元素，每次插入都会成功，并且元素会在容器中保持其插入顺序（或根据提供的比较函数进行排序）。
（2）插入和查找： multiset 同样使用红黑树作为底层数据结构，因此其插入和查找操作的平均时间复杂度也是 O(log n)。
（3）用途： multiset 适用于需要存储可能重复的元素，并且需要按某种顺序对这些元素进行排序的情况。例如，可以使用 multiset 来跟踪某个值出现的次数，或者存储一个按分数排序的学生列表，其中可能有多个学生获得相同的分数。
总结来说，set 和 multiset 的主要区别在于它们对重复元素的处理方式：set 不允许重复元素，而 multiset 则允许。这使得它们各自适用于不同的场景和需求。
面试题 2 ：如何在 set 中查找一个元素？请提供代码示例。 在 std::set 中查找一个元素，可以使用 find 成员函数。find 函数接受一个键作为参数，并返回一个迭代器，指向在容器中第一个等于该键的元素。如果未找到元素，则返回 end() 迭代器。
下面是一个如何在 std::set 中查找一个元素的代码示例：
#include &lt;iostream&gt; #include &lt;set&gt; int main() { // 创建一个set容器并插入一些元素 std::set&lt;int&gt; mySet = {1, 2, 3, 4, 5}; // 要查找的元素 int elementToFind = 3; // 使用find函数查找元素 auto it = mySet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e55d59a1e9b8ff9e111aef6c1b64f9d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06a3f8722f3147fd92556bc320c681ed/" rel="bookmark">
			使用Java的等待/通知机制实现一个简单的阻塞队列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java的等待/通知机制 Java的等待通知机制是多线程间进行通信的一种方式。
有三个重要的方法：wait()，notify() 和以及notifyAll()
wait()：该方法用于让当前线程（即调用该方法的线程）进入等待状态并且释放掉该对象上的锁。而这个线程会在以下三种情况下从 wait() 返回到执行状态： 其他线程调用了同一个对象的 notify() 方法。其他线程调用了同一个对象的 notifyAll() 方法。其他线程调用了该线程的 interrupt() 方法，线程收到中断信号。 notify()：唤醒在此对象监视器上等待的单个线程，选择其唤醒的线程是任意的，并且是随机的。唤醒后，等待线程会尝试重新获取锁并继续执行。notifyAll()：唤醒在此对象监视器上等待的所有线程。 实现阻塞队列 我们就是使用这几个方法来实现了一个简单的阻塞队列，借助生产者-消费者模型来构建更方便理解。而且是较为简单的单个生产者和单个消费者。
我们有一个容量是n的仓库，起初仓库是空的，此时消费者来消费是不可以的，因此就被阻塞，而当生产者生产了一个物品之后，就会调用notify，唤醒在此对象监视器上等待的单个线程（消费者）。当仓库是满的时候，此时生产者再生产也是不行的，也会被阻塞，此时当消费消费之后，也会调用notify唤醒在此对象监视器上等待的单个线程（生产者）。
import java.util.*; public class BlockQ&lt;T&gt; { // 队列的最大容量 static final int MAX_CAPACITY = 10; // 队列的默认容量 static final int DEFAULT_CAPACITY = 5; // 队列的最小容量 static final int MIN_CAPACITY = 1; // 队列（仓库，仓库不满生产者才能生产，仓库不空消费者才能消费） private Queue&lt;T&gt; q = new LinkedList&lt;&gt;(); // 队列的容量 private int capacity; public BlockQ(){ this.capacity = DEFAULT_CAPACITY; } public BlockQ(int capacity){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06a3f8722f3147fd92556bc320c681ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cbb824786db4b71cf87b7fb516073f7/" rel="bookmark">
			【其他】sd卡的照片在相机上能看到在电脑上却看不到
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sd卡的照片在相机上能看到在电脑上却看不到 前情提要：太长不看版解决办法：思路：一、首先考虑恢复数据二、 解决文件后缀是exe的问题 前情提要： 在相机里可以看到照片和视频，但是SD卡通过读卡器插入电脑看不到，这种情况发生在 我将其他视频文件复制到这张卡里之后，就不能使用了。
太长不看版解决办法： 参考 https://zhuanlan.zhihu.com/p/97482744
查看下面 二 2。
思路： 一、首先考虑恢复数据 1.电脑文件夹设置为《显示隐藏的文件》，此办法无效
2.使用数据恢复应用 （可以用《Recuva.exe》）恢复数据，有效，但恢复出来的文件后缀是exe。
二、 解决文件后缀是exe的问题 1.中病毒了吗？使用杀毒软件，发现无毒，无效。
2. 参考 https://zhuanlan.zhihu.com/p/97482744
（1）在SD卡里新建两个txt文件，分别1.txt 和2.txt
（在这之前，先点击文件夹标题栏上的“查看”，然后勾选“显示文件扩展名”）
（2）在1.txt中输入
Windows Registry Editor Version 5.00 [HKEY_LOCAL_ MACHINE \SOFTWARE\Microsoft\Windows\CurrentVersion \Explorer\Advanced\Folder\Hidden \SHOWALL] "CheckedValue"=dword:00000001 （3）在2.txt中输入
for /f "delims=" %%i in ('dir /ah /s/b') do attrib "%%i" -s -h （4）把文件名分别改成 1.reg 和 2.bat ，依次双击。重启计算机（可不重启），文件夹恢复正常。
（5）备份SD卡中的照片和视频文件
（6）格式化SD卡。
成功，✿✿ヽ(°▽°)ノ✿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4485544ab9966218fffba3576a1bf5/" rel="bookmark">
			高防CDN有哪些优势，如何应对ddos攻击？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DDoS攻击通过大量生成的流量，超过服务器负荷承载能力，使其无法正常运行，导致网站瘫痪和服务不可用。这不仅给企业带来经济损失，还可能伴随着声誉风险。传统的防护方法可能难以应对这类攻击，高防CDN成为了一项不可或缺的安全工具，其中高防CDN以其出色的性能和多层次的防护策略脱颖而出。
高防CDN的优势：
1.多层次的防护策略
高防CDN采用多层次的防护策略，为用户提供全面的安全保护。通过实时监控和分析流量，系统能够迅速识别并过滤掉恶意请求和DDoS攻击流量，确保服务器免受攻击，保障业务稳定运行。
2.弹性扩展能力
高防CDN具备全球分布的服务器节点，具有弹性扩展能力以满足大流量的需求。面对DDoS攻击，系统会通过智能负载均衡技术将流量均匀分发到多个节点，分散攻击压力，确保服务器的稳定性和可用性。
3.实时流量监测和分析
通过实时监测和分析流量，高防CDN能够及时识别和应对各种攻击威胁。利用先进的流量分析技术，系统能够检测异常行为、分析攻击模式，快速响应并隔离恶意流量，确保正常用户的访问不受影响。
4.自定义防护规则
高防CDN允许用户根据业务需求，灵活定制防护规则。用户可以基于不同类型的攻击设置规则，包括基于IP、基于URL、基于协议等，以确保最佳的安全防护效果。
作为企业或网站管理员，保护服务器安全是一项不可忽视的任务。高防CDN以其强大的防御力和全面的保护措施，为用户提供了可靠的解决方案，助力有效抵御DDoS攻击，确保业务稳定运行。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/34/">«</a>
	<span class="pagination__item pagination__item--current">35/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/36/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>