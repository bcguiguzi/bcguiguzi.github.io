<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4026ce77059493f2f85e25be4f4ffcd/" rel="bookmark">
			【匠心打造】从0打造uniapp 可视化拖拽设计 c_o 第六篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、这个版本的变化是左侧增加了布局设计和包资源管理器
包资源管理器：eclipse的特称，左侧的项目管理。和hbuildx左侧类似
项目的整体设计结构如下:
v1.0 普通模式：支持新建前端项目，拖拽，且生成前端项目（最终不只是uni），支持在线预览项目。
v2.0 进阶模式：兼容v1以上所有功能，且外加 实时对接服务端接口(http/https)。
v3.0 无敌模式：兼容v2以上所有功能，革命性的改变。
提供数据库的独特在线设计模式，以直面数据库的方式进行设计。
为什么要这样设计呢？
有人问了为什么要这样设计，这里我们剖析一个项目的结构
A 后台接口服务器
B 后台对应web页面
C 手机端接口服务
D 手机端web页面
底层都是基于数据库来设计
V3 模式，会提供一个直面数据库的模式，我们可以这样理解。
新增一张表 user
fid
name
age
例如：新增一个功能对应的是user 表选中是否创建该对应的B，A？
如果是A 则 生成对应的增删改查（都是可选项），
B 对应的也是表格+增删改查
基础的业务判断，我们也可以内置。就算不内置也没关系。至少节省了85%的时间。
C D 对应复杂一点。
D的结构比较多样化。对应C来说。也是一些接口的增删改查。我们也可以用V3的模式来创建接口服务，
C 的结构在c_o看来是json格式，只要我们记住内置的json格式。就能通过json，动态指定一套ui出来。或者说85%的UI
其中AC都是可以基于自己的项目技术架构内置项目模板(目前只会去支持java)，当然AC是可选项目，不使用也不影响其他的两种模式。
以上均会免费提供
第七篇：【匠心打造】从0打造uniapp 可视化拖拽设计 c_o 第七篇_我只是一个coder的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfdea364bd9438e36a4d2c1cd16290e/" rel="bookmark">
			3296电位器调节工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		3296电位器是一种常用可调电阻，对于电路参数调整很方便。
具体尺寸图在厂家网站上可以很方便找到。
一般使用一字改锥调节，但是改锥尺寸大了会很难调节，小了会容易滑脱，在带电操作时会有一定的危险，因为改锥头是金属的，容易导致短路。
在网上搜索发现，有人用圆珠笔芯的塑料杆部分加电阻腿，做成一个中间有一字对电位器调节，周围是个圆柱固定对准调节螺钉的工具。手边找了几个圆珠笔芯，比划了一下，塑料杆内径太细，丢。看到签字笔，取出笔芯，正合适，找了一个1/8w电阻腿，能放到电位器调节钮豁口上，零件准备完毕。笔芯用尖镊子扎了一个通孔，电阻腿穿入，两边挝个弯，避免滑脱，到电位器一试，好，完活。
调节螺帽为什么不做成十字的呢，那样就不容易滑脱了。
另外，cdsn的草稿箱难找，编辑器贴图昨天不行，今天就行了，奇怪不？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12284259a2181eab32c50a5866922951/" rel="bookmark">
			云顶之奕 辅助 高亮显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		云顶之奕 辅助 高亮显示 一、前言二、环境设置三、卡牌识别3.1 候选框截取3.2 ocr识别 四、高亮显示参考资料 一、前言 本文提供一个简易的demo，用于对目标阵容的高亮显示，避免猪脑过载或慢速思考。基本流程由两部分组成，一是使用tesseract识别出卡牌池的名字列表，与目标阵容进行比较，得到需要的卡牌坐标；二是基于上述坐标，对卡牌高亮
二、环境设置 博主是在windows上运行，搭配Pycharm使用，使用该教程需要进行以下设置：
将英雄联盟客户端语言设置为英文游戏内设置分辨率为1920*1080，无边框模式windows桌面，右键-&gt;显示设置-&gt;缩放与布局-&gt;更改文本、应用等项目的大小-&gt;100%安装tesseract，并配置到系统环境变量以管理员身份运行pycharm 三、卡牌识别 3.1 候选框截取 import pyscreenshot # Screenshot tool, PIL friendly from ocr import get_text_from_image from pynput import keyboard def takeScreenshotROI(coordinates): # Take a screenshot of the champion zone only return pyscreenshot.grab(coordinates) def get_champions(): width, height = (1920, 1080) left, top, right, bottom = (int(width * 0.25), int(height * 0.96), int(width * 0.77), int(height * 0.99)) _width = (right-left)/5 champions_list = [] for idx in range(5): coordinates = (int(left + idx*_width)+10, top, int(left + (idx+1)*_width)-55, bottom) roi_example = takeScreenshotROI(coordinates) # 用于测试 正式运行时将 以下两行代码 注释 # roi_example = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12284259a2181eab32c50a5866922951/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ec94e34007c281bbc5f494449c7d698/" rel="bookmark">
			java后端-servlet超详细入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java后端介绍 今天我正式开始了一个新话题，那就是 Web。目前我主要会介绍后端。作为后端的老大哥 java，也有很多后端框架，比如大家耳熟能详的 spring 等。今天来带大家入门 servlet，不管是学生，刚毕业或是已经工作自学编程的人群都能看懂。
准备工作 目前我们使用的服务器是 Tomcat，大家可以先安装 Tomcat，这一步网上有很多教程，我不再说了。然后还需要下载 idea，配置 Tomcat 和 jdk，这些网上都有，如果配置遇到问题可以私信我。
Servlet项目创建 大家先用idea 创建 web 项目，创建好后应是这样。
现在在你的 src 目录下创建一个package，并命名为 com.xxxx.servlet。
然后在这个包下面创建一个 java类，名叫 servlet（你也可以自己起名字）
Servlet的基础使用 导入包 package com.xxxx.servlet; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; 主要是导入了 servlet 的基本方法。
创建 java 类，并继承自HttpServlet 类 因为我们后面还要重写 HttpServlet 类中的方法，所以要继承这个类。
public class servlet extends HttpServlet{ } 重写 service 方法 因为我们要处理请求，所以要重写服务类来处理请求，否则处理不了请求。
@Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { } 设置访问路径 @WebServlet("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ec94e34007c281bbc5f494449c7d698/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0009c13caa436d20cc2369754e63ee1/" rel="bookmark">
			阿里云短信接口调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境准备
安装composer并切换到阿里云源
cd到项目根目录
根据阿里云示例安装 composer require alibabacloud/smsintl
直接在api/controller/common源码里引用
use AlibabaCloud\Client\AlibabaCloud; use AlibabaCloud\Client\Exception\ClientException; use AlibabaCloud\Client\Exception\ServerException; public function smsaliyun($mobile,$code){ // 此处填写你的阿里云 key 和 server AlibabaCloud::accessKeyClient('akey', 'skey') -&gt;regionId('cn-hangzhou') -&gt;asDefaultClient(); try { $result = AlibabaCloud::rpc() -&gt;product('Dysmsapi') // -&gt;scheme('https') // https | http -&gt;version('2017-05-25') -&gt;action('SendSms') -&gt;method('POST') -&gt;host('dysmsapi.aliyuncs.com') -&gt;options([ 'query' =&gt; [ 'RegionId' =&gt; "cn-hangzhou", 'PhoneNumbers' =&gt; $req['mobile'], 'SignName' =&gt; "【填写你的短信模板签名】", 'TemplateCode' =&gt; "SMS_199920034【你的短信模板】", // 'TemplateParam' =&gt; "{\"code\":\"123456\"}", 'TemplateParam' =&gt; "{\"code\":\"".$code."\"}", ], ]) -&gt;request(); $this-&gt;success('发送成功', $result-&gt;toArray()); } catch (ClientException $e) { $this-&gt;error('发送失败',$e-&gt;getErrorMessage() .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0009c13caa436d20cc2369754e63ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5760e2dee051f1d5cb94f8a93575ef46/" rel="bookmark">
			HBASE shell 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hbase shell 命令进入 hbase 提供的 shell 工具，help 命令可以查看帮助。
1、查看有哪些表
hbase(main):003:0&gt; list TABLE t1 t2 2 row(s) in 0.0270 seconds =&gt; ["t1", "t2"] 2、创建表
// 表名 stu、列族 info hbase(main):004:0&gt; create 'stu','info' 0 row(s) in 2.9680 seconds =&gt; Hbase::Table - stu 3、插入数据
hbase(main):005:0&gt; put 'stu','1001', 'info:sex','male' 0 row(s) in 0.2210 seconds hbase(main):006:0&gt; put 'stu','1001', 'info:age','18' 0 row(s) in 0.0160 seconds hbase(main):007:0&gt; put 'stu','1002', 'info:name','rose' 0 row(s) in 0.0140 seconds hbase(main):008:0&gt; put 'stu','1002', 'info:sex','female' 0 row(s) in 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5760e2dee051f1d5cb94f8a93575ef46/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350e1a9a5c6a13e4d66cec9a5d9905b0/" rel="bookmark">
			如何利用极狐GitLab 轻松管理NPM依赖发布与更新？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文来自：
任治桐 极狐(GitLab) 前端工程师
NPM 是 Node.js 的包管理工具，用来安装各种 Node.js 的扩展。本文将分享如何通过极狐GitLab，让 NPM 依赖发布更新更加快速和自动化，让你轻松管理依赖，拥有更多时间专注于核心工作！
少年小明之烦恼 在开发团队日常工作中，不可避免的会依赖大量第三方模块；同时，团队内部也会发布一些公共模块到内部或外部源中，方便跨团队复用。但往往会遇到和小明一样的烦恼。
小明同学负责内部公共 NPM 模块发布和升级工作。他每天的工作是这样的：
1. 开发同学通知小明某个公共模块代码有更新；
2. 小明打包内部公共模块；
3. 发布到 NPM 源；
4. 在开发群里通知各个团队升级到最新版本。
渐渐的，每个团队都被繁琐小事缠身，低效：
开发同学需要经常检查依赖的 NPM 模块是否有更新；
公共模块的维护同学更新代码后需要决定是否发布版本；
版本更新后还需要通知各个团队；
各个团队还是容易出现更新不及时、容易遗漏等问题。
终于有一天，小明同学灵机一动：如果以后更新公共模块代码能够根据一定规则，自动更新版本号→自动发布日志→自动发布到 NPM 源→自动将公司内所有依赖该模块的代码库更新为最新版本，岂不乐哉？
经过一番探索，小明发现，通过极狐GitLab CI 和第三方工具结合，就可以达到目的。一起实践吧！
NPM 自动发布-操作指南 我们知道，NPM 包版本规范为 Semantic Versioning ，即为 major.minor.patch 格式数字组成。
那么，如果我们可以识别开发人员的 git commit message ，通过对提交信息进行形式化约定，就可以自动生成新的符合 Semantic Versioning 的版本号。然后，将新版本号更新到我们的 package.json 文件中，最后发布到 NPM 源中即可。
commitlint 首先，我们需要通过 commitlint 或类似工具，强制规范化团队的 git commit message ，通过如下命令将 commitlint 安装到项目中：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350e1a9a5c6a13e4d66cec9a5d9905b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cd8cf5f406e9d5b019dc86f758255cc/" rel="bookmark">
			CAD数据导入到ArcGIS中出现乱码怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中，我们通常会涉及到将甲方提供的CAD数据提取成标准.SHP数据，但是CAD它导入到ArcGIS Desktop中竟然乱码了，标注看不清了，好头大。其实是字符集的问题，将注册表中的字符集改为简体中文就可以解决，下面来看解决方法。
操作步骤： 在windows搜索框中输入“regedit”。
点击“注册表编辑器”，出现“是否允许对你的设备进行修改”，点击“是”。
找到“计算机\HKEY_CURRENT_USER\SOFTWARE\ESRI\Desktop10.2”。
在“Desktop10.2”文件夹里新建一个“Common”项。
在“Common”中新建“CodePage”项。
在“CodePage”中新建“dbfDefault”字符串值。
右键修改。
在数值数据中输入”969“，点击确定。
再次用ArcGIS Desktop 打开，完美解决乱码问题。
下次将更新"如何解决CAD数据导入到ArcGIS中没有坐标的问题”。
关注“GIS小李子”，GISer不迷路
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e36e47e8dfc4d335d4f3193a8bc2aa9e/" rel="bookmark">
			python3.11安装， 解决pip is configured with locations that require TLS/SSL问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：centos7.4（虚拟机）
python版本：本机自带的2.7.5，以及参考python安装的python3.11
pip版本：本机自带的8.1.2，参考pip安装&amp;升级升级到了20.3.4，pip3版本为22.3.1
openssl版本：本机自带的1.0.2k-fips（这里是个坑）
报错原因是，想通过下面的命令下载安装numpy包：
pip3 install numpy 在此之前用pip命令是可以的:
pip install numpy 但pip3一直报错：
pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available. Collecting numpy Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'SSLError("Can't connect to HTTPS URL because the SSL module is not available.")': /simple/numpy/ Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'SSLError("Can't connect to HTTPS URL because the SSL module is not available.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e36e47e8dfc4d335d4f3193a8bc2aa9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07943f3839efed8abc3af2dce391d964/" rel="bookmark">
			qt鼠标事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：qt的鼠标事件包含头文件 &lt;QMouseEvent&gt; 二：qt鼠标事件需要重写虚函数 （1）：鼠标移动事件（需捕捉到鼠标后，才可以打印坐标，在QWidget内点击鼠标后，就可以捕捉到鼠标） void mouseMoveEvent(QMouseEvent *event)； void Widget::mouseMoveEvent(QMouseEvent *event) { QPoint p_ab = event-&gt;globalPos();//相对于整个桌面的位置 QPoint p_re = event-&gt;pos();//相对于Widget窗口内的位置 QString str1, str2; str1 = QString("%1 , %2").arg(p_ab.x()).arg(p_ab.y());//存放相对于整个桌面的x，y坐标 str2 = QString("%1 , %2").arg(event-&gt;x()).arg(event-&gt;y());//存放相对于Widget的x，y坐标 //str2 = QString("%1 , %2").arg(p_re.x()).arg(p_re.y());//存放相对于Widget的x，y坐标，与上面等价 qDebug() &lt;&lt; str1 &lt;&lt; " | " &lt;&lt; str2 &lt;&lt; endl; } （2）：持续捕捉鼠标事件（持续捕捉鼠标事件，不用按下鼠标，只要鼠标在QWidget内移动，就可以捕捉） 鼠标移动事件，只要移动鼠标，就会触发这个函数，其中，正常情况下，只有当鼠标在QWidget界面点击鼠标后，才会捕捉到鼠标的坐标，那如何实现，在不点击鼠标的情况下，也可以捕捉到鼠标移动事件呢？
代码如下：
//QWidget的构造函数 Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) { ui-&gt;setupUi(this); //添加如下代码 this-&gt;setMouseTracking(true);//持续捕捉鼠标事件，不用按下鼠标也可以捕捉到； } （3）：鼠标点击事件（左键点击，右键点击） void mousePressEvent(QMouseEvent *event)； void Widget::mousePressEvent(QMouseEvent *event) { if(event-&gt;button() &amp; Qt::LeftButton) { qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07943f3839efed8abc3af2dce391d964/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56524ba970463a2b043ab2d2bfae268a/" rel="bookmark">
			【CS 143 Compiler 编译原理】Assignment 3：语法分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章主要总结 完成 这次 Assignment 所需 知识和思路的总结
代码地址：https://link.zhihu.com/?target=https%3A//github.com/casual-lab/stanford-cool
Bison 语法 cool.y 文法定义文件总体架构 %{ Prologue %} Bison declarations %% Grammar rules %% Epilogue 注释：/* ... */ 或 // (单行注释)
Prologue 和 Epilogue 分别是 原封不动地 复制到输出代码文件地开头和末尾.
Bison declaration token kind names 终结符名称 Token kind names 就是 终结符 的名称。一个 %token 后可跟随定义 多个 终结符, 用 空格或回车隔开.
%token &lt;tag&gt;? ( id number? string? )+ ( tag ( id number? string? )+ )* number 段是一个 token 间互不冲突的正整数.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56524ba970463a2b043ab2d2bfae268a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad5a29e6f84dadb93d60a69e6f10a2b4/" rel="bookmark">
			【蓝桥杯】历届真题 时间显示（省赛）Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
小蓝要和朋友合作开发一个时间显示的网站。在服务器上，朋友已经获取了当前的时间，用一个整数表示，值为从1970年1月1日O0:00:00到当前时刻经过的毫秒数。
现在，小蓝要在客户端显示出这个时间。小蓝不用显示出年月日，只需要显示出时分秒即可，毫秒也不用显示，直接舍去即可。
给定一个用整数表示的时间，请将这个时间对应的时分秒输出。
【输入格式】
输入一行包含一个整数，表示时间。
【输出格式】
输出时分秒表示的当前时间，格式形如HH:MM:SS，其中HH表示时，值为0到23，MM表示分，值为0到59，SS表示秒，值为0到59。时、分、秒不足两位时补前导0。
【样例输入1】
46800999
【样例输出1】
13:00:00
【样例输入2】
1618708103123
【样例输出2】
01:08:23
【评测用例规模与约定】
【思路与分析】
该题有两种方法可解：1. 使用Java自带的API进行计算、2. 通过计算毫秒数，将范围确定为一天内，并按照题意忽略毫秒位，计算出其所代表的时间。
总体来说此题还是较为简单的，方法一主要体现在对Date类及其实例化、时间的输出格式等方面。
而方法二则较为考察逻辑能力，如何获取到正确的数据范围、如何进行不足位补0的操作，能够有一个明确的思路的话，写代码还是很轻松的。
来吧，展示！
【代码：API】
import java.util.Scanner; import java.sql.Date; import java.text.SimpleDateFormat; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); long time = sc.nextLong(); //减8小时是因为Date以1970-01-01 08:00:00开始，比题目中要求的时间早8个小时 time -= 8 * 60 * 60 * 1000; //格式化输出 System.out.println(new SimpleDateFormat("HH:mm:ss").format(new Date(time))); } } 【代码：计算】
import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad5a29e6f84dadb93d60a69e6f10a2b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f7e3b2339955c2ba506e1d4d3b5ea01/" rel="bookmark">
			SQL查询重复数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查找表中多余的重复记录，重复记录是根据单个字段（Id）来判断
select * from 表名称 where Id in (select 字段名 from 表名称 group by 字段名 having count(字段名) &gt; 1)
2、查找表中多余的重复记录（多个字段）
select * from 表名称 a where (a.字段名,a.字段名) in (select 字段名,字段名 from 表名称 group by 字段名,字段名 having count(*) &gt; 1)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/febf7dd451551122912616bb49b4f042/" rel="bookmark">
			RocketMQ源码(十三)—消费者DefaultMQPushConsumer启动主要流程源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此前我们学习了Broker和Producer的启动源码，以及Producer发送消息源码和Broker接收存储消息的源码，现在，我们来学习Consumer的启动以及消费消息的源码。Consumer的启动源码和Producer的启动源码还是有很多相似的地方的。
目录
1 创建DefaultMQPushConsumer实例 2 subscribe订阅
3 start启动消费者
3.1 copySubscription拷贝订阅关系
4 小结
客户端常用的消费者类是DefaultMQPushConsumer，此类的简单消费者案例如下，在RocketMQ源码的example模块下 找到更多快速案例。
消费者代码举例：
public class Consumer { public static void main(String[] args) throws InterruptedException, MQClientException { // 实例化消费者 DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("c1-group"); // 设置NameServer的地址 consumer.setNamesrvAddr("127.0.0.1:9876"); //TODO:订阅一个或者多个Topic，以及Tag来过滤需要消费的消息 consumer.subscribe("test_topic", "*"); // TODO: 注册消息监听器，用来消费消息 consumer.registerMessageListener(new MessageListenerConcurrently() { @Override public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) { try { System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs); boolean consume = new Random().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/febf7dd451551122912616bb49b4f042/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc679ea5a4822049506d0aee33890803/" rel="bookmark">
			CentOS 7 下 MongoDB 分片副本集群日志切割测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7 下 MongoDB 分片副本集群日志切割测试 文章目录 CentOS 7 下 MongoDB 分片副本集群日志切割测试测试说明环境搭建测试方案处理 config 服务日志处理 shard 服务日志处理 mongos 服务日志 测试结果参考 测试说明 # 操作系统 - CentOS 7.9 2009 # MongoDB 版本 - v3.4.24 # 测试方法 - kill -SIGUSR1 ${port} # 测试服务 - mongodb config - mongodb shard - mongodb mongos 环境搭建 10.10.200.20510.10.200.20610.10.200.207configconfigconfigshard1shard1shard1shard2shard2shard2shard3shard3shard3mongosmongosmongos 测试方案 处理 config 服务日志 查看 config 服务日志 [root@node2 log]# tail -2 config.log 2023-01-16T10:17:44.205+0800 I NETWORK [conn913] received client metadata from 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc679ea5a4822049506d0aee33890803/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c167e74b6911c17438b86af49129284/" rel="bookmark">
			git-git abandon之后内容提交的步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 abandon用到次数比较少，后续步骤容易忘记记录一下
通过Gerrit进行abandon（本地是commit状态）git log（确认记录）撤销commit
git reset --soft HEAD^撤销add
git reset .
接下来正常修改提交就可以了
目前我只知道这个方法，有其他更简便方法可以教我一下 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2661aa4d19ec1c3277c08ff1647386/" rel="bookmark">
			Linux 系统启动过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux 系统启动过程 linux启动时我们会看到许多启动信息。
Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：
内核的引导。运行 init。系统初始化。建立终端 。用户登录系统。 init程序的类型：
SysV: init, CentOS 5之前, 配置文件： /etc/inittab。Upstart: init,CentOS 6, 配置文件： /etc/inittab, /etc/init/*.conf。Systemd： systemd, CentOS 7,配置文件： /usr/lib/systemd/system、 /etc/systemd/system。 内核引导 当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。
操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。
运行init init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。
init 程序首先是需要读取配置文件 /etc/inittab。
运行级别 许多程序需要开机启动。它们在Windows叫做"服务"（service），在Linux就叫做"守护进程"（daemon）。
init进程的一大任务，就是去运行这些开机启动的程序。
但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。
Linux允许为不同的场合，分配不同的开机启动程序，这就叫做"运行级别"（runlevel）。也就是说，启动时根据"运行级别"，确定要运行哪些程序。
Linux系统有7个运行级别(runlevel)：
运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录运行级别2：多用户状态(没有NFS)运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式运行级别4：系统未使用，保留运行级别5：X11控制台，登录后进入图形GUI模式运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 系统初始化 在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。
它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。
l5:5:wait:/etc/rc.d/rc 5 这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。
而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。
/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。
而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。
这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。
至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的"System Services"来自行设定。
建立终端 rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。
init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：
1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 3:2345:respawn:/sbin/mingetty tty3 4:2345:respawn:/sbin/mingetty tty4 5:2345:respawn:/sbin/mingetty tty5 6:2345:respawn:/sbin/mingetty tty6 从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e2661aa4d19ec1c3277c08ff1647386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf7d242e943a8d94150bea6de28892c1/" rel="bookmark">
			【微信小程序入门到精通】— 事件绑定的详细解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、事件绑定导论二、常用事件三、事件对象属性列表3.1 target 和 currentTarget 的区别3.2 bindtap 的用法 总结 前言 对于目前形式，微信小程序是一个热门，那么我们该如何去学习并且掌握之后去做实际项目呢？
为此我特意开设此专栏，在我学习的同时也将其分享给大家！
这一篇文章我们就涉及到事件绑定问题了，也就是我们小程序最重要的用户交互问题，我们是如何接收用户触发的信息并且处理的呢？这一篇文章将告诉你答案！
如果在往下阅读的过程中，有什么错误的地方，期待大家的指点！
一、事件绑定导论 事件是渲染层到逻辑层的通讯方式，通过事件我们可以将用户在界面的操作反馈到逻辑层进行处理。
过程如下图所示：
其基本过程就是在 .wxml 里面设置事件，然后在 .js 里面构建处理函数。
二、常用事件 大家肯定很关注我们到底在平时使用微信小程序时都要用到哪些事件，那么接下来我给大家列举一下。
类型绑定方式事件描述tapbindtap 或 bind：tap手的点击动作（触摸后离开，类似于HTML中的 click 事件）inputbindinput 或 bind：input文本框的输入事件changebindchange 或 bind：change状态改变触发事件 tap 事件非常常用，因为在我们微信小程序中，点击这一用户操作是必然发生的，我们绝大部分需要处理的也是点击事件。
三、事件对象属性列表 当我们的事件触发后进行回调时，会收到一个事件对象 event，接下来我们详细介绍一下它的属性。
老规矩我们先通过表格了解一下 event 到底有哪些属性！
属性类型说明typestring事件类型timestampinteger页面打开到事件触发所用时间（毫秒）targetobject触发事件组件的一些属性值集合currentTargetobject当前组件的一些属性值集合detailobject其他的细节信息touchesarray触摸事件，当前停留在屏幕中触点信息的数组changedTouchesarray触摸事件，当前变化的触点信息的数组 type 属性值的作用就是返回我们事件的类型，如果是我们前面的 tap事件，那么我们 event.type 返回的就是 taptimestamp 就是记录事件触发前后的时间间隔target 属性值就非常常用了，event.target 就是展示触发事件的属性值currentTarget 和上面的 target 形成对比，currentTarget 是对于当前组件的属性值的展示，而 target 则是对于最开始触发事件的属性值展示（后面我们具体例子讲解）detail 可以让当前触发的事件的额外信息可以通过 event.detail 获取touches 获取当前屏幕上手指的触摸信息changedTouches 获取变化的触摸点信息 3.1 target 和 currentTarget 的区别 前面咱们提到 target 的时候，说到这俩属性值有相似但是有实质性区别，那么他们到底有什么不同呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf7d242e943a8d94150bea6de28892c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7d3309731632c52578c2f1e453fa054/" rel="bookmark">
			win10自动开启移动热点脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、同时按win + R，弹出运行窗口，在运行窗口里输入：shell:startup，点确定。
2、打开一个文件夹之后，新建一个记事本文件，写入下面的代码，并保存。
powershell -ExecutionPolicy Bypass "$connectionProfile = [Windows.Networking.Connectivity.NetworkInformation,Windows.Networking.Connectivity,ContentType=WindowsRuntime]::GetInternetConnectionProfile(); $tetheringManager = [Windows.Networking.NetworkOperators.NetworkOperatorTetheringManager,Windows.Networking.NetworkOperators,ContentType=WindowsRuntime]::CreateFromConnectionProfile($connectionProfile); $tetheringManager.StartTetheringAsync();" 3、将记事本文件名更改成：wifi.bat，注意后面是bat的格式，而不是txt。
4、完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc74e15c7002fb1987dbed16a4172f6/" rel="bookmark">
			【复现笔记】SRT3D: Sparse Region-Based 3D Object Tracking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		paper: SRT3D: A Sparse Region-Based 3D Object Tracking Approach for the Real World
Manuel Stoiber, Martin Pfanne, Klaus H. Strobl, Rudolph Triebel, and Alin Albu-Schäffer
International Journal of Computer Vision (IJCV) 2022
作者提供源代码：3DObjectTracking/SRT3D at master · DLR-RM/3DObjectTracking · GitHub
目录
目录
Description of Content
USAGE
开始复现
1、cmake
2、build
Description of Content This repository contains everything necessary to reproduce the results presented in our paper. This includes the evaluation on the RBOT and OPT datasets as well as the conducted parameters study.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc74e15c7002fb1987dbed16a4172f6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/182/">«</a>
	<span class="pagination__item pagination__item--current">183/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/184/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>