<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223875527bbe8c24db3b1a129ff43c0e/" rel="bookmark">
			JSP 总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、页面乱码问题2、注释、表达式、注意事项3、错误调试方法4、登录注册界面点击按钮无法获取值在界面显示5、request.setAttribute()后，在action中为什么取不到值？6、request.getRequestDispatcher(“login_success.jsp“).forward(request,response)7、跳转页面的三种方式8、request 内置对象9、GET 与 POST 的区别10、小项目【实现登录界面】11、知识总结12、身份证、抽奖、简单地登录流程13、更改cookie的过期时间14、页面实现自动跳转15、meta标签之详解 原创不易，只想要一个赞，感谢！
1、页面乱码问题 链接：https://blog.csdn.net/qq_26748397/article/details/77943034
我正在初学JSP，我犯了第一个错误，再次登记一下！
原因： JSP中默认使用iso-8859-1字符编码方式，而它不支持中文，所以一旦我们的代码有中文，就会出现乱码
应将其改为：UTF-8，如图所示：
也就是我们熟称的“万国码”！改成这个之后，写入中文代码就不会再出现乱码了！
2、注释、表达式、注意事项 在JSP中实现注释的方式有如下三种：
HTML 注释：&lt;!–HTML 注释 -&gt;还漏写了一个杠，注意。
JSP 注释：&lt;%–JSP 注释 --%&gt;
JSP 脚本注释：&lt;%//JSP 单行注释 %&gt;、&lt;%/*JSP 多行注释 */%&gt;
表达式：
使用out 对象输出信息时，需要在HTML 标签中进行嵌套，页面会显得混乱。JSP 还提供了另外一种输出显示的方式，就是借助表达式实现输出显示。表达式的语法如下：
&lt;%=Java 表达式%&gt;
tip：&lt;%=title %&gt;
注意：使用表达式进行输出时，在表达式的结尾处不能添加分号来表示结束，否则JSP 会提示错误。
3、错误调试方法 4、登录注册界面点击按钮无法获取值在界面显示 之前，老是遇到一个问题，比如我在一个登录界面，如图：
注册界面：
之后就跳转到这个错误的界面：
那么造成这样的问题，大部分的原因都是因为，找不到正确的网址！那么造成这种原因，只有可能是因为以下几点原因：
一丶
二丶
每次写完代码后，记得要先保存，然后再关闭服务器，再点击打开，重新运行下注册界面，点击提交，就不会再出现这样的错误了，因为服务器还需要重新在编译一次jsp代码，否则就跟没改过代码一样！
三丶
5、request.setAttribute()后，在action中为什么取不到值？ 看网上有两种说法：
一丶：
不能这么请求。
因为页面上的request 和使用form提交的request 请求 不是一个对象。
二丶：
request 只在当前页面有效
正确写法应该是放在form里
&lt;form action="WebPay.do" name="webPayForm" onsubmit="return _validation( this )"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/223875527bbe8c24db3b1a129ff43c0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3480b4826ee2b5e22b72c8190fd61628/" rel="bookmark">
			【微信小程序】-- 全局配置 -- window - 导航栏（十五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		💌 所属专栏：【微信小程序开发教程】 😀 作 者：我是夜阑的狗🐶 🚀 个人简介：一个正在努力学技术的CV工程师，专注基础和实战分享 ，欢迎咨询！
💖 欢迎大家：这里是CSDN，我总结知识的地方，喜欢的话请三连，有问题请私信 😘 😘 😘
文章目录 前言一、全局配置1、全局配置文件及常用的配置项 二、window1、小程序窗口的组成部分2、window 节点常用的配置项3、设置导航栏的标题4、设置导航栏的背景色5、设置导航栏的标题颜色 总结 前言 大家好，又见面了，我是夜阑的狗🐶，本文是专栏【微信小程序开发教程】专栏的第15篇文章;
今天开始学习微信小程序的第九天💖💖💖，开启新的征程，记录最美好的时刻🎉，每天进步一点点。
专栏地址：【微信小程序开发教程】， 此专栏是我是夜阑的狗微信小程序开发过程的总结，希望能够加深自己的印象，以及帮助到其他的小伙伴😉😉。
如果文章有什么需要改进的地方还请大佬不吝赐教👏👏。
一、全局配置 前面已经介绍了WXSS模板语法-全局样式和局部样式，通过栗子学习了WXSS模板语法样式之间的覆盖。接下来就来讲解一下小程序的全局配置。话不多说，让我们原文再续，书接上回吧。
1、全局配置文件及常用的配置项 &amp;ems; 小程序根目录下的 app.json 文件是小程序的全局配置文件，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。常用的配置项如下：
配置项说明pages记录当前小程序所有页面的存放路径window全局设置小程序窗口的外观tabBar设置小程序底部的 tabBar 效果style是否启用新版的组件样式 &amp;ems; 前面已经学习过了pages和style属性，现在就来学习另外两个重要属性：window、tabBar。
二、window 用于设置小程序的状态栏、导航条、标题、窗口背景色。
1、小程序窗口的组成部分 小程序窗口一般由导航栏区域和页面主体区域组成，如下图所示，1 部分表示为导航栏区域，2 部分表示为页面的主体区域，用来显示wxml中的布局，1 和 2 之间还有一个背景区域，默认不可见，只有下拉才能显示。
window配置项只能对导航栏和背景区域进行配置，不能对页面的主体区域进行配置。
2、window 节点常用的配置项 根据 window 节点配置项的作用，可以对 window 中的属性进行分类：
第一类、配置导航栏相关样式，以 navigation 开头；第二类、配置窗口背景相关样式，以 background 开头；第三类、控制页面效果； 常用配置项如下表所示：
属性名类型默认值说明navigationBarTitleTextString字符串导航栏标题文字内容navigationBarBackgroundColorHexColor#000000导航栏背景颜色，如 #000000navigationBarTextStyleStringwhite导航栏标题颜色，仅支持 black / whitebackgroundColorHexColor#ffffff窗口的背景色backgroundTextStyleStringdark下拉 loading 的样式，仅支持 dark / lightenablePullDownRefreshBooleanfalse是否全局开启下拉刷新onReachBottomDistance Number50页面上拉触底事件触发时距页面底部距离，单位为px 3、设置导航栏的标题 刚创建微信小程序的时候，导航栏上的标题都是默认为 WeChat。现在要将默认标题修改为 我是夜阑的狗 ，具体操作为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3480b4826ee2b5e22b72c8190fd61628/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8bc3846718b47bdc6f248ec1f6401ca/" rel="bookmark">
			强迫症福音，让tinyMediaManager来成为你NAS影音库的贴身管家
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 相信任何一个影音爱好者都会希望拥有一个属于自己的影音库。
在配置了一套群晖NAS之后，我便马不停蹄的开始将我各处搜刮来的影视资源统统迁移到NAS上，想要通过NAS构建一套家庭影视资源库，可以提供电视、手机、IPAD等设备连接观看。首当其冲的一个问题，搜刮来的影视文件文件名琳琅满目，要如何能让他们被Kodi、Jellyfin或者群晖自带的Video Station等软件准确的识别出来然后生成一个漂亮的海报墙呢？
我使用的方案是通过tinyMediaManager来管理整理本地影视库，削刮到的影视信息保留在本地，并且文件都按照规范的命名来重命名保存，然后各个应用平台直接读取本地的电影信息使用。
这个方案有两个优点，
井井有条的本地化文件管理
tinyMediaManager可以将你的视频文件按照削刮来的信息重新命名，创建或者重命名你的电影文件夹，并将削刮的元数据保留到对应的文件夹，在寻找电影的时候可以让你体会到满满的舒适感； 一劳永逸的多平台设置
Kodi、Jellyfin、Video Station可以直接使用我本地的元数据，或者通过规范的命名削刮影视信息，少去了削刮器的设置操作，也省去了电影文件命名不规范要手动识别的情况，因为这些操作都已经由tinyMediaManager完成了！ 接下来和大家一起分享我这个方案的安装过程。
安装过程 在docker共享文件夹下新建一个tinymediamanager的文件夹，并且在该目录下创建data、addons两个子文件夹。
打开Docker 注册表搜索 tinyMediaManager，下载映像tinyMediaManager/tinyMediaManager。
这是官方版本的tinyMediaManager，目前版本是v4.3.8.1，已经适配中文，并且免费版没有削刮电影数量的限制。
在这里插入图片描述
启动下载好的映像，使用已选择的网络，
点击高级设置，
修改环境变量，
USER_ID = 0 GROUP_ID = 0 #获取root权限 PASSWORD = mima #可自行设定，不可为空，打开tinyMediaManager的密码 设置一个本地端口，
添加文件夹存储空间映射，
设置存储好映射，
/docker/tinymediamanager/data →/data
/docker/tinymediamanager/addons → /app/addons
/video → /media
video是你NAS上面存放电影剧集的文件夹，请自行替换成你NAS上的文件夹，
保存，完成，然后tinyMediaManager容器就开始运行了。
接下来打开输入网页你的 NAS的IP地址：端口号 来进入tinyMediaManager，点击Connect，输入在环境中设置好的密码。
进入tinyMediaManager界面之后，点击Setting，进去修改语言为中文，然后退出设置，点击主界面右上角的X，软件会自动开始重启，
重启之后就可以看到语言已经成功修改成中文，这时候可以继续点击设置，一一设置你的电影媒体库、电视剧媒体库。
到这里安装部分已经告一段落，软件已经可以正常更新数据源，削刮电影电视剧，但是因为themoviedb网址DNS已经被严重污染，所以我们还需要修改一下host，tinyMediaManager才能够成功搜索下载到电影信息。
首先通过 https://ping.chinaz.com 来获取 themoviedb 的可用IP地址，分别需要获取以下四个网址的可用ip地址，
www.themoviedb.org
image.tmdb.org
api.themoviedb.org
api.thetvdb.org
打开容器tinymediamanger详情，新增终端机，
在终端机中输入:
apt-get update
运行代码之后在输入：
apt-get install vim
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8bc3846718b47bdc6f248ec1f6401ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f7c2c57f9a95bbff517f293d81221e/" rel="bookmark">
			Watch 在 vue 3 中使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、监听基础类型 const nums = ref(9) watch(nums, (newValue, oldValue) =&gt; { console.log('watch 已触发', newValue) }) 二、监听复杂类型 const demo = reactive({ name: '前端小玖', nickName: '小玖', soulmate: { name: '', nickName: '' } }) 复杂类型的监听有很多种情况，具体的内容如下
监听整个对象
watch(demo, (newValue, oldValue) =&gt; { console.log('watch 已触发', newValue) }) 其第一个参数是直接传入要监听的对象。当监听整个对象时，只要这个对象有任何修改，那么就会触发 watch 方法。无论是其子属性变更（如 demo.name），还是孙属性变更（如 demo.soulmate.name）…，都是会触发 watch 方法的。
监听对象中的某个属性 // 监听demo对象的name属性
watch(() =&gt; demo.name, (newValue, oldValue) =&gt; { console.log('watch 已触发', newValue) }) 如上代码，监听 demo 对象的 name 属性，那么只有当 demo 对象的 name 属性发生变更时，才会触发 watch 方法，其他属性变更不会触发 watch 方法。注意，此时的第一个参数是一个箭头函数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8f7c2c57f9a95bbff517f293d81221e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9a3c2698e1e8401061a900fc7a5443/" rel="bookmark">
			Xorg，X11，Wayland？Linux显示服务器和协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：https://www.linuxmi.com/xorg-x11-wayland-linux.html
2021年3月15日
您是否想知道X Server，Xorg，X11，Wayland以及诸如此类的东西到底是什么？Wayland vs Xorg，哪个更好？本指南就为你详细讲解。
您总是会遇到这些术语，并且知道它们与图形有关，但您可能想更深入了解它们。
Linux中的显示服务器是什么？
显示服务器是一个程序，其主要任务是协调客户端与其他操作系统，硬件以及彼此之间的输入和输出。显示服务器通过显示服务器协议与其客户端进行通信。
显示服务器是任何图形用户界面（尤其是窗口系统）中的关键组件。它是图形用户界面（GUI）的基本组件，位于图形界面和内核之间。因此，借助显示服务器，您可以将计算机与GUI一起使用。没有它，您将只能使用命令行界面。
不要将显示服务器与桌面环境混淆是非常重要的。桌面环境(Gnome、KDE、Xfce、MATE等)使用了底层的显示服务器。
比如：Ubuntu 21.04现在默认启用Wayland https://www.linuxmi.com/ubuntu-21-04-linux-5-10-lts-wayland.html
显示服务器通过显示服务器协议与其客户端进行通信。Linux中提供了三种显示服务器协议。X11和Wayland是其中两个。第三个Mir超出了本文的范围。
X Window System, X.Org, X11介绍
X Window System（通常仅称为X或X11）确实很古老。它最初起源于1984年，最终成为大多数类似UNIX的操作系统（包括Linux）的默认窗口系统。
X.Org服务器是X.Org基金会管理的X Window System显示服务器的免费开放源代码实现。它是一个通过X11协议与客户端应用程序进行交互的应用程序，用于在显示器上绘制内容并发送输入事件，例如鼠标移动，单击和击键。通常，将启动一个X服务器，它将等待客户端应用程序连接到它。Xorg基于客户端/服务器模型，因此允许客户端在另一台计算机上本地或远程运行。
在X11的设计中，应用程序和显示器不必在同一台计算机上，这一点并不明显。在开发X时，X server运行在工作站上，而用户在具有更强处理能力的远程计算机上运行应用程序是很常见的。
X11 是网络协议。它描述了如何在客户端（应用程序）和显示器（服务器）之间交换消息。这些消息通常带有原始的绘制命令，例如“绘制框”，“在此位置写这些字符”，“已单击鼠标左键”等。
但是X11已经很古老了，X server协议提供的大部分功能不再使用。X11所做的几乎所有工作都重新分配给了各个应用程序和窗口管理器。然而，所有这些旧特性仍然存在，给所有这些应用程序带来了压力，损害了性能和安全性。
下一代显示服务器Wayland
Wayland 由X.Org开发人员Kristian Hogsberg于2008年作为个人项目开始。它是一种通信协议 ，用于指定显示服务器与其客户端之间的通信。Wayland是作为一个免费的开源社区驱动的项目而开发的，目的是用现代，安全和简单的窗口系统代替X Window System（也称为X11或Xorg）。
在Wayland中，合成器是显示服务器。Compositor是一个窗口管理器，它为应用程序提供每个窗口的屏幕外缓冲区。窗口管理器将窗口缓冲区合成为代表屏幕的图像，并将结果写入显示内存。
Wayland协议允许合成器将输入事件直接发送到客户端，并让客户端将损坏事件直接发送到合成器。
与X情况一样，客户端在接收到事件时会作为响应更新用户界面（UI）。但是，在Wayland中，渲染发生在客户端中，并且客户端只是向合成器发送请求以指示已更新的区域。
Wayland与X相比的主要优势在于它是从头开始的。X的复杂性的主要原因之一是，多年来，它的作用已经改变。结果，今天，X11很大程度上充当了客户端和窗口管理器之间的“一个非常糟糕的”通信协议。
Wayland在安全性方面也很出色。使用X11，可以通过允许任何程序在后台存在并读取X11区域中打开的其他窗口所发生的事情来执行称为“键盘记录”的操作。使用Wayland，这根本不会发生，因为每个程序都是独立工作的。
总结
但是，与Wayland相比，X Window System仍具有许多优势。即使Wayland消除了Xorg的大多数设计缺陷，它也有其自身的问题。即使Wayland项目已经进行了十多年，事情还是不是100％稳定的。截至2020年，大多数用于Linux的视频游戏和图形密集型应用程序仍为X11编写。另外，许多封闭源代码的图形驱动程序，例如NVIDIA GPU的驱动程序，都尚未完全提供对Wayland的支持。
X不能持久，Wayland在许多方面都可以改善。但是到目前为止，现有的绝大多数本机应用程序都是为Xorg编写的。在移植所有这些应用程序之前，需要维护Xorg。与Xorg相比，Wayland还不是很稳定。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b57772df577e40e47df513c6349135/" rel="bookmark">
			Set-Cookie:SameSite=Lax 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 springboot 添加配置类去解决：
import org.springframework.boot.autoconfigure.session.DefaultCookieSerializerCustomizer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.session.MapSessionRepository; import org.springframework.session.SessionRepository; import org.springframework.session.config.annotation.web.http.EnableSpringHttpSession; import org.springframework.session.web.http.DefaultCookieSerializer; import java.util.concurrent.ConcurrentHashMap; @Configuration @EnableSpringHttpSession public class SessionConfig { @Bean public SessionRepository sessionRepository() { return new MapSessionRepository(new ConcurrentHashMap&lt;&gt;()); } @Bean DefaultCookieSerializerCustomizer cookieSerializerCustomizer() { return new DefaultCookieSerializerCustomizer() { @Override public void customize(DefaultCookieSerializer cookieSerializer) { cookieSerializer.setSameSite("None"); cookieSerializer.setUseSecureCookie(true); } }; } } 导入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-core&lt;/artifactId&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d714f81994dbff0ed17d790bda41283/" rel="bookmark">
			【DR_CAN-MPC学习笔记】3&amp;4.详细的MPC建模例子和matlab代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇博客：【DR_CAN-MPC学习笔记】2.最优化数学建模推导
参照二次规划一般形式，详细推导了MPC的数学模型，即最小化代价函数的表达式，最终推导结果为：
DR_CAN的视频：
【MPC模型预测控制器】3_一个详细的建模例子
【MPC模型预测控制器】3
【MPC模型预测控制器】4_完整案例讲解 - Octave代码
【MPC模型预测控制器】4
离散系统状态空间一般形式： 其中 为状态向量（n×1）， 为输入向量（p×1）， 为系统状态矩阵（n×n）， 为系统输入矩阵（n×p）。
单输入二阶系统的例子： 上式中，，，n = 2，p = 1
系统状态向量和输入向量的关系： 表示在k时刻预测 k＋1 时刻的系统状态。由于 由 决定，因此不需要 ，所以 比 少一个维度。因为初始值 和 均为 n×1 向量，因此 为 (N+1)n×1 向量。同理可推出 为 Np×1 向量。 为 (N+1)n×n 矩阵。 矩阵上面所有的 0 与初始状态 有关（n×1矩阵）， 均为 n×p 矩阵，因此 为 (N+1)n×Np 矩阵。 具体可参考上一篇博客的推导（【DR_CAN-MPC学习笔记】2.最优化数学建模推导）：
分析过程： 回到单输入二阶系统的例子，，，n = 2，p = 1，假设预测区间 N=3 ，
整理一下维度：
=+(N+1)n×1=(N+1)n×nn×1+(N+1)n×NpNp×18×1=8×22×1+8×33×1 对于系统输出方程： ，参考值 ，误差 ，代价函数为：
代价函数 = 误差加权和 + 输入加权和 + 终端误差，其中 和 为权重系数矩阵且均为对角矩阵。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d714f81994dbff0ed17d790bda41283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d49624945c52ee4fcc9a1bcbf23c1af6/" rel="bookmark">
			服务器被攻击进黑洞了怎么快速解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海外防御服务器是采用防火墙，能够对网络攻击采取积极的预防措施的技术。一旦发现服务器被攻击进入黑洞，可以用下列步骤进行快速解决：
1. 首先回复默认设置，并重启服务器；
2. 确认攻击源地址，并封禁它；
3. 检查防火墙设置，添加嗅探和DDOS攻击检测模块；
4. 检查服务器安全状况，更新已知的漏洞程序和系统；
5. 根据攻击来源建立严格的安全策略，以防止再次进入黑洞；
6. 定期监控服务器状态，及时发现安全漏洞，做出必要的调整。
举个例子：
学校的防御服务器因为抗击攻击频繁，被攻击拉入了黑洞，管理者及时采取上述步骤快速解决了问题，确保了服务器的安全性。但后续也要加强服务器的安全策略，以防止再次发生类似情况。
如果服务器被攻击进入黑洞，首先要采取入侵检测措施来确认来源并限制访问。此外，要检查服务器的网络安全性，并采取相应的固有保护措施。安装安全防御系统，如防火墙、反恶意软件等，能够有效地防止外部攻击。此外，提供海外防御服务来对服务器进行安全保护，可以有效地防止服务器被网络攻击，以保护贵公司的IT资源不被窃取或被损坏。
以上就是海外防御服务的一般做法。举个例子，比如新加坡的DDoS云防御服务，可提供多层防御，抵御不断增加的恶意和存在攻击，防止任何流量以正常模式访问，检测潜在的外部威胁，并了解服务器上的当前活动状态。来自用户设备的恶意流量，将被转发到DDoS服务提供商的专业平台上分析，可以在客户端服务器上建立安全可靠的防护环境。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26aae5a40e26207ff67452781b54b784/" rel="bookmark">
			服务器使用windows server 2008修改密码步骤教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、进入服务器后右击计算机，点击管理，进入服务器管理器
2、在服务器管理器里面双击配置（打开下一列）-双击本地用户和组（打开下一列）-点击用户
3、右击Administrator-点击设置密码
4、弹出下列对话框（为Administrator设置密码）后直接点击继续即可
5、输入密码-点击确定即可（注意：密码设置尽量能复杂些，如字母+数字+符号组合，过于简单的密码可能设置会失败）
6、出现系统提示密码已设置即为完成密码修改操作，点击确定即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93910ba2fc5eef16d742fdafc94e9298/" rel="bookmark">
			a-table 表格中的编辑修改交互
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求
右侧的编辑/新增/删除+input框/√/×的交互都在子组件中，真正的接口调用在父组件中
因为是列表，涉及子组件的复用，所以交互在子组件中进行
点击右侧新增时，列表没有展开时，需要展开并新增节点，展开时则新增节点
采用a-table的API（:expandedRowKeys=“tableExpandedRowKeys” @expand=“onTableExpand”）
// table的展开收起事件 onTableExpand(expanded, record) { if (expanded) { this.tableExpandedRowKeys.push(record.key) } else { this.tableExpandedRowKeys.splice(this.tableExpandedRowKeys.indexOf(record.key), 1) } }, 列表展示，当有子选项时需要有可以点击展示子节点的icon
采用a-table的API（:expandIcon=“expandIcon”）进行自定义icon
// 修改列表展开的icon expandIcon(props) { if (props.record.children &amp;&amp; props.record.children.length &gt; 0) { const list = props.record.children.filter((item) =&gt; item.isShow) // 判断是否有子节点 if (list.length === 0) { return &lt;span style={{ 'margin-right': '19px' }}&gt;&lt;/span&gt; } if (props.expanded) { return ( &lt;span className="table-icon" onClick={(e) =&gt; { props.onExpand(props.record, e) }} &gt; &lt;a-icon type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93910ba2fc5eef16d742fdafc94e9298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769637457ae73e6184c746442378374b/" rel="bookmark">
			ant-design中a-table中文字字数过长时显示tooltip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求
a-table表格中文字字数过长时，需要…显示
文字过长时，可以截取字数进行…展示，但是会存在中文和英文长度不一致的问题，所以采用css的方式截取显示…
&lt;span v-if="!isShowHover" class="text-ellipsis"&gt; {{ value }} &lt;/span&gt; // 样式部分 .text-ellipsis { max-width: 200px; // 控制最大长度 display: block; white-space: nowrap; text-overflow: ellipsis; overflow: hidden; } 字数过长的时候，不需要显示a-tooltip
采用隐藏的span标签，计算完整显示字数时，所需的高度，当高度大于1行时候用js的方式进行判断是否显示
&lt;!-- 隐藏的span标签 --&gt; &lt;span :ref="`text${id}`" class="disNone"&gt;{{ value }}&lt;/span&gt; // 使用 getComputedStyle 方法，获取高度， val 为显示几行 getStyle(val) { const lineHeight = getComputedStyle(this.$refs[`text${this.id}${this.type}`]).lineHeight.replace('px', '') - 0 || 20 const height = getComputedStyle(this.$refs[`text${this.id}`]).height.replace('px', '') - 0 if (height &gt; lineHeight * val) { this.isShowHover = true // 需要显示tooltip } else { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/769637457ae73e6184c746442378374b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c449458f85ada00740321a502aa65e6/" rel="bookmark">
			海外服务器跟防御
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		海外防御服务器是一种网络安全基础架构，实现网络保护、安全及服务稳定性的基本需求。在涉及大量数据流量的环境尤其重要。目前，绝大多数的网络设置均需要对流量进行监控和防御，特别是针对Internet跨境流量而言，更需要多起一些保护措施，这些措施通常放置在海外防御服务器上。
为此，全球许多组织和企业都在采用海外防御服务器来完善其系统安全风险。例如，美国陆军与FireEye公司合作设计了一种新型的基于虚拟硬件平台的海外防御服务器，这种服务器可以提供敏捷的网络保护，让重要的政府信息可以得到安全的保护。同时，该服务器还能够检测网络里的威胁，帮助机构们及时应对任何威胁。
此外，海外防御服务器还可以提供正确的认证服务，防止未经授权的用户获取数据，可以确保信息安全。全球最大的搜索引擎公司——谷歌也采用了海外防御服务器，可靠的服务器加密网络并执行来自不同国家的用户请求。
因此，海外防御服务器在安全防护和访问控制均受到广泛认可，帮助组织及企业应对潜在的安全威胁，更好地保护信息安全，确保和提升网络安全风险管控的能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c8af06601dcf0a42688674417006c81/" rel="bookmark">
			scipy.misc包中的toimage和fromimage
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 对 Image 打开的图像做二值化以及黑白花处理时，找资料说要导包 from scipy.misc import fromimage, toimage
自己实验发现这包用不了了，找资料找到说 toimage 已经被 Image.fromarray替换；而 fromimage 没有资料。
解决办法：下边代码中提供了替换原来 fromimage与toimage 的方法
import numpy as np from PIL import Image # 打开图像，并灰度化 img = Image.open(img_path).convert('L') # 1. 因为打开的图像是 Image 格式的，我们查看不了。所以将其转换为 数组格式，这步用 np 包实现。 img = np.asarray(img) # 图像作为数组进行操作 # 2. 对转换好的数组图像进行操作 img = (np.ceil(img / 255.0) * 255.0).astype('uint8') # 我这里是黑白化 # 3. 最后将处理完之后的图像数组再次转化为 Image格式的图像，进行保存 img = Image.fromarray(img) img.save() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54086d21892c37a623c78d4d31ee765e/" rel="bookmark">
			离线安装samba与配置（.tar方式安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、samba离线安装
【安装并设置成功后，相关文件及其位置：
①smbd：/usr/local/samba/sbin/smbd
②nmdb：/usr/local/samba/sbin/nmbd
③配置文件 smb.conf：/usr/local/samba/lib/smb.conf
④添加用户的 smbpasswd 文件：/usr/local/samba/bin/smbpasswd
⑤测试文件 testparm：/usr/local/samba/bin/testparm】
1、下载安装包：samba-3.2.0.tar.gz
百度云方式：链接：https://pan.baidu.com/s/19QnUcdLbxdTyqEkDB3C80g
提取码：kmh4
2、将下载好的 samba-3.2.0.tar.gz 压缩包传到服务器上
3、在压缩包所在路径下依次执行以下命令：
tar zxvf samba-3.2.0.tar.gz cd samba-3.2.0/source # 进入解压后目录的子目录source,因为代码在里面 ./configure # 我们不使用--prefix参数,因为它默认安装到/usr/local/samba make make install 运行完后就可以见到在 /usr/local/samba 目录下生成的文件：
4、将原来解压的目录的子目录 examples 中的 smb.conf.default 配置文件复制到上面的lib目录中去（记得把.default去掉）
cp /home/cqf/samba-3.2.0/examples/smb.conf.default /usr/local/samba/lib/smb.conf 在 /etc/ld.so.conf 的文件中加入一行 /usr/local/samba/lib
因为：tar安装时没有在系统的库文件中指定刚才安装的samba服务器的库路径
6、运行 ldconfig 命令更新库文件：
ldconfig 7、启动samba：（.tar安装方式，启动不能使用命令：systemctl status smbd / systemctl status nmbd / systemctl restart smbd）
/usr/local/samba/sbin/smbd -D /usr/local/samba/sbin/nmbd -D 正常情况，启动命令之后不会有任何提示。
如图：
8、运行以下命令测试是否安装成功：testparm
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54086d21892c37a623c78d4d31ee765e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b34863db804f8684d2a56a20cf974045/" rel="bookmark">
			计算机网络常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在计算机网络中经常要对网络进行管理，测试，了解和掌握网络常用命令将会有助于节省时间，提高效率。
网络命令的基本格式如下：
网络命令 参数1参数2参数3参数…
查看这些参数的方法是在网络命令后加“/?”,如要查看ping命令的参数可以输入ping/?
一、ping命令： Ping向目标主机(地址)发送一个回送请求数据包，要求目标主机收到请求后给予答复，从而判断网络的响应时间和本机是否与目标主机(地址)联通。
如果执行Ping成功而网络仍无法使用，那么问题很可能出在网络系统的软件配置方面，Ping成功只能保证本机与目标主机间存在一条连通的物理路径。
常用格式：ping IP地址或主机名 参数...
（示例未使用参数，可通过“/？”查询参数列表）
二、tracert命令： Tracert命令用来显示数据包到达目标主机所经过的路径，并显示到达每个节点的时间。命令功能同Ping类似，但它所获得的信息要比Ping命令详细得多，它把数据包所走的全部路径、节点的IP以及花费的时间都显示出来。该命令比较适用于大型网络。
常用格式：tracert IP地址或主机名 参数...
（示例未使用参数，可通过“/？”查询参数列表）
三、netstat命令： 利用Netstat命令可以了解网络的整体使用情况，显示当前正在活动的网络连接的详细信息，例如显示网络连接、路由表和网络接口信息，统计目前总共有哪些网络连接正在运行。
常用格式：netstat 参数...
注意：此命令需要使用管理员权限 该命令参数列表：
-a 显示所有连接和侦听端口。
-b 显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。此情况下，可执行程序的名称位于底部[]中，它调用的组件位于顶部，直至达到 TCP/IP。注意，此选项可能很耗时，并且在您没有足够权限时可能失败。
-e 显示以太网统计。此选项可以与 -s 选项结合使用。
-f 显示外部地址的完全限定域名(FQDN)。
-n 以数字形式显示地址和端口号。
-o 显示拥有的与每个连接关联的进程 ID。
-p proto 显示 proto 指定的协议的连接；proto 可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s 选项一起用来显示每个协议的统计，proto 可以是下列任何一个: IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP或 UDPv6。
-r 显示路由表。
-s 显示每个协议的统计。默认情况下，显示IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6的统计；-p 选项可用于指定默认的子网。
-t 显示当前连接卸载状态。
interval 重新显示选定的统计，各个显示间暂停的间隔秒数。按 CTRL+C 停止重新显示统计。如果省略，则 netstat将打印当前的配置信息一次。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b34863db804f8684d2a56a20cf974045/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f791a1c5711b1a51229b5fb6b07a3b4e/" rel="bookmark">
			Ubuntu 离线安装软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu 离线安装软件 准备工作联网电脑操作离线电脑操作 准备工作 需要一台能连互联网的ubuntu电脑操作系统版本与离线电脑版本一致，本文使用的是ubuntu18.04-server版本 联网电脑操作 安装dpkg-dev，后面要用到dpkg-scanpackages命令 apt-get install dpkg-dev 下载安装包，首先清空/var/cache/apt/archives目录，这里选择备份，防止文件丢失 # 备份archives mv /var/cache/apt/archives /var/cache/apt/archives-bak # 新建一个archives目录 mkdir /var/cache/apt/archives # 新建一个文件夹，后面用于拷贝 mkdir /home/dorahou/your_software/ # 安装文件，此处不是真的安装，而是下载所有用到的离线包，-d表示只下载，是必加的,your_software的安装教程直接网上搜索，教程中install的记得加-d apt-get -d install your_software apt-get -d install your_software # 复制archives文件夹，并用dpkg-scanpackages建Packages.gz索引 cp -r /var/cache/apt/archives /home/dorahou/your_software/ cd /home/dorahou/your_software/ dpkg-scanpackages archives /dev/null | gzip &gt; archives/Packages.gz # 打包，并将your_software.tar.gz拷贝到离线电脑或服务器上 cd .. tar czvf your_software.tar.gz your_software 离线电脑操作 将your_software.tar.gz拷贝到电脑或服务器上，并解压 cd /home/dorahou/ tar xzvf your_software.tar.gz pwd 创建本地源 # 备份源文件 mv /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f791a1c5711b1a51229b5fb6b07a3b4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6977b7667fec79f50e6fc1b92750fbf/" rel="bookmark">
			zabbix可以监控哪些数据指标？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.监控web服务
web服务是否正常
业务（网页是否能访问、是否可以完成下订单、注册用户）
服务的响应时间
服务的并发量（活动用户、非活动用户）
2.监控数据库
监控磁盘使用情况
监控内存内存使用
查看并发连接数量
检查数据库执行增删改查的频率
检查主从状态
检查数据库的备份情况
3. 服务器监控
磁盘 使用率
inode数
block数
读写速率
CPU 监控cpu负载
监控使用cpu资源最多的进程
内存 使用率
缓冲区
缓存区
交换分区大小
网络 监控每个网卡的上先行速率
监控占用网络带宽见多的进程
监控数据包的丢包
监控网络数据包的阻塞情况
进程 当前系统中的总进程数
监控特定的程序的进程数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74851c91a104b64f3796d87241c98c8d/" rel="bookmark">
			mysql数据库升级-5.7.29-5.7.30 RPM包升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql版本5.7.29升级到5.7.30 由于我们安装mysql的方式是通过mysql-5.7.29-1.el7.x86_64.rpm-bundle.tar中的rpm包安装:
rpm -Uvh mysql-community-*.rpm
所以升级的方式是专门针对这种方式的.
其实升级的过程跟从0开始安装的过程类似.
1 第一步:查看当前的安装版本 方式一:mysql -V
方式二:rpm -qa |grep -i mysql
2 第二步:创建一个新目录,解压mysql-5.7.30-1.el7.x86_64.rpm-bundle.tar到新目录中.10个rpm包.、 第三步:备份数据库,以防升级失败 3.1 备份 mysqldump -u root -p --add-drop-table --routines --events --all-databases --force &gt; data-for-upgrade.sql
3.2 设置参数使数据库关闭时会清空缓存避免版本间缓存格式差异 mysql -u root -p --execute="SET GLOBAL innodb_fast_shutdown=0"
3.3 关闭数据库(如果在升级安装开始时MySQL服务器正在运行，则会在安装结束时自动重启，执行上述升级命令后，可直接查看版本号变为升级后的版本号) systemctl stop msyqld 第四步:升级:直接替换二进制文件(即直接yum update/rpm -Uvh升级rpm包)数据库目录等都不变
cd 目录/
rpm -Uvh mysql-community-*.rpm
yum update -y *.rpm --操作只更新了软件不影响datadir内容。
第五步:检查并可能解决旧数据和升级软件之间的任何不兼容性 service mysqld strat
mysql_upgrade -uroot -p
注意:当从5.7.29升级到5.7.30需要更新,当升级到最新的5.7.30后,就不用了.当然,如果非要更新(其实没必要),要加--force选项.
第六步:验证 6.1 rpm验证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74851c91a104b64f3796d87241c98c8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2703c0b660a2f98cfa89c0177990e4b1/" rel="bookmark">
			Chromedp 绕过检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用chromdedp爬虫，绕过检测机制
chromedp.Flag("enable-automation", false), // 防止监测webdriver chromedp.Flag("disable-blink-features", "AutomationControlled"),//禁用 blink 特征 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7547c367f5cf6635a97b858f7e0fc1e/" rel="bookmark">
			利用MATLAB批量读写tif数据（Landsat7&amp;8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用MATLAB批量读写tif数据（Landsat7&amp;8） 代码来源于：批量读写
代码如下：
clc;clear %% 读取NDVI-tif文件 file_path_N = 'E:\';% 图像文件夹路径 img_path_list_N = dir(strcat(file_path_N,'*.tif'));%获取该文件夹中所有TIF格式的图像 img_num_N = length(img_path_list_N);%获取图像总数量 II_N=cell(1,img_num_N); if img_num_N &gt; 0 for jj = 1:img_num_N image_name_N = img_path_list_N(jj).name;% 图像名 [image_N,geo] = geotiffread(strcat(file_path_N,image_name_N)); II_N{jj}=image_N; fprintf(' %d %s\n',jj,strcat(file_path_N,image_name_N));% 显示正在处理的图像名 end end %% 计算植被覆盖度 NDVImax = 0.8; NDVImin = 0.2; fc_1 = cell(1,img_num_L); for i = 1:img_num_L fc_1{i} = ((II_N{i}-NDVImin)./(NDVImax-NDVImin)).^2; end %% 输出TIF图像 for j = 1:1:img_num_L CoordRefSysCode=32648; outpath='E:\'; outFile=strcat(outpath,img_path_list_L(j).name); geotiffwrite(outFile,fc_1{i},geo,'CoordRefSysCode',CoordRefSysCode); end 遇到的问题： 在读取Landsat7的数据时，批量导出数据一直失败，原因在于，下载的Landsat7的数据，每一幅影像的行列号有差异，导致导出时的地理信息‘geo’与各个影像并不匹配，因此出错。在换成Landsat8的数据时，数据已经可以正常导出。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/172/">«</a>
	<span class="pagination__item pagination__item--current">173/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/174/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>