<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45942e462b3b86cf481600b5e2dd58c6/" rel="bookmark">
			搭建数字孪生三维开发平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		更多示例代码：地图API_卫星地图_离线地图_地图可视化_离线地图二次开发_离线地图三维开发示例
1、如何搭建离线地图开发环境 视频教程
2、下载离线地图数据(金字塔瓦片数据） 视频教程
3、下载离线地图地形数据库（实现地表高低起伏） 4、添加离线地图数据到本地服务器 （含3D） 视频教程
立体三维起伏 立体建筑物
5、离线地图二次开发接口（离线地图API）
6、离线地图API接口实例DEMO
三维地球
三维数据可视化
三维建筑物
三维雨雪效果（三维特效）
更过三维效果及二次开发示例代码：地图API_卫星地图_离线地图_地图可视化_离线地图二次开发_离线地图三维开发示例​
技术支持 电话：400-028-7262 028-65472965 QQ：384720499
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c77680e50e2238041736144e277f4e2/" rel="bookmark">
			最近在调试ios手机自动化测试前提需要部署WDA，但是mac本连接苹果机时总是闪现请信任该电脑，导致不能连接电脑的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		应该是USB进程的问题。
解决方法是把USB进程杀掉，拔下设备，然后重新连接。
终端运行命令杀掉USB进程：
$ sudo killall -STOP -c usbd 然后需要输入电脑解锁密码，输入密码（不会显示，直接输入就好）之后，回车。
然后拔下设备，重新连接。
在 macOS 中，sudo killall -STOP -c usbd 命令的含义如下：
sudo: 以管理员权限执行命令。killall: 终止指定名称的进程。-STOP: 发送停止信号给目标进程。-c: 在终止进程之前显示有关进程计数的信息。usbd: 要终止的进程名称。 在这个命令中，"usbd" 是一个代表 USB 设备服务（USB Device Services）的进程。该命令的作用是停止名为 "usbd" 的进程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ef1c10514a5d0e06b6b1f9f8c2d0ba/" rel="bookmark">
			SpringBoot笔记总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一:SpringBoot简介
二:SpringBoot入门案例开发步骤
三:SpringBoot与Spring框架对比
四:SpringBoot程序中需要关注的点
1.pom.xml文件中的标签
2.starter起步依赖
3.引导类
4.变更起步依赖使用Jetty服务器替代Tomcat
五:SpringBoot配置文件
1.配置文件格式
2.配置文件加载顺序
3.yaml格式
4.多环境开发配置
1.配置多个环境
2.项目打成jar包后通过命令行启动时,可以通过设置临时参数来更改配置
3.Maven与SpringBoot多环境配置冲突的解决方案
4.SpringBoot中的配置文件级别
一:SpringBoot简介 SpringBoot是由Pivotal团队提供的全新框架,其设计目的是用来简化Spring应用的初始搭建和开发过程
具体怎么简化的,看完SpringBoot入门案例你就明白了
二:SpringBoot入门案例开发步骤 1.创建新模块,选择Spring初始化,并配置相关基础信息 2.选择SpringBoot版本(尽量选低版本)以及当前模块需要使用的依赖
(可以选择很多依赖,根据你们项目需要的技术进行选择即可,入门案例这里为了最简开发只勾选了Spring Web依赖)
3.删除工程不需要的目录
4.在pom.xml文件中的web起步依赖环境中排除tomcat起步依赖,并添加jetty起步依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--web起步依赖环境中排除tomcat起步依赖--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--添加jetty依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; 5. 编写控制器类
@RestController @RequestMapping("/books") public class BookController { @GetMapping("/{id}") public String getById(@PathVariable Integer id){ System.out.println("id=&gt;"+id); return "{'message':'hello,springboot'}"; } } 6.运行自动生成的Application引导类 好啦,到这一步,SpringBoot入门案例就编写完成了
要测试的话浏览器输入下面路径即可:http://localhost:8080/books/1
三:SpringBoot与Spring框架对比 使用Spring开发SpringMVC程序需要引入SpringMVC和Servlet依赖,需要编写ServletConfig和SpringMvcConfig配置类,再需要编写控制器类
使用SpringBoot开发SpringMVC程序需要选择Spring Web依赖,不再需要编写ServletConfig和SpringMvcConfig配置类,最后编写控制器类即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ef1c10514a5d0e06b6b1f9f8c2d0ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2548c97136441babd5c793acd23ebe90/" rel="bookmark">
			软考论文如何得高分？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软考论文如何才能得高分？这是最近很多同事咨询我的问题，最近几天我也反思了一下为什么我的论文可以取得高分，对比了一下网络上45-55分的论文之后，总结如下：
1.子题目的要求一定要重点全面的回应
2. 要有过渡段-理论结合实际丝滑过度
3. 结构清晰，条理清楚，每一段主题明确。
4. 解决问题时至少要用一到两个工具和技术的运用，工具介绍结合项目来写，而不是纯理论。
5.遇到的问题不能影响太大，因为你分享的是成功案例。
6. 心得体会一定要有，且这部分真实现实。
7. 可移植性越差的论文，分数越高，可移植性差代表的是理论加深度结合实际（真实，诚实，具体，不要照搬模版论文），而不是纯理论或者纯理论加空洞的实际。
8.语言书面化，标准化，切勿使用口语。
写论文其实和写作文一样，如果想得高分，需要有创新，千篇一律很难得高分，而结构没有多大创新头，尤其在考试中，如果结构创新，会给阅卷老师带来理解上的困难，不但不能得高分，可能反而弄巧成拙，所以内容创新，细节创新才是王道，结构是可以背模版的，内容考察的才是个人理论联系实际的能力，真正的解决问题的能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e651cb2c6783eca7e8d58a728a4484fe/" rel="bookmark">
			AutoDL从0到1搭建stable-diffusion-webui
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 AI绘画当前非常的火爆，随着Stable diffusion，Midjourney的出现将AI绘画推到顶端，各大行业均受其影响，离我们最近的AI绘画当属Stable diffusion，可本地化部署，只需电脑配备显卡即可完成AI绘画工作，此篇文章将以AUTODL从0到1云部署stable-diffusion-webui。
1.注册 打开AutoDL，点击立即注册，根据提示完成注册即可
2.租用实例 登录完成后进入控制台，在容器实例界面点击租用新实例
选择合适价格的示例，可以选择按量计费，使用多久就支付多少
滚动下来选择基础镜像，选择_Miniconda/conda3/3.10(ubuntu22.04)/11.8_（此处我选择的最新版，需要看选择CUDA版本是否低于实例的最高CUDA，如果过高将无法创建），完成镜像选择后，点击底部的立即创建即可。
3.开始部署 进入控制台-&gt;容器实例，可以看到刚创建的示例，点击快捷工具JupyterLab进入Jupyter
点击终端，新建终端
3.1 环境配置 初始化conda，执行conda init，执行完成后关闭终端，重新开启一个终端
root@autodl-container-19e411b150-db72abe2:~# conda init
新建conda sd虚拟环境，新建后退出原有base环境，再激活sd环境
(base) root@autodl-container-19e411b150-db72abe2:~# conda create -n sd python=3.10.6
(base) root@autodl-container-19e411b150-db72abe2:~# conda deactivate
root@autodl-container-19e411b150-db72abe2:~# conda activate sd
3.2 拉取stable-diffusion-webui 开启学术资源加速（不开很慢甚至无法下载相关文件）,在终端执行此命令
# 开启学术加速 source /etc/network_turbo # 关闭学术加速 unset http_proxy &amp;&amp; unset https_proxy 拉取stable-diffusion-webui git源码
进入autodl-tmp目录，此目录是实例数据盘目录
(sd) root@autodl-container-19e411b150-db72abe2:~# cd autodl-tmp/
(sd) root@autodl-container-19e411b150-db72abe2:~/autodl-tmp# git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git
3.3 启动Stable-diffusion-webui 进入stable-diffusion-webui目录
(sd) root@autodl-container-19e411b150-db72abe2:~/autodl-tmp# cd stable-diffusion-webui/
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e651cb2c6783eca7e8d58a728a4484fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3f36876c45e108b92142e045923a738/" rel="bookmark">
			张量Tensor &amp;&amp; 深度学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 张量的定义 张量tensor理论是数学的一个分支学科，在力学中有重要的应用。张量这一术语源于力学，最初是用来表示弹性介质中各点应力状态的，后来张量理论发展成为力学和物理学的一个有力数学工具。
张量（Tensor）是一个定义在一些向量空间和一些对偶空间的笛卡尔积上的多重线性映射，其坐标是|n|维空间内，有|n|个分量的一种量， 其中每个分量都是坐标的函数， 而在坐标变换时，这些分量也依照某些规则作线性变换。r 称为该张量的秩或阶（与矩阵的秩和阶均无关系）。
2 深度学习中的张量 在深度学习中，Tensor实际上就是一个多维数组（multidimensional array）。
Tensor表现形式0维张量标量、常数（0、1等）1维张量矢量、一维向量2维张量二维矩阵3维张量三维矩阵 单个彩色图片其实就可以看作为一个三维的张量。彩色图片RGB包含有三个图层，每层又是一个[0,255]的二维矩阵。
3 PyTorch库中张量的应用 在PyTorch库中有专门处理张量的类torch.Tensor，该类有一系列方法用于进行张量之间的各种运算。张量之间的加减乘除点乘等都可以通过该类实现。
import torch torch.tensor([ [[9,1,8],[6,7,5],[3,4,2]], [[2,9,1],[8,6,7],[5,3,4]], [[1,5,9],[7,2,6],[4,8,3]] ]) 上述代码创建了一个三维的张量，也可以理解为一个三维的数组。==所以为什么叫张量而不是矩阵呢？==就是因为我们通常需要处理的数据有零维的（单纯的一个数字）、一维的（数组）、二维的（矩阵）、三维的（空间矩阵）、还有很多维的。Pytorch为了把这些各种维统一起来，所以起名叫**张量Tensor**。
PyTorch中的Tensor支持超过一百种操作，包括转置、索引、切片、数学运算、线性代数、随机数等等，总之，凡是你能想到的操作，在pytorch里都有对应的方法去完成。
参考资料 [1] 张量 力学术语）（人工智能术语)
[2] 笔记 | 什么是张量（tensor）&amp; 深度学习 - 知乎 (zhihu.com)
[3] 什么是张量？ - 知乎 (zhihu.com)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a05be03ab3aab106a4c811c6e31e17a/" rel="bookmark">
			Vue request接口get请求正常，post请求失效，一直处于pending状态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做项目中，我们要是自己搭建一个vue项目框架需要耗费很多时间。所以很多时候方便快速开发，直接利用网上的各种框架。最近在网上下了一个vue2模板项目，在开发过程中利用它封装的request方法请求接口过程中，发现一个post接口请求一直响应超时，但是在postman上测试接口，数据能正常返回，奇怪的是get请求也能够请求成功，说明代理配置上也是没问题的。
以前用若依框架也没遇到过这个问题啊。网上各种搜有人分析是post的数据格式。但是我看request方法里面格式也没做处理啊，寻思一翻最终想到这个罪魁祸首mock。
大家先了解一下mock:
在 vue 或 react 项目中使用 mockjs 搭建 mock server_react 添加mock_不怕麻烦的鹿丸的博客-CSDN博客
我这个框架有登录，所以用到了mock，mock对请求做了处理，判断你系统有没有引入mock，看下vue.config.js配置里这行属性：
最终网友的解决办法来了：
两种办法，再次处理返回数据格式和直接注释mock引入。要是没用到数据模拟的话，直接注释就好。重启项目请求访问正常了。
proxy: { '/dev-api': { target: 'http://1x.xx.x.xxx:xxxx', // changeOrigin: true, pathRewrite: { '^/dev-api': '' }, //第一种方法 onProxyReq: function(proxyReq, req, res, options) { if (req.body) { const bodyData = JSON.stringify(req.body) // incase if content-type is application/x-www-form-urlencoded -&gt; we need to change to application/json proxyReq.setHeader('Content-Type', 'application/json') proxyReq.setHeader('Content-Length', Buffer.byteLength(bodyData)) // stream the content proxyReq.write(bodyData) } } } }, //第二种方法，注释这行 before: require('.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a05be03ab3aab106a4c811c6e31e17a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684aa5f05feec0d7ff497bfe7ff7fbb8/" rel="bookmark">
			Android Framework 之 启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 系统的启动流程 Android 系统的启动流程可以分为以下几个主要步骤：
引导加载器（Bootloader）启动：当你打开一个 Android 设备时，首先启动的是引导加载器。引导加载器负责启动 Android 的核心操作系统。
Linux 内核启动：引导加载器加载并启动 Linux 内核。Linux 内核负责启动系统的底层硬件，并启动 init 进程。
Init 进程启动：init 进程是 Linux 系统中的第一个进程（PID = 1）。在 Android 系统中，init 进程负责启动一些重要的守护进程和服务，例如 Zygote 进程。
Zygote 进程启动：Zygote 是 Android 中的一个特殊进程，负责孵化（Fork）出所有其他的应用进程。Zygote 进程在启动时会预加载大量的系统类和资源，以此来提高应用启动的速度。
SystemServer 进程启动：Zygote 进程会 fork 出一个新的进程来启动 SystemServer。SystemServer 是 Android 系统中的核心服务，它管理并提供了许多系统级别的服务，例如窗口管理服务、活动管理服务等。
系统服务启动：在 SystemServer 进程中，会启动各种系统服务。这些服务在系统启动完成后，将一直运行，为应用程序提供各种服务。
启动 Launcher 应用：系统服务启动完毕后，Activity Manager Service 会启动设备的 Launcher 应用，此时，用户可以开始与设备进行交互。
这就是 Android 系统启动的整个过程。请注意，这个过程可能会因设备制造商的定制和 Android 版本的不同而有所不同，但大体流程是相同的。
Launcher的启动流程 Launcher 的启动过程更具体的说明如下：
当 Android 系统启动完成，并且所有的系统服务都已经启动后，ActivityManagerService （AMS）会开始处理用户的交互。AMS 是 Android 中负责管理所有活动的系统服务。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684aa5f05feec0d7ff497bfe7ff7fbb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bb5109d892cfb16ae71b4d21757fc3d/" rel="bookmark">
			wonderful sql day4 初识数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DBMS 主要通过数据的保存格式（数据库的种类）来进行分类，根据数据库种类分别：
层次数据库（Hierarchical Database，HDB）
关系数据库（Relational Database，RDB）
其中RDBS有现阶段主要有以下 5 种类型：
Oracle Database：甲骨文公司的RDBMS（缺点是服务和升级贵）SQL Server：微软公司的RDBMS（只能安装在微软操作系统）DB2：IBM公司的RDBMS（适合处理海量数据）PostgreSQL：开源的RDBMSMySQL：开源的RDBMS SQL（结构化查询语言）：专门用于与数据库通信的语言，优点
不是特定数据库供应商专门的语言，几乎所有DBMS都支持SQL简单易学灵活使用其他语言元素可以进行非常复杂高级的数据库操作 RDBMS 最常见的系统结构就是客户端 client/ 服务器server类型（C/S类型），一般安装数据库说的是安装数据库的服务端，因为数据都放在服务端上。
根据对 RDBMS 赋予的指令种类的不同，SQL 语句可以分为以下三类：
DDL ：DDL（Data Definition Language，数据定义语言） 用来创建或者删除存储数据用的数据库以及数据库中的表等对象。DDL 包含以下几种指令。 CREATE ： 创建数据库和表等对象DROP ： 删除数据库和表等对象ALTER ： 修改数据库和表等对象的结构 DML :DML（Data Manipulation Language，数据操纵语言） 用来查询或者变更表中的记录。DML 包含以下几种指令。 SELECT ：查询表中的数据INSERT ：向表中插入新数据UPDATE ：更新表中的数据DELETE ：删除表中的数据 DCL ：DCL（Data Control Language，数据控制语言） 用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对 RDBMS 的用户是否有权限操作数据库中的对象（数据库表等）进行设定。DCL 包含以下几种指令。 COMMIT ： 确认对数据库中的数据进行的变更ROLLBACK ： 取消对数据库中的数据进行的变更GRANT ： 赋予用户操作权限REVOKE ： 取消用户的操作权限 SQL的基本书写规则 SQL语句要以分号（ ; ）结尾SQL 不区分关键字的大小写，但是插入到表中的数据是区分大小写的win 系统默认不区分表名及字段名的大小写linux / mac 默认严格区分表名及字段名的大小写 * 本教程已统一调整表名及字段名的为小写，以方便初学者学习使用。常数的书写方式是固定的：'abc', 1234, '26 Jan 2010', '10/01/26', '2010-01-26'.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0bb5109d892cfb16ae71b4d21757fc3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bf5cba76267f47fe4d3207a6235d6f4/" rel="bookmark">
			从 GPU 到 ChatGPT，一文带你理清GPU/CPU/AI/NLP/GPT之间的千丝万缕【建议收藏】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
硬件
GPU
什么是 GPU？
GPU 是如何工作的？
GPU 和 CPU 的区别
GPU 厂商
海外头部 GPU 厂商：
国内 GPU 厂商：
nvidia 的产品矩阵
AI
什么是人工智能 (Artificial Intelligence-AI)？
人工智能细分领域
机器学习（Machine Learning）：研究如何通过算法和模型让计算机从数据中学习和提取规律，以完成特定任务。
深度学习（Deep Learning）：是机器学习的一种，使用多层神经网络来学习特征和模式，以实现对复杂任务的自动化处理。
自然语言处理（Natural Language Processing, NLP）：研究如何让计算机理解、分析、处理人类语言的方法和技术。
计算机视觉（Computer Vision）：研究如何让计算机“看懂”图像和视频，并从中提取有用的信息和特征。
机器人学（Robotics）：研究如何设计、构建和控制机器人，让它们能够完成特定任务。
强化学习（Reinforcement Learning）：是一种机器学习的方法，通过与环境的交互和反馈来学习最优行动策略。
知识图谱（Knowledge Graph）：是一种将知识以图谱的形式进行组织、表示和推理的方法，用于实现智能搜索、推荐等应用。
语音识别（Speech Recognition）：研究如何让计算机识别和理解人类语音，以实现语音输入、语音控制等功能。
NLP
Transformer 是什么？
Transformer 模型的实现
还有没有其他模型 ？
GPT 模型
ChatGPT
与现存的其他同类产品相比，ChatGPT 的独特优势在于：
GPT-3.5
ChatGPT 的优势在于：
GPT-4
AIGC 模型
人工智能突破摩尔定律
未来
参考
福利：文末有chat-gpt纯分享，无魔法，无限制 硬件 “没有硬件支持，你破解个屁”
GPU 什么是 GPU？ GPU 是 Graphics Processing Unit 的缩写，中文翻译为图形处理器。GPU 最初是为了提高电脑处理图形的速度而设计的，主要负责图像的计算和处理。GPU 通过并行计算的方式，可以同时执行多个任务，大大提高了图形和数据处理的速度和效率。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bf5cba76267f47fe4d3207a6235d6f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da77c32227564ae5fb3288d9298c6e7b/" rel="bookmark">
			半监督学习Semi- Supervised Learning的一致性约束，一致正则损失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		半监督学习的一致性约束分析 1. Base Assumptions1.1 The Smoothness Assumption1.2 The Cluster Assumption1.3 The Manifold Assumption 2. Consistency Regularization 半监督学习的一致性约束2.1 Pi-Model2.2 Temporal Ensembling2.3 Mean Teachers2.4 Unsupervised Data Augmentation2.5 小节 3. Proxy-label Methods 代理标签/伪标签方法 在现实生活中，无标签的数据易于获取，而有标签的数据收集起来通常很困难，标注也耗时和耗力。在这种情况下，半监督学习（Semi-Supervised Learning）更适用于现实世界中的应用，近来也已成为深度学习领域热门的新方向，该方法只需要少量有带标签的样本和大量无标签的样本，而本文主要介绍半监督学习的三个基本假设和三类方法。 1. Base Assumptions 在什么假设下可以应用半监督算法呢？半监督算法仅在数据的结构保持不变的假设下起作用，没有这样的假设，不可能从有限的训练集推广到无限的不可见的集合。具体地假设有：
1.1 The Smoothness Assumption 如果两个样本 x 1 x_1 x1​， x 2 x_2 x2​ 相似，则它们的相应输出 y 1 y_1 y1​， y 2 y_2 y2​ 也应如此。这意味着如果两个输入相同类，并且属于同一簇，则它们相应的输出需要相近，反之亦成立。
1.2 The Cluster Assumption 假设输入数据点形成簇，每个簇对应于一个输出类，那么如果点在同一个簇中，则它们可以认为属于同一类。聚类假设也可以被视为低密度分离假设，即：给定的决策边界位于低密度地区。两个假设之间的关系很容易看出。
一个高密度区域，可能会将一个簇分为两个不同的类别，从而产生属于同一聚类的不同类，这违反了聚类假设。在这种情况下，我们可以限制我们的模型在一些小扰动的未标记数据上具有一致的预测，以将其判定边界推到低密度区域。
1.3 The Manifold Assumption （a）输入空间由多个低维流形组成，所有数据点均位于其上；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da77c32227564ae5fb3288d9298c6e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a06687c572997ad0db79f245e3324e78/" rel="bookmark">
			Mysql常用的查询语法~！(个人收藏)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL是一个流行的开源关系型数据库管理系统，支持多种查询语法来操作数据库。以下是MySQL常用的查询语法：
1. 查询所有数据：
SELECT * FROM table_name; 2.查询指定字段的数据：
SELECT column1, column2 FROM table_name; 3.使用WHERE子句进行条件查询：
SELECT * FROM table_name WHERE condition; 4.使用ORDER BY 进行排序：
SELECT * FROM table_name ORDER BY column_name [ASC|DESC]; 5.使用LIMIT限制查询结果数量：
SELECT * FROM table_name LIMIT num; 6.使用LIMIT和OFFSET进行分页查询：
SELECT * FROM table_name LIMIT num OFFSET offset_num; 7.使用GROUP BY进行分组查询：
SELECT column1, column2, COUNT(*) FROM table_name GROUP BY column1, column2; 8.使用HAVING进行分组后的条件过滤：
SELECT column1, column2, COUNT(*) FROM table_name GROUP BY column1, column2 HAVING condition; 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a06687c572997ad0db79f245e3324e78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be33676dd2d656c1ef569a991749d91/" rel="bookmark">
			【论文精读3】基于历史抽取信息的摘要抽取方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 论文分享 今天分享的是来自2018ACL的长文本抽取式摘要方法论文，作者来自哈尔滨工业大学和微软，引用数369
Neural Document Summarization by Jointly Learning to Score and Select Sentences
摘要抽取通常分为两个部分，句子打分和句子选择。句子打分的方法有基于特征的，比如字概率，TF-IDF权重，句子位置和句子长度特征，基于图的方法比如TextRank和LexRank。在句子选择阶段，有基于最大边际相关性（maximal marginal relevance）的方法，选择分数最高，冗余最小的摘要；以摘要长度为限制，基于整数线性规划（Integer Linear Programming）的方法；用于发现最优句子子集的优化方法子模块方程（submodular function）；基于神经网络的方法等
这些方法都是将句子打分和句子选择分为两个步骤，即先打分后选择，论文提出一种将打分和选择进行联合学习的模型。作者的创新点在于构建的模型在每一次选择句子的时候，会同时考虑句子的重要性和之前已选择的句子。
模型 作者提出的模型一共包括3个GRU，第一个GRU用于编码字级别特征，将GRU的最后一层作为句子编码，第二个GRU对所有句子进行学习，得到文档级的句子编码，第三个GRU用于学习历史抽取信息，前两个GRU的公式比较简单，这里就不详细描述了，学习历史信息，得到隐层状态，然后利用历史信息的隐层状态，去影响剩余句子的打分过程，方式如下
s t − 1 s_{t-1} st−1​为上一时刻采集的句子向量， h t − 1 h_{t-1} ht−1​为上一时刻隐层状态，GRU得到当前时刻的隐层状态，然后通过当前隐层状态对剩余的句子进行打分，得到分数 δ ( S i ) \delta(S_i) δ(Si​)，需要注意的是，在抽取第一个句子的时候， s 0 s_0 s0​向量为0，隐层状态计算如下
用于计算隐层状态的 s 1 ← \mathop{s_1}\limits ^{\leftarrow} s1​←​为文档级向量的最后一个反向隐层向量
目标函数 目标函数为预测段落的得分和添加每一个句子可获得的ROUGE分数提升之间的KL-Divergence
预测段落的得分
添加每一个句子可获得的ROUGE分数提升，MinMax归一化后进行softmax
实验 作者比较了几个当时最好的抽取式模型，NEUSUM均优于baseline
作者比较了NN-SE和NeuSum抽取的句子和贪婪算法（ORACLE）得到的参考句子，在抽取的前3个句子的准确性，NeuSum是要优于NN-SE，并且发现越往后抽取，准确率是越下降的，如何高效的利用历史抽取是一个可提升的点
作者还比较了抽取句子位置的统计信息，得出NN-SE抽取的句子80.91%的概率来自前三个句子，而NeuSum只有58.64%，NeuSum利用历史抽取信息的方法能够避免依赖前面的段落。ORACLE中句子的分布是比较均匀的，而算法倾向于抽取前几个句子
总结 NeuSum提出了一种基于历史抽取信息的摘要抽取方法，其只能抽取固定数量的段落和目标函数在MemSum中得到了优化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87f0e747985fb4c8329a96301605df26/" rel="bookmark">
			使用 Docker Compose 部署 Redis Cluster 集群，轻松搭建高可用分布式缓存
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis Cluster（Redis 集群）是 Redis 分布式解决方案的一部分，它旨在提供高可用性、高性能和横向扩展的功能。Redis Cluster 能够将多个 Redis 节点组合成一个分布式集群，实现数据分片和负载均衡，从而确保在大规模应用场景下的稳定性和可靠性。我们这篇文章了将为大家介绍如何使用 docker-compose 搭建 redis 集群。
Redis Cluster 介绍 Redis Cluster 介绍将数据划分为多个槽（slot），默认情况下共有 16384 个槽。每个 Redis 节点负责处理其中的一部分槽。当客户端请求访问某个键时，Redis Cluster 会根据键的哈希值决定它应该位于哪个槽，并将请求转发到负责该槽的 Redis 节点上。
在 Redis Cluster 中，每个槽都可以有多个副本，通常有一个主节点和一个或多个从节点。主节点负责处理客户端请求，并将数据同步到从节点上。这样，即使主节点出现故障，系统仍然可以继续工作，从节点可以接管主节点的工作，并保持数据的一致性。Redis Cluster 提供了自动分片和数据复制的机制，无需手动管理数据分片和节点复制。
Redis Cluster 使用 Gossip 协议进行节点间的通信，节点之间互相交换信息以保持集群的状态一致性。通过 Gossip 协议，Redis 节点可以动态发现新的节点加入或者节点离开集群，从而实现集群的自动伸缩和高可用性。
Redis Cluster 具有良好的扩展性。当数据量增加或请求量增大时，可以简单地增加新的 Redis 节点，并让集群自动重新分片和重新分配槽。这种横向扩展方式能够无缝地增加集群的容量和性能，而无需停机或对现有节点进行复杂的迁移操作。
Redis Cluster 具有很强的容错性。即使有部分节点宕机，只要主节点的数量仍然满足半数以上，集群仍然可以继续工作。当集群检测到主节点不可用时，会自动将从节点提升为主节点，确保服务的连续性和可用性。
docker-compose 创建一个 redis-cluster 的文件夹，在其中在创建一个 redis6479 的一个文件夹，在 redis6479 中创建 docker-compose.yml 文件，文件如下：
version: '3.3' services: redis6479: network_mode: 'host' image: redis container_name: redis6479 restart: always logging: driver: 'json-file' options: max-size: '5g' volumes: - .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87f0e747985fb4c8329a96301605df26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19774bd072a1466cbfb6ed2b5ff09949/" rel="bookmark">
			Softmax函数个人解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是Softmax? S o f t m a x = s o f t + m a x Softmax=soft + max Softmax=soft+max，其中 m a x max max就是求最大值的意思，其核心是soft，在英文中soft有软的意思。与之相对应的hardmax，也就是说的在实际中经常求得最大值，如：numpy.max()。
通过上述这个例子，我们不难发现hardmax最大特点就是其求出的最大值是唯一的。因此，在一些特定的应用场景中，这个方法是很不合理的，比如：文本分类，一篇文章可能包含多种主题的信息（即多个类别），我们更期望得到文章属于各个类别的概率值（置信度）。
以下是 Softmax 函数的定义：
S o f t m a x ( z i ) = e z i ∑ c = 1 C e z c Softmax\left(z_i\right)=\frac{e^{z_i}}{\sum_{c=1}^C e^{z_c}} Softmax(zi​)=∑c=1C​ezc​ezi​​
其中== z i z_i zi​为第 i i i个节点的输出值， C C C为输出节点的个数，即类别个数==。通过Softmax函数就可以将多分类问题的输出值转换到区间 [0,1] 和为1的概率分布。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19774bd072a1466cbfb6ed2b5ff09949/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f8bfe345cbf50c3d3a2c507ee5c2a62/" rel="bookmark">
			Scala项目找不到或无法加载主类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1，出错背景2，分析与解决 1，出错背景 Scala项目无法创建scale和Java文件。项目没有报错，但执行时项目总是找不到项目下的类，报错信息如下所示：
错误: 找不到或无法加载主类 com.my.memTestCheck 但该类是存在的.
2，分析与解决 该项目的Models下有多个model，导致加载的时候不知道加载那个项目的。
而且在操作model下的信息时会报错说冲突：
解决办法
1，将其中一个model去掉即可，将model的Dependencies比较少的那个去掉
file-&gt;“Project Strucure”-&gt;Models 下的另一个model去掉。
2，然后在model的依赖中引入Scala的sdk
完成1之后执行的时候还会报错：
Exception in thread "main" java.lang.NoClassDefFoundError: scala/Predef$ 然后在file-&gt;“Project Structure”-&gt;“Modules”-&gt;“Dependencies”
点击‘+’ 选择"2 Library"
点击Scala包，”Add Selected“ 添加进去。
3，在pom文件中设置先编译Scala
通过1，2之后程序基本可以执行，在执行的时候有时候会出现找不到符号的情况，重新rebuild之后就可以执行了但下次执行还会出现这种问题：
尤其是在使用maven打包的时候会报错：
报错：
Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project rt-n-flink: Compilation failure: Compilation failure: /checkDemo.java:[63,9] 找不到符号 符号: 类 test_check_content 在pom文件的build-&gt;plugins下添加plugin：
&lt;plugin&gt; &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt; &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;scala-compile-first&lt;/id&gt; &lt;phase&gt;process-resources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;scala-test-compile&lt;/id&gt; &lt;phase&gt;process-test-resources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;testCompile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;jvmArgs&gt; &lt;jvmArg&gt;-Xms128m&lt;/jvmArg&gt; &lt;jvmArg&gt;-Xmx512m&lt;/jvmArg&gt; &lt;/jvmArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; 指定scala-compile-first 先编译Scala就可以了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f8bfe345cbf50c3d3a2c507ee5c2a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e7a68d153c1b2a4cdbc5353ce69b63b/" rel="bookmark">
			Excel·VBA定量装箱、凑数值金额、组合求和问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图：对图中A-C列数据，根据C列数量按照一定的取值范围，组成一个分组装箱，要求如下：
1，每箱数量最好凑足50，否则为47-56之间；
2，图中每行数据不得拆分；
3，按顺序对分组装箱结果进行编号，如D列中BS0001；
4，生成分组装箱结果（包含B-C列数据），以及单独生成最终无法装箱的数据
目录 实现方法1实现方法2实现方法33种实现方法生成结果、对比、耗时 装箱结果整理编号无序编号有序 本问题本质上是组合求和问题，调用了combin_arr1函数，代码详见《Excel·VBA数组组合函数、组合求和》（如需使用代码需复制）
实现方法1 代码思路：持续不断组合
1，对数据读取为字典，行号为键数量为值；
2，对行号数组从2-N依次进行组合，判断是否符合取值范围；
3，对符合取值范围的行号组合，在res数组对应行号中写入装箱编号，并在字典中删除该行号
4，删除行号后，跳出后续循环遍历，并重复步骤2-3，直至无法删除行号，即没有符合范围的行号组合
5，在D列写入对应的装箱编号
注意：由于步骤4需要跳出循环，所以无法使用for…each遍历组合数组，否则报错该数组被固定或暂时锁定
Sub 装箱问题1() Dim arr, dict As Object, i&amp;, j&amp;, temp_sum, res, w&amp;, dc&amp;, brr, r&amp;, c&amp; target = 50: trr = Array(47, 56) '目标值，范围 Set dict = CreateObject("scripting.dictionary"): tm = Timer With Worksheets("数据") '读取数据 arr = .[a1].CurrentRegion: ReDim res(1 To UBound(arr)): res(1) = "箱号" For i = 2 To UBound(arr) If arr(i, 3) = target Then w = w + 1: res(i) = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e7a68d153c1b2a4cdbc5353ce69b63b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a187bd58e70670b4d431af8dedd9aacd/" rel="bookmark">
			vxe-table 获取滚动高度、还原滚动条位置、展开树形表格
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、场景说明二、代码实现三、关键代码 一、场景说明 点击按钮会打开抽屉，在抽屉内进行某些操作，关闭抽屉后会调接口刷新表格数据。刷新数据后，树形表格全部展开，且滚动条定位到点击按钮时的位置。 二、代码实现 &lt;template&gt; &lt;div class="box"&gt; &lt;vxe-button @click="openDrawer"&gt;新增&lt;/vxe-button&gt; &lt;vxe-table :data="tableData" max-height="400px" class="table" ref="xTable" :tree-config="{ children: 'children', expandAll: true }" &gt; &lt;vxe-column field="name" title="Name" tree-node&gt;&lt;/vxe-column&gt; &lt;vxe-column field="sex" title="Sex"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="age" title="Age"&gt;&lt;/vxe-column&gt; &lt;/vxe-table&gt; &lt;a-drawer title="抽屉" :visible="visible" @close="onClose"&gt; &lt;p&gt;假设进行了一些操作，关闭抽屉后会刷新表格数据。&lt;/p&gt; &lt;p&gt;刷新表格数据后，需要将滚动条定位到打开抽屉前的位置。&lt;/p&gt; &lt;/a-drawer&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { visible: false, tableData: [ { name:'一班', children: [ { id: 10001, name: 'Test1', role: 'Develop', sex: 'Man', age: 28, address: 'test abc' }, { id: 10002, name: 'Test2', role: 'Test', sex: 'Women', age: 22, address: 'Guangzhou' }, { id: 10003, name: 'Test3', role: 'PM', sex: 'Man', age: 32, address: 'Shanghai' }, { id: 10004, name: 'Test4', role: 'Designer', sex: 'Women', age: 24, address: 'Shanghai' }, { id: 10005, name: 'Test5', role: 'Develop', sex: 'Man', age: 28, address: 'test abc' }, { id: 10006, name: 'Test6', role: 'Test', sex: 'Women', age: 22, address: 'Guangzhou' }, { id: 10007, name: 'Test7', role: 'PM', sex: 'Man', age: 32, address: 'Shanghai' }, { id: 10008, name: 'Test8', role: 'Designer', sex: 'Women', age: 24, address: 'Shanghai' } ] }, { name:'二班', children: [ { id: 10009, name: 'Test9', role: 'Develop', sex: 'Man', age: 28, address: 'test abc' }, { id: 10010, name: 'Test10', role: 'Test', sex: 'Women', age: 22, address: 'Guangzhou' }, { id: 10011, name: 'Test11', role: 'PM', sex: 'Man', age: 32, address: 'Shanghai' }, { id: 10012, name: 'Test12', role: 'Designer', sex: 'Women', age: 24, address: 'Shanghai' }, { id: 10013, name: 'Test13', role: 'Develop', sex: 'Man', age: 28, address: 'test abc' }, { id: 10014, name: 'Test14', role: 'Test', sex: 'Women', age: 22, address: 'Guangzhou' }, { id: 10015, name: 'Test15', role: 'PM', sex: 'Man', age: 32, address: 'Shanghai' }, { id: 10016, name: 'Test16', role: 'Designer', sex: 'Women', age: 24, address: 'Shanghai' } ] }, ], scrollHeight: 0 } }, methods: { onClose() { // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a187bd58e70670b4d431af8dedd9aacd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddda038a32c7616520fae3befbf1bd22/" rel="bookmark">
			基于spring session实现session共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景：
通过集成gateway实现单点登录后，各个子系统之间session无法共享
实现方案
使用spring session方案，即把sessionid放入到redis中，session被spring统一管理。
除了网关模块，其他需要session分享的子应用按照如下步骤添加即可。
1.添加依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2.2. 需要session共享的模块启动类添加注解
@EnableRedisHttpSession(flushMode = FlushMode.IMMEDIATE) 示例：
注： 若找不到FlushMode相关参数或类，可以通过提高springboot版本，或者将该参数去掉
注入DefaultCookieSerializer类添加个性化配置； @Bean public DefaultCookieSerializer defaultCookieSerializer() { DefaultCookieSerializer defaultCookieSerializer = new DefaultCookieSerializer(); defaultCookieSerializer.setCookieName("JSESSIONID"); defaultCookieSerializer.setUseBase64Encoding(false); return defaultCookieSerializer; } 如果缺包自行添加一下依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-core&lt;/artifactId&gt; &lt;/dependency&gt; 以上完成集成session共享。
注意：
由于是基于redis做的，所以请保证各个系统连接的redis是一个。
部分步骤说明
在步骤3需要有个性化配置的原因是：
spring session默认使用的cookiename是“SESSION”
需将cookieName修改为与自己项目一致，我这里是修改为了“JSESSIONID”。
然后是useBase64Encoding，这个参数是加密状态设置，默认是true，进行加密，可以根据自己需要进行调整
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df85f7d88d412d4f785a26c74f50b2bd/" rel="bookmark">
			Android Framework 之 SystemServer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android SystemServer SystemServer是Android系统中的一个核心组件，负责启动和管理许多重要的系统服务。它的启动过程相对复杂，包含以下主要步骤：
Zygote启动SystemServer：在Android系统启动过程中，Zygote进程会通过fork操作创建一个新的进程，并在这个新的进程中启动SystemServer。
加载并执行SystemServer的main函数：SystemServer进程启动后，会加载SystemServer类并执行其main函数。这个函数是SystemServer的入口点，它负责启动和初始化各种系统服务。
创建Looper和Handler：SystemServer会创建一个Looper和一个Handler，它们用于在主线程中处理消息和运行任务。Looper是Android事件循环的一部分，负责在主线程中接收和分发消息。Handler则用于发送和处理消息。
启动各种系统服务：在SystemServer的main函数中，会创建并初始化各种系统服务。这些服务包括ActivityManagerService、PackageManagerService、WindowManagerService等。这些服务在SystemServer进程中运行，并通过Binder提供给其他进程使用。
创建系统上下文：SystemServer创建一个系统级别的Context，这个Context是许多系统服务运行的环境。
运行Looper循环：完成上述操作后，SystemServer会启动Looper的消息循环。这个循环会一直运行，处理来自各种系统服务的消息。
SystemServer的启动过程就是这样。它在Android系统中起到了非常重要的作用，管理和提供了许多关键的系统服务。这些服务对Android系统的运行至关重要，它们负责处理用户输入、管理应用程序、控制屏幕显示等等。
系统服务启动的相互依赖 Android 系统中的各种系统服务可能会有相互依赖关系，即某些服务可能依赖于其他服务才能正常工作。为了解决这个问题，Android 在 SystemServer 中使用了一种特殊的启动顺序和机制，下面简单介绍这个过程：
按照固定顺序启动服务：在 SystemServer 的启动过程中，系统服务是按照一个固定的顺序启动的。这个顺序是根据服务之间的依赖关系来确定的，确保某个服务在依赖的服务之后启动。
分阶段启动服务：系统服务的启动过程分为两个阶段。在第一阶段，所有的服务都会被创建和初始化，但不会启动。在第二阶段，所有的服务都会被启动。这样做的好处是，当一个服务在第二阶段启动时，它依赖的其他服务已经被创建和初始化了。
懒加载服务：为了解决服务之间的循环依赖问题，Android 提供了一种名为 “Service Fetcher” 的机制。这个机制允许一个服务在需要时才获取它依赖的其他服务，而不是在启动时就获取。这样，即使两个服务互相依赖，也可以正确地启动。
服务异常处理：如果一个服务在启动过程中发生异常，SystemServer 会捕获这个异常并终止进程。这样做的原因是，一个不能正常启动的系统服务可能会导致整个系统不稳定。
这就是 Android 如何解决系统服务启动的相互依赖问题的。虽然这个机制相对复杂，但是它可以确保所有的系统服务都能正确地启动，使得整个系统可以正常运行。
SystemServer创建并初始化各种系统服务 SystemServer创建并初始化各种系统服务的过程大致如下：
加载并执行SystemServer的main函数：SystemServer进程启动后，首先会加载SystemServer类并执行其main函数。这个函数是SystemServer的入口点。
创建并运行SystemServer的Looper：SystemServer会创建一个Looper对象并调用其loop()方法，以开始处理消息队列中的消息。Looper对象是Android中处理消息循环的核心组件。
创建各种系统服务：SystemServer在其主线程（也就是主Looper线程）中创建各种系统服务，这些服务包括（但不限于）ActivityManagerService、PackageManagerService、WindowManagerService等。创建这些服务通常涉及实例化相应的类并调用其初始化方法。
至于SystemServer如何监听这些服务是否启动成功，具体的方法可能因服务而异，但通常包括以下几种方式：
通过回调函数：某些服务可能会提供一个回调函数，当服务启动成功或失败时，这个回调函数会被调用。
通过异常处理：如果服务在启动过程中抛出了异常，SystemServer会捕获这个异常。根据异常的类型和信息，SystemServer可以判断服务是否启动成功。
通过检查服务的状态：SystemServer可以通过调用服务的方法来检查其状态。例如，SystemServer可能会调用服务的isRunning()方法来检查服务是否正在运行。
请注意，如果一个系统服务启动失败，SystemServer通常会选择终止整个进程，因为一个不能正常工作的系统服务可能会导致整个系统的不稳定。在实际的开发过程中，开发者应该尽量确保系统服务能够正确地启动并运行。
混淆的 SystemServer 、ServiceManager 、SystemServerManager ServiceManager 和 SystemServerManager 在 Android 系统中，ServiceManager 和 SystemServiceManager 是两个不同的概念，它们的职责和功能不同：
ServiceManager：ServiceManager 是 Android 的一个核心组件，它提供了一个全局的服务注册表，用于存储所有已注册的系统服务。ServiceManager 主要用于 IPC（进程间通信），通过它，应用和系统服务可以互相通信。它提供了 addService() 方法来注册服务，以及 getService() 和 checkService() 方法来获取服务。ServiceManager 是系统服务中的一个基础组件，用于管理和调度所有的系统服务。
SystemServiceManager：SystemServiceManager 是一个在 SystemServer 中负责启动和管理系统服务的类。它并不涉及到 IPC，而是用来在 SystemServer 进程中启动和管理各种系统服务。SystemServiceManager 提供了一组 API，用于启动服务、获取服务以及查询服务的状态等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df85f7d88d412d4f785a26c74f50b2bd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/123/">«</a>
	<span class="pagination__item pagination__item--current">124/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/125/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>