<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d44f7e8d09a72ab46429a8a523e0b355/" rel="bookmark">
			云服务器被攻击了怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的发展，很多使用云服务器的网络工作者会发现经常会遭到一些来路不明的网络攻击，由于云服务器没有设置任何有力的防火墙，而当遭遇攻击时，常常导致服务器宕机陷入黑洞，造成业务无法开展而损失大量用户。
那么使用云服务器被攻击要怎么去解决呢。
第一种，更换高防服务器，将业务数据全部搬迁至高防服务器上，由高防服务器上的独有的硬件防火墙对网络攻击进行防护，做到受到攻击也不影响业务的进展。
第二种，接入高防产品，对于大部分人来说，转移数据重新搭建是一件非常复杂和繁琐的一件事，为此随着互联网的发展，诞生出了很多的防护产品，已不用转移数据重新搭建为前提，即可享受到同高防服务器一样的防护能力。
下面我们重点讲讲市场上的高防产品吧。
游戏盾 游戏盾这款产品是专门为了应对游戏行业的网络攻击而诞生的防护产品。随着近几年游戏行业的高速发展，游戏行业是蒸蒸日上，很多从业者都想从其中分一块蛋糕，纷纷跻身进入游戏行业的大潮流中，与此同时同行之间的恶意竞争、不法分子利用网络攻击进行敲诈勒索等等威胁着大量的游戏从业者。
由此在这样的环境中出现了游戏盾这款产品，游戏盾是由高防节点池组成，智能多线节点分布，配合独家研发的VPN隧道填补技术，保证每一条线路都是优质的网络。在遭遇大流量攻击时可智能降流量分摊到其他节点上，使攻击不在对游戏产生影响，有效保障自身的利益和增强玩家的体验感。
高防CDN 高防CDN是专门针对网站的防护产品，如H5 ，基于web的APP，websocket、http、https协议等都是适用的，高防CDN主要以多节点多IP防护为主，将域名解析到CDN独有的别名上，使对外节点显示为CDN的节点IP，完美隐藏服务器IP，接入后，流量首先将经过CDN的节点IP，由节点IP对恶意流量进行清洗，转发正常的访问流量到源机，保障服务器在遭遇攻击时也可安全运行。
并且德迅高防CDN还专门配备有WEB应用防火墙功能，除了能应对日常的DDOS、CC攻击以外，还能帮各位站长预防SQL注入，XSS跨站脚本攻击、扫描漏洞拦截漏洞攻击、后门隔离保护、Webshell上传、非法HTTP协议请求、代码审计等。
高防IP 高防IP即可保护网站又可以保护游戏，接入高防IP后会隐藏掉服务器IP的，对外查询到的IP为高防IP，流量先经过高防IP，通过端口转发协议转发回服务器上，同时会对恶意流量进行清洗过滤，只转发正常的访问流量，确保业务在遭遇网络攻击时能安全稳定的运行。
在业务配置方面非WEB业务需要将对外的业务IP修改成高防IP，WEB业务需要将域名解析到高防IP上，并且在高防IP服务提供商后台设置转发规则（服务器IP和端口），这样用户访问就是先经由高防IP然后转发回服务器上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0dc866a8dfbc4c9f12e37587603577d/" rel="bookmark">
			扬州晶澳-年产3GW高性能太阳能光伏组件项目 Acrel-3000WEB电能管理系统的设计及应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要：在信息时代，电力信息系统的应用促迚了电力企业的収展，增强了电力系统运行的安全性与稳定性，对满足用户需求其有重要意义。随着国家电网改革政策的逐步推进和落实，Acrel-3000WEB电能管理系统运用互联网和大数据技术，为电力运维公司和售配电公司提供变电所运维云平台。该平台基于WEB开发，使用云平台，手机APP作为连接运维单位和用电企业的纽带，全方位的实时监视用户配电系统的运行状态和电量数据，为用户提供更好的运维服务。平台提供用户概况、电力数据监测、电能质量分析、用电分析、日/月/年用能数据报表、异常事件报警和记录、运行环境监测、运维派单等功能，并支持多平台、多终端数据访问。
关键词：电能管理系统；扬州晶澳；配电室监测系统；通讯管理机。
1 引言
2015年国务院发布《中共中央、国务院关于进一步深化电力体制改革的若干意见》（中发[2015]9号），简称“电改9号文”。而本次新电改的重点是“三放开一独立三强化”：输配以外的经营性电价放开、售电业务放开、配电业务放开、公益性和调节性以外的发供电计划放开，交易平台独立。本次电改将有利于还原电力的商品属性，实现电力交易市场化，从而激发电力企业的市场活力，重塑电力工业价值链，并将带动售电、运维、用能管理、新能源接入等业务的发展。
安科瑞电气股份有限公司Acrel-3000WEB电能管理系统正是基于这样的背景而研发，为电力运维公司和售配电公司提供与用户变电所连接互动的平台，便于运维和售电公司为用户提供更好的服务。
2 设计依据
本平台遵循以下标准开发：
DL/T 5430-2009 《无人值班变电站远方监控中心设计技术规程》
GB/T 2887-2011 《计算机场地通用规范》
Q/GDW 231-2008 《无人值守变电站及监控 中心技术导则》
GB/T 32893-2016 10kV及以上电力用户变电站运行管理规范
Q/GDW11 浙江省电力公司企业标准 变电站运维管理规范
GB/T 13462-2008电力变压器经济运行
GB/T 19862-2005电能质量监测设备通用要求
GB/T 14549-93 电能质量-公用电网谐波
GB/T 23331-2009 能源管理体系要求
GB/T 15316-2009 节能检测技术通则
GB/T 17166 企业能源审计技术通则
GB/T 15587-2008 工业企业能源管理导则 3 项目概况
扬州晶澳-年产3GW高性能太阳能光伏组件项目，位于江苏省扬州市邗江区经济技术开发区建华路 1 号。其建设一套安科瑞Acrel-3000WEB电能管理系统，实现对配电室电气参数、开关状态、变压器温度、线缆温度24小时不间断监视，并可以通过APP系统进行实时预警。
系统采用Acrel-3000WEB电能管理系统，服务器位于本地110kV变电站监控中心，变电所现场设置数据采集箱，通过内部网络到运维平台服务器。现场所有配电回路均配备多功能仪温湿度检测、门状态监测、视频监控等。
4 系统架构
Acrel-3000WEB电能管理系统采用分层分布式结构进行设计，整体架构如下：
系统结构图
如系统结构图所示：运维云平台包含站控管理层（运维软件）及网络通讯层（变电所数据网关），现场安装多功能电力仪表及无线测温系统。
多功能电能表ACR220EL
ACR 电力质量分析仪包含 ACR220ELH 仪表,是本公司按 IEC 标准设计，与国际先进技术同步的综合电力监控。该产品具有全面的三相交流电量测量、复费率电能计量、四象限电能计量、谐波分析、电网质量分析、遥信输入、遥控输出以及网络通讯等功能，其中 ACR220ELH/ACR330ELH 同时还具有电网波形实时跟踪显示和 SOE 事件记录功能，主要用于对电网供电质量的综合监控诊断及电能管理。
多功能电能表
无线测温设备
无线温度传感器适用于高低压开关柜内电缆接头、断路器触头、刀闸开关、高压电缆中间头、干式变压器、低压大电流等设备的温度监测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0dc866a8dfbc4c9f12e37587603577d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e574da8253098300b60c22654ee0441/" rel="bookmark">
			亲测可用|亚信防毒墙网络版卸载图文教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		许多大公司（尤其是央企）都统一安装亚信防毒墙网络版，但亚信在使用中非常不友好，功能差、内存占比高，每个人都有干掉它的冲动，但卸载亚信防毒墙网络版需要本地管理员密码，多数人面对亚信防毒墙网络版只能望洋兴叹。哪么，有没有办法不需要密码就可以卸载亚信防毒墙网络版的方法呢？
答案是肯定的。下面就来介绍采用删除注册表项来卸载亚信防毒墙网络版的方法（以64位操作系统的客户端卸载为例）。
1. 打开注册表编辑器
开始-运行，输入regedit回车即可
2. 找到Allow Unistall的值
依此路径HKEY_LOCAL_MACHINE/SOFTWARE/TrendMicro/ PC-cillinNTCorp/CurrentVersion/Misc定位Allow Unistall
3. 将Allow Unistall的键值改为1
4. 运行卸载程序或软件管家卸载亚信杀毒
具体操作步骤如下：
STEP1:
点击开始---运行, 输入regedit
STEP2:
按以下路径找到注册表Allow Unistall
\HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\TrendMicro\PC- cillinNTCorp\CurrentVersion\Misc---------【Allow Unistall】
STEP3:
将Allow Unistall 的键值由0 改为1 。
STEP4:
利用软件管家或卸载程序卸载亚信防毒墙网络版，卸载时会收集用户信息，搜集时间大概5分钟，需耐心等待。
大家快去试试吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c96af85cc77bdfcadef5c30e22bc6309/" rel="bookmark">
			仿苹果官网首页面（Hbuilder X&#43;CSS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录我的成长过程，仿苹果官网，学HTML的第四天。完成老师布置的作业敲一个苹果官网。
文章目录 一、代码二、代码解释 一、代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Apple（中国大陆）- 官方网站&lt;/title&gt; &lt;/head&gt; &lt;style type="text/css"&gt; .A { border: 1px white solid; width: 100%; height: 40px; text-align: center; padding-top: 130px; background-color: darkgray; background-color: rgba(0, 0, 0, 0.06); } .B { border: 1px white solid; width: 100%; height: 780px; text-align: center; background-color: rgba(251, 251, 253) } .B1 { margin-top: 100px; font-size: 64px; } .B2 { margin-top: 10px; } .B3 { margin-top: 10px; } a:link { text-decoration: none; } a:visited { color: blue; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c96af85cc77bdfcadef5c30e22bc6309/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bee0f53e09810c15c38494d4c33f8a63/" rel="bookmark">
			【重识云原生】第2.5节——商用云主机方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节内容《【重识云原生】第2.4节——主流虚拟化技术之KVM》
三、商用云主机解决方案 在大规模商用云主机解决方案中，目前头部厂商大部分是基于KVM来实现各自云主机的虚拟化方案。不过虚拟化技术如果要大规模商用，仅有KVM还不够。上述ESXi、Xen、KVM等虚拟化技术方案，均聚焦于单宿主机级别的资源虚拟化实现，而面向整个数据中心规模的大型计算资源的虚拟化，除了解决单宿主机虚拟化问题，还需要大型分布式资源调度系统来真正实现计算资源的全局调度、部署交付、运维管控。云计算行业经过年发展，确实也先后产生了多种分布式调度实现方案，比较知名的有 Hadoop YARN、Mesos、阿里伏羲、Google Borg、Kubernetes等。
3.1 调度系统架构演进简述 Google 和 UC Berkeley 提出的调度系统的架构演进分类，分为统一调度架构、两级调度架构和共享状态调度架构。
三类调度架构 1. 统一调度架构
如上图所示，左侧的架构即为统一调度架构，下方是集群的宿主机；中间是集群状态信息，用于保存宿主机的资源状态；上方是统一的调度器，负责接收调度请求，并在集群状态信息的基础上进行调度决策。许多调度系统最初都被设计为这种架构，例如第一代 Hadoop MapReduce。
这种架构，设计简单，可以便捷的保持资源数据一致性，但是当宿主机规模增大时，调度器处理单次资源调度请求的时间会开始增加。当资源调度请求增大到一定程度时，调度器的吞吐量不足，调度请求开始排队，造成任务阻塞积压。
2. 两级调度架构
两级调度系统，其典型代表是 Mesos。Mesos Master 通过 Resource Offer 的形式和上层 Framework 的调度器进行资源通信。在灵活性上和并发性上有了一定的改善。但是仍然存在局限性。
缺乏全局资源视图。上层调度器只能在分配给它的 Resource Offer 的范围内进行调度，相当于只有子集资源视图，没有全局资源视图，无法保证调度决策全局最优。特别是在需要抢占的情况下，无法实现跨调度器抢占，例如公有云中竞价实例的场景。
并发度仍然受限，Resource Offer 机制本质上是在不同的 Framework 之间进行串行轮询，相当于悲观加锁并发控制，并发度仍然有提升空间。
和 Mesos 同时期的 Hadoop YARN 是另一款著名的分布式调度系统，其类型划分一直存在争议。Hadoop YARN 的支持者[3]表示 YARN 是一款两级调度系统，而 Google 系的研究成果则通常认为 YARN 属于统一调度架构。我们更加认同 Google 的看法，认为 YARN 属于统一调度架构。
统一调度、两级调度、共享调度是 Omega 提出的分类方法，这里的调度是指为任务分配资源，而不是处理任务间的关系。在这个前提下，Hadoop YARN 的调度过程是由 Resource Manager 完成的，而 Application Master 主要负责任务间关系的管理工作，并未实际参与调度过程。因此，Hadoop YARN 属于统一调度架构。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bee0f53e09810c15c38494d4c33f8a63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f327d276969abe81418247d60abf3769/" rel="bookmark">
			CentOS8最新镜像
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CentOS 8 （非 Stream 版）已提前进入 EOL 停止服务阶段，因此镜像已被官方移动。如果您正在寻找关于这些系统的镜像，请参考 centos-vault 的帮助。
Index of /centos/8-stream/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
将/etc/yum.repos.d/下的源文件中的URL替换成更新源的地址 如CentOS-Linux-BaseOS.repo中, URL替换为https://mirrors.tuna.tsinghua.edu.cn/centos/8-stream/BaseOS/x86_64/os/XXXXXXXXX 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/883a98a0ab7e00621d719415c901ecd1/" rel="bookmark">
			以太坊Dapp 编译脚本 &#43; 部署脚本 &#43; 测试脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
目录结构
创建包管理
安装依赖
编译脚本
安装依赖
准备合约源码
准备编译脚本
执行编译脚本
部署脚本 安装依赖
准备部署脚本
执行部署脚本 测试脚本
安装依赖
准备测试脚本
执行测试脚本
测试例子
测试脚本
执行测试脚本 将以上工作流步骤串起来
修改 package.json 执行命令
目录结构 手动创建 contract_workflow 文件夹
并在其目录下创建 compiled、contracts、scripts、test 四个文件夹
contracts 存放源代码scripts 存放编译脚本compiled 存放编译结果test 存放测试文件 创建包管理 在 contract_workflow 目录下，执行以下命令
会生成 package.json 文件
npm init 安装依赖 在 contract_workflow 路径下，执行以下命令
安装ganache-cli，附加生成 node_modules 和 package-lock.json 文件
npm install ganache-cli@6.1.8 --save-dev ganache-cli 仅仅用作测试用，每一次重新运行都会重新生成10个新的账号
运行 ganache-cli 后面用作测试用
./node_modules/.bin/ganache-cli 编译脚本 安装依赖 在 contract_workflow 路径下，执行以下命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/883a98a0ab7e00621d719415c901ecd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc5cd701ee509fafec6eb48160d3bd5f/" rel="bookmark">
			Hadoop的datanode没有启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		千万别多次格式化hadoop，因为datanode的id只有是第一次生成的，不会和namenodeid同步
datanode启动失败，直接无法上传文件到hdfs中
解决方法：
查看hdfs-site.xml文件
cd /usr/loca/hadoop/etc/hadoop
查看上面两个文件夹
可以查看namenode和datanode的集群id
比如查看namenode
只要查看到current/VERSION就可以查看到
都是查看VERSION
上图是datanode
现在是进入datanode的版本中clusterID改成namenode的clusterID
之后关掉hdfs
然后重新启动
有datanode了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89577804e3dbdc76dac3215dda5da90c/" rel="bookmark">
			Perfetto —— 靠谱的trace利器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近踩到的坑，报了一个cst的测试项fail，帧率不符合预期，对应的测项进程是android.view.cts
肯定是要抓sytrace看看了
但是，试了systrace和atrace去抓，只抓了launcher的绘制，并没有android.view.cts的绘制信息
用-a指定app也是一样
经过实验，可以试下perfetto抓取（果然，google极力推荐使用还是没错的，要跟上工具的变化）
1、开启trace UI
am start com.android.traceur/com.android.traceur.MainActivity
需要开启开发者模式的，不然会打开闪退，因为对应的IAtrceService没有启动
settings put global development_settings_enabled 1
2、开启record trace,即可开始录制
3、复现场景
4、再次启动trace UI,关闭record trace
5、获取trace文件
/data/local/traces/
6、打开Perfetto UI ，加载trace文件分析
可以抓到cts的测项trace了
也可使用open with legacy UI，使用传统的systrace UI去分析trace，只是大小有限制，试过一百多M就直接报error，而perfetto仍然可以打开
备注：也可以用命令去抓，参考perfetto | Android 开发者 | Android Developers (google.cn)，就是麻烦了点
Perfetto:
开启traced|traced_peobes进程
setprop persist.traced.enable 1
ps -ef | grep -E "traced|traced_peobes"
perfetto -o /data/misc/perfetto-traces/trace_log -t 120s -b 100mb -s 150mb sched freq idle am wm gfx view input
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89577804e3dbdc76dac3215dda5da90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88d36f68a98e856a9610a1b22d0fba8/" rel="bookmark">
			【牛客网 - 华为机试 - HJ22 汽水瓶】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		描述 某商店规定：三个空汽水瓶可以换一瓶汽水，允许向老板借空汽水瓶（但是必须要归还）。
小张手上有n个空汽水瓶，她想知道自己最多可以喝到多少瓶汽水。
数据范围：输入的正整数满足 注意：本题存在多组输入。输入的 0 表示输入结束，并不用输出结果。
输入描述： 输入文件最多包含 10 组测试数据，每个数据占一行，仅包含一个正整数 n（ ），表示小张手上的空汽水瓶数。n=0 表示输入结束，你的程序不应当处理这一行。
输出描述： 对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。
思路： 观察发现最多可以喝的瓶子数是：手上瓶子数与2相除取整
step1:输入手上瓶子数；
step2:如果手上数量为0，直接break；
输出手上瓶子数与2相除取整的结果
代码如下： while True: try: n = int(input()) if n == 0: break print(n//2) except: break 题解 | #汽水瓶#_牛客博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4854106ca2d07009b182a56f4e1da54f/" rel="bookmark">
			HTTP状态 500 - 内部服务器错误java.lang.NullPointerException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个错误主要是因为在导入别人的项目的时候没有把jar包成功添加到Artifacts中，我是把jar包添加到Artifacts中就可以解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b92eb141be6dd09140a450ba4f1f297b/" rel="bookmark">
			Neo4j的两种方式访问（嵌入式访问、服务器模式访问）-- java客户端连接和SpringBoot整合Neo4j
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Neo4j数据库访问 1、Neo4j数据库访问 嵌入式数据库服务器模式(通过REST的访问) 它是由应用程序的性质（neo4j是独立服务器 还是和程序在一起),性能，监控和数据安全性来决定架构选择。
2、An embedded database（嵌入式数据库） 嵌入式Neo4j数据库是性能的最佳选择。 通过指定数据存储的路径以编程方式访问嵌入式数据库。我们选择嵌入式数据库出于以下原因：
使用Java作为我们项目的编程语言时
应用程序是独立的程序追求很高的性能 3、Neo4j Server（服务器模式） Neo4j Server是相互操作性，安全性和监控的最佳选择。 实际上，REST接口允许所有现代平台和编程语言与它进行互操作。 此外，作为独立应用程序，它比嵌入式配置更安全（客户端中的潜在故障不会影响服务器），并且更易于监控。 如果我们选择使用这种模式，我们的应用程序将充当Neo4j服务器的客户端。要连接到Neo4j服务器，可以使用任何编程语言的REST 访问数据库。
二、Java客户端操作Neo4j 1、嵌入式模式 &lt;dependency&gt; &lt;groupId&gt;org.neo4j&lt;/groupId&gt; &lt;artifactId&gt;neo4j&lt;/artifactId&gt; &lt;version&gt;3.5.5&lt;/version&gt; &lt;/dependency&gt; public class EmbeddedNeo4jAdd { private static final File databaseDirectory = new File( "target/graph.db" ); public static void main(String[] args) { GraphDatabaseService graphDb = new GraphDatabaseFactory().newEmbeddedDatabase(databaseDirectory); System.out.println("Database Load!"); Transaction tx = graphDb.beginTx(); Node n1 = graphDb.createNode(); n1.setProperty("name", "张三"); n1.setProperty("character", "A"); n1.setProperty("gender",1); n1.setProperty("money", 1101); n1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b92eb141be6dd09140a450ba4f1f297b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/575ef8d95739991dd15276aae386988a/" rel="bookmark">
			vscode配置保姆级教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode配置使用文档 vscode基本配置关于vscode为什么要用vscode基本配置下载插件安装创建项目 高级配置命令行插件关于插件的设置 插件推荐关于编码对于c语言开发者在远程服务器上开发代码显示漂亮的代码关于如何高亮你是否老少括号找半天？你是否写了函数不想写注释？SVN函数中文命名插件 关于同步FAQ关于插件安装关于远程服务器连接报错 vscode基本配置 关于vscode Visual Studio Code (简称 VS Code / VSC) 是一款免费开源的现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux
为什么要用vscode 目前主流的代码编辑器有Vim，Notepad++，Visual Studio Code，Atom， Sublime Text，source insight。vim学习曲线陡峭，对新人不友好，Atom作为后起之秀，也算优秀，但也存在bug以及插件兼容性问题。Sublime Text固然很好，但是收费。接下来就是霸占程序员界多年，至今还被称神的source insight，这个东西对于工程量庞大的项目代码，有一个非常大的优势，就是检索很快。本人作为新人时，刚开始用的也是vscode，但是发现检索要等“一年”，后面看大家都在用，就下载了source insight，当时惊为天人，居然能这么快！久而久之，问题也会被发现，就是这玩意虽然快，但一个项目就要去创建项目，而且功能不能定制化，导致有些时候，我只想看某个项目一部分功能的时候，还是用直接用vscode打开。当我有一天从某站刷到关于vscode配置的时候，我看了一下，于是还是被这种主流的炫酷界面吸引了，想着能不能搜一下，有什么方法减少vscode的短板，一百度，新世界的大门由此打开，一种叫做插件的东西，可以做任何你能想到的事情。
符合主流简洁明了支持各种扩展能解决检索慢的唯一短板 还有什么理由拒绝！！！
基本配置 下载 微软官网 https://code.visualstudio.com/.
直接下载安装即可，安装完成后应该全英文的。
插件安装 首先就是进行插件安装，安装中文插件，请在如下界面搜索chinese
创建项目 创建项目？，根本不需要创建项目，只需要下载你的工程代码到本地，然后文件 - 打开文件夹 就ok啦！
![(https://img-blog.csdnimg.cn/59148cd35e5144bd96302a53e384fad0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbG9ibW8=,size_20,color_FFFFFF,t_70,g_se,x_16)
学会以上这些，基本就可以来敲代码了。
高级配置 面对庞大的项目代码时，以上的基础功能往往是不够用的。下面介绍一下进阶配置！
命令行 1.vscode自带一个命令行，通过 Ctrl +Shift +P 调出，里面可以搜索任何能在vscode找到的设置项以及功能，可以快速调出。比如将变量切换大小写，包括后面讲到的插件的一些功能也要用vscode调出。
2.另外还有一个和目前正在编辑的相关的命令行，通过 Ctrl +P 调出，里面直接敲 **“ :”**然后出入行号，可以跳转，使用 “@” +关键字 检索当前文件的函数以及变量 “#”****+关键字 检索当前项目的函数。
插件 讲到这里，最重要的环节来了，插件几乎是vscode的灵魂。
点击插件，搜索你想用的插件，然后点击安装即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/575ef8d95739991dd15276aae386988a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60b071fd4728d9fc75ad451794beac4b/" rel="bookmark">
			Vuex中的state,mapState,...mapState
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.state state是什么?
定义:state(vuex) ≈ data (vue)
vuex的state和vue的data有很多相似之处,都是用于存储一些数据,或者说状态值.这些值都将被挂载 数据和dom的双向绑定事件,也就是当你改变值的时候可以触发dom的更新.
虽然state和data有很多相似之处,但state在使用的时候一般被挂载到子组件的computed计算属性上,这样有利于state的值发生改变的时候及时响应给子组件.如果你用data去接收$store.state,当然可以接收到值,但由于这只是一个简单的赋值操作,因此state中的状态改变的时候不能被vue中的data监听到,当然你也可以通过watch $store去解决这个问题,那你可以针是一个杠精
综上所述,请用computed去接收state,如下
//state.js let state = { count: 1, name: 'dkr', sex: '男', from: 'china' } export default state &lt;template&gt; &lt;div id="example"&gt; &lt;button @click="decrement"&gt;-&lt;/button&gt; { {count}} { {dataCount}} &lt;button @click="increment"&gt;+&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { dataCount: this.$store.state.count //用data接收 } }, computed:{ count(){ return this.$store.state.count //用computed接收 } } methods: { increment () { this.$store.commit('increment') }, decrement () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60b071fd4728d9fc75ad451794beac4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c6cd26f5120a57ca5313141a0b03016/" rel="bookmark">
			verilog 文本自动对齐：input output wire reg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、之前有个脚本可以对齐input和output，但是没有解决wire和reg定义不对齐的问题。所以脚本改进了下，支持input output wire reg对齐
2、知识点总结：perl的字符串进行比较时需要使用eq，lt，gt，不能使用数字比较符==，&gt;=，否则会出现逻辑错误。
#! /usr/bin/perl use 5.010; use strict; my ($sec,$min,$hour,$day,$mon,$year,$weekday,$yeardate,$savinglightday) = (localtime(time)); $sec = ($sec &lt; 10)? "0$sec":$sec; $min = ($min &lt; 10)? "0$min":$min; $hour = ($hour &lt; 10)? "0$hour":$hour; $day = ($day &lt; 10)? "0$day":$day; $mon = ($mon &lt; 9)? "0".($mon+1):($mon+1); $year += 1900; my $date = "${mon}${day}"; my $dir = '*.v'; my @all_files = glob($dir); foreach my $file_name (@all_files){ open my $file_text,'&lt;',"$file_name"; my $file_name_store = $file_name; open my $new_file,'&gt;',"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c6cd26f5120a57ca5313141a0b03016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8078bbc8381c40337ec8255142e7116b/" rel="bookmark">
			数组根据对象id去重的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		arr = [ { id: 1, name: '张一', age: 20 }, { id: 1, name: '张一', age: 20 }, { id: 2, name: '张二', age: 20 }, { id: 3, name: '张三', age: 20 }, ]; 方法一 通过forEach再通过some方法判断数组是否包含当前对象id，不包含则添加
some() { let some: any = []; this.arr.forEach(el =&gt; { if (!some.some(e =&gt; e.id == el.id)) { some.push(el); } }); console.log('%c [ some去重结果 ]-43', 'font-size:13px; background:pink; color:#bf2c9f;', some); } 方法二 通过forEach再通过find方法判断数组是否包含当前对象id，不包含则添加
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8078bbc8381c40337ec8255142e7116b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65a4875c29a584635d966bdf5f121b4a/" rel="bookmark">
			夜间灯光数据（npp/viirs）网格化处理全过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、准备遥感数据：下载的是2017年月度数据，共12组。
下载地址：科罗拉多矿业大学地球观测组(EOG) 网址：VIIRS Nighttime Light (mines.edu)https://eogdata.mines.edu/products/vnl/
2、准备矢量数据：使用的是南京主城区
下载地址：1）根据所需下载 .json格式DataV.GeoAtlas地理小工具系列 (aliyun.com)http://datav.aliyun.com/portal/school/atlas/area_selector
2）转化为shpmapshaperhttps://mapshaper.org/
3)使用工具箱：合并， 将各个区域合并成一个shp
3、按掩膜提取：裁剪夜光数据，(最好保存在数据库中.gbd ，可以避免数据存储不了问题)
4、重投影：投影栅格，将地理坐标系转化为投影坐标系（此处选择的是Albers等面积投影），可以为重采样做铺垫，方便改空间分辨率。
5、重采样：将空间分辨率改为500*500 ， 重复4-5步骤处理完12个月的数据
6、栅格计算器： 遥感数据叠加获取平均值
7、栅格转点：插值需要转化为点
8、插值分析：作用是补充未采集到的缺失点数据；主意Z值的选择，此处选择的是IDW反距离权重法
10、创建渔网：像元宽高0.005表示分辨率500*500，几何类型选择面PLOYGON
11、按位置选择：裁剪渔网.面
11.1 发现裁剪无效
11.2 换种方法裁剪，按位置选择
12、裁剪：裁剪渔网点point
13、多值提取至点：经过插值的像素点值提取到了栅格点
14、连接：面关联点，提取值
15、符号化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56276e3b40dbddecda2e2cbdf3afdfbb/" rel="bookmark">
			js onclick 传递字符串类型的参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、规则 碰到嵌套的时候才会同时用两种引号，规则是外层如果是单引号，内层就是双引号，如果想要在引号内引用变量，则需要跟外层的符号一致。如果外层使用的是单引号，那么内层的双引号就自动转译会被识别为引号。因为外层是单引号，内层的双引号可以直接识别成引号，不需要转移字符“/”（比如：'你好，“js” ’ ,我们可以直接知道他想表达的是：你好，“js” ，如果用相同的引号就会有歧义：比如：'你好，‘js’ ‘，这个就可以理解成很多种意思：你好，js’ ；你好，'js；你好，‘js’ ），因此内外层一样时，需要转译字符，'你好，‘js’ ’ 。这样子还是只有一种意思：你好，‘js’ 。
总之，如果外层用单引号，内层用双引号，这个双引号包裹的内容会被看成一个整体，不需要转译；如果外层使用单引号内层也使用单引号，那么需要转义字符加以区分。 二、例子 (一) onclick 事件函数传入字符串参数，引发的not defined 问题 简单的代码 &lt;span id="test"&gt;&lt;/span&gt; &lt;script th:inline="javascript"&gt; $(function() { var id=1; var tile = "java"; $('#test').html("&lt;a class='btn btn-default btn-xs' href='javascript:void(0)' οnclick='goTaskDetail(" +id + ","+tile+")'&gt;&lt;i class='fa fa-search'&gt;&lt;/i&gt;任务详情&lt;/a&gt; ") }); /* 任务详情*/ function goTaskDetail(taskId,taskTitle) { console.log(taskId+taskTitle) } &lt;/script&gt; 引发的问题
点击后发现会报错，说java这个变量没有定义，我们本意是传入“java”字符串，但是浏览器解析成了java这个变量，所以会报错。
查看元素，发现
解决： // 改成下面的格式 $('#test').html("&lt;a class='btn btn-default btn-xs' href='javascript:void(0)' οnclick='goTaskDetail(\"" +id + "\",\""+tile+" \")'&gt;&lt;i class='fa fa-search'&gt;&lt;/i&gt;任务详情&lt;/a&gt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56276e3b40dbddecda2e2cbdf3afdfbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/268fea8c6784547f344c54bae6868c7a/" rel="bookmark">
			二层主机通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二层主机通信
主机p1向主机p2通信，首先会查看自己的arp缓存，
（1）没有arp缓存 ： p1会广播arp请求，p2收到会单播回复mac地址，同时p2也会保存p1的mac地址到自己的arp缓存，p1收到p2的arp回复后，把p2的mac地址写到自己的arp缓存，并封装成帧转发给交换机，
（2）有arp缓存，也就是arp缓存中有p2的mac地址，则p1把自己要发的数据封装成帧，帧的格式为（目的mac地址，源mac地址，目的ip地址，源ip地址 数据），帧到交换机后，交换机会检查p1的mac地址表中有没有目的mac地址，有的话，交换机单播把帧转发给p2， 如果没有，交换机会广播arp请求，p2收到请求会把自己的mac地址发给交换机，交换机储存p2的mac到自己的arp缓存，然后发帧到p2.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40e7220235592c8f42f478348b65ab12/" rel="bookmark">
			管道channel的关闭和遍历以及死锁的产生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内建函数close关闭信道，该通道必须为双向的或只发送的。
它应当只由发送者执行，而不应由接收者执行，其效果是在最后发送的值被接收后停止该通道。
在最后的值从已关闭的信道中被接收后，任何对其的接收操作都会无阻塞的成功。对于已关闭的信道，
语句∶
x , ok := &lt;-c
还会将ok置为false
channel支持for-range的方式进行遍历，请注意两个细节
1.在遍历的时候，如果channel没有关闭，则会出现deadlock的错误。
2.在遍历的时候，如果channel已经关闭，则会正常遍历数据，遍历完后会退出遍历。
package main import( "fmt" ) // 内建函数close关闭信道，该通道必须为双向的或只发送的。 // 它应当只由发送者执行，而不应由接收者执行，其效果是在最后发送的值被接收后停止该通道。 // 在最后的值从已关闭的信道中被接收后，任何对其的接收操作都会无阻塞的成功。对于已关闭的信道， // 语句∶ // x , ok := &lt;-c // 还会将ok置为false //channel支持for-range的方式进行遍历，请注意两个细节 //1.在遍历的时候，如果channel没有关闭，则会出现deadlock的错误。 //2.在遍历的时候，如果channel已经关闭，则会正常遍历数据，遍历完后会退出遍历。 //遍历管道案例 func main(){ intChan2 :=make(chan int,100) //这个是因为:=操作符导致的，:=不能用于声明全局变量！只能在函数内部使用。 //:=只用来声明临时变量, 初始化全局变量需使用var关键字，正确操作如下： for i := 0;i &lt; 100;i++ { intChan2 &lt;- i * 2 } //遍历管道的时候，不能使用普通的for循环结构 //比如使用for i:= 0;i &lt; len(intChan2);i++{ } 会失败 //前提是会把管道关闭，当取完的时候会及时的停止。 //在遍历的时候，如果channel没有关闭，则会出现deadlock的错误。 close(intChan2) for v := range intChan2{ fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40e7220235592c8f42f478348b65ab12/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/257/">«</a>
	<span class="pagination__item pagination__item--current">258/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/259/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>