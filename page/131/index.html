<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe768f1a4e60fe7d7df5f18a8f57abaf/" rel="bookmark">
			Tomcat出现validateJarFile-jar not loaded问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目依赖的jar包和tomcat容器的依赖jar包有重复，一般为servlet-api.jar、jsp-api.jar
解决方式：
如果是非maven项目，在/WEB-INF/lib中找出servlet-api.jar、jsp-api.jar删除
如果是maven项目就把pom.xml中的servlet依赖注释掉。
因为我是非maven项目。
不能一股脑把右侧项目库拉入左侧lib中（我就是），导致与tomcat中的包冲突。 库里面我配置了tomcat jsp -api.jar与servlet-api.jar。
pom
&lt;!-- 添加servlet3.0核心包 --&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; 注意此处要限定servlet-api的运行范围，不然会和tomcat插件冲突 &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.2-b01&lt;/version&gt; &lt;/dependency&gt; jstl &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; --&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9752059cd980d4f7170c3715f4b076dc/" rel="bookmark">
			Cesium加载各影像底图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. Cesium加载天地图 天地图官网给的文档网址是错误的，加载不出来，要以下网址才是对的
加载矢量底图 new Cesium.WebMapTileServiceImageryProvider({ url: "http://t{s}.tianditu.gov.cn/vec_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=vec&amp;tileMatrixSet=w&amp;TileMatrix={TileMatrix}&amp;TileRow={TileRow}&amp;TileCol={TileCol}&amp;style=default&amp;format=tiles&amp;tk=替换成你的token", subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'], layer: "tdtImgLayer", style: "default", format: "image/jpeg", tileMatrixSetID: "GoogleMapsCompatible" }) 加载矢量标注 new Cesium.WebMapTileServiceImageryProvider({ url: "http://t{s}.tianditu.com/cva_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=cva&amp;tileMatrixSet=w&amp;TileMatrix={TileMatrix}&amp;TileRow={TileRow}&amp;TileCol={TileCol}&amp;style=default&amp;format=tiles&amp;tk=替换成你的token", subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'], layer: "tdtAnnoLayer", style: "default", format: "image/jpeg", tileMatrixSetID: "GoogleMapsCompatible", maximumLevel: 18 }) 加载影像底图 http://t{s}.tianditu.com/img_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=img&amp;tileMatrixSet=w&amp;TileMatrix={TileMatrix}&amp;TileRow={TileRow}&amp;TileCol={TileCol}&amp;style=default&amp;format=tiles&amp;tk=替换成你的token 加载影像标注 http://t{s}.tianditu.com/cia_w/wmts?service=wmts&amp;request=GetTile&amp;version=1.0.0&amp;LAYER=cia&amp;tileMatrixSet=w&amp;TileMatrix={TileMatrix}&amp;TileRow={TileRow}&amp;TileCol={TileCol}&amp;style=default&amp;tk=替换成你的token 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58ae62d74101a2f0751c5a07116e63cb/" rel="bookmark">
			18、气象学中风场的绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、批量读取数据二、绘制2022年的平均风场三、绘制每个季节的平均风场四、绘制每个月的风场 前言 数据及代码下载链接➡️：如何绘制自定义颜色的风场图
一、批量读取数据 import os import xarray as xr folder_path = "./" file_pattern = os.path.join(folder_path, "*.nc") try: ds = xr.open_mfdataset(file_pattern) u10 = ds["u10"] v10 = ds["v10"] ds.close() except Exception as e: print(f"读取文件时出现错误：{str(e)}") 二、绘制2022年的平均风场 import xarray as xr import numpy as np import pandas as pd import matplotlib as mpl import matplotlib.pyplot as plt import cartopy.crs as ccrs import cartopy.feature as cfeature from matplotlib.offsetbox import AnchoredText from matplotlib.colors import ListedColormap import cmaps import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58ae62d74101a2f0751c5a07116e63cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/129ee25044cb0dfe9c582d265c3f0e60/" rel="bookmark">
			ES6~ES13新特性（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 ECMA新描述概念
2 let、const的使用
3 let、const和var区别
4 块级作用域的使用
5 模板字符串的详解
6 ES6函数的增强用法
一个执行上下文关联两个环境。词法环境和变量环境。
词法环境是由let和const创建；变量环境是由var创建的。
let-const的基本使用、不能重复声明变量 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; // ES6之前 var message1 = "Hello World" message1 = "Hello Coderwhy" message1 = "aaaaa" console.log(message1) // ES6开始 // 1.let let message2 = "你好, 世界" message2 = "你好, why" message2 = 123 console.log(message2) // 2.const // const message3 = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/129ee25044cb0dfe9c582d265c3f0e60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e6e29ceac025267584e522e1b4d097/" rel="bookmark">
			右键pdf文件没有打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 右键点pdf文件，弹出的菜单找不到打印选项。网上找了很多办法，然并卵啊。还是得靠自己慢慢摸索。
原因分析 新安装的win11系统，pdf文件默认可以用windows自带的edge浏览器打开。但是edge浏览器没有能力提供右键打印功能。
解决办法 1、安装Adobe Acrobat DC 2023（其他版本应该也可以，博主刚上拼多多买了一个2023版本的，就用这个解决问题了）
2、右键点pdf文件的属性--&gt;更改--&gt;选择新安装的Adobe Acrobat
3、至此，问题成功解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6fc9b987272454025d10919adb79872/" rel="bookmark">
			TCP 协议（四）重传与超时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.TCP 协议中的计时器 TCP 中有四种计时器（Timer），分别为：
重传计时器：Retransmission Timer
持久计时器：Persistent Timer
保活计时器：Keeplive Timer
等待计时器：Timer_Wait Timer
1.1.重传计时器 TCP 是保证数据可靠传输的。怎么保证呢？带确认的重传机制。在滑动窗口协议中，接受窗口会在连续收到的包序列的最后一个包时，向发送端发送一个 ACK。当网络拥堵的时候，发送端的数据包和接收端的 ACK 包都有可能丢失。TCP 为了保证数据可靠传输，就规定在重传的“时间片”到了以后，如果还没有收到对方的 ACK，就重发此包，以避免陷入无限等待中。
当 TCP 发送报文段时，就创建该特定报文的重传计时器。可能发生两种情况：
1.若在计时器截止时间到之前收到了对此特定报文段的确认，则撤销此计时器。
2.若在收到了对此特定报文段的确认之前计时器截止时间到，则重传此报文段，并将计时器复位。
1.2.持久计时器 先来考虑一下情景：
发送方向接收方发送数据包直到“接收窗口”填满了，然后“接收窗口”告诉发送方：“接收窗口”填满了，请停止发送数据。此时的状态称为“零窗口”状态，发送方和接收方窗口大小均为0，直到接收方发送 ACK 并宣布一个非零的窗口大小。我们知道 TCP 中，对 ACK 是不需要确认的。 若该 ACK 丢失了，接收方并不知道，并等待着发送方发送更多的报文；而发送方由于没有收到 ACK，继续等待接收方发送 ACK 来通知窗口大小。双方都在永远的等待着对方，陷入死锁状态。
要打开这种死锁，TCP 为每一个连接使用一个持久计时器。当发送方收到窗口大小为0的 ACK 时，就坚持启动持久计时器。当持久计时器期限到时，发送方就发送一个特殊的报文段，叫做探测报文；该报文段只有一个字节的数据；他有一个序号，但该序号永远不需要确认；甚至在计算机对其他部分的数据的确认时该序号也被忽略。探测报文段提醒接收方：ACK 已丢失，必须重传！
持久计时器的值设置为重传时间的数值。但是，若没有收到从接收方来的 ACK，则需发送另一个探测报文段，并将持久计时器的值加倍和复位。发送方继续发送探测报文段，将坚持计时器设定的值加倍和复位，直到这个值增大到门限值（通常是60秒）为止。在这以后，发送端每个60秒就发送一个探测报文，直到窗口重新打开。
1.3.保活计时器 保活计时器用来防止 TCP 连接出现长时间的空闲。假定客户端打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户端出故障了。在这种情况下，这个连接将永远的处在打开状态。
要解决这种问题，可以在服务器设置保活计时器。每当服务器收到客户端的信息，就将保活计时器复位。
超时时长通常设置为两小时。若服务器过了两小时还没有收到客户端的信息，他就发送探测报文段。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户端出了故障，就可以终止该连接。
这种连接的断开当然不会使用四次握手，而是直接硬性的中断和客户端的 TCP 连接。
1.4.等待计时器 等待计时器是在四次挥手的时候使用的。四次挥手的简单过程是这样的：假设客户端准备中断连接，首先向服务器发送一个 FIN，然后由 ESTABLISHED 过渡到 FIN_WAIT_1 状态。服务器收到 FIN 包以后会发送一个ACK，然后自己由 ESTABLISHED 进入 CLOSE_WAIT 状态。客户端收到 ACK 之后由 FIN_WAIT_1 进入 FIN_WAIT_2 状态。此时通信进入半双工状态，即留给服务器一个机会将剩余数据传递给客户端，传递完后服务器发送一个 FIN 的包，表示我已经发送完数据可以断开连接了，由 CLOSE_WAIT 进入 LAST_ACK 状态。客户端收到 FIN 以后，发送一个 ACK 表示收到并同意请求，接着由 FIN_WAIT_2 进入 TIME_WAIT 状态。服务器收到 ACK，结束连接。此时（即客户端发送完 ACK 包之后），客户端还要等待 2MSL（MSL=maxinum segment lifetime 最长报文生存时间，2MSL 就是两倍的 MSL）才能真正的关闭连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6fc9b987272454025d10919adb79872/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93c80a0de31b0eb614a35218c601be16/" rel="bookmark">
			java.lang.IllegalArgumentException: InputStream of class class org.apache.commons.compress.archivers
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译报错：
java.lang.IllegalArgumentException: InputStream of class class org.apache.commons.compress.archivers.zip.ZipFile$1 is not implementing InputStreamStatistics.
明显是包冲突
代码搜了下
org.apache.commons.compress.archivers.zip.ZipFile
在两个包中都有，同名类
&lt;groupId&gt;commons-compress:commons-compress&lt;/artifactId&gt;&lt;groupId&gt;org.apache.commons：commons-compress&lt;/artifactId&gt;
本项目使用的下面的，把上面排掉就OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbdad53f8a8cb32dcd3128e408155685/" rel="bookmark">
			怎么加速访问github？怎么打开win 11的自带虚拟机？少走弯路，一篇文章告诉你
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Win11家庭版开启方法
1、如果是win11家庭版，默认没有Hyper-V选项。这时候桌面上新建一个文本文档。
2、复制以下命令粘贴进去。左上角点击文件—另存为，保存类型选择所有文件，文件名为Hyper-V.cmd，点击保存。（直接下载文件： 链接: https://pan.baidu.com/s/1XjiS3tKOmcjpDmkHYRxjdg 提取码: mvbq）
3、右键以管理员身份运行，等待命令执行，操作成功之后，输入Y重启电脑。然后按照上面win11专业版的步骤开启。
二、Win11专业版开启方法
1、依次点击开始—设置—应用—可选功能—更多windows功能，找到“Hyper-V”，勾选上。
2、继续下拉，找到“虚拟机平台”，勾选，点击确定，这时候就配置该功能并安装，需要重启电脑。
三、如何简单快捷访问github
官网下载：https://steampp.net/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a43033617ee34c21ca88d2f1f12879/" rel="bookmark">
			修改表字段SQL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.删除表字段
ALTER TABLE table_name DROP COLUMN column_name; 2.新增表字段
alter table 表名 add (字段 字段类型) [ default '输入默认值'] [null/not null] ; ALTER TABLE employee ADD spbh varchar(20) NOT NULL Default 0; 3.修改字段(可修改字段名，字段类型，约束条件)
---ALTER TABLE 表名 CHANGE 原字段名 新字段名 字段类型 约束条件 ALTER TABLE sg_article CHANGE test_time modify_time datetime DEFAULT NULL; ALTER TABLE sg_article CHANGE modify_time modify_time datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c09a88b6ded6f0bb07f755b707fd7298/" rel="bookmark">
			node.js 多进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nodejs 多进程 题目 nodejs 如何开启一个进程，进程之间如何通讯
进程 process 和线程 thread 进程，是操作系统进行资源调度和分配的基本单位，每个进程都拥有自己独立的内存区域（参考“堆栈模型”）。
一个进程无法直接访问另一个进程的内存数据，除非通过合法的进程通讯。
执行一个 nodejs 文件，即开启了一个进程，可以通过 process.pid 查看进程 id 。
线程，是操作系统进行运算调度的最小单位，线程是附属于进程的。一个进程可以包含多个线程（至少一个），多线程之间可共用进程的内存数据。
如操作系统是一个工厂，进程就是一个车间，线程就是一个一个的工人。
JS 是单线程的，即执行 JS 时启动一个进程（如 JS 引擎，nodejs 等），然后其中再开启一个线程来执行。
虽然单线程，JS 是基于事件驱动的，它不会阻塞执行，适合高并发的场景。
为何需要多进程 现代服务器都是多核 CPU ，适合同时处理多进程。即，一个进程无法充分利用 CPU 性能，进程数要等于 CPU 核数。
服务器一般内存比较大，但操作系统对于一个进程的内存分配是有上限的（2G），所以多进程才能充分利用服务器内存。
nodejs 开启多进程 child_process.fork 可开启子进程执行单独的计算（源码参考 process-fork.js）
fork('xxx.js') 开启一个子进程使用 send 发送信息，使用 on 接收信息 cluster.fork 可针对当前代码，开启多个进程来执行（源码参考 cluster.js）
答案 可使用 child_process.fork 和 cluster.fork 开启子进程使用 send on 传递消息 扩展：使用 PM2 nodejs 服务开启多进程、进程守护，可使用 pm2 ，不需要自己写。代码参考 koa2-code
全局安装 pm2 yarn global add pm2增加 pm2 配置文件修改 package.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c09a88b6ded6f0bb07f755b707fd7298/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d5e8da526d678e3d1c8f80877a7e45/" rel="bookmark">
			vue通用后台管理系统（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要实现的页面 二、整体ui的搭建 1. Container布局容器 使用element-ui中的Container布局容器进行整体ui的搭建：在element-ui中选取一个组件样式然后引入到main.vue组件中
（1）全局引入element-ui
（2）在main.vue中使用想要引入的Container布局容器代码
（3）基本页面布局的效果
Aside:菜单区（导航区），Header：标题区，Home:内容区
1.1 菜单区的实现 （1）左侧菜单栏的引入 利用element-ui中的组件库实现左侧菜单栏的引入：
注意：组件拆分：具有单一功能的页面将其拆分为单独的组件，这样可以方便后面代码的维护
所以，我们需要在components文件夹中新建CommonAside.vue组件，然后将在element-ui中选取的NavMenu导航菜单的代码部分复制进去，并进行格式的调整。
// src/components/CommonAside.vue &lt;template&gt; &lt;el-menu default-active="1-4-1" class="el-menu-vertical-demo" @open="handleOpen" @close="handleClose" :collapse="isCollapse"&gt; &lt;el-submenu index="1"&gt; &lt;template slot="title"&gt; &lt;i class="el-icon-location"&gt;&lt;/i&gt; &lt;span slot="title"&gt;导航一&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item-group&gt; &lt;span slot="title"&gt;分组一&lt;/span&gt; &lt;el-menu-item index="1-1"&gt;选项1&lt;/el-menu-item&gt; &lt;el-menu-item index="1-2"&gt;选项2&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-menu-item-group title="分组2"&gt; &lt;el-menu-item index="1-3"&gt;选项3&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;el-submenu index="1-4"&gt; &lt;span slot="title"&gt;选项4&lt;/span&gt; &lt;el-menu-item index="1-4-1"&gt;选项1&lt;/el-menu-item&gt; &lt;/el-submenu&gt; &lt;/el-submenu&gt; &lt;el-menu-item index="2"&gt; &lt;i class="el-icon-menu"&gt;&lt;/i&gt; &lt;span slot="title"&gt;导航二&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="3" disabled&gt; &lt;i class="el-icon-document"&gt;&lt;/i&gt; &lt;span slot="title"&gt;导航三&lt;/span&gt; &lt;/el-menu-item&gt; &lt;el-menu-item index="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d5e8da526d678e3d1c8f80877a7e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e454c77dc74818b1d1a176516e3e01/" rel="bookmark">
			ChatGPT 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 背景与发展历程1.1 背景1.2 发展历程 2 技术原理2.1 第一阶段：训练监督策略模型2.2 第二阶段：训练奖励模型2.3 第三阶段：采用强化学习来增强模型的能力。 3 国内使用情况及应用的领域4 面临的数据安全挑战与建议4.1 ChatGPT获取数据产生的问题4.1.1 数据泄露问题4.1.2 删除权问题4.1.3 语料库获取合规问题 4.2 ChatGPT恶意利用产生的问题 5 结语6 参考 团队博客: CSDN AI小组
相关阅读
从 ELMo 到 ChatGPT：历数 NLP 近 5 年必看大模型关于 ChatGPT 必看的 10 篇论文ChatGPT 中的人类反馈强化学习 (RLHF) 实战 1 背景与发展历程 1.1 背景 ChatGPT是由OpenAI开发的一个人工智能聊天机器人程序，于2022年11月推出。该程序使用基于GPT3.5架构的大型语言模型并通过强化学习进行训练。
ChatGPT以文字方式互动，除了可以透过人类自然对话方式进行交互，还可以用于相对复杂的语言工作，包括自动文本生成、自动问答、自动摘要等在内的多种任务。如：在自动文本生成方面，ChatGPT可以根据输入的文本自动生成类似的文本，在自动问答方面，ChatGPT可以根据输入的问题自动生成答案。还具有编写和调试计算机程序的能力。
ChatGPT因其在许多知识领域给出详细的回答和清晰的答案而迅速获得关注，但其事实准确性参差不齐被认为是一重大缺陷。ChatGPT于2022年11月发布后，OpenAI估值已涨至290亿美元。上线两个月后，用户数量达到1亿。
ChatGPT主要包含以下特点：
(1) OpenAI使用 RLHF（Reinforcement Learning from Human Feedback，人类反馈强化学习）技术对 ChatGPT 进行了训练，且加入了更多人工监督进行微调。(2) 可以主动承认自身错误。若用户指出其错误，模型会听取意见并优化答案。(3) ChatGPT 可以质疑不正确的问题。例如被询问 “哥伦布 2015 年来到美国的情景” 的问题时，机器人会说明哥伦布不属于这一时代并调整输出结果。(4) ChatGPT 可以承认自身的无知，承认对专业技术的不了解。(5) 支持连续多轮对话。(6) ChatGPT可以通过分析语料库中的模式和敏感词或句子来识别敏感话题（种族，政治，人身攻击等）。它将会自动识别可能触发敏感问题的输入，并且可以自动过滤掉敏感内容，最大程度地确保用户的安全。此外，它也可以帮助用户识别出可能触发敏感问题的话题，从而避免他们无意中使用不当的语言破坏聊天气氛。 图1 示例：ChatGPT 写自我介绍 图2 示例：ChatGPT 改代码 Bug 图3 示例：ChatGPT 写代码 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e454c77dc74818b1d1a176516e3e01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090f08a6123e22563a340939d83ab4b7/" rel="bookmark">
			Linux高并发服务器开发第二章：Linux多进程开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 基本概念1.1 程序1.2 进程1.3 单道、多道程序设计1.4 时间片1.5 并行和并发1.6 进程控制块（PCB） 2. 进程的状态3. 进程相关命令4. 进程号和相关函数5. 进程创建、父子进程关系6. GDB 多进程调试7. exec 函数族（1）`int execl(const char *path, const char *arg, ...);`（2）`int execlp(const char *file, const char *arg, ... );` 8. 进程控制8.1 进程退出8.2 孤儿进程8.3 僵尸进程8.4 进程回收8.5 `pid_t wait(int *wstatus);`8.6 `pid_t waitpid(pid_t pid, int *wstatus, int options);`8.7 退出信息相关宏函数 9. 进程间通信9.1 进程间通信概念9.2 Linux 进程间通信的方式9.3 匿名管道9.4 管道的特点9.5 为什么可以使用管道进行进程间通信9.6 管道的数据结构9.7 创建匿名管道：`int pipe(int pipefd[2]);`9.8 查看管道缓存大小命令：`ulimit -a`9.9 查看管道缓冲大小函数：`long fpathconf(int fd, int name);`9.10 匿名管道的使用9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/090f08a6123e22563a340939d83ab4b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9787ee4739498a27fa2bbc70e8bc3889/" rel="bookmark">
			【Flutter】移动开发者的Flutter Web实践（利用GitHub Pages进行部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		移动开发者的Flutter Web实践（利用GitHub Pages进行部署） 前言 自从Flutter2发布以来，Flutter对Web的支持已经进入稳定阶段，但一直没有时间研究，直到目前为止Flutter3.3已经正式发布，Flutter 3 是正式为全平台提供支持的一个重量级里程碑。从移动端，到Web，到桌面端的性能稳步提升，借着自己还有一点点前端开发经验，了解了一下Flutter对Web开发的支持与体验。
Flutter Web初体验 新建Flutter Web工程，New Flutter Project
老样子，还是直接可以使用Android Studio进行开发，毕竟还是在用Flutter进行开发。
这里记得勾选Web
Create，完成创建
创建完成会发现，工程目录比平时多了一个web目录，里边是存放一些Web特性的一些东西，跨平台的业务代码依然在lib目录中
选中运行，Bingo！你成功了！
在Flutter中文网的教程中，已经详细描述了如何构建一个Flutter Web应用，这里不再过多描述，放上传送门。
上述初体验描述了一个FlutterWeb工程从创建到成功运行，都是傻瓜式操作，跟着教程一路Next就可以了，这肯定满足不了个人或企业级外网访问的需求啊。接下来介绍如何部署到云上运行。
Flutter Web部署 FlutterWeb部署的教程官网上也有，
构建和发布为 Web 应用 - Flutter 中文文档 - Flutter 中文开发者网站 - Flutter
但是不详细，仅仅介绍了可以部署到哪里，没有具体的操作，下面就以GitHubPages为例介绍如何部署。
Firebase HostingGitHub PagesGoogle Cloud Hosting 第一步：打包 第一步，先打包，跟移动开发打包一样，flutter build web，不赘述。
打完包之后，同样会在工程目录下生成build目录，用于存放构建结构，下面有一个web目录，就是存放Web项目的打包后结果。
第二步：部署 有了web的构建结果，我们就准备部署了。
关于GitHub Pages的使用，在他的官网中也有详细介绍，那我们如何实施呢？
准备工作 新建一个github仓库，我的仓库是这个，
是的，准备工作只需要新建一个github仓库就可以了。
操作 把github仓库clone下来把web的构建结果复制到我们的github仓库的本地目录中去**【关键1】**修改构建结果中的index.html文件中的base标签，修改成你github仓库的名字，不然关联不到相对路径资源文件，例如， 原来的
修改后
如果不想像步骤3一样，手动修改的话，我们可以使用命令参数实现，
我们在执行flutter build web的时候，增加--base-href=/knowledge.io/,也能实现同样效果。 做完之后，把内容push到远端仓库
来到github，进入到远端仓库的Settings页面
在左侧菜单的Code and automation栏，找到Pages项，进入
在这里你可以选择如何部署，部署源是什么，
我们这里选择Deploy from a branch，部署一个分支，选择master，然后save，然后会触发github的默认流水线
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9787ee4739498a27fa2bbc70e8bc3889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63d151c49cd22b50fd4cbeb32407cec4/" rel="bookmark">
			什么是卷积
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是卷积 卷积（convolution），是一种运算，你可以类比于加，减，乘，除，矩阵的点乘与叉乘等等，它有自己的运算规则，卷积的符号是星号*。表达式为：
连续的为
( f ∗ g ) ( n ) = ∫ − ∞ ∞ f ( x ) g ( n − x ) d x (f*g)(n) = \int_{-\infty}^{\infty}f(x)g(n-x)dx (f∗g)(n)=∫−∞∞​f(x)g(n−x)dx
离散的为
( f ∗ g ) ( n ) = ∑ x = − ∞ ∞ f ( x ) g ( n − x ) (f*g)(n) = \sum_{x=-{\infty}}^{\infty}f(x)g(n-x) (f∗g)(n)=x=−∞∑∞​f(x)g(n−x)
从参数上来看，x + (n-x) = n，可以类比为x + y = n，也就是说f, g的参数满足规律y = -x + n，即g的参数是f的参数先翻转再平移n。把g从右边褶到左边去，也就是卷积的卷的由来。然后在这个位置对两个函数的对应点相乘，然后相加，这个过程是卷积的积的过程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63d151c49cd22b50fd4cbeb32407cec4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfb64a79bfe54a65f64828ecfcecd8f/" rel="bookmark">
			Unity 点乘和叉乘的原理和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity当中经常会用到向量的运算来计算目标的方位，朝向，角度等相关数据，下面咱们来通过实例学习下Unity当中最常用的点乘和叉乘的使用。
点乘 （又称”点积”,”数量积”,”内积”）（Dot Product, 用＊）
定义：a·b=|a|·|b|cos&lt;a,b&gt; 【注：粗体小写字母表示向量，&lt;a,b&gt;表示向量a,b的夹角，取值范围为[0，180]】
几何意义：是一条边向另一条边的投影乘以另一条边的长度.
v1和v2向量的点乘运算：相应元素的乘积的和：v1( x1, y1，z1) * v2(x2, y2,z2) = x1*x2 + y1*y2+z1*z2;
注意 : 结果不是一个向量，而是一个标量。
性质1： a*b = |a||b|Cos(θ) ，θ是向量a 和向量 b之间的夹角。
性质2： a*b = b*a 满足乘法交换律
Unity项目应用：
1.根据点乘计算两个向量的夹角。&lt;a,b&gt;= arccos(a·b / (|a|·|b|))
2.根据点乘的正负值，得到夹角大小范围，&gt;0，则夹角（0,90）&lt;0,则夹角（90,180），可以利用这点判断一个多边形是面向摄像机还是背向摄像机。
3.根据点乘的大小，得到向量的投影长度，反应了向量的长度关系。
4.在生产生活中，点积同样应用广泛。利用点积可判断一个多边形是否面向摄像机还是背向摄像机。向量的点积与它们夹角的余弦成正比，因此在聚光灯的效果计算中，可以根据点积来得到光照效果，如果点积越大，说明夹角越小，则物理离光照的轴线越近，光照越强。物理中，点积可以用来计算合力和功。若b为单位矢量，则点积即为a在方向b的投影，即给出了力在这个方向上的分解。功即是力和位移的点积。计算机图形学常用来进行方向性判断，如两矢量点积大于0，则它们的方向朝向相近；如果小于0，则方向相反。矢量内积是人工智能领域中的神经网络技术的数学基础之一，此方法还被用于动画渲染（Animation-Rendering）。
叉乘 （又称”叉积”,”向量积”,”外积”）（cross product，用x）
定义：c = a x b，其中a b c均为向量
几何意义是：得到一个与这两个向量都垂直的向量，这个向量的模是以两个向量为边的平行四边形的面积
v1和v2向量的叉乘运算：相应元素的乘积的和：v1( x1, y1，z1) x v2(x2, y2, z2) = (y1*z2 – y2*z1)i+(x2*z1 – x1*z2)j+(x1*y2-x2*y1)k;
二维向量的话：v1 x v2 = （x1,y1）x (x2,y2) = x1*y2-x2*y1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcfb64a79bfe54a65f64828ecfcecd8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e48c34404d76bdb595b8f60ca513e7b/" rel="bookmark">
			Linux RPM包安装、卸载和升级（rpm命令）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RPM包默认安装路径 通常情况下，RPM 包采用系统默认的安装路径，所有安装文件会按照类别分散安装到表 1 所示的目录中。
表 1 RPM 包默认安装路径 安装路径含 义/etc/配置文件安装目录/usr/bin/可执行的命令安装目录/usr/lib/程序所使用的函数库保存位置/usr/share/doc/基本的软件使用手册保存位置/usr/share/man/帮助文件保存位置 RPM 包的默认安装路径是可以通过命令查询的。
除此之外，RPM 包也支持手动指定安装路径，但此方式并不推荐。因为一旦手动指定安装路径，所有的安装文件会集中安装到指定位置，且系统中用来查询安装路径的命令也无法使用（需要进行手工配置才能被系统识别），得不偿失。 与 RPM 包不同，源码包的安装通常采用手动指定安装路径（习惯安装到 /usr/local/ 中）的方式。既然安装路径不同，同一 apache 程序的源码包和 RPM 包就可以安装到一台 Linux 服务器上（但同一时间只能开启一个，因为它们需要占用同一个 80 端口）。
实际情况中，一台服务器几乎不会同时包含两个 apache 程序，管理员不好管理，还会占用过多的服务器磁盘空间。
RPM 包的安装 安装 RPM 的命令格式为：
[root@localhost ~]# rpm -ivh 包全名
注意一定是包全名。涉及到包全名的命令，一定要注意路径，可能软件包在光盘中，因此需提前做好设备的挂载工作。
此命令中各选项参数的含义为：
-i：安装（install）;-v：显示更详细的信息（verbose）;-h：打印 #，显示安装进度（hash）; 此命令还可以一次性安装多个软件包，仅需将包全名用空格分开即可，如下所示：
[root@localhost ~]# rpm -ivh a.rpm b.rpm c.rpm
RPM包的升级 使用如下命令即可实现 RPM 包的升级：
[root@localhost ~]# rpm -Uvh 包全名
-U（大写）选项的含义是：如果该软件没安装过则直接安装；若已经安装则升级至最新版本。
[root@localhost ~]# rpm -Fvh 包全名
-F（大写）选项的含义是：如果该软件没有安装，则不会安装，必须安装有较低版本才能升级。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e48c34404d76bdb595b8f60ca513e7b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58798140c7f603f56ceaeddd4e6b1a19/" rel="bookmark">
			Pandas高级应用：数据透视表和字符串操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas是Python中用于数据处理和分析的强大库。这篇文章将深入探讨Pandas库的高级功能：数据透视表和字符串操作。
一、数据透视表 数据透视表是一种常见的数据汇总工具，常用于电子表格程序和某些数据库。Pandas提供了创建数据透视表的功能，这使得数据分析更加灵活和直观。
1. 创建数据透视表 Pandas的pivot_table()函数可以轻松地创建数据透视表。我们需要指定以下参数：values（要聚合的列名），index（在透视表的行中要分组的列名），columns（在透视表的列中要分组的列名），aggfunc（用于聚合的函数）。
import pandas as pd import numpy as np df = pd.DataFrame({ 'A': ['one', 'one', 'two', 'three'] * 3, 'B': ['A', 'B', 'C'] * 4, 'C': ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2, 'D': np.random.randn(12), 'E': np.random.randn(12) }) # 创建数据透视表 pivot_table = df.pivot_table(values='D', index=['A', 'B'], columns=['C'], aggfunc=np.sum) print(pivot_table) 2. 查询数据透视表 你可以像查询普通的DataFrame那样查询数据透视表。
# 查询数据透视表 print(pivot_table.loc['one']) # 查询行索引为'one'的数据 print(pivot_table['foo']) # 查询列索引为'foo'的数据 二、字符串操作 Pandas提供了一系列的字符串处理方法，在str属性中集成了这些方法，这使得在DataFrame和Series中的字符串操作更加方便。
1. 字符串基本操作 Pandas支持大部分Python内置的字符串方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58798140c7f603f56ceaeddd4e6b1a19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/223475ebf151655c8128a247b5971b9d/" rel="bookmark">
			毕设校园失物招领小程序ssm毕业设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		校园失物招领是大学生活中常见的问题，为了解决这一问题，设计一个基于SSM框架的校园失物招领小程序，可以提高失主寻找失物的机会，帮助失主找回失物，也方便拾得者进行招领。本文将介绍该校园失物招领小程序的设计与开发。
首先，该小程序的设计目标是提供一个便捷的平台，让校园内的学生可以快速发布失物信息，并能够及时查看和招领失物。下面将从功能设计、技术架构和用户体验等方面对该小程序进行介绍。
该小程序具备以下主要功能：
失物发布：用户可以通过小程序发布失物信息，包括失物描述、拾得地点、联系方式等。发布后的失物信息将在小程序上展示。
招领信息浏览：其他用户可以在小程序上浏览最新发布的失物信息，并可以通过筛选功能按照时间、地点等条件查找特定的失物信息。
招领申请：当用户发现自己有可能是某个失物的拾得者时，可以通过小程序提交招领申请，留下自己的联系方式。
失物认领：失主可以通过小程序查看招领申请，并选择认领合适的招领者，联系对方进行失物归还。
评价与反馈：用户在找回失物或成功招领后，可以对对方进行评价和反馈，提供参考给其他用户。
接下来是该小程序的技术架构。该小程序采用SSM（Spring+Spring MVC+MyBatis）框架进行开发，前端使用微信小程序原生开发语言，后端使用Java语言编写。数据库使用MySQL进行存储。
在用户体验方面，该小程序注重简洁明了的设计和良好的交互体验。通过清晰的导航结构、直观的操作按钮和友好的界面布局，使用户能够快速找到所需功能，并便捷地完成操作。同时，小程序还支持用户个性化设置，例如可以设置消息提醒方式、浏览历史记录等。
通过该校园失物招领小程序，失主可以方便地发布失物信息，提高失物找回的机会；招领者也可以及时浏览失物信息，积极参与到招领行动中。这一小程序的设计与开发旨在促进校园内失物的迅速找回，提升学生的社会责任感和互助意识。
总之，基于SSM框架的校园失物招领小程序是解决大学校园失物问题的一种创新方式。通过该小程序，失主和招领者可以更高效地进行信息发布和查找，帮助失主找回失物，促进校园内的互助与交流。这一校园失物招领小程序的设计与开发有望提升学生的生活品质和社会参与度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/328279c05a9c40ac2b7bd5b42b9ed2ef/" rel="bookmark">
			vue通用后台管理系统（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、脚手架的搭建
1.yarn和npm对比
1.1 npm的缺点
1.2 yarn的优点
1.3 Yarn和npm命令对比
2.vue-cli搭建的详细过程
2.1 安装node和npm
2.2 安装vue-cli
2.3 使用vue-cli创建项目
3. element-ui
3.1 element-ui在网页中使用
3.2 element-ui结合脚手架之全部引入
3.3 element-ui结合脚手架之按需引入
3.4 项目打包
3.vue-router
3.1 vue-router的引入
3.2 vue-router的代码配置
3.3 嵌套路由
3.4 关闭eslint校验
一、脚手架的搭建 1.yarn和npm对比 1.1 npm的缺点 npm install的时候巨慢。特别是新的项目拉下来时要等半天，删除node_modules，重新install的时候依旧如此同一个项目，安装的时候无法保持一致性。由于package.json文件中版本号的特点，下面三个版本号在安装的时候代表不用的含义 安装的时候，包会在同一时间下载和安装，中途某个时候，一个包抛出了错误，但是npm会继续下载和安装包。因为npm会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆npm打印的警告中丢失掉，并且你甚至永远不会注意到实际发生的错误 1.2 yarn的优点 Yarn是由Facebook、Google、Exponent和Tilde联合推出了一个新的JS包管理工具，Yarn是为了弥补npm的一些缺陷而出现的。
速度快 安装版本统一 更简洁的输出 多注册来源处理 更好的语义化 1.3 Yarn和npm命令对比 2.vue-cli搭建的详细过程 2.1 安装node和npm 注：node，可以理解为一种环境
查看node安装版本：node -v
查看npm安装版本： npm -v
2.2 安装vue-cli npm install -g @vue/cli
或者 yarn global add @cue/cli
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/328279c05a9c40ac2b7bd5b42b9ed2ef/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/130/">«</a>
	<span class="pagination__item pagination__item--current">131/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/132/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>