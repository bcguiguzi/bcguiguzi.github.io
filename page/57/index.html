<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/496b531f816b1a50b2d6265a253b143a/" rel="bookmark">
			【探索AI】十三 深度学习之第2周：深度神经网络（二）参数初始化策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（二）深度学习的参数初始化策略
为什么参数初始化在深度学习中是如此重要 首先，参数初始化决定了模型训练的起点。在深度学习模型中，通常存在大量的参数需要优化。这些参数的初始值将直接影响模型的学习方向和速度。如果初始值选择不当，模型可能需要更长的时间才能找到最优解，甚至可能陷入局部最优解而无法收敛到全局最优解。
其次，参数初始化对于梯度传播有重要影响。在深度神经网络中，梯度在反向传播过程中可能会变得非常小（梯度消失）或非常大（梯度爆炸）。这会导致模型训练的不稳定，使得模型难以收敛。适当的参数初始化策略可以帮助减轻这个问题，确保梯度在传播过程中保持在一个合理的范围内。
此外，参数初始化还影响模型的泛化能力。如果参数初始值过大或过小，模型可能会过于复杂，导致过拟合。合适的初始化策略可以帮助模型在训练数据和测试数据之间达到一个良好的平衡，提高模型的泛化能力。
因此，参数初始化在深度学习中具有举足轻重的地位。通过选择合适的初始化策略，我们可以为模型的训练过程打下良好的基础，提高模型的性能和稳定性。
参数初始化的基本原则 在深度学习中，参数初始化是一个核心步骤，它决定了模型训练的开始点以及模型学习的速度和稳定性。下面，我将详细介绍参数初始化的基本原则，包括权重初始化和偏置初始化。
权重初始化
权重初始化是指为神经网络的权重赋予初始值的过程。权重是神经网络中连接不同神经元之间的参数，它们决定了模型在训练过程中的学习速度和效果。
为何不能将所有权重初始化为零或相同的值？
将所有权重初始化为零或相同的值会导致模型训练出现问题。具体原因如下：
对称性问题：如果所有权重都相同，那么在每一层中，每个神经元的输入都是相同的。这意味着在前向传播过程中，每一层的神经元都会输出相同的值，导致模型无法学习到不同的特征。
学习速度缓慢：如果所有权重都初始化为零，那么模型在训练开始时将不会有任何学习信号。权重更新将非常缓慢，因为梯度接近于零。这会导致训练过程变得非常漫长，甚至可能无法收敛到最优解。
因此，我们需要使用一种合适的权重初始化策略，以确保每个权重都有一个合理的初始值，从而使模型能够迅速且有效地学习。常见的权重初始化策略包括随机小值初始化、Xavier初始化、He初始化等。
偏置初始化
偏置是神经网络中每个神经元的一个固定值，它决定了神经元的输出阈值。偏置的初始化通常比较简单，通常将其初始化为零。
为何偏置通常初始化为零？
偏置初始化为零的主要原因是为了简化模型，并减少模型在训练开始时的不必要复杂性。偏置的主要作用是调整神经元的输出范围，而不是改变输出值的符号或大小。因此，将偏置初始化为零可以确保模型在训练开始时不会受到偏置的干扰，从而更容易学习到数据的真实特征。
总的来说，合适的参数初始化策略对于深度学习模型的训练至关重要。通过理解权重初始化和偏置初始化的原则，我们可以为模型的训练过程打下良好的基础，提高模型的性能和稳定性。
经典的初始化策略 详细介绍几种经典的初始化策略，来理解它们的原理和应用。
1. 随机初始化
随机初始化是为了打破模型的对称性，使每个神经元在训练开始时都能接收到不同的输入信号。如果所有权重都被初始化为相同的值，那么每个神经元在训练开始时都会接收到相同的输入，导致模型无法有效地学习。
不同的随机初始化方法：
小随机数初始化：将权重初始化为小的随机值，如从均匀分布[-0.1, 0.1]或正态分布N(0, 0.01)中采样。这种方法可以避免权重过大导致的梯度爆炸问题，但可能导致训练初期学习速度较慢。
大随机数初始化：将权重初始化为较大的随机值，如从均匀分布[-1, 1]或正态分布N(0, 1)中采样。这种方法可能导致训练初期梯度消失问题，但也可能使模型更快地跳出局部最优解。
2. Xavier/Glorot 初始化
Xavier初始化（也称为Glorot初始化）是一种旨在保持神经网络中每一层方差稳定的权重初始化方法。它基于输入和输出神经元的数量来调整权重的初始值，以确保前向传播和反向传播时的梯度大小保持一致。
原理：
假设激活函数是线性的，权重和输入都是随机分布的，那么每一层的输出方差应该与输入方差相同。
为了实现这一点，权重应该根据输入和输出神经元的数量进行缩放，即W ~ U[-sqrt(6 / (n_in + n_out)), sqrt(6 / (n_in + n_out))]，其中n_in和n_out分别是输入和输出神经元的数量。
3. He 初始化
He 初始化是对Xavier初始化的改进，特别是在使用ReLU（Rectified Linear Unit）激活函数时。ReLU函数会将所有负值置为零，这可能导致一半的神经元在训练初期处于不活跃状态，从而影响方差的传播。
与Xavier初始化的区别：
He 初始化只考虑输入神经元的数量来调整权重的初始值，即W ~ U[-sqrt(2 / n_in), sqrt(2 / n_in)]，其中n_in是输入神经元的数量。
这种方法可以更好地保持ReLU网络的方差稳定。
4. 偏置初始化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/496b531f816b1a50b2d6265a253b143a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8dc22882f0b89f5ba08bde3bdf3de34/" rel="bookmark">
			Layui实现动态下拉框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		layui样式 &lt;div class="layui-form-item"&gt; &lt;div class="layui-inline"&gt; &lt;label class="layui-form-label"&gt;下拉框 &lt;/label&gt; &lt;div class="layui-input-inline" id="consumerNames"&gt; &lt;select id="dropDownNames" &gt;&lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; js 初始化时加载下拉框数据 $(document).ready(function(){ let select = $('#dropDownNames'); layui.use(['form'], function(){ var form = layui.form; $('#dropDownNames').empty();//先清空数据 $('#drownDownParameters').empty();//先清空数据 $.ajax({ url: '', type: 'GET', contentType: 'application/json', success: function (data){ var json = eval('(' + data + ')'); let module = json.dictDataList.resultList; $.each(module,function (index,value){ var option = $('&lt;option&gt;&lt;/option&gt;').val(value.typecode).text(value.typename); select.append(option); }); var passType = `${swap.passType}`; // 使用模板字符串正确地获取变量的值 // 假设select是一个已经选择好的jQuery对象 if (passType === "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8dc22882f0b89f5ba08bde3bdf3de34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f69f92eaeb18bcea462350fc7335f75/" rel="bookmark">
			基于x86架构的OpenHarmony应用生态挑战赛等你来战！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了更快速推进OpenHarmony在PC领域的进一步落地，加快x86架构下基于OpenHarmony的应用生态的繁荣，为北向应用开发者提供一个更加便捷的开发环境，推动OpenHarmony北向应用开发者的增加，助力OpenHarmony在PC领域实现新的突破，由开放原子开源基金会、央视网、江苏省工业和信息化厅、无锡市人民政府、江苏软件产业人才发展基金会、苏州工业园区、无锡高新区等共同承办，鸿湖万联参与共建的“基于x86架构的OpenHarmony应用生态挑战赛” 已于2月1日火热开启，正在踊跃报名中！
本赛题的硬件以“Intel i3/i5/i7”为主。
还在等什么？心动不如行动！快叫上小伙伴一起为目标而战吧~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e435797fb32b039c4a92dab5b710b55/" rel="bookmark">
			apache如何配置，并配置php
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先安装apache 并找到配置文件
2.在配置文件中搜索DocumentRoot，这里到时把页面放在这个目录下
3.搜索servername 如果是注释掉的就解开。这是到时可以访问的域名
4.找到电脑里的hosts文件，进行解析操作 把www.example.com指向127.0.0.1（本地）
5.终端 运行sudo apachectl restart 重启apache
6.找到第2步的目录下，新建index.html文件，随便输入点内容
7.成功访问 看到内容就是配置成功了
8.目前我们可以解析道.html的文件，但是php文件还无法解析.安装php 我的是8.1
9.在apache的配置文件中 查找LoadModule
一般情况下 是可以搜索到php_module的扩展，直接把注释解开就可以了。但是通过第一个箭头的地方可以看到因为我的mac版本太高这个扩展被移除了，所以我需要手动添加 LoadModule php_module /opt/homebrew/Cellar/php@8.1/8.1.26/lib/httpd/modules/libphp.so "PHPCA" 引号里面的是证书签名
步骤一、创建证书（如果在终端运行 httpd -t，没有报No code signing authority的错就不需要走创建证书的步骤）
1、打开启动台 —&gt; 其他 —&gt; 钥匙串访问，如下图所示
2、在弹框中输入证书名称，比如：PHPCA，证书类型选择代码签名，勾选“让我覆盖这些默认”，点击继续。
3、填写证书信息，有效天数可以自己定义，点击继续
接着往下输入
密钥对信息：密钥大小 2048位，算法 RSA
密钥使用扩展：签名
以扩展的密钥使用扩展：代码签名
后边就一直是默认不用修改，最后直接“创建”，看到下边的图就是成功了。
10.证书创建完成后，在命令行输入,其中php@8.1修改为自己安装的版本，可以在/opt/homebrew/opt/目录下查看，主要是对libphp.so 文件签名， PHPCA为自己步骤一生成的签名文件名字
codesign --sign "PHPCA" --force --keychain ~/Library/Keychains/login.keychain-db /opt/homebrew/opt/php@8.1/lib/httpd/modules/libphp.so 完成之后，在命令行会显示：/opt/homebrew/opt/php@8.1/lib/httpd/modules/libphp.so: replacing existing signature， 看到这个就说明成功了
成功后返回第9步输入
LoadModule php_module /opt/homebrew/opt/php/lib/httpd/modules/libphp.so "PHPCA"
引号内是证书名字
11.apache的配置文件里搜索找到 DirectoryIndex 改成下面这样
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e435797fb32b039c4a92dab5b710b55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f843d13502d1c24db275f93c282a906/" rel="bookmark">
			echart中自定义下载功能--on和dispatchAction两种事件触发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 echart中的两种事件 ECharts 中的事件有两种，一种是鼠标事件(‘用on绑定，off解除事件’)，在鼠标点击某个图形上会触发，还有一种是 调用 dispatchAction 后触发的事件。每个 action 都会有对应的事件，具体见 action 和 events 的文档。
监听 finished 事件 myChart.on(‘finished’, function () {
// 在这里执行你的下载操作
// 例如，下载图表的数据或图像
downloadDataOrImage();
});
下载数据或图像的函数 function downloadDataOrImage() { // 这里是下载操作的代码 // 你可以根据需求选择下载图表的数据或图像 // 例如，使用 a 标签模拟下载操作 var dataOrImage = myChart.getDataURL({ // 这里可以设置导出图片的配置 // 例如，设置图片类型、背景色等 type: 'png', pixelRatio: 2, backgroundColor: '#fff' }); var downloadLink = document.createElement('a'); downloadLink.href = dataOrImage; downloadLink.download = 'chart.png'; // 设置下载文件的名称 document.body.appendChild(downloadLink); downloadLink.click(); document.body.removeChild(downloadLink); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db505780451e3724fd7848cf744ad939/" rel="bookmark">
			easyexcel加粗边框
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package org.zt.task.report.listener; import com.alibaba.excel.metadata.Head; import com.alibaba.excel.write.metadata.style.WriteCellStyle; import com.alibaba.excel.write.metadata.style.WriteFont; import com.alibaba.excel.write.style.AbstractVerticalCellStyleStrategy; import org.apache.poi.ss.usermodel.BorderStyle; import org.apache.poi.ss.usermodel.FillPatternType; import org.apache.poi.ss.usermodel.HorizontalAlignment; import org.apache.poi.ss.usermodel.IndexedColors; /** * @author liuhuapeng * @date 2024/2/29 */ public class CustomCellWriteHandler extends AbstractVerticalCellStyleStrategy { @Override protected WriteCellStyle headCellStyle(Head head) { WriteCellStyle writeCellStyle = new WriteCellStyle(); writeCellStyle.setFillBackgroundColor(IndexedColors.RED.getIndex()); WriteFont writeFont = new WriteFont(); writeFont.setBold(false); writeFont.setFontHeightInPoints(Short.valueOf((short)15)); writeCellStyle.setWriteFont(writeFont); return writeCellStyle; } // 重写定义内容部分样式的方法 @Override protected WriteCellStyle contentCellStyle(Head head) { WriteCellStyle writeCellStyle = new WriteCellStyle(); writeCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND); writeCellStyle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db505780451e3724fd7848cf744ad939/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c45e93d86ed3d37790c14d97bb4e6a7a/" rel="bookmark">
			SQLServer,MySQL,Oracle,PostgreSQL数据库优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言： 如果是学生或刚工作SQL Server建议要有一定了解，MySQL也是一个绕不开的话题，但刚工作别人也不会要求你什么都会，Oracle如果遇到或未来从事相关工作还是可以学的，专业度高但工资也高。
一个产品的好不好也分多种，可能产品很好但生态不好，这种比较就好像微软C#和Java的对比，语言自身很优秀，但生态不足，比如三方类库资源太少，像微服务C#一定可以实现但就是没有知名的三方产品，无法与SpringCloud这样一些优秀产品抗衡
专业的DBA目前我遇到的很少，企业内部多数是兼岗。MySQL我认为可以有一定研究，灵活度也比较高，像MySQL的高可用方案就很多种，读写分离等都比SQL Server灵活很多。
步入正题 首先看下数据库最新的排名，长期位居数据库排名榜的前三名，实时排名请点击链接：DB-Engines Ranking - popularity ranking of database management systems
SQLServer 微软当家数据库产品,可以看下SQLServer的发展历程
SQL Server 官方说明资料网址 SQL Server 技术文档 - SQL Server | Microsoft Learn
SQL Server 是微软开发的一款关系型数据库管理系统，它具有以下特点：
强大的处理能力：SQL Server 具有高度可扩展性，可以支持大规模数据存储，支持并发处理大量请求，满足企业级应用的需求。
数据安全性：SQL Server 提供了多重数据安全保护措施，如透明数据加密（TDE）、行级安全、动态数据屏蔽和其他多种安全机制，确保数据的安全性和完整性。
高效的性能优化：SQL Server 内置了性能优化功能，包括查询执行计划、索引优化、存储过程优化等，可以有效提高查询和数据处理速度。
集成分析和报告服务：SQL Server 提供了强大的数据分析和报告工具，如 SQL Server Analysis Services（SSAS）、SQL Server Reporting Services（SSRS）等，帮助用户快速构建业务报告和数据仪表盘。
兼容性：SQL Server 支持多种应用开发语言，如 .NET、Java、Python 等，同时有多种连接器和驱动可供开发者使用，便于快速构建和集成各种应用程序。
云支持：SQL Server 可以在公有云、私有云以及混合云中部署，满足企业不同场景的需求。
灵活的许可模式：SQL Server 提供多种许可模式，高度灵活，客户可以根据自己的需求选择不同的许可策略。
优点：
学习成本低
微软的产品一般在易用性方面具有较大优点，图形化界面设计的比较好，从安装到使用基本上都可以基于图形化界面操作。从登录到增删改查基本上都可以不用代码。所以入手想对容易。
维护成本低
这个是相对的，如果不购买微软的授权，那运维成本基本上就在于人工，因为入门想对容易，所以SQLServer有较大的受众和工程师，简单的日常运维监控、备份等都可以入手，对于一些小公司确实可以降低一些成本。
数据仓库
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c45e93d86ed3d37790c14d97bb4e6a7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8653c1bc299ed3ddee87d3080732eb09/" rel="bookmark">
			【探索AI】一：什么是AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一：什么是AI？
AI，即人工智能（Artificial Intelligence），是指一种模拟人类智能思维和行为的技术和系统。人工智能的目标是使计算机系统具有类似人类的智能，包括学习能力、推理能力、感知能力、语言理解能力等，从而能够像人类一样执行各种任务。
人工智能可以分为弱人工智能和强人工智能两种类型：
弱人工智能（Narrow AI）是指针对特定任务或领域设计的人工智能系统，只能完成特定任务，如语音识别、图像识别等。
强人工智能（General AI）是指能够像人类一样在各种不同任务和领域表现出智能的人工智能系统，具有自主学习和自我改进的能力。
人工智能的实现主要依赖于机器学习、深度学习、自然语言处理、计算机视觉等技术，通过这些技术实现对大量数据的分析、学习和模式识别，从而完成各种智能任务。
人工智能在各个领域都有广泛的应用，包括自动驾驶、医疗诊断、金融风险管理、智能客服、智能家居等。随着技术的不断发展，人工智能将在未来发挥越来越重要的作用。
二：AI的基础知识包含那些？
AI（人工智能）的基础知识包括以下内容：
机器学习：机器学习是指让计算机系统具有学习能力，通过从数据中学习规律和模式，从而做出预测和决策。包括监督学习、无监督学习、强化学习等不同类型。
深度学习：深度学习是机器学习的一个分支，主要基于人工神经网络模型，能够对复杂的非线性关系进行学习和建模，是实现许多人工智能任务的关键技术。
自然语言处理（NLP）：自然语言处理是指让计算机能够理解、解释和生成人类语言的技术，包括语音识别、文本分析、机器翻译等方面。
计算机视觉：计算机视觉是指让计算机系统能够“看懂”图像和视频，包括图像识别、目标检测、图像生成等技术。
强化学习：强化学习是一种通过试错而学习的方法，主要用于训练智能体在特定环境下做出最优决策。
数据挖掘：数据挖掘是从大量数据中发现未知模式和规律的过程，是许多机器学习算法的基础。
推荐系统：推荐系统利用机器学习和数据挖掘技术，根据用户的偏好和行为向其推荐个性化的产品或服务。
模式识别：模式识别是识别数据中的模式和特征，是许多人工智能应用的基础。
三、相互关系
以上是AI的基础知识，掌握这些知识可以帮助你理解人工智能的基本原理和应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e68903fb792ec7c8b8921a191b58d3b/" rel="bookmark">
			【探索AI】十二 深度学习之第2周：深度神经网络（一）深度神经网络的结构与设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第2周：深度神经网络 将从以下几个部分开始学习，第1周的概述有需要详细讲解的的同学自行百度；
深度神经网络的结构与设计
深度学习的参数初始化策略
过拟合与正则化技术
批标准化与Dropout
实践：使用深度学习框架构建简单的深度神经网络，并进行训练与评估
（一）深度神经网络的结构与设计 一. 神经网络基础回顾 二. 深度神经网络结构 深度网络
引入深度概念： 深度神经网络由多个隐藏层组成，可以进行多层次的特征抽取和表示学习。
随着层数增加，网络可以学习到更加抽象和复杂的特征。
层与层之间的连接方式：
全连接：每个神经元都与上一层的所有神经元相连，参数量大。
卷积连接：通过卷积操作提取局部特征，共享权重减少参数量。
池化操作：减少特征图大小、参数量，保留关键信息。
常见结构
卷积神经网络（CNN）： 适用于图像数据处理：通过卷积层和池化层提取空间特征。
包括卷积层、池化层、全连接层等，常用于图像分类、目标检测等任务。
循环神经网络（RNN）：
适用于序列数据处理：具有记忆功能，能处理不定长序列数据。
可以捕捉序列中的时间依赖关系，常用于自然语言处理、时间序列预测等领域。
注意力机制（Attention）：
用于处理不定长序列数据：允许模型在不同时间步关注输入序列的不同部分。
提高模型对长序列的处理能力，常用于机器翻译、语音识别等任务。
三. 神经网络设计与调参 网络设计要点
深度与宽度的选择： 深度：增加深度可提高网络表达能力，但也增加训练难度和计算成本。根据任务复杂度和数据量进行选择。
宽度：每层神经元数量的选择影响网络的表示能力，通常在实践中会通过试验选择最佳宽度。
正则化与批标准化的使用：
正则化：如L1/L2正则化、Dropout等可以减少过拟合问题。
批标准化：减少内部协变量偏移，加速训练过程，提高模型泛化能力。
梯度消失与爆炸问题的处理：
梯度消失：通过使用恰当的激活函数（如ReLU）、初始化权重（如He初始化）、或者使用残差连接（如ResNet）来缓解。
梯度爆炸：梯度裁剪、合适的权重初始化（如Xavier初始化）等方法可以解决。
超参数调优
学习率、批大小、激活函数的选择： 学习率：影响模型收敛速度和性能，可以采用学习率衰减策略。
批大小：影响梯度更新频率和内存占用，选择适当大小有助于加快训练。
激活函数：根据任务需求选择适当的激活函数。
交叉验证、网格搜索等调参方法：
交叉验证：评估模型泛化能力，选择最佳超参数组合。
网格搜索：通过遍历不同超参数组合来寻找最优模型配置。
四. 实践与案例分析 实践项目：文本情感分类
项目描述： 任务：对电影评论进行情感分类，判断评论是正面还是负面情感。
数据集：使用IMDb数据集，包含大量电影评论和对应情感标签。
模型：使用卷积神经网络（CNN）进行文本分类。
设计过程：
数据预处理：文本分词、构建词典，将文本转换为词向量表示。
搭建CNN模型：包括卷积层、池化层和全连接层。
模型训练：选择合适的损失函数（如交叉熵损失）、优化器（如Adam）、正则化方法（如Dropout）进行训练。
代码示例：
数据预处理：
# 文本分词及构建词典 tokenizer = Tokenizer(num_words=max_words) tokenizer.fit_on_texts(texts) sequences = tokenizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e68903fb792ec7c8b8921a191b58d3b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c498b5982814bd7103bca0120424de7/" rel="bookmark">
			出行洞察：车载以太网未来已来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01核心观点
数据传输需求快速增长催化 E/E 架构变革。
由于车内 ADAS 及大量的传感器的数量提升，智能汽车迎来了从分布式向域集中式过渡阶段，从全车 100 余 ECU 到 5 个 DCU，控制功能迅速集中。在域集中式汽车架构设计中，域控制器处于需要强大的计算能力、超高的实时性能以及大量的通信外设。因此，大量的高速传输需求，带来了车载网络通讯的变革，我们认为以太网将成为域间控制器网络的网络骨干介质，并用于代替现有串行网络（如 MOST 和 FlexRay），未来高速总线将以以太网为主。
当前产业链以海外供应商为主，国产化替代空间较大。
车载以太网上游产业链主要包括芯片和处理器部分，大多为海外厂商供应。随着国产化需求的逐步提升，以及华为、百度等巨头对汽车行业的加码，国内厂商未来有望占据一席之地。例如，裕太车通和景略半导体均已在 2019 年成功研发出车载以太网 PHY 芯片，并已进入量产阶段，打破了海外芯片巨头公司在芯片领域的垄断。
以太网以新型网络的姿态介入汽车网络当然无法一蹴而就，在短期内是无法取代现有的车载网络，因此以太网在进入汽车网络时考虑分阶段、从子系统开始逐步深入，并最终整合汽车网络的演进过程。
第一阶段：子系统级别，单独在某个子系统使用以太网，这一阶段的衍生产品目前已经在整车上实施，如基于DoIP标准的OBD诊断设备；或已有示例应用，如使用 IP摄像头的驾驶辅助系统；
第二阶段：架构级别，将几个子系统功能整合，形成一个拥有功能集合的小系统；
第三阶段：域级别，以太网为车载网络骨干，集成动力总成、底盘、车身、多媒体、辅助驾驶，真正形成一个域级别的汽车网络。
02市场分析
// 全球及中国车载以太网市场规模预测
车载以太网网络架构主要包括网关、交换机、域控制器、连接器、双绞线缆等，各个域控制器均通过车载以太网总线连接网关的交换机，车载以太网交换机用于实现各个域控制器之间的信息交互，网关将通讯协议转换后的执行请求通过交换机转发给域控制器，实现各个域控制器之间信号的高效交互。
根据测算 2020 年单车车载以太网节点约为 6 个，随着域控制器需求的增加预计 2025 年提升至 13 个，2030 年提升至 17-20 个，节点数对应交换机需求数量，另外单车配备一个中央网关。从车载以太网的渗透率来看，我们预计2020 年渗透率约为10%，考虑到自动驾驶对车载以太网的需求方面，我们认为到 2030 年 L3 级别以上的自动驾驶车辆将以车载以太网技术为主，渗透率有望达到 50%。依照以上假设测算，我们预计 2030 年全球车载以太网上游网关和交换机市场规模约为 426 亿元，较 2020 年的 10 亿元增长超过 40 倍。
// 市场的驱动因素及趋势
▎应用驱动：
以太网的通用技术
就目前采用的车载网络技术，都是难以与外部设备及网络服务连接的封闭标准。究其原因，目前占主流的车载网络标准CAN、LIN及FlexRay，以及面向媒体的系统传输标准MOST等都具有浓重的“汽车行业”色彩，导致其应用的局限性，反之以太网是一种简单、成熟的开放标准，基于以太网的应用都极大地降低了应用成本。
高层应用对带宽的迫切需求
从功能性的角度，车载子系统增加，不同的子系统之间对共享数据的需求越来越多；另外随着摄像头分辨率的提升，显示需求大量增加，传统车载网络在带宽上面临巨大挑战，目前主导车载网络标准的CAN和FlexRay无疑将遭遇发展的瓶颈，在这方面最有竞争力的是MOST。MOST总线目前最大带宽为150 Mb/s，但MOST常用架构为多个设备共享带宽。与 MOST相比，以太网可以采用更为灵活的星形连接架构，使得每一条链路都可以专享 100 Mb/s 甚至更高的带宽。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c498b5982814bd7103bca0120424de7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53da2e4a8c9650654a03f4ad3a1c4d38/" rel="bookmark">
			车载以太网协议的架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		无论是软件定义汽车，还是分布式ECU抑或是自适应Autosar，都离不开智能汽车时代的基础技术车载以太网，对于硬件工程师来说，车载以太网物理层和交换机是其最关注的芯片，这也是利润率远超过高算力芯片的领域，也是基本上被欧美企业垄断的领域。
上图是整个车载以太网的7层OSI模型与标准分布图，我们最常提到的是TSN或EAVB，而物理层标准鲜少有人提及。因为绝大多数工程师都不会和物理层打交道。
很多人都在说域控制器、服务导向架构、分布式计算或软件定义汽车，殊不知关键的1G车载以太网物理层芯片在2020年才SOP，而多G带宽的车载以太网物理层标准才刚刚在去年完成，SOP还得一年或两三年左右。没有这个芯片，什么域控制器、服务导向架构、分布式计算或软件定义汽车都是空中楼阁。
全面使用域控制器、服务导向架构、分布式计算或软件定义汽车都需要以太网做骨干网，也就是多G以太网，而第一个支持多G车载以太网物理层的芯片在2020年11月才正式推出，量产估计要到2021年底或2022年初，也有可能到2022年底才量产。使用单一域控制器，也离不开1G车载以太网物理层芯片，而1G车载以太网物理层芯片量产是在2019年。
首先一个问题，为什么要独立制定一个车载以太网物理层标准？沿用传统以太网物理层不更好么？
传统以太网与车载以太网最大不同是传统以太网需要2-4对线，车载以太网只需一对，且是非屏蔽的，仅此一项，可以减少70-80%的连接器成本，可以减少30%的重量。这是车载以太网诞生的最主要原因。同时也是为了满足车内的EMC电磁干扰。
常见汽车传输界面特性一览表。
四个车载以太网物理层标准，车载以太网野心勃勃，10Base-T1S是试图取代传统的CAN网络的。第一个1000Base-T1标准的物理层芯片是Marvell的88Q2112，虽然其推出时间是2015年10月，但在2019年才量产，典型应用如英伟达的旗舰盒子Pegasus。
特斯拉最新的HW3.0使用Marvell的88EA1512，是20年前的传统以太网物理层标准。2020年10月，Marvell推出第三代产品，实际上88Q2112有两代，第一代没有量产，只是占个第一的位置。所以Marvell第三代型号是88Q222xM。
第三代特别增加对Open Alliance TC10，用于睡眠模式和唤醒。能够满足最严苛的ASIL-D级标准，在AEC-Q100温度上达到1级标准，也就是最高可承受125°高温，通常物理层芯片都是2级标准，即105°高温。除了Marvell，还有德州仪器、博通能提供1000Base-T1标准的物理层芯片。台湾Realtek有支持1000Base-T1标准物理层的交换机芯片。
博通在NGBase-T1的物理层芯片领域拔得头筹，2020年11月，博通宣布推出BCM8989X 和BCM8957X，BCM8989X是业内第一个对应NGBase-T1（即IEEE 802.3ch）标准的MACsec 物理层芯片，到目前为止，博通是唯一能提供NGBase-T1芯片的厂家。BCM8957X则是业内第一个支持10Mbps 到10Gbps速率的L2/L3级车载以太网交换机芯片。特斯拉与博通在下一代FSD芯片上有合作，但不大可能将多G物理层嵌入FSD中，因为物理层芯片一般都是独立的。还有一个IEEE 802.3cy，也就是10G以上车载以太网物理层标准，分别支持25、50、100G。
IEEE的车载以太网物理层基本上是全部照搬OPEN Alliance的标准，OPEN Alliance是非盈利性的汽车行业和技术联盟，旨在鼓励大规模使用以太网作为车联网标准。OPEN Alliance成员单位利用以太网的可扩展性和灵活性实现车联网低成本通信，减少通讯复杂性。以太网通信网络也是实现未来自动驾驶和智能网联汽车功能的重要组成部分。自建立以来，OPEN Alliance的成员单位已增至近400家。
10BASE-T1S即IEEE 802.3cg也就是 OPEN Alliance 的TC14 ，100BASE-T1即IEEE802.3bw也就是OPEN Alliance TC1，100/1000BASE-T1 ECU测试标准即OPEN Alliance的TC8， 1000BASE-T1即IEEE802.3bp也就是OPEN Alliance 的TC12，2.5/5/10GBASE-T1即IEEE802.3ch也就是OPEN Alliance 的TC15标准。
OPEN Alliance有18家发起(Promote)会员单位，2011年11月，宝马、博通和NXP成立OPEN Alliance，后来还有Marvell（原是Adopter会员，后提升）、通用、丰田、沃尔沃、大众、捷豹路虎（曾经是，目前退出）、现代、博世、瑞萨、大众、雷诺（曾经是，目前退出）、大陆汽车、奔驰（曾经是，目前退出）、三星哈曼（曾经是，目前退出）、现代、中国台湾瑞昱（曾经是，目前退出）。Promoter会员单位只能有原始的三家邀请才能成为Promoter会员单位。
另外每年交1500美元就能成为的Adopter会员，其中包括20家中国企业（可能有遗漏），这20家中国企业是：北汽、北京汽车研究总院、北汽福田、华晨汽车、一汽集团、航盛电子、台湾HTC、惠州华阳、豪恩、恒润科技、东软、宁波卡倍亿、泛亚汽车、台湾和硕、沈阳东信创智、深圳鹏毅实业、台湾凌阳创新、台湾凌阳科技、信利光电、信利半导体。虽然IEEE制定了标准，但车载以太网ECU测试标准是OPEN Alliance制定的。这里面涵盖了行业的全部有影响力的企业。
物理层标准再分为三层，即PCS、PMA和PMD。
PMA比较关键，变化也比较多。PCS子层负责3B2T（千兆车载以太网）编码，它可以把从GMII口接收到的8位并行的数据转换成10位并行的数据输出。因为10比特的数据能有效地减小直流分量，降低误码率，另外采用3B2T编码便于在数据中提取时钟和进行首发同步。可以把PCS两头看成GMII接口和TBI接口。PMA子层进一步将PCS子层的编码结果向各种物理媒体传送，主要是负责完成串并转换。PCS层以125M的速率并行传送10位代码到PMA层，由PMA层转换为1.25Gbps的串行数据流进行发送，以便实际能得到1Gbps的千兆以太网传送速率。可以把PMA子层的两头分别看做TBI接口和SGMII接口。PMD子层将对各种实际的物理媒体完成接口，完成真正的物理连接。
因为是非屏蔽单对线，担心有RF泄露，因此美国FCC会对此类产品做检验。车载以太网的测试是大麻烦，直到2021年2月，泰科才第一个推出满足IEEE 802.3ch MultiGBASE-T1规范的车载以太网测试系统。
全双工通信及 PAM3 信令为在真实世界条件下验证 ECU 增加了复杂度。大多数串行标准都在单工模式下工作，一次只有一台设备通信，有些通信标准对发送和接收使用一条单独的链路，而在汽车以太网中，主设备和从设备可以通过同一条链路同时通信。因此，来自主设备的信号与来自从设备的信号相互叠加。主设备知道它发送的是哪些数据，它可以从叠加的信号中确定从设备的信号，反之亦然。尽管收发机是为处理这种情况而设计的，但在示波器上隔离信号，进行信号完整性测试或协议解码几乎是不可能的。
测试需要昂贵的硬件和软件，还要有足够强的学习能力，几乎没有人熟悉这个领域。这个在开发后期需要频繁测试调整，租一套设备测试几乎是不可能的。硬件昂贵，像高带宽的示波器是很昂贵的，13G的示波器，大概200万人民币左右，硬件工程师得人手一个，可不是只买一个就行得，110G的示波器价格是百万美元。频谱仪，射频信号源，网络分析仪这些一旦上G带宽，都是数百万元价格。
主要测试内容如上表。物理层芯片是一个技术门槛非常高的领域，全球只有NXP、博通、Marvell、瑞昱、Microchip、德州仪器六家能够完成，因为物理层芯片是模拟领域。物理层芯片在发送数据的时候，收到MAC过来的数据（对物理层芯片来说，没有帧的概念，对它来说，都是数据而不管什么地址，数据还是CRC），每4bit就增加1bit的检错码，然后把并行数据转化为串行流数据，再按照物理层的编码规则（10Based-T的NRZ编码或100based-T的曼彻斯特编码）把数据编码，再变为模拟信号把数据送出去。
网线上的到底是模拟信号还是数字信号呢？答案是模拟信号，因为它传出和接收是采用的模拟的技术。虽然它传送的信息是数字的，并不是传送的信号是数字的。
众所周知，模拟IC处理的信号都具有连续性，可以转换为正弦波研究，而数字IC处理的是非连续性信号，都是脉冲方波。模拟电路比较注重经验，设计门槛高，学习周期10-15年；数字电路则有EDA工具辅助，学习周期2-3年。模拟IC强调的是高信噪比、低失真、低耗电、高可靠性和稳定性。产品一旦达到设计目标就具备长久的生命力，生命周期长达30年以上的模拟IC产品也不在少数。如运算放大器NE5532，生命周期超过50年，现在还在用。
数字IC多采用低压CMOS工艺，而模拟IC少采用CMOS工艺。因为模拟IC通常要输出高电压或者大电流来驱动其他元件，而CMOS工艺的驱动能力很差。此外，模拟IC最关键的是低失真和高信噪比，这两者都是在高电压下比较容易做到的。而CMOS工艺主要用在5V以下的低电压环境，并且持续朝低电压方向发展。
对于数字电路来说是没有噪音和失真的，数字电路设计者完全不用考虑这些因素。此外由于工艺技术的限制，模拟电路设计时应尽量少用或不用电阻和电容，特别是高阻值电阻和大容量电容，只有这样才能提高集成度和降低成本。某些射频IC在电路板的布局也必须考虑在内，而这些是数字IC设计所不用考虑的。因此模拟IC的设计者必须熟悉几乎所有的电子元器件特性，非15年以上经验不可。
另一个门槛是CDR，即时钟数据恢复，对于高速的串行总线来说，一般情况下都是通过数据编码把时钟信息嵌入到传输的数据流里，然后在接收端通过时钟恢复把时钟信息提取出来，并用这个恢复出来的时钟对数据进行采样，因此时钟恢复电路对于高速串行信号的传输和接收至关重要。
对于高速的串行总线来说，一般情况下都是通过数据编码把时钟信息嵌入到传输的数据流里，然后在接收端通过时钟恢复把时钟信息提取出来，并用这个恢复出来的时钟对数据进行采样，因此时钟恢复电路对于高速串行信号的传输和接收至关重要。
CDR接口的主要设计挑战是抖动，即实际数据传送位置相对于所期望位置的偏移。总抖动(TJ)由确定性抖动(DJ)和随机抖动(RJ)组成。大多数抖动是确定的，其分量包括码间干扰、串扰、占空失真和周期抖动(例如来自开关电源的干扰)。而随机抖动是半导体发热问题的副产品，无法科学预测，只能凭经验猜测。传送参考时钟、传送PLL、串化器和高速输出缓冲器都对会传送抖动造成影响。一般来说对低频的抖动容忍度很高，PLL电路能够很好地跟踪，恢复出来的时钟和被测信号一起抖动。高频比较麻烦，要设置PLL电路过滤掉，如何设置，没有电脑辅助，全靠经验，没有15年左右的经验是做不好的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec4133a8604c7328041664f903c8658/" rel="bookmark">
			Docker镜像常用管理命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号：“DevOps实战派”，获取更多DevOps和运维的精彩内容。
在容器的世界中，镜像是一切的基础。为了有效地管理和利用这些镜像，Docker提供了一系列强大的镜像管理命令。
本文将深入探讨这些命令，帮助你更好地使用容器镜像。
一. 搜索镜像 Docker默认会从Docker Hub的网站下载镜像，在下载之前我们可以使用docker search 命令搜索该站点上的镜像仓库，该命令会列出相关的仓库信息。
例如，要搜索所有与Nginx相关的镜像，可以运行以下命令：
$ docker search nginx NAME DESCRIPTION STARS OFFICIAL AUTOMATED nginx Official build of Nginx. 16272 [OK] jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 2115 [OK] richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 822 [OK] jc21/nginx-proxy-manager Docker container for managing Nginx proxy ho… 324 ...... 注：NAME字段为镜像仓库名称，搜索结果会列出网站上包括Docker官方以及第三方的镜像仓库，其中第一个带nginx关键字的为官方仓库，其他第三方镜像仓库会在前面带上名称空间信息；DESCRIPTION为仓库的描述；STARS可以理解为镜像的受欢迎程度，一般优先选择START多的镜像；OFFICIAL表示该镜像是否为官方镜像；AUTOMATED代表为自动构建；
命令支持以下选项：
-f, --filter filter ：根据条件过滤输出内容；
--format string :格式化输出内容；
--limit int :限制显示结果数量，默认为25个；
--no-trunc：显示完整信息；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dec4133a8604c7328041664f903c8658/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/001b3f5a657914c2c4eeb9e41b312c0e/" rel="bookmark">
			QTableWidget实现复制粘贴
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 实现功能
2 代码
1 实现功能 （1）选择一个单元格复制，可进行多个单元格粘贴
（2）选择多个单元格复制，可进行同样多单元格粘贴，行列均可
2 代码 void TableWidgetClass::keyPressEvent(QKeyEvent *event) { if (event-&gt;modifiers() == Qt::ControlModifier &amp;&amp; event-&gt;key() == Qt::Key_C) { // 实现复制逻辑 QTableWidgetItem *item; //QMimeData *mimeData = new QMimeData; QString list; for (int i = 0; i &lt; selectedItems().count(); ++i) { item = selectedItems().at(i); if(item-&gt;text().isEmpty()) list += " "; else list += item-&gt;text(); list += "\n"; } //mimeData-&gt;setText(list); m_Clipboard-&gt;setText(list); QString list1 = m_Clipboard-&gt;text(); list1.trimmed(); } else if (event-&gt;modifiers() == Qt::ControlModifier &amp;&amp; event-&gt;key() == Qt::Key_V) { // 实现粘贴逻辑 QString mimeData = m_Clipboard-&gt;text(); if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/001b3f5a657914c2c4eeb9e41b312c0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f61a93045d82c4751b131fde3cf818a/" rel="bookmark">
			大文件切片上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		封装成通用组件：
&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 上传组件 --&gt; &lt;el-upload action="" :auto-upload="false" :show-file-list="false" :on-change="handleChange"&gt; &lt;el-button size="small" type="primary"&gt;点击上传&lt;/el-button&gt; &lt;div slot="tip" class="el-upload__tip"&gt;{{ placeholder }}&lt;/div&gt; &lt;/el-upload&gt; &lt;el-dialog title="提示" :visible.sync="dialog" width="400px" center&gt; &lt;div class="display-flex fd-column ai-center"&gt; &lt;p class="mt-0"&gt;关闭弹窗后可继续上传，不推荐关闭，以免文件传输失败&lt;/p&gt; &lt;el-progress type="circle" :percentage="Number(percent.toFixed())"&gt;&lt;/el-progress&gt; &lt;div class="mt-20"&gt; &lt;el-button type="primary" size="mini" @click="handleClickBtn"&gt;{{ upload | btnTextFilter}}&lt;/el-button&gt; &lt;el-button type="warning" size="mini" @click="handleClose"&gt;取消上传&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;div v-for="(item, index) in fileList" :key="index" class="display-flex ai-center jc-space-between fs-14 mt-6 cursor-pointer" :style="{width: fileWidth}"&gt; &lt;div class="display-flex ai-center" style="width: 90%;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f61a93045d82c4751b131fde3cf818a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b91d19ea8dc13220101635c82d704ee3/" rel="bookmark">
			Prometheus的24节实战课
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号：“DevOps实战派”，获取更多DevOps和运维的精彩内容。
本专栏是一套Prometheus的零基础入门教程，基于本人多年的实战经验编写而成，内容完整覆盖了产品的核心技术要点，适合想入门和进阶技术的朋友学习。整个系列总共24篇课程，由基础知识开始，逐步进阶学习，到最终掌握高级用法，手把手教你玩转Prometheus。
目前，教程已得到了不少购买读者的正向反馈，这也从侧面验证了教程的内容质量，毕竟说再多也没有读者的口碑来得实在。
在教程的置顶文章页，我提供了售后支持的微信号。如果在学习过程中有遇到问题，可以找我进行一对一的答疑解惑。这是我为购买读者提供的额外福利，在市场上没有上千元的课程都难有这种待遇，因为我相信这样能够帮助到你更好的学好课程。
专栏原价128元，限时优惠价49.9元。 后面我会逐步对价格进行调整，以更好地反映课程的价值和提供的服务。
如果有需要的朋友可以尽快入手，别错过优惠了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4cbec07b4ef43d769ffd4742bd2146/" rel="bookmark">
			ElasticSearch 8.x 使用 High Level Client 以 HTTPS 方式链接，SSL 证书、主机名验证器 各是什么，如何忽略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ElasticSearch 1、ElasticSearch学习随笔之基础介绍
2、ElasticSearch学习随笔之简单操作
3、ElasticSearch学习随笔之java api 操作
4、ElasticSearch学习随笔之SpringBoot Starter 操作
5、ElasticSearch学习随笔之嵌套操作
6、ElasticSearch学习随笔之分词算法
7、ElasticSearch学习随笔之高级检索
8、ELK技术栈介绍
9、Logstash部署与使用
10、ElasticSearch 7.x 版本使用 BulkProcessor 实现批量添加数据
11、ElasticSearch 8.x 弃用了 High Level REST Client，移除了 Java Transport Client，推荐使用 Elasticsearch Java API
12、ElasticSearch 8.x 使用 snapshot（快照）进行数据迁移
13、ElasticSearch 8.x 版本如何使用 SearchRequestBuilder 检索
14、ElasticSearch 8.x 使用 High Level Client 以 HTTPS 方式链接，SSL 证书、主机名验证器 各是什么，如何忽略
15、ElasticSearch 8.x 创建父子文档，用Join类型字段以及用has_child、has_parent 检索
ElasticSearch，创始人 Shay Banon（谢巴农）
本文主要讲解ElasticSearch 高级搜索实战，来满足复杂的业务场景，还是用 Kibana 来操作。
文章目录 ElasticSearch前言一：pom 依赖二：开放式连接方式三：用户名密码验证方式四：忽略 SSL证书 和 主机名验证4.1 忽略 SSL 认证方式一方式二方式三 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb4cbec07b4ef43d769ffd4742bd2146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27b8d4893a3b89025bbe29150a595622/" rel="bookmark">
			SpringBoot整合ActiveMQ步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot整合ActiveMQ主要涉及以下几个步骤：
添加依赖：在SpringBoot项目的pom.xml文件中添加ActiveMQ的依赖。 &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-spring&lt;/artifactId&gt; &lt;version&gt;版本号&lt;/version&gt; &lt;/dependency&gt; 请替换“版本号”为当前可用的ActiveMQ版本。
配置ActiveMQ：在SpringBoot的配置文件（如application.properties或application.yml）中添加ActiveMQ的配置信息，如连接工厂、目的地等。 spring.activemq.broker-url=tcp://localhost:61616 spring.activemq.user=admin spring.activemq.password=admin spring.jms.listener.container-type=default spring.jms.listener.acknowledge-mode=auto 创建JMS监听器：创建JMS监听器来监听ActiveMQ队列或主题的消息。 @JmsListener(destination = "yourQueueName") public void receiveMessage(String message) { System.out.println("Received message: " + message); } 在这里，“yourQueueName”是你要监听的队列名称，receiveMessage方法是接收到消息后的处理逻辑。
发送消息：在需要发送消息的地方，注入JmsTemplate并使用它来发送消息。 @Autowired private JmsTemplate jmsTemplate; public void sendMessage(String queueName, String message) { jmsTemplate.convertAndSend(queueName, message); } 在这里，“queueName”是你要发送消息到的队列名称，message是要发送的消息的内容。
运行和测试：启动SpringBoot应用和ActiveMQ服务，然后尝试发送和接收消息，确保整合成功。 注意：在实际应用中，你可能还需要考虑更多的配置和异常处理，如连接池、重试策略、消息持久化等。具体的配置和使用方式可以参考ActiveMQ和SpringBoot的官方文档。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc60e8192f02849a7a70dc49abd5ca14/" rel="bookmark">
			sed：替换整行内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要在文本文件中查找并替换指定的一行，可以使用sed命令。以下是一个基础的示例：
sed -i 's/old-line/new-line/g' filename 这个命令将在filename文件中查找所有出现的"old-line"，并用"new-line"替换它。
解析:
-i: 该选项告诉 sed 在原地（即在输入文件本身）进行编辑。's/old-line/new-line/g': 这是 sed 的命令部分。s 是替换操作的标志，old-line 是要查找的模式，new-line 是替换后的文本，g 标志表示全局替换（即替换每一行中的所有匹配项）。filename: 这是你要修改的文件名。 需要注意的是，如果 "old-line" 或 "new-line" 中包含斜杠 /（或其他特殊字符），你需要对其进行转义，比如 \/。
此外，上述命令将会替换文件中所有的"old-line"，而不只是一行。如果你知道具体的行号，你可以使用如下命令来替换指定行的内容：
sed -i '3s/.*/new-line/' filename 在这个命令中，数字 3 指定了你想要替换的行号。. 匹配任何字符，* 表示任意次数，所以 .* 代表整行。这样整个命令就表示将第三行的所有内容替换为 "new-line"。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb085fc7f609fd75492397051dd24de8/" rel="bookmark">
			Ubuntu系统开机异常：ACPI Error：AE_NOT_FOUND
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ACPI（Advanced Configuration and Power Interface）错误在开机时提示，它通常与计算机的 BIOS、UEFI 或固件设置有关。下面是一些解决方法：
方法1：更新系统
首先，确保你的Ubuntu系统是最新版本的。目前你正在使用 Ubuntu 20.04，但是如果不是最新的小版本，可能会遇到某些问题。运行以下命令来更新你的系统：
sudo apt update &amp;&amp; sudo apt -y upgrade
方法2：更新BIOS/UEFI
你可能需要更新你的计算机的 BIOS 或 UEFI 固件。这通常可以从你的设备制造商的网站上找到。
方法3：调整GRUB配置
你可以尝试修改 GRUB 引导加载器的配置添加或修改 ACPI 参数。
① 打开 /etc/default/grub 文件进行编辑：
sudo vim /etc/default/grub
② 找到 GRUB_CMDLINE_LINUX_DEFAULT 行，并尝试添加 acpi=off 或者 pci=noacpi，例如：
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash acpi=off"
或者
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash pci=noacpi"
③ 保存并关闭文件，然后更新 GRUB 配置：
sudo update-grub
④ 重启你的计算机以使更改生效。
请注意，关闭 ACPI 可能会导致电源管理问题，如电池寿命短和过度的 CPU 使用。这只应作为最后的手段来尝试，并且你应该在尽可能的情况下尝试更新 BIOS/UEFI。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/194065293b38b274d9a599c913fc5d63/" rel="bookmark">
			Ubuntu系统开机异常：initramfs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当 Ubuntu 开机进入 (initramfs) 提示时，通常是由于系统在启动过程中遇到了一些问题，比如文件系统错误或者硬盘问题。以下是一些可能的解决步骤：
方法1：使用 fsck 修复文件系统
在 (initramfs) 提示下，你可以尝试使用 fsck 命令修复文件系统：
fsck /dev/sda1
这里，/dev/sda1 是你的主分区。如果你不确定，可以尝试 fsck -l 来查看所有的分区。
此命令将检查并尝试修复任何文件系统错误。在某些情况下，你可能需要手动确认修复操作。完成后，重启你的计算机看看是否解决了问题。
方法2：检查 /etc/fstab 文件
/etc/fstab 文件包含了系统启动时需要挂载的分区信息。如果此文件有误，可能会导致系统无法正常启动。
在 (initramfs) 提示下，使用以下命令切换到 shell：
/bin/sh
然后尝试检查 /etc/fstab 文件：
cat /etc/fstab
检查此文件，确保所有列出的分区都存在，并且没有语法错误。
方法3：重新安装系统
如果以上方法都无法解决问题，你可能需要考虑备份你的数据，并重新安装 Ubuntu 系统。
注意：在执行这些操作时，请特别小心，因为它们可能会对你的数据产生影响。如果可能的话，最好先备份你的数据。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/56/">«</a>
	<span class="pagination__item pagination__item--current">57/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/58/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>