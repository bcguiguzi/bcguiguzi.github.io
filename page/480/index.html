<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59642d5dc4dc5c2a5da8ff330b44a8f8/" rel="bookmark">
			yacc&amp;lex-Chapter1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考资料 －《lex &amp; yacc 2nd》：下载地址参考 http://blog.csdn.net/a_flying_bird/article/details/52486815
本文即此书的学习笔记。
Lex 要点 扩展名 lex文件通常使用的后缀名： .l, .ll, .lex。——实际上，可以是任意的名称。
文件结构 文件内容分为三部分，各个部分之间以 %% 分隔：
%{ /* part 1: Definition Section. e.g.: Global declaration of C. */ %} %% /* part 2: Rules section. Rule = Pattern + Action. */ %% part 3: C codes. 注意，%} 不要写成 }% 了，否则 premature EOF。
%{ 和 %} 之间的内容会原封不动地拷贝到最后生成的c文件中，所以这里可以是任何合法的C代码。通常而言，这里放lex文件后面C代码要用到的一些东西。
lex文件生成c文件 使用lex命令，把lex文件转换成c文件（lex.yy.c）；在生成可执行文件的时候，要链接库文件l。示例：
lex simplest.l gcc lex.yy.c -ll -o test 示例 最简单的例子 对应En Page 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59642d5dc4dc5c2a5da8ff330b44a8f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34f6b76857587395bcbd672133b339cf/" rel="bookmark">
			c和c&#43;&#43;一些区别----01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于new和malloc的区别：
1.new关键字是c++的一部分，malloc是由C的库函数提供
2.new的分配的单位是以数据类型的字节数，而malloc 的单位是由单个的字节数
3.new的在空间分配后可以进行初始化（尽量一个初始化，多个不建议），但是malloc分配后不能直接的初始化；
关于指针和引用的区别：
1.引用访问一个变量的时候是直接的访问，而指针的访问时间接的访问
2.引用不需要空间的分配，而指针需要空间的分配指针的空间
3.引用的定义的时候就需要初始化，且只能对应一个；不能再引用其他的；
使用一个new,进行分配一个二维，三维数组的空间：
char (* pp)[2] = new char[2][2];
char (*ppp)[2][2][2] = new char [2][2][2];
宏函数和内联函数：
宏函数在预处理的时候就进行了替换；
在执行的时候减少了进行参数的分配参数空间的；
用编译的时间换取空间
内联函数，是将函数整个代码的替换，减少了函数的调用的和返回的时间；
关键字的register:
原本C语言的register主要是讲频繁使用的变量申请寄存器，减少对cpu的访问的时间和次数；
被register关键字的修饰的变量注意点：
1.register无法修饰全局的变量
2.被register修饰的变量无法取地址（&amp;）；
3.被修饰的变量需要时cpu能够接受的变量；
在c++里面，进行优化以后是可以进行去地址的；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f1347b442d1ef15cd81c06bdf22840/" rel="bookmark">
			用c&#43;&#43;建立一个形状类Shape作为基类，派生出圆类Circle和矩形类Rectangle，求出面积并获取相关信息。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体要求如下：
（1）形状类Shape
（a）保护数据成员
double x,y：对于不同的形状，x和y表示不同的含义，如对于圆，x和y均表示圆的半径，而对于矩形，x表示矩形的长，y表示矩形的宽。访问权限定义为保护类型是为了能被继承下去，以便派生类能直接访问x和y。
（b）公有成员函数
构造函数Shape(double _x,double _y)：用_x、_y分别初始化x、y。
double GetArea()：求面积，在此返回0.0。
（2）圆类Circle，从Shape公有派生
（a）公有成员函数
Circle(double r)：构造函数，并用r构造基类的x和y。
double GetArea()：求圆的面积。
double GetRadius()：获取圆的半径。
（3）矩形类Rectangle，从Shape公有派生
（a）公有成员函数
Rectangle(double l,double w) ：构造函数，并用l和w构造基类的x和y。
double GetArea()：求矩形的面积。
double GetLength()：获取矩形的长。
double GetWidth()：获取矩形的宽。
（4）在主函数中对派生类进行测试。注意，在程序的开头定义符号常量PI的值为3.14。测试的输出结果如下：
circle:r=1, area=3.14
rectangle:length=3, width=4, area=12
Shape.h
#ifndef _SHAPE_H_ #define _SHAPE_H_ class Shape{ protected: double x; double y; //对于不同的形状，x和y表示不同的含义，如对于圆，x和y均表示圆的半径，而对于矩形，x表示矩形的长，y表示矩形的宽。访问权限定义为保护类型是为了能被继承下去，以便派生类能直接访问x和y。 public: Shape(double _x,double _y); //用_x、_y分别初始化x、y。 double GetArea(); //求面积，在此返回0.0。 }; class Circle:public Shape{ public: Circle(double r); //构造函数，并用r构造基类的x和y。 double GetArea(); //求圆的面积。 double GetRadius(); //获取圆的半径。 }; class Rectangle:public Shape{ public: Rectangle(double l,double w) ; //构造函数，并用l和w构造基类的x和y。 double GetArea(); //求矩形的面积。 double GetLength(); //获取矩形的长。 double GetWidth(); //获取矩形的宽。	}; #endif Shape.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06f1347b442d1ef15cd81c06bdf22840/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bfbcf0335c82c2e290b15f31dc14e0e/" rel="bookmark">
			维纳过程（Wiener Process）与高斯过程（Gaussian Process）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 维纳过程又叫布朗运动过程（Brownian motion）；
1. 维纳过程 维纳过程 Wt 由如下性质所描述：
W0=1 , a.s.（a.s.，almost surely） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca030a6b192a58cb7b7f84e0494afd0b/" rel="bookmark">
			Hololens官方教程精简版 - 08. Sharing holograms（共享全息影像）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 注意：本文已更新到5.5.1f1版本
本篇集中学习全息影像“共享”的功能，以实现在同一房间的人，看到“同一个物体”。之所以打引号，是因为，每个人看到的并非同一个物体，只是空间位置等信息相同的同类物体而已。
要想实现这个效果，有以下几点需要注意：
需开启设备的Spatial Perception功能（在Player Settings…面板的Publishing Settings &gt; Capabilities中勾选）需开启设备的网络功能暂时只能两台以上真机测试，无法在Unity中测试（即便是Remoting连接Hololens也不行）设备在同一房间内（废话） 友情提醒：本章需在多台设备间折腾，把设备休眠时间设置得长一点，会方便很多。具体方法如下： 设备打开，浏览器访问设备IP，进入：Hololens Device Portal，Home菜单下有个Sleep settings，最长设置30分钟。
要实现共享全息影像的效果，主要掌握以下技术点：
使用Socket协议传递数据理解世界坐标系及空间锚点的使用（WorldAnchor及WorldAnchorStore）Sharing组件的使用（锚点的上传和下载） Chapter 1 - Unity Setup 请按照第一篇的教程，完成项目的创建。 新建文件夹：”Assets/_Scenes/Holograms 240/”新建场景：”Assets/_Scenes/Holograms 240/Holograms 240.unity”打开场景，删除默认的Main Camera将”Assets/HoloToolkit/Input/Prefabs/HololensCamera.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/Input/Prefabs/InputManager.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/Input/Prefabs/Cursor/DefaultCursor.prefab”添加到Hierarchy根级 在Hierarchy面板根级，添加一个Cube，设置如下： 本节完成！
Chapter 2 - 使用Socket协议传递数据 目标 使用HoloToolkit提供的Socket套件进行数据传输
实践 搭建Socket服务基础环境
首先要说明的是：HoloToolkit提供的Socket套件，使用的是RakNet，对其原理感兴趣的同学，可以去官网查看。
在下载的HoloToolkit-Unity开发包中，找到：”External\”文件夹，将其复制到项目目录下（与Assets文件夹同级目录）。如图： 点击Unity主菜单下的：HoloToolkit &gt; Sharing Service &gt; Launch Sharing Service，如图： 此时将会打开一个Socket服务端，如图所示，记录下IP，例如本例为：192.168.0.108 在Project面板中，找到：”Assets/HoloToolkit/Sharing/Prefabs/Sharing.prefab”，拖动到Hierarchy根级，并在其Inspector面板中找到Server Address属性，填写上面一步得到的IP地址。如图： 此步相当于为APP增加了一个Socket客户端。 以上步骤完成后，可以点击Play按钮，并观察Socket服务端界面，看是否有设备加入到服务器。如图： 创建Socket消息传输类
上一步中，我们利用HoloToolkit提供的Socket套件，搭建了基础数据传输环境（包含一个Socket服务端程序和一个Socket客户端连接组件），下面用一个移动Cube的例子来学习如何同步数据。
新建文件夹：”Assets/_Scenes/Holograms 240/Scripts/”新建脚本：”Assets/_Scenes/Holograms 240/Scripts/Cube240.cs”，附加给Cube，编写脚本如下： （代码适用：5.5.0f3版本）
using HoloToolkit.Unity.InputModule; using UnityEngine; public class Cube240 : MonoBehaviour, IInputClickHandler { // 是否正在移动 bool isMoving = false; // 单击Cube，切换是否移动 public void OnInputClicked(InputEventData eventData) { isMoving = !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca030a6b192a58cb7b7f84e0494afd0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c071918bd8e18f9bb77937612ed2724/" rel="bookmark">
			用js原生加jquery实现下拉跳转至商品详情页，上拉回到商品简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在做一个商城的项目时，做到商品详情页的时候需要实现这种下拉跳转到商品详情页加载许多图片，上拉回到商品简介的效果，并且需要用户在滑动时有一种费力的感觉。最初是通过iscroll插件实现的，但这个插件在使用时有太多坑儿，总是下面会出现大片空白，还找不到是哪里的问题。
这里用了js原生事件，核心是移动端的touchstart,touchmove,touchend三个事件，判断相对位移来绑定相应的事件。下面是相应的代码，效果还不是很完善。
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta name="viewport"
content="width=device-width,inital-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;&lt;/title&gt;
&lt;style&gt;
*{
margin: 0;
padding: 0;
}
html,body{
width:100%;
height: 100%;
background: pink;
font-size: overflow-y:scroll;
-webkit-overflow-scroll:touch;
overflow-scroll:touch;
}
header{
width:100%;
height: 100%;
background: yellow;
position: relative;
}
section{
width:100%;
height: 200%;
background: green;
display: none;
position: relative;
}
div{
background: #fff;
height: 50px;
text-align: center;
line-height: 50px;
width:100%;
}
div.header{
position: absolute;
bottom: -50px;
left: 0;
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c071918bd8e18f9bb77937612ed2724/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b870f1381bb77eb55fc7a31637caca99/" rel="bookmark">
			基于Redis&#43;MySQL&#43;MongoDB存储架构应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要： Redis+MySQL+MongoDB技术架构实现了本项目中大数据存储和实时云计算的需求。使用MongoDB切片的水平动态添加，可在不中断平台业务系统的同时保障扩容后的查询速度和云计算效能；依据切片键索引分片，位于各切片独立进行计算，使大数据下的实时分析成为现实。对于高频访问的数据放在了Redis中，有效地降低磁盘I/O，使业务系统响应更为敏捷，满足了高并发下应用服务的高呑吐要求。
关键词： 移动位置服务SaaS；Redis；MongoDB
基于移动位置服务的应用是根据用户所在位置提供的一种增值业务，主要通过移动定位技术获得其当前所在位置，在电子地图和业务平台的支持下，提供位置相关的信息服务。通过互联网提供软件服务的SaaS（Software as a Service）模式具有企业初期零投入，不需服务器、系统研发等软硬件投入等独特的优点，为广大中小企业解决前期资金投入不足的情况下开展信息化建设，引入管理信息系统提供了一个可行的模式。
1 项目简介
基于此需求背景提出开发一种面向中小企业移动位置服务的SaaS平台，帮助所有具有外勤、外巡、外服的户外工作业务的中小企业降低成本，将定位技术与智能手机客户端相结合，利用运营商的GSM/WCDMA等无线网络，为企业提供在外工作人员的具体位置和行走轨迹，同时实现考勤签到、快速审批、位置标注、语音群聊、数据上报、区域预警，更好地进行地理化分析、业绩审视，快速响应客户需求和有效管理员工，深度巩固企业在市场中主体地位和增强企业核心竞争力。
2 业务数据分析
移动位置服务的SaaS平台作为企业移动互联网应用，应用过程将积累大量数据。其中包括：静态信息（手机号码、注册信息、手机型号等）；位置信息（行动轨迹、速度、停留时间、地点属性）；与APP关联的数据（访问行为、社交行为、交易行为等）；交互特点（报告频率、数据类型与格式等）。其数据容量和特点较传统业务有较大地变化。
2.1 数据来源分析
数据来源包括终端采集的数据和SaaS平台数据，终端数据涵盖了Android、IOS智能终端和PC端，智能终端是企业应用的数据采集器，是企业人在业务活动中“人体器官”的延伸。同时还有部分数据源于PC端；另外系统运行过程中，会产生大量日志数据。
（1）终端采集的数据
①轨迹数据：以包括公司id、用户id、经纬度、地址、定位时间、定位类型等信息的一个数据样本为例，默认30 s采集一次，假如企业员工默认工作时间8小时，每个员工每天条数为2 080条，假定用户数为10 000，那么每天有2 080万条；单条数据占用空间184 KB，10 000用户一天占用空间约为3 GB。
②常规业务数据：常规业务数据种类有考勤、工作计划、工作日志、申请、事件提醒、通知公告、销售上报等；保守预计单条数据容量为512 KB，按每个用户每天产生15条相关业务，其数据量为7 680 KB，10 000用户一天产生数据量约为73 MB。
③即时聊天和工作微博数据：即时聊天和工作微博数据为非结构化数据，包含如下种类：语音、图片、文本、位置分享等。保守预计单条图片语音数据量为： 100 KB，按每个用户每天产生30条，其数据量为3 000 KB，10 000用户一天产生数据量约为28 GB。
（2）平台数据
作为服务众多企业的云平台，还有如下种类数据需要产生和管理：企业、企业组织、企业用户、用户通信录、用户通信录个性化备注、群组名片等；平台方面的数据暂且不作考量，与普遍的企业应用基本类似。
2.2 数据特点分析
（1）移动化。与PC应用相比较，移动应用数据采集的时空变化了，智能终端不知疲倦，可以自动采集上报如位置等信息；同时移动化使得采集数据的便捷性得到了极大提高，用手机拍照立即便可上传，相比过去的照相机采集没有空间限制也没有链接PC上传的限制。
（2）非结构化。采集的图片语音等媒体数据非结构化，例如采集门店的货品陈列的图片数据等，工作微博分享的数据文档化，与传统结构化、需要事务支持的数据有明显差异。
（3）平台级增量化。与以往企业级应用对应一家企业增量相比，平台级数据增量化带来的数据量巨大增加，通过上面的分析，10 000用户每天会带来大约30 GB的数据增量。30 GB数据有些均匀地提交到平台，有些会以峰值的方式提交到平台；考勤通常集中在上下班时段，而轨迹则均匀分布在所有上班时间。
针对以上数据分析，如何解决其大容量和非结构化数据特点面临的存储和处理的挑战？通过技术选型和前期的测试数据对比，选用了Redis+MySQL+Mongodb架构的解决方案。
3 相关技术
3.1 Redis简介
Redis（Remote Dictionary Server）是一个使用ANSI C语言开发的开源的Key-Value存储系统，它和目前较流行的Memcached类似，都是基于内存（缓存）的数据存储方式，不同的是Redis支持的数据类型更加丰富并且对每种数据结构提供了丰富的操作。同时，Redis不同于Memcached之处在于它会将更新的数据异步的持久化到硬盘中或者把进行过的修改操作写入日志文件中。Redis虽然是Key/Value形式的数据库，但是它吸收了部分关系型数据库的优点，如在能保存Lists和Sets类型的数据的同时，还能完成排序等高级功能，同时在实现INCR（自增）、SETNX（若不存在Key则创建并设值）等功能时保证其操作的原子性。在此基础上还实现了Master-Slave（主从）同步[2]。Redis主从复制特点：（1）支持一个Master可以拥有多个Slave，同时Slave还可以接收其他的Slave；（2）主从复制不会阻塞Master和Slave，在同步数据时，Master和Slave都可以接收Client请求[2]。
3.2 MongoDB及其自动分片简介[3]
MongoDB是一个基于分布式文件存储的数据库[4]。由C++语言编写。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。MongoDB的特点是面向集合存储，模式自由，支持动态查询、完全索引、查询、复制和故障转移，自动处理碎片[5]。MongoDB的核心理念在于文档模型，它是MongoDB数据的基本单元，等价于关系型数据库的行。MongoDB中的集合等价于关系型数据库中的表。一个单一的MongoDB可以承载多个独立的数据库，每个数据库可以拥有自己的集合和管理权限。
MongoDB的分片架构是指把数据分割成不同部分，在不同的机器上的存储过程，通过分割数据到不同的服务器上，使得无需使用更强大的机器来存储更多的数据和处理更大的负载。MongoDB支持自动分片，集群可以自动分割数据和数据的再均衡。MongoDB提供以下的分片技术：（1）对负载的变换和数据的分布自动平衡；（2）动态添加额外服务器；（3）无单点故障；（4）自动故障转移[6]。
4 技术实现
4.1 架构功能角色
Redis+MySQL+Mongodb架构对应功能角色如下。
Redis：基于内存高速缓存，保存集群中央会话，即时通信离线消息队列，即时通信重发消息集合，用户令牌生命周期管理，应用高频访问数据缓存，HTML5模板数据缓存，静态应用资源缓存。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b870f1381bb77eb55fc7a31637caca99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99a09db1a397bedd0afe7d67728e4b87/" rel="bookmark">
			git报错：RPC failed; curl 18 transfer closed with outstanding read data remaining
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体报错
fatal: The remote end hung up unexpectedly
error: RPC failed; curl 18 transfer closed with outstanding read data remaining
解决方法
git config --global http.postBuffer 524288000
需要注意的是http.postBuffer 后，单位是b，524288000B也就500M左右
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d45db483c3e5859a15bba19a391e7e66/" rel="bookmark">
			排序之选择排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 思想：首先找到数组中最小的那个元素，其次，将它和数组中的第一个元素交换位置（如果第一个元素就是最小，那它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序这种方法叫选择排序，因为它在不断地选择剩余元素之中的最小着。 注意：对于长度为N的数组，选择排序大约需要（N^ 2）／2次比较和N次交换 特点： 1.运行时间和输入无关。 为了找出最小的元素而扫描一遍数组并不能为了下一遍扫描提供什么信息，这种性质在某种程度上来说是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或者主键全部相等的数组和一个元素随机排列的数组所用的时间是一样的长！ 2.数据移动是最少的。 每次交换都会改变两个数组元素的值，因此选择排序用了N次交换－－交换次数和数组的大小是线性的关系。（其他任何算法都不具有这个特征，大部分的增长是线性对数或是平方级的） java代码实现： /** * 选择排序 */ private void selectSort(int[] list) { // 需要遍历获得最小值的次数 // 要注意一点，当要排序 N 个数，已经经过 N-1 次遍历后，已经是有序数列 for (int i = 0; i &lt; list.length - 1; i++) { int temp = 0; int index = i; // 用来保存最小值得索引 // 寻找第i个小的数值 for (int j = i + 1; j &lt; list.length; j++) { if (list[index] &gt; list[j]) { index = j; } } // 将找到的第i个小的数值放在第i个位置上 temp = list[index]; list[index] = list[i]; list[i] = temp; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e2e79905662bdbbc0320700307d490b/" rel="bookmark">
			Hololens官方教程精简版 - 07. Spatial mapping（空间映射）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 注意：本文已更新到5.5.1f1版本
个人建议，学习Holograms 230之前，一定完成《Hololens官方教程精简版 - 02. Introduction with Device》的学习。
本篇集中学习空间映射功能，完成以下目标：
Chapter 1 - 空间扫描 目标 完成空间扫描替换三角面材质 实践 完成空间扫描
请按照第一篇的教程，完成项目的创建。 新建文件夹：”Assets/_Scenes/Holograms 230/”新建场景：”Assets/_Scenes/Holograms 230/Holograms 230.unity”打开场景，删除默认的Main Camera将”Assets/HoloToolkit/Input/Prefabs/HololensCamera.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/Input/Prefabs/InputManager.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/Input/Prefabs/Cursor/DefaultCursor.prefab”添加到Hierarchy根级 将”Assets/HoloToolkit/SpatialMapping/Prefabs/SpatialMapping.prefab”添加到Hierarchy根级 本节完成！
使用Hololens远程连接Unity进行调试，等待“一段时间”（这个一段时间，第一次可能很长……）。将会看到Hololens根据空间扫描结果，绘制了很多三角面。
替换三角面材质
点击SpatialMapping找到Inspector面板中的Surface Material，替换为SpatialUnderstandingSurface 本节完成！
再次测试，会发现三角面的材质被替换。
Chapter 2 - 扫描结果处理 目标 扫描结束后，用手势点击，将扫描结果转换为地板模型
实践 在Hierarchy面板根级，新建空对象，重命名为：Controller点击Controller，在Inspector面板中点击Add Component，加入：Surface Meshes To Planes组件点击Surface Meshes To Planes组件属性Surface Plane Prefab右侧的圆钮，选择：SurfacePlane同第2步相同的方法，为Controller添加Remove Surface Vertices新建文件夹：”Assets/_Scenes/Holograms 230/Scripts/”新建脚本文件：”Assets/_Scenes/Holograms 230/Scripts/Controller230.cs“，并附加到Controller上编辑脚本如下：
using System.Collections.Generic; using UnityEngine; using HoloToolkit.Unity; public class Controller230 : Singleton&lt;Controller230&gt; { [Tooltip("扫描过多少秒开始转换")] public float scanTime = 30.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e2e79905662bdbbc0320700307d490b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/544fa9db0a77da009a1631b5d1b757b5/" rel="bookmark">
			win10操作系统IE11浏览器的日期时间格式调整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、现象 自从升级了win10 以后，资产管理系统修改数据后就无法保存。 3.jpg (49.63 KB, 下载次数: 0) 下载附件 2017-1-10 11:19 上传 4.jpg (17.32 KB, 下载次数: 0) 下载附件 2017-1-10 11:20 上传 二、原因分析： 原因为win10 IE11浏览器调用了WIN10系统默认语言设置，一般我们系统默认语言都为中文，如截图中的“15-12-17 下午03时50分17秒”，导致保存时日期或时间值格式无法识别。 以前的win7系统中浏览器显示的时间格式是这样的。 1.jpg (59.07 KB, 下载次数: 0) 下载附件 2017-1-10 11:20 上传 三、设置 进入“控制面板”，选择“语言”，点击“高级设置”，在如下截图中勾选“不允许网站访问我的语言列表，转而使用我的日期、时间和数字格式的语言。” 2.jpg (58.7 KB, 下载次数: 0) 下载附件 2017-1-10 11:21 上传 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/10023411/viewspace-2132332/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/10023411/viewspace-2132332/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fc71a858d30320f79e847ceaf7d8928/" rel="bookmark">
			Android限制EditText只能输入中文或者指定内容的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目中要限制EditText中只能输入中文,之前写过一个限制EditText只能输入中文的实现,不过存在一些问题,而且扩展性不是很好,所以换了一种方法来实现. 先看一下效果图:
具体实现 一般对EditText的操作及处理都是用addTextChangedListener方法来对EditText进行监听,之后在监听方法中去做处理.这里也打算用这个种方法来做,大体的思路是监听EditText中输入的内容,然后将不是中文的部分清除掉,也就是置为空.所以大概应该这样写
mLimitEt.addTextChangedListener(new TextWatcher() { @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { // 1.处理输入的内容s:清除其中不是中文的部分 ... // 2.设置处理完的s mLimitEt.setText("处理之后的s"); } @Override public void afterTextChanged(Editable s) { } }); 处理的方法这里先不写,先来看一下这样写会出现的一个问题,运行一下,输入一些内容会发现程序崩溃了,查看崩溃信息,会发现出现了StackOverflowError异常,这是什么原因呢?带着疑问去扒了一下源码(看源码时遇到一个问题,升级完Studio之后,发现无法查看源码了,查了一些资料解决了,也有相同问题的童鞋可以参考下我写的 Mac版Android Studio查看不到源码的解决方法,windows版解决方法也类似)出现异常的位置在 mLimitEt.setText()这句代码上,所以先看一下setText()方法.setText方法在TextView中,看一下实现(这里只关心引起异常的部分,其他部分的内容不讨论)
private void setText(CharSequence text, BufferType type, boolean notifyBefore, int oldlen) { ... // Text改变前的回调处理 sendBeforeTextChanged(mText, 0, oldlen, text.length()); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fc71a858d30320f79e847ceaf7d8928/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acbaf03309b151e4b8988097bd198be7/" rel="bookmark">
			Java IO流学习总结一：输入输出流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java IO流学习总结一：输入输出流 转载请标明出处：http://blog.csdn.net/zhaoyanjun6/article/details/54292148
本文出自【赵彦军的博客】
Java IO流学习总结一：输入输出流
Java IO流学习总结二：File
Java IO流学习总结三：缓冲流-BufferedInputStream、BufferedOutputStream
Java IO流学习总结四：缓冲流-BufferedReader、BufferedWriter
Java IO流学习总结五：转换流-InputStreamReader、OutputStreamWriter
Java IO流学习总结六：ByteArrayInputStream、ByteArrayOutputStream
Java IO流学习总结七：Commons IO 2.5-FileUtils
2021年 Java Okio-更加高效易用的IO库
Java流类图结构： 流的概念和作用 流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。
IO流的分类 根据处理数据类型的不同分为：字符流和字节流根据数据流向不同分为：输入流和输出流 字符流和字节流 字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：
读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。
处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。
字节流：一次读入或读出是8位二进制。
字符流：一次读入或读出是16位二进制。
设备上的数据无论是图片或者视频，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。
结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。 输入流和输出流 输入流只能进行读操作，输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。
输入字节流 InputStream InputStream 是所有的输入字节流的父类，它是一个抽象类。ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。 输出字节流 OutputStream OutputStream 是所有的输出字节流的父类，它是一个抽象类。ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据。ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。 总结：
输入流：InputStream或者Reader：从文件中读到程序中；输出流：OutputStream或者Writer：从程序中输出到文件中； 节点流 节点流：直接与数据源相连，读入或读出。
直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。
常用的节点流 父　类 ：InputStream 、OutputStream、 Reader、 Writer文　件 ：FileInputStream 、 FileOutputStrean 、FileReader 、FileWriter 文件进行处理的节点流数　组 ：ByteArrayInputStream、 ByteArrayOutputStream、 CharArrayReader 、CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）字符串 ：StringReader、 StringWriter 对字符串进行处理的节点流管　道 ：PipedInputStream 、PipedOutputStream 、PipedReader 、PipedWriter 对管道进行处理的节点流 处理流 处理流和节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。如BufferedReader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acbaf03309b151e4b8988097bd198be7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f068e96c2cc6d64d0434f100dbecfc/" rel="bookmark">
			Mac版Android Studio查看不到源码的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写东西时,遇到些问题,想查看一下源码,看看问题出在那,然后在SDK Manager下载完源码后,还是查看不了,弹出找不到源码的提示,点也没反应,如下图:
查阅了一些资料,最终把问题解决了.记录一下步骤,之后遇到方便查阅.
步骤 先确认一下源码是否下载成功,打开SDK Manager,查看源码是否已经下载
确定源码下载成功后,找到~/Library/Preferences/AndroidStudioXXX目录,进入AndroidStudioXXX/options/ 里边有一个jdk.table.xml文件. 打开jdk.table.xml文件,找到源码相应版本的 &lt; sourcePath&gt;标签,把源码路径写进去就可以了
&lt;root type="simple" url="file://$USER_HOME$/Library/Android/sdk/sources/android-23" /&gt; 如图
保存后重启studio,源码就可以查看了 :) .
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a33b8ad560f059ad0b4b8d9127ed2812/" rel="bookmark">
			TNetHTTPClient演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TNetHTTPClient演示
TNetHTTPClient是DELPHI新增加的异步HTTP通信控件（区别于INDY的阻塞控件）。
unit Unit1;
interface
uses
Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants,
System.Classes, Vcl.Graphics,
Vcl.Controls, Vcl.Forms, Vcl.Dialogs, System.Net.URLClient,
System.Net.HttpClient, System.Net.HttpClientComponent, Vcl.StdCtrls;
type
TForm1 = class(TForm)
NetHTTPClient1: TNetHTTPClient;
btnGet: TButton;
Memo1: TMemo;
btnSsl: TButton;
NetHTTPClient2: TNetHTTPClient;
btnPost: TButton;
procedure btnGetClick(Sender: TObject);
procedure NetHTTPClient1RequestCompleted(const Sender: TObject;
const AResponse: IHTTPResponse);
procedure btnSslClick(Sender: TObject);
procedure NetHTTPClient2RequestCompleted(const Sender: TObject;
const AResponse: IHTTPResponse);
procedure btnPostClick(Sender: TObject);
private
{ Private declarations }
public
{ Public declarations }
end;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a33b8ad560f059ad0b4b8d9127ed2812/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a2d8f8e19c58ea5521545967a9aef3/" rel="bookmark">
			AndroidStudio配置支持java1.8lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 android { compileSdkVersion 25 buildToolsVersion "25.0.2" defaultConfig { applicationId "com.xx.xxx" minSdkVersion 16 targetSdkVersion 25 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" //----------- jackOptions { enabled true } //------------ } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } //---------- compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } //----------- } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e71a33a337d1aaae2e8137ca871a8679/" rel="bookmark">
			你的团队需要一个会讲故事的人读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本书是一本讲述理论的图书，看完后最大的感受是当初应该尽量的购买原本读物。这本书宣讲的主题我认为非常好，第一次读这类主题的书，再结合上当下工作环境，感觉本书给了我一定的启发，整体下来这书值得一看，当然如果带上一个完整故事案例就是完美了。本书宣讲的理论是”我们应该学会用故事思维来解决问题”,罗振宇说：不管是日常社交还是职场，做营销还是做管理，只要你想影响其他人，那讲故事的能力就是你不能缺的核心能力，而很多朋友偏偏缺的就是这个。什么样的故事最能打动人：特斯拉早年遇到的最大问题是：延迟交货。这不是饥饿营销，而是公司就是没有办法把已经预售出去的车真实生产出来。客户和媒体都对特斯拉展开批评。一次，在门罗公园的展示会上，穿着皮夹克、宽松长裤和皮鞋的马斯克（特斯拉的CEO），在谈论将要装在车上的马达时，先是谈论了一下马达的性能，然后，出乎所有人意料，举起了重量超过45公斤的马达。结果是，虽然客户仍然对车迟迟不能交付抱怨很多，但马斯克的热情和对产品的热爱打动了他们。只有少数客户要求退还预付款。请相信，相比较单纯为了钱的人，那些热爱产品的人更容易让消费者心甘情愿地花钱。人们之所以会抵触领导的决策，往往是因为他们不理解工作流程 ，或是缺乏宏观印象。如果你习惯了在故事中，清楚描述重要决策的形成过程，加入决策人、决策时间、决策地点这类细节，员工与你之间的信任会逐渐建立起来，以防将来时间紧迫时，无须多言也能让员工理解。如果有那么一天，你需要发布任务，但是没有时间让你解释，你的团队会根据以往你讲述的故事，推断相信这次的决策和之前的决策一样，都是在深思熟虑的基础上做出的。书中摘录： ★我们无法通过智力去影响别人，情感却能做到这一点。事实确实重要，但情感却能将事实的意义传达给你的听众。没有故事来赋予数字意义，就算是大数据也会降低实用价值。无论收集了多少数据，我们总是需要故事来理解和影响人类莫测的欲望和恐惧。 ★要找寻和讲述能让自己和听者都产生共鸣的故事，一旦掌握了这种技巧，你也就具备了说服、沟通、打动他人的基本技巧。一个善于讲故事的人懂得利用自身的情绪反应，来判断他人的情绪反应，从而加以运用。 ★学着讲自己的故事，实际上就是，学着在自己发出的信息中包含一丝人情味儿。自我感悟：工作十年，回忆下过往，中小型企业中初创小企业是最高效也是成本最低廉的，这里面的情感因素是：公司各种领导各类员工天天工作、加班及吃饭都在一起，时时刻刻有交流，时时刻刻刻有故事分享，员工较容易被领导高昂的斗志影响变得斗志十足；中型企业们是一个艰难的过渡，领导们影响力下降，中层人员成长需要时间，可是公司的发展需要中层成长的速度要比中层自身成长规律高速太多，工作的忙碌、培训机制的不健全等原因导致了中型企业中影响力变弱，从而导致企业核心战斗力(各个团队内成员)下降，自己的企业也是这样的状态，希望公司发展顺利，也希望自己可以按照自身的学习计划成长起来，并从这个过程中学到实际经验。脑补下巨头型的公司，这类公司没有亲身经历过，只是听朋友分享过在巨头型公司工作，能感觉的出，巨头型公司人才阶梯很严格，影响力逐级的下散，再加上晋升进制的健全、薪酬体系的完备等外在环境，更促成了巨头公司的不断螺旋上升。 参考资料： 1、 你的团队需要一个会讲故事的人 江苏凤凰文艺出版社 安妮特·西蒙斯 著 2、豆瓣网大牛的总结书评：豆瓣网大牛的书评感叹与大牛差距太大。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c78c82a565f2273bb85dd56e67e4375/" rel="bookmark">
			Android仿打字机打字效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近不太忙,看了看JS方面的知识,偶然看到一个打字机打字的效果,感觉挺棒的,就打算用android搞一个试试.为了不造重复的轮子,先在度娘上找了找,果然有前辈已经写过这方面的文章.所以参考了一下,并且加入了一些自己的想法,做了一些优化.先来看一下效果吧:
图片可能有点掉帧,实际效果更好一些.
一、简单分析 看到这个效果,想一想其实并不太难,做一个定时器,然后一点一点的把文字显示出来就可以了,为了更加像打字机的效果,可以在每一个字显示出来时在后边加上一些修饰的符号比如” _ “或者” | ” 这些.下边就来实现一下.
二、具体实现 比较简单,先看一下代码:
package com.example.junweiliu.printertextview; import android.content.Context; import android.util.AttributeSet; import android.widget.TextView; import java.util.Timer; import java.util.TimerTask; /** * Created by junweiliu on 16/12/29. */ public class PrinterTextView extends TextView { /** * TAG */ private static final String TAG = "PrinterTextView"; /** * 默认打字字符 */ private final String DEFAULT_INTERVAL_CHAR = "_"; /** * 默认打字间隔时间 */ private final int DEFAULT_TIME_DELAY = 80; /** * 计时器 */ private Timer mTimer; /** * 需要打字的文字 */ private String mPrintStr; /** * 间隔时间 */ private int intervalTime = DEFAULT_TIME_DELAY; /** * 间隔时间 */ private String intervalChar = DEFAULT_INTERVAL_CHAR; /** * 打字进度 */ private int printProgress = 0; public PrinterTextView(Context context) { super(context); } public PrinterTextView(Context context, AttributeSet attrs) { super(context, attrs); } public PrinterTextView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } /** * 设置要打字的文字 * * @param str */ public void setPrintText(String str) { setPrintText(str, DEFAULT_TIME_DELAY); } /** * 设置需要打字的文字及打字间隔 * * @param str 打字文字 * @param time 打字间隔(ms) */ public void setPrintText(String str, int time) { setPrintText(str, time, DEFAULT_INTERVAL_CHAR); } /** * 设置需要打字的文字,打字间隔,间隔符号 * * @param str 打字文字 * @param time 打字间隔(ms) * @param intervalChar 间隔符号("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c78c82a565f2273bb85dd56e67e4375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a187320da6b915639a119dd197acc6cc/" rel="bookmark">
			CS143-project4基于滑窗的人脸检测 Face detection with a sliding window
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用一个窗口（模板）对图像进行滑动计算匹配。是目标检测中的传统方法，尤其是人脸检测。
1.hog和方法简介
2.获取积极(人脸)特征
3.获取随机消极(非人脸)特征
4.训练模型
5.检测验证
一.hog和方法简介
方向梯度直方图(Histogram of Oriented Gradient)，简称HOG 是用于目标检测的描述算子
将每个图像划分为若干个cells，计算每个cell中像素的梯度，然后统计每个cell中不同梯度的直方图，形成一个完整的hog特征算子
这里直接调用开源api:vl_feat的vl_hog算法，得到我们想要的hog算子
我们先对训练数据进行标记，分为两类：人脸(积极positive)和非人脸(消极negative),是人脸则标记为1，非人脸标记为-1
然后分别获取两类图像的hog特征算子
使用svm或其他算法对训练数据进行训练
使用训练好的模型对测试集进行验证
二.获取积极(人脸)特征 get_positive_features
project已经提供了一些头像的图片，只需要读入这些图像，并生成对应的hog特征
代码：
function features_pos = get_positive_features(train_path_pos, feature_params)
% 'train_path_pos' is a string. This directory contains 36x36 images of
% faces
% 'feature_params' is a struct, with fields
% feature_params.template_size (probably 36), the number of pixels %块的大小
% 36*36个像素，一个块=6个cell*6个像素 cell包含像素越小越好，但是性能变差
% spanned by each train / test template and
% feature_params.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a187320da6b915639a119dd197acc6cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7696caca2918f22a0e6f29c27fefa04/" rel="bookmark">
			Linux设备驱动五 (1)总线、设备和驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sysfs文件系统
设备模型是2.6内核新引入的特征。设备模型提供了一个独立的机制专门来表示设备，并描述其在系统中的拓扑结构。
在2.4内核中，设备的信息放在/proc中。
而在2.6内核，内核把设备相关的信息归类在新增加sysfs文件系统，并将它挂载到/sys目录中，把设备信息归类的同时，让用户可以通过用户空间访问。
接下来简单介绍一些sys中的目录：
block：用于管理块设备，系统中的每一个块设备会在该目录下对应一个子目录。
bus：用于管理总线，没注册一条总线，在该目录下有一个对应的子目录。
其中，每个总线子目录下会有两个子目录：devices和drivers。
devices包含里系统中所有属于该总线的的设备。
drivers包含里系统中所有属于该总线的的驱动。
class：将系统中的设备按功能分类。
devices：该目录提供了系统中设备拓扑结构图。
dev：该目录已注册的设备节点的视图。
kernel：内核中的相关参数。
module：内核中的模块信息。
fireware：内核中的固件信息。
Fs：描述内核中的文件系统。
上面的目录，接下来的章节会常常提起bus和device。
再说说这些目录,来个简单的命令：
root@xiaobai-laptop:/sys# ll class/net/eth0
lrwxrwxrwx 1 root root 0 2011-01-31 10:11 class/net/eth0 -&gt; ../../devices/pci0000:00/0000:00:1c.5/0000:86:00.0/net/eth0/
上面的命令也可以看到class/net/eth0的路径其实就是devices目录中一个网卡设备的软连接。
贴个书上的图：
由上面两个例子看到，sys中的其他目录都是将devvice目录下的数据加以转换加工而得。上面的图中，将use设备归类到bus总线上，又把它归类到class。正是在sys中有很多这样的结构，内核就有一个完整而且复杂的拓扑结构图。
而维护这些关系的结构体就包括kobject、kset、ktype和subsystem等数据结构，不过这里就先不介绍。
通过设备模型，内核就能实现多种不同的任务，如：
1、电源管理和系统关机。
2、与用户空间通信。这个就比较容易理解，sys目录向用户展示了设备模型的结构图。
3、热插拔设备。大概意思就是，当设备插入后，内核会根据插入的设备安装驱动，设备拔出后，内核又会自动卸载驱动。
4、设备类型。将设备归类。
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
在接下来的内容会简单介绍总线、设备和驱动程序的概念和函数调用，以下的函数我将模拟创建一条ubs总线，一个usb设备和一个usb驱动。
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
二、总线
总线是处理器和设备之间的通道，在设备模型中，所有的设备都通过总线相连，以总线来管理设备和驱动函数。总线有bus_type结构表示。
/*linux/device.h*/
51 struct bus_type {
52 const char *name;
53 struct bus_attribute *bus_attrs;
54 struct device_attribute *dev_attrs;
55 struct driver_attribute *drv_attrs;
56
57 int (*match)(struct device *dev, struct device_driver *drv);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7696caca2918f22a0e6f29c27fefa04/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/479/">«</a>
	<span class="pagination__item pagination__item--current">480/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/481/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>