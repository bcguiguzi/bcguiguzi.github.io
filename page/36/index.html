<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d1c83cd101f2f5732af53d1c5d2656f/" rel="bookmark">
			将 create react app创建的项目迁移到vite时报错：useRoutes() may be used only in the context of a ＜Router＞ componen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 改之前
import React from 'react' import ReactDOM from 'react-dom/client' import App from './App.tsx' import './index.css' ReactDOM.createRoot(document.getElementById('root')!).render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, ) 改之后
import ReactDOM from 'react-dom/client' import App from './App.tsx' import './index.css' import { BrowserRouter } from 'react-router-dom'; const root = ReactDOM.createRoot(document.getElementById('root') as Element); root.render( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; ); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e470cd63ad0962ba3f59eeb1eb4d5e62/" rel="bookmark">
			记录 Dubbo&#43;Zookeeper 学习Demo
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Dubbo+Zookeeper ZookeeperZookeeper 下载可能出现的问题 辅助程序下载dubbo-admin项目打包工程打包常见问题 SpringBoot集成Dubbo项目依赖定义服务接口服务端实现服务端配置依赖代码实现 消费端实现服务端配置依赖代码实现 启动 结合Dubbo官网学习如何完成SpringBoot+Dubbo+Zookeeper集成的学习，本次采用环境如下：
开发工具：IntelliJ IDEA Community Edition 2023.2.5 （IDEA社区版 2023.2.5）开发环境：JDK 1.8，Windows 11Dubbo 3.2.0-beta.4，SpringBoot 2.7.8， Zookeeper 3.8.4辅助程序：dubbo-admin-develop Zookeeper Zookeeper 下载 下载地址：https://zookeeper.apache.org/releases.html#news
下载解压完毕后找到apache-zookeeper-3.8.4-bin/bin目录启动zkServer.cmd和zkcli.cmd文件，测试是否能够联通
出现以下效果说明zookeeper测试成功
可能出现的问题 启动zkServer.cmd时出现闪退
排除方法：使用文本编辑器打开zkServer.cmd文件，在末尾添加pause，解除闪退查看原因
截断之后发现原因时在conf文件夹下缺少zoo.cfg文件，那么复制zoo_sample.cfg文件修改成zoo.cfg即可，当然也可以自己编辑cfg的内容
tickTime=2000 initLimit=10 syncLimit=5 dataDir=/tmp/zookeeper clientPort=2181 admin.serverPort=8888 辅助程序 dubbo-admin-develop 主要是进入到dubbo-admin页面，可以查看服务提供者提供了什么服务，启动后页面如下：
下载dubbo-admin 下载地址：https://gitee.com/apache-dubbo/dubbo-admin
dubbo-admin环境：Node.js v16.3.0，npm 7.15.1，Maven 3.8.8，JDK 1.8，Zookeeper 3.8.4
项目打包 首先需要完成前端工程，打开项目，进入dubbo-admin-ui文件，进入命令行模式(cmd)，执行npm install 下载前端node_modules，完毕后再次运行命令npm run dev
完成前端工作后，回到dubbo-admin-develop文件夹，进入命令行模式(cmd)，执行mvn package -Dmaven.test.skip=true ，打包整体项目，完成之后进入到
工程打包 常见问题 常见问题见：https://blog.csdn.net/qq_43780610/article/details/136622497?spm=1001.2014.3001.5501
SpringBoot集成Dubbo 由于本人使用的社区版，所以搭建Springboot的方式是创建Maven项目，然后通过Maven配置SpringBoot依赖，觉得麻烦的可以自己去SpringBoot官网下载或者使用非社区版。
项目依赖 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e470cd63ad0962ba3f59eeb1eb4d5e62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/806d2a37a36901e30a78ccce7f92c60a/" rel="bookmark">
			TikTok数据采集技巧，轻松get！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		热身 - 用python写一个自动刷Tiktok的代码 用Python进行自动上下滑动手机屏幕通常涉及到用ADB(Android Debug Bridge)命令或Appium、Airtest这样的自动化工具。Android的话使用uiautomator2也是一个很不错的选择。
使用adb import subprocess def swipe_with_adb(start_x, start_y, end_x, end_y, duration=200): subprocess.run(f"adb shell input swipe {start_x} {start_y} {end_x} {end_y} {duration}", shell=True) # 向上滑动 swipe_with_adb(300, 1000, 300, 500) # 向下滑动 swipe_with_adb(300, 500, 300, 1000) 这个坐标可以通过配置文件读取，这样之后只需要修改配置文件就可以了，配置文件可以使用yaml或者config.ini格式。
如果你连接了多台设备，需要通过 ADB 指定设备进行滑动，你可以使用以下命令：
adb -s &lt;设备序列号&gt; shell input swipe x1 y1 x2 y2 这里 &lt;设备序列号&gt; 是你要操作的设备的序列号，可以通过 adb devices 命令来获取。x1 y1 x2 y2 是起始点和结束点的坐标。
以下是一个例子：
adb -s HT68B1A04448 shell input swipe 500 1000 500 500 这个命令会让编号为 HT68B1A04448 的设备从坐标 (500,1000) 滑动到 (500,500)。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/806d2a37a36901e30a78ccce7f92c60a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50d5718d0909f60c597888fa04a80d4c/" rel="bookmark">
			布隆过滤器和布谷鸟过滤器详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天和大家分享下布隆过滤器和布谷鸟过滤器
一.布隆过滤器
1.简单介绍
布隆过滤器是用于检索一个元素是否在一个集合中的算法，是一种用空间换时间的查询算法。
2.实现原理
布隆过滤器的存储结构是一个bitmap结构，初始值都是0，如下图所示：
当需要存储一个数据的时候，会通过多次(这里假设为3次)hash函数运算之后，计算出3个hash值，然后将计算出的这3个hash值当做坐标，将数组对应的坐标数据由0改成1，以此来标记这个数据已经存储在数组中了。如下图所示：
等到需要查询数据是否在数组中时，就通过hash计算出对应的坐标，判断是否全都为1，如果都为1数据就可能存在，如果有一个为0，则数据一定不存在。
为什么这里说可能存在能，因为可能会出现hash碰撞的情况，不同的数据经过hash函数运算之后，计算出来的hash坐标却相同，导致数据本来不存在数组中，但是这里却判断存在，因此布隆过滤器会出现误判的情况，但是概率会很低，误判的概率和设置的hash运算次数是成反比的。
如下图所示：
Data和Data2的hash值一样，但是Data数据存在，Data2不存在，在判断Data2的时候，布隆过滤器就会判断Data2也存在，由此产生误判。
这里有个很有意思的网站，大家可以自己动手去看下数据存储的具体过程：https://www.jasondavies.com/bloomfilter/网站内容如下:
总的来说，布隆过滤器的判断：存在-&gt;可能存在，不存在-&gt;一定不存在。
根据上述特性，布隆过滤器在很多场景下，可以帮我们判断大部分的判断请求。因此较多用于高并发的场景下使用，比如处理缓存击穿、用户视频推荐等场景。
3. 布隆过滤器的缺点
误判：
上文已经说明一点了，就是布隆过滤器会产生误判，在此就不过多赘述了。
当数组过大时，查询效率不高：
因为布隆过滤器的判断方式是根据多次hash值判断的，当数组过大，那么hash值的跨度可能就越大，跨度大就是不连续，那么CPU的缓存命中率就会变低，就会影响查询效率。
布隆过滤器不能删除元素：
因为不同的数据可能会计算出相同的hash值，因此我们如果要删除某个元素，可能也会影响其他的元素的判断。在这个限制条件下，当数据量大的时候，就会导致很多的垃圾数据。并且数据量越大，误判率也就会越高。
二.布谷鸟过滤器
1.简单介绍
布谷鸟过滤器可以说是一个增强版的布隆过滤器，可以删除元素，查询效率更高，空间利用率更高。
2.实现原理
布谷鸟过滤器不同于布隆过滤器主要有两点改动：
hash算法：
在布谷鸟过滤器中，数组中存储的是每个元素的"指纹信息"，也就是hash运算之后的几个bit位。查询数据的时候，就是看看对应的位置上有没有对应的“指纹”信息，删除数据的时候，也只是抹掉该位置上的“指纹”而已。
由于指纹是对元素进行 hash 计算得出的，那么必然会出现 hash 碰撞的问题，也就是“指纹”相同的情况，也就是会出现误判的情况，所以这点和布隆过滤器一样。
布谷鸟过滤器的hash算法是基于布谷鸟哈希算法做了改进，计算公式如下：
fp = fingerprint(x)
h1 = hash(x)
h2 = h1 ^ hash(fp) // 异或
在上列公式可以看出，h2的位置是根据h1的位置计算出来的，也就是说我们知道了其中一个位置，就可以直接获取到另外一个位置，不需要再做全量的hash运算。因为使用的异或运算，所以这两个位置具有对偶性。这也是提高查询效率的一个点。
只要保证 hash(fp) !=0，那么就可以确保 h2!=h1，也就可以确保不会出现自己踢自己的死循环问题了。
这里还有个注意点：就是hash运算的时候，并没有对值进行长度取模运算，那么他是如何保证计算出来hash坐标，一定是在数组长度范围内呢？这就说到布谷鸟过滤器的一个限制条件了，那就是强制数组的长度必须是 2 的指数倍
这个限制带来的好处就是，进行异或运算时，可以保证计算出来的下标一定是落在数组中的。
布谷鸟过滤器对布隆过滤器的另一个优化点就是存储结构：
布谷鸟过滤器的存储结构是每个坐标下的空位是多个，不同于布隆过滤器的一个空位。如下图所示：
布谷鸟过滤器会记录每个元素的两个hash位置，每个位置下都会有多个空位，空位内存储的就是元素的“指纹信息”。
布谷鸟过滤器添加元素的流程是这样的：
布谷鸟过滤器会先计算出元素对应的指纹信息，然后对元素进行hash运算，计算出元素的第一个存储坐标，该坐标下存在四个空位，如果四个空位中有空闲的，就将该元素的指纹信息存进去；如果没有空位，就会根据指纹和第一个hash坐标进行异或运算，计算出第二个坐标，如果第二个坐标下有空位，就将该元素的指纹信息存进去；如果还没有空位，那么该元素就会随机将一个空位中的指纹信息挤出，然后自己存进去，被挤出的指纹信息会计算出自己的第二个坐标，然后判断是否有空位，重复上述操作，直到达到一个阀值，布谷鸟过滤器返回false或进行扩容处理。
流程如下所示：
数据Data想要存储到布谷鸟过滤器中，首先会计算出h1和h2两个存储坐标，结果发现两个坐标的空位都已经“满员”了，此时会随机挤掉一个元素的指纹信息，假设挤掉了h1坐标的指纹3，然后指纹3会找自己的第二个坐标，然后判断是否有空位，有空位就存到第二个坐标下，如下图：
扩容：如果数组过小，会发生循环挤兑的情况，就可以设置最大挤兑次数，如果超过该次数，进行扩容，重新计算每个指纹的位置。
当 hash 函数固定为 2 个的时候，如果一个下标只能放一个元素，那么空间利用率是 50%。如果为 2，4，8 个元素的时候，空间利用率分别是 84%，95%，98%，可以发现空间利用率飙升。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50d5718d0909f60c597888fa04a80d4c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd0efbb138b010f645e98ef408b7bd5d/" rel="bookmark">
			关于C/C&#43;&#43;中指针概念与值传递的深入理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 基础知识的内容真是常看常新，这两天学习C++时看到了一段代码有些犯懵，所以弄明白之后将其记录一下。
问题起因 让我犯懵的主要是下面这段代码：
#include &lt;iostream&gt; using namespace std; void testPTR(int* p){ int a = 12; p = &amp;a; } int main(){ int a = 10; int* b = &amp;a; testPTR(b); cout &lt;&lt; a &lt;&lt; endl; //10 cout &lt;&lt; *b &lt;&lt; endl; //10 } 运行结果如下：
可以看到，a与 *b 的值都输出为10。
而我一开始认为这样不对，因为值传递嘛，b指针变量传入testPTR函数之后，应该相当于testPTR函数拷贝了一份b指针变量的内容，也就是testPTR函数内的指针p应该与main函数中的指针b指向同一个地方，那么在testPTR函数中对指针p指向进行修改以后，b指针也应该同时被修改指向啊？
那么在testPTR函数执行完毕之后其内存资源应该被清空，包括指针所指向的空间资源，那为什么main函数中的指针b还能正常输出呢？（先别骂先别骂，知道是很简单的问题，但是今天确实脑子抽了，反应了一会儿才想明白-_-||）
前置知识概述：指针基础 在正式分析刚刚的问题之前，我们需要明白一件非常重要的事情，即到底什么是指针：
1、指针其实就是地址，地址也就是指针。
2、因为指针本身也是一块内存区域，所以指针本身也有地址。
3、指针型变量和我们平常说的 int 型变量、char 型变量什么的是一个意思，只不过指针变量存储的内容是地址值，而如 int 型变量存储的则是 int 类型的数值。
4、所谓变量名，也就是声明了一个变量的动作内涵其实就是给一块内存地址空间取一个别名。
在上面的基础上，举个例子，从代码形式上理解：
//a 就是一个整形变量，其值是存储了一个字面值 10 int a = 10; //因此直接输出 a ，输出的就是其所存值的内容 cout &lt;&lt; a &lt;&lt; endl; //10 //输出a的地址，因为a是一块内存地址空间的别名，因此其具有地址 cout &lt;&lt; &amp;a &lt;&lt; endl;//比如为 0x123456 ------------------------指针变量与上述整形变量是类似的概念--------------------------------- //b 就是一个指针变量，其值是存储了一个变量 a 的地址值，也就是上述的 0x123456 int* b = &amp;a; //因此直接输出 b，输出的就是其所存值的内容：a的地址值0x123456 cout &lt;&lt; b &lt;&lt; endl;//0x123456 //输出b的地址，因为b作为指针变量它也是一块内存地址空间的别名，也具有地址 cout &lt;&lt; &amp;b &lt;&lt; endl;//如 0x123458 //通过解引用运算符*，我们可以拿到整形指针变量b所存储的地址空间上所存储的值 cout &lt;&lt; *b &lt;&lt; endl; //10 从图示上就更好理解了：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd0efbb138b010f645e98ef408b7bd5d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c9c6d619cd4b08b7fb8c47c60516ebc/" rel="bookmark">
			相机模型Omnidirectional Camera(全方位摄像机)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 背景 大多数商用相机都可以描述为针孔相机，通过透视投影进行建模。然而，有些投影系统的几何结构无法使用传统针孔模型来描述，因为成像设备引入了非常高的失真。其中一些系统就是全方位摄像机。
有几种方法可以制作全向相机。屈光照相机(Dioptric cameras)使用成形透镜的组合（例如鱼眼透镜；见图1a），并且可以达到甚至大于180度的视野（即略大于半球）。折反射相机(Catadioptric cameras)将标准相机与成型镜（如抛物面镜、双曲面镜或椭圆镜）相结合，在水平面上提供360度的视野，在仰角(elevation)上提供100度以上的视野。在图1b中，您可以看到使用双曲镜的折反射相机示例。最后，多折射相机使用多个具有重叠视场的相机，迄今为止是唯一提供真正全向（球形）视场（即4π立体视场）的相机。
折反射相机最早于1990年由Yagi和Kawato引入机器人学，他们使用折反射相机定位机器人。直到2000年，由于新的制造技术和精密工具，鱼眼相机才开始普及，使其视野增加到180度甚至更多。然而，直到2005年，这些相机才被小型化到1-2厘米的大小，并且它们的视野增加到190度甚至更大）。
2. 模型原理 Ocam模型成像参考D Scaramuzza，可分为两个过程，先将相机坐标系下的坐标转换成ocam坐标系下的角度，再根据θ计算畸变系数，进而计算像素坐标，需要注意Ocam相机是左手系，存在一个相机坐标系到Ocam坐标系的坐标变换，其θ角度与Fisheye不同。
2.1. Central omnidirectional cameras 当被观察物体的光线在3D中的一个点（称为投影中心或单有效视点）相交时，视觉系统被称为中心（图2）。此属性称为单一有效视点属性。透视相机(perspective camera)是中央投影系统的一个示例，因为所有光线(optical rays)在一个点（即相机光学中心）相交。
所有现代鱼眼相机都是中心的，因此，它们满足单一有效视点特性。相反，中央折反射相机只能通过适当选择镜子形状和相机与镜子之间的距离来构建。正如Baker和Nayar[6]所证明的，满足单视点特性的镜族是一类旋转（扫描）圆锥截面，即双曲、抛物线和椭圆镜。对于双曲线镜和椭圆镜，通过确保相机中心（即针孔或透镜中心）与双曲线（椭圆）的一个焦点重合来实现单视点特性（图3）。对于抛物面反射镜，必须在相机和反射镜之间插入正交透镜，这使得抛物面反射镜反射的平行光线可能会聚到相机中心（图3）。
单一有效视点之所以如此理想，是因为它允许用户从全向相机拍摄的图片中生成几何正确的透视图像（图4）。这是可能的，因为在单视点约束下，感知图像中的每一个像素测量是通过视点的光在特定方向上的辐照度。当全向相机的几何形状已知时，即相机校准时，可以为每个像素预先计算出该方向。因此，可以将每个像素测量的辐照度值映射到视点任意距离的平面上，形成平面透视图像。此外，可以将图像映射到以单个视点为中心的球体上，即球形投影(图4，底部)。单视点属性如此重要的另一个原因是它允许用户应用著名的视极几何理论，这对从运动到结构非常重要。极向几何适用于任何中央相机，无论是透视还是全向。
2.2. Omnidirectional camera model and calibration 直观地说，全向相机的模型比标准透视相机稍微复杂一点。该模型确实应该考虑折反射相机的镜面反射，或者鱼眼相机的镜头折射。由于这一领域的文献相当多，本章回顾了两种不同的预测
这些模型已经成为全方位视觉和机器人技术的标准。此外,
已经为这两个模型开发了Matlab工具箱，全世界的专家和非专家都在使用它们。
第一种模型称为中央折反射相机的统一投影模型。它是由Geyer和Daniilidis(后来由Barreto和Araujo[8]改进)在2000年开发的，他们的优点是提出了一个包括所有三种类型的中央折反射相机的模型，即使用双曲镜、抛物面镜或椭圆镜的相机。这个模型是专门为中央折反射相机开发的，对鱼眼相机无效。用折反射透镜近似鱼眼透镜模型通常是可能的-然而，只有有限的精度-在[9]中进行了研究。
相反，第二种模型将中心折反射相机和鱼眼相机统一在一个通用模型下，也称为泰勒模型。它由Scaramuzza等人在2006年开发[10,11]，其优点是折反射相机和屈光相机都可以用同一个模型来描述，即一个泰勒多项式。
2.3. Unified model for central catadioptric cameras(中央折反射相机的统一模型) Geyer和Daniilidis在2000年发表的具有里程碑意义的论文中指出，每一种折反射(抛物线、双曲线、椭圆线)和标准透视投影都等价于从一个以单一视点为中心的球体到一个以垂直于平面且距离较远的平面为投影中心的平面的投影映射。从球体的中心。图5总结了这一点。
本节的目标是找到场景点的观看方向和其对应图像点的像素坐标之间的关系。Geyer和Daniilidis的投影模型遵循四个步骤。设P = (x, y, z)为以C为中心的镜像参照系中的场景点(图5)。为了方便起见，我们假设镜子的对称轴与相机的光轴完全对齐。我们还假设相机和镜子的x轴和y轴是对齐的。因此，相机和镜像参考系的不同只是沿z轴的平移。
第一步是将场景点投射到单位球体上;因此:
然后将点坐标转换为以c为中心的新参照系= (0,0，…);因此:
范围在0(平面镜)和1(抛物面镜)之间。的正确值。可以通过知道圆锥曲线的焦点和直侧肌之间的距离d得到，如表1所示。圆锥剖面的直腹侧是通过平行于圆锥剖面准线的焦点的弦。
然后将p投影到距离c1的归一化图像平面上;因此,
最后，通过本征参数矩阵K将该点m映射到摄像机图像点p= (u, v, 1);因此,
很容易证明函数g.1是双射的，它的逆g由:
∝表示g与右边的量成正比。为了得到归一化因子，只要将g(m)归一化到单位球上就足够了。
式(6)可通过对式(3)求逆，加上p_s必须在单位球上的约束而得，因此。从这个约束条件，我们得到了zs作为xm和ym的函数的表达式。更多细节可以在[12]中找到。
可以看出式(6)是中心折反相机投影模型的核心。它表示了归一化图像平面上的点m与镜像参考系中单位向量Ps之间的关系。注意，对于平面镜，我们，成为透视相机的投影方程。
该模型已被证明能够准确地描述所有中心折反相机(抛物面镜、双曲镜和椭圆镜)和标准透视相机。Ying和Hu[9]在2004年提出了对鱼眼镜头模型的扩展。然而，通过折反射光学相机来接近鱼眼相机只能在有限的精度下工作。这主要是因为，虽然可以用精确的参数函数(抛物线、双曲线、椭圆)表示三种中心折射率相机，但鱼眼镜头的投影模型因相机而异，并取决于镜头的视场。为了克服这个问题，提出了一个新的统一模型，将在下一节中进行描述。
2.4. Unified model for catadioptric and fisheye cameras（折射率相机和鱼眼相机的统一模型） 该统一模型由Scaramuzza等人在2006年提出[10,11]。与前一个模型的主要区别在于函数g的选择。针对鱼眼相机参数化模型知识不足的问题，提出了利用泰勒多项式的方法，通过标定过程求出泰勒多项式的系数和度。因此,规范化的关系像点m= (xm, ym, 1)和鱼眼的单位向量Ps(镜子)参考系可以写成:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c9c6d619cd4b08b7fb8c47c60516ebc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be01c6beb6d2270f74b45e7a344da2e5/" rel="bookmark">
			define、const&amp;inline
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.#define宏的用法 #define用宏名代替一个字符串，这样便于修改，提高了程序的可移植性。编译器在编译预处理时只对宏做文本替换，而不进行类型检查，所以替换后可能产生一些副作用。
带参数的宏类似于函数调用，但是宏替换不是函数，二者不是一回事。
让我们从一道面试题开始：定义一个函数宏，求 x 的平方。
我们首先想到的是：#define SQR(x) x*x，以下测试代码运行一下，符合预期。
#include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define SQR(x) x*x int main(int argc, char* argv[]) { int a = 2; int s1 = SQR(a); printf("s = %d\n", s1); return EXIT_SUCCESS; } 接下来，对传入的参数稍作修改，变成加法表达式 a+b，其结果是预期的 25 吗？
int b = 3; int s2 = SQR(a+b); printf("s2 = %d\n", s2); gcc -E 预处理宏替换为 a+b*a+b，编译运行的结果=2+3*2+3=11。
你可能已经注意到宏替换展开的表达式中，运算符的优先级影响了计算的结果。
我们修改宏的定义：#define SQR(x) (x)*(x)，将算子用括号括起来，保证x可能展开的表达式的整体性。预处理展开为 (a+b)*(a+b)，运行结果符合预期为 25。
让我们继续来看一下下面一段测试代码，其结果是预期的 2 吗？
int c = 50; int s3 = 50 / SQR(a+b); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be01c6beb6d2270f74b45e7a344da2e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e9772759ce62fce234103b0cb5dc3ff/" rel="bookmark">
			工作安排提醒软件叫什么？如何高效管理时间？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在日常工作中，我总是忙于应对各种工作任务和个人事务，从早忙到晚，这包括项目截止日期、会议安排、家庭活动，甚至是我个人成长计划中的学习任务。要想在这种繁忙的生活中既能高效完成工作任务，又不遗漏任何重要的事项，就需要依靠一款强大的工作安排提醒软件进行时间管理。
那么，工作安排提醒软件叫什么呢？好用的时间管理APP有哪些？在我四处寻求解决方案的过程中，同事向我强烈推荐了一款名为敬业签的工作安排提醒软件。使用敬业签之后，我发现它不仅仅是一个简单的待办事项提醒工具，而是一个全面的时间管理平台。
在这款待办软件中，我可以根据工作内容、个人学习和家庭事务等不同方面创建多个待办分类。这样，每当我有新的任务时，我只需要在相应分类中添加一条新的待办事项，然后记录下具体的时间点，它的智能系统会自动为这条待办设置提醒时间，操作非常简单高效。
此外，所有设定了提醒时间的事项，都会按照“超时、今天、明天、未来”的提醒时间顺序显示在提醒列表中，这样的设计极大地方便了我对日程的管理和时间的规划。到了提醒时间，无论我是在使用手机还是电脑，敬业签都能够通过弹窗、响铃等多种方式准时提醒，确保我能够按时完成每一项计划安排。
使用它之后，我明显感觉到工作效率有了显著的提升。不仅如此，它还帮助我更好地平衡了工作和生活，让我能够在繁忙中找到属于自己的时间，用于学习和成长。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b68313660bd7829f114d9db1240fffe/" rel="bookmark">
			SQL Server错误：15404
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行维护计划失败，提示SQL Server Error 15404 无法获取有关... 异常如下图：
原因：数据库用户名与计算机名称不一致
解决办法：1.重名称数据库用户名 将前缀改成计算机名
2.重启SQL Server代理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c114071179d4decd2998d65f56b13fb7/" rel="bookmark">
			Ansys Lumerical | 激光雷达天线仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		附件下载 联系工作人员获取附件
在本文中，我们将了解如何根据激光雷达应用需求设计和优化相控阵光栅天线。
概述 激光雷达（LIDAR）是“light detection and ranging”的简称，近年来由于在机器人、自动驾驶汽车、高精度测绘等领域的快速应用而备受关注。由于具有高角度分辨率和很快的转向速度，目前最先进的激光雷达能够实现每秒对数百万个点进行测距。现有激光雷达架构中的光束转向机制通常分为两类：机械式（如基于旋转或 MEMS 的实现）和非机械式（最常见的是光学相控阵）。基于硅光子技术的光学相控阵具有大光学孔径和紧凑的占地面积，被认为是低成本、高速、坚固耐用的固态激光雷达的理想解决方案。在本示例中，我们展示了如何设计可同时用于发射和接收的集成光学相控阵天线，过程包括从单个天线元件的设计到相控阵的整体优化。最后，我们将展示如何INTERCONNECT中建立相控阵天线的紧凑模型，以便对激光雷达系统进行更大规模的仿真。
要了解整个激光雷达系统的工作原理，请参阅后文集成激光雷达系统概述 。
本示例的大部分内容是与Cadence Design Systems 和MathWorks合作开发的“更全面的激光雷达”研讨会的一部分，我们对他们的贡献表示感谢，特别是来自MathWorks的Rick Gentile，他开发了步骤3的大部分内容：使用MATLAB进行设计优化。
我们使用MODE的FDE求解器创建初始天线设计，使用3D FDTD验证设计，并提取天线参数，使用MATLAB的天线阵列和全局优化工具箱优化相控阵。最后，我们使用INTERCONNECT创建了一个紧凑模型。
步骤1：使用FDE求解器进行初始设计
使用FDE求解器计算波导有效折射率(neff)，它是与波导宽度相关的函数。也将选择光栅宽度和占空比。确定光栅波导的平均有效折射率，寻找避开波导光栅带隙的近正常发射所需的工作点，并以此为基础选择光栅间距。考虑直波导之间的频散耦合，估算可使用的最小波导间距。
步骤2：利用 3D FDTD 进行设计验证和参数提取
使用3D FDTD进行模拟，验证带隙和工作点是否符合预期。确定光栅的衰减长度。验证步骤1中估计的最小天线间距是否正确。提取远场辐射模式作为波长和其他参数的函数，以便后续在MATLAB和INTERCONNECT中使用。假设天线加权均匀的前提下，计算波束远场。
步骤3：使用 MATLAB 进行设计优化
在这一步中，我们将使用MATLAB来加载步骤2中计算的角度分布数据，并将波束可视化。优化天线权重和天线间距。分析制造缺陷造成的扰动对天线性能的影响。
步骤4：INTERCONNECT 中的相控阵紧凑模型
使用步骤2和3中确定的参数来更新INTERCONNECT中的天线阵列紧凑模型。运行测试仿真，绘制波束极角和方位角随时间变化的曲线。
运行和结果 模型运行说明和主要结果讨论
步骤 1：使用 FDE 求解器进行初始设计
初始模拟
1.在 MODE 中打开 LIDAR1.lms。
2.按 "运行 "按钮运行特征模态求解器。
这将弹出 "Eigensolver 分析窗口"（您可能需要解锁该窗口以将其放大），您可以按下 "计算模 式 "按钮。您将在 Eigensolver 分析窗口中看到如下所示的模式列表和相应的模式剖面图：
确定有效指数 (n eff ) 与波导宽度的关系
1.切换回布局模式。布局按钮位于 "运行 "按钮的位置：
2.打开"Optimization and sweeps"窗口，右键单击名为neff_vs_width的扫描项，然后选择"运行"。这将启动8项计算，在单独的进程中计算neff与宽度的函数关系。(如果找不到 "优化和扫描 "窗口，请用鼠标右键单击上部菜单栏，确保选中该窗口）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c114071179d4decd2998d65f56b13fb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc40b88f8edae5b4a70e4133751981f0/" rel="bookmark">
			MySQL 面试题及答案整理，最新面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL中InnoDB和MyISAM存储引擎的区别是什么？ InnoDB和MyISAM是MySQL中两种常见的存储引擎，它们的主要区别包括：
1、事务支持： InnoDB支持事务，而MyISAM不支持。
2、行级锁和表级锁： InnoDB提供行级锁，MyISAM提供表级锁。
3、外键支持： InnoDB支持外键约束，MyISAM不支持。
4、全文索引： MyISAM支持全文索引，而InnoDB在较早版本中不支持。
5、数据恢复： InnoDB提供事务日志，支持崩溃恢复。
6、存储限制： MyISAM支持较大的表，而InnoDB的表大小受到文件系统的限制。
MySQL中的索引类型及其使用场景。 MySQL中常见的索引类型包括：
1、B-Tree索引： 适用于全值匹配、匹配列前缀、匹配范围值、精确匹配和ORDER BY操作。
2、哈希索引： 适用于等值查询，但不支持范围查询。
3、全文索引： 用于全文搜索，主要在MyISAM引擎中。
4、空间索引： 用于地理数据存储。
5、复合索引： 包含多个列，适用于多列的查询条件。
根据不同的查询需求选择合适的索引类型可以显著提高查询效率。
MySQL中如何实现高效的分页查询？ 在MySQL中实现高效分页查询的方法包括：
1、避免OFFSET的大数值： 使用LIMIT时，较大的OFFSET值会导致性能问题。
2、使用覆盖索引： 确保查询只需要访问索引，不需要回表。
3、查询缓存： 利用查询缓存来存储分页结果，适用于数据变化不频繁的场景。
4、记住上次查询的最后位置： 而不是使用OFFSET。
MySQL中的锁机制有哪些类型？ MySQL中的锁机制包括：
1、表级锁： 锁定整个表，实现简单，开销小，但并发能力弱。
2、行级锁： 锁定单独的行，开销大，但并发能力强。
3、页面锁： 锁定相邻的一组行，是表级锁和行级锁的折中。
4、意向锁： InnoDB特有，用于指示行级锁的存在。
5、共享锁和排他锁： 共享锁允许其他事务读取，排他锁不允许其他事务访问。
MySQL中的事务隔离级别及其特点。 MySQL支持四种事务隔离级别，每种级别都有其特点：
1、READ UNCOMMITTED（未提交读）： 最低级别，允许读取未提交的数据变更，可能会导致脏读、不可重复读和幻读。
2、READ COMMITTED（提交读）： 允许读取并发事务已提交的数据，可以避免脏读，但不可重复读和幻读仍然可能发生。
3、REPEATABLE READ（可重复读）： MySQL默认级别。保证在同一个事务中多次读取同样数据的结果一致，但幻读可能发生。
4、SERIALIZABLE（可串行化）： 最高隔离级别，强制事务串行执行，避免脏读、不可重复读和幻读，但并发性能最差。
根据应用的具体需求选择合适的隔离级别，以平衡一致性和性能。
MySQL如何处理死锁？ MySQL处理死锁的方法包括：
1、死锁检测： InnoDB引擎具有死锁检测机制，能够检测到死锁并回滚一部分事务来解除死锁。
2、超时机制： 设置锁等待超时时间（innodb_lock_wait_timeout），超过时间未获得锁则事务回滚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc40b88f8edae5b4a70e4133751981f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ec98a557826739952458ab25819120e/" rel="bookmark">
			Flutter 的 switch 语句补遗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我的 App 里，一个消息气泡变成空白了，非常奇怪，此前一直是没问题的，经过调试定位我发现：
static TextSpan _buildRootSpan(BuildContext ctx, List&lt;LinkifyElement&gt; parts, TextStyle? style) { List&lt;InlineSpan&gt; children = []; for (var p in parts) { switch (p.runtimeType) { case TextElement _: children.add(TextSpan(text: p.text)); break; case UrlElement _: var url = p as UrlElement; var recognizer = TapGestureRecognizer(); recognizer.onTap = () { AutoRouter.of(ctx).push(WebRoute(targetUrl: url.url)); }; children.add(TextSpan( text: url.text, style: TextStyle( color: Theme.of(ctx).colorScheme.secondary, decoration: TextDecoration.underline, decorationColor: Theme.of(ctx).colorScheme.secondary, ), recognizer: recognizer, )); break; } } return TextSpan( style: style, children: children, ); } 问题出在这段代码里，最后的 TextSpan 返回的内容是空的。怎么会如此呢？从没改过这段代码。加了很多 Log 后，我发现，Switch 语句的所有 case 都没命中！我对 p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ec98a557826739952458ab25819120e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a6de7f3359d8ff06864bc55e5225d72/" rel="bookmark">
			基于SWOT的智能手机企业财务战略研究1.62
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 近些年，网络技术日新月异，智能手机深受消费者喜爱，人们通过网络，手机应用，可以极大地方便人们学习，工作等等。由于国家对电信行业的大力支持，中国消费者群体逐步成为最具潜力的手机购买者。本文以智能手机企业为立足点，宏观分析中国美国此类企业发展现状，再以华为手机、苹果手机作为具体案例swot分析各自优势劣势，机会威胁，通过对比，研究财务数据及相应的财务战略，分析企业核心竞争力并得出以下结论。华为公司抓住互联网的时代机遇，国家税收补贴，集中各种资源，努力提升自主创新能力，扩大研发团队及研发资金，专注于主营业务，秉持以客户为核心的理念，但仍要加强品牌建设，提升客户忠诚度和品牌认知度，并坚持投入资金用于研发和服务，制定合理的财务战略，保障企业持续经营，增强竞争力。
关键词：智能手机企业； SWOT分析方法； 财务战略；核心竞争力
ABSTRACT
These days, the revolution of information technology is happening, which is known as the Internet era. People use Internet technologies whenever and wherever they like, including their smart phones that can enrich and facilitate people’s daily life. As the country’s strong support for the telecommunications industry, China has gradually become the largest mobile phone sales market. In this paper, the overall picture of smart phone enterprises is analyzed.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a6de7f3359d8ff06864bc55e5225d72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/559487dab9be111ecc5d873a0cc7d2c2/" rel="bookmark">
			Pandas教程：DataFrame删除重复的行数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		---------------pandas数据分析集合---------------
Python教程71：学习Pandas中一维数组Series
Python教程74：Pandas中DataFrame数据创建方法及缺失值与重复值处理
Pandas数据化分析，DataFrame行列索引数据的选取，增加，修改和删除操作
Pandas教程05：DataFrame数据常用属性和方法汇总
Pandas教程06：DataFrame.merge数据的合并处理
Pandas教程07：DataFrame数据的算术运算+逻辑运算+describe()方法+统计函数+自定义函数运算
Pandas教程08：教你DataFrame数据的条件筛选——精选篇
Pandas教程09：使用date_range函数，创建时间序列数据
Pandas教程10：DataFrame数据可视化绘制折线图、柱状图、散点图、饼形图
Pandas教程11：关于pd.DataFrame.shift(1)数据下移的示例用法
Tkinter教程22：DataFrame数据加入到treeview树视图（含横纵滚动条+正反向排序）
Pandas教程12：常用的pd.set_option方法，显示所有行和列+不换行显示等等…
Pandas教程13：groupby函数的分组、聚合、转换和过滤操作
Pandas教程14：DataFrame数据合并（concat+merge+_append+join）的4种方法
Pandas教程15：多个DataFrame数据（保存+追加）为Excel表格数据
Pandas教程16：DataFrame列标题批量重命名+空df数据判断+列名顺序重排
在Pandas中，要删除DataFrame中的重复数据，您可以使用drop_duplicates()方法。这个方法会返回一个新的DataFrame，其中删除了重复的行。默认情况下，drop_duplicates()会考虑所有列来确定哪些行是重复的。
以下是如何使用drop_duplicates()来删除DataFrame中重复数据的示例：
# @Author : 小红牛 # 微信公众号：WdPython import pandas as pd # 创建一个包含重复数据的DataFrame data = { '股代码': ['sz300433', 'sz300433', 'sz600519', 'sz600519'], '时间': ['20240306', '20240306', '20240307', '20240307'], '金额': [630.85, 630.85, 1500, 1500], 'kind': ['B', 'S', 'S', 'S'] } df = pd.DataFrame(data) # 显示原始DataFrame print('1.原始DataFrame数据:'.center(30, '-')) print(df) # 2.删除重复数据，保留第一个出现的重复项（默认行为） df_no_duplicates = df.drop_duplicates() print('2.保留第一个重复数据:'.center(30, '-')) print(df_no_duplicates) # 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/559487dab9be111ecc5d873a0cc7d2c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b411a84343b4e50a301ce1d294b74a/" rel="bookmark">
			css3常见选择器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用工具 Visual Studio Code
1.CSS3基础选择器 1.1 标签选择器 1.2.1 标签选择器的语法 一个完整的HTML5页面是由很多不同的标签组成的，而标签选择器则决定标签应采用的CSS样式，语法如下:
标签名{
属性1：属性值1；
属性2：属性值2；
}
所有的HTML5标签都可以作为标签选择器
1.2 类选择器 1.2.1 类选择器的语法 类选择器使用英文"."进行标识，后面紧跟类名，语法如下:
.类名{
属性1：属性值1；
属性2：属性值2；
}
1.2.2 类选择器的引用方法 类名为HTML5元素的class属性，即&lt;标签名 class="类名"&gt;标签内容&lt;/标签名&gt;；
类名的第一个字符不能使用数字，并且严格区分大小写 ；
&lt;标签名 class = "class名"&gt;标签内容&lt;/标签名&gt;；
1.3 id选择器 1.3.1 id选择器的语法 在CSS中，ID选择器使用"#"进行标识，后面紧跟ID名，语法如下:
#ID名{
属性1：属性值1；
属性2：属性值2；
}
1.3.2 id选择器的引用方法 &lt;标签名 ID = "ID名"&gt;标签内容&lt;/标签名&gt;；
ID选择器在HTML页面中只能使用一次；
1.4 基础选择器的优先级 三种选择器的优先级是
id选择器&gt;类选择器&gt;标签选择器
2. CSS3高级选择器 CSS3高级选择器包含层次选择器、结构伪类选择器和属性选择器；
2.1 层次选择器 2.1.4 后代选择器 用来选择特定元素或元素组的后代，将对付元素的选择放在前面，对子元素的选择放在后面，中间加一个空格分开。(就是表示前面那个标签中所有的后面那个标签)
2.1.4 子选择器 子选择器与后代选择器容易混淆，因此请注意子选择器仅指它的直接后代，也可以理解为作用于子元素的第一个后代。子选择器通过&gt;标识符进行选择(就是表示前面那个标签中有直接关系的后面那个标签)
2.2 结构伪类选择器 在最后一个标签后加一个标签可以查找该父标签内内容的第几个该标签
2.2.1 first-child选择器 用于为父元素的第一个子元素设置样式；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b411a84343b4e50a301ce1d294b74a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1c5907d8f283632540ad24d04e3542/" rel="bookmark">
			Pandas教程17：关于json数据转化成DataFrame数据，消除警告提示的方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		---------------pandas数据分析集合---------------
Python教程71：学习Pandas中一维数组Series
Python教程74：Pandas中DataFrame数据创建方法及缺失值与重复值处理
Pandas数据化分析，DataFrame行列索引数据的选取，增加，修改和删除操作
Pandas教程05：DataFrame数据常用属性和方法汇总
Pandas教程06：DataFrame.merge数据的合并处理
Pandas教程07：DataFrame数据的算术运算+逻辑运算+describe()方法+统计函数+自定义函数运算
Pandas教程08：教你DataFrame数据的条件筛选——精选篇
Pandas教程09：使用date_range函数，创建时间序列数据
Pandas教程10：DataFrame数据可视化绘制折线图、柱状图、散点图、饼形图
Pandas教程11：关于pd.DataFrame.shift(1)数据下移的示例用法
Tkinter教程22：DataFrame数据加入到treeview树视图（含横纵滚动条+正反向排序）
Pandas教程12：常用的pd.set_option方法，显示所有行和列+不换行显示等等…
Pandas教程13：groupby函数的分组、聚合、转换和过滤操作
Pandas教程14：DataFrame数据合并（concat+merge+_append+join）的4种方法
Pandas教程15：多个DataFrame数据（保存+追加）为Excel表格数据
Pandas教程16：DataFrame列标题批量重命名+空df数据判断+列名顺序重排
1.遇到问题：比如你爬虫某网页数据，然后将json数据转化成df数据，运行程序后，下方输出会提示如下异常警告，这个警告是关于pandas库的read_json函数的使用。警告指出，直接将JSON字符串传递给read_json是已被弃用，并将在未来的版本中移除。为了从JSON字符串中读取数据，您应该将该字符串包装在StringIO对象中。
FutureWarning: Passing literal json to ‘read_json’ is deprecated and will be removed in a future version. To read from a literal string, wrap it in a ‘StringIO’ object.
2.解决办法，需要导入StringIO
from io import StringIO 使用StringIO将JSON字符串包装起来，再传递给read_json。再去运行程序就警告就消失了，并且代码在未来的pandas版本中仍然可以正常工作。
# @Author : 小红牛 # 微信公众号：WdPython from io import StringIO import pandas as pd # 假设你有以下JSON数据 json_data = ''' {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c1c5907d8f283632540ad24d04e3542/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdf05303f26bcf8f945ce0c6ce1640fb/" rel="bookmark">
			Redis底层数据结构之String
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 前提回顾2. RedisObject三大数据类型简介3. SDS字符串4. SDS字符串源码分析5. 总结 1. 前提回顾 前面我们说到redis的String数据结构在底层有多种编码方式。例如我们执行下面两条语句
set k1 v1 set age 17 我们查看类型，发现这类型都是String类型
我们现在查看底层的编码类型，发现编码类型一个是embstr一个是int类型，虽然都是String字符串，但redis根据value的不同类型设置了不同的编码方式
redisObject内部对应3大物理编码：int、embstr和raw
2. RedisObject三大数据类型简介 int 它保存long型（长整型）的64位（8个字节）有符号整数（9223372036854775807，最高19位）。
只有整数才会使用int类型去编码，如果是浮点数，redis内部其实先将浮点数转化为字符串值，然后再保存。
emstr 代表embstr格式的SDS（Simple Dynamic String 简单动态字符串），保存长度小于44字节的字符串，embstr即embedded String，表示嵌入式的String
raw 保存长度大于44字节的字符串
下面给演示一下各个类型的使用：
首先长度小于19位的数字，类型为int
浮点数底层为emstr
长度超过19的数字，类型为emstr
普通字符串是emstr
长度超过44的字符串，为raw类型
长度超过44的浮点数，为raw类型
3. SDS字符串 我们知道c语言底层表示字符串本质上是用的一个char数组。但是redis没有直接复用C语言的字符串的底层实现，而是新建了属于自己的结构—SDS，在redis数据库里，包含字符串值的键值对都是由SDS实现的（redis中所有的键都是由字符串对象实现的即底层是由SDS实现，Redis所有的值对象中包含的字符串对象底层也是SDS实现的）
我们看一下sds结构体的源码：
typedef char *sds; /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdf05303f26bcf8f945ce0c6ce1640fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3cae41e0c1b16f0affbcd5be92562379/" rel="bookmark">
			145.【JWT&#43;SpringSecurity】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JWT+Seacher (一)、未使用安全验证的SpringBoot程序1.未使用安全验证(1).依赖(2).控制层(3).测试(4).结论 (二)、认证授权等基本概念1.认证方式(authentlcation)(1).认证(authentlcation)(1.1).系统为什么要认证?(1.2).什么是认证 (登入)?(1.3).常见的用户身份认证方式 2.会话 (session)(1).什么是会话?(2).基于session的认证方式(3).基于token的认证方式 3.授权(authorization)(1). 为什么要授权 (控制资源被访问)?(2).什么是授权(给用户颁发权限) 4.RBAC(基于角色的访问控制)5.Java的安全框架 (三)、SpringSecurity1.什么是 spring security2.SpringSecurity 入门 (2⭐)(1).添加依赖(2).登入系统(3).退出系统(4).结论(10).问题 (密码默认随机，如何定制密码?) 3.认证入门3.1.使用配置文件配置用户名和密码 (3⭐)(1).添加依赖(2).配置文件(3).查看源码(4).问题 (如何定制多用户的密码和账户?) 3.2.基于内存的多用户管理 (4⭐)(1).添加依赖(2).配置文件(3).查看流程图(4).编写用户配置类(5).运行系统(6).配置加密器 (5⭐)(7).再次运行(8).问题 4.密码处理(1).为什么要加密?(2).加密方案(3).BCryptPasswordEncoder类初体验(4).配置BCryptPasswordEncoder(5).问题 (如何查看用户的权限和配置用户权限) 5. 查看当前登入用户信息及配置用户信息 (7⭐)(1).获取当前登入用户的信息(2).配置用户权限(3).问题 (我们对用户进行了认证，但是依然没有多大的实际拦截效果) 6.授权【URL级别的权限控制】(8⭐)(1).所有请求都拒绝执行(2).仅允许进入登入页面(3).允许所有请求操作(4).mvcMatchers 具体化控制权限 7.授权【方法级别的权限控制】 (9⭐)(1).配置环境(2).在serviceImpl上添加注解(3). 测试 8.SpringSecurity 返回json (10⭐)(1).搭建环境(2).用户详情配置类 (MySecurityUserConfig )(3).认证成功处理器配置类(AppAuthenticationSuccessHandler )(4).认证失败处理器配置类(AppAuthenticationFailHandler )(5).用户授权配置类(WebSecurityConfig ) 9. 使用UserDetailsService获取用户认证信息 (11⭐)(1).新建一个用户信息 (SecurityUser实现UserDetails接口)(2).新建一个UserServiceImpl实现UserDetailsService接口(3).修改WebSecurityConfig(授权配置类)(4).测试 10.基于数据库的认证 (12⭐)(1).搭建环境(2).新建一个用户信息 (SecurityUser实现UserDetails接口)(3).新建一个UserServiceImpl实现UserDetailsService接口(4).新建WebSecurityConfig(授权配置类)(5).控制层(Controller)(6).测试 11.基于数据库的授权 (12的基础上二次开发⭐)(1).查找数据库的权限(2).编写Mapper层接口(3).编写service层接口(4).修改一个用户信息 (SecurityUser实现UserDetails接口)(5).修改一个用户信息 (SecurityUser实现UserDetails接口)(6).测试 (四)、SpringSecurity集成1.SpringSecurity集成Thymeleaf (12的基础上三次开发⭐)(1).添加依赖(2).添加静态页面(3).添加控制层(4).修改WebSecurityConfig配置类(5).启动测试 2.SpringSecurity优化Thymeleaf(1).当用户没有某权限时，页面不展示按钮(2).导入依赖(3).在页面添加标签 3.Springsecurity 集成图片验证码 (12的基础上四次开发)(1).概述(2).原理、存在问题、解决思路(3).添加依赖(4).静态页面(5).修改WebSecurityConfig 配置类(6).编写CaptchaController 控制层(7).创建验证码过滤器(8).将验证码过滤器配置到SpringSecurity执行连(9).测试 (五)、Base64编码 ⭐1.什么是Base64(1).进行base64加密(2).是否可以使用base64进行密码加密?(3).对文件进行base64加密实操 2.Base64和BaseUrl的区别3.跨域认证问题和JWT实现登入原理(1).跨域认证问题(2).JWT实现登入原理 (六)、JWT学习1.简介2.用途3.JWT的组成(1).Header(2).Payload (负载)(3).Signature (保证数据安全的) 4.JWT的使用方式【重点】5.JWT的特点(1).JWT优点(2).Jwt缺点 6.Java中使用JWT(1).添加依赖(2).工具类(3).测试JWT(4).JWT的总结 (七)、JWT+SpringSecurity+Redis+MySQL 实现认证1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3cae41e0c1b16f0affbcd5be92562379/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d486b88e4b63586aa6307a91526252d4/" rel="bookmark">
			高中数学：对数及其运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、定义 由指数推导出对数
公式演化：
重要结论：
二、基本运算 1、数乘运算 系数与指数的相互转化
公式：
证明：
“下头”：指数变系数
“上头”：系数变指数
“下头”运算的逆运算
2、加减运算 加减运算化乘除运算
前提：底数相同
公式：
证明：
三、换底公式 处理的情况是，底数不同时的运算
公式：
常用的底数是10和e
自然对数e:e≈2.71828
四、例题 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c31ef5efbede6cbbc48ff328e43b02/" rel="bookmark">
			想当个运维总监有多难？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注公众号：“DevOps实战派”，获取更多DevOps和运维的精彩内容。
运维总监通常是运维人员向上发展的最高职位，再往上就是CTO和CIO这类职位，而那已经不属于运维的范畴。
不想做将军的士兵不是好士兵，有目标是好事，但前提是要有相应的实力可以匹配得上。那么，本文我们就来聊聊，要做一名优秀的运维总监，需要具备哪些能力呢？
下面是我整理了Boss上一堆相关职位后，为你总结出来的几条核心能力，供你参考比较，记得点赞收藏啦。
一. 技术专业知识
深入了解网络、操作系统、运维监控、云计算等技术领域。
具备基础设施和DevOps的多年实施经验。
能够解决复杂的技术问题，例如性能调优、框架搭建等。
二. 团队管理技能
领导和激励团队成员，使其能够高效地完成工作任务。
建立团队文化，促进合作和沟通。
招聘、培训和发展团队成员，以确保团队的技能和能力与业务需求保持同步。
三. 项目管理能力
规划和执行复杂的基础设施项目，确保项目按时、按预算完成。
管理资源，包括人力资源、物资和预算，以支持项目目标的实现。
识别和管理项目风险，并制定相应的风险应对策略。
四. 跨部门沟通与协调能力
与其他部门（例如开发团队、运营团队）紧密合作，确保IT基础设施与业务目标保持一致。
在跨部门项目中担任领导者的角色，协调各方利益，解决冲突和问题。
五. 战略规划和执行能力
制定并执行IT基础设施发展战略，以支持业务增长和创新。
评估新技术和解决方案，以确保公司保持竞争优势。
分析业务需求，制定长期和短期的IT规划，并调整战略以应对变化的业务环境。
六. 领导力和影响力
通过示范价值观和领导风格，激励团队成员达到最佳绩效。
在公司内部树立权威和信任，成为IT战略决策的关键参与者。
建立与高管层的良好关系，以确保运维部门的声音被充分听取和重视。
上面列出了一名优秀的运维总监应该具备的专业技能，其中的技术专业知识根据行业不同也会有所区别。例如互联网行业的运维总监对于技术能力的要求往往会高很多，总监通常具有专家级别的技术能力。而传统行业的中高级管理职位，则会更偏向其他的软技能。
当然，不管在哪类公司想要做到中高层职位，除了专业技能以外，其他软技能一样很重要。就像我之前说过的，技术能力决定了你的下限，技术能力强的一般不会混得太差。但软技能则决定你未来的上限，毕竟到了一定级别，很多事情不是光靠技术就能解决的了。
公众号好文推荐：
运维被裁后一周入职新公司，凭什么？
运维工程师的职业前景
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/35/">«</a>
	<span class="pagination__item pagination__item--current">36/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/37/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>