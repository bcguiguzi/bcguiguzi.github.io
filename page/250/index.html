<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be7b4e5bbf97b9edbe223baf4301d6f8/" rel="bookmark">
			JS中的事件冒泡和事件捕获
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当有很多盒子嵌套并且多层盒子都存在事件的时候，我们就必须要思考一个问题——这些事件的发生顺序。JS中用事件冒泡和事件捕获来处理事件流中事件发生顺序，在用addEventListener方法添加事件监听的时候，第三个参数用来控制是冒泡事件还是捕获事件（false为冒泡，true为捕获，默认值为false）。
事件冒泡 事件冒泡顾名思义，事件发生的顺序就像一个气泡从水底浮起那样，从底到顶，从内到外。
当只存在事件冒泡的时候，点击“李”的盒子，输出的答案如下图
可以看到从内到外依次输出了“li sun qian zhao”.
事件捕获 事件捕获与事件冒泡刚好相反，它是从顶到底，从外到内的。
当只存在事件捕获的时候，点击“李”的盒子，相信答案你已经想到了，如下图：
可以看到从外到内依次输出了“zhao qian sun li”.
事件冒泡和事件捕获同时存在 下面咱们来看一下如果两种处理方式都存在的时候，会产生怎么样的效果。
可以先思考下自己的答案，正确答案如下图：
如果对这个答案有些小疑惑，解释一下这个输出结果的原因：
当同时存在冒泡事件和捕获事件的时候，捕获事件的优先级比冒泡事件的优先级高，并且上面咱们说过，捕获事件是从外到内的，所以先输出了“qian”,然后输出了“sun”；而后冒泡事件是从内到外的，所以先输出“li”，然后输出“zhao”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8c5855c46c3bcdc03636a225f0a2d2e/" rel="bookmark">
			服务器被攻击网站打不开解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有很多服务器在阿里云的客户来找我们做防御，最多的就是网站业务了，相信有很多站长最为头疼的就是网站经常被攻击，怎么样才能有效的去防止自己的网站被攻击呢？下面小蚁君就详细的给大家介绍怎么有效的防止CC攻击、DDOS流量攻击这三种攻击，需要的站长朋友可以参考下
随着互联网的发展，越来越多的人们开始认识到网络宣传的优越性。大大小小的网站层出不穷。然而随着网站数量的增加，出现的问题也大大增多。同行之间的竞争、也随之体现在了网络之间。一些不法分子也逐渐转移阵地到网络上来谋取利益。同行之间往往雇佣黑客打压对手攻击对方网站，甚至有些人故意攻击别人网站索要保护费。不给钱就攻击你，让你网站瘫痪。对于这类事情，网站主往往是求助无门干着急，不得已妥协。
各位站长在做站的工程中应该都会遇到类似的问题，虽然我们勤勤恳恳的做自己的站，但是突然有一天会发现我们的网站突然就被人黑了，这时候只要我们打开自己网站的时候展现在我们面前的画面往往会让我们崩溃不已，此时各位站长的内心肯定是恨的牙痒痒，但是没有办法我们不惹别人，别人不一定就不惹我们，虽然心里很不舒服，但是问题也是需要解决的。
网站攻击一般分为2类，分别为CC攻击、DDOS流量攻击。
一、CC攻击
相对来说，这种攻击的危害大一些。主机空间都有一个参数 IIS 连接数，当被访问网站超出IIS 连接数时，网站就会出现Service Unavailable 。攻击者就是利用被控制的机器不断地向被攻击网站发送访问请求，迫使IIS 连接数超出限制，当CPU 资源或者带宽资源耗尽，那么网站也就被攻击垮了。对于达到百兆的攻击，防火墙就相当吃力，有时甚至造成防火墙的CPU资源耗尽造成防火墙死机。达到百兆以上，运营商一般都会在上层路由封这个被攻击的IP。
二、流量攻击
就是DDOS攻击，这种攻击的危害是最大的。原理就是向目标服务器发送大量数据包，占用其带宽。对于流量攻击，单纯地加防火墙没用，必须要有足够的带宽和防火墙配合起来才能防御。如果想防御10G 的流量攻击，那就必须用大约20G 的硬件防火墙加上近20G 的带宽资源。如果单用硬防机器的成本相当高，
如何使用高防来帮助网站防御DDOS攻击呢 1.隐藏网站源站ip提供安全性
隐藏源站服务器IP地址。cdn域名解析只针对解析记录值，不针对源服务器IP，从而隐藏源服务器IP地址。cdn可以多个高防节点可抵御大规模流量攻击，拦截并清洗大量的流量，减少因为流量攻击对业务造成的影响。高防CDN对外露出的是各网络节点的ip地址段,利用CDN网络节点IP实现对源站的业务转发,攻击者没法根据业务交互获得真实的用户源站,进而确保了源站的安全性。
2.高防cdn的防御机制
根据不同的攻击类型进行调整高防防护策略，以此更有效的拦截清洗攻击，把攻击对网站的影响降低。
3.缓存加速能力好
cdn本身可以就近抓取缓存文件，可以根据DNS智能解析来实现调度，还可以对业务网站中的静态数据资源进行提速，还可以对动态、静态资源的加速分发减少源服务器带宽消耗。速度提高啦，体验度增强，节省运营成本。
DDoS攻击防御方法
过滤不必要的服务和端口：可以使用Inexpress、Express、Forwarding等工具来过滤不必要的服务和端口，即在路由器上过滤假IP。只开放服务端口成为目前很多服务器的流行做法，例如WWW服务器那么只开放80而将其他所有端口关闭或在防火墙上做阻止策略。
异常流量的清洗过滤：通过DDOS硬件防火墙对异常流量的清洗过滤，通过数据包的规则过滤、数据流指纹检测过滤、及数据包内容定制过滤等顶尖技术能准确判断外来访问流量是否正常，进一步将异常流量禁止过滤。单台负载每秒可防御800-927万个syn攻击包。
分布式集群防御：这是目前网络安全界防御大规模DDOS攻击的有效办法。分布式集群防御的特点是在每个节点服务器配置多个IP地址(负载均衡)，并且每个节点能承受不低于50G的DDOS攻击，如一个节点受攻击无法提供服务，系统将会根据优先级设置自动切换另一个节点，并将攻击者的数据包全部返回发送点，使攻击源成为瘫痪状态。
高防智能DNS解析：高智能DNS解析系统与DDOS防御系统的完美结合，它颠覆了传统一个域名对应一个镜像的做法，智能根据用户的上网路线将DNS解析请求解析到用户所属网络的服务器。同时智能DNS解析系统还有宕机检测功能，随时可将瘫痪的服务器IP智能更换成正常服务器IP。
当发生DDOS攻击时，网络监控系统会侦测到网络流量的异常变化并发出报警。在系统自动检测或人工判断之后，可以识别出被攻击的虚拟机公网IP地址。这时高防CDN调用系统的防DDOS攻击功能将恶意攻击阻挡下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7144c26b4e68e6b8458df3fc4e13c3d/" rel="bookmark">
			韵达快递上门取件API技术对接文档 java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		韵达快递上门取件，是电商平台为寄件用户提供的通过一键下单到快递员，并在2小时上门取件的寄件服务。适用于散客在线寄件、电商退货上门取件等业务场景；通过API指令由系统自动将消息发送给物流公司和快递员，由快递员上门取货揽件与在线收款；解决寄件客户不用线下找快递员、不用苦苦等待，通过上门取件服务让客户可以轻松选择约定时间、地点完成寄件需求。
一、请求代码例示
import java.io.BufferedReader;
import java.io.IOException; import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.Map;
import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;
import java.security.MessageDigest; /**
*
* 韵达快递上门取件api接口
*
* ID和Key请到官网申请：http://www.kdniao.com/ServiceApply.aspx
*/
public class KdGoldAPIDemo {
//电商ID
private String EBusinessID="请到快递鸟官网申请http://www.kdniao.com/ServiceApply.aspx"; //电商加密私钥，快递提供，注意保管，不要泄漏
private String AppKey="请到快递鸟官网申请http://www.kdniao.com/ServiceApply.aspx"; //测试请求url
private string ReqURL = "http://testapi.kdniao.cc:8081/api/oorderservice";
//正式请求url
//private string ReqURL = "http://api.kdniao.cc/api/OOrderService";
/**
* Json方式 在线下单
* ​​@throws​​ Exception */
public String orderOnlineByJson() throws Exception{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a7144c26b4e68e6b8458df3fc4e13c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8e7992e117ac6ba84152993dd62d5e8/" rel="bookmark">
			网站被攻击最全面的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网站被攻击怎么办？作为一名站长，网站被攻击，总是在所难免。特别是一些个人或小企业网站，由于没有专业的程序员维护，三天两头打不开，被整的焦头烂额。不过面对网站攻击并不是束手无策而坐以待毙，网站被攻击恰恰说明网站存在安全漏洞，只要查缺补漏，加以防范，便可保持网站的正常运行。网站之所以存在漏洞，是因为电脑系统或网站程序不断被发觉新漏洞，不是很专业的程序员疏于防范，便给一些不法之徒带来可乘之机。为此，网站运维不是一个简单的事，需要程序员的专业技术、管理习惯、责任心息息相关。
当我们发现云服务器被攻击的时候，不要过度惊慌失措，先查看一下网站服务器是不是被黑了，找出网站存在的黑链，然后做好网站的安全防御，具体操作是：
1）断开所有网络连接。服务器之所以被攻击是因为连接在网络上，因此在确认系统遭受攻击后，一定要断开网络连接，即断开攻击。
2）开启IP禁PING，可以防止服务器被扫描。关闭不需要的服务端口，打开网站的防火墙。
3）备份系统数据。在备份系统数据时，一定要注意所备份数据是否夹杂攻击源，若存在，一定及时删除。
4）恢复网络连接。在一切都正常后，把系统连接到网络上，恢复服务。
一、网站被攻击的常见形式：
（一）网站网页被挂马：当我们打开网站网页时，会被浏览器或电脑安全管理软件提示，此网站存在风险、此网站被挂马等报告，是因为网页和根目录文件中被植入了js，当打开网页时，触发js的命令，自动执行含有木马的脚本或php文件，从而窃取用户的隐私数据。被攻击的网站往往是一些涉及虚拟货币或有交易性质的网站。
（二）网站网页中出现大量的黑链：网站的网页一般用户看着没有什么异常，但是在网站的源代码中，往往是在最底部，出现了大量的锚文本链接，而这些链接往往被隐藏起来，字体大小为0或极限便宜位置。被攻击的目的在于，一些黑客非法植入链接，来提高一些低权重网站的权重和流量而获取利益，而被攻击方的网站往往会被降权惩罚。被攻击的网站往往是一些存在一定搜索引擎权重和流量的网站。
（三）网站根目录中出现大量植入的网页：如果网站维护不及时，会发现网站收录突然暴增，而收录的内容都是非自身网站的内容，大多数是一些非法广告页面，诸如博彩、色情、游戏私服外挂等内容，我们检查服务器网站数据会发现大量植入的静态页。被攻击的网站广泛，特别是一些流量高的网站备受黑客青睐。
（四）网站网页打开自动跳转到其它网站页面：这种形式我们常常称之为非法桥页，在网页中植入的强制转的js，或入侵服务器，在iis中做了301重定向跳转，其目的在于黑客进行一些非法广告性或网站权重转移而从中获益。被攻击的对象往往是一些有权重、有流量的网站。
（五）网站数据库被植入新内容。网站数据被植入了一些新增加的内容，这些内容形式和网站其他数据看似正常，但是看时间日期，会发现内容往往比较集中，而并不是编辑人员添加的内容。这种网站往往是一些能够办理证件的网站，诸如职业资格证、毕业证等。黑客为一些非法客户在正规官网植入虚假职业信息，而从中获取高额利益。被攻击的网站往往是一些大学官网、教育部门网站或一些资质认定的网站。
（六）网站被攻击打不开会打开极为缓慢：网站网页经常打不开，或服务器无法远程连接，这种情况往往是由于企业竞争激烈，非法的竞争对手雇佣网络黑客，恶意攻击自己的网站程序和服务器，导致网站或服务器无法正常运行，诸如大量的DDoS攻击、CC攻击、直接破坏或删除网站数据。部分黑客存在心理扭曲、炫耀自己的能力进行恶意攻击。被攻击的网站往往是企业网站或一些维护水平较低存在大量安全漏洞的网站。
（七）网站和服务器密码被篡改：有时会发现网站和服务器的密码不正确，被篡改了。是因为黑客对存在漏洞的网站和服务器进行暴力破解，篡改了密码。其目的往往在于炫耀黑客技术能力，进行恶意的、非法的黑客技术操作。被攻击的网站甚至影响服务器里的所有网站。
（八）网站数据库丢失或损坏：有时发现自己的网站可以正常打开，但是无法再继续更新程序和新添加内容。这种情况往往是一些缺乏职业道德的离职程序员或黑客，进行恶意的攻击网站。被攻击的网站为各类网站。
（九）网站域名DNS劫持：打开自己的网站，内容却不是自己的网站内容，检查服务器和网站程序均正常，这种情况我们ping网站ip到时候已经不是自己的服务器ip，这种情况往往存在域名DNS劫持。其目的在于恶意的攻击炫耀或广告利益。被攻击的网站为所有类网站。
（十）网站服务器运行缓慢，被植入蠕虫等病毒：有时候站长会发现网站运行更新或在服务器操作异常缓慢，我们查看服务器的进程管理会发现，有运行占据高CPU、高内存的进程。这是查杀木马，往往会查出蠕虫等病毒。其目的在于占据网站资源，或服务器自身被攻击入侵，作为一种“肉鸡”用来攻击其他人的平台。被攻击网站，往往是一些高性能、高带宽的服务器。
如何使用高防来帮助网站防御DDOS攻击呢
1.隐藏网站源站ip提供安全性
隐藏源站服务器IP地址。cdn域名解析只针对解析记录值，不针对源服务器IP，从而隐藏源服务器IP地址。cdn可以多个高防节点可抵御大规模流量攻击，拦截并清洗大量的流量，减少因为流量攻击对业务造成的影响。高防CDN对外露出的是各网络节点的ip地址段,利用CDN网络节点IP实现对源站的业务转发,攻击者没法根据业务交互获得真实的用户源站,进而确保了源站的安全性。
2.高防cdn的防御机制
根据不同的攻击类型进行调整高防防护策略，以此更有效的拦截清洗攻击，把攻击对网站的影响降低。
3.缓存加速能力好
cdn本身可以就近抓取缓存文件，可以根据DNS智能解析来实现调度，还可以对业务网站中的静态数据资源进行提速，还可以对动态、静态资源的加速分发减少源服务器带宽消耗。速度提高啦，体验度增强，节省运营成本。
DDoS攻击防御方法
过滤不必要的服务和端口：可以使用Inexpress、Express、Forwarding等工具来过滤不必要的服务和端口，即在路由器上过滤假IP。只开放服务端口成为目前很多服务器的流行做法，例如WWW服务器那么只开放80而将其他所有端口关闭或在防火墙上做阻止策略。
异常流量的清洗过滤：通过DDOS硬件防火墙对异常流量的清洗过滤，通过数据包的规则过滤、数据流指纹检测过滤、及数据包内容定制过滤等顶尖技术能准确判断外来访问流量是否正常，进一步将异常流量禁止过滤。单台负载每秒可防御800-927万个syn攻击包。
分布式集群防御：这是目前网络安全界防御大规模DDOS攻击的有效办法。分布式集群防御的特点是在每个节点服务器配置多个IP地址(负载均衡)，并且每个节点能承受不低于50G的DDOS攻击，如一个节点受攻击无法提供服务，系统将会根据优先级设置自动切换另一个节点，并将攻击者的数据包全部返回发送点，使攻击源成为瘫痪状态。
高防智能DNS解析：高智能DNS解析系统与DDOS防御系统的完美结合，它颠覆了传统一个域名对应一个镜像的做法，智能根据用户的上网路线将DNS解析请求解析到用户所属网络的服务器。同时智能DNS解析系统还有宕机检测功能，随时可将瘫痪的服务器IP智能更换成正常服务器IP。
当发生DDOS攻击时，网络监控系统会侦测到网络流量的异常变化并发出报警。在系统自动检测或人工判断之后，可以识别出被攻击的虚拟机公网IP地址。这时高防CDN调用系统的防DDOS攻击功能将恶意攻击阻挡下来。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29d903b55c9dfc505ec579094690c129/" rel="bookmark">
			【题目记录】——ICPC上海2021
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 D Strange_Fractions 思维+数学E Strange_Integers 思维G Edge Groups 思维+数学I Steadily Growing Steam DP 题目集地址 第 46 届 ICPC 国际大学生程序设计竞赛亚洲区域赛（上海） 放假第一次训练，效果还不错，做了DE两个签到题 本次补题： DE（签到） G（树上DP） I（背包DP） J（位运算） K（构造） D Strange_Fractions 思维+数学 题目地址D Strange_Fractions
题目大意:给出一个分数 p q \frac{p}{q} qp​ ，现在找到两个正整数a , b a,ba,b使得等式 p q = a b + b a \frac{p}{q}=\frac{a}{b}+\frac{b}{a} qp​=ba​+ab​ ，如果无解就输出两个0
思路:将原问题转换，设 x = a b , t = p q x=\frac{a}{b},t=\frac{p}{q} x=ba​,t=qp​ ，那么原等式就可以变成 x + 1 x = t x+\frac{1}{x}=t x+x1​=t，等价于求解方程 x 2 − t x + 1 = 0 x^2-tx+1=0 x2−tx+1=0，可得解为 x = t ± ( t 2 − 4 ) 2 x=\frac{t±\sqrt{(t^2-4)}}{2} x=2t±(t2−4) ​​，可知题目条件是有理数解，那么 ( t 2 − 4 ) \sqrt{(t^2-4)} (t2−4) ​就必须是有理数，得出来的解分别对应 a b , b a \frac{a}{b},\frac{b}{a} ba​,ab​，因此直接对给定的q,p带入方程求出解，判断是否是有理数解即可，如果是，则进一步将求得的解化为分数形式获得a,b。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29d903b55c9dfc505ec579094690c129/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11a2502a0dd8f1b7cdb0c9d565e9b74b/" rel="bookmark">
			Linux 服务器突然连接不上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 一直可以正常连接的 Linux Ubuntu 系统服务器，重启虚拟机后连接失败，查阅好多资料，最终解决 是自己的 虚拟机服务器的 IP地址发生了变化。
解决办法 在 Windows 端xshell 终端连接时修改一下 用户ip, ssh new_ip， 此处修改为新的 remote host ip即可。
而我们一直在使用的 vscode remote 插件连接时连接不到，可以去重新修改一下配置文件，位置是 C\用户\自己的用户名\.ssh\config
推荐当连接不到服务器时首先 ifconfig 查看一下 服务器 ip是否发生变化。
分配新的 ip地址 的步骤
ifconfig -a 出现 ens33 不过分配的以太网，没有想要的 inet
sudo dhclient ens33 通过 dhclient 命令来获取ip地址。
sudo ifconfig ens33 就分配了 ip 地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ac18722cdfe18f7259124762f59b24/" rel="bookmark">
			web端攻击类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了各种类型的安全攻击和缓解它们的技术。
点击劫持 点击劫持是一种欺骗用户点击链接、按钮等的做法，这与用户认为的不同。例如，这可以用来窃取登录凭据或让用户在不知情的情况下安装恶意软件。（点击劫持有时被称为“用户界面纠正”，尽管这是对“纠正”一词的误用。）
跨站脚本 (XSS) 跨站点脚本 (XSS) 是一种安全漏洞，允许攻击者将恶意客户端代码注入网站。此代码由受害者执行，让攻击者绕过访问控制并冒充用户。根据开放 Web 应用程序安全项目，XSS 是2017 年第七大最常见的 Web 应用程序漏洞。
如果 Web 应用程序没有采用足够的验证或编码，这些攻击就会成功。用户的浏览器无法检测到恶意脚本是不可信的，因此可以访问任何 cookie、会话令牌或其他敏感的站点特定信息，或者让恶意脚本重写HTML内容。
跨站点脚本攻击通常发生在 1) 数据通过不受信任的来源（通常是 Web 请求）进入 Web 应用程序或 2) 动态内容在未经验证的情况下发送给 Web 用户是否存在恶意内容。
恶意内容通常包括JavaScript，但有时也包括 HTML、Flash 或浏览器可以执行的任何其他代码。基于 XSS 的攻击种类几乎是无限的，但它们通常包括向攻击者传输 cookie 或其他会话信息等私有数据，将受害者重定向到攻击者控制的网页，或在用户机器上执行其他恶意操作。伪装易受攻击的网站。
XSS 攻击可以分为三类：存储（也称为持久）、反射（也称为非持久）或基于 DOM。
存储型 XSS 攻击
注入的脚本永久存储在目标服务器上。然后，当浏览器发送数据请求时，受害者会从服务器检索此恶意脚本。
反射型 XSS 攻击
当用户被诱骗点击恶意链接、提交特制表单或浏览恶意网站时，注入的代码会传播到易受攻击的网站。Web 服务器将注入的脚本反射回用户的浏览器，例如在错误消息、搜索结果或任何其他响应中，其中包括作为请求的一部分发送到服务器的数据。浏览器执行代码是因为它假定响应来自用户已经与之交互的“可信”服务器。
基于 DOM 的 XSS 攻击
由于修改了原始客户端脚本使用的 DOM 环境（在受害者的浏览器中），payload 被执行。即页面本身并没有改变，但是页面中包含的客户端代码却因为对DOM环境的恶意修改而以意想不到的方式运行。
跨站请求伪造 (CSRF) CSRF（有时也称为 XSRF）是一类相关的攻击。攻击者使用户的浏览器在未经用户同意或不知情的情况下向网站后端执行请求。攻击者可以使用 XSS 载荷来发起 CSRF 攻击。
维基百科提到了 CSRF 的一个很好的例子。在这种情况下，某人包含的图片并非真正的图片（例如在未经过滤的聊天或论坛中），而是向您的银行服务器发出的取款请求：
&lt;img src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01ac18722cdfe18f7259124762f59b24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39c5574d5fe91d2ce838c1ace48b19e2/" rel="bookmark">
			2-蛇形矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蛇形矩阵 首先我们来看问题：
上面这个矩阵我们要怎么将它输出呢？
我们仔细观察这个矩阵，不难发现它是有一定规律的：它的数字沿着一条蛇一样弯曲排布：
那么问题来了，我们在电脑中输出都是以一行一行这样来输出的，这个矩阵的顺序明显不符合以行为参考时的输出方式，那我们就改个思路，既然不能按蛇形的顺序打印，但是我们可以按蛇形的顺序将数据存入一个数组呀，想到这里，我们就有一定方向了。
首先是写好用来存储的数组和打印函数：
#include&lt;stdio.h&gt; int main() { int arr[20][20] = { 0 }; int n = 0, m = 1; int i = 0, j = 0, flag = 0; scanf("%d", &amp;n); //... for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) printf("%-2d ", arr[i][j]); printf("\n"); } return 0; } 接下来就可以开始我们的核心部分，数据蛇形存放：
首先我们看看这个矩阵，每一次数据蛇形的方式都是向左下方移动或者向右上方移动，我们可以以此为突破口，每一次沿左下方移动就分别令控制数组下标的i 和 j分别加加和减减，以达到向左下方或者右上方移动的目的。
while (m &lt;= n * n) { //右上旋 while (i &gt;= 0 &amp;&amp; (m &lt;= n * n) &amp;&amp; j &lt;= n - 1) { arr[i][j] = m++; i--; j++; } //左下旋 while (j &gt;= 0 &amp;&amp; (m &lt;= n * n) &amp;&amp; i &lt;= n - 1) { arr[i][j] = m++; i++; j--; } } 然后就是要着重注意的问题是：每一次从左下旋到右上旋的转弯处的状态应该如何调整。这里要注意，位于分界线左端和右端以及分界线上的转弯状态都不同，所以要分情况，如下图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39c5574d5fe91d2ce838c1ace48b19e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20ea1f7a7721b04b7137896925f7519b/" rel="bookmark">
			PCL教程-点云分割之平面模型分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：Plane model segmentation — Point Cloud Library 0.0 documentation
基于RANSAC的基本检测算法虽然具有较高的鲁棒性和效率，但是目前仅针对平面，球，圆柱体，圆锥和圆环物种基本的基元。
在本次教程中，我们将学习对一组点云做简单的平面分割，也就是在点云中找到组成平面模型的所有点。
目录
程序代码
实验结果
程序分析
步骤1：创建在同一个平面上的点云（z=1）：
步骤2：设置几个平面外的点（z != 1)
步骤3：平面分割
步骤4：分割结果-系数因子
步骤5：分割结果-模型内点的下标
步骤6：打印结果并显示
CmakeLists.txt
程序代码 #include &lt;iostream&gt; #include &lt;pcl/ModelCoefficients.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/sample_consensus/method_types.h&gt; #include &lt;pcl/sample_consensus/model_types.h&gt; #include &lt;pcl/segmentation/sac_segmentation.h&gt; #include&lt;pcl/visualization/pcl_visualizer.h&gt; #include&lt;pcl/io/pcd_io.h&gt; #include&lt;vector&gt; int main(int argc, char** argv) { //原始点云 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); //平面上的点云 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_inner(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);	//平面外的点云 pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_outer(new pcl::PointCloud&lt;pcl::PointXYZ&gt;); //填充点云数据 (*cloud).width = 15; (*cloud).height = 1; (*cloud).points.resize((*cloud).width * (*cloud).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20ea1f7a7721b04b7137896925f7519b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20db70af6310ccfed415fd4875538a15/" rel="bookmark">
			PCL教程-点云分割之欧式聚类分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：Euclidean Cluster Extraction
目录
理论基础
程序代码
代码解析
使用Kd-tree作为抽取算法的搜索方法
创建EuclideanClusterExtraction对象，并设置参数
实验结果
点云处理全过程
滤波
平面分割并去除
聚类抽取
打印结果
CMakeLists.txt
在本篇教程中，我们将学习使用pcl::EuclideanClusterExtraction类提取欧几里德聚类。为了使本篇教程更加精简，之前教程中提到的知识点将不再重复说明，比如平面模型分割，可参考之前的博文：PCL教程-点云分割之平面模型分割
数据集下载链接： table_scene_lms400.pcd
理论基础 聚类方法，通过特征空间确定点与点之间的亲疏程度。
一个聚类方法需要将一个无序的点云模型P分割成更小的部分，使得处理P的整体时间显著减少。一种简单的欧氏聚类方法可以通过使用固定宽度的框对空间进行三维网格细分来实现，或者更普遍地说，使用八叉树数据结构。
这种特殊的表示非常快速，对于需要占用空间的体积表示，或者对每个结果3D盒子(或八叉树叶子)中的数据可以近似为不同的结构的情况非常有用。
然而，在更一般的意义上，我们可以利用最近邻并实现一种本质上类似于漫水填充算法的聚类技术。
假设我们使用的点云数据的场景为：一张桌子，以及桌子上放置的一些东西。我们要找出并分割平面上的单个目标点云族:
假设我们使用Kd-tree结构去查找最近邻，算法步骤如下：
为输入的点云数据集P创建Kd-tree的表示设置一个空的聚类列表C，以及一个需要被检查的点云队列Q然后对P中的每一个点p_i进行如下步骤： 将p_i添加到当前队列Q对每个Q中的 p_i 进行如下步骤： 设置半径 r&lt;d_th，在此范围内搜索 p_i 的 最近邻 点云集 P_i_k.对于每个最近邻点云集 P_i_k ,检查其中的点是否被处理过，如果没有被处理过，就添加到Q中。当Q中列表中的所有点都被处理完成了，把Q添加到聚类列表C中，并将Q清空。当数据集P中的所有点都被处理过了，并且成了聚类列表中的一部分，算法完成。 算法流程简述： 找到空间中某点p，有kdTree找到离他最近的n个点，判断这n个点到p的距离。将距离小于阈值r的点 p1,p2,p3....放在类Q里在 Q里找到一点p1,重复1，找到p22,p23,p24....全部放进Q里 当 Q 再也不能有新点加入了，则完成搜索了 程序代码 #include &lt;pcl/ModelCoefficients.h&gt; #include &lt;pcl/point_types.h&gt; #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/filters/extract_indices.h&gt; #include &lt;pcl/filters/voxel_grid.h&gt; #include &lt;pcl/features/normal_3d.h&gt; #include &lt;pcl/kdtree/kdtree.h&gt; #include &lt;pcl/sample_consensus/method_types.h&gt; #include &lt;pcl/sample_consensus/model_types.h&gt; #include &lt;pcl/segmentation/sac_segmentation.h&gt; #include &lt;pcl/segmentation/extract_clusters.h&gt; #include&lt;pcl/visualization/pcl_visualizer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20db70af6310ccfed415fd4875538a15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97349e6594a0ebf4a4d70d3883dcb780/" rel="bookmark">
			OpenFOAM写代码用并行时出错的一种解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenFOAM自己写程序，在只有单核计算时，寻址不会有什么问题。但如果改用并行，就会报错。一种解决办法就是用for循环。
如图，如果用单核串行计算，那么就可以直接寻址anchorCell对应的位置，因为一个核负责的计算域就是全局。但如果用并行计算，每个核都会分走一部分计算域，那么没分到anchorCell所在区域的那个核就会因为找不到地址而报错，这类似于数组溢出。单行代码是会被所有核执行的。一种解决办法就是用for循环来遍历所有cell：
OpenFOAM在for循环的一种机制就是，会自动给各核分配任务。各个核也会开始寻找，如果某个核在其区域找到了，就执行寻址赋值。这样，由并行引起的问题就解决了。一个缺点就是会因为遍历而增加计算量，降低计算效率。
但是这样也许不能很好地解决问题。比如说有4个核并行，那么这样每个核就都会赋值一个anchorNew，在他们自己的计算域里进行计算。要想真的解决这个问题，需要用Pstream库的函数配合自己的需求来改代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a895dedec170a768158e07444a77c7d/" rel="bookmark">
			蓝桥杯-时间显示（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 小蓝要和朋友合作开发一个时间显示的网站。在服务器上，朋友已经获取了当前的时间，用一个整数表示，值为从1970年1月1日O0:00:00到当前时刻经过的毫秒数。
现在，小蓝要在客户端显示出这个时间。小蓝不用显示出年月日，只需要显示出时分秒即可，毫秒也不用显示，直接舍去即可。
给定一个用整数表示的时间，请将这个时间对应的时分秒输出。
输入格式 输入一行包含一个整数，表示时间。
输出格式 输出时分秒表示的当前时间，格式形如HH:MM:SS，其中HH表示时，值为0到23，MM表示分，值为0到59，SS表示秒，值为0到59。时、分、秒不足两位时补前导0。
样例输入 1 4680999 样例输出 1 13:00:00 样例输入 2 1618708103123 样例输出 2 01:08:23 我的思路: 硬写。
代码: package LanQiao; import java.io.BufferedInputStream; import java.util.Scanner; /** * Copyright (C), 2019-2022, Kkoo * Author: Kkoo * Date: 2022/3/30 0030 19:17 * FileName: 时间显示 */ public class 时间显示 { public static void main(String[] args) { Scanner in = new Scanner(new BufferedInputStream(System.in)); long time = in.nextLong(); long h, m, s; //毫秒-&gt;秒 time /= 1000; //取模只留下时分秒 time = time % (24 * 60 * 60); //时分秒 h = time / 60 / 60; m = time / 60 % 60; s = time % 60; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a895dedec170a768158e07444a77c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad348a23d02caf788905fb2037b8d8c/" rel="bookmark">
			蓝桥杯-字符统计（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 给定一个只包含大写字母的字符串 S，请你输出其中出现次数最多的字母。
如果有多个字母均出现了最多次，按字母表顺序依次输出所有这些字母。
输入格式 一个只包含大写字母的字符串 S .
输出格式 若干个大写字母，代表答案。
样例输入 BABBACAC 样例输出 AB 我的思路: 签到。
代码: package LanQiao; import java.io.BufferedInputStream; import java.util.Scanner; /** * @copyright (C), 2019-2022, Kkoo * @author: Kkoo * @date: 2022/4/11 0011 17:13 * @fileName: 字符统计 */ public class 字符统计 { public static void main(String[] args) { Scanner in = new Scanner(new BufferedInputStream(System.in)); String str = in.nextLine(); char[] arr = str.toCharArray(); // A-65 int[] index = new int[27]; int max = 0; for (int i = 0; i &lt; arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad348a23d02caf788905fb2037b8d8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e5a20bd3da3fd3b7c1ad2284c449989/" rel="bookmark">
			蓝桥杯-印章（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 共有n种图案的印章，每种图案的出现概率相同。小A买了m张印章，求小A集齐n种印章的概率。
输入格式 一行两个正整数n和m
输出格式 一个实数P表示答案，保留4位小数。
样例输入 2 3 样例输出 0.7500 我的思路: 动态规划也是很难。
代码: package LanQiao; import java.io.BufferedInputStream; import java.util.Scanner; /** * Copyright (C), 2019-2021, Kkoo * Author: kkoo * Date: 2021/11/14 10:37 下午 * FileName: 印章 */ public class 印章 { public static void main(String[] args) { Scanner in = new Scanner(new BufferedInputStream(System.in)); //输入n和m int n = in.nextInt(); int m = in.nextInt(); //定义p代表每一次的概率 double p = 1.0 / n; //定义dp数组 dp[m][n] 买m张凑齐n种 double[][] dp = new double[m + 1][n + 1]; //i代表买了i张 j代表凑齐j种 for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { //因为i&lt;j 不可能买了i张凑齐j种 所以dp=0； if (i &lt; j) { dp[i][j] = 0; } else if (j == 1) { //如果j=1 买了i张凑齐j种 所以dp=p的i-1次方 dp[i][j] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e5a20bd3da3fd3b7c1ad2284c449989/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2443b8d510a88dabb17fd6c5e35cccc0/" rel="bookmark">
			蓝桥杯-拿金币（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 有一个N x N的方格,每一个格子都有一些金币,只要站在格子里就能拿到里面的金币。你站在最左上角的格子里,每次可以从一个格子走到它右边或下边的格子里。请问如何走才能拿到最多的金币。
输入格式 第一行输入一个正整数n。
以下n行描述该方格。金币数保证是不超过1000的正整数。
输出格式 最多能拿金币数量。
样例输入 3 1 3 3 2 2 2 3 1 2 样例输出 11 我的思路: 就dp硬写。
代码: package LanQiao; import java.io.BufferedInputStream; import java.util.Scanner; /** * Copyright (C), 2019-2021, Kkoo * Author: kkoo * Date: 2021/11/15 8:27 上午 * FileName: 拿金币 */ public class 拿金币 { public static void main(String[] args) { Scanner in = new Scanner(new BufferedInputStream(System.in)); //输入n int n = in.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2443b8d510a88dabb17fd6c5e35cccc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/994733c4795700d8a49e2f117a1524f7/" rel="bookmark">
			快速排序_降序（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 快速排序_降序 写个快速排序降序的模板。
代码: package Template; import java.util.Arrays; /** * Copyright (C), 2019-2021, Kkoo * Author: Kkoo * Date: 2021/11/24 0024 14:36 * FileName: 快速排序_降序 */ public class 快速排序_降序 { //降序就把升序反过来 public static void main(String[] args) { int[] arr = {324, 23, 4, 234, 2, 35234, 54, 2314, 12, 3, 123, 12, 4, 32, 54, 235, 34, 5, 234, 231}; jx(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); } public static void jx(int[] arr, int right, int left) { int i = right; int j = left; int temp = arr[right]; while (i &lt; j) { while (i &lt; j &amp;&amp; temp &gt;= arr[j]) { j--; } while (i &lt; j &amp;&amp; temp &lt;= arr[i]) { i++; } if (i &lt; j) { int t = arr[i]; arr[i] = arr[j]; arr[j] = t; } } arr[right] = arr[i]; arr[i] = temp; if (right &lt; i) { jx(arr, right, i - 1); } if (i &lt; left) { jx(arr, i + 1, left); } } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f543015c72aedac753323ee89753e0d6/" rel="bookmark">
			蓝桥杯-猜年龄（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 美国数学家维纳(N.Wiener)智力早熟，11岁就上了大学。他曾在1935~1936年应邀来中国清华大学讲学。
一次，他参加某个重要会议，年轻的脸孔引人注目。于是有人询问他的年龄，他回答说：“我年龄的立方是个4位数。我年龄的4次方是个6位数。这10个数字正好包含了从0到9这10个数字，每个都恰好出现1次。”
请你推算一下，他当时到底有多年轻。
我的思路: 就硬写。
代码: package LanQiao; import java.util.HashSet; /** * Copyright (C), 2019-2021, Kkoo * Author: Kkoo * Date: 2021/12/6 0006 21:40 * FileName: 猜年龄 */ public class 猜年龄 { public static void main(String[] args) { for (int i = 11; i &lt; 50; i++) { //判断条件 if (Math.pow(i, 3) &lt;= 9999 &amp;&amp; Math.pow(i, 3) &gt;= 1000 &amp; Math.pow(i, 4) &gt;= 100000 &amp;&amp; Math.pow(i, 4) &lt; 999999) { //用字符串存储 String a = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f543015c72aedac753323ee89753e0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/518f3e00c4e906b9268a6bcbcae7c300/" rel="bookmark">
			蓝桥杯-车的放置（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
输入格式 包含一个正整数n
输出格式 一个整数，表示放置车的方法数
样例输入 2 样例输出 7 我的思路: 就硬写。
代码: package LanQiao; import java.io.BufferedInputStream; import java.util.Scanner; /** * Copyright (C), 2019-2021, Kkoo * Author: Kkoo * Date: 2021/12/6 0006 19:21 * FileName: 车的放置 */ public class 车的放置 { public static void main(String[] args) { Scanner in = new Scanner(new BufferedInputStream(System.in)); //输入n int n = in.nextInt(); //定义n行 int[] flag = new int[n]; //使用dfs从第0行开始搜索 dfs(0, flag); //输出答案 System.out.println(count); } //因为不放车也是一种情况所以count默认为1 public static int count = 1; public static void dfs(int step, int[] flag) { //step代表放下的个数 如果超过数量则返回 if (step &gt; flag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/518f3e00c4e906b9268a6bcbcae7c300/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfc3235c31c485e2e61ebb2d31b249a/" rel="bookmark">
			蓝桥杯-山（java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 这天小明正在学数数。他突然发现有些正整数的形状像一座“山”，比如 123565321、145541，它们左右对称（回文）且数位上的数字先单调不减，后单调不增。小明数了很久也没有数完，他想让你告诉他在区间 [2022, 2022222022] 中有多少个数的形状像一座“山”。
我的思路: 啊，就暴力跑写两个方法一个判断是否是回文数，一个判断是否是先单调不减，后单调不增。一两分钟分钟就跑出来了答案3138。
代码: package LanQiao; /** * @copyright (C), 2019-2022, Kkoo * @author: Kkoo * @date: 2022/4/11 0011 11:05 * @fileName: 山 */ public class 山 { public static void main(String[] args) { //记录满足条件的个数 int count = 0; for (int i = 2022; i &lt;= 20222022; i++) { //int -&gt; String String s = i + ""; //String -&gt; char[] char[] t = s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdfc3235c31c485e2e61ebb2d31b249a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e970b7aeb8574374339e0d22c252f8b8/" rel="bookmark">
			安卓跨进程通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为什么需要多进程 ①安卓系统给单个应用可以使用的最大内存做了限制，当app想要突破限制时，需要多进程获取更多内存空间。
②一些特殊模块需要不影响主模块的稳定性、不占用主模块的内存，并且需要与主业务生命周期剥离。
③app保活，一些app在后台为了不被系统杀掉，可以用多线程方式进行app拉活。
多进程问题 ①Application多次重建
②静态成员变量和单例模式失效：系统给每个进程分配独立虚拟机，导致单例等会有多个副本
③线程同步机制失效：因为基于多进程，不同进程的锁对象都不同
④SharedPreferences可靠性降低：SharedPreferences不支持两个进程同时操作
安卓的跨进程通信 Activity
Activity的跨进程和进程内访问都需要Intent对象，但跨进程不用指定Context对象和Activity的Class底下，需要的是访问Activity对应的Action字符串，有些还要指定Uri（类似DeepLink）
ContentProvider
ContentProvider提供在多个应用之间数据共享方式（对不同应用的SqlLite数据库进行增删改查），列表数据将以Cursor对象（二维表）形式返回。
Broadcast
广播是被动跨进程通讯方式，当某个程序向系统发送广播，其余应用都被动接收广播数据。听众并不能主动和电台沟通（通过Intent对象发送需要广播的数据）。
Service
AIDL安卓接口定义语言，实际就是将跨进程通信中的参数序列化、发送和解析返回等麻烦自动完成。所需要做的就是写接口文件，用aidl工具转化得到另一个java文件（客户端和服务端都需要）。服务程序继承Stub将函数接口中的逻辑实现。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/249/">«</a>
	<span class="pagination__item pagination__item--current">250/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/251/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>