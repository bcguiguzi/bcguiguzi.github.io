<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b84a5ebb935e63c2de487d65674f5e/" rel="bookmark">
			常规双边带调幅（AM）仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、调制原理
常规双边带调幅又叫标准调幅，简称调幅（AM）。假设调制信号 m(t) 的平均值为 0，将其加上一个直流分量 A0 后与载波相乘就可以得到AM信号。
调制模型如下图所示：
二、解调原理
对于AM信号来说，使用两种解调方式：相干解调和非相干解调均可。在通常情况下，因为其包络与调制信号 m(t)的形状、波形起伏完全一致。故可以使用实现较为简便的包络检波法来恢复原信号。
包络检波器如下图所示：
其中，利用的原理分别是二极管的单向导通性、电容的高频旁路特性和电容的隔直特性。
三、仿真程序
调制部分：
clear all clc; close all; dt = 0.001; %时间采样频率 fm = 1; %信源最高频率 fc = 10; %载波中心频率 t = 0:dt:5-dt; %时间向量 fs = 1/dt; %抽样频率 df = fs/length(t); % fft的频率分辨率 msg = sqrt(2)*cos(2*pi*fm*t); %模拟消息信号 A = 2; %直流分量 sig_AM_modu = (A+msg).*cos(2*pi*fc*t); %AM信号 B = 2*fm; subplot(3,1,1) plot(t,msg,'b'); %画出消息信号 xlabel('时间/s');ylabel('幅度/V'); title('模拟消息信号') subplot(3,1,2) plot(t,sig_AM_modu,'g');hold on; %画出AM信号 plot(t,A+msg,'r--'); %画出包络 xlabel('时间/s');ylabel('幅度/V'); title('AM调制信号及其包络') 解调部分：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b84a5ebb935e63c2de487d65674f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a78023eec9e232d46cc16e6f64cd22b/" rel="bookmark">
			成功解决 KeyError: Unable to open object (object x doesnt exist)和no file found ./SGN/asd.phl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两个问题出现原因都一样，都是不知道为什么代码只生成了一部分文件或者识别出一部分正确路径.因为路径是正则表达式拼成的，所以没办法更改为绝对路径。第一个问题解决办法删掉程序生成的文件再次运行，第二个问题直接再次运行，问题解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4931c3ab779a3195bacba7891e09f46/" rel="bookmark">
			编程错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LeetCode 代码错误 错误:
Line 1060: Char 9: runtime error: addition of unsigned offset to 0x7ffd5a832640 overflowed to 0x7ffd5a83263f (basic_string.h) SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/..b/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/basic_string.h:1070:9 错误原因:
因为后面用到两个数组下标i,j,for中的两个变量判断时不能使用逗号,应该用&amp;&amp;
错误代码: for(i=num1.size()-1,j=num2.size()-1;i&gt;=0,j&gt;=0;i--,j--){ ...... } 正确代码: for(i=num1.size()-1,j=num2.size()-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--){ ...... } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ee149324ed60358ee8a565cd9d88327/" rel="bookmark">
			微信小程序之--账号注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作 第一步、首先登录微信公众平台，地址传送微信公众平台
第二步、在最上面的一栏中有立即注册四个字，不要怕，勇敢而自信的点击下去，接下来你会跳转至一个新的页面。在这里有四个选项，是你选择注册账号的类型，既然看本篇文章那你没得选，小程序走起来。
第三部、就是填写一些信息，无非就是些邮箱密码之类的东西，将常用的邮箱和密码填上，再邮箱认证激活。然后选择注册人的类型，个人就好，不用听人家说个人有一些功能用不了，第一你那些功能本来就用不上，第二，你没办法注册企业账号。先注册个人账号没什么毛病。
最后当你看见这个页面的时候，恭喜你，你有资格开发自己的小程序了。
后面涉及到具体的开发，我后续的博客会贴出来
下一篇：开发环境配置
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b430a34d0510718f07ee73019e6a4b/" rel="bookmark">
			visual studio 2019&amp; Intel Parallel Studio XE2020下FORTRAN安装及MPI并行配置计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现步骤 下载安装包visual studio 2019版本的下载intel parallel studioXE2020下载 安装过程visual studio 2019版本的安装intel parallel studioXE2020安装 MPI相关配置新建项目步骤配置步骤 结束 下载安装包 visual studio 2019版本的下载 （1）visual studio 2019版本的下载，下载地址如下：
https://visualstudio.microsoft.com/zh-hans/vs/
下载界面如图：
共有三个版本可供选择，community版本适合个人使用，并且免费；professional版本和enterprise版本都需要序列号，
我在这里选择了专门面向程序开发人员的professional版本并进行下载
intel parallel studioXE2020下载 （2）intel parallel studioXE2020下载，我下载的是集群版本的，为了做MPI；具体的下载途径可以百度（我的是直接从别人copy来的）。
安装过程 ！！！重要！！！
必须先安装visual studio2019，后安装intel parallel studioXE2020。
visual studio 2019版本的安装 这里因为我已经安装好了，所以只有修改选项，如果是首次安装，只需要在选项中选择C++的那个即可，其余的默认点击右下角安装就好
安装好之后，输入序列号认证（如果是communnity版本就不用认证），激活之后，关掉界面。进行后续安装
intel parallel studioXE2020安装 可以参考这里百度经验上面对2918版本的安装步骤https://jingyan.baidu.com/article/37bce2be5efc901002f3a216.html
因为我需要使用MPI和VTune等功能，所以我在选择时把所有的功能全都选上了。
安装完成后可以选择一个fortran很简单的例子测试并运行一下看看是否正常，比如hello world
MPI相关配置 新建项目步骤 文件&gt;&gt;新建&gt;&gt;项目
&gt;&gt;下一步
&gt;&gt;创建
在source files右键&gt;&gt;添加&gt;&gt;新建项
&gt;&gt;添加
这样就创建好了，就可以直接在里面写代码，编译运行。但是在这之前，需要对MPI进行编译环境配置
配置步骤 文章的信息，主要来源于官网，一定要按照步骤准确配置，否则会出现许多错误。
https://software.intel.com/content/www/us/en/develop/documentation/mpi-developer-guide-windows/top/introduction.html
（1）安装mpi库，因为我已经在XE2020里面选择了此选项，所以不必重新安装；
（2）设置MPI库环境：直接双击运行批处理文件：vars.bat，我的在C:\Program Files (x86)\IntelSWTools路径下面搜索，然后找到。
（3）在电脑搜索框输入cmd，以管理员身份运行，输入hydra_service -status，以确保hydra_service正在运行
如果不是正在运行的话，可以输入hydra_service -install，
这样再输入hydra_service -status的话，显示的就是在运行了，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b430a34d0510718f07ee73019e6a4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c72b0c5147b3a9ba4cfbc18d28a5dfa3/" rel="bookmark">
			宝德服务器安装过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每次装的话，都会绕晕，然后记录下。
德宝服务器
首先开机的话，开到提示按Ctrl+H进入WebBIOS，迅速的按下Ctrl+H，进入配置页面
如图，点击 【Configuration Wizard】
点击 【Next】
点击【Next】
选中一个磁盘，点击【Add To Array】然后看到右侧 Driver Groups就多一个，把所有的HDD都加入Driver Groups中。
全部添加后，点击 【Accept DG】
点击 【Next】
点击 【Add to SPAN】，然后点击【Next】
点击 【Updata Size】
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91b4d9f65bcaf15add074d4cba55f6b5/" rel="bookmark">
			学习笔记 | 通用能力提升
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		01【自我认知】如何清晰地认识自我，发挥自我价值 每个人的素质可以划分为三个层面👇：越往冰山底部走，越难被发现，也越难改变。
1、最外显的知识和技能层
2、相对隐秘一些的能力层
3、最隐秘的天赋层，包括潜在能力、性格特质、动机、价值观等
冰山的三个层面中，最难发现也最难改变的是天赋这一层，而这一层也是和我们工作价值度和幸福度相关性最高的层面。天赋又分为意愿天赋和能力天赋。意愿天赋包括性格、动机、价值观，能力天赋就是你的隐藏能力，比如快速赢得陌生人好感的能力等。 如何发现自己的天赋呢：SIGN模型 🔒 Self-efficacy自我效能： 做某事时非常有信心 🔒Instinct本能： 让你迫不及待、跃跃欲试的事
🔒Growth成长：一接触就明显比别人快
🔒Needs满足：做完之后即使疲劳困倦，依然有满足感
既然天赋能让你感觉自己更强大，那么你需要记录：在哪些瞬间， 你感到强大？
具体做法是：找出一周时间，在这一周里，记录自己的每个瞬间， 包括兴奋、有成就感、愉快的瞬间，以及沮丧、无助、反抗的瞬间。不 仅仅是工作相关，还有业余生活的部分。请注意，你需要记录那些因为你做了某件事而获得的感受，不要记录那些只有享受而没有付出的瞬间，比如：我今天睡到自然醒，我很幸福；或者，今天朋友请我吃了大餐，我很高兴。
正确运用天赋需要做到：找到天赋差异性大且决定性强的领域， 找到能有更多自主感、胜任感、归属感的能维持热情的工作⚠ 02【自主学习】 1、我应该学什么呢？
2、怎么才能提升我的学习能力呢？
👉工作可以分为5种类型：投机型、知识型、技能型、能力型、天赋型
💎知识和技能，是比较容易被淘汰的；而通用能力，则是不论什么时候都需要的。
☁比如：20年前你学了操作计算机技术，很值钱，而放到现在人人都会计算机，你就不值钱了；如果20年前你让自己锻炼到了有影响力的表达能力，现在你只会越来越值钱。
⛳其实想要真正学会并提升自己的通用能力，我们需要的是：学习方法+激励措施。
🎈1、学习方法：知识和问题相互靠。 ⚠其实就是四个字——建立链接。具体来说，可以分为两个步骤：一是知识向问题靠，二是问题向知识靠。
意思是在刚开始学习某个知识的时候，就提前预想好它今后可以被用来解决哪些问题。所以，知识是可以灵活运用的。我们应该养成这样提前预想问题场景的习惯，把知识向问题靠，才能慢慢把知识活化🔥这是指当问题真正发生的时候，我们要记住立马去回顾自己储藏的新知识（方法论模型），用新知识来解释遇到的问题，而不是按照惯常的旧模式去应对。每次学到一个有用的理论或者模型，都记录到这个钥匙库中，并且在它的后面写下至少3个适用的场景。以后遇到问题了，就先到这个钥匙库里看看能不能找到匹配的“钥匙”（模型），找不到就把这个新场景给补充进去。 如何用“3C模型”在面试中脱颖而出👇
模型中的3C分别指的是：
Capability能力：你是否有足够的工作能力Compatibility匹配：你的能力是否能跟职位的招聘要求相匹配Confidence信心：你的言谈、举止能否给公司信心，让对方相信你能够为公司带来价值 🎈2、激励措施：个人和环境两头抓
心理学家告诉我们，人类大脑内部有两个系统，分别是理性和感性。所以啊，💎要想让说服它全心全意的去做一件事，首先我们得从理性和感性两方面去做工作。
1）发挥理性的作用：树立明确目标，细化目标，具体化，量化，精准化
2）发挥感性的作用：利用情绪冲动
能够帮助我们激发动力的感性情绪：
-（1）截止日期产生的紧迫感
-（2）对手竞争产生的焦虑感
-（3）同伴鼓励带来的成就感
-（4）榜样示范带来的期待感
3）发挥情境的作用：创造学习环境古话说，近朱者赤。想要做到好好学习，主动创造一个适宜的学习环境是非常重要的。 03【思维效率】：减少80%的无用功，真正提高工作效率 🎈一、不是所有的问题，都是真正的问题
💎其实，工作中碰到的很多表象问题，都不是真正的问题。如果我们不能在行动之前花时间去撇开表象、深挖本质，之后就要花大量时间在毫无意义的“返工”上，最后给自己一种“努力”的假象，也就是圈圈常说的“无效努力”状态😷。
其实，每当遇到一个新的问题时，行动之前，必须先做下面👇两件事，让本质问题浮出水面：
第一步，排除理解偏差
理解偏差指的是对话中的两人对同一问题的理解可能存在差异⭕。最好的方式就是提问，⚠就是当场向任务提出者澄清一些关键信息。 第二步，排除隐藏偏差
隐藏偏差指的是，对方声称的问题，反映的往往只是其表层的需求，实则背后还存在隐藏的原因，🔔也就是内心真正的需求。 这是Simon Fisher提出的【冲突层】模型，它就很好的表明了每个问题背后存在的不同需求层次 ⛳所以啊，当你接到老板或同事的一项工作任务时，可以先问自己3个问题：
💎What: 对方的真正需求是什么？
💎Or: 除了现有方法，对方的需求还能通过什么方式实现？
💎How: 我怎么帮助对方实现，以解决其核心问题？
🎈二、不是所有真正的问题，都值得被解决
这个矩阵中使用了两个维度，一个是“关键度”，也就是立刻解决该问题究竟有多重要（时间，金钱，资源价值等），另一个是“解决度”，就是立刻解决掉这个问题的可能性有多大。（问题难易程度，资源掌握程度等）
比如👇：
☁如果你缺乏批判性思维，上面班班列的6个问题，你可能没想清楚，所以工作中就导致加班返工；
☁如果你缺少创新思维，那你面对新任务，想不出好的应对方案，只能照搬过去未必合适的经验。结果怎样？只有苦劳，没有功劳；
☁如果你分不清工作优先级，即执行效率，那你面对所有工作都花同样力气，极大可能出力不讨好，你做了100分，老板只能感受60分。
《年轻的时候，做什么才不会浪费？》 💡一、从学校到公司，这条路有多长
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91b4d9f65bcaf15add074d4cba55f6b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07a1505da1416ab31da79e023ec5ab48/" rel="bookmark">
			wayland简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Wayland Wayland旨在作为X的更简单的替代品，更易于开发和维护。
Wayland复用了所有Linux内核的图形、输入输出技术：KMS、evdev，因此已支持的驱动可以直接拿来用。Wayland没有传统的Server/Client的模式，取而代之的是：Compositor/ClientWayland是供合成器与其客户对话的协议，以及该协议的C库实现Wayland合成器可以是在Linux内核模式设置和evdev输入设备上运行的独立显示服务器 了解wayland之前需要先了解X Linux 本身是没有图形化界面的，所谓的图形化界面系统只不过中 Linux 下的应用程序。
什么是 X X 协议由 X server 和 X client 组成。X server 管理主机上与显示相关的硬件设置（如显卡、硬盘、鼠标等），它负责屏幕画面的绘制与显示，以及将输入设置（如键盘、鼠标）的动作告知 X client。X client (即 X 应用程序) 则主要负责事件的处理。 大多数基于Linux和Unix的系统都依赖X作为用于构建位图图形界面的底层协议。在这些系统上，X堆栈已增长为可以包含在客户端库，帮助程序库或主机操作系统内核中的功能。
对PCI资源管理，显示配置管理，直接渲染和内存管理等功能的支持已集成到X堆栈中，从而产生了一些局限性，例如对独立应用程序的有限支持，在其他项目中的重复，以及将多个元素组合在一起的系统的高度复杂性（例如fb驱动程序和X驱动程序之间的内存映射处理或VT切换)。 而且，X已经成长为合并了诸如屏幕外渲染和场景合成之类的功能，但受到X体系结构的限制,例如，composition的X实现增加了其他上下文切换，并使输入重定向之类的事情变得困难。
X的工作流程:
内核从输入设备获取事件，并通过evdev输入驱动程序将其发送到X。内核通过驱动设备并将不同的设备特定事件协议转换为linux evdev输入事件标准来完成所有艰苦的工作。X服务器确定事件影响哪个窗口，并将其发送到在该窗口上为该事件选择的客户端。X服务器实际上并不知道如何正确执行此操作，因为屏幕上的窗口位置是由合成器控制的，并且可能以X服务器无法理解的许多方式进行转换（缩小，旋转，摆动，等等）。客户查看事件并决定要做什么。UI通常必须响应事件而改变-也许单击了复选框或指针输入了必须突出显示的按钮。因此，客户端将渲染请求发送回X服务器。X服务器接收到渲染请求后，会将其发送给驱动程序，以使其对硬件进行编程以进行渲染。X服务器还计算渲染的边界区域，并将其作为损伤事件发送到合成器。损坏事件告诉合成器窗口中发生了某些更改，并且必须重新合成可见该窗口的屏幕部分。合成器负责根据其场景图和X窗口的内容渲染整个屏幕内容。但是，它必须通过X服务器来呈现它。X服务器从合成器接收渲染请求，然后将合成器后缓冲区复制到前缓冲区或进行页面翻转。在一般情况下，X服务器必须执行此步骤，以便它可以考虑重叠的窗口，这可能需要裁剪并确定是否可以翻页。但是，对于始终为全屏显示的合成器，这是另一个不必要的上下文切换。 如上所述，这种方法存在一些问题。X服务器没有信息来决定哪个窗口应该接收事件，它也不能将屏幕坐标转换为窗口局部坐标。即使X将屏幕的最终绘制工作移交给了合成管理器，X仍然控制着前缓冲区和模式设置。 X服务器用于处理的大多数复杂性现在都可以在内核或自包含的库中找到（KMS，evdev，mesa，fontconfig，freetype，cairo，Qt等）。
通常，X服务器现在只是一个中间人，它在应用程序和合成器之间引入了一个额外的步骤，在合成器和硬件之间引入了一个额外的步骤。
walyland工作流程
在Wayland中，合成器是显示服务器。我们将KMS和evdev的控制权转移给合成器。wayland协议允许合成器将输入事件直接发送到客户端，并让客户端将损坏事件直接发送到合成器：
内核获取一个事件，并将其发送到合成器。这与X情况类似，这非常好，因为我们可以重用内核中的所有输入驱动程序。合成器通过其场景图进行查看，以确定应该接收该事件的窗口。场景图与屏幕上的内容相对应，并且合成器了解它可能已应用于场景图中的元素的转换。因此，合成器可以选择右窗口，并通过应用逆变换将屏幕坐标转换为窗口局部坐标。可以应用于窗口的转换类型仅限于合成器可以执行的操作，只要它可以计算输入事件的逆转换即可。与X情况一样，当客户端收到事件时，它会更新UI以作为响应。但是在路途中，渲染发生在客户端中，而客户端只是向合成器发送请求以指示更新的区域。合成器从其客户端收集损坏请求，然后重新合成屏幕。然后，合成器可以直接发出ioctl来调度带有KMS的翻页。 walyland渲染
在上面的概述中遗漏的细节之一是客户如何在Wayland下实际渲染。通过从图片中删除X服务器，还删除了X客户端通常呈现的机制。但是已经在X下的DRI2中使用了另一种机制：直接渲染。通过直接渲染，客户端和服务器共享视频内存缓冲区。客户端链接到诸如OpenGL之类的渲染库，该库知道如何对硬件进行编程并将其直接渲染到缓冲区中。
当合成器合成桌面时，合成器又可以获取该缓冲区并将其用作纹理。初始设置后，客户端仅需要告诉合成器要使用哪个缓冲区以及何时何地向其提供了新内容。
这为应用程序留下了两种更新窗口内容的方法：
将新内容呈现到新缓冲区中，并告知合成器使用该内容代替旧缓冲区。应用程序可以在每次需要更新窗口内容时分配一个新的缓冲区，也可以保留两个（或多个）缓冲区并在它们之间循环。缓冲区管理完全在应用程序控制之下。将新内容呈现到以前告诉合成器使用的缓冲区中。
尽管可以直接渲染到与合成器共享的缓冲区中，但这可能会与合成器竞争。合成器重新绘制桌面可能会中断重新绘制窗口内容。如果应用程序在清除窗口后但呈现内容之前被中断，则合成器将从空白缓冲区进行贴图。结果是应用程序窗口将在空白窗口或半渲染内容之间闪烁。
避免这种情况的传统方法是将新内容呈现到后台缓冲区，然后从那里复制到合成器表面。后台缓冲区可以动态分配，大小足以容纳新内容，或者应用程序可以保留缓冲区。同样，这在应用程序控制之下。
无论哪种情况，应用程序都必须告诉合成器表面的哪个区域容纳新内容。当应用程序直接呈现到共享缓冲区时，需要注意合成器存在新内容。而且，在交换缓冲区时，合成器不假定任何更改，并且需要应用程序发出请求才能重新绘制桌面。即使应用程序将新缓冲区传递给合成器，该缓冲区只有一小部分也可能会有所不同，例如闪烁的光标或微调框。
合成器的类型
合成器的类型不同，具体取决于它们在操作系统的总体体系结构中所扮演的角色。例如，系统合成器可用于引导系统，处理多用户切换，可能的控制台终端仿真器等。一个不同的合成器，一个会话合成器 将提供实际的桌面环境。不同类型的合成器可以通过多种方式共存。
系统合成器: 系统合成器可以从早期启动一直运行到关机为止。它有效地替代了内核vt系统，并可以与系统的图形启动设置和多座支持配合使用。
系统合成器可以托管不同类型的会话合成器，并让我们在多个会话之间切换（快速用户切换或安全/个人桌面切换）。
系统合成器的Linux实现通常使用libudev，例如egl，kms，evdev和cairo。
对于全屏客户端，系统合成器可以重新编程视频扫描地址，以直接从客户端提供的缓冲区中读取。
会话合成器 会话合成器负责单个用户会话。如果存在系统合成器，则会话合成器将嵌套在系统合成器下运行。嵌套是可行的，因为该协议是异步的。当涉及嵌套时，往返将太昂贵。如果没有系统合成器，则会话合成器可以直接在硬件上运行。
嵌入式合成器 X11允许客户端从其他客户端嵌入窗口，或者让客户端将其他客户端渲染的像素图内容复制到其窗口中。这通常用于面板中的applet，浏览器插件等。Wayland不允许直接这样做，但是客户端可以带外传送GEM缓冲区名称，例如，使用D-Bus，或在面板启动小程序时使用命令行参数。另一种选择是使用嵌套的Wayland实例。为此，Wayland服务器必须是主机应用程序链接到的库。然后，主机应用程序会将Wayland服务器套接字名称传递给嵌入式应用程序，并且需要实现Wayland合成器接口。主机应用程序将客户端表面作为其窗口的一部分进行合成，也就是说，在网页或面板中。嵌套Wayland服务器的好处在于，它提供嵌入式客户端向主机通知缓冲区更新所需的请求，以及用于转发来自主机应用程序的输入事件的机制。
这种设置的一个示例是将Flash Player嵌入为专用合成器的firefox。
Wayland协议和操作模型
Wayland协议是一种异步的面向对象的协议。所有请求都是对某个对象的方法调用。该请求包括一个对象ID，该ID唯一地标识服务器上的一个对象。每个对象都实现一个接口，并且请求包括一个操作码，该操作码标识接口中要调用的方法。
该协议是基于消息的。客户端发送到服务器的消息称为请求。从服务器到客户端的消息称为事件。一条消息包含许多参数，每个参数都有特定的类型。
此外，该协议可以指定枚举的准名称来特定数字枚举值。这些本质上仅是描述性的：在有线格式级别，枚举只是整数。但是它们还具有辅助目的，以增强类型安全性或添加用于语言绑定或其他此类代码的上下文。仅在引入这些属性之前编写的代码，在此之后仍然有效时，才支持后一种用法。换句话说，添加枚举不会破坏API。
枚举可以仅定义为一组整数，也可以定义为位域。这是通过枚举定义中的布尔值属性指定的。如果此属性为true，则打算主要使用按位操作来访问该枚举，例如，当任意多个枚举可以一起进行“或”运算时；如果为false，或者省略了属性，则枚举参数只是一系列数值。
服务器将事件发送回客户端，每个事件都是从一个对象发出的。事件可能是错误条件。事件包括对象ID和事件操作码，客户端可以从中确定事件的类型。事件是响应请求（在这种情况下，请求和事件构成往返）而生成的，或者是在服务器状态更改时自发生成的。
状态更改时发出事件。客户端必须侦听这些更改并缓存状态。不需要查询服务器状态。
服务器将广播许多全局对象的存在，而这些对象又将广播其当前状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07a1505da1416ab31da79e023ec5ab48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9f47fbba073b4aeb67743cb78930874/" rel="bookmark">
			JAVA基本数据类型与byte互相转换（位运算，原码，补码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近整理了之前的一些知识，做了一个java中byte类型与int ，long转换以及将字节信息表示成字符串形式的工具。对前面的只是做了一下复习整理。
原码、反码、补码： 首先这三者都是二进制码即（0，1组合）。
原码：最高位为符号位，0表示正数，1表示负数，剩余部分表示真值。
反码：正数的反码是他本身，负数的反码是在原码基础上符号位不变，其余部分按位取反。
补码：反码基础上末位加1。
举个例子（以数值-8的单字节表示为例）：
原码：1000 1000（红色为符号位，其余所有位组成数值）
反码：1111 0111
补码：1111 1000
注意：计算机中保存的数据都是以补码形式存在或计算的。原码是方便你计算的，纸上算数用的东西。 位运算： 顾名思义，位运算就是用来操作比特位的。需要用到的几个位运算符：
&amp;按位与（全真为真，一假则假）（1为真，0为假）
|按位或（一真为真，全假则假）
&gt;&gt; 带符号左移 &gt;&gt;&gt; 无符号左移
&lt;&lt;右移
java中强制类型转换到底做了什么？ 首先你得知道java中对于小于四字节的基本数据类型（short，char，boolean，byte，float）内部进行运算时全部转为四字节。当然int和float本身就是四字节的。long和double都是八字节。
通过一个测试类来分析一下这个问题：
public class Test1 { public static void main(String[] args) { //-256：原码：10000000 00000000 00000001 00000000 ---&gt;补码：11111111 11111111 11111110 00000000 //低8位为：00000000	结果0 int num = -256; byte bNum = (byte) num; System.out.println(bNum); //-4:原码10000000 00000000 00000000 00000100 ---&gt;补码：11111111 11111111 11111111 11111100 //低8位：11111100(补码) -----&gt;原码：10000100 结果-4 num = -4; bNum = (byte)num; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9f47fbba073b4aeb67743cb78930874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/638fcaa8960d80e66f8d09c78c430a3e/" rel="bookmark">
			【字典树】用python实现Trie树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		字典树常用做高效的文本词语保存，适用于敏感词过滤、关键词提取等场景。在字典树中相同前缀的词之间共享相同的树节点和路径。
字典树结构一般包括如下功能和属性：（1）构建；（2）添加；（3）删除；（4）前缀统计；（5）搜索
实现一：通过字典的嵌套来实现 class Trie(object): """ 实现1：通过python自带的字典结构 具有如下基本功能： （1）根据一组words进行TrieTree的构建 （2）添加某个word （3）查询某个word （4）删除某个word """ def __init__(self): self.trie = {} self.count = 0 def __repr__(self): return str(self.trie) def buildTree(self, wordList): for word in wordList: t = self.trie # 指向各节点的指针，初始化为root节点 for w in word: if w not in t: t[w] = {'count': 0} t[w]['count'] += 1 t = t[w] self.count += 1 t['end'] = 1 def add(self, word): t = self.trie for w in word: if w not in t: t[w] = {'count': 0} t[w]['count'] += 1 t = t[w] self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/638fcaa8960d80e66f8d09c78c430a3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/445b6368ab7bd9f12cbd2e220bc979dd/" rel="bookmark">
			Hash转magnet magnet:?xt=urn:btih:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hash码之前加上“magnet:?xt=urn:btih:”，注意空格和标点！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e7ff2c338808e1e327158a29f2826e/" rel="bookmark">
			C11/C&#43;&#43;11内存模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C11/C++11内存模型 1. 什么是内存模型？2. C11/C++11内存模型2.1 memory order releaxed2.2 memory order consume2.3 memory order acquire2.4 memory order release2.5 memory order acq_rel2.6 memory order seq_cst2.7 Relationship with volatile 3. Reference 现代计算机体系结构上，CPU执行指令的速度远远大于CPU访问内存的速度，于是引入Cache机制来加速内存访问速度。除了Cache以外，分支预测和指令预取也在很大程度上提升了CPU的执行速度。随着SMP的出现，多线程编程模型被广泛应用，在多线程模型下对共享变量的访问变成了一个复杂的问题。于是我们有必要了解一下内存模型，这是多处理器架构下并发编程里必须掌握的一个基础概念。
1. 什么是内存模型？ 到底什么是内存模型呢？看到有两种不同的观点：
A：内存模型是从来描述编程语言在支持多线程编程中对共享内存访问的顺序。
B：内存模型的本质是指在单线程情况下CPU指令在多大程度上发生指令重排(reorder)[1]。
实际上A，B两种说法都是正确的，只不过是在尝试从不同的角度去说明memory model的概念。个人认为，内存模型表达为“内存顺序模型”可能更加贴切一点。
一个良好的memory model定义包含3个方面：
Atomic OperationsPartial order of operationsVisable effects of operations 这里要强调的是：我们这里所说的内存模型和CPU的体系结构、编译器实现和编程语言规范3个层面都有关系。
首先，不同的CPU体系结构内存顺序模型是不一样的，但大致分为两种：
x86_64和Sparc是强顺序模型（Total Store Order），这是一种接近程序顺序的顺序模型。所谓Total，就是说，内存（在写操作上）是有一个全局的顺序的（所有人看到的一样的顺序）， 就好像在内存上的每个Store动作必须有一个排队，一个弄完才轮到另一个，这个顺序和你的程序顺序直接相关。所有的行为组合只会是所有CPU内存程序顺序的交织，不会发生和程序顺序不一致的地方[4]。TSO模型有利于多线程程序的编写，对程序员更加友好，但对芯片实现者不友好。CPU为了TSO的承诺，会牺牲一些并发上的执行效率。
弱内存模型（简称WMO，Weak Memory Ordering），是把是否要求强制顺序这个要求直接交给程序员的方法。换句话说，CPU不去保证这个顺序模型（除非他们在一个CPU上就有依赖）， 程序员要主动插入内存屏障指令来强化这个“可见性”[4]。ARMv8，PowerPC和MIPS等体系结构都是弱内存模型。每种弱内存模型的体系架构都有自己的内存屏障指令，语义也不完全相同。弱内存模型下，硬件实现起来相对简单，处理器执行的效率也高， 只要没有遇到显式的屏障指令，CPU可以对局部指令进行reorder以提高执行效率。
对于多线程程序开发来说，对并发的数据访问我们一般到做同步操作， 可以使用mutex，semaphore，conditional等重量级方案对共享数据进行保护。但为了实现更高的并发，需要使用内存共享变量做通信（Message Passing）， 这就对程序员的要求很高了，程序员必须时时刻刻必须很清楚自己在做什么， 否则写出来的程序的执行行为会让人很是迷惑！值得一提的是，并发虽好，如果能够简单粗暴实现，就不要搞太多投机取巧！要实现lock-free无锁编程真的有点难。
其次，不同的编程语言对内存模型都有自己的规范，例如：C/C++和Java等不同的编程语言都有定义内存模型相关规范。
2011年发布的C11/C++11 ISO Standard为我们带来了memory order的支持， 引用C++11里的一段描述：
The memory model means that C++ code now has a standardized library to call regardless of who made the compiler and on what platform it’s running.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92e7ff2c338808e1e327158a29f2826e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e89dec4d93268f0fd5f0ba62f3649e/" rel="bookmark">
			vuex：弄懂mapState、mapGetters、mapMutations、mapActions
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex进阶 一、state 1.1 引入vuex 以后，我们需要在state中定义变量，类似于vue中的data，通过state来存放状态
import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { //存放状态 nickname:'Simba', age:20, gender:'男' }, mutations: {}, actions: {}, modules: {} }) 注册两个组件分别引入到app.vue中
&lt;div id="app"&gt; &lt;vabout&gt; &lt;/vabout&gt; &lt;vhome&gt; &lt;/vhome&gt; &lt;/div&gt; vhome组件内容
&lt;div class="home"&gt;{{$store.state.nickname}}&lt;/div&gt; vabout组件内容
&lt;h1&gt;{{$store.state.nickname}}:{{$store.state.age}}&lt;/h1&gt; 如图，显示出显示出相应的内容，有了vuex，我们不必在考虑组件之间的传值，直接就可以通过$store来获取不同的数据，但是如果需要vuex中的多个数据的这时候，这样写就太啰嗦了，我们可以将它定义在computed中。
Props，methods,data和computed的初始化都是在beforeCreated和created之间完成的。
例：
&lt;template&gt; &lt;div class="home"&gt; {{nickname}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'home', computed:{ nickname(){ return this.$store.state.nickname } } } &lt;/script&gt; 这样引入就方便了很多。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e89dec4d93268f0fd5f0ba62f3649e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f206d9455dc92b753091484113a6f0/" rel="bookmark">
			浅析 Semi-Supervised Learning 中的 consistency 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		浅析 Semi-Supervised Learning 中的 Consistency 问题 传统半监督学习简述：现有半监督学习的问题 —— Individual Consistency实现方法总结 传统半监督学习简述： 区别于全监督学习，半监督学习针对训练集标记不完整的情况：仅仅部分数据具有标签，然而大量数据是没有标签的。因此，目前半监督学习的关键问题在于如何充分地挖掘没有标签数据的价值。主流的半监督学习方法有下面几种：
Self-Training 方法。这是一种很直观的思路：既然大量数据是没有标签的，那么能否对这些数据生成一些伪标签 Pseuo Labels，对这些伪标签数据的训练从而利用原始的无标签数据。Adversarial-Learning-based 方法。这类方法基于一种假设，无标签数据通常具有和有标签数据在某种程度上类似的潜在标签。所以很自然地，可以采用 GAN 的图像模拟思路来进行对 Labeled Data 进行类似于 Unlabeled Data 的数据增强，进而利用 Unlabeled Data 的潜在知识。Consistency-based 方法。 这类方法的核心思路在于 consistency loss，对于进过扰动的 unlabeled data，模型应该对其做出一致性的预测 —— 可以理解成一种利用 unlabeled data 进行网络正则化的方法。 其中经典的算法有 Π-model，Temporal Ensembling 和 Mean Teacher。这些内容具体可以参见 飘入东湖的鱼的知乎专栏。本篇博客的后续讨论都是基于 Mean Teacher 模型上的。 现有半监督学习的问题 —— Individual Consistency 目前大多数半监督学习方法都是基于 consistency-enforcing strategy，利用无标签数据对网络进行正则化，要求预测结果对于输入扰动和网络参数扰动具有一致性。具体来说，给定一个输入样本，对其进行一定程度的扰动 (如添加 Gaussian noise)，使得网络对于这些样本具有相似的预测结果。
这类方法的局限性在于 没有考虑样本和样本之间的关系 —— 这些关系能够有助于从无标签的样本中提取语义信息。如下图所示， 传统半监督学习考虑 individual consistency，将每个样本当成独立的个体考虑，仅仅考虑它和对应扰动之后的样本之间的对应关系。除此之外，我们能否进一步考虑样本之间的关系一致性 (Relation Consistency)，在添加扰动之后其 relation consistency 也应该保持 —— 最小化，从而确保 high-level semantic information 也能够被学习到，进而确保学习的鲁棒性和高判别性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58f206d9455dc92b753091484113a6f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23eb7c7e165e965bcb813137308608c/" rel="bookmark">
			Syntax error near *的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译出现Syntax error near *
的解决方法是：
仔细看错误提示处，会发现少一个分号（主要错误原因）。
或者分号打成中文
或者少一个标点
这个现象常出现于c++/c编程，主要是少分号错误的概率居多
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dfda36286bf2648a44e60b472bfea17/" rel="bookmark">
			nextcloud&#43;onlyoffice docker-compose创建私有云
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nextcloud镜像 分两种镜像：
nextcloud:latest nextcloud镜像默认对应的是apache web服务器版本nextcloud:fpm 基于php-fpm镜像，并运行fastCGI-Process。此版本需要组合可以代理http请求到FastGFI端口（9000）的web服务器。 来源: https://hub.docker.com/_/nextcloud/
nextcloud+onlyoffice方案 采用onlyoffice官方的配置，仓库：docker-onlyoffice-nextcloud
安装 clone最新版本
git clone https://github.com/ONLYOFFICE/docker-onlyoffice-nextcloud cd docker-onlyoffice-nextcloud 使用Docker Compose安装:
sudo docker-compose up -d 登录http://localhost 注册用户和选择相应的数据库等配置，确定登录成功后将更新镜像nextcloud所在容器于/var/html/www/config/config.php的配置信息
运行 set_configuration.sh 脚本添加可信任域名并安装onlyoffice:
注意: 需要root权限，并把脚本文件中的ng-server或者ip换成nginx服务器的ip或者域名，可在局域网或外网访问.
sudo bash set_configuration.sh 成功后，从打印信息可知，onlyoffice已安装成功并将ng-server的ip添加到了可信任域名的名单中。
验证：查看app-server容器/var/html/www/config/config.php的配置信息查看，或浏览器打开域名。
'trusted_domains' =&gt; array ( 0 =&gt; 'localhost', 1 =&gt; '192.168.16.xxx', ), 样例 已部署案例，点击查看http://192.168.16.xxx,用户名：admin，密码：123456
注意 顶部workspace无法加载问题。
在nginx.config中注释掉以下信息
#error_page 403 /core/templates/403.php; #error_page 404 /core/templates/404.php; 直接将这部分隐藏，点击左下角的设置按钮,去掉显示富文本编辑区的默认勾选。
参考：
https://help.nextcloud.com/t/workspace-not-loading/79717
https://help.nextcloud.com/t/spinning-wheel-on-top-of-files/81335/7
onlyoffice新建文件（非word文档）时显示无法连接服务器。
The document could not be saved.Please check connection settings or contact your addministrator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dfda36286bf2648a44e60b472bfea17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cddf656c40cdbb54fc1e04e3f2318362/" rel="bookmark">
			RAID磁盘阵列及配置（服务器中配置实战）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、RAID磁盘阵列介绍1.1RAID 01.2RAID 11.3RAID 51.4RAID 61.5RAID 1+0 二、阵列卡介绍2.1阵列卡介绍2.2阵列卡的缓存 三、配置RAID3.1生产环境配置硬阵列3.2配置软阵列3.2.1mdadm命令 – 管理linux软RAID3.2.2创建RAID 03.2.3创建RAID 13.2.4创建RAID 53.2.5创建RAID 63.2.6创建RAID 1+0 一、RAID磁盘阵列介绍 RAID是Redundant Array of Independent Disks的缩写，中文简称为独立冗余磁盘阵列把多块独立的物理硬盘按不同的方式组合起来形成一个硬盘组(逻辑硬盘)， 从而提供比单个硬盘更高的存储性能
和提供数据备份技术组成磁盘阵列的不同方式称为RAID级别(RAID Levels)常用的RAID级别
RAID0，RAID1, RAID5, RAID6，RAID1+0等 1.1RAID 0 RAID 0连续以位或字节为单位分割数据，并行读/写于多个磁盘上，因此具有很高的数据传输率，但它没有数据冗余RAID 0只是单纯地提高性能，并没有为数据的可靠性提供保证，而且其中的一个磁盘失效将影响到所有数据RAID 0不能应用于数据安全性要求高的场合
1.2RAID 1 通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能RAID 1是磁盘阵列中单位成本最高的,但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据
1.3RAID 5 N (N&gt;=3) 块盘组成阵列，- -份数据产生N-1个条带，同时还有1份校验数据,共N份数据在N块盘上循环均衡存储N块盘同时读写，读性能很高，但由于有校验机制的问题，写性能相对不高(N-1) /N磁盘利用率可靠性高，允许坏1块盘，不影响所有数据
1.4RAID 6 N (N&gt;=4) 块盘组成阵列，(N-2) /N磁盘利用率与RAID 5相比，RAID 6增加了第二个独立的奇偶校验信息块两个独立的奇偶系统使用不同的算法，即使两块磁盘同时失效也不会影响数据的使用相对于RAID 5有更大的"写损失”，因此写性能较差
1.5RAID 1+0 N (偶数，N&gt;=4)块盘两两镜像后，再组合成一个RAID 0N/2磁盘利用率N/2块盘同时写入，N块盘同时读取性能高，可靠性高
二、阵列卡介绍 2.1阵列卡介绍 阵列卡是用来实现RAID功能的板卡通常是由i/0处理器、硬盘控制器、硬盘连接器和缓存等一系列组件构成的不同的RAID卡支持的RAID功能不同
例如支持RAID0、RAID1、 RAID5、RAID10等RAID卡的接口类型
IDE接口、SCSI接口、SATA接口和SAS接口 IDE接口
IDE的英文全称为“Integrated Drive Electronics”，即“电子集成驱动器”，属于并行接口。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cddf656c40cdbb54fc1e04e3f2318362/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ff4c497f9da8143a416a2b0f1703815/" rel="bookmark">
			MVC  增 、删、 改、查 四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVC 增 、删、 改、查 using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ConsoleApp6 { class Program { static void Main(string[] args) { //查 RbacDBEntities db = new RbacDBEntities(); //方式1 var roles1 = from r in db.Roles where r.Name.Contains("主任") select r; //方式2 var roles2 = db.Roles .Where(p =&gt; p.Name.Contains("主任")) .Select(p =&gt; p).ToList(); //方式3调用方sql string sql = @"select * from roles where name like '%主任%'"; db.Database.SqlQuery&lt;Role&gt;(sql); db.SaveChanges(); //方式4，调用存储过程 List&lt;cp_select_role_Result&gt; roles11= db.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ff4c497f9da8143a416a2b0f1703815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3a9678015d03954c9b433dea24bedfc/" rel="bookmark">
			Echarts实现热力图热点图聚合图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、热力图 function initHeatChartMap(){ var option = { bmap: {roam: true}, title: { text: '热点热力图', left: 'center', textStyle: { color: '#787464' } }, geo: { map: 'bmap', polyline: true, progressiveThreshold: 500, progressive: 200, label: { emphasis: { show: false } }, roam: true, itemStyle: { normal: { areaColor: '#323c48', borderColor: '#404a59' }, emphasis: { areaColor: '#2a333d' } } }, visualMap: { min: 0, max: 100, splitNumber: 5, inRange: { //color: ['#FF3300','#FF9900','#009900'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3a9678015d03954c9b433dea24bedfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afa590b4c7451184b7b5ce58109f683c/" rel="bookmark">
			YOJ208 严神的机器人 III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 二分初始体力模拟即可
#include&lt;bits/stdc++.h&gt; using namespace std; int n,h[110000]; inline bool check(int mid){ long long md=mid; for (int i=1;i&lt;n;++i){ md*=2; if (md&gt;1e10) md=1e10; md-=h[i+1];if (md&lt;=0) return 0; }return 1; } int main(){ //freopen("c.in","r",stdin); scanf("%d",&amp;n); for (int i=1;i&lt;=n;++i) scanf("%d",&amp;h[i]); int l=1,r=1e9+1,ans; while(l&lt;=r){ int mid=l+r&gt;&gt;1; if (check(mid)) ans=mid,r=mid-1;else l=mid+1; } printf("%d\n",ans); return 0; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/379/">«</a>
	<span class="pagination__item pagination__item--current">380/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/381/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>