<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d537c16911ddc4b7ce9b146ab928423b/" rel="bookmark">
			剑指Offer 数组中唯一只出现一次的数字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
思路：我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示中对应的那一位是0；否则就是1。
代码如下：
#include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; int FindNum(const vector&lt;int&gt; &amp;vec){ if(vec.size() == 0) return -1; int bit[32] = {0}; for(int i=0;i&lt;vec.size();++i){ int bitMask = 1; for(int j=0;j&lt;32;++j) { int n = vec[i] &amp; bitMask; if(n != 0) bit[j] += 1; bitMask = bitMask&lt;&lt;1; } } int res = 0; for(int i=31;i&gt;=0;--i){ res = res&lt;&lt;1; res += (bit[i] % 3); } return res; } int main(){ vector&lt;int&gt; vec{2,2,2,4,4,4,6,7,7,7}; cout&lt;&lt;FindNum(vec)&lt;&lt;endl; return 0; } 这种解法的时间效率是O(n)。我们需要一个长度为32的辅助数组存储二进制表示的每一位的和。由于数组的长度是固定的，因此空间效率是O(1)。该解法比其他两种直观的解法效率都高：（1）我们很容易就能从排序的数组中找到只出现一次的数字，但排序需要O(nlogn)时间；（2）我们也可以用一个哈希表来记录数组中每个数字出现的次数，但这个哈希表需要O(n)的空间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54837629443febfba04df4bdecdce1b0/" rel="bookmark">
			boost::format用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		boost::format用来代替C里面的sprintf,优点是类型齐全，不会因为类型和参数不匹配而导致程序崩溃，而且还可以重复使用参数，并且效率更高
使用示例：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;boost/format.hpp&gt; using namespace std; int _tmain(int argc, char** argv) { // 使用%序号%的方式给出指示符， 后面用%连接对应的数据。 cout &lt;&lt; boost::format("writing %1%, x=%2% : %3%-th try") % "toto" % 40.23 % 50 &lt;&lt; endl; // 输出:writing toto, x=40.23 : 50-th try // 可以延迟使用，顺序不必一致 boost::format fmter("%2% %1%"); fmter % 36; fmter % 77; cout &lt;&lt; fmter &lt;&lt; endl; // 输出:77 36 // 可重用 fmter % 12; fmter % 24; cout &lt;&lt; fmter &lt;&lt; endl; // 输出:24 12 // 可直接转成字符串 std::string s = fmter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/54837629443febfba04df4bdecdce1b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f878af0c9d8b46c6cdcea2aec415e1d0/" rel="bookmark">
			关于自定义广播接收不到的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于自定义广播接收不到的问题 8.0及以上版本，自定义广播接收不到adb 发送广播 8.0及以上版本，自定义广播接收不到 在最近的项目中，需要使用广播监听PCO状态值的改变，发现发送的广播接收不到，查看log后，发现
Background execution not allowed: receiving Intent { act=com.hotpepper.datasaver.action.statechange flg=0x10 (has extras) } to com.android.settings/.datausage.PcoReceiver
在查阅资料后，发现是系统对隐式广播做了限制，目前查到两种方法
在不同包间接收广播 ，
Intent.addFlags(0x01000000);//加上这句话，可以解决在android8.0系统以上2个module之间发送广播接收不到的问题}；在同一个包内发送： intent.setComponent(new ComponentName("com.android.settings","com.android.settings.datausage.PcoReceiver")); adb 发送广播 adb shell am broadcast -a “com.hotpepper.datasaver.action.statechange” --es prostate 1 -f 0x01000000
adb shell am broadcast 后面的参数有：
[-a ]
[-d &lt;DATA_URI&gt;]
[-t &lt;MIME_TYPE&gt;]
[-c [-c ] …]
[-e|–es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt; …]
[–ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; …]
[-e|–ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; …]
[-n ]
[-f ] []
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be9e7666dc72c644af335cb6d625cc10/" rel="bookmark">
			python实现排列和组合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python实现排列和组合 一、模块二、python实现 一、模块 python模块实现排列和组合
组合 from itertools import combinations s = "123456" print(list(combinations(s, 4))) # [('1', '2', '3', '4'), ('1', '2', '3', '5'), ('1', '2', '3', '6'), # ('1', '2', '4', '5'), ('1', '2', '4', '6'), ('1', '2', '5', '6'), # ('1', '3', '4', '5'), ('1', '3', '4', '6'), ('1', '3', '5', '6'), # ('1', '4', '5', '6'), ('2', '3', '4', '5'), ('2', '3', '4', '6'), # ('2', '3', '5', '6'), ('2', '4', '5', '6'), ('3', '4', '5', '6')] combinations(iterable,r)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be9e7666dc72c644af335cb6d625cc10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c606cb872dc07030335e42d02478422a/" rel="bookmark">
			Linux &#43; Anaconda3 &#43; Pytorch(Pytorch安装)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装环境： cuda: 8.0.61 + python 3.6.5 + Linux
安装步骤： １：后台新建安装环境 创建新的虚拟环境：conda create -n pytorch python=python3.6(这个自己选择，也就是Anoconda的好处)
2: 进入虚拟环境搭建pytorch环境：source activate pytorch 3: 下载安装：（需要根据自己的环境改变安装命令） conda install pytorch torchvision -c pytorch
如果你的环境跟我不同　可以参考下篇博客：https://blog.csdn.net/qq_41149269/article/details/81267591
４：测试安装成功：在后台输入python--------import pytorch 如果无报错为成功
参考博客：
https://blog.csdn.net/sinat_34611224/article/details/83026924
https://blog.csdn.net/red_stone1/article/details/78727096
https://blog.csdn.net/qq_41149269/article/details/81267591
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bff201944adb732e86d1be6ed7eb5f0/" rel="bookmark">
			计算几何——向量的叉乘、点乘、夹角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇总篇：计算几何汇总
一、向量的叉乘 向量p=(x1,y1), q=(x2,y2)
则 pxq=x1.y2-x2.y1
pxq= - qxp
叉乘的大小等于于2倍三角形面积.
右手法则：手掌表示p向量，手指表示q向量，方向均指向指尖
pxq &gt; 0, 则p在q的顺时针方向（q,p），即大拇指朝上，手指与手掌弯曲成九十度，手指弯向左边，p逆时针方向旋转到q
pxq&lt;0, 则p在q的逆时针方向 (p,q) ，即大拇指朝下，手指与手掌弯曲成九十度，手指弯向右边，p顺时针方向旋转到q
pxq=0. 则pq 重合
代码计算叉乘 class point{ public: double x; double y; point(double x_=0,double y_=0):x(x_),y(y_){} friend const point operator+(const point&amp; p1,const point&amp; p2){ return point(p1.x+p2.x,p1.y+p2.y); }; friend const point operator-(const point&amp; p1,const point&amp; p2){ return point(p1.x-p2.x,p1.y-p2.y); }; friend const point operator*(const point&amp; p,const double&amp; m){ return point(p.x*m,p.y*m); }; friend const point operator*(const double&amp; m,const point&amp; p){ return point(p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bff201944adb732e86d1be6ed7eb5f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f71e479d1b0e28fa0ff9d715cf3386f/" rel="bookmark">
			再一次安装caffe
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考此博客装的caffehttps://blog.csdn.net/yhaolpz/article/details/71375762
安装过程中出现的问题（CUDA9.0+Cudnn7.0）
问题1:compute_20
https://blog.csdn.net/tjuyanming/article/details/79249964?utm_source=blogxgwz6
nvcc fatal:unsupported gpu architecture "compute_20" 解决：
问题显示不支持compute_20，将Makefile.config中CUDA_ARCH的gencode arch=compute_20这行注释掉
#在caffe路径下 $vim Makefile.config #找到CUDA_PATH，删掉前两行 CUDA_ARCH :=-gencode arch=compute_30,code=sm_30 \ -gencode arch=compute_35,code=sm_35 \ -gencode arch=compute_50,code=sm_50 \ -gencode arch=compute_52,code=sm_52 \ -gencode arch=compute_60,code=sm_60 \ -gencode arch=compute_61,code=sm_61 \ -gencode arch=compute_61,code=compute_61 问题2:cudnn.h文件
./include/caffe/util/cndnn.hpp:5:19:fatal error:cndnn.h:No such file or directory 原因：没有cudnn.h文件，cudnn.h文件本应该在/usr/local/cuda-9.0/include/中，去查看了一下，确实没有，于是去同学那考了一个cudnn.h文件放到此文件夹下就行
#复制cudnn.h到/usr/local/cuda-9.0/include/ $sudo cp /home/ltpc/../cudnn.h /usr/local/cuda-9.0/include/ #其中/home/ltpc/../是cudnn.h所在的绝对路径 问题3：protobuf版本不同
https://blog.csdn.net/m0_38082419/article/details/80117132
.build_release/src/caffe/prete/caffe.pb.h:12:2:error:#error This file was generated by a new version of versin of protoc which is 原因：说protobuf版本太高了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f71e479d1b0e28fa0ff9d715cf3386f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d889e93d70c7c571d87d122ecf4e3a59/" rel="bookmark">
			WPF设置Button的Style
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扣扣技术交流群：460189483
一、前言
程序界面上的按钮多种多样，常用的就这几种：普通按钮、图标按钮、文字按钮、图片文字混合按钮。本文章记录了不同样式类型的按钮实现方法。下面话不多说了，来一起看看详细的介绍吧。
二、固定样式的按钮
固定样式的按钮一般在临时使用时或程序的样式比较固定时才会使用，按钮整体样式不需要做大的改动。
2.1 普通按钮-扁平化风格
先看效果：
来自苏守坤的CSDN 定义Button的样式，详见代码：
&lt;Style x:Key="BtnInfoStyle" TargetType="Button"&gt; &lt;Setter Property="Width" Value="70"/&gt; &lt;Setter Property="Height" Value="25"/&gt; &lt;Setter Property="Foreground" Value="White"/&gt; &lt;Setter Property="BorderThickness" Value="0"/&gt; &lt;Setter Property="Background" Value="#43a9c7"/&gt; &lt;Setter Property="Template"&gt; &lt;Setter.Value&gt; &lt;ControlTemplate TargetType="Button"&gt; &lt;Border x:Name="border" Background="{TemplateBinding Background}" BorderBrush="{TemplateBinding BorderBrush}" BorderThickness="{TemplateBinding BorderThickness}" SnapsToDevicePixels="True"&gt; &lt;TextBlock Text="{TemplateBinding Content}" Foreground="{TemplateBinding Foreground}" VerticalAlignment="Center" HorizontalAlignment="Center"/&gt; &lt;/Border&gt; &lt;ControlTemplate.Triggers&gt; &lt;Trigger Property="IsMouseOver" Value="True"&gt; &lt;Setter TargetName="border" Property="Background" Value="#2f96b4"/&gt; &lt;/Trigger&gt; &lt;Trigger Property="IsPressed" Value="True"&gt; &lt;Setter TargetName="border" Property="Background" Value="#2a89a4"/&gt; &lt;/Trigger&gt; &lt;/ControlTemplate.Triggers&gt; &lt;/ControlTemplate&gt; &lt;/Setter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d889e93d70c7c571d87d122ecf4e3a59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7642f9fb4563779dfd4314b7bf80708a/" rel="bookmark">
			一文快速入门docker和nvidia-docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker和nvidia-docker介绍 目录
docker和nvidia-docker介绍
docker介绍
nvidia-docker介绍
docker快速入门
Docker架构
Docker生命周期
Docker常用命令
创建容器
Nvidia-docker使用
容器资源
创建前台运行容器
容器生命周期
停止容器
暂停容器
杀死容器
docker stop与docker kill区别
删除容器
端口映射
数据持久化
容器中环境变量
下载镜像
列出所有的镜像
推送镜像到官方hub中
nvidia-docker 示例
容器中查看GPU显卡信息
启动gpu版本的Tensorflow
批量操作命令
快速删除所有的容器
删除名字是的镜像
删除所有退出的容器
归档所有的镜像
参考：
nvidia-docker官网
docker 官网
docker介绍 容器级别的虚拟化不是基于硬件虚拟化和宿主机共享操作系统内核和资源轻量方便的构建&amp;部署应用程序采用虚拟化控制 虚拟机和容器虚拟化比较 nvidia-docker介绍 docker原生并不支持在他生成的容器中使用Nvidia GP资源。nvidia-docker是对docker的封装，提供一些必要的组件可以很方便的在容器中用GPU资源执行代码。从下面的图中可以很容器看到nvidia-docker共享了宿主机的CUDA Driver。
nvidia-docker架构设计 docker快速入门 docker 引擎
Docker Engine是一个客户端-服务端应用程序，包含以下主要组件：
一个长时间运行的程序被称作守护进程（这个docker命令）一个REST API，它指定程序可以用来与守护进程通信并指示它做什么。一个命令行接口（CLI）客户端（这个docker命令） CLI使用Docker REST API控制Docker守护进程或者通过脚本/直接CLI命令和Docker守护进程交互。
Docker守护进程创建和管理Docker对象，比如：镜像，容器，网络和卷。
docker management resource Docker架构 Docker采用主从架构，这个Docker客户端和Docker守护进程通信，后者负责构建，运行和分发Docker容器。
Docker 架构 Docker 架构 Docker生命周期 Docker常用命令 查看版本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7642f9fb4563779dfd4314b7bf80708a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/045795db0db7061730127e98232ea4cd/" rel="bookmark">
			解密虚拟 DOM——snabbdom 核心源码解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文源码地址：github.com/zhongdeming…
对很多人而言，虚拟 DOM 都是一个很高大上而且远不可及的专有名词，以前我也这么认为，后来在学习 Vue 源码的时候发现 Vue 的虚拟 DOM 方案衍生于本文要讲的 snabbdom 工具，经过阅读源码之后才发现，虚拟 DOM 原来就是这么回事，并没有想象中那么难以理解嘛～
这篇文章呢，就单独从 snabbdom 这个库讲起，不涉及其他任何框架，单独从这个库的源码来聊一聊虚拟 DOM。
在讲 snabbdom 之前，需要先学习 TypeScript 知识，以及 snabbdom 的基本使用方法。
一、snabbdom 核心概念 在学习 snabbdom 源码之前，最好先学会用 snabbdom，至少要掌握 snabbdom 的核心概念，这是阅读框架源码之前基本都要做的准备工作。
以下内容可以直接到 snabbdom 官方文档了解。
snabbdom 的一些优点 snabbdom 主要具有一下优点：
核心部分的源代码只有两百多行（其实不止），容易读懂。通过 modules 可以很容易地扩展。钩子函数很丰富，用户可以通过钩子函数直接干涉 Vnode 到 DOM 挂载到最终销毁的全过程。性能很棒。容易集成。 modules 的一些优点 通过 h 函数，可以很容易地创建 Vnode。通过 h 函数可以创建 SVG 元素。事件处理能力强大。可以通过 Thunks 优化 DOM Diff 和事件。 第三方支持很多的优点 通过一些第三方的插件，可以很容易地支持 JSX、服务端 HTML 输出等等……
核心 API 较为核心的 API 其实就四个：init、patch、 h和tovnode，通过这四个 API 就可以玩转虚拟 DOM 啦！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/045795db0db7061730127e98232ea4cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7447680d0dc4bcbc4f23e84d11f29cdc/" rel="bookmark">
			OpenWRT配置IPV6
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备材料 智博通 WG3526 路由器 (MT7621A 16M ROM, 512M RAM)中国移动光纤入户 (Prefix Delegation前缀委托模式) 刷机 OpenWRT 18.06 for ZBT WG3526
配置 /etc/config/dhcp
config dhcp 'lan' ... option dhcpv6 'server' option ra 'server' 复制代码 dchpv6和ra配置,保持不变,均为'server'
/etc/config/firewall
config defaults ... # Uncomment this line to disable ipv6 rules option disable_ipv6 1 复制代码 关闭IPV6防火墙，否则本机的一些端口无法暴露到公网
/etc/config/network
关闭global prefix
#config globals 'globals' # option ula_prefix 'fdca:59d7:4008::/48' 复制代码 配置pppoe(加自动ipv6)
config interface 'wan' option ifname 'eth0.2' option proto 'pppoe' option username '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7447680d0dc4bcbc4f23e84d11f29cdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3acd06450bee41ccb77928b23c60ff8/" rel="bookmark">
			【B&#43;树】树结构之B&#43;树简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.m阶B+树定义2.m阶B+树节点数据结构3.m阶B+树的基本操作示意3.1查找操作3.2插入操作3.3删除操作 1.m阶B+树定义 B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。根结点本身即可以是内部结点，也可以是叶子结点。根节点关键字个数范围[1,m-1]。除根节点外的节点关键字个数范围[ ⌈ \lceil ⌈m/2 ⌉ \rceil ⌉-1,m-1]。内部节点中，存储的索引数是关键字数加1；叶子节点中，存储的数据数是关键字数所有叶子节点在同一层。内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接构成一个链表。 2.m阶B+树节点数据结构 b+树节点本身(包括叶子节点)不存储信息，常作为索引记录待查数据位置信息，通常通过指针索引待查数据。b+树只有叶子节点存储指向待查数据的指针。这点和b树不同。其基本数据结构如下(如果是叶子节点还需存放一个指针索引数据) template&lt;typename T&gt;//节点key值类型为模板类型T class BPlusTreeNode { private: int currentKeyNum;//节点当前存储的key数量 int maxKeyNum;//节点最多能存储的key数量 T *pKey;//存放key的一位数组，初始化时需new分配maxKeyNum个空间 BPlusTreeNode&lt;T&gt; *pParent;//父节点指针 BPlusTreeNode&lt;T&gt; **pChilds;//存放孩子节点的一位数组，初始化时需new分配maxKeyNum个空间 static const T keyMaxValue = 10000;//节点key的最大值 } 3.m阶B+树的基本操作示意 3.1查找操作 从根节点开始查找，利用B+树的性质可以逐层查找，不过多赘述。 3.2插入操作 例1：在下面三阶b+树中插入9 首先查找9应插入的叶节点(最左下角的那一个),插入发现没有破坏B+树的性质,完毕。插完如下图所示:
例2：在下面三阶b+树中插入20 首先查找20应插入的叶节点(第二个叶子节点),插入，如下图
发现第二个叶子节点已经破坏了B+树的性质,则把之分解成[20 21], [37 44]两个,并把21往父节点移，如下图
发现父节点也破坏了B+树的性质,则把之再分解成[15 21], [44 59]两个,并把21往其父节点移，如下图
这次没有破坏B+树的性质(如果还是不满足B+树的性质,可以递归上去,直到满足为至),插入完毕
例3：往下图的3阶B+树插入100 首先查找100应插入的叶节点(最后一个节点), 插入，如下图
修改其所有父辈节点的键值为100(只有插入比当前树的最大数大的数时要做此步),如下图
然后重复例2的方法拆分节点,最后得
3.3删除操作 例1：删除下图3阶B+树的关键字91
首先找到91所在叶节点(最后一个节点),删除之，如下图
没有破坏B+树的性质,删除完毕
例2：删除下图3阶B+树的关键字97
首先找到97所在叶节点(最后一个节点),删除之，然后修改该节点的父辈的键字为91(只有删除树中最大数时要做此步)，如下图
例3：删除下图3阶B+树的关键字51
首先找到51所在节点(第三个节点),删除之，如下图
破坏了B+树的性质,从该节点的兄弟节点(左边或右边)借节点44，并修改相应键值,判断没有破坏B+树,完毕，如下图
例4：删除下图3阶B+树的关键字59
首先找到59所在叶节点(第三个节点),删除之，如下图
破坏B+树性质,尝试借节点,无效(因为左兄弟节点被借也会破坏B+树性质),合并第二第三叶节点并调整键值，如下图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3acd06450bee41ccb77928b23c60ff8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81ebfed6ffc17df9418be6482c04f679/" rel="bookmark">
			antd-RangePicker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		antd 使用RangePicker 组件的时候想要自定义其时间选择组件的value值时候该怎么处理？
下面是使用组件代码：
首先需要先引入组件所需的东西
import { DatePicker, } from ‘antd’;
const {RangePicker} = DatePicker;
const dateFormat = ‘YYYY/MM/DD HH:mm:ss’;
import moment from ‘moment’;
然后是组件所用到的方法（让组件吗，默认为空的时候 组件会默认显示“开始时间-结束时间”）
this.state={
dataValue:null,
}
//把组件选择后的时间值赋予dataValue的状态值里
dataVal(val){
console.log(val)
var startTime = new Date(val[0]._d)
var endTime = new Date(val[1]._d)
this.setState({dataValue:[moment(startTime), moment(endTime)]})
}
组件的使用：
&lt;RangePicker
locale={zh_CN}
value={this.state.dataValue}
onChange={this.dataVal.bind(this)}
showTime
style={{width:“100%”,}}
onOk={this.getTime.bind(this)}
format={dateFormat}
/&gt;
以上就是我们自定义antd-RangePicker组件时间值的用法了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b6a42bd77c37d04619dbaebee3c0a21/" rel="bookmark">
			Clickhouse 入门教程（二）—— Java 连接示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、JDBC 驱动二、代码示例2.1 create table2.2 batch insert2.3 select query2.4 drop table 三、解决 Connection refuse 的问题 一、JDBC 驱动 clickhouse 有两种 JDBC 驱动实现。
官方驱动：
&lt;dependency&gt; &lt;groupId&gt;ru.yandex.clickhouse&lt;/groupId&gt; &lt;artifactId&gt;clickhouse-jdbc&lt;/artifactId&gt; &lt;version&gt;0.1.52&lt;/version&gt; &lt;/dependency&gt; 三方提供的驱动：
&lt;dependency&gt; &lt;groupId&gt;com.github.housepower&lt;/groupId&gt; &lt;artifactId&gt;clickhouse-native-jdbc&lt;/artifactId&gt; &lt;version&gt;1.6-stable&lt;/version&gt; &lt;/dependency&gt; 两者间的主要区别如下：
驱动类加载路径不同，分别为 ru.yandex.clickhouse.ClickHouseDriver 和 com.github.housepower.jdbc.ClickHouseDriver默认连接端口不同，分别为 8123 和 9000连接协议不同，官方驱动使用 HTTP 协议，而三方驱动使用 TCP 协议 需要注意的是，两种驱动不可共用，同个项目中只能选择其中一种驱动。
二、代码示例 本例使用三方提供的驱动，示例代码如下所示：
2.1 create table Class.forName("com.github.housepower.jdbc.ClickHouseDriver"); Connection connection = DriverManager.getConnection("jdbc:clickhouse://192.168.60.131:9000"); Statement statement = connection.createStatement(); statement.executeQuery("create table test.jdbc_example(day Date, name String, age UInt8) Engine=Log"); 通过 clickhouse-client 命令行界面查看表情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b6a42bd77c37d04619dbaebee3c0a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de6d7944611906c24b188d80d2a71dca/" rel="bookmark">
			在Linux下使用树莓派交叉编译工具编译opencv库并进行移植
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、交叉编译opencv 继上一篇博客：“在Linux下配置opencv”之后，我以为直接将编译命令：g++ `pkg-config --cflags opencv` -o TestOpencv TestOpencv.cpp `pkg-config --libs opencv` 中的g++直接改成arm-linux-gnueabihf-g++就可以编译生成树莓派里可以执行的文件了。但事实上并非如此，而是在编译时出现了如下错误：
系统提示我libopencv_shap.so文件格式无法识别。然后我以此为关键词在网上查找资料，发现有人指出libopencv_shap.so是x86的，然而目标文件却是arm的。也就是说，需要先链接arm架构的库，即需要先交叉编译opencv（资料引自：http://tieba.baidu.com/p/4618016956）。这时我才明白原来我之前在Linux PC下编译的opencv库是不能在arm构架的树莓派上运行的。于是我便在Linux PC中使用树莓派交叉编译工具编译opencv库。网络上的资料都大同小异，基本都是使用cmake-gui来配置opencv。我最开始是参照下面这篇博客（https://blog.csdn.net/sun_28/article/details/52760463）进行配置的。后来又搜索到了另一篇文章（http://bbs.elecfans.com/m/jishu_531776_1_1.html），上面有实例介绍。然后我就参照他的编译指令将我的程序进行编译，指令如下：
arm-linux-gnueabihf-g++ TestOpencv.cpp -o TestOpencvForRaspberry `pkg-config --cflags --libs opencv` -lpthread -lrt -ldl 然而出现如下错误：
到网上查找资料并未有任何收获，后来向老师请教，她说这么多的同类型错误应该是配置的问题，然后我意识到可能是在交叉编译opencv时有些选项选择不正确。如下图所示：
我把其中能选的都选上了（有些勾选之后，点击图片左下角的“configure”是会提示有错误的）。然后重新make install，这次得的到的库文件（在CMAKE_INSTALL_PREFIX选项指定的文件夹的lib文件夹下面）不是.a文件，而是.so文件，后来我又去看之前参照配置opencv的博客，发现他没有勾选BUILD_SHARED_LIBS，采用的是静态编译。然后将.so文件放到了交叉编译工具里的lib目录下重新编译程序。这次就没有出现大批量的未定义标识符的错误，而是出现了如下错误：
错误的原因应该是交叉编译工具找不到动态链接库，但是我确实将动态链接库放进去了，后来我到交叉编译工具的目录下去查看。发现不止一个lib目录，还有/usr/lib,/usr/local/lib,于是我将xxxx.so文件放到所有的lib文件夹中去了，再次编译程序就没有问题了。
二、移植opencv库 然后我将交叉编译好的xxxx.so文件拷贝到了树莓派上的/lib目录下，将可执行文件TestOpencvForRaspberry拷贝到了~/Public/executable_files目录下。然后给TestOpencvForRaspberry添加可执行权限并执行程序，却提示如下错误：
提示我加载动态库的时候出现了问题，然后使用ldd指令查看依赖库，有如下回馈：
问题就是../../libopencv_xxxxx.so =&gt; not found,一直不明白这是怎么回事，只有把可执行文件放在当前用户的home目录或者根目录及其非home的子目录下才能正确执行。如下图所示：
然后不管把可执行文件放入其他任何地方都是无法执行，而且提示相同的错误。
后来自己用树莓派交叉编译工具编译了一个非opencv的动态链接库，将其放置到树莓派的/lib目录下，然后执行相应的程序，程序正确执行。现在初步怀疑在使用树莓派交叉编译opencv库的时候出现了错误。
三、解决方法 针对上述问题的解决方法：直接在树莓派上编译安装opencv生成动态链接库(.so文件)。并在Linux PC中也使用树莓派交叉编译工具编译相应版本的opencv，这样树莓派就不需要再编译程序而只要执行程序了。
1、在树莓派上安装opencv，转载自：https://blog.csdn.net/leaves_joe/article/details/67656340
软件源更新 sudo apt-get update 升级本地所有安装包，最新系统可以不升级，版本过高反而需要降级才能安装 sudo apt-get upgrade 升级树莓派固件，固件比较新或者是Ubuntu则不用执行 sudo rpi-update 然后安装构建OpenCV的相关工具： 安装build-essential、cmake、git和pkg-config sudo apt-get install build-essential cmake git pkg-config /安装常用图像工具包： 安装jpeg格式图像工具包 sudo apt-get install libjpeg8-dev 安装tif格式图像工具包 sudo apt-get install libtiff5-dev 安装JPEG-2000图像工具包 sudo apt-get install libjasper-dev 安装png图像工具包 sudo apt-get install libpng12-dev 安装视频I/O包（注意最后一个包的数字“4”后面是“L”）： sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev 下面安装gtk2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de6d7944611906c24b188d80d2a71dca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2244f4f697b098bd35ae15fb4b58a959/" rel="bookmark">
			(*a)[]与*a[]的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(*a)[]与*a[]的区别 要注意符号优先级问题，
(*a)[]表示*a首先要是一个指针，这个指针指向的数据类型是一个数组，这叫数组指针
可以相当于二维数组用
int(*k)[3] = new int[5][3]; k[1][1] = 2; k[1][2] = 3; *a[]优先级是先算a[],表示a首先要是一个数组，再算*，就是数组里面每一个元素都是一个指针，这叫指针数组
*a++和(*a)++区别 我们通常定义一个整型指针变量a，那么*a是a指向的整型变量的值
如果要使该值自增，单独写一条语句：*a++；将会带来问题，因为优先级问题
所以要写成(*a)++； 或者++*a;因为单条语句中a++和++a并无区别。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4ec916876e19d901613a6fae4d8dd70/" rel="bookmark">
			小程序开发调用本地接口报错：SSL certificate: unable to get local issuer certificate
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、PHPStudy集成环境，解决办法如下：
1. 到 http://curl.haxx.se/ca/cacert.pem下载pem文件；
2. 将文件拷贝至PHPTutorial文件夹下，如： D:\phpStudy\PHPTutorial\cacert.pem；
3. 打开 php.ini 配置文件， 增加 curl.cainfo = "D:\phpStudy\PHPTutorial\cacert.pem"。
二、 wampserver集成环境，解决办法如下：
1. 到 http://curl.haxx.se/ca/cacert.pem下载pem文件；
2. 将文件拷贝至wampserver安装根目录下，如： D:\wamp64l\cacert.pem；
3. 打开 php.ini 配置文件， 增加 curl.cainfo = "curl.cainfo="D:/wamp64/cacert.pem""。
三、手动安装的wamp环境
通过上面两个集成环境配置流程就可以看出，解决办法如下：
1. 到 http://curl.haxx.se/ca/cacert.pem下载pem文件；
2. 把下载的cacert文件放置在php可访问到的位置；
3. 到php.ini中配置curl.cainfo的文件地址。
四、说明
先把解决办法说明白，解决了问题再说。
解决完问题，我们也改想想，增加的这个文件具体是什么呢？
说这个文件前，先说说什么是HTTPS。
很多刚做IT的朋友，可能也不太理解什么是http和https？以及这两者之间有什么区别？
百度了一篇说明文章，感兴趣的朋友可以自己看看：HTTP与HTTPS的区别。
我这里从一个角度简单说明：https是http通讯协议的升级版，在http的基础上，增加了一层SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密，所以https可以理解陈http协议的安全版。
我们在开发小程序的一个限制是：服务端请求必须使用https接口。
那我们本地没有SSL证书，怎么办？这时候，聪明的你想起了什么没有？
对，我们刚刚下载的那个文件，cacert.pem正是一个SSL模拟证书，安装到我们本地的开发环境，就可以实现https效果了。
本地开发结束，上线后再购买SSL证书配置到线上的环境，直接无缝对接上线。
最后，祝你的小程序裂变无数，生意兴隆，哈哈 ^O^
--------------------- 作者：追风2019 来源：CSDN 原文：https://blog.csdn.net/createNo_1/article/details/82627063 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c984c99c4912b44a26d4ab9df052b8c/" rel="bookmark">
			ROS launch用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		roslaunch文件通过XML文件实现多节点的配置和启动。
$ roslaunch [package] [filename.launch] 首先在功能包的src路径下创建launch文件夹，然后在文件夹下创建.launch文件XML文件必须包含一个根元素，launch文件的根源素采用标签定义，文件中的其他元素都必须包含在这个标签当中 &lt;launch&gt; ... &lt;/launch&gt; 启动的ROS节点采用标签定义 &lt;node pkg="package_name" type="executable_name" name="node_name"/&gt; pkg为节点所在的功能包的名称 type为节点的可执行文件的名称 name为节点运行时的名称，将覆盖init()赋予节点的名称 其他属性及作用： output="screen" 终端输出转储在当前的控制台上，而不是在日志文件中 ns = "NAME_SPACE" 在自定义的命名空间里运行节点 respawn="true" 当roslaunch启动完所有该启动的节点之后，会监测每一个节点，保证它们正常的运行状态。对于任意节点，当它终止时，roslaunch 会将该节点重启 required="true" 当被此属性标记的节点终止时，roslaunch会将其他的节点一并终止。注意此属性不可以与respawn="true"一起描述同一个节点 参数设置 &lt;param name="output_frame" value="odom"/&gt; 用来设置ROS系统运行中的参数，存储在参数服务器中，其中name为参数名，value为参数值 &lt;rosparam file="params.yaml" command="local" ns="params"/&gt;用来将一个YAML格式文件的多个参数全部加载到参数服务器中 &lt;arg name="arg_name" default="arg_value"/&gt; arg时launch文件内部的局部变量，仅限于launch文件内部使用，便于launch文件的重构，与ROS节点的内部实现没有关系 launch文件需要使用到arg时，用以下方式调用
&lt;param name="foo" value="$(arg arg_name)"/&gt; &lt;node name="node" pkg="package" type="type" args="$(arg arg_name)"/&gt; 重映射 &lt;remp from="turtlebot/cmd_vel" to="cmd/vel"/&gt; 重映射ROS计算图资源的命名 -嵌套
&lt;include file="$(find package-name)/launch-file-name"/&gt; 包含其他launch文件 如： &lt;include file = "find learning_tutrols"/launch/start_demo.launch" / &gt; 有时也用： &lt;include file="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c984c99c4912b44a26d4ab9df052b8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c0df311a9c5f6bc60b9f8a9e6a9f582/" rel="bookmark">
			第一个C# 单元测试程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		测试对象： Web应用程序里面的一个方法AddDog 如下：
1. 新建测试项目 UnitTest_Demo
2. 在单元测试项目引用待测试的项目。也要引用待测试项目引用的依赖项，例如我的EF项目有引用EF来实现数据库操作，所以在测试项目里也要引用。
3. 在测试用例里面添加如下代码： Assert 断言原来判断测试结果是否符合预期。
[TestMethod] public void TestMethod1() { EF.EF ed = new EF.EF(); Assert.AreEqual(ed.AddDog(), true); } 4. 准备工作做完开始测试，设置待测试工程为启动项，然后点击 测试--》run--》selected tests 显示如下结果表示测试用例执行成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd5e834fbcb7ecad5224020189ed559/" rel="bookmark">
			nexus下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://help.sonatype.com/repomanager3/download/download-archives---repository-manager-3
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/428/">«</a>
	<span class="pagination__item pagination__item--current">429/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/430/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>