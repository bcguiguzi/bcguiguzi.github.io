<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1514e75b3d94cdd45b2f39d192ef3743/" rel="bookmark">
			常见漏洞原理简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天复习上个月学的漏洞的知识点。
一、SQL注入漏洞 sql注入是就是通过把SQL语句插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
理解这张图就可以理解sql注入的原理，因为在mysql数据库中存在一个Information_schema数据库，这个数据库里面存在两张表。一个是tables表，里面存有所有的表名和数据库名；另一个是columns表，里面存有所有的字段名，字段所属的表名，字段所属的库名。第一步我们查找数据库名，第二步我们通过查找tables表里的数据库，可以确定表名，第三步我们通过前两步得到的库名和表名就可以在columns这张表中得到字段名，最后一步我们通过前几步得到的数据库名、表名、字段名得到想要的数据。
如何通过进行sql注入，进后台？
1、找注入点，判断是否可以注入。
2、判断是数字型注入还是字符型注入。and 1=1 ；and 1=2
3、如果是字符型注入，判断闭合符。’ " ') ") …
4、优先使用联合查询注入-&gt;报错查询 -&gt;bool型查询 -&gt;时间盲注 -&gt;宽字节
5、判断列数。 order by
6、判断显错位。 union select 1,2,3, …
7、求库、求表、求字段、求数据。
8、找后台，御剑扫后台目录。
9、上传一句话木马。菜刀，蚁剑连接
1、数字型注入 id=1' //报错，说明有注入点 id=1 and 1=1 //正确 id=1 and 1=2 //错误，说明是数字型注入，否者为字符型注入 order by //判断列数 and 1=2 union select 1,2,3, ... //判断显错位 and 1=2 union select 1,2,database() //求库 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='数据库名' //求表 and 1=2 union select 1,2,group_concat(column_name) from information_schema.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1514e75b3d94cdd45b2f39d192ef3743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9df306f03daedccf83f5e2983dbb5422/" rel="bookmark">
			MySql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL 1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 3 种注释 * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) * 多行注释: /* 注释 */ 3. SQL分类 1) DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL：操作数据库、表 1.操作数据库：CRUD C(Create):创建 * 创建数据库； * create database 数据库名称; * 创建数据库，判断不存在，在创建 * create database if not exists 数据库名称； * 创建数据库，并指定字符集 * create database 数据库名称 character set 字符集名；	* 练习：	创建db4数据库，判断是否存在，并指定字符集为gbk； * create database if not exists db4 character set gbk; R(Retrieve):查询 * 查询所有数据库的名称； * show databases; * 查询某个数据库的字符集：查询某个数据库的创建语句 * show create database 数据库名称； U(Update):修改 * 需改数据库的字符集 * alter database 数据库名称 character set 字符集名； D(Delete):删除 * 删除数据库 * drop database 数据库名称； * 判断数据库存在，存在再删除 * drop database if exists 数据库名称； 使用数据库 * 查询当前正在使用的数据库名称 * select database(); * 使用数据库 * use 数据库名称； 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9df306f03daedccf83f5e2983dbb5422/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/398d696e869c952b11c7b116938accbc/" rel="bookmark">
			前端QRCode.js生成二维码插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		填报二维码生成
http://code.ciaoca.com/javascript/qrcode/demo/
git仓库地址
&lt;el-table :data="scenicForm" style="width: 100%" border&gt; &lt;el-table-column label="二维码" width="180"&gt; &lt;template slot-scope="scope"&gt; &lt;div :id="'item_' + scope.row.id"&gt;&lt;/div&gt; &lt;a href="" download="erweima"&gt;点击下载二维码&lt;/a&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; export default { data() { return {} }, methods:{ // 生成二维码 qrcode(qrcode, text) { let qrcode2 = new QRCode(qrcode, { width: 100, height: 100, // 高度 text: text // 二维码内容 }), getInfo(){ //获取表格数据 //...... this.$store .dispatch('sInfo') .then(data =&gt; { if (!data) { this.$message({ message: '没有信息', type: 'warning' }); return; } this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/398d696e869c952b11c7b116938accbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bacccdfdff6b8fbbe1e5f78a1fa336c1/" rel="bookmark">
			DevEco Studio 2.0开发鸿蒙HarmonyOS应用初体验全面测评
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、开源网站二、开发工具三、鸿蒙应用初体验视频讲解四、视频配套项目源码地址五、HarmonyOS项目和Android项目对比（一）资源目录的变更1.资源目录名称有更改2.资源目录分门别类，统一管理3.部分资目录删除，新增一些资源目录类型4.编写方式有改变,xml变更为json （二）配置文件的变更（三）Java代码的变更 六、HarmonyOS项目和微信小程序项目对比七、HarmonyOS优点（1）多终端开发调试便捷（2）对开发者友好，开发难度和学习成本低1.IDE开发工具方面2.语言平台3.框架方面4.权限处理5.测试方便，无需下载模拟器 八、HarmonyOS缺点（1）HML语法有待加强，可以进一步封装完善（2）连接远程模拟设备有时间限制（3）TV模拟器有些许卡顿，建议优化 九、结束语 在9月10日召开的华为开发者大会上，宣布了鸿蒙2.0系统正式面世，同时开启了Beta版本的测试和开源网站。对于开发者来说两个最关键的点值得关注：一个是Beta版的开发工具，一个是开源网站。
一、开源网站 在开发者大会上宣布将HarmonyOS源代码捐赠给中国开放原子开源基金会，并在大会上公布了鸿蒙系统的开源路线。
官网地址：
OpenHarmony 官方源码地址
二、开发工具 鸿蒙使用基于Intellij IDEA深度定制研发的DevEco Studio作为其开发工具。官方下载地址如下：
DevEco Studio 下载地址
三、鸿蒙应用初体验视频讲解 全网最新最全面的DevEco Studio开发鸿蒙HarmomyOS项目初体验。我这里从五个方面给大家详细讲解鸿蒙应用开发，包括：开发工具安装和配置；项目代码分析；项目部署运行到模拟器；鸿蒙项目和Android项目对比；鸿蒙项目和微信小程序项目对比，最后一部分是结束语。
开发工具安装和配置。项目代码分析)。项目部署运行到模拟器。鸿蒙项目和Android项目对比。鸿蒙项目和微信小程序项目对比。最后一部分是结束语总结。 🎥 带你一起走进DevEco Studio开发鸿蒙应用初体验系列视频，点此进行观看
四、视频配套项目源码地址 ↓ 视频配套项目源码 Github 地址：
https://github.com/AweiLoveAndroid/AndroidVSHarmonygithub.com
↓ 视频配套项目源码 CodeChina CSDN 地址：
https://codechina.csdn.net/lzw2497727771/harmonyoslearning
五、HarmonyOS项目和Android项目对比 （一）资源目录的变更 1.资源目录名称有更改 安卓res目录，这里用resources目录, 它包括base 和 rawfile两部分，其中base是核心的资源目录，常用的都放在这里面，便于查找和使用。rawfile会原封不动打包到生成的应用里面。
安卓是res/values目录，这里是resources/element目录。
安卓raw目录，这里用rawfile目录。
2.资源目录分门别类，统一管理 android目录结构就比较松散，没有统一的文件夹管理，res/values目录里面可以创建各种资源的xml文件，只能去官网查看有哪些可以创建。
这里有base目录统一管理。
3.部分资目录删除，新增一些资源目录类型 比如float.json文件, plural.json文件, profile文件夹等。
4.编写方式有改变,xml变更为json 安卓的values里面是xml写的，这里是element目录里面的，都是json格式的。
最后了一张同类型资源对比图：
文件目录介绍Android Studio res目录采用格式备注DevEco Studioresources目录采用格式备注资源目录根路径res目录resources目录动画资源res/animationXML用于属性动画resources/animationXML动画资源res/animXML用于补间动画resources/animationXML布局资源res/layoutXMLresources/layoutXML元素资源根路径res/valuesXMLresources/elementJSON布尔类型资源res/values/bools.xmlXMLresources/element/boolean.jsonJSON颜色类型资源res/values/colors.xmlXMLresources/element/color.jsonJSON整型类型资源res/values/integer_arrays.xmlXMLresources/element/intarray.jsonJSON组类型资源res/values/integers.xmlXMLresources/element/integer.jsonJSON字符串数组类型资源res/values/string_arrays.xmlXMLresources/element/strarray.jsonJSON字符串类型资源res/values/strings.xmlXMLresources/element/string.jsonJSON样式类型资源res/values/styles.xmlXMLresources/element/pattern.jsonJSON浮点型类型资源无resources/element/float.jsonJSON复数形式类型资源无resources/element/plural.jsonJSON媒体资源resources/mipmap一般存放logo资源resources/media存放媒体资源，包括图片、音频、视频等非文本格式的文件存放通用的文件，它们不会被编译成二进制文件，按原样复制到设备上。resources/raw可以存放js,html,css,音频,视频等各种文件资源resources/rawfile可以存放js,html,css,音频,视频等各种文件资源可绘制资源resources/drawableresources/graphic其他类型文件无resources/profile表示其他类型文件，以原始文件形式保存 最后了一张同类型资源对比图：
↓ 完整的资源目录的具体变更对比如下图所示：
（二）配置文件的变更 清单文件 AndroidManifest 变成了 config.json 文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bacccdfdff6b8fbbe1e5f78a1fa336c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2975aed179ff376e017f0f1185f4c0/" rel="bookmark">
			微信小程序事件bindtap实现页面跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		index.wxml通过bindtap="getUrl"设置一个名为getUrl事件
&lt;view class="tab-con"&gt; &lt;view class="newsinfo" bindtap="getUrl"&gt; &lt;view class="newsimg"&gt; &lt;image src="../../images/1.png" mode="widthFix"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="con"&gt; &lt;view class="title"&gt; &lt;text&gt;标题&lt;/text&gt; &lt;/view&gt; &lt;view class="intro"&gt; &lt;rich-text&gt;近日，周迅工作室晒出了一组周迅出席时尚活动的照片&lt;/rich-text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; index.js 获取点击的参数实现url跳转
getUrl: function (e) { // var id = e.currentTarget.dataset.id;//获取到绑定的数据 //跳转传值 wx.navigateTo({ // url: '/pages/show/show?id=' + id, url: '/pages/show/show', }) }, 场景二点击跳转页面实现：
show.wxml
&lt;view class="footer"&gt; &lt;text bindtap="urlfun" data-current="0" data-url="/pages/index/index"&gt;首页&lt;/text&gt; &lt;text bindtap="urlfun" data-current="1" data-url="/pages/news/news" style="color:#fff;background:#F8626E;"&gt;新闻&lt;/text&gt; &lt;text bindtap="urlfun" data-current="2" data-url="/pages/about/about" class='{{menuTapCurrent=="0"?"hover":""}}'&gt;关于我们&lt;/text&gt; &lt;/view&gt; show.js
data: { menuTagCurrent: '1', res:{} }, urlfun: function (e){ var myurl = e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be2975aed179ff376e017f0f1185f4c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d69aeca83c4a323c223c71832fb3f099/" rel="bookmark">
			python入门--input()函数与if判断语句（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天写一下前段时间学习的python资料。
input()函数的使用 我认为input()函数是人向计算机的说话，也就是通过键盘输入信息，电脑input函数处理你输入的信息。
test = input("请问你叫什么名字？") print（test） 注意：在执行第一条程序之后，需要我们自己输入信息，这样才能给test赋值。input()函数必须要复制。
input()函数的返回类型一定是字符串，无论你在终端输入的是整型还是浮点型，input()函数数据类型一定是字符型。
input()函数数据类型是可以强制转换的。比如我想要整型，我就可以把赋值语句加上int()函数。
if判断语句 if条件判断语句在python编程中是通过判断条件是否成立，成立则执行语句，不成立则执行另一条语句。
单项判断:
a =5 if a &gt; 2: print('hello') 双向判断：
a = 5 if a &gt; 3: print('yes') else: print('no') 多向判断：
a = 101 if a &lt;= 50: print("a小于等于50") elif 50 &lt; a &lt;= 100: print("a大于50小于等于100") else: print('a大于100') if嵌套搭配input()函数使用：
fen_shu = int(input('请输入考试成绩：')) if fen_shu &gt;= 60: if fen_shu &gt;= 80: print('很优秀啊') else: print('及格啦') elif fen_shu &lt;30: if fen_shu &lt;= 10: print('你的长处可能不是考试，你可以试试其它的方面，也许你就成为人上人。') elif 10 &lt; fen_shu &lt;30: print('考的太差啦，我就不说了，天赋不够，努力来凑！') else: print('你离及格就差了几步，下次加油吧！') 结束
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf1e5ae691a6755e05b3cff335015ae4/" rel="bookmark">
			树状数组优化LIS ? 不要以为树状数组能简单的维护最大值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面几天又看了一下树状数组，突然发现树状数组维护最大值其实没有想象中的简单。
以前一直用树状数组优化LIS问题，想当然的以为树状数组可以很方便的维护前缀最大值，
细想才发现这个思路是有问题的
这是优化LIS的树状数组的更新函数
void modify(int x, int pos) { while(pos&lt;=N) { C[pos]=max(C[pos], x);//x只有比pos处的数大才会修改，而不是无条件修改 pos+=lowbit(pos); } } 可以发现事实上这并不是一般意义上的无条件修改
x只有比pos处的数大才会修改，显然这对于优化LIS是没有问题的
但对于一般的 修改-询问类的问题要多加小心，因为可能是不适用的
比如：对于a[5]=5, a[6]=6, 则b[5]=5, b[6]=6
现将a[6]修改为4，则按照前面的做法，b[6]是不变的，这是不对的
至于树状数组怎么维护区间最大，其实比较复杂，个人认为不如线段树直观
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375f284e4d82f1dfa29b365e38d30e73/" rel="bookmark">
			5个让前端代码变得简洁的最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「每天一点小知识，天天学习好孩子」
欢迎来到学习章节：5个让前端代码变得简洁的最佳实践
“即使错误的代码也可以起作用。但是，如果代码不干净，则会使开发组织屈服。” -罗伯特·马丁（鲍勃叔叔）
善用ES6最新语法API
例如解构，扩展运算符，async-await，模板字符串，可选链等
编写线性代码
始终尽可能多地编写线性代码，它使我们的代码简单，干净，易于阅读和易于维护，从而使开发人员的生活更加轻松。
我目前是在职前端开发，如果你现在也想学习前端开发技术，在入门学习前端的过程当中有遇见任何关于学习方法 学习路线，学习效率等方面的问题，你都可以申请加入我的前端学习交流3000人裙：前面：851 中间：231 最后：348。 里面聚集了一些正在自学前端的初学者裙文件里面也有我做前端技术这段时间整理的一些前端学习手册，前端面试题， 前端开发工具，PDF文档书籍教程，需要的话都可以自行来获取下载。 例如，让我们编写一个函数，向后台请求一个数据类型，并根据返回的类型查询信息。
如果使用async-await
另外在看一个常见的判断
那么这么写又如何呢？
更好的命名变量和方法
好的命名提高了代码的可读性，并且代码变得更易于维护。名称应该有意义并且具有上下文。通过阅读函数或变量的名称，人们应该了解其目的。例
「始终使用确定词来命名。因此，不要使用isNotActive ，而应该使用！isActive来替换」
函数只做一件事
功能不得大于20–25行，且单个函数功能越小越好。函数应该修改或查询某些内容，但不能两者都进行。考虑下面的代码。
同样的事情可以有更清晰的结构
使用eslint和prettier插件来格式化代码
建议使用ESLint和Prettier在开发人员之间建立通用的编码样式，查找语法错误和代码格式。 配合在项目中设置editorconfig,让所有的开发者享有同样的编码格式。
希望本文对您有所帮助，并感谢您的阅读。始终欢迎您提供反馈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792d4964f917d00b4149a515a87ac62c/" rel="bookmark">
			linux代码之 arm64 启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初看arch/arm64/boot目录下的启动代码时，发现与arch/arm/boot目录不一样了。arm64/boot/下除了dts以外，少了arm/boot下的bootp和compressed目录。少了bootp下的几个汇编文件和vmlinux.lds，一时不知从何下手了。通过编译，才看到自动生成了vmlinux.lds文件。通过对System.map的查看，发生内核的入口地址，ffffff8008080000。此地址位于text段，是个局部定义，标号为_head，在代码里搜索_head， 位于arch/arm64/kernel/head.S中，所以确定arm64的启动代码从这个文件开始。
1.启动步骤：
由跳转代码 b stext 开始。preserve_boot_args ---&gt; el2_setup ---&gt; set_cpu_boot_mode_flag ----&gt; __create_page_tables ---&gt; __cpu_setup ---&gt; __primary_switch ---&gt; __primary_switched ---&gt; start_kernel 。
。preserve_boot_args ： 保存uboot传入的参数
。el2_setup ：启动的模式是el2
。set_cpu_boot_mode_flag ： 将启动模式保存到全局变量
。__create_page_tables ： 两张内存映射表，swapper_pg_dir（内核地址映射），idmap_pg_dir（物理地址等于虚拟地址映射）
。__cpu_setup ： 初始化处理器
。__primary_switch ：开启MMU
。__primary_switched ：保存线程信息、FDT指针、清除BBS，跳转到start_kernel运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75cd74f69cc677903c1015b25b448d2/" rel="bookmark">
			JDBC （Java Database Connectivity）开发步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDBC 开发步骤 1 注册驱动 使用 Class.forName(“com.mysql.jdbc.Driver”);手动加载字节码文件到 JVM 中。
Class.forName("com.mysql.jdbc.Driver");//加载驱动 2 连接数据库 通过 DriverManager.getConnection(url,user,password) 获取数据库连接对象 URL:jdbc:mysql://localhost:3306/databaseusername:rootpassword:1234 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/database?useUnicode=true&amp;characterEncoding=utf8", "root","1234"); URL(Uniform Resource Locator) 统一资源定位符：由协议、IP、端口、SID（程序实例名称）组成 3 获取发送 SQL 的对象 通过 Connection 对象获得 Statement 对象，用于对数据库进行通用访问。
Statement statement = conn.createStatement(); 4 执行SQL 语句 执行 SQL 语句并接收执行结果。
String sql ="INSERT INTO t_jobs(JOB_ID,JOB_TITLE,MIN_SALARY,MAX_SALARY) VALUES('JAVA_Le','JAVA_Lecturer',4000,10000);"; int result = statement.executeUpdate(sql);//执行SQL语句并接收结果 注意：在编写 DML 语句时，一定要注意字符串参数的符号是单引号 ‘值’DML 语句：增删改时，返回受影响行数（int 类型）。DQL 语句：查询时，返回结果数据(ResultSet 结果集)。 5 处理结果 接受处理操作结果。
if(result == 1){ System.out.println("Success"); } 受影响行数：逻辑判断、方法返回。查询结果集：迭代、依次获取。 6 释放资源 遵循先开后关原则，释放所使用到的资源对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d75cd74f69cc677903c1015b25b448d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64824ecc746217503007e3fad81581d3/" rel="bookmark">
			C&#43;&#43; Primer 学习笔记-第三章（string &#43; vector）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此笔记仅记录容易忘记的知识点，对于已经掌握或者比较容易的知识点，此笔记将不涉及。
3.1 命名空间的using声明 (简化总是需要输入std::cin,而使用cin即可)
使用：：符号可以确定和读取特定命名空间内部的名字：
//before: std::cin &gt;&gt;xxx; std::cout&lt;&lt; xxx &lt;&lt;std::endl; //after: using std::cin,std::cout; int main(){ cout &lt;&lt;xxx &lt;&lt;endl ; cin &gt;&gt; xxx } 3.2 标准库类型string （可变长的字符序列）
基本使用方法：1. 引用string头文件： #include &lt;string&gt;
2.使用using命名空间(确定string的作用域)： using std::string;
3.使用string定义变量即可
3.2.1 定义和初始化string对象
除了标准初始化之外，还有以下几个初始化方法：
直接初始化和拷贝初始化：直接初始化就是使用c++11里面的最新初始化方法： string s1(xxx);
拷贝初始化就是使用 = 进行赋值；
#include &lt;string&gt; using std::string; int main(){ string s1; string s2=s1; string s3="hiya"; string s4(10,'c'); //s4的内容为cccccccccc //使用c++全新的定义方法： string s2(s1); string s3("hiya"); } 3.2.2 string对象上的操作
int main(){ //读写string 对象 string s; cin &gt;&gt;s; cout &lt;&lt;s; return 0; } 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64824ecc746217503007e3fad81581d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0b182aae37170f232987cd95a9755e4/" rel="bookmark">
			pyqt&#43;qt designer开发完界面程序后，利用pyinsatller打包成exe程序（脱坑记录）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 开发的界面中有一个窗口需要连接V-Rep（一款机器人仿真软件）获取视频流，需要将V-Rep提供的remoteApi.dll文件与项目文件放在同级目录以支持远程连接。
首次打包时所用命令(需先进入目标py文件所在目录)：
pyinstaller -F dianwnag3.py 打包完成后（打包时设置命令窗口未隐藏，），命令窗口一闪而过。在命令窗口打开exe文件，发现问题描述如下：
也就是remoteApi.dll在打包时未加载进去。故重新打包，以便将remoteApi.dll打包进去。代码如下：
pyinstaller -F dianwnag3.py --add-data .\remoteApi.dll;./ 打包完成后，发现依然出错。在命令窗口打开exe文件，问题描述如下：
发现先前问题已经消失，新问题仅仅是无法找到UI文件目录。故把ui4和image文件夹都复制到exe文件所在文件夹内，确保可以加载到相应ui文件及图片。
双击exe文件，等待数秒，成功打开。
如果把ui文件转为py文件，也就不用把ui4的文件夹放到相关目录，打包时py文件会自动包含。这样软件的安全性可能会更好。
尾注：出现问题不要着急去百度，先找到问题描述，分析问题，然后，，，，，再百度。回头看，问题并不复杂，但当时是真的难，搞了5.6个小时吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd1cbb0509d4a34f69b90e1479577265/" rel="bookmark">
			latex：用minipage并排放置两个表格、两个图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		并排放置表格 %---------------------------------------
\begin{minipage}{\textwidth}
\centering
\begin{minipage}[t]{0.48 \textwidth}
\centering
\makeatletter\def\@captype{table}\makeatother
\caption{The choice of $h_{i}$ }
\label{practical-h} \footnotesize
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{ |c | c| c| c| c| }
\hline
&amp;$h_{1}$&amp;$h_{2}$&amp;$h_{3}$ &amp; $h_{4}$ \\
\hline
&amp; 2 &amp; 3 &amp; 4 &amp; 1 \\
\hline
&amp; 4 &amp; 5 &amp; 6 &amp; 3 \\
\hline
&amp; 8 &amp; 9 &amp; 10 &amp; 7 \\
\hline
\end{tabular}
\end{minipage}
\begin{minipage}[t]{0.48 \textwidth}
\centering
\makeatletter\def\@captype{table}\makeatother \caption{$\textbf{S}_{i}$ and its corresponding $rs$, $l_{rs}$ }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd1cbb0509d4a34f69b90e1479577265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a17ffee55c4fb69beca8874b0c5452c4/" rel="bookmark">
			事务，事务的特性和使用以及sql优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		事务 : 每条sql语句都是一个独立操作，一个操作对数据库的影响是永久性的。
事务是一个原子操作，是最小执行单元，由一个或多个sql语句组成。在同一个事务中，所有的sql语句都执行成功时，整个事务成功。有一个sql语句执行失败，整个事务都执行失败
事务是基于增删改语句的操作
原理：数据库会为每个客户端都维护一个空间独立的缓存区（回滚段），一个事务中所有的增删改语句的执行结果都会缓存在回滚段中，当所有sql语句均正常结束，才会将回滚段中的数据同步到数据库，无论因为什么失败，整个事务将回滚 事务的特性： Atomicity （原子性） 表示一个事务内的所有操作是一个整体，要么全部成功，要么全部失败Consistency（一致性） 表示一个事务内有一个操作失败时，所有的更改过的数据都必需回滚到修改前状态Isolation （隔离性） 事务查看数据操作时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事物修改它之后的状态，不会查看中间状态的数据Durability（持久性） 持久性事务完成之后，它对于系统的影响性是永久的 START TRANSACTION; #开启事务 SETAUTOCOMMIT = 0;#禁止自动提交 = 1 #开启自动提交 # 增删改 # 增删改 # 。。。 COMMIT; # 所有语句成功 提交 ROLLBACK;# 事务出现错误，回滚 索引： ​ 索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，在数据十分庞大的时候，索引可以大大加快查询的速度，这是因为使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据
注意： ​ 1、索引需要占用磁盘空间，因此在创建索引时要考虑到磁盘空间是否足够
​ 2、创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行
索引的优缺点： 优势：可以快速检索，减少I/O次数；根据索引分组和排序，可以加快分组和排序；
劣势：索引本身也是表，因此会占用存储空间，维护和创建需要时间成本；也会降低数据表的修改操作的效率，因为在修改数据表的同时还需要修改索引表；
索引的分类： 1、主键索引：即主索引，根据主键 建立索引，不允许重复，不允许空值；
2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值
3、普通索引：用表中的普通列构建的索引，没有任何限制
4、全文索引：用大文本对象的列构建的索引
5、组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值
6、组合唯一索引：列值的组合必须唯一
### mysql优化： - 选择合适的数据类型 - 避免空值 ，null字段依旧会占用空间，使索引更加复杂，使用有意义的值代替null 也能避免 is not null 的使用 - text类型优化：text字段存储数据量大，容易影响其他字段的查询 ，单独取出来放在子表里，用业务主键关联。 - 索引优化：分页查询。单表索引数不超过5个、单个索引字段数不超过5个 - 操作符&lt;&gt; 优化， 通常&lt;&gt;操作符无法使用索引 使用 union (all) 代替 &lt;&gt; - OR 优化 在Innodb引擎下or无法使用组合索引 使用 union (all) 代替 OR - IN 优化 使用 left join代替 - 不做列运算 通常在查询条件列运算会导致索引失效 - 避免 * 的出现 - like优化 尽量不要前后都模糊的查询 如果要求前后都模糊 可以用全文索引fulltext，但Elasticsearch才是终极武 - join 优化 join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为基础数据，通过该结数据作为	过滤条件到下一个表中循环查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环	数据，再次到后一个表中查询数据。 ​	1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a17ffee55c4fb69beca8874b0c5452c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e704b6bd8af3c3da7cfcb23e8426872/" rel="bookmark">
			数据库常用的四种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序查询
select 列表属性，列表属性 from 列表名order by 列表属性，列表属性;
删除
delete from 列表名 where 列表属性=“值”
插入
insert into 列表名 values(值，值，值，值）
insert into 列表名 （列1，列2，…）valves(值1，值2…)
修改
update 列表名 set 列表属性=新值 where 列表属性=某值
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66ce95a7a6f95c87df87a6486db337df/" rel="bookmark">
			Java8 - 使用 Comparator.comparing 进行比较排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://blog.csdn.net/Hydra_shuang/article/details/84573212
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23a4260b95e0c4c1b23082b214f403a4/" rel="bookmark">
			2020-09-08
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
@[TOC](2020-09-08)
前言 提示：这里可以添加本文要记录的大概内容：
例如：随着人工智能的不断发展，机器学习这门技术也越来越重要，很多人都开启了学习机器学习，本文就介绍了机器学习的基础内容。
提示：以下是本篇文章正文内容，下面案例可供参考
#1 一、pandas是什么？ 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。
#2 二、使用步骤 1.引入库 代码如下（示例）：
import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns import warnings warnings.filterwarnings('ignore') import ssl ssl._create_default_https_context = ssl._create_unverified_context 2.读入数据 代码如下（示例）：
data = pd.read_csv( 'https://labfile.oss.aliyuncs.com/courses/1283/adult.data.csv') print(data.head()) 该处使用的url网络请求的数据。
总结 提示：这里对文章进行总结：
例如：以上就是今天要讲的内容，本文仅仅简单介绍了pandas的使用，而pandas提供了大量能使我们快速便捷地处理数据的函数和方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06589287a709bdd70316365df5f44b8c/" rel="bookmark">
			Elsevier 期刊模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Elsevier 期刊模板下载说明
https://www.elsevier.com/authors/author-schemas/latex-instructions
or
Elsevier 期刊模板直接下载地址
https://ctan.org/tex-archive/macros/latex/contrib/elsarticle
Elsevier期刊模板中，连续多篇参考文献
转载：
http://laser2007.blog.sohu.com/165757649.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64114c9884e2995253394db3d7abc29b/" rel="bookmark">
			RSA签名和验签说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近遇到一个项目，需要进行RSA的验签，RSA的密钥为2048位即256个字节长。
上游是先对一个文件进行SHA256做hash，得到32字节的摘要，然后进行填充，填充规则为前面两个字节为0x00,0x01，然后填充全FF，接下来是32字节的摘要数据，这样填充之后的总数据长度为256字节，然后使用RSA的私钥对这256字节进行签名，下发下来，下游需要对这个签名进行处理，得到原始摘要，然后跟自己计算的摘要比对，验证通过则合法。
涉及的知识点如下：
一、RSA签名算法的填充方式，常用的有如下三种
1、RSA/ECB/PKCS1Padding 填充模式，最常用的模式
要求:
输入：必须 比 RSA 密钥长度 短至少11个字节, 否则会报错，数据不足时由接口自动进行随机填充
如果输入的明文过长，必须切割，　然后填充
输出：和RSA密钥长度一样长
根据这个要求，对于2048bit的密钥，　block length = 2048/8 – 11 = 245字节
注意：加密的时候会在你的明文中随机填充一些数据，所以会导致对同样的明文每次加密后的结果都不一样。
对加密后的密文，服务器使用相同的填充方式都能解密。解密后的明文也就是之前加密的明文。
如果是私钥签名，那么填充的前面两个字节为0x00和0x01(表示私钥签名)，如果是公钥签名，那么填充的签名的两个字节为0x00和0x02(表示公钥签名)，然后填充全FF，在填充最后的有效数据之前，会填充一个00，然后后面就全部是有效数据，所以使用RSA签名的数据再解密之后得到的数据在真是数据之前一定有00，否则就是输入没有严格遵守RSA/ECB/PKCS1Padding填充方式
2.RSA_PKCS1_OAEP_PADDING
输入：必须 比 RSA 密钥长度 短至少41个字节, 否则会报错，数据不足时由接口自动进行随机填充
输出：和RSA密钥长度一样长
3.RSA/ECB/NoPadding　不填充
输入：可以和RSA钥模长一样长，如果输入的明文过长，必须切割，然后填充，这种方式需要自己手动进行填充好输入数据
输出：和RSA密钥长度一样长
跟DES，AES一样，　RSA也是一个块加密算法（ block cipher algorithm），总是在一个固定长度的块上进行操作。
但跟AES等不同的是，　block length是跟key length有关的。
每次RSA加密的明文的长度是受RSA填充模式限制的，但是RSA每次加密的块长度就是密钥长度
具体代码片段如下：
/**
* RSA签名
* * @param key RSA的密钥 公钥用X.509编码；私钥用PKCS#8编码
* @param data 输入数据
* @param mode 0-加密，1-解密
* @param type 0-私钥加密，公钥解密 1-公钥加密，私钥解密
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64114c9884e2995253394db3d7abc29b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96148b825bc7d34198c6ed57346d1526/" rel="bookmark">
			PyQt5之信号与槽介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyQt的窗口控件类中有很多内置信号，开发者也可以添加自定义信号。在编写一个类时，要先定义该类的信号与槽，在类中信号与槽连接，实现对象之间的数据传输。信号与槽具有如下特点：
一个信号可以连接多个槽；一个信号可以连接另一个信号；信号参数可以是任何Python类型；一个槽可以监听多个信号；信号与槽的连接方式可以是同步连接，也可以是异步连接；信号与槽的连接可能会跨线程；信号可能会断开。 一、定义信号 为QObject对象创建信号： -使用pyqtSignal()函数创建一个或多个重载的未绑定的信号作为类的属性，信号只能在QObject的子类中定义。 -信号必须在类创建时定义，不能在类创建后作为类的属性动态添加进来。 -使用pyqtSignal()函数创建信号时，信号可以传递多个参数，并指定信号传递参数的类型，参数类型是标准的Python数据类型（字符串、日期、布尔类型、数字、列表、元组和字典）。 为控件创建信号： from PyQt5.QtCore import * from PyQt5.QtWidgets import * class WinForm(QMainWindow): btnClickedSignal = pyqtSignal() #为自定义控件WinForm创建了一个btnClickedSignal信号 二、操作信号 使用connect()函数可以把信号绑定到槽函数上；使用disconnect()函数可以解除信号与槽函数的绑定；使用emit()函数可以发射信号。 三、信号与槽的入门应用 内置信号与槽的使用： import sys from PyQt5 import QtCore from PyQt5.QtWidgets import * from PyQt5.QtGui import * from PyQt5.QtCore import * app = QApplication([]) form = QWidget() def showMsg(): QMessageBox.information(form,"信息提示框","ok,弹出测试信息") btn = QPushButton('测试点击按钮',form) #将信号与槽绑定，clicked为内置信号，单击按钮会出现提示框 btn.clicked.connect(showMsg) form.show() sys.exit(app.exec_()) 运行效果如下：
自定义信号与槽的使用： import sys from PyQt5 import QtCore from PyQt5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96148b825bc7d34198c6ed57346d1526/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/367/">«</a>
	<span class="pagination__item pagination__item--current">368/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/369/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>