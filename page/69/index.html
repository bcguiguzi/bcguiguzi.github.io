<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/515c83071cbb5b2c5c535181bc7e03f3/" rel="bookmark">
			SpringBoot基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot基础快速开发 SpringBoot 概述SpringBoot 快速入门快速构建springboot项目(推荐)基于maven搭建SpringBoot工程 SpringBoot 起步依赖原理分析SpringBoot 配置yamlprofile内部配置加载顺序外部配置加载顺序 SpringBoot 整合其他框架SpringBoot整合Junit。SpringBoot整合Redis。SpringBoot整合MyBatis. SpringBoot 项目部署jar包(推荐)war包 SpringBoot 概述 SpringBoot官方开发文档spring boot reference guide
springBoot快速入门指南官方地址
Spring Boot 功能
自动配置
起步依赖(传递依赖):将具备某种功能的坐标打包到一起,并提供一些默认的功能.
辅助功能:内置tomcat等
Spring Boot 并不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式。
SpringBoot 快速入门 快速构建springboot项目(推荐) 使用springboot构建应用官方地址
快速构建springboot官方网址
基于maven搭建SpringBoot工程 创建Maven项目
导入SpringBoot起步依赖
pom.xml中添加
&lt;groupId&gt;com.emprock&lt;/groupId&gt; &lt;artifactId&gt;springboot_helloworld&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 从Spring Boot默认继承 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- 为web应用程序添加典型的依赖项 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ​
定义Controller
HelloController类中
package com.emprock.controller; import org.springframework.web.bind.annotation.RequestMapping; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/515c83071cbb5b2c5c535181bc7e03f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/707c23684842908ae54b23ddaa6d171f/" rel="bookmark">
			AcWIng 901 滑雪 记忆化搜索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定一个 R 行 C 列的矩阵，表示一个矩形网格滑雪场。
矩阵中第 i 行第 j 列的点表示滑雪场的第 i 行第 j 列区域的高度。
一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。
当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。
下面给出一个矩阵作为例子：
1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 在给定矩阵中，一条可行的滑行轨迹为 24−17−2−1。
在给定矩阵中，最长的滑行轨迹为 25−24−23−…−3−2−1，沿途共经过 25 个区域。
现在给定你一个二维矩阵表示滑雪场各区域的高度，请你找出在该滑雪场中能够完成的最长滑雪轨迹，并输出其长度(可经过最大区域数)。
输入格式 第一行包含两个整数 R 和 C。
接下来 R 行，每行包含 C 个整数，表示完整的二维矩阵。
输出格式 输出一个整数，表示可完成的最长滑雪长度。
数据范围 1≤R,C≤300
0≤矩阵中整数≤100000
输入样例： 5 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 输出样例： 25 记忆化搜索的本质就是将深度优先搜索的过程，通过避免重复计算同一个状态的结果，从而将时间复杂度优化到多项式复杂度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/707c23684842908ae54b23ddaa6d171f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/896e2bee03901a17891b4d7696d3a6c3/" rel="bookmark">
			时间复杂度解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时空复杂度概述
首先o(1), o(n), o(logn), o(nlogn)是用来表示对应算法的时间复杂度,这是算法的时间复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。
算法复杂度分为时间复杂度和空间复杂度。其作用：
时间复杂度是指执行这个算法所需要的计算工作量；
空间复杂度是指执行这个算法所需要的内存空间；
时间和空间都是计算机资源的重要体现，而算法的复杂性就是体现在运行该算法时的计算机所需的资源多少； 时间复杂度的优劣对比
常见的数量级大小：越小表示算法的执行时间频度越短，则越优；
O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2n)//2的n方&lt;O(n!)&lt;O(nn)//n的n方
O(1)解析
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话），冲突的话很麻烦的，指向的value会做二次hash到另外一快存储区域。
通俗易懂的例子
什么是O(1)呢，就比如你是一个酒店的管理员，你负责管理酒店的钥匙，你很聪明，你把酒店的100把钥匙放在了100个格子里面存着，并且把格子从1~100进行了编号，有一天有客人来了，酒店老板说，给我拿10号房间的钥匙给我，你迅速从10号格子里面拿出钥匙给老板，速度非常快，这时候你就是一个电脑了，老板跟你说拿几号房房间的钥匙，你只需要看一眼就能知道钥匙在哪里。
O(n)解析
比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。
比如常见的遍历算法。要找到一个数组里面最大的一个数，你要把n个变量都扫描一遍，操作次数为n，那么算法复杂度是O(n)。链表遍历是典型的例子。
通俗易懂的例子
突然，有一天，你的老板给你说，你用100个箱子存100把钥匙，太浪费空间了，你能补能把钥匙上编号一下，然后把钥匙要用绳子穿起来，这样我们可以把这个放箱子的地方再装修一个房间出来。你想了一下，是啊，现在房价这么贵，这样能多赚点钱。所以你就不能通过上面的方法来找到钥匙了，老板跟你说，给我拿45号房间的钥匙出来，你就需要从100个钥匙里面挨个找45个房间的钥匙。
O(n^2) 解析
再比如时间复杂度O(n2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n2)的算法，对n个数排序，需要扫描n×n次。
用冒泡排序排一个数组，对于n个变量的数组，交换位置n2次数，所以复杂度是n2
通俗易懂的例子
随着经济发展越来越好，你的老板把酒店扩大了，有100层每一层有100个房间，你把每一层的钥匙穿在一起，然后一共就有100个用绳子穿起来的钥匙串。然后老板叫你找钥匙的时候，你先要找到楼层的编号，再对应找到房间的编号，所以大概对应的是这样的代码。
O(log n)解析
再比如O(log n)，当数据增大n倍时，耗时增大log n倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(log n)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。
通俗易懂的例子
这个就像是有一百把钥匙，你突然觉得，我从头找是不是太慢了，我从中间找，比如我要找到23号的房间钥匙，我从中间切开，找到50编号的位置，然后23在150里面，我再把从中间切开变成25，然后23在125之间，我再切开变成12.5，然后23在12.5~25之间，依次找下去，直到找到钥匙。这种查找钥匙的方法的复杂度就是O(log^n)
O(n log n)解析
O(n log n)同理，就是n乘以log n，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(n log n)的时间复杂度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fea4f3b833de8c8ea8649205ab3f97a8/" rel="bookmark">
			nodejs中process.execPath和__dirname差异
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用nodejs的pkg打包工具打包exe包的时候发现引用外部文件做配置文件时需要更改path.join的参数：
var configInfo = require(path.join(process.execPath,'../data/config.json')); //打包用 var configInfo = require(path.join(__dirname,'../data/config.json')); //调试用 process.execPath是一个用于存储当前正在执行的Node.js可执行文件的路径的字符串。它返回Node.js可执行文件的绝对路径，例如/usr/local/bin/node。
__dirname是一个全局变量，它表示当前模块的目录的路径。它是相对于当前模块文件所在的路径的字符串。例如，如果__dirname的值是/Users/user/Documents/project, 则表示当前模块的所在路径。
区别在于，process.execPath存储了Node.js可执行文件的路径，而__dirname存储了当前模块的路径。process.execPath在整个Node.js进程中只有一个值，而__dirname在每个模块中都有自己的值，根据当前模块所在的不同，__dirname的值也会不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb455d8ddac404a6401bd40b2791c38e/" rel="bookmark">
			在nodejs中使用mysql2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装 mysql2:导入 mysql2 模块:创建数据库连接:执行查询操作:关闭数据库连接: 在之前的项目中nodejs模板使用的mysql包，mysql数据库版本是5.7，最近更新了数据库版本为mysql8，发现之前的代码无法成功连接数据库，经过排查发现问题就出在8和5.7的账号密码加密方式有差异，mysql5.7前账号密码是mysql_native_password加密，mysql8用caching_sha2_password加密匹配
mysql2 是一个基于 libmysqlclient 的 Node.js MySQL 驱动程序。用于与 MySQL 数据库进行交互。它提供了一些简单易用的方法来执行数据库操作。
以下是 mysql2 的用法示例：
安装 mysql2: npm install mysql2 导入 mysql2 模块: const mysql = require("mysql2"); 创建数据库连接: 直接连接：
const connection = mysql.createConnection({ host: "localhost", user: "root", password: "password", database: "mydatabase" }); 数据库连接池：
var mysql_pool_config = { host: "localhost", user: "root", password: "password", database: "mydatabase" } var dbpool = mysql.createPool(mysql_pool_config); // module.exports=dbpool //模块化文件加 执行查询操作: 它还提供了更多的功能，例如批量插入、事务管理和预处理语句等。
有关更详细的用法，可以参考 ：https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb455d8ddac404a6401bd40b2791c38e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00fecb4c8d6d2f4440273a9fe6479537/" rel="bookmark">
			bqplot，一个非常强大的 Python 库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 bqplot 是一个基于Jupyter Notebook的交互式2D绘图库，它是用Python编写的，并且与Jupyter交互性非常强。该库利用了d3.js的能力，并与Jupyter交互框架无缝集成，使得绘图变得更加容易和交互性更强。bqplot 的一个主要特点是它允许用户创建复杂的可视化，并提供丰富的交互功能，这些特性使得它非常适合教育和研究。
安装方式 bqplot 可以通过pip进行安装，也可以通过conda进行安装。建议在虚拟环境中进行安装以避免依赖冲突。
使用 pip 安装：
pip install bqplot 使用 conda 安装：
conda install -c conda-forge bqplot 确保你的Jupyter Notebook环境已经配置妥当。为了在Jupyter Notebook中使用bqplot，你需要确保你的nbextension是启用的。通常安装bqplot时会自动启用，但如果没有，你可以手动启用它：
jupyter nbextension enable --py bqplot 使用方式 在Jupyter Notebook中使用bqplot，你需要首先导入必要的模块，然后创建图表、轴和标记等，最终显示图表。
# 导入 bqplot 的相关模块 import bqplot as bq from bqplot import pyplot as plt 创建基本的图表通常涉及几个步骤：
创建一个或多个标记（例如线、条形图、散点图等）。
创建图表的x轴和y轴。
将标记和轴添加到Figure对象中。
显示Figure对象。
代码示例 由于需要至少150行的代码示例，下面将通过一个较为复杂的图表来详细展示bqplot的使用。
# 此示例代码可能需要根据实际情况调整以确保能够在您的环境中运行 # 导入必要的模块 import numpy as np from bqplot import ( OrdinalScale, LinearScale, Bars, Lines, Axis, Figure, Tooltip ) from IPython.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00fecb4c8d6d2f4440273a9fe6479537/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6435784d83fcb548bd5ae8978b3fb2b9/" rel="bookmark">
			X-AnyLabeling标注工具的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 项目链接：https://github.com/CVHub520/X-AnyLabeling/tree/main
X-AnyLabeling 是一款全新的交互式自动标注工具，其基于 Labelme 和 Anylabeling 等诸多优秀的标注工具框架进行构建，在此基础上扩展并支持了许多丰富的模型和功能，并借助Segment Anything和 YOLO 系列等目前主流和经典的深度学习模型提供强大的 AI 能力支持。无须任何复杂配置，下载即用，大大降低用户使用成本，同时支持自定义模型和快捷键设置等，极大提升用户标注效率和使用体验!
X-AnyLabeling 具备以下优势：
支持中英文一键切换，随心所欲；支持必要的快捷键操作，可自定义设置；支持CPU和GPU一键推理，可按需选取；提供详细的操作手册及交流社区，帮助用户快速解决问题；支持Windows、Linux和MacOS等多个主流的操作系统，同时支持用户自编译；提供多种标注样式，包括多边形、矩形、线段、点、圆形、文本等，以满足用户的多元化的需求.支持多种导出格式，包括 YOLO-txt、COCO-json、VOC-xml 以及图片掩码等，只需一键运行，即可满足日常训练所需标签样式。提供多种模型架构，包括但不仅限于YOLO系列、DETR系列和SAM系列等，可无缝衔接OpenMMLab、PaddlePaddle、timm等多个主流的深度学习框架，同时支持自定义模型导入。支持多种任务模式，包括目标检测、语义分割、姿态估计、人脸关键点回归、文本检测、识别和KIE（关键信息提取）标注等。 此外，为了加速模型推理速度，提供了多个量化版本及LRU缓冲机制，极大提升用户体验。
AI标注功能： 第一： 目标检测 &amp; 语义分割 提供了多个yolo的模型
第二：细粒度检测分类 细粒度与粗粒度概念对比
粗粒度：类间appearance差异较大，如猫、鸟、鱼、飞机、汽车等细粒度：类间差异较小，如不同品种的犬类之间，不同型号的飞机之间等 例如下面的例子使用YOLOv5s-ResNet50模型进行分类
第三：人脸检测+关键点回归 例如下面的例子使用YOLOv6Lite-Face模型进行分类
第四：全身人体姿态估计 例如下面的例子使用YOLOX+DWPose模型进行分类
第五：车道线检测 例如下面的例子使用CLRNet-tusimple-r18模型进行分类
第六：医学图像分割 超声波乳腺癌分割 | 结直肠息肉分割 | 皮肤镜病变分割
第七：自然图像分割 使用SAM-ViT-B、SAM-ViT-L、SAM-ViT-H或者Mobile-SAM模型进行分割。
第八：OCR 文本标签是许多标注项目中的一项常见任务，但遗憾的是在 Labelme 和 LabelImg 中仍然没有得到很好的支持。X-AnyLabeling 中完美支持了这一项新功能。
图像文本标签：用户可以切换到编辑模式并更新图像的文本——可以是图像名称或图像描述。
文本检测标签：当用户创建新对象并切换到编辑模式时，可以更新对象的文本。
文本分组：想象一下，当使用 KIE（键信息提取）时，需要将文本分组到不同的字段中，包含标题和值。在这种情况下，你可以使用文本分组功能。当创建一个新对象时，我们同样可以通过选择它们并按G将其与其他对象组合在一起。分组的对象将用相同的颜色标记。当然，也可以按快捷键U取消组合。
参考链接：https://zhuanlan.zhihu.com/p/656703406
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e532203678bec1237610084f2532e2/" rel="bookmark">
			Django、Flask 与 Javascirpt 之间传值与数据转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见问题：JavaScript 如何处理Django、Flask传递的数据库数据 Django 、Flask从数据库读出的数据通常保存为：对象列表、字典列表，或 tuple列表形式
# 用object_list 对象列表表示数据库记录 [ &lt;Article: id=1,title=星际穿越影评,body=作为一部硬科幻电影，..., ck=False&gt;, &lt;Article: id=2,title=流浪地球,body=《流浪地 球》该部影片..., ck=False&gt;, &lt;Article: id=3,title=海的尽头是草原,body=无论处在多么艰难的时..., ck=False&gt;, &lt;Article: id=4,title=我们的岁月,body=想看看时代的缩影，结..., ck=False&gt; ] # 用 字典列表来表示数据库记录 [ {'id': 1, 'title': '星际穿越影评', 'ck': False}, {'id': 2, 'title': '流浪地球', 'ck': False}, {'id': 3, 'title': '海的 尽头是草原', 'ck': False}, {'id': 4, 'title': '我们的岁月', 'ck': False} ] # 以tuple 列表，或二维列表，表示数据库记录 [ (1, '星际穿越影评', False), (2, '流浪地球', False), (3, '海的尽头是草原', False), (4, '我们的岁月', False), ] 有时，我们需要使用Javascript的功能，比如使用 echarts 库进行绘图, 或者为了减轻服务器压力只返回原始数据给浏览器，在本地通过 assembly 或javascript 进行数据处理，等场景下，在javascript 端需要对收到的数据转换为javascript 易于处理的格式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32e532203678bec1237610084f2532e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61d4fa58f479460c2f47cacdbdf65e38/" rel="bookmark">
			pve宿主机更改网络导致没网,pve更改ip
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 快过年了，我把那台一直在用的小型服务器，带回去了，导致网络发生了变更，需要对网络进行调整，否则连不上网，我这里改的是宿主机，不是pve虚拟机中的系统。
二、解决方法 pve用的是debian,参考debian怎么修改网络即可,按如下操作即可
2.1 修改/etc/network/interfaces配置文件 root@xxxx:~# vi /etc/network/interfaces 或者 root@xxxx:~# vim /etc/network/interfaces auto lo iface lo inet loopback iface enp2s0 inet manual auto vmbr0 iface vmbr0 inet static address 192.159.1.230/24 # 新的ip地址 （可以从ifconfig 上查看） gateway 192.159.1.1 # 网关，可以从另一台同网段的主机查看（这个配错 可能访问会出现问题） bridge_ports enp2s0 bridge_stp off bridge_fd 0 iface vmbr0 inet manual 最主要的就是更改其中的address和gateway即可，修改好之后执行如下命令，重启系统。
reboot 上面是修改网络，下面修改下两个无用的配置，主要是显示用的，不修改也不影响使用
2.2 修改 /etc/issue 配置文件 此文件是刚开机时欢迎屏幕那块的显示配置文件，其实没啥作用。
vim /etc/issue 2.3 修改/etc/hosts配置文件 此文件应该是你安装虚拟机是配置的地址关联文件，其实也没啥作用。
vim /etc/hosts 上面是直接通过命令的方式修改的，也可以直接通过界面的方式修改
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfcb7db2528b3e121ceb0bccb345cf3/" rel="bookmark">
			vue3的reactive赋值问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue3的reactive赋值问题 问题 vue3中直接对reactive声明的变量本身进行赋值是无效的。
筛选表单重置功能 // 数据结构 let filterForm = reactive({ createDate: null, q: null }) 起初我的做法是直接给filterForm变量赋值。
function reset() { filterForm = { createDate: null, q: null } } 写完之后发现无效，便改成了单个数据置空，此时生效了。
function reset() { filterForm.createDate = null filterForm.q = null } 弹窗数据回显 const props = defineProps({ visible: { type: Boolean, default: false }, data: { type: Object, default: {} } }) let visible = ref(false) let modalData = reactive({}) 我的逻辑：监听visible变量，如果弹窗显示，则将数据回显。
我的做法是：把props.data结构赋值给modalData变量，结果没有生效，我用vue插件查看，插件显示modalData变量是一个空对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecfcb7db2528b3e121ceb0bccb345cf3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92889253dc7b8f6406921ed892bf7dd0/" rel="bookmark">
			MCU常用外设总线
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、时钟与中断二、GPIO三、ADC四、定时器4.1 基本定时器4.2 通用定时器4.2.1 输入捕获4.2.2 输出比较 五、UART5.1 通讯的基本概念5.1.1 串行通讯与并行通讯5.1.2 全双工、半双工及单工通讯5.1.3 同步通讯与异步通讯5.1.4 通信速率 5.2 异步串口UART5.2.1 物理层5.2.2 协议层 5.3 串口配置 六、IIC6.1 IIC简介6.1.1 IIC物理层6.1.2 IIC协议层6.1.3 IIC读写通讯 6.2 软件模拟I2C 七、SPI7.1 SPI简介7.1.1 SPI物理层7.1.2 SPI协议层7.1.3 SPI工作模式7.1.4 SPI通讯方式 7.2 硬件SPI7.3 软件模拟SPI 前言 本文主要讲单片机外设的功能，即这些外设是什么，可以用来干什么，了解了之后我们就可以通过相应的寄存器配置来驱动这些外设。本文带大家深入了解一下这些外设的工作原理，知道了功能之后，对应任意一个MCU都可以找相应功能的寄存器。因为寄存器名字可以不同，配置方式可以不同，但是功能不可能有很大的差异。这样才能在换一个平台MCU的情况下，实现快速入手
一、时钟与中断 在之前首先了解一下寄存器，与远古时代的汇编不同，现在都是C语言操作寄存器。那寄存器是什么，百度百科说的很笼统，我们可以将寄存器比做成可以被软件控制的开关，通过不同的开关组合状态，就可以形成我们想要的功能。
然后我们再了解一下时钟，学过数电的都知道，系统内部改变状态都需要一个CLK脉冲信号，这边到MCU就是一个时钟信号。以下所有外设都需要时钟的支持，当然我们可以通过寄存器和选择器来配置系统时钟，并对其作相应的分频和倍频，来得到我们需要的时钟频率。以下就是M4内核的时钟树结构：
不过时钟不需要太关心，我们只需要知道常用的主频是多少Hz就行，因为对于像STM32之类，使用库函数都被官方封装好了时钟，然后被启动文件直接上电执行。如果是RISC或者STM8内核之类，其实配置时钟就一两个寄存器，一般就是主频选择和时钟分频。其他如51内核的，一般情况下不需要配置时钟，MCU默认开启，除非需要修改时钟的情况下才需要配置。
有了上面的基础就可以开始中断部分了，首先要知道中断是什么？中断是一种发生了一个外部的事件时调用相应的处理程序的过程。这个概念可能不好理解，那我们直接需要知道就是中断可以用来干什么，怎么来触发中断的就行。正常情况下，计算机所有指令都是随着系统时钟从上到下执行，但是中断可以在系统指令执行期间优先执行。
通常情况下，中断需要一个触发源，即触发中断的信号，如外部中断、定时器、ADC等等，出发后程序运行进入中断函数，原主函数位置会保存到栈空间，等中断函数执行完成之后，再从栈空间读取继续主函数的运行。
上图就是STM32的中断控制器，其他MCU也很类似，由上大概可以知道需要配置的寄存器如下，然后再对比参考手册找相应的寄存器：
中断触发源：即触发中断信号的来源中断优先级：部分MCU需要配置中断优先级，即高优先级的中断优先处理中断触发类型：比如在上升沿触发中断使能：即开启中断功能中断标志位：主要是触发中断和中断完成标志位，需要软件判断和设置 二、GPIO GPIO（ general purpose intput output） 是通用输入输出端口的简称。那什么是输入输出呢？我们都知道芯片只能处理数字信号，数字信号在数据上体现为逻辑0和逻辑1，实际上代表了高电平（5V或3.3V）和低电平（0V）两种状态。那输入就是MCU通过I/O口来检测外部电平状态，而输出就是MCU向外部输出不同的电平状态。
知道I/O的功能之后，我们就可以来配置GPIO，需要配置的参数如下：
I/O时钟
ARM系列需要单独开启IO时钟，其他如51、STM8、RISC等不需要配置，只需要初始化系统时钟即可。方向控制
方向控制就是配置IO口输入输出模式，基本所有MCU都需要配置输入模式配置
当IO被用于输入模式时，一般可设置为上拉、下拉或浮空模式。所谓的上拉就是接一个上拉电阻，上拉电阻连接正极，提供5V或者3.3V电压，即默认高电平。浮空模式就是没有高低电平状态，I/O口电压跟随周围电路状态输出模式配置
当IO被用于输出模式时，一般可设置为推挽、开漏或准双向口。准双向口和推挽的区别是，推挽是强上下拉，可以提供更大的电流，但是准双向口可以进行输入输出。开漏输出时会关闭内部上拉电阻，只能下拉输出，上拉输出需要外部加上拉电阻。由于开漏相当于MOS开关，所以可以用于IIC电路电平匹配数据寄存器
当I/O口作为输入的时候，可以读取数据寄存器，查看I/O口高低电平状态；当I/O口作为输出时，将数据写进数据寄存器，此时对应的引脚就可以输出相应的电平状态I/O复用与映射
I/O复用是一个很常见的功能，就是将普通的I/O口当作其他外设使用，比如复用为ADC可以当作模拟输入，复用给定时器作为PWM输出等等；而映射就是当复用的I/O引脚不够用的时候，可以把其他外设比如ADC的某个通道，映射到特定的引脚，原来的I/O作为其他用途 三、ADC 首先要知道ADC是什么？ADC，Analog-to-Digital Converter的缩写，指模/数转换器或者模数转换器，是指将连续变化的模拟信号转换为离散的数字信号的器件。
那ADC有什么用呢？我们在电路中通常会使用一些传感器，这些传感器可以将一些模拟量转换成不同的阻值，比如温度传感器，他的阻值会随着温度的变换而变化，此时我们只要测量出阻值就可以根据线性表得出温度。而ADC最基本的作用就是测量电压，然后我们就可以根据电压值计算出阻值，从而得到最终温度。
上图就是STM32内部ADC框架，还是很复杂的，不过一些MCU的ADC没有那么多功能，我们可以去掉上图的3和7，以一个RISC的内部ADC框架来说明，如下图：
这样了解ADC就会简单点，ADC具体配置如下：
ADC时钟配置 使能ADC时钟，即开启ADC选择时钟源，即时钟信号的来源，比如系统时钟，内部晶振，外部晶振进行时钟分频采样延迟，防止采样抖动，可以选择延迟一段时间后采样 通道选择 I/O配置：使用ADC采样一定是用的某个I/O口，将其设置成模拟输入模式通道选择：每个ADC几个通道，分别对应不同的I/O口，也可以使用I/O映射功能 触发模式选择 触发源：一般可以定时器中断触发，ADC中断触发，或者软件触发触发方式：一般有上升沿、下降沿、低电平等等之类触发 参考电压选择
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92889253dc7b8f6406921ed892bf7dd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7e60d237ff6d30012ef39d1baa4371/" rel="bookmark">
			VUE:实现随鼠标移动旋转的3D卡片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、效果展示 二、实现原理 1.通过 @mousemove获取鼠标位置，再计算应有的旋转角度
2.通过perspective() rotateY() rotateX()实现旋转
三、代码展示 &lt;template&gt; &lt;div class="page"&gt; &lt;div class="card" @mousemove="handleMouseMove($event)" @mouseleave="handleMouseLeave($event)" ref="cardRef" &gt; &lt;div class="box1"&gt;{{ position.x }},{{ position.y }}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; import { ref, reactive } from "vue"; const cardRef = ref(); const position = reactive({ x: 0, y: 0 }); const handleMouseMove = (e: any) =&gt; { position.x = e.offsetX; position.y = e.offsetY; let roX = position.x / 9 - 15; let roY = -((position.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7e60d237ff6d30012ef39d1baa4371/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e34660202256c0dca4d8bb26a5eac60e/" rel="bookmark">
			python3.8 安装缺少ssl、_ctypes模块解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 安装pyhton3.8安装默认不依赖ssl
运行Flask项目时报错：
Traceback (most recent call last): File "/usr/local/python3/bin/flask", line 8, in &lt;module&gt; sys.exit(main()) File "/usr/local/python3/lib/python3.8/site-packages/flask/cli.py", line 967, in main cli.main(args=sys.argv[1:], prog_name="python -m flask" if as_module else None) File "/usr/local/python3/lib/python3.8/site-packages/flask/cli.py", line 586, in main return super(FlaskGroup, self).main(*args, **kwargs) File "/usr/local/python3/lib/python3.8/site-packages/click/core.py", line 1078, in main rv = self.invoke(ctx) File "/usr/local/python3/lib/python3.8/site-packages/click/core.py", line 1686, in invoke sub_ctx = cmd.make_context(cmd_name, args, parent=ctx) File "/usr/local/python3/lib/python3.8/site-packages/click/core.py", line 943, in make_context self.parse_args(ctx, args) File "/usr/local/python3/lib/python3.8/site-packages/click/core.py", line 1408, in parse_args value, args = param.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e34660202256c0dca4d8bb26a5eac60e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2482096560855c51402200de57870bab/" rel="bookmark">
			ubuntu下faster-whisper安装、基于faster-whisper的语音识别示例、同步生成srt字幕文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、faster-whisper的安装1.docker及nvidia-docker安装2.镜像下载3.启动容器3.容器中创建用户，安装anaconda 二、基于faster-whisper的语音识别1.将cuda 和 nvidia加入到dl的环境变量中2.安装faster-whisper3.模型下载4.启动jupyter notebook 测试是否安装成功 三、转srt字幕文件 前言 上一篇某站视频、音频集合批量下载写了如何下载某站的音频和视频文件，这一篇主要讲解记录一下基于faster-whisper的语音识别怎么做，不包含理论部分，主要包括以下三部分
1）faster-whisper的安装
2）基于faster-whisper的语音识别
3）转srt字幕文件
一、faster-whisper的安装 1.docker及nvidia-docker安装 见ubuntu20.04下nvidia驱动安装，docker/nvidia-docker安装
2.镜像下载 docker pull nvidia/cuda:11.3.1-cudnn8-devel-ubuntu20.04 3.启动容器 docker run -itd --name=faster-whispter-demo --net=host --gpus all --shm-size=16g nvidia/cuda:11.3.1-cudnn8-devel-ubuntu20.04 bash docker exec -it faster-whispter-demo bash 3.容器中创建用户，安装anaconda 主要是容器中为root用户，有时候文件夹映射后在主机访问文件总要修改权限比较麻烦，可以不添加用户，但是基础软件可以按需安装
# 在容器中 #添加dl用户 useradd -ms /bin/bash dl # 设置dl的密码 passwd dl New password: Retype new password: passwd: password updated successfully # 修改/home/dl文件夹权限 chmod -R o+wrx /home/dl # 安装一些基础软件 apt-get update apt-get install vim apt-get install sudo # 给dl赋予sudo权限 chmod +wrx /etc/sudoers vi /etc/sudoers # 在root下面加dl 所有权，抄root的 #切换到dl用户 su dl sudo apt-get install wget sudo apt-get install git # 下载anaconda，也可以提前下载好拷贝到容器里 cd /home/dl/ wget https://repo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2482096560855c51402200de57870bab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed42778a9e3665cbc413070816134fdf/" rel="bookmark">
			ubuntu20.04下nvidia驱动安装，docker/nvidia-docker安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、驱动安装1.安装驱动2.（可选）cuda安装 二、nvidia-docker安装1.docker安装2.nvidia-docker安装 三、用户添加到docker组四、设置是否随docker重启容器自动重启 前言 由于现在深度学习各个开源库对cuda/cudnn/pytorch等环境要求各不相同，所以很多时候采用docker方式部署不同的深度学习框架，本文主要记录ubuntu20.04下驱动安装、docker/nvidia-docker安装，修改docker容器等data的存储路径、ubuntu下的用户加入到docker组里等
一、驱动安装 1.安装驱动 切换root用户，关闭图像界面， 禁用第三方显卡驱动
# 切换root用户 sudo su # 关闭图像界面 systemctl set-default multi-user.target systemctl get-default # 禁用第三方显卡驱动 vim /etc/modprobe.d/blacklist.conf最后添加 blacklist nouveau options nouveau modeset=0 #更新内核 update-initramfs -u # 系统重启 reboot 重新进入系统后
sudo su # 安装驱动 chmod +x ./NVIDIA-Linux-x86_64-460.106.00.run ./NVIDIA-Linux-x86_64-460.106.00.run --no-opengl-files # NO-&gt;一路回车 # 校验是否安装成功 nvidia-smi # 将驱动模式设置为常住内存： nvidia-smi -pm 1 2.（可选）cuda安装 chmod +x cuda-10.0.run ./cuda-10.0.run --no-opengl-libs # 依次执accept -&gt; no -&gt; yes -&gt; 默认 -&gt; yes -&gt; no 二、nvidia-docker安装 从这里下载安装包，存放到docker-ubuntu-20.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed42778a9e3665cbc413070816134fdf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/187da5f44c703113bda0fa45840ffb91/" rel="bookmark">
			[官方精简母盘WIM]_Windows11_23H2_22631.3007
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [官方精简母盘WIM]_Windows11_23H2_22631.3007 【原汁原味】不过多阐述了哈，谁用谁知道😉😉😉 zh-cn_windows_11_business_editions_version_23h2_updated_jan_2024_x64_dvd_fee59269.ISO 链接：https://pan.baidu.com/s/18_ImKnp17sASTDRia8AlJw?pwd=77xv 提取码：77xv 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d5570c7b0cf409069e9d56e5a9bdbe8/" rel="bookmark">
			关于rocketmq与rocketmq-mqtt之间的acl控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 因业务需求需要在rocketmq中整合mqtt，期间遇到了许多问题，在此处记录
一、安装rocketmq和rocket-mqtt并能正常测试 具体参考rocketmq使用mqtt协议_rocketmq mqtt-CSDN博客
如果按照该博客流程走，是可以正常生产和订阅的，其中补充遇到的几点坑
1. mqtt并不会自动创建索引，所以autoCreateTopicEnable属性不会生效，需要手动创建，会报如图所示的错误
2. 如果遇到了只能生产不能消费，有以下几种可能
2.1 未创建通配符列表(topic命名为mqtttest，rocketmq地址为192.168.5.251:9876为例)
配置通配符列表 sh mqadmin updateKvConfig -s LMQ -k mqtttest -v mqtttest/+ -n 192.168.5.251:9876 2.2 如果还是不能生效且是rocetmq生产，mqtt消费情景，有可能是子topic未设置(以子topic命名为task为例，用rocketmq消费断点可以看见，两种方式生产的数据差异在于properties中属性的不同，特别是mqtt生产中多出的INNER_MULTI_DISPATCH属性)
具体两者差异如下
#mqtt生产者 properties={CONSUME_START_TIME=1706501170642, MSG_REGION=DefaultRegion, UNIQ_KEY=C0A80510BC640EED1F1492CA922D0BBA, CLUSTER=DefaultCluster, INNER_MULTI_QUEUE_OFFSET=560,383, MIN_OFFSET=0, qosLevel=1, TAGS=MQTT_COMMON, TRACE_ON=true, originMqttTopic=mqtttest/task, INNER_MULTI_DISPATCH=%LMQ%mqtttest%+%,%LMQ%mqtttest%task%, IS_EMPTY_MSG=false, retryTimes=0, extData={"qosLevel":"1"}, MAX_OFFSET=191} #rocketmq生产者 properties={CONSUME_START_TIME=1706509718866, MSG_REGION=DefaultRegion, UNIQ_KEY=C0A80C9A833873D16E93934D554F0009, CLUSTER=DefaultCluster, MIN_OFFSET=0, TAGS=task, WAIT=true, TRACE_ON=true, MAX_OFFSET=235} 具体代码参考rocketmq-mqtt源码中的RocketMQProducer
生产者关键代码：
static void sendMsg(DefaultMQProducer producer, String topic, String tag) throws Exception { byte[] bytes = ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d5570c7b0cf409069e9d56e5a9bdbe8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85dd01dce58e2aa383782ee86674e2e1/" rel="bookmark">
			ubuntu18.04 安装anaconda
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1,安装
1.1 anaconda，版本：python3.7
Windows(win7,win10) ，Anaconda3-2020.02-Windows-x86_64.exe
ubuntu (Linux) x64，Anaconda3-2020.02-Linux-x86_64.sh
Mac OS，Anaconda3-2020.02-MacOSX-x86_64.pkg
1.2 minianaconda, 地址
2，配置conda源
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes Linux系统设置，conda环境设置，国内conda源
编辑.condarc文件 Linux操作系统 vim ~/.condarc channels: - defaults show_channel_urls: true channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 2.1 conda环境配置指令
conda env list # conda列表 conda clean -i # 更新conda源 source activate myenv # 激活环境 source deactivate # 退出虚拟环境 conda create --name myenv python=3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85dd01dce58e2aa383782ee86674e2e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2844f089cfb263c55cd16cb903c2b514/" rel="bookmark">
			Type-C协议-CC检测原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Type-C连接器中有两个管脚CC1和CC2，他们用于识别连接器的插入方向，以及不同的插入设备。本文介绍CC的基本识别原理。
先介绍几个概念：
DFP——Downstream Facing Port，也就是Host
UFP——Upstream Facing Port，也就是Device
DRP——Dual Role port，既可以做DFP，也可以做UFP。
在建立连接之前，DRP的角色在DFP和UPF之间切换。如果两个DRP连接，最先随机到那种角色后开始建立连接，之后可以通过USB协议协商进行动态切换。
USB Type-C插座和插头的两排管脚对称，USB数据信号都有两组重复的通道，但主控芯片通常只有一组TX/RX和D+/-通道（某些芯片有两组TX/RX和D+/-通道）。
由于USB2.0的数据率最高只有480Mbps, 可以不考虑信号走线的阻抗连续性，USB2.0的D+/-信号可以不被MUX控制而直接从主控芯片走线，然后一分二连接至USB Type-C插座的两组D+/-管脚上。
但USB3.0或者USB3.1的数据率高达5Gbps或者10Gbps，如果信号线还是被简单地一分二的话，不连续的信号线阻抗将严重破坏数据传输质量，因此必须由MUX切换来保证信号路径阻抗的一致性，以确保信号传输质量。
下图中右侧所示的MUX从TX1/RX1和TX2/RX2中选择一路连接至主控芯片，而这个MUX就必须被CC管脚控制。
在USB2.0应用中，无需考虑CC方向检测问题，但USB3.0或者USB3.1应用中，必须考虑CC方向检测问题。
注意UFP，比如U盘，移动硬盘内部不需要CC逻辑检测，因为它是上行，只有一对USB2.0或USB3.0信号，如下图
3 CC检测原理 CC信号有两根线，CC1和CC2，大部分USB线（不带芯片的线缆）里面只有一根CC线，DFP可根据两根CC线上的电压，判断是否已经插入设备。通过判断哪根CC线上有下拉电阻来判断方向，下图的说明已经非常清晰。
如果CC1引脚检测到有效的Rp/Rd连接（对应的电压），则认为电缆连接未翻转。
如果CC2引脚检测到有效的Rp/Rd连接（对应的电压），则认为电缆连接已翻转。
“有效的Rp/Rd连接”指在CC上形成了有效的电压。
从DFP的角度看，下表列出了所有可能的连接状态，
以上只是介绍了CC检测中判断是否翻转的原理，两个CC信号还有向UPF通告DFP提供电流能力的功能等，见下文
3.1 DFP的上拉电阻Rp DFP的CC1和CC2信号上都必须有上拉电阻Rp，上拉到5V或3.3V。或者CC1和CC2都用电流源上拉。最终的目的是在插入后，能检测到CC1或CC2上的电压，进而判断是否翻转以及DFP的电流能力。如下是所有可能的配置。可以选择右边三列中的任何一列作为上拉方式，比如Fairchild的FUSB300就是用330uA上拉，TI的TUSB320LAI用的是80uA的上拉，不同的上拉方式在CC引脚上形成的电压不同，不同的电压对应不同的电流能力。
3.2 UPF的Rd UFP的CC1和CC2管脚都要有一个下拉电阻Rd到GND（或者使用电压钳位）。Rd的处理方式如下表。
注意，最后一列的电流源连接至的电压，是指3.1节中表格的最后一列电流源的上拉电压。
结合这个表格，和3.1节的表格，我们把每种可能的上下拉范围都计算出了最终形成的电压范围，如下表。
CC检测芯片会检测这个电压，通过判断电压范围来决定下一步操作。下表是CC管脚上不同的电压对应的DFP能提供的电流能力。第二列列出的每一种电压范围，都分别覆盖了上表计算出的电压。Rp/Ra的计算是同理的。
3.3 数据线上的Ra 带电子标签的线缆，其中一个CC管脚被更名为VCONN，用于给电子标签芯片供电。这个VCONN管脚与GND之间需要一个Ra电阻，这个电阻值范围是800Ω~1.2KΩ。
3.4 VCONN电源 VCONN的允许范围是4.75V~5.5V，要求供电能力是1W。默认情况下DFP提供这个电源。如果两个DRP连接，则双方可以通过USB PD协议协商来交换VCONN供电方。
支持PD的USB3.0接口均需支持VCONN，可以通过下面两种方式之一提供VCONN电源。
如果其中一个CC引脚上检测到有效的Rp/Rd连接，则VCONN电源可以接到另一个对应的CC引脚。如果其中一个CC引脚上检测到有效的Rp/Rd连接，先检查另一个CC引脚是否也有Rp/Ra连接，然后再提供VCONN。先检测是否有Ra存在，如果有说明需要Vconn供电，此时再提供Vconn。检测过程不需要Vconn存在。
注意，每一个CC引脚内部都有一个开关，轮训CC和VCONN功能，下图是一个典型的连接方式： 4 手机都是DRP 现实中，我们的手机都是DRP，既能做DFP，又能做UFP，那么是如何切换呢？
DRP在待机模式下每50ms在DFP和UFP间切换一次。当切换至DFP时，CC管脚上必须有一个上拉至VBUS的电阻Rp或者输出一个电流源，当切换至UFP时，CC管脚上必须有一个下拉至GND的电阻Rd。此切换动作必须由CC Logic芯片来完成。当DFP检测到UFP插入之后才可以输出VBUS，当UFP拔出以后必须关闭VBUS。此动作必须由CC Logic芯片来完成。下面是一个CC逻辑芯片框图，CC上有一个开关，在不断切换功能。
USB Power Delivery 2.0
这个是由USB-IF制定的单线协议，在CC线上传输，用于协商供电角色，电压，最大供电能力，数据角色，备用模式等，端口与供电电缆之间的通信业通过PD协议进行。协议不做展开，详见USB-IF官网。下面是协议的几个特点：
所有通信均通过CC线。
DFP是总线主设备，用于发起所有通信。
所有消息均采用32bit 4b/5b编码的双向标记编码（Bi-phase Mark Coded，BMC）
300K波特率
CRC32错误检验+消息重试
Type-C线缆规范
线缆至少支持10000次拔插。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2844f089cfb263c55cd16cb903c2b514/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ddfdf33bf6ad88af73e5f6fc0b1a7ff/" rel="bookmark">
			想用免费chat GPT？这里有你的答案（副链接）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.导语 大家好，我是一名第一次发博客的小作者。
众所周知，chat GPT是一个由OpenAI发布的一个可以跟人类对话的AI，这个AI不仅可以帮你制定旅行计划，还可以帮你画画，但是这个chat GPT还要收钱，那本期我来推荐两个我个人觉得好用的两个AI。
二.百度AI（文心一言） 百度AI是一个由百度制作的一个AI助手，chat GPT能做的事它大部分也能做，而且这里面还可以体验各种类型的AI，比如简历助手、PPT制作什么的，都可以，还能在手机上使用。
链接：搜索AI伙伴https://chat.baidu.com/
三.chat8 这个AI也是我在上编程课的时候听后桌说的，跟百度AI一个用处，都可以聊天、做旅行计划什么什么的，而且种类丰富，虽然chat4需要收费，但是可以差不多无限次使用chat3.5，没有像其他厂商一样只给你使用几次，但是这个目前只能在电脑上使用。
链接：Chat8永久地址 地址发布页https://x.chat838.com/
四.结尾 这里只是我个人觉得喜欢的AI，其实还有很多AI ，比如微软发布的copilot，这些可以看个人的爱好来选择你喜欢的AI。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/68/">«</a>
	<span class="pagination__item pagination__item--current">69/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/70/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>