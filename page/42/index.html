<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4426d9bd81ff104a246f47036746f5f/" rel="bookmark">
			路由算法与路由协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由选择协议的核心是路由算法，即需要何种算法来获得路由表中的各个项目。
路由算法的目的很简单：给定一组路由器以及连接路由器的链路，路由算法要找到一条从源路由器到目标路由器的最佳路径。通常，最佳路径是指具有最低费用的路径。
1，静态路由与动态路由
常用的动态路由算法可以分为两类：距离-向量路由算法和链路状态路由算法。
分层次的路由选择协议：
互联网采用的是自适应的、分布式路由选择协议。因为互联网的规模非常大，许多联网的单位不愿意让外界了解自己单位网络的布局细节，所以互联网采用分层次的路由选择协议。
为此，可以把整个互联网划分为需要较小的自治系统，自治系统还在单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同的度量。一个AS对其他AS表现出的是一个单一的和一只的路由选择策略。
因此，这样护理啊王就把路由选择协议划分为两大类。
1.内部网关协议，
内部网关协议，就是在一个自治系统内部使用的路由选择协议，它与在互联网中的其他自治系统选用什么路由选择协议无关。目前这列路由选择协议使用的最多，如RIP和OSPF。
2.外部网关协议，
如果源主机和目的主机处在不同大哥自治系统中，则当数据报传到一个自治系统大哥边界的时候，就需要一种协议将路由选择信息传递到另一个自治系统中。这样的洗衣你，就是外部网关协议，目前使用最多的外部网关协议是BGP-4。
自治系统之间的路由选择，也称为域间路由选择，自治系统内部的路由选择也称为域内路由选择。
路由信息协议，RIP，routing information protocl，是内部网关协议IGP中最先得到广泛使用的协议，RIP是一种分布式的基于距离向量的路由选择协议。
RIP的规定，
1，网络中的每个路由器都要维护从它自身到其他每个目的网络的距离记录，即距离向量。
2，RIP使用跳数，来衡量到达目的网络的距离。规定从一个路由器直接连接的网络的距离定义为1，而每经过一个路由器距离就加1.
3，RIP认为好的路由就是他通过的路由器的数目少，即距离短或者跳数少。
RIP的特点，
1，和谁交换信息，仅和直接相邻的路由器交换信息。
2，交换什么信息，交换的信息是本路由器所知道的全部信息，即自己的路由表。
3，何时交换信息，（1）按固定的时间间隔交换路由信息，（2）当网络拓扑发生变化的时候， 路由器也及时的向相邻的路由器通告拓扑变化后的路由信息。
路由器刚开始工作的时候，只知道自己到相邻的几个网络的距离为1。每个路由器仅仅和相邻路由器周期行的交换并更新路由信息。经过若干次交换和更新后，所有的路由器最终都会知道到达本自治系统内任何网络的最短距离和下一跳路由器的地址，被称为收敛。
RIP是应用层协议，他使用UDP来传送数据，RIP选择的路径不一定是时间最短的，但是一定是路由的跳数最少的，因为他是根据路由的跳数来选择路径的。
OSPF，开放最短路径优先协议，
开放最短路径优先协议，是使用分布式链路状态路由算法的典型代表，也是内部网关协议的一种，OSPF与RIP相比，有如下四点的主要区别：
1，OSPF，想本自治系统中所有路由器发送信息。这里使用的方法是泛洪法，而RIP仅仅🤔自己相邻的几个路由器发送信息。
2，发送的信息是与本路由器相邻的所有路由器的链路状态，但是知识路由器所知道的部分信息。在RIP中，发送的信息是本路由器所知道的全部信息，即整个路由表。
3，只有当链路状态发生变化的时候，路由器才是永红犯法向所有的路由器发送次信息，并且更新过程熟练的很快，不会出现RIP坏消息传的慢的情况。而在RIP中，不管是网络拓扑是否发生变化，路由器之间都要定期的交换路由表的信息。
4，OSPF是网络层的协议，他不适用UDP或者TCP，而直接使用IP数据包传送，RIP是应用层的协议，在传输层使用UDP。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f2ba33f84fb809a1b82e7983c8f93ee/" rel="bookmark">
			6.S081的Lab学习——Lab1: Xv6 and Unix utilities
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、启动xv6(难度：Easy)解析： 二、sleep(难度：Easy)解析： 三、pingpong（难度：Easy）解析： 四、Primes(素数，难度：Moderate/Hard)解析： 五、find（难度：Moderate）解析： 六、xargs（难度：Moderate）解析： 总结 前言 一个本硕双非的小菜鸡，备战24年秋招。打算尝试6.S081，将它的Lab逐一实现，并记录期间心酸历程。
代码下载
官方网站：6.S081官方网站
安装方式：
通过 APT 安装 （Debian/Ubuntu）
确保你的 debian 版本运行的是 “bullseye” 或 “sid”（在 ubuntu 上，这可以通过运行 cat /etc/debian_version 来检查），然后运行：
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu （“buster”上的 QEMU 版本太旧了，所以你必须单独获取。
qemu-system-misc 修复
此时此刻，似乎软件包 qemu-system-misc 收到了一个更新，该更新破坏了它与我们内核的兼容性。如果运行 make qemu 并且脚本在 qemu-system-riscv64 -machine virt -bios none -kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img，if=none，format=raw，id=x0 -device virtio-blk-device，drive=x0，bus=virtio-mmio-bus.0 之后出现挂起
，
则需要卸载该软件包并安装旧版本：
$ sudo apt-get remove qemu-system-misc $ sudo apt-get install qemu-system-misc=1:4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f2ba33f84fb809a1b82e7983c8f93ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a4e5206da3d5c9cfe2eee3802da6595/" rel="bookmark">
			深入理解Java中的线程安全List：CopyOnWriteArrayList原理和应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 心中有诗画，指尖舞代码，目光览世界，步履越千山，人间尽值得 ! 在Java并发编程中，线程安全的数据结构是至关重要的。其中，CopyOnWriteArrayList是一个线程安全的ArrayList实现，它提供了在并发环境下对列表进行读写的功能。本文将深入探讨CopyOnWriteArrayList的工作原理、使用场景以及潜在的性能问题。
目录 1️⃣ 什么是CopyOnWrite（写时复制）2️⃣什么是CopyOnWriteArrayList3️⃣CopyOnWriteArrayList的工作原理3.1 读写分离的设计模式的几个优点3.2 存在的性能问题 3️⃣CopyOnWriteArrayList使用场景4️⃣CopyOnWriteArrayList的应用5️⃣总结 1️⃣ 什么是CopyOnWrite（写时复制） CopyOnWrite，也被称为写时复制（Copy-On-Write，简称COW），是程序设计领域中的一种优化策略。这种策略的核心思想是，当多个调用者（或线程）同时访问同一份资源时，他们会共同获取一个指向该资源的指针。只要没有调用者尝试修改这份资源，所有的调用者都可以继续访问同一个资源。但是，一旦有调用者尝试修改资源，系统就会复制一份该资源的副本给这个调用者，而其他调用者所见到的仍然是原来的资源。这个过程对其他的调用者都是透明的，他们并不知道资源已经被复制。
在Java中，CopyOnWriteArrayList和CopyOnWriteArraySet就是使用了这种策略的两个类。这两个类都位于java.util.concurrent包下，是线程安全的集合类。当需要修改集合中的元素时，它们不会直接在原集合上进行修改，而是复制一份新的集合，然后在新的集合上进行修改。修改完成后，再将指向原集合的引用指向新的集合。这种设计使得读操作可以在不加锁的情况下进行，从而提高了并发性能。
总的来说，CopyOnWrite是一种适用于读多写少场景的优化策略，它通过复制数据的方式实现了读写分离，提高了并发性能。但是，它也存在一些潜在的性能问题，如内存占用增加、写操作性能下降以及频繁的垃圾回收。因此，在使用时需要根据具体场景进行权衡和选择。
2️⃣什么是CopyOnWriteArrayList CopyOnWriteArrayList是Java并发包java.util.concurrent中的一个类，它实现了List接口。如其名所示，
CopyOnWriteArrayList是Java中的一个类，位于java.util.concurrent包下。它是ArrayList的一个线程安全的变体，其中所有可变操作（如add和set等）都是通过创建底层数组的新副本来实现的，因此被称为“写时复制”的列表。
由于CopyOnWriteArrayList在遍历时不会对列表进行任何修改，因此它绝对不会抛出ConcurrentModificationException的异常。它在修改操作（如add、set等）时，会复制一份底层数组，然后在新的数组上进行修改，修改完成后再将指向底层数组的引用切换到新的数组。这种设计使得读操作可以在不加锁的情况下进行，从而提高了并发性能，这个特性使得它在多线程环境下进行遍历操作时更为安全。
然而，CopyOnWriteArrayList并没有“扩容”的概念。每次写操作（如add或remove）都需要复制一个全新的数组，这在写操作较为频繁时可能会导致性能问题，因为复制整个数组的操作是相当耗时的。因此，在使用CopyOnWriteArrayList时，需要特别注意其适用场景，一般来说，它更适合于读多写少的场景。
3️⃣CopyOnWriteArrayList的工作原理 CopyOnWriteArrayList是ArrayList的一个线程安全的变体。读操作可以在不加锁的情况下进行，从而提高了并发性能。
具体来说，CopyOnWriteArrayList内部有一个可重入锁（ReentrantLock）来保证线程安全，但这个锁只在写操作时才会被使用。当进行修改操作时，线程会先获取锁，然后复制底层数组，并在新数组上执行修改。修改完成后，通过volatile关键字修饰的引用来确保新的数组对所有线程可见。由于读操作不需要获取锁，因此多个线程可以同时进行读操作，而不会相互干扰。
3.1 读写分离的设计模式的几个优点 读操作性能很高 由于读操作不需要获取锁，因此多个线程可以同时进行读操作，而不会相互干扰。这使得在高并发场景下，CopyOnWriteArrayList的读操作性能非常出色。
数据一致性 由于写操作是通过复制底层数组并在新数组上执行修改来实现的，因此不会出现多个线程同时修改同一个元素的情况。这保证了数据的一致性。
适用于读多写少的场景 由于写操作需要复制整个底层数组，因此在写操作较为频繁的场景下，CopyOnWriteArrayList的性能可能会受到较大影响。但在读多写少的场景下，它可以充分发挥其优势。
3.2 存在的性能问题 内存占用 每次写操作都需要复制整个底层数组，这会导致内存占用增加。特别是在列表较大时，这种内存开销可能会变得非常显著。
写操作性能下降 由于每次写操作都需要复制整个数组，并在新数组上执行修改，因此写操作的性能可能会受到较大影响。特别是在高并发场景下，这种性能下降可能会更加明显。
频繁的垃圾回收 由于写操作会创建新的数组，因此可能导致频繁的垃圾回收。这可能会对系统的整体性能产生影响。
总的来说，CopyOnWriteArrayList是一种适用于读多写少场景的线程安全列表实现。它通过复制底层数组的方式实现了读写分离，提高了读操作的并发性能。但在使用时需要根据具体场景进行权衡和选择，以避免潜在的性能问题。
3️⃣CopyOnWriteArrayList使用场景 CopyOnWriteArrayList适用于读多写少的场景。在这种场景下，由于读操作不需要获取锁，因此可以充分发挥多核CPU的并行计算能力，提高系统的吞吐量。然而，在写操作较为频繁的场景下，CopyOnWriteArrayList的性能可能会受到较大影响。
4️⃣CopyOnWriteArrayList的应用 下面是一个使用CopyOnWriteArrayList的代码，它模拟了一个简单的新闻发布系统。在这个系统中，多个线程可以并发地添加新闻和读取新闻列表。由于读操作远多于写操作，因此使用CopyOnWriteArrayList是合适的。
import java.util.List; import java.util.concurrent.CopyOnWriteArrayList; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; // 新闻类 class News { private String title; private String content; public News(String title, String content) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a4e5206da3d5c9cfe2eee3802da6595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14387c7e7e2436d4b31f2f3323daaa28/" rel="bookmark">
			js常用工具jjychengtoolsbox；获取URL参数,获取Cookie,设置Cookie, 时间万能转换-兼容IE,截取字符串,过滤全部html,生成随机数,检查是否手机端访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		js常用工具jjychengtoolsbox;获取URL参数,获取Cookie,设置Cookie, 时间万能转换-兼容IE,截取字符串,过滤全部html,生成随机数,检查是否手机端访问
npm 项目地址：https://www.npmjs.com/package/jjychengtoolsbox?activeTab=readme
jjychengtoolsbox 介绍 “获取URL参数”,
“获取Cookie”,
“设置Cookie”,
“时间万能转换-兼容IE”,
“截取字符串”,
“过滤全部html”,
“生成随机数”,
“检查是否手机端访问”
作者 “author”: “JJY.Cheng”，
“blogUrl”:https://cplvfx.blog.csdn.net/"
使用演示 安装 npm i jjychengtoolsbox 引入 import jjychengtoolsbox from 'jjychengtoolsbox'; 使用 根据名称获取URL参数 jjychengtoolsbox.GetQueryStringFun('参数名称') 获取Cookie jjychengtoolsbox.getCookieFun('名称') 设置Cookie jjychengtoolsbox.setCookieFun('名称') 时间万能转换-兼容IE jjychengtoolsbox.DateTimeConvertFun('时间字符串','格式') // 格式如下： // 'yyyy/mm/dd hh:mm' // 'yyyy/mm/dd' // 'yyyy-mm-dd hh:mm' // 'yyyy-mm-dd' // 'yyyy年mm月dd日' 截取字符串 jjychengtoolsbox.SliceTxtFun('字符串','截取长度（数字）') 过滤全部html标签 jjychengtoolsbox.FilterHtmlFun('字符串') 生成随机数 jjychengtoolsbox.RandomNumberFun('起始数字','结束数字') 检查是否手机端访问 jjychengtoolsbox.IsMobileFun() //如果是手机访问，返回true,否则false 完整演示 js import jjychengtoolsbox from 'jjychengtoolsbox'; export default { name: 'App', components: { HelloWorld }, data(){ return { jjyT:{}, FilterHtml:'', } }, created(){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14387c7e7e2436d4b31f2f3323daaa28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11904f2310260b04549fecbba34fe50d/" rel="bookmark">
			淘宝购物数据分析（桑吉图制作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import pandas as pd import numpy as np import pandas as pd import matplotlib as mpl from matplotlib import pyplot as plt import seaborn as sns import warnings import matplotlib.dates as mdates from pyecharts import options as opts from pyecharts.charts import Funnel from pyecharts.faker import Faker from datetime import timedelta from pyecharts.globals import CurrentConfig, OnlineHostType from pyecharts import options as opts # 图形设置 from pyecharts.charts import Sankey # 导入桑基图型的类 from pyecharts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11904f2310260b04549fecbba34fe50d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566848563d1b2628af549f3f108b7d93/" rel="bookmark">
			Mysql8 如何在 Window11系统下完成跳过密钥校验、完成数据库密码的修改？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我 | 在这里
✈️公众号 | 热爱技术的小郑 。文章底部有个人公众号二维码。回复 Java全套视频教程 或 前端全套视频教程 即可获取 300G+ 教程资料及项目实战案例
🚀 邮箱 | 2977429967@qq.com
前言 Window 11系统安装5.7 版本的mysql会报错。安装8版本的则可以、在安装8版本的过程中，初始化生成的密钥没有效果。只能先跳过密钥校验、不像mysql 5.7 在配置文件中添加一行密码校验跳过就行。需要通过命令行的形式打开mysql、然后进行操作。具体步骤看后续：
过程 1、关闭mysql服务，用管理员命令窗口。否则会报如下错误
2、开启跳过密码验证登录的MySQL服务
控制台输入这个命令行
mysqld --console --skip-grant-tables --shared-memory 出现如图提示
3、再打开一个管理员命令窗口
输入登录命令，然后回车即可登录
mysql -u root -p 4、进入到mysql登录界面后，输入命令
use mysql; update user set password=password('你的密码') where user='root' and host='localhost'; flush privileges; quit; 提示：如果执行update sql语句报错。就用flush privileges; 刷新一下、然后使用 ALTER USER 'root'@'localhost' IDENTIFIED BY '密码' 的方式修改数据库密码。
5、可视化工具连接操作
使用可视化数据库操作工具，测试连接。
参考资料 数据库安装教程：Windows下安装MYSQL数据库（详细图解过程）
这里的文章写的目的，就是mysql8 在window11系统下，导入初始化密钥失败的后续解决方法。mysql5.7 安装暂时没遇到问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3916342f879069cfb6ec925cbd4bb2ea/" rel="bookmark">
			hadoop报错：HADOOP_HOME and hadoop.home.dir are unset. 解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：https://blog.csdn.net/weixin_45735242/article/details/120579387
解决方法
1.下载apache-hadoop-3.1.0-winutils-master
官网下载地址：
https://github.com/s911415/apache-hadoop-3.1.0-winutils
win配置系统环境：
然后重启idea!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6886a105e08140c45530dbf93c6cb915/" rel="bookmark">
			pl/sql savepoint的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		保存点(savepoint)是事务处理过程中的一个标志，和回滚命令(rollback)结合使用，主要的用途是允许用户将某一段处理回滚而不必回滚整个事务，这在pl/sql研发中还是非常有用处的。
下面的例子中，把savepoint标记在insert语句之前，如果这条insert语句试图将重复的数据保存到emp表中的话，将触发执行预先定义的dup_val_on_index例外处理，在这里面的rollback to do_insert命令将回滚上面的那条insert操作，而不会影响前面的所有操作。
declare
emp_id emp.empno%type;
begin
update emp set ... where empno = emp_id;
delete from emp where ...
...
savepoint do_insert;
insert into emp values (emp_id, ...);
exception
when dup_val_on_index then
rollback to do_insert;
end;
如果你定义了多个savepoint，当你指定回滚到某个savepoint时，那么回滚操作将回滚这个savepoint后面的所有操作（即使后面可能标记了n个savepoint）。例如，在一段处理中
你定义了五个savepoint，从第三个savepoint回滚，后面的第四、第五个标记的操作都将被回滚，如果不使用rollback to savepoint_name而使用rollback，将会滚整个事务处理。
如果你在递归子程式里面定义了一个savepoint, 如果每一个递归层都设置了savepoint. 此时, 你只能回滚到最近的一个savepoint.
savepoint的声明能在同一个事务处理里面重复定义. 他的作用就是把savepoint从上一个位置转移到目前的位置. 因而，执行回滚也只回滚到最近的savepoint.
下面是个例子:
begin
...
savepoint my_point;
update emp set ... where empno = emp_id;
...
savepoint my_point; -- move my_point to current point
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6886a105e08140c45530dbf93c6cb915/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e2e6c463f172351e77f7bbacb48472/" rel="bookmark">
			##天气预报爬虫 项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//主要功能 #include "head.h" #include "cJSON.h" void FunWeather(void); void RecvSendWeather(void); int RealTimeWeather(void); int CreateTcpClient(char *p,int port); int SendHttpRequest(int sockfd,char *q); void RecvSendWeather(void); char city[256] = {0}; int sockfd = 0; typedef struct media { int id; char menulist[512];//菜单名字的长度 }MEDIA_CFG_S; typedef struct menuinfo { int id; int pos_start; int pos_end; int focus; }MENU_CFG_S; MEDIA_CFG_S medialist[32]= { {1,"选择城市"}, {2,"实时天气"}, {3,"未来天气"}, {4,"历史天气"}, {5,"退出"}, }; int pos_start=0;	//界面起始位置 int pos_end = 4;	//界面结束位置 int focus;	//界面焦点位置 void PrintfMenu(void) { int i =0; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62e2e6c463f172351e77f7bbacb48472/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae7fc5f6c8e9a8ab6b444900623154fe/" rel="bookmark">
			spring boot单元测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring Boot单元测试是测试Spring Boot应用程序中的单个组件、类或方法的测试方法。它可以帮助开发人员验证代码的正确性并提供即时反馈和可靠的结果。
下面是一些常用的Spring Boot单元测试的方法和技巧：
使用JUnit：Spring Boot单元测试通常与JUnit测试框架一起使用。JUnit提供了一组用于编写和执行单元测试的注解和断言方法。
使用@SpringBootTest：@SpringBootTest注解用于启动整个Spring Boot应用程序上下文，并提供各种配置选项。它可以帮助您在测试中访问应用程序的各个部分，包括服务、存储库和控制器。
使用@MockBean：@MockBean注解用于模拟一个或多个依赖项，以便在测试中隔离其他组件的影响。它可以用于模拟数据库访问、外部服务调用等。
使用@Test注解：@Test注解用于标记一个测试方法。可以使用它来运行单个测试用例并验证其预期结果。可以使用不同的断言方法来检查结果是否与预期相匹配。
使用@TestConfiguration：@TestConfiguration注解用于在测试中提供自定义的配置类。它可以用于模拟和替代实际的配置类，以便更好地控制测试环境。
使用@AutoConfigureTestDatabase：@AutoConfigureTestDatabase注解用于自动配置测试数据库。它可以帮助您轻松地在测试中使用不同的数据库配置，并确保测试数据的安全性和一致性。
除了上述方法，还有其他一些技巧和工具可以用于Spring Boot单元测试，如使用Mockito进行模拟和验证，使用Spring Test来模拟和集成测试等。建议参考Spring Boot官方文档和在线教程，了解更多有关Spring Boot单元测试的详细信息。
单元测试是用于测试软件中最小可测试单位的测试方法。在Spring Boot中，可以使用JUnit和Mockito等框架来进行单元测试。
首先，确保在项目的pom.xml文件中已经引入了JUnit和Mockito的依赖。
接下来，创建一个测试类，并添加@Test注解以标识该方法为测试方法。
在测试方法中，可以使用Mockito来模拟依赖的外部组件，以便进行测试。
例如，假设有一个名为UserService的服务类，其中有一个方法getUserById用于根据用户ID获取用户信息。可以编写以下单元测试用例来测试该方法：
import static org.mockito.Mockito.when; @RunWith(MockitoJUnitRunner.class) public class UserServiceTest { @Mock private UserRepository userRepository; @InjectMocks private UserService userService; @Test public void testGetUserById() { User user = new User("1", "John Doe"); when(userRepository.getUserById("1")).thenReturn(user); User result = userService.getUserById("1"); assertEquals("1", result.getId()); assertEquals("John Doe", result.getName()); } } 在上述示例中，使用@Mock注解来模拟UserRepository，使用@InjectMocks注解将模拟的UserRepository注入到UserService中。
然后，在测试方法中使用Mockito的when方法来设置当调用getUserById方法时，返回预设的用户对象。
最后，使用断言方法assertEquals来验证实际结果与预期结果是否相等。
通过以上的单元测试，可以验证UserService的getUserById方法是否按预期工作。
最后，运行该单元测试，并确保所有的测试用例都通过。可以使用集成开发环境（IDE）的单元测试运行功能或者使用命令行工具进行运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35a4a90bb7d0057668c72cdd2eb90b88/" rel="bookmark">
			面试如何介绍MVCC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MVCC（多版本并发控制）是一种并发控制机制，用于在数据库中实现高效的并发读取操作。它的基本思想是为每个数据记录维护多个版本，允许并发事务在不相互阻塞的情况下读取不同版本的数据。
在 MVCC 中，每个事务都有自己的视图，该视图展示了数据在某个特定时刻的状态。当事务读取数据时，它看到的是数据的一个版本，而不是实际的最新版本。这意味着读操作不会被写操作阻塞，提高了系统的并发性能。
MVCC 通常通过以下几个关键技术来实现：
版本号：每个数据记录都有一个版本号，用于标识不同的版本。读视图：每个事务都有一个读视图，记录了该事务可见的版本范围。写操作：写操作会创建新的版本，并更新相关记录的版本号。冲突检测：在写操作时，通过比较版本号来检测是否存在冲突。 MVCC 的优点包括：
提高并发性能：读操作不需要加锁，避免了读锁的阻塞，提高了系统的整体并发性能。避免脏读：通过维护版本号和读视图，MVCC 可以确保读操作不会读取到未提交的写入数据，避免了脏读问题。支持并发写：MVCC 允许多个事务同时进行写操作，通过版本管理和冲突检测来保证数据的一致性。 在面试中介绍 MVCC 时，可以强调其核心思想、实现方式和优点。同时，可以结合具体的数据库系统（如 MySQL 的 InnoDB 引擎）来解释 MVCC 的工作原理和应用场景。此外，还可以提及一些与 MVCC 相关的概念，如幻读、串行化隔离级别等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/350e059994502c88562e3a0b38ce32c1/" rel="bookmark">
			android HAL层崩溃排查记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要最近在调试系统HDMI CEC功能时，遇到一个奇怪的崩溃问题，这边记录下。
初步分析 先上日志：
--------- beginning of crash 03-06 10:48:25.503 1133 1133 F DEBUG : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** 03-06 10:48:25.503 1133 1133 F DEBUG : Build fingerprint: ':13/TD1A.220804.031/3582:userdebug/release-keys' 03-06 10:48:25.503 1133 1133 F DEBUG : Revision: '0' 03-06 10:48:25.503 1133 1133 F DEBUG : ABI: 'arm64' 03-06 10:48:25.503 1133 1133 F DEBUG : Timestamp: 2024-03-06 10:48:25.490260378-0500 03-06 10:48:25.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/350e059994502c88562e3a0b38ce32c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e89e24d3e41d4e7092020440343ee65/" rel="bookmark">
			Android adb 使用手册，机顶盒开发必看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 调试桥 (adb) 是一种功能多样的命令行工具，可让您与设备进行通信。adb 命令可用于执行各种设备操作，例如安装和调试应用。adb 提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：
客户端：用于发送命令。客户端在开发机器上运行。您可以通过发出 adb 命令从命令行终端调用客户端。
守护程序 (adbd) ：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。
服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。
adb 包含在 Android SDK 平台工具软件包中。您可以使用 SDK 管理器下载此软件包，该管理器会将其安装在 android_sdk/platform-tools/ 下。如果您需要独立的 Android SDK 平台工具软件包，请点击此处进行下载。
adb是Android SDK里的一个工具, 用这个工具可以直接操作管理android模拟器或者真实的android设备。
adb 的工作原理 当您启动某个 adb 客户端时，该客户端会先检查是否有 adb 服务器进程已在运行。如果没有，它会启动服务器进程。服务器在启动后会与本地 TCP 端口 5037 绑定，并监听 adb 客户端发出的命令。
注意：所有 adb 客户端均使用端口 5037 与 adb 服务器通信。
然后，服务器会与所有正在运行的设备建立连接。它通过扫描 5555 到 5585 之间（该范围供前 16 个模拟器使用）的奇数号端口查找模拟器。服务器一旦发现 adb 守护程序 (adbd)，便会与相应的端口建立连接。
每个模拟器都使用一对按顺序排列的端口：一个用于控制台连接的偶数号端口，另一个用于 adb 连接的奇数号端口。例如：
模拟器 1，控制台：5554
模拟器 1，adb：5555
模拟器 2，控制台：5556
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e89e24d3e41d4e7092020440343ee65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e74d835ade25507b8dac6861b00439bb/" rel="bookmark">
			外卖平台订餐流程架构的实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们想要在外卖平台上订餐时，背后其实涉及到复杂的技术架构和流程设计。本文将就外卖平台订餐流程的架构进行介绍，并探讨其中涉及的关键技术和流程。
## 第一步：用户端体验
用户通过手机应用或网页访问外卖平台，浏览菜单、选择餐厅和菜品，并下单订餐。这一过程需要一个直观友好的用户界面，以及快速、稳定的响应速度。在这一阶段，关键的技术包括：
- **移动应用开发**：为了提供良好的用户体验，外卖平台需要开发高质量的移动应用程序，支持各种手机型号和操作系统。
- **前端技术**：采用响应式网页设计和优化的前端技术，确保在不同设备上都能够流畅显示和操作。
## 第二步：订单处理与管理
一旦用户下单，订单信息需要传递给后台系统进行处理。这包括订单的接收、确认、派送等流程。关键的技术和流程包括：
- **后台系统**：订单管理系统需要能够高效处理大量订单，同时保证订单的准确性和安全性。
- **实时通讯**：外卖平台需要实现与餐馆和配送员的实时通讯，以便确认订单、安排取餐和派送食物。
## 第三步：支付和结算
完成订单后，用户需要进行支付。外卖平台通常支持多种支付方式，包括在线支付、货到付款等。支付和结算涉及到支付网关、第三方支付平台等技术：
- **支付网关**：确保支付安全和可靠性，同时支持多种支付渠道和货币类型。
- **结算系统**：用于与餐厅和配送员进行结算，管理资金流动和账务。
## 第四步：配送和跟踪
最后一步是食物的配送和跟踪。外卖平台需要实时追踪订单状态，并为用户提供配送进度的实时信息：
- **地理位置服务**：利用GPS等技术，跟踪配送员的实时位置，为用户提供准确的配送时间和路线信息。
- **用户反馈与评价**：用户收到食物后，可以对配送员和餐厅进行评价，这需要一个可靠的反馈系统。
以上就是外卖平台订餐流程的架构和关键技术。通过这些技术和流程的支持，外卖平台得以提供便捷、高效的订餐服务，满足用户的需求和期望。随着科技的不断发展，外卖平台的订餐流程也在不断演进，为用户带来更加便利的体验。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d9747b559e988f7e443c18b6ce5b2f6/" rel="bookmark">
			【Java】获取手机文件名称补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本地的 ADB 工具路径指的是你电脑上安装的 Android Debug Bridge（ADB）工具的路径。ADB 是 Android SDK 中的一个工具，用于与连接到计算机上的 Android 设备进行通信。你需要确保 ADB 已正确安装，并知道其在你计算机上的位置。
通常，ADB 工具的路径可能是类似于以下路径的地方：
在 Windows 上：C:\Users\YourUsername\AppData\Local\Android\Sdk\platform-tools\adb.exe（请将 YourUsername 替换为你的用户名） 在 macOS 或 Linux 上：/Users/YourUsername/Android/Sdk/platform-tools/adb（请将 YourUsername 替换为你的用户名） 请查看你的 Android SDK 安装位置，找到 platform-tools 文件夹，然后找到其中的 adb 或 adb.exe 文件。将这个路径设置为你的 Java 代码中的 adbPath。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8f08f17a8b4b385d2888ad619f86d84/" rel="bookmark">
			【Java】读取手机文件名称
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，确保你已经连接了你的手机并已启用 USB 调试模式。然后，你需要使用 Android Debug Bridge（ADB）工具来获取手机文件列表。以下是一个简单的 Java 代码片段，使用 ProcessBuilder 调用 ADB 命令来获取文件列表：
import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.List; public class ADBFileLister { public static void main(String[] args) { String adbPath = "path/to/adb"; // 替换为你的 adb 路径 String deviceID = "your_device_id"; // 如果只连接了一个设备，可以为 null // Android 文件路径 String androidPath = "/storage/emulated/0/BaiduNetdisk/我的学习"; List&lt;String&gt; fileList = listFiles(adbPath, deviceID, androidPath); // 打印文件列表 for (String file : fileList) { System.out.println(file); } } private static List&lt;String&gt; listFiles(String adbPath, String deviceID, String androidPath) { List&lt;String&gt; fileList = new ArrayList&lt;&gt;(); // 构建 ADB 命令 List&lt;String&gt; command = new ArrayList&lt;&gt;(); command.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8f08f17a8b4b385d2888ad619f86d84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc0c750c5ea0802a17f75b82d3d9b077/" rel="bookmark">
			【机器学习】机器学习是什么？用在哪里？怎么用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.机器学习是什么？ 机器学习（Machine Learning）是人工智能的一个分支，它是一种通过对数据进行训练和学习，让计算机系统从中获取知识并改善性能的方法。简而言之，机器学习使计算机具有从数据中学习并自动改进的能力，而无需显式地进行编程。
2.机器学习用在哪里？ 机器学习可以应用于各种领域，包括但不限于：
1. 预测和分类：如股票价格预测、邮件分类等。
2. 聚类和分割：将数据分成不同的群组或类别。
3. 强化学习：使计算机代理程序学会在一个环境中通过试错来达到某个目标。
4. 生成模型：生成新的数据，如图像、音频等。
3.机器学习怎么使用？ 要使用机器学习，通常需要以下步骤：
1. 数据收集：收集并准备用于训练的数据。
2. 数据预处理：清洗、转换和处理数据，以便于算法学习。
3. 选择模型：选择适合问题的机器学习模型，如决策树、神经网络等。
4. 模型训练：使用训练数据训练模型，使其能够学习数据之间的模式。
5. 模型评估：评估模型的性能并调整参数以提高准确度。
6. 模型部署：将训练好的模型应用于实际场景中，进行预测或分类等任务。
在实际应用中，可以使用各种机器学习框架和库，如TensorFlow、PyTorch、Scikit-learn等来实现机器学习模型的开发和部署。这些工具提供了丰富的算法和函数，简化了机器学习的过程。
4.机器学习生活中经典案例 机器学习在日常生活中有许多经典案例，以下是一些常见的应用：
1. 推荐系统：网上购物平台（如亚马逊、淘宝）和视频流媒体服务（如Netflix、YouTube）利用机器学习算法来分析用户的历史行为和偏好，从而推荐用户可能感兴趣的产品或内容。
2. 语音助手：智能语音助手（如Siri、Alexa、小爱同学）利用自然语言处理和语音识别技术，通过机器学习来理解用户的指令并提供相应的服务。
3. 图像识别：社交媒体平台（如Facebook、Instagram）和智能相册应用利用机器学习算法进行人脸识别、物体识别等，帮助用户管理照片和视频。
4. 医疗诊断：医疗影像领域使用机器学习技术进行疾病诊断，如基于MRI或X光图像的肿瘤检测和分类。
5. 金融风控：银行和金融机构利用机器学习算法进行信用评分和欺诈检测，帮助降低风险和提高效率。
6. 自动驾驶：无人驾驶汽车利用机器学习算法来感知环境、规划路径和做出决策，以实现自动驾驶功能。
7. 舆情分析：媒体和企业利用机器学习对海量的社交媒体数据和新闻报道进行情感分析和舆情监控，了解公众对某些话题或事件的看法和态度。
这些都是机器学习在日常生活中的经典案例，展示了机器学习在各个领域的广泛应用和重要作用。希望这些例子能给您一个更清晰的了解！如果您对特定领域或案例有更深入的疑问，请随时告诉我。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7239dd12eca6a4ad9854a85fb2567593/" rel="bookmark">
			基于javaweb&#43;mysql的ssm&#43;maven医院挂号管理系统(java&#43;ssm&#43;jsp&#43;js&#43;jquery&#43;layui&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的ssm+maven医院挂号管理系统(java+ssm+jsp+js+jquery+layui+mysql)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于javaweb的SSM+Maven医院挂号管理系统(java+ssm+jsp+js+jquery+layui+mysql)
管理员 admin	123456 用户 用户1	123456 用户2	123456 用户3	123456 用户4	123456 用户5	123456 用户6	123456 医生 医生1	123456 医生2	123456 医生3	123456 医生4	123456 医生5	123456 医生6	123456 项目介绍
基于SSM的医院挂号系统
角色：管理员、用户、医生
管理员：管理员、个人中心、公告信息管理、用户管理、、室信息管理、医生管理、预约时间段管理、出诊信息管理、在线预约管理、上班打卡管理、留言板管理、系统管理。
用户: 个人中心、在线预约管理、我的收藏管理
医生：个人中心、出诊信息管理、在线预约管理、上班打卡管理
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。 2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA; 3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可 4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 5.是否Maven项目: 是；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目; 6.数据库：MySql 5.7/8.0等版本均可；
技术栈
后端：SSM(Spring+SpringMVC+Mybatis)
前端：JSP+CSS+JS+JQUERY+Layui
使用说明
使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件； 2. 使用IDEA/Eclipse/MyEclipse导入项目，修改配置，运行项目； 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7239dd12eca6a4ad9854a85fb2567593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b3332e7ab5f9fb5c112153b924a3fc4/" rel="bookmark">
			基于javaweb&#43;mysql的springboot医院挂号管理系统(java&#43;springboot&#43;vue&#43;elementui&#43;layui&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的springboot医院挂号管理系统(java+springboot+vue+elementui+layui+mysql)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Node.js≥10
开发工具
后端：eclipse/idea/myeclipse/sts等均可配置运行
前端：WebStorm/VSCode/HBuilderX等均可
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于javaweb的SpringBoot医院挂号管理系统(java+springboot+vue+elementui+layui+mysql)
项目介绍
基于SpringBoot Vue的医院信管系统
角色：管理员、用户、医生
管理员：首页、个人中心、用户管理、医生管理、科室管理、医生信息管理、挂号信息管理、取消挂号管理、问诊记录管理、病房管理、药房管理、管理员管理等
用户：首页、医生信息、医院情况、个人中心、后台管理、在线容服、预约挂号等
医生：个人中心首页、挂号信息管理、取消挂号管理、问诊记录管理等
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。 2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA; 3.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 4.数据库：MySql 5.7/8.0版本均可； 5.是否Maven项目：是；
技术栈
后端：SpringBoot+Mybaits
前端：layui+Vue+ELementUI
使用说明
项目运行： 1. 使用Navicat或者其它工具，在mysql中创建对应sql文件名称的数据库，并导入项目的sql文件； 2. 使用IDEA/Eclipse/MyEclipse导入项目，导入成功后请执行maven clean;maven install命令，然后运行； 3. 将项目中application.yml配置文件中的数据库配置改为自己的配置; 4. 运行项目，控制台提示运行成功后再去运行前端项目； 5. 管理员用户名密码：admin/admin 普通用户名密码：user/123456
文档介绍(功能需求分析、系统设计规则与运行环境、系统流程分析、操作流程、添加信息流程、删除信息流程、系统设计、系统设计主要功能、数据库设计、数据库设计规范、ER图、数据表、系统实现、系统功能模块、管理员功能模块、医生功能模块、系统测试、功能测试、可用性测试、维护测试、性能测试、测试结果分析)：
医院管理系统首页详情介绍:
医院概况详情介绍:
医生信息详情介绍:
个人中心详情介绍:
后台管理登录详情介绍:
医院后台管理系统：首页、个人中心、用户管理、医生管理、科室管理、医生信息管理、医生信息、挂号信息管理、取消挂号管理、问诊记录管理、病房管理、药房管理、管理员管理、系统管理
挂号信息详情介绍:
@RequestMapping(value="updatePwd") public String updatePwd(@RequestParam(value="Pwd") String Pwd,@RequestParam(value="aNumber") String aNumber,@RequestParam(value="Name") String name){ Administor administor = new Administor(aNumber, name, Pwd); administorService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b3332e7ab5f9fb5c112153b924a3fc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12f35b7245c2589b0c66d323bcdb6369/" rel="bookmark">
			基于javaweb&#43;mysql的ssm医院在线预约挂号系统(java&#43;ssm&#43;jsp&#43;bootstrap&#43;layui&#43;echarts&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的ssm医院在线预约挂号系统(java+ssm+jsp+bootstrap+layui+echarts+mysql)
私信源码获取及调试交流
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于javaweb的SSM医院在线预约挂号系统(java+ssm+jsp+bootstrap+layui+echarts+mysql)
管理员 admin	123456 用户 user1 123456 user2 123456 医生 13600000001	123456	外科 13600000002	123456	神经科 13600000003	123456	骨科 ssm医院在线预约挂号系统
角色：管理员、用户、医生
管理员登录后，主要功能有：首页、用户列表、添加用户、科室列表、新增科室、医生列表、新增医生信息、公告列表、新增公告、系统设置、数据统计等功能。
用户主要功能包括：首页、我的信息、科室列表、医生列表、门诊预约列表、门诊预约、公告列表、数据统计等功能。
医生主要功能包括：首页、科室列表、我的个人信息、我的门诊预约列表、公告列表、数据统计等功能；
由于本程序规模不大，可供课程设计，毕业设计学习演示之用
后端：SSM(Spring+SpringMVC+Mybatis)
前端：JSP+css+javascript+Bootstrap+layUI+echarts
@RestController public class DepartmentController { @Autowired DepartmentService service; @Autowired UserService userService; @RequestMapping("/DepartmentList") public ModelAndView DepartmentList( @RequestParam(defaultValue="1") Integer currentPage,HttpServletRequest request, Map&lt;String,Object&gt; map){ User user = (User)request.getSession().getAttribute("user"); String DepartmentName = request.getParameter("key"); List&lt;Department&gt; list = new ArrayList&lt;&gt;(); Map&lt;String,Object&gt; maps = new HashMap&lt;&gt;(); maps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12f35b7245c2589b0c66d323bcdb6369/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/41/">«</a>
	<span class="pagination__item pagination__item--current">42/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/43/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>