<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76f4caae27298092869f0d82723f6489/" rel="bookmark">
			主动学习论文复现（xPAL）：Toward optimal probabilistic active learning using a Bayesian approach - 2021 ML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文献： 【1】 Kottke D, Herde M, Sandrock C, et al. Toward optimal probabilistic active learning using a Bayesian approach[J]. Machine Learning, 2021, 110(6): 1199-1231.
BibTex： @article{kottke2021toward, title={Toward optimal probabilistic active learning using a Bayesian approach}, author={Kottke, Daniel and Herde, Marek and Sandrock, Christoph and Huseljic, Denis and Krempl, Georg and Sick, Bernhard}, journal={Machine Learning}, volume={110}, number={6}, pages={1199--1231}, year={2021}, publisher={Springer} } 评论： 非常优秀的一篇文章，这篇论文是Kottke继McPAL之后的又一篇基于概率的主动学习方法。
读懂这篇论文需要有一定的统计学基础。读不懂的宝子们莫要灰心。
原理： 基本原理，通过选择一个valuable样本，来达到模型期望误分类风险的下降。
用Kottke的意思是，利用共轭先验来计算得到是的期望概率收益（Expected Probabilistic Gain）最大的样本。
代码： https://download.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/76f4caae27298092869f0d82723f6489/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40c3fb14934db296e37c32a74ffd519f/" rel="bookmark">
			Python操作串口通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python操作串口通信 注意Linux下先要修改串口的权限：
sudo chmod 777 /dev/ttyUSB0
以下是python代码：
# coding=utf-8 # 包：pyserial，pymysql # 权限：sudo chmod 777 /dev/ttyUSB0 import serial # import pymysql import threading import time # x=serial.Serial('COM3',9600) # winsows系统使用com3口连接串行口 # x=serial.Serial("/dev/ttyUSB0",9600,timeout=0.5) # 使用USB连接串行口 x=serial.Serial("/dev/ttyS4",9600,timeout=0.5) # Linux系统使用com4口连接串行口 def fasong():#发送函数 while True: time.sleep(3) myinput= bytes([0x01,0X03,0X00,0X00,0X00,0X01,0X84,0X0A]) #这是我要发送的命令，原本命令是：01 03 00 00 00 01 84 0A x.write(myinput) def jieshou():#接收函数 while True: while x.inWaiting()&gt;0: myout=x.read(7)#读取串口传过来的字节流，这里我根据文档只接收7个字节的数据 datas =''.join(map(lambda x:('/x' if len(hex(x))&gt;=4 else '/x0')+hex(x)[2:],myout))#将数据转成十六进制的形式 new_datas = datas.split("/x")#将字符串分割，拼接下标4和5部分的数据 need = new_datas[4]+new_datas[5];#need是拼接出来的数据，比如：001a my_need = int(hex(int(need,16)),16)#将十六进制转化为十进制 sql = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40c3fb14934db296e37c32a74ffd519f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5cafa0d0dcd96277a8ea336eb5411d9/" rel="bookmark">
			毕设项目：在线校园报修系统(JSP&#43;java&#43;springmvc&#43;mysql&#43;MyBatis)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本项目包含程序+源码+数据库+LW+调试部署环境，文末可获取一份本项目的java源码和数据库参考。
项目文件图 项目介绍 随着互联网技术的快速发展，越来越多的学校开始使用在线校园报修系统来管理校园设施的维修和保养。这种系统可以帮助学校更好地掌握设施的使用情况，及时发现问题并进行处理，提高设施的使用寿命和效率。同时，它还能够方便学生和教职工提交报修请求，减少等待时间和不必要的沟通成本。因此，本课题旨在设计并实现一个高效、易用的在线校园报修系统，以提高学校的设施管理水平和服务质量
以上介绍只是对这个选题的介绍内容，具体功能和技术以下面列的技术和界面为准
项目配置环境 项目运行环境 1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。
2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐eclipse;
3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可,推荐Tomcat7.0
4.硬件环境：windows 7/8/10 4G内存以上；或者 Mac OS；
5.是否Maven项目: 否；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目
6.数据库：MySql 5.7/8.0等版本均可；
项目技术 jsp + mybatis + Maven +mysql5.7或8.0+html+css+js等等组成，B/S模式 + Maven管理等等。
用户发送请求：用户通过浏览器或其他客户端向系统发送请求，请求访问特定的页面或执行特定的操作。
前端处理：前端使用JSP技术生成动态的Web页面，将页面展示给用户。用户可以在页面上进行交互，例如填写表单、点击按钮等。
请求传递到后端：用户的请求被传递到后端Java程序。后端程序接收到请求后，根据请求的类型和参数进行相应的处理。
后端业务逻辑处理：后端程序使用Java语言开发，根据业务需求进行相应的业务逻辑处理。这包括数据的处理、计算、验证等操作。
数据库交互：与数据库进行交互，后端程序使用SSM框架中的MyBatis组件来执行数据库操作。它可以通过SQL语句或者对象映射的方式来操作MySQL数据库。
数据返回给前端：后端程序处理完业务逻辑后，将结果数据返回给前端。可以是生成的HTML页面、JSON数据等形式。
前端展示结果：前端接收到后端返回的数据，根据需要进行展示。可以是渲染页面、显示提示信息等。
项目界面图 文末源码分享与获取↓↓↓↓ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88cfb019f38ae739dc1ee1b9b5f9d8ab/" rel="bookmark">
			C语言中i&#43;&#43;；&#43;&#43;i； i--； --i以及&#43;=；-=的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，可能会遇到很多内容相似，表达结果却完全不同的操作符，如题目所言，接下来我讲给大家解释这四种单目操作符及两种赋值操作符的区别。
“+”号在前，就先加1，而后赋值；“+”号在后，就自己加1，但不赋值。
如果记不住，可以这样想：
“+”号在前，被赋值者“看到”了i进行了“+1”操作，那么i在进行“+1”操作的同时，就要给被赋值者也“+1”；“+”号在后，被赋值者“看不到”i进行了“+1”操作，那么i就可以只给自己“+1”，不用给被赋值者也“+1”；
赋值操作符中，“a += b”相当于“a = a + b"；“a -= b”相当于“a = a - b"；
例题如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802cffa333b1c7b2521f1ac3c9703348/" rel="bookmark">
			2023年下半年和2024年上半年EI国际学术会议推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【IEEE CPS出版】2023年人工智能与自动化控制国际学术会议（AIAC 2023）
2023年10月27-29日 | 中国-厦门
主办单位：黑龙江工程学院
征稿主题：1、人工智能（机器学习、自然语言处理与理解、神经网络与深度学习、计算机视觉等）
2、控制科学工程（新兴技术建模和仿真、自动化和诊断、智能系统控制等）
——邀请码填H8053，会议秘书直接联系——
【IEEE出版|Ei稳定检索】第三届电子信息工程与计算机技术国际学术会议（EIECT 2023）
2023年11月17 - 19日 | 中国 深圳
征稿主题：计算机技术：数值分析、逻辑编程、机器学习等
电子信息工程：第六代移动通信技术（6G）、GPS与无线定位、人工智能与神经网络等
会议出版：会议论文集将由IEEE出版，并提交EI核心和Scopus检索，ISBN号：979-8-3503-5770-7。
【知网检索】第二届旅游管理与产业经济国际学术会议(TMIE 2023)
2023年11月3-5日 | 中国 · 西双版纳
出版信息：TMIE 2023所有录用的论文将由SHS Web of Conferences (ISSN: 2261-2424)出版，见刊后将提交至CPCI、CNKI等数据库检索。
【SPIE出版】第三届信号处理与通信技术国际学术会议（SPCT 2023）
2023年12月1-3日 中国-青岛
征稿主题：信号处理（雷达信号处理，图像信号处理等）；通信技术（模拟电子技术，电子线路综合设计等）；大数据（机器学习，软件开发，JAVA编程等）。
第四届消费电子与计算机工程国际学术会议 (ICCECE 2024)
2024年1月12-14日 广州
征稿主题：消费电子发展与应用、计算机与网络信息安全、人工智能与机器学习、物联网与传感器技术等
——邀请码填H8053，会议秘书直接联系——
第六届下一代数据驱动网络国际学术会议 (NGDN 2024)
2024年4月26-28日 | 中国沈阳
征稿主题：数据驱动的移动计算及无线通讯、安全和隐私、物联网（IoT）及大数据、大数据助力电信运营（客户维护/增值服务等）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba2232de59df8cd51285bd6aa40ad1c7/" rel="bookmark">
			TypeScript 断言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TypeScript 中的类型断言（Type Assertion）允许开发者明确告诉编译器一个值的类型，即使编译器无法确定。类型断言有两种语法形式：尖括号语法和as语法。它们可以在需要时用于处理类型不明确的情况。
1. 尖括号语法：
这里，value 的类型被明确指定为 any，但我们知道它是一个字符串。使用类型断言，我们告诉编译器将 value 视为字符串，并可以访问字符串的属性和方法。
2. as 语法：
as 语法是在 TypeScript 中更常用的方式，因为它与 JSX 不会发生冲突，更加一致。
类型断言的使用场景包括：
将一个更通用的类型断言为更具体的类型，以访问更具体类型的属性和方法。处理从动态数据源（如 API 调用或用户输入）返回的数据，其中编译器无法准确推断类型。在使用第三方库时，库可能未提供类型声明，可以使用类型断言来明确告诉编译器变量的类型。 需要注意的是，过度使用类型断言可能导致代码中出现类型错误，因此应谨慎使用。最好的实践是尽量避免使用类型断言，而是使用更明确的类型定义和类型推断来编写类型安全的代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a8f2e77ba43d3b42d3fa9f1df34e0b9/" rel="bookmark">
			PTrade获取财务数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PTrade提供了获取财务数据函数get_fundamentals，可以用于获取财务三大报表数据、日频估值数据、各项财务能力指标数据，数据源为恒生。
示例 先来看一个展示使用get_fundamentals函数获取财务数据的例子：
def initialize(context): g.security = ['600900.SS', '601877.SS'] def before_trading_start(context, data): data = get_fundamentals(security=g.security, table='growth_ability', fields=['operating_revenue_grow_rate', 'net_profit_grow_rate'], date=get_trading_day().strftime('%Y%m%d') ) log.info(data) def handle_data(context, data): passdef initialize(context): g.security = ['600900.SS', '601877.SS'] def before_trading_start(context, data): data = get_fundamentals(security=g.security, table='growth_ability', fields=['operating_revenue_grow_rate', 'net_profit_grow_rate'], date=get_trading_day().strftime('%Y%m%d')) log.info(data) def handle_data(context, data): pass 我们在这里尝试查询两只标的（‘600900.SS’, ‘601877.SS’）的财务数据，在表growth_ability（成长能力指标）中查询他们的operating_revenue_grow_rate（营业收入同比增长%）和net_profit_grow_rate（净利润同比增长%）两个指标。PTrade里设置回测时间为2023-05-05，输出结果为：
2023-05-05 08:30:00 - INFO - publ_date end_date operating_revenue_grow_rate \ secu_code 600900.SS 2023-04-28 2023-03-31 25.1657 601877.SS 2023-04-29 2023-03-31 47.3708 net_profit_grow_rate secu_abbr secu_code 600900.SS 18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a8f2e77ba43d3b42d3fa9f1df34e0b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2ee718bafa1a335ddfd109f03546468/" rel="bookmark">
			西储大学轴承监测数据集及数据集分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据集简介
振动数据来源于美国凯斯西储大学的开发数据集。轴承试验装置的示意图如图1-1所示。平台组成：
一个1.5KW（2马力）的电动机（图左侧）；
一个扭矩传感器/ 译码器（图中间连接处）；
一个功率测试计（图右侧）；
驱动端轴承为SKF6205 ，采样频率为12Khz和48Khz；
电子控制器(图中没显示) 。
DE - drive end accelerometer data 驱动端加速度数据；
FE - fan end accelerometer data 风扇端加速度数据；
BA - base accelerometer data 基座加速度数据（正常）；
time - time series data 时间序列数据；
RPM- rpm during testing 转每分钟，除以60为旋转频率；
B -滚动体故障；IR – 内圈故障；OR –外圈故障；
驱动端和风扇端轴承外圈的损伤点分别放置在3点钟、6点钟、12点钟三个不同位置。
数据文件为Matlab格式。每个文件包含风扇和驱动端振动数据，以及电机转速。
例子：12k_Fan_End_OR007@6_3_297.mat 12k：12KHZ采样频率
Fan_End_OR：风扇端外圈故障
007：直径
@6：外圈的损伤点在6点钟位置
3：表电机载荷模式
297：编号。
数据集由
12kHz采样率下电机端轴承的故障数据（DE）60个、
12kHz采样率下风扇端轴承的故障数据（FE）45个、
48kHz采样率下电机端轴承的故障数据（DE）52个，
还有正常运转的轴承数据4个组成。
图1-2 12k驱动端故障数据列表
2.数据集下载
3.python 训练及验证数据集制作代码.
from scipy.io import loadmat import numpy as np import os from sklearn import preprocessing # 0-1编码 from sklearn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2ee718bafa1a335ddfd109f03546468/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5f2ef2c3f3b44c817eb2fc506a38e6d/" rel="bookmark">
			报错ImportError: libffi.so.8: cannot open shared object file: No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ImportError: libffi.so.8: cannot open shared object file: No such file or directory
python版本问题，高或者低都有可能，这种情况最好重新安装了，从头开始
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98681a6606abcacd4f6eddda594ea7c1/" rel="bookmark">
			论文复现：Active Learning by Learning
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇文章说实在的，写的差强人意。
实质性内容是两个现有方法的拼凑！
讲的模模糊糊！对于复现代码不太友好！
撸一点，通读一遍 ，再撸一点，通读一遍~~~
""" 注意：使用了训练集索引。 """ import xlwt import xlrd import numpy as np import pandas as pd from pathlib import Path from copy import deepcopy from sklearn.preprocessing import StandardScaler from time import time from sklearn.metrics.pairwise import pairwise_distances from numpy.linalg import inv from sklearn.metrics import accuracy_score, mean_absolute_error, f1_score, mutual_info_score from sklearn.neighbors import NearestNeighbors np.seterr(divide='ignore',invalid='ignore') class AL_ALBL(): def __init__(self,X, y, labeled, budget, X_test, y_test): self.X = X self.y = y self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98681a6606abcacd4f6eddda594ea7c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ceed77be7ea904937457edc5cd6089d/" rel="bookmark">
			TypeScript 的基本类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TypeScript 提供了丰富的基本数据类型，让开发者能够更精确地定义变量和函数参数的类型。以下是 TypeScript 的基本类型：
布尔类型（boolean）：表示逻辑值，只能取 true 或 false。
数字类型（number）：表示数值，包括整数和浮点数。
字符串类型（string）：表示文本数据。
数组类型（array）：表示一组值的有序集合。可以使用数组泛型 Array&lt;ElementType&gt; 来指定元素类型。
元组类型（tuple）：表示一个固定长度和类型的数组。每个元素的类型在元组中是已知的。
枚举类型（enum）：用于表示一组有名字的常量，通常是整数值的集合。
任意类型（any）：表示变量的类型可以是任何类型，类似于普通 JavaScript。
空类型（void）：通常用于表示函数没有返回值。
Null 和 Undefined 类型：分别表示 null 和 undefined 值。
Never 类型：表示永远不会有返回值的函数。
对象类型（object）：表示非原始数据类型，即除 number、string、boolean、symbol、null、或 undefined 之外的类型。
这些基本类型可以组合和嵌套，以创建更复杂的数据结构和类型定义，帮助开发者在编写 TypeScript 代码时更准确地捕获错误并提高代码质量。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97edd7d27de3f6510e49c80443005ee9/" rel="bookmark">
			Excel VBA&#43;MATLAB 求数独？？？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仅用0.1秒解决一个问题，无疑是非常快速和高效的。该方法需要一定的Excel VBA和MATLAB知识，但通过Excel VBA和MATLAB的连接，即使是没有编程经验的小白也能够迅速解决问题，这真正打破了知识屏障，使问题的求解变得简单而直观。
从Excel VBA的编程语言中连接Matlab是可以在Excel输入数据，直接通过 VBA宏将这些数据导入Matlab中，再通过Matlab优化箱进行求解。
Excel VBA可否解决数独问题，有什么优缺点
优点：
1. 简单易用：Excel VBA是一种相对易学和易用的编程语言，无需深入的编程背景，就可以使用Excel VBA来解决数独问题。
2. 强大的电子表格功能：Excel VBA提供了丰富的电子表格功能，可以轻松地输入、编辑和处理数独问题的数据。可以利用Excel的功能和工具来导入、转换和处理数据，如将文本文件导入Excel、快速修改或复制数据等。
3. 可视化展示：Excel VBA可以将数独问题的求解过程和结果以图表、表格等形式可视化展示，便于理解和分享。
4. 数据交互：Excel VBA可以与Excel表格紧密地集成，方便将数据从Excel导入到VBA中进行计算，并将结果再次导入到Excel中，实现数据的交互。
缺点：
1. 效率相对较低：相对于使用专门的编程语言和算法，利用Excel VBA解决数独问题可能会比较慢。Excel的电子表格计算速度有一定的限制，并且VBA的执行效率可能较低。
2. 资源消耗：由于Excel VBA需要在Excel环境中运行，可能会占用较大的系统资源。特别是在处理较大规模的数独问题时，可能会导致Excel运行缓慢甚至崩溃。
3. 灵活性受限：相比专门的编程语言和算法，Excel VBA的灵活性可能较低。在处理复杂的数独问题时，VBA的功能和工具可能相对有限，无法灵活地适应各种求解策略。
综上所述，Excel VBA可以解决数独问题，并且具有一些优点，如简单易用、强大的电子表格功能和可视化展示。然而，需要注意的是，使用Excel VBA解决数独问题可能会面临一些缺点，如相对较低的效率、资源消耗较大和灵活性受限。因此，根据具体情况和需求，可以权衡利弊，选择合适的解决方案。
Matlab能否解决数独问题，有什么优缺点
优点：
1. 强大的数值计算和矩阵操作能力：MATLAB作为一种专门的数学计算软件，具有强大的数值计算和矩阵操作能力，适合处理数独问题的求解过程中的复杂计算和矩阵操作。
2. 丰富的函数库和工具箱：MATLAB提供了丰富的函数库和工具箱，包括线性代数、优化、逻辑推理等方面的工具和算法，这些功能可以方便地应用于数独问题的求解。
3. 灵活性和定制性：使用MATLAB可以编写自定义的算法和函数来解决数独问题，具有较高的灵活性和定制性。可以根据问题的特点和要求，进行算法优化和改进。
4. 可视化展示：MATLAB提供了丰富的绘图和可视化函数，可以将数独问题的求解过程和结果以图表、图像等形式直观地展示出来，便于理解和分享。
缺点：
1. 学习成本相对较高：相对于一些简单的编程语言，MATLAB的学习成本可能较高。需要掌握MATLAB的语法、函数等基本知识，并理解和应用相关的数学和算法概念。
2. 许可限制和成本：MATLAB是一款商业软件，使用需要购买相应的许可证。对于个人或小规模项目，可能需要考虑成本和许可限制的问题。
3. 适用范围局限：MATLAB主要针对数学计算和科学工程应用，对于其他类型的问题可能不太适用。如果只是解决简单的数独问题，可能存在过度使用MATLAB的问题。
综上所述，MATLAB可以解决数独问题，并且具有一些优点，如强大的数值计算和矩阵操作能力、丰富的函数库和工具箱、灵活性和定制性，以及可视化展示功能。然而，需要注意的是，使用MATLAB解决数独问题可能需要一定的学习成本，而且可能受到许可限制和成本问题。此外，要考虑问题的复杂程度和需求，避免过度使用MATLAB。根据具体情况和需求，可以综合评估优缺点，选择合适的解决方案。
Excel VBA和MATLAB结合解决数独
Excel VBA和MATLAB结合解决数独问题是一种高效和灵活的方法，但在问题求解的过程中，还有其他一些方面也值得我们关注和探讨。
1. 算法选择和优化：数独问题可以使用多种算法进行求解，例如回溯算法、深度优先搜索、约束满足问题等。在利用Excel VBA和MATLAB解决数独问题时，我们可以根据问题的复杂程度和要求选择合适的算法，并对算法进行优化和改进，以提高求解效率和准确性。
2. 数独问题的建模和规则：数独问题可以通过数学建模来描述和求解。在使用Excel VBA和MATLAB解决数独问题时，我们可以将数独问题转化为数学模型，并利用线性规划、整数规划等数学工具进行求解。这样可以更好地理解数独问题的规则和限制，并设计更合理的求解策略。
3. 可视化和交互性：除了将结果输出到Excel中进行可视化展示外，我们还可以考虑其他形式的结果展示和交互方式。例如，可以利用MATLAB的图形界面工具，设计一个交互式数独求解器，让用户可以直接输入和修改数独问题，并实时观察求解过程和结果。
4. 扩展应用和问题：除了求解数独问题，利用Excel VBA和MATLAB的组合还可以解决其他类型的数独变种或类似的逻辑问题。考虑如何将已有的数独求解方法进行扩展和推广，以适应更广泛的问题类别和应用场景。
5. 效率和优化：使用Excel VBA和MATLAB解决数独问题的效率是如何的？是否还有其他方法和工具可以进一步提高求解速度和效率？这些都是我们可以继续探索和优化的方向。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97edd7d27de3f6510e49c80443005ee9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7affb007b05e156f8cb5c3377d71b11b/" rel="bookmark">
			Excel VBA&#43;Matlab解决大型运输问题 太牛了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		观看此文章的大家一定对Excel或者是Matlab都有一定的了解。
大家应该都知道，Excel是一款可以解决线性规划问题的工具，它也可以用于求解运输问题。然而，Excel的线性规划功能在约束数量上有限制，最多只能处理200个约束。而在实际的运输问题中，约束的数量往往超过了这个限制。
为了应对这个问题，许多人选择使用Python、Matlab或Lingo等编程语言来进行数学优化问题的求解。这些编程语言不受数据和约束数量的限制，因此非常适合处理复杂的运输问题。
但是，这些编程语言对于数字输入和导出处理并不方便。为了解决这个问题，我们可以将Excel与这些编程语言连接起来，从而既能在Excel中方便地输入和修改数据，又可以通过Python、Matlab或Lingo来进行求解。
这个连接可以通过编写宏来实现。通过调用编程语言的函数，我们可以将Excel中的数据传递给编程语言进行求解，然后将结果传递回Excel进行展示或进一步分析。这样，我们就可以在Excel的界面上方便地操作和控制数学优化问题的求解过程。
这种方法结合了Excel的易用性和Python、Matlab、Lingo等编程语言的强大计算能力，使得处理运输问题变得更加灵活和高效。
Excel VBA+Matlab解决大型运输问题
通过对Excel vba和Matlab的了解，我们做到了可以通过Excel输入数据之后，在Excel里边一键求解。
彻底实现了在Excel输入数据，一键求解运输问题，即使是纯小白用户也能轻松使用，且求解过程不超过一秒。
Excel VBA与MATLAB的连接和数据交互：
1. 确保已在计算机上安装了MATLAB软件。这样才能在Excel VBA中引用MATLAB的相关库和函数。
2. 添加MATLAB库引用。
3. 创建MATLAB对象，即创建所需要运行的函数。
4. 使用VBA宏从Excel中导入数据到MATLAB。可以将Excel数据存储在数组或矩阵中，并将其传递给MATLAB的工作空间。
5. 使用VBA宏执行MATLAB的代码。可以通过调用MATLAB的工作空间和函数来实现与MATLAB的交互。
6. 将计算结果从MATLAB导出到Excel中。可以将结果存储在VBA的变量中，并将其写入到Excel的单元格中。
通过这些步骤，可以在Excel VBA中使用宏来实现与MATLAB之间的数据交互和运算。将数据从Excel导入MATLAB，进行MATLAB代码的执行和计算，并将结果导出到Excel中，实现了Excel和MATLAB之间的集成和互操作性。将Excel VBA与MATLAB结合，可以发挥两个工具的优势，提高数独问题的求解效率和灵活性。
如果大家有想要利用Excel VBA和MATLAB的组合求解的问题，可以评论区大家沟通交流学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3022e098cc47eae2e3e6049401de240f/" rel="bookmark">
			人工智能的基础.pdf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天给大家带来的这本书电子数据是：人工智能的基础。需要的左侧我的工众号回复：“人工智能基础” 即可获取数据下载。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e77c7777d3f0976611f74d0bea3f95e/" rel="bookmark">
			基于Python实现的神经网络分类MNIST数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		神经网络分类MNIST数据集
目录
神经网络分类MNIST数据集 1
一 、问题背景 1
1.1 神经网络简介 1
前馈神经网络模型： 1
1.2 MINST 数据说明 4
1.3 TensorFlow基本概念 5
二 、实现说明 5
2.1 构建神经网络模型 5
为输入输出分配占位符 5
搭建分层的神经网络 6
处理预测结果 8
2.2 运行模型 9
三 、程序测试 9
3.1 运行说明 10
3.2 运行输出 10
四 、实验总结 11
2.2运行模型
首先调用 tf.global_variables_initializer() 初始化模型的参数，Session提供了Operation执行和Tensor求值的环境
其中：
模型训练分批次，每一批用100个样本训练神经网络模型，每一批都在上一批的基础上对网络模型 的参数进行调整。
mnist.train.next_batch ：返回的是一组元组，元组的第一个元素图片像素阵列，第二个元素为 one-hot 格式的预测标签。
：在一个Session 里面计算张量的值，执行定义的所有必要的操作来产生这个计算这个张量需要的输入，然后通过这些输入产生这个张量。
feed_dict 作用是给使用 placeholder 创建出来的张量赋值，上述我们使用 定义
的占位符包括输入 x 、输出 y 和Dropout 层保留比例 keep_prob 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e77c7777d3f0976611f74d0bea3f95e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dff24126d95e39fd4719f4119d3c24c6/" rel="bookmark">
			qemu基础篇——VSCode 配置 GDB 调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 VSCode 配置 GDB 调试安装 VSCode 插件调试文件创建调试配置配置脚本qemu 启动脚 启动调试报错情况一报错情况二报错情况三 调试界面运行 GDB 命令查看反汇编断点查看内核寄存器查看变量参考链接 VSCode 配置 GDB 调试 qemu-基础篇——arm 裸机调试环境搭建
上一节中直接使用 GDB 命令行调试，本节介绍如何使用 VSCode 来进行调试
安装 VSCode 插件 调试文件创建 选择 Node.js，此时在当前工作区域会新建一个 launch.json 文件
调试配置 配置脚本 { "version": "0.2.0", "configurations": [ { "name": "qemu_bare", "type": "cppdbg", "request": "launch", "program": "${workspaceFolder}/qemu_code/bare/example/0020_mmu/bsp.elf", "args": [], "stopAtEntry": true, "cwd": "${workspaceFolder}/qemu_code/bare", "environment": [], "externalConsole": false, "MIMode": "gdb", "miDebuggerPath": "/home/tyustli/cross_tool/gcc-arm-10.3-2021.07-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-gdb", "miDebuggerServerAddress": "localhost:1234", } ] } version：表示版本号，一般不用修改configurations：其中包含每一项调试任务的具体配置信息。name：调试任务的名称，在运行和调试下拉框可以展示出来。也就是下图位置。type：指示编译器类型，如果用的 arm-none-gcc，那填的就是 cppdgbrequest：有两种类型，分别是 launch 和 attach，前者的意思就是 VSCode 会打开这个程序然后进入调试，后者的意思是你已经打开了程序，然后接通 Node.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dff24126d95e39fd4719f4119d3c24c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01ab5ca165c4999a983223bd12050b60/" rel="bookmark">
			z3 C&#43;&#43;学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为项目需要使用z3库来解决问题，所以自己学习了一下，结果发现网上教程比较少，而且大部分都是使用Python，而我本人是C++的忠实信徒，在知道C++也可以使用z3库以后我毫不犹豫地着手用C++使用z3，但是我很快发现，网上基本没有关于C++使用z3的教程（中文社区一点都没有），因此我记录一下我自己的学习过程希望能够帮助到其他学习的人。
教程链接 网上现有的有三个教程：
官方example.cpp文档：https://github.com/Z3Prover/z3/blob/master/examples/c%2B%2B/example.cpp
入门笔记：
http://www.cs.utah.edu/~vinu/research/formal/tools/notes/z3-notes.html
API接口：
https://z3prover.github.io/api/html/group__cppapi.html
其中主要教程是官方的example.cpp
第二个入门教程也非常不错，里面包含了环境的搭建，例子的说明（其实就是example.cpp的说明）
第三个API没有什么用觉得
不过上面的教程都没有说如何在一个普通文件中使用z3库，我在StackOverflow上找到一个回答解决了这个问题：https://stackoverflow.com/questions/17514923/need-help-in-using-z3-api-in-a-c-program。简单来讲在install之后要在文件中包含z3++.h头文件，而且在编译参数上要加上-lz3
我一开始是学习使用Python使用z3的，因此也发现一些很好的教程，其中对我帮助最大的是一个用z3解决背包问题的博客，让我明白如何用z3解决极值问题：https://blog.csdn.net/weixin_41950078/article/details/111416573
性能测试 同时我测试了Python和C++的性能差距，以上面学习到的01背包问题为例，在数据量为40的时候，Python的运行时间是5830.4131779670715s（我没有写错） （实测2023.10 Python版本已经挺快了），C++的运行时间是57s。
希望的我的测试能够坚定大家用C++使用z3库的决心（狗头
下符测试代码和运行截图：
Python 使用前安装z3的库：
pip install z3-solver 测试代码 import time from z3 import * def zero_one_knapsack(weights, values, cap): solver = Optimize() # the decision variables flags = [Int(f"x_{i}") for i in range(len(weights))] for flag in flags: solver.add(Or(flag == 0, flag == 1)) weight_arr = [] i = 0 for w in weights: weight_arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01ab5ca165c4999a983223bd12050b60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ebe5b8ec3ea5a82244f503b98a5524f/" rel="bookmark">
			Excel VBA&#43;Matlab解决数独问题 太牛了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Excel VBA+Matlab解决数独问题 真的太牛了！
仅用0.2秒解决一个问题，无疑是非常快速和高效的。该方法需要一定的Excel VBA和MATLAB知识，但通过Excel VBA和MATLAB的连接，即使是没有编程经验的小白也能够迅速解决问题，这真正打破了知识屏障，使问题的求解变得简单而直观。
从Excel VBA的编程语言中连接Matlab是可以在Excel输入数据，直接通过 VBA宏将这些数据导入Matlab中，再通过Matlab优化箱进行求解。
Excel VBA+Matlab解决数独问题 太牛了！
Excel VBA与MATLAB的连接和数据交互：
1. 确保已在计算机上安装了MATLAB软件。这样才能在Excel VBA中引用MATLAB的相关库和函数。
2. 添加MATLAB库引用。
3. 创建MATLAB对象。
4. 使用VBA宏从Excel中导入数据到MATLAB。可以将Excel数据存储在数组或矩阵中，并将其传递给MATLAB的工作空间。
5. 使用VBA宏执行MATLAB的代码。可以通过调用MATLAB的工作空间和函数来实现与MATLAB的交互。
6. 将计算结果从MATLAB导出到Excel中。可以将结果存储在VBA的变量中，并将其写入到Excel的单元格中。
通过这些步骤，可以在Excel VBA中使用宏来实现与MATLAB之间的数据交互和运算。将数据从Excel导入MATLAB，进行MATLAB代码的执行和计算，并将结果导出到Excel中，实现了Excel和MATLAB之间的集成和互操作性。将Excel VBA与MATLAB结合，可以发挥两个工具的优势，提高数独问题的求解效率和灵活性。
利用Excel VBA和MATLAB结合解决数独问题的方法具有以下几个强大之处：
1. 数据处理能力：Excel VBA提供了强大的电子表格处理能力，可以方便地输入、编辑和处理数独问题的数据。可以使用Excel的多种功能和工具来导入、转换和处理数据，例如将文本文件导入Excel、快速修改或复制数据等。这样可以将大量的数独问题数据方便地导入到MATLAB中进行求解。
2. MATLAB的算法和优化能力：MATLAB作为一种功能强大的数值计算和优化软件，提供了丰富的算法和工具箱。可以使用MATLAB的内置函数和工具箱来实现高效的数独求解算法，例如基于约束的优化算法、深度优先搜索、遗传算法等。这些算法和工具可以用于搜索解空间、检查数独规则并生成满足条件的解。
3. 灵活的求解策略：使用Excel VBA和MATLAB的组合，可以灵活地设计和调整数独问题的求解策略。通过编写自定义的VBA宏和MATLAB代码，可以根据问题的复杂性和特点，选择合适的求解算法和策略。例如，在初级数独问题中，可以使用简单的回溯算法，并通过VBA宏将每一步的结果在Excel中可视化展示；而在高级数独问题中，可以利用MATLAB的强大算法和工具来优化求解过程，并进行更复杂的数独规则和逻辑推理。
4. 结果的可视化和输出：使用Excel VBA和MATLAB结合，可以方便地将数独问题的求解结果输出到Excel中，以便可视化和分享。通过在Excel中设置合适的格式和样式，可以直观地呈现数独的解决过程和结果。
总之，利用Excel VBA和MATLAB的组合，可以充分发挥各自的优势，提高数独问题的求解效率和灵活性。Excel VBA提供了方便的数据处理和动态查看的功能，而MATLAB提供了强大的算法和优化能力。通过这种集成的方法，可以更直观地输入和编辑数据，使用不同的算法进行求解，并将结果以可视化和可导出的方式展示出来。这为解决数独问题带来了更加便捷和高效的方法。
如果大家有想要利用Excel VBA和MATLAB的组合求解的问题，可以评论区大家沟通交流学习。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c34aa516332d88fd79cf765b168f327b/" rel="bookmark">
			vue,引入this.$store.state.user.info，获取用户信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用vuex管理状态遇到的问题
报错：this.$store.state拿不到值
解决办法
第一步：在store--index里面引入Vue,Vuex,最后用export default 封装代码，让外部可以引用
import Vue from 'vue' import Vuex from 'vuex' import app from './modules/app' import user from './modules/user' import tagsView from './modules/tagsView' import permission from './modules/permission' import settings from './modules/settings' import getters from './getters' Vue.use(Vuex) const store = new Vuex.Store({ modules: { app, user, tagsView, permission, settings }, getters }) // 用export default 封装代码，让外部可以引用 export default store 第二步：在user.js里面添加定义的state.info
代码
import { login, logout, getInfo } from '@/api/login' import { getToken, setToken, removeToken } from '@/utils/auth' const user = { state: { token: getToken(), name: '', avatar: '', roles: [], permissions: [] }, mutations: { SET_TOKEN: (state, token) =&gt; { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c34aa516332d88fd79cf765b168f327b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91cf857ba0c271cb3a0898f63cc2f2e/" rel="bookmark">
			【总结归纳】查看linux系统的磁盘大小、内存大小和CPU内核数的命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		– 查看磁盘
df -Th
=====================================
– 查看内存
– 单位是GB
free -g
–以总和的形式查询内存的使用信息
free -t
– 单位是MB
free -m
或者用下面的命令
—查看linux系统内存的大小（显示单位是MB）
dmidecode -t memory | grep Size: | grep -v “No Module Installed”
====================================
– 查看CPU
– 查看详情
cat /proc/cpuinfo
– 查看CPU内核数
cat /proc/cpuinfo | grep processor
–查看CPU使用情况
top
–查看cpu数量及关于其他参数通过lscpu命令
lscpu
=关于CPU的一些参数解释信息如下：=
Architecture: x86_64 #架构
CPU op-mode(s): 32-bit, 64-bit
CPU(s): 96 #逻辑cpu个数
On-line CPU(s) list: 0-95
Thread(s) per core: 2 #每个核心线程数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a91cf857ba0c271cb3a0898f63cc2f2e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/104/">«</a>
	<span class="pagination__item pagination__item--current">105/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/106/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>