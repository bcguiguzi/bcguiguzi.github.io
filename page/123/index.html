<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07bf5e95874d550c0bd8e7d0c587e582/" rel="bookmark">
			【NoteExpress】统一Elsevier旗下期刊参考文献格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在准备把论文投稿到某某期刊时，你是否还在按照已发表论文的参考文献格式一个字一个字地码参考文献？
本文将教你借助软件 NoteExpress（NE），减轻插入参考文献的工作量。
NE 是一款国产文献管理软件，对投稿新手比较友好。
这里以投稿 Elsevier 旗下期刊为例。非新手可以自行跳到最后一节。
软件准备 NoteExpress官网
我当时好像是在学校图书馆那边下载的
一路正常安装就行
打开后页面如下：
点击上方菜单栏中的 选项 ，再点击 扩展 ，可以安装自己所需的插件（推荐安装经典版）：
Word 插件：
导入文献 在插入文献之前，首先要保证 NE 数据库里面有所需的文献（重点是题录）。
如何导入文献有多种方法，比如手打题录信息，从知网/百度学术等网站上直接下载 NE 的NoteExpress Reference Import File (.net) 引用文件，或者下载全文然后导入等等。
这里根据自己的需求选择文献来源并且导入，导入方法可以自行百度，这里不再赘述。
插入文献 先在文档中把光标移动到需要插入文献的位置，
在 NE 中选中要插入的文献（变蓝色）：
然后点击上方菜单栏中的 引用 即可。
修改样式 NE 自带了不少参考文献样式。点击上方菜单栏中的 选项 ，再点击 样式 ，然后点击 编辑输出样式，最后搜索目标期刊。
搜索 Elsevier Style ，选中然后关闭就可以了。
当然，也可以在 Word 里面选择样式。
如果期刊对格式有特别要求，可以在此样式基础上进行修改，点击 编辑选中的样式：
在样式编辑器中修改设置：
如果没有 Elsevier Style 样式，可以下载这个：
Elsevier Style.nes 在 NoteExpress 中：选项&gt;样式&gt;编辑输出样式&gt;安装新的输出样式
再选中该文件即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07bf5e95874d550c0bd8e7d0c587e582/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9515b5cac28ca3c150661c5c42657f16/" rel="bookmark">
			Windows平台下搭建自己的Git服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章转自：http://www.codeceo.com/article/windows-git-server.html
Gitblit 是一个纯 Java 库用来管理、查看和处理 Git 资料库，相当于 Git 的 Java 管理工具。
Gitblit 支持Linux操作系统，因此 Gitblit 需要java运行环境（JRE）。
如果公司要搭建自己的 Git 服务器，可以使用 Gitblit 这个开源的 Git 服务器。
第一步：下载Java
第二步：安装JDK步骤不再详述，网上教程一搜一大把，可参考：Windows平台下Git服务器搭建 - 阿祥当码农 - 博客园
第三步：确保电脑安装了Java 运行时环境 JRE 或者 JDK （ version &gt;=1.7 ）。
在命令窗口中，输入java命令：java -version，回车，如果出现版本信息，说明安装成功。
第四步：下载安装Gitblit
1）下载Gitblit，下载地址：Gitblit
2）解压缩下载的压缩包即可，无需安装
第五步：配置Gitblit 1）创建用于存储资料的文件夹。
2）找到Git目录下的data文件下的 gitblit.properties 文件，用“记事本”或文本编辑器打开。
3）找到 git.repositoriesFolder（资料库路径），赋值为 第1）步 创建好的文件目录。
4）找到 server.httpPort，设定http协议的端口号（注意：所使用的端口不要与已有端口冲突）。
5）找到 server.httpBindInterface，设定服务器的IP地址。这里就设定你的服务器IP。
6）保存，关闭文件。
第六步：运行gitblit.cmd 批处理文件。
1）找到 gitblit 目录中的 gitblit.cmd 文件，双击运行。
运行成功，结果如下：
3）在浏览器中打开，现在就可以使用GitBlit了。
第七步：设置成服务方式（Windows Service）启动Gitblit
1）在Gitblit目录下，找到 installService.cmd 文件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9515b5cac28ca3c150661c5c42657f16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b4fd5c22c1d650e0bf3b6137ff3e15e/" rel="bookmark">
			【HMS Core】推送报错907135701、分析数据查看
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【关键字】
HMS、推送服务、分析服务
【问题描述1】
集成推送服务，获取Token时报错 907135701: scope list empty
【解决方案】
907135701OpenGW没有配置Scope
1、您可以检查下网络是否有问题，手机是否可以正常连接互联网
2、查看推送服务开关是否正常打开
【问题描述2】
集成事件分析以后，如何按照参数查询，多久能看到数据
【解决方案】
​
事件分析里这里可以按照参数查询，数据一般第二天就可以查询到了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/113e06a042712a2e23bf5d9fba592b5a/" rel="bookmark">
			MYSQL按照小时、按天、按月分组统计，无数据补0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发过程中，写统计接口时，总会遇到按时、按天、按月统计，无数据进行补零的业务需求
现在市面既有补0的做法；也有不补0的做法：
不补0对于数据统计来说简洁明了,一个单表分组查询完事。（也就是在前端展示时，某个时间没有数据则不展示该时间，对于用户来说，其实可以接受）
补0的做法在市面相对更广泛一些，就是某个时间没有数据也展示出来该时间且对应数据补0。
以下为根据时间序列进行关联查询
目的：按小时、天、月进行分组统计，没有数据的时间段自动补零 （只能实现一个时间段内的数据条数统计） 实现方式： 基于左连接的方式进行查询 左表的数据为根据时间序列建立的时间段（比如：一天24小时，00-23 一个月：05-01 ~ 05-31） 右表的数据为业务表根据指定查询条件、对时间进行指定格式化后分组得到（分组目的：和左表生成的时间进行对应，以做关联） 左右两表按照时间进行关联 使用IFNULL方法进行为null补0 按小时分组，统计指定某天的数据，无数据补0
获取某天每小时的数据，若是想获取24小时的话，则小时设为23， 若是想获取当天动态的话，可以用sysdate()代替CONCAT('2022-12-12',' 23:59:59') SET @i=-1; SELECT DATE_FORMAT(DATE_SUB(CONCAT('2022-12-12',' 23:59:59'),INTERVAL ( (@i:=@i+1) ) HOUR ),'%H') AS dateTime	FROM mysql.help_category WHERE @i&lt;23 order by dateTime asc 效果如下：
关联要查询的表后
SELECT t1.date,IFNULL(t2.count,0) AS count FROM ( SELECT @a:=@a + 1 AS `index`, DATE_FORMAT(ADDDATE( sysdate() ,INTERVAL @a HOUR),'%H') AS date FROM mysql.help_topic,(SELECT @a:=0) temp LIMIT 24 ) AS t1 LEFT JOIN ( SELECT date_format(td.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/113e06a042712a2e23bf5d9fba592b5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb1be839e7c98fbd50732c918f416e89/" rel="bookmark">
			Arcgis 乱码处理最快的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、复制这串代码。
注意您的版本号，如果您是arcgis10.2的就将以下代码 改为Desktop10.2。
reg add HKEY_CURRENT_USER\Software\ESRI\Desktop10.8\Common\CodePage /v dbfDefault /t REG_SZ /d 936 /f
2、同时按下 win+R 键。
3、出现运行框，上面代码粘贴进去，点确定，完成。
这样打开dbf就不是乱码了。 解决不了，可以留言！！！
本解决方法，2023年8月7日创作，创作不易！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32faa435a8b45dcc9420e4d25d7c625e/" rel="bookmark">
			【数学】这可能是全网最易懂的贝叶斯公式讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 上午在B站连续刷到两个讲贝叶斯的视频，都讲的极好，而且一个视频是从应用的角度，一个是从原理的角度。我将两个视频反复对照观看发现之前怎么都无感的贝叶斯，这次居然通透了！视频链接我将放到最下方。
正文 第一个看的是从应用的角度去理解贝叶斯，举了一个有趣的例子。
说，妻子回家发现家中出现了一件明显不是自己的女人内衣！于是想知道老公出轨的可能性。而这个例子居然可以套贝叶斯公式。 我在此结合两个视频以及自己的理解，来把这个过程说清楚。
条件概率 首先我们需要理解什么是条件概率。
条件概率是指在给定某个事件发生的前提下，另一个事件发生的概率。它表示了一个事件在另一个事件已知发生的条件下的发生概率。
条件概率通常用 P(A|B) 表示，其中 A 和 B 分别代表两个事件。
P(A|B) 表示在事件 B 已经发生的情况下，事件 A 发生的概率。
数学公式为： P(A|B) = P(A∩B) / P(B)
其中，P(A∩B) 表示事件 A 和事件 B 同时发生的概率，P(B) 表示事件 B 发生的概率。
联合概率 上面提到的P(A∩B)就是联合概率，反向推到一下，联合概率就等于：
P(A∩B) = P(A|B) * P(B)
这个公式表示，事件 A 和事件 B 同时发生的概率等于在事件 B 发生的条件下，事件 A 发生的概率与事件 B 发生的概率的乘积。
出轨事件模型带入模型 模型说明 首先事件B，就是女主在家中发现其它女人的内衣，这个是已经发生的事情了。已经发生的事情还有概率可言吗？
没有啊！所以我们需要的是一个条件概率, P(B|A1) 及A1(出轨事件)发现的情况下家中出现内衣的概率。那么这个条件概率就是 P(B|A1) 。
那已经出轨且家中出现内衣的联合概率就是 P(B|A1) * P(A1)。
那有没有其是其他原因导致家中出现内衣呢？那我们就假设有个一事件A2.
A2事件就是，其实是男主的狐朋狗友把自己女朋友的内衣落在他家了！那于是就有，P(B|A2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32faa435a8b45dcc9420e4d25d7c625e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc00704f46d71168f65ea760fb18c6c2/" rel="bookmark">
			C# 使用gdi绘制自定义控件，自适应分辨率。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		录制_2023_08_06_14_12_28_725
C# 使用gdi绘制自定义控件 解决cpu占用高的问题以及闪烁问题的解决方案
视频演示
问题描述 GDI+的效率其实没有GDI的效率高的, 一般的提高效率的方法也就那么多:
减少不必要的绘制, 区域刷新效果比全部绘制效率高很多, 比如只是一个控件需要重绘,我们就不应该让整个窗口或者说大于次区域的界面无效不在显示区域的绘制工作能省就省, 主要绘制可视界面, 就是平时说的 脏矩形技术使用内存绘制, 然后直接贴图(或者截取贴图), 另外如果某些工作是不变的,比如说背景, 那么就在第一次的时候绘制到内存dc, 以后直接取用如果有可能可以使用Directx或者openGL 主要分为3步，
1.添加自适应分辨率类
2.绘制GDI图形
3.调用
1.添加自适应分辨率类
class AutoSizeFormClass { //(1).声明结构,只记录窗体和其控件的初始位置和大小。 public struct controlRect { public int Left; public int Top; public int Width; public int Height; public float FontSize; public string name; } //(2).声明 1个对象 //注意这里不能使用控件列表记录 List nCtrl;，因为控件的关联性，记录的始终是当前的大小。 // public List oldCtrl= new List();//这里将西文的大于小于号都过滤掉了，只能改为中文的，使用中要改回西文 public List&lt;controlRect&gt; oldCtrl = new List&lt;controlRect&gt;(); int ctrlNo = 0;//1; //(3).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc00704f46d71168f65ea760fb18c6c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/396cd8f38f62cb10e8e3397906c96ad0/" rel="bookmark">
			【OpenCV实战】简洁易懂的车牌号识别Python&#43;OpenCV实现“超详解”（含代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前面4篇博客介绍了OpenCV图像处理的基础知识，本篇博客利用前4篇的知识完成一个小项目——车牌号码识别。该篇博客的代码可以满足小区门禁车牌号的识别。本篇博客是前4篇博客知识的一个综合运用。感觉学会了这个可以实现一系列的图像识别任务。。。毕竟好多技巧都是共通的
首先要感谢 大佬的博客 ，在它的基础上完成了自己的识别任务。
简洁易懂的车牌号识别Python实现“超详解”（含代码） 1、整体思路2、代码详解2.1提取车牌位置2.2车牌字符的分割2.3模板匹配识别字符 3、总结4、参考 1、整体思路 首先附上本次识别的图片：（图片是我在百度上找的）
基于OpenCV车牌号识别总体分为四个步骤：
（1）提取车牌位置，将车牌从图中分割出来；
（2）车牌字符的分割；
（3）通过模版匹配识别字符；
（4）将结果绘制在图片上显示出来。
与深度学习相比，传统图像处理的识别有好处又有坏处：
好处：不需要大量的数据集训练模型，通过形态学、边缘检测等操作提取特征
坏处：基于传统图像处理的图像识别代码的泛化性较低，当图像的角度，光照不同时，识别效果有时会不尽人意。
2、代码详解 为了方便观察每一步图片的变化，本次代码在Jupyter Notebook上编写，全部代码以上传（可直接运行）。
本次项目中会多次使用到图片显示和图片去噪灰度处理，所以首先定义了显示函数和高斯滤波灰度处理函数，方便后面的调用：
# 导入所需模块 import cv2 from matplotlib import pyplot as plt import os import numpy as np # plt显示彩色图片 def plt_show0(img): #cv2与plt的图像通道不同：cv2为[b,g,r];plt为[r, g, b] b,g,r = cv2.split(img) img = cv2.merge([r, g, b]) plt.imshow(img) plt.show() # plt显示灰度图片 def plt_show(img): plt.imshow(img,cmap='gray') plt.show() # 图像去噪灰度处理 def gray_guss(image): image = cv2.GaussianBlur(image, (3, 3), 0) gray_image = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/396cd8f38f62cb10e8e3397906c96ad0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be332fe660f8bb7c905d82ee5b2abcc9/" rel="bookmark">
			RuntimeError: Background label not declared (remeber that this should be label 0!)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、报错:
2、解决办法：
3、具体代码：
1、报错: nnUNet v2在准备进行数据预处理时候，出现如下报错。
上述问题的原因是： 在对下载好的数据集KiTS19进行转化时，建立了一个dataset.json说明文件，其中对数据格式作出描述。
但是nnunet v1和v2版本是有区别的，所以在nnunet框架识别的时候，会报错。
v2与 nnU-Net v1 相关的重要更改：
“modality”现在被称为“channel_names”，以消除对医学图像的强烈偏见
“labels”的结构不同（name -&gt; int 而不是 int -&gt; name）。这是支持基于区域的培训所必需的
添加了“file_ending”以支持不同的输入文件类型
“overwrite_image_reader_writer”可选！可用于指定某个（自定义）ReaderWriter 类，该类应 与此数据集一起使用。如果未提供，nnU-Net将自动确定ReaderWriter
“regions_class_order”仅用于基于区域的培训
2、解决办法： 具体解决办法则是修改生成dataset.json文件的代码：
像我的问题（如下）是之前的labels键值对，反过来了，正确修改结果如上图所示。 除此之外，“modality”需修改为“channel_names”。
加了一行这个用来说明file_ending： json_dict['file_ending'] = ".nii.gz"
最终代码整体如下：
3、具体代码： json_dict = {} """ name: 数据集名字 dexcription: 对数据集的描述 modality: 模态，0表示CT数据，1表示MR数据。nnU-Net会根据不同模态进行不同的预处理（nnunet-v2版本改为channel_names） labels: label中，不同的数值代表的类别(v1版本和v2版本的键值对刚好是反过来的) file_ending: nnunet v2新加的 numTraining: 训练集数量 numTest: 测试集数量 training: 训练集的image 和 label 地址对 test: 只包含测试集的image. 这里跟Training不一样 """ json_dict['name'] = "KiTS" json_dict['description'] = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be332fe660f8bb7c905d82ee5b2abcc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8261f46e0419c895225a63cae701731a/" rel="bookmark">
			Apache RocketMQ之集成RocketMQ_MQTT 安装部署协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache RocketMQ 安装说明
安装步骤 参考快速开始
https://rocketmq.apache.org/zh/docs/quickStart/01quickstart
安装可视化rocketmq_dashboard下载地址
https://rocketmq.apache.org/zh/docs/4.x/deployment/03Dashboard/
安装rocketmq_mqtt
https://rocketmq.apache.org/zh/docs/4.x/mqtt/01RocketMQMQTTOverview
broker.conf配置文件中添加参数，开启多队列分发特性 (备注：最好安装5.0.0版本) enableLmq = true enableMultiDispatch = true
2.打包rocketmq-mqtt git clone https://github.com/apache/rocketmq-mqtt
cd rocketmq-mqtt
mvn -Prelease-all -DskipTests clean install -U cd distribution/target/
target下是打包的包
3.配置rocketmq-mqtt 下面例子中 ROCKETMQ所在机器192.168.33.22，ROCKETMQ-MQTT服务所在机器172.16.10.160
修改conf/connect.conf
mqttPort=1883
enablePrometheus=true
修改conf/meta.conf
IP换成要运行服务的机器的
selfAddress=172.16.10.160:25000
membersAddress=172.16.10.160:25000
修改conf/service.conf
metaAddr的IP换成要运行服务的机器的
username和secretKey配置了要记住，mqtt生产者要使用它做认证
eventNotifyRetryTopic=xx //notify重试topic，提前创建
clientRetryTopic=xx //客户端消息重试topic，提前创建
NAMESRV_ADDR的IP换成RocketMQ nameserver服务所在机器的IP
如下：
username=test
secretKey=test
NAMESRV_ADDR=192.168.33.22:9876
eventNotifyRetryTopic=eventNotifyRetryTopic
clientRetryTopic=clientRetryTopic
metaAddr=172.16.10.160:25000
初始化操作 创建topic
mqadmin updatetopic -c {cluster} -t {topic} -n {namesrv}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8261f46e0419c895225a63cae701731a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/897255bcfb7425913e64f340ccd6bc47/" rel="bookmark">
			生产环境weblogic 10.3.6安装部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、环境准备 1、创建weblogiic用户组：
groupadd weblogic useradd -d /app/ -g weblogic weblogic passwd weblogic 2、修改open file参数，方法如下：
vim /etc/security/limits.conf weblogic soft nofile 65536 weblogic hard nofile 65536 3、配置JDK环境变量：
[weblogic@localhost src]$ tar -zxf /usr/local/src/jdk-8u231-linux-x64.tar.gz -C /usr/local/java [weblogic@localhost app]$ vim .bash_profile export JAVA_HOME=/usr/local/java export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar [weblogic@localhost app]$ source .bash_profile [weblogic@localhost app]$ java -version java version "1.8.0_231" Java(TM) SE Runtime Environment (build 1.8.0_231-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11,、 mixed mode) 二、安装主域 [weblogic@localhost src]$ java -jar wls1036_generic.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/897255bcfb7425913e64f340ccd6bc47/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3d4065abe790cac3f944846909658fa/" rel="bookmark">
			本地上传到服务器的视频不能在线播放怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：我们在本地测试视频播放时，常常遇到这种情况，本地测试视频是可以正常播放的，但项目上传服务器后，视频就无法播放了，原因通常有以下几种，原因及解决方案如下：
一、视频编码格式
以MP4为例，虽然格式类型都是MP4，但视频编码格式有很多种，通常浏览器支持的为“H264”编码格式。
解决方法：
可以下载格式工厂等视频转码工具，将视频编码格式选成H264，转码即可。
二 、IIS服务器没有配置MIME类型
1、打开IIS服务器，找到MIME类型
2、视频以常用的MP4、FLV、OGG为例，进入MIME后，右侧点添加，
文件扩展名输入：.mp4，MIME类型输入：video/mp4。注：扩展名mp4前方有”.“
然后根据需要，文件扩展名输入：.flv，MIME类型输入：flv-application/octet-stream
文件扩展名输入：.ogg，MIME类型输入：video/ogg
3、如果还无法播放，可以尝试重启IIS服务器。
三 、网站安装了安全狗
如果以上两种方法视频还是无法播放，或部分视频无法播放，那么要考虑服务器是否安装了“网站安全狗”，如果有，请卸载，服务器安全狗没有影响，可不卸载。卸载完成后，你会神奇地发现，视频可以正常播放了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38f20bc398446a267ad68e4b3ace415/" rel="bookmark">
			Linux_TCP/IP_网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程 一、Internet与TCP/IP协议 ​ 20世纪50年代，美国领导的西方阵营，苏联领导的东方阵营。为争夺科技，军事力量的背景下产生。
​ 美国成立国防部高级研究计划。1968年提出高级资源共享的计算机网络。后实现网络互连。最初的Internet形成。
​ 也叫ARPAnet 阿帕网。其他国家相继建立本国的主干网并接入Internet.又MIC,Sprint 公司运营使普通家庭也可以使用。
1.1 OSI OSI是Open System Interconnect的缩写，意为开放式系统互联。
其各个层次的划分遵循下列原则：
（1）同一层中的各网络节点都有相同的层次结构，具有同样的功能。
（2）同一节点内相邻层之间通过接口进行通信。
（3）七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。
（4）不同节点的同等层按照协议实现对等层之间的通信。
​ 应用层： 产生网络流量的程序
​ 表示层： 传输之前是否进行加密或者压缩处理
​ 会话层： 查看会话，查木马 netstat-n
​ 传输层： 可靠传输、流量控制、不可靠传输
​ 网络层： 负责选择最佳路径、规划ip地址
​ 数据链路层： 帧的开始和结束、透明传输、差错校验
​ 物理层： 接口标准、电器标准、如何更快传输数据
1.2 TCP/IP ​ TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。
TCP/IP是在网络的使用中的最基本的通信协议。TCP/IP传输协议对互联网中各部分进行通信的标准和方法进行了规定。TCP/IP传输协议是保证网络数据信息及时、完整传输的两个重要的协议。TCP/IP传输协议是严格来说是一个四层的体系结构，应用层、传输层、网络层和数据链路层都包含其中。 各层的常见协议
第层常见协议1应用层Telnet（远程登录）
FTP（文件传输协议）
HTTP（超文本传输协议）
DNS（域名系统）
SNMP（简单网络管理协议 基于UDP）
SMTP（简单邮件传输）2传输层TCP（传输控制协议） 可靠的
UDP（用户数据报协议） 不可靠的3网络层IP协议（网际协议）
ICMP（互联网报文控制协议）
IGMP（组管理协议）4网络接口和物理层以太网、令牌环网、FDDI
ARP（地址解析协议） RARP（逆地址解析协议） 四层的作用
应用层：应用层是TCP/IP协议的第一层，是直接为应用进程提供服务的。 对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用了SMTP协议、万维网应用使用了HTTP协议、远程登录服务应用使用了有TELNET协议。应用层还能加密、解密、格式化数据。应用层可以建立或解除与其他节点的联系，这样可以充分节省网络资源。 运输层：作为TCP/IP协议的第二层，运输层在整个TCP/IP协议中起到了中流砥柱的作用。且在运输层中，TCP和UDP也同样起到了中流砥柱的作用网络层：网络层在TCP/IP协议中的位于第三层。在TCP/IP协议中网络层可以进行网络连接的建立和终止以及IP地址的寻找等功能网络接口层：在TCP/IP协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路 OSI模型和TCP/IP模型的结构图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38f20bc398446a267ad68e4b3ace415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8f103cc94fa3e8fa890ee56476f8074/" rel="bookmark">
			报错 -bash: wget: command not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、报错 -bash: wget: command not found 可以重装 wget 工具：
卸载 wget 工具
yum remove wget 下载 wget 工具
yum -y install wget 最后尝试 wget “url” 又OK了，一般是原来的wget初始化有文件损坏造成的。
如果还是不能执行wget url 命令，依旧报错 -bash: wget: command not found，就执行如下命令：
1）卸载 wget 工具
yum remove wget 2）清除yum缓存：
rm -rf /var/cache/yum/* 3）清除所有yum：
yum clean all 4）显示仓库列表：
yum repolist 5）下载 wget 工具
yum -y install wget 参考链接 1. 已经安装完【wget】,但是执行【wget url】时还是提示：“-bash: wget: command not found”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c62e957e0489d54ff4bb3845d86c35a/" rel="bookmark">
			MP4视频剪切合并软件绿色免费 电脑端使用 速度快 体积小 免安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 视频快速剪切合并软件 我目前使用过速度最快的
​
软件特点：速度快 体积小 免安装 电脑端
绿色免安装直接点击选择文件选择好开始结束位置 剪切 几百兆的只需几秒
视频剪切合并器是一款目前剪切视频速度最快，支持无损切割视频，最好用的免费视频剪切合并工具，剪切一个100MB大小的视频文件只需要10秒左右时间。视频剪切合并器可以对AVI,MP4, FLV, MOV, RMVB,3GP,WMV等视频格式进行任意时间段的剪切，还支持多个视频文件的合并。
绿色
a003视频快速剪切合并软件免费 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/557b56af325844eb71065355107b4f21/" rel="bookmark">
			openmv底层算法剖析---梦飞openmv前传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
接梦飞openmv博客，本篇重点剖析openmv的算法和功能实现。openmv是国外开源团队依托mirco-python架构开发的一套基于stm32内核优化算法的图像识别模组，其目的是让图像视觉算法应用开发更加简便，算法运行效率更高，其底层代码全部由C语言实现，上层代码用micro-python开发。经问世以来，受到广大高校学生和开发者的追捧和喜爱，常常在电赛上使用，并且也可帮助快速学习嵌入式和图像识别；笔者作为openmv源码二次开发者和3年开发经验的嵌入式工作者，在此简单分析openmv的算法实现和其优劣势；
openmv集成了哪些功能？
（1）sensor驱动
作为一款机器视觉模块，支持多种摄像头是必须的，openmv开发了一套完整且有效的coms–sensor驱动框架，其核心数据结构是sensor功能结构体，包括sensor ID，分辨率，图像格式，sensor功能配置函数等，用结构体的方式定义了整个sensor的全部功能，在实现上只需要实现每个sensor对应得功能函数即可，方便接入各种不同的图像传感器；当然openmv也集成了很多其他硬件模块，如wifi模块，LCD，servo驱动，测距模块等，不过其硬件价格稍贵；
（2）图像处理算法
openmv上基本实现了大部分传统图像处理算法和机器视觉算法，具体包括图像滤波如均值滤波，中值滤波，盒子滤波，高斯滤波，拉普拉斯滤波等等，另外集成了整套RGB/YUV/以及灰度图像的颜色空间转换处理算法，其中包括LAB颜色空间变换，YUV颜色空间变换等；并且openmv上实现了基于sensor自带的3A算法和图像控制处理算法，如图像任意方向旋转，畸变矫正，透视变换，3D旋转等；
（3）传统图像识别算法
在色块识别上，openmv最常用的功能是色块识别算法，其实现方式是联通域标记，其算法优势是遍历一遍即可标记所有的联通区域，方便快速实现色块定位，支持灰度和LAB颜色标记；
在形状识别上，openmv基于霍夫变换算法实现了直线，圆，矩形识别等算法；
在常见标签和条码识别上，openmv集成了开源的zbar，quirc等用于二维码解码和条形码识别，支持datamatrix识别，另外还支持了apriltag标签识别，可用于目标3D标记和跟踪定位；
在目标跟踪上，集成了目标关键特征点keypoints标记orb算法，以及帧差分算法可用于移动侦测；
在特征算法上，集成了光流特征，HOG特征计算，边缘特征CANNY算法等
在模式识别上，集成NCC模板匹配算法，可进行任意模板匹配；
在传统机器学习算法上，openmv集成了haarcascade小波特征检测算法，可基于opencv训练的各种haar特征，将其转换成openmv支持的haar文件，支持任意目标的检测；
（4）深度学习算法
openmv集成了各种框架的深度学习算法，其中包括基于ST cube-AI的深度学习框架，以及CNN，tensorflow-lite micro等，由于CNN占用资源太大且不能使用CMSIS-nn推理加速，最新的openmv源码中深度学习推理框架只保留了tensor-flow lite micro；
openmv算法为什么能在单片机上运行这么快？
首先，openmv的算法是不同于opencv的，openmv的算法底层优化策略是基于ARM-cortex-M指令集优化的，其类似于采用ARM的NEON指令集作一些算法优化，由于单片机并不具备强大的DSP，GPU,NPU这些专用数字处理模块，stm32也仅集成了具备较弱DSP功能的FPU，支持单/双精度浮点运算；因此，想要让算法跑的更快，只能在单片机内核上和算法实现策略上下功夫。
（1）指令集优化
值得称赞的是openmv算法团队将传统的图像处理算法（如滤波算法），图像分割（联通域算法）等重新优化并实现了一遍。举一个简单的例子来说，openmv上实现卷积的方式是采用32位乘加指令smlad，利用内联汇编实现的优化计算，另外对于传统数学计算，也采用了内联汇编的优化方式，这是其算法运行效率得到大幅度提升的关键因素；
（2）定点计算优化
openmv做了很多定点化计算，也是就我们常用的查表法，进一步加快算法运算速度，将一些确定的计算和数据提前算好并保存在一个数组中，直接查表计算；
（3）数据处理优化
openmv在图像像素处理上做了很多优化，如取像素，存像素，数据转换等，最大程度上适应32位处理器架构；
（4）ROI感兴趣区域
openmv在算法运行上，支持roi区域计算，只取部分区域图像进行运算，方便多种算法配合执行，这也算一个优化项；
（5）图像前处理优化
由于openmv是顺序执行，先解析python代码，再调用C函数，由于sensor图像采集一般为RGB565的图像或者YUV的图像，要处理成算法直接能运行的图像，需要作一些图像格式转换，这部分图像采集和转换处理做了单缓存，双缓存，和三缓存优化，使得图像采集速度更快，并在DCMI中断中做图像格式变换，以及图像拷贝操作，最大程度提升图像前处理的效率，使得采集出来的图像直接进入算法处理环节；
（6）资源分配优化
由于stm32的分散内存特性，openmv将文件系统缓存分配给CCM快速内存，可以方便micro-python代码的快速读取和解析，这算一个隐藏的优化项，另外支持从底层图像缓存中分配内存用于算法计算，提高了内存的利用率，不管是flash还是内存，openmv在芯片的资源利用率基本上能达到90%以上；
（7）ARM-CMSIS加速
ARM公司提供了整套基于ARM-cortex系列的内核加速计算库，包括很多指令计算库，汇编计算，还有CMSIS-NN神经网络推理加速库，openmv使用的stm32单片机引用了ARM官方计算库，因此在一些复杂的计算上，能节省很大一部分时间，这也是openmv能运行一些AI算法的基本条件；
总的来说，openmv采用的算法优化策略主要包括，ARM-cortex-M指令集优化（thumb指令集），内联汇编优化，定点化计算优化等策略，另外还在内存，flash，图像采集方法上做了很多优化；
梦飞在openmv上做了哪些事？
前面的博客文章有介绍梦飞自己设计的openmv的硬件并自己开发了底层的固件，这里重点讲解梦飞在开发openmv底层代码上做的几件事：
（1）梦飞在openmv4上做了一些算法集成和硬件集成，其中算法主要为了保证openmv支持更多的机器学习和深度学习，在底层代码上，支持ST cube-AI运行的mnist手写数字识别（但是不能支持自己训练，自己训练之后要转换到底层才能使用，如果有需要我们会提供整套代码和模型转换方法），支持lenet，CNN训练的模型算法，支持最新的mobilenet训练的模型；另外，收集了很多haarcascade训练的模型文件，通过openmv提供的工具转换成cascade模型，可在openmv上运行，支持行人检测，口罩检测，车辆识别，车牌检测，笑脸检测，动物，水果检测等等；
（2）梦飞在stm32F407上实现了整套openmv代码的集成，基于openmv源码和自主移植支持了大部分openmv3支持的算法，进一步降低了openmv硬件的成本，并在其基础上开发了一些识别例程，其中包括颜色识别，二维码识别，巡线识别，基于模板匹配的数字识别，手势识别，标记识别，人脸识别等；还有基于haarcascade的行人，车辆，口罩检测等，除了不支持深度学习，其他很多基本的算法都能使用，能在一些对硬件成本较敏感的实际应用上使用，另外梦飞支持的摄像头和LCD价格也更低；
openmv的优劣势
在传统算法性能上，openmv运行的传统图像处理和图像识别算法确实具备很大的优势，前面也分析了其算法优化的策略和实现；特别表现在色块识别，条码识别等传统算法上，这可能是openmv能转换到实际应用上的一个优势；
但是其在深度学习上没有优势，一般带AI核的芯片都能运行一些大型的深度学习框架和网络模型，但是openmv一般只能运行轻量化的神经网络模型，就算使用带SDRAM的openmv4plus也只是在内存上占优势，依然不能运行像yolov3这样的网络模型，可想而知，硬件算力限制了其作为机器视觉模块的前景；
未来趋势，尽管openmv依托stm32芯片表现出其劣势的一面，但是不影响其未来发展，目前ARM已经设计了cortex-M55的架构，也就是说未来单片机是支持AI算力的，并且最新的openmv源码中已经开始集成cortex-M55的底层库，未来前景依然是客观的；
总结启示
openmv虽然是一个MIT开源且不受限制的项目，但是有人将其硬件注册商标并指定其为官方的做法限制了很多人的学习道路，至少对于那些资金有限而勤奋好学的学生是不公平的，在此，梦飞智能自主开发的硬件将持续发光发热，通过学习和开发openmv，对于个人能力和认知的提升和进步是非常有益的，在其C语言部分个人学到了非常多有用的知识，虽然短期内还未将其完全学懂学透，从长远来看学习它是一个不错的选择。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ef42113c827e674a9b628f3f8aef113/" rel="bookmark">
			梦飞openmv--stm32单片机跑AI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 背景
前面两篇文章《openmv底层算法剖析---梦飞openmv前传》 以及《梦飞openmv py-AI机器视觉_自主开发openmv底层固件和硬件》 充分展示了梦飞openmv的开发历程，也充分证实了单片机做图像识别算法的可行性。 引用openmv官方的话术： OpenMV适合做什么？ ---DIY相关的项目制作，比如追踪小球的车，云台，或者解魔方的机器人。 ---对成本要求很高的嵌入式工业方案，比如流水线物品的分拣。 OpenMV不适合做什么？ ---复杂的算法：比如OCR识别，车牌识别，猫狗分类，深度学习之类的。 那么单片机到底能否做AI？小梦给出了一个供大家参考的分析和案例， 我认为是完全可以做AI的，并且有其应用场景和市场前景 2 AI算力的差距
单片机主打的微控制器领域，但是目前AIOT的市场越来越火 ARM公司也不得不推出适用于单片机架构cortex-M系列的神经网络运行加速库CMSIS-NN 使得cortex-M4，cortex-M7系列的单片机有运行AI算法的内核能力 意法半导体也推出了很多基于stm32微控制器的嵌入式AI应用方案（具体可查看https://stm32ai.st.com/zh/） 但要想在图像识别领域使用低端单片机运行AI算法，算力方面差距还是不小 我们以勘智K210和stm32H7为例，计算其AI算力。 2.1 DMIPS和MIPS
1、DMIPS （Dhrystone，Million Instructions executed Per Second）： 是测量处理器运算能力的最常见基准程序之一，常用于处理器的整型运算性能的测量。 Dhrystone是一种整数运算测试程序。 2、MIPS：Million Instructions executed Per Second，每秒执行百万条指令， 用来计算同一秒内系统的处理能力，即每秒执行了多少百万条指令。 2.2 TOPS和FLOPS
1.FLOPS是指每秒钟浮点数运算的次数，它通常用于衡量计算机的通用浮点数计算性能 例如，如果一个处理器能够执行10亿次浮点数运算，则它的浮点运算速度为1 GFLOPS 2.算力 TOPS则是指每秒钟执行的整数和/或定点数运算次数，它主要用于衡量处理器的特定功能的性能， 如人工智能领域的卷积计算等。通常，深度学习处理器的算力 TOPS 比普通处理器的 FLOPS 高得多。 2.3 stm32H7 和K210 AI算力
stm32H7 480M主频，具备双精度FPU浮点运算单元 K210 600M主频，具备专用KPU神经网络运算单元 **整形运算能力对比：** H7整型计算能力856 DMIPS，每秒大概可以处理32位整型运算 856DMIPS=856MIPS，大概是 几百MOPS； 换算0.856G OPS=0.000856TOPS 和AI芯片K210（1TOPS）差了好几个量级 **AI计算能力对比：** 由于AI模型的计算量都是以浮点运算量计算，例如某AI网络模型总计算量为0.012BFLOPs， 使用stm32H7在CMSIS-NN加速条件下一秒可以推理12次（测试值），总计算量大约0.14GFLOP=0.00014TFOPS； K210的AI算力大概0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0ef42113c827e674a9b628f3f8aef113/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48fa49c085efead49afe362c7fc962a4/" rel="bookmark">
			C&#43;&#43;11中的内存模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、几种关系术语 1.1、sequenced-before sequenced-before用于表示同一个线程中，两个操作上的先后顺序，这个顺序是非对称、可以进行传递的关系。
它不仅仅表示两个操作之间的先后顺序，还表示了操作结果之间的可见性关系。两个操作A和操作B，如果有A sequenced-before B，除了表示操作A的顺序在B之前，还表示了操作A的结果操作B可见
1.2、happens-before 与sequenced-before不同的是，happens-before它既包括同一个线程里的操作顺序，也包不同线程操作间的顺序，同样的也是非对称、可传递的关系。
如果A happens-before B，则A的内存状态将在B操作执行之前就可见
1.3、synchronizes-with synchronizes-with 描述的是两个线程对同一个原子变量的修改和读取之间的关系，如果一个线程修改某变量的之后的结果能被其它线程可见，那么就是满足synchronizes-with关系的。
显然，满足synchronizes-with关系的操作一定满足happens-before关系了。
二、C++11中支持的内存模型 从C++11开始，就支持以下几种内存模型：
enum memory_order { memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel, memory_order_seq_cst }; 与内存模型相关的枚举类型有以上六种，但是其实分为四类，如下图所示，其中对一致性的要求逐渐减弱，以下来分别讲解。
在原子操作上添加六种内存顺序标记（中的一部分），会影响（但不一定改变；视 CPU 架构）原子操作附近的内存访问顺序（包括其他原子操作，亦包含对非原子变量的读写操作）。注意，内存顺序（通过六种标记）讨论的实际上是线程内原子操作附近非原子操作访问内存的顺序，而非是多线程之间的执行顺序。只不过，因为原子变量自身可能建立了线程间的同步关系，所以两个线程内各自的内存顺序会经由原子变量的同步建立间接的顺序关系。亦即，内存顺序本质上是在讨论单线程内指令执行顺序对多线程影响的问题
2.1、顺序一致顺序 (sequentially-consistent ordering) 以 memory_order_seq_cst 为参数对原子变量进行load、store或者read-modify-write操作。这是默认的内存模型，c++11所有的原子操作都是采用memory_order_seq_cst作为默认参数。所有以memory_order_seq_cst为参数的原子操作（不限于同一个原子变量），对所有线程来说有一个全局顺序（total order），并且两个相邻memory_order_seq_cst原子操作之间的其它操作(包括非原子变量操作)，不能reorder到这两个相邻操作之外。【注：同一个程序的不同运行，这个全局顺序是可以不一样的】。
我们通过下面的例子来理解一下顺序一致性：
std::atomic&lt;bool&gt; x = {false}; std::atomic&lt;bool&gt; y = {false}; std::atomic&lt;int&gt; z = {0}; // 线程A void write_x() { x.store(true, memory_order_seq_cst); } // 线程B void write_y() { y.store(true, memory_order_seq_cst); } // 线程C void read_x_then_y() { while (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48fa49c085efead49afe362c7fc962a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1ba1d9feba2260f17ab6f0760eeae4/" rel="bookmark">
			vscode的settings配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		"eslint.enable": true, "eslint.codeAction.showDocumentation": { "enable": true }, "eslint.validate": ["javascript", "typescript", "javascriptreact", "typescriptreact", "html", "vue"], "typescript.validate.enable": true, "javascript.validate.enable": true, // 这里配置eslint和stylelint和prettier的自动格式化 "editor.codeActionsOnSave": { "source.fixAll.eslint": true, // 开启eslint 保存自动检测 "source.fixAll.stylelint": true // 开启 Stylelint 保存自动检测 }, "workbench.iconTheme": "material-icon-theme", "workbench.colorTheme": "Community Material Theme Palenight High Contrast", "editor.fontFamily": "mononoki", "liveServer.settings.donotShowInfoMsg": true, "git.ignoreMissingGitWarning": true, "typescript.updateImportsOnFileMove.enabled": "always", // 当按tab键的时候，会自动提示 "emmet.triggerExpansionOnTab": true, "emmet.showAbbreviationSuggestions": true, "emmet.includeLanguages": { "javascript": "javascriptreact" }, "js/ts.implicitProjectConfig.checkJs": true, "workbench.startupEditor": "none", "stylelint.packageManager": "yarn", "[scss]": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1ba1d9feba2260f17ab6f0760eeae4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6bf9154da338742f4cad5dcb270bbe7d/" rel="bookmark">
			基于Springboot&#43;vue的前后端分离的实时多人在线聊天管理系统（简易版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于Springboot+vue的前后端分离的实时多人在线聊天管理系统（简易版） 项目简介软件架构运行截图部分代码源码获取如果项目对大家有帮助？麻烦大家帮忙点点赞，点点收藏啦！谢谢大家！！ 项目简介 本项目为基于Springboo+vue+websocket的前后端分离的实时多人在线聊天管理系统
本项目实现功能：
登录注册添加搜索好友好友上线提醒好友上线下线标识好友发送消息通知（红点数字）好友申请通知我的申请记录单人聊天同时多人聊天不在线信息保存及上线信息提示等 注意：本项目为简易版项目，可能会存在部分bug，且功能并没有完善好，很适合学习使用，禁止商用！！后续会把项目继续完善好！
后面会把添加更多功能，包括：
好友列表搜索 好友分类 个人信息编辑 设置好友备注 群聊功能 暂时就想到这些 这些也是下一步的开发计划 ！
本项目源代码分为前后端以及上传到资源中了
目前项目是收费的，但是价格很低，前后端一共不到20块钱，算大家犒劳一下作者了！已开启不允许自动调整价格！（不喜勿喷）
软件架构 数据库Mysql8.0JDK1.8Springboot2.1.9vue2.6.14axios1.4webSocketnode16.14.2 运行截图 数据库模型
前端项目结构：
后端项目结构：
1.首页
2.登录页面
3.聊天页面
4.搜索添加联系人
5.我的消息通知
6.注册页面
7.好友在线与不在线标识
8.我的申请列表
9.多人同时聊天
10.好友上线通知
11.我的消息内容
12.未读消息提示
部分代码 前端主要websocket链接代码
initConnect() { this.ws = new WebSocket(`ws://localhost:8080/talk/imserver/` + this.user.no);//websocket连接地址 this.ws.onopen = () =&gt; { console.log('WebSocket连接已建立'); this.isConnected = true; // 建立心跳定时器 this.heartbeatInterval = setInterval(() =&gt; { if (this.ws.readyState === 1) { this.ws.send(JSON.stringify({ type: 'heartbeat' })); console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6bf9154da338742f4cad5dcb270bbe7d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/122/">«</a>
	<span class="pagination__item pagination__item--current">123/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/124/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>