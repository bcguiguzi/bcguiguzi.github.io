<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96af7fa6ac4a6b8b8f67a208af919761/" rel="bookmark">
			sql查询语句练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		select * from emp where a=b group by deptno having c&gt;0 order by sal
#where：子句查询的条件
#group by：按列分组
#having：分组结果的筛选条件
执行顺序： from --&gt; where --&gt; group by --&gt; having --&gt; select --&gt; order by --&gt; limit
where后面不能跟聚合函数
1、先看一下emp表中存放的数据： empno：员工编号
ename：员工姓名
job：员工职位
mgr：部门经理的编号
hiredate：入职日期
sal：薪资
comm：奖金
deptno：部门编号
(1)查询EMP表中各部门工资大于2000的员工人数，并且按人数从高到低排列 思路：
step1：先找出工资大于2000的人 select * from emp where sal&gt;2000; 执行结果如图：
step2：分组找出各个部门工资大于2000的人(对step1中的查询结果按部门进行分组)，并进行人数统计
​ select deptno,count(*) from emp where sal&gt;2000 group by deptno; ​ 执行结果：
step3：对step2中统计出的人数进行排序
select deptno,count(*) sort_count from emp where sal&gt;2000 group by deptno order by sort_count desc; 执行顺序： from --&gt; where --&gt; group by --&gt; having --&gt; select --&gt; order by --&gt; limit
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96af7fa6ac4a6b8b8f67a208af919761/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e970f19eb57f7ae858bde12ced142f44/" rel="bookmark">
			云原生到底是个啥玩意？从云端降临的超级技术：云原生
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
福利：文末分享云原生相关全套资料哦
一、云计算？云原生？
二、云原生带来什么好处
7个字：隔离、弹性、自动化。
三、云原生的基础知识
四、云原生中最重要的概念
1、虚机
2、容器
3、容器编排
4、VPC
5、微服务（Microservices）
6、服务网格（Service Mesh）
7、无服务器（serverless）
8、基础设施即代码（IaC）
9、DevOps
五、更深一步：云计算背后的东西
1、云平台和云管平台
2、地域（Region）
3、可用区（AZ）
4、SDN
5、网络资源池
那么，云原生是什么
福利：文末分享云原生相关全套资料哦 云原生技术里有很多技术、概念和术语，不了解的人，往往弄不清楚而一头雾水，这些概念都是啥，之间是什么关系？
本文要说的就是这些。
本文更多是科普和扫盲，无意面面俱到，也无意深入细节。 本文适合一定IT基础的人阅读，完全的小白和门外汉，可能是看不懂的。
完全看不懂的云原生
一、云计算？云原生？ 云原生就是“云+原生”（cloud + native）。一般而言，“云”更关注IaaS，也就是基础设施层面（如计算、存储、网络）；“原生”更关注PaaS层面（如容器、微服务）。之所以叫“原生”，是因为它一生下来是给云用的，可谓是生在云里，长在云里。
一位学者可能会说：“云计算是一种灵活提供基础IT资源的架构，云原生是一种在云计算上创建和运行应用程序的方法。”这话没有什么错，但也没有什么用，因为太抽象了。
在词汇使用上，据我观察，“云计算”和“云原生”基本上已经混为一谈了，我从来没有见过一个人说“云原生”的时候，另一个人站出来说“不对，这个是云计算”，反之亦然。
唯一的区别是：人们以前爱说“云计算”，现在爱说“云原生”。
毕竟，新词总是高大上一点嘛。
所以，这块不要太纠结。
二、云原生带来什么好处 其实这等同一个问题：为什么要上云。
好处有很多，我本人觉得最重要的有3点：
7个字：隔离、弹性、自动化。 1、隔离：在传统架构中，一个网络配置错误可能导致整个DC故障，一个模块出问题可能会导致整个应用系统故障。而且往往很难定位和隔离。云原生通过VPC、容器、微服务这些能力，把网络、操作系统、应用系统以虚拟或拆分的方式隔离开来，做到互不影响。一个部分的运行、变更或故障，不会影响其他部分，这就安全多了。
2、弹性：应用系统在服务能力紧张时，需要扩容，比如增加机器的内存和CPU，或是部署新的实例并做负载均衡，在传统环境下，这需要一定的工作量，尤其是需要运维人员的安装和配置。云原生在一开始设计时，就考虑了如何更方便、更快捷、更安全地扩容，比如虚机、容器的快速生成，自动地扩容和负载均衡。这样，以前是几个小时的事，现在稍稍动动手指就可以了，几分钟或者更少的时间搞定。
3、自动化：不管是部署还是变更、维护，如果一项工作涉及多个步骤，需要多项配置，甚至需要多个团队配合，那就会很繁琐，很复杂，对使用者的要求就会很高，出错的概率就会变大。如果只需一条指令、一个按键就能完成相关工作，那就是高度的自动化。云原生的很多设计，就是以尽可能少的指令，完成尽可能复杂的操作。
自动化通过什么方式呈现给用户？一是图形化界面，让各类用户（平台租户、运营人员、运维人员、开发人员）都可以简单上手操作，比如租户（就是客户）点点鼠标就能申请一台虚机或是一台网关；二是命令行界面，让喜欢命令行的人可以直接或者写脚本调用；三是API，让程序员可以写程序任意编排操作。这样，各种不同技能基础的人，都能够尽自己能力实现尽可能的自动化。
云原生的本质，就是IT全过程的软件化，也即“软件定义everything”在IT行业得以实现，而且是规模化和自动化的实现。原先冗长、复杂、颇费时费力的技术工作和体力活，现在可以轻轻松松搞定。
说这么多，现在略略见识一下：
kubectl create deployment nginx --image=nginx --replicas=2 kubectl set image deployment/nginx nginx=nginx:latest 以上是两条kubernetes命令，其中，第一条命令部署两个nginx容器，第二条命令则让它们更新成一个最新的镜像版本。
看，这多么简单。
三、云原生的基础知识 考虑扫盲性质，现在说一点最基础的东西。
1、虚机：虚机是在物理服务器之上虚拟出来的具有完整功能的计算机。人们可以通过云平台创建虚机并安装操作系统，对其扩容，并在不停机的情况下将其迁移到另一台物理机上。
2、裸金属：裸金属即云纳管的物理机。裸金属不参与虚拟化，不提供虚机，但一样可以被云管理，可以被云自动化地分配、回收和管理。
3、存储：云可以提供块存储（如IPSAN）、文件存储（如NAS）、对象存储（OBS）。并且都提供界面、命令行和API给用户，让用户可以非常便利的使用和管理存储。通过对存储的资源池化和虚拟化，抹平了不同设备的差异，用户不再需要学习具体的存储设备知识、指令和配置方法。 比如在openstack中，用如下命令创建一个叫my_volume的卷，大小为10G，然后通过命令将这个创建好的卷连接到虚拟服务器my_server上。
openstack volume create --size 10 my_volume openstack server add volume myserver my_volume 看，这多么简单！作为一个完全不懂存储的人，我也可以轻而易举做到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e970f19eb57f7ae858bde12ced142f44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4331557e9e679c7dcb875710d9c31262/" rel="bookmark">
			代码库 - git管理工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引导目录 安装git3种状态基本命令进阶命令常用提交类型常见问题commit取消暂存取消（取消add）用户名邮箱配置gitignore忽略上传gitignore文件不生效的解决办法冲突问题git推送验证git 命令报错问题 安装git npm 所有版本
官网下载
中文文档
命令：总览
终端执行git --version 检测是否安装成功
3种状态 分别为：工作区、暂存区、Git仓库。
命令查询（git status）
Changes not staged for commit：被修改，待添加到缓冲区(add)Changes to be committed：暂存(缓冲)区，待提交(commit)Untracked files：新建的文件，未被监管，首次添加 文件标注
M: 文件内容或者mode被修改了，最常见
U: 新增文件，未添加到暂存区
A: 新增文件，已添加到暂存区
D: 已经被删除的文件，一般显示在提交记录中
基本命令 git init：初始化
git clone 远程仓库链接：首次检出 clone
git add 文件名：添加暂存(缓冲)区(状态A)，.是所有文件，
git commit -m： 提交 暂存区=&gt;本地仓库，提交规则忽略加 --no-verify
git commit -m "feat：提交日志信息" // feat是提交类型，见下文 git commit -m "feat：提交日志信息" --no-verify git pull：拉取，远程仓库→本地仓库
git push：推送，本地仓库→远程仓库,
语法：git push &lt; remote &gt; &lt; branch &gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4331557e9e679c7dcb875710d9c31262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e27645b84e6921d4c0e1ed809a0eca8/" rel="bookmark">
			5. 超炫酷的爬虫源代码-vip音乐下载器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 准备工作2. 安装第3方库2.1 os 库2.2 tkinter库2.3 webbrowser 库2.4 requests 库2.5 PySimpleGUI 库2.6 retrying库 3. 源代码4. 运行结果5. 音乐下载器的使用6. 去哪里找下载的音乐7. 部分代码解析8. 留言 1. 准备工作 在电脑D盘新建一个【安迪笔记】文件夹。
【安迪笔记】文件夹里新建【2.爬虫笔记】文件夹。
【2.爬虫笔记】文件夹里新建【5.vip音乐爬虫】文件夹。
【5.vip音乐爬虫】文件夹里新建【5.vip音乐下载器.py】文件。
我用vscode编辑器打开【安迪笔记】文件夹。
vscode打开的文件夹决定了相对路径，这一步要重点关注。
【备注】
我写笔记需要用到【安迪笔记】里的其他资料，为了笔记方便，我才建了这么多文件夹 。
因为有太多太多的同学找不到最终输出的文件，所以我对建文件夹和py文件做了详细说明。
如果你能掌握绝对路径的知识，能找到输出的文件，直接建py文件写即可。
2. 安装第3方库 【程序需要导入的所有库】
import os import tkinter as tk import webbrowser import requests import tkinter.messagebox as mes_box import PySimpleGUI as sg from tkinter import ttk from retrying import retry 2.1 os 库 os是Python的内置库，不需要额外安装。
os库提供了一系列与操作系统交互的函数。
包括文件操作、进程管理、环境变量等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e27645b84e6921d4c0e1ed809a0eca8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d91524739e0fa7729d717b16c92b5cd3/" rel="bookmark">
			Python Selenium WebDriver 如何设置请求头用户代理(User-Agent)参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本文中，将演示如何为浏览器设置用户代理，以及如何在Python Selenium WebDriver中读取用户代理。测试中的许多方案都需要操作用户代理。
什么是用户代理？ User-Agent 请求标头包含一个特征字符串，该字符串允许网络协议对等方标识请求软件用户代理的应用程序类型、操作系统、软件供应商或软件版本。它显示在 HTTP 请求标头中，不适用于响应标头。所有浏览器都支持它。
简而言之，用户代理是客户端（用户）的身份。
用户代理的通过格式：
User-Agent: Mozilla/&lt;version&gt; (&lt;system-information&gt;) &lt;platform&gt; (&lt;platform-details&gt;) &lt;extensions&gt; Example:
Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0 Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:63.0) Gecko/20100101 Firefox/63.0 Selenium 没有实现任何直接方法来读取请求或响应标头。
注意：要运行以下示例，您需要在 PATH 环境变量中设置浏览器驱动程序路径详细信息，或者在创建浏览器实例时必须将浏览器驱动程序路径传递给executable_path变量。
获取用户代理值 Selenium没有任何直接的方法可以从WebDriver实例查询用户代理。我们需要使用执行javascript内置方法来执行此操作，并传递返回user-agent的脚本。
浏览器启动后，我们可以通过执行以下代码行来获取用户代理
# Store it in a variable and print the value agent = driver.execute_script("return navigator.userAgent") print(agent) # directly print the value print(driver.execute_script("return navigator.userAgent")) Firefox 中的用户代理设置： 要更改 Firefox 浏览器的用户代理，请在 Firefox 配置文件中设置变量“general.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d91524739e0fa7729d717b16c92b5cd3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59b0174aa011d18a0b6ef06a7770b582/" rel="bookmark">
			代码随想录刷题营day1|双指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 双指针思想 双指针思想主要应用场景是解决双重循环问题，降低算法的时间复杂度一般有两个指针完成数组的遍历，双指针可能都从数组首元素出发，也有可能一个指针从前向后遍历、另一个指针从后向前遍历使用快慢指针要特别注意边界条件的处理，即什么时候停下来 Leetcode27.移除元素 题目分析 不能使用额外的空间，就要求我们只能在原数组中做改动需要移除等于val的元素，想到的就是遍历该数组，如果遇到等于val的元素，那就与后面不等于val元素做swap，并记录最后一个不等于val元素的索引，这样也就间接知道了移除后数组的新长度 思路 采用双指针的思想，左指针从前向后遍历整个数组，如果遍历到的元素不等于val，继续向后遍历；否则，右指针从后向前遍历，找到第一个不等于val的元素，两元素交换，同时更新左指针，右指针
边界条件：什么时候停止？右指针标志从后向前第一个不等于val元素的位置，所以循环遍历结束的条件应该是i &gt; j,这样while循环条件就是i &lt;= j
代码实现 class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { if (nums.size() == 0) return 0; int i = 0; int j = nums.size() -1; while(i &lt;= j){ if(nums[i] == val){ nums[i] = nums[j]; j--; } else{ i++; } } return i; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d91fa58b263c9428d5833b6b4330e6/" rel="bookmark">
			常说的一区二区含义是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一区和二区是对于SCI期刊的划分，用于评估期刊的学术声誉和影响力。这种划分通常是指SCI期刊的影响因子（Impact Factor）范围。
一区期刊（Q1）是指影响因子排名靠前的期刊，即影响因子在某个学科领域中排名前25%的期刊。一区期刊通常被认为是学术质量较高的期刊，发表在这些期刊上的论文被视为较有影响力。
二区期刊（Q2）则是指影响因子排名次高的期刊，即排名在第26%到第50%之间的期刊。二区期刊相对于一区期刊来说，影响力稍逊一筹，但仍然具有一定的学术声誉。
这种划分对于学术研究者、科研机构和学术期刊来说，可以作为评估研究成果质量和期刊声誉的参考指标。然而，需要注意的是，一区和二区只是对SCI期刊的大致划分，具体期刊的影响因子和分类可能会有所变化，并且不同学科领域之间的划分也可能有所不同。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6f474b5fb6d11759df2dc7de3579407/" rel="bookmark">
			python 利用描述器 批量修改分组的属性值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：class中的属性值init_height是一个变量，另一个属性值real_height是以init_height为参数的计算公式算出的值，现在有多个此类，该如何管理这些类的数据，现在要求上述的代码具备以下两个功能：1.初始化时，不进行分组，后面指定部分类进行分组。2.要求同组的init_height属性值都是一样的，且当我二次更改class中的init_height属性值时，同组的class的real_height属性值都要更新，且更新后的值也是一样的。3.同时要求计算的方法是可以修改的。
class MyClass: data = [] groups = {} def __init__(self, init_height=None, calculate_real_height=None): self._init_height = init_height self.calculate_real_height = calculate_real_height self.real_height = None self.group = None MyClass.data.append(self) @property def init_height(self): return self._init_height @init_height.setter def init_height(self, value): if self.group is not None: self.update_group_init_height(value) self.update_real_height() self._init_height = value def update_group_init_height(self, value): group = self.group for obj in MyClass.groups[group]: obj._init_height = value def update_real_height(self): group = self.group init_height = self._init_height for obj in MyClass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6f474b5fb6d11759df2dc7de3579407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe9ee0803d322781dd72875c32e6d3e5/" rel="bookmark">
			a-table 格式化处理数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.a-table 格式化处理列数据 &lt;a-table :rowKey="(record) =&gt; record.id" :columns="columns" :data-source="tableData" :row-selection="{ selectedRowKeys: selectedRowKeys, onChange: onSelectChange, }" :pagination="false" &gt; &lt;template slot="sex" slot-scope="text, row"&gt; &lt;span&gt;{{row.sex === 'M' ? '男':'女'}}&lt;/span&gt; &lt;/template&gt; &lt;template slot="opt" slot-scope="text, row"&gt; &lt;span class="cursor-pointer" style="margin-right: 8px;"&gt;详情&lt;/span&gt; &lt;span class="cursor-pointer"&gt;编辑&lt;/span&gt; &lt;/template&gt; &lt;/a-table&gt; js部分：
格式化处理列数据的时候可以使用scopedSlots插槽的方式处理；也可以使用customRender处理。
在数据过长时，使用ellipsis显示省略号。用sorter去排序。align是指定对齐方式，可选’left’ 、‘right’ 、 ‘center’，默认是’left‘。
注：这里引入的filter.js是我自定义的格式化方法，替换成自己即可
import vFilter from "@/common/js/filter.js" export default { data() { return { tableData: [ { key: 1, name: "李娟", age: 20, sex: "M", educationalBg: "本科", graduateSchool: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe9ee0803d322781dd72875c32e6d3e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/788afc2fe28862260d0decd7c4c21d81/" rel="bookmark">
			a-table 批量删除功能：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.a-table多选删除功能： &lt;a-table :rowKey="(record) =&gt; record.id" :columns="tableData.columns" :data-source="tableData.data" :row-selection="{ selectedRowKeys: selectedRowKeys, onChange: onSelectChange, }" :pagination="false" &gt; &lt;/a-table&gt; js部分:
用onSelectChange方法把选中的ID存到selectedRowKeys中，再发送remove请求。
rowKey使用唯一标识id，如果是有层级关系的表格使用index会有bug产生，故有id就绑定id。
export default { data() { return { // 用来存选中行id selectedRowKeys: [], } }, methods: { onSelectChange(selectedRowKeys) { this.selectedRowKeys = selectedRowKeys; // 将选中行的id保存到selectedRowKeys中 }, onDeleteSelected() { if (this.selectedRowKeys.length &gt; 0) { this.$confirm({ title: "提示", content: "该操作将永久删除该记录且不可恢复, 是否继续?", okText: "确定", cancelText: "取消", onOk: () =&gt; { remove({ ids: this.selectedRowKeys }).then((res) =&gt; { if (res &amp;&amp; res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/788afc2fe28862260d0decd7c4c21d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e163e91a7178fbe2a40d0d5efca5768c/" rel="bookmark">
			肝到爆，通过Canal如何优雅的将MySQL同步到ES？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		技术是什么？就是拿来玩的，边玩边学，才能成长得更快。
之前已经给大家讲解了 MySQL 同步 ES 的几种方案，下面就教大家如何通过 Canal，将 MySQL 同步到 ES，文章内容绝对妥妥干货！
本文会先讲解需要用到的基础知识，然后再是软件安装，最后就是实战部分。
不 BB，上文章目录：
01 基础知识 1.1 主从复制原理 MySQL 的主从复制是依赖于 binlog，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上二进制日志文件。
主从复制就是将 binlog 中的数据从主库传输到从库上，一般这个过程是异步的，即主库上的操作不会等待 binlog 同步地完成。
详细流程如下：
主库写 binlog：主库的更新 SQL(update、insert、delete) 被写到 binlog；
主库发送 binlog：主库创建一个 log dump 线程来发送 binlog 给从库；
从库写 relay log：从库在连接到主节点时会创建一个 IO 线程，以请求主库更新的 binlog，并且把接收到的 binlog 信息写入一个叫做 relay log 的日志文件；
从库回放：从库还会创建一个 SQL 线程读取 relay log 中的内容，并且在从库中做回放，最终实现主从的一致性。
1.2 Cannel 基础 Canel 是一款常用的数据同步工具，其原理是基于 Binlog 订阅的方式实现，模拟一个 MySQL Slave 订阅 Binlog 日志，从而实现 CDC（Change Data Capture），将已提交的更改发送到下游。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e163e91a7178fbe2a40d0d5efca5768c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d818b946c1ea2108c403532d2beefeab/" rel="bookmark">
			C&#43;&#43;__vector容器的遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;vector&gt; // 使用vector容器时，需要引入头文件。 //1、通过无参构造，构造一个空的vector容器。
vector&lt;int&gt; v; //2、添加若干个元素。
v.push_back(1); v.push_back(2); v.push_back(3); //3.迭代器（iterator）：使用普通指针，依次指向vector中的每一个元素。、
/*
begin(): 获取到的是vector容器中的首元素的地址。
end(): 获取到的是vector容器中的最后一位元素的下一位的指针。
需要注意的是，end()函数返回的迭代器指向的位置是一个不存在的元素，因此不应该对其进行解引用操作。
如果要访问最后一个元素，应该使用vector容器的back()函数来获取。
*/
vector&lt;int&gt;::iterator it = v.begin(); // 注意，迭代器获取的是地址。 cout &lt;&lt; "v[0]=" &lt;&lt; *it &lt;&lt; endl; // v[0]=1 *it++; cout &lt;&lt; "v[1]=" &lt;&lt; *it &lt;&lt; endl; // v[1]=2 *it++; cout &lt;&lt; "v[2]=" &lt;&lt; *it &lt;&lt; endl; // v[2]=3 //*it++; //cout &lt;&lt; "v[3]=" &lt;&lt; *it &lt;&lt; endl; // 越界，无法输出结果。 //使用迭代器，遍历vector容器。（可缩写）
int i = 0; for (vector&lt;int&gt;::iterator it = v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d818b946c1ea2108c403532d2beefeab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db70742ab4ac0777cb3a212a2d7b9d78/" rel="bookmark">
			chatgpt赋能python：Python的强制语句缩进解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python的强制语句缩进解析 什么是语句缩进 在其他编程语言中，我们通过使用花括号或者一些其他的符号来区分控制语句的范围。但在Python中，我们使用缩进来实现这个目的。这意味着任何控制结构的主体都必须按照要求正确缩进。
为什么Python强制要求使用缩进 Python通过采用强制缩进，使代码的结构更加清晰、易于阅读，并且可以减少错误。同时，这种方式也很容易让编程者遵循一种结构化的编程方式。
在Python中，代码块的开始通过冒号表示，代码块的结束则由缩进的层数隔开。因此，缩进的作用在于告诉编译器这段代码应该归属到哪个代码块中。这让Python的代码可读性更佳，更容易阅读、理解和维护。
Python中用于语句缩进的标准 Python 语言规范定义了四种不同程度的缩进来实现不同级别的语句块，它们分别是：
一个缩进层级为4个空格时，用于表示语句块的开始。两个缩进层级用于嵌套语句块。三个缩进层级用于更深层次的嵌套。四个缩进层级用于表达最深层次的嵌套。 结论 语句缩进可以让Python代码结构更加清晰易懂，使得代码块之间更加紧密，同时保证了代码的可读性和可维护性。同时，在Python中缩进的标准也十分明确，一般在实际使用中以四个空格为一层来进行缩进，这方便了不同开发者之间的代码衔接和项目的编写。
因此，语句缩进是非常重要的，它是Python编程的基础知识之一，对于新手来讲，花一些时间去学习和理解它是非常有必要的。同时，在编写Python代码的过程中，应该保证缩进的一致性，避免出现缩进错误的情况。
最后的最后 本文由chatgpt生成，文章没有在chatgpt生成的基础上进行任何的修改。以上只是chatgpt能力的冰山一角。作为通用的Aigc大模型，只是展现它原本的实力。
对于颠覆工作方式的ChatGPT，应该选择拥抱而不是抗拒，未来属于“会用”AI的人。
🧡AI职场汇报智能办公文案写作效率提升教程 🧡 专注于AI+职场+办公方向。
下图是课程的整体大纲
下图是AI职场汇报智能办公文案写作效率提升教程中用到的ai工具
🚀 优质教程分享 🚀 🎄可以学习更多的关于人工只能/Python的相关内容哦！直接点击下面颜色字体就可以跳转啦！ 学习路线指引（点击解锁）知识定位人群定位🧡 AI职场汇报智能办公文案写作效率提升教程 🧡进阶级本课程是AI+职场+办公的完美结合，通过ChatGPT文本创作，一键生成办公文案，结合AI智能写作，轻松搞定多场景文案写作。智能美化PPT,用AI为职场汇报加速。AI神器联动，十倍提升视频创作效率💛Python量化交易实战 💛入门级手把手带你打造一个易扩展、更安全、效率更高的量化交易系统🧡 Python实战微信订餐小程序 🧡进阶级本课程是python flask+微信小程序的完美结合，从项目搭建到腾讯云部署上线，打造一个全栈订餐系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1fe76698b95d8b5100b32622690112d/" rel="bookmark">
			Vue3中集成Unreal 5.2 像素流(Pixel Streaming插件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 创建一个Unreal项目2. 启用Pixel Streaming插件3. 下载Unreal 5.2对应的Pixel Streaming Infrastructure4. 创建一个Vue项目5. 推流方式一：使用Unreal Engine 5.26. 推流方式二：打包项目参考资源： 1. 创建一个Unreal项目 默认大家都已经成功安装好了Unreal Engine 5.2版本。如果没有的话，可以先去官网下载一个EPIC，然后从EPIC里下载一个Unreal Engine 5.2，推荐大家安装的时候选一个空间大一些的盘，最好放在固态里，这样启动可以快很多。
首先，在EPIC里启动安装好的Unreal Engine 5.2.
点击游戏，选择空白项目，取消勾选初学者内容包，这样可以少占一些空间，选择合适的项目位置，最好不要选择C盘，因为Unreal项目所占的空间都比较大，然后单击创建。
现在就创建好了一个空白项目，如下图所示。
2. 启用Pixel Streaming插件 单击菜单栏-编辑-插件，搜索Pixel Streaming，勾选后点击立即重启。
当重启完成后，出现像素流送按钮，说明插件启用成功。
3. 下载Unreal 5.2对应的Pixel Streaming Infrastructure 推荐大家直接从github上下载PixelStreamingInfrastructure最新版的，也可以打包项目，打包完成后里也是有的。
找一个空白目录，打开cmd，输入以下命令，确保已经安装过git。
git clone https://github.com/EpicGames/PixelStreamingInfrastructure.git clone完成后，目录是这个样子，未来也许会改变。
简单介绍一下，每个文件夹的内容。
配对器(MatchMaker)：该文件夹包含配置和运行配对器所需的所有脚本。
SFU：该文件包含配置和运行选择性转发单元(SFU)所需的所有内容。
SignallingWebServer ：这是必需像素流送元素的位置，例如信令服务器、Web服务器和前端。
Platform_scripts 目录是用于启动每个像素流送元素的所有脚本的常用位置。你可以在 cmd 和 bash 中分别找到Windows和Linux的脚本。 4. 创建一个Vue项目 创建vue项目的方式很多，通过手脚架或者命令行都可以。
创建一个新的Vue项目，然后通过vscode或者webstorm打开，目录大致如下所示：
安装UE5.2的PixelStreaming对应的前端依赖，一个是API库依赖，一个是UI库依赖。
npm install @epicgames-ps/lib-pixelstreamingfrontend-ue5.2 npm install @epicgames-ps/lib-pixelstreamingfrontend-ui-ue5.2 在views目录下，新建一个vue文件，命名为Player.vue：
代码如下：
&lt;template&gt; &lt;div&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1fe76698b95d8b5100b32622690112d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d88b815ae5d5ecd80c774b36ea4245dd/" rel="bookmark">
			c&#43;&#43;与python进行管道通信，内附详细代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因项目需求，需要实现python与c++间的通信。由于代码都在本地，因此采用管道通信的方式。
文章目录 一、管道简介 二、struct模块相关内容 三、代码demo 一、管道简介 管道是用于连接读/写进程的共享文件，pipe文件，本质上是内存中固定大小的缓冲区。管道通信的特点如下：
1.以流的形式读写：未满不读，已满不写，未空不写，已空不读，读后删除
2.同一时段只能单向通信，属于半双工通信
3.以先进先出（FIFO）方式组织数据传输
4.通过系统调用read()/write()函数进行读写操作
二、struct模块相关内容 此模块用于解析从c++端获取的数据，以及打包从python端发送的数据。 对齐方式：
格式符：
三、代码demo 下面是代码demo：
1.python创建管道，c++先写再读，python先读再写
python端代码：
import torch import win32file import win32pipe import struct from alog import MyAdd class Mypipe(): def __init__(self): # 数据内容 self.end_context = None # 初始化模型 self.model = torch.jit.load("model.pt") def pipe_init(self): # 创建管道 self.python_pipe = win32pipe.CreateNamedPipe(r"\\.\\Pipe\\JUECE1-1", win32pipe.PIPE_ACCESS_DUPLEX, win32pipe.PIPE_TYPE_MESSAGE|win32pipe.PIPE_WAIT|win32pipe.PIPE_READMODE_MESSAGE, win32pipe.PIPE_UNLIMITED_INSTANCES, 65536, 65536, 500, None) def pipe_connect(self): win32pipe.ConnectNamedPipe(self.python_pipe, None) print("python 管道链接成功！") def pipe_run(self): print("管道开始运行！") while(1): # 计算格式大小 formats = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d88b815ae5d5ecd80c774b36ea4245dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/519d9381b0235b7e01a472ea396b46f0/" rel="bookmark">
			分享mysql创建索引的3种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家应该都知道索引的建立对于MySQL数据库的高效运行是很重要的,索引可以大大提升MySQL的检索速度,下面这篇文章主要给大家介绍了关于mysql创建索引的3种方法,需要的朋友可以参考下
1、使用CREATE INDEX创建，语法如下： 1
CREATE INDEX indexName ON tableName (columnName(length));
2、使用ALTER语句创建，语法如下： 1
ALTER TABLE tableName ADD INDEX indexName(columnName);
ALTER语句创建索引，下面提供一个设置索引长度的例子：
1
2
3
ALTER TABLE t_user_action_log ADD INDEX ip_address_idx (ip_address(16));
SHOW INDEX FROM t_user_action_log;
3、建表的时候创建索引 1
2
3
4
5
CREATE TABLE tableName( id INT NOT NULL, columnName columnType,
INDEX [indexName] (columnName(length)) );
扩展：MySql 创建索引原则 1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/519d9381b0235b7e01a472ea396b46f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b6fb11be3ce5bb40670bc595f12a07/" rel="bookmark">
			kali系统渗透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用kali远程ssh时，如果不能的话 按照以下方法
┌──(root㉿kali)-[~]└─# mkdir ~/.ssh┌──(root㉿kali)-[~]└─# vim ~/.ssh/configHost *HostkeyAlgorithms +ssh-rsaPubkeyAcceptedKeyTypes +ssh-rsa msfconlole -q //进入马上发不显示内容，所以加个q
msf6 &gt; workspace -v //显示工作区详细信息
msf6 &gt; hosts //查看扫描结果中的主机
msf6 &gt; services -p 80 //查看扫描结果中80端口信息
1.网站目录扫描（Linux靶机)
第一步：查找辅助脚本，使用辅助脚本
msf6 &gt; search dir_scan //搜索dir_scan脚本（找枪）
msf6 &gt; use 0 //使用编号为0的脚本（端枪）
msf6 &gt; set rhosts 192.168.10.143 //设置攻击目标（瞄准）
msf6 &gt; run //运行脚本（开枪） [] Detecting error code
[] Using code '404' as not found for 192.168.10.143
[+] Found http://192.168.10.143:80/cgi-bin/ 404 (192.168.10.143)
[+] Found http://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b6fb11be3ce5bb40670bc595f12a07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4eda7625973db87e21850ba8beaabae/" rel="bookmark">
			树莓派安装python3.9以及pip换源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 安装python3.9 sudo apt update 安装编译Python需要用到的环境
sudo apt install -y build-essential zlib1g-dev \ libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libsqlite3-dev \ libreadline-dev libffi-dev curl libbz2-dev 下载Python源码
wget \ https://www.python.org/ftp/python/3.9.10/Python-3.9.10.tgz 解压压缩包，并进入该目录
tar xvf Python-3.9.10.tgz 配置 ./configure --enable-optimizations 编译（调用四核来编译，这一步很漫长，大概30分钟左右）
make -j4 安装
sudo make install 查看当前软链接指向的python版本
ls /usr/bin/python -l 删除原来的软连接
sudo rm -f /usr/bin/python 在/usr/bin/目录创建软连接 python，定向/usr/local/bin/python3.9 sudo ln -s /usr/local/bin/python3.9 /usr/bin/python 检查python版本是否是3.9 python --version 二. pip换源 pip有点像python环境中的apt-get,从服务器获得python开发用的第三方包
sudo apt install -y python-pip python3-pip 更新源：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4eda7625973db87e21850ba8beaabae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ffb2bc2e7a4ede20778b9284784817/" rel="bookmark">
			uniapp检测更新功能开发记录 安卓版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现思路
1、在登录页面（首次加载页面）onReady（根据项目配置的首次触发的生命周期中）进行版本校验
如果检测到版本不一致 则调用 updateApp 方法进行更新提示
plus.io.resolveLocalFileSystemURL 方法可以根据相对路径获取下载文件夹。
entry.removeRecursively 递归进行文件夹删除
plus.downloader.createDownload 下载最新的安装包
plus.runtime.openFile 安装包安装
下面时实现代码
updateApp() { let self = this uni.showModal({ title: '更新', showCancel: true, content: '检测到更新的版本，是否进行更新', confirmText: '更新', success: function(result) { if (!result.confirm) { self.goNextPage() return } try { // 先清除已经下载的所有的安装包 plus.io.resolveLocalFileSystemURL('_downloads/', function(entry) { //	entry.removeRecursively(function(entry) { var downTask = plus.downloader.createDownload( config.VUE_APP_BASE_API_HPJY + '/appVersion/app/download', {}, function(d, status) { console.log(status); //d为下载的文件对象 if (status == 200) { console.log(1); // 下载成功,d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57ffb2bc2e7a4ede20778b9284784817/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec0d8d642785012fc0a61883a37326e/" rel="bookmark">
			IP归属地API分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 各大网站和app都更新了用户IP归属地功能，但是如何获取IP归属地信息科难为了一些技术人员了，下面给大家分享最好用的IP归属地API，能够大大的提升了效率。
IP归属地API（IP66_ip归属地在线查询_免费ip查询_ip精准定位平台），根据IP地址查询归属地信息，包含国家、省、市、区县和运营商等信息。
IP数据云（IP数据云 - 免费IP地址查询 - 全球IP地址定位平台） 有很多免费API接口，利用这些接口可以帮你实现去开发出很多功能丰富，服务稳定的网页、APP还有小程序，无论是练手还是实战都是不错的选择。
接下来和大家分享一下接口的一些信息。
1. 接口说明
对外提供 IP 地址查询的服务接口
2. 接口方式
接口地址：https://api.ipdatacloud.com
请求方式
输出格式
字符集
HTTPS GET/POST
Json
UTF-8
3. 请求说明
字段名称
字段类型
是否必填
字段描述
备注
IP
String
是
IP地址
同时支持 IPV4 和 IPV6
KEY
String
是
产品密钥
根据所选产品分配，权限校验用
3.1 请求参数
https://api.ipdatacloud.com/v2/query?ip=140.224.61.98&amp;key=2ff42e7ea14811edb158
4. 输出说明
4.1 输出参数
字段名称字段类型字段描述备注codeString状态码参考附录 4.2 状态码messageString状态信息请求成功时内容为successdataJsonObject输出信息请求失败时内容为空，参考 4.1.1 data 输出参数 4.1.1data输出参数
字段名称字段类型字段描述备注locationJsonObjectIP归属地数据详情参考4.1.1.1 location输出参数scenesJsonObjectIP应用场景数据详情参考4.1.1.2 scenes输出参数riskJsonObjectIP风险画像数据详情参考4.1.1.3 risk输出参数 4.1.1.1 location输出参数
字段名称字段类型字段描述备注versionStringIP类型continentString七大洲countryString国家country_codeString国家英文简写provinceString省份cityString城市districtString区县streetString街道longitudeString经度latitudeString纬度area_codeString行政代码ispString运营商local_timeString本地时间elevationString海拔weather_stationString气象站zip_codeString邮编is_proxyString是否代理当无代理时为空proxy_typeString代理类型详情参考proxy_type说明city_codeString国际直拨电话和区号asnStringasnusage_typeString应用场景详情参考usage_type说明risk_proofJsonObject风险证据详情参考risk_proof说明risk_tagJsonObject风险标签详情参考risk_tag说明 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/140/">«</a>
	<span class="pagination__item pagination__item--current">141/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/142/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>