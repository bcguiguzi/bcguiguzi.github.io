<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b5c8fc9a7475169c7eb5789eeceb3b/" rel="bookmark">
			Latex修改后发现参考文献编号不连续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 修改论文，加了一些新的引用参考文献的文字，然后去掉了一些之前有参考文献的文字，发现参考文献编号不连续， 如下所示。这样肯定不行
方法 这是由于编译过程中用了之前的缓存的辅助文件造成的，我们只需要删掉这些辅助文件，让他从新开始编译就好了。
删除 如下文件，重新编译即可
.blg
.aux
.bbl
.log
.out
.gz
结果 从新编译的界面
序号已经正常了
后记 突然发现只需删除 .blg文件就会重新编号了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb5e2ec30f32f9b61e49452b276ed358/" rel="bookmark">
			Windows程序设计——简单记事本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总体框架目录 一、简介二、记事本功能简介与实现（一）新建文件（二）界面设计（1）MenuStrip（菜单控件）（2）ToolStrip（工具栏控件）（3）RichTextBox（多格式文本框控件）（4）StatusStrip（状态栏控件）（5）OpenFileDialog（打开对话框）（6）SaveFileDialog（保存对话框）（7）FontDialog（字体对话框）（8）Timer（计时器控件） （三） 代码编写1、多格式文本框代码（RichTextBox）2、 菜单代码（1）【文件（F）】菜单（2）【打开（O）】菜单项（3）【保存（S）】菜单项（4）【另存为（A）】菜单项（5）【退出（X）】菜单项 3、【编辑（E）】菜单4、【格式（O）】菜单（1）【自动换行（W）】菜单项（2）【字体（F）】菜单项 5、【查看（V）】菜单（1）【工具栏（T）】菜单项（2）【状态栏（S）】菜单项（不是必须的） 6、【帮助（H）】菜单具体实现关于记事本 7、工具栏代码8、计时器代码 三、添加一些有用的功能1、新建一个窗口2、导入其他txt文件3、清空4、查找和替换（1）设计窗口（2）代码编写 四、总结五、链接 一、简介 介绍如何使用Visual C#设计一个Windows应用程序——记事本，通过本章的学习，可以进一步掌握MenuStrip（菜单）、ToolStrip（工具栏）、RichTextBox（高级文本框）和StatusStrip（状态栏控件）等控件的使用，以及如何使用CommonDialog（公共对话框）实现对文本的存取、格式设置等操作。
二、记事本功能简介与实现 记事本是一种常用的软件，在微软的Windows中，自带了一个记事本软件，Windows 下的记事本软件如图1所示。
我们首先会实现一些简单的功能比如下图：
实现完这些功能后我自己还从其他文章里学习加入了一些我自己觉得比较有用的功能：替换、查找、清空所有内容、导入其他txt文件的内容。接下来先介绍上图的功能实现。
（一）新建文件 新建一个Windows窗体应用程序，并命名为“Notepad”。本节介绍记事本程序的界面设计以及界面上各控件的属性设置。
1.打开VS单击 文件→新建→项目
2.选择 模版 → Visual C# → windows→ windows窗体应用程序 在下面的名称写Notepad
3 更改窗体名称 单击窗体， →右下角属性→text 修改为“记事本”如图所示
size和起始位置根据自己情况随意设置。
（二）界面设计 新建好“Notepad”项目后，定位到记事本程序的窗体设计器窗口，然后依次在窗体上放置以下控件（各1个）：
（1）MenuStrip（菜单控件） 单击窗体左边会出现工具箱→ 找到menustrip →拖动到窗体中
单击菜单栏→右下角属性→修改Name属性为“mnusNotepad”
单击 输入【文件（F）】、【编辑（E）】、【格式（O）】、【查看（V）】和【帮助（H）】如图所示
设置【文件（F）】、【编辑（E）】、【格式（O）】、【查看（V）】和【帮助（H）】的属性→单击【文件（F）】、【编辑（E）】、【格式（O）】、【查看（V）】和【帮助（H）】找到对应的属性窗口，按照以下表格进行设置
（2）ToolStrip（工具栏控件） 单击窗体左边会出现工具箱→ 找到“ToolStrip” →拖动到窗体中
单击工具栏→右下角属性→修改Name属性为“tlsNotepad”如图所示
右击工具栏→ 插入标准项 出现如图所示
右击工具栏→ 编辑项 可以看到我们的按钮成员 在这里我们可以删除或者增加，为了新手学习，我们只设置几个简单的功能（新建，打开，保存，剪切，粘贴，复制）。其它我们不再设置。
为了看起来直观，这个我们不更改它们的Name属性了，接下来根据程序本身的需要，对添加的标准工具子项进行增加和删除，在设置好各子项的属性即可。
这样设置为，实现这种效果：
（3）RichTextBox（多格式文本框控件） 单击窗体左边会出现工具箱→ 找到“RichTextBox” →拖动到窗体中
单击工具栏→右下角属性→修改Name属性为“rtxtNotepad”如图所示
Anchor属性选择“Top，Bottom，Left，Right”，这样当窗体大小改变时，RichTextBox控件的大小也会跟着改变，如图2.1所示。
（4）StatusStrip（状态栏控件） 添加StatusStrip控件，将其Name属性设为“stsNotepad”，将Dock属性设为“Bottom”再将Anchor属性设为“Bottom，Left，Right”。然后单击右边的按钮，打开【项集合编辑器】对话框，如图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb5e2ec30f32f9b61e49452b276ed358/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8016399f21a316d073916cb9310783fa/" rel="bookmark">
			尝试搭建Chargpt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您位于中国大陆，建议使用清华镜像站下载 Python 和 TensorFlow 等软件包，以加快下载速度。同时，在安装和配置 TensorFlow 时，还应注意考虑一些特殊的网络连接和环境设置问题。
以下是国内搭建 CharGPT 的基本步骤：
下载代码：利用 Git 客户端从 GitHub 上 Clone CharGPT 开源项目到您的本地计算机中（https://github.com/CLUEbenchmark/CharCEP）。 安装并配置 Python、TensorFlow 和其他依赖项：在终端上运行以下指令： sudo pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple 这将会通过 Tsinghua Pipy 镜像站安装所需模块。而且因为 tensorflow 模块相对较大，建议单独执行 : sudo pip install tensorflow==1.15.0 -i https://pypi.tuna.tsinghua.edu.cn/simple 下载数据集：同样地，直接打开官方网站，并下载 CharCEP 数据集，并将其解压缩到 data 文件夹中。 训练并验证：针对数据集，利用 train.py 脚本提交训练任务，并检查每个 epoch 是否提升了验证损失值。确保训练过程没有任何错误或异常情况发生。可以按以下方式启动训练过程： CUDA_VISIBLE_DEVICES=0 python train.py \ --model_name gpt_char_ce_p \ --do_train True \ --use_tpu False \ --tpu_name None \ --num_epochs 20 \ --batch_size 32 \ --gpu_index 0 \ --dropout_rate 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8016399f21a316d073916cb9310783fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66a07b2cce0896507c2479275ee3fc53/" rel="bookmark">
			Android Studio解除全局搜索100条限制及ide.usages.page.size找不到解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在2021.2及以后设置全局搜索结果不限制为100找不到ide.usages.page.size 解决办法，其实另有设置，在settings中找到Advanced Settings即可解决：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc57b259cb039136a58eb360dc22ee77/" rel="bookmark">
			SLB负载均衡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 负载均衡SLB1 SLB定义2 工作流程3 基础架构4 功能概述5 SLB算法解析6 产品优势7 应用场景8 组成部分8.1 负载均衡实例Load Balancer8.2 监听Listenr8.3 后端服务器 Backend Server 9 实例规格9.1 性能共享型实例9.2 性能保障型实例 10 SLB监听11 会话保持12 后端服务器13 SLB健康检查14 SLB证书管理14.1 证书格式14.2 访问控制 15 SLB使用限制16 SLB产品计费17 SLB与其他产品 负载均衡SLB 1 SLB定义 是将访问流量根据转发策略分发到后端多台云服务器ECS实例的流量分发控制服务
负载均衡扩展了应用的服务能力，增强了应用的可用性
2 工作流程 通过设置虚拟服务地址，将添加的同一地域的多台ECS实例虚拟成一个高性能、高可用的后端服务池，并根据转发原则，将来自客户端的请求分发给后端服务器池中的ECS实例
3 基础架构 集群部署
提供四层传输层 TCP UDP协议
提供七层应用层 HTTP HTTPS协议的负载均衡
可实现会话同步消除服务器单点故障，提升冗余，保证服务的稳定性
4 功能概述 协议支持：四层和七层协议的负载均衡
健康检查：自动屏蔽异常状态的ECS实例，等正常后再解除
会话保持：将同一客户端的会话请求转发到同一台后端ECS实例
调度算法：支持轮询 加权轮训WRR 加权最小连接数WLC 一致性哈希CH(7层不支持)
证书：PEM格式的证书
URL转发：支持按用户访问的域名和URL来转发流量到不同的虚拟服务器组
访问控制：支持添加黑名单和白名单，控制访问
支持内网和外网类型的负载均衡
结合监控，可查看负载均衡的连接数、流量等信息
5 SLB算法解析 轮询 后端ECS服务能力相同时，将请求依次分发给后端ECS，避免分发不均导致其中一台提前饱和
加权轮询 后端ECS服务能力不同时，根据服务能力不同按权重分配请求，保证后端ECS利用率保持在相同的级别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc57b259cb039136a58eb360dc22ee77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12ddfb9d36d2fa7091207256b9bd34c8/" rel="bookmark">
			UUID无处不在，你就是唯一（2023.4.16）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		六种语言生成UUID 2023.4.16 引言1、UUID简介2、UUID格式和编码3、UUID各历史版本4、UUID代码具体调用实现4.1 C# 生成UUID4.2 Java 生成UUID4.3 Python 生成UUID4.4 C++ 生成UUID4.5 C 生成UUID4.6 JavaScript 生成UUID（较为实用）4.6.1 控制台运行（浏览器）4.6.2 控制台运行（Node TestUUID.js） 5、总结 引言 全球数字化浪潮滚滚而来，各行各业无时无刻不在与数字打交道，万事万物或被牵扯和囊括其中。数字（Digit or number）作为一种简单快速的识别代码，深受开发者和广大用户的喜爱，在以下诸如此类的众多场景中被广泛使用：
（1）各个国家居民身份的唯一标识（ID Card）
（2）全世界生产的所有电脑，每台电脑都有着唯一的序列号（硬件MAC地址）
（3）各大手机厂商为用户分配的识别号，如（苹果手机AppID、华为手机HUAWEI_id）
（4）全球通信运营商为用户分配的移动号码（8614879421684）
（5）互联网为政府机构、大学校园教育、企业单位、个人用户都分配了唯一的IP地址，从广域网（WAN）到局域网（LAN），从IPv4到IPv6，公网环境下寄托在域名服务器DNS中的域名地址
（6）银行等业务部门为客户办理的业务单号、账单流水、卡号等
(7) 世界上所有英文期刊发表的论文的唯一标识，如（DOI）。
假如存在这样一个问题→从全球数十亿人口中寻找满足特定条件的某一个人，那么我们该如何去做这件事情呢？
思路一：世界本无序，但人们可以定义规则生成秩序，对几十亿人口按照阿拉伯数字编号并排序，寻找某个人就相当于获取该人物的编号，但是数字的存储位数显著增加会给计算机存储带来巨大挑战，因为人处于社会当中，伴随复杂多样的关系，导致属性关联、各异，海量信息无法仅仅依赖于数字；
思路二：为所有人口分配互不重复且唯一的识别码，这个识别码可以是数字、字母、符号以及它们的组合体，但需要统一管理。
思路三：结合思路一和思路二，考虑归纳分组、分门别类的思想，采取分而治之，从国家到地区、城市、县、乡、村，正如域名分配一样，从顶级、中级到低级一样，采用分层分级的思路实现，便于提高处理效率，缩短计算时间。
前两种思路无形中都与数据库密切相关，数据库的规模可大可小，查询检索速度可快可慢，主要取决于查询条件和数据量的大小；第三种思路正如金字塔、树等结构，自上而下，分门别类，扩展延伸，分层分级，较为灵活，当然比较符合现代科学技术的发展、计算机的存储方式、数据库设计模式等理念。当然大家如果有好的想法，欢迎在评论区各抒己见，畅所欲言呀！✨✨✨
1、UUID简介 UUID的全称为（Universally Unique Identifier）通用唯一标识符，它出现的目的是让分布式系统中出现的一切元素都具有唯一的辨识，而不需要根据中央控制端来指定辨识资格，即出生便具有独特性、唯一性和有效性。下图为Github上的uuid，已然收获了13k+的star数量，足见其深受广大开发者和工程师的喜爱。
2、UUID格式和编码 3、UUID各历史版本 如果想要进一步了解UUID是如何生成的，可以参考UUID标准和维基百科上的UUID介绍。UUID具有多个版本且各个版本具有不同的算法和应用范围，分别为基于时间的UUID、DCE安全的UUID、基于名字的UUID（MD5）、随机UUID和基于名字的UUID（SHA1）。总的来说，各个版本的发展都是为了保证唯一性、尽可能避免冲突同时提高生成效率，基本是与时间、MAC地址、域名、URL相关或随机生成。
Version 1 UUIDs are generated from a time and a node id (usually the MAC address); version 2 UUIDs are generated from an identifier (usually a group or user id), time, and a node id; versions 3 and 5 produce deterministic UUIDs generated by hashing a namespace identifier and name; and version 4 UUIDs are generated using a random or pseudo-random number.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12ddfb9d36d2fa7091207256b9bd34c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e654e3b47e2caa1918535bff4445f6/" rel="bookmark">
			【JavaEE案例】spring中的Bean的管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【案例介绍】
（1）Bean的装配方式之基于注解的装配。
（2）Bean的生命周期。
【案例实现】
创建项目 引入相关依赖：在pom.xml文件中加载Spring依赖包。 &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;userManager&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 1.1 在src/main/resources目录下创建applicationContext.xml，在该文件中引入Context约束并启动Bean的自动扫描功能。
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 使用 context 命名空间 ,在配置文件中开启相应的注解处理器 --&gt; &lt;context:component-scan base-package="com.itheima" /&gt; &lt;/beans&gt; 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90e654e3b47e2caa1918535bff4445f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3072e0e951443bcd7d9cd724b166106e/" rel="bookmark">
			一些小白需要的git命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一些llw需要的git命令 怎么建一个仓库git init即可！ 加文件到仓库，但是没提交：git add 文件名字 怎么提交到仓库 git commit -m “我大佬要提交啦”
git push -u 远程仓库的别名 本地分支名字:远程分支名字
清除自上次git add后的本次修改 git checkout 文件名字 查看自上次git add后的本次修改 git diff 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e61d82d3374d9ca6970484673339b8e/" rel="bookmark">
			【nnUNet】CUDA10.1安装nnUNet框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python3.6+pytorch1.6+cuda10.1
问题
由于nnUNet框架需要pytorch1.6以上版本，而cuda版本为10.1,使用如下语句安装
conda install pytorch torchvision cudatoolkit=10.1 -c pytorch 导致默认安装的pytorch为1.4，所以需要指定安装的pytorch版本。
1.安装Anaconda
上传下载的anaconda到服务器，cd到需要安装的文件夹，运行如下命令
bash Anaconda3-2019.10-Linux-x86_64.sh 修改安装目录，直接输入想要安装的位置路径
2.安装pytorch
创建环境
conda create -n pytorch python=3.6 激活环境
source activate pytorch 安装pytorch1.6
pip install torch==1.6.0+cu101 torchvision==0.7.0+cu101 -f https://download.pytorch.org/whl/torch_stable.html 执行以下语句检验pytorch是否安装成功 import torch print(torch.__version__) torch.cuda.is_available() 显示如下表示安装成功
3.安装NVIDIA-Apex：
在你用来安装环境的目录下打开终端
git clone https://github.com/NVIDIA/apex； 出现‘fatal:unable to access’错误重新执行语句即可
cd apex 进入你刚才下载下来的apex文件夹里面执行语句
python setup.py install --cuda_ext --cpp_ext 安装成功
4.安装hiddenlayer
pip install --upgrade git+https://github.com/nanohanno/hiddenlayer.git@bugfix/get_trace_graph#egg=hiddenlayer(没有换行，这是一行代码) 5.安装nnUNet
在home下创建nnUNet_sd_loss文件夹(自己定)，在这个文件夹内打开终端，输入如下命令
git clone https://github.com/MIC-DKFZ/nnUNet.git cd nnUNet pip install -e .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e61d82d3374d9ca6970484673339b8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/237c2c9308d23ffc33eac4bf92d1ef62/" rel="bookmark">
			Ant Design 引入vue2项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ant Design 引入vue2项目 1.安装指定版本的ant-design-vue UI框架（当项目为vue2项目时） npm i --save ant-design-vue@1.7.8
2.vue2项目引入 在main.js中
import Antd from 'ant-design-vue'; import App from './App'; import 'ant-design-vue/dist/antd.css'; Vue.use(Antd); Ant Design 引入vue3项目 环境介绍 vue3+ts+ant-design-vue
使用组件 # 安装 # $ npm i --save ant-design-vue 全局完整注册 全局完整注册
import { createApp } from 'vue'; import Antd from 'ant-design-vue'; import App from './App'; import 'ant-design-vue/dist/antd.css'; const app = createApp(App); app.use(Antd).mount('#app'); 1.form表单 api:
1.labelCol labelCol : label 标签布局，同 `&lt;Col&gt;` 组件，设置 `span` `offset` 值，如 `{span: 3, offset: 12}` 或 `sm: {span: 3, offset: 12}` 例如:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/237c2c9308d23ffc33eac4bf92d1ef62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3afb78eca253c6eb9a4ee952253b335/" rel="bookmark">
			QNX7.1 交叉编译开源库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载QNX7.1 SDK并解压
ITL:~/work/tiqnx710$ ls -l
总用量 16
drwxrwxr-x 4 xxx4096 1月 28 13:38 host
-rwxrwxr-x 1 xxx 972 1月 28 13:38 qnxsdp-env.bat
-rwxrwxr-x 1 xxx 1676 1月 28 13:38 qnxsdp-env.sh
drwxrwxr-x 3 xxx 4096 1月 28 13:38 target
xxxITL:~/work/tiqnx710$
2.编译protobuf-c-test
cd protobuf-c-test
mkdir out
cd …
sudo apt install autoconf libtool
source …/…/tiqnx710/qnxsdp-env.sh
./autogen.sh
make -j8
make install
zlog编译类型步骤：
zlog
git clone http://xxxx/zlog.git
cd zlog
git checkout tag-1.2.15
./autogen.sh
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3afb78eca253c6eb9a4ee952253b335/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b0a9fe2f81fb20df6dceae642b7dc73/" rel="bookmark">
			flink任务处理下线流水数据，数据遗漏不全（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flink任务处理下线流水数据，数据遗漏不全（二）
居然还是重量，做一个判断，如果是NaN 就直接获取原始的数据的重量
测试后面会不会出现这个情况！
发现chunjun的代码运行不到5h以后，如果网络不稳定，断开mqtt链接以后，就会永远也连接不上了，更短命！！
分析原因：
1、配置mqtt服务器的信息，配置设置选项
2、设置回调函数，当数据来的时候，处理数据；当失去连接的时候，先关闭连接，然后尝试连接数据，但是没有订阅主题，所以我觉得是这个原因
之前的代码为什么有问题
我觉得是没有设置数据是否连接上就中断连接了，所以失败，其次是主题重复了！！
2023-4-08 21:25分处理
问题：chunjun的的确是不会漏数据了，但是运行不了多久以后mqtt中断了，死活连接不上
2023-04-14日，成功解决这个问题！！！
原因：1、在高并发度的情况下，即使用时间戳来设置clientid也会重复，加一个随机数！
2、数据量太大，处理的程序太慢了导致的，增加并行度
贴上我的代码！
package org.example.mqtt; import com.alibaba.fastjson.JSONObject; import lombok.Data; import lombok.NoArgsConstructor; import org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction; import org.eclipse.paho.client.mqttv3.MqttClient; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import java.util.concurrent.BlockingQueue; import java.util.concurrent.SynchronousQueue; /** * MQTT客户端订阅消息类 * * @author zhongyulin */ @NoArgsConstructor @Data public class JsonMqttSource extends RichParallelSourceFunction&lt;JSONObject&gt; { //阻塞队列存储订阅的消息 public static BlockingQueue&lt;JSONObject&gt; queue; private String topic; private transient MqttClient client; public JsonMqttSource(String topic) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b0a9fe2f81fb20df6dceae642b7dc73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/573153847419b2301f5a7ac6e5b070c1/" rel="bookmark">
			SpringBoot异步任务及并行事务实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇介绍了原生Java如何实现串行/并行任务，主要使用了线程池 + Future + CountDownLatch，让主线程等待子线程返回后再向下进行。而在SpringBoot中，利用@Async和AOP对异步任务提供了更加便捷的支持，下面就针对SpringBoot使用异步任务需要注意的细节做一些分析。
1 SpringBoot异步任务基础实现 使用起来很简单，在启动类或配置类上加上@EnableAsync启动异步任务，并在需要异步调用的方法上加@Async，在注册Bean时就会生成该类的Proxy子类，也就是动态代理类，AOP会在代理类中重写并增强该异步方法。
1.1 配置异步任务线程池 SpringBoot自然也选择了线程复用，想要实现就需要使用线程池，可以先来看看默认线程池的配置。
ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); //配置核心线程数 executor.setCorePoolSize(8); //配置最大线程数 executor.setMaxPoolSize(Integer.MAX_VALUE); //配置空闲线程保留时间 executor.setKeepAliveSeconds(60); //配置队列大小 executor.setQueueCapacity(Integer.MAX_VALUE); //设置饱和策略：当pool已经达到max size的时候，如何处理新任务 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); 配置过线程池参数的小伙伴，一眼就能看到几个很不合理的点：
最大线程数为Integer.MAX_VALUE，创建线程过多会导致“oom:unable to create new native thread”。最长队列数为Integer.MAX_VALUE，队列堆积任务过多也会导致oom。饱和策略为AbortPolicy，队列满了直接抛异常，如果不catch程序直接爆炸。 综上，我们应该给SpringBoot指定一个线程池，并让异步任务执行时使用他，配置就不赘述直接放在下面。
//自定义Spring默认线程池 //ThreadPoolTaskExecutor vs ThreadPoolExecutor ： //ThreadPoolTaskExecutor是对ThreadPoolExecutor的进一步封装 //ThreadPoolTaskExecutor来源于Spring，ThreadPoolExecutor属于JUC //ThreadPoolTaskExecutor需要声明initialize，ThreadPoolExecutor不需要 @Bean("common") public Executor commonExecutorBuild() { log.info("Common Executor Building Start!"); //ThreadPoolExecutor executor = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, // UNIT, LINKED_BLOCKING_QUEUE, new ThreadPoolExecutor.CallerRunsPolicy()); ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); //配置核心线程数 executor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/573153847419b2301f5a7ac6e5b070c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0844f6a6dcdcec4a76bd6495aa7daddf/" rel="bookmark">
			求素数的方法（实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先记住一点，1不是素数也不是合数 试除法判断是否素数 bool check(int x){ if( x &lt; 2 ) return false ; for(int i = 2 ; i &lt;= x / i ; i++ ) if( x % i == 0) return false ; return true ; } 朴素筛法 找出从2到n的素数 primes存的是素数 cnt表示素数的数量 st表示是否为合数
int primes[N], cnt; bool st[N]; void get_primes(int n) { for (int i = 2; i &lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i + i; j &lt;= n; j += i) st[j] = true; } } 埃氏筛法 找出从2到n的素数 primes存的是素数 cnt表示素数的数量 st表示是否为合数
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0844f6a6dcdcec4a76bd6495aa7daddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/769aa0b34b88b8a021cc38ecf65df9c1/" rel="bookmark">
			点云到图像的投影
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://www.youtube.com/watch?v=S-UHiFsn-GI&amp;list=PL2zRqk16wsdoCCLpou-dGo7QQNks1Ppzo&amp;index=1 3D 点如何投影到图像像素平面 1. 利用lidar和camera之间的外参矩阵，将雷达坐标系下的点投影到相机坐标系下
外参矩阵是一个4x4的齐次旋转矩阵
2. 利用相机的内参矩阵，把相机坐标系下的点投影到像素平面
相机的内参，包含畸变参数，k1-k5;包含cx,cy,fx,fy
相机坐标系到像素平面的投影 世界坐标系的点投影到相机坐标系 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31e10c600dd198206ed4cdefd88c06f9/" rel="bookmark">
			TrimbleRealWorks点云数据预处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 我们知道，点云数据往往都是比较大的，如果直接加载到绘图软件或者建模软件中，会有些吃不消，影响绘图或者建模的效率，这时候，我们可以通过对点云进行预处理，来减少点云数据的容量，提高绘图或者建模的效率
Trimble RealWorks处理点云数据（一）之坐标转换
Trimble RealWorks处理点云数据（二）之点云切割
Trimble RealWorks处理点云数据（三）之点云抽稀取样
Trimble RealWorks处理点云数据（四）之点云外部分类
Trimble RealWorks处理点云数据（六）之点云数据格式转换
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3b6c2b4c2b2e2147edd66808f62835f/" rel="bookmark">
			【统计学习】归一化 or 标准化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		归一化 （Normalization）、标准化 （Standardization）和中心化/零均值化 （Zero-centered） - 简书
本文简述统计学中的数据归一化与标准化处理， 以及分别适用于哪种场景下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99f40388a027e436e96b583538e1fe41/" rel="bookmark">
			SpringBoot——使用ThreadLocal解决类成员变量并发线程安全问题!
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 在开发过程中，我们一旦在某个类中使用一个可变的成员变量，就会涉及到线程安全问题，因为我们的类对于其他依赖使用类来说，可能是单例注入的，这就会涉及到多个线程共享操作同一个变量问题。如何解决？
遇到线程安全问题，我们首先想到的就是使用锁，万物可加锁，只要不怕慢！我们通过加锁来实现多个线程并发访问操作问题，我加锁，你就得等我解锁后才能操作。但是众所周知，加锁，必定会在多线程并发访问时造成一部分线程阻塞等待，从而产生一定的性能影响。那除了加锁，有没有其他方法来避免？答案是：有滴！我们可以使用多种方式，下面我们娓娓道来~
ThreadLocal方式 介绍 ThreadLocal从字面理解就是本地线程，全称：Thread Local Variable。换句话说，就是当前线程变量，它是一个本地线程变量，其填充的是当前线程的变量，这个变量对于其他线程来说都是封闭且隔离的。如何实现变量隔离这一功能？ThreadLocal可以为每个线程创建一个自有副本，每个线程可以访问自己内部的副本变量来达到隔离效果，从而解决共享变量的线程安全问题。ThreadLocal变量是线程内部的局部变量，在不同的线程Thread中有不同的副本，副本只能由当前Thread使用，不存在多线程共享问题。ThreadLocal一般由private static修饰，线程结束时，可回收掉ThreadLocal副本。 案例 之前在SpringBoot—集成AOP详解（面向切面编程Aspect）中的AOP编码中也是用到了ThreadLocal进行starttime变量的存储。
源码 set方法 /** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the {@link #initialValue} * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99f40388a027e436e96b583538e1fe41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed77029c904220460c5276174c6130fa/" rel="bookmark">
			IDEA 报错 Package ‘java.util‘ is declared in module ‘java.base‘, which is not in the module graph
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 IDEA 中更改了 JDK 版本之后报错：Package 'java.util' is declared in module 'java.base', which is not in the module graph，项目中的所有 java.util 和 java.lang 包的代码全部带红色波浪线
解决方法：清理 IDEA 缓存：
File -&gt; Invalidate caches -&gt; select "Clear file system cache and Local history" -&gt; Invalidate and Restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0b023eecd366afc5bf0d2d59b9622f/" rel="bookmark">
			实用思维与职场技巧手册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		版权归作者所有，任何形式转载请联系作者。
作者：山水居士（来自豆瓣）
来源：实用思维与职场技巧手册
有几位老读者和咨询者希望我写一篇如何在社会中可以更好地生存、在工作中如何减少阻力、且有利于职场发展的思维模式（也可以说是思维习惯或技巧），最终动笔写这篇是因为在咨询中确实会发现很多年轻人对于以下这些思维模式和社会技巧是完全空白的、父母和老师也从未教过——不知该如何发力、如何避免职场陷阱，直接导致在社会中的被动困境。以我个人的经验看，在社会上生存是很有必要去掌握这些玩儿法与软工具的、就像上战场是需要枪和子弹一样；由于无法全部使用实例（有些敏感地带）、所以会借用一些小故事代替，希望能有所启发：
1、以现有的资源入门
刚进入一个行业、一家公司的时候很多东西都不懂、很多工具也不会用，不知道如何上手，等人带领也未必有前辈能手把手的教，这个时候就要靠自己已有的资源（信息/工具/人）来搭建入门的桥梁：不会销售话术就去竞品机构咨询录音（客户为你的问题不知道怎么回答就复制粘贴去问自家或竞品的在线客服）、不知道怎么写文案就上竞品公司的网站上去扒然后调整顺序变换词汇、不知道怎么用Axure画UI就拿word排版、不知道怎么使用EDIUS处理专业音频视频就先拿小程序做、不知道怎能使用Photoshop就拿PPT的模板先拼图、不知道如何设计宣传页就拿往年的活动页做参考……总之，拿已有的资源先干起来，上手后可以慢慢补充相关技能的短板。
2、迭代思维
我们很难一上来就做一个大而全的完美产品，都是先上一个雏形然后根据市场需求与资源跟进再迭代下去。比如我写一篇文章，即使改很多遍、如果不发出去我也是不知道反馈如何或有没有问题的，经常就是写完先发，然后再改细节，有的时候可能过了好几天我才能发现文章的某个逻辑问题或需要补充信息的地方，这时候修改优化也来的及。同样，做新项目不会等到万事俱备了再启动，都是拿着一部分资源先推进、然后根据市场与用户的反馈以及预算的增加再一点点补足、优化、迭代。
3、避免简单归因
举例：这个季度业绩突然增长了150%，在季度复盘会上，每个部门的负责人都按照自己的认知与常识去解释增长的原因，CEO也通过总结大家的原因制订了下一个季度的投放策略与营销策略，然而季度结束后却发现并没有获得同样的业绩增长、后来又在第二年同季度运用了同样的策略也没有明显的增长。在职场工作中，我们总会听到一些“专业行话”，用这些对事物和人进行粗暴的简单归因、然后就冲动地采取行动，而没有因地制宜、因人而异地了解情况、制定相关策略，导致削减了不该削减的部门、制定了错误的投放策略、或修改了不该修改的产品体系或价格体系等等。
我们在日常中也经常会碰到类似的事情，例如对网络上的某个事件的解说因为符合自己的认知偏好、便简单地认为就是这个原因导致了这个事件，但随着调查的深入才看到不一样的原因、不但消耗了不少情绪与精力，还扭曲了自己的价值观念。我们习惯用一种简单的方式去归纳或者为事物打标签，这种思维习惯往往会被有心人利用以达到某种目的。
在与我们旁边人的日常沟通中，偶尔也会发生误解、出现矛盾，其深层原因可能并不像我们想象的那样表面，如果没弄清缘由就发生冲突，只会让双方彼此敌视而增加了解真实内情的难度；不如引发更大的冲突前、先让对方冷静下来，然后了解事情的来龙去脉再对其中的误解进行解释、并制定出避免再发生类似事情的方案，这样可能会更好些。
我们无法通过视频与数据看到事件的本质、就像我们无法通过钟表看到时间的本质一样——ta们只是利用我们认知的习惯与局限性去展示了想让我们认识的那一面而已。这个世界远比我们想象的要复杂很多，一个决策、一个事件背后往往有我们看不到的诸多因素组成，因此不要盲目地下定论、也无需按照表面的文字与数据信息在某一认知维度片面的解读、更不必听网络上过度的渲染，这些对个体没有任何实际意义、还会造成很多负面的心理影响。
4、多轮证伪思维
这种思维源于“幸存者偏差”，很多骗子就利用这一招来忽悠人，例如某人用短信群发或者是邮件群发信息，第一次给其中的2500人发某一只股票会涨的信息，然后给另外2500人发某一只股票会跌的信息，第二次再把押对宝的这2500人分成两拨，一拨发股票会涨的信息，另一拨继续发股票会跌的信息。然后不断地往下分，最后会有五个人是连续10次接到预测百分之百准确的信息，这个骗子在他们的心中那就是股神一样的人物，然后就把钱委托给这个骗子，骗子拿上钱就跑路了。当我们拿到一套投资方法论或一套经济趋势模型后，如果在实战中进行了几十次实验全部准确，是否能证明这些理论与模型的真实可靠性呢？答案是未必，因为当方法论或模型的外部环境发生变化或未曾考虑到的参数加入进来的时候，其预测的趋势可能会恰恰相反。
以我所在互联网公司为例，当时这个赛道有五六家头部竞争者，我们采用了各种方式去增加销售额并针对对手的营销策略实施应对方案，在两年多的混战过程中我们依次击垮了竞争对手并成功上市，然而这并不代表我司的策略是成功的第一因素，后来继续执行这些策略、业绩反而越来越差；之后在和这些公司内部人员以及投它们的资本方处了解到，有家是因为和投资方签了极为苛刻的对赌协议导致人为的资金断裂、而另一家公司则是内部管理团队调整导致某重要岗位人员带领团队离职，并不完全是因为我们策略的成功而击垮对手的。
在网络上这种案例也很多，如看到一个和自己各方面情况相似的博主因为出国留学收获了学位与当地的工作机会以及丰厚的收入然后也效仿此路径、花费了大量的时间精力金钱走出国门，毕业后发现即无法找到工作也很难留下，只能先找一份很普通的工作留下，之后从旁边一起打工的留学生处才了解到大部分选择这个专业的都很难找到工作、而此学科的留学生也都选择了沉默，当事人才意识到之前看到的那个博主只是个例，即“幸存者”，而自己只是诸多“不幸者”的一员。
多轮证伪思维就是不把自己对人对事的判断完全以信息茧房与主观偏好作为依据、不以之前的有限阅历或表面的调研数据就相信ta人所谓的成功路径或秘诀，而是去更广泛地收集数据与一手信息、聆听不同的声音、动态地按照现在的情况去研究去决策、并对未知的参数保持敬畏心，而不是单纯地去执行一套固定策略。从另一个方面看，如果某个人去宣传ta的某一获取财富的理论，那我们首先要明白ta的动机是什么，可能是瞎说、可能是有别的目的，一个真正财富自由的人是不会到处炫耀自己有多成功以及真实的赚钱方法的（没有人会引来对手和自己分蛋糕，下面第四点会具体讲），且所有属实的成功都是具有偶然性的，当环境变了、关键要素变了、实施的人变了，也就不具备复制成功的可能性了。另外，这些人在宣yang某个成功模式或某种路径时并不会考虑其倡导的理念对大多数参考者的实施难度与未来成本，这些都是我们要注意的。
5、打破思维盲点
举例：有一个非常牛的老偷教出了一个小偷，徒弟有一天把老偷拉到一家人的房子面前指着门上的锁说“师傅，您把所有的开锁技能都教给我了，可是这锁太先进实在打不开”，老偷会心一笑凑到徒弟耳边说“那是扇木门，直接踹开就是”。
拥有突破逻辑盲点的能力往往让你先人一步，事半功倍。我们在职场上经常会落入这类逻辑盲点中或被因为别人陷入在逻辑盲点中而一起跟着原地转圈。之前我司BD在和其他公司交换资源的时候，双方都认为要先获得对方提供的资源才能进行相等的资源反馈，由于僵持不下差点谈崩，我了解到这个情况后，问BD对方需要多少免费产品，BD说了一个量、我说还可以多给，我们的目的是要通过对方的客户群体了解我们的产品与品牌、并在激活相关产品后获得客户信息、接着便可以进行后期转化，给对方免费资源本身就是对我们有益的，何必只是关注对方能提供给我们的资源呢。
6、研究规律与bug
这个点不太好说，可能会让人有不太好的联想，借小孩子的例子说个职场上的事吧。小明小学时看上了一台掌上游戏机，如果靠父母给的零花钱想买这台游戏机需要攒很久。这天班里组织选生活委员，工作职责就是为班级提供桶装水的服务，流程是组织同学们缴费、在教务处购买水票、运水装水的工作，看起来很费事且还要收钱费力不讨好，但小明看到里面的规则漏洞，他接了这个工作，全班40人，一桶水10元，当水票消费到30张时便告知大家水票用完了、组织全班缴纳下一次水费，每次就有100元的“收入”。
了解此点并不是引导大家往错误的方向发展，而是陈述一个事实就是所有的规则中都有bug，有时能帮我们识破同事的陷阱避免承担相关责任、有时候也能帮我们轻松完成KPI（以不触犯规则的形式），举个相关例子：小明是销售人员，此岗位的KPI权重是购买产品的消费者数量权重为70%、销售额权重为30%，即数量权重更大，小明发现在公司销售业绩规则里有一条是“如果消费者更换或升级产品、在财务系统中也算一个新增消费者数量”（理论上即使只额外支付一元钱也是算的），因此小明会在销售中留意相关消费者的情况、在合适的时候帮助客户升级产品（补一点点费用），这就导致小明不仅可以轻松完成业绩考核，还在每次的销售排名中得到冠军（即使第二名比小明的销售额多很多）。再举个例子：小红公司的销售提成是8%，而竞品机构只有6%，小红发现这个差值，便联系到竞品的朋友，答应以7%回报对方资源的介绍（都是对方转化不了的资源），这样就额外增加了自己的销售额，也顺利完成了自己的业绩目标（在各通道中只要有价差或信息差就有利差可图）。除了工作，在日常小的地方我们也可以用到这种思维模式，比如有些文章在平台发不出去，我们可以一段一段地在日记中去输入，看在哪段发生了“锁文”，然后筛选出相关词汇，再加以修改即可。
任何体系、福利、制度、规则、程序中都存在规律与bug。当这些事物的规则在被制定的那一刻起时，它就注定会奖励那些找到它并在不犯规的前提下将规律与bug转化成业绩或利益的人；在发现bug后隐匿其存在越久，获利就越多，当有更多人知道后，也就是退出游戏的时候了，因为后面分利的玩家多了会趋向无利可图，且规则的制定者会堵上bug、并严厉地去惩罚那些不按规则运行的玩家——这也告诉大家一个道理，真正赚钱的机会不会传到你的耳朵里的，当你听到某个赚钱机会时大概率只有坑了。另外，通常某个市场的蛋糕就这么大，你努力、别人也努力，大多数人为了获得“奖励”都会加大投入，那结果就是每个人付出的越来越多、分得的蛋糕却越来越小——这和同行业机构在百度关键字竞价一个道理，当竞争对手增多后，花的钱多了，有效UV反而少了，ROI便更低。去找一个未被人发现的赛道去挖掘新的蛋糕，那样会更容易获得“奖励”。
7、用问题解决问题
先举个职场例子：小明因为老领导去了竞品机构而遭到公司高层的怀疑、担心他会跟着一起走或作为老领导的信息通报者。当老领导的其他下属都纷纷投简历找退路时，小明则按兵不动、等待时机，没过多久公司年度经营会开始，和老领导最不对付的公司coo提出对营销策略的重大改动，当时所有管理者都不同意（包括coo的嫡系也都持保留意见）而受影响最大的便是小明的团队；小明晚上临时针对这个情况修改了PPT，在第二天的继续会议中用数据和具体举措支持了coo的想法，不但获得了coo的认可还在之后因为支持掌权的coo而获得老领导原有的位置。
再举个家庭版的例子：小明家拆迁，小明希望尽快获得货币补偿、父亲则想要个天价补偿宁愿承担不确定风险去当钉子户，如果小明强迫父亲接受拆迁协议、那未来必然会活在父亲的埋怨中，如“你看xx家才多扛了一年就多要了五百万”，如果让父亲耗下去又不知道会不会鸡飞蛋打，看起来是矛盾无解的，但小明是个丁克、最近也在受父亲催婚要孩子的压力，小明利用支持父亲当钉子户的想法要求自己想去外地工作、以腾开空间让父亲和相关方周旋，小明父亲因为主要精力都在拆迁上随即同意，从此小明和父亲拉开了地理距离、免受父亲对催婚要孩子的要求，不但获得了几年的自由、在多年后即拿到了巨额拆迁费，也因为父亲老了管不了自己以及年龄问题让生育的事不了了之。
我们在工作和生活中经常会碰到解决不了的问题与矛盾，如果能正确地引入另一个矛盾或利益方借力打力便可使两个问题或多个问题对冲化解。
8、多专业学习思维
其本质就是一种多维组合思想，把不同的跨学科的知识汇集在一起，解决一个问题。 不同问题和学科所占权重不一样，综合起来考虑问题就更全面，正确概率就更高。尤其是涉及多部门参与的项目中，如果我们在职场中只用自己的专业背景或个体利益去认识与处理一项工作，往往很难去联合各部门的同事去共同推进——不同的专业背景看待同一个工作是完全不一样的。首先我们可以在日常的沟通中学习相关部门的技术与经验、使自己的业务能力更加全面，其次是了解其他部门同事的KPI考核表知道如何让对方也能在推进项目中顺利完成KPI（寻找到共同的利益点）、最后了解ta们的顾虑并知道如何利用以上信息引导ta们积极参与到新项目中。因此，只有了解了各部门的痛点与利益点，才能把各部门的资源与专业能力融入到工作中、以达到事半功倍地去推进工作，尤其对想做管理岗的同学，跨部门学习与思考是非常重要的，能将各部门的力量组织成合力才能有更大的晋升空间。
9、手段为目的服务
在我们从事一项工作时要明白所有规矩只是服务于目的的手段，通常会具备一个灵活变通带，寻找到这个灵活带，在不违背原则的情况下达成任务目标才是正确的。
反之，我们不能把手段当作目的，例如在工作中目的是通过把事办好已获得领导的肯定与赏识——这里做事是手段，获得领导的肯定是目的，如果为了把事办好却和领导或客户发生争吵与矛盾，那做这件事的目的就消失了、反而被手段所绑架、得不偿失。所以在实际工作中研究并练习说话方式（有标准化的speech pattern是最高效的）、以及领导在不同场合需要什么样的角色，都可以因地制宜、因人而异地去演其所需，目的是为了让自己获得更多的赏识与晋升机会。
生活中也可以用到这种思维模式，如健身本来是为了健康，但却因为不停地加重强度而使自己受伤，就是把手段当目的了。本来朋友间就一个事情讨论是为了增进情感，但却为了争论而争论起来、忘了大家在一起闲聊的初衷，最后弄得不欢而散，也是把手段当目的了。
和家人相处中也如是，有时候为了让父母/子女明白某个道理便在沟通中忽略了方式方法以及对方的性格年龄，导致了家人的抗拒、发生了争执，反而使家人更加听不进去、越说越错，这就是把说教这个错误的手段当目的了，忽略了如何能实现目标。老子说“善着果而已，不敢以取强。果而勿矜，果而勿伐，果而勿骄，果而不得已，果而勿强。”就是这个道理，要根据对方的情况而实施合适的策略，而不是在实施中忘了初衷与目的。
10、价值互换思维
在执行某一项工作时或和某一个人合作时，要先找到共同的利益点或双方认同的目标，要看清自己有什么价值是可以提供给对方，并确定对方认可自己所提供价值的稀缺性或持续稳定性，同时也要看对方所提供的价值质量，如果只是单方面输出或索取、不能形成正循环的流动与分享，一个小小的事件便会让合作关系停滞甚至以失败告终。
11、博弈中的道德高点
在工作中不能以不义去战正义，会输的很惨，因为无论是机构还是规则的制定者在道德的裹挟中必须要站在正义的一方，所以不能失了先机。如果失去了这一点，无论你多么有理或给公司创造多少利益都会成为被驱逐方。
12、强者思维
强者思维就是以“把事情办成”的角度去接受任务，并以此反推所需的资源与手段、甚至是超越常规去实现目标。举个例子，之前在参加培训的时候，培训师让五个组的成员（每个小组四人）用五分钟的时间叠出尽可能多的飞机、如果能叠出五百个便算胜利，第一次各组叠出的飞机差不多，都是几十个，培训师让大家继续第二轮、第三轮…大部分小组成员发现五分钟叠出五百个纸飞机是不可能的都有些放弃的表现；随着挑战次数的增加、大家叠出的飞机数量越来越多、飞机的样子也越来越不整齐，后来某个小组成员发现教官在验证飞机的规格时并没有明确的指出，便告诉了组员们这个点，然后在最后一轮挑战中大家开始批量把纸裁成三角形，很快就裁出了五百只所谓的“纸飞机”、获得了胜利。这个并不是教大家取巧，而是说在职场中大部分的工作都是有挑战和难度的，你去审视挑战的角度决定了是否能完成它、甚至超越那个目标，如果你按照战胜它的角度去思考、所得出的方法肯定和你按照无法完成的角度所得出的方法完全不同，关键是你以什么态度怎么认识它。如果我们看到一项任务、一个挑战或一个业绩目标只是考虑它的不可行性，则很难去推进了。
13、如何避免职场pua
1、如果领导给你画饼，我们也可以在相关项目上反向画饼，比如老板承诺给出X资源达到Y业绩，那你可以跟老板提出如果你给我7×X的资源我可以给你5倍Y的业绩并提供具体的方案，以反向画饼来换取更多的资源支持、团队的扩充、以及心仪项目的启动。2、当领导说你有问题、打击你的时候，告诉领导：您说的很对，我希望能像你一样优秀、专业，以后以您为师，也希望您能倾囊相授、我一定认真学习，我现在有几个问题想请教您，请您帮忙解答，然后开聊；以后ta只要打击你，你就问ta一堆问题，ta如果不想回答你就反向pua他，问是不是不想帮你进步。3、经常把你和别人对比，告诉领导：小明非常优秀，但想超越他是一回事、如何超越是另一回事，我现在具体需要的是xx、xx，和xx这几样具体的支持才可以和ta一样优秀，您能给予我这些支持吗？4、日常甩锅，要留好书面证据；如果给你很多工作要当面以请示的口吻确认优先级，你的工作流程的专业度是最好保护自己被刷锅的方法。如果以上不这些仍然没有改变对方的态度，就要尽快找下家了。
14、打造因人而异的语言模式
语言是利用人性实现目的的重要工具，它可以让领导看到个体的为人处世能力、可以增强同事们的配合度、也可以让原本麻烦的事情简单轻松地推进下去。在职场上无论是当面沟通（提现自己的重视、培养私下关系）、在线沟通（增加沟通效率）、email沟通（注重正式性、让领导了解进度、为未来纠纷留下证据），还是上传下达、谈判磋商，其实都在考验个体的语言艺术。把话说得好听容易，而能驾驭好语言把事情做成便需要有心地深度打磨了。有几个小技巧可以记一下：1、说话要准确不要夸大、注意副词的使用；2、不要啰嗦、简单明了；3、向领导描述问题时要给领导做选择题而不是简单题（比如领导交代的事情碰到麻烦，可以给出ABC等方案让领导选择，而不是把问题描述一遍等待领导解答）；4、说话注意边界、不要让旁人尴尬；5、说话不能说绝，要给自己留有周旋的余地；6、所谓贵人话语迟，如果别人问的问题没想好怎么回答或不知对方的意图，可以通过反问来争取时间或确认对方问题的真实目的；7、避免因不同立场而争执，要看沟通的目的是什么来反推所说内容，根据对方的情绪、状态、对应地去调整自己的语速、节奏和表达方式；8、对于比较敏感的事情，说话不要留下痕迹、避免未来授人以柄；9、正所谓“君不密则失臣，臣不密则失身，几事不密则害成。是以君子慎密而不出也”，不该说的就要学会不说。
语言能力在谈判中、升职加薪中、处理矛盾与人事纠纷中都是重要的杀手锏。反观之，我们旁边会碰到一些说话很呛的、善于雄辩的、得理不饶人的同事，TA们往往止于中基层，只能被领导利用当枪使；这类同事很难有更好的发展（除非有其他背景与资源），因为会为老板树敌，所以即使忠诚、有能力，也不会被重用；而且这类人在职场上很难有合作伙伴，没有优秀的人愿意和不会说话的人为友，就是怕招惹来麻烦或因其树敌。因此，如果想往高处走、交到更多战友，还是要注意嘴上留三分余地，言谈和善方是大才。
15、把公司当成自己的创业平台
在认知中，我们在工作中所处的位置往往是被动的，如果我们能化被动为主动，将公司视为自己的无成本的创业平台或不用交学费反而有收入的学习平台，往往工作起来会更加积极和有冲劲——拿着公司的资源与金钱去打磨自己的能力与操盘经验、让公司成为失败与成本的承担者、让自己在大量的实战尝试中摸索出成功的经验并把公司的人脉与资源转化成自己的人脉与资源。如果能这样去操作，职场就变成了自己攀登高峰的垫脚石，心态、动力以及收获则会大不相同。
16、聚德为用
在公司中要时时为自己立德——多给予别人力所能及的帮助、不甩锅或牺牲他人利益为自己加分、营造良好的个人口碑等等。当把这种积累从量到质变后便会形成潜在的助力，无论是升职加薪、推进项目，还是优先排队开发、财务审批速度、预算headcount支持，都会有不一样的效果。
从发展角度看，高层不单看你的业务能力、忠诚度、为人、管理能力，还要看你是否有为公司培养人才、聚拢人才的意识。公司真正提拔到核心层的人员都是能站在老板和公司利益角度去考虑问题的人。
17、培养职场属性人格
即不需要把真实的自己、真实的情感、真实的过往暴露在别人面前。除了学会包装自己、也要学会掩饰好自己，从而不被他人伤害或利用。和职场上的同事掏心掏肺、告诉别人自己真实的想法都是很危险的举措。
之所以在工作中出现很多精神内耗，主要原因就是把自己的价值观和情绪感受卷入在职场的利益纷争之中。在商言商，打造一种专业且社会化的状态去参与职场的挑战与人事关系会大大减轻对自己的精神内耗，处人待事越理性工作效率也会越高。
18、“出售自由权”的消费思维
这点之前写过，这篇也重新提及一下，除了知道如何挣钱还得学会如何花钱、不被商家把辛苦所得无意识地消费出去是非常重要的，这样留在财富池中的水才会越积越多：你拥有的每一分钱都是市场争夺的对象，这些财富是个体通往社会性自由的唯一通道（即不再以出卖时间、体力、脑力、健康去从事支持生存收入的工作），保存好这些财富才能实现自由，而随意消费则是在“变相出售自由”——成功卖给你服务或商品的人便获取了你这部分实现自由的权利。举例（数据仅为参考）：如果200万的存款利息收入可以使单身的个体不用再上班、享受三四线城市的自由生活，那购买一辆20万的汽车就相当于你赠予了卖家1/10的自由权，在未来的十五年中，每年的油钱、保险、税、保养、修理、停车费、洗车费假设是2万/年，十五年则是30万，那你等于共出卖了1/4的自由权在这辆车上。而在真实的生活中，消耗我们的往往是那些你并不在乎的小额产品，用这种“出售自由权”的思路来换算、你会发现那也是一笔不可忽视的数额。
任何让你产生购物欲望或诱惑你购物的通道要尽早屏蔽，无论是APP促销还是直播带货还是所谓的知识付费等等，这些通道的商业目的非常明显，无非是通过创造出来的需求、焦虑与效果来激发你的消费欲望，这类“需求”一旦在意识中产生，再去消除它便会造成很大精神内耗，因此不如一开始就屏蔽掉。
在生活中只买你客观需要的产品（注意那些成瘾性产品也不是我们真实需要的、且会对身体或大脑造成伤害），在购买前可以给自己十天到一个月的思考周期，分析到底是否真的需要某件商品或服务，有没有现成的或价格更低的替代品。
结语：写了这么多，希望能对职场小白们有所帮助。做事即做人、这个社会远比我们想象的复杂，如果想提高职场晋升的概率就要在工作中多观察、多学习，在自己羽翼未丰满前尽量避免暴露自己的弱点；要寻找正确的时机、以正确的方式、对正确的人展现自己的才华与能力才能得到好的反馈。知易行难，还是要在实践中去磨练才能把这些文字变成自己随意运用的思维与能力。如果能把这些思维模式融会贯通，且有机会进入高层操盘一家大型公司、或执掌资本层面的运作，当有了权力的加持便会衍生出更加炫丽的玩儿法与组合拳，那种能力与思维的变现数额就不是普通级别了…总之，万里之行始于足下，祝一切好🙏。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/157/">«</a>
	<span class="pagination__item pagination__item--current">158/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/159/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>