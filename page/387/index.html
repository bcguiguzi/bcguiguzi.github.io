<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81d76d2a3658446dbfbed69decbddfa9/" rel="bookmark">
			ASP.NET的数据控件repeater应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.0 Repeater控件概览 掌握数据绑定控件Repeater使用方式学会使用Repeater控件展示批量数据通过一个小案例来实现repeater的实际应用 2.0 什么是Repeater控件 Repeater 控件用于显示被绑定在该控件上的项目的重复列表
举一个栗子（如下图书的列表）：
Step1：首先让前端设计人员写一个列表页（这里我是通过Bootstrap实现的）
demo.html
&lt;!DOCTYPE html&gt; &lt;html lang="zh"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;书籍列表页&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/bootstrap-grid.min.css" /&gt; &lt;link rel="stylesheet" href="http://jrain.oscitas.netdna-cdn.com/tutorial/css/fontawesome-all.min.css"&gt; &lt;style type="text/css"&gt; .product-grid { font-family: 'Open Sans', sans-serif; text-align: center; } .product-grid .product-image { position: relative; overflow: hidden; } .product-grid .product-image a.image { display: block; } .product-grid .product-image img { width: 75%; height: auto; transition: all 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81d76d2a3658446dbfbed69decbddfa9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9013326bcc0ae4abc983ed9c39efa35d/" rel="bookmark">
			shell编程（十一）awk指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		awk指令 简介 一般情况下，awk指令是进行文件内容的列操作，与sed相反，sed主要进行文件内容的行操作，这两个指令就可以直接对一个文件进行快速的操作。
功能介绍 一般使用awk的列操作，默认情况下，是以空格进行分割。
首先创建一个文件内容如下：
My name is dhy This is a awk_test files Content is a,b,c,df 对文件进行awk的指令操作 awk '{print $1}' test.txt 打印test文件的首行（第一行）内容。
测试代码如下：可以根据用户输入进行打印 #!/bin/bash #author by dhy Num=$1 #echo $Num awk '{print $'$Num'}' 运行结果：
-F功能 -F功能可以自己定义分割标准
使用逗号分割，或者使用冒号分割等
由于只有第三行有逗号，所以按照逗号分割，前两行没有内容。
-v 设置变量 -v后可以跟变量名称，表示设置变量，在之后的操作中可以使用该变量。
上图设置了a变量，然后再使用打印的时候直接可以使用a变量进行打印。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87d217b9625cda898823b3e9c01f9c66/" rel="bookmark">
			深度学习--第10篇: Pytorch卷积层,池化层,线性层和激活函数层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pytorch卷积层,池化层,线性层和激活函数层 1. 卷积层 Conv Layer1.1 卷积 1d/2d/3d1.2 nn.Conv2d1.3 转置卷积 nn.ConvTranspose 2. 池化层 Pooling Layer2.1 最大池化 nn.MaxPool2d2.2 平均值池化 nn.AvgPool2d2.3 最大池化上采样 nn.MaxUnpool2d 3. 线性层 Linear Layer4. 激活函数层 Activation Layer4.1 nn.Sigmoid4.2 nn.tanh4.3 nn.ReLu4.4 其他激活函数 5. 正则化6. 批量标准化 1. 卷积层 Conv Layer 1.1 卷积 1d/2d/3d 定义: - 卷积运算：卷积核在输入信号（图像）上滑动，相应位置上进行乘加; - 卷积核：又称为滤波器，过滤器，可认为是某种模式，某种特征; - 卷积维度：一般情况下，卷积核在几个维度上滑动，就是几维卷积 功能: 卷积过程类似于用一个模板去图像上寻找与他相似的区域，与卷积核模式越相似，激活值越高，从而实现特征提取; 1.2 nn.Conv2d nn.Conv2d 功能：对多个二维信号进行二维卷积 主要参数(包含默认值)： in_channels：输入通道数 out_channels：输出通道数，等价于卷积核个数 kernel_size：卷积核尺寸 stride=1：步长 padding=0：填充个数 dilation=1：空调卷积大小 groups=1：分组卷积设置 bias=True：偏置 padding_mode='zeros': 填充模式 图像尺寸计算公式: 参数:
输入图片大小 Input*InputFilter(卷积核)大小 f*f空调卷积大小 d步长 Steppadding(填充)的像素数p，p=1就相当于给图像填充后图像大小为(input+1) *(input+1)输出图片的大小 output * output 注意: 对于计算不能得到整数的输出结果,采用np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87d217b9625cda898823b3e9c01f9c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4389e181820e32c0fb9d02d39394f4f0/" rel="bookmark">
			ArcMap学习笔记（九）叠置分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		叠置分析 前言介绍矢量数据叠置分析栅格数据叠置分析 前言 使用软件：ArcMap10.4.1中文版
如果出现侵权，请在评论留言，我会及时删除，谢谢。
介绍 叠置分析是将两层或多层地图要素进行叠加产生一个新要素及其相应属性的操作，其结果综合了原有个图层所具有的属性。由于数据结构不同，矢量数据与栅格数据的叠置方法是不一样的。
矢量数据叠置分析 （1）裁剪，是将目标图层与裁剪图层进行运算，输出结果为被裁剪后的目标图层，其属性不变。
导入数据，如下图：
打开ArcToolBox，找到裁剪，如下：
双击裁剪，并设置参数，如下：
效果图如下：
（2）相交，相交是以用来计算两个图层的交叉部分，落在公共区域的特征被保留，输出结果将继承两个层面所有属性。
导入数据：
找到相交工具：
完成之后右下角提示：
效果图如下：
（3）联合，联合是将两张地图并成一张图，输出结果将合并两层面的所有要素，并继承两层面的所有属性。
导入数据：
找到工具：
设置参数：
完成提示：
效果图：
（4）合并，合并是将几张地图(需为相同数据类型)并成一张图的过程，输出结果将合并两层而的所有要素，如果属性字段一致则将被保留。
导入数据，如下：
找到合并工具：
设置参数：
完成提示：
效果图：
（5）边界融合，边界触合消除具有相同属性的多边形边界(如图11-5所示)，实现数据分类。严格意义上说，边界融合分析只有一个图层参与分析，不属于叠置分析，但是.该分析方法也是常见的矢最地图分析操作。
导入数据：
找到边界融合工具：
设置参数：
完成提示：
效果图：
（6）空间连接，连接分析是将一个图层的属性数据表(目标表)按位置与另外一个图层的属性表(源表)进行属性连接。
导入数据：
原数据属性表：
找到工具：
设置参数：
完成提示：
效果图：
空间连接结果的属性表：
栅格数据叠置分析 这里，主要使用的是栅格计算器这个工具。在这里找到栅格计算器：
按照条件，输入合适的语句：
如有错误，请批评指正。谢谢！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578bf1b3141ab4a2d87d896f078f7277/" rel="bookmark">
			win10使用解惑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10使用解惑 1. 磁盘读写优化1.1 问题描述1.2 问题解决 -- sysmain1.2.1 sysmain的解决方法1.2.1 sysmian是做什么的 1. 磁盘读写优化 1.1 问题描述 最近，松松给家里的老电脑进行装机—— win10，开心地装机完成后，发现磁盘的读写一直很高，接近于100%，因此对这个问题进行解决。
1.2 问题解决 – sysmain 1.2.1 sysmain的解决方法 打开任务管理器，按照磁盘读取排序，发现占比最高的是 sysmain 服务win+r打开运行，然后输入 services，打开服务在服务中，搜索 sysmain，将该服务禁用然后重启电脑即可 1.2.1 sysmian是做什么的 SysMain服务是1809之后的版本才有的，原来这个服务之前叫superfetch服务，superfetch服务是“超级预读取”，这个服务是由XP系统中的Prefetch进化而来的。这个原理也很简单：Superfetch 内存管理机制会将用户可能使用的应用程序页面利用内存可用空间进行预加载；尽可能地避免系统发生从硬盘的页面调用，让应用程序最快速度开启。
但实际上，superfetch服务很占内存，并且对固态硬盘优化速度几乎没有，所以我们可以禁用SysMain服务。
参考文献：
[1]: http://www.winwin7.com/JC/15743.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a2f85768cdd3c5e8e334882223deac/" rel="bookmark">
			一个域名下部署多个vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在有这么一个需求，有两个 vue 项目， vue1和 vue2 ，如何让
http://www.baidu.com/vue1/ 作为 vue1 项目的根路径
http://www.baidu.com/vue2/ 作为 vue2 项目的根路径 也就是说两个项目互相不影响？
现在我们创建一个名为 vue1 的项目
以3.0+ 的 vuecli 创建的项目为例，我们需要在根目录创建这个 vue.config.js 文件
// vue.config.js module.exports = { // 假如想在同一个域名下配置多个项目,当前项目前缀是 /vue1 // 基本路径，如果是生产(也就是run build) 那么生成的 index.html 文件，引入的js，css路径前缀会是 /vue1/ publicPath: process.env.NODE_ENV === 'production' ? '/vue1' : '/', // 输出文件目录 outputDir: 'vue1', devServer: { // 是否自动弹出浏览器页面 open: true, // 设置为0.0.0.0则所有的地址均能访问 host: '0.0.0.0', // 端口 port: '8888', https: false, hotOnly: false, // 代理配置 proxy: { '/proxyApi_vant': { // 后端接口地址 target: 'http://localhost:8090', // 代理 websockets ws: true, // 允许跨域 changeOrigin: true, // 重写路径,把 proxyApi 去掉 pathRewrite: { '^/proxyApi_vant': '' } } }, } } 第一步： 配置 publicPath 里面的重点配置是 publicPath 这个配置，这个三目表达式的意思是， 如果是生产环境，（也就是打包的时候）以 vue1 为根路径， 也就是说通过这个配置 我们打包生成的 index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5a2f85768cdd3c5e8e334882223deac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c685854b0bd303f9d0aebb93fe036b98/" rel="bookmark">
			思科 计算机网络 第三章测试答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么类型的传输会使用数据链路层地址？选择一项：
A.远程传输
B.本地传送和远程传输
C.本地传送
D.使用路由器的远程传输
2.在数据通信行业中，开放标准为什么重要？选择一项：
A.它们是设备获取 Internet 访问所必需的。
B.它们消除了安全漏洞的威胁。
C.它们实现了来自不同供应商的软件和硬件之间的互操作性。
D.它们鼓励网络组织开发专有软件来维护其竞争优势。
3.发送给一组特定主机的消息属于哪种类型？选择一项：
A.静态
B.单播
C.动态
D.组播
E.广播
4.物理地址在 OSI 模型的哪一层进行封装？选择一项：
A.物理层
B.数据链路层
C.网络层
D.传输层
5.当所有设备需要同时接收同一消息时，使用哪个消息传输选项？选择一项：
A.duplex
B.单播
C.组播
D.广播
6.网络通信中使用的协议定义了下列哪三项要求来允许通过网络传输消息？ （选择三项。）选择一项或多项：
A.连接器规格
B.消息编码
C.介质选择
D.消息大小
E.传输选项
F.终端设备安装
7.哪个逻辑地址用于将数据传输到远程网络？选择一项：
A.目的 MAC 地址
B.目的 IP 地址
C.目的端口号
D.源 MAC 地址
E.源 IP 地址
8.如果主机上的默认网关配置不正确，对通信有何影响？选择一项：
A.该主机无法在本地网络上通信。
B.该主机可以与本地网络中的其他主机通信，但不能与远程网络上的主机通信。
C.该主机可以与远程网络中的其他主机通信，但不能与本地网络中的主机通信。
D.对通信没有影响。
9.下列哪个术语用于描述网络模型的任何层的数据片段？选择一项：
A.帧
B.数据包
C.协议数据单元
D.数据段
10.PC 移动到另一网络中时，PC 的 MAC 地址不会更改，因为 MAC 地址内嵌在 PC 的 网卡 中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c685854b0bd303f9d0aebb93fe036b98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ff76438cf5757644779e9970727ff7/" rel="bookmark">
			函数式编程思想&amp;Lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		函数式编程的思想 在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——强调做什么，而不是以什么形式做。
面向对象的思想:
​ 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.
函数式编程思想:
​ 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程
传统写法 当需要启动一个线程去完成任务时，通常会通过java.lang.Runnable接口来定义任务内容，并使用java.lang.Thread类来启动该线程。代码如下：
public class Demo01Runnable { public static void main(String[] args) { // 匿名内部类 Runnable task = new Runnable() { @Override public void run() { // 覆盖重写抽象方法 System.out.println("多线程任务执行！"); } }; new Thread(task).start(); // 启动线程 } } 代码分析 对于Runnable的匿名内部类用法，可以分析出几点内容：
Thread类需要Runnable接口作为参数，其中的抽象run方法是用来指定线程任务内容的核心；为了指定run的方法体，不得不需要Runnable接口的实现类；为了省去定义一个RunnableImpl实现类的麻烦，不得不使用匿名内部类；必须覆盖重写抽象run方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错；而实际上，似乎只有方法体才是关键所在。 3.3 编程思想转换 做什么，而不是怎么做 我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而不得不创建一个对象。我们真正希望做的事情是：将run方法体内的代码传递给Thread类知晓。
传递一段代码——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。
3.4 体验Lambda的更优写法 借助Java 8的全新语法，上述Runnable接口的匿名内部类写法可以通过更简单的Lambda表达式达到等效：
public class Demo02LambdaRunnable { public static void main(String[] args) { new Thread(() -&gt; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8ff76438cf5757644779e9970727ff7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c199c6efa2f333ca45e3343631809b6/" rel="bookmark">
			shell编程（十）sed指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sed指令介绍 sed指令是shell中常用常见的指令，一般使用sed来进行文本文件的处理。
一般sed指令是以行为单位进行处理文本文件的。
参数说明 a：新增，在指定行的下方进行新增行c：取代，取代n1到n2行之间的内容d：删除某些行i：插入，在指定行的上行插入一行内容p：打印s：替换，和vi中的替换语法类似，将内容替换成指定内容 增加操作 下方增加一行，两种方式 第一种方式
sed 4a'#######' testflie #第四行的下方插入一行 sed 4i'#######' testflie #第四行的上方插入一行 第二种方式
sed '/This/a ###########' testfile # 查找This字符串位置，在该位置下方插入一行 删除 sed '1,3d' testfile #将1到3行进行删除 取代 sed 1c'hello' testflie #将第一行取代为hello 替换 sed 's/HELLO/hello/g' testfile #将大写的HELLO替换为hello 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f5289f595ebce89cd4c1c2b548d833/" rel="bookmark">
			计算机网络原理笔记精整理 第四章 网络层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络原理笔记 第四章 网络层 网络层提供得两种服务1.虚电路服务2.数据包服务虚电路服务与数据报服务的对比 网际协议 IP1.虚拟互联网2.IP地址3.划分子网和构造超网4.IP地址与硬件地址5.**ARP &amp; RARP**6.IP数据报格式7.IP转发分组的流程 网际控制报文协议 ICMP互联网的路由选择协议（1）内部网关协议RIP(2)内部网关协议OSPF IP多播网络地址转换NAT 网络层提供得两种服务 网络层提供的两种服务
在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。
争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是网络层提供的两种服务
在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。
争论焦点的实质就是：在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？ ？
两种服务：网络层应该向运输层提供怎样得服务
虚电路服务数据包服务 1.虚电路服务 面向连接的通信方式
建立虚电路(Virtual Circuit)，以保证双方通信所需的一切网络资源。
如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点。
虚电路是逻辑连接
虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。
请注意，电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。
.
.
2.数据包服务 因特网采用的设计思路
网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。
网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。
网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。
.
.
尽最大努力交付的好处
由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。
如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。
采用这种设计思路的好处是：网络的造价大大降低，运行方式灵活，能够适应多种应用。
因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。
.
.
虚电路服务与数据报服务的对比 对比的方面虚电路服务数据报服务思路可靠通信应当由网络来保证可靠通信应当由用户主机来保证连接的建立必须有不需要终点地址仅在连接建立阶段使用，每个分组使用短的虚电路号每个分组都有终点的完整地址分组的转发属于同一条虚电路的分组均按照同一路由进行转发每个分组独立选择路由进行转发当结点出故障时所有通过出故障的结点的虚电路均不能工作出故障的结点可能会丢失分组，一些路由可能会发生变化分组的顺序总是按发送顺序到达终点到达终点时不一定按发送顺序端到端的差错处理和流量控制可以由网络负责，也可以由用户主机负责由用户主机负责 .
.
网际协议 IP 1.虚拟互联网 网络层中间设备
中间设备又称为中间系统或中继(relay)系统。
物理层中继系统：转发器(repeater)。
数据链路层中继系统：网桥或桥接器(bridge)。
网络层中继系统：路由器(router)。
网络层以上的中继系统：网关(gateway)。
注： 现在说的网关一般指的是路由器接口，网关地址一般习惯使用本网段第一个地址或者最后一个地址
虚拟互连网络的意义
所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。
使用 IP 协议的虚拟互连网络可简称为 IP 网。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f5289f595ebce89cd4c1c2b548d833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96923a8142792e386be0b1d1ba2ba170/" rel="bookmark">
			2020年的云计算概念和趋势
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 近年来，目睹了云计算从少数大型公司使用的晦涩技术发展为如今已被大约90％的企业普遍接受的模式转变。随着时间的流逝，一些云计算概念和相关行业的增长推动了这种广泛采用。我们将再次分析和概述最有可能在2020年定义云计算的概念。
本文将讨论：
2020年将推动云计算应用的云计算概念
云计算趋势有望跨多个行业
这些概念和趋势对集成云计算的企业的预期影响
2020年要考虑的顶级云计算概念 量子计算 –云计算的定义性和优点之一是在处理增加的工作负载时具有可伸缩性。随着数据分析和监视需求的增加，大规模仿真需求以及生成设计的需求，需要能够轻松处理大量工作负载的更快计算机。
量子计算是解决如何快速管理大型工作负载的一种解决方案。在2019年，IBM，Microsoft，Google和Intel等《财富》500强企业参加了开发具有无限敏捷性量子计算系统的竞赛。尽管已经取得了长足的进步，但是量子计算仍然只对少数人可用，就像今天的主流云计算技术是在2000年代初期一样。
预计2020年将成为利益相关者构建量子计算解决方案的转折点。据Tractica称，随着量子计算服务的不断发展，量子计算市场估计为1.16亿美元，并且在2020年将进一步增长。
边缘计算 –云计算的另一个主要功能或优势是对分布式基础架构的使用以及它如何驱动用户的可访问性。在工业制造中，利益相关者仍在努力将旧设备与云集成在一起，而这正是边缘计算，边缘硬件和边缘分析发挥作用的地方。
边缘计算概念以及实现低延迟的硬件和通信协议将在2020年继续发展。这包括边缘硬件的创新，在设计过程的最前沿具有美学，耐用性和功能性。
尽管通过云进行管理，但是大多数分析和实时计算都是在边缘进行的，因此需要功能强大的边缘设备。因此，供应商将肩负开发适用的边缘计算硬件的任务，从而提高工业云服务和边缘计算的采用率。
开源无服务器计算 –无服务器计算是一种云计算概念，服务器由服务提供商运行。在这种计算模型中，卖方根据客户的付款请求分配机器资源。这种按需付费的方法可以在购买云服务时更有效地利用有限的资源。无服务器计算也很灵活，可以根据对计算资源日益增长的需求进行扩展。
今天，有46％的企业使用无服务器计算，但是可用的无服务器计算选项仍然是专有的。这将客户锁定到特定的云供应商，但是越来越多的开源选项将改变一切。预计2020年将成为企业使用开源无服务器计算选项的成熟之年。
工业云计算的兴起 –云计算仍被专有的公共和私有云服务所支配，这些服务也已投入商业使用。尽管这些计算服务在计算资源和数据管理方面提供了灵活性和可伸缩性，但它们并未提供满足特定工业要求的专用服务或应用程序。这种现象导致采用混合和多云服务来满足行业需求。
最近三年见证了为企业提供特定于行业的功能的工业云计算服务的增长。金融服务业和制造业已从这些服务中受益，预计2020年将推动持续增长。开放源代码概念推动了工业云领域的增长，人们可以期望在这一领域有更多的供应商和选择。
区块链技术的广泛采用 –云计算和区块链技术以不同的方式自然适用。首先，云计算是一种访问或提供计算能力的分散可扩展方法，并且如果考虑到加密货币，区块链技术也将是分散和可扩展的。还值得注意的是，当前影响云计算的当前网络安全挑战已成为考虑采用此类服务的商业实体和政府组织关注的问题。区块链为保护通过云进行的交易提供了机会。
当前，亚马逊，沃尔玛和Facebook等大型企业已经集成了使用区块链技术来保护和加速其业务运营。预计到2020年，应用率还将提高。由于其能够加快交易，确保隐私和发展业务的能力，预计云计算供应商将探索和集成区块链技术。
智能云 –人工智能为企业提供了自动化流程和接收业务洞察力的能力，从而带来利润。工业4.0和物联网、智能边缘设备以及推动这些创新的机器人的出现，为云计算服务中集成人工智能提出了严峻的挑战。这是因为收集数据和确保设施之间的互连不是工业4.0的唯一功能。其他功能包括自动化，预测分析和数据分析。
因此，云计算解决方案将依靠AI来有效，准确地监视，管理和简化业务流程和重复性任务。人工智能还将用于改善数据管理，并在需要它们的应用程序之间准确共享云计算资源。人工智能也将在确保混合和多云生态系统始终保持最佳功能方面发挥重要作用。2020年将见证AI以及机器和深度学习等相关概念的继续采用，以实现流程自动化并获得对传统企业的更深入了解。
结论 一个新的十年即将到来，理解那些有可能改变不同方式开展业务的概念是成功的关键。打算增加对云计算的依赖的企业必须分析AI，边缘计算，量子计算和开源模型在新的一年中所扮演的角色和发挥的作用。这些知识对于选择满足特定行业要求的最佳云概念至关重要。
附录：Corvina Cloud 1.0——连接管理方案 Corvina Cloud 1.0是一种高级连接管理解决方案 ，可让您控制自己的IIoT业务。Corvina Cloud 1.0从JMCloud产品无缝地领导，具有强大的功能，高度可扩展的功能并提供高级VPN功能。用户界面非常干净并且易于使用。基于Web的网络使您的所有远程设备，网络和用户都能够安全地进行通信。Corvina Cloud 1.0 可以作为本地云基础结构提供，可提供任何规模的工业应用程序和控制服务所需的正常运行时间和性能。
下面是一个比较有意思的短视频：
高端HMI助力工业4.0打造智能工厂
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74ddafc5e7f80921b841c8e3b44776e/" rel="bookmark">
			C&#43;&#43; cin 实现循环读入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		习惯了使用while(~scanf("%d",x)){}来实现循环读入，但是有时候使用泛型编程的时候就必须使用C++中的cin，但是当我想要实现循环读入的时候却发现有些困难。
我们可以看一下下面这个简单的例子：
#include &lt;iostream&gt; using namespace std; int main() { int n; while(cin&gt;&gt;n) { cout&lt;&lt;n&lt;&lt;endl; } int x; cout&lt;&lt;"请输入x:"; cin&gt;&gt;x; cout&lt;&lt;"x的值为"&lt;&lt;x&lt;&lt;endl; return 0; } 运行结果：
这和我们想要的不一样。为了能够使用cin进行循环读入，就必须使用cin的一些成员函数
实际上我们使用cin读取失败以后会有一个错误的标志位，cin.fail()将会为真。如果我们不清除的话是没有办法再使用cin的。因此使用失败后应该cin.clear()方法清除标志位
但是此时还是不能正常读取，这是因为缓冲区中仍然是那个错误的输入，为了解决这个问题，我们可以使用cin.ignore()清除缓冲区，这样就可以重新输入啦。
这两个方法还可以带参数，但是简单使用的话不用考虑那么多。
然后我们就能够使用cin循环读入啦。
#include &lt;iostream&gt; using namespace std; int main() { int n; cin&gt;&gt;n; while(cin.fail() == false)//没有发生错误 { cout&lt;&lt;n&lt;&lt;endl; cin&gt;&gt;n; } cin.clear(); cin.ignore(); int x; cout&lt;&lt;"请输入x:"; cin&gt;&gt;x; cout&lt;&lt;"x的值为"&lt;&lt;x&lt;&lt;endl; return 0; } 运行结果
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3842fe9ceb3ccf93ece4363cf3e09c7/" rel="bookmark">
			【C&#43;&#43;】调试问题Bug记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		static 类型的变量需要在类外实现 例子:PrimerC++13章StrVec的实现
/tmp/ccHWCyce.o：在函数‘StrVec::push_back(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const&amp;)’中： StrVec.cpp:(.text+0x38)：对‘StrVec::alloc[abi:cxx11]’未定义的引用 /tmp/ccHWCyce.o：在函数‘StrVec::alloc_n_copy(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const*, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; const*)’中： StrVec.cpp:(.text+0x82)：对‘StrVec::alloc[abi:cxx11]’未定义的引用 /tmp/ccHWCyce.o：在函数‘StrVec::free()’中： StrVec.cpp:(.text+0x11e)：对‘StrVec::alloc[abi:cxx11]’未定义的引用 StrVec.cpp:(.text+0x153)：对‘StrVec::alloc[abi:cxx11]’未定义的引用 /tmp/ccHWCyce.o：在函数‘StrVec::reallocate()’中： StrVec.cpp:(.text+0x2c0)：对‘StrVec::alloc[abi:cxx11]’未定义的引用 /tmp/ccHWCyce.o:StrVec.cpp:(.text+0x32f): 跟着更多未定义的参考到 StrVec::alloc[abi:cxx11] collect2: error: ld returned 1 exit status 之前写单例模式的时候遇到过一次，没搞清除也没有记住，给自己一个差评。
修改
在类外实现:allocator&lt;string&gt; StrVec::alloc;
获得随机数 #include &lt;time.h&gt; #include &lt;stdlib.h&gt; int random() { srand((int)time(0)); //获得1到100的随机数 return rand()%100; } must take exactly one argument 输入输出运算符必须是非成员函数，可以在类外面定义，然后在类里声明为友元。
‘std::istream&amp; Sales_data::operator&gt;&gt;(std::istream&amp;, Sales_data&amp;)’ must take exactly one argument istream&amp; operator&gt;&gt;(istream &amp;is, Sales_data&amp; sd) { 输出char指针的地址 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3842fe9ceb3ccf93ece4363cf3e09c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f06081c27eb86a03fbef0fb5c96771/" rel="bookmark">
			解决wireshark检测不到网卡的问题（Windows）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决wireshark检测不到网卡的问题（Windows） 目前在调试4G/5G模块时，会有个radins的网口（连接usb接口即可生成），但是在使用wireshark抓包时，找不到这个网卡，于是各种google/baidu，终于解决了此问题，各种综合解决方案，如下：
一. 方案1 第一步
1、打开windows设备管理器。 2、查看-&gt;显示隐藏的设备 3、非即插即用驱动程序 4、NetGroup Packet Filter Driver 右键属性—驱动程序—启动类型，修改类型为“系统” 第二步：
在cmd下输入net start npf，打开网络抓包服务 执行时如果遇到权限问题，可以以管理员权限执行cmd.exe，然后在cmd里执行上述命令即可。
第三步：
运行wireshark ，此时网卡已经可以正常检测到了。 二. 方案2 win10系统，直接可以参找一下方法：
1)以管理员身份运行cmd，启动npf服务
输入： net start npf 2）重启wireshark
三. 方案3 1.wireshark自带的Npcap不支持win10，需要重新下载Win10Pcap，下载地址为http://www.win10pcap.org/download/。安装时需要关闭wireshark，然后重新打开wireshark即可。
2.使用管理员权限打开命令窗口，如下，输入net start npf命令，出现如下提示即可（注意：如命令窗口不是以管理员身份打开，命令会执行失败）。最后以管理员身份打开wireshark软件即可，如下图。
3.但是我在尝试了上面两种方式之后，打开wireshark依然显示没有找到接口。
后续我就尝试了把wireshark程序重新安装了一下，然后同时我又重装了Win10Pcap，但是打开最新的wireshark依然显示没有找到接口。
瞬间有点崩溃，最后尝试在360软件管理里面把wireshark自带的Npcap(名称：也可能是winpcap)程序卸载后，然后再次打开wireshark程序，此时出现了接口，终于成功。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfd92d6651db0663264bb12a4b5b74e6/" rel="bookmark">
			linux安装odoo总流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos7安装odoo总流程 一、安装系统后的基本配置 联网：先插上网线 Vim /etc/sysconfig/network-scripts/ifcfg-enp0s25
ONBOOT=yes
保存
重启
service network restart
Ping www.baidu.com可以使用。
查看IP ： IP addr
关闭防火墙：
systemctl stop firewalld.service
systemctl disable firewalld.service
新建用户odoo
adduser odoo
修改odoo用户密码
passwd odoo
安装基本包
yum install lrzsz tree net-tools nmap vim bash-completion -y
yum -y install readline-devel
yum -y install zlib-devel
yum -y install make
二、安装python2.7.13 Su
Cd
查看当前python版本 python --version ，当前为2.7.5
安装所有的开发工具包
yum groupinstall -y “Development tools”
安装其它的必需包
yum install -y zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfd92d6651db0663264bb12a4b5b74e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26eeb9a8d5179a0ea0af156bb9113df2/" rel="bookmark">
			Java编程题：增加一个字符，判断其是否为回文串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回文串 给定一个字符串，问是否能通过添加一个字母将其变为回文串。
输入描述:
一行一个由小写字母构成的字符串，字符串长度小于等于10。
输出描述:
输出答案(YES\NO).
输入
coco
输出
YES
如果长度为n的字符串添加一个字符能成为回文串，那么删除一个字符也能成为回文，因为这个两个字符是对称的位置。
import java.util.*; public class Main { public static void main(String[] args){ Scanner sc = new Scanner(System.in); while (sc.hasNext()){ String str = sc.nextLine(); char[] chas = str.toCharArray(); boolean flag = false; for (int i=0; i&lt;chas.length; ++i){ //复制 String str1 = String.copyValueOf(chas); char[] chas1 = str1.toCharArray(); chas1[i] = ' '; //每次删除一个, //对char中的字符逐个删除，直到出现回文串为止 String s = String.valueOf(chas1).replaceAll(" ", ""); if (isPa(s)){ flag = true; } } if (flag){ System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26eeb9a8d5179a0ea0af156bb9113df2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c6121c69e3902e5f8004bd8cdc43a27/" rel="bookmark">
			AndroidStudio安装app失败：resource android:attr/dialogCornerRadius not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 AndroidStudio安装app失败：resource android:attr/dialogCornerRadius not found
先试试 build-&gt; clean；如果不管用 , 再试试 File-&gt; Invalidate Caches / Restart清除缓存并重启AndroidStudio；如果还没管用，尝试降低项目使用的SKD版本；如果还是没管用，在项目的 gradle.properties 文件中加上 : android.enableAapt2=false 我是进行到第4步管用的，也可以试试直接使用第4步看看是否可以修改成功。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9613027d15133abbb69ab6273ecfa1b1/" rel="bookmark">
			简述什么是冲突域和广播域，集线器、交换机、路由器分别如何分割冲突域和广播域？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冲突域（collision domain) 在以太网中，如果某个CSMA/CD网络上的两台计算机在同时通信时会发生冲突，那么这个CSMA/CD网络就是一个冲突域。如果以太网中的各个网段以中继器连接，因为不能避免冲突，所以它们仍然是一个冲突域。 使用交换机可有效避免冲突。而集线器则不行！因为交换机可以利用物理地址进行选路，它的每一个端口为一个冲突域。而集线器不具有选路功能，只是将接收到的数据以广播的形式发出，极其容易产生广播风暴。它的所有端口为一个冲突域。 广播域(Broadcast Domain)是指网段上所有设备的集合。这些设备收听送往那个网段的所有广播。 冲突域：在同一个冲突域中的每一个节点都能收到所有被发送的帧 广播域：网络中能接收任一设备发出的广播帧的所有设备的集合 冲突域是基于第一层（物理层） 广播域是基于第二层（链路层） 广播域就是说如果站点发出一个广播信号后能接收到这个信号的范围。通常来说一个局域网就是一个广播域。 广播域内所有的设备都必须监听所有的广播包，如果广播域太大了，用户的带宽就小了，并且需要处理更多的广播，网络响应时间将会长到让人无法容忍的地步。 冲突域：一个站点向另一个站点发出信号。除目的站点外，有多少站点能收到这个信号。这些站点就构成一个冲突域。 HUB （集线器）所有端口都在同一个广播域，冲突域内。所以HUB不能分割冲突域和广播域。
总结：
集线器：纯硬件、用于连接网络终端、不能打破冲突域和广播域。
交换机：拥有软件系统、用于连接网络终端、能够打破冲突域，但是不能分割广播域。
路由器：拥有软件系统、用于连接网络、可以打破冲突域也可以分割广播域，是连接大型网络的比备设备
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4435708e81de5c0da2da72bfbb2dd31/" rel="bookmark">
			问卷自动填写脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简介 懒人专用刷问卷脚本！ 害怕验证码！
本文基于Selenium+chromedriver实现问卷自动填写。目前只支持单选和多选题型，暂不支持填空题。
原理 通过检查问卷星的网页代码，我们会发现一个规律：
每道题的选项答案会有一个共同特征： a[rel='q题目号_选项号']
因此我们可通过代码定位第一题的A选项：
find_element_by_css_selector("a[rel='q1_1']") 详细原理我有时间再补充完整 ！ovo
代码展示 from selenium import webdriver import time import random for i in range(n): # 控制填写数量 driver = webdriver.Chrome() driver.get("https://") #括号内填写问卷地址 time.sleep(1) xx = random.randint(1, 2) if xx == 1: driver.find_element_by_css_selector("a[rel='q1_1']").click() time.sleep(1) elif xx == 2: driver.find_element_by_css_selector("a[rel='q1_2']").click() time.sleep(1) driver.find_element_by_id('submit_button').click() # 提交问卷 time.sleep(1) driver.quit() time.sleep(5) # 关闭问卷 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70f2dabcb77c4c9e2b4105d0b2ba050e/" rel="bookmark">
			Selenium&#43;chromedriver环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 selenium 是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。
支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera等。
这个工具的主要功能包括：测试与浏览器的兼容性——测试你的应用程序看是否能够很好得工作在不同浏览器和操作系统之上。测试系统功能——创建回归测试检验软件功能和用户需求。支持自动录制动作和自动生成 .Net、Java、Perl等不同语言的测试脚本。
（参考百度百科）
简单来说，就是一个自动化测试的库
环境配置 首先，我们需要安装selenium库。打开cmd输入以下指令即可：
pip install selenium 这里，我们使用chrome浏览器配合selenium工作。通过查看chrome浏览器的版本安装配对的chromedriver。
chromedriver下载地址
我们在上面的链接下载相应版本的驱动，解压后得到一个.exe的文件。
将其解压在chrome的安装目录下，然后再配置环境变量。
默认安装路径为：(C:\Program Files (x86)\Google\Chrome\Application\)
环境变量配置：
（1）进入我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量
（2）修改系统变量path最后面添加 ;C:\Program Files (x86)\Google\Chrome\Application\chromedriver.exe 即可
在python中测试是否配置成功：
from selenium import webdriver driver = webdriver.Chrome() driver.get("https://www.baidu.com") 正常打开网页即说明配置成功。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/386/">«</a>
	<span class="pagination__item pagination__item--current">387/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/388/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>