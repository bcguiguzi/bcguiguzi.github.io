<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75253fd7cdccc227e4efb44b5a41ffd5/" rel="bookmark">
			1 buffers were freed while being dequeued
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7817760a5bb5356dd8f4fee85e1ccb5a/" rel="bookmark">
			【Bug解决】AttributeError: ‘DataParallel‘ object has no attribute ‘XXX‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 报错内容：
raise AttributeError("'{}' object has no attribute '{}'".format( AttributeError: 'DataParallel' object has no attribute 'XXX' 报错信息的意思是 DataParallel object 没有 attribute/method XXX。
报错原因： 多卡训练使用 DataParallel，导致原本 model 中的方法名添加了前缀 module（和参数名变化的原理一样）。
解决： 使用 model.module.XXX 而不是 model.XXX
model = DataParallel(model) ... model.module.XXX() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e85ee3cfae66ba8901a49053e29aba7/" rel="bookmark">
			如何进行最小二乘法，并且附加条件呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请问如何运用最小二乘法去解多项式，然后保证得到的结果都大于0呢？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/910f7cb30d247462af50ffe35ac12288/" rel="bookmark">
			树莓派使用c&#43;&#43; qt 编译opencv流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装qt。
我是用的是bullseye版本的树莓派，32位和64位的都用过，均只能使用下述命令来安装。
$ sudo apt-get update
$ sudo apt-get upgrade
$ sudo apt-get install qtbase5-dev qtchooser
$ sudo apt-get install qt5-qmake qtbase5-dev-tools
$ sudo apt-get install qtcreator
$ sudo apt-get install qtdeclarative5-dev
上述命令来自下面这条博客
(85条消息) 树莓派bullseye 系统安装QT5_bullseye安装pyqt5_Li丶Chong的博客-CSDN博客
（另一种常见的方法使用下面这个命令：
sudo apt-get install qt5-default
但是我使用这条命令始终显示没有下载候选选项，更换了下载源后依旧无法找到，因此应该是树莓派版本问题。）
2、编译opencv。
这个烦得很。
（a）首先去opencv官网下载源码（即sources选项），然后放到树莓派中。进入opencv文件夹，创建build文件，进入build文件，输入cmake .. ，再输入make -j4（若这一过程中突然停掉，可能是swap空间不够，按照网上的方式开辟一块就可以了），最后再输入sudo make install。（其实这一段都是很常规的步骤，网上这样讲的方法也很多，可参考这个博客(85条消息) 树莓派安装使用 opencv c++版本_Lin_QC的博客-CSDN博客）
此外，如果(96条消息) 为什么OpenCV4 “pkg-config --modversion opencv”显示“ No package ‘opencv‘ found”？解决方法！_no package 'opencv' found_疯狂的蕉尼基的博客-CSDN博客
（b）重点讲接下来可能出现的报错怎么整。首先就是在使用qt过程中引入opencv的话可能会报错找不到opencv的各种头文件（其实4.几的版本只需要一个#include&lt;opencv2/opencv.hpp&gt;就够了），那我们首先需要配置一下opencv.conf。首先输入如下命令：
sudo nano /etc/ld.so.conf.d/opencv.conf
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/910f7cb30d247462af50ffe35ac12288/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a94474475f44ebb6829def357d16f5f3/" rel="bookmark">
			两步轻松实现ChatGPT联网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1️⃣第一步 在谷歌应用商店网站下载 “webChatGPT” 插件
Chrome 应用商店 - webchatgpt (google.com)
2️⃣第二步 登录ChatGPT会发现搜索栏新增了很多东西。
Web access按钮打开：使得ChatGPT可以联网搜索。
3results：代表GPT只会展现3条符合的信息。
Any region：代表我们的数据是全世界范围内的。
Default prompt：代表默认命令行
3️⃣测试联网后与联网前 我们都知道ChatGPT联网前，我们询问他最近发生的事情他是不知道的，也给不出相关的网址索引。但是现在我想让他给我一些当下关于WEB3的资讯，并且给出引用网站时，他的回答十分详细切符合要求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/780b1e1bd49ebd36a9ab50a60f198643/" rel="bookmark">
			flink任务处理下线流水数据，数据遗漏不全（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 1、test3是单独接受T4301的mqtt主题数据
以下是flink代码
以下是node-red的
跟踪分析 拉出tdengine里面的数据曲线，看是否存在遗漏的情况
少2023-04-05 22:05:48的日志
贴上我的代码
小结 1、虽然下线记录比之前的多很多了，但是还是遗漏一些数据，不全！！
2、再看看Test2的程序log，因为Test2是接受所有的，看看这里的T43-1是否存在遗漏情况 跟踪Test2发现
也少了数据
发现Test2和Test3一样的，遗漏一样的数据 Test2的数据量是Test3的四倍！！！ 目前没有证据指名是数据量大小导致数据遗漏的，我觉得可能是程序判断有Bug，先把Test3的原因找到！！
数据遗漏的原因，如果不是跟数据量有关
可能的原因1、判断下线的代码有误
我把这里判断的数据改成之前的程序，然后运行看看2023-04-06 11:27发布的Test2 Test3
这个版本不对，== 改成equals()；不然2分钟就会存储一次数据 2023-04-06 12:12:00
可能的原因2、tdengine数据莫名其妙的错位
昨天发现很奇怪的现象，数据存在CWW=40多和CWW=0.1交错；上一秒数据是40多，下一秒数据0.1，查遍整个流程的代码，并没有出现，topic写错的情况！！！
然后怀疑是数据到达emqx的时候有混乱排序，把数据的时间改成从Node-red创建时间，而不是在emqx中插入语句的now();
今天并未出现这种现象！！
所以我打算把所有的topic的now()改成node-red数据发出时创建的时间ts!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8415ecf0dd0cd2eac6681062451de889/" rel="bookmark">
			自定义MVC应用（通用增删改查）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：上一次与大家分享了自定义MVC框架的创造过程，今天紧接要对自己创造的自定义MVC应用。 一、优化web.xml文件： 1、我们自己创造的自定义MVC框架最终目的归根结底是要导出变成jar包，以后自己使用，方便代码，节约时间。那么将自己创造的自定义MVC框架导出后，其中的.xml文件内容就看不到了，而在这里就要对.xml文件进行优化。 2、思路： 2.1、在中央控制器中注释与浏览器联系的语句。 2.2、新建一个source folder文件夹（注意此文件与src资源文件夹是并列关系，其中千万要注意不要建成package包，如下图所示，如果不按上述建并列资源文件夹，就会报空指针异常）图中整个web项目报错是因为我把其中一个没用的jar包给删除了，所以报错，但是对整个项目毫无影响，可以运行出结果。 2.3、新建资源文件夹ZJ.xml中写好之前config.xml文件中内容， 2.4、在中央控制器中写好建模的代码： public void init() throws ServletException { // actions.put("/book", new BookAction()); // actions.put("/goods", new GoodsAction()); try { String configurationLocation = this.getInitParameter("configurationLocation"); if (StringUtils.isNotBlank(configurationLocation)) { configModel = ConfigModelFactory.build(configurationLocation); } else { configModel = ConfigModelFactory.build(); } } catch (Exception e) { e.printStackTrace(); } } 运行效果（隐藏之前的config.xml文件之后的运行效果）：其中book中的属性为null值，是因为没有在视图层加数据 由上述结果得出：优化.xml文件配置成功。 二：通用的增删改查： 思路：1、首先在basedao中写好增删改的通用方法（查询要进行分页) public void excuteUpdate(String sql, T t,String[] attrs) throws Exception { Connection con = DBAccess.getConnection(); PreparedStatement ps = con.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8415ecf0dd0cd2eac6681062451de889/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67526e6bcc15d8657224df9cd0bd7493/" rel="bookmark">
			CentOS7设置阿里源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7
CentOS 7是CentOS项目发布的开源类服务器操作系统，于2014年7月7日正式发布。CentOS 7是一个企业级的Linux发行版本，它源于RedHat免费公开的源代码进行再发行。
1、打开centos的yum文件夹
cd /etc/yum.repos.d/ 2、用wget下载repo文件
wget http://mirrors.aliyun.com/repo/Centos-7.repo 3、备份系统原来的repo文件
cp CentOS-Base.repo CentOS-Base.repo.bak 4、替换系统原理的repo文件
mv Centos-7.repo CentOS-Base.repo 5、执行yum源更新命令
# 清除缓存： yum clean all # 生成缓存 yum makecache # 更新 yum update &amp;&amp; yum upgrade -y 现在你的就已经配置好了阿里云的环境了.
注意: 如果提示-bash: wget: 未找到命令 说明还没有安装wget工具
输入yum -y install wget 回车进行安装。
阿里镜像官方地址 http://mirrors.aliyun.com/
清华镜像地址：https://mirrors.tuna.tsinghua.edu.cn/centos-vault/
中科大镜像地址： https://pypi.mirrors.ustc.edu.cn/simple
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b25c68c0d2dddac1b164b231355c26ba/" rel="bookmark">
			[联邦学习] FedAvg聚合算法详解及代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		该文章首发于若绾 [联邦学习] FedAvg聚合算法详解及代码实现,转载请标注出处。
论文原文：Communication-Efficient Learning of Deep Networks from Decentralized Data
概述 在现代计算机科学中，机器学习被广泛应用于各种领域。然而，机器学习需要大量的数据才能达到最佳性能。在某些情况下，由于数据隐私和安全的原因，集中式训练模型可能不可行。这就是联邦学习的概念出现的原因。联邦学习是一种机器学习范式，其中模型在本地设备上训练，而不是在集中式服务器上训练。本篇博客将介绍一种常用的联邦学习算法——FedAvg。
FedAvg是一种常用的联邦学习算法，它通过加权平均来聚合模型参数。FedAvg的基本思想是将本地模型的参数上传到服务器，服务器计算所有模型参数的平均值，然后将这个平均值广播回所有本地设备。这个过程可以迭代多次，直到收敛。
为了保证模型聚合的准确性，FedAvg算法采用加权平均的方式进行模型聚合。具体来说，每个设备上传的模型参数将赋予一个权重，然后进行加权平均。设备上传的模型参数的权重是根据设备上的本地数据量大小进行赋值的，数据量越多的设备权重越大。
FedAvg的优势 与其他联邦学习算法相比，FedAvg有以下优点：
低通信开销：由于只需要上传本地模型参数，因此通信开销较低。
支持异质性数据：由于本地设备可以使用不同的数据集，因此FedAvg可以处理异质性数据。
泛化性强：FedAvg算法通过全局模型聚合，利用所有设备上的本地数据训练全局模型，从而提高了模型的精度和泛化性能。
FedAvg的缺点 尽管FedAvg具有许多优点，但它仍然存在一些缺点：
需要协调：由于需要协调多个本地设备的计算，因此FedAvg需要一个中心化的协调器来执行此任务。这可能会导致性能瓶颈或单点故障。
数据不平衡问题：在FedAvg算法中，每个设备上传的模型参数的权重是根据设备上的本地数据量大小进行赋值的。这种方式可能会导致数据不平衡的问题，即数据量较小的设备对全局模型的贡献较小，从而影响模型的泛化性能。
FedAvg的算法流程 伪代码 详解 服务器初始化全局模型参数 w 0 w_0 w0​；
所有本地设备随机选择一部分数据集，并在本地计算本地模型参数 w i w_i wi​；
所有本地设备上传本地模型参数 w i w_i wi​ 到服务器；
服务器计算所有本地模型参数的加权平均值 w ˉ \bar{w} wˉ，并广播到所有本地设备；
所有本地设备采用 w ˉ \bar{w} wˉ 作为本地模型参数的初始值，重复步骤2~4，直到全局模型收敛。
代码实现 Code def fedavg(self): # FedAvg with weight total_samples = sum(self.num_samples) base = [0] * len(self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b25c68c0d2dddac1b164b231355c26ba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c440e06f31e2eaf8bd80dbf5cc497245/" rel="bookmark">
			MPU6050 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
关于MPU6050芯片
关于小板
关于厂家和DATASHEET
关于漂移
关于角加速度还是角速度
关于精度和量程（可调，可选）
关于功耗，
陀螺仪 + 加速器工作电流：3.8mA（全功率，陀螺仪在所有速率下，在 1kHz 采样率下加速）采样率高，功耗也高
可以参考 MPU6050陀螺仪与Processing和匿名上位机飞控联动实录 - 知乎
关于MPU6050芯片 MPU6050 传感器模块是6 轴运动跟踪设备。包含 3 轴陀螺仪、3 轴加速度计、运动处理器、温度传感器。 I2C 总线接口，可与微控制器进行通信。
通过辅助 I2C 总线与其他传感器设备通信，如 3 轴磁力计、压力传感器等。如果 3 轴磁力计连接到辅助 I2C 总线，则 MPU6050 可以提供完整的 9 轴运动融合输出。
使用 16 位 ADC 数字化以对每个轴进行采样。
满量程输出范围为 +/- 250、+/- 500、+/- 1000、+/- 2000。
它以度/秒为单位测量沿每个轴的角速度。
关于小板 MPU-6050模块有8个引脚，
INT：中断数字输出引脚。
AD0： I2C 从机地址 LSB 引脚。这是设备 7 位从地址中的第 0 位。如果连接到 VCC，则它被读取为逻辑 1 并且从机地址发生变化。
XCL：辅助串行时钟引脚。此引脚用于将其他启用 I2C 接口的传感器 SCL 引脚连接到 MPU-6050。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c440e06f31e2eaf8bd80dbf5cc497245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0dc123b963f0c50c75a70691affe5a78/" rel="bookmark">
			C#学习质料
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.https://www.cnblogs.com/chillsrc/p/5261605.html
2.Main方法_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50eecd0a0c988493af2e9effc08f9687/" rel="bookmark">
			实时分析海量新数据的难点 和解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
难点和解决方案
具体技术栈
难点和解决方案 实时分析海量新数据的难点和解决方案主要涉及以下几个方面：
1. 数据量和数据流速度的挑战：实时分析海量新数据，需要处理大量的数据和高速的数据流，这会对计算和存储带来很大的挑战。
解决方案：使用分布式计算和存储技术，如Hadoop、Spark、Kafka等，将数据分散存储在多个节点上，同时进行分布式计算和处理，以实现数据的实时处理和分析。
2. 数据质量的保障：海量新数据的质量不一定稳定，可能存在缺失、重复、错误等问题，对实时分析结果的准确性会产生影响。
解决方案：采用数据清洗、去重、纠错等技术，对数据进行处理和筛选，同时增加数据验证和监控机制，保证数据的质量和准确性。
3. 实时性和性能的要求：实时分析需要在短时间内对大量数据进行处理和计算，要求处理速度快，同时还需要考虑系统的可扩展性和容错性。
解决方案：使用分布式计算和存储技术，采用分布式算法和实时计算引擎，提高处理速度和系统的可扩展性和容错性。
4. 业务需求和分析模型的变化：实时分析需要不断调整和改进分析模型和算法，同时还需要根据业务需求进行实时调整和优化。
解决方案：采用机器学习和深度学习技术，对数据进行模型训练和优化，同时建立灵活的分析模型和算法，根据业务需求进行调整和优化。
5. 安全和隐私的保障：海量新数据可能涉及到个人隐私和敏感信息，需要对数据进行保密和加密处理。
解决方案：采用数据加密和权限控制技术，保证数据的安全性和隐私性。同时需要建立数据监控和追踪机制，确保数据的安全和完整性。
具体技术栈 以下是一些常用的分布式计算和存储技术，以及实时计算引擎：
分布式存储技术：如HDFS、Ceph、GlusterFS等，可以将数据分散存储在多个节点上，提高数据存储的可扩展性和容错性。
分布式计算框架：如Hadoop、Spark、Flink等，可以对大规模数据进行批处理或流处理，并且支持分布式计算，提高数据处理速度和可扩展性。
分布式数据库：如TiDB、Cassandra、MongoDB等，支持水平扩展和数据分片，提高数据库的可扩展性和性能。
分布式消息队列：如Kafka、RabbitMQ等，支持高吞吐量和低延迟的消息传递，提供可靠的数据传输和数据缓存功能。
实时计算引擎：如Storm、Spark Streaming、Flink等，支持流式数据处理和实时计算，具有低延迟和高吞吐量的特点。
以上技术和引擎并非全部，还有其他的技术和引擎可以用于实时分析海量新数据。选择何种技术和引擎，需根据具体场景和业务需求来综合考虑。
大数据流式计算和重复计算 大数据流式计算和重复计算是两种不同的计算方式，下面对它们进行比较。
计算方式 大数据流式计算是一种实时计算的方式，它可以处理不断变化的数据流，每次只处理一小部分数据，而不是一次性处理所有数据。流式计算适用于需要及时处理数据并做出相应决策的场景，如实时监控和反欺诈等。
重复计算是一种离线计算方式，它需要一次性将所有数据加载到内存中，并重复多次运算。重复计算适用于需要对整个数据集进行分析和处理的场景，如数据挖掘和机器学习等。
数据处理方式 大数据流式计算处理数据的方式是逐个数据处理，处理完一个数据后即释放资源，不会将处理过的数据保留在内存中。流式计算中的数据是以流的形式输入，处理完即输出，不会对数据进行存储和管理。
重复计算是对整个数据集进行分析和处理，需要将所有数据加载到内存中，并对数据进行排序、分组、聚合等操作。重复计算中的数据是以静态数据集的形式进行处理，处理完后可以将结果输出并存储到磁盘上。
系统设计和实现 大数据流式计算系统需要支持高并发、低延迟的处理，可以通过分布式系统、消息队列、缓存等技术来实现。流式计算需要实时处理数据，需要满足系统的实时性和容错性要求。
重复计算系统需要支持高效的数据处理和存储，可以通过Hadoop、Spark等分布式计算框架来实现。重复计算需要处理大量的数据，需要满足系统的计算性能和数据管理要求。
综上所述，大数据流式计算和重复计算是两种不同的计算方式，适用于不同的场景和需求。选择哪种计算方式取决于具体业务场景和数据处理需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1f34635481e71f32111972e0bbe2d37/" rel="bookmark">
			蓝桥杯最后一战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
分巧克力_二分
题目描述
输入格式
输出格式
输入输出样例
说明/提示
代码：
巧克力 - 优先队列
题目描述
输入格式
输出格式
输入输出样例
说明/提示
代码：
思路分析：
秘密行动_dp
蓝桥杯算法提高-秘密行动
题目描述
输入格式
输出格式
样例输入
样例输出
代码：
思路分析：
合并果子_优先队列
题目描述
输入格式
输出格式
输入输出样例
说明/提示
代码：
思路分析：
回文平方数_进制转换API
题目描述
输入格式
输出格式
输入输出样例
说明/提示
代码：
说在最后
分巧克力_二分 题目描述 儿童节那天有 KK 位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。
小明一共有 NN 块巧克力，其中第 ii 块是 Hi×WiHi​×Wi​ 的方格组成的长方形。
为了公平起见，小明需要从这 NN 块巧克力中切出 KK 块巧克力分给小朋友们。切出的巧克力需要满足：
形状是正方形，边长是整数。
大小相同。
例如一块 6×56×5 的巧克力可以切出 66 块 2×22×2 的巧克力或者 22 块 3×33×3 的巧克力。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1f34635481e71f32111972e0bbe2d37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae6bbc468e9789feff89fafcfe123db/" rel="bookmark">
			GB28181之H264打包PS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GB28181之H264打包PS 本章开始尝试更加有难度的操作，把H264打包成ps流。PS流分为4大部分：PS头/系统头/节目流/PES包。这四大部分每个都有大量需要填写的字段，一时弄不清楚如何填写。为了解决这一问题，我找了一段公安一所的测试PS流进行逐步分析，希望能弄清楚每个字段如何填写。
第一个：PS头定义如下：
上码流一共14个字节：
转换成2进行如下：
0000 0000 0000 0000 0000 0001 1011 1010 0100 0100
0000 1010 1011 0100 1111 1100 0000 0100 0000 0001
0000 0000 0011 1010 1001 1011 1111 1000
pack_start_code =0000 0000 0000 0000 0000 0001 1011 1010
‘01’=01
system_clock_reference_base [32..30] =000 marker_bit=1
system_clock_reference_base [29..15] =00 0000 1010 1011 0
marker_bit=1
system_clock_reference_base [14..0] =00 1111 1100 0000 0
marker_bit=1
system_clock_reference_extension = 00 0000 000
marker_bit=1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aae6bbc468e9789feff89fafcfe123db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c492e26bf159b435eda877f22b98b77/" rel="bookmark">
			【Python学习】对比numpy中随机数生成函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://huaweicloud.csdn.net/638069b3dacf622b8df8732d.html?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-5-125273828-blog-86423754.235%5Ev27%5Epc_relevant_3mothn_strategy_and_data_recovery&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Eactivity-5-125273828-blog-86423754.235%5Ev27%5Epc_relevant_3mothn_strategy_and_data_recovery&amp;utm_relevant_index=10
本文简述 numpy中常用的几个随机数生成函数用法，并进行对比。函数包括：np.random.rand()、np.random.randn()、np.random.uniform()、np.random.randint()
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c9c00dd71ef3c14e8303c39b9b1554/" rel="bookmark">
			CloudFront 跨域问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错信息： blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource
1、编译【行为】
2、
【响应标头策略-可选】 如果没有创建，创建策略如下：
创建“【响应标头策略-可选】，如下：
【保存更改】如下：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e20fad5b42659d431b88bd9175f197d4/" rel="bookmark">
			【2022保研】双非上岸东南网安
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【2022保研】双非上岸东南网安 今天是2022年10月14日，距离928保研结束已经半个多月了，之前一直想写一篇博客来记录自己的保研历程，一直摆烂拖到现在，感觉这半个月像是报复性摆烂一点都不想学习，每天睡十多个小时hhh。
保研结果只能是说好不好，说差不差。有些奇怪，感觉从高考到保研一直没取得自己满意的结果，总会有些遗憾，也可能是自己已经得到了的可能就显得没那么好，总是想得到更好的。
夏令营 个人情况 学校：中部双非
专业：信息安全
排名：3/63
英语：六级463分
竞赛：蓝桥杯国二，还有其他一些水奖
论文：无
项目：两个结项的项目都很水基本没什么用（中科院科创计划、校级大创），还有一个正在进行的区块链项目，保研联系的老师也都是区块链方向的
入营情况 夏令营基本是能投的都投了，最后只入了几个海王营，因为自己背景确实不太好，而且好多大佬也都在海投，所以夏令营的结果十分惨淡。
入营情况：华东理工、浙软、信工所、北邮网安、东南网安、南开网安
华东理工 华东理工是我入的第一个夏令营，当时收到邮件还激动了好久hhh
面试过程：中文自我介绍+英语问答+中文问答
英语问答都是些比较常见的问题，自己刚好都准备到了所以基本就是背上去的感觉回答的还不错，后面中文问答基本都是在围绕着项目进行提问，三个项目挨个问。另外我当时说自己对网安和区块链比较感兴趣，老师问了几个网安的问题没有回答上来，之后自己也是在mooc上把网安的知识又复习了一遍hhh。
上午面试完好像下午就直接在腾讯会议里宣布结果了，一共三个评级ABC，A是学硕，BC是专硕，我拿到一个B，凡是入营的最差都是C，入营即offer
浙软 浙软也是海王营，夏令营不发offer，不过听说夏令营优营是双非预推免的入场券，考核挺麻烦的而且浙软在宁波，所以也就没参加。
现在想想浙软是真香啊，可能是双非鼠鼠上岸华五的唯一机会了，再给鼠鼠一次机会鼠鼠肯定冲浙软。
信工所 信工所是我最开始的梦校，今年信工所夏令营是海王营报名的都入了，分研究室面试，我选的是二室并且也提前联系了导师（听学长说联系导师好像挺重要的），二室的考核包括机试+英文面试+中文面试
机试就是在答题，包括一些专业课的选择题还有三道编程题，编程题比较简单AK了，机试好像不算在最终的面试成绩中但是会作为参考
英文面试与中文面试是分开的，先是英文自我介绍，然后抽题目回答，我当时抽到的是——“印象最深刻的梦是什么？为什么印象深刻”，抽到之后人就傻了，磕磕绊绊一塌糊涂，赶紧随便说了说就结束了，最后是一段英文文献，先读一遍再翻译。
中文面试，中文面试没有问项目全都是问专业课+数学，专业课提问了两个数据结构
1.如何用栈模拟队列。这个在网上有很多方法，不细说了
2.一个先递减后递增的数组，如何找到最小的数字，时间复杂度要小于O(n)。单调数组直接用二分查找，老师又问边界条件是什么，当时脑子抽了回答的好像是下标有关的，老师让再想想，后来想了想只需要判断左右元素均大于当前元素即可
数学一点都没复习，刚开始问的好像是正态分布——不会，然后又问的大数定理——不会，然后就没了。
后面问的研究生想做什么方向，同意调剂吗，专硕、学硕、直博怎么选择排序。
夏令营结果分为卓越、优秀、良好，卓越和优秀发offer，良好是候补。很幸运拿到了卓越，后续也进行了体检邮寄材料啥的，终于有保底了hhh
北邮网安 北邮网安也是海王营，分组面试，感觉北邮夏令营组织的很乱，自己去官网找群没有任何通知，有许多人都错过了机试面试，而且听说夏令营也不发offer，总之就是感觉特别乱不知道最后offer是怎么发的。
我面试的是1组，首先是机试，一共五道题，不算难都AK了，然后根据机试成绩筛选一部分人参加面试，面试之前老师发了两篇论文让选一篇在面试的时候首先讲解论文，面试就只有一个老师提问，就只问了我做过的代码里最多的项目是什么，有多少行代码，但是自己没做过代码量比较大的项目，后面就提问我计组啥的课设做的什么，我们学校比较水也没做什么课设，然后就没有了。
后来自己去官网查结果是合格再后来就没有消息了。
东南网安 东南网安夏令营和预推免是一起的，也是海王营报名的基本都入了。
面试过程就是中文自我介绍+英文提问+中文提问
中文自我介绍的时候有些紧张，最后有一段忘说了匆匆结束。。。
英文问题之前在群里看到有人被提问了项目，于是就准备了英文项目的回答，正好碰巧老师真的提问了项目，就背上了这个感觉回答的还行。
中文提问就一直在问项目，没有问专业课，感觉回答的还行。
面试结果是一个排名，只要参加面试的都在候补名单里，按照排名从前往后划分学硕专硕，最后候补到专硕（有点遗憾差几名就候补到学硕了），这也是我的最终去处。东南网安在群里实时进行双选，自己联系导师，但是928还是鸽穿了，第二天又开了一批面试。
南开网安 南开网安是自己联系导师面试，刚开始联系了一个导师隔了一个月才回复，导师安排了一些考核任务，大概就是读两篇论文还有一个编程考核，当时正好赶上期末考试没有做完就跟老师说了说，之后也是参加了面试，面试结果老师的回复是“比较认可”让我继续完成之前的考核任务，这里跟老师一直都是邮件联系，老师也没有发微信啥的感觉老师可能也不是很想要我，编程考核尝试了好多方法最后还是没完成加上自己的论文表现也一般，最后还是g了。
预推免 个人情况 学校：中部双非
专业：信息安全
排名：1/63
英语：六级463分
竞赛：蓝桥杯国二，还有其他一些水奖
论文：无
项目：两个结项的项目都很水基本没什么用（中科院科创计划、校级大创），还有一个正在进行的区块链项目，保研联系的老师也都是区块链方向的
预推免的时候排名升到rk1了，当时信心满满肯定还能再冲一个更好的学校，结果狠狠的打脸了。
因为已经有东南保底了，所以投的都是一些个人感觉比东南好一些的学校
入营情况：天大智算、北理网安（上到航开济下到中九基本都投了最后只入了这俩）
天大智算感觉不如东南，而且天大名声也不好就没有参加
北理网安 北理网安感觉没有统一的考核通知啥的，自己发邮件到心仪的方向，我选的是密码学，然后老师拉了一个微信群就开始面试了。
面试30分钟，中文自我介绍+英文提问+抽题回答+中文提问，这里英文提问的问题竟然是自我介绍！！！因为前面已经中文介绍过了，没想到会用英文再介绍一遍，于是一点都没准备直接没了啊啊啊啊阿。
抽题回答时自己选一个号，然后老师那边放题目，大概有四五道题目，我抽到的是网安相关的，好像是解释数字签名、HMAC记不太清了。
因为有30分钟的面试时间，所以中文提问问的很多，项目、专业课都问了不少，回答的有对有错，总体感觉一般吧。
当时面试的时候正好有个老师是区块链的大牛，面试结束后老师也跟我电话交流了一些，感觉老师人挺好的，但是无奈自己实力不够后来也没了消息算是默拒了吧。
写在最后 总体来说有些遗憾，预推免排名升到rk1，结果什么学校也没有冲上，东南网安也是差一点点就补到学硕，不过想想这也符合我自己的背景了，没有很出众的竞赛、没有论文、项目也都很水有个中九也不错了。
最后再吐槽一下保研的乱象，线上面试前排大佬都在海，后面的鼠鼠都没学上，928好多学校都被鸽穿，继续线上的话这种现象肯定越来越严重，不知道什么时候才能改善。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ee0b800f9803c0604c66bd4c8da3dee/" rel="bookmark">
			【leetcode】二叉树专题-遍历
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 二叉树的结构二叉树的深度遍历的三种方式前序遍历中序遍历后序遍历 二叉树的宽度优先遍历BFSBFS获得二叉树最大宽度 二叉树的结构 * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; 二叉树的深度遍历的三种方式 在开始总结三种遍历方式之前，先将左程云老师提到递归序做一个总结，我理解的递归序就是递归过程中遍历到节点顺序。针对下面这个伪代码:
void recursive(TreeNode*node){ if(node == NULL) return ; recursive(node-&gt;left); recursive(node-&gt;right); } 递归过程，是先遍历自己，然后进而遍历左子树，再遍历右子树，调用函数的过程中，return会返回到上一次调用的位置，所以每个节点都会被遇到3次。对应的递归顺序如下：
12444255523666377731
前序遍历 所谓前序遍历是指第一次遇到这个节点的时候就做出相应的动作，比如打印，这样前序遍历的舒顺序是：1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6-&gt;7(在递归序中取出第一次出现的数字即可)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ee0b800f9803c0604c66bd4c8da3dee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2e2abb880b628cb79fe753ae630a30c/" rel="bookmark">
			string.find()函数(C/C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.介绍2.分析3.使用 1.介绍 A. 函数原型：
B. 函数原型：
find(str字符串或者单个字符，pos起始搜索位置)，若成功找到匹配的子字符串则返回第一个成功匹配的子字符串的索引坐标(相对于str, 而不是相对于pos起始搜索位置)，否则返回npos
2.分析 A. 头文件：iostream
B. 函数原理就是从pos位置开始搜索整个字符串，如果没有输入起始位置pos，则默认为0。找到能成功匹配的子字符串str，如果可以找到合法存在的子字符串位置，这里需要注意，返回这个位置的索引坐标相对于整个字符串的起始位置而言，而不是相对于起始搜索的位置，否则返回npos.
C. npos: 这是一个特殊值，等于size_type可以表达的最大值，通常为无符号整型的最大值。确切的含义取决于上下文，通常用来标识字符串结束或者是函数作用错误指示符。在本函数当中就用来代表函数作用错误，即无法成功搜索到合法位置返回npos，这里返回的是unsigned long long的最大值18446744073709551615
3.使用 A. 查找字符串
#include&lt;cstdio&gt; #include&lt;iostream&gt; using namespace std; int main(){ string s = "Today is a good day, hope you are happiness"; int k1 = s.find("is"); // pos未输入则默认为0 int k2 = s.find("is", 4); cout &lt;&lt; k1 &lt;&lt; ' ' &lt;&lt; k2 &lt;&lt; endl; // 6 6 if(s.find("is", 10) == s.npos){ cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2e2abb880b628cb79fe753ae630a30c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d354d00491dad3bf1ad5f92f0b8bd459/" rel="bookmark">
			vite中server.proxy的一些配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		target是目标代理的接口地址，当监测到以 /api开头的接口后，把axios请求中前面的本地服务器地址改为target的值，实际发送给后端的请求就是下方后一个请求 http://XX.XX.XX.XX:8080/api/def --&gt; http://localhost:8081/api/def
changeOrigin表示是否跨域
PathRewrite：替换请求中匹配的内容，在这里就是去掉 /api 前面的 ^
server:{ proxy:{ '/api':{ target:"http://localhost:8081", //目标代理接口地址 secure:false, changeOrigin:true, //开启代理，在本地创建一个虚拟服务器 PathRewrite:{ '^/api':'/api' } } } } vite配置的server.proxy其实和vue-cli配置的devServer.proxy大致一样
附上vite官网的server.proxy链接：
https://cn.vitejs.dev/config/server-options.html#server-proxy
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/160/">«</a>
	<span class="pagination__item pagination__item--current">161/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/162/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>