<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f2321daacfba163c5be065cf54c8a2/" rel="bookmark">
			关于在eclipse中创建并运行Servlet时出现的问题及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用的 eclipse 版本为Java EE Version: 2021-12 (4.22.0)。
刚开始tomcat版本为10.0，在“FirstServlet.java"源文件中import如下：
import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; 直接报错：The import javax.servlet cannot be resolved。上网求助，很多人都说未引入jsp-api.jar和servlet-api.jar，顺着路径找了半天发现配置好服务器就自动引入这些jar包了。
继续上网求助，发现好像是由于版权问题导致javax和jakarta之间的冲突，有人说把javax都改成jakarta就好了，改完之后倒是不报错了，但运行时会报错，事后发现并不能否定这个方法，也许是我其他地方搞错了，还有待进一步研究学习。
接着求助，发现一根救命稻草，有人说最快的办法就是“弃掉tomcat10，用回tomcat9”，死马当活马医，换掉tomcat再试，还是不行！！！？？？几乎已经要崩溃了......
玩会手机缓解一下，继续求助。一位博主描述的问题和我的问题虽然不是一回事，但他的一句话给了我灵感，我马上把server关掉重启，然后就莫名其妙好了，此刻的我一脸懵逼却内心窃喜。搞了整整半天，期间不断的重建、删除工程，和教程上的代码一个字母一个字母核对，不管怎么说，老天还是开眼的。
对自己曾经总结过的一句话更加深信不疑：80%的技术问题可以通过重启解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f3a92538a196ec83bb18e23aa8fd00e/" rel="bookmark">
			PyQt5实现侧面菜单栏-仿QQ设置--以及透明选中按钮效果(详细讲解)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是我们要仿制的样式，甚至你可以在这个界面中弄更漂亮的界面效果
源码和UI文件都会开放的
这是我们实现的效果，可以看到切换页面的同时按钮会有被选中的感觉，这是通过label去实现的
下面开始教程
用QtDesign设计一个界面，包含四个按钮和stackedWidget, 后边还要弄个label，这里页面就弄两页就算了，然后给按钮绑定槽函数
绑定好后生成UI文件后，转成py文件格式，当然你如果是PySide6可以直接生成py文件
生成好的py文件
class Ui_MainWindow(QMainWindow): def __init__(self): super().__init__() self.setupUi(self) 初始化，这是写在同一个文件里边，我是不推荐这样做的一般界面和槽函数分开写，然后通过继承UI_MainWIndow来分开写，这个前几篇文章都是这样写的，有兴趣可以看看，由于我特别懒就写一块了。
if __name__ == "__main__": app = QApplication(sys.argv) window = Ui_MainWindow() window.show() sys.exit(app.exec_()) 主入口，写完后再补充绑定的函数即可
def ChangeTwo(self): self.stackedWidget.setCurrentIndex(0) 这里0和1就是页面的页数切换，写完这里切换功能就完成了，要加上选中的效果就要用到我们的label了
self.label = QtWidgets.QLabel(self.centralwidget) self.label.setPixmap(QtGui.QPixmap("Text.png")) self.label.setGeometry(QtCore.QRect(0, 0, 691, 451)) self.label.setScaledContents(True) self.label.setObjectName("label") 给label配上图片，要注意的是后边的setText要删掉不然就没图片了，图片和代码我会整合成一个压缩包。
最后通过修改label的位置按钮选中状态就完成了
def ChangeOne(self): self.stackedWidget.setCurrentIndex(1) x = self.label.pos().x() y = self.label.pos().y() self.anim = QPropertyAnimation(self.label, b"geometry") self.anim.setDuration(100) self.anim.setStartValue(QRect(x, y, 3, 40)) self.anim.setEndValue(QRect(42, 136, 3, 40)) self.anim.start() 对应每个槽函数的位置填写对应的x，y就好了
写完后可以看到Text3是有一个选中的效果，这只是对label移动其中一个例子而已，最后通过修改按钮的样式改成透明
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f3a92538a196ec83bb18e23aa8fd00e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f98d04b86d7420350028604ce6d90a73/" rel="bookmark">
			Vue 的 computed 和 watch 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		computed 是模板表达式的声明式描述，会创建新的响应式数据。而 watch 是响应式数据的 自定义侦听器，用于响应数据的变化。除此之外，computed 还具有可缓存，可依赖多个属 性，getter 函数无副作用等特点。watch 则更适用于异步或开销大的操作。
1. 实现原理
在了解 Vue 数据双向绑定的基础上，computed 等同于为属性设置 getter 函数 （也可设置 setter），而 watch 等同于为属性的 setter 设置回调函数、监听深度 deep 及响应速度 immediate。下面简单讲解下两者的实现原理，具体细节可以参考源码。
1.1 computed 原理
主要分为四个阶段
初始化：为 computed 属性创建 lazy watcher（此处 watcher 指双向绑定中的监听 器，下同）。首次模板渲染：渲染 watcher 检测到 computed 属性时，会调用 computed 属性的 getter 方法，而 computed 属性的 getter 方法会调用依赖属性的 getter，从而形成链 式调用，同时保存引用关系用于更新。取得计算结果后 lazy watcher 会将结果缓存，并 返回给渲染 watcher 进行模板渲染。多次模板渲染：直接取 lazy watcher 中的缓存值给到渲染 watcher 进行渲染。依赖属性更新：根据首次模板渲染阶段构建的依赖关系向上通知 lazy watcher 进行重新 计算，缓存计算结果并通知渲染 watcher 重新渲染更新页面。 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f98d04b86d7420350028604ce6d90a73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0528b031abfaac3db8c67bc42aecad23/" rel="bookmark">
			webpack 的工作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webpack 是一种模块打包工具，可以将各类型的资源，例如图片、CSS、JS 等，转译组合为 JS 格式的 bundle 文件。
webpack 构建的核心任务是完成内容转化和资源合并。主要包含以下 3 个阶段：
1. 初始化阶段
初始化参数：从配置文件、配置对象和 Shell 参数中读取并与默认参数进行合并，
组合成最终使用的参数。
创建编译对象：用上一步得到的参数创建 Compiler 对象。
初始化编译环境：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、
加载配置的插件等。
2. 构建阶段
开始编译：执行 Compiler 对象的 run 方法，创建 Compilation 对象。
确认编译入口：进入 entryOption 阶段，读取配置的 Entries，递归遍历所有的入
口文件，调用 Compilation.addEntry 将入口文件转换为 Dependency 对象。
编译模块（make） ： 调用 normalModule 中的 build 开启构建，从 entry 文件
开始，调用 loader 对模块进行转译处理，然后调用 JS 解释器（acorn）将内容转 化为 AST 对象，然后递归分析依赖，依次处理全部文件。
完成模块编译：在上一步处理好所有模块后，得到模块编译产物和依赖关系图。
3. 生成阶段
输出资源（seal） ：根据入口和模块之间的依赖关系，组装成多个包含多个模块的
Chunk，再把每个 Chunk 转换成一个 Asset 加入到输出列表，这步是可以修改输 出内容的最后机会。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0528b031abfaac3db8c67bc42aecad23/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abcb395d00c9ad5fe42a3c256188b874/" rel="bookmark">
			虚拟机ubuntu通过fdisk命令扩充硬盘容量，分区简单说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、分区的简单说明 一般第一块硬盘，是要分成：
先一个主分区：主分区是独立的，对应磁盘的第一个分区，“一般”就是C盘一个扩展分区：一般剩下的全部都弄成扩展分区。 然后在扩展分区上进行逻辑分区，相当于分成D盘，E盘之类的，不是特别需求，就分成一个就好了 新加一块硬盘话，作为从盘，不装系统，是可以不要主分区的，然后直接直接分区进行挂载
应该，如果只有一块硬盘，那么应该就是 /dev/sda 它的分区也都是sda1 sda2 sda3这种
再加一块硬盘就是 /dev/sdb 它的分区就是sdb1 sdb2 sdb3这种
还有一点：
一般centos都是用的LVM(逻辑卷管理器)，df命令查看时，主要存储位置一般都会有/dev/mapper这样的字眼，这是比较方便直接在原来的目录上面增加容量的。
然后ubuntu一般都没使用LVM，新增的数据盘一般都是直接使用fdisk处理吧，分好区挂载到一个新的目录下(这不能在原有目录上进行扩展)
参考：磁盘管理，LVM。
二、fdisk使用—ubuntu新增磁盘 ​ 假设后期添加新一块硬盘，这种方式就需要新建目录，把分好的区挂载在这新建目录上，没办法扩大已有目录的容量，下面是一个简单的使用demo：
​ 这里先以VMware添加一块类似于物理磁盘(就是相当于外面再加了一块硬盘)为例子：
首先随便找一个虚拟机，进到“编辑虚拟机设置”，点击添加硬盘，基本选用推荐下一步就行了，最后选择使用单个文件和立即分配空间就好了，然后就会多一快硬盘：
然后就开机，进行分区：首先使用命令：fdisk -l 查看分区情况，可以看到 /dev/sdb 没有有效的分区表，
然后就是进行分区：fdisk /dev/sdb 然后就会进到fdisk的交互界面，先输入m查看一下菜单，然后再输入p查看一下当前分区表，可以看到是没有的:
再然后输入n来新建一个分区,因为是新增的从盘，是可以不要主分区的，就直接建立扩展分区，然后再把扩展分区划分逻辑分区：
Ps:一开始输入P选择建立主分区(这是第一块磁盘才这样弄主分区吧，从盘加量的话，选择e扩展分区)，因为是建立的第一个分区，所以就输入1，如果是建立的第二个分区，那就是输入2;然后就要开始选择分区的起始位置和大小了，如下：
这里就是把2G弄成一个主要分区。（这里就是一个展示，添加从盘可忽略这一小步）
然后就可以再p打印一下分区表，就可以看到我们刚刚的2G大小的分区了,再输入w，写分区表，然后fdisk的界面也会自动退出了：
Tips：
这里的/dev/sdb1 就是建立的扩展分区这里的/dev/sdb5 就是在扩展分区上建立的逻辑分区主分区和扩展分区的磁盘号位1-4，也就是说最多有4个主分区或者扩展分区，逻辑分区开始的磁盘号为5 格式化分区：
新的分区需要进行格式化才能使用，千万注意分区别搞错了，接着上图，我们的逻辑分区名字是 /dev/sdb5 ，也可以再用fdisk -l进行查看
格式化命令：mkfs.ext3 /dev/sdb5 # 这是格式化成 ext3,ext2就是对应把前面的3改成2，
挂载新虚拟磁盘：
在根目录下新建一个文件夹，比如 mkdir /home/sh/new_disk1再帮刚刚的分区挂载到这个文件夹下：mount /dev/sdb5 /home/sh/new_disk1/然后df -h就能看到这个磁盘了 永久挂载：
系统重启后，发现挂载的虚拟硬盘就看不到了，需要再手动去mount挂载，太麻烦了，vim编辑vim /dev/fstab文件，在里面添加一行（注意别写错了)： /dev/sdb5 /home/sh/new_disk1 ext3 defaults 0 0
Tips:
删除分区的命令是d,d删除分区后，也要用 w 写入后退出,不然退出后分区还是存在。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/abcb395d00c9ad5fe42a3c256188b874/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6212e2f489081051e19e2ee59fc5ba60/" rel="bookmark">
			golang mac 卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、删除 go 目录，通常为目录 /usr/local/go ，使用命令
sudo rm -rf /usr/local/go 2、从 PATH 环境变量中移除 Go 的 bin 目录。 编辑 /etc/profile，如下图，删除红色圈出部分：。
vim /etc/profile
如果是通过Mac OS X 包安装的 Go，则移除 /etc/paths.d/go 文件即可，命令
sudo rm -rf /etc/paths.d/go 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/153f928557462e0ef580112e77376434/" rel="bookmark">
			深度学习框架随想（一）：Op与Kernel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://zhuanlan.zhihu.com/p/100418869?utm_source=com.slack
在深度学习框架中，Op和Kernel是非常重要的两个概念。以TensorFlow为例，我们有"MatMul" op，有"Conv2D" op，有"Matmul" kernel，也有"Conv2D" kernel等。
那么到底什么是Op？什么是Kernel？他们的定义是什么呢，他们之间的区别又是什么？我来分享下我的理解。
先来看看Kernel。
什么是Kernel？Kernel其实就是对Tensor进行操作的一个函数，一段计算逻辑，Tensor In Tensor Out。
对于一些简单的Kernel（如"Add"）来说，其是一个纯函数。但对于一些复杂的Kernel来说，其可能需要初始化一些状态，也有可能拥有一些中间状态需要保存，所以其就不是纯函数。因此，在TensorFlow中，用 Class 的形式来表现Kernel，方便存储中间状态。
那么什么是Op呢？我理解Op就是Kernel的集合，一个Op代表的是有一定共性的多个Kernel。
举例而言，在TensorFlow中，“MatMul” op对应的kernel是 class MatMulOp&lt;Device, T, USE_CUBLAS&gt;。这个模板类的每一个全特化对应的都是一个真正的kernel，所以在"MatMul" op这个概念之下，其实有着很多的kernel。例如CPU实现的针对于float数据类型的kernel（三个模板参数是 kCPU, float, false ），GPU上使用cublas实现的针对float的kernel（kGPU, float, true），GPU上不用cublas实现的针对half数据类型的kernel（kGPU, half, false）等等。
虽然在计算图上我们是用Op来表示一个个的节点，但实际上，计算图上的每个节点代表的一个Kernel。因为在计算图上我们除了存储Op本身的配置属性之外，还存储了一些额外的属性（如Device、DataType等）。基于Op的配置和这些额外的配置，我们可以确切的为每个节点找到唯一一个对应的Kernel。
为什么要在Kernel上抽象出一层Op？因为Kernel太多太杂了，为了简化图分析的复杂性，我们按照某种规则去合并多个Kernel，并在图分析时把多个Kernel看作一个，命名为Op，然后去处理。
而关于具体按照哪种规则来把多个Kernel合并为一个Op，其实并没有一个固定的答案。
以Conv为例，理论上来说，我们可以把"Conv1D"、“Conv2D"和"Conv3D"共3个op合并成一个"Conv” op，然后在"Conv" op的配置中让用户选择1D、2D还是3D的卷积操作。
我也可以把"Conv2D" op拆成很多个op，例如"CpuConv2D", “GpuConv2D”, “CpuConv2DForFloat”, "GpuConv2DForHalf"等等，使得每个op都只对应更少（甚至只有一个）kernel。
所以，一个Op对应几个Kernel，其实都并没有一个明确的答案，更像是框架开发者的个人喜好。
我个人而言的话，有一条不是那么严格的原则：如果在图分析阶段需要针对与某一个或多个Kernel进行处理，那就把它们抽出来当成一个Op，否则的话就不要把这些Kernel暴露在图分析阶段，以简化分析复杂度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69359a52ed73536279020dff0931855b/" rel="bookmark">
			go get拉取常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题1.出现错误信息： module declares its path as: url1*** but was required as: url2*** 出现该错误信息，如果 url1*** 和 url2*** 不一样：
如上图所示：一般是你要拉取的包的go.mod文件的module后面跟的模块名称或者路径名称在你初始化的时候不正确。
修改方法：
将你要拉取的库的 go.mod 的 module 的值修改成“***but was required as:***”后面的值。
问题2. 出现该错误信息：*** is not in GOROOT *** 如上图所示，则需检查你拉取的库的内部是否有 import 包错误，造成该错误的原因，可能是修改 问题1 中的 go.mod的module后面的路径名导致。
解决办法：
修改拉取库的内部import错误的地方
问题3.出现错误信息：dial tcp *******:443: i/o timeout 出现该错误信息原因是，你拉取的库可能是私有库导致的。因为Go 1.13设置了默认的 GOSUMDB=sum.golang.org，
GOSUMDB 的全称为 Go CheckSum Database，用来下载的包的安全性校验问题。包的安全性在使用 GoProxy 之后更容易出现，比如我们引用了一个不安全的 GoProxy 之后然后下载了一个不安全的包，这个时候就出现了安全性问题。
解决办法：
1、关闭哈希校验，可以将 GOSUMDB 设置为 off
go env -w GOSUMDB=off 2、使用 GOPRIVATE 设置私跳过有库，私有仓库自动忽略验证
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/69359a52ed73536279020dff0931855b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de733ef3e8f2851fbc4b299ce7a22ef/" rel="bookmark">
			C&#43;&#43; string中的find() 函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos，也就是-1。（返回值可以看成是一个int型的数） 例子：找到的情况
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string str = "aabc"; int pos = str.find("abc"); if (pos != str.npos) { cout &lt;&lt; pos &lt;&lt;endl; //运行结果是1 } else { cout &lt;&lt; "not find!"; } cout &lt;&lt; endl; return 0; } 例子：找不到的情况，调试可以看到npos的值为-1，即是4294967295
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string str = "aabc"; int pos = str.find("d"); if (pos != str.npos) { cout &lt;&lt; pos &lt;&lt;endl; } else { cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3de733ef3e8f2851fbc4b299ce7a22ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba1fbeeeffd3e4e9455f631ad847472a/" rel="bookmark">
			PINN笔记：NaN的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Learning RateReLU：当确定并非Learning Rate问题后，可查看是否是activation函数的问题，比如应用LeakyReLU。Softmax：注意不要在此时除以0，除此以外，如果传入刀Softmax的数值过大也可能导致NaN的出现，可将数组以最大值shift至0，在matlab中的操作为softmax(lay1 - max(lay1))。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b268ab4e58b6e25d3be8081a61c3c7d/" rel="bookmark">
			寒假笔记06
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		面向对象 面向对象编程的本质：以类的方式组织代码，以对象的组织(封装)数据
特性 1.封装 2.继承 3.多态
认识角度：先有对象后有类。对象是具体的事物，类是抽象的,是对对象的抽象
代码角度：先有类后有对象，类是对象的模板
方法的定义 1.修饰符
2.返回类型
3.break：跳出Switch 结束循环 return 的区别
方法名：注意规范
参数列表
异常抛出
方法的调用 1.静态方法
2.非静态方法
3.形参和实参
4.值传递和引用传递
5.this的关键字
package JavaBase; // 引用传递 public class Demo6 { public static void main(String[] args) { People people = new People(); String name=people.name; System.out.println(name); name=person(name); System.out.println(name); } public static String person(String name) { name="哈哈哈"; return name; } } class People { String name; } 类 类是一种抽象的数据类型，它是对某一种事物整体的描述/定义，不能代表某一个具体的事物
创建与初始化对象 使用new关键字创建对象 使用new关键字创建的时候，进行默认的初始化以及对类中构造的调用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b268ab4e58b6e25d3be8081a61c3c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42222291c4c2918e66abf6aab7f03dba/" rel="bookmark">
			当数据为字符串类型的数字时，要转换成数字类型快捷方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当数据为字符串类型的数字时，要转换成数字类型时可以用这种方式
例如
假如res.header['X-Total-Count']=‘1'
res.header['X-Total-Count'] - 0 转换之后变成数字类型1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/657a599091a72dfd5f6985116d5c5472/" rel="bookmark">
			计算机网络——组播地址（多播地址、D类地址）详解——不断完善更新中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、是什么 先看这张图，组播地址是分类编址的IPv4地址中的D类地址，又叫多播地址，他的前四位必须是1110，所以网络地址的取值范围是224~~239。 2、这些IP地址用来做什么 224.0.0.0～224.0.0.255为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用 224.0.1.0～224.0.1.255是公用组播地址，可以用于Internet 224.0.2.0～238.255.255.255为用户可用的组播地址（临时组地址），全网范围内有效 239.0.0.0～239.255.255.255为本地管理组播地址，仅在特定的本地范围内有效 组播地址列表如下： 224.0.0.0 基准地址（保留） 224.0.0.1 所有主机的地址 （包括所有路由器地址） 224.0.0.2 所有组播路由器的地址 224.0.0.3 不分配 224.0.0.4 dvmrp路由器 224.0.0.5 该地址被OSPF协议所使用，所有使用OSPF协议的路由器都是这个地址 224.0.0.6 OSPF DR/BDR 224.0.0.7 st路由器 224.0.0.8 st主机 224.0.0.9 rip-2路由器 224.0.0.10 Eigrp路由器 224.0.0.11 活动代理 224.0.0.12 dhcp 服务器/中继代理 224.0.0.13 所有pim路由器 224.0.0.14 rsvp封装 224.0.0.15 所有cbt路由器 224.0.0.16 指定sbm 224.0.0.17 所有sbms 224.0.0.18 vrrp 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dad0b1991e4a35c3dc9cff254ccdaef/" rel="bookmark">
			MarkDown 常用语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、标题 最为常用的格式，只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低
一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 注：1）# 和[标题]之间需保留一个字符的空格，这是最标准的MarkDown写法；2）只有一级到六级标题（最多六级）。 二、首行缩进、换行、空行、对齐方式 首行缩进 在 Markdown 中，&amp;emsp;或&amp;#8195; // 全角 &amp;ensp;或&amp;#8194; // 半角 &amp;nbsp;或&amp;#160; // 半角之半角
这是全角状态下的首行缩进
这也是全角状态下的首行缩进
这是半角状态下的首行缩进
这也是半角状态下的首行缩进
这是半角之半角状态下的首行缩进
这也是半角之半角状态下的首行缩进
换行 常用的为直接换行回车，由于markdown编辑器的不同，具体方法可能有所区别。
空行 在编辑的时候有多少个空行(只要这一行只有回车或者space没有其他的字符就算空行)，在渲染之后，只隔着一行。
对齐方式 利用Html行内式：center、align
这是居中对齐方式 这是左对齐方式
这是右对齐方式
三、列表 列表也很常用，只需要在文字面前加上 - 即可（- 和文字之间记得加空格）
无序列表 文本一文本二文本三 有序列表，在文字前面加上1. 2. 3.即可（1. 和文字之间也要记得加空格）
有序列表 文本一文本二文本三 定义型列表 定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)
MarkDown 轻量级文本标记语言，可以转换成html,pdf等格式 四、插入链接和图片 在 Markdown 中，插入链接不需要其他按钮，你只需要使用 [显示文本](链接地址) 这样的语法即可
这是我的CSDN博客地址
在 Markdown 中，插入图片不需要其他按钮，你只需要使用 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dad0b1991e4a35c3dc9cff254ccdaef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2399366e2d7c17fe7c333b9912e9889/" rel="bookmark">
			寒假笔记05
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数组 声明数组变量 dataType[] array dateType array [] Java创建数组 dataType[] array = new dataType[arraysize]; 数组的元素是通过索引访问的，数组索引从0开始
获取数组长度
数组的四个基本特点 1.长度是确定，数组一旦被创建，它的大小就是不可以改变
2.元素必须是相同类型
3.元素可以是任何数据类型
4.数组变量属引用类型，数组也可以看成对象，数组中的每个元素相当该对象的成员变量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ad8e45d91503618357281f4982db1e/" rel="bookmark">
			如何在Latex中插入MATLAB代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在编写一篇文章时需要用到在latex中插入MATLAB代码，如果直接在文本中添加会使文章变得不美观，那么此时我们非常有必要了解一下如何在latex中插入优美的MATLAB代码。
1.复制mcode.std文件在latex目录里： 通常情况下我们是需要在latex中安装一个名为mcode.std的文件，我在本文中已经将该文件从官网中下载下来了，大家只需按照我的步骤做即可。
step1.首先复制压缩包里的文件mcode文件
step2.找到latex的安装路径，我的是这样子：
我的texlive是安装在D盘中，按照路径：texlive\2021\texmf-dist\tex\latex便可以找到latex的std文件，里面从a到z排列，此时我们在该路径下新建一个名为mcode的文件夹，将复制的mcode文件：
2.刷新系统 点击电脑开始键，找到windowsPowershell ，注意！一定要单击右键以管理员身份运行，输入texhash等待done语句的出现即可！
3.检验是否成功 我们在latex文件中插入如下代码：
\begin{lstlisting}	%正文插入代码 rand('state',sum(clock)); p0=0; tic for i=1:10^7 x=randi([0,99],1,5); [f,g]=mengte(x); if all(g&lt;=0); if p0&lt;f x0=x;p0=f end end end x0,p0,f; toc \end{lstlisting} 效果如下：
这样我们便成功了。
文件下载地址为：
链接：https://pan.baidu.com/s/1IiS5_PAjYW7BwAlxQhQHEA 提取码：1234
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40133d12bbacca51521d676917388a1a/" rel="bookmark">
			一种简易的、临时性的VS&#43;opencv环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非常的简单，但需要你创建每个项目都需要配置一次。
方法如下：
步骤一： 看清楚这里的Debug和x64选项。需要说明的是，当你改变了Debug和x64选项（比如改成了Debug和x86选项）那么项目属性里的设置也就改变了。我这里选择Debug和x64选项。
步骤二： 把opencv的文件夹放在VS的项目文件夹下面，如下所示：
步骤三： 打开VS项目，打开项目的属性（右键点击项目名），打开配置属性，打开VC++目录。我们接下来的任务是为“包含目录”和“库目录”添加路径。
包含目录下添加：
C:\Users\zhou\Desktop\Project1\OpenCV\include;
C:\Users\zhou\Desktop\Project1\OpenCV\include\opencv;
C:\Users\zhou\Desktop\Project1\OpenCV\include\opencv2
库目录下添加：
C:\Users\zhou\Desktop\Project1\OpenCV\lib
注意，opencv文件夹在项目Project1文件夹下。
步骤四： 在链接器中加入你opencv文件夹下的opencv_world310d.lib这个名称，操作如下。需要说明的是，我这里是Debug，因此我选择的是opencv_world310d.lib而不是opencv_world310.lib。
至此，如果你成功了，那么恭喜。
如果失败了，说运行时提示缺少opencv_world310(d).dll，解决方案是，在OpenCV文件夹里找到对应的dll文件复制到程序exe所在的目录即可。并且，将bin目录( C:\Users\zhou\Desktop\Project1\OpenCV\bin)中的3个dll文件复制在（C:\Windows\System32）以及(C:\Windows\SysWOW64)中。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a02b506862a52d981aed2a667a617684/" rel="bookmark">
			计算机专业本科毕业设计答辩技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机毕业设计在整个过程进行中，一般是有三次答辩的，分别是开题答辩、中期答辩以及最终答辩；有的学校会简化成两个，分别是开题答辩和最终答辩；还有的学校会直接是最终答辩，省去开题答辩和中期答辩。不管你要参加几次答辩，亦或者是哪种类型的答辩，最为关键的还是要好好准备，接下来给大家分享一下计算机毕业设计答辩技巧。
00 — 理解课题；熟悉业务逻辑；理清中心功能或者亮点
这三点是最为重要的，也就是在答辩之前一定要好好准备，上面三点一定要根据ppt理清思路。
01 —“滔滔不绝”讲解不一定是贬义词
这一点大家要注意一下，总结一下，现在的毕业生各种答辩、面试等最大的问题就是“挤牙膏式”的问答形式。这个大家都清楚，因此，在答辩的时候，我们要有条理的进行讲解，而且是不要有间断，如果间断时间过长，就很容易被导师抓住提问的机会，从而会被问各种各样的问题，因而，我们要多讲，少给导师留下提问的机会。
首先要对自己的课题有一定的了解，比如分几种用户权限、每种用户权限实现什么功能、每种功能具体是怎么实现的、具体功能的实现代码是怎样的、具体功能模块的流程是怎样的、课题的亮点或者创新点在哪以及怎样实现的、整体开发过程中使用到了哪些技术以及最为新颖的技术亦或者最为关键的技术…
总而言之，一句话，不管程序是不是自己设计或者开发的，但是大家一定要能整体上把握中心思想。
02 — 用自己的“聪明”应对导师提问
不管什么答辩，导师都会进行一定次数的提问，但是对于编程基础不好的学生来说，对于导师的提问估计是最为头疼的，那么我们如何化简呢？
这个化简之法还是要在对整个课题业务以及程序都弄懂的情况下进行，比如导师会问你这个图表功能是怎么实现的？当你听到这个提问的时候，也许你只是知道图表功能是采用的Echarts技术实现的，那么你就需要根据这个线索进行讲解，比如我是通过课题中的某一个功能中的xxxx作为统计的起点，然后结合数据库中的xxx表实现数据的准备，然后在程序中具体怎么借助js等技术使用Echarts实现绘制（具体问题具体分析）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbf31180f0e7c8baf1bf7dd4180b1958/" rel="bookmark">
			寒假笔记03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scanner对象 基本语法 Scanner s = new Scanner (System.in) scanner.close(); netx()
不能输入带有空格的字符串
nextLine()
可以输入带有空格的字符串
hasNext或者hasNextLine 判断是否还有数据输入
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea9efca1c296cbfe36f643d63a592c3/" rel="bookmark">
			寒假笔记02
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/* 字符串连接符 */ int a=10; int b=20; System.out.println(""+a+b); // 1020 System.out.println(a+b+""); // 30 三元运算符
x ? y : z 如果x==ture;则结果为y;否则结果为z
JavaDoc 参数信息 @author作者名@version版本号@since指明需要最早使用的jdk的版本@param参数名@return返回值情况@throws异常抛出 命令行生成
javadoc -encoding UFT-8 -charset UFT-8 文件名
IDEA生成JavaDoc文档
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/270/">«</a>
	<span class="pagination__item pagination__item--current">271/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/272/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>