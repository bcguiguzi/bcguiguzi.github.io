<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e39955d2703e173f28cd578d0540bacb/" rel="bookmark">
			坐了怎么久，傻傻分不清动车和高铁，有哪些区别呢？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生活水平的提高，相对于火车出行，更多人会选择乘坐高铁、动车，耗时短而且环境也比较好，相对于飞机价格更能够让人接受。
这里就有一个疑问？做了这么久的车，是高铁还是动车你知道嘛？两者具体有什么区别呢？你知道嘛？下面就带你看看具体的答案。
一、概念不同
动车全称是动车组列车，指的是一种交通工具。
高铁全称是高速铁路，指的是一种路线。
比如京沪高铁、武广高铁，具体到线路。
通常我们将D开头的称为动车，以G开头的称为高铁，第一个区分条件就是查看列出的首字母是G还是D,就比较浅显易懂了。
二、时速不同
动车行驶速度能达到200-250公里千米每小时
高铁行驶速度能达到300-350公里每小时。
从速度上看，高铁的速度是要快于动车的，这和高铁的车型与设备是脱离不了关系的，所以根据列出行驶的车速，我们也是能够判断出乘坐的是高铁还是动车。
三、价格不同
上面介绍了高铁的车型以及设备都是要高于动车的，特别是车内环境方面，高铁是要优于动车。
高铁不仅座位等级比较全面，一等座、二等座、三等座、商务座，特等座都有区分，乘坐感也是有很大的区别，高铁在运行的过程是感受不到晃动的，但是动车就会有明显的晃动感。
所以通过票价以及坐车的感受也是能够判断的出，乘坐的是动车还是高铁。
四、路线不同
一般情况高铁只能在新修建的高铁线上运行，铁路是无渣的，多数是在桥上，而动车就没有什么要求，既能普通的铁路上运行也能够在高铁上运行。
通过观看乘坐的列出轨道大致也能观察出我们乘坐的是高铁还是动车，当然综上几点进行结合判断会更加的准确。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1936eb19df0fbe387c8036ad30c21ee5/" rel="bookmark">
			[Qt]   tcp服务器连接多个客户端的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Qt]tcp服务器连接多个客户端的实现 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 要求:数据按字节接收,以1~255个字节循环发送 编译环境:Qt 5.9.5 客户端的实现: 代码如下: TcpClient.h: #ifndef TCPCLIENT_H #define TCPCLIENT_H #include &lt;QWidget&gt; #include &lt;QTcpSocket&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; namespace Ui { class TcpClient; } class TcpClient : public QWidget { Q_OBJECT public: explicit TcpClient(QWidget *parent = 0); ~TcpClient(); private slots: void on_pushButtonEnter_clicked(); void slotconnectedsuccess(); //处理连接成功的信号 void slotreceive(); //接收服务器传过来的信息 void on_pushButtonSend_clicked(); void slotdisconnected(); //处理离开聊天室的信号 private: Ui::TcpClient *ui; bool status; //用来判断是否进入了服务器 size_t strSize; int port; QHostAddress *serverIP; QString userName; QTcpSocket *tcpsocket; }; #endif // TCPCLIENT_H TcpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1936eb19df0fbe387c8036ad30c21ee5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3126289d269ef85a328bb77c8b3f3b7/" rel="bookmark">
			DIY官网可视化微擎后台 生成后台源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DIY官网可视化微擎后台，在线可视化设计微擎后台，一键导出微擎后台代码，后台包括了bootstrap通用的组件，微擎后台组件日期组件_tpl_form_field_date,表情组件tpl_form_field_emoji,颜色组件tpl_form_field_color,图标组件tpl_form_field_icon,单图组件tpl_form_field_image,多图组件tpl_form_field_multi_image,音频组件tpl_form_field_audio,视频组件tpl_form_field_video,多文本组件tpl_ueditor等
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fec177fc482663cfc337db424038399f/" rel="bookmark">
			图解JVM 对象是否存活 (一): 引用计数法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解析 引用计数法是众多判断对象存活与否之间的一个方法.
此方法很简单, 如果有引用指向该对象, 该对象的计数器+1, 如果引用被断开(null), 计数器 -1.
此方法解决不了循环引用的问题(即A指向B, B指向A)
图解 实践 jvm参数: -verbose:gc
package cn.geek51; // 引用计数方法 public class ReferenceCountingGC { public Object instance = null; private static final int _1MB = 1024 * 1024; private byte[] bigSize = new byte[2 * _1MB]; public static void main(String[] args) { // objA引用计数值+1 ReferenceCountingGC objA = new ReferenceCountingGC(); // objB引用计数值+1 ReferenceCountingGC objB = new ReferenceCountingGC(); // 相互引用, objA和objB都=2 objA.instance = objB; objB.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fec177fc482663cfc337db424038399f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a65df7aea85fe3cde9ae0e25e094962/" rel="bookmark">
			Abaqus 实体平移和旋转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		说明一下本问题对本人的实用性，在进行地质力学建模的时候，在几何建模部分本人习惯一般就是先把形状画出来（干了再说其他），在此处并没有考虑坐标系的问题。
但是呢！在Abaqus中三维实体默认Z轴对应地层深度方向，二维模型默认Y轴对应地层深度方向，所以就需要到了实体的旋转和平移，将模型与实际的地质情况有所对应。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dfd7dc68e4f7971edef02290bdab4c9/" rel="bookmark">
			被微信好友删除，自己却不知道！3招帮你检测出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信现在已经成为了我们日常生活中不可或缺的社交工具，相对于另一个社交工具——QQ，两者有各自的优点和缺点，例如在删除好友的方式上，QQ上被对方删除好友，是互相删除的，对方不会再出现在你的好友列表中。
但是在微信上，如果你没有跟对方聊天发消息是发现不了的，当你兴致勃勃的想跟对方发个消息却收获一个红色感叹号时，微信的这个设计就显得很不人性化了。那我们该如何判断自己是否被TA删除了呢？
1. 查看朋友圈
假设你想测试某个好友或者发觉到很久没有看到他的朋友圈更新了，可以点进他的朋友圈看一看，如果只有一条横杆，有可能是你已经被对方删除或者把你屏蔽了。
如果底部出现“非朋友最多显示十张图片”，也说明你被删除了，只是对方开启了允许陌生人查看十张图片的功能。
2. 创建群聊
创建一个新的微信群，把需要测试的好友拉进去，如果有人删除了你，他的微信昵称会显示为蓝色字体，并且会提示你：“你无法邀请未添加你为好友的用户进去群聊，请先向xx发送朋友验证申请。对方通过验证后，才能加入群聊。”
3. 给Ta转账
这个方法并不是真的要转钱给对方，打开聊天界面，选择转账，输入任意金额，然后点击“转账”，如果弹出“你不是收款方好友”的提醒，则说明对方已经删了你。正常情况是直接弹出输入密码的窗口。
以上就是检测删除好友的方法了，你被好友删除过吗？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/589357a0623499c75053b8ab03ed3627/" rel="bookmark">
			现代通信原理9.2：数字基带传输系统模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、发射机：脉冲调制1.1 线路编码1.2 窄脉冲生成1.3 发送滤波器 2、信道：AWGN信道2.1 带宽无限AWGN信道2.2 带宽有限AWGN信道 3、接收机：检测 数字基带传输系统模型如图1所示。我们把它分成三个模块：发射机、信道、接收机，下面分别进行讨论。
图1 数字基带传输系统模型 1、发射机：脉冲调制 这里的发射机，也就是《现代通信原理9.1：数字系统通用模型》中介绍的脉冲调制模块，具体来说，它是把来自信源的二进制随机序列 { b n } \{b_n\} {bn​}变为信号波形 s ( t ) s(t) s(t)。
那么到底脉冲调制这个模块是如何实现从二进制序列到波形的变化呢？或者说，如何用具体的波形 s ( t ) s(t) s(t)来表达二进制随机序列 { b n } \{b_n\} {bn​}呢？
从图1中可以看出，脉冲调制模块包含三个子模块，即线路编码模块、窄脉冲生成模块、发送滤波器。下面我们就来看看它们如何实现从比特到波形的变化。
1.1 线路编码 线路编码模块的主要功能是，将二进制随机序列 { b n } \{b_n\} {bn​}映射成电平 { a n } \{a_n\} {an​}，例如对于单极性码，将“0”映射为零电平，“1”映射为正电平；而对于双极性码，将“0”映射为负电平，“1”映射为正电平等。《现代通信原理9.3：常用线路编码码型》中将给出更详细的介绍。
1.2 窄脉冲生成 窄脉冲生成器的作用，是产生间隔为 T s T_s Ts​的冲激序列，这里的 T s T_s Ts​为码元间隔（即每个码元所对应的传输时间， r s = 1 T s r_s=\frac{1}{T_s} rs​=Ts​1​为码元传输速率）。而第 n n n个冲激信号的强度，就是线路编码之后的电平 a n a_n an​，因此窄脉冲生成器输出为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/589357a0623499c75053b8ab03ed3627/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2278db5f57f7926389869b3e57b6154b/" rel="bookmark">
			【编译原理】 CS143 斯坦福大学公开课 专栏总揽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个专栏总结（或者说翻译）了 斯坦福大学的公开课 – 编译原理 课程代号CS143。
课程地址为：
Stanford University Compilers
我观看视频的地址为Youtube（上面的地址不能调画质，流量有限）：
1.1| Introduction to Compilers and interpreters
自己正在学习编译原理，和这方面的大神们比起来是真的小白，课程有4个极富挑战性的Assignment（任务），希望自己能认真完成。
最后还是希望能够给小白一些帮助，水平有限，文章有任何问题都欢迎指正。
第一周还讲了COOL语言，这里没有记录，第一周的内容偏小白，介绍了一些编译原理和它的历史。 【编译原理】 CS143 斯坦福大学公开课 第一周：简介
第二周讲的感觉很不错，词法分析和有限自动机讲的很好。 【编译原理】 CS143 斯坦福大学公开课 第二周：词法分析和有限自动机（上）
【编译原理】 CS143 斯坦福大学公开课 第二周：词法分析和有限自动机（下）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c94fb2d57946f0c48f567738b175f87/" rel="bookmark">
			C语言——华为机试训练（1-5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.题目描述：计算字符串最后一个单词的长度，单词以空格隔开。
输入：hello world 输出：5
#include &lt;stdio.h&gt; int main(void) { char av; int letters = 0; printf("输入字符："); while ((av = getchar()) != '\n') { if (av == ' ') { letters = 0; } else { letters++; } } printf("最后一个单词=%d\n",letters); return 0; } 2.题目描述：写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。
输入：ABCDEF A 输出：1
#include&lt;stdio.h&gt; #include&lt;string.h&gt; int main(void) { char str[10000]; char ch; int length = 0; gets_s(str,10000);//读入一行字符串，存入数组str中,读取字符串直到换行符'\n'结束 //ch = getchar(); scanf("%c",&amp;ch); for(int i=0;i&lt;strlen(str);i++) { if (str[i] == ch || str[i] == ch - 32 || str[i] == ch + 32) { length++; } } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c94fb2d57946f0c48f567738b175f87/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14973695f6eebd2e4d6bfcb6fc0a6cfe/" rel="bookmark">
			截至2019年11月份完全免费开放亲测可用稳定的API接口（持续更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搜索了一下网上的一些API接口，发现大多数都是过时的，不可用的，不再维护状态。我找了好久，终于找到一些最新的，实时更新的，可用稳定的一些API接口，全部总结在这里推荐给大家。欢迎大家多多关注。
【ps】:标注了“SDK”的是带有SDK下载的，需要用到SDK，标注了“非官方”的意思就是不是官方的接口，随时可能会被停止使用，请谨慎使用。另外有些API接口是限量免费的，使用的时候请注意看文档说明。声明：这里是从网络收集的一些接口资源，使用时请看清楚对应网站的声明，如因使用过程中出现法律纠纷，后果自负。使用接口需谨慎！！！
目录 开发者技术干货有关API二次元博客和杂志出行出行（SDK）旅游物流和快递地图（SDK）即时通讯(IM)&amp;聊天（SDK）消息推送（SDK）语义识别&amp;语音识别（SDK）音乐&amp;电台音乐&amp;电台（SDK）新闻&amp;信息笔记（SDK）支付（SDK）社交外卖订餐外卖订餐（SDK）词典&amp;翻译视频视频（SDK）电影图片与图像处理图片与图像处理（SDK）天气开发者API文档中心（SDK）云平台（SDK）综合综合（SDK） 开发者技术干货有关API 名称链接描述开源中国OpenApi V1.0http://www.oschina.net/openapi授权后可访问开源中国网站的内容。博客园OpenAPIhttps://api.cnblogs.com/help授权后可访问博客园网站的内容。V2EXhttps://www.v2ex.com/p/7v9TEc53可访问V2EX网站的内容。Codinghttps://open.coding.net/授权后可访问coding.net网站的内容。干货集中营http://gank.io/api提供妹子图和Android, iOS, 前端，拓展资源等内容。GitHubhttps://developer.github.com/v3/世界上领先的软件开发平台.diycodehttps://www.diycode.cc/api授权后可访问diycode网站的内容，如：技术文章、资讯、项目等内容。V2EX API 接口https://github.com/djyde/V2EX-API可访问V2EX网站的内容。 非官方Cnodejs.orghttps://cnodejs.org/api/论坛带接口 二次元 名称链接描述Bilibili(非官方)https://github.com/fython/BilibiliAPIDocs支持登录，我的信息，番剧专题，视频/专题收藏、关注，番剧，弹幕等。 #非官方Bilibili(非官方)https://github.com/Vespa314/bilibili-api/blob/master/api.md支持获取Bilibili网站数据。#非官方 博客和杂志 名称链接描述豆瓣一刻https://github.com/ZongweiBai/DoubanOpenDaily/blob/b87473b90911e687d291e847b133b5c4c4a700a3/app/src/main/java/com/monosky/daily/constant/APIConstData.java支持获取指定日期文章列表，栏目总览，推荐作者，作者信息，作者更多文章信息，栏目文章列表及翻页，文章评论及热门评论列表。 #非官方豆瓣https://douban-api-docs.zce.me这个是重新整理的API，支持图书，电影，音乐，同城，广播，用户，日记，相册，线上活动，论坛，回复和我去等功能。可以查看这里查看最新消息，https://douban.uieee.com 或 https://douban-api.uieee.com #非官方开眼(非官方)https://github.com/jokermonn/-Api/blob/master/Eyepetizer.md支持获取未登录状态下开眼精选、发现、关注信息。 #非官方One一个(非官方)https://github.com/jokermonn/-Api/blob/master/ONEv3.5.0~.md支持获取首页图片，文章，音乐及电影。 #非官方图虫(非官方)https://github.com/jokermonn/-Api/blob/master/Tuchong.md支持获取图虫 app 所有信息。 #非官方一席(非官方)https://github.com/jokermonn/-Api/blob/master/Yixi.md支持获取一席主页、演讲、讲者、枝桠等内容 #非官方知乎日报https://github.com/izzyleung/ZhihuDailyPurify/wiki/知乎日报-API-分析支持获取界面启动图像，软件版本查询，最新消息，消息内容获取与离线下载，过往消息，新闻额外消息，新闻对应长/短评论查看，主题日报列表，主题日报内容，热门消息，栏目总览，栏目具体消息，新闻的推荐者，某个专栏之前的新闻，Editor的主页等。 #非官方知乎专栏https://github.com/marktony/zhuanlan/wiki支持获取指定专栏的信息，指定专栏的文章列表，指定的文章内容，评论列表，点赞信息。 #非官方知乎日报APIhttps://github.com/izzyleung/ZhihuDailyPurify/wiki/知乎日报-API-分析非正常方式获取的，随时都可能删，谨慎使用 #非官方 出行 名称链接描述神州专车https://developer.10101111.com/resourceCenter/doc?r=guide/content神州专车提供了API接入模式，允许进行基础信息，订单，支付，充值，用户，发票，代金券，企业等方面的操作。 出行（SDK） 名称链接描述滴滴开放平台http://developer.xiaojukeji.com/doc/SDK为通用接入模式，只需注册为滴滴开发者即可使用。 旅游 名称链接描述飞猪开放平台https://open.alitrip.com/doc2/apiList.htm?spm=a21tt.8223301.0.0.39d0c486aAF5L8支持国内&amp;国际机票、酒店客栈、旅游度假、景区门票、旅行游记业务。提供Java,Python,PHP,.NET等版本SDK。艺龙http://open.elong.com/wiki/API文档支持获取产品数据，完成用户的预订，进行订单查询、更改或取消。提供在线工具，以及H5, Java, C#, PHP, Ruby版本的Demo。途牛http://open.tuniu.cn/支持途牛网的内容，仅开放给供应商系统。去哪儿http://open.qunar.com/支持获取去哪儿网的内容。需要申请并成功注册才能使用（不对外开放）。携程http://u.ctrip.com/union/help/Termsofuse.aspx支持访问携程网的内容。（除了推广分发，暂未找到任何API接口，可能API接口下线了）12306(非官方)https://github.com/jokermonn/-Api/blob/master/12306.md支持获取12306火车票票数、票价查询。 #非官方途牛火车票(非官方)https://github.com/jokermonn/-Api/blob/master/TuniuTickets.md支持获取途牛火车票票数、票价查询。 #非官方 物流和快递 名称链接描述Trackingmorehttps://www.trackingmore.com/api-index-cn.htmlTrackingmore目前支持400多家国内外快递商，免费版有使用次数限制：100个单号/天。快递100http://www.kuaidi100.com/openapi/快递100支持300家国内国际快递，免费版有使用次数限制：100个单号/天。快递100(非官方)https://github.com/jokermonn/-Api/blob/master/ExpressDelivery100.md快递100支持300家国内国际快递。 #非官方 地图（SDK） 名称链接描述百度地图http://lbsyun.baidu.com/百度地图提供了Android, iOS版本的SDK和JavaScript API，可进行定位、地图、数据、出行、鹰眼轨迹和分析服务。高德地图http://lbs.amap.com/高德地图提供了JavaScript和web服务API，Android和iOS SDK，支持地图，定位，搜索，路线规划，导航和室内地图等。腾讯地图http://lbs.qq.com/腾讯地图提供了JavaScript API，Android和iOS SDK，支持定位，地图，地点搜索，路线和导航等。图吧地图http://open.mapbar.com/图吧提供了JavaScript和Flash API，Android和iOS SDK，支持定位，地址解析，位置标注，位置截图，路线规划，周边查询，兴趣点搜索和在线导航。 即时通讯(IM)&amp;聊天（SDK） 名称链接描述钉钉https://ding-doc.dingtalk.com/支持免登，企业通讯录，服务窗，钉盘，地图，会话，DING，电话，音频，扫码，支付，分享等服务，提供SDK和Demo，PC版UI规范，调试工具和钉钉UI组件库。环信http://www.easemob.com/支持Android, iOS, WebIM, Linux, REST集成，支持多种消息类型。融云http://rongcloud.cn/支持Android, iOS, Web, 游戏集成，支持多种消息类型。网易云信http://netease.im/支持IM实时通讯，实时音视频，教学白班，专线电话，短信，聊天室，提供iOS, Android, Windows和Web SDK。腾讯云通信IM SDKhttps://cloud.tencent.com/document/product/269提供iOS, Android, Windows和Web SDK，支持多种消息类型。官方也提供了一个IMSDK指导文档：http://docs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14973695f6eebd2e4d6bfcb6fc0a6cfe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0251b88a7e121514f8183ba92452ad40/" rel="bookmark">
			【OpenGL】鼠标控制旋转（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先声明自己是这方面的小白，希望大神可以对有问题以及可以优化的地方提出来。也欢迎指出不足和吐槽。希望帮到小白。
自己参考得比较多的网站是这个：
http://www.cppblog.com/doing5552/archive/2009/01/08/71532.html
所有代码都可以去github免费下载（不怎么喜欢CSDN的积分下载）：
https://github.com/Iamttp/OpenGLTest
不多废话，好先上这一节的效果图。
#include &lt;gl/glut.h&gt; #include &lt;iostream&gt; bool mouseDown = false; float xrot = 0.0f; float yrot = 0.0f; float xdiff = 0.0f; float ydiff = 0.0f; // 绘制正方体 void drawBox() { glBegin(GL_QUADS); glColor3f(1.0f, 0.0f, 0.0f); // FRONT glVertex3f(-0.5f, -0.5f, 0.5f); glVertex3f(0.5f, -0.5f, 0.5f); glVertex3f(0.5f, 0.5f, 0.5f); glVertex3f(-0.5f, 0.5f, 0.5f); // BACK glVertex3f(-0.5f, -0.5f, -0.5f); glVertex3f(-0.5f, 0.5f, -0.5f); glVertex3f(0.5f, 0.5f, -0.5f); glVertex3f(0.5f, -0.5f, -0.5f); glColor3f(0.0f, 1.0f, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0251b88a7e121514f8183ba92452ad40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/627c021be5e57bfda8183b4a2a4c7b0d/" rel="bookmark">
			线阵相机、镜头及光源的选型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线阵相机顾名思义就是取像是成线性的。 它的传感器是成线型的。
举个例子： 比如面阵相机的分辨率是640*480就是说这个相机横向有640个像元，纵向有480个像元。
而线阵相机分辨率只体现在横向，比如2048像素的线阵相机就是说横向有2048个像元，纵向大多数为1。（RGB相机和TDI相机除外）
关于线阵相机的传感器 70年代大多数使用的是MOS，而从70年代末CCD开始迅速发展，一直到现在也是主流，CMOS大概是在80年代中期开始出现的，但是随着技术的发展CCD的取像速度要低于CMOS，而且直到2010年以前CMOS的传感器价格要高于CCD，从2010年以后几家主要的相机制造商都已经大力开发CMOS的相机了，并且也得到了不少的实际应用。
鄙人认为，以后的线阵相机主流将是CMOS的传感器。（这两种传感器的优缺点大家可以到网上找，主要是取像速度和敏感度的差异）
线阵相机的几个重要参数:
resolution: 像素数， 传感器上有多少个像元。
MAX DATA RATE（应该叫相机时钟吧）： 意思是相机每秒可以采取最大的数据量
Linerate 行频： 意思是每秒钟相机最大可以采取多少行影像
比如像素为8192*1， data rate为160Mhz, 那么此相机的行频就是160M/8192= 19000line/sec
每秒钟最大可以取像19000行，横向为8192pixel,纵向为19000pixel, 1秒钟取得的这幅图像大小大概为160M
还有就是像元的大小和镜头的尺寸。一般ccd的像元大小最小为5um，再小好像做不出来，而且感光度也差，cmos的像元可以比ccd小近一倍。
相机的选择十分重要，直接关系到整体设备的成本，像素多就要采用大的镜头，数据量大就要采用传输率大的数据线，还需要图像处理卡，数据量大对运算要求也高，对计算机的要求也高。
还是以目前的主流CCD相机为例子吧，由于相机的取像速度有限，一般每个tap最多能取得60M的数据，所以目前告诉的相机都采用多tap的处理方式，一般每个tap为40M，拿160M的相机为例就是有4个tap ,每个tap的取像为40M，40M*4=160Mhz, 当然也有single-tap(1), dual-tap(2), triple-tap(3),
octal-tap（8） 之分，目前ccd的取像速度都低于400M， 而cmos目前最高可以到1.6Ghz(以后可能会更高）
相机的输出方式也有多种，8bit,10bit,12bit, 我主要了解的就是8bit 黑白256进制影像。
有single输出，取像时1，2，3，~8192，有双输出，1，3，5，7/ 2,4,6,8, 也有1，3，5~4095/ 4097,4099~8191
这里的输出方式可以大概了解下（一般使用默认值对取像不会造成影响）
线阵相机主要接口还是以GiGe和cameralink为主流，高速的相机需要用HSlink.
相机主要的几个设定有exposre,gain, 还有内触发/外触发模式，不常用的当然也有很多如平均影像灰度，offset设定等等。
exposure ， 这个设定和相机的行频有直接关联，此设定必须低于可以采取的最大行频。
比如刚才的19000行的相机，如果想采取19000行的话，设定为1sec/19000=
53us 这里还有一些延迟在里面，设定在47us左右才可以采集最大的行频。 （表达不清楚，烦）
此数值越低，获取的影像越暗，反之越亮。
gain/offset， 调整取得影像的灰度，在照明亮度不够时可以使用，但是使用后会导致影像的鲜明度下降，对分析影像时会造成一些影像，我不建议使用，即使使用也不要超过默认值的20%
还有一些其他的设定可以参照相机的说明书。
线阵相机的应用领域，主要为连续的生产线（web),比如钢铁冶金，有色金属，电子素材，纺织，造纸，LCD等等，也可以说面阵相机可以应用的领域线阵相机也都可以完成，但是就是成本问题了。
我举一个实例说明吧， 这里先举一个单目相机实例。
电子铜带的表面缺陷检测设备
电子铜带宽度450mm， 生产线速度120米每分，需要检测最小缺陷为0.2mm
那么在选型的时候就可以考虑 4096像素的线阵相机，这样使用普通F口的镜头，横向分辨率大概是0.11mm，可以检测出最小0.2mm的缺陷了，那么纵向怎么选择呢？ 120米每分=2米每秒=2000mm每秒
如果让横向纵向分辨率都一致的话 应该是2000mm/ 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/627c021be5e57bfda8183b4a2a4c7b0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a56978024ffcca30d929aee5f2fd3c7b/" rel="bookmark">
			如何使用anaconda打开ipynb文件,有安装软件的图解。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果没有Anaconda，需要先下载安装包 ·安装包的下载地址如下选择自己的系统，Python的版本，系统的位数.博主选择的是Windows-Python3.7-64Bit 安装Anaconda
可以通过下图的指示进行安装
注意:安装路径不要有任何空格或汉字
在Advanced Installation Options中不要勾选Add Anaconda to my PATH environment variable,因为如果勾选，可能会影响其他程序的使用。
Python版本使用3.7，软件会自动帮忙安装
如果安装过程中让你安装VScode，可以点击安装按钮，此项我选择了。
进入Thanks for installing Anaconda界面则意味着安装成功，点击“Finish”完成安装。
开始菜单输入：Anaconda Prompt
选择下面的应用进入命令行
切到目标磁盘,比如是E盘： E:
进入文件夹所在的目录， cd E:\book然后输入jupyter notebook
自动弹出浏览器的窗口，这样就可以愉快的阅读了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f79ec4ce2f59525eab268d7690c0727/" rel="bookmark">
			【OpenCv】 VS C&#43;&#43; （零）：专栏总揽与OpenCv介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCv介绍 OpenCv是什么呢？ OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉库，它提供了很多函数，这些函数非常高效地实现了计算机视觉算法（最基本的滤波到高级的物体检测皆有涵盖）。
OpenCv支持什么语言呢？ OpenCV 使用 C/C++ 开发，同时也提供了 Python、Java、MATLAB 等其他语言的接口。而这个专栏将只使用C++开发，一个重要的原因是自己更习惯C++的编程方式。而用C++也符合对高性能的追求。这也说明如果你要看这个专栏，则需要有一些C++基础。
C++需要什么地步才可以看呢？ 第一就是需要明确的是，对于很酷的视觉算法，理解算法本身才是最重要的。
第二就是C++的基础越好，你越能写出简洁、高效的程序。
第三就是没错，还是需要C++基础，你逃避不了，但是，编程基础不需要太多，学习变量和数据类型、循环结构和选择结构、数组、函数、预处理命令、指针、结构体这些C语言基本的东西。了解类和对象、C++引用、模板、STL（标准模板库）就可以开始学习了（对于某些教材的各种多重继承和把脑袋都调晕的构造函数了解就行）。
如果你还没有这些基础，我推荐你去看视频或者看书，我非常不推荐抱着一本砖头书就一步一步看，疯狂的记笔记，而没有自己多写一些比如：计算器、简单的数据结构的代码。我比较推荐先看视频，如果你还是喜欢看书，那尽量选择一些评价高的书（选择评价高的书时，需要注意它适合初学者还是进阶的读者），以及尽量不要选择教材（有些教材考什么++i+=1;或者各种无脑指针已经偏离了程序应该简洁明确的本质了）。
我需要配置什么东西吗？ OpenCV 是跨平台的，可以在 Windows、Linux、Mac OS、Android、iOS 等操作系统上运行。这个专栏，演示都是在Window10的Visual Studio（VS）上的。对于初学者我建议抛弃VC6.0++，安装VS，如果你是Linux用户，直接用CLion也可以配置好OpenCv后完美运行。安装好VS后，你需要网上安装OpenCv的安装包。
OpenCV下载和安装 在 https://opencv.org/releases.html 可以发现最新的为 Windows 准备的最新版本 OpenCV 下载链接（现在有OpenCv4了，你可以选择OpenCv3）。可以通过这个链接下载一个 EXE 文件，该文件会把预编译好的 OpenCV 解压到你的电脑上，预编译版本支持不同版本的 Visual Studio 环境。
你也可以通过源代码编译 OpenCV，进行安装，但是会麻烦不少。
文章目录 这两篇文章主要讲的安装好OpenCv后如何进行环境配置，如果你配置出现任何问题，都欢迎您在文末评论留言，但是请尽量描述清楚，然后讲的OpenCv的一些基本例子。若有错误，欢迎您在文末评论留言。 OpenCv VS C++ 图像处理（一）: 环境配置及简单使用
OpenCv VS C++ 图像处理（二）：OpenCv基本用法
这两篇直接给了图像识别相关的代码，粗略讲了角点、图像识别相关的知识，在OpenCv3上正常运行。若有错误，欢迎您在文末评论留言。 OpenCv3 VS C++ （三）：图像识别
OpenCv3 VS C++ （四）：图像识别
这两篇是自己实现的超像素分割处理、Kmeans分类分割图片的相关代码，并较详细的进行了讲解，非常推荐大家自己试试。若有错误，欢迎您在文末评论留言。 OpenCv3 VS C++ （五）：SLIC超像素分割算法
OpenCv3 VS C++ （六）：Kmeans分类算法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f79ec4ce2f59525eab268d7690c0727/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acb8c695a25ff8958849008f74b96949/" rel="bookmark">
			qlv文件怎么打开 怎么把qlv文件转换成MP4的文件呢
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现今时代越来越多的人喜欢利用空闲时间去看电影，而优酷、爱奇艺和腾讯视频则是常用的三大主流浏览器，其中腾讯视频以其众多的独家资源和良好的用户体验收到广大用户的喜爱，那怎么把腾讯视频独家的qlv格式转换成常用的mp4格式呢？
1、接下来小编跟大家说一下迅捷视频转换器的操作流程。大家认真看哦！双击打开软件，就可以看到软件首页的界面图了！界面当中有很多操作功能，单击选择视频转换功能。
2、选择软件左上角的添加文件按钮导入你需要的素材文件，或者选择添加文件夹按钮导入文件。
3、把文件添加进来之后，就可以开始设置输出格式和输出路径，输出格式小编直接选择了mp4格式，分辨率也是默认的同原文件，如果你想设置其他分辨率，也可以选择其他分辨率，还可以自定义设置。输出路径可以点击右边的更改路径输入。
4、以上都设置好之后，就可以直接进行转换了可以点击文件的后方的蓝色转换按钮或者软件右下方的全部转换按钮。如果多个文件，建议用软件右下角的全部转换，可以一次性把所有文件都转换好。
5、点击转换按钮之后，视频会出现一个进度条，当进度条到达100%时就表示视频转换好了。此时只要打开覆盖在转换按钮上的绿色打开按钮就可以找到转换后的mp4视频了。
这个软件总体来说还是很好用的，转换速度也快，唯一的不足点大概就是新版腾讯qlv文件不能转换，很多软件也都是不可以的，问题不大，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/493e53c755758e97b44fdcc13c405490/" rel="bookmark">
			安装NVIDIA-DOCKER
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		添加链接描述
If you have nvidia-docker 1.0 installed: we need to remove it and all existing GPU containers docker volume ls -q -f driver=nvidia-docker | xargs -r -I{} -n1 docker ps -q -a -f volume={} | xargs -r docker rm -f
sudo apt-get purge -y nvidia-docker
Add the package repositories curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
distribution=$(. /etc/os-release;echo I D ID IDVERSION_ID)
curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/493e53c755758e97b44fdcc13c405490/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/611caa4cabe1493dd1c678b37b039b3c/" rel="bookmark">
			【Flutter】三十六、Flutter解决点击非输入框时关闭键盘问题及TextFormField焦点切换问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Form( key: _key, child: Column( children: &lt;Widget&gt;[ TextFormField( controller: _userController, focusNode: _userFocusNode, decoration: InputDecoration( icon: Icon(Icons.person_outline, size: 35.0, color: Theme.of(context).primaryColor), labelText: '用户名' ), validator: (value) { if (value.isEmpty) { return '用户名不能为空'; } return null; }, onSaved: (value) { setState(() { _userName = value; }); }, ), SizedBox(height: 10.0,), TextFormField( controller: _passwordController, focusNode: _passwordFocusNode, obscureText: true, decoration: InputDecoration( icon: Icon(Icons.lock_outline, size: 35.0, color: Theme.of(context).primaryColor), labelText: '密码' ), onSaved: (value) { setState(() { _password = value; }); }, validator: (value) { if (value.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/611caa4cabe1493dd1c678b37b039b3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc0f654b21c9f2523f037f65b11af7c8/" rel="bookmark">
			flutter状态栏的颜色设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一：整体设置状态栏颜色：(亲测暂时无效)
void main() { runApp(MyApp()); //黑色 SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle.dark); 白色 SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle.light); } 二：单个页面状态栏颜色改变（亲测有效）
1：使用AppBar
brightness：关键代码 appBar: AppBar( title: Text('appbar',style: TextStyle(color: Colors.black),), brightness: Brightness.light, backgroundColor: Colors.white, ), 2：未使用AppBar
单页设置更改状态栏颜色 return AnnotatedRegion&lt;SystemUiOverlayStyle&gt;( value: SystemUiOverlayStyle.dark, child: Scaffold( resizeToAvoidBottomInset: false, body: Column(), )); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d23dee3b746479ab0066543558b5b663/" rel="bookmark">
			ubuntu1804安装的自定义分区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装ubuntu系统时，如果我们要使用自定义分区的方式，那么需要配置下面几个分区：
挂载目录： / 主分区 ext4 最好分的大点，方便系统更新以及安装其他软件
/boot 主分区 ext4 1024MB
swap 逻辑分区 1024MB efi 逻辑分区 1024MB
/home 逻辑分区 ext4 剩余空间都给home
如下图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b419e411382e384dbbc60fb3c4f0f81b/" rel="bookmark">
			AndroidStudio 3.4.2配置 Opencv 3.7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：1、前期准备2、 新建AS项目3、配置NDK4、复制opencv的相关文件5、配置build-gradle6、配置Cmake7、测试8 参考链接 前言： 前段时间做项目，需要给AS配置Opencv环境，查了很多博客，遇到了很多坑，为了避免遗忘，在此记录，如有错误，请指教。
1、前期准备 下载opencv androidSdk：https://opencv.org/releases/
这里网速太慢，我截个图示意一下，我之前下载的是3.7版本 2、 新建AS项目 这一步要注意，AS3.2版本的时候可以勾选include C++ Surpport,而AS3.4.2把 NativeC++单独拿了出来，需要下拉右侧滑动条选择 Native C++,我之前找这个找了半天?
3、配置NDK NDK需要手动配置，在刚刚新建好的项目中，选择 file —&gt;setting—&gt;Android SDK —&gt; SDK tools 勾选NDK和cmake
4、复制opencv的相关文件 include文件
将下载好的opencv安装包解压后在路径*\OpenCV-android-sdk\sdk\native\jni下有一个include文件夹，复制该文件夹到我们项目中的src/main/cpp下jni 文件
在项目的main文件夹下新建一个名为jniLibs的文件夹，然后在路径*\OpenCV-android-sdk\sdk\native下有一个libs文件夹，将此文件夹复制到刚刚新建的jniLibs文件夹下。项目结构如下图所示 5、配置build-gradle 在 app下的build-gradle中的android节点下添加以下代码
sourceSets { main { jniLibs.srcDirs = ['src/main/jniLibs/libs'] } } 此代码的作用就是设置动态链接库的地址,android节点是下图圈出的部分
然后在Android.defaultConfig.externalNativeBuild 的节点内增加过滤器，如下：
abiFilters 'x86', 'x86_64', 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'mips64' 其中'x86', 'x86_64', 'armeabi', 'armeabi-v7a', 'arm64-v8a', 'mips', 'mips64'，选择一个就行，如果是在模拟器上开发就选择X86，如果在手机上选择armeabi-v7a，这一步要注意的是过滤器添加的位置不要弄错了，是添加在下图中上第一个圈出来的节点。
完整的build-gradle文件，如下
apply plugin: 'com.android.application' android { compileSdkVersion 29 buildToolsVersion "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b419e411382e384dbbc60fb3c4f0f81b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/406/">«</a>
	<span class="pagination__item pagination__item--current">407/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/408/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>