<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce0d0ece5f45d25495bd3cc7b1406e5/" rel="bookmark">
			【vm虚拟机安装centos7教程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.vmware(CentOS 7）的下载与安装 自行在vm的官网下载自己需要的版本
CentOS 7下载链接
vm官网
二.创建虚拟机安装CentOS 7 （1）双击打开vm，创建新的虚拟机
（2）选择自定义，下一步
（3） 选择稍后安装操作系统
（4）选择linux系统和CentOS7 64位
（5）为虚拟机命名，选择存储的文件路径
（6）下一步
（7）设置需要的磁盘容量（后期不够可以重新配置）
（8）选择桥接网络
（9）选择系统默认控制器，下一步
（10）选择系统默认，下一步
（11）创建新虚拟机磁盘（因为之前未安装过所以选择新建）
（12）设置需要的磁盘容量
（13）下一步
（15）完成
（16）点击编辑虚拟机设置
（17）使用ISO映像文件，找到下载好的CentOS 7，点击确定
（18）点击开启此虚拟机
（19）点击CentOS 7进行安装，等待安装（也可以直接回车）
（20）回车 等待安装
（21）选择简体中文
（22）选择带GUI的服务器
（23）点进安装位置自动分区，点完成
（24）打开以太网，点击完成
（25）配置完成后开始安装
（26）设置root密码
创建用户名用户密码
（27）安装后点击重启
（28）点击CentOS 7，进入系统
（29）许可证点接受，点击完成配置
（30）输入密码登入账号
（31）汉语 前进 跳过 开始
（32）进入linux系统界面，右击打开终端，就可以输入指令进行操作了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01c084a485a0b9f670b9ef8ef56f2459/" rel="bookmark">
			Hololens低版本不支持多通道或者单眼左眼显示问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接
自己学习记录一下
第1篇. Multi-Pass VS Single-Pass-Instanced
1.1 Multi-Pass
Multi-Pass，又称传统双通道模式。该模式是先完成左眼的渲染，然后再做右眼的渲染。这种模式虽然能很快速适配VR/MR，但是两眼之间会有一定的时滞与延迟，体验不佳。因为在这种模式下, Unity会为左右眼各分配一个Render Texture做渲染, 目的是和非VR模式下的渲染方式尽可能的兼容。
该模式可以完美支持自定义shader和后处理，即自定义shader和后处理按照传统的方法实现，不需要额外添加代码。但渲染效率并不高。
1.2 Single-Pass-Instanced
Single-Pass-Instanced，又称单通道实例化模式。在该模式下，利用渲染目标数组来执行单个绘制调用，该调用将实例实例化为每只眼睛的适当渲染目标。此外，此模式允许所有渲染都在渲染管道的一次执行中完成。
因此，选择Single Pass Instanced渲染作为混合现实应用程序的渲染路径可以节省CPU和GPU上的大量时间，并且是推荐的渲染配置。
但是，为了对每只眼睛的每个网格发出单个绘制调用，所有着色器都必须支持GPU Instancing。实例化使GPU可以在两只眼睛之间复用绘图调用。默认情况下，Unity内置着色器以及MRTK标准着色器在着色器代码中包含必要的实例化指令。如果为Unity编写自定义着色器，则可能需要更新这些着色器以支持Single Pass Instanced渲染。
1.3 Multi-Pass 或 Single-Pass-Instanced的设置方法
设置方法如下：
File ——&gt; Build Settings ——&gt; Player Settings ——&gt; XR Settings ——&gt; Stereo Rendering Mode
第2篇. Single-Pass-Instanced自定义shader
上一篇已经说到，默认的着色器以及MRTK标准着色器在着色器代码中包含必要的实例化指令。官方建议使用MRTK标准着色器，相关的技术文档可见https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/README_MRTKStandardShader.html
如果需要自定义shader，可以通过下面的方法为自定义的shader添加实例化指令。
2.1 为自定义的shader添加实例化指令
1、在预处理指令那里添加GPU Instance预处理指令，shader会根据是否开启GPU Instance生成不同的shader变体。
//添加GPU Instance预处理指令 #pragma multi_compile_instancing 2、在顶点输入输出结构体添加以下宏
//为顶点实例化一个ID UNITY_VERTEX_INPUT_INSTANCE_ID 3、针对XR的Single-Pass-Instanced，还需要再顶点输出结构体添加以下宏
//在顶点着色器声明立体目标眼睛字段输出结构 //与普通的GPU Instancing不一样的地方，XR的Single-Pass-Instanced需要添加这个宏 UNITY_VERTEX_OUTPUT_STEREO 4、为顶点着色器添加以下宏
//初始化顶点信息 //这个宏必须在Vertex Shader的最开始调用 //如果你需要在Fragment Shader里访问Instanced属性，则需要在Fragment Shader的开始也用一下 //这个宏的目的在于让Instance ID在Shader函数里也能够被访问到。 UNITY_SETUP_INSTANCE_ID(v); //在顶点程序中，将实例ID从输入结构复制到输出结构 //在Vertex Shader中把Instance ID从输入结构拷贝至输出结构中 //只有当你需要在Fragment Shader中访问每个Instance独有的属性时才需要写这个宏。 UNITY_TRANSFER_INSTANCE_ID(v,o); //分配立体目标的眼睛 //与普通的GPU Instancing不一样的地方，XR的Single-Pass-Instanced需要添加这个宏 UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o); 5、为片元着色器添加以下宏
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01c084a485a0b9f670b9ef8ef56f2459/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57954b7580def174d811c3be9f26653/" rel="bookmark">
			一键式 new 多个相同的实例（通过界面按钮 来控制 应用的创建、修改、删除，使用Docker Compose 编排应用所需环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单介绍 需求：通过界面按钮 来控制 实例的创建、修改、删除。
由于Web应用采用多服务方式开发，每个服务都可以单独访问（单独占用一个端口）。以前部署服务器，采用的Nginx监听端口 转发。但是这样就会在new整个应用的时候，就需要暴露很多端口（每个服务都可以单独访问）、很多容器（每个服务一个容器）管理起来不方便。
对部署进行调整：所有服务打成war包形式，统一部署到tomcat上，对外只需暴露出tomcat端口+服务名就可访问对应服务。
二、环境准备：Docker镜像 Tomcat:8Mysql:5.7.30webcenter/activemq:latestredis:5.0.7elasticsearch:7.7.0 注意：因elasticsearch 占用内存较大，这里所有的应用共享一个elasticsearch。其他中间件则每次new新实例，都会进行重新创建
三、安装 Docker 在创建容器时，为每个容器分配一个ip，如果不指定network则默认容器连接到docker0的虚拟网桥。
由于elasticsearch 是所有容器共享的，但是在使用Docker Compose编排时，每个Compose Docker 都会分配一个network，导致 Compose内容器与elasticsearch 不在一个网段中，Tomcat会连接不上elasticsearch 。
解决方案： 在创建elasticsearch 时，为elasticsearch 单独创建一个network（如果不单独创建，采用默认的network，Compose中容器会连接不上 Docker默认的network），因所有服务打成war包，部署在Tomcat上，所以Tomcat容器需连接 。也可不创建 但是 每次new完新实例就需单独使用命令(使不同网段容器间互联)
docker network connect 0f7725a561c1(elasticsearch 所在networkID) 7fcc20626a4e`(Tomcat容器ID) Docker Compose 一个service下 容器访问可直接使用服务名称（jdbc:mysql://mysql:3306）,如果容器是Compose 外部，则需容器互连之后，也可以采用容器名称访问。
1、elasticsearch 为elasticsearch 创建network
docker network create -d bridge elasticsearch Docker创建elasticsearch 容器 docker run --name elasticsearch --network elasticsearch -d -e ES_JAVA_OPTS="-Xms512m -Xmx512m" -e "discovery.type=single-node" -p 9200:9200 -p 9300:9300 3ff142212faf(imgeId) 这里采用初始elasticsearch 即可，线上使用自定义elasticsearch 镜像（设置访问密码等操作）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e57954b7580def174d811c3be9f26653/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c0103806863455f373f87bbc7d520c/" rel="bookmark">
			解决element-ui组件库中dialog组件只显示遮罩层，未显示弹框的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是直接粘贴的组件--基础用法
&lt;el-button type="text" @click="dialogVisible = true"&gt;点击打开 Dialog&lt;/el-button&gt;
&lt;el-dialog
title="提示"
:visible.sync="dialogVisible"
width="30%"
:before-close="handleClose"&gt;
&lt;span&gt;这是一段信息&lt;/span&gt;
&lt;span slot="footer" class="dialog-footer"&gt;
&lt;el-button @click="dialogVisible = false"&gt;取 消&lt;/el-button&gt;
&lt;el-button type="primary" @click="dialogVisible = false"&gt;确 定&lt;/el-button&gt;
&lt;/span&gt;
&lt;/el-dialog&gt;
&lt;script&gt;
export default {
data() {
return {
dialogVisible: false
};
},
methods: {
handleClose(done) {
this.$confirm('确认关闭？')
.then(_ =&gt; {
done();
})
.catch(_ =&gt; {});
}
}
};
&lt;/script&gt;
此时注意看属性文档中有这样一条
append-to-body
默认值是false，所以需要自己在el-dialog标签中手动设置
&lt;el-dialog title="我是标题" :visible.sync="dialogVisible" :append-to-body="true" &gt;...........后面代码省略
加上属性后就会显示弹框了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fabc7d3780cc2c94307a3216396fdaa/" rel="bookmark">
			Android：自定义UI预览设备
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：适配多机型UI时，如果边写边呈现是最好的，但Android机型尺寸之丰富不是所有都能提供的，这也就需要自定义。
参数采集 % adb shell wm size Physical size: 1440x3200 % adb shell wm density Physical density: 560 计算出屏幕尺寸
创建虚拟机 找到 Add Device Definition
选择 New Hardware Profile填入采集的参数 设备名字屏幕尺寸：6.27宽高像素：1440x3200内存（只用作预览，不用太大） 选择刚新建的设备，点击 Next 选一个系统版本，没有的需要下载
起名，结束
后续说明 这个是自定义的预览设备
这个是物理设备
虽然新建了设备但是总不能与原设备完全一致，很离谱，但找不到原因！！！但是能凑合用…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17e4004c0d6bde2349a7c93f3b9f8e0a/" rel="bookmark">
			Git删除/恢复本地任意提交记录的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Git删除本地任意提交记录的方法 参考：
Git删除本地任意提交记录的方法
git之删除修改某次的commit记录
删除本地提交记录的最后一条或最后N条记录 git reset --hard HEAD~1 删除提交记录中的某几条 1. 使用命令查看提交的记录： git log 2. 找到相应的记录ID 3. 执行命令：git rebase -i 记录ID 4. 进入到一个页面。 5. 使用cw命令将行首的pick替换为drop（注意每完成一个替换操作，需要按下Esc键退出vi的编辑模式）。 6. 检查确认后，按wq保存并退出 Git恢复本地任意提交记录的方法 参考：
删除git 本地commit提交与恢复最后一条记录
查看删除记录：git reflog 恢复：git reset --hard id 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/567d0c27123d51751f42bf244cdf5648/" rel="bookmark">
			【ICPC2022济南站】【树形dp】【删物品背包dp】C.DFS Order 2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【题意】 题目链接：https://codeforces.com/gym/104076/problem/C
简要题意：给定一棵n个点的有根树，对于所有的二元组 ( i , j ) (i,j) (i,j)求这颗树所有可能的dfs序中有多少个dfs序满足第 i i i个点出现在dfs序第 j j j个位置。
【思路】 赛场上假了无数次以后，我终于才理清楚了这题的dp思路。
状态定义：
定义 d p [ u ] [ i ] dp[u][i] dp[u][i]表示只考虑 u u u子树外的点的情况下，dfs序中在 u u u前面有 i i i个点的方案数。注意，这个 d p dp dp值并不能直接作为答案，还要乘上 u u u子树内部的所有可能的dfs序方案数。显然这个 d p dp dp的取值与 u u u子树的情况无关，因此这道题 d p dp dp的转移与一般树形 d p dp dp不同，这道题应当自上而下用父亲的信息更新儿子的信息。上文提到过，为了得到答案，我们还需要 u u u子树内部的dfs序方案数量，因此定义 d p 2 [ u ] dp2[u] dp2[u]表示 u u u子树内的dfs序方案数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/567d0c27123d51751f42bf244cdf5648/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1bdc98d5d2d9d6648ec03e67e435073f/" rel="bookmark">
			有关“ModuleNotFoundError: No module named ‘flask._compat’”错误的解决过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在进行flask安装后，运行程序的过程中出现了“ModuleNotFoundError: No module named ‘flask._compat’”的错误，在查询了多个网站后给出了不同的答案
其报错原因是flask版本过高导致无法识别该语法。
解决方法1：降低flask版本，1.1.2即可
pip3 install flask==1.1.2 而该方法可能存在的问题是，会导致其他代码因为flask版本过低同样无法运行。
可能会报诸如：ImportError: cannot import name ‘json‘ from ‘itsdangerous‘的错误 这一般是flask版本过低导致的，因此需要重新安装高版本flask
pip install flask==2.0.2 解决方法2：
使用高版本的flask，在flask_script/__init__.py 里面的
from ._compat import text_type
改成
from flask_script._compat import text_type
从而能够解决该问题，在查找资料的过程中，我认为以下链接的解释更为专业和详细，能够让大家清楚了解flask_script的作用。
Flask-script使用及错误No module named flask._compat_eaglecolin的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be89b0f68b650edb31c9b9a38a097d25/" rel="bookmark">
			github个人博客快速搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 首先搭建起一个github博客1 左上角标题及简介以及下方的介绍2 评论和访客数3 文章4 Home Archives Categories 和 Tags5 Collections6 Demo7 About 首先搭建起一个github博客 首先建立一个个人博客github仓库。其实只要把 需要的代码 fork下来, 仓库名改为自己的{{github.username}}.github.io就可以了。
这里以shen-xmas下的shen-xmas.github.io仓库为例。(博客样板如首页)
fork下来项目以后别忘了看看 代码仓库-Settings-Pages的Branch等设置好没有。
大概等待几分钟看到settings-pages出现如下图标则表示已搭建成功, 可以通过其中的url访问了。
然后根据以下做需要的改造即可:
(Ps: 原本fork自大佬HyG, 做了一些个人改动。这里记录下各个文件的用途, 也帮助像我一样很少接触前端的后端迅速上手。)
1 左上角标题及简介以及下方的介绍 变量都位于_config.yaml文件,直接修改即可。
title 左上角标题brief-intro 左上角简介description_footer 下方的小字 2 评论和访客数 评论使用的是Disqus插件。访问量使用的百度统计。不是放在逻辑里用代码写的。
注册自己对应的账号ID等… 直接在_config,yaml中修改对应变量即可。
3 文章 文章都放置在_posts中, 需要按特定格式书写, 是markdown格式。
4 Home Archives Categories 和 Tags 这些的展现逻辑都已经写好了, 不用动。
Archives是按照时间排序。Categories是按类别排序。Tags是按照tag过滤。
文章开头都会填写这些字段的值, 多字段直接空格隔开即可, 如: --- layout: post title: "填写需要的标题" categories: Java Python Golang tags: Java Python Golang author: Shen-Xmas --- * content {:toc} 然后接下来就可以按照markdown的格式书写内容了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be89b0f68b650edb31c9b9a38a097d25/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24203e67f08a891ddc8c9cbe135fe9cb/" rel="bookmark">
			STL——vector与迭代器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言：vector与数组迭代器---“通用指针"迭代器的本质迭代器的分类迭代器失效 vector功能复写成员变量构造函数默认构造函数自定义的构造函数拷贝构造函数赋值运算符 size()capacity()operator[]begin()end()reserve()resize()push_back()pos_back()insert()erase()find(） 全部代码 前言： 博主收集的资料New Young，连载中。博主收录的问题:New Young转载请标明出处：New Young vector与数组 vector在底层是一种类似数组的C++类模板，因此vector容器一但实例化其大小是不变的，但是容器中指向堆上的元素对象是动态变化的，支持“增删查改"，同数组一样对于插入，insert的效率是很低的
迭代器—“通用指针" 迭代器的本质 循环的控制方式有2种：标志控制(while),计数控制(for),而迭代器将这2种循环方式的统一为一种控制方式—迭代器控制—“通用指针"为什么称迭代器为指针，因为其的行为和指针非常相似，另外不同容器的迭代器类型是不同的，因此这里的“通用"是一种概念上的通用几乎所有的的泛型容器和泛型算法都使用迭代器来访问对象 迭代器的分类 迭代器功能Input_iterator–输入迭代器只提高读操作Output_iterator–输出迭代器只提高写操作Forward_iterator–单向迭代器只能向前访问下一元素，不能向后访问，支持++Bidirectional_iterator–双向迭代器双向访问迭代器，支持++与–Random_iterator–随机迭代器可以随机访问对象中的每一个元素，支持++，-,+,–等运算 从表中可以得出，功能更全的迭代器是支持向功能少的迭代器支持的接口进行传参的
迭代器失效 迭代器失效指的是：当容器底层发生变化，原来的迭代器可能由于元素存储位置的变动，成为野指针或者后续的迭代器不在指向准确的数据。
常见的引发操作：insert()时的扩容，erase（）的缩容，clear（），remove()等
解决方法：及时的更新迭代器并通过返回值得到正确的指向下一个元素的
vector功能复写 成员变量 typedef T* iterator; iterator _start; iterator _finish; iterator _end_of_storage; 构造函数 默认构造函数 vector() :_start(nullptr), _finish(nullptr), _end_of_storage(nullptr) {} 自定义的构造函数 vector支持通过迭代器区间来初始化对象
template&lt;class inputIterator&gt; vector(inputIterator first, inputIterator last) :_start(nullptr), _finish(nullptr), _end_of_storage(nullptr) { while (first != last) { push_back(*first); ++first; } } 拷贝构造函数 vector(const vector&lt;T&gt;&amp; v)//提前初始化成员，防止delete随机值 : _start(nullptr), _finish(nullptr), _end_of_storage(nullptr) { vector&lt;T&gt; tmp(v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24203e67f08a891ddc8c9cbe135fe9cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38e831f46a6e27189820352c0f9cd84e/" rel="bookmark">
			【c&#43;&#43;】：智能指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一 智能指针是什么1.1 为什么要使用智能指针 二 内存泄漏2.1 什么是内存泄漏，内存泄漏的危害2.2 内存泄漏分类2.3 如何检测内存泄漏2.4如何避免内存泄漏 三 智能指针的使用及原理3.1 std::auto_ptr3.2 std::unique_ptr3.3 std::shared_ptr3.4 std::weak_ptr3.5 定制删除器 四 C++11和boost中智能指针的关系 一 智能指针是什么 智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源
1.1 为什么要使用智能指针 看下面的代码
int div() { int a, b; cin &gt;&gt; a &gt;&gt; b; if (b == 0) { throw "除0错误"; } return a / b; } void Func() { int* p1 = new int; int* p2 = new int; cout &lt;&lt; div() &lt;&lt; endl; cout &lt;&lt; "delete p1"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38e831f46a6e27189820352c0f9cd84e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/078c9a324ad24ce1da062a0b58956907/" rel="bookmark">
			centos7 防火墙设置 多网卡 内网访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0 应用场景 服务器有多个网卡：
公网的ip为210.xx.xx.xx（interface为en1）。内网的为192.xx.xx.xx（interface为en2）。允许公网ip的443端口，开放所有内网的访问。 注意：下面加粗的命令为实际需要操作的操作，如：开启服务。其他的命令是补充的细节，不需要操作，如：关闭服务。
准备知识：firewall中支持如下不同的区域区隔与过滤规则，之后不同的配置可以参考下面的内容：
区域
drop: 丢弃所有进入的包，而不给出任何响应 block: 拒绝所有外部发起的连接，允许内部发起的连接 public: 允许指定的进入连接 external: 同上，对伪装的进入连接，一般用于路由转发 dmz: 允许受限制的进入连接 work: 允许受信任的计算机被限制的进入连接，类似 workgroup home: 同上，类似 homegroup internal: 同上，范围针对所有互联网用户 trusted: 信任所有连接 过滤规则
source: 根据源地址过滤 interface: 根据网卡过滤 service: 根据服务名过滤 port: 根据端口过滤 icmp-block: icmp 报文过滤，按照 icmp 类型配置 masquerade: ip 地址伪装 forward-port: 端口转发 rule: 自定义规则 1 开启服务 开启服务：
systemctl start firewalld.service 关闭服务：
systemctl stop firewalld.service 开机自启：
systemctl enable firewalld.service 取消开机自启：
systemctl disable firewalld.service 2 将内网的interface添加到信任区域 将内网的网卡添加为信任区域：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/078c9a324ad24ce1da062a0b58956907/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b38c7af5540b50213b2cade6e7c7fd20/" rel="bookmark">
			Java线程池示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package cn.stydy; import com.google.common.util.concurrent.ThreadFactoryBuilder; import java.util.concurrent.*; public class ThreadPoolTest { private static ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("thread-pool-%d").build(); private static ThreadPoolExecutor executorService = new ThreadPoolExecutor(2, 20, 60L, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10), threadFactory, new ThreadPoolExecutor.AbortPolicy()); public static void main(String[] args) { for (int i = 1; i &lt;= 15; i++) { //创建15个任务 executorService.execute(new Task("第" + i + "个任务")); } // 关闭线程池 executorService.shutdown(); } private static void printThreadPoolStatus(ThreadPoolExecutor executor) { BlockingQueue queue = executor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b38c7af5540b50213b2cade6e7c7fd20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/647ddddcd0c80271e6c717ba65ec4ee1/" rel="bookmark">
			HW6：Threads and Locking
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MIT6.828_HW6_Threads and Locking
ph.c程序 这个实验给了我们一个实例ph.c，这个程序会创建一个线程，thread，如下所示：
static void * thread(void *xa) { long n = (long) xa; int i; int b = NKEYS/nthread; int k = 0; double t1, t0; // printf("b = %d\n", b); t0 = now(); for (i = 0; i &lt; b; i++) { // printf("%d: put %d\n", n, b*n+i); put(keys[b*n + i], n); } t1 = now(); printf("%ld: put time = %f\n", n, t1-t0); // Should use pthread_barrier, but MacOS doesn't support it .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/647ddddcd0c80271e6c717ba65ec4ee1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f9bdd560877385a4e51b9a8f4f78d62/" rel="bookmark">
			数据库安全，如何防止数据库被入侵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近很多小伙伴都反应自己的游戏、网站数据库遭到了不同程序的入侵，轻者被篡改数据，严重者数据库数据被全部删除，还有的小伙伴甚至被勒索，那么数据库攻击都有哪些，我们该如何预防数据库被入侵呢？
常见的数据库攻击一般有
1、数据库弱口令：弱口令容易被黑客暴力破解，我们一般在选择口令密码时，建议搭配字母、数字、符号来增加密码的复杂程序。
2、SQL注入：寻找WEB应用防火墙功能的服务器，可以有效防止SQL注入。
3、数据库的3306端口：数据库端口大部分小伙伴都是默认的，如果对外开发也很容易被爆破，这个时候一定要对相关的数据库端口做安全策略，限制对外开放，或者使用phpmyadmin对数据库进行管理等操作，网站的数据库调用账户使用普通权限账户，只有读写，增加删除等操作。
4、数据库版本漏洞：数据库版本出现的漏洞针对数据库厂商打上补丁，防止其版本漏洞被黑客利用，做好系统安全工作，经常查看数据库操作日志记录，不要以为麻烦就不处理，等出现纰漏悔之晚矣。
最后切记要开启数据库日志记录，并且定期查看数据库日志，提早预防，并且定期要记得备份数据哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33aee292fa2346207f49ef53895d4073/" rel="bookmark">
			linux之输入输出流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出流： 源代码：从未知参数读取，然后输入到流中，从后向前 #include &lt;stdio.h&gt; int printf(const char *format, ...); int fprintf(FILE *stream, const char *format, ...); int dprintf(int fd, const char *format, ...); int sprintf(char *str, const char *format, ...); int snprintf(char *str, size_t size, const char *format, ...); #include &lt;stdarg.h&gt; int vprintf(const char *format, va_list ap); int vfprintf(FILE *stream, const char *format, va_list ap); int vdprintf(int fd, const char *format, va_list ap); int vsprintf(char *str, const char *format, va_list ap); int vsnprintf(char *str, size_t size, const char *format, va_list ap);	描述：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33aee292fa2346207f49ef53895d4073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23dd2a006b9d4a67f8732fe13eb9cdd6/" rel="bookmark">
			微信小程序点击跳转页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：index.wxml
&lt;button bindtap="gotoPage" style="color: rgb(151, 27, 27);"&gt;详情页面&lt;/button&gt; 第二步：index.js
// 详情页面跳转页面 gotoPage: function (options) { wx.navigateTo({ url: '/pages/xiang/xiang', }) }, 以下是点击跳转的详情页面：
xiang.wxml:
&lt;view&gt; &lt;view class="v1"&gt; 111111111111111111 &lt;/view&gt; &lt;view class="v21"&gt; &lt;view class="v2"&gt; &lt;image class="im1" src="/imgs/蓝色花.png" alt=""/&gt; &lt;/view&gt; &lt;view class="v3"&gt; &lt;text&gt;智驾网\n&lt;/text&gt; &lt;text style="font-size:12px; color: rgb(180, 177, 177);"&gt;2022年11月24日10:13 辽宁 汽车领域创作者&lt;/text&gt; &lt;/view&gt; &lt;view class="v4"&gt;+关注&lt;/view&gt; &lt;/view&gt; &lt;view class="v5"&gt; &lt;text&gt;从今年中国市场电动汽车的飞速发展来看，在汽\n&lt;/text&gt; &lt;text&gt;车行业整体平缓发展的大盘中，电动汽车呈现出\n&lt;/text&gt; &lt;text&gt;指数级的变化。这对于小米集团有两个方面的刺\n&lt;/text&gt; &lt;text&gt;激，一方面必须进一步加大研发投入，才可能保\n&lt;/text&gt; &lt;text&gt;证产品在投放市时，产品不落后，其二，必须提\n&lt;/text&gt; &lt;text&gt;速产品上市的时间，防止在产品上市时，市场的\n&lt;/text&gt; &lt;text&gt;高速增长趋势已经结束,而产品已经饱合。\n&lt;/text&gt; &lt;/view&gt; &lt;view class="v6"&gt; &lt;image class="im2" src="https://c-ssl.dtstatic.com/uploads/item/202003/08/20200308172425_3eCnW.thumb.1000_0.jpeg"&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class="v51"&gt; &lt;text&gt;节奏，同时不焦虑对于雷布斯变为雷斯克更\n&lt;/text&gt; &lt;text&gt;为重要\n&lt;/text&gt; &lt;text&gt;节奏，同时不焦虑对于雷布斯变为雷斯克更\n&lt;/text&gt; &lt;text&gt;为重要\n&lt;/text&gt; &lt;text&gt;节奏，同时不焦虑对于雷布斯变为雷斯克更\n&lt;/text&gt; &lt;text&gt;为重要\n&lt;/text&gt; &lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23dd2a006b9d4a67f8732fe13eb9cdd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/044152108a0c07fddab3e32907a97594/" rel="bookmark">
			HTML5学习笔记（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CSS3 多列布局 CSS3新增了一种布局方式——多列布局。使用多列布局，可以轻松实现类似报纸那样的布局。
多列布局的应用非常广泛，像各大电商网站、素材网站中常见的“瀑布流效果”。
column-count属性来定义多列布局的列数。
column-width属性来定义多列布局中每一列的宽度。
column-gap属性来定义列与列之间的间距。
column-rule属性来定义列与列之间的边框样式。
column-rule: width style color; column-span属性来实现多列布局的跨列效果。这个属性跟表格中的colspan属性类似。
滤镜效果 所有的滤镜效果都是使用filter属性来实现的。
brightness()亮度 来实现亮度滤镜效果。亮度滤镜可以减弱或增强图片的亮度。
filter: brightness(百分比); brightness()方法的取值是一个百分比，其中0%~100%表示减弱图片的亮度，例如0%就是完全黑色；100%以上表示增强图片的亮度，例如200%就是将亮度提高2倍。
grayscale() 灰度（黑白照片） 可以实现灰度滤镜效果。灰度滤镜可以将彩色图片转换成黑白图片。
filter: grayscale(百分比); grayscale()方法的取值是一个百分比，其中0%表示不做任何修改，100%表示完全灰度（即黑白图片）
sepia() 复古滤镜 用来实现复古滤镜效果。复古滤镜，也叫褐色滤镜。
filter: sepia(百分比); sepia()方法的取值是一个百分比，取值范围为0%~100%。其中，0%表示没有转换，100%表示复古效果。
invert()反色滤镜 用来实现反色滤镜效果的。反色，指的是将红、绿、蓝3个通道的像素取各自的相反值。
filter: invert(百分比); nvert()方法的取值是一个百分比，取值范围为0%~100%。其中，0%表示没有转换，100%表示反转所有颜色。
hue-rotate()色相旋转 实现色相旋转的滤镜效果。
filter: hue-rotate(度数)； hue-rotate()方法的取值是一个度数，单位为deg（即degree的缩写）。其中，0deg表示不旋转，360deg表示旋转360°，也就是相当于一个循环。
drop-shadow()阴影 用来实现阴影滤镜效果。
filter: drop-shadow(x-offset y-offset blur color); opacity()透明度 实现透明度滤镜效果。
filter: opacity(百分比); opacity()方法的取值是一个百分比，取值范围为0%~100%。其中，0%表示完全透明，100%表示完全不透明。
blur() 模糊度 blur()方法来实现模糊度滤镜效果，也就是“马赛克”。
filter: blur(像素); blur()方法的取值是一个像素值，取值越大，模糊效果越明显。
contrast()对比度 实现对比度滤镜效果。
filter: contrast(百分比); contrast()方法的取值是一个百分比。其中，0%~100%表示减弱对比度，例如0%则是灰度图片；100%以上表示增强对比度，例如200%表示增强对比度为原来的2倍。
saturate()饱和度 实现饱和度滤镜效果。
filter: saturate(百分比); saturate()方法的取值是一个百分比。其中，0%~100%表示减弱饱和度，100%以上表示增强饱和度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/044152108a0c07fddab3e32907a97594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f00d4d290aa8cbdecc1f10cc0ce594/" rel="bookmark">
			数据库——数据库备份与恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
原因：
数据库的备份与恢复：
1、使用MySQLdump命令备份
2、恢复数据库
表的导入和导出
1、表的导出
2、表的导入
原因： 尽管采取了一些管理措施来保证数据库的安全，但是不确定的意外情况总是有可能造成数据的损失，例 如意外的停电、管理员不小心的操作失误都 可能会造成数据的丢失。保证数据安全最重要的一个措施是 确保对数据进行 定期备份。如果数据库中的数据丢失或者出现错误，可以使用备份的数据进行恢复，这 样就尽可能地降低了意外原因导致的损失。 数据备份是数据库管理员非常重要的工作之一。系统意外崩溃或者硬件的损坏都可能导致数据库的丢失，因此MySQL 管理员应该定期地备份数据库，使得在意外情况发生时，尽可能减少损失 . 数据库的备份与恢复： 1、使用MySQLdump命令备份 MySQLdump 是 MySQL 提供的一个非常有用的数据库备份工具。 MySQLdump 命令执行时，可以将数据库备份成一个文本文件，该文件中实际包含了多个CREATE 和 INSERT 语句，使用这些语句可以重新创建 表和插入数据 再改路径下输入cmd 说明： -u 用户名 -h 主机，如果是本机省略 -p test 要备份的库 还可以使用改命令备份某个表 多个表直接用空格隔开 可以备份多个数据库，加入参数 --databases 多个库之间用空格隔开 2、恢复数据库 如果像之前导入某个库下的表，此时生成的 sql 语句中不存在创建库的语句，需要自己创建库或是登录的 到改库下再导入备份的语句。 表的导入和导出 MySQL 数据库导出数据时，允许使用包含导出定义的 SELECT 语句进行 数据的导出操作。该文件被创建 到服务器主机上，因此必须拥有文件写入权 限（ FILE 权限）才能使用此语法 这是因为MySQL默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。那么指定的目录是什么呢？ 找到my.ini文件 添加 secure-file-priv=D:/ secure-file-priv=D:/ 然后以管理员身份运行 cmd 重新启动 mysql net stop mysql net start mysql SHOW GLOBAL VARIABLES LIKE '%secure%' 1、表的导出 SELECT * FROM books INTO OUTFILE 'D:/bf/books.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f00d4d290aa8cbdecc1f10cc0ce594/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f28995172d4275c9f0aa3bb19e2be5b5/" rel="bookmark">
			git 进阶系列教程--add
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git add ---- 将工作区内容放入暂存区 功能介绍 将工作区(working directory)中的内容放入暂存区(staging area)追踪文件(解释：刚被添加到工作区的文件处于未跟踪状态(Untracked files),该命令会将新添加的文件放入暂存区，并且文件将处于已跟踪状态) 命令解析 git add . 添加工作区所有文件进入暂存区
最后的点可以理解为正则里的通配符，git add后面添加的是可以为任意合法的路径。
比如：a.txt、/b.txt、*.txt、a/b.txt…
git add --all 这个命令和git add .命令很像。都是添加工作区所有文件进入暂存区。但是区别还是有的。
区别一：在git的2.0版本之前，git add .只会添加修改的文件、创建的文件。但是，如果你删除了一个文件，这个命令运行后，不会记录你删除了这个文件。以至于，如果你从暂存区恢复所有文件时，删除的文件还会出现在工作区，或者是提交代码后，被删除的文件依旧会在版本库中。所以你需要做其他的操作来办到删除功能，例如：git rm。但是git add --all命令会将所有结果一起放入暂存区（修改、创建、删除）。然后在git的2.0版本后，两者统一了。都是git add --all的效果了。
区别二：git add .命令认为是添加工作区所有文件进入暂存区，是因为我们在运行git命令时，通常是在项目的根目录。git add .的命令其实是提交当前目录的所有文件，而不是项目中的所有文件都提交。git add --all则是真正的将项目中的所有未忽略的文件添加到暂存区。
工作中，上面的这条命令能处理99%需要add命令的情况。下面的知识是为有好奇add命令还能做什么的同学准备的
git add -n . 这条命令多了一个选项：-n,是选项：--dry-run的简写形式 作用是：并不会将匹配到的文件真的添加到暂存区，而是查看一下是否存在文件还没被追踪或者是修改过但是未添加到暂存区。 回车后，会将没有追踪的文件或未添加到暂存区的文件显示出来。 但是通常我们都不会用到该选项，因为查看工作区的状态我们有更好的选择：git status git add -v . 这条命令的选项：-v，全写是：--verbose 作用：提交的冗余模式 我也不清楚这个冗余模式是什么，官网对它这个命令的解释就一句话：Be verbose. 有清楚的同学踢我一下，评论甩我个链接，不胜感激。 git add -p 文件名.txt 作用是，这样添加一个文件的部分内容进入暂存区。具体做法是，输入命令后会进入交互模式。如果输入Y就全部添加，如果输入e就进入编辑模式，只保留想添加的部分，然后保存退出，最后Y确认。
git add -f . 选项：-f,全写：--force 作用：允许添加已经被忽略的文件 众所周知，在项目的根目录，一版会有.gitignore文件，用于告诉git，哪些文件是不用纳入git管理的。 而-f选项则不惯着这个配置文件。就算被忽略的文件，它也会强行追踪，毕竟force(强制)是程序员的老朋友了。 git add -i .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f28995172d4275c9f0aa3bb19e2be5b5/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/193/">«</a>
	<span class="pagination__item pagination__item--current">194/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/195/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>