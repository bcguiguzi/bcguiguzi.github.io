<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2248e44555e8d773a48c0b79f7e311ba/" rel="bookmark">
			CentOS 6.9安装LibreOffice及字体安装及python调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近由于遇到了要使用预览的功能，然后有一个doc转PDF的需求，然后需要使用libreoffice的功能，然后使用 soffice --headless --invisible --convert-to pdf /tmp/abc.docx --outdir /tmp/ 就可以安装了。
libreoffice安装
［root@CentOS~］# yum install libreoffice ［root@CentOS~］# yum install libreoffice-headless 12 字体安装
［root@CentOS~］# mkdir /usr/share/fonts/simsun ##拷贝windows中的simsun.ttc到/usr/share/fonts/simsun/ 然后执行以下命令 ［root@CentOS~］#cd /usr/share/fonts/simsun ［root@CentOS~］#mkfontscale ［root@CentOS~］#mkfontdir ［root@CentOS~］#fc-cache -fv 执行以下命令让字体生效 ［root@CentOS~］#source /etc/profilesoffice --headless --invisible --convert-to pdf /tmp/abc.docx --outdir /tmp/######python调用借助libreoffice将doc进行格式转换#!/usr/bin/env python# coding:utf-8import subprocessoutput = subprocess.check_output(["soffice","--headless","--invisible","--convert-to","docx","/home/requiem/workspace/python3/test.doc","--outdir","/home/requiem/workspace/python3/"])########################转自：https://blog.csdn.net/u011053407/article/details/74989837https://blog.csdn.net/qq_30371793/article/details/76578181
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0906a6ddc1dda03b1b1657f48930f723/" rel="bookmark">
			vue单页应用如何在页面刷新时保留状态数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Vue单页应用中，如果在某一个具体路由的具体页面下点击刷新，那么刷新后，页面的状态信息可能就会丢失掉。这时候应该怎么处理呢？如果你也有这个疑惑，这篇文章或许能够帮助到你 一、问题 现在产品上有个需求：单页应用走到某个具体的页面，然后点击刷新后，刷新的页面要与刷新前的页面要保持一致。
这时候就需要我们保存刷新之前页面的状态。
二、一种解决方案 在这个Vue单页应用中，王二是用Vuex作为状态管理的，一开始王二的思路是将Vuex里的数据同步更新到localStorage里。
即：一改变vuex里的数据,便触发localStorage.setItem 方法，参考如下代码：
import Vue from "vue" import Vuex from "vuex" Vue.use(Vuex) function storeLocalStore (state) { window.localStorage.setItem("userMsg",JSON.stringify(state)); } export default new Vuex.Store({ state: { username: "王二", schedulename: "标题", scheduleid: 0, }, mutations: { storeUsername (state,name) { state.username = name storeLocalStore (state) }, storeSchedulename (state,name) { state.schedulename = name storeLocalStore (state) }, storeScheduleid (state,id) { state.scheduleid = Number(id) storeLocalStore (state) }, } }) 然后在页面加载时再从localStorage里将数据取回来放到vuex里，于是王二在 App.vue 的 created 钩子函数里写下了如下代码：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0906a6ddc1dda03b1b1657f48930f723/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/245ba84c00b4f93061f6a11f5825317b/" rel="bookmark">
			5.3.6 直方图统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、灰度图像直方图统计
直方图统计是图像处理中的一个非常重要的操作。VTK中实现直方图统计功能的filter是vtkImageAccumulate。其将每个组分的数值范围划分为离散的间隔，然后统计每个灰度间隔上的像素数目。vtkImageAccumulate输入和输出都是vtkImageData类型，因此直方图也可以看做是一幅图像；对于输入图像的像素数据类型可以是任意的，但是最大支持3个组分像素类型，而输出图像的像素数据类型为int型。一个灰度图像的直方图为一个一维图像。
#include"vtkSmartPointer.h" #include"vtkJPEGReader.h" #include"vtkImageAccumulate.h" #include"vtkImageData.h" #include"vtkIntArray.h" #include"vtkDataObject.h" #include"vtkFieldData.h" #include"vtkBarChartActor.h" #include"vtkProperty2D.h" #include"vtkTextProperty.h" #include"vtkLegendBoxActor.h" #include"vtkImageActor.h" #include"vtkRenderer.h" #include"vtkRenderWindow.h" #include"vtkRenderWindowInteractor.h" int main() { vtkSmartPointer&lt;vtkJPEGReader&gt;reader = vtkSmartPointer&lt;vtkJPEGReader&gt;::New();//读入一幅灰度图像 reader-&gt;SetFileName("data\\lena-gray.jpg"); reader-&gt;Update(); int bins = 16; //直方图一维数组的维数 int comps = 1; vtkSmartPointer&lt;vtkImageAccumulate&gt;histogram = vtkSmartPointer&lt;vtkImageAccumulate&gt;::New(); histogram-&gt;SetInputData(reader-&gt;GetOutput()); histogram-&gt;SetComponentExtent(0, bins - 1, 0, 0, 0, 0); //6个参数是RGB3个组分直方图的最大最小值 histogram-&gt;SetComponentOrigin(0, 0, 0); //函数设置的是统计每个组分直方图时的起始灰度值 histogram-&gt;SetComponentSpacing(256.0 / bins, 0, 0); //设置直方图每个间隔代表的灰度范围 histogram-&gt;Update(); int* output = static_cast&lt;int*&gt;(histogram-&gt;GetOutput()-&gt;GetScalarPointer()); vtkSmartPointer&lt;vtkIntArray&gt; frequencies = vtkSmartPointer&lt;vtkIntArray&gt;::New(); frequencies-&gt;SetNumberOfComponents(1); for (int j = 0; j &lt; bins; ++j) { for (int i = 0; i &lt; comps; ++i) { frequencies-&gt;InsertNextTuple1(*output++); } } vtkSmartPointer&lt;vtkDataObject&gt; dataObject = vtkSmartPointer&lt;vtkDataObject&gt;::New(); dataObject-&gt;GetFieldData()-&gt;AddArray(frequencies); /*******************************************************/ vtkSmartPointer&lt;vtkBarChartActor&gt; barChart = vtkSmartPointer&lt;vtkBarChartActor&gt;::New(); barChart-&gt;SetInput(dataObject); barChart-&gt;SetTitle("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/245ba84c00b4f93061f6a11f5825317b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5510e0e778c622d381743b9c47c85bd6/" rel="bookmark">
			以太坊虚拟机(EVM)架构和源码简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		EVM架构简析和源码分析 EVM为以太坊虚拟机。以太坊底层通过EVM模块支持智能合约的执行和调用，调用时根据合约的地址获 取到代码，生成具体的执行环境，然后将代码载入到EVM虚拟机中运行。通常目前开发智能合约的高级 语言为Solidity,在利用solidity实现智能合约逻辑后，通过编译器编译成元数据（字节码）最后发布到以 坊上。 EVM架构概述 EVM本质上是一个堆栈机器，它最直接的的功能是执行智能合约，根据官方给出的设计原理，EVM的主
要的设计目标为如下几点：
简单性确定性空间节省为区块链服务安全性保证便于优化针对以上几点通过对EVM源代码的阅读来了解其具体的设计思想和工程实用性。 EVM存储系统 机器位宽 EVM机器位宽为256位，即32个字节，256位机器字宽不同于我们经常见到主流的64位的机器
字宽，这就标明EVM设计上将考虑一套自己的关于操作，数据，逻辑控制的指令编码。目前主流的处理
器原生的支持的计算数据类型有：8bits整数，16bits整数，32bits整数，64bits整数。一般情况下宽字
节的计算将更加的快一些，因为它可能包含更多的指令被一次性加载到pc寄存器中，同时伴有内存访问
次数的减少。目前在X86的架构中8bits的计算并不是完全的支持（除法和乘法），但基本的数学运算大概
在几个时钟周期内就能完成，也就是说主流的字节宽度基本上处理器能够原生的支持，那为什么EVM要采
用256位的字宽。主要从以下两个方面考虑：
时间，智能合约是否能执行得更快空间，这样是否整体字节码的大小会有所减少gas成本 时间上主要体现在执行的效率上，我们以两个整形数相加来对比具体的操作时间消耗。32bits相加的X86
的汇编代码
mov eax, dword [9876ABCD] //将地址9876ABCD中的32位数据放入eax数据寄存器 add eax, dword [1234DCBA] //将1234DCBA地址指向32位数和eax相加,结果保存在eax中 64bits相加的X86汇编代码
mov rax, qword [123456789ABCDEF1] //将地址指向的64位数据放入64位寄存器 add rax, qword [1020304050607080] //计算相加的结果并将结果放入到64位寄存器中下面我们看一下在64bits机器上如何完成256bits的加法 mov rax, qword [9876ABCD] add qword [1234DCBA], rax mov rax, qword [9876ABCD+8] adc qword [1234DCBA+8], rax//这里应用adc带进位的加法指令，影响进位标记CF mov rax, qword [9876ABCD+16] adc qword [1234DCBA+16], rax mov rax, qword [9876ABCD+24] adc qword [1234DCBA+24], rax由上面的的汇编指令我们可以看出256位操作要比系统原生支持的要复杂的多，从时间上考虑采用 256位这样的字节宽度，实际的收益并不大。 空间上，由上面的汇编操作（在实际的EVM中操作类似）我们不难看到，如果直接对地址进行操 作似乎是一种快速的方式，并减少了操作数，进而操作码也有所减少，相应的智能合约的字节流 大小就会小很多，gas花费也会有所下降。但是从另外一个层面来讲，支持宽字节的数据类型势必 会造成在处理低字节宽度的数据时候带来存储上的浪费（如添加标识用来区分类型）或者添加额外 的操作来进行数据的compact。从时间和空间角度来看，仅支持256字节宽度的选择有利有弊，具
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5510e0e778c622d381743b9c47c85bd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f07dbc097cf4e6758ee04ae99e19db6/" rel="bookmark">
			c语言一些简单的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三个数找最大值
//C语言（.c文件） #include &lt;stdio.h&gt; int max(int x,int y) { int t; t=x&gt;y?x:y; return t; } int main() { int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int maxs=max(a,max(b,c)); printf("%d",maxs); } 素数判断
#include &lt;stdio.h&gt; int main() { int m,n,i; while(m--) { scanf("%d",&amp;n); for(i=2;i&lt;n;i++) if(n%i==0) break; if(i==n) printf("%d是素数\n",n); else printf("%d不是素数\n",n); }return 0; } #include&lt;stdio.h&gt; #include&lt;math.h&gt; void main() { int m,flag,i; scanf("%d",&amp;m); flag=1; for(i=2;i&lt;=sqrt(m);i++) { if(m%i==0) { flag=0; break; } } if(flag) { printf("%d是素数\n",m); } else { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f07dbc097cf4e6758ee04ae99e19db6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4be28632cdfb3bd5426f8a711965d39/" rel="bookmark">
			简述C/S和B/S模式的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C/S结构 ，即 Client/Server (客户机/服务器)结构，是大家熟知的软件系统体系结构，通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，可以充分利用两端硬件环境的优势。早期的软件系统多以此作为首选设计标准。。 B/S结构 ，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对 C/S结构 的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在 服务器端 实现，形成所谓3-tier结构。 B/S结构 ，主要是利用了不断成熟的WWW浏览器技术，结合浏览器的多种Script语言(VBScript、JavaScript…)和ActiveX技术，用通用浏览器就实现了原来需要复杂专用软件才能实现的强大功能，并节约了开发成本，是一种全新的软件系统构造技术。随着 Windows 98 / Windows 2000 将浏览器技术植入 操作系统 内部，这种结构更成为当今应用软件的首选体系结构。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/359c1847d7234377fdbf8c36ef81bdc6/" rel="bookmark">
			PHP中单例模式实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于我以前是做java开发的，在使用单例模式的时候，首先想到的想用饿汉式，然后发现在PHP中，有这样一个特性：因为PHP不支持在类定义时给类的成员变量赋予非基本类型的值。如表达式，new操作等等。转而想要确保这个单例模式的原子性，发现PHP中也没有像JAVA中的线程安全问题。嘿嘿，你说PHP好不好？那么OK接下来就试试PHP的懒汉式单例模式了。
一、三私一公：
①、私有静态属性，又来储存生成的唯一对象
②、私有构造函数
③、私有克隆函数，防止克隆——clone
④、公共静态方法，用来访问静态属性储存的对象，如果没有对象，则生成此单例
二、关键词instanceof
检查此变量是否为该类的对象、子类、或是实现接口。
1、一个private的__construct是必须的，单例类不能在其它类中实例化，只能被自身实例化； 2、拥有一个保存类的实例的静态成员变量; 3、一个静态的公共方法用于实例化这个类，并访问这个类的实例;
class SingleInstance{
private function _construct(){
}
private static $instance;
private function _clone(){
}
public static function getInstance(){
if(!self::$instance instanceof SingleInstance){
self::$instance=new SingleInstance();
}
return self ::$instance;
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd92da0eecc3ee23cb377e193bd99572/" rel="bookmark">
			Python错误：TypeError: &#39;list&#39; object is not callable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在学习并使用Python的过程中，总会遇到各种各样的错误，因此，写下整个系列的帖子，方便自己回顾，也方便其他同学参阅。
正文 在Python运行过程中遇到了如下错误： TypeError: ‘list’ object is not callable
list = ['经点', '咸汤', '鱼儿', '骆驼'] tup_1 = (1, 2, 3, 4, 5) tupToList = list(tup_1) print(tupToList) 代码运行后出错了，提示是TypeError: ‘list’ object is not callable
Traceback (most recent call last): File "&lt;pyshell#42&gt;", line 1, in &lt;module&gt; counterA() TypeError: 'list' object is not callable callable()是python的内置函数，用来检查对象是否可被调用，可被调用指的是对象能否使用()括号的方法调用，类似于iterable（） 在如上代码中，由于变量list和函数list重名了，所以函数在使用list函数时，发现list是一个定义好的列表，而列表是不能被调用的，因此抛出一个类型错误
解决办法 我们只需修改变量名listx就可以了：
listx = ['经点', '咸汤', '鱼儿', '骆驼'] tup_1 = (1, 2, 3, 4, 5) tupToList = list(tup_1) print(tupToList) 运行后和结果是正常的：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd92da0eecc3ee23cb377e193bd99572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01f1c4dd857205cc222bdaf0742622ed/" rel="bookmark">
			如何用笔记本开无线热点（涉及cmd操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、点击“开始”，搜索栏打：cmd，弹出cmd选项，右键以管理员方式运行。
2、弹出输入命令的窗口，输入 netsh wlan set hostednetwork mode=allow ssid=Test key=0123456789
注意：ssid后跟的是你要设置的wife用户名，key后是密码
3、打开：控制面板 -&gt;网络和 Internet -&gt;网络和共享中心,更改适配器设置如下图（系统版本不一样可能显示页面有所差异，本人目前还是xp系统，win10可以直接右下开启无线热点）
4、检查无线网是否是开启状态，确认开启后，选“本地连接”，右键“属性”，选共享，然后勾选第一条，点击确定
5、回到cmd命令框，输入netsh wlan start hostednetwork，成功开启热点
6、输入netsh wlan stop hostednetwork，关闭热点
注意：如果打开适配器设置后并没有出现俩项无线网络，只有一个，则右键该网络，选“禁用“后，再”开启“，会有另一项无线网显示。然后继续执行第4步操作。（欢迎留言交流）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81849b3d7fac5002edffd7bcf758c4f3/" rel="bookmark">
			继电器模块的的使用方法、引脚说明、内部结构、接线说明（超通俗超详细看了就能给别人讲）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近老师让做课程设计，同学们用继电器模块的人不少，但是同学们貌似都不会用继电器模块，这次我就写一个文章记录一下，详细的讲解一下继电器的模块使用，以及引脚的定义。
首先说最普通的继电器模块吧（在本文图中就简称继电器了，仍然指继电器模块，请大家悉知），先上图：
这个就是大概的引脚图，VCC就是电源正极，GND就是电源负极，IN是通断信号的输入引脚。
而另一边，NC即常闭端（normal close），COM即公共端，NO即常开端（normal open）。在中学物理中已经学过，开路即通路、断路，闭合指的是开关闭合，也就是说，在没有任何上电之类的动作时，NC和COM端相当于已经连通，这种继电器模块的连线一般为：
因为在一般情况下NC是闭合的，所以我们要接到NO接口，然后信号输入引脚即IN引脚给低电平，NC端断开，NO端闭合，负载端电路形成闭合回路，开始工作，当IN端给高电平时，NO端断开，负载即停止工作。
如果想一直工作，给信号停止工作，即把NO端的连线接在NC端就行了。（切记：继电器的GND要和单片机的GND接在一起共地，也可以使用同一个电源来达到共地的效果）
继电器被发明的目的使用来用弱电控制强电，保证人们不会在高压电路中因为某种因为发生危险（当然单片机使用的继电器模块驱动电流很小，甚至光耦隔离的继电器，只需要一个低电平的信号即可触发，并不需要太大的电流。如果是工业级的继电器，可能需要几安培的电流才能驱动，所以不建议大家使用）
继电器模块的大概使用方法已经讲完了，下面介绍一下工作原理，先上图：
这个大概就是继电器模块内部的原理了（本人小白理解浅陋，如果有错误希望大家留言指正，我一定会修改错误）。
PS:图中为PNP型三极管，基极为0是，发射极有电压，三极管导通，所以给低电平会吸合。
当输入口给低电平时，这个线圈便会因为电生磁原理将COM端的动子吸下来，完成吸合。
PS: 手绘图，难看，请大家多多包涵。
以上就是继电器模块（不是工业级的）的工作原理以及内部结构还有使用方法，希望能帮助到大家。
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2018年7月21号更新：
npn管高电平导通,pnp管低电平导通.特意来补充，因为有的厂家生产的继电器不一样，大部分应该是NPN的三极管。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d44ec28d94864cb81e7a8e30a50956f/" rel="bookmark">
			本机ssh连接不上虚拟机的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前连接的好好的，突然xshell连接虚拟机就连接不上了
找了一顿，发现问题。
我们本机都有2个网卡 无线的和有线的 以太网适配器就是你的网卡连网线用的，无线局域网适配器是你的无线网卡连WIFI用的，如下图， 他们都有自己的ip，注意：当无线网络换的时候，他的ip会发生变化，所以网段也会发生变化。 所以问题就出在这里，我搬家的时候路由换了，但是虚拟机的ip就没有及时换过来，造成了ssh连接不上的情况。
所以当ssh连接不上虚拟机以后的操作方法：
1、在本机和虚拟机两端ping IP
2、如果ip ping不通 本地进入cmd ipconfig/all 查看无线适配器或有限适配器的（根据你自己的使用的是有线或者无线定）的ip，将虚拟机的ip和本机的ip设置在同一网段
3、这些都设置好了，还不可以，检查一下防火墙。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6052bf7770cd4f529f3f55ed1c486ae/" rel="bookmark">
			前端框架选型调研报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。谷歌浏览器的V8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。V8在运行之前将JavaScript编译成了机器码，而非字节码或是解释执行它，以此提升性能。更进一步，使用了如内联缓存（inline caching）等方法来提高性能。初此之外，还有 IE9/Edge 的 Chakra、Firefox 的 TraceMonkey等。
一门编程语言的良好发展离不开其标准的制定，而ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。
开始之前我们先来看几个问题： 1.前端模块化的意义 ？ 支撑庞大的前端业务逻辑需要编写大量的js代码，如此繁多的js代码如果缺乏有效的组织，项目会变得越来越难维护。为解决这个问题，引入了模块化开发的方案。最流行的当属以下三个规范： AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。
2.有了模块化工具，是否还需要JS框架？（自动化仓库/哆啦A梦） 答案是肯定的，这是两个不同的层面的东西，提供的功能不同，JS框架是为了简化开发，规范代码风格；模块加载器是为了实现模块的定义、分割、通信和加载。
3.什么样的JS框架适合我们？ 前端目前最流行的JS框架有：
ReactJS是一个用来构建用户界面的 JavaScript 库，主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。
主要特性： 1. 声明式设计 −React采用声明范式，可以轻松描述应用。 2. 高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。 3. 灵活 −React可以与已知的库或框架很好地配合。 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6052bf7770cd4f529f3f55ed1c486ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b694332d7a95f8b6275cbae6487fce8b/" rel="bookmark">
			MySQL服务器的管理与维护
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MySQL服务器的管理与维护
1、监控复制
1）、查看主服务器状态：SHOW MASTER STATUS mysql&gt; show master status;
+-------------------+----------+--------------+------------------+
| File | Position | Binlog_Do_DB |Binlog_Ignore_DB |
+-------------------+----------+--------------+------------------+
| master-bin.000011 | 106 | | |
+-------------------+----------+--------------+------------------+
1 row in set (0.04 sec)
2）、显示二进制日志中的事件：SHOW BINLOG EVENTS
SHOW BINLOG EVENTS [IN 'log_name'] [FROMpos] [LIMIT [offset,] row_count]
如果不指定'log_name'，则显示第一个二进制日志。
FROMpos：从哪个位置开始
LIMIT[offset,] row_count：显示显示条目，用法同SELECT语句
例：第一个二进制日志，从第十个条目起，取3条目 mysql&gt; show binlog events limit 10,3;
+-------------------+------+------------+-----------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Log_name | Pos | Event_type | Server_id | End_log_pos | Info |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b694332d7a95f8b6275cbae6487fce8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45ea084f138a4cdcab5391100eeccecf/" rel="bookmark">
			嵌入式Linux——oops：根据oops信息，找到错误的产生位置以及函数的调用关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
本文主要介绍通过oops信息找到程序中出错位置的方法。并结合自己代码中的错误来讲解如何找到出错位置。同时还会介绍使用栈信息来推到函数间的调用关系。
Linux内核：linux-2.6.22.6
所用开发板：JZ2440 V3（S3C2440A）
声明：
本文主要是对韦东山老师视频的总结，同时看了一些网友的博文来对这方面的信息进行补充。希望通过我的文章让你对oops信息有更好的了解。
oops信息介绍：
我们先以一个例子来介绍oops中都含有什么信息。我们看下面这几部分：
1 一段文本描述信息,用于描述程序出错的原因：
Unable to handle kernel paging request at virtual address 56000050
2 Oops 信息的序号
Internal error: Oops: 5 [#1]
bit 0 如果第0位被清0，则异常是由一个不存在的页所引起的；否则是由无效的访问权限引起的。
bit 1 如果第1位被清0，则异常由读访问或者执行访问所引起；否则异常由写访问引起。
bit 2 如果第2位被清0，则异常发生在内核态；否则异常发生在用户态。
Oops中的 [#1] crash发生次数。
Oops中的 PREEMPT 是指系统支持抢占模式，有时会还会输出SMP(多核) ARM/THUMB(指令集)等信息。
3 内核中加载的模块名称,也可能没有,以下面字样开头。
Modules linked in: first_drv
4 发生错误的 CPU 的序号,对于单处理器的系统,序号为 0,比如:
CPU: 0 Not tainted (2.6.22.6 #1)
其中Tainted的表示可以从内核中 kernel/panic.c 中找到：
Tainted描述‘G’if all modules loaded have a GPL or compatible license‘P’if any proprietary module has been loaded.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45ea084f138a4cdcab5391100eeccecf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79fa7076f5bfb6d29214171308a301a2/" rel="bookmark">
			5.3.4 图像颜色映射 (二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注：此文知识学习笔记，仅记录完整程序和实现结果，具体原理参见：
https://blog.csdn.net/www_doling_net/article/details/8541534
https://blog.csdn.net/shenziheng1/article/category/6114053/4
3、灰度图像映射成伪彩色图像（查表法 vtkLookUpTable）
图像彩色映射的原理是首先生成一个颜色查找表，然后根据图像的一个标量值向颜色查找表中查找对应的颜色，并用新颜色值替代原来的像素值。VTK中vtkImageMapToColors负责图像彩色映射，vtkLookUpTable负责生成颜色查找表。
#include &lt;vtkSmartPointer.h&gt; #include &lt;vtkJPEGReader.h&gt; #include &lt;vtkLookupTable.h&gt; //生成颜色查找表 #include &lt;vtkImageMapToColors.h&gt; //实现图像彩色映射 #include &lt;vtkImageActor.h&gt; #include &lt;vtkRenderer.h&gt; #include &lt;vtkRenderWindow.h&gt; #include &lt;vtkRenderWindowInteractor.h&gt; #include &lt;vtkInteractorStyleImage.h&gt; int main() { vtkSmartPointer&lt;vtkJPEGReader&gt; reader = vtkSmartPointer&lt;vtkJPEGReader&gt;::New(); reader-&gt;SetFileName("data\\lena-gray.jpg"); //建立颜色映射查找表 vtkSmartPointer&lt;vtkLookupTable&gt; colorTable = vtkSmartPointer&lt;vtkLookupTable&gt;::New(); colorTable-&gt;SetRange(0.0, 255.0); colorTable-&gt;SetHueRange(0.1, 0.5); //色调（H）范围 colorTable-&gt;SetValueRange(0.6, 1.0); //明度（V）范围 colorTable-&gt;Build(); //生成颜色查找表 //建立颜色映射 vtkSmartPointer&lt;vtkImageMapToColors&gt; colorMap =	vtkSmartPointer&lt;vtkImageMapToColors&gt;::New(); colorMap-&gt;SetInputConnection(reader-&gt;GetOutputPort()); colorMap-&gt;SetLookupTable(colorTable); //用来设置相应的颜色查找表 colorMap-&gt;Update(); //建立演员 vtkSmartPointer&lt;vtkImageActor&gt; origActor = vtkSmartPointer&lt;vtkImageActor&gt;::New(); origActor-&gt;SetInputData(reader-&gt;GetOutput()); vtkSmartPointer&lt;vtkImageActor&gt; colorActor =	vtkSmartPointer&lt;vtkImageActor&gt;::New(); colorActor-&gt;SetInputData(colorMap-&gt;GetOutput()); //化妆 double origView[4] = { 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79fa7076f5bfb6d29214171308a301a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25447bebdd348553d91337ef4fcbddae/" rel="bookmark">
			OpenCV VideoCapture.get()参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 paramdefinecv2.VideoCapture.get(0)视频文件的当前位置（播放）以毫秒为单位cv2.VideoCapture.get(1)基于以0开始的被捕获或解码的帧索引cv2.VideoCapture.get(2)视频文件的相对位置（播放）：0=电影开始，1=影片的结尾。cv2.VideoCapture.get(3)在视频流的帧的宽度cv2.VideoCapture.get(4)在视频流的帧的高度cv2.VideoCapture.get(5)帧速率cv2.VideoCapture.get(6)编解码的4字-字符代码cv2.VideoCapture.get(7)视频文件中的帧数cv2.VideoCapture.get(8)返回对象的格式cv2.VideoCapture.get(9)返回后端特定的值，该值指示当前捕获模式cv2.VideoCapture.get(10)图像的亮度(仅适用于照相机)cv2.VideoCapture.get(11)图像的对比度(仅适用于照相机)cv2.VideoCapture.get(12)图像的饱和度(仅适用于照相机)cv2.VideoCapture.get(13)色调图像(仅适用于照相机)cv2.VideoCapture.get(14)图像增益(仅适用于照相机)（Gain在摄影中表示白平衡提升）cv2.VideoCapture.get(15)曝光(仅适用于照相机)cv2.VideoCapture.get(16)指示是否应将图像转换为RGB布尔标志cv2.VideoCapture.get(17)× 暂时不支持cv2.VideoCapture.get(18)立体摄像机的矫正标注（目前只有DC1394 v.2.x后端支持这个功能） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96eed898ba8c32ecf68cc1a9fde12908/" rel="bookmark">
			gif动态图合成
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import imageio def create_gif(image_list, gif_name): frames = [] for image_name in image_list: frames.append(imageio.imread(image_name)) # Save them as frames into a gif imageio.mimsave(gif_name, frames, 'GIF', duration=0.1) return def main(): image_list = ['a279.jpg', 'a281.jpg', 'a283.jpg', 'a285.jpg', 'a287.jpg', 'a290.jpg'] gif_name = 'created_gif.gif' create_gif(image_list, gif_name) if __name__ == "__main__": main() 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fbe57f30df8c2c6d07dfabba847e089/" rel="bookmark">
			Linux无线网络管理命令(ip/iw/iwconfig/iwlist/ifconfig/wpa_supplicant)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
以下各小节的前半部分介绍无线网络相关的各种命令的背景以及适用范围。
后半部分演示常用命令搭配和相关操作。
iw命令 man手册中可以找到说明 iw - show / manipulate wireless devices and their configuration
这意味着iw既可以查看信息，又可以管理无线网络设备，还能更改配置，属于比较全能的命令。
缺点：实测对USB网卡支持性很差，几乎只适用于物理接入设备（PCI板载设备）。
常用命令列表： iw list # 查看本机支持的无线特性，such as band information (2.4 GHz, and 5 GHz), and 802.11n information iw dev wlan0 scan # 扫描无线网络，列表的内容都是实时更新的 iw dev wlan0 link # 获取设备连接状态信息（实测不包含IP地址） iw wlan0 info # 获取设备工作状态信息 iw event # 获取所有网络设备的工作日志信息 英文原文介绍：https://wireless.wiki.kernel.org/en/users/Documentation/iw
译文：https://blog.csdn.net/robertsong2004/article/details/40044947
ifconfig命令 ifconfig - configure a network interface 配置网络接口命令
通用的接口操作命令，但通用意味着只能做一些少量配置，例如打开关闭设备接口，配置IP、子网掩码，查看IP地址等。
ifconfig eth0 down # 关闭eth0接口 ifconfig wlan0 up # 打开wlan0接口 ifconfig eth0 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fbe57f30df8c2c6d07dfabba847e089/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db37d035fbd6feee06ccbd9a80ab7049/" rel="bookmark">
			嵌入式Linux——kmsg：分析/proc/kmsg文件以及写自己的/proc/mymsg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介：
本文主要分析/proc/kmsg文件的形成过程以及使用cat /proc/kmsg查看log_buf中的信息时所要经历的代码。并结合上面的分析写自己的 /proc/mymsg和myprintk 。
Linux内核：linux-2.6.22.6
所用开发板：JZ2440 V3（S3C2440A）
声明：
本文主要是看完韦东山老师的视频后，自己分析代码所写。同时我在写这篇文章的时候也参考了一些网友的文章。我相信这样可以让我们的知识点变得更加全面。
分析/proc/kmsg：
我们都知道当我们使用cat /proc/kmsg时，我们可以看到缓存在log_buf中的内容，那么/proc/kmsg文件是在什么时候创建的？同时我们是如何使用cat /proc/kmsg获得log_buf中的信息，这就成了我们要问的问题了。下面我们会通过分析代码来回答上面的问题。
我先将上篇文章中的一幅图引入这里，希望对大家有帮助：
首先我们看/proc/kmsg文件是什么时候创建的。我们打开内核的文件我们会发现有fs（文件系统）文件，并在这个文件下面有proc文件，在proc文件下有proc_misc.c文件，我们看这个文件的入口函数：proc_misc_init
void __init proc_misc_init(void) { ······· #ifdef CONFIG_PRINTK { struct proc_dir_entry *entry; entry = create_proc_entry("kmsg", S_IRUSR, &amp;proc_root); if (entry) entry-&gt;proc_fops = &amp;proc_kmsg_operations; } #endif ······· } 从上面看代码可能的意思是，当我们定义了CONFIG_PRINTK时，我们就要在/porc目录下创建一个kmsg的子条目，而子条目的文件操作函数为proc_kmsg_operations。下面我们慢慢分析代码看是不是我说的这个意思。从上面程序看，先定义了一个proc_dir_entry的结构体。
/* * 这个结构体不会完全的运用。但是他的想法是： * 在内存中创建一个proc_dir_entries的树（就像真实的/proc文件系统树） * 这样我们就可以动态的添加一个新的文件到/proc */ struct proc_dir_entry { unsigned int low_ino; unsigned short namelen; //名字长度 const char *name; //名字 mode_t mode; //操作属性 nlink_t nlink; uid_t uid; gid_t gid; loff_t size; const struct inode_operations *proc_iops; const struct file_operations *proc_fops; //文件操作函数 get_info_t *get_info; struct module *owner; struct proc_dir_entry *next, *parent, *subdir; //下一个条目，父条目，子条目 void *data; read_proc_t *read_proc; write_proc_t *write_proc; atomic_t count;	/* use count */ int deleted;	/* delete flag */ void *set; }; 从上面proc_dir_entry的注释我们可以知道，这个结构体就是要将我们注册到/proc目录下的子条目填写到这个结构体中。而通过create_proc_entry函数来完成这个任务，同时create_proc_entry函数还会将这个子条目注册到/proc目录下，然后通过返回填好的proc_dir_entry结构体。我们现在看create_proc_entry函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db37d035fbd6feee06ccbd9a80ab7049/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a371804cee8a23ebc18221ea64dc9c4/" rel="bookmark">
			MATLAB神经网络图像识别代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 I0=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\0 (1).png')); I1=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\1 (1).png')); I2=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\2 (1).png')); I3=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\3 (1).png')); I4=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\4 (1).png')); I5=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\5 (1).png')); I6=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\6 (1).png')); I7=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\7 (1).png')); I8=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\8 (1).png')); I9=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\9 (1).png')); %以上数据都是归一化好的数据。 P=[I0',I1',I2',I3',I4',I5',I6',I7',I8',I9']; T=eye(10,10); %%bp神经网络参数设置 net=newff(minmax(P),[144,200,10],{'logsig','logsig','logsig'},'trainrp'); net.inputWeights{1,1}.initFcn ='randnr'; net.layerWeights{2,1}.initFcn ='randnr'; net.trainparam.epochs=5000; net.trainparam.show=50; net.trainparam.lr=0.001; net.trainparam.goal=0.0000000000001; net=init(net); %%%训练样本%%%% [net,tr]=train(net,P,T); PIN0=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\4 (2).png')); PIN1=pretreatment(imread('Z:\data\PictureData\TestCode\SplitDataTest\3 (2).png')); P0=[PIN0',PIN1']; T0= sim(net ,PIN1') T1 = compet (T0) d =find(T1 == 1) - 1 fprintf('预测数字是：%d\n',d); %有较高的识别率 识别率还是挺高的。但是最大的难点问题是图像的预处理，分割，我觉得智能算法的识别已经做得很好了。最重要的是图像预处理分割。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/455/">«</a>
	<span class="pagination__item pagination__item--current">456/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/457/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>