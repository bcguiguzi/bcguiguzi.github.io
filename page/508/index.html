<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95dc70d4f8123fa7472d93708ba51b2e/" rel="bookmark">
			惯性导航系统INS与GPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 惯性导航系统INS(Inertia Navigation System)
参考http://baike.baidu.com/view/1574404.htm
定义1： 能完成惯性导航任务的成套装置。 应用学科： 船舶工程（一级学科）；船舶通信导航（二级学科） 定义2： 应用高精度的陀螺仪和加速度计等惯性敏感器件测量运动载体的加速度，再经过计算机解算出运动载体的加速度、位置、姿态和航向等导航参数的自主式导航系统。 应用学科： 航空科技（一级学科）；飞行控制、导航、显示、控制和记录系统（二级学科） 惯导的基本工作原理是以牛顿力学定律为基础，通过测量载体在惯性参考系的加速度，将它对时间进行积分，且把它变换到导航坐标系中，就能够得到在导航坐标系中的速度、偏航角和位置等信息。 惯性导航系统（ 英语：INS ）是一个使用加速计和陀螺仪来测量物体的加速度和旋转，并用计算机来连续估算运动物体位置、姿态和速度的辅助导航系统。它不需要一个外部参考系，常常被用在飞机，潜艇，导弹和各种航天器上。 GPS(Global Positioning System)全球卫星定位系统：利用GPS定位卫星，在全球范围内实时进行定位、导航的系统（GPS卫星有多颗，围绕地球）。GPS功能必须具备GPS终端、传输网络和监控平台三个要素。 GPS组成部分： 1、空间部分。24颗卫星 2、地面控制部分。收集由卫星传回之讯息，并计算卫星星历、相对距离，大气校正等数据。 3、用户设备部分。即GPS信号接收机。根据这些数据，接收机中的微处理计算机就可按定位解算方法进行定位计算，计算出用户所在地理位置的经纬度、高度、速度、时间等信息。 1988年又进行了最后一次修改：21颗工作星和3颗备用星工作在互成30度的6条轨道上。这也是现在GPS卫星所使用的工作方式。 GPS导航系统的基本原理是测量出已知位置的卫星到用户接收机之间的距离，然后综合多颗卫星的数据就可知道接收机的具体位置。 GPS导航系统卫星部分的作用就是不断地发射导航电文。然而，由于用户接受机使用的时钟与卫星星载时钟不可能总是同步，所以除了用户的三维坐标x、y、z外，还要引进一个Δt即卫星与接收机之间的时间差作为未知数，然后用4个方程将这4个未知数解出来。所以如果想知道接收机所处的位置，至少要能接收到4个卫星的信号。 GPS接收机接收卫星信号 GPS/INS组合制导 即GPS辅助惯性制导。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7012c3d8426eef42ba914774ce6a24/" rel="bookmark">
			Linux常用命令速查字典
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、启动、关机、登入、登出相关命令
[login] 登录
[logout] 登出
[exit] 登出
[shutdown] 停止系统
[halt] 停止系统
[reboot] 重启动
[poweroff] 切断电源
[sync] 把内存里的内容写入磁盘
[lilo] 安装lilo启动管理程序
[grub] 安装lilo启动管理程序
二、Shell相关命令
[chsh] 切换Shell
[history] 显示命令履历
[alias] 设置命令别名
[unalias] 取消命令别名
[which] 显示命令所在位置
[type] 查询命令种类
[echo] 显示字符串或者变量内容
[set] 设置/显示Shell变量
[printenv] 显示环境变量
[export] 设置环境变量
[env] 设置临时环境变量
[unset] 释放环境变量
[setenv] 设置环境变量
[unsetenv] 释放环境变量
[source] 执行文件当中的命令
[man] 查询命令手册
[info] 查询超文本命令手册
[whatis] 显示命令简介
[apropos] 通过关键字查询手册
三、用户管理相关命令
[su] 切换到其他用户
[useradd] 追加用户
[adduser] 追加用户
[userdel] 删除用户
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa7012c3d8426eef42ba914774ce6a24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7c6af6680c0d02ad7bea003ea70e863/" rel="bookmark">
			Android的十六进制颜色值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 颜色和不透明度 (alpha) 值以十六进制表示法表示。任何一种颜色的值范围都是 0 到 255（00 到 ff）。对于 alpha，00 表示完全透明，ff 表示完全不透明。表达式顺序是“aabbggrr”，其中“aa=alpha”（00 到 ff）；“bb=blue”（00 到 ff）；“gg=green”（00 到 ff)；“rr=red”（00 到 ff）。
参考1：http://blog.sina.com.cn/s/blog_70a9e6090100zt6x.html
颜色 16进制对照表 颜色代码表：以下样色显示您可能觉得不够精确，这和电脑显示器有直接关系。您可查看颜色代码，绝对正确，绝无重复。
红色和粉红色，以及它们的16进制代码。
#990033#CC6699#FF6699#FF3366#993366#CC0066#CC0033#FF0066#FF0033..#CC3399..#FF3399#FF9999#FF99CC#FF0099#CC3366#FF66CC#FF33CC#FFCCFF#FF99FF#FF00CC 紫红色，以及它们的16进制代码。
#FF66FF#CC33CC#CC00FF#FF33FF#CC99FF#9900CC#FF00FF#CC66FF#990099#CC0099#CC33FF#CC99CC#990066#993399#CC66CC#CC00CC#663366 蓝色，以及它们的16进制代码。#660099#666FF#000CC#9933CC#666699#660066#333366#0066CC#9900FF#333399#99CCFF#9933FF#330099#6699FF#9966CC#3300CC#003366#330033#3300FF#6699CC#663399#3333FF#006699#6633CC#3333CC#3399CC#6600CC#0066FF#0099CC#9966FF#0033FF#66CCFF#330066#3366FF#3399FF#6600FF#3366CC#003399#6633FF#000066#0099FF#CCCCFF#000033#33CCFF#9999FF#0000FF#00CCFF#9999CC#000099#6666CC#0033CC 黄色、褐色、玫瑰色和橙色，以及它们的16进制代码。#FFFFCC#FFCC00#CC99090#663300#FF6600#663333#CC6666#FF6666#FF0000#FFFF99#FFCC66#FF9900#FF9966#CC3300#996666#FFCCCC#660000#FF3300#FF6666#FFCC33#CC6600#FF6633#996633#CC9999#FF3333#990000#CC9966#FFFF33#CC9933#993300#FF9933#330000#993333#CC3333#CC0000#FFCC99#FFFF00#996600#CC6633 绿色，以及它们的16进制代码。#99FFFF#33CCCC#00CC99#99FF99#009966#33FF33#33FF00#99CC33#CCC33#66FFFF#66CCCC#66FFCC#66FF66#009933#00CC33#66FF00#336600#33300#33FFFF#339999#99FFCC#339933#33FF66#33CC33#99FF00#669900#666600#00FFFF#336666#00FF99#99CC99#00FF66#66FF33#66CC00#99CC00#999933#00CCCC#006666#339966#66FF99#CCFFCC#00FF00#00CC00#CCFF66#CCCC66#009999#003333#006633#33FF99#CCFF99#66CC33#33CC00#CCFF33#666633#669999#00FFCC#336633#33CC66#99FF66#006600#339900#CCFF00#999966#99CCCC#33FFCC#669966#00CC66#99FF33#003300#99CC66#999900#CCCC99#CCFFFF#33CC99#66CC66#66CC99#00FF33#009900#669900#669933#CCCC00 白色、灰色和黑色，以及它们的16进制代码。#FFFFF#CCCCCC#999999#666666#333333#000000 16色和它们的16进制代码。AquaBlackFuchsiaGrayGreeLimeMaroonNavyOlivePurpleRedSilverTealWhiteYellowBlue 参考2：http://www.blogjava.net/zks518/archive/2011/08/12/356409.html
LightPink 浅粉色 #FFB6C1 255,182,193 Pink 粉红 #FFC0CB 255,192,203 Crimson 猩红 #DC143C 220,20,60 LavenderBlush 脸红的淡紫色 #FFF0F5 255,240,245 PaleVioletRed 苍白的紫罗兰红色 #DB7093 219,112,147 HotPink 热情的粉红 #FF69B4 255,105,180 DeepPink 深粉色 #FF1493 255,20,147 MediumVioletRed 适中的紫罗兰红色 #C71585 199,21,133 Orchid 兰花的紫色 #DA70D6 218,112,214 Thistle 蓟 #D8BFD8 216,191,216 plum 李子 #DDA0DD 221,160,221 Violet 紫罗兰 #EE82EE 238,130,238 Magenta 洋红 #FF00FF 255,0,255 Fuchsia 灯笼海棠（紫红色） #FF00FF 255,0,255 DarkMagenta 深洋红色 #8B008B 139,0,139 Purple 紫色 #800080 128,0,128 MediumOrchid 适中的兰花紫 #BA55D3 186,85,211 DarkVoilet 深紫罗兰色 #9400D3 148,0,211 DarkOrchid 深兰花紫 #9932CC 153,50,204 Indigo 靛青 #4B0082 75,0,130 BlueViolet 深紫罗兰的蓝色 #8A2BE2 138,43,226 MediumPurple 适中的紫色 #9370DB 147,112,219 MediumSlateBlue 适中的板岩暗蓝灰色 #7B68EE 123,104,238 SlateBlue 板岩暗蓝灰色 #6A5ACD 106,90,205 DarkSlateBlue 深岩暗蓝灰色 #483D8B 72,61,139 Lavender 薰衣草花的淡紫色 #E6E6FA 230,230,250 GhostWhite 幽灵的白色 #F8F8FF 248,248,255 Blue 纯蓝 #0000FF 0,0,255 MediumBlue 适中的蓝色 #0000CD 0,0,205 MidnightBlue 午夜的蓝色 #191970 25,25,112 DarkBlue 深蓝色 #00008B 0,0,139 Navy 海军蓝 #000080 0,0,128 RoyalBlue 皇军蓝 #4169E1 65,105,225 CornflowerBlue 矢车菊的蓝色 #6495ED 100,149,237 LightSteelBlue 淡钢蓝 #B0C4DE 176,196,222 LightSlateGray 浅石板灰 #778899 119,136,153 SlateGray 石板灰 #708090 112,128,144 DoderBlue 道奇蓝 #1E90FF 30,144,255 AliceBlue 爱丽丝蓝 #F0F8FF 240,248,255 SteelBlue 钢蓝 #4682B4 70,130,180 LightSkyBlue 淡蓝色 #87CEFA 135,206,250 SkyBlue 天蓝色 #87CEEB 135,206,235 DeepSkyBlue 深天蓝 #00BFFF 0,191,255 LightBLue 淡蓝 #ADD8E6 173,216,230 PowDerBlue 火药蓝 #B0E0E6 176,224,230 CadetBlue 军校蓝 #5F9EA0 95,158,160 Azure 蔚蓝色 #F0FFFF 240,255,255 LightCyan 淡青色 #E1FFFF 225,255,255 PaleTurquoise 苍白的绿宝石 #AFEEEE 175,238,238 Cyan 青色 #00FFFF 0,255,255 Aqua 水绿色 #00FFFF 0,255,255 DarkTurquoise 深绿宝石 #00CED1 0,206,209 DarkSlateGray 深石板灰 #2F4F4F 47,79,79 DarkCyan 深青色 #008B8B 0,139,139 Teal 水鸭色 #008080 0,128,128 MediumTurquoise 适中的绿宝石 #48D1CC 72,209,204 LightSeaGreen 浅海洋绿 #20B2AA 32,178,170 Turquoise 绿宝石 #40E0D0 64,224,208 Auqamarin 绿玉碧绿色 #7FFFAA 127,255,170 MediumAquamarine 适中的碧绿色 #00FA9A 0,250,154 MediumSpringGreen 适中的春天的绿色 #F5FFFA 245,255,250 MintCream 薄荷奶油 #00FF7F 0,255,127 SpringGreen 春天的绿色 #3CB371 60,179,113 SeaGreen 海洋绿 #2E8B57 46,139,87 Honeydew 蜂蜜 #F0FFF0 240,255,240 LightGreen 淡绿色 #90EE90 144,238,144 PaleGreen 苍白的绿色 #98FB98 152,251,152 DarkSeaGreen 深海洋绿 #8FBC8F 143,188,143 LimeGreen 酸橙绿 #32CD32 50,205,50 Lime 酸橙色 #00FF00 0,255,0 ForestGreen 森林绿 #228B22 34,139,34 Green 纯绿 #008000 0,128,0 DarkGreen 深绿色 #006400 0,100,0 Chartreuse 查特酒绿 #7FFF00 127,255,0 LawnGreen 草坪绿 #7CFC00 124,252,0 GreenYellow 绿黄色 #ADFF2F 173,255,47 OliveDrab 橄榄土褐色 #556B2F 85,107,47 Beige 米色（浅褐色） #6B8E23 107,142,35 LightGoldenrodYellow 浅秋麒麟黄 #FAFAD2 250,250,210 Ivory 象牙 #FFFFF0 255,255,240 LightYellow 浅黄色 #FFFFE0 255,255,224 Yellow 纯黄 #FFFF00 255,255,0 Olive 橄榄 #808000 128,128,0 DarkKhaki 深卡其布 #BDB76B 189,183,107 LemonChiffon 柠檬薄纱 #FFFACD 255,250,205 PaleGodenrod 灰秋麒麟 #EEE8AA 238,232,170 Khaki 卡其布 #F0E68C 240,230,140 Gold 金 #FFD700 255,215,0 Cornislk 玉米色 #FFF8DC 255,248,220 GoldEnrod 秋麒麟 #DAA520 218,165,32 FloralWhite 花的白色 #FFFAF0 255,250,240 OldLace 老饰带 #FDF5E6 253,245,230 Wheat 小麦色 #F5DEB3 245,222,179 Moccasin 鹿皮鞋 #FFE4B5 255,228,181 Orange 橙色 #FFA500 255,165,0 PapayaWhip 番木瓜 #FFEFD5 255,239,213 BlanchedAlmond 漂白的杏仁 #FFEBCD 255,235,205 NavajoWhite Navajo白 #FFDEAD 255,222,173 AntiqueWhite 古代的白色 #FAEBD7 250,235,215 Tan 晒黑 #D2B48C 210,180,140 BrulyWood 结实的树 #DEB887 222,184,135 Bisque （浓汤）乳脂，番茄等 #FFE4C4 255,228,196 DarkOrange 深橙色 #FF8C00 255,140,0 Linen 亚麻布 #FAF0E6 250,240,230 Peru 秘鲁 #CD853F 205,133,63 PeachPuff 桃色 #FFDAB9 255,218,185 SandyBrown 沙棕色 #F4A460 244,164,96 Chocolate 巧克力 #D2691E 210,105,30 SaddleBrown 马鞍棕色 #8B4513 139,69,19 SeaShell 海贝壳 #FFF5EE 255,245,238 Sienna 黄土赭色 #A0522D 160,82,45 LightSalmon 浅鲜肉（鲑鱼）色 #FFA07A 255,160,122 Coral 珊瑚 #FF7F50 255,127,80 OrangeRed 橙红色 #FF4500 255,69,0 DarkSalmon 深鲜肉（鲑鱼）色 #E9967A 233,150,122 Tomato 番茄 #FF6347 255,99,71 MistyRose 薄雾玫瑰 #FFE4E1 255,228,225 Salmon 鲜肉（鲑鱼）色 #FA8072 250,128,114 Snow 雪 #FFFAFA 255,250,250 LightCoral 淡珊瑚色 #F08080 240,128,128 RosyBrown 玫瑰棕色 #BC8F8F 188,143,143 IndianRed 印度红 #CD5C5C 205,92,92 Red 纯红 #FF0000 255,0,0 Brown 棕色 #A52A2A 165,42,42 FireBrick 耐火砖 #B22222 178,34,34 DarkRed 深红色 #8B0000 139,0,0 Maroon 栗色 #800000 128,0,0 White 纯白 #FFFFFF 255,255,255 WhiteSmoke 白烟 #F5F5F5 245,245,245 Gainsboro Gainsboro #DCDCDC 220,220,220 LightGrey 浅灰色 #D3D3D3 211,211,211 Silver 银白色 #C0C0C0 192,192,192 DarkGray 深灰色 #A9A9A9 169,169,169 Gray 灰色 #808080 128,128,128 DimGray 暗淡的灰色 #696969 105,105,105 Black 纯黑 #000000 0,0,0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cea639b3071e35f87b35c1266a3796d/" rel="bookmark">
			windows程序设计（6）：基本画图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows程序画图，大体上有3种方法：
（1）你告诉系统点的坐标和颜色，系统通过SetPixel来画。类似的，通过GetPixel来获取某一点像素值。
（2）使用MoveToEx、LineTo来划线，MoveToEx设置起点坐标，LineTo设置终点坐标，或者使用Polyline函数，这个函数接受一个POINT类型的数组，通过数组里的点连线。
（3）windows提供了一些基本图形绘制的函数供我们直接调用，比如Rectangle绘制矩形，Ellipse绘制椭圆，RoundRect绘制圆角椭圆。
下面看看程序中如何使用它们：（还是那本windows程序设计里的）
#include &lt;windows.h&gt; #include &lt;math.h&gt; #define NUM 1000 #define TWOPI (2*3.14159) LRESULT CALLBACK WndProc (HWND,UINT,WPARAM,LPARAM); int WINAPI WinMain(HINSTANCE hInstance,	//当前实例句柄 HINSTANCE hPrevInstance, //先前实例句柄 LPSTR lpCmdLine,	//命令行 int iCmdShow)	//显示状态 { static TCHAR szAppName[] = TEXT("画图"); //窗口句柄 HWND hwnd; //消息 MSG msg; //窗口类 WNDCLASS wndclass; //窗口风格：当移动窗口或者改变大小时重绘窗口 wndclass.style	= CS_HREDRAW | CS_VREDRAW; //指明回调函数 wndclass.lpfnWndProc = WndProc; //额外的比特用来确认下一个窗口类的位置，暂时不用 wndclass.cbClsExtra = 0; //额外的比特用来确认下一个窗口实例的位置，暂时不用 wndclass.cbWndExtra = 0; //实例句柄 wndclass.hInstance = hInstance; //装载图标 wndclass.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cea639b3071e35f87b35c1266a3796d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70b6d9e019c05e31c69a2cdd752f863a/" rel="bookmark">
			向量的点乘与叉乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向量 - 向量叉乘 向量点乘
2010年07月28日 星期三 14:33
向量（Vector）
在几乎所有的几何问题中，向量（有时也称矢量）是一个基本点。向量的定义包含方向和一个数（长度）。在二维空间中，一个向量可以用一对x和y来表示。例如由点（1,3）到（5,1的向量可以用(4,-2）来表示。这里大家要特别注意，我这样说并不代表向量定义了起点和终点。向量仅仅定义方向和长度。
向量加法
向量也支持各种数学运算。最简单的就是加法。我们可以对两个向量相加，得到的仍然是一个向量。我们有：
V1（x1, y1）+V2（x2, y2）=V3(x1+x2, y1+y2)
下图表示了四个向量相加。注意就像普通的加法一样,相加的次序对结果没有影响（满足交换律），减法也是一样的。
点乘（Dot Product）
如果说加法是凭直觉就可以知道的，另外还有一些运算就不是那么明显的，比如点乘和叉乘。
点乘比较简单，是相应元素的乘积的和：
V1( x1, y1) V2(x2, y2) = x1*x2 + y1*y2
注意结果不是一个向量，而是一个标量（Scalar）。点乘有什么用呢，我们有：
A B = |A||B|Cos(θ)
θ是向量A和向量B见的夹角。这里|A|我们称为向量A的模(norm)，也就是A的长度， 在二维空间中就是|A| = sqrt(x2+y2)。这样我们就和容易计算两条线的夹角：
Cos(θ) = A B /(|A||B|)
当然你知道要用一下反余弦函数acos()啦。（回忆一下cos(90)=0 和cos(0) = 1还是有好处的，希望你没有忘记。）这可以告诉我们如果点乘的结果，简称点积，为0的话就表示这两个向量垂直。当两向量平行时，点积有最大值
另外，点乘运算不仅限于2维空间，他可以推广到任意维空间。（译注：不少人对量子力学中的高维空间无法理解，其实如果你不要试图在视觉上想象高维空间，而仅仅把它看成三维空间在数学上的推广，那么就好理解了）
叉乘（cross product）
相对于点乘，叉乘可能更有用吧。2维空间中的叉乘是：
V1(x1, y1) X V2(x2, y2) = x1y2 – y1x2
看起来像个标量，事实上叉乘的结果是个向量，方向在z轴上。上述结果是它的模。在二维空间里，让我们暂时忽略它的方向，将结果看成一个向量，那么这个结果类似于上述的点积，我们有：
A x B = |A||B|Sin(θ)
然而角度 θ和上面点乘的角度有一点点不同，他是有正负的，是指从A到B的角度。下图中 θ为负。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70b6d9e019c05e31c69a2cdd752f863a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c22c903c5eea0a0b595cdcab7b82e20/" rel="bookmark">
			Write a Microsoft Network Monitor3.4 Parser
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/342e42e95c0f99ea1739ef450c06e055/" rel="bookmark">
			对于window和linux下的换行符的一点理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		从网络上的已有资料可知道：
\r的意义即回车,\n的意义即换行。
何为回车，何为换行：
这都是从打字机的概念来的：
车指的就是打字机头，那么回车就是打字机归为操作
而换行呢指的就是打印机走纸的操作。
但是，
在window中，使用\n就是使用\r\n即回车换行,而是用\r仅仅就是回车。
测试程序如下：
#include &lt;iostream&gt;
using namespace std;
int main(){
cout&lt;&lt;"abcde\nbbbb"&lt;&lt;endl;
cout&lt;&lt;"*******************"&lt;&lt;endl;
cout&lt;&lt;"abcde\rbbbb"&lt;&lt;endl;
cout&lt;&lt;"*******************"&lt;&lt;endl;
cout&lt;&lt;"abcde\r\nbbbb"&lt;&lt;endl;
return 0;
}
测试程序结果：
abcde
bbbb
*******************
bbbbe
*******************
abcde
bbbb
对于linux，未测试，但是有已有网络资料可以知道，\n单单就是回车，\r单单就是换行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4169c53a2719536ae11851fc8637305c/" rel="bookmark">
			oracle 之定义数组类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle 数组类型，没有现成的类型，但是可以自己随意定义，很方便。
Oracle 数组可以分为定长数组和可变长的数组两类。以下主要是一维数组介绍：
定长数组：
/*定长字符数组，数组大小为10*/declaretype v_arr is varray(10) of varchar2(30);my_arr v_arr;my_arr:=v_arr('1','2','3');beginfor i in 1..my_arr.countloopdbms_output_line(my_arr(i));end loop;end;	变长数组：
/*可变长字符数组，元素大小30，索引标号integer类型自增长*/declare type v_table is table of varchar2(30) index by binary_integer; --类型可以是前面的类型定义，index by binary_integer子句代表以符号整数为索引， --这样访问表类型变量中的数据方法就是“表变量名(索引符号整数)”。 my_table v_table; begin for i in 1..20 loop my_table(i):=i; dbms_output.put_line(my_table(i)); end loop; end; 以上内容只涉及到一维数组的定义和简单实用，多维数组未介绍。
参考oracle数组介绍地址：http://www.cnblogs.com/lll3344/archive/2011/03/09/1978366.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f85b8de51136ba87a8b6e460dfe3587/" rel="bookmark">
			WebView外面不加LinearLayout滚动不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;ScrollView android:layout_width="fill_parent" android:layout_height="0dip" android:layout_weight="1" android:background="@color/white" android:fillViewport="true" android:scrollbars="none" &gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="vertical" &gt; &lt;WebView android:id="@+id/webview" android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginBottom="6dip" android:layout_marginLeft="8dip" android:layout_marginRight="8dip" android:layout_marginTop="6dip" android:background="@color/white" &gt; &lt;/WebView&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; 上面的代码如果没有LinearLayout，那么webview就不会滚动。从Android SDK1.6之后就会出现了，即使一个控件，也要加LinearLayout。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c94f2c1034a17f98f6f58dca78ef8626/" rel="bookmark">
			单目摄像机标定程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我自己写了一个摄像机标定程序，核心算法参照learning opencv，但是那个程序要从命令行预先输入参数，且标定图片要预先准备好，我觉得不太好，我就自己写了一个，跟大家分享下。 若有纰漏，希望大家指正！ #include "stdafx.h"#include "cv.h"#include "highgui.h"#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main(){int cube_length=7;CvCapture* capture;capture=cvCreateCameraCapture(0);if(capture==0){printf("无法捕获摄像头设备！\n\n");return 0;}else{printf("捕获摄像头设备成功！！\n\n");}IplImage* frame;cvNamedWindow("摄像机帧截取窗口",1);printf("按“C”键截取当前帧并保存为标定图片...\n按“Q”键退出截取帧过程...\n\n");int number_image=1;char *str1;str1=".jpg";char filename[20]="";while(true){frame=cvQueryFrame(capture);if(!frame)break;cvShowImage("摄像机帧截取窗口",frame);if(cvWaitKey(10)=='c'){sprintf_s (filename,"%d.jpg",number_image);cvSaveImage(filename,frame);cout&lt;&lt;"成功获取当前帧，并以文件名"&lt;&lt;filename&lt;&lt;"保存...\n\n";printf("按“C”键截取当前帧并保存为标定图片...\n按“Q”键退出截取帧过程...\n\n");number_image++;}else if(cvWaitKey(10)=='q'){printf("截取图像帧过程完成...\n\n");cout&lt;&lt;"共成功截取"&lt;&lt;--number_image&lt;&lt;"帧图像！！\n\n";break;}}cvReleaseImage(&amp;frame);cvDestroyWindow("摄像机帧截取窗口");IplImage * show;cvNamedWindow("RePlay",1);int a=1;int number_image_copy=number_image;CvSize board_size=cvSize(7,7);int board_width=board_size.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c94f2c1034a17f98f6f58dca78ef8626/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50af4b223ccff6e6e390bfe0caef1bdc/" rel="bookmark">
			jQuery ScrollPagination
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		看着腾讯微博的ScrollPagination挺好玩的，就在网上找找，写了个demo玩玩。
JQuery ScrollPagination ： http://andersonferminiano.com/jqueryscrollpagination/ 在该插件基础上修修改改。
1. 简单的servlet代码 DemoServlet
1 /** 2 * Create by: zhuyoufeng
3 * Date: 12-4-4
4 */ 5 public class DemoServlet extends HttpServlet { 6 protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { 7 doGet(request, response); 8 } 9 10 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { 11 List&lt;String&gt; content = new ArrayList&lt;String&gt;(); 12 for ( int i = 0; i &lt; 20; i++) { 13 content.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50af4b223ccff6e6e390bfe0caef1bdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d12ab30ba0366847c070b4deaa508ed/" rel="bookmark">
			Android中的Audio播放：竞争Audio之Audio Focus的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		田海立
2012-04-03
Android是多任务系统，Audio系统是竞争资源。Android2.2之前，没有内建的机制来解决多个程序竞争Audio的问题，2.2引入了称作AudioFocus的机制来管理对Audio资源的竞争的管理与协调。本文主要讲解AudioFocus的使用。
按照AudioFocus的机制，在使用Audio之前，需要申请AudioFocus，在获得AudioFocus之后才可以使用Audio；如果有别的程序竞争你正在使用的Audio，你的程序需要在收到通知之后做停止播放或者降低声音的处理。值得指出的是，这种机制是需要合作完成的，需要所有使用Audio资源的程序都按照这种机制来做，而如果有程序在它失去AudioFocus的时候仍然在使用Audio，AudioFocus拿它也没办法。而这一点对于开放系统的Android来说很致命的：用户可能安装没遵守这种机制的程序，或者版本太老还没引入这种机制的程序，这最终会导致很差的用户体验。
对于手机方案公司来说，要做的能做的事情就是教育和培训团队成员以保证自己内建的程序遵守机制没问题，这包括了Android原生的程序、自己开发的程序，以及适配第三方的程序。
一、AudioFocus的申请与释放
下面看与AudioFocus的相关的类：
获取/放弃AudioFocus的方法都在android.media.AudioManager中，获取AudioFocus用requestAudioFocus()；用完之后，放弃AudioFocus，用abandonAudioFocus()。
其中，参数：
streamType是《Android中的Audio播放：音量和远程播放控制》中说明的AudioStream，其值取决于AudioManager中的STREAM_xxx，在AudioStream的裁决机制中并未有什么实际意义； durationHint是持续性的指示：AUDIOFOCUS_GAIN指示申请得到的Audio Focus不知道会持续多久，一般是长期占有；AUDIOFOCUS_GAIN_TRANSIENT指示要申请的AudioFocus是暂时性的，会很快用完释放的；AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK不但说要申请的AudioFocus是暂时性的，还指示当前正在使用AudioFocus的可以继续播放，只是要“duck”一下（降低音量）。 AudioManager.OnAudioFocusChangeListener是申请成功之后监听AudioFocus使用情况的Listener，后续如果有别的程序要竞争AudioFocus，都是通过这个Listener的onAudioFocusChange()方法来通知这个Audio Focus的使用者的。 返回值，可能是：
AUDIOFOCUS_REQUEST_GRANTED：申请成功； AUDIOFOCUS_REQUEST_FAILED：申请失败。 二、AudioFocus被抢占与重新获得
由上节中知道，申请/释放AudioFocus时传入了AudioManager.OnAudioFocusChangeListener这个参数，其onAudioFocusChange()方法是Audio Focus被抢占与再次获得通知的地方。所以，每个要使用AudioFocus的程序都要小心实现这个函数，保证AudioFocus实现的一致性。
onAudioFocusChange()方法的focusChange参数指示了该AudioFocus的竞争者对AudioFocus的拥有情况，取值如下：
AUDIOFOCUS_GAIN：获得了Audio Focus； AUDIOFOCUS_LOSS：失去了Audio Focus，并将会持续很长的时间。这里因为可能会停掉很长时间，所以不仅仅要停止Audio的播放，最好直接释放掉Media资源。而因为停止播放Audio的时间会很长，如果程序因为这个原因而失去AudioFocus，最好不要让它再次自动获得AudioFocus而继续播放，不然突然冒出来的声音会让用户感觉莫名其妙，感受很不好。这里直接放弃AudioFocus，当然也不用再侦听远程播放控制【如下面代码的处理】。要再次播放，除非用户再在界面上点击开始播放，才重新初始化Media，进行播放。 AUDIOFOCUS_LOSS_TRANSIENT：暂时失去Audio Focus，并会很快再次获得。必须停止Audio的播放，但是因为可能会很快再次获得AudioFocus，这里可以不释放Media资源； AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK：暂时失去AudioFocus，但是可以继续播放，不过要在降低音量。 下面是onAudioFocusChange()方法处理的代码片段：
OnAudioFocusChangeListener afChangeListener = new OnAudioFocusChangeListener() { public void onAudioFocusChange(int focusChange) { if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT // Pause playback } else if (focusChange == AudioManager.AUDIOFOCUS_LOSS) { am.unregisterMediaButtonEventReceiver(RemoteControlReceiver); am.abandonAudioFocus(afChangeListener); // Stop playback } else if (focusChange == AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) { // Lower the volume } else if (focusChange == AudioManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d12ab30ba0366847c070b4deaa508ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56c5fa6087045e772488355871174b2c/" rel="bookmark">
			数字黑洞问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任意一个五位数，调整其各位数字，分别组成一个最大数字和一个最小数字；将其差值再作为新的五位数，再次进行上一操作，直到出现循环。例如41679，首次得差值82962，继续进行，则产生75933，63954，61974。由此构成一个循环数。
例如本题：
输入：41679
输出：[82962，75933，63954，61974]
请编程实现，一个给定五位数的循环圈。
方法一：使用数组
#include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int FindMax(int*); int FindMin(int*); void Div(int,int*); int main(){ int n,fir,max,min; //n is 原数， int a[5]; int res=0,cont=0; cout&lt;&lt;"输入一个五位数："&lt;&lt;endl; cin&gt;&gt;n; if(n&gt;99999||n&lt;10000){ cout&lt;&lt;"输入错误！"&lt;&lt;endl; return 0; } while(1){ Div(n,a); max=FindMax(a); if(cont==0) fir=max; min=FindMin(a); if(max==fir&amp;&amp;cont!=0) return 0; res=max-min; cout&lt;&lt;res&lt;&lt;endl; n=res; cont++; } } bool compare(int a,int b){ return a&gt;b; } int FindMax(int *a){ sort(a,a+5,compare); int n=a[0]*10000+a[1]*1000+a[2]*100+a[3]*10+a[4]; return n; } int FindMin(int *a){ sort(a,a+5); int n=a[0]*10000+a[1]*1000+a[2]*100+a[3]*10+a[4]; return n; } void Div(int n,int*a){ a[0]=n/10000; a[1]=(n-10000*a[0])/1000; a[2]=(n-10000*a[0]-1000*a[1])/100; a[3]=(n-10000*a[0]-1000*a[1]-100*a[2])/10; a[4]=(n-10000*a[0]-1000*a[1]-100*a[2]-10*a[3]); } 方法二，使用vector容器
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56c5fa6087045e772488355871174b2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b0948608394b1541e1aa1356fe2fc76/" rel="bookmark">
			在Ubuntu下编译Android系统问题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Ubuntu下编译Android系统问题汇总 在编译Android系统前，一定要确定相关的编译环境支持软件都已经全部安装： $sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev lib32ncurses5-dev ia32-libs x11proto-core-dev libx11-dev lib32readline5-dev lib32z-dev 对于编译Froyo或一个较老到64-bit到系统，还需要安装如下到包： $ sudo apt-get install gcc-multilib g++-multilib libc6-i386libc6-dev-i386
具体问题：
1、 编译时出现/usr/bin/ld: skipping incompatible/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../libz.so when searchingfor -lz错误信息
============================================ PLATFORM_VERSION_CODENAME=AOSP PLATFORM_VERSION=AOSP TARGET_PRODUCT=generic TARGET_BUILD_VARIANT=eng TARGET_SIMULATOR= TARGET_BUILD_TYPE=release TARGET_BUILD_APPS= TARGET_ARCH=arm TARGET_ARCH_VARIANT=armv5te HOST_ARCH=x86 HOST_OS=linux HOST_BUILD_TYPE=release BUILD_ID=OPENMASTER ============================================ host Executable: aapt(out/host/linux-x86/obj/EXECUTABLES/aapt_intermediates/aapt) /usr/bin/ld: skipping incompatible/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../libz.so when searchingfor -lz /usr/bin/ld: skipping incompatible/usr/lib/gcc/x86_64-linux-gnu/4.4.5/../../../libz.a when searchingfor -lz /usr/bin/ld: skipping incompatible //usr/lib/libz.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b0948608394b1541e1aa1356fe2fc76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e3178497664ad8f339893c76e57c1eb/" rel="bookmark">
			《一个操作系统的实现》读书笔记--第三章---不同特权级代码段之间的跳转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、特权级
2、一致代码段和非一致代码段
3、DPL、RPL、CPL分别代表的含义，存储在什么位置，以及它们之间的关系
4、不同特权级数据段之间的访问规则
5、不同特权级代码段之间的转移
6、代码段之间的转移对堆栈的影响
7、结合pmtest5.asm来见证不同特权级代码段之间的跳转
一、特权级 在IA32的分段机制下，特权级总共有4个特权级别，从高到低分别是0、1、2、3。数字越小表示的特权级越大。特权级如下图所示：
较为核心的代码和数据，将被存放在特权级较高的层级中。处理器将用这样的机制来避免低特权级的任务在不被允许的情况下访问位于高特权级的段。
二、一致代码段 和 非一致代码段
系统要安全，必须保证内核与用户程序分离开，内核要安全，必须不能被用户来打扰。但是有的时候，用户程序也是需要访问内核中的部分数据，那怎么办？
于是操作系统就将内核中的段分为共享的代码段和非共享的代码段两部分。
其中一致代码段就是操作系统拿出来被共享的代码段，可以被低特权级的用户直接访问的代码。
一致代码段的限制作用：
(1)特权级高的代码段不允许访问特权级低的代码段：即内核态不允许调用用户态下的代码。
(2)特权级低的代码段可以访问特权级高的代码段，但是当前的特权级不发生变化。即：用户态可以访问内核态的代码，但是用户态仍然是用户态。
非一致代码段：为了避免低特权级的访问而被操作系统保护起来的系统代码，也就是非共享代码。
非一致代码段的限制作用：
(1)只允许同特权级间访问
(2)绝对禁止不同级间访问，即：用户态不能访问内核态，内核态也不访问用户态。
下图为一致码段与非一致码段的访问规则：
三、CPL、DPL、RPL分别代表的含义，存储在什么位置，以及它们之间的关系
1、CPL(Current Privilege Level)是当前执行的程序或任务的特权级。它被存储在CS和SS的第0位和第1位上。通常情况下，CPL等于代码的段的特权级。在遇到一致代码段时，一致代码段可以被相同或者更低特权级的代码访问。当处理器访问一个与CPL特权级不同的一致代码段时，CPL不会被改变。
2、DPL(Descriptor Privilege Level)：DPL表示段或者门的特权级，它被存储在段描述符或者门描述符的DPL字段中。当当前代码段试图访问一个段或者门时，DPL将会和CPL以及段或门选择子的RPL相比较，根据段或者门类型的不同，DPL将会被区别对待，下面介绍一下各种类型的段或者门的情况。
(1)数据段：DPL规定了可以访问此段的最低特权级。比如，一个数据段的DPL是1，那么只有运行在CPL为0或者1的程序才有权访问它。
(2)非一致代码段（不使用调用门的情况下）：DPL规定访问此段的特权级。比如一个非一致代码段的特权级为0，那么只有CPL为0的程序才可以访问它。
(3)调用门：DPL规定了当前执行的程序或任务可以访问此调用门的最低特权级（这与数据段的规则是一致的）。
(4)一致代码段和通过调用门访问的非一致代码段：DPL规定了访问此段的最高特权级。比如，一个一致代码段的DPL是2，那么CPL为0和1的程序将无法访问此段。
3、RPL（Requested Privilege Level）:RPL是通过选择子的第0位和第1位表现出来的。处理器通过检查RPL和CPL来确认一个访问请求是否合法。
四、不同特权级数据段之间的访问规则 数据段中DPL规定了可以访问此段的最低特权级，因此，对数据的访问，只要CPL和RPL都小于被访问的数据段的DPL就可以了，即CPL&lt;=DPL和RPL&lt;=DPL。
五、不同特权级代码段之间的转移
使用jmp或call指令可以实现下列4种转移
(1)目标操作数包含目标代码段的段选择子。
(2)目标操作数指向一个包含目标代码段选择子的调用门描述符。
(3)目标操作数指向一个包含目标代码段选择子的TSS。
(4)目标操作数指向一个任务门，这个任务门指向一个包含目标代码段选择子的TSS。
这4种方式可以看做是两大类，一类是通过jmp和call的直接转移（上述第一种），另一类是通过某个描述 符的间接转移（上述第2,3,4种）。
1、通过jmp或call进行直接转移
2、通过调用门进行转移
(1)门描述符的结构
调用门描述符里面保存着目标代码段的段选择子，偏移量，以及属性。
(2)调用门的使用方式
假设我们想由代码A转移到代码B，运用一个调用门G，即调用门G中的目标选择子指向代码B的段。实际上，这个问题主要涉及这几个元素：CPL、RPL、代码B的DPL（记做DPL_B），调用门G的DPL（记做DPL_G）。 调用门使用时特权级检验的规则如下：
也就是说，通过调用门和call指令，可以实现从低特权级到高特权级的转移，无论目标代码段时一致的还是非一致的。 通过调用门和jmp指令，如果目标代码段是一致的，则可以实现从低特权级到高特权级的转移。如果目标代码段是非一致的，则只能实现相同特权级的转移。
六、代码段之间的转移对堆栈的影响
1、“长”跳转/调用 和 “短”跳转/调用
如果一个调用或跳转指令时段间而不是段内进行的，那么我们称之为“长”的（Far jmp/call），反之，如果在段内则是“短”的(Near jmp/call)。
那么长的和短的jmp或call有什么分别呢？
对于jmp而言，仅仅是结果不同罢了，短跳转对应段内，长跳转对应段间。
对于call来说，就比较复杂一些，因为call指令是会影响堆栈的，长调用和短调用对堆栈的影响是不同的。
下面我们讨论短调用对堆栈的影响，call指令执行时下一条指令的eip压栈，到ret指令执行时，这个eip会被从堆栈中弹出，
如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e3178497664ad8f339893c76e57c1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a58b99fbeecd9fc57c6c42c33fe41f6b/" rel="bookmark">
			产品创新的秘诀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来自：http://www.programmer.com.cn/10013/
文 / Marty Cagan 译 / 黄捷文，韦文凯
Marty Cagan是享有世界声誉的产品管理专家，曾经担任网景副总裁、eBay产品管理及设计高级副总裁。本文是他回顾自己二十多年来从事软件产品管理工作的总结和经验分享，谈到了产品创新应该注意的问题，以及在大公司创新的方法。
创新就是这样被扼杀的
我拜访了两家软件技术公司（都不在硅谷），它们近期都引入了六西格玛顾问。我非常惊讶，我本以为六西格玛的思想在高科技公司早已销声匿迹了。我希望这只是个别现象，但“忘记历史的人注定重蹈覆辙”，因此我认为有必要在此讨论一下六西格玛这类以质量为中心的方法。
在制造业，尤其在公司深陷质量或成本问题时，六西格玛是非常合适的解决方案。它基于一套质量管理的方法和实践经验，可以有效地降低成本及缺陷率。
不幸的是，很多宣扬六西格玛的人认为这套原则应该适用于公司的所有业务流程。但这些能在制造流程中去除质量缺陷的方法，却是扼杀创新、摧毁产品探索和开发的罪魁祸首。
对于有些公司而言，创新意味着企业的全部，也许你的意愿是好的，但六西格玛的实施绝对会让你误入歧途，甚至毁掉整个公司，而这绝对不是在耸人听闻。在我们这个行业，创新能力就是企业的命脉。质量固然重要，但只有创造出顾客需要的产品后，才有资格讨论质量问题。
还记得摩托罗拉，那个曾经靠创造力发展的公司吗？还记得3M，那个曾经靠鼓励员工主动创新的公司吗？还记得通用电气，那个确实曾经“将伟大的想法注入生活”的公司吗？还有Sun，那个曾经极具创新能力的公司？Intuit，那个在建立之初就承诺要取悦客户的公司？
曾经，它们都是广受赞誉、持续进行科技创新的公司，直到六西格玛介入，它们的创新能力几乎统统被扼杀了。只能靠小幅的增量优化在行业里“苟延残喘”。当然六西格玛的本意绝不是充当创新“终结者”，但一个组织尝试采用六西格玛取代原本适合的产品管理流程，无疑会造成“副作用”大于“疗效”的后果，尤其是随着时间的推移，“副作用”会更加明显。你固然可以在短期内降低一些成本，但你很快会看到后果，例如新产品推出慢如蜗牛，客户对你的产品越来越失望。
人们一向对大公司里的创新嗤之以鼻，认为唯有创业型公司才可能创新，大公司只能复制创业型公司的成果，或者干脆收购那些成功的创业型公司。不可否认，创业型公司的氛围更适合创新，但不代表大公司做不到这一点。
你会发现在采用六西格玛管理方式的高科技产品团队中，具有创造力和主动性的人才会快速流失掉。他们受不了严苛制度的制约，更受不了所谓的“制度”将自己的创意行为描述成“离经叛道”。因此，别指望在六西格玛的高压下留住有这类人才，而没有了他们，你的企业也就失去了未来。
高科技公司的首要工作不是排除缺陷、提高效率，而是探索并创造出客户喜爱的产品及服务。不要误入歧途——把“正确地创建产品”当作“创建正确的产品”。
如果你的目标是夺得美国波多里奇国家质量奖（Malcolm Baldrige National Quality Award），那么六西格玛可能对你有用；但如果你的目标是要创造成功的产品，你需要在产品探索、鼓励创新及主动性方面优化你的组织，激发员工“离经叛道”的创意。
在不适合的领域强行推广不合适的工具，不只是六西格玛咨询师犯这样的错误。某些过度狂热的Scrum（一种迭代开发流程）宣扬者在不适用Scrum的领域推行他们的流程，结果乱得一塌糊涂。但坦率地说，在扼杀创新的“能力”上，六西格玛排第二，就没谁敢排第一了。
因此，假如在你的高科技公司里发现了六西格玛咨询师，建议快快把他们扫地出门，一刻都不能耽误。
大公司如何创新
有困难，但值得一试。
人们一向对大公司里的创新嗤之以鼻，认为唯有创业型公司才可能创新，大公司只能复制创业型公司的成果，或者干脆收购那些成功的创业型公司。不可否认，创业型公司的氛围更适合创新，但不代表大公司做不到这一点。
没在大公司工作过，你想象不出在大公司里创新有多难。随着规模变大，公司会不可避免地变得更加保守，不敢冒险。因为一旦失败，比起小公司来，大公司的损失会惨重得多，所以只要情况允许，他们会尽可能维持现状。但大公司也需要创新以谋求发展，何况大公司还有自己的优势。
有两大因素影响着大公司的创新氛围：企业文化和老板的观念。依我看，任何一家大公司都有潜力为自己的员工营造创新氛围。如果你发现在公司里难以实现创新，可以尝试以下方法。
20%法则
你也许听说过，谷歌的程序员有20%的工作时间可以用来从事创新研究。20多年前我在惠普工作时就这样做过，这个方法最早是从施乐帕克研究所学来的，至今仍然行之有效。在惠普实验室，我们的工作任务是技术创新，然后和产品部门合作“孵化”出产品。我所在的小组一共完成了五款产品，有四款是20%法则催生的，剩下的一款产品是公司高管命令我们完成的，结果只有这款产品被市场淘汰了。
人们误以为优秀的产品是战略规划的结果，或是来自公司高管的创意。其实，最好的创意大多来自于普通员工。20%法则鼓励普通员工自己尝试各种想法，发挥大家的主观能动性，让员工打心底里愿意倾注更多的激情和汗水去创新。
20%法则不仅适用于开发人员，也同样适用于产品经理和交互设计师。遗憾的是，大部分公司没有采用20%法则，我建议产品公司尝试这个方法。如果公司实在不同意在工作时间创新，那我们只好私下开展“臭鼬工程”了。
臭鼬工程
臭鼬工程是工程界的行话，原指秘密军事行动，现指在受限制的条件下，利用自己的时间，低调地进行创新研究。臭鼬工程拯救了很多大公司。
在大公司里，普通员工很难凭空获得允许从事创新研究。如果你能拿出阶段性的成果来，获得许可会容易得多。在这种情况下，只要不耽误本职工作，管理层通常会支持你的做法。
有一点要提醒大家，有些公司规定在职期间研究出来的成果都归公司所有，所以不要随意拿研究成果自行创业。如果公司因为某些原因不愿意帮助你，你才能尝试谋求其他途径来实现自己的创意。了解硅谷历史的人知道，当年斯蒂夫·沃兹尼亚克（Steve Wozniak）因为惠普公司不愿意进入个人电脑市场，所以离职创业，才有了后来的苹果公司。
主动观察
观察和倾听是最简单的创新途径。仔细观察用户使用公司产品或同类产品的一举一动，留心他们欣喜和失望的表情，假以时日，你肯定能想出办法更好地满足他们的需求。再找一位熟悉技术的开发人员合作，你们就可以着手改进产品了。
注意，应该选择实际用户作为观察对象，不要选择产品尝鲜者，更不能选择公司同事。测试产品用不着正式的可用性测试实验室，你可以去用户的住所、办公室、购物场所，请他们就地体验你的产品。不仅要观察软件能否正常使用，更要留心软件能否满足他们的需求。即使软件可用，他们真的需要吗？究竟什么是他们想解决的问题？
记住，创新不是发现新问题，而是用新方法解决已有的问题。观察人们对现有产品的不满，是创新的最佳途径。
改善用户体验
另一种创新途径是跳出技术局限，完善用户体验。改善用户体验不仅要提高产品的工作效率，更要剔除多余的功能，明白哪些功能是用户必须的，哪些是设计和开发带来的衍生物。
每款产品都有特定的实现模型，但用户脑子里装的是概念模型，他们对产品要解决的问题，以及如何解决问题有自己的想法。如果实现模型与用户的概念模型不一致，用户就会感到失望。找到用户失望的地方，就找到了创新的机会，至少是改善产品的机会。
收购小公司
最后，我们来谈谈“收购”别人的创意。虽说有些产品经理看不起这种做法，但收购确实是有效维持创新的手段。创业型公司如雨后春笋般出现，经过市场淘汰，留下来的通常都有其特长，可以作为收购对象。收购创业型公司不仅可以引入新技术，而且可以引入创新型人才，为公司注入新鲜的血液。
我建议大公司的产品经理多和业内活跃的创业型公司建立联系，互相帮助，互相学习。这种人脉关系也许能替公司节省上百万的资金。从以往的经验来看，创业型公司在选择收购自己的东家时，并不是只看收购价格，他们往往会选择有过合作关系的公司。
妥善安排收购来的新员工，让他们继续发挥特长，才能拓展产品线，保持市场领先地位。但很遗憾，多数公司没有处理好这个问题。
建议大家尝试以上的方法，帮助公司保持创新。德鲁克曾说过：“公司的核心竞争力在于创新。”我相信大公司一样可以创新，苹果公司就是最好的例证。
在大公司工作经常会感觉到束手无策，施展不开。然而，如果能够参照文中给出的十大秘诀并懂得合理利用资源，就会发现在大公司工作其实有一些明显的优势。
在大公司施展拳脚的10大秘诀
我曾与许多大公司合作，他们的产品经理向我抱怨工作时束手束脚，施展不开。我也在大公司工作过，知道其中的难处，但我相信只要懂得利用资源，在大公司工作有明显的优势。
也许你工作的公司目前规模尚小，但随着业务发展，总有一天你会面临同样的窘境。如果你的合作伙伴是一家大公司的话，那么你们实际上是在一条船上。了解大公司的运作方式，对双方的合作都有益处。在讨论如何顺利展开工作，让整个公司支持你的产品，协助你设计、开发、发布产品前，我先介绍一下大公司的现实情况。
首先，大公司都遵循一条潜规则——尽量规避风险。这并非偶然，随着业务规模变大，公司会不可避免地变得保守。因为大公司承担的风险更大，如果出现问题，损失也比小公司惨重。所以创新更容易发生在小公司里。在大公司工作，首先要面对的是公司现有的流程、规定和条条框框。 其次，多数大公司都采取矩阵式的管理方式，核心部门（如设计部门、开发部门、QA部门、运维部门、市场部门）是共享资源，产品经理要确保争取到足够的资源才能研发出产品。采用这种组织结构不是因为它的效率高，而是为了节约公司运营的成本。 充分理解这两点后，我来介绍在大公司施展拳脚的十大秘诀。
了解公司制订决策的方式
每家公司的企业文化各不相同，制订决策的方式也千差万别。如果公司制订决策的方式不符合你的习惯，不要老想着改变大家来适应自己，要学着融入其中。
虽然有些公司有明确的民主决策制度，但最终决策还是要请某位大人物拍板。你千万不要纠缠大家有没有没按照制度办事，与其抱怨，不如主动利用这一点。知道决策权在谁手里，你的工作目标就更明确了。了解他制订决策的方式，他是更看重原型演示、市场数据，还是客户的承诺和评价。如果你需要公司的支持，那么只需要说服他就可以了。
建立人脉网络
在大公司工作必须与人合作，你需要同事的协助才能完成设计、开发、发布工作。如果你喜欢单枪匹马的工作，创业型公司更适合你。
主动与各个部门的同事结交朋友，聊聊工作的事，向大家介绍你手头的项目，不要等到有事才去找人家。主动帮助他人，积累人脉关系。
拥抱“臭鼬工程”
在大公司里，凭空申请创新资源很困难。想靠几张画着产品构想的幻灯片就能说服老板是不切实际的。更可行的方法是找三五个志趣相投的同事在工作之余把产品原型做出来。你会发现产品原型具有超出想象的说服效果，比起枯燥的陈述，生动形象的演示更有吸引力。数不清的优秀产品就是这样诞生的。
自己顶上
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a58b99fbeecd9fc57c6c42c33fe41f6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93837504c791b956774ed701ea16730d/" rel="bookmark">
			Top 10 Leadership Qualities
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是leader？who is able to get others to willingly follow. 哪10个特质呢？
They have a vision. they has a clear, vivid picture of where to go, as well as a firm grasp on what success looks like and how to achieve it. But it’s not enough to have a vision; leaders must also share it and act upon it. Jack Welch, former chairman and CEO of General Electric Co., said, "Good business leaders create a vision, articulate the vision, passionately own the vision and relentlessly drive it to completion.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93837504c791b956774ed701ea16730d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac14f16da89972280e6272906e9361b7/" rel="bookmark">
			GDB基本命令(整合)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、gdb调试基本知识
a.调试器指示的是将要执行的代码行
b.只有在编译时拥有调试符号(-g)的程序才能在调试时看到源码
c.同一行上有多个断点时，gdb仅中断在断点号最小的那个断点上
d.断点可以设置在同一程序的不同文件中
e.在任何给定时间，gdb只有一个焦点，即当前“活动”的文件
f.源文件改变后，断点发生移动，带式断点属性的行号不变
二、GDB基本命令清单查询
在 gdb 提示符处键入help，将列出命令的分类，主要的分类有： * aliases：命令别名 * breakpoints：断点定义； * data：数据查看； * files：指定并查看文件； * internals：维护命令； * running：程序执行； * stack：调用栈查看； * statu：状态查看； * tracepoints：跟踪程序执行。 键入 help 后跟命令的分类名（如help aliases），可获得该类命令的详细清单。
三、GDB基本命令用法
1、运行退出
run（简写r）：执行程序
(gdb)run app [argv1] [argv2] ...
run命令后可跟随发给该程序的任何参数，包括标准输入和标准输出说明符(&lt;和&gt;)和外壳通配符（*、？、[、]）在内。 如果使用不带参数的run命令，gdb就再次使用前一条run命令的参数。
set args：设定传递给程序的参数
(gdb)set args [argv1] [argv2] ...
show args：查看其缺省参数的列表 (gdb)show args kill（简写k）：异常终止在gdb 控制下运行的程序
(gdb)kill
quit（简写q）：退出gdb
(gdb)quit
2、查看信息
list（简写l）：查看源码
(gdb) list line_num或l line_num，line_num为行号。 pirnt(简写p)：
print var：查看变量var的值。 (gdb) print var
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac14f16da89972280e6272906e9361b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6dce93496691dd47e8b007b4b17f51d/" rel="bookmark">
			读写器reader和writer详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、读取器Ext.data.reader.Reader 根类
1、JSON格式的读取器
(1)定义数据集(例子使用内存代理)
varuserData={
//total:200,
count:250,
user:[autorth:"zhang",info{
userID:1,
name:"marico",
orders:[
{id:"001",name:"pen"},
{id:"002",name:"book"}
]
}]
};
(2)定义model数据模型 配置一对多关联
配置一对多关系 ，hasmany字段指定一个对象
model指定的是多方的数据模型
name指定的属性名，如果配置name则使用这个名字来获取级联的记录，如果不配置系统自动生成为orders
Ext.regModel("user",{
fields:[
{name:"userID",type:"string"},
{name:"name",type:"string"}
],
hasMany:{
model:"order"
//name:"order"
}
});
配置多对一关系，belongTo指定一个对象
参数type值得是什么关联，belongTo代表多对一 model指定一方的数据模型
Ext.regModel("order",{
fields:[
{name:"id",type:"string"},
{name:"name",type:"string"}
],
belongTo:{type:"belongTo",model:"user"}
});
(3)创建内存代理并指定reader
reader指定的是对象
type指定的是什么数据 常用json和xml
root指定的是得到数据的根，也就想得到的数据的对象名，上方userData中的user
implicitIncludes默认为true 设置是否级联操作
totalProperty指定的是读取total数据的属性名 如果没有系统则默认为1
record对服务器返回的数据可能很复杂，用record可以筛选出有用的的数据信息，装载到Model中
varmproxy=Ext.create("Ext.data.proxy.Memory",{
model:"user",
data:userData,
reader:{
type:"json",
root:"user",
implicitIncludes:true,
totalProperty:"count",//上方已经设置为count
record:"info" }
});
(4)调用代理中的read方法遍历并输出元素
mproxy.read(newExt.data.Operation(),function(result){
vardatas=result.resultSet.records;//存放数据的对象数组
//alert(result);
alert(result.resultSet.total);
//利用ExtArray中的each方法遍历数组
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6dce93496691dd47e8b007b4b17f51d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9de7ba09f2c0d41f724b87e59fc0ac8/" rel="bookmark">
			PS域业务与CS域业务的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、CS和PS是针对核心网部分而言的，两者的不同在于交换方式。CS是电路交换，通信之前，资源预留，不同用户独占各自分配的资源，没有统计复用。PS是包交换，不同的用户可以共享同样的资源，统计复用。包交换又分为面向连接和非连接，面向连接预先为数据包指定路由，从而减少路由时间，也在一定程度上保证了数据包的顺利到达；非连接不预先指定路由，各个数据包单独选路。但不管是面向连接和非连接，在对资源的使用上都是采用了存储转发的统计复用方式。 所以一般语音走CS域，而手机上网走PS域。 但如果是VOIP电话这算是走PS域。 2、CS域主要负责语音业务，如12.2K语音业务，64K视频电话业务等，PS域用于数据业务，通俗点说也就是上网业务，接入互联网。 3、CS域叫电路交换域，主要有语音业务（AMR 12.2K），视频电话业务（CS64K）；PS域叫数据交换域，负责数据业务，包括PS384K业务（UE发起384kbps PS域数据业务，是用手机下载一些数据文件等），还有就是高速数据业务包括上传和下载数据业务，也就是HS业务等。 4、交换方式和业务不一样。CS主要针对实时性要求较高的业务，如语音、视频业务，对延时的要求很高。PS是分组数据业务，体现在数据二字上面，主要提供像PS384HS等上网服务 5、CS电弧交换，独占信道主要用于语音，直到通话结束才释放信道，供其他用户使用。PS分组交换（包交换），主要用于数据业务（上网之类），采用分组-转发机制，多用户共用信道资源，使得资源利用率大大提高。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/507/">«</a>
	<span class="pagination__item pagination__item--current">508/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/509/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>