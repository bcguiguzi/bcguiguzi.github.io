<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141bd630b600de3be46be9c3e128590b/" rel="bookmark">
			MySql安装最后一步start service失败，手动启动报1067错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 个人解决步骤:
C:\Program Files\MySQL\MySQL Server 5.1下my-small.ini 拷贝一份到当前目录改名为my.init
在my.init最后加入如下安装路径和数据路径：
[mysqld] basedir=C:\Program Files\MySQL\MySQL Server 5.1
datadir=C:\ProgramData\MySQL\MySQL Server 5.1\data\
[WinMySQLServer] server=C:\Program Files\MySQL\MySQL Server 5.1\bin\mysqld-nt.exe 然后在cmd命令行进入到bin目录下执行：
C:\Program Files\MySQL\MySQL Server 5.1\bin &gt;mysqld –install Service successfully installed. C:\Program Files\MySQL\MySQL Server 5.1\bin &gt;net start mysql 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15f9edb1204a51a3a288f674d3e9ce66/" rel="bookmark">
			jquery 获取所有的 checkbox 值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script type="text/javascript" src="jquery-1.7.2.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function getCheckAdIds() { var adIds = ""; $("input:checkbox[name=check_name]:checked'").each(function(i){ if(0==i){ adIds = $(this).val(); }else{ adIds += (","+$(this).val()); } }); alert(adIds); return adIds; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input name="check_name" type="checkbox" value="1"/&gt;1 &lt;input name="check_name" type="checkbox" value="2"/&gt;2 &lt;input name="check_name" type="checkbox" value="3"/&gt;3 &lt;input name="check_name" type="checkbox" value="4"/&gt;4 &lt;input name="check_name" type="checkbox" value="5"/&gt;5 &lt;input name="check_name" type="checkbox" value="6"/&gt;6&lt;br/&gt; &lt;button οnclick="getCheckAdIds()"&gt;获取选中结果&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4dfe4e592e1f3a3153a4d3c66178bcaf/" rel="bookmark">
			虚拟机和双系统的优缺点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 虚拟机需要划分部分内存，硬盘占用空间不大，窗口切换，比较灵活。 装双系统的话，每个系统使用的硬件条件是一样的，内存不打折，反应快，可能需要划分硬盘空间做新系统盘，但是进入另外一个系统需要重启。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0017412692867c8d34d46e0e58a9833/" rel="bookmark">
			Android中@Deprecated 标签的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 @Deprecated 标签的作用是是使一个变量名或者类、方法名中间画上黑粗横线表示已过期 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca4cf9340c9d5e625502284bf6b2f3c2/" rel="bookmark">
			TDW与PostgreSQL数据互访问功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TDW与PostgreSQL数据互访问功能 李巍
TDW作为一个离线数据分析系统，在处理海量数据方面，通过并行计算，有很好的性能优势。但是我们知道，想用一个大而全的系统解决所有问题一般也是不现实的，同样，TDW也有它的劣势，比如对小数据处理性能低，update/delete性能差、接口不丰富等。因此我们引入一个强大的开源数据库PostgreSQL，并对其做一些功能扩展，使之有访问TDW数据的能力；同时我们在TDW中开发了一种新的存储引擎，我们称之为pgdata存储引擎，使得TDW具备读写PostgreSQL中的数据的能力。TDW与PostgreSQL互访问功能的实现，对TDW是一个强有力的补充，这些主要体现在如下3点：
1. 弥补TDW接口不丰富的短板
TDW缺乏标准化的JDBC/ODBC，编程接口也不丰富，而PostgreSQL有社区强大的力量，提供了JDBC/ODBC, shell,C/C++, C#, python, perl等各种语言的接口，用户通过这些丰富的接口和我们开发的PostgreSQL的TDW桥接工具tdwlink，访问TDW中的数据。
2. 弥补TDW小数据分析效率底的短板
TDW在海量数据处理时，可以发挥它并行执行的优势。但是对于小数据分析，它的性能反而不如传统的DB。使用PostgreSQL，对于10GB以内的数据分析，可以获得更好的性能和时间响应，一般可以在秒级返回结果，相比TDW分钟级的响应，tPG在这种场景下更有优势。
3. 作为TDW的pgdata存储引擎，弥补TDW update/delete效率底下的短板
TDW作为数据仓库系统，对于记录级的update/delete支持不是很好。在TDW中记录级的update/delete，会导致整个表的重写，也就是说，即使delete一条数据，也会导致整个表重写一遍，耗费大量系统资源。而tPG作为传统数据库，记录级的update和delete效率非常高。
PostgreSQL系统在TDW生态圈中的位置如下图所示，tPG是我们对扩充之后的PostgreSQL的一个叫法：
下面我们分两个部分对TDW与PostgreSQL的互访问功能做一个介绍，也即是pgdata存储引擎以及tdwlink功能。
pgdata存储引擎
TDW本身支持多种存储格式，包括textfile， rcfile，pbfile，在这个基础上，我们开发一种新的存储引擎，也即pgdata存储引擎，能够透明的存储以及访问PostgreSQL中的数据，具体情况如下图
在使用上，只需要在创建表的时候指定为pgdata存储引擎即可，例如使用如下语句就可以创建此类型的外表
create external tablefoo(idx bigint, str string) stored as pgdata
在后续访问过程中就和使用其他TDW表一般即可，在此简单说明一下访问的实现方式，访问的数据流大致如下
1. 在解析SQL查询语句时，先分解出每个子查询，然后对每个子查询总是会首先判断当前查询涉及的表中是pgdata外表，如果没有DB外表则走正常的查询语句执行流程；
2. 如果有pgdata外表, 接着再检查在本次查询中涉及到的外表数据是否已经导入，如果导入则直接复用已经导入的数据，如果没有则对相应的子查询进行加工，将其转换为相应的标准关系型数据库SQL语句，然后从表中获取连接信息，使用JDBC执行查询语句；
3. 将查询结果的数据从数据库中导入到位于tmp目录下的一个随机HDFS目录中，这个随机目录使用UUID生成，因此可以保证唯一性，而不与其他查询语句产生冲突，然后将其设置为外表的数据所在的HDFS文件路径，Mapreduce任务会自动读取该路径作为任务的输入路径；
4. 在该条查询执行结束以后，并且查询结果已经获取成功，则清除掉这个临时文件。如果查询出现了异常也会自动的清理到已经导入的垃圾数据信息。
tdwlink功能
SQL标准中包含了一个名为SQL/MED也即"SQL Management of External Data"的功能， PostgreSQL在2011年的9.1版本使用一种叫Foreign Data Wrappers的机制对此标准做了只读支持，开发人员只需要对相应的数据源开发相应的插件即可通过PostgreSQL对远端数据源进行访问。目前社区已经有很多基于此功能开发的插件，诸如oracle_fdw，mysql_fdw，redis_fdw等，我们团队基于PostgreSQL的这个特性，开发了具备访问TDW数据能力的插件，称之为tdw_fdw，可以参考下图
为了方便用户使用此功能，我们开发了一个存储过程tdwlink，用户只需要事先配置好对应的Foreign server以及认证信息，即可很方便的使用，例如我们已经定义好了tdw_svr这个server，想访问tdw里的test库的test表，我们只需要selecttdw_meta.tdwlink(‘tdw_svr’, ‘test’, ‘select col1, col2 from test’)即可。
由于此函数是通过PostgreSQL提供的，因此我们可以使用PostgreSQL提供的任意接口来使用，这样也间接的扩充了TDW所具备的访问接口。
这里补充一点，我们的tdw_fdw插件是基于PostgreSQL 9.1版本开发的，这个版本的Foreign Data Wrappers只能对外部数据源提供只读访问，因此我们的tdw_fdw只能够提供对TDW的只读访问，而最新发布的PostgreSQL9.3版本的Foreign Data Wrappers已经提供写支持，这个也是我们的tdw_fdw插件后续可以进行功能扩充的地方。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70fc24e8de6f775d77da34aee4a0855b/" rel="bookmark">
			矩阵消元
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		矩阵消元法（Elimination）是常用的方程组Ax=b求解方法，但是该如何利用矩阵变换的思想来理解消元法呢？
假设有方程组
对于上述方程组，系数矩阵A为，整个消元过程为
在用矩阵变换的思想理解矩阵消元之前，关于矩阵乘法的理解很重要，矩阵乘法可以从行的角度理解，列的角度理解，也可从矩阵单个元素的角度理解（这是我们通常的理解）。如果从行的角度，则相乘是矩阵行的线性组合，为了方便书写，这里给出的例子是向量与矩阵的相乘，因为矩阵-矩阵的相乘最终也是分解为矩阵-向量的相乘来实现的，如
这个过程表示对进行了行变换，也就是说，要对一个矩阵进行变换，需在该矩阵左侧乘以一个矩阵。
如果从列的角度，则相乘是矩阵列的线性组合，如
这个过程表示对进行了列变换，也就是说，要对一个矩阵进行列变换，需在该矩阵右侧乘以一个矩阵。
因此如果有矩阵A和矩阵B相乘A*B，我们可以理解为A对B进行了行变换，也可以理解为B对A进行了列变换。
回到矩阵的消元，有什么样的矩阵可以实现将A的第一行乘以-3加到第二行去，保持第一行不变？由于消元法进行的是行变换，因此上面的过程应该是在A的左侧乘以一个未知阵，即
设该未知消元矩阵E21为
则有
由上式易得E21=，E21表示将矩阵第2行第1列的数消去。
同样有什么样的矩阵可以实现将A的第二行乘以-2加到第三行去，保持第一、二行不变？即
按照上面的方法，可得消元矩阵E32=
也就是说上述的整个矩阵消元过程可以表示为 E32*(E21*A)=U
由于消元法中有可能涉及行之间的交换，因此还有一类重要的矩阵完成交换矩阵中两行次序的功能，称为置换矩阵（Permutation），同样按照上面矩阵相乘的思路，如果要交换行，则
如果要交换列，则
即如果要进行列交换，置换矩阵应放在右侧，如果进行行交换，置换矩阵放在左侧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a4d13679805f8e37e169bbeffba0b2/" rel="bookmark">
			[总结]自制USB转232（TTL电平）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、芯片选型 网上版本很多，我已经用PL2303制作了一个，但是速度很慢，而且不是很稳定，主要是芯片盗版的太多，只能用旧版驱动，而且波特率非常的不稳定，大部分盗版芯片只能用最低波特率通信，非常不好用。 所以选用与PL2303电路差不多的FT232芯片，稳定性和速度都要好很多，而且FT232自带晶振，比2303简单一点。 封装2个芯片都是SSOP28 ，自己用万能板做的话需要一个贴片转DIP直插的转接板。 二、电路图
三、开工 1.跳线用开关代替，切换输出的电源3.3V和5V 2.没用的usb引脚4意外折断，⊙﹏⊙b汗 3.开始用成了ssop24的转接板量的尺寸，结果悲催的输出接插件只能焊到背面了，丑死了 4.未花心思布局，有心的童鞋可以画个洞洞板的PCB看看，毕竟电路不负杂
四、测试OK
下载速度非常快，非常犀利，比PL2303要好太多太多了。 附：PL2303已经实测成功的电路图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d493c9f902d97183e2a7046536cd14de/" rel="bookmark">
			sql查询重复记录、删除重复记录方法大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查找所有重复标题的记录： SELECT * FROM t_info a WHERE ((SELECT COUNT(*) FROM t_info WHERE Title = a.Title) &gt; 1) ORDER BY Title DESC 一。查找重复记录 1。查找全部重复记录 Select * From 表 Where 重复字段 In (Select 重复字段 From 表 Group By 重复字段 Having Count(*)&gt;1) 2。过滤重复记录(只显示一条) Select * From HZT Where ID In (Select Max(ID) From HZT Group By Title) 注：此处显示ID最大一条记录 二。删除重复记录 1。删除全部重复记录（慎用） Delete 表 Where 重复字段 In (Select 重复字段 From 表 Group By 重复字段 Having Count(*)&gt;1) 2。保留一条（这个应该是大多数人所需要的 ^_^） Delete HZT Where ID Not In (Select Max(ID) From HZT Group By Title) 注：此处保留ID最大一条记录 1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断 select * from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) 2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录 delete from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) and rowid not in (select min(rowid) from people group by peopleId having count(peopleId )&gt;1) 3、查找表中多余的重复记录（多个字段） select * from vitae a where (a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d493c9f902d97183e2a7046536cd14de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1904db5becd719f1296dcb1ab13f75b7/" rel="bookmark">
			linux操作提示：“Can&#39;t open file for writing”或“operation not permitted”的解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux上使用vi命令修改一个文件内容的时候，发现无法保存，每次写完使用“:q!”命令可以正常退出但是使用"：wq!"命令保存文件并退出时出现一下信息提示：
E212: Can't open file for writing Press ENTER or type command to continue
出现这个错误的原因可能有两个：
1.当前用户的权限不足
2.此文件可能正被其他程序或用户使用。
一般错误原因都是前者，解决方案是在使用vi命令打开文件时，前面加上sudo来临时提供管理员权限，比如使用命令“sudo vi hosts”打开编辑文件。
由此看来，sudo命令是很有用的，当我们执行某种操作系统提示诸如“operation not permitted”等权限不足信息时，我们很多时候都可以在命令前面加上sudo来解决权限不足问题。比如当我们从linux服务器上下载某一个文件或上传某一个文件有可能提示这个，也有肯能直接上传不成功但是什么都没提示；这时你就应该想想是不是账号的权限不足，加个sudo试试。
转载于:https://www.cnblogs.com/yangkai-cn/p/4016563.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb0ba7b2154891e33cf8bf8c02ca1d48/" rel="bookmark">
			android中bitmap压缩的几种方法的解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、质量压缩法
2、采样率压缩法
3、缩放法
4、RGB_565法
最近在研究微信的sdk，在缩略图这遇到了一点问题。
微信的缩略图要求是不大于32k，这就需要对我的图片进行压缩。试了几种方法，一一道来。
1、质量压缩法 代码如下
ByteArrayOutputStream baos = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, baos); int options = 100; while ( baos.toByteArray().length / 1024&gt;32) { baos.reset(); image.compress(Bitmap.CompressFormat.JPEG, options, baos); options -= 10; } ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray()); Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null); 最开始使用这个来进行压缩，但是始终压缩不到32k这么小。后来看高手的解释才明白，这种压缩方法之所以称之为质量压缩，是因为它不会减少图片的像素。它是在保持像素的前提下改变图片的位深及透明度等，来达到压缩图片的目的。进过它压缩的图片文件大小会有改变，但是导入成bitmap后占得内存是不变的。因为要保持像素不变，所以它就无法无限压缩，到达一个值之后就不会继续变小了。显然这个方法并不适用与缩略图，其实也不适用于想通过压缩图片减少内存的适用，仅仅适用于想在保证图片质量的同时减少文件大小的情况而已。
2、采样率压缩法 代码如下
ByteArrayOutputStream out = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, out); BitmapFactory.Options newOpts = new BitmapFactory.Options(); int be = 2; newOpts.inSampleSize = be; ByteArrayInputStream isBm = new ByteArrayInputStream(out.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb0ba7b2154891e33cf8bf8c02ca1d48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0082504ff8b8a1fa1021ef0bfba10357/" rel="bookmark">
			国外医疗行业大数据应用解决之道
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 医疗保健不乏大数据分析应用案例，其中包括减少再住院、更好的药物治疗管理、提高战略规划和防欺诈行为。
这些意愿都很好，但关键在于从何开始？大多数医疗数据仍然非结构化的专有的和孤立的——为此创建一个临床
数据仓库是一件非常复杂的事情，这让医疗行业CIO常常不能自圆其说。
幸运的是，可以从医疗行业大数据实践中来吸取教训。下面是是那些一直在该行业从事大数据应用的供应商所讲述的工作和生活的故事。
据Mayo诊所James Buntrock回忆，医疗机构只是简单添加应用程序和数据库、端对端接口时，其结果是，最终断开与数据仓库连接的多如牛毛。Buntrock表示，与其关注关注App，不如采用以数据为中心方法，把数据作为研究、临床等需求的重要资产。将业务目标与IT紧密结合，像传统商业智能应用那样，对信息数据进行挖掘。
Group Health公司Gwn O'Keefe医生表示，医疗机构也需要高效的分析模型，也需要提供前端业务管理仪表盘或者面板，以提供更好的可视化衡量标准。一旦具备了这样的条件，医疗机构可以添加外部数据(从供应商以及患者)用于内部的临床、实施预测分析和使用后续的数据分析，推动临床和业务变化。
没有什么是免费的 - 但如果应对得当，也可以保证终身使用。当然医疗行业CIO必须卖IT给高管。但涉及到分析，O'Keefe建议首先找到需要解决问题的商业领袖(更多似是未来)。采取了一种快速灵活的方法来解决问题，建立一个向前兼容的解决方案，如此会有许多人会来。
业务线的领导者须要IT人员合作，高官定义数据治理和质量标准，O'Keefe补充说。这种合作有助于避免“分析瘫痪”，从一开始就确定，决策需要大概数字与具体数字。
最高领导不意味着一切，对话不能局限于组织结构图高层，成功分析需要“沟通”，有关案例、以及重要培训等，O'Keefe说。
当你做到这一点，Buntrock说，你就可以挖掘更多专业知识。如此就将可提高有关分析主题和项目的“成熟度”，他补充说。这助于数据发现，有助于从这些发现中受益。
美国匹兹堡大学医学中心(UPMC)Lisa Khorey警告说：如果你机构不是立刻采取行动，就不要对其进行测量和分析。
Khorey提供了几个建议：许多人有监管，所以少有颠覆式创新，更多只是生存。所采取的举措包括医师效率分析和金融建模，这些根据联邦法规质量报告。
也就是说，数据分析可以帮助医疗机构做一个有关基因组研究的案例 - 或者，UPMC将他作为个性化医疗项目，将来自临床、基因组以及不同来源(和供应商)的数据进行汇总，研治疗乳腺癌。
这种强大素话剧分析有助于研究人员研究法裔加拿大人雷综合症，如果未经治疗，这仍然是一种很致命疾病，但是其症状与其他疾病很相似，非常难于诊断。Broad研究机构的Michael Reich表示，通过查看一个基因表达数据集和已知线粒体蛋白数据库(在一些公共库中就可以获取)，就可帮助研究人员发现基因变化，当重新排序时，就可以显示了LRPPRC基因突变导致疾病的产生。目前的最新进展——只要花费4000美元，就可以在36小时内完成基因测序，在基因组数据应用中取得“突破”性进展，Reich说，很快这些应用就会成为一种常态。
你能达到你的目的地，但仍属于较小规模，Khorey提供医疗机构10种分析加速的方法，有些在前面已经提到了，
以下是其他一些方法：
*购买数据模型。不要自己建模型，其过于复杂和昂贵。
*利用现有的技术，包括数据仓库。你需要针未来而不是现在来购买、。
*要着迷。需要构建，提供报告和结果，让怀疑转成确信，让大家对分析能够做什么感兴趣。
*准备组织变革。分析和洞察力意味着管理变革——这将威胁到传统权力格局和影响力阶层。
*影响用药。要比“糖尿病人吃什么药。”更加深入，诸如应该怎么吃？多长时间吃？药效如何等？
数据分析指南在四年前就已经开始提供帮助，波士顿医疗中心(Boston Medical Center )在高校健康系统联盟(University HealthSystem Consortium，UHC)死亡率排名中，以10%垫底。其安全医院网络排名25%，名列前茅。数据分析在此发挥了很大作用。波士顿医疗中心审阅病人安全以及死亡报告，用于降低死亡率，并调整管控风险，该医院分析和公开报告主管Roshan Hussain说。也很关键：独立观察(临床)和判断(分析)死亡率，重新定因果关系，强调制度改进，而不是个人惩罚。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04efd5aaeeddeadbfbe35ece59e0501f/" rel="bookmark">
			L1范数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通常情况下，欠定线性方程是没有唯一解的，如果加上其他的条件则可以缩小解得范围，比如加上二范数最小化这个条件，则方程可以得到最小范数解，该解唯一，我们知道二范数是能量的度量单位，它是用来度量重构误差的，如果我们不用二范数改用另外的附加条件，比如稀疏性，要求方程的解具有最小数目的非零项，也就是零范数，那么方程到底有没有唯一解，怎么证明求得的是全局解而不是局部解，此外假设有全局的唯一解，那么求解过程呢，是一个NP问题，既然零范数具有现实意义，那么可不可以找它的近似解呢，这就引出了l1范数最小化问题，用1范数来代替0范数的话，他们最终求的解是不是一致，是不是1范数求的解一定是0范数解的近似值，这两个解得误差有多大，是不是可以被接受，当然这些问题不属于我们这些搞图像处理的小鱼小虾来研究，我们只需要接受结果就行，剩下的证明推导是那些搞应用数学的大牛的事情。
再看一下信号处理领域的Sparse，我们应该熟悉JPEG跟JPEG2000的区别吧，JPEG的核心算法是DCT，而后者是DWT，本质上，这两种处理方法都是将信号从一个域变换到另外一个域（把坐标系进行旋转，将信号投影到不同的基上），从而获得信号的稀疏表示，即用最少的系数来表示信号，不过DWT比DCT更加稀疏而已。信号不同，对应最稀疏表达的基也会不同，比如，对于一维信号可能小波基是最稀疏的，而对于图像而言，可能那些Curvelet和contourlet是最优的，对于有些信号，也有可能需要将几种基结合起来才是最优的。当然，我们可以通过求解零范数问题来得到信号的最稀疏表达。
人们习惯于用正交基来表示信号，直到最近几十年，人们才发现用冗余的基元素集合来表示信号能够取得更好的结果，当然我们追求的肯定是用最小数量的基元素来最优的表示信号，这就出现了信号的稀疏表示。
L1范数最小化最早并不是Donoho提出的，早在80年代，Fadil Santosa 和William Symes就曾提出了L1范数的最小化，而Donoho提出Compressed sensing 并不是换汤不换药，CS并不是解决信号在一个完备集里面的最优表示问题的，而是提出了一种新的信号采集或者测量方式，这种新的测量方式打破了Shannon-Nyquist定理在信号处理领域一手遮天的局面，已经提出，就引起了相关领域大批学者的关注。Shannon-Nyquist采样定理要求在信号的采集阶段以高于信号带宽的两倍采样率来获取信号，信号才能得到完美的重构，而CS则对信号的带宽不再作要求，取而代之的是稀疏性，满足条件的信号则可在远少于SN采样率的情况下精确的重构信号。
从数学上来说，CS是在一定的条件下求解欠定方程，条件包括x要是稀疏的，测量矩阵要满足RIP条件，那么欠定方程就会以很大的概率有唯一解
当然求解信号的稀疏表达问题，被分成两种类型：L1范数最小化，和启发式的贪婪算法。L1范数最小化是通过用L1范数来近似0范数，取1而不取1/2,2/3或者其他值，是因为1范数最小化是凸优化问题，可以将求解过程转化成有一个线性规划问题。
转自：http://hi.baidu.com/jrjian/item/38ad9c8139aeccdad1f8cd04
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0c8f293e87c14e4c3b7ab0cd87de5aa/" rel="bookmark">
			Compressive Sensing资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自prfans：
Sparse, L1-minimization, Compressive Sensing 集中讨论帖 （第一页常更新）
Sparse大家并不陌生，是个经典话题了。而此时sparse已经卷土重来，虽然还是那一锅汤，但是药已经换了。以L1-minimization为核心的算法，近几年飞速进展，Compressive Sensing (Compressive Sampling) 已然成为数学领域和信号处理最前沿最热门的方向。最近一年多这种新形式的算法快速蔓延到模式识别界应用，论文质量高、算法效果好、而且算法一般都非常简单。而这仅仅是个开始，所以我一直有这个想法专开一贴，供大家一起讨论、共同进步，今天付诸与行动，希望大家支持。在这个地方（第一个帖），我会陆续更新提供一些这方面的材料，供大家了解。如果大家提供了有趣的材料，我也尽量加进来。当然，此贴重点还是放在理论应用和模式识别上。大家踊跃发言啊！
Compressive Sensing资源主页：
Compressive Sensing Resources （最权威最全面的Compressive Sensing资源主页，几乎什么都能找的到）；
Compressive Sensing （和上面的差不多）；
Compressive Sensing Listing； 马毅的课程主页
Compressive Sensing Videos；Compressed Sensing Codes （还有Compressive Sensing Resources 的Software一栏中）；
Nuit Blanche；Compressive Sensing: The Big Picture；Terence Tao's What's new;
理论方面的代表人物：
David Donoho; Emmanuel Candes;
Tutorials
Emmanuel Candès, Compressive sampling. (Int. Congress of Mathematics, 3, pp. 1433-1452, Madrid, Spain, 2006)
Richard Baraniuk, Compressive sensing. (IEEE Signal Processing Magazine, 24(4), pp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0c8f293e87c14e4c3b7ab0cd87de5aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/617454543add8f73ecedda2441401698/" rel="bookmark">
			如何根据Sip协议的SDP和onvif摄像头进行视频媒体能力的协商 （1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近一段时间在从事onvif/rtsp转sip协议的研发工作，那到底为什么要在这两种协议之间进行相互转换呢？因为我公司的软交换系统目前仅仅支持sip协议，而大部分的网络摄像头仅仅支持onvif/rtsp协议，所以公司的软交换系统不支持onvif摄像头的接入，为了扩展公司的软交换系统支持更多的视频接入协议，所以公司决定通过增加视频网关的方式来完成onvif/rtsp协议和sip协议的转换，使公司的软交换系统支持更多的视频接入协议。在协议转换过程中，有一个十分关键的技术问题，那就是要解决如果根据sip协议的invite消息中的携带的媒体处理能力SDP对onvif摄像头进行合理的参数设置，即修改onvif摄像头某个profile的视频参数，即完成媒体的协商。在下一篇中我将重要介绍我自己如何实现媒体协商的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9968d794a2ca9123f482c05cb2378e05/" rel="bookmark">
			编译deb包过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译deb包过程
sudo apt-get build-dep language-pack-gnome-zh-hans-base //安装language-pack-gnome-zh-hans-base 的依赖 language-pack-gnome-zh-hans-base需要建立的包
dpkg-buildpackage //建立包
Cd ..
Dpkg -i language-pack-gnome-zh-hans-base_13.04+20130418_all.deb //安装包
利用dpkg的这种方式与makefile的是不同的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01cecc5380d9acc7c1bd2e0a10082497/" rel="bookmark">
			为什么DataGridView不出现滚动条？它的ScrollBars属性我设置为Both了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我水平滚动条也不见了。原因是太多字段Frozen设置为true了。这些不算滚动条范围的。所以水平滚动条不出现了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/684c6559916b09814c9f4c928b982354/" rel="bookmark">
			opencv的assert函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ASSERT()是一个调试程序时经常使用的宏，在程序运行时它计算括号内的表达式，如果表达式为FALSE (0), 程序将报告错误，并终止执行。如果表达式不为0，则继续执行后面的语句。这个宏通常原来判断程序中是否出现了明显非法的数据，如果出现了终止程序以免导致严重后果，同时也便于查找错误。例如，变量n在程序中不应该为0，如果为0可能导致错误，你可以这样写程序： ...... ASSERT( n != 0); k = 10/ n; ...... ASSERT只有在Debug版本中才有效，如果编译为Release版本则被忽略。 assert()的功能类似，它是ANSI C标准中规定的函数，它与ASSERT的一个重要区别是可以用在Release版本中。 assert宏的原型定义在&lt;assert.h&gt;中，其作用是如果它的条件返回错误，则终止程序执行，原型定义： #include &lt;assert.h&gt; void assert( int expression ); assert的作用是现计算表达式 expression ，如果其值为假（即为0），那么它先向stderr打印一条出错信息， 然后通过调用 abort 来终止程序运行。 请看下面的程序清单badptr.c： #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #include &lt;stdlib.h&gt; int main( void ) { FILE *fp; fp = fopen( "test.txt", "w" );//以可写的方式打开一个文件，如果不存在就创建一个同名文件 assert( fp ); //所以这里不会出错 fclose( fp ); fp = fopen( "noexitfile.txt", "r" );//以只读的方式打开一个文件，如果不存在就打开文件失败 assert( fp ); //所以这里出错 fclose( fp ); //程序永远都执行不到这里来 return 0; } [root@localhost error_process]# gcc badptr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/684c6559916b09814c9f4c928b982354/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd814257c2b5d75d2a2fa24dd478ac9b/" rel="bookmark">
			计算机经典书籍(纯屌丝)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机经典书籍 1、Java Java编程语言（第三版)---Java四大名著----James Gosling(Java之父) Java编程思想（第2版)----Java四大名著----Bruce Eckel Java编程思想（第3版)----Java四大名著----------------Bruce Eckel JAVA 2核心技术 卷I：基础知识（原书第7版）---Java四大名著-----Cay Horstmann JAVA 2核心技术 卷II：高级特性（原书第7版)----Java四大名著-----Cay Horstmann Effective Java中文版------Java四大名著--------Joshua Bloch 精通Struts:基于MVC的Java Web设计与开发---孙卫琴 精通Hibernate：Java对象持久化技术详解---孙卫琴 Tomcat与Java Web开发技术详解------------孙卫琴 Java与模式------------------------------阎宏 2、c# C#程序设计-------Charles Petzold“windows编程泰山北斗”---C#语言“倚天屠龙双剑” C# Primer中文版--------Stanley B.Lippman---C#语言“倚天屠龙双剑” .NET框架程序设计（修订版)--------Jeffrey Richter“windows编程泰山北斗”---.NET平台四大天王 c#Windows程序设计----------Charles Petzold“windows编程泰山北斗”------.NET平台四大天王 .NET程序设计技术内幕-------------Jeff Prosise---.NET平台四大天王 .NET本质论--第1卷：公共语言运行库(中文版)--------Chris Sells---.NET平台四大天王 3、C++ C++程序设计语言（特别版)---c++八大金刚----Bjarne Stroustrup“C++之父” C++ Primer (第3版)中文版----c++八大金刚---Stanley B.Lippman C++ Primer (第4版)中文版----c++八大金刚---Stanley B.Lippman C++标准程序库—自修教程与参考手册--c++八大金刚--Nicolai M.Josuttis C++语言的设计和演化-----c++八大金刚----Bjarne Stroustrup“C++之父” 深度探索C++对象模型---c++八大金刚----Stanley B.Lippman Essential C++中文版---c++八大金刚---Stanley B.Lippman Effective C++中文版 2nd Edition-----c++八大金刚------Scott Meyers More Effective C++中文版----c++八大金刚------Scott Meyers C++编程思想（第2版） 第1卷：标准C++导引--------Bruce Eckel C++编程思想（第2版）第2卷：实用编程技术 --------Bruce Eckel C++程序设计--------------------------谭浩强 C++ 程序设计教程(第2版)--------------钱能 C++ Primer Plus(第五版)中文版---Stephen Prata 广博如四库全书The c++ programming language、c++ Primer 深奥如山重水复Inside the c++ object model 程序库大全The c++ standard libray 工程经验之积累Effective c++、More Effective c++、Exceptional c++ c++八大金刚： 1、Essentital c++---lippman---C++之父，旁枝暂略，主攻核心，轻薄短小，初学者 2、The c++ programming language----C++之父，技术权威，用词深峻，思想深远，c++百科全书代表，圣经。 3、c++ Primer----lippman---纵横书市十数年，c++最佳教本，c++百科全书代表。 4、Inside the c++ object model-----lippman----揭示c++底层，非常好，非常难。 5、Effective c++-----通过50个编程实例，展示专家经验，行文有趣，深处浅出。 6、More Effective c++－－－－通过35个编程实例，展示专家经验，行文有趣，深处浅出。 7、The c++ standard libray－－－c++标准库的百科全书。 8、设计模式：可复用面向对象软件的基础－－－－－－good!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd814257c2b5d75d2a2fa24dd478ac9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5475f914f94f99519d613fac4f46680/" rel="bookmark">
			Android横竖屏切换小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android横竖屏切换小结 （老样子，图片啥的详细文档，可以下载后观看 http://files.cnblogs.com/franksunny/635350788930000000.pdf）
Android手机或平板都会存在横竖屏切换的功能，通常是由物理重力感应触发的，但是有时候也不尽然，通常在设置里面我们可以对手机的横竖屏切换进行关闭，操作界面如下
只需要点击下“屏幕旋转”按钮就可以关闭横竖屏切换了。
一、禁止APP内横竖屏切换 上述设置更改的是整个手机的横竖屏切换，当手机没有关闭横竖屏切换功能时，系统一旦触发横竖屏切换，缺省状态下，当前活动的App的界面就会进行横竖屏切换，由于横竖屏的界面尺寸等参数不同，很多软件在设计和开发中为了避免横竖屏切换时引发不必要的麻烦，通常需要让App禁止掉横竖屏的切换，这就需要通过在AndroidManifest.xml中设置activity中的android:screenOrientation属性值来实现。
该android:screenOrientation属性，他有以下几个参数：
"unspecified":默认值 由系统来判断显示方向.判定的策略是和设备相关的，所以不同的设备会有不同的显示方向.
"landscape":横屏显示（宽比高要长）
"portrait":竖屏显示(高比宽要长)
"user":用户当前首选的方向
"behind":和该Activity下面的那个Activity的方向一致(在Activity堆栈中的)
"sensor":有物理的感应器来决定。如果用户旋转设备这屏幕会横竖屏切换。
"nosensor":忽略物理感应器，这样就不会随着用户旋转设备而更改了（"unspecified"设置除外）。
比如下列设置
android:screenOrientation="portrait"
则无论手机如何变动，拥有这个属性的activity都将是竖屏显示。
android:screenOrientation="landscape"，为横屏显示。
上述修改也可以在Java代码中通过类似如下代码来设置
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)
二、APP的横竖屏切换可以手动触发吗 由上面描述可知，当android:screenOrientation为默认值"unspecified"或"sensor"等时，就会有系统根据设备的旋转情况来触发横竖屏的切换，那么有没有方法我们手动在程序中触发横竖屏的变换呢，显然上面为我们提供的setRequestedOrientation就是系统提供的一个入口，下面我们给出一个按键的方式来触发的案列：
public class MainActivity extends Activity implements OnClickListener {
private Button mBtnLandscape;
private Button mBtnPortrait;
@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
mBtnLandscape = (Button) findViewById(R.id.but_landscape);
mBtnPortrait = (Button) findViewById(R.id.but_portrait);
mBtnLandscape.setOnClickListener(this);
mBtnPortrait.setOnClickListener(this);
}
@Override
public void onClick(View v) {
// TODO Auto-generated method stub
if(v == mBtnLandscape){
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5475f914f94f99519d613fac4f46680/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133661ed2b25167dbcc215b67a4d1f4d/" rel="bookmark">
			rand()和RAND_MAX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 RAND_MAX是C中stdlib.h中宏定义的一个字符常量： #define RAND_MAX Ox7FFF 其值最小为32767,最大为2147483647 通常在产生随机小数时可以使用RAND_MAX。 一、C++中不能使用random()函数 random函数不是ANSI C标准，不能在gcc,vc等编译器下编译通过。但在C语言中int random(num)可以这样使用，它返回的是0至num-1的一个随机数。 可改用C++下的rand函数来实现。 1、C++标准函数库提供一随机数生成器rand，返回0－RAND_MAX之间均匀分布的伪随机整数。 RAND_MAX必须至少为32767。rand()函数不接受参数，默认以1为种子（即起始值）。 随机数生成器总是以相同的种子开始，所以形成的伪随机数列也相同，失去了随机意义。（但这样便于程序调试） 2、C++中另一函数srand（），可以指定不同的数（无符号整数变元）为种子。但是如果种子相同，伪随机数列也相同。一个办法是让用户输入种子，但是仍然不理想。 3、 比较理想的是用变化的数，比如时间来作为随机数生成器的种子。 time的值每时每刻都不同。所以种子不同，所以，产生的随机数也不同。 二、rand()的用法 rand()不需要参数，它会返回一个从0到最大随机数的任意整数，最大随机数的大小通常是固定的一个大整数。 #define RAND_MAX 0x7fffu 这个是bcc55中的定义，说明这个整数的最大数是0x7fffu，u代表unicode编码。 这样，如果你要产生0~10的10个整数，可以表达为： int N = rand() % 11; 这样，N的值就是一个0~10的随机数，如果要产生1~10，则是这样： int N = 1 + rand() % 10; 总结来说，可以表示为： a + rand() % n 其中的a是起始值，n是整数的范围。 a + rand() % (b-a+1) 就表示　ａ～ｂ之间的一个随机数 若要0~1的小数，则可以先取得0~10的整数，然后均除以10即可得到随机到十分位的10个随机小数，若要得到随机到百分位的随机小数，则需要先得到0~100的10个整数，然后均除以100，其它情况依 此类推。 通常rand()产生的随机数在每次运行的时候都是与上一次相同的，这是有意这样设计的，是为了便于程序的调试。若要产生每次不同的随机数，可以使用srand( seed )函数进行随机化，随着seed的不同，就能够产生不同的随机数。 如大家所说，还可以包含time.h头文件，然后使用srand(time(0))来使用当前时间使随机数发生器随机化，这样就可以保证每两次运行时可以得到不同的随机数序列(只要两次运行的间隔超过1秒)。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/498/">«</a>
	<span class="pagination__item pagination__item--current">499/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/500/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>