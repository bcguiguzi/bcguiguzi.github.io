<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21fe6ed17aa19ae6e8c5c49f9e0d4732/" rel="bookmark">
			AxGlyph学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.页面布局 2.画布操作 滚轮：放缩画布
鼠标右键：移动画布
3.选择 点选、滑选
Ctrl+点击未选图形，最后一个为主选图形
Shift+点击未选图形，第一个为主选图形
Shift+点击已选图形，取消选中
主选图形：旋转等操作时以该图像为中心点
4.图形大小 Shift+拖动，保持横纵比，对于直线，不改变方向
shift+滚轮 或 shift+方向键，改变图形大小
在加ctrl键一般就是微调，也可以在参数设置里调
5.旋转 Alt+滚轮 或 Alt+方向键：旋转
空格 或 Alt+空格：旋转
在加ctrl键一般就是微调，也可以在参数设置里调
6.图层 Home：移动至顶层
组合
7.镜像、创建阵列 8.支持剪贴板 Ctrl+拖动对象，复制
Ctrl+B，Ctrl+G 抓取位图，抓取矢量图
9.可自定义快捷键 10.笔记、收藏、分类图形库 11.图层显示与锁定 注意：当前图层不受锁定与隐藏的限制
12.外观 有格式刷
13.磁力点 可以自定义磁力点阵
Ctrl+点击，临时磁力点
可以在工具栏设置交点磁力点等
注意：Ctrl+拖动，不受磁力点吸附
14.文本和标注 一般搞一堆出来，然后拖，不要的删掉
15.自由路径 钢笔，绘制自由路径，可以调光滑程度和闭合
按住Ctrl，可以连续绘制
16.混合路径 根据路径点，绘制特殊图形
17.漫水工具 填充与提取
18.剪接路径工具 19.仿真变换 20.函数绘图 参考链接：
01. 简介_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68bd4b4452ba626d337439d64d5a0c37/" rel="bookmark">
			常见的网络命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. ipconfig:网络诊断命令
主要作用查看IP，以及DNS的一些配置
1. ipconfig/all 显示全部参数（显示IP地址，子网掩码，默认网关等详细信息）
2. ipconfig/renew 更新DHCP配置，重新获取IP（重新获取DHCP）
3. ipcongfig/release 释放DHCP获得的IP地址
4. ipconfig/flushdns 清除DNS缓存信息
5. ipconfig/displaydns 显示DNS缓存信息
下面是一些图片可以参考：
此时用了一个命令是ipconfig ,查看了一下它的IP地址：192.168.1.6
下面又用到一个命令是：ipconfig/release ,释放了IP地址，图片如下：
下面用到了ipconfig/displaydns命令，主要是想显示DNS缓存信息，图片如下：
最后我们就可以利用ipconfig/flushdns 命令来删除DNS缓存信息，图片如下：
二. ping命令：检查网络连通性
主要作用：1.用来检测网络的连通情况和分析网络速度
2.根据域名得到服务器IP
3.根据ping返回的TTL值来判断对方所使用的操作系统以及数据包经过路由器的数量
1.ping+ ip地址:（ping 后面直接带一个IP地址）是默认情况下使用的。默认情况下发送4个数据包，每个数据包占用32个字节
例子：ping 192.168.1.1
1.ping -t :不停的ping直到按ctrl+c 才终止。
2. ping -a :它的作用是将域名解析为IP地址
ping baidu.com 和 ping -a baidu.com ping www.baidu.com
这种情况下,系统会自动帮我们解析域名对应的IP地址,然后再ping。
如果要显示解析出的IP地址,可以使用-a参数: ping -a www.baidu.com
这样ping命令会先显示解析出的IP地址:
Ping www.baidu.com [110.242.68.66] with 32 bytes of data:
我们可以清晰看到域名被解析的IP地址是110.242.68.66
可参考下面这张图：
如果只输入一个IP地址,使用-a参数将不会有效果: ping -a 110.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68bd4b4452ba626d337439d64d5a0c37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8b26d86e8052515aee9800d2d6b891e/" rel="bookmark">
			大数据：AI大模型对数据分析领域的颠覆（文末送书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着数字化时代的到来，大数据已经成为了各行各业中不可或缺的资源。然而，有效地分析和利用大数据仍然是一个挑战。在这个背景下，OpenAI推出的Code Interpreter正在对数据分析领域进行颠覆性的影响。
如何颠覆数据分析领域？带着这个问题，我们一起来探讨一下。
什么是数据分析？
数据分析是一种通过收集、清洗、转化和解释数据，以获得有意义的信息、洞察和知识的过程。它涉及对大量数据进行逻辑和统计分析，以发现模式、趋势、关联和异常，从而为决策制定、问题解决和业务优化提供支持。数据分析不仅仅是将数据呈现为图表和图形，还包括对数据背后的意义和价值进行深入理解和解释。
数据分析的过程通常包括以下几个关键步骤：
数据收集： 收集各种来源的数据，可以是结构化数据（例如数据库中的表格数据）或非结构化数据（例如文本、图像和音频）。
数据清洗： 对数据进行清理和预处理，去除重复、缺失和错误数据，确保数据的准确性和一致性。
数据转化： 对数据进行转换和整合，以便于后续分析。这可能包括数据的重塑、合并和聚合。
探索性数据分析（EDA）： 进行数据的初步分析，探索数据的分布、关联和特征。这有助于发现数据中的模式和趋势。
统计分析： 应用统计方法来验证假设、进行推断和确认数据之间的关系。这可以包括描述统计、假设检验、回归分析等。
数据可视化： 利用图表、图形和可视化工具将数据呈现出来，以便更好地理解数据的含义和趋势。
模型建立： 基于数据的分析结果，建立数学或统计模型，用于预测未来趋势、进行分类或聚类等。
洞察和解释： 解释分析结果，提取洞察和知识，为业务决策提供支持。
决策支持： 基于数据分析的结果，为组织的决策制定提供建议和指导。
数据分析在各个领域都有广泛的应用，包括商业、科学、医疗、金融、市场营销等。它可以揭示隐藏在数据中的信息，帮助组织更好地了解市场趋势、客户需求、业务绩效等，从而作出更明智的决策。
传统数据分析的痛点
传统的数据分析往往需要专业的数据科学家或分析师编写和执行复杂的查询和算法，以从大数据中提取有价值的信息。这需要深入的技术知识和编程技能，限制了普通业务人员参与到数据分析中来。此外，数据分析过程通常较为繁琐，需要耗费大量的时间和精力，结果可能并不总是令人满意。
其中，数据可视化是我们从日常浏览的海量数据中提取洞察的关键，让我们能够将规模庞大的原始数据转换为既具有视觉吸引力、又易于理解的图形。然而，实现可视化的具体过程往往令人生畏，其中涉及到复杂的数据处理、设计和调试环节。
对数据分析的颠覆之举
有了 ChatGPT Code Interpreter 后，我们唯一要做的就是提出问题。只需用简单的语言指导 AI，它就能做好余下的工作，基于现实数据创建出详尽而准确的可视化结果。
目前，已经有不少网友分享了自己如何让用这款 AI 工具如何生成富有洞见的可视化结果。比如，曾有一位宾夕法尼亚大学沃顿商学院教授 Ethan Mollick 分享了自己使用 ChatGPT Code Interpreter 的经验。他上传了一个 XLS 文件，并向 AI 提出三个问题：
“你能通过可视化和描述性分析，帮助我理解数据内容吗？”
“你能试着用回归分析找到其中的模式吗？”
“你能运行回归诊断吗？”
Code Interpreter 完成了数据处理，并根据 Ethan 的要求给出准确的可视化与分析结果，展现出轻松处理复杂数据解释任务的强大能力。
另外一个用户，根据数据内容生成了完备的 HTML 热图，表现出利用不同数据集快速创建数据可视化结果的潜力。
这些真实示例说明，ChatGPT Code Interpreter 在简化数据可视化过程方面有着强大能力。通过对话中提出的问题，用户无需编写任何代码即可获取有价值的见解和关于数据的图形表示。Ethan 对 Code Interpreter 的评价是“用过的最有用、最有趣的 AI 模式”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8b26d86e8052515aee9800d2d6b891e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a1093706f2f82363ddb76f5a76b945f/" rel="bookmark">
			基于javaweb&#43;mysql的jsp&#43;servlet校园招聘平台系统(java&#43;mysql&#43;jdbc&#43;servlet&#43;springmvc&#43;html)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的jsp+servlet校园招聘平台系统(java+mysql+jdbc+servlet+springmvc+html)
运行环境
Java≥8、MySQL≥5.7、Tomcat≥8
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于javaweb+mysql的JSP+Servlet校园招聘平台系统(java+mysql+jdbc+servlet+springmvc+html)
一、项目简述 功能： 用户和企业用户的注册登录，简历的筛选查看搜索，应聘信息互动等等。
二、项目运行 环境配置：
Jdk1.8 + Tomcat8.5 + mysql + Eclispe（IntelliJ IDEA,Eclispe,MyEclispe,Sts都支持）
项目技术：
Jdbc+ Servlert + SpringMvc + Jsp + css + JavaScript + JQuery + Ajax + Fileupload等等
/** * @Description * @Date */ public class DownloadResumeFileController extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { String fileName = req.getParameter("fileName"); String path = req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a1093706f2f82363ddb76f5a76b945f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0483921571f3b480ccced55c67bdab21/" rel="bookmark">
			VS code 可视化调试Linux kernel内核
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、背景介绍 在Qemu模拟ARM64使用GDB调试linux kernel一文中，向大家介绍了使用Qemu模拟ARM64芯片，通过GDB来调试linux kernel，但是使用的是GDB命令模式，调试过程复杂，操作也不方便。本文向大家介绍通过VS code 来调试linux kernel内核，结合源代码实现可视化的单步调试。
2、参数配置 VS code 中调试C/C++，需要安装 C/C++ 插件支持；
在VS code 中打开linux kernel源代码工作区，在工作区添加调试的配置信息：运行-&gt;添加配置
在配置文件 launch.json 中添加配置：
"configurations": [ { "name": "gdb调试", "type": "cppdbg", "targetArchitecture": "arm64", "request": "launch", "program": "${workspaceFolder}/vmlinux", "args": [], "stopAtEntry": true, "cwd": "${workspaceFolder}", "environment": [], "externalConsole": false, "MIMode": "gdb", "miDebuggerPath": "/usr/bin/gdb-multiarch", "miDebuggerServerAddress": "localhost:1234", "setupCommands": [ { //"text": "set arch aarch64", "text": "set architecture aarch64", "ignoreFailures": false }, { "description": "为 gdb 启用整齐打印", "text": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0483921571f3b480ccced55c67bdab21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aba9c2ca64d107bca64b44b58cfcb93/" rel="bookmark">
			【IMX6ULL驱动开发学习】12.Linux SPI驱动实战：DAC驱动设计流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础回顾： 【IMX6ULL驱动开发学习】10.Linux I2C驱动实战：AT24C02驱动设计流程_阿龙还在写代码的博客-CSDN博客
【IMX6ULL驱动开发学习】11.Linux之SPI驱动_阿龙还在写代码的博客-CSDN博客
一、编写驱动 查看芯片手册，有两种DAC数据格式，12位和16位，这里选用16位数据（2字节）编写驱动。
重点在驱动程序中写函数spi_drv_write的编写：spi_transfer结构体的构造，其中tx_buf存放发送数据，len表示发送长度（字节数），发起SPI同步传输
/** * spi_sync_transfer - 同步的SPI传输函数 * @spi: 读写哪个设备 * @xfers: spi_transfers数组，用来描述传输 * @num_xfers: 数组项个数 * 上下文: 能休眠的上下文才可以使用这个函数 * * 返回值: 0-成功, 负数-失败码 */ static inline int spi_sync_transfer(struct spi_device *spi, struct spi_transfer *xfers, unsigned int num_xfers); static ssize_t spi_drv_write(struct file *file, const char __user *buf, size_t size, loff_t *offset) { int err; short val;//2个字节 unsigned char ker_buf[2]; struct spi_transfer t; memset(&amp;t, 0, sizeof(t)); if (size !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aba9c2ca64d107bca64b44b58cfcb93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e99e0fc29797c817ceaac989482825b/" rel="bookmark">
			【IMX6ULL驱动开发学习】11.Linux之SPI驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：驱动程序开发：SPI设备驱动_spi驱动_邓家文007的博客-CSDN博客
目录
一、SPI驱动简介
1.1 SPI架构概述
1.2 SPI适配器（控制器）数据结构
1.2 SPI设备数据结构
1.3 SIP设备驱动
1.4 接口函数
二、SPI驱动模板
一、SPI驱动简介 SPI驱动框架和I2C驱动框架是十分相似的，不同的是因为SPI是通过片选引脚来选择从机设备的，因此SPI不再需要像I2C那样先进行寻址操作（查询从机地址）后再进行对应寄存器的数据交互，并且SPI是全双工通信，通信速率要远高于I2C。
但是SPI显然占用的硬件资源也比I2C要多，并且SPI没有了像I2C那样指定的流控制（例如开始、停止信号）和没有了像I2C应当机制（导致无法确认数据是否接收到了）。
1.1 SPI架构概述 Linux的SPI体系结构可以分为3个组成部分：
spi核心（SPI Core）：SPI Core是Linux内核用来维护和管理spi的核心部分，SPI Core提供操作接口函数，允许一个spi master，spi driver和spi device初始化时在SPI Core中进行注册，以及退出时进行注销。spi控制器驱动或适配器驱动（SPI Master Driver）：SPI Master针对不同类型的spi控制器硬件，实现spi总线的硬件访问操作。SPI Master 通过接口函数向SPI Core注册一个控制器。spi设备驱动（SPI Device Driver）：SPI Driver是对应于spi设备端的驱动程序，通过接口函数向SPI Core进行注册，SPI Driver的作用是将spi设备挂接到spi总线上。 Linux的软件架构图如下图所示： 1.2 SPI适配器（控制器）数据结构 参考内核文件：include/linux/spi/spi.h
Linux中使用spi_master结构体描述SPI控制器，里面最重要的成员就是transfer函数指针：
transfer 函数，和 i2c_algorithm 中的 master_xfer 函数一样，控制器数据传输函数。
transfer_one_message 函数，也用于 SPI 数据发送，用于发送一个 spi_message，SPI 的数据会打包成 spi_message，然后以队列方式发送出去。
1.2 SPI设备数据结构 参考内核文件：include/linux/spi/spi.h
Linux中使用spi_device结构体描述SPI设备，里面记录有设备的片选引脚、频率、挂在哪个SPI控制器下面：
1.3 SIP设备驱动 参考内核文件：include/linux/spi/spi.h
Linux中使用spi_driver结构体描述SPI设备驱动：
可以看出，spi_driver 和 i2c_driver、 platform_driver 基本一样，当 SPI 设备和驱动匹配成功以后 probe 函数就会执行。 比如：spi1下面接有两个设备（有两个片选信号），我们就可以把设备放入子节点里面，子节点将有内核解析后转换成一个spi_device，与某一个spi_driver匹配后，spi_driver里的probe函数就被调用，我们在probe函数里就可以注册字符设备驱动程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e99e0fc29797c817ceaac989482825b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3962d7867f8516f0be0494b0e2dfd3f6/" rel="bookmark">
			【IMX6ULL驱动开发学习】09.Linux之I2C驱动框架简介和驱动程序模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：Linux之I2C驱动_linux i2c驱动_风间琉璃•的博客-CSDN博客​​​​​​
目录
一、I2C驱动框架简介
1.1 I2C总线驱动
1.2 I2C设备驱动
二、I2C总线-设备-驱动模型
2.1 i2c_driver
2.2 i2c_client
2.3 I2C 设备数据收发和处理
三、Linux I2C驱动程序模板
一、I2C驱动框架简介 在 Linux 内核中 I2C 的体系结构分为 3 个部分：
I2C 核心： I2C 核心提供了 I2C 总线驱动和设备驱动的注册、 注销方法I2C 总线驱动： I2C 总线驱动是对 I2C 硬件体系结构中适配器端的实现， 适配器可由CPU 控制， 甚至可以直接集成在 CPU 内部。I2C 总线驱动就是 SOC 的 I2C 控制器驱动，也叫做 I2C 适配器驱动。I2C 设备驱动： I2C 设备驱动是对 I2C 硬件体系结构中设备端的实现， 设备一般挂接在受 CPU 控制的 I2C 适配器上， 通过 I2C 适配器与 CPU 交换数据。 1.1 I2C总线驱动 I2C 总线和 platform 总线类似， 区别在于platform 总线是虚拟的一条总线， 而 I2C 总线是实际
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3962d7867f8516f0be0494b0e2dfd3f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d0d9d3f7a9300d0859ab6233baa2abf/" rel="bookmark">
			【原创】PyCharm启动Debug报错无法运行，提示No such file or directory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题场景 问题原因 Pycharm根目录带有空格
Pycharm根目录带有空格
Pycharm根目录带有空格
启动python原生Debug时会去PyCharm安装目录下寻找/plugins/python/helpers/pydev/pydevd.py由于PyCharm默认安装目录带有空格,所以无法找到它的目录 解决方案 将原来的PyCharm 版本号 目录****替换为PyCharm即可
奉劝大家安装ide编译器时千万不要带有空格…
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf26c0f5b684909f910e2e9b9f46abb4/" rel="bookmark">
			【IMX6ULL驱动开发学习】10.Linux I2C驱动实战：AT24C02驱动设计流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情回顾：【IMX6ULL驱动开发学习】09.Linux之I2C框架简介和驱动程序模板_阿龙还在写代码的博客-CSDN博客
目录
一、修改设备树（设备树用来指定引脚资源）
二、编写驱动
2.1 i2c_drv_read
2.2 i2c_drv_write
2.3 完整驱动程序
三、上机测试
一、修改设备树（设备树用来指定引脚资源） 放在哪个I2C控制器下面AT24C02的I2C设备地址（查看芯片手册 0x50）compatible属性：用来寻址驱动程序 修改设备树：在内核目录下 vi arch/arm/boot/dts/100ask_imx6ull-14x14.dts &amp;i2c1 { clock-frequency = &lt;100000&gt;; pinctrl-names = "default"; pinctrl-0 = &lt;&amp;pinctrl_i2c1&gt;; status = "okay"; at24c02 { compatible = "100ask,i2cdev"; reg = &lt;0x50&gt;;//设备地址 查看芯片手册 }; }; at24c02节点会转换成i2c_client，i2c_client里有个adpater，即i2c_client.adpater。i2c_client.adpater将指向一个i2c控制器，i2c控制器与&amp;i2c1节点对应，即&amp;i2c1就是一个i2c控制器，内核里对&amp;i2c1这个i2c控制器已经编写好了驱动程序。
二、编写驱动 在I2C驱动框架的基础上对i2c_drv_read和i2c_drv_write函数修改
2.1 i2c_drv_read 实现读AT24C02的0地址数据需要完成一下步骤：
初始化i2c_msg
发起一次写操作: 把0发给AT24C02, 表示要从0地址读数据
发起一次读操作: 得到数据
/* 实现对应的open/read/write等函数，填入file_operations结构体 */ static ssize_t i2c_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset) { int err; unsigned char *kern_buf; struct i2c_msg msgs[2]; /* 从0读取size字节 */ kern_buf = kmalloc(size, GFP_KERNEL); /* 初始化i2c_msg * 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf26c0f5b684909f910e2e9b9f46abb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae486d3dc48832ac675dbd5e97ca21f0/" rel="bookmark">
			MySQL MVCC的详解之Read View
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要一、基于UNDO LOG的版本链1.1、行记录结构1.2、了解UNDO LOG1.3、版本链 二、Read View2.1、判定机制2.2、源码 三、参考 概要 在上文中，我们提到了MVCC（Multi-Version Concurrency Control)多版本并发控制，是通过undo log来实现的。那具体是如何实现的呢？将在本文一一道来。
MVCC是为了实现非阻塞读，即提高数据库并发读能力的一种机制。
通常来说，A事务正在修改数据行X，在修改未结束前，B事务要读数据行X,为了避免读到脏数据，B就会被阻塞,直到A事务修改完数据行X，MVCC很好的避免了这种情况的发生。
MVCC是通过保存数据在某个时间点的快照来实现的，即保存一个数据行的多个变更版本（空间换时间）。这些版本就是undo log了，每一行的变更记录就存在undo log中，通过链表联系在一起，构成了一个完整的版本链，供MVCC实现非阻塞读。
例如在可重复读隔离级别下，A事务正在修改数据行X，在修改数据行X前会把其当前记录插入到版本链中，B事务要读数据行X就到版本链中找符合的，这样B就不会被阻塞了。
ps:MySQL的MVCC只作用于在REPEATABLE READ和READ COMMITED两个隔离级别下执行普通的SELECT操作。
在高性能MySQL第三版一书中对MVCC的操作描述如下：
下面来一起探索下具体实现吧。
本文背景：MySQL InnoDB存储引擎。
一、基于UNDO LOG的版本链 在了解版本链之前，首先看一下InnoDB存储引擎的行记录。
1.1、行记录结构 提到MySQL的行记录，肯定会想到行ID、用户数据列等内容，除了这些信息外，还有一些隐藏信息，比如事务ID、回滚指针等其他额外信息，那我们可以得出下图：
其中事务ID(trx_id)、回滚指针(rollback_ptr)是本文要讲的核心。
ps:InnoDB的行记录是存储在聚族索引中的
1.2、了解UNDO LOG MySQL undo log结构示意图 MySQL的undo log分为两大类：
insert undo:insert 操作产生的，记录了table_id、trx_id、主键各列数据等信息。update undo:update和delete操作产生的， 虽说update和delete操作产生的undo log都会记录到update undo这个大类，但其记录内容是有很大差距的。
delete操作产生的undo log会记录table_id、trx_id、rollback_ptr、主键各列数据等信息，而update操作产生的undo log会记录更新table_id、trx_id、rollback_ptr、被更新列旧值、主键各列数据等信息。
ps:可以看到undo log中并没有记录用户列数据
1.3、版本链 我们现在在test库下有一个test表：
下面我们经过一系列插入，删除，更新来演示版本链的变迁：
假设当前全局trx_id = 101。
插入一条数据 insert into test (id,num,name,key_id) values (1,1,"bob",11); 此时有：
更新数据
1）令id=1的数据name=tom update test set name = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae486d3dc48832ac675dbd5e97ca21f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80269d46ce6b52e966bc91185ea99c3d/" rel="bookmark">
			Wayland文档翻译：第3章. Wayland 架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		x 与 Wayland 架构
Wayland 渲染 为 Wayland 启用硬件支持
X 与 Wayland 架构 了解 Wayland 架构以及它与 X 的区别的一个好方法是从输入设备的事件开始，一直到该事件影响的变化显示在屏幕上的点。
目前我们在 X 方面所处的情况如下：
图3.1. X 架构图
对于 X 来说，事件首先由内核从输入设备获取，并通过 evdev 输入驱动程序发送到 X 服务器。在此过程中，内核通过驱动设备并将不同设备特定的事件协议转换为 Linux evdev 输入事件标准来执行所有的重要工作。然后，X 服务器确定事件影响的窗口，并将其发送到已选择在该窗口上为所讨论的事件进行操作的客户端。实际上，X 服务器并不知道如何正确执行此操作，因为窗口在屏幕上的位置由合成器控制，可能会以 X 服务器不理解的多种方式进行变换（缩小、旋转、抖动等）。客户端检查事件并决定如何处理。通常情况下，界面会根据事件进行更改 - 例如，复选框被单击，或者指针进入必须突出显示的按钮。因此，客户端向 X 服务器发送了一个渲染请求。当 X 服务器接收到渲染请求后，会将其发送到驱动程序，以便让驱动程序编程硬件进行渲染。X 服务器还计算渲染的边界区域，并将其作为损伤事件发送到合成器。损伤事件告诉合成器窗口中的某些内容发生了变化，需要重新合成屏幕上显示该窗口的部分。合成器负责根据其场景图和 X 窗口的内容呈现整个屏幕内容。然而，它必须通过 X 服务器进行渲染。X 服务器接收来自合成器的渲染请求，并将合成器的后备缓冲区复制到前端缓冲区，或进行页面翻转。在一般情况下，X 服务器必须执行此步骤，以便可以处理重叠的窗口，这可能需要进行剪切，并确定是否可以进行页面翻转。然而，对于始终全屏的合成器来说，这是另一个不必要的上下文切换。 如上所示，这种方法存在一些问题。X 服务器没有信息来决定哪个窗口应该接收事件，也无法将屏幕坐标转换为窗口本地坐标。尽管 X 已将最终屏幕的绘制责任交给了合成器，但 X 仍然控制前端缓冲区和模式设置。X 服务器过去处理的大部分复杂性现在都可以在内核或自包含的库（KMS、evdev、mesa、fontconfig、freetype、cairo、Qt 等）中找到。总体而言，X 服务器现在只是一个中间人，在应用程序和合成器之间引入了一个额外的步骤，并在合成器与硬件之间引入了一个额外的步骤。
在 Wayland 中，合成器是显示服务器。我们将 KMS 和 evdev 的控制权交给了合成器。Wayland 协议允许合成器将输入事件直接发送到客户端，并允许客户端将损伤事件直接发送到合成器。
图3.2. Wayland 架构图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80269d46ce6b52e966bc91185ea99c3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9018778a5d0261fb75d5c5b3cbeb26c/" rel="bookmark">
			后台管理系统:简介与登录退出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 1:什么是后台管理系统项目？
注意：前端领域当中，开发后台管理系统项目，并非是java、php等后台语言项目。
【尚品汇电商平台项目】，这个项目主要针对的是用户（游客），可以让用户在平台当中购买产品。
但是你需要想明白一件事情，用户购买产品信息从何而来呀？
比如：前台项目当中的数据来源于卖家（公司），但是需要注意的时候，卖家它不会数据库操作。对于卖家而言，需要把产品的信息上传于服务器，写入数据库。
卖家并非程序员，不会数据库操作（增删改查）。导致卖家，找了一个程序员，开发一个产品，可以让我进行可视化操作数据库（增伤改查）
卖家（公司）：组成，老板、员工。
老板：开发这个项目，对于老板而言，什么都可以操作。【产品的上架、产品的下架、查看员工的个人业绩、其他等等】
员工：可能就是查看个人业绩
后台管理系统：可以让用户通过一个可视化工具，可以实现对于数据库进行增删改查的操作。
而且需要注意，根据不同的角色（老板、员工），看到的、操作内容是不同的。
对于后台管理系统项目，一般而言，是不需要注册的。
模板 简洁版: https://github.com/PanJiaChen/vue-admin-template
加强版: https://github.com/PanJiaChen/vue-element-admin
模板的文件与文件夹认知【简洁版】
下载文件并解压 打开文件夹发现，他缺少npm的包,那我们就npm i 下载包就可以了
如果要运行这个文件，我们需要在配置文件中找他开启服务器的命令，例如这个就是
npm run dev 看一下这个界面 模板的文件与文件夹认知【简洁版】
build
----index.js webpack配置文件【很少修改这个文件】
mock
----mock数据的文件夹【模拟一些假的数据mockjs实现的】，因为咱们实际开发的时候，利用的是真是接口
node_modules
------项目依赖的模块
public
------ico图标,静态页面，publick文件夹里面经常放置一些静态资源，而且在项目打包的时候webpack不会编译这个文件夹，原封不动的打包到dist文件夹里面
src
-----程序员源代码的地方
------api文件夹:涉及请求相关的
------assets文件夹：里面放置一些静态资源（一般共享的），放在aseets文件夹里面静态资源，在webpack打包的时候，会进行编译
------components文件夹：一般放置非路由组件获取全局组件
------icons这个文件夹的里面放置了一些svg矢量图
------layout文件夹：他里面放置一些组件与混入
------router文件夹：与路由相关的
-----store文件夹：一定是与vuex先关的
-----style文件夹：与样式先关的
------utils文件夹：request.js是axios二次封装文件****
------views文件夹：里面放置的是路由组件
App.vue:根组件
main.js：入口文件
permission.js:与导航守卫先关、
settings：项目配置项文件
.env.development
.env.producation
登录业务完成 登录静态组件先完成
就是修改这个界面的ui
el-form组件：element-ui插件里面的一个组件，经常展示表单元素 model:用于收集表单数据 rules:表单验证规则 修改它的背景图
现在实现登录的业务
如果觉得写的比较难受可以换成我们之前的写法
async login({ commit }, userInfo) { //解构出用户名与密码 const { username, password } = userInfo; let result = await login({ username: username.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9018778a5d0261fb75d5c5b3cbeb26c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50688136019a98e0d93d79a342c6a177/" rel="bookmark">
			Wayland文档翻译：第2章. 合成器的类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 系统合成器会话合成器嵌入合成器 合成器根据它们在操作系统整体架构中所扮演的角色而分为不同类型。例如，系统合成器可用于引导系统、处理多用户切换、可能的控制台终端仿真器等。另一种合成器，会话合成器，将提供实际的桌面环境。不同类型的合成器有许多共存的方式。
在本节中，我们介绍了三种依赖于 libwayland-server 的 Wayland 合成器类型。
系统合成器 系统合成器可以从早期引导一直运行到关机。它实际上替代了内核的虚拟终端系统，并可以与系统的图形引导设置和多座位支持进行关联。
系统合成器可以托管不同类型的会话合成器，并允许我们在多个会话之间切换（快速用户切换或安全/个人桌面切换）。
Linux 上的系统合成器实现通常会使用 libudev、egl、kms、evdev 和 cairo。
对于全屏客户端，系统合成器可以重新编程视频扫描输出地址，直接从客户端提供的缓冲区中读取。
会话合成器 会话合成器负责单个用户会话。如果存在系统合成器，则会话合成器将在系统合成器下嵌套运行。嵌套是可行的，因为协议是异步的；在涉及嵌套时，往返会太昂贵。如果没有系统合成器，会话合成器可以直接在硬件上运行。
X 应用程序可以通过按需激活的无根 X 服务器在会话合成器下继续工作。
会话合成器的可能示例包括
gnome-shellmoblinkwinkmsconrdp 会话Weston 与 X11 或 Wayland 后端是在另一个会话合成器中嵌套的会话合成器。在 Wayland 下的全屏 X 会话 嵌入合成器 X11 允许客户端嵌入来自其他客户端的窗口，或者将另一个客户端渲染的像素图内容复制到它们的窗口中。这在面板中的小程序、浏览器插件等方面经常使用。Wayland 并不直接允许这样做，但客户端可以通过非直接的方式传递 GEM 缓冲区名称，例如使用 D-Bus 或者当面板启动小程序时使用命令行参数。另一个选择是使用嵌套的 Wayland 实例。为此，Wayland 服务器必须是主机应用程序链接到的库。主机应用程序将 Wayland 服务器套接字名称传递给嵌入式应用程序，并需要实现 Wayland 合成器接口。主机应用程序将客户端表面作为其窗口的一部分进行合成，即在网页或面板中。嵌套 Wayland 服务器的好处在于，它为嵌入式客户端提供了通知主机有关缓冲区更新的请求，并提供了将输入事件从主机应用程序转发的机制。
这种设置的一个示例是 Firefox 将 Flash 播放器嵌入为一种特殊用途的合成器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64849a9f7a7f5eb437c34db3451b13f1/" rel="bookmark">
			如何为Typora配置图床，实现图片自动上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目开发中经常会使用Typora记录下一些笔记，此时会用到一些图片。但如果图片存在本地的话，当更换设备或移动位置，或者将这些笔记发布到网上时，则会出现图片丢失或无法识别的问题。因此需要为Typora配置图床，当在笔记中添加图片时自动上传该图片到“已配置成功”的图床中。实现步骤如下：
1.安装node.js 官网：Node.js
PS: 检测是否安装成功
Win + R输入cmd打开命令行窗口，输入“node -v”，“npm -v”，如下图所示则代表安装成功：
2.Gitee图床仓库创建： 1).创建图床仓库： 登录“gitee.com”网站后点击右上角“+”创建新仓库：
注意:
1.新创建的仓库一定要勾选“Readme文件”，其他保持默认即可
2.Gitee网站改版后无法直接在创建仓库时设置其为“开源”，只能在创建完成后在“仓库设置”中再修改。具体修改方式：菜单栏“管理 -&gt; 仓库设置 -&gt; 基本信息”，勾选“开源”即可
2).生成私人令牌： “Gitee”网站点击右上角头像：
点击左侧菜单中“安全设置 -&gt; 私人令牌”：
点击右上角“生成新令牌”：
在“权限”中只需要勾选以下两个即可：
之后点击“提交”即可生成“私人令牌”。
PS：这里成功创建的“私人令牌”的编码需要保存起来，用于后续PicGo中图床参数配置。因为在Gitee中创建“私人令牌”后，只有在此时才可以看到该令牌的详细编码，之后无法在任何地方再查询到，因此如果该令牌后续需要用在如Typora图床等地方，则需要预先暂存该编码，否则只能重新创建新的“私人令牌”)
3.PicGo安装及配置： 1).PicGo安装： PicGo下载：Releases · Molunerfinn/PicGo · GitHub，选择“正式版”，这里安装的是“PicGo-2.3.1”
2).Gitee插件安装： 在PicGo左侧菜单栏“插件设置”中搜索“gitee”，选择“gitee-uploader 1.1.2”安装
PS：之前的插件“gitee 2.0.5”已经无法上传图片，会报错“【上传异常】403 Forbidden”。故这里选择新版插件“gitee-uploader 1.1.2”，经过测试可以正常使用
3).Gitee上传配置： 参数解析：
“repo”： 代表gitee上新创建的仓库的链接，但注意：这里不能直接使用“仓库名称”，而应该使用仓库的链接地址中“https://gitee.com”后续的内容：(该信息可在“管理 -&gt; 仓库设置 -&gt; 基本信息”中找到)。
“branch”：指gitee图床仓库中使用的分支名，默认为“master”(有的仓库默认分支为“main”)，并且也可以使用仓库中的其他分支，因此可以根据需求自由填写使用的分支
“token”：指之前生成“私人令牌”密钥
“path”：上述设置了使用的仓库分支，如果需要将图片上传到指定分支下的指定文件夹中，则可以在此填写文件夹名字，如需要将图片上传到“main”分支下的“Typora”文件夹中，则设置“path”为“Typora”即可(但需要先确保远程仓库的“main”分支下有文件夹“Typora”，否则会上传失败)
“customPath”： 上传图片后生成的链接中的“图片名字”
“default”代表保持图片原本的名字
“年/年季/年月”代表根据当前时间对图片链接重命名，通常选择“年月”
“customUrl”：保持默认，不做改变
4.在Typora中配置“图片上传”： 1).设置“插入图片时”执行“上传图片”操作：菜单栏“文件 -&gt; 偏好设置” 2).在下方的“上传服务”中选择“PicGo(app)”： PS: 1.Gitee图床仓库必须为“公有仓库(开源)”，否则图片上传时会因为缺少权限而失败
2.可以在PicGo应用程序的“相册”中随时查看当前已上传的图片(该“相册”与“远程图床仓库”中包含的图片内容一致)。因此当删除“相册”中任意图片时，“远程图床仓库”中该图片也会被自动删除
3.当需要验证配置是否正确时，可以直接使用“验证图片上传选项”。如果上传失败，则可在以下路径查看log文件：C:\Users\xxx\AppData\Roaming\picgo\picgo.log，避免盲目纠错
4.上传图片时出现报错“【上传异常】403 Forbidden”，出现该报错的原因大概有两种：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64849a9f7a7f5eb437c34db3451b13f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44b0a31618962f9676982ca8eb10e22a/" rel="bookmark">
			H3C配置堆叠
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 把多台网络设备组合一起当作一台设备来管理和使用，称之为堆叠或者虚拟化
二、需求 三台交换机坐堆叠（如果需要增加直接往后顺延即可） 1、堆叠域默认 domail 0
2、H3C1 作为主设备，堆叠口 g1/0/47、g1/0/48
H3C2作为从设备，堆叠口 g1/0/47、g1/0/48
H3C2 作为从设备，堆叠口 g1/0/47、g1/0/48
三、注意事项 1、尽量使用光口最好是10GB以上的光口，电口及千兆光口有可能会导致堆叠不成功
2、H3C1的47口连接H3C2的48口
H3C2的47口连接H3C3的48口
H3C3的47口连接H3C1的48口
3、在三台交换机都配置完成后在分别执行 irf-port-configuration active，执行前先保存配置。
4、建议在配置完成后在接线。
5、堆叠后配置会以主机配置为准，主机的配置会同步给备机。备机原有的配置会丢失，不会同步给主机。
6、同一拓扑内同一组设备必须在同一个domain下，默认domain为0，member序号即是虚拟化后【大设备】的slot【板卡】序号。
四、配置实例 1、主设备配置 [H3C1]irf domain 0 #同一拓扑内如果有其它堆叠组，domain不能重复（可不用配置）
[H3C1]irf member 1 priority 30 #priority：优先级，大的为主设备，其余为备，默认值为1
[H3C1]int range GigabitEthernet 1/0/47 to GigabitEthernet 1/0/48
[H3C1-if-range]shutdown #端口加入irf-port之前必须先shutdown
[H3C1]irf-port 1/1
[H3C1-irf-port1/1]port group interface GigabitEthernet 1/0/47
[H3C1]irf-port 1/2
[H3C1-irf-port1/2]port group interface GigabitEthernet 1/0/48
[H3C1]int range GigabitEthernet 1/0/47 to GigabitEthernet 1/0/48
[H3C1-if-range]undo shutdown
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44b0a31618962f9676982ca8eb10e22a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c17bb5a459b4a2f7c89e3316df34db97/" rel="bookmark">
			通达信快捷功能键大全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		通达信金融终端网上交易软件 快捷键分为四种
数字键:比如1,61,81,10,91等
点系列键:比如.101,.201,.301… .909等
功能键:比如F1,F2… 空格键,减号键,TAB等
组合键:比如Ctrl+V,Alt+1,Ctrl+Z等 #龙虎榜小红牛系统 #官方微信公众号：gxzfp888 1.Ctrl+V 切换前复权与还原 Ctrl+B切换后复权与还原
2.在分时图或分析图界面下,使用Ctrl+W进行本屏的区间统计
3.Ctrl+M 按当前的股票集合进入多股界面
4.Ctrl+R 所属板块
5.Ctrl+D 系统设置
6.Ctrl+Z 加入到板块 Shift+Ctrl+Z 从板块中删除
7.在分时图或分析图界面下,Ctrl+O 叠加股票,Ctrl+G 删除叠加
8.Ctrl+J 进入主力监控精灵,再按Ctrl+J 退回
9.Ctr+F进入公式编辑器
10.Shift+F10 进入基本权息资料界面
11.在有信息地雷的画面,按Shift+回车键进入信息地雷
12.Ctrl+1,Ctrl+2显隐辅助区和功能树 Ctrl+3,Ctrl+4显隐工具栏和状态栏 Ctrl+5显隐滚动资讯栏
13.Ctrl+L显隐右边信息区(也可以敲 .6)
14.快速排名 点系列键 .202至.226
15.热门板块分析 点系列键 .400
15.如果有自定义的版面,使用点系列键 .001至.099
16.使用减号键"-“来启动或停止"自动换页”
17.在走势图或分析图画面,使用加号键"+“来切换右下角的内容,Shift+加号键反向切换
18.在报价界面和报表界面,使用空格键打开股票集合的菜单等,使用]或[键切换各分类
19.深证100 快捷键:100 上证180 快捷键:180 沪深300 快捷键:300
20.在财经资讯和信息地雷浏览过程中,可以连续按回车键或连续双击鼠标来快速切换标题区和内容区
21.新版本支持16(信息地雷),18(机构评测和诊断)
22.画线工具:Alt+F12
23.条件选股 .905或按Ctrl+T 定制选股 ；.906 ；模式选股 .907 综合选股 .909
24.Ctrl+P 全屏和非全屏的切换 全屏显示 画面更清爽干净
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c17bb5a459b4a2f7c89e3316df34db97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64f2de019674f36c72d18cc507f2376f/" rel="bookmark">
			linux常用命令大全(个人笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是一些常用的 Linux 命令：
文件和目录操作：
ls：列出目录内容。cd：切换目录。pwd：显示当前工作目录。mkdir：创建目录。rm：删除文件或目录。cp：复制文件或目录。mv：移动文件或目录。 文件查看和编辑：
cat：查看文件内容。less：逐页查看文件内容。head：显示文件开头部分。tail：显示文件结尾部分。vi 或 vim：文本编辑器。 文件权限和属性：
chmod：修改文件权限。chown：修改文件所有者。chgrp：修改文件所属组。lsattr：显示文件属性。 系统信息和管理：
uname：显示系统信息。whoami：显示当前用户。top：实时显示系统资源占用情况。ps：显示进程信息。kill：终止进程。shutdown：关机或重启系统。 网络相关：
ping：测试与目标主机的连通性。ifconfig 或 ip：查看网络接口信息。netstat：显示网络连接、路由表和网络接口统计信息。ssh：远程登录到其他计算机。 压缩和解压缩：
tar：打包和解包文件。gzip：压缩文件。gunzip：解压缩文件。 包管理器：
apt 或 apt-get：Debian/Ubuntu 系统的包管理器。yum：CentOS/RHEL 系统的包管理器。 文本处理：
grep：在文件中搜索匹配的文本。sed：流编辑器，用于文本替换和转换。awk：文本处理工具，执行复杂的文本操作。 网络工具：
wget：下载文件。curl：通过 URL 进行数据传输。 磁盘和文件系统：
df：显示磁盘空间使用情况。du：估算文件或目录的磁盘使用情况。mount：挂载文件系统。umount：卸载文件系统。 用户和权限管理：
useradd：创建用户账号。passwd：修改用户密码。su：切换用户身份。sudo：以超级用户身份执行命令。 时间和日期：
date：显示当前日期和时间。cal：显示日历。 进程管理：
ps：显示进程状态。top：实时显示系统进程和资源使用情况。kill：终止进程。 日志文件：
tail：显示文件末尾的内容。grep：在文件中搜索匹配的文本。less：逐页查看文件内容。 Shell 脚本：
chmod：修改脚本文件的执行权限。sh 或 bash：执行 Shell 脚本。 vi文本编辑器常用指令
打开和保存文件：
vi filename：打开指定文件。在 Vi 中，按下 i 进入插入模式，可以开始编辑文本。按下 Esc 键退出插入模式。:w：保存文件。:q：退出 Vi 编辑器。:wq：保存文件并退出 Vi 编辑器。 导航和编辑文本：
h：向左移动光标。j：向下移动光标。k：向上移动光标。l：向右移动光标。x：删除当前光标所在位置的字符。dd：删除当前行。yy：复制当前行。p：粘贴剪贴板内容。 搜索和替换：
/text：向下搜索指定文本。?text：向上搜索指定文本。n：继续查找下一个匹配项。:%s/old/new/g：将文本中所有的 "old" 替换为 "new"。 撤销和重做：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64f2de019674f36c72d18cc507f2376f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee7eacb7b80b9d237343a307e990a583/" rel="bookmark">
			ubuntu18.04安装之后没有网络，不显示网络图标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新安装的ubuntu18.04.06安装完成后插着网线，但是没有有线网，桌面上不显示网络图标。
原因是因为ubuntu系统安装时自带的网卡驱动不兼容导致的。下面来讲解解决方法：
首先，先试用手机连接线，将手机连接到电脑usb口，使用手机上的USB网络共享，让电脑先可以联网。然后在终端输入如下命令，查看网卡设备：
lspci 可以看到需要的网卡驱动是Realtek RTL8125。去realtek官网下载网卡驱动：
Realtek PCIe FE / GBE / 2.5G / Gaming Ethernet Family Controller Software - 瑞昱半导体
下载下来，解压。在解压后的文件夹下打开终端，输入以下命令安装：
sudo ./autorun.sh 安装完成后，重启，网络即可正常使用。在这一步往往有很多错误。 提示没有make组件，或者没有gcc组件，这是因为电脑内的这两个包没有安装导致的。解决方法：
现在Software &amp; Updates中换源，更改源为清华。
然后运行下面两个命令，更新并安装缺失的包：
#检查可用更新包 sudo apt-get update #更新已安装的软件包 sudo apt-get upgrade 更新完成之后，重新安装网卡驱动，安装完重启，网络即可用。
有问题，欢迎留言，博主随时为你解答。
有用的话，点个免费的赞吧！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30eb97bd3541a4d3b0852a7e485c1b0a/" rel="bookmark">
			常用的pytest的assert断言操作(个人笔记)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pytest 提供了一系列常用的断言函数，用于在测试中进行各种断言操作。以下是一些常用的 pytest 断言操作的示例：
相等性断言：
assert result == expected 不相等性断言：
assert result != unexpected 包含性断言：
assert item in collection 不包含性断言：
assert item not in collection 真值断言：
assert condition 假值断言：
assert not condition 异常断言：
with pytest.raises(ExpectedException): # 执行可能引发异常的代码 比较断言：
assert x &gt; y assert x &lt; y assert x &gt;= y assert x &lt;= y 类型断言：
assert isinstance(obj, expected_type) 属性断言：
assert hasattr(obj, 'attribute') assert not hasattr(obj, 'attribute') 这些是一些常见的 pytest 断言操作，您可以根据具体的测试需求选择适当的断言函数进行使用。断言操作可以帮助您验证测试的预期结果，确保代码的正确性和可靠性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30eb97bd3541a4d3b0852a7e485c1b0a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/117/">«</a>
	<span class="pagination__item pagination__item--current">118/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/119/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>