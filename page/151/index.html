<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c0f64f87566e0c3356eed220e2e6a70/" rel="bookmark">
			【毕业设计】基于JAVA的springboot篮球竞赛预约平台(源代码&#43;论文）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这两年开始毕业设计和毕业答辩的要求和难度不断提升，传统的理念缺少创新和亮点，往往达不到毕业答辩的要求，这两年不断有学弟学妹告诉学长自己做的各类系统很难达到老师的要求。
为了大家能够顺利并以最少的精力通过毕设，学长分享优质毕业设计项目，需要的自取。
目录
1.说明
2.系统分析与设计
2.1 可行性分析
2.1.1 技术可行性
2.1.2 操作可行性
2.1.3经济可行性
2.2 需求分析
2.3 总体设计
2.4 数据库设计与实现
2.4.1 数据库概念结构设计
3.系统功能的具体实现
3.1 前台功能模块
3.2 后台功能模块
3.2.1 管理员功能
3.2.2 用户功能
1.说明 本篮球竞赛预约平台以springboot作为框架，b/s模式以及MySql作为后台运行的数据库，同时使用Tomcat用为系统的服务器。本系统主要包括首页，个人中心，用户管理，项目分类管理，竞赛项目管理，赛事预约管理，系统管理等功能，通过这些功能的实现基本能够满足日常篮球竞赛预约管理的操作。
2.系统分析与设计 2.1 可行性分析 一个完整的系统，可行性分析是必须要有的，因为他关系到系统生存问题，对开发的意义进行分析，能否通过本网站来补充线下篮球竞赛预约管理模式中的缺限，去解决其中的不足等，通过对本网站，不仅能使工作量不断地减少，还能使工作和管理的效率更加高。所以开发该网站能实现更大的意义和价值，网站完成后，能否达到预期效果就要通过可行性分析，分析之后，决定此系统是否开发。该篮球竞赛预约平台的开发设计中，对技术、经济、操作方面进行了可行性分析； 2.1.1 技术可行性 本系统开发选择java语言，它被研究的目的就是在于能够为网页创建等可以看到的信息。随着移动互联网技术的不断发展和创新，java俨然已成为下一代互联网的Web标准。所以后台设计选择使用mysql数据库主要用来的建立和维护信息。对于前台开发要求应具备功能完善、易于操作等优点，后台数据库的要求则是能够建立和维护数据信息的统一性和完整性。
2.1.2 操作可行性 现在随着科技的飞速发展，计算机早已经进入了人们的日常生活中，人们的工作环境也不像以前有那么多的要求，需要工作人员一定要到公司办公，有的工作在家也可以完成。这使得人们的工作效益有了很大的提高。操作的多样性也变高了。因此，管理的计算机化，智能化是社会发展而带来的必然趋势，各种智能的软件层出不穷，不同的软件能完成用户不同的需求，这不仅提高了工作效率还能完成一些客户特定的一些需求。本系统不仅界面简洁明了还采用可视化界面，用户只要用鼠标和键盘就可以完成对相关信息的修改，删除，添加等操作。因为这个系统的操作十分简单，方便上手，对于第一次使用系统的人，只需要很少的时间就可以上手操作。由此可见，本系统在操作上是可行的。
2.1.3经济可行性 基于springboot的篮球竞赛预约平台，该网站软件开发仅需要一台普通的计算机便可完成实现开发，其成本很低。另外，作为毕业设计作品来讲，开发成本基本上可以忽略不计，且该系统软件的投入使用，可以实现更加快速高效的篮球竞赛预约管理，同时还能实现对人力资源和管理资源的有效节约，该篮球竞赛预约平台在经济上完全可行。
2.2 需求分析 利用springboot、Java、MyEclipse和mysql数据库等知识点，结合相关设计模式、以及软件工程的相关知识，设计一个篮球竞赛预约平台，来进行记录用户的信息，以及系统信息的增删改查的功能，根据实现需求，系统需完成这些基本功能：
（1）系统合理显示系统首页界面，管理员界面，用户界面等界面。
（2）管理员和用户所有的信息都保存与数据库中。
（3）对篮球竞赛预约信息能够进行查询、修改、删除、添加等操作。
2.3 总体设计 根据篮球竞赛预约平台的功能需求，进行系统设计。
前台功能：用户进入系统可以实现首页，竞赛项目，平台公告，个人中心，后台管理等功能进行操作；
后台由管理员和用户，主要功能包括首页，个人中心，用户管理，项目分类管理，竞赛项目管理，赛事预约管理，系统管理等功能；
系统对这些功能进行整合，产生的功能结构图如下：
2.4 数据库设计与实现 在每一个系统中数据库有着非常重要的作用，数据库的设计得好将会增加系统的效率以及系统各逻辑功能的实现。所以数据库的设计我们要从系统的实际需要出发，才能使其更为完美的符合系统功能的实现。
2.4.1 数据库概念结构设计 数据库的E-R图反映了实体、实体的属性和实体之间的联系。下面是各个实体以及实体的属性。
用户注册实体属性图如下所示：
竞赛项目实体属性图如下所示：
赛事预约管理实体属性图如下所示：
3.系统功能的具体实现 3.1 前台功能模块 篮球竞赛预约平台，用户进入到平台首页，可以查看首页，竞赛项目，平台公告，个人中心，后台管理等内容进行操作，如图所示。
用户注册；在用户注册页面中输入用户账号，密码，确认密码，用户姓名，年龄，用户手机，身高，体重等内容进行用户注册操作；如图所示。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c0f64f87566e0c3356eed220e2e6a70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e1aa8b9bbcd238fdfb6edf773ce799/" rel="bookmark">
			人群归因分数（Population Attributable Fraction, PAF）：概念、简单计算案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		专注系列化、高质量的R语言教程
推文索引 | 联系小编 | 付费合集
本篇目录如下：
1 人群归因分数
1.1 相对风险度
1.2 人群归因分数
2 案例
2.1 示例数据
2.2 计算案例1
2.3 计算案例2
2.4 计算案例3
3 总结
1 人群归因分数 人群归因分数（Population Attributable Fraction, PAF）是疾病负担研究中常用的指标，其大致含义是，假设人群的风险暴露降低至理想水平，预计可减少的患病人口数占实际患病人口数的比例。
The population attributable fraction (PAF), which represents the proportion of risk that would be reduced in a given year if the exposure to a risk factor in the past were reduced to an ideal exposure scenario.[1]
风险因素的理想暴露水平有多种定义方式，常用的是理论最小风险水平（Theoretical Minimum Risk Level，TMREL），指理论上能使疾病负担水平达到最低的暴露水平。如世卫组织推荐的不会造成健康风险的污染物临界指标[2]：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e1aa8b9bbcd238fdfb6edf773ce799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/936afe03927a91f9837e285d62d81446/" rel="bookmark">
			安全测试 —— 越权漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.越权漏洞介绍 越权漏洞是指攻击者通过各种手段，绕过系统的权限控制，获得未被授权的访问权限，从而实现对系统的非法操作。 2.越权漏洞的产生原因 1.后台应用没有做权限控制，或仅仅在菜单、按钮上做了权限控制，导致恶意用户可以猜测其他管理页面的URL或者敏感的参数信息，从而访问或控制其他角色用户的数据和页面。 2.验证权限不足，例如通过登录后即可验证用户的身份，从而不会做下一步验证，最后导致越权。 3.开发人员对数据的增、删、改、查时对客户端请求的数据过分相信而遗漏了权限的判定，由于服务区端在接受到请求数据进行操作时，没有判断数据的所属人而导致的越权数据访问漏洞。 3.越权漏洞的危害 越权漏洞的危害主要表现在以下几个方面： 1.泄露敏感信息：攻击者可以通过越权漏洞获取到未被授权的敏感信息，比如用户信息、交易记录等。 2.篡改数据：攻击者可以通过越权漏洞修改系统中的数据，比如更改账户余额、修改订单状态等。 3.执行非法操作：攻击者可以通过越权漏洞执行系统中未被授权的操作，比如删除数据、创建用户等。 4.越权漏洞类型 越权漏洞主要分为水平越权和垂直越权两种类型。 1.水平越权：攻击者尝试访问与自己拥有相同权限的用户资源。例如，用户A和用户B属于同一角色，拥有相同的权限等级，他们能获取自己的私有数据（数据A和数据B），但如果系统只验证了能访问数据的角色，而没有对数据做细分或者校验，导致用户A能访问到用户B的数据（数据B），那么用户A访问数据B的这种行为就叫做水平越权访问。 2.垂直越权：攻击者尝试访问比自己权限高的用户资源。例如，普通用户想要访问管理员的权限，如果系统没有对其进行权限判断，那么就会出现垂直越权漏洞。 未授权访问：攻击者通过各种手段，绕过系统的权限控制，获得未被授权的访问权限，从而实现对系统的非法操作。 5.越权漏洞防御方案 为了防止越权漏洞，可以采取以下几种防御措施： 1.建议使用基于角色访问控制机制来防止纵向越权攻击，即预先定义不同的权限角色，并为每个角色分配不同的权限。每个用户都属于特定的角色，即拥有固定的权限。当用户执行某个动作或产生某种行为时，通过用户所在的角色判定该动作或者行为是否允许。 2.对于水平越权漏洞，需要对数据做细分或者校验，确保只有数据的拥有者才能访问。 3.对于垂直越权漏洞，需要对用户进行身份验证，确保只有拥有相应权限的用户才能访问。 4.对于未授权访问漏洞，需要对系统进行全面的权限控制，确保只有被授权的用户才能访问系统中的资源。 5.定期进行安全审计和 6.在挖掘越权漏洞方面，可以采取以下技巧 1.抓取对目录及类名的请求（URL层）。 2.枚举敏感参数和请求头，例如Cookie、Authorization等。 3.尝试使用其他用户的账号进行操作，例如管理员账号。 4.使用代理工具拦截请求，进行数据包分析，尝试修改请求参数和请求头。 5.模拟攻击者的行为，例如尝试修改URL、请求参数等，查看是否可以访问其他用户的资源。 END绵薄之力 最后感谢每一个认真阅读我文章的人，看着粉丝一路的上涨和关注，礼尚往来总是要有的，虽然不是什么很值钱的东西，如果你用得到的话可以直接拿走：
这些资料，对于【软件测试】的朋友来说应该是最全面最完整的备战仓库，这个仓库也陪伴上万个测试工程师们走过最艰难的路程，希望也能帮助到你！
加入我的软件测试交流群：110685036免费获取~（同行大佬一起学术交流，每晚都有大佬直播分享技术知识点） 软件测试面试小程序 被百万人刷爆的软件测试题库！！！谁用谁知道！！！全网最全面试刷题小程序，手机就可以刷题，地铁上公交上，卷起来！
涵盖以下这些面试题板块：
1、软件测试基础理论 ，2、web,app，接口功能测试 ，3、网络 ，4、数据库 ，5、linux
6、web,app，接口自动化 ，7、性能测试 ，8、编程基础，9、hr面试题 ，10、开放性测试题，11、安全测试，12、计算机基础
获取方式 ：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63075689614981dfcb200ad97d4b7642/" rel="bookmark">
			Android 13 有线网变更(用到的可以收藏)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 13 有线网变更 文章目录 Android 13 有线网变更一、从接触的Android13 （Tv版）源码和测试结果看，有线网有如下变更：二、有线网具体变更介绍1、限制了设置有线网参数设置接口方法2、新增有线网开启关闭接口方法3、新增了 updateConfiguration 接口方法4、有线网设置的静态ip和代理信息重启后无效 三、总结1、有线网变化2、Android13 有线网适配思路3、其他 如果是Android12 的系统需要开发用到有线网络，那么本文可以让你少走一些弯路。
Android12 和13 网络部分变化是不大的，
Android11 到Android 12 网络部分无论是代码存放目录和代码逻辑都是有较多修改的。
一、从接触的Android13 （Tv版）源码和测试结果看，有线网有如下变更： 1、限制了设置有线网参数设置接口方法 2、新增有线网开启关闭接口方法 3、新增了 updateConfiguration 接口方法 4、有线网设置的静态ip和代理信息重启后无效 简单的说就是，如果app api 设置成Android13 ，应用用无法有以前的接口设置有线网信息。
二、有线网具体变更介绍 1、限制了设置有线网参数设置接口方法 有线网设置新路径：
packages\modules\Connectivity\framework-t\src\android\net\EthernetManager.java
@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553) public IpConfiguration getConfiguration(String iface) { try { return mService.getConfiguration(iface); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553) public void setConfiguration(@NonNull String iface, @NonNull IpConfiguration config) { try { mService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63075689614981dfcb200ad97d4b7642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/161df0999f1d06e033f9e6fc6668dabb/" rel="bookmark">
			自动化测试框架有哪几种？全网最全面的总结来了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
什么是测试自动化框架
自动化测试框架的类型
测试自动化框架的好处
流行测试自动化框架
Robot Framework
WebdriverIO
Citrus
Cypress
Selenium
Cucumber
Gauge
Carina
总结
重点：配套学习资料和视频教学
前言 为了适应快速发展的行业生态系统的步伐，必须加快应用程序交付时间，而且必须不能以质量为代价。在更短的时间内达到质量的目的至关重要，因此质量保障倍受关注。为了满足对卓越质量和更快迭代的要求，越来越多的企业引入自动化，并将优先进行自动化测试。敏捷开发模型使其测试过程自动化变得越来越必要，但是最关键的方面是选择正确的测试自动化框架。
什么是测试自动化框架 测试自动化框架是为自动化测试用例或者脚本提供执行环境而搭建的基础设施。自动化测试框架为用户提供了各种好处，可帮助他们有效地开发、执行和报告自动化测试用例。自动化测试框架更像是专门为自动化测试而创建的一套系统。用一种非常简单的语言，也可以说框架是各种编码标准、测试过程、工作实践、项目层次结构、模块化、报告机制、测试数据注入等支持自动化测试的功能的极大融合。
自动化测试框架的优点是多方面的，例如易于脚本支持、可伸缩性、模块化、易理解性、可重用性、成本、维护等。因此，为了获得这些好处，建议测试工程师在使用以下一种或多种测试自动化框架。此外，许多测试人员在同一应用程序的不同模块上工作时，并且当我们希望避免每个人都实现某一同样功能的自动化方法时，就需要一个单一的标准测试自动化框架。
自动化测试框架的类型
现在我们对自动化框架有了基本的了解，让我们看一下现在流行的各种类型的测试自动化框架。这些框架可能基于对不同关键因素（例如驱动类型、可重用性、易于维护等）进行自动化的支持而彼此不同。
测试自动化框架的类型：
基于模块的测试框架仓库架构测试框架数据驱动测试框架关键字驱动测试框架混合测试框架行为驱动开发框架
测试自动化框架的好处 除了自动化测试所需的最少手动干预之外，实施测试自动化框架还有许多优点。下面列出了其中一些：
加快产品上市时间：使用良好的测试自动化框架，可以通过持续执行测试用例来帮助缩短应用程序的上市时间。一旦自动化，测试用例的执行速度将比手动测试更快，并且可持续运行时间更长。更早发现「BUG」：测试团队可以轻松地记录软件「BUG」。它提高了总体开发速度，同时确保了跨模块的正确功能。越早发现「BUG」，解决该问题的成本就越低。提高测试效率：测试占据了整个开发生命周期的很大一部分。即使是整体效率的最轻微改善，也可能对项目的整个时间范围产生巨大的影响。尽管最初的设置时间会更长，但是自动化测试最终会花费更少的时间。它们几乎可以在无人值守的情况下运行，从而可以在过程结束时对结果进行监视。更高的投资回报率：虽然初始投资可能更高，但是自动化测试可以为组织节省很多钱。这是由于运行测试所需的时间减少了，这导致了更高的工作质量。反过来，这减少了释放后固定毛刺的必要性，从而降低了项目成本。更高的测试覆盖率：在测试自动化中，可以执行与应用程序有关的更多测试。这导致更高的测试覆盖率，这在手动测试方法中将意味着庞大的团队，其工作时间受到了很大的限制。测试覆盖率的提高导致测试更多功能和更高质量的应用程序。自动化测试的可重用性：测试案例在测试自动化中的重复性，除了相对容易配置的设置外，还可以帮助软件开发人员评估程序反应。自动化测试用例可以重复使用，因此可以通过不同的方法加以利用。
流行测试自动化框架 Robot Framework 如果要使用python测试自动化框架进行测试自动化，则Robot Framework是最佳选择。Robot Framework是基于Python的，但是也可以使用Jython（Java）或IronPython（.NET）语言进行脚本用例的编写。Robot Framework使用关键字驱动的方法使测试用例易于创建。Robot Framework还可以测试MongoDB、FTP、Android、Appium等。它拥有非常多的测试库，包括Selenium WebDriver库和其他常用的的工具。Robot Framework具有许多API，可帮助使其尽可能地扩展。Robot Framework使用的关键字方法非常适合已经熟悉其他测试框架的测试人员，关键字驱动的测试工具的测试人员，这使他们更容易过渡到Robot Framework测试框架。
WebdriverIO WebdriverIO是基于Node.js的自动化测试框架。它具有集成的测试运行程序，可以为Web应用程序以及本机移动APP运行自动化测试用例。而且，WebdriverIO可以同时在WebDriver协议和Chrome Devtools协议上运行，从而使其对于基于Selenium Webdriver的跨浏览器测试或基于Chromium的自动化都非常有效。由于WebDriverIO是开源的，因此测试工程师可以获得一堆满足自动化需求的插件。
Citrus Citrus是一个开源测试框架，测试人员可以使用该框架自动化针对任何消息传递协议或数据格式的集成测试。对于诸如REST、HTTP、SOAP或JMS之类的任何消息传递传输，Citrus测试框架都适用于测试消息传递集成。如果需要与用户界面进行交互然后验证后端过程，则可以将Citrus与Selenium进行集成。例如，如果必须单击发送电子邮件按钮并在后端确认已收到电子邮件，则Citrus可以接收此电子邮件或由UI触发的JMS通信，并验证后端结果，所有的操作和验证步骤都在一个测试用例中。
Cypress Cypress是一个以开发人员为中心的测试自动化框架，该框架使TDD测试驱动开发对开发人员而言成为现实。它的设计原理是能够非常简单地将所有内容打包并捆绑在一起以进行整个端到端测试。Cypress的架构与Selenium不同。Selenium WebDriver在浏览器外部远程运行，而Cypress在其内部运行。这种方法有助于了解浏览器内部和外部发生的所有事情，以提供更一致的测试结果。当测试人员将应用程序拉入浏览器时，Cypress可以将浏览器内部发生的每件事同步通知使用者，这样测试就可以原生访问每个元素。这也使将调试功能序变得容易，从而使使用开发人员更加容易对功能进行打包验证。
Selenium Web应用程序中最受欢迎的开源测试自动化框架之一。Selenium具有跨平台和跨浏览器功能，它还可以用作许多其他测试工具的基础。Selenium支持多种编程语言，例如Java、C＃、PHP、Python、Ruby等。它拥有最大的在线社区之一，因此更加易于维护。Selenium可以通过广泛的库和API进行高度扩展，以满足每个团队的需求。Selenium是测试人员首选的测试框架，因为可以编写更高级的测试脚本来满足各种复杂程度。它提供了用于测试创作的回放工具，而无需学习特定的脚本语言。
Cucumber Cucumber是一个跨平台行为驱动的开发BDD工具，用于编写Web应用程序的验收测试。Cucumber可以快速、简单地建立执行程序，并允许在测试中重用代码。它支持Python、PHP、Perl、.NET、Scala、Groovy等语言。易于阅读和理解的格式的功能验证自动化。Cucumber还有一个很好的功能是规范和文档都上传到一个最新的文档库中，使不熟悉测试的业务的相关人员都能很快了解业务内容。当测试报告以业务可读较高的编写时，所有人可以轻松阅读脚本代码。
Gauge Gauge是针对Mac、Linux和Windows的开源测试自动化框架。在「TDD」和「BDD」模式上工作的人们将看到Gauge在创建有效/可执行文档方面的优势。规范：规范自动化测试是使用Markdown语言、C＃、Java和Ruby在现有的IDE（如Visual Studio、Eclipse以及Intellij IDE）中编写的。Gauge也可以通过其插件的支持来扩展，它是作为*BYOT（自带工具）*框架开发的。因此，测试人员可以使用Selenium或其他任何东西来驱动UI测试或API测试。如果团队希望采用一种可读强的，而非「BDD」的自动化方法，则应尝试使用Gauge。
Carina Carina使用流行的开源解决方案（如Appium、TestNG和Selenium）构建的，可减少对特定技术堆栈的依赖。测试人员可以测试APP（原生APP、混合APP、WebAPP）、WEB应用程序、REST服务和数据库。Carina框架支持不同类型的数据库，例如MySQL、SQL Server、Oracle、PostgreSQL，从而提供了使用MyBatis ORM框架实现DAO层的完美体验。Carina支持所有流行的浏览器和移动设备，并且在IOS/Android之间重用了高达80％的测试自动化代码。API测试基于Freemarker模板引擎，它在生成REST请求方面提供了极大的灵活性。Carina是跨平台的，可以在Unix或Windows OS上轻松运行测试用例。
总结
感谢每一个认真阅读我文章的人！！！
如果下面这些资料用得到的话可以直接拿走：
1、自学开发或者测试必备的完整项目源码与环境
2、测试工作中所有模板（测试计划、测试用例、测试报告等）
3、软件测试经典面试题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/161df0999f1d06e033f9e6fc6668dabb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c1fb2b6706e6cecab6ba0c2c8fb5487/" rel="bookmark">
			MySQL原理(八)：触发器和存储过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一篇介绍了 MySQL 的内存管理和磁盘管理，这一篇将介绍存储过程和触发器相关的内容。
存储过程 存储过程是一组为了完成特定功能的 SQL 语句集合，使用存储过程的目的在于：将常用且复杂的 SQL 语句预先写好，然后用一个指定名称存储起来，这个过程经过编译解析、执行优化后存储在数据库中，当以后需要使用这个过程时，只需调用根据名称调用即可。
优点：
复用性：可以在程序中被反复调用；灵活性：可以定义变量、使用流程控制等，相较于普通的 SQL 语句更灵活；降低网络负载：相较于将整条 SQL 语句通过网络传输再运行的方式，可以降低网络负载；高性能：存储过程执行后，会将语句编译成机器码驻留在线程缓冲区，后续调用无需再次编译执行；安全性：对于不同的存储过程，可以根据权限设置执行的用户； 缺点：
内存占用高：存储过程执行后，会将语句编译成机器码驻留在线程缓冲区，如果大量使用，会造成内存占用率高；维护性差：存储过程要求开发人员掌握相关的语法，且不支持 Debug 调试； 存储过程难以维护，同时扩展性和移植性都很差，所以一般都不会使用。但是在以下场景中可以使用存储过程：
插入测试数据；对数据做批处理操作； 定义 DELIMITER $ -- 创建的语法：指定名称、入参、出参 CREATE PROCEDURE 存储过程名称(返回类型 参数名1 参数类型1, ....) [ ...约束条件... ] -- 表示开始编写存储过程体 BEGIN -- 具体组成存储过程的SQL语句.... -- 表示到这里为止，存储过程结束 END $ DELIMITER ; DELIMITER $ 表示指定结束标识。在 MySQL 中默认是以分号 ; 作为一条语句的结束标识，因此当存储过程的过程体中，如果包含了 SQL 语句，且以分号结束时， 会认为存储过程的定义也结束了，过程体就会和结束符冲突，所以一般要重新定义结束符，例如DELIMITER $，表示以 $ 作为结束标识，只有当识别到 $ 符时，才会认为结束了。所以在结束后，需要再次把结束符改回分号，即 DELIMITER ;。
类型 存储过程支持四种类型，主要依赖于 IN、OUT、INOUT 三个关键字来区分：
定义存储过程时，没有入参也没有出参，代表无参无返回类型。定义存储过程时，仅定义了带有 IN 类型的参数，表示有参无返回类型。定义存储过程时，仅定义了带有 OUT 类型的参数，表示无参有返回类型。定义存储过程时，同时定义了带有 IN、OUT 类型的参数，或定义了带有 INOUT 类型的参数，表示有参有返回类型。 约束条件 LANGUAGE SQL：说明存储过程中的过程体是否由 SQL 语句组成；[NOT] DETERMINISTIC：说明存储过程的返回值是否为固定的，没有 NOT 表示为固定的，默认为非固定的。{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：说明过程体使用 SQL 语句的限制： NO SQL：表示当前存储过程中不包含任何 SQL 语句；CONTAINS SQL：表示当前存储过程包含 SQL，但不包含读写数据的 SQL 语句；READS SQL DATA：表示当前存储过程中包含读数据的 SQL 语句；MODIFIES SQL DATA：表示当前存储过程中包含写数据的 SQL 语句； SQL SECURITY { DEFINER | INVOKER }：说明哪些用户可以调用当前创建的存储过程： DEFINER：表示只有定义当前存储过程的用户才能调用。INVOKER：表示任何具备访问权限的用户都能调用。 COMMENT ‘…’：注释信息，可以用来描述当前创建的存储过程。 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c1fb2b6706e6cecab6ba0c2c8fb5487/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf0564da4fe60281247e072d27e73b7d/" rel="bookmark">
			如何判定IP地址合法性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IP合法性校验是开发中非常常用的，看起来很简单的判断，作用的确很大，写起来比较容易出错，今天我们来总结一下，看一下3种常用的IP地址合法性校验的方法。
IPv4的ip地址格式：（1~255）.（0~255）.（0~255）.（0~255）
正则表达式判定法
最简单的实现方法是构造一个正则表达式。判断用户的输入与正则表达式是否匹配。若匹配则是正确的IP地址，否则不是正确的IP地址。
下面给出相对应的验证ip的正则表达式：
^(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|[1-9])\.(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)\.(1\d{2}|2[0-4]\d|25[0-5]|[1-9]\d|\d)$
\d表示0~9的任何一个数字
{2}表示正好出现两次
[0-4]表示0~4的任何一个数字
| 的意思是或者
1\d{2}的意思就是100~199之间的任意一个数字
2[0-4]\d的意思是200~249之间的任意一个数字
25[0-5]的意思是250~255之间的任意一个数字
[1-9]\d的意思是10~99之间的任意一个数字
[1-9])的意思是1~9之间的任意一个数字
\.的意思是.点要转义（特殊字符类似，@都要加\\转义）
代码如下：
字符串拆解法 把ip地址当作字符串，以.为分隔符分割，进行判断
引入IPy类库 IPy库是一个处理IP比较强大的第三方库。涉及到计算大量的IP地址，包括网段、网络掩码、广播地址、子网数、IP类型等别担心，Ipy模块拯救你。Ipy模块可以很好的辅助我们高效的完成IP的规划工作。
IPy库的安装方法请根据自己的操作系统自行查找，有很多详细例子。
总结
这几种方法都能够准确的判断出ip（IP V4）地址的合法性， 正则表达式代码量少， 逻辑简单， 但是正则表达式繁琐， 字符串判定法容易理解，但是代码量大， 使用类库，判断简洁，但是需要引入额外的库。各有利弊， 使用时自行选择即可。IP地址查询，通过IP数据云进行查询。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3135dcab9bfd2be0b6ae44c61db1763/" rel="bookmark">
			mac下安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、就直接安装2、配置参考地址 3、卸载重装（连接提示2002……）的解决方法参考地址 1、就直接安装 安装完成之后，在系统偏好设置底部有mysql
2、配置 参考地址 vim /etc/profile 添加以下配置
# mysql配置 export PATH=$PATH:/usr/local/mysql/bin 输入以下命令：是配置生效
source /etc/profile 此时在终端查看 mysql 版本可以看到已经可以查到我们安装的版本了，说明环境已经配好
mysql --version 3、卸载重装（连接提示2002……）的解决方法 参考地址 1.首先我们把MYSQL卸载了（系统偏好设置–&gt;点击底部MYSQL–&gt;点击unInstall）
2.然后需要通过命令彻底删除mysql相关文件
sudo rm /usr/local/mysql sudo rm -rf /usr/local/mysql* sudo rm -rf /Library/StartupItems/MySQLCOM sudo rm -rf /Library/PreferencePanes/My* sudo rm -rf /Library/Receipts/mysql* sudo rm -rf /Library/Receipts/MySQL* sudo rm -rf /var/db/receipts/com.mysql.* 3.然后需要重启电脑
4.重新安装Mysql
5.然后打开Navicat就可以连接成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a902723ce6582cb10e2a822b2ed7e3a/" rel="bookmark">
			ajax前后台对应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、后台map2、后台list3、后台是String字段 1、后台map $.ajax({ url: contextRoot + "/mvc/wageAnnualLaborCost/archive", method: 'post', data: JSON.stringify({"costYearId": costId, "status": "3652000002"}), dataType: "json", contentType: 'application/json', success: function (data) { mini.hideMessageBox(messageid); if (data) { var flag = data.success; if (flag) { ciic.miniAlert("归档成功！", "提示", "", ""); grid.load({"costYearId": costId}); $("#archive").hide(); return; } var msg = "归档失败！" if (data.msg !== null &amp;&amp; data.msg !== "") { msg = data.msg; } ciic.miniAlert(msg, "提示", "", "fail"); } } }); @PostMapping("archive") public Result archive(@RequestBody ParmMap parmMap) { ResultVO resultVO = wageAnnualLaborCostService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a902723ce6582cb10e2a822b2ed7e3a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ec4881a8a9d9185042aca6b704e0168/" rel="bookmark">
			基于SpringBoot、Layuimini、echarts的仓库管理系统（附源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集成开发环境：IntelliJ IDEA(2021)
数据库：MySQL 8.0
技术栈：Springboot、mybatisPlus、jquery、echarts
适用于结课大作业，课程设计、项目练习、学习演示等；
目录
第1章 系统定义
第2章 需求分析
2.1 系统需求综述
2.2 数据流图
2.3 用例图
第3章 系统设计
3.1系统功能模块设计
3.2 数据库设计
第四章 功能实现
登录
第五章 代码
5.1数据表对象层
passwordDTO
5.2配置类
5.3数据访问层
5.4业务逻辑层
5.5接口控制层
5.6 工具类
LocalDateTime格式对象映射器
前端数据格式控制类
登录全局拦截器
5.7 页面代码
第1章 系统定义 仓库管理系统是一款标准化、智能化过程导向管理的仓库管理软件，它结合了众多知名企业的实际情况和管理经验，能够准确、高效地管理跟踪客户订单、采购订单、以及仓库的综合管理。使用后，仓库管理模式发生了彻底的转变。从传统的“结果导向”转变成“过程导向”；从“数据录入”转变成“数据采集”，同时兼容原有的“数据录入”方式；从“人工找货”转变成了“导向定位取货”；同时引入了“监控平台”让管理更加高效、快捷。条码管理实质是过程管理，过程精细可控，结果自然正确无误。
第2章 需求分析 2.1 系统需求综述 1. 用户登录：
用户登录模块用于管理员、老师、学生三种用户的登录。登录时需要验证用户的账号、工号、学号及其密码，此时需要与数据库中的用户登录信息进行比较，如果与数据库表中数据一致，则进入对应的系统中，否则，提示用户名或密码错误。
2. 员工信息管理：
员工信息管理模块主要是管理员对于员工信息的管理，管理员可以增加员工信息，其中学生的用户名是唯一，不可重复。还可以通过员工用户名、昵称进行查询。
3. 入库信息查询：
入库信息查询模块是针对管理员和员工对入库信息的查询，管理员和员工可以根据自己的查询的需要，根据入库商品的商品名称、型号、存放位置来进行对需要商品信息的查询。
4. 出库信息查询：
出库信息查询模块是针对管理员和员工对入库信息的查询，管理员和员工可以根据自己的查询的需要，根据出库商品的商品名称、型号、存放位置来进行对需要商品信息的查询。
2.2 数据流图 1. 系统总流图，主要权限为查看入库信息、打印入库单据、查看出库信息、打印出库单据。数据流图如图2-1所示：
图2-1 系统总数据流图
2. 出库信息流图，主要权限为商品出货、打印出货单据。数据流图如图2-2所示：
图2-2 出库信息数据流图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ec4881a8a9d9185042aca6b704e0168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1de08c1bff47f2e0769742a6d8e229d/" rel="bookmark">
			Django解决AttributeError: ‘tuple‘ object has no attribute ‘startswith‘问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
问题：AttributeError: 元组对象没有属性 'startswith'
报错代码：
操作代码：
解决方案：
问题：AttributeError: 元组对象没有属性 'startswith' 我在 settings.py里面加了
STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static') ] 之后Django 就无法启动
报错代码： /usr/local/bin/python3.6 /Users/wangxianyun/Desktop/Django/BBS/manage.py runserver 8000 Watching for file changes with StatReloader Performing system checks... Exception in thread django-main-thread: Traceback (most recent call last): File "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/threading.py", line 916, in _bootstrap_inner self.run() File "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/threading.py", line 864, in run self._target(*self._args, **self._kwargs) File "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/django/utils/autoreload.py", line 64, in wrapper fn(*args, **kwargs) File "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/django/core/management/commands/runserver.py", line 118, in inner_run self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c1de08c1bff47f2e0769742a6d8e229d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26ca2985f62840af88716c6612f6aca5/" rel="bookmark">
			服务器硬件及RAID配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 RAID磁盘阵列 独立冗余磁盘阵列:
RAID(磁盘阵列)是一种通过将多个硬盘驱动器组合起来以提供更高可靠性和性能的技术。它将多个硬盘驱动器组合在一起，以形成单个逻辑驱动器。
RAID通常用于服务器和数据
存储系统，以提供更高的数据可用性、更高的性能或两者兼而有之。
RAID级别
组成磁盘阵列的不同方式称为RAID级别 (RAID Levels)
常用的RAID级别
RAIDO、 RAID1、 RAID5、 RAID6、 RAID1+0等
raid0:1、读写性能是高的 2、没有数据备份功能 3、最少2块 偶数块
raid1:1、互为备份(镜像存储) 2、写性能差一些，读性能一般3、高可用，换一块不影数据的 4、硬盘偶数
raid5:1、硬盘数量n&gt;=3,2、读性能强，写性能一般 3、可以坏一块硬盘，不影响业务 4、数据的校验机制
raid6:1、硬盘数要大于等于4，最少4个盘 2、奇偶校验，校验位 3、谈性能和raid5相当，但是写性能比raid5更差 4、他可以坏两块盘，但是不影响业务
raid1+0:1、磁盘数N大于等于4，只有一半的磁盘利用率 2、读性能高，写性能档差 3、理论上可以坏三块，分许两个基组中各坏一
奇偶校验 奇偶校验是一种简单的错误检测和纠正技术
简单来说奇偶校验中的0和1 表示校验位，用来使字节中的所有位中1的数量偶数或者奇数
是用来检测数据位是否相同
raid总结 raid级别硬盘数量磁盘利用率读性能写性能高可用性raid0 N N 100% 高 高 无radi1 N(偶数) N/2 50% 低 低 中等
raid5 N &gt;=3 (N-1)/N 高 低 高raid6 N&gt;=4（N-2)/N 高 低 很高raid1+0 N&gt;=4(偶数)N/2 50% 高 中等 中等 特点 raid0：追求最大容量和读写速度，坏一块，数据全部异常
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26ca2985f62840af88716c6612f6aca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/786949e4b838e4d5647d7b6b71dc4f1d/" rel="bookmark">
			StringUtils工具类常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		StringUtils类在操作字符串是安全的，不会报空指针异常，也正因此，在操作字符串时使用StringUtils相比使用原生的String会更加安全。
一、判空
StringUtils提供常用的判断空字符串有两个方法：isEmpty和isBlank，这两者的有何区别呢，直接看源码：
// isEmpty public static boolean isEmpty(String str) { return str == null || str.length() == 0; } // isBlank public static boolean isBlank(String str) { int strLen; if (str == null || (strLen = str.length()) == 0) { return true; } for (int i = 0; i &lt; strLen; i++) { if ((Character.isWhitespace(str.charAt(i)) == false)) { return false; } } return true; } // isNotEmpty public static boolean isNotEmpty(String str) { return !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/786949e4b838e4d5647d7b6b71dc4f1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9533038d563799bd9504b4c0ddce2835/" rel="bookmark">
			Keil pack官方下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Keil pack官方下载：
https://www.keil.com/dd2/pack/#!#third-party-download-dialog
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7153ace4232f0f58c99309b8d88e37e2/" rel="bookmark">
			QGIS - 帮助文档汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ref
[1] Welcome to the QGIS project!
[2] QGIS Tutorials and Tips — QGIS Tutorials and Tips
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b99ddc386759b9a64fe1578be5755f7/" rel="bookmark">
			【error】dubbo服务注册到zookeeper非常极其慢（一个服务注册了1小时左右TAT）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 场景介绍问题描述原因分析解决方案联系自身 场景介绍 本人项目由多个service服务构成。多个service同时注册到一个zookeeper。
问题描述 上午时，代码运行一切正常。新写了几行代码，打算重新运行调试时，有几个服务注册巨慢，慢到根本跑不起来，但其他服务是正常的。
原因分析 因为使用的是同一zookeeper，且有的服务注册正常，部分服务注册很慢，所以排除是zookeeper的问题。网上找到一个解决方案说：取消断点。
解决方案 取消所有断点。
联系自身 本人的解决方案是删掉所有断点。删掉断点后，注册的就很快了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41d119998f5acdf741a87ba969e6b125/" rel="bookmark">
			Qt多线程实现网络发送文件功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		客户端给服务器发送文件，服务器进行接收文件的简单操作
1. 服务器 1. 创建QTcpServer 类的对象
QTcpServer * server = new QTcpServer(this); 2. 进行监听
bool QTcpServer::listen(const QHostAddress &amp;address = QHostAddress::Any, quint16 port = 0) 3. 通过接收 QTcpServer 发出的 newConnection 的信号，进行下一步操作
[signal] void QTcpServer::newConnection() 4. 通过调用 nextPendingConnection 方法获取套接字
// 通过 this-&gt;m_server 调用 nextPendConnection QTcpSocket * socket = server-&gt;nextPendingConnection(); 5. 接收客户端发来是消息 通过 [signal] void QIODevice::readyRead() 信号
6.客户端下线 [signal] void QAbstractSocket::disconnected() 信号 表示
创建一个子线程类，继承 QThread ,重写父类的run() 方法
在run方法中，创建文件，接收客户端发的文件写进创建的文件中；
接收文件时，要先获取第一次客户端发来的文件大小；
获取客户端第一次发来的文件大小
// 进行接收数据的时候，需要知道客户端发来的文件的大小 // 先将客户端第一次发来的数据的大小读取出来 static int count = 0; // 判断是否是客户端第一次发来的数据 static int total = 0; // 记录文件的大小 if(count == 0) { this-&gt;m_tcp-&gt;read((char*)&amp;total, 4); // 获取文件大小 } 创建子线程类 并启动子线程
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41d119998f5acdf741a87ba969e6b125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/230da8e32af10f2db7265e9106367441/" rel="bookmark">
			Http知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、http协议
目前存在HTTP1.1（当前广泛运用的版本）、HTTP2.0和HTTP3.0协议，有以下的优点和缺点
1. HTTP1.1
优点：默认支持长连接，即在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟；
缺点：首部是明文的（cookies、token等之类），没有进行压缩；可能会造成http对头阻塞：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。
2. HTTP2.0
优点：
多路复用：所有的相同域名请求都通过同一个 TCP 连接并发完成，减少了等待时间；首部压缩，报文变为二进制；提供更快的传输速度；支持服务器推送，可以将客户端所请求的相关资源推送给客户端，减少客户端发送请求的次数和等待时间。（比如浏览器只请求了index.html，但是服务器把index.html、style.css、example.png全部发送给浏览器。） 缺点：存在兼容性问题和安全性问题
3. HTTP3.0：基于QUIC和UDP协议，提高了通信的平均速度
二、nginx配置http2.0
升级到Http2.0会使某些请求响应速度变快
nginx在nginx.conf配置http2.0
listen 443 ssl http2; 二、https
是在http协议的基础上用TLS/SSL进行加密（对称加密：各自都有公钥私钥，非对称加密：客户端有公钥，服务端有公钥和私钥）。SSL证书是保存在源服务器的数据文件，需要向CA申请，包括了特定的公钥私钥等信息，可以确保客户端和服务器身份的真实性和可信度。
三、http缓存：为了减少重复的网络请求，一般js、css、image会被缓存
1. 强制缓存：第一次请求，服务器会返回Cache-Control字段，告诉浏览器最大缓存过期时间max-age或者no-cache，比如地图请求max-age:0，public（可以被任意请求缓存），no-cache(可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）)
2. 协商缓存：第一次请求，服务器会返回Last-Modified（资源的最后修改时间）和ETag（资源的唯一标识，字符串），浏览器再次请求的时候会带上if-Modified-Since或if-None-Match去请求，服务器会进行比较，如果一致则304，从客户端缓存获取资源，如果不一致，则返回200，带上新的标识和资源；优先使用Etag，Last-Modified只能精确到秒，但是很多请求可能是毫秒级的
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4f5115e5cb5dc917ed0ae7ec644814e/" rel="bookmark">
			Python 3.x | 史上最详解的 导入（import）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如需转载请注明出处。
win10+Python 3.6.3
一旦使用多层文件架构就很容易遇上import的坑！哈哈。
一、理解一些基本概念
1、模块、包
**模块 module：**一般情况下，是一个以.py为后缀的文件。其他可作为module的文件类型还有".pyo"、".pyc"、".pyd"、".so"、".dll"，但Python初学者几乎用不到。
module 可看作一个工具类，可共用或者隐藏代码细节，将相关代码放置在一个module以便让代码更好用、易懂，让coder重点放在高层逻辑上。
module能定义函数、类、变量，也能包含可执行的代码。module来源有3种：
①Python内置的模块（标准库）；
②第三方模块；
③自定义模块。
包 package： 为避免模块名冲突，Python引入了按目录组织模块的方法，称之为 包（package）。包 是含有Python模块的文件夹。
当一个文件夹下有 init .py时，意为该文件夹是一个包（package），其下的多个模块（module）构成一个整体，而这些模块（module）都可通过同一个包（package）导入其他代码中。
其中 init .py文件 用于组织包（package），方便管理各个模块之间的引用、控制着包的导入行为。
该文件可以什么内容都不写，即为空文件（为空时，仅仅用import [该包]形式 是什么也做不了的），存在即可，相当于一个标记。
但若想使用from pacakge_1 import *这种形式的写法，需在 init .py中加上： __all__= [‘file_a’, ‘file_b’] ，其中 #package_1下有file_a.py和file_b.py，在导入时 init .py文件将被执行。
但不建议在 init .py中写模块，以保证该文件简单。不过可在 init .py导入我们需要的模块，以便避免一个个导入、方便使用。
其中，__all__ 是一个重要的变量，用来指定此包（package）被import *时，哪些模块（module）会被import进【当前作用域中】。不在__all__列表中的模块不会被其他程序引用。可以重写__all__，如__all__ = [‘当前所属包模块1名字’, ‘模块1名字’]，如果写了这个，则会按列表中的模块名进行导入。
在模糊导入时，形如from package import *，*是由__all__定义的。
精确导入，形如 from package import *、import package.class。
path 也是一个常用变量，是个列表，默认情况下只有一个元素，即当前包（package）的路径。修改 path 可改变包（package）内的搜索路径。
当我们在导入一个包（package）时（会先加载 init .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c4f5115e5cb5dc917ed0ae7ec644814e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc0bb49951658e88494fec5bf86655de/" rel="bookmark">
			pip的常用操作命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 忽略已安装的库（以llvmlite为例）
pip install xxx --ignore-installed llvmlite 2. 错误 - AttributeError: 'int' object has no attribute 'endswith'
解决方案：
常见原因因为使用的pip为pip2，可以使用 pip -V 查看pip版本，必要时使用 pip3
3. 错误 - ImportError: cannot import name 'sysconfig'
解决方案：
sudo gedit /etc/apt/sources.list # 追加源 deb http://cn.archive.ubuntu.com/ubuntu bionic main multiverse restricted universe deb http://cn.archive.ubuntu.com/ubuntu bionic-updates main multiverse restricted universe deb http://cn.archive.ubuntu.com/ubuntu bionic-security main multiverse restricted universe deb http://cn.archive.ubuntu.com/ubuntu bionic-proposed main multiverse restricted universe # 保存后运行 sudo apt-get update sudo apt-get install python3-pip 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc0bb49951658e88494fec5bf86655de/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/150/">«</a>
	<span class="pagination__item pagination__item--current">151/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/152/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>