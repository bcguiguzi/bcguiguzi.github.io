<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f7402c9073c4ee98f1aeca2b4d86b40/" rel="bookmark">
			jsoup的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文在写作过程中参考了官方文档，传送门。
一、jsoup概述 jsoup 是一款基于 Java 的HTML解析器，它提供了一套非常省力的API，不但能直接解析某个URL地址、HTML文本内容，而且还能通过类似于DOM、CSS或者jQuery的方法来操作数据，所以 jsoup 也可以被当做爬虫工具使用。
二、相关概念简介 Document ：文档对象。每份HTML页面都是一个文档对象，Document 是 jsoup 体系中最顶层的结构。Element：元素对象。一个 Document 中可以着包含着多个 Element 对象，可以使用 Element 对象来遍历节点提取数据或者直接操作HTML。Elements：元素对象集合，类似于List&lt;Element&gt;。Node：节点对象。标签名称、属性等都是节点对象，节点对象用来存储数据。类继承关系：Document 继承自 Element ，Element 继承自 Node。一般执行流程：先获取 Document 对象，然后获取 Element 对象，最后再通过 Node 对象获取数据。
三、获取文档（Document） 获得文档对象 Document 一共有4种方法，分别对应不同的获取方式。
正式开始之前，我们需要导入有关 jar 包。
&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.15.1&lt;/version&gt; &lt;/dependency&gt; –
3.1）从URL中加载文档对象（常用） 使用 Jsoup.connect(String url).get()方法获取（只支持 http 和 https 协议）:
Document doc = Jsoup.connect("http://csdn.com/").get(); String title = doc.title(); System.out.println(title); connect(String url)方法创建一个新的 Connection并通过.get()或者.post()方法获得数据。如果从该URL获取HTML时发生错误，便会抛出 IOException，应适当处理。
Connection 接口还提供一个方法链来解决特殊请求，我们可以在发送请求时带上请求的头部参数，具体如下：
Document doc = Jsoup.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f7402c9073c4ee98f1aeca2b4d86b40/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d0a7ad47ec960b4680b6ba992f5223fa/" rel="bookmark">
			Python 批量处理 ICESat-2 ATL08 数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		改编内容，原文链接：​​​​​​ICESat2学习笔记10 ：python批量读取处理ATL08数据_晚秋10的博客-CSDN博客
如果报错KeyError: 'Unable to open object (component not found)'，请先检查h5存放路径是否只包含源数据*.h5。
代码包括了简单数据筛选以及批量导出csv，代码如下：
import pandas as pd import h5py import os import numpy as np def read_atl08(fname): # Each beam is a group, strong beams are selected only here group = ['/gt1r', '/gt2r', '/gt3r'] # Loop trough beams for k, g in enumerate(group): with h5py.File(fname, 'r') as fi: # Define the variables and construction, open the h5 files and check it out lat = fi[g + '/land_segments/latitude'][:] lon = fi[g + '/land_segments/longitude'][:] h_canopy = fi[g + '/land_segments/canopy/h_canopy'][:] h_canopy_uncertainty = fi[g + '/land_segments/canopy/h_canopy_uncertainty'][:] result = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d0a7ad47ec960b4680b6ba992f5223fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15c64bca885febeb7a17e833bfbd1d8/" rel="bookmark">
			TOMCAT下载及环境配置并启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网下载最新版https://tomcat.apache.org/
下载完成后解压缩
在bin目录下找到startup.bat文件，复制该文件路径
win+R打开cmd,粘贴该文件路径并运行。然后大概率会报错
The CATALINA_HOME environment variable is not defined correctly This environment variable is needed 这是由于未设置环境变量。
右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;添加变量
在系统变量中添加上面两个变量，值为tomcat的路径。
并修改PATH变量，添加下面的值
%CATALINA_HOME%\lib;%CATALINA_HOME%\bin 在这里一定要注意路径正确，前后不能多或少符号，前面不能有空格，后面不能加 \ ！
然后重新运行发现报错变化:
Neither the JAVA_HOME nor the JRE_HOME environment variable is defined
At least one of these environment variable is needed to run this program
这是由于没有配置Java的JDK环境变量，且运行程序中也未声明路径。所以需要在环境变量中添加
变量值为JDK路径。 同样修改PATH变量，加入以下值
%Java_Home%\bin;%Java_Home%\jre\bin 如果至此还不能运行成功，在bin目录找到并编辑setclasspath.bat文件，在图中位置添加JDK路径
set JAVA_HOME=D:\Program Files\Java\jdk-18.0.2.1 等号后面为JDK路径。
之后再次运行即可成功。
打开浏览器访问：http://localhost:8080/ ，得到如下界面即成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/908689c84b99a873223f3a0838c27168/" rel="bookmark">
			[网站]node.js如何在云服务器上搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//下载node.js v14.5.0的压缩包 wget https://nodejs.org/dist/v14.5.0/node-v14.5.0-linux-x64.tar.xz //解压 tar xvf node-v14.5.0-linux-x64.tar.xz //建立软连接 ==&gt;　软连接就是起一个别名的意思　就像我们会有一个小名或者外号差不多 ln -fs /root/node-v14.5.0-linux-x64/bin/node /usr/local/bin/node ln -fs /root/node-v14.5.0-linux-x64/bin/npm /usr/local/bin/npm ／／检查版本号　最重要的作用是看看是否配置成功 node -v ／／检查版本号　最重要的作用是看看是否配置成功 npm -v ⬆⬆⬆⬆⬆⬆以上按着敲完就 如果显示版本号就代表配置成功咯,
⬇⬇⬇⬇⬇⬇以下就是为啥我在配置成功之前经历的九九八十一难的心路历程,:
说实在的这个环境的配置,我花了3,4天,当然不是真的一天全部时间都在搞,因为课程也是要安排时间的, 我为啥会卡这么久, 就在于几点:
第一: 我其实很早就配置好了, 不过版本号比较低, 我就想怎么可以切换,然后查了之后, 有说借助 n 来实现的, 我也不知道自己咋想的, 就感觉也不用n不n了, 直接删了重新配置不就好了嘛, 然后就开始了漫长的配置旅程, 因为我第一次配置成功就花了一天不到, 我就感觉自己接下来也很快就可以配置成功, 可事实, 直接让我多次修心, 有种自己快要进入 "胸有激雷, 而面如平湖者"的心境了~
第二: 配置的时候请务必看好下载的安装包的后缀名( 当然我上方的压缩包后缀名没问题的哦), 是 .xz 还是 .gz兄弟们, 写到这里我都绷不住了阿.... 就是因为这个后缀,给我恶心坏了~
第三: 软连接卡我了很久, 其实很多朋友们查到的可能是 ln -s, 为啥我是 ln -fs是直接避免了我们已经存在, ln -fs是直接覆盖了之前的, 直接省去了一个这个报错, 小伙伴也可以自己试下, 看看是不是这样哦~ 第四: 改BUG的时候要有个好的心态, 告诉自己我一定能给它改出来, 我一定可以,我一定可以,不要总是问别人, 这样到后面就是 这种"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/908689c84b99a873223f3a0838c27168/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eee9c1b73bc9a77e14320521df77777/" rel="bookmark">
			百余行VUE代码实现贪吃蛇小游戏简易版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天使用qt qwidget实现了一个贪吃蛇小游戏后，突然想到vue好像还没有写过贪吃蛇的小demo，所以就花了一点时间写了一个 话不多说 上代码。
&lt;template&gt; &lt;div class="map"&gt; &lt;span v-for="(item, index) in map" :key="index" :class="{ base: true, header: index == 0, body: index != 0, }" :style="{ left: item.x * 10 + 'px', top: item.y * 10 + 'px', }" &gt; &lt;/span&gt; &lt;span class="base food" :style="{ left: food.x * 10 + 'px', top: food.y * 10 + 'px', }" &gt;&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data() { return { map: [], timer: null, nowdir: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eee9c1b73bc9a77e14320521df77777/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46fe2230e3de07abf1c06045292fa05d/" rel="bookmark">
			《lwip学习6》-- ARP协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初始ARP 地址解析协议（Address Resolution Protocol， ARP）是通过解析 IP 地址得到数据链路层地址的，是一个在网络协议包中极其重要的网络传输协议，它与网卡有着极其密切的关系，在 TCP/IP 分层结构中，把 ARP 划分为网络层， 为什么呢，因为在网络层看来，源主机与目标主机是通过 IP 地址进行识别的，而所有的数据传输又依赖网卡底层硬件，即链路层，那么就需要将这些 IP 地址转换为链路层可以识别的东西，在所有的链路中都有着自己的一套寻址机制，如在以太网中使用 MAC 地址进行寻址，标识不同的主机，那么就需要有一个协议将 IP 地址转换为 MAC 地址，由此就出现了 ARP 协议， ARP 协议在网络层被应用，它是网络层与链路层连接的重要枢纽。
在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的 MAC 地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的 MAC 地址，那就需要 ARP 进行地址解析， 所谓“地址解析”就是主机在发送帧前将目标 IP 地址转换成目标 MAC 地址的过程。 ARP 协议的基本功能就是通过目标设备的 IP 地址，查询目标设备的 MAC 地址，以保证通信的顺利进行。
以太网帧结构 既然谈到 MAC 地址， 那就不得不说一下以太网帧结构了， 每个网卡都有唯一一个物理地址， 在硬件中进行数据帧传输的时候就必须有正确的目的物理地址， 例如以太网的 48位 MAC 地址就是存储在网卡内部存储器中。
以太网帧以一个 7 字节的前同步码（Preamble）字段开始。该前同步码的值都是10101010（0x55，大端模式） ； 而后紧接着一个字节的帧开始符， 其值是 10101011（0xD5，大端模式） 。前同步码字段的作用是实现物理层帧输入输出的同步， 而帧开始符表示着以太网帧的开始， 剩下的 5 个字段才是真正的以太网数据帧结构。
目标 MAC 地址（6 字节） ： 这个字段包含目标网卡的 MAC 地址， 当一个网卡收到一个以太网数据帧，如果该数据帧的目标地址是网卡自身的 MAC 地址或者是 MAC 广播地址，它都将该帧的数据字段的内容传递给网络层；如果它收到了具有任何其他 MAC 地址的帧，则将该数据帧丢弃。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46fe2230e3de07abf1c06045292fa05d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/990f6ca8d57c28c446f635f2caa0bbbf/" rel="bookmark">
			mysql慢查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、sql慢查询介绍 SQL慢查询定义:
慢查询就是那些执行慢的sql语句，包括crud（创建（Create）、更新（Update）、读取（Read）和删除（Delete）操作），一般是查询，所以称为慢查询。
如何查看哪些sql是慢查询：
开启慢查询⽇志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数 据库系统的性能。
顾名思义，慢查询⽇志中记录的是执⾏时间较⻓的query，也就是我们常说的slowquery，通过 设–log-slow-queries[=file_name]来打开该功能并设置记录位置和⽂件名。
慢查询⽇志采⽤的是简单的⽂本格式，可以通过各种⽂本编辑器查看其中的内容。
其中记录了语句执⾏的时刻，执 ⾏所消耗的时间，执⾏⽤户，连接主机等相关信息。
MySQL 还提供了专⻔⽤来分析满查询⽇志的⼯具程序 mysqlslowdump，⽤来帮助数据库管理⼈员解决可能存在的性能问题。
二、配置Mysql慢查询 2.1 查看慢查询相关参数 查询慢查询的开启状态及日志位置
mysql&gt; show variables like 'slow_query%'; +---------------------+-------------------------------------------------+ | Variable_name | Value | +---------------------+-------------------------------------------------+ | slow_query_log | OFF | | slow_query_log_file | /var/lib/mysql/iz2ze2w3v37sit3vf71kuez-slow.log | +---------------------+-------------------------------------------------+ 2 rows in set (0.00 sec) slow_query_log 慢查询开启状态
slow_query_log_file 慢查询⽇志存放的位置
（这个⽬录需要MySQL的运⾏帐号的可写权限，⼀般设置为MySQL的 数据存放⽬录）
查询慢查询时长
long_query_time 查询超过多少秒才记录，默认为10秒
mysql&gt; show variables like 'long_query_time'; +-----------------+-----------+ | Variable_name | Value | +-----------------+-----------+ | long_query_time | 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/990f6ca8d57c28c446f635f2caa0bbbf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/935ac77b4397b2e00aaca85249434de2/" rel="bookmark">
			移动端布局之postcss-px-to-viewport
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主角是谁 在今天这篇文章中，我并不会在这里讲一些移动端视口的概念，包括物理像素和逻辑像素，理想视口，dpr等等等等，我只介绍这样一种非常不错的移动端适配方案：post-css-to-viewport，如果我说这种方案能解决98%以上的移动端布局痛点，我想整个掘金，应该没有人会反驳。
痛点在哪里 在之前有一种流行已久的移动端适配方案，那就是rem，我想下面这两句代码，有不少老移动端都不会陌生：
const deviceWidth = document.documentElement.clientWidth || document.body.clientWidth; document.querySelector('html').style.fontSize = deviceWidth / 7.5 + 'px'; 复制代码 没错，在那个移动端UI稿尺寸为750*1334满天飞的时代，这两句代码确实给开发者带来了很大的方便，这样设置根font-size后，px和rem的转换比例成了100, 为比如UI稿一个长宽分别为120px*40px，那么开发者对应的写成1.2rem*0.4rem就可以了
这种换算已经是颇为方便，但是并非所有的项目都能这样去设置一个方便换算的比例系数，当比例系数为100时，小数点往前面挪两位就行了，然而有的项目设置的换算系数千奇百怪，有50的，有16的，很多已经严重超出口算力所能及的范畴了。所以后来诞生的px-to-rem或者px2rem就是为了解决这个问题
人们希望有这样一种方案... 首先，无论换算方不方便，我都不想换算（就是这么懒🤭），我也不想去操心什么转换系数其次，有些属性或者类选择器我不想进行转换css代码要足够简洁，我只希望看到一种单位，那就是px 两种方案都很好，但我偏爱后者 第一种方案是lib-flexible+postcss-pxtorem，在相当长一段时间里，这两个插件搭配都是解决移动端布局的神器，lib-flexible是阿里手淘系开源的一个库，用于设置font-size，同时处理一些窗口缩放的问题。其中一位主要贡献者正是阿里的大神winter。
直到2020年的今天，我仍然可以说，lib-flexible+postcss-pxtorem是解决移动端布局的主流，但是我们可以好好想一想，它是否有什么不足？
从我个人来说，我认为它主要有以下两个不足：
两个插件需要配套使用，而且rootValue设置的值不好理解rem是相对于html元素字体单位的一个相对单位，从本质上来说，它属于一个字体单位，用字体单位来布局，并不是太合适 翻阅其github地址，可以看到这样一段有意思的话：
第二种方案是viewport，postcss-px-to-viewport就是这样一款优秀的插件，它解决了以上提到的痛点，也满足以上提到的理想要求。它将px转换成视口单位vw，众所周知，vw本质上还是一种百分比单位，100vw即等于100%，即window.innerWidth
在vue项目中引入试试（更新于2021年9月27日） 创建一个vue项目并安装该插件 vue create mobile-px-demo cd mobile-px-demo &amp;&amp; yarn add postcss-px-to-viewport -D 复制代码 以下是我的创建配置，本机node版本为v14.16.1：
在项目根目录下添加.postcssrc.js文件添加如下配置： module.exports = { plugins: { autoprefixer: {}, // 用来给不同的浏览器自动添加相应前缀，如-webkit-，-moz-等等 "postcss-px-to-viewport": { unitToConvert: "px", // 要转化的单位 viewportWidth: 750, // UI设计稿的宽度 unitPrecision: 6, // 转换后的精度，即小数点位数 propList: ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/935ac77b4397b2e00aaca85249434de2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28b9ee08f04ef432f02005b8f068ed4d/" rel="bookmark">
			Linux文件权限：特殊权限、权限属性、权限掩码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 特殊权限概述取值作用 SUID概述授权方式测试案例SUID总结 SGID概述授权方式测试案例SUID总结 SBIT(sticky)概述授权方式测试案例SUID总结 权限属性概述lsattr、chattr 权限掩码umask概述umask计算修改umask值 特殊权限 概述 Linux系统共12位权限位，基本权限位有9位，但还有3位特殊权限位，
基本权限：UGO上的读写执行权限
[root@cys ~]# ll test.txt -rwxrwxrwx. 1 root root 206 9月 28 15:18 test.txt 特殊权限：UGO上的特殊权限
当UGO对文件具有执行权限时 [root@cys ~]# ll test.txt -rwsrwsrwt. 1 root root 206 9月 28 15:18 test.txt #UGO对象的执行权限位上分别为s、s、t 当UGO对文件具没有有执行权限时 [root@cys ~]# ll test.txt -rwSrwSrwT. 1 root root 206 9月 28 15:18 test.txt #UGO对象的执行权限位上分别为S、S、T 取值 r：读=4w：写=2x：执行=1SUID：4000SGID：2000SBIT：1000 作用 SUID 用户设置位 配置在u位 SGID 组设置位	配置在g位 SBIT 粘滞位 配置在o位 SUID
主要是对命令，或者二进制文件，以该二进制文件的属主权限来执行该文件 命令：passwd
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28b9ee08f04ef432f02005b8f068ed4d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d5ec7d811851cec71f59fe83b0184d/" rel="bookmark">
			Docker的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Docker的基本组成
三要素：
镜像：
容器：
仓库：
二、Docker的平台架构
三、Docker安装步骤
一、Docker的基本组成 三要素： 镜像： Docker的镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以创建很多容器。他也相当于是一个root文件系统。比如官方镜像Centos7就包含了一套完整centos最小系统的root文件系统。就相当于容器的源代码，docker镜像文件类似于JAVA的类模板，而docker容器实例类似于java中new出来的实例对象。
容器： 从镜像容器角度
可以把容器看做是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序
从面向对象角度
Docker利用容器独立运行的一个或一组应用，应用程序或服务运行在容器里面，容器就类似于一个虚拟化的运行环境，容器是镜像场景的运行实例。镜像是静态的定义，容器是镜像运行时的实体。容器为镜像提供了一个标准的和隔离的运行环境，他可以被启动，开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。
仓库： 仓库是集中存放镜像文件的场所。仓库分为公开仓库和私有仓库；最大的公开仓库是 Docker Hub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云等
Docker通过客户端可以连接到主机的docker引擎的后台程序daemon，运行时，如果本地有镜像，可以通过镜像直接运行一个容器，如果本地没有，docker引擎程序则去远程仓库上（docker hub）拉取一个镜像。
Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。类似于MySQL；主机上启动之后，服务中会出现一个MySQL进程（类比于docker守护进程），我们使用Navicat客户端（类比于docker客户端）连接到数据库；执行SQL脚本生成SQL语句（类比于docker使用镜像生成各种容器）。
总结：Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例。image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。
二、Docker的平台架构 Docker 是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。
1.用户是使用Docker Client与 Docker Daemon建立通信，并发送请求给后者。
2.Docker Daemon作为Docker架构中的主体部分，首先提供 Docker Server的功能使其可以接受Docker Client 的请求。
3.Docker Engine执行Docker 内部的一系列工作，每一项工作都是以一个Job 的形式的存在。
4.Job 的运行过程中，当需要容器镜像时，则从Docker Registry中下载镜像，并通过镜像管理驱动Graph driver将下载镜像以Graph的形式存储。
5.当需要为Docker创建网络环境时，通过网络管理驱动Network driver创建并配置Docker容器网络环境。
6.当需要限制Docker容器运行资源或执行用户指令等操作时，则通过Exec driver来完成。
7.Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作。
三、Docker安装步骤 1.确认Centos7及以上版本
2.安装gcc编译环境相关
[root@localhost ~]# yum install gcc -y [root@localhost ~]# yum install gcc-c++ -y 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d5ec7d811851cec71f59fe83b0184d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be23c4fbe0378d5e99fc344219c1798c/" rel="bookmark">
			【Java/补题/牛客/ACM赛制】2021年ICPC国际大学生程序设计竞赛暨陕西省第九届大学生程序设计竞赛（正式赛）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目链接知识一览题目列表快输C - GCD（数论分块） 题目链接 2021年ICPC国际大学生程序设计竞赛暨陕西省第九届大学生程序设计竞赛（正式赛）
知识一览 01-数论分块
题目列表 快输 static class FastReader{ BufferedReader br; StringTokenizer st; String tmp; public FastReader() { br=new BufferedReader(new InputStreamReader(System.in)); } String next() { while(st==null||!st.hasMoreElements()) { try { st=new StringTokenizer(br.readLine()); }catch(IOException e) { e.printStackTrace(); } } return st.nextToken(); } int nextInt() { return Integer.parseInt(next()); } long nextLong(){return Long.parseLong(next());} String nextLine() { String str=""; try { str=br.readLine(); }catch(IOException e) { e.printStackTrace(); } return str; } boolean hasNext(){ if(st!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be23c4fbe0378d5e99fc344219c1798c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6673d4e3cd2edad1c32ecb21842b7d4/" rel="bookmark">
			C&#43;&#43;数据结构查找——哈希表（包含GIF和相关图示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、介绍
哈希表(Hash Table)
1.定义
2.举例
3.本质
哈希冲突（Hash Collision)
1.定义
2.举例
二、哈希函数的构造
直接定址法
i.举例1
ii.举例2
iii.总结
数字分析法
i.举例
ii.总结
除余法与平方法
其他方法
三、处理哈希冲突
链地址法：
开放寻址法：
四、STL库中的哈希表使用
五、哈希表的实现
1.链地址法
算法实现
代码执行结果
全部代码
2.开放寻址法
算法实现
全部代码
代码执行结果
六、总结
一、介绍 哈希表(Hash Table) 1.定义 "散列表"也叫哈希表，是一个 根据键值(Key)直接访问在内存中的存储位置 的数据结构。哈希表通过一个哈希函数(散列函数)，将键值(Key)映射为哈希表中的一个位置，我们可以通过这个位置来访问记录。
2.举例 为了方便理解，在另外一篇文章我看到一个很好的例子，以下加以阐述：
example：有一天你想给李四(键值Key)打电话，但是李四的电话你忘记了，这个时候你打开电话簿,电话薄里储存了人名首字母以及首字母对应的电话号码的页数的目录(哈希表)，这个目录是由你所确定的一个法则得来的：将人名的姓转换为英文再转换为单个首字母(如王二→Wang→W),这个法则就是哈希函数，通过目录你找到了李四所对应的首字母L,在首字母L的后面你找到了李四的电话所在的页数(位置),翻到该页你找到了李四的电话(记录)，然后你就可以给李四打电话了。
💡tips：为什么叫哈希表呢？因为散列表的英文就是Hash Table,谐音过来就是哈希表，为了方便起见，本文将直接称呼散列为哈希。
3.本质 哈希表的底层结构是数组，哈希表就是基于数组实现的一个数据结构，其意义在于可以根据一个键值Key就可以查找到一个数据在数组中的位置或者下标，从而加快查找的速度。我们可以知道，要想在一个数组里面查找我们想要的元素，我们可以利用顺序查找、折半查找、分块查找等方法（想知道这些方法的实现可以看我的另外一篇文章：查找算法：顺序查找、折半查找、分块查找
但是这些方法都远不及我们的这个哈希表，只需要一个键值就可以直接查找到该数据，因此查找速度十分之快。
哈希冲突（Hash Collision) 1.定义 在理想的情况下，每一个Key通过哈希函数的运算后得出来的值都是不一样的，但现实中，往往会出现两个不同的关键字经过同一个哈希函数的运算后得出来的值相同，这种情况就称之为哈希冲突。
2.举例 假如我们的电话簿有张三和张六这两个人，那么按照我们的哈希函数，也就是法则：取名字的姓的英文并转换为首字母，这个时候张三和张六这两个关键字经过哈希函数的处理之后都是Zhang,指向的都是存储了地址为0的一个数据域，这就造成了哈希冲突。
二、哈希函数的构造 tips:下面的图的数据都是虚构的，目的在于理解各个方法
哈希函数的构造方法有很多种，评价一个哈希函数的好坏我们可以通过不同关键字的冲突次数来评估，一个好的哈希函数产生哈希冲突的次数低，完全不产生哈希冲突的哈希函数也叫完美哈希函数，另外，一个好的哈希函数不会有过于复杂的计算，也就是说，如果你将关键字转换为对应地址的时间过长，那么我们查找数据的时候也会十分慢，因此一个好的哈希函数既要计算快，又要不冲突
直接定址法 这种方法适用于关键字简单且关键字连续的情况
i.举例1 如下图是一个国家不同年龄对应的不同人数的部分数据，我们要通过年龄来得到这个年龄的元素，我们观察年龄可以发现是从0-n岁的，恰好可以对应于一个连续的存储空间，因此我们可以直接把年龄作为地址，也就是:
Hashfunction(age)=age
address ( peoplenumber ) =Hashfunction ( age )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6673d4e3cd2edad1c32ecb21842b7d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7f534c172f8c20730ae9057354b0ab5/" rel="bookmark">
			气象数据下载网站（存档）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.cnblogs.com/icydengyw/p/12664027.html
1、http://weather.uwyo.edu/upperair/seasia.html
需要提前查明站点ID
2、https://rp5.ru/
3、http://www.meteomanz.com/
2005年至今，包含原始报文，数据十分详细
4、http://data.cma.cn/
中国国家气象局官网，只能下近7天和2010年前的数据，不好用
5、http://www.tutiempo.net/en/Climate/
没用过
6、https://www.ncei.noaa.gov/data/global-hourly/
气象数据要素包括1942年07月以来气温、气压、露点、风向风速、云量、降水量。气象数据来自美国国家气候数据中心（NCDC），每年更新。
时间精度：近年的数据大多为3小时数据，少量站点有1小时数据。 站点数量：近年为400多个。
按年打包文件china_isd_lite_****.zip解压后是几百个站点数据文件，每个文件是单个站点全年的数据。文件名如“552990­99999­2000”，第1段数字是站点ID，第3段数字是年份。
数据格式ISD­Lite，是简化的ISD（Integrated Surface Data）数据。每列固定宽度，非常易于程序解析，也可直接当做“空格分隔的CSV”使用。具体每列的含义及数据格式见isd­lite­format.txt，有详细解释。时间是GMT时间。站点ID和站点名、经纬度的对应关系见isd­history.csv，该列表各列含义见isd­history.txt文件开头。isd­history.csv里包含了所有用到过的站点，包括大量现在已经不在使用的。
经纬度是WGS­84坐标系。
7、https://rda.ucar.edu/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b5f26fea754f06e2683d8b42e04296/" rel="bookmark">
			Jetson nano编译第一个驱动程序，挂载并运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		编译第一个驱动程序，挂载并运行 1. 交叉编译编译内核源码什么是交叉编译？编写驱动，为啥要编译内核源码？具体步骤：1. 1 下载Jetson nano的源码包和交叉编译器1.2 配置交叉编译环境1.3 编译内核源码 2. 装载/烧录编译好的文件2.1 EMMC烧录2.2 装载内核到现有系统 3. 交叉编译驱动程序4. 装载设备驱动5. 上层应用调用驱动程序中间小插曲 参考 这篇文章主要记录自己在嵌入式Linux学习过程中的收获，以方便后续自己查看，这次记录的内容是我使用nano板加载了自己的第一个驱动程序，并且测试成功！下面是具体的步骤。 1. 交叉编译编译内核源码 什么是交叉编译？ 所谓的交叉编译指的就是在一个CPU架构平台上，编译出另外一个CPU架构平台上可以执行的程序。交叉编译的好处在于可以提高内核源码编译的速度，交叉编译的原因在于嵌入式平台在设计过程中的性能和内存等硬件资源并没有特别好，因此需要使用性能更好的平台完成编译的任务，同时交叉编译使得我们不需要花时间将各种支持包移植到目标板上。
编写驱动，为啥要编译内核源码？ 因为在设备驱动中，需要引用内核源码编译后的文件，因此需要先编译内核源码。
具体步骤： 1. 1 下载Jetson nano的源码包和交叉编译器 3231版本链接.
最后可以得到下面两个文件，对下面两个文件tar解压。
1.2 配置交叉编译环境 export PATH=/opt/gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu/bin/:$PATH source ~/.bashrc export LOCALVERSION=-tegra export CROSS_COMPILE=aarch64-linux-gnu- 官方文档
1.3 编译内核源码 首先要到源码的目录当中： /home/shaokun/Jetson/Linux_for_Tegra/source/public/kernel/kernel-4.9 配置.config文件 sudo make ARCH=arm64 O=$TKOUT tegra_deconfig (tegra_deconfig不同的平台不一样，ARCH=arm64代表的就是目标平台是ARM64位的硬件平台) 编译内核 sudo make ARCH=arm64 O=$TKOUT -j4(j后面代表当前编译平台上CPU的数量) 等待十几分钟即可编译完成 此过程不仅会将内核编译完成，还会将设备树，设备驱动程序的都编译完成。
2. 装载/烧录编译好的文件 2.1 EMMC烧录 有一种emmc的烧录，思路就是通过跳线将nano板进入工厂模式，通过usb线，注意这个usb线质量要好，执行脚本就可以烧录了，详情参考：
https://blog.csdn.net/ldl371122/article/details/120860054?spm=1001.2014.3001.5502
2.2 装载内核到现有系统 装载就是将编译好的内核、设备树、模块与nano板正在使用的进行替换；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35b5f26fea754f06e2683d8b42e04296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54bd3ad3213e587a9ff408a5b93c19b6/" rel="bookmark">
			交换机VLAN知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、二层通信和三层通信 1、二层通信是指通信的双方是以直接交换帧的方式来传递信息的。也就是说，目的计算机所接收到的帧与源计算机发出的帧是一模一样的，帧的目的mac地址、源mac地址、类型值、载荷数据、CRC等内容都没有发生任何改变。
2、二层交换的工作原理
当交换机在某个接口上收到一个单播数据帧时，它将首先读取数据帧的目的mac地址，并且在自己的Mac地址表中查询该地址，如果查询不到匹配的表项，则将该数据帧进行泛洪。如果能够在Mac地址表中找到匹配的表项，并且收到该帧的接口与表项中对应的接口不同时，则将数据帧从该表项中对应的接口转发出去；如果收到该帧的接口与该表项中对应的接口相同时，则丢弃该数据帧
3、当一个交换机收到一个广播或组播帧，交换机不会进行目的Mac查询，而是直接将其泛洪
二、Mac地址 1、Mac地址与IP地址类似，也有单播、组播和广播，Mac地址的长度是48bit
2、厂商将OUI作为mac地址的前24bit，而后24bit则由厂商自己指定
3、单播mac地址第一个字节的最低比特位为0
4、组播Mac地址第一个字节的最低比特位为1
5、广播Mac地址的所有比特位全都是1
三、Mac地址表 由目的mac地址、所属vlan、出接口、Mac表项类型、老化时间组成
四、Vlan的好处 1、隔离广播域
2、提高网络组建的灵活度
3、提高网络的可管理性
4、提高网络的安全性
五、802.1Q帧的格式 TPID，表示这个帧是否带有tag
PRI，表示帧的优先级
VID，表示该帧所属的vlan
六、Vlan的类型 1、基于接口的vlan
2、基于Mac地址的vlan
3、基于协议的vlan
七、Access接口接收帧： 1、接口收到untagged帧：接收该帧，并打上该接口PVID的tag
2、接口收到tagged帧：当该帧的vlan id与该接口的PVID相同时，接收该帧
当该帧的vlan id与该接口的PVID不同时，丢弃该帧
Access接口发送帧：
1、帧的vlan id与接口PVID相同：先剥离该帧的tag，然后再将其从该接口发出
2、帧的vlan id与接口PVID不同：禁止将该接口发出
八、Trunk接口接收帧： 1、接口收到untagged帧：该帧打上PVID，当PVID在该接口允许通过的vlan列表里时接收该帧；当PVID不在允许通过的vlan列表里时，丢弃该帧
2、接口收到tagged帧：当该帧的vlan id在该接口允许通过的vlan列表里，接收该帧，否则丢弃该帧
Trunk接口发送帧：
1、帧的vlan id与接口PVID相同：当该帧的vlan id在该接口允许通过的vlan列表中，则将该帧的tag剥除，然后将其从该接口发送出去；如果vlan id不在允许通过的vlan列表中则禁止将该帧从该接口发出
2、帧的vlan id与接口PVID不同：当该帧的vlan id在该接口允许通过的vlan列表中，则保留该帧的tag，然后将其从该接口发送出去；如果vlan id不在允许通过的vlan列表中则禁止将该帧从该接口发出
九、Hybrid接口接收帧： 1、Untagged数据帧，打上PVID，且VID在允许列表中，则接收；VID不在允许列表中，则丢弃
2、Tagged数据帧，查看VID是否在允许列表中，则接收；VID不在允许列表中，则丢弃
Hybrid接口发送帧：
1、VID不在允许列表中，直接丢弃
2、VID在Untagged列表中，剥离标签发送
3、VID在tagged列表中，带标签直接发送
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e57fa993f09c040b0e875ecf07b2b789/" rel="bookmark">
			网络工程师小知识:静态路由配置命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是静态路由？
二、静态路由的特点！
三、静态路由的一些配置命令
四、实验配置命令
更多配置命令，评论区留言[私信R]“学习”免费分享
#网络工程师 #华为认证 #计算机网络 #静态路由 #学习
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee542f614e211aad40dc7ffc1e9afe11/" rel="bookmark">
			最新微信小程序反编译方法（亲测有效，无需模拟器）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此方法是本人多次试错意外发现的方法，以下是本人遇到的问题及解决方法，有其他方法欢迎讨论
1.下载node.js,直接去官网下载，配置教程网上有这里不讲了。
确保安装目录下有npm文件夹，后面会用到。
2.下载破解工具并解压，我解压到桌面https://codeload.github.com/superBiuBiuMan/wechatMiniAppReverse/zip/refs/heads/main
3.找到小程序文件
PC端小程序路径：在微信设置的文件管理位置，打开该目录下的Appet文件夹
通过查看修改日期确认自己要用到的小程序,实在找不到就删掉Applet里面所有的文件然后重新在pc端微信进入要破解的小程序，会自动在Applet新生成小程序文件。
点击文件夹进去，_APP_.wxapkg就是我们要找的小程序包
找到后将.wxapkg文件复制到一级目录文件，例如桌面文件夹D:\Desktop，否则后面破解工具找不到文件会报错。
4.解密
因为PC端的wxapkg是被加密存储的，直接解包会弹出Magic number is not correct!错误
所以必须先解密。
win+R 输入cmd打开控制台，然后通过cd+文件名回车，一步步进入到破解工具目录1.first，
然后按照 pc_wxapkg_decrypt.exe -wxid 微信小程序id -in 要解密的wxapkg路径 -out 解密后的路径 的格式输入。
例如wxapkg最初的路径为：C:\Users\xxxx\Documents\WeChat Files\Applet\wx2xxx84w9w7a3xxxx\_APP_.wxapkg,那么微信小程序id为：wx2xxx84w9w7a3xxxx
要解密的wxapkg路径是之前复制到一级目录的wxapkg路径，我的是D:\Desktop\_APP_.wxapkg
解密后的路径：随便找一个一级目录，然后给解密后的wxapkg取个名字，我的是D:\123\123_.wxapkg
我的完整输入：D:\Desktop\wechatMiniAppReverse-main\1.first&gt;pc_wxapkg_decrypt.exe -wxid wxc20a5f25f3cc21f5 -in D:\Desktop\__APP__.wxapkg -out D:\123\123_.wxapkg
回车，解密完成
成功在解密路径生成了解密文件
5.解包
控制台切换到D:\Desktop\wechatMiniAppReverse-main\2.second\nodejs目录下,
输入node .\wuWxapkg.js 解密文件目录
例如 node .\wuWxapkg.js D:\123\123_.wxapkg
回车，报错
发现缺少uglify-es项目，于是通过D:\Desktop\wechatMiniAppReverse-main\2.second\nodejs&gt;npm install uglify-es 安装缺失块，结果又报错，缺少npm-cli.js
原因是破解工具自带的node.js版本太老而且缺少npm目录
解决方法，将一开始我们在官网下载安装好的最新node.js所有文件复制到破解工具的2.second\nodejs文件夹中，替换相同项目
全部粘贴到下面这个nodejs文件夹中 ，替换相同项目
然后返回控制台安装uglify-es 项目
成功安装
控制台在D:\Desktop\wechatMiniAppReverse-main\2.second\nodejs&gt;目录下
输入node .\wuWxapkg.js D:123\123_.wxapkg回车开始解包，此时可能出现cheerio项目缺失
问题不大，缺什么就npm install什么，继续npm install cheerio
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee542f614e211aad40dc7ffc1e9afe11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b541e741f12c2168309f04d11455f785/" rel="bookmark">
			pip下载包时出现不适配导致无法下载安装包:error: subprocess-exited-with-error；error: metadata-generation-failed；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不用怀疑，首先排除将pip升级到最新这个没啥用的主意
其次，这个问题出现一般是环境不匹配导致的
最老实的办法莫过于弄清楚环境具体应该如何适配，然后再pip下载 这个就不细说了，因人而异，可以尝试用不同源下载，也可以试试切换下python版本或者安装包的版本
中庸之策略则是下载该包的wheel文件，再本地安装 PS：这里有个问题，那就是，如果在pip install的不是官方包，而是别人上传到PYPI的包怎么办，按以上方法，也可以在清华源去搜索：https://pypi.tuna.tsinghua.edu.cn/simple/，{安装tar.gz:cd到解压后路径,./configure -&gt; make -&gt; make install或者python setup.py install}
当然除此之外，还有以下这种方法：
这里以Wikipedia2Vec为例，it can be installed from PyPI:
pip install wikipedia2vec
如若不行，就采取以下措施，用其自带的sh文件安装
% git clone https://github.com/studio-ousia/wikipedia2vec.git % cd wikipedia2vec % pip install Cython % ./cythonize.sh % pip install . 安装的时候若是报错：error: Microsoft Visual C++ 14.0 or greater is required. Get it with “Microsoft C++ Build Tools”: https://visualstudio.microsoft.com/visual-cpp-build-tools/
则在以下页面下载Build Tools即可
https://visualstudio.microsoft.com/zh-hant/visual-cpp-build-tools/
如果觉得占用内存过大，也可以考虑如下方法
conda install libpython m2w64-toolchain -c msys2 参考
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b541e741f12c2168309f04d11455f785/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef75e1ad4476ae782c3680337a1ad853/" rel="bookmark">
			v-bind=“$attrs“ v-on=“$listeners“使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用场景：当vue中有多层组件嵌套， 且多层组件间需要相互传递数据时
A组件
&lt;template&gt; &lt;view class="bg-color-F4 reserve-box"&gt; 档期 &lt;button @click="btnClick"&gt; btn &lt;/button&gt; &lt;child v-bind.sync="obj" :a="'b'" @clickBtn="clickBtn"&gt;&lt;/child&gt; &lt;midell-box :current-page="1"&gt;&lt;/midell-box&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; import child from './components/child' export default { data() { return { obj:{ name:"old name", title:"old title" } } }, watch:{ obj:{ handler(newVal) { console.log(newVal); }, deep: true } }, created() { }, methods: { btnClick(){ uni.navigateTo({ url:`/pages/mealLabel/index` }) }, clickBtn(){ console.log(1); } }, components: { child }, } &lt;/script&gt; &lt;style scoped lang="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef75e1ad4476ae782c3680337a1ad853/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bb38966c49fcbddc0380c7599151d16/" rel="bookmark">
			Qt关于csv的生成和读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 void createCSV() { QFile file("test.csv"); if(!file.open(QIODevice::WriteOnly| QIODevice::Append)) { return; } QTextStream out(&amp;file); QTextCodec* code = QTextCodec::codecForName("UTF-8"); out&lt;&lt;code-&gt;toUnicode("测试1,测试2,测试3\n"); out&lt;&lt;code-&gt;toUnicode("1,2,3\n"); out&lt;&lt;code-&gt;toUnicode("4,5,6\n"); out&lt;&lt;code-&gt;toUnicode("7,8,9\n"); out.flush(); file.close(); } void slot_readCSV() { QFile file("test.csv"); if(!file.open(QIODevice::ReadOnly)) { return; } QTextStream in(&amp;file); QTextCodec* code = QTextCodec::codecForName("UTF-8"); QList&lt;QStringList&gt; list; while(!in.atEnd()) { QString data = code-&gt;fromUnicode(in.readLine()); QStringList dataList = data.split(","); list.append(dataList); } qDebug()&lt;&lt;list; int count = list.size(); for(int i=0;i&lt;count;i++) { QString str = list.at(i); ui-&gt;plainTextEdit-&gt;appendPlainText((list.at(i))); ui-&gt;plainTextEdit-&gt;appendPlainText("\n"); } qDebug()&lt;&lt;list; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/210/">«</a>
	<span class="pagination__item pagination__item--current">211/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/212/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>