<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6429385d6f167d0d441cfd6fdd3a037/" rel="bookmark">
			VMware 安装 CentOS7 详细过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请注明来源：VMware 安装 CentOS7 详细过程
软件：VMware14
镜像：CentOS-7-x86_64-DVD-1810.iso
一.虚拟机准备 1.创建虚拟机；
典型安装： 将主流的配置应用在虚拟机的操作系统上，对于新手来很友好。
自定义安装：自定义安装可以针对性的把一些资源加强，把不需要的资源移除。避免资源的浪费。
我选择典型推荐
2.选择稍后安装操作系统
3. 选择系统版本，系统：Linux，版本:根据自己下载的CentOS版本进行相对应的选择。
4.虚拟机位置与命名
虚拟机名称就是一个名字，在虚拟机多的时候方便自己找到。
默认位置是在C盘
5. 磁盘容量默认20G，这里我选择单个文件存储，你可以可以按照自己的需要选择；
6. 内存：2G，处理器：4，CD：使用ISO影响选择iso文件路径
二.安装CentOS系统
1.开启虚拟机后会出现以下界面
Install CentOS 7 安装CentOS 7Test this media &amp; install CentOS 7 测试安装文件并安装CentOS 7Troubleshooting 修复故障 选择第一项，安装直接CentOS 7，回车，进入下面的界面
2. 选择语言：中文，简体中文
3. 系统选择安装位置
4.安装位置-选择我要配置分区
5.点左下角的“+”号，挂载点：swap，期望容量：2048
6. 继续点左下角的“+”号，挂载点：/ 期望容量：18.43GB #剩余所有空间，直接空着点添加挂载点即
7. 点左上角的“完成”，接受更改，返回安装信息摘要
8. 选择网络和主机名，进入以下界面，开启网络，点击配置
9.以太网-设备，你会看到有2个ens33，选择带mac地址的。我尝试过用不带mac地址的ens33，然后进入系统，进行ens33的网络配置文件修改，网络会一直无法ping通www.baidu.com。查过个用各种方式去修改参数，都无法成功ping通。选择用带mac地址的ens33就不会有这个问题；我也不是很明白这点是为什么；配置文件都一样；
10.网络和主机名修改完成 ，进入下个界面，对root密码进行添加，输入密码，点击完成，开始安装系统
11.安装完成后点击重启，进入系统
12. cd /etc/sysconfig/network-scripts/ #进入网络配置文件目录
ll： 查看网络配置文件目录下的所有文件
13.vi ifcfg-ens33 #编辑配置文件，添加修改以下内容
以下为未修改过的ens33文件
以下为修改过的ens33文件 BOOTPROTO=static #启用静态IP地址
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6429385d6f167d0d441cfd6fdd3a037/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d4ee87edc1ccbfbb7e3401b4690c75b/" rel="bookmark">
			SSD模型训练技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、训练参数调整
描述：训练参数对收敛速度以及最终精度有影响。
措施：了解每个参数的背后的数学意义，改变参数，进行对比实验。
2、数据集样本总量
描述：训练模型所使用的数据集样本量越多，效果越好。
措施：一边训练一边增加样本量，尤其是样本量相对较低的某一类。样本可以手工做，也可以找公开的数据集。
3、样本的类别
描述：对于样本类别的划分会对结果产生影响。
措施：减少样本种类。例如将长头发、短头发、帽子合并为一类。
4、图框的长宽比
描述：不同样本resize成统一大小之后会丢失信息，对结果造成影响。
措施：阅读SSD论文或其他资料，确定SSD根据图框产生正样本的机制，如果有影响，则将图框统一改成固定长宽比之后再训练。
5、负样本的产品
描述：图像中存在半个目标的情况，可能会被SSD当作负样本进行训练。
措施：阅读SSD论文或其他资料，确定SSD负样本产生机制，如果有影响，则要将图片中存在半个目标的样本全部去掉，再试验。
6、输入图像的长宽和模型输入长宽的关系
描述：模型输入长宽是否跟输入图像的长宽有关。
措施：改变模型的输入长宽，观察结果变化。
7、对模型检测错误的样本进行增强
描述：误检，漏检，框不准，以及概率过低的目标，需要进行增强。
措施：得到一个初步稳定的模型之后，用模型去检测每一张输入样本图像，人工筛选出上述检测不合格的样本图像，用这些样本对原有数据集进行增强（会产生重复的数据，需要重命名），再训练，再看结果。
8、准确率测试方法：
描述：准确率的判定会影响对模型好坏的判断。
措施：必须从一开始就要固定一个准确率测试的方法。同类实验用同一标准判定结果好坏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c191ba37e8537a69af22f958bacc416a/" rel="bookmark">
			js算法-快速排序(Quicksort)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要O(nLogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序O(nLogn)通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成 快速排序可能大家都学过，在面试中也经常会遇到，哪怕你是做前端的也需要会写，这里会列举两种不同的快排代码进行分析
快速排序的3个基本步骤： 从数组中选择一个元素作为基准点排序数组，所有比基准值小的元素摆放在左边，而大于基准值的摆放在右边。每次分割结束以后基准值会插入到中间去。最后利用递归，将摆放在左边的数组和右边的数组在进行一次上述的1和2操作。 为了更深入的理解，可以看下面这张图
我们根据上面这张图，来用文字描述一下
选择左右边的元素为基准数，7将小于7的放在左边，大于7的放在右边，然后将基准数放到中间然后再重复操作从左边的数组选择一个基准点23比2大则放到基准树的右边右边的数组也是一样选择12作为基准数，15比12大所以放到了12的右边最后出来的结果就是从左到右 2 ，3，7，12，15了 以上就是快速排序基本的一个实现思想。
快速排序实现方式一 这是我最近看到的一种快排代码
var quickSort = function(arr) { if (arr.length &lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++) { if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return quickSort(left).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c191ba37e8537a69af22f958bacc416a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0e8b9703d8e46d308ae67fee23d6e2/" rel="bookmark">
			阅读作业——关于习而学的看法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇博客是作为软件工程课的阅读作业，要求
出于个人兴趣，我或是粗略或是详细地阅读了：
邹老师关于习而学的看法
茅于轼先生对茅以升的习而学的介绍
Discuss: Is “Computer Science != Software Engineering” an excuse to teach programming poorly?
和一些来自不同身份的人(学生、engineer)相关的讨论和意见。
对于这个”习而学“的问题，也有了一些我自己的看法。
首先，习而学的提出显然是创新的，是值得考虑的，当前大学里学然后习的方法也确是有弊端的。在这个讨论中，我主要讨论计算机和软件（而非茅以升先生提出的桥梁工程）领域，从我个人的角度来看，我认为学然后习的弊端，有以下几点：
毕业生的工程实践能力差学生在低年级对自己所处的领域了解非常有限，对当前学的东西一知半解，要很久以后才能理解知识和实践之间的联系对研究 or 工程的选择太仓促 其原因，不能简单地归咎于体制问题或社会风气问题，因为这个原因是多方面的复杂而深层次的。我在这里想说几个：
其一，现行的高等教育选拔制度使得大多学生和家长在选择大学和专业十分盲目，追热点或是盲目选的人我身边有很多
其二，工程学科在大学里有一个天然的弱势，就是高校里的老师很多离工程实践很远，或是很久，以至于学生即使进入了这个专业也没有办法从他们那里了解到真实的工程实践是怎样的，老师本身也早已不重视学生的工程实践能力和行业视野
其三，大多数学生的学习方法并不适合学习如何做工程（当然也大多不适合学习如何做研究）
关于上述问题我的一点想法：
茅以升先生提出的“习而学”方法在我看来是很值得应用的，然而由于时间已久，事实上存在一定的落后，即是那时的大学生由国家分配工作，大约是在入学时便知道了自己将会在那个领域工作，但如今并非如此，因此，如果真的要实行此”习而学“之做法，应当考虑探索学生的兴趣和发展方向，所以必然不能一入学便教授桥梁工程施工条例，如此倘若学生沿此道路学到四年级，发现设计桥梁的建筑学更加有趣，但此时再去学习美术学已然晚了。
回到计算机领域，也是因此，要让学生在知道计算机科学与软件工程的区别以前就选择在这个领域中的专攻，未免强人所难。最近开始流行的大类招生稍稍有了这个意向，我觉得是一个好的改革方向。然而大类确是大类了，课程结构至少在科大是没有大变化的，在专业选择时学生依然是云里雾里，”桥梁工程导论“，”计算机科学导论“之类的课又未免看起来就让人反胃。我能想到的是在一年级教授基础课（数学、物理，在我看来这是必须的）的同时，开设一门类似于科大的“科学与社会”研讨课的课程，科大的新生可以听几场学术界大佬的讲座，也会在青年教师的领导下做一些非常非常基础的小项目。这个课可以推广，把如果把请大佬现场做报告换成看视频，把做基础小项目换成在广泛的领域做调研，出一份大领域的研究和工程现状的调研报告，在我看来是极好的。
习而学中的习指的是什么呢？做一个假设，软件学院的学生未来会做软件工程，计算机学院的学生不知道自己未来是做软件工程还是CS研究（而事实上，他们都很可能去做银行柜员）。那么邹老师提出的课表对软件学院的同学们是很好的，如果要为计算机学院的同学制定一个习而学标准的培养计划，应该如何呢？
至此以超出了我的见识和规划能力，因此不再继续。只是希望这样的改革尽快到来。
转载于:https://www.cnblogs.com/wyc9725/p/10221310.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae3bd81d48cc4d4e869e348551e4ead3/" rel="bookmark">
			工具收藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.网站和博客 GITHUBStackOverFlowCSDN博客知识库菜鸟教程（学习必备）W3SchoolSegmentFault深度开源OPEN经验开源中国知乎推酷极客学院慕课网麦子学院程序猿学习导航网站：我的索引 2.IDE和编辑器 IDE：Visual Studio、Qt、Eclipse编辑器：VSCode、Notepad++、Gedit、Geany、vim 3.系统软件 搜索：everything、Listary杀毒：kaspersky(有条件正版，无条件淘宝搜许可证，无需繁琐破解)划词翻译：有道词典百度文库下载：冰点文库下载桌面截图：picpick 4.软件开发辅助 版本控制：git代码仓库：GitHub(公开库免费)、Bitbucket(私有库免费)代码比较：Beyond Compare串口调试：ZYICOMETest 5.LInux开发辅助 虚拟机：VMware远程桌面：VNC Viewer远程登录：XShell远程传输文件：Xftp 6.Google Chrome浏览器 科学上网插件：氪星人的科学上网工具Github代码目录插件：Octotree手势插件：smartUp手势广告拦截：Adguard 广告拦截器JSON工具：JSON handle颜色取值插件：Eye Dropper 7.其他软件 桌面壁纸：搜狗壁纸PDF阅读：FoxiReader广告屏蔽：净网大师(Windows、Android) 8.在线工具 百度脑图石墨文档 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc3671c44e7288dc469f4c0844b2cd77/" rel="bookmark">
			Unity 之新版unet(NetworkManager)使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 首先我们来区分下新版unet和老版unet。
1.老版unet，是指unity5.0以前就有的，一个unity用于构建多人游戏的网络架构，主要以NetworkView类展开，RPC的方式调用远程函数。
2.新版unet，是指unity5.0之后的一套Mutiplayer的网络架构，主要以NetworkManager为主，NetworkIdentity，NetworkTransform，NetworkAnimator等组件辅助的一套网络架构部。比老版本更方便，封装更全面。
当然官方把网络又分为HLAPI和LLAPI，甚至还有高级用法NetworkTransport API。我们不做讨论，大家自行研究，
今天主要讲一下新版unet（NetworkManager的用法）
将单人游戏转换为Unity多人游戏 本文档介绍了将单个玩家游戏转换为多人游戏的步骤，使用新的Unity多人游戏网络系统。这里描述的过程是真实游戏的实际过程的简化的更高级版本; 它并不总是像这样工作，但它提供了该过程的基本配方。
1.NetworkManager设置 添加新的GameObject的场景并将其重命名为“NetworkManager”。将NetworkManager组件添加到“NetworkManager”GameObject。添加NetworkManagerHUD游戏对象的组件。这提供了默认UI管理网络游戏状态的。 请参阅使用NetworkManager。
2.Player Prefab设置 在游戏中找到玩家GameObject的预制件，或者从玩家GameObject创建预制件添加NetworkIdentity组件中的播放器Prefab检查NetworkIdentity上的LocalPlayerAuthority框将playerPrefabNetworkManager的“ Spawn Info”部分设置为播放器Prefab如果场景中存在Player Player实例，则从场景中移除它 请参阅Player对象。
3.Player控制 将NetworkTransform组件添加到播放器Prefab更新输入和控制脚本中的isLocalPlayer根据生成的player和isLocalPlayer更新Camera的位置 例如，此脚本仅处理本地播放器的输入：
using UnityEngine; using UnityEngine.Networking; public class Controls : NetworkBehaviour { void Update() { if (!isLocalPlayer) { // exit from update if this is not the local player return; } // handle player input for movement } } 4.基本的玩家游戏状态 将包含重要数据的脚本放入NetworkBehaviours而不是MonoBehaviours将重要的成员变量放入SyncVars 请参见状态同步。
5.网络行为 将含有网络更新的脚本继承NetworkBehaviours而不是MonoBehaviours将玩家的网络行为更新为[Command] 请参见联网操作。
6.非玩家游戏对象 修复非玩家预制件，如敌人：
添加NetworkIdentify组件添加NetworkTransform组件使用NetworkManager注册spawnable Prefabs使用游戏状态和操作更新脚本 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fc3671c44e7288dc469f4c0844b2cd77/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab1f2fc8b2488f81beec543ef1420b29/" rel="bookmark">
			Vue--创建一个vue项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前期准备： 安装phpstorm
安装node.js
Node.js是一个Javascript运行环境。
Node.js 安装及环境配置 安装weex以及idea 的vue相关插件
安装完成node.js，npm也就安装完成了。
npm是node的包管理工具。
安装Git
创建vue项目 PHPStorm 使用git bash 为terminal终端 File -&gt; Settings -&gt; Tools -&gt; Terminal
设置shell_path为"D:\Git\bin\sh.exe" --login -i这里注意路径两侧的双引号，如果去掉打开终端会报错。
基本步骤 建立一个储存vue项目的文件夹
在该文件夹目录下的终端输入npm install --global vue-cli(下载全局vue-cli)
vue-cli是vue.js的脚手架，用于自动生成vue.js+webpack的项目模板。
输入vue init webpack timeattendance（timeattendance是我的项目名）
然后他会询问你一些问题：
Project name项目名称（确定按enter，否按N） （按enter）Project description (A Vue.js project)；项目描述（一vue.js项目）。（随意输入一段简短介绍，不写直接回车也行）（按enter）Author (sunsanfeng)；作者（sunsanfeng）。（确定按enter，否按N)（按enter）Vue build (Use arrow keys)&gt; Runtime + Compiler: recommended for most usersRuntime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab1f2fc8b2488f81beec543ef1420b29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb5605884f02f70378591f871218e818/" rel="bookmark">
			看vue项目体会(app.vue，router的index.js)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		template标签的作用 template本身没有很特别的意义，可以了解下html 的template标签官网以及其他人所描述的“根元素”，是指template标签下的元素，不包括也不是template本身。template只能有一个根元素。 HTML 元素 是一种用于保存客户端内容的机制，该内容在页面加载时不被渲染，但可以在运行时使用JavaScript进行实例化。
可以将一个模板视为正在被存储以供随后在文档中使用的一个内容片段。虽然, 在加载页面的同时,解析器确实处理 &lt;template&gt;元素的内容，这样做只是确保这些内容是有效的; 然而,元素的内容不会被渲染。
vue-router 基本使用 路由，其实就是指向的意思，当我点击页面上的home按钮时，页面中就要显示home的内容，如果点击页面上的about 按钮，页面中就要显示about 的内容（Home按钮 =&gt; home 内容， about按钮 =&gt; about 内容）。也可以说是一种映射。 所以在页面上有两个部分，一个是点击部分，一个是点击之后，显示内容的部分。
点击之后，怎么做到正确的对应，比如，我点击home 按钮，页面中怎么就正好能显示home的内容。这就要在js 文件中配置路由。
路由中有三个基本的概念 route, routes, router。
route，它是一条路由，由这个英文单词也可以看出来，它是单数， Home按钮 =&gt; home内容， 这是一条route, about按钮 =&gt; about 内容， 这是另一条路由。
routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}]
router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。
客户端中的路由，实际上就是dom 元素的显示和隐藏。当页面中显示home 内容的时候，about 中的内容全部隐藏，反之也是一样。客户端路由有两种实现方式：基于hash 和基于html5 history api.
vue-router中的路由也是基于上面的内容来实现的 在vue中实现路由还是相对简单的。因为我们页面中所有内容都是组件化的，我们只要把路径和组件对应起来就可以了，然后在页面中把组件渲染出来。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb5605884f02f70378591f871218e818/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5300486c454f4b0318ba0cc5326274bd/" rel="bookmark">
			程序猿 网站 | 常用 技术学习网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、技术网站 0.https://www.w3cschool.cn/ w3cschool
1.http://www.vwpan.com/ 唯网盘。
2.http://java.goodym.cn/ java项目源码共享
3.http://www.zuidaima.com/ 最代码
4.http://codingxiaxw.cn/ codingxiaxw 5.http://blog.didispace.com/ 程序员dd
6.https://www.oschina.net/ 开源中国
7.https://www.proginn.com/ 程序员客栈 --主要雇佣BAT级别开发者为创业者开发产品。
8.https://pro.lagou.com/ 大鲲----这是按需供应的网站，大鲲适合中高水平的程序员，建议是积累一定的项目经验之后，再去接活。
9.https://www.yuanjisong.com/ 猿急送----这里的优点就是入驻平台快，写好介绍之后，你可以坐等企业预约你，也可以自己去选择自己想要的项目。这里的项目比较垂直于程序员、UI、产品这一块，专业性比较强。
10.https://mart.coding.net/ 码市是Coding 推出的基于云技术的软件外包平台,意在连接需求方与广大开发者。
相当于一个代码买卖市场,提供一个给有开发经验和项目需求的人的交易平台,可以随时申请成为码士,并参与感兴趣的悬赏项目,从而得到高额的回报，在连接需求方与广大开发者。
说完国内的网站，或许不少人都认为国外的平台佣金可能会更高，但其实并没有！想在国外平台接活，首先就要求你的英语足够的好，其次你的能力要及格，国外的平台竞争也是相当激烈，唯一的好处就是可以锻炼你的英文。
11.http://www.codeceo.com/ 码农网
12.https://github.com/ Github代码托管----作为开源代码库以及版本控制系统，Github拥有140多万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。代码托管必备。
13.http://stackoverflow.com/ StackOverFlow技术问答---Stack Overflow是一个与程序相关的IT技术问答网站。用户可以在网站免费提交问题，浏览问题，索引相关内容，在创建主页的时候使用简单的HTML。在问题页面，我们不会弹出任何广告，销售信息，Java 窗口等。
14.https://dribbble.com/ Dribbble设计达人---Dribbble是一个面向创作家、艺术工作者、设计师等创意类作品的人群，提供作品在线服务，供网友在线查看已经完成的作品或者正在创作的作品的交流网站。对于前端设计来说真是再好不过的一个网站了。
15.https://www.cnblogs.com/ 博客园---这样一个不起眼的地方，却吸引了很多IT技术精英，把这里当作自己的网上家园，每天在这里分享着精彩的原创内容，也许他们看重的不是华丽的外表、诱人的虚名，而是纯净、专注、对技术人员的理解。
16.https://www.v2ex.com/ V2EX---无论你是在大学进行人生最重要阶段的学习，或者是在中国的某座城市工作，或者是在外太空的某个天体如 Sputnik 1 上享受人生，在注册进入 V2EX 之后，你都可以为自己设置一个所在地，从而找到更多和你在同一区域的朋友。
17.http://www.guokr.com/ 果壳网---作为一个开放、多元的泛科技兴趣社区，吸引了百万名有意思、爱知识、乐于分享的年轻人聚集在这里，用知识创造价值，为生活添加智趣。在这里可以关注感兴趣的人，阅读他们的推荐，也将有意思的内容分享给关注的人；依兴趣关注不同的小组，精准阅读喜欢的内容，并与网友交流；在“果壳问答”里提出困惑你的科技问题，或提供靠谱的答案。
18.https://www.nowcoder.com/ 牛客网
二、非技术网站 19.http://36kr.com/ 36氪
20.https://www.huxiu.com/ 虎嗅网 21.http://www.zhihu.com/ 知乎
22.https://www.nowcoder.com/ 牛客网
23.http://www.jianshu.com/ 简书
三、其他 网站 24.http://www.atguigu.com/ 尚硅谷
25.https://ke.qq.com/ 腾讯课堂
26.http://www.itcast.cn/ 传智播客
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5300486c454f4b0318ba0cc5326274bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ceee888b751209aa235e2d523c4da7/" rel="bookmark">
			有（晒素数&#43;枚举）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有 时间限制: 1 Sec 内存限制: 128 MB
题目描述
乌龟给自己的贵重物品上了密码锁。密码锁上有5个数字拨盘。每个数字拨盘每次向上拨使数字增加1(9向上拨得到0)，向下拨使数字减少1(0向下拨得到9)。
拨盘上的数字组成一个5位数。只要拨盘上的数字变为素数，密码锁就会被解开。素数(又称质数)是只能被1和它自身整除的大于1的自然数。因为乌龟动作实在太慢，他希望你帮他计算如何开锁，使得拨动的总次数最少。
输入
一个5位数，表示拨盘的初始数字
输出
一个5位素数，表示开启密码锁使用的素数(拨动次数最少)。如有多组解，输出满足条件的最大数
样例输入 复制样例数据
01212 样例输出
01213 1.首先算出2~100000的所有素数。（随便你用什么算法，保证小于等于O(nlogn)就行） 2.其次枚举每一个素数，与原来的数的每一位比较，算出每一位至少要拨几次，然后算出最小的，等于的话，为最大的素数。。
PS：0拨到9有2中方法，分别为拨一次和拨9次，发现没有0-9+10=1,9-0=9; 再来，8拨到2有2中方法，分别为拨4次和拨6次，8-2=6，2-8+10=4； 知道了怎么求每一位的最小拨动次数了吧！
/**/ #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;cctype&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;set&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;stack&gt; #include &lt;queue&gt; typedef long long LL; using namespace std; int prim[9600], vis[100005], tot, num[6], nu[6]; char s[6]; void get_prim(){ for (int i = 2; i &lt; 100000; i++){ if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02ceee888b751209aa235e2d523c4da7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e3441127b87d3c23bac463c1c8d1dc/" rel="bookmark">
			PHP制作简易问卷调查
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PHP老师布置的作业，使用各种不同的控件来制作一份简易的问卷调查。
我们使用记事本操作就行，复制如下代码，并将后缀名改为html。
&lt;html&gt; &lt;head&gt; &lt;title&gt;问卷调查&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="wp2.php" method=POST&gt; &lt;p&gt;姓名：&lt;input type="text" name=姓名&gt; &lt;p&gt;兴趣：&lt;input type="text" name=兴趣&gt; &lt;p&gt;性别：&lt;/p&gt; &lt;input type=radio name=sex value="男"&gt;男 &lt;input type=radio name=sex value="女"&gt;女 &lt;p&gt;血型：&lt;/p&gt; &lt;input type=radio name=blood value=A&gt;A &lt;input type=radio name=blood value=B&gt;B &lt;input type=radio name=blood value=AB&gt;AB &lt;input type=radio name=blood value=O&gt;O &lt;p&gt;请选择您擅长的一种或几种编程设计语言：&lt;/p&gt; &lt;input type=checkbox name=yy[] value="C++"&gt;C++ &lt;input type=checkbox name=yy[] value="PHP"&gt;PHP &lt;input type=checkbox name=yy[] value="Shell"&gt;Shell &lt;input type=checkbox name=yy[] value="VBScript"&gt;VBScript &lt;p&gt;请选择您最擅长的操作系统：&lt;/p&gt; &lt;select name=OS&gt; &lt;option value="Linux" selected&gt;Linux &lt;option value="Unix"&gt;Unix &lt;option value="Windows"&gt;Windows &lt;/select&gt;	&lt;p&gt;如果您有什么建议，敬请留言：&lt;/p&gt; &lt;textarea name=advise rows=5 cols=60&gt; &lt;/textarea&gt;	&lt;br&gt; &lt;input type=submit value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3e3441127b87d3c23bac463c1c8d1dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32c34a7cb3f81a92f0a1921079e507ed/" rel="bookmark">
			【NOIP2007提高组】矩阵取数游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题DP+高精度即可。
首先我们可以发现它的贡献只与行有关系，于是就分成n行，每行都做DP，然后将max加起来即可。（PS：用高精度实现）
上标：
#include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #define mo 100000 #define ll long long using namespace std; int n,m,c[81][81]; struct gjd { int a[51],top; }ans,f[81][81],e[81],s,d; inline int read() { int x=0; char c=getchar(); while (c&lt;'0' || c&gt;'9') c=getchar(); while (c&gt;='0' &amp;&amp; c&lt;='9') x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^48),c=getchar(); return x; } gjd cheng(gjd a,int b) { int x=0; for (int i=1;i&lt;=a.top;i++) { a.a[i]=a.a[i]*b+x; x=a.a[i]/mo;a.a[i]%=mo; } while (x) a.a[++a.top]=x%mo,x/=mo; return a; } gjd plus(gjd a,gjd b) { int x=0; memset(d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32c34a7cb3f81a92f0a1921079e507ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b0507cf985aeed908dfefcddf21d6cb/" rel="bookmark">
			基于CENTOS7安装Kubernates集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、节点规划 主机名
IP
角色
C7m1
10.137.213.240
k8s主节点
C7m2
10.137.213.241
k8s从节点
C7m3
10.137.213.242
k8s从节点
节点的软件版本：
操作系统： CentOS-7
Docker版本： 18.06.1-ce
Kubernetes版本： 1.13.1
所有节点都需要安装以下组件：
Docker：不用多说了吧
kubelet：运行于所有 Node上，负责启动容器和 Pod
kubeadm：负责初始化集群
kubectl： k8s命令行工具，通过其可以部署/管理应用 以及CRUD各种资源
二、准备工作 我们需要在所有节点都进行如下操作：
1.安装Docker 详细安装方法可参考我的博客文章：《基于CentOS7安装Docker》
https://blog.csdn.net/lazy_moon/article/details/85260896
2.关闭防火墙 systemctl disable firewalld systemctl stop firewalld 3.禁用SELINUX setenforce 0 vi /etc/selinux/config 修改config文件中的内容如下：
SELINUX=disabled 4.所有节点关闭 swap 由于使用kubeadm安装，需要关闭swap，临时关闭的方法如下：
swapoff –a 永久关闭swap：
cp -p /etc/fstab /etc/fstab.bak$(date '+%Y%m%d%H%M%S') sed -i "s/\/dev\/mapper\/centos-swap/\#\/dev\/mapper\/centos-swap/g" /etc/fstab mount -a reboot 5.设置主机名和host映射 这部分不必再多讲。
三、安装Kubernetes 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b0507cf985aeed908dfefcddf21d6cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/225316f17ca7b771564edfebe43bab6f/" rel="bookmark">
			基于CentOS7安装Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CentOS的环境要求 Docker要求CentOS的系统内核要高于3.10，通过uname -r指令查看自己的CentOS内核版本是否符合规定。
[root@c7m1 ~]# uname -r
上面表示本机内核是符合要求的。
二、安装Docker 1.移除旧版本 较旧版本的Docker被称为docker或docker-engine。如果已安装这些，请卸载它们以及相关的依赖项。
yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-selinux \ docker-engine-selinux \ docker-engine 表示本机没有响应的软件包。
2.安装设置存储库 设置Docker的存储库并从中进行安装，以便于安装和升级任务。这是推荐的方法，但前提是该机器能够联网，本文采用这种方式安装。
在新主机上首次安装Docker CE之前，需要设置Docker存储库。之后，就可以从存储库安装和更新Docker。
执行以下指令，安装所需要的包：
yum install -y yum-utils device-mapper-persistent-data lvm2 如果需要的包成功安装：
3.设置稳定的存储库 在国内的开发环境中一般使用阿里云镜像，它的优点是快速、稳定：
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 设置好新的存储库后，需要更新yum缓存：
yum makecache fast 如下图所示：
4.查看可安装的Docker版本 通过以下指令可以查看可安装的Docker版本：
yum list docker-ce --showduplicates | sort –r 在这里我们选择的是docker-ce-18.06.1.ce-3.el7版本：
5.安装指定版本的Docker 通过以下指令可以安装我们指定的Docker版本：
yum install -y --setopt=obsoletes=0 docker-ce-18.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/225316f17ca7b771564edfebe43bab6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/912540141ddb0f5eb0a1112ab90df0b5/" rel="bookmark">
			嵌入式linux 线程内usleep与cpu调度时间片大小分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.在嵌入式linux平台下调用sleep或者usleep函数的CPU线程调度情况？
2.开发板上使用的时at91sam9261 ARM9 CPU芯片,主频240M，操作系统是linux2.6.28.10版本，那么在该操作系统下的线程调度的切换CPU时间片是多长，网上有地方说是linux2.6是线程切换CPU时间片默认是10ms,不知是否准确，不提升线程优先级的情况下能否将线程切换时间片改变（如改为1ms）？
3.at91sam9261 ARM9 CPU芯片,主频240M，操作系统是linux2.6.28.10版本，大概每秒中能处理多少条基本指令，是怎么算的？
例如：假如当前linux系统的线程切换CPU时间片是10ms，程序中我在某个线程中调用usleep(20000）；
情况a:如果当前系统线程不多的情况下（即cpu20ms内有足够的空余时间把其它的线程（这里都是指同优先级别的线程）都轮转一遍的情况）毫无疑问这个线程应该基本能够准确的usleep 20ms左右，误差范围应该是一个线程切换CPU时间片10ms吧。如果不是这样请确认说明一下？
情况b:如果当前系统线程很多的情况下（即cpu20ms内不足以把其它的线程（这里都是指同优先级别的线程）都轮转一遍的情况），系统还会在20ms左右重新将该线程再度调度起来吗？如果基本即时地在20ms左右将该线程再度调度起来了，那对其它同优先级别的还没有轮转到时间片的线程岂不是十分不公平，请问此种情况linux是怎么来调度的，调用usleep(20000）；后该线程还能在20ms左右后基本即时的被唤醒吗？
情况c:当前linux系统的线程切换CPU时间片仍然是10ms，如果我程序中的这个线程调用的usleep时间不是20ms,而是1ms,
即usleep(1000）；系统是否仍然是最少睡眠10ms,也就是usleep(1000）；的效果与usleep(10000）；效果是一样的
嗯，问题比较多，大家能说几点说几点吧，人多不能追加分数的话，就另外开贴再散吧。
|
主频也就是最大时钟频率，240M执行的指令不见得有240M那么多，因为有的指令周期不是单个时钟周期就可以完成的，是多时钟周期的。
情况C理解应该是对的。
|
进程不一定是完全用完一个时间片才调度的，也有可能是进程因为等待某个资源或条件主动放弃cpu
因此，usleep(1000）；的效果与usleep(10000）；不一定相同，但是肯定不是sleep 1ms了
|
呵呵，10ms
|
核心缺省设置为 HZ = 100，貌似就是 100ms
问题太多，看的头大
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c30261f0afdaa45758a57d8142ba7d86/" rel="bookmark">
			YUV格式初探（一）---NV12格式转RGB24的两种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最新需要将ffmpeg对视频硬解码之后的NV12格式通过操作像素的方式转换成RGB24，不是使用sws_getContext函数直接转换。网上找到了两个方法，分别测试可用但是效率大不相同
方式一：耗时：210ms左右 /* 功能：NV12 转 RGB24 耗时：210ms左右 使用举例：NV12_to_rgb24(0, srcSlice[0], RGB24, tex_w, tex_h) ; 因为没有区分 格式，因此第一个参数 随便写， 同时定义一个转换之后的指针： unsigned char RGB24[1920*1080*10] = {0}; */ static long int crv_tab[256]; static long int cbu_tab[256]; static long int cgu_tab[256]; static long int cgv_tab[256]; static long int tab_76309[256]; static unsigned char clp[1024]; //for clip in CCIR601 void init_yuv420p_table() { long int crv,cbu,cgu,cgv; int i,ind; static int init = 0; if (init == 1) return; crv = 104597; cbu = 132201; /* fra matrise i global.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c30261f0afdaa45758a57d8142ba7d86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca597c5e17f8fa87b9db830bdae82c37/" rel="bookmark">
			Ubuntu&#43;Apache2配置腾讯云ssl证书实现https
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu+Apache2配置腾讯云ssl证书实现https 前言 本文所用的服务器环境是 Ubuntu18.04 + Apache2 .通过部署 ssl 来达到默认使用https方式访问网站的目的。
超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。
历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。
— 来自《维基百科》
其实可以解决很大部分的运营商劫持问题，比如别人打开你的网站，网页上面会出现一些广告之类的，所以需要配置 https 来防止这个问题。
正文 Ubuntu 下 LAMP 环境的搭建，就不细说了，主要讲一下如何配置证书。
申请证书 打开腾讯云https://buy.cloud.tencent.com/ssl来获得腾讯云提供的免费证书：
点击域名型免费版，然后进去填一下网址和邮箱即可申请到。
过了几分钟，就会受到一个邮件，是一个压缩包，里面有各种服务器的 ssl 证书文件，我们进入 Apache2 这个目录，然后发现里面有三个文件：
1_root_bundle.crt # 证书文件 2_xxx.xxx.xxx.crt # 证书文件 3_xxx.xxx.xxx.key # 私钥文件 1_root_bundle.crt包含一段代码-----BEGIN CERTIFICATE-----和-----END CERTIFICATE-----2_xxx.xxx.xxx.crt文件包括一段证书代码-----BEGIN CERTIFICATE-----和-----END CERTIFICATE-----3_xxx.xxx.xxx.key文件包括一段私钥代码-----BEGIN RSA PRIVATE KEY-----和-----END RSA PRIVATE KEY----- 这是这几个文件的作用。
配置证书 在这里，我假设你已经会配置基本的/etc/apache2/sites-available/000-default.conf这个文件来达到已经可以通过 http 的方式来访问你的站点。
在/etc/apache2这个目录下，有两个有关的目录sites-available和sites-enabled，我们进入sites-enabled目录下可以发现，里面有一个文件000-default.conf
lrwxrwxrwx 1 root root 35 Dec 28 15:24 000-default.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca597c5e17f8fa87b9db830bdae82c37/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6677da548ebf8c67e0d1313a5ee08eb8/" rel="bookmark">
			POST 下载文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求背景 遇到个需求，需要根据用户输入的id列表下载文件。一般情况下，下载文件用GET请求就能满足需求，但是，这个需求的请求参数中可能有上千个id，GET请求很可能超出浏览器参数长度限制。那么该怎么解决这个问题呢？
解决方案 请求方式基本可以确定只能用POST了，而直接用Ajax发POST请求是不行的。经过一番调研，总结两种方案：
可以后台接到请求后生成下载文件，放到静态文件目录，然后返回文件路径，前端拿到路径后用GET请求拉取文件。此方案可行，但是我们的静态文件都在亚马逊服务器上，还要把文件上传到亚马逊服务器，然后前端去亚马逊服务器拉取文件，总感觉绕个弯怪怪的。所以有了下边的方案2；客户端使用POST表单提交请求，不要用Ajax。示例代码如下： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;下载文件示例程序&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick="downloadExcel()"&gt;下载&lt;/button&gt; &lt;script type="text/javascript"&gt; function downloadExcel(){ download("http://localhost:8080/download", {"ids": "10000,10002"}); } /** * post方式下载文件 * @param {[string]} url 接口 * @param {[json]} data 数据 * @return */ function download(url, data){ var body = document.getElementsByTagName('body')[0]; var form = document.createElement('form'); form.method = 'POST'; form.action = url; for(key in data){ var param = document.createElement('input'); param.type = "hidden"; param.name = key; param.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6677da548ebf8c67e0d1313a5ee08eb8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19100e9daaf2d052bbc8770be017216d/" rel="bookmark">
			C&#43;&#43; 随机函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.产生随机数：
rand()：内部实现是用线性同余法做的，它不是真的随机数，因其周期特别长，故在一定的范围里可看成是随机的。
rand()返回一随机数值的范围在0至RAND_MAX 间。RAND_MAX的范围最少是在32767之间(int)。
所在的头文件：#include &lt;cstdlib&gt; // 标准库
实现代码：
#include &lt;iostream&gt; #include &lt;cstdlib&gt; // 标准库 using namespace std; int main(int argc, const char * argv[]) { cout &lt;&lt; rand() &lt;&lt; endl; cout &lt;&lt; rand() &lt;&lt; endl; return 0; } 运行结果：
2.如果没加srand()初始化随机数发生器，会发现rand虽然产生了随机数，但是重复运行会发现随机数
不会变。同样是下面对应的两个数。用户未设定随机数种子时，系统默认的随机数种子为1。
3.srand()初始化：rand()产生的是伪随机数字，每次执行时是相同的;若要不同,用函数srand()初始化它。
语法：void srand(unsigned int seed); 所在头文件：cstdlib
参数seed必须是个整数，通常可以利用time(0)的返回值或NULL来当做seed。
#include &lt;iostream&gt; #include &lt;cstdlib&gt; // 标准库 #include &lt;ctime&gt; using namespace std; int main(int argc, const char * argv[]) { srand((unsigned)time(NULL)); cout &lt;&lt; rand() &lt;&lt; endl; return 0; } 运行结果：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3943c225d4c6543a86792212dafe8f4f/" rel="bookmark">
			ajaxResult
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ajax的result工具类为前后台交互提供了更大的变量
前台ajax:
$.ajax({ url : "&lt;%=request.getContextPath()%&gt;/xxx", // 请求地址 type : "get", // 请求的类型 data : { person_id : person_id }, // 请求的数据,规定连同请求发送到服务器的数据 success : function(data){ // 请求成功时的回调函数 flag = rs.success; if(flag){ alert("删除成功!"); } }, }) 后台Java：
@RequestMapping("/xxx") @ResponseBody public Result&lt;String&gt; method(HttpServletRequest request){ Result&lt;String&gt; rs = new Result&lt;&gt;(); String supplierId = request.getParameter("personId"); xxService.XXmethod(personId); rs.setSuccess(true); return rs; } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/437/">«</a>
	<span class="pagination__item pagination__item--current">438/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/439/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>