<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de59df62657b1f64101ed98ac5b4efe1/" rel="bookmark">
			【mysql系列】windows安装mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载 1、下载压缩包 方式一：公众号获取 关注微信公众号【I am Walker】，回复“mysql”获取
方式二：官网下载 安装地址
https://dev.mysql.com/downloads/mysql/
2、解压 下载完之后进行解压，解压之后将其移动到自己想要移动的路径，并记住自己的路径，
安装 1、使用管理员权限打开命令行提示符 1、找到命令提示符
2、右键，点击以管理员的身份运行
2、进入mysql的bin目录 复制安装的mysql的bin目录，切换到该目录
3、执行安装语句mysqld --install 问题 1、安装拒绝
这个原因是因为没有使用命令行的管理员权限
mysql初始化 切换到bin目录，进行执行
1、执行初始化指令mysqld --initialize --console 之后会生成一个随机密码，将其复制起来
2、启动Mysql 使用指令net start mysql
3、登录测试 执行指令mysql -u root -p，之后输入密码【密码为随机生成的密码，这里可能没法复制，需要自己手动打】
修改密码 1、执行修改密码指令 ALTER USER "root"@"localhost" IDENTIFIED BY "新密码";
例如
2、重新验证 环境配置 使用环境配置的目的，使我们不需要每次都进入到安装目录bin路径下，在初始命令行路径下就可以使用mysql了，例如：
执行步骤 1、找到高级系统设置，并进入环境配置 如果不是win10的话，也可以使用这种方式进行查找
点击"我的电脑"–&gt;“属性”–&gt;’‘高级系统设置’’–&gt;’‘环境变量’
2、创建变量mysql 3、新增path路径 %mysql%\bin
4、创建初始配置文件 创建my.ini文件 mysql初始文件
打开文件
将下面的文字复制进去
[mysqld] character-set-server=utf8mb4 bind-address=0.0.0.0 port=3306 default-storage-engine=INNODB [mysql] default-character-set=utf8mb4 [client] default-character-set=utf8mb4 5、测试 使用ctrl+R,输入CMD 打开命令
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de59df62657b1f64101ed98ac5b4efe1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb7a3408059e3afae1040c3815e681bc/" rel="bookmark">
			调取小程序当前经纬度位置及计算两点之间距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调取小程序公共的getLocation接口，这个接口可以开启高精度模式，但是返回的数据可能会较慢，而且这个接口大概20S内只能调用一次，是无法反复调用的。调取方法如图所示：
wx.getLocation({ //小程序 的获取当前的位置经纬度 type: 'gcj02',
isHighAccuracy: true,
success(res) {
that.setData({ //给经纬度赋个值吧
curLat: res.latitude,
curLon: res.longitude
})
如图所示curLat和curLon就是返回的经纬度，isHighAccuracy代表开启高精度。
如果是要求调取频率较高获取经纬度的话，就不能用上面这个API，要用另外两个API组合调用，分别为startLocationUpdate和onLocationChange，通过这两个API就可以持续性获得当前所在位置的API，但是这种耗电较高。获取到两次经纬度之后进行计算算取两点间距离，使用方法如图所示。
wx.startLocationUpdate({
success: (res) =&gt; {
wx.onLocationChange((data) =&gt; {
//获取当前时间
var currentTime = new Date().getTime();
//获取上次保存的位置信息
var oldLocation = wx.getStorageSync('oldLocation');
//获取上次执行的时间
var oldTime = wx.getStorageSync('oldTime');
//将经纬度拼接
var newLocation = data.latitude + "" + data.longitude;
console.log("更新了计算距离", newLocation,
"精度：", data.horizontalAccuracy, "距离：", that.data.distance)
if (currentTime - oldTime &gt; 1000) {
that.setData({ //给经纬度赋个值吧
chooseLat: data.latitude,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb7a3408059e3afae1040c3815e681bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac20ff74fc3acfd5b32c6a7083f63a2/" rel="bookmark">
			使用python来实现接收手机验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实现接收手机验证码的方式有很多，下面是其中一种使用Python的方法：
使用第三方短信API，如阿里云短信、腾讯云短信等。这些API提供了发送短信和接收短信的功能，你可以通过调用它们的接口实现发送验证码和接收验证码。
创建一个接收短信的服务，接收到短信后使用Python脚本进行处理。接收短信的服务可以使用Twilio、Nexmo等第三方服务。
以上是实现接收手机验证码的几种方法，具体实现方式取决于你的需求和选择的短信服务。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3daa84d8279c25f3f4a682547aa783aa/" rel="bookmark">
			k8s 1.24 创建管理员及部署Kubernetes Dashboard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 背景：在AWS EKS上部署的Kubernetes。版本1.24， 早期的版本会有所不一样。
另外提醒：这个长期token，注意安全。
创建管理员配置文件 mysecretname.yaml
apiVersion: v1 kind: Secret type: kubernetes.io/service-account-token metadata: name: eks-admin annotations: kubernetes.io/service-account.name: eks-admin 创建Secret
#kubectl -n kube-system create -f mysecretname.yaml 查看该 Secret 的详细信息，其中包括token信息
#kubectl -n kube-system describe secret eks-admin 删除令牌 #kubectl delete secret eks-admin 安装Kubernetes Dashboard #curl -O https://raw.githubusercontent.com/kubernetes/dashboard/v2.4.0/aio/deploy/recommended.yaml #kubectl apply -f recommended.yaml 启动kubectl proxy #kubectl proxy 附：有token，使用kubectl 管理k8s 配置kubectl config #kubectl config set-credentials eks-admin --token= xxxxx #kubectl config set-cluster Egatee-EKS-UAT-SG --insecure-skip-tls-verify=true --server=https://xxxx.com #kubectl config set-context contextname --cluster=集群名称 --user=eks-admin 应用config #kubectl config use-context contextname 测试 #kubectl get pods -A 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7e7d624cd5182b385f3f7014c66f4f2/" rel="bookmark">
			二三层转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是二层转发：
当源ip地址和目的ip地址在同一个网段的时候，只需要进行二层转发即可。
当正常情况下，我们需要访问某个地址时，必然需要知道对方的IP地址，这个是必然条件，比如我们访问www.baidu.com这个网址，其实访问的也只是百度的IP地址，只不过期间经过了DNS域名解析，将这个域名地址解析成一个IP地址这个过程。
这就像是我们发快递，必然要知道收件人的姓名（这也就相当于收件人=目的IP，发件人=源IP）然后我们还需要知道对方的目的地址在哪。（目的地址和源地址就像是IP地址的掩码），如果我跟对方在同一个城市，那么我们就不需要使用快递，直接本地把快递给别人即可。这个就是二层转发，也就是当源IP和目的IP在同一个网段时，这时候只需要进行二层转发即可。 二、什么是三层转发： 当我们发送报文时，发现源IP和目的IP不在同网段，那这时候就需要网关这个参数。
网关的作用就像是快递员，当我们发快递需要发往其他城市时，肯定不会为了一个小东西就直接开车前往其他城市，那这时候比较方便的做法就是寄快递，将东西（报文）交给快递员，然后由快递员在各个城市之间转发，直至最后到达收件人的手上。 ​ 所以在这个过程中，我们的源IP和目的IP肯定是不能变化的。这就像是收件人和寄件人姓名和地址，必然不能发生变化，而变化的在于快递是在谁手上，比如一开始报文从我的手上发给快递员A，那这时候源MAC则是我，目的MAC则是快递员A，然后当快递到达了快递员A手上后，可能需要发往其他城市的其他快递员手上，那这时候报文在到达快递员A后，会重新进行封装，将源MAC修改成快递员A，目的MAC修改成快递员B。直至最后，当快递员B找到收件人，则将报文的源MAC修改成快递员B，目的MAC修改成收件人本人。 三、为什么需要区分二层和三层的转发区别： 当报文需要进行二层转发时，是不需要查找三层的路由表信息的，而且二层转发的时候也不会对报文里面的某些字段进行修改，这样，二层转发的速度和效率必然远远高于三层转发。
当报文需要进行三层转发时，需要将目的MAC，目的IP字段进行识别，然后在根据目的IP地址的网段在自己的路由表中进行查找，匹配，然后对应ARP里面的信息，进行转发。 这个过程毋庸置疑是比二层转发要慢的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54701c974681656b9c15cacdb7d9d472/" rel="bookmark">
			补充：tensor之间进行矩阵相乘的方法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用@进行简单的矩阵乘 @符号在tensor中就表示矩阵相乘，@符号的矩阵相乘性质在numpy中依然适用。
首先矩阵相乘的双方必须满足可以矩阵相乘的条件@只会关注两个矩阵最里面的两个维度是否符合条件，外面的维度都只表示矩阵运算的次数，甚至两个矩阵只要满足广播的条件和里面两个维度可以进行矩阵乘，二者的维度都可以不一样。 torch.mul 一定要注意这个函数是陷阱！其与*的作用是完全一样的，其不管相乘的双方维度如何，执行的都是对位相乘的操作， *与torch.mul均不能实现矩阵相乘的规则。
torch.mm torch.mm是阉割版的@，其只能对二维的tensor进行矩阵相乘，高了的维度其不会进行广播 ↓
a=torch.ones((2,3)) b=torch.ones((3,4)) print(torch.mm(a,b)) ''' tensor([[3., 3., 3., 3.], [3., 3., 3., 3.]]) ''' torch.matmul 其作用与@完全相同 ↓
a=torch.ones((1,2,2,3)) b=torch.ones((2,1,3,4)) print(torch.matmul(a,b)) ''' tensor([[[[3., 3., 3., 3.], [3., 3., 3., 3.]], [[3., 3., 3., 3.], [3., 3., 3., 3.]]], [[[3., 3., 3., 3.], [3., 3., 3., 3.]], [[3., 3., 3., 3.], [3., 3., 3., 3.]]]]) ''' 总结：就认准@就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39f0e60b8277c0541e702feffe7a6687/" rel="bookmark">
			mybatis&#43;testng完成数据驱动测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据驱动解决了大量脚本重复的问题，实现了脚本与数据的解耦。比如一个功能，要验证在不同的输入值下产品的运行情况，就可以很好的利用数据驱动测试。把数据存在csv、xls、yaml、数据库中，需要的时候去相应文件中获取。每次执行用例之前，把上次生成的业务数据删掉，可以保证测试数据的重用。数据驱动测试的思想可以运行在ui自动化测试，api测试，单元测试中。
testng的Data Provider很好的实现数据驱动，现在用mybatis+testng进行数据驱动测试讲解。
用到的jar包
&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; mybatis-config.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;!-- 填写自己的mysql用户名和密码， 还有连接的url要加上"?serverTimezone=GMT%2B8"不然会报错 --&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mock?serverTimezone=GMT%2B8" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mapper/TestDataMapper.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; TestDataMapper.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE mapper PUBLIC "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39f0e60b8277c0541e702feffe7a6687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fac545722bbdb574c41fc3d07bdb45f4/" rel="bookmark">
			一篇带你揭开 go mod 的面纱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		go module 在go1.16版本发布后，go module由原来的默认值 auto 变为 on 了，这意味着后续开发中，go更推荐用go module 模式开发，而不是gopath模式开发了。
在之前，我也是大多数以go module模式进行golang开发，但至今对其不熟悉，仅仅停留在：别人是这样做的，我跟着做就是了 ，这都算不上会使用go module， 更不必说熟悉或者精通了；在此之前，我会存在这些疑问：
go mod文件中定义的各项内容代表什么；除了常见的 require 、偶尔见 replace 关键字外，exclude 、retract （1.16）这些关键字是什么，怎么用；go mod文件语法格式是什么，目前除了跟着别人写，好像也不明白其中的语法github.com/tal-tech/go-zero v1.1.5 、github.com/antlr/antlr4 v0.0.0-20210105212045-464bcbc32de2
、google.golang.org/protobuf v1.25.0 // indirect 等格式分别代表什么，为什么有的还有
// indirect 修饰；go.mod下面为什么有一个go.sum，其有什么作用；… 不知道有多少人和我一样，对go module的了解微不足道。
最近，带着这些疑惑，去学习了官方的参考手册，这些疑惑就引刃而解了。
project 在正式进入module介绍前，有必要首先了解一下project和module的关系，相信开发过Android或者Java的同学对module有非常好的理解，通俗的讲，一个project可以有多个module组成，module可以作为独立
的project被别的project作为依赖引用，如下golang工程 demo 中就包含了 foo 和 bar 两个module
demo ├── bar │ └── go.mod └── foo └── go.mod module介绍 go module(以下称：module、模块、工程模块)
是golang中已发布版本的package的集合，是Go管理依赖的一种方式，类似Android中的Gradle，Java中的Maven，当然，他们的管理形式肯定是大相径庭，但是目的都是一致的，对依赖进行管理。
在go.mod中，其包含了main module的module路径、module依赖及其关联信息（版本等），如果一个工程模块需要以
go module mode（module模式）开发，在工程模块的根目录下必须包含 go.mod 文件。
module path(module路径) module路径是一个工程模块中的名称，在go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fac545722bbdb574c41fc3d07bdb45f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/726fcc864272cc5e7be24a5669900b61/" rel="bookmark">
			Android SVG认知误区？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：http://blog.csdn.net/zhaoyanjun6/article/details/128907538
本文出自【赵彦军的博客】
文章目录 前言为什么svg 在编译期间，会自动生成多份图片？优化建议 前言 为了更好的视觉效果，经常在项目中使用了 svg （可缩放矢量图形），如下：
查看包体积：
查看apk 包体积，可以看到在 xhdpi、xxhpdi、xxxhpdi 分别生成了图片，并且有的比较大。
为什么svg 在编译期间，会自动生成多份图片？ Android5.0（即API21）开始支持SVG, 生成多份图片是为了向后兼容。
对于 minSDK &lt; 21 , 会自动生成多份图片，而我的项目 minSDK 为 20 ；
minSDK &gt;= 21 , 只会保留xml ，不会生成多份图片。
附上svg 官方文档：https://developer.android.com/studio/write/vector-asset-studio?hl=zh-cn
优化 把所有 大svg 换成 png , 最后压缩成 webp , 包体积减小 0.7M
建议 1、不是排斥所有的svg , 有些 svg 本身很小，只有几b，即时生成多份 png 也会很小，对整体影响不大。所以要特别注意 大 svg ，避免滥用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92928b5645cd1ee8e9525d3a7c55ca01/" rel="bookmark">
			C&#43;&#43;Primer第五版——习题答案&#43;详解(完整版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++Primer第五版——习题答案详解
新手入门必看的书。知识是一个系统化并且相互关联的体系，零散的东西每天收获如果不形成自己的体系的话，那将是毫无意义的，所以我觉得有必要将这本书先啃一遍，消化其中的关键有用的东西，了解相关但是目前不那么重要的东西。博客不是我的目的，将这本书中的知识啃透才是我的目标！共勉！
看的不快不慢，有很多东西暂时确实用不上，所以很多都没有深入的探讨，但是知识点覆盖的很全面，每一道题涉及的知识点都写上简单的解释。
文中代码的中文注释也尽量详细阐述，自己皆编译通过。
水平有限，如有有误之处，希望大家不吝指教！
不断学习中，肯定会写完的！欢迎交流。(~~最新学习过程更新见结尾~~)
第一章
全部题目(第一章基础较多)C++Primer第五版 第一章习题答案（部分）_MISAYAONE的博客-CSDN博客_c++ primer答案
第二章
1~10题：C++Primer第五版 第二章习题答案（1~10）_MISAYAONE的博客-CSDN博客
11~20题：C++Primer第五版 第二章习题答案（11~20）_MISAYAONE的博客-CSDN博客_c语言第五版第二章答案
21~30题：C++Primer第五版 第二章习题答案（21~30）_MISAYAONE的博客-CSDN博客
31~41题：C++Primer第五版 第二章习题答案（31~41）_MISAYAONE的博客-CSDN博客
第三章
1~10题：C++Primer第五版 第三章习题答案（1~10）_MISAYAONE的博客-CSDN博客
11~20题：C++Primer第五版 第三章习题答案（11~20）_MISAYAONE的博客-CSDN博客
21~30题：C++Primer第五版 第三章习题答案（21~30）_MISAYAONE的博客-CSDN博客
31~40题：C++Primer第五版 第三章习题答案（31~40）_MISAYAONE的博客-CSDN博客_c++primer第五版练习13.31
41~45题：C++Primer第五版 第三章习题答案（41~45）_MISAYAONE的博客-CSDN博客
第四章
1~10题：C++Primer第五版 第四章习题答案（1~10）_MISAYAONE的博客-CSDN博客_c++ primer第五版第四章答案
11~20题：C++Primer第五版 第四章习题答案（11~20）_MISAYAONE的博客-CSDN博客
21~30题：C++Primer第五版 第四章习题答案（21~30）_MISAYAONE的博客-CSDN博客
第五章
1~10题：C++Primer第五版 第五章习题答案（1~10）_MISAYAONE的博客-CSDN博客
11~20题：C++Primer第五版 第五章习题答案（11~20）_MISAYAONE的博客-CSDN博客_c++primer第五章习题答案
21~25题：C++Primer第五版 第五章习题答案（21~25）_MISAYAONE的博客-CSDN博客_c++primer第五版第五章答案
第六章
1~10题：C++Primer第五版 第六章习题答案（1~10）_MISAYAONE的博客-CSDN博客
11~20题：C++Primer第五版 第六章习题答案（11~20）_MISAYAONE的博客-CSDN博客
21~30题：C++Primer第五版 第六章习题答案（21~30）_MISAYAONE的博客-CSDN博客
31~40题：C++Primer第五版 第六章习题答案（31~40）_MISAYAONE的博客-CSDN博客
41~50题：C++Primer第五版 第六章习题答案（41~50）_MISAYAONE的博客-CSDN博客
51~56题：C++Primer第五版 第六章习题答案（51~56）_MISAYAONE的博客-CSDN博客
第七章
1~10题：C++Primer第五版 第七章习题答案（1~10）_MISAYAONE的博客-CSDN博客
11~20题：C++Primer第五版 第七章习题答案（11~20）_MISAYAONE的博客-CSDN博客
21~30题：C++Primer第五版 第七章习题答案（21~30）_MISAYAONE的博客-CSDN博客_c++primee 7 .21习题答案
31~40题：C++Primer第五版 第七章习题答案（31~40）_MISAYAONE的博客-CSDN博客_c++ primer第五版练习7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92928b5645cd1ee8e9525d3a7c55ca01/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a9484db530823f40a94d7b60e218001/" rel="bookmark">
			Android禁用横竖屏切换那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序 在Android中，我们经常遇到横竖屏切换的问题，可是在目前的大多数界面我们是不需要支持横竖屏切换的，这时候就需要禁用它，下面介绍常用的禁用方法。
禁用方法一：
在清单文件中：
&lt;activity
android:name=".MainActivity"
android:screenOrientation="portrait|landscape" /&gt;
portrait表示竖屏，landscape表示横屏。 这样就可以设置该activity的固定显示模式。
禁用方法二:
竖屏
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT)
横屏
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE)
统一设置禁用
我们知道一个项目中有许多个Activity，那每个Activity都设置一个不是很麻烦？
其实我们将属性设置在BaseActivity（所有Activity的父类）即可。
如果有个别的不需要禁用横竖屏：
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED)
横竖屏切换时的逻辑操作 if(getResources().getConfiguration().orientation==Configuration.ORIENTATION_LANDSCAPE){
//横屏逻辑
}else{
//竖屏逻辑
};
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8ecbe63d3facc14c805a9ac3d03ab4b/" rel="bookmark">
			Golang之mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、事务的属性（ACID） （1）原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
（2）一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。
（3）隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
（4）持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。
2、并发性问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:
（1）脏读: 对于两个事务 T1、T2, T1 读取了已经被 T2 更新但还没有被提交的字段，之后, 若 T2 回滚, T1读取的内容就是临时且无效的。
（2）不可重复读: 对于两个事务T1、T2, T1 读取了一个字段, 然后 T2 更新了该字段，之后, T1再次读取同一个字段, 值就不同了.
（3）幻读: 对于两个事务T1、T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插 入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.
3、事务隔离级别，即一个事务与其他事务隔离的程度称为隔离级别 read uncommitted会出现脏读、不可重复读、幻读read committed会出现不可重复读、幻读repeatable read会出现幻读serializable（串行化）不会出现并发性问题，但性能低下 Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED Mysql 支持 4 种事务隔离级别，
Mysql 默认的事务隔离级别为: REPEATABLE READ，可重复读能够保证一个事务执行过程中看到的数据跟这个事务在启动时看到的数据是一致的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8ecbe63d3facc14c805a9ac3d03ab4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be2ac6cae830a9f95a3e6a11a7a1b519/" rel="bookmark">
			C&#43;&#43;实现数独（附带过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，来到这里的人应该都知道数独是什么。
那么，如果没有c++,你，在面对数独时会怎么做？
1.纯方法 1.摒除法：用数字去找单元内唯一可填空格，称为摒除法，数字可填唯一空格称为摒余解（隐性唯一解）。 就是通过某一个格子所在行与列和宫，确定当前格子上的数：
1345(x)5(x)5(x)55(x)5(x)555 根据已知三个“5”，排除一宫8个格子，得到“5”的掘除法
#ifndef SHUDUFA_H #define SHUDUFA_H//定义头文件 #include&lt;bits/stdc++.h&gt; using namespace std; typedef pair&lt;int,int&gt; P; P ji[11]; int kuai[11][11],lie[11][11],hang[11][11],ma[11][11],k,mm[11][11]; inline int d(int pd,int x,int y) {if(pd==1) return x; else return y;} inline int find(int num) { int jinum=0; for(int i=1;i&lt;=9;i++) for(int j=1;j&lt;=9;j++) if(ma[i][j]==num) ji[++jinum]=P(i,j); return jinum; }//find(i)表示寻找数独上所有i数字的坐标并存于ji[i]中。 inline void biao_hui(int p,int x,int y,int val,int howk) { hang[x][val]=p; lie[y][val]=p; kuai[howk][val]=p; mm[x][y]=1; ma[x][y]=p*val; k+=2*p-1; }//biao_hui(p,x,y,val,howk)表示将数独第（x,y）个格子填入val且仅当p=1,标记（p=0时为回溯） inline void does(int i1,int i2,int j1,int j2,int temp[11][11],int num,int howk) { int sum=0,x,y; for(int i=i1;i&lt;=i2;i++) { for(int j=j1;j&lt;=j2;j++) { if(temp[i][j]) sum++; else x=i,y=j; } } if(sum==8&amp;&amp;kuai[howk][num]==0) biao_hui(1,x,y,num,howk);//宫内唯一解 } inline void tian(int shu,int num) { int temp[11][11]; for(int j=1;j&lt;=9;j++) for(int kk=1;kk&lt;=9;kk++) temp[j][kk]=mm[j][kk];//记录那些位置没填，temp与mm此处功能一样。 for(int i=1;i&lt;=shu;i++) { int x=ji[i].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be2ac6cae830a9f95a3e6a11a7a1b519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d0de20d90a6caa2edf27889198582fa/" rel="bookmark">
			身份验证之Cookie、Session、Jwt
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于HTTP是一种无状态的协议，每个请求是独立的（这个说法比较片面），因此服务端无法确认当前请求着的身份。因此，对于web开发者来说，用户身份认证成了一种最基础，也是非常有必要的技能。当然，基于Koa开发的Web应用，也同样需要掌握这些基础技能。
基本概念 什么是认证（Authentication） 通俗地讲就是验证当前用户的身份，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）。
互联网中的认证
用户名密码登录邮箱发送登录链接手机号接收验证码只要你能收到邮箱/验证码，就默认你是账号的主人 什么是授权（Authorization） 用户授予第三方应用访问该用户某些资源的权限你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）实现授权的方式有：cookie、session、token、OAuth 什么是凭证（Credentials） 实现认证和授权的前提是需要一种媒介（证书）来标记访问者的身份。
在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。 什么是 Cookie HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
cookie存储在客户端：cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。cookie是不可跨域的：每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。 cookie 重要的属性 name=value：键值对，设置Cookies的名称以及相对应的值，都必须是字符串类型，如果是值为Unicode字符，需要为字符编码，如果值为二进制，则需要使用BASE64编码。domain：绑定cookie所属的域名，默认是当前域名path：指定Cookie在哪个路径下面生效，默认是/，如果设置为/abc，则只有/abc下的路由可以访问到该cookie，如/abc/defmaxAge：Cookie失效的时间，单位秒，如果为整数，则该Cookie在maxAge秒后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器不会以任何形式保存该Cookie，如果为0，则表示删除该Cookie。默认为-1，比expires好用expires：过期时间，在设置的某个时间点后该Cookie就会失效。一般浏览器的Cookie都是默认存储的，当关闭浏览器结束这个会话的时候，这个Cookie也会被删除。secure：该Cookie是否仅被使用安全协议传输。安全协议有Https，ssl等，在网络上传输数据之前，先将数据加密，默认为false。当secure值为true时，cookie在Http中是无效的，在https中才有效。httpOnly：如果给某个Cookie设置了HttpOnly属性，则无法通过js脚本读取到该Cookie的信息，但还是能通过Application中手动修改cookie，所以只是在一定程度上可以防止XSS攻击，不是绝对的安全。 什么是 Session session 是另一种记录服务器和客户端会话状态的机制session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中 session 认证流程 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d0de20d90a6caa2edf27889198582fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b2bcc130ae29c1e6365a130818521a6/" rel="bookmark">
			叶尖速比与风力利用系数之间的关系曲线（代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		风力发电机功率与物理参数之间的关系为：
Cp为风能利用系数，是桨距角 与叶尖速比 的函数，具体的关系可表示为：
根据上述公式，叶尖速比与风力利用系数之间的规律如图所示。
可见，每一个确定的桨距角，都存在一个最大风力利用系数，随着桨距角的变大，最大风力利用系数降低，其对应的叶尖速比也降低。在 r 一定的情况下，可以通过改变叶尖速比 和桨距角 来调整达到合理利用风能的目的。
绘图代码：
set(0,'defaultfigurecolor','w')
C1=0.5173;
C2=116;
C3=0.4;
C4=5;
C5=21; C6=0.0068;
lada=0.01:0.01:18;
for beta=0:10:20
Cp=C1.*((1./(lada+0.08.*beta)-0.035./(beta.^3+1)).*C2-C3.*beta-C4).*exp(-1.*(1./(lada+0.08.*beta)-0.035./(beta.^3+1)).*C5)+C6.*lada;
plot(lada,Cp)
hold on
end
ylim([0,0.6])
xlabel('λ')
ylabel('Cp')
legend('0°','10°','20°')
title('变桨距角的风能利用率曲线')
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/752d75ebc937c8274e58bfbbed6a7a08/" rel="bookmark">
			【转载&#43;补充】“最简单的” 相机透视投影矩阵推导与解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接 作者：大其心宏其量扩其识
链接：https://www.jianshu.com/p/09fef48e7b0f
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
原文写得很好，但是主题格式我不太喜欢，所以我对文章的格式和重点的部分进行了 补充校正，方便自己日后阅读
正文 相机透视投影矩阵的 目标 是将 视锥体 内的顶点映射到 规范观察立方体 （NDC）内
以前总是记不住透视投影矩阵的推导，现在回过头翻看其实就可以总结为以下 4 步
相似三角形人为构造线性映射解方程 透视锥到标准设备坐标
相似三角形计算（ x e x_{e} xe​-&gt; x p x_{p} xp​ 和 y e y_{e} ye​-&gt; y p y_{p} yp​） 先用 相似三角形 的原理，计算出 x e x_{e} xe​ 和 y e y_{e} ye​ 在 近裁剪面 上的投影 $x_{p} 和 $ y p y_{p} yp​
左：顶视图 右：侧视图
先计算 x 轴
同理，再计算 y 轴
人为构造第四行 因为 x p x_{p} xp​, y p y_{p} yp​ 都与 − z e -z_{e} −ze​ 成反比，因为相机空间的坐标被 GL_PROJECTION 矩阵转换后还是 齐次坐标，最终得到 NDC 坐标是通过除以 裁剪坐标 的 w w w 元素来得到的，所以把 − z e -z_{e} −ze​ 当作裁剪坐标的 w w w 元素
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/752d75ebc937c8274e58bfbbed6a7a08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdd75e506b5562b499487ee01dcb6c2a/" rel="bookmark">
			【转载】“最简单的” Unity 光照探头总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接 版权声明：本文为CSDN博主「zengjunjie59」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zengjunjie59/article/details/123899729
原文写得很好，我对文章的格式进行一些调整，并修正+补充了一些内容
正文 作用 PBR 流程中，光照探头用于在 光照没有变化 的情况下，给 动态 物体提供 间接光 的 漫反射 信息。
内容对应某位大佬的视频：Light Probes 基本理论介绍_哔哩哔哩_bilibili
整个流程 第一步：记录所有探头的数据 在烘培的时候，光照探头需要记录周围 360 度的颜色信息。类似 反射探头 的 cubemap ，但是由于光照探头非常多，而且 cubemap 占用内存太多，所以实际储存 不可能 用 cubemap ，而是储存着 球谐函数某几个基函数的系数。当实际渲染进行采样的时候，用这几个系数和球谐函数基函数来 还原 周围的颜色信息。这里的思想和 傅里叶变换 是一样的，也是用几个简单的信息基函数，通过不同的系数来还原一个复杂的信号。
傅里叶变换 如下图：
c1 是第一个基函数的系数，f1 则是第一个基函数。通过这种组合方式还原出复杂的原信号。
而 球谐函数 也是，通过
系数 1 ∗ 基函数 1 + 系数 2 ∗ 基函数 2.... 系数1*基函数1+系数2*基函数2.... 系数1∗基函数1+系数2∗基函数2....
的形式来 还原 出光照探头原本位置的 Cubemap 颜色信息，只不过球谐函数是建立在 球坐标系 上的，而傅里叶变换则是建立在 二维笛卡尔坐标系 上的，当然，这并不能百分百还原。总的来说，烘焙 光照探头就是 记录几个基函数的系数 以此来记录探头周围的颜色信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdd75e506b5562b499487ee01dcb6c2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0009b47d5a3e7af956df6841d28465f3/" rel="bookmark">
			【OpenMMLab】模型训练常见策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模型训练范式 范式一：监督学习
在有标注的数据上进行模型训练，如VGG、ResNet等网络模型
范式二：自监督学习
通过恰当设计辅助任务,让模型在无标注的数据上进行模型训练，如MAE
当前的深度学习网络架构基本都是基于梯度下降的训练策略，其完整过程流程图为：
二、调参 参数对于模型的效果至关重要，下图给出了不同网络架构的最优参数配置：
常见的参数配置和训练策略包括但不限于：
1. 权重初始化策略 1）随机初始化，包括分布采样（如均匀分布或高斯分布）、Xavier方法和Kaiming 方法
2）预训练权重初始化
2. 学习率策略 包括退火策略、warm up策略
3. 优化器策略 包括动量优化器、权重衰减、自适应梯度
4. 权重保存策略 包括早停机制、模型权重平均（EMA）、模型权重平均（SWA）
5. 数据加强策略 在CV领域，常见的数据加强策略包括：几何变换、颜色变换、遮挡、旋转、翻转、图片组合（如mixup、cutmix等）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/817029bbbacf5c06568d71b5f5223bed/" rel="bookmark">
			python将文本信息拷贝到剪切板(解决selenium send_keys输入文本很慢,会卡住的情况)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 python将文本信息拷贝到剪切板可以使用pyperclip库就能很简单的实现 使用pyperclip.copy将文本拷贝到剪切板
import pyperclip # 导入需要的库 pyperclip.copy("123") # 将123拷贝到剪切板 而要输出剪切板的内容则可以使用pyperclip.paste()
s = pyperclip.paste() # 得到剪切板的数据 print(s) 注:在使用selenium的时候有时我们需要向文本框里输入的推送的内容较多,这个时候就会很慢,会卡很久,这就很影响我们的执行效率,此时我们可以使用pyperclip来解决
selenium使用pyperclip 在selenium中我们可以使用send_keys来配合pyperclip就可以很快的输入较长的文本,如
from selenium.webdriver import Keys from selenium.webdriver.common.by import By # 使用Ctrl+V来进行粘贴剪切板的数据 driver.find_element(By.XPATH, "//textarea[@class='text']").send_keys(Keys.CONTROL, 'v') 感谢您的阅读! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af35890769c27fcc7588e1fafd61a42/" rel="bookmark">
			系统编程之进程间的 信号量 通信（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一章 系统编程之多进程
第二章 系统编程之进程间的 管道 通信（1）
第二章 系统编程之进程间的 信号 通信（2）
第二章 系统编程之进程间的 共享内存 通信（3）
第二章 系统编程之进程间的 信号量 通信（4）
第二章 系统编程之进程间的 消息队列 通信（5）
目录
系列文章目录
前言
一、信号量
1 信号量的工作原理
2 信号量相关命令
​编辑
3 相关的接口函数
3.1 申请信号量(信号灯)
3.2 操作信号量(重点，重点，重点) 3.3 设置信号量的值，获取值，删除信号量 4 信号量的特点 总结
前言 这篇文章将讲述另一种进程间通信的机制——信号量。注意请不要把它与之前所说的信号混淆起来，信号与信号量是不同的两种事物。
一、信号量 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
作用：协调多个进程在通信的时候，对于共享资源(临界区资源)的访问。
1 信号量的工作原理 由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：
P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行
V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.
举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。
2 信号量相关命令 ipcs -s // 查看信号量 ipcrm -s 信号量的ID // 删除信号量 3 相关的接口函数 3.1 申请信号量(信号灯) #include &lt;sys/sem.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8af35890769c27fcc7588e1fafd61a42/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/178/">«</a>
	<span class="pagination__item pagination__item--current">179/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/180/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>