<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fd6edb0221216b3530e95cb63c6026c/" rel="bookmark">
			MDK中$Super$$main和$Sub$$main的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MDK中Super main和Sub main的含义 在主程序执行前插入一段新程序 int $Sub$$main(void) { rt_hw_interrupt_disable(); rtthread_startup(); return 0; } 在主程序运行前插入一段已有的程序 #if defined (__CC_ARM) $Super$$main(); /* for ARMCC. */ #elif defined(__ICCARM__) || defined(__GNUC__) main(); #endif rtthread_startup() 是进入主程序前的系统初始化，因此这两段程序作用就是为了完成主程序运行前的系统初始化工作，其中int Sub main(void) 是在主程序main前插入一段新代码，这段代码可以用来初始化系统，当然也可以做其他事情；而Super main() 是在主程序main前插入一段已有的代码，比如以前写好的一段系统初始化的程序段 。
####以下附上官方说明文档
MDK拓展 &lt;-----click
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bd4475506ad4a9d4ccaa29d6105e53f/" rel="bookmark">
			Swift 与 Kotlin 的简单对比，简直是太像了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Swift 的语法与 Kotlin 有很多相似之处，整理了一些 Swift 和 Kotlin 的对比，下面是一些例子，大家不妨来看看。可以说掌握了kotlin 再去看swift简直爽的不要不要的。学习成本大大降低。
Hello World 变量和常量 显式类型 强制类型转换 字符串插值 范围操作符 区域操作符（for while等） 数组 map 空集合 函数 返回值 参数的变量数目 函数类型 遍历 排序 命名参数 类的声明 类的用法 子类 类型检查 模式匹配 类型向下转换 协议 扩展 最后放一张完整的图 更多干货请看 公众号 Flutter那些事，精彩干货等你来看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efa8e79a8f1edcd10f6724adec41ed73/" rel="bookmark">
			如何在命令行查看文件大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如何在shell终端查看文件大小 du命令 sszxr:Desktop sszxr$ du -h *.* 12K	access.log 88K	access.log.1 304K	access.log.2 1.3M	access.log.9 4.0K	error.log 4.0K	error.log.1 sszxr:Desktop sszxr$ 查看大小并排序
sszxr:Desktop sszxr$ du -h *.* | sort -hr 1.3M	access.log.9 304K	access.log.2 88K	access.log.1 12K	access.log 4.0K	error.log.1 4.0K	error.log sszxr:Desktop sszxr$ 命令参数释义
-a或-all 显示目录中个别文件的大小。 -b或-bytes 显示目录或文件大小时，以byte为单位。 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -k或--kilobytes 以KB(1024bytes)为单位输出。 -m或--megabytes 以MB为单位输出。 -s或--summarize 仅显示总计，只列出最后加总的值。 -h或--human-readable 以K，M，G为单位，提高信息的可读性。 -x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 -L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。 -S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。 -X&lt;文件&gt;或--exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。 --exclude=&lt;目录或文件&gt; 略过指定的目录或文件。 -D或--dereference-args 显示指定符号链接的源文件大小。 -H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或--count-links 重复计算硬件链接的文件。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e226b563150fef8321c4d7addf4657e9/" rel="bookmark">
			javascript高级排序算法之快速排序（快排）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		javascript高级排序算法之快速排序（快排）
我们之前讨论了javascript基本排序算法
冒泡排序选择排序插入排序 简单复习： 冒泡排序：
比较相邻的两个元素，如果前一个比后一个大，则交换位置。第一轮的时候最后一个元素应该是最大的一个。按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。 选择排序：
首先从原始数组中找到最小的元素，并把该元素放在数组的最前面，然后再从剩下的元素中寻找最小的元素，放在之前最小元素的后面，直到排序完毕。
插入排序：
从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置后；重复步骤2~5。 今天开始讨论高级排序算法
快速排序 快速排序是处理大量数据最快的排序算法之一，一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列，然后不断重复这个步骤直到所有数据都是有序的。
首先需要在数据列表中选择一个元素作为基准值（pivot，这个变量我们后面会用到），数据排序围绕着基准值进行，（基准值可以是任意一个位置的数，不过一般选择中间的数字或者最左边的数字），每一轮结束后，比该基数小的数都位于该基数的左边，比该基数大的数都位于该基数的右边。然后再分别对基数左边和右边的数组进行相同的操作，直到数组中只有一个元素时，返回该数组。
简单说：（从小到大排序）
选择一个基准元素，将数据列表分成两个子序列；对数据列表进行重新排序，将所有小于基准值的元素放在基准值的前面，所有大于基准值的元素放在基准值的后面；分别对较小元素的子序列和较大元素的子序列重复步骤1和2。 看一个?：
let arr = [] function arrData(num) { for (let i = 0; i &lt; num; i++) { arr[i] = Math.floor(Math.random() * num + 1) } } arrData(10) function qSort(myArr) { if(myArr.length===0){ return[] } let smallArr=[] let bigArr = [] let pivot = myArr[0] for(let i =1;i&lt;myArr.length;i++){ if(myArr[i]&lt;pivot){ smallArr.push(myArr[i]) }else{ bigArr.push(myArr[i]) } } // return qSort(smallArr).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e226b563150fef8321c4d7addf4657e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48e097b1ef00689484620bc278178d79/" rel="bookmark">
			Visual studio 2017 &#43; cuda9.0环境配置 心路历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：下载安装VS2017(如果想用cuda code ，vs版本不可以太低，最好用最新版本 可以向下兼容)
2：下载cuda9.0,下载之前要先检查自己的电脑显卡是否支持NVIDIA，如果不支持就结束整个配置；如果支持，接着去桌面-》（右键）-》是否有NVIDIA控制桌面？Yes：点进去，查看左下角的资料，有一条DLL的就是你电脑所能支持的 最高cuda版本，或者你可以自己升级驱动，这样支持的cuda版本会更好。NO:去电脑-》控制界面——》找到NVIDIA控制桌面，或者相关教程。
3：配置：参考教程：https://blog.csdn.net/u013165921/article/details/77891913
4：注意事项：之前往复循环了很多次下载cuda9.0，各种检查版本、款式的，原因是 有很多教程告诉我 在自定义安装cuda时 不要选择Visual studio install那个选项，导致安装结束 验证cuda安装成功与否，VS的新建界面并没有NIVIDIA选项，一度下载重搞。
5：后来完成VS界面下有NVIDIA选项后，出现新的情况：C:\ProgramData\NVIDIA Corporation\CUDA Samples\v9.0路径下的对应vs2017.sln文件难以运行成功，报错：C1189 有关host_config.h的133行出错
推荐教程 超级正确：亲测可用
https://blog.csdn.net/lovelessyi/article/details/79219276
（windows10或者win7 都无所谓 只是版本而已，注意下载文件的对应版本就可以，别纠结那么久）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/36aa6d06124543409add255d8b8b7190/" rel="bookmark">
			Matlab 读取—处理—保存遥感影像（带有地理信息的图像）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Start_Latitude = 0.6; End_Latitude = 0.8; Start_Lontitude = 0.1; End_Lontitude = 0.3; Matlab读取遥感影像的函数是：geotiffread（针对的是tif数据文件）
一、简介 （1）数据读取 [A,R] = geotiffread(filename) ; Reads a georeferenced grayscale, RGB, or multispectral image or data grid from the GeoTIFF file specified by filename into A and creates a spatial referencing object, R.（官方解释）。
描述一下就是 A 代表的数据文件（高程之类的数据），R 为空间坐标信息（包括数据的大小，经纬度范围与起始经纬度，数据单位、方向等）。
读取部分到此为止！
（2）数据处理
我这里主要介绍的数据的裁剪（比如要从一块数中选择其中的某一部分画图等）。
我们应该很清楚在做数据裁剪时会用到Matlab的冒号（：）函数，这个也是很简单。但是我们在对含有地理坐标的数据进行裁剪时，经纬度信息也要对应数据裁剪的办法进行裁剪。
Start_Latitude = 0.6; End_Latitude = 0.8; Start_Lontitude = 0.1; End_Lontitude = 0.3; 以上四个部分是裁剪的核心部分，只要修改对应的这四个值就可以选择裁剪对应的数据区域。比如在一个10*10的矩阵中，上面的四个数字（0.6，0.8 ；0.1，0.3）对应的区域如图1中的绿色区域。
图1 示例图
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/36aa6d06124543409add255d8b8b7190/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73633c4d844b198201cbdf35dce88266/" rel="bookmark">
			交叉编译那些事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		那些年，交叉编译那些事
编译 python2.7.11 arm64
复制代码
1 先编译个x86版本。
2 mkdir build.pc
3 cd build.pc 4 ../configure --disable-ipv6 --enable-shared 5 make 6 7 编译arm64版本之前，先在configure文件前面添加
8 ac_cv_file__dev_ptmx=yes
9 ac_cv_file__dev_ptc=no
10 11 mkdir build.arm64
12 cd build.arm64
13 ../configure --host=aarch64-linux-gnu --prefix=/home/trait/v8le/linaro-aarch64/aarch64-linux-gnu --disable-ipv6 --enable-shared --build=aarch64
14 15 遇到错误1：
16 Parser/pgen ../Grammar/Grammar Include/graminit.h Python/graminit.c
17 Parser/pgen: Parser/pgen: cannot execute binary file
18 make: *** [Include/graminit.h] Error 126
19 拷贝build.pc的pgen即可解决。
20 cp /home/trait/v8le/Python-2.7.11/build.pc/Parser/pgen ./Parser/
21 22 make &amp;&amp; make install
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73633c4d844b198201cbdf35dce88266/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f8c9b6ab60d54432062ef8f83f48ef3/" rel="bookmark">
			Git 一次性 pull push 所有的分支
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Git 一次性 pull push 所有的分支 /*********************************************************************************
Git 一次性 pull push 所有的分支
说明：
使用Git一次性推送所有的分支，之前一般都是单独推送一个分支，现在是多分支操作，可能涉及到多分支推送，得找个办法解决。 ********************************************************************************/
一、参考文档： 1. Push local Git repo to new remote including all branches and tags http://stackoverflow.com/questions/6865302/push-local-git-repo-to-new-remote-including-all-branches-and-tags 2. Set up git to pull and push all branches http://stackoverflow.com/questions/1914579/set-up-git-to-pull-and-push-all-branches 二、解决办法： 1. push 1. git push REMOTE '*:*' 2. git push REMOTE --all 3. git push --all origin 根据需要使用以上命令
2. pull 1. git fetch --all 2. git pull --all 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e752241b0b1a498b322df10dcca375/" rel="bookmark">
			vue中兄弟组件之间的联动，兄弟组件之间的传值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		兄弟组件之间的传值，使得兄弟组件之间可以联动，相互操作
方法1：借助父组件，让两个兄弟组件可以联动，子组件A将值传递给父组件，父组件再将值传递给子组件B
第一步：子组件A传值给父组件
通过$emit将e.target.innerText传递给父组件
&lt;template&gt; &lt;div class="initail"&gt; &lt;ul&gt; &lt;li v-for="(item,key,index) of cities" :key="index" @click="handleInitail"&gt;{{key}}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Initail', props: { cities: Object }, methods: { handleInitail (e) { console.log(e.target.innerText) this.$emit('message', e.target.innerText) } } } &lt;/script 第二步：父组件接收子组件A的传值，并将值保存到自己的data中，并取名letter（letter：字母）
第三步：父组件将letter传递给子组件B
子组件B通过props接收该值
下面就是子组件B监听到letter值的变化后作出反应：用watch对象来监听
补充知识：Better-scroll插件中，提供一个方法，到指定的标签区域，或者说是，让某个指定的dom，出现到屏幕中，展现给用户。
需要注意的是：
上图中div.ct中的ref=“key”，由于此处是循环绑定的dom，所以打印dom的结果：
是个数组，第一位是dom元素
所以，在使用scrollElement()方法的时候：
方法2：bus总线传值
思路：在Vue的原型上创建一个属性bus，该属性的值为new Vue（），即bus也是一个vue实例
第一步：在main.js中创建bus总线
第二步：在子组件A中，通过bus总线抛出信息和值。this.bus就是Vue实例，$emit也是上面的方法
第三步：在子组件B中，在created或mounted等生命周期函数上，监听那个事件和获取那个值。
注意：bus总线，是联动的，当A组件触动bus总线的时候，B组件中也会响应式的触发。
B组件中的bus，需要在函数中，比如：created函数、mounted函数、甚至是data函数。
data中：
生命周期函数中：
总之，监听bus总线的事件，必须要函数中，但是该函数执行的时候，跟bus总线无关。
路由组件中：两个组件不在一个页面，bus总线即使改变了值，当点击另一个路由路径的时候，data函数又将值初始化了，
所以说，bus总线作用的两个组件应该在同一页面中。当然，可以用一个仓库来存储这个改变的值，比如：vuex、webStorage、数据库等等。
比如：bus在vuex中使用：
A组件：
methods: { handleClick () { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1e752241b0b1a498b322df10dcca375/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c554ca714943def31acd76eee6e00b23/" rel="bookmark">
			通信之自相关、互相关函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章参考：https://blog.csdn.net/wordwarwordwar/article/details/63253272 https://blog.csdn.net/dengheCSDN/article/details/78848046
相关函数定义：随机序列的不同时刻的状态之间，存在着关联性或者说不同时刻的状态之间相互有影响，包括随机序列本身或者不同随机序列之间。
事实上，在图象处理中，自相关和互相关函数的定义如下：设原函数是f(t)，则自相关函数定义为R(u)=f(t)*f(-t)，其中*表示卷积；设两个函数分别是f(t)和g(t)，则互相关函数定义为R(u)=f(t)*g(-t)，它反映的是两个函数在不同的相对位置上互相匹配的程度。
通信系统中，自相关性决定多径干扰，互相关性决定了多址干扰。
自相关函数是描述随机信号 x(t) 在任意不同时刻 t1,t2的取值之间的相关程度。定义式：
主要性质如下：
（1）自相关函数为偶函数，其图形对称于纵轴。
（2）当s=t 时，自相关函数具有最大值，且等于信号的均方值，即1？
（3）周期信号的自相关函数仍为同频率的周期信号。
（2）、互相关函数
自相关是互相关的一种特殊情况.。互相关函数是描述随机信号 x(t)、y(t) 在任意两个不同时刻s，t的取值之间的相关程度,其定义为：
对于连续函数，有定义：
对于离散的，有定义：
从定义式中可以看到，互相关函数和卷积运算类似，也是两个序列滑动相乘，但是区别在于：互相关的两个序列都不翻转，直接滑动相乘，求和；卷积的其中一个序列需要先翻转，然后滑动相乘，求和。所以，f(t)和g(t) 做相关等于 f*(-t) 与 g(t) 做卷积。
2、物理意义
两个相关函数都是对相关性，即相似性的度量。如果进行归一化，会看的更清楚。
自相关就是函数和函数本身的相关性，当函数中有周期性分量的时候，自相关函数的极大值能够很好的体现这种周期性。互相关就是两个函数之间的相似性，当两个函数都具有相同周期分量的时候，它的极大值同样能体现这种周期性的分量。
相关运算从线性空间的角度看其实是内积运算，而两个向量的内积在线性空间中表示一个向量向另一个向量的投影，表示两个向量的相似程度，所以相关运算就体现了这种相似程度。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f3199271bb565d7d25cd9708424ddc/" rel="bookmark">
			构建Hadoop集群
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集群规范 Hadopp运行在商业硬件上。用户可以选择普通硬件供应商生产的标准化的、广泛有效的硬件来构建集群。Hadoop一般使用多核CPU和多磁盘，以充分利用硬件的强大功能。（建议采用ECC内存，因为非ECC内存会产生校验和错误。）
注：为何不使用RAID？尽管建议采用RAID作为namenode的存储器以保护元数据，但是若将RAID作为datanode的存储设备则不会给HDFS带来益处。HDFS所提供的节点间数据复制技术已可满足数据备份需求，无需使用RAID的冗余机制。尽管RAID条带化技术被广泛用于提升性能，但是其速度仍然比用在HDFS里的JBOD(Just a Bunch Of Disks)配置慢。JBOD在所有磁盘之间循环调度HDFS块，RAID0的读/写操作受限于磁盘阵列中响应最慢的盘片的速度，而JBOD的磁盘操作均独立，因而平均读/写速度高于最慢盘片的读/写速度。若JBOD配置的某一磁盘出现故障，HDFS可以忽略该磁盘，继续工作。而RAID的某一盘片故障会导致整个磁盘阵列不可用，进而使相应节点失效。
集群的构建和安装 1.安装Java
2.创建用户账号：最好创建特定的用户账号以区分各Hadoop进程，及区分同一机器上的其他服务。HDFS、MapReduce和YARN服务通常作为独立的用户运行，分别命名为hdfs、mapred和yarn。它们都属于同一hadoop组。
3.安装Hadoop：鉴于hadoop用户的home目录可能挂载在NFS上，Hadoop系统最好不要安装在该目录上。比如可以选择：cd /usr/local
此外，还需将Hadoop文件的拥有者改为Hadoop用户和组：sudo chown -R hadoop:hadoop hadoop-x.y.z
4.SSH配置
Hadoop控制脚本依赖SSH来执行针对整个集群的操作。为了支持无缝式工作，SSH安装好之后，需要允许来自集群内机器的hdfs用户和yarn用户能够无需密码即可登录。最简单的方法是创建一个公钥私钥对，存放在NFS之中，让整个集群共享该密钥对。首先，键入以下指令来产生一个RSA密钥对。你需要做两次，一次以hdfs用户身份，一次以yarn用户身份：ssh -keygen -t rsa -f ~/.ssh/id_rsa
尽管期望无密码登陆，但无口令的密钥并不是一个好的选择。可以使用ssh-agent以免为每个连接逐一输入密码。私钥放在由-f选项指定的文件之中。存放公钥的文件名称与私钥类似，但是以“.pub”作为后缀，例如~/.ssh/id_rsa.pub。接下来，需确保公钥存放在用户打算连接的所有机器的~/.ssh/authorized_keys文件中。如果用户的home目录是存储在NFS文件系统中，则可以键入如下指令在整个集群内共享密钥(第一次作为hdfs用户，第二次作为yarn用户)：cat ~/.ssh/id_rsa.pub &gt;&gt;~/.ssh/authorized_keys 。如果home目录并没有通过NFS共享，则需要利用其他方法共享公钥，比如ssh-copy-id。
5.配置Hadoop（附后）
6.格式化HDFS文件系统：在能够使用之前，全新的HDFS安装需要进行格式化。通过创建存储目录和初始版本的namenode持久数据结构，格式化进程将创建一个空的文件系统。由于namenode管理所有的文件系统元数据，datanode可以动态加入或离开集群，所以初始的格式化进程不涉及到datanode。同样原因，创建文件系统时也无需指定大小，这是由集群中的datanode数目决定的。格式化HDFS是一个快速操作，以hdfs用户身份运行以下命令：hdfs namenode -format
7.启动和停止守护进程：Hadoop自带脚本。为使用这些脚本(在sbin目录下)，需要告诉Hadoop集群中有哪些机器。文件slaves正是用于此目的，该文件包含了机器主机名或IP地址的列表，每行代表一个机器信息。文件slaves列举了可以运行datanode和节点管理器的机器。以hdfs用户身份运行以下命令可以启动HDFS守护进程：start -dfs.sh 。
脚本所做的事情如下：⓵在每台机器上启动一个namenode，这些机器由执行hdfs getconf -namenodes得到的返回值所确定。⓶在slaves文件列举的每台机器上启动一个datanode。⓷在每台机器上启动一个辅助namenode，这些机器由执行hdfs getconf -secondarynamenode得到的返回值所确定。
YARN守护进程以相同的方式启动，以yarn用户身份运行以下命令：start -yarn.sh 。在这种情况下，资源管理器总是和start -yarn.sh脚本运行在用一机器上：⓵在本地机器上启动一个资源管理器⓶在slaves文件列举的每台机器上启动一个节点管理器。
对于以上脚本，还提供了stop -dfs.sh和stop -yarn.sh脚本用于停止由相应的启动脚本启动的守护进程。
这些脚本实质是使用了hadoop-deamon.sh脚本启动和停止Hadoop守护进程。如果你使用了前面提到的脚本，那么你不能直接调用hadoop-deamon.sh。但是如果你需要从另一个系统或从你自己的脚本来控制Hadoop守护进程，hadoop-deamon.sh脚本是一个很好的切入点。最后，仅有一个MapReduce守护进程，即作业历史服务器，是以mapred用户身份用以下命令启动的：mr -jobhistory-deamon.sh start historyserver
8.创建用户目录：一旦建立并运行了Hadoop集群，就需要给用户提供访问手段。涉及到为每个用户创建home目录，给目录设置用户访问许可：hadoop fs -mkdir /user/username。 hadoop fs -chown username：username /user/username。
Hadoop配置 重要的配置文件都放在Hadoop的etc/hadoop目录中。配置目录可以被重新安置在文件系统的其他地方，只要启动守护进程时使用 --config选项或使用HADOOP_CONF_DIR环境变量集说明目录所在位置。
文件名称格式描述hadoop-env.shBash脚本脚本中要用到的环境变量，以运行Hadoopmapred-env.shBash脚本脚本中要用到的环境变量，以运行MapReduce(覆盖hadoop-env.sh中设置的变量)yarn-env.shBash脚本脚本中要用到的环境变量，以运行YARN(覆盖hadoop-env.sh中设置的变量)core-site.xml Hadoop配置XML
Hadoop Core的配置项，例如HDFS、MapReduce和YARN常用的I/O设置等。hdfs-site.xmlHadoop配置XMLHadoop守护进程的配置项，包括namenode、辅助namenode和datanode等。mapred-site.xmlHadoop配置XMLMapReduce守护进程的配置项，包括作业历史服务器yarn-site.xmlHadoop配置XMLYARN守护进程的配置项，包括资源管理器】web应用代理服务器和节点管理器slaves纯文本运行datanode和节点管理器的机器列表(每行一个)hadoop-metrics2.propertiesJava属性控制如何在Hadoop上发布度量的属性log4j.propertiesJava属性系统日志文件、namenode审计日志、任务JVM进程的任务日志的属性hadooop-policy.xmlHadoop配置XML安全模式下运行Hadoop时的访问控制列表的配置项 1.配置管理：Hadoop并没有将所有配置信息放在一个单独的全局位置中。反之，集群的每个Hadoop节点，都各自保存一系列配置文件。Hadoop集群管理工具例如Cloudera Manager和Apache Ambari表现突出，因为在集群间传递修改信息是它们的关注点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24f3199271bb565d7d25cd9708424ddc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf19f05a84d1dd823d1a72f84f4b1283/" rel="bookmark">
			编译原理系列之五 自底向上优先分析(1)-简单优先分析法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单优先分析法 1.基本概念 通过语法树来理解这三个概念更加简单：
文法G1[S]：
S→AB
A→bB
A→Aa
B→a
B→Sb
语法树
短语：若S=*=&gt;αAδ且A=+=&gt;β，则称β是相对于非终结符A的句型αβδ的短语。
即：语法树中以非终结符的作为根的子树的叶子所组成的字符串。
如：ba是相对于非终结符A的句型AB的短语。句型baSb的短语有ba，a，Sb，baSb。
直接短语：若S=*=&gt;αAδ且A=&gt;β，则称β是相对于非终结符A的句型αβδ的直接短语。
即：语法树中以非终结符的作为根的子树，它的孩子都是叶子，没有其他子树。
如：Sb是相对于非终结符B的句型AB的短语。句型baSb的短语有a，Sb。
句柄：位于句型最左边的直接短语称为该句型的句柄。
即：位于语法树中最左边的直接短语。
如：句型baSb的句柄是a。
2.优先关系定义 X和Y优先级相等，表示为 X=·Y，当且仅当G中存在产生式规则A=&gt;···XY···。
解读：X、Y的优先级相同，当XY存在一个句柄之中，它们将同时被归约。表现在语法树中S=·b。
优先级相等在语法树中
X优先级小于Y，表示为 X&lt;·Y ，当且仅当G中存在产生式规则A=&gt;···XB···，B=+=&gt;Y···。
解读：X优先级小于Y，当XY存在一个句型中时，它们将不可能出现在同一个句柄中，Y一定比X先被规约。表现在语法树中b&lt;·a。
优先级小于语法树中
X优先级大于Y，表示为 X&gt;·Y ，当且仅当G中存在产生式规则A=&gt;··BD···，B=+=&gt;···X，D=*=&gt;Y···。
解读：X优先级大于Y，当XY存在一个句型中时，它们将不可能出现在同一个句柄中，X一定比Y先被规约。表现在语法树中a&gt;·S。
优先级大于在语法树中
X和Y的优先级为空，表示在文法的任何句型中都不会出现该符号对相邻出现的情况。 注意：以上优先关系之间不具有对成性。
3.简单优先文法定义 一个文法是简单优先文法，需要满足以下两个条件：
在文法符号集中V，任意两个符号之间必须之后一种优先关系存在。（显然满足）在文法中，两个产生式不能有相同的右部。 4.简单优先分析法的操作步骤 将输入输入串a1a2···an#依次压栈，不断比较栈顶符号ai和下一个待输入符号aj的优先级，若ai&gt;·aj则进行下一步，否则重复此步骤。
解读：停止条件是ai&gt;·aj表示前面输入串一定比后面先归约，所以只需要在前面找句柄就行了。
栈顶符号ai即为句柄尾，从此处向左寻找句柄头ak，满足ak-1&lt;·ak。
解读：从后向前找ak-1&lt;·ak表示ak之前的输入串一定比ai···ak后归约，由此确定现在就是要归约ai···ak。
由句柄ai···ak在文法中寻找右部为ai···ak的产生式；找到则将句柄替换为相应左部，找不到则说明该输入串不是该文法的句子。
重复以上步骤直到归约完成。
5.实例 由于还是以上面的例子不满足简单优先文法定义（b和b的优先关系不唯一），这里我们用另一个文法来举例。
文法G2[S]：
S→bAb ①
A→(B ②
A→a ③
B→Aa) ④
输入串为b(aa)b#
首先我们做出文法符号的优先关系矩阵： SABab()#S A == B &gt;&gt; a &gt;&gt; = b = &lt; &lt; ( &lt;=&lt; &lt; ) &gt;&gt; # 这里#比其相邻所有符号的优先性都要小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf19f05a84d1dd823d1a72f84f4b1283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7268fd51db75b3e247eb8a2ddddc1c7/" rel="bookmark">
			英语写作——知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名词所有格to的所有格用法as follow，as follows，和followingbe of + 名词 名词所有格
one of my brother’s friends （明确表示我兄弟有一个以上的朋友）
a friend of my brother’s (暗指不止一个朋友)
a friend of my brother (对我朋友有好感的人)
my brother’s friend (我哥哥的唯一的朋友)
to的所有格用法
一般所有格利用of，有时候，有些固定搭配也是需要到to的，下面总结了一些to作为所有格形式的固定搭配
the answer to question
the solution to the problem
the key to the door
the entrance to the cinema
the way to the park
the ticket to the ball game
另外，of一般用于没有生命的东西，如：the leg of the desk.
as follow，as follows，和following
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7268fd51db75b3e247eb8a2ddddc1c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a24c48918136e3ff5f1d85420159874a/" rel="bookmark">
			Debian9的各个版本的下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# 以下为debian-9.6版的下载地址，不同镜像对应不同的Linux桌面环境 # 官网下载地址 共三个镜像文件，一般只下载第一个就行了，当然也可以全部现在，启动时先选择第一个光盘，如果你安装的时候选择的软件比较多，可能会提示你插入第二张或者第三张光盘 链接：https://cdimage.debian.org/debian-cd/current/i386/iso-dvd/debian-9.6.0-i386-DVD-1.iso 链接：https://cdimage.debian.org/debian-cd/current/i386/iso-dvd/debian-9.6.0-i386-DVD-2.iso 链接：https://cdimage.debian.org/debian-cd/current/i386/iso-dvd/debian-9.6.0-i386-DVD-3.iso # 这下面时163网站给出的镜像，而且是分成不同的桌面版本来下载的，如果不想折腾，可以直接选择下面一个镜像进行下载。 # 事先可以搜索一下Debian的各种桌面 cinnamon/gnome(主流)/kde(主流)/lxde/mate/xfce # debian-live-9.6.0-i386-cinnamon.iso 下载地址 链接：http://mirrors.163.com/debian-cd/9.6.0-live/i386/iso-hybrid/debian-live-9.6.0-i386-cinnamon.iso # debian-live-9.6.0-i386-gnome.iso 下载地址 链接：http://mirrors.163.com/debian-cd/9.6.0-live/i386/iso-hybrid/debian-live-9.6.0-i386-gnome.iso # debian-live-9.6.0-i386-kde.iso 下载地址 链接：http://mirrors.163.com/debian-cd/9.6.0-live/i386/iso-hybrid/debian-live-9.6.0-i386-kde.iso # debian-live-9.6.0-i386-lxde.iso 下载地址 链接：http://mirrors.163.com/debian-cd/9.6.0-live/i386/iso-hybrid/debian-live-9.6.0-i386-lxde.iso # debian-live-9.6.0-i386-mate.iso 下载地址 链接: http://mirrors.163.com/debian-cd/9.6.0-live/i386/iso-hybrid/debian-live-9.6.0-i386-mate.iso # debian-live-9.6.0-i386-xfce.iso 下载地址 链接：http://mirrors.163.com/debian-cd/9.6.0-live/i386/iso-hybrid/debian-live-9.6.0-i386-xfce.iso 不同桌面环境的效果演示的链接：https://blog.csdn.net/Aria_Miazzy/article/details/84729537
不同桌面效果演示&amp;转载来源：http://server.zol.com.cn/537/5373142.html
未完待续。。。
PS:另外提供国内外各大网站镜像源，也可以下载处于维护的CentOS-Linux版本镜像
开源网站镜像：
搜狐开源镜像站：http://mirrors.sohu.com/网易开源镜像站：http://mirrors.163.com/开源中国：http://mirrors.oschina.net/首都在线科技股份有限公司：http://mirrors.yun-idc.com/阿里云开源镜像：http://mirrors.aliyun.com/LUPA：http://mirror.lupaworld.com/常州贝特康姆软件技术有限公司(原cn99）：http://centos.bitcomm.cn/ 大学校园镜像：
中山大学镜像：http://mirror.sysu.edu.cn/山东理工大学：http://mirrors.sdutlinux.org/哈尔滨工业大学：http://run.hit.edu.cn/中国地质大学：http://cugbteam.org/大连理工大学：http://mirror.dlut.edu.cn/西南林业大学 http://cs3.swfu.edu.cn/cs3guide.html北京化工大学（仅教育网可以访问），包含 CentOS 镜像：http://ubuntu.buct.edu.cn/天津大学：http://mirror.tju.edu.cn/西南大学：http://linux.swu.edu.cn/swudownload/Distributions/青岛大学：http://mirror.qdu.edu.cn/南京师范大学：http://mirrors.njnu.edu.cn/大连东软信息学院： http://mirrors.neusoft.edu.cn/浙江大学：http://mirrors.zju.edu.cn/兰州大学：http://mirror.lzu.edu.cn/厦门大学：http://mirrors.xmu.edu.cn/北京理工大学：
http://mirror.bit.edu.cn (IPv4 only)
http://mirror.bit6.edu.cn (IPv6 only)北京交通大学：
http://mirror.bjtu.edu.cn (IPv4 only)
http://mirror6.bjtu.edu.cn (IPv6 only)
http://debian.bjtu.edu.cn (IPv4+IPv6)上海交通大学：
http://ftp.sjtu.edu.cn/ (IPv4 only)
http://ftp6.sjtu.edu.cn (IPv6 only)清华大学：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a24c48918136e3ff5f1d85420159874a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17ddc8474dcd75d004301ce86bc9997f/" rel="bookmark">
			七大Linux桌面介绍：Unity、KDE、GNOME等等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于Linux桌面环境来说，因为具备着各种独特的设计风格、功能配备以及自身特性。从具体硬件平台上，只有通过实际情况才可以判断一款桌面环境究竟能否适合用户的需求。这里就来为大家推荐七款顶级Linux桌面环境选项。
一、Unity
Unity是一款Ubuntu自家的桌面环境，并面向Ubuntu推出和开发。目前还没有其它Linux发行版采用Unity作为桌面方案。
从Unity设计风格上，Ubuntu对于桌面环境定位效果与传统Windows桌面没有太大区别。Unity最具特色的一项功能“scopes”，允许通过“dash”搜索不同类型的网络与本地内容类型，也包括安装在系统当中的应用程序。另外，Unity还拥有其它一些独特的设计，如“HUD”就允许用户直接搜索某款程序中的菜单选项，并通过键盘直接加以启用。
开启了Dash菜单的Ubuntu Unity桌面方案
Unity的一些用户往往对其可配置能力有所顾忌，Unity启动器栏一直显示在屏幕的左侧，而且用户无法将其移除。窗口按钮(包括最小化、最大化与关闭)则显示在每个窗口的左上角设计与Mac OS X相同。Unity几乎没有发生大变化，但Ubuntu项目团队即将推出同时面向手机与台式机的融合优化型Unity 8版本。
此外，Unity只能作为Ubuntu主桌面的组成部分。
二、GNOME 3
与其它主流桌面Linux发行版一样，Ubuntu曾使用过GNOME桌面方案。自从GNOME 2逐步升级到GNOME 3乃至GNOME Shell桌面之后，GNOME Shell的改变让人们改变之前版本的成见。即使是习惯传统桌面环境的用户，也可以通过GNOME提供的经典模式拥有了完整的可配置能力。
运行Fedora Workstation中的GNOME桌面方案
从设计上，Unity与GNOME十分相似，能够利用3D图形硬件实现炫丽的视觉效果。GNOME 3.16添加了一套集中式通知中心，从而在功能性方面领先Unity。凭借着强大的扩展选项，GNOME还拥有远超Unity的可配置能力。
Fedora Workstation使用最新GNOME为其默认桌面选项，而GNOME也得到了充分的施展空间。Debian同样采用GNOME作为默认桌面方案，不过Debian 8所使用的GNOME版本相对老一些。
三、KDE Plasma 5
KDE与GNOME都属于Linux阵营中最具影响力的桌面环境选项。GNOME桌面形成GNOME、Unity、Cinnamon及MATE等多个阵营，但KDE项目却保持很好的市场表现。Plasma 5界面也拥有精致的风格。
KDE在可配置性方面一直优于GNOME以及GNOME衍生的Linux发行版。针对用户的实际情况，喜欢多选项所带来的自由搭配空间，或也有些用户更倾向于GNOME精简化方案。KDE已经简化很多高级选项，用户可以直接享受其搭配合理的默认效果。
Kubuntu当中的KDE
与Unity、GNOME、Cinnamon或MATE完全不同，这些桌面环境都使用内置于GTK工具包中，与GNOME非常相似的应用组合。而KDE坚持Qt路线并拥有着一套与之配合的应用套件，量身打造出来的效果让KDE上的应用与主屏幕及桌面更好融合。
四、Cinnamon
Cinnamon原本专门面向Linux Mint所打造，但如今多种Linux发行版上有着不错的表现，具体包括Ubuntu、Fedora以及Debian等。
采用Cinnamon桌面方案的Linux Mint
Cinnamon采用现代代码编写而成，但重新调整为用户提供一套更为传统的桌面界面。GNOME舍弃了任务栏以及开始菜单类界面来显示已安装应用程序的同时，Cinnamon则选择围绕这些更为传统的特性构建桌面环境。另外，相比较GNOME以及Unity，Cinnamon始终为桌面用户提供更多新增功能及改进。
对于传统Linux桌面环境用户，Cinnamon定位让倾向于传统窗口列表、不喜欢Windows 7新型任务栏机制的用户更为关注，同时为了获得最佳Cinnamon体验，配合Linux Mint一同使用。
五、MATE
MATE与Cinnamon是两种相似的桌面环境，同时受到Linux Mint支持。尽管Cinnamon采用了GNOME 3中的一部分代码并将其fork成一套传统桌面，MATE却采用更加陈旧的GNOME 2桌面代码，并Linux发行版中进行更新。除了Mint之外，MATE也适用于Fedora、Ubuntu以及Debian等。
Linux Mint采用MATE桌面
对于使用过GNOME 2的用户，MATE将成为最为理想的桌面环境选项。新用户们则更喜欢Cinnamon这款现代代码的传统风格桌面。在Cinnamon的使用过程中遇到了性能问题，并因此希望找到一套替代性方案，MATE 2确实是一个不错的选择。
与其它现代的桌面环境不同，MATE在默认情况下并不需3D加速硬件实现桌面视觉效果。不过通过启用Compiz，在MATE桌面上享受到更多酷炫的光影特效，选择Linux Mint与MATE来进一步感受使用体验。
六、Lxde
作为一款轻量级兼用户友好桌面环境，Lxde相较于现代Linux桌面环境，对于图形硬件、CPU时钟频率以及内存的配置要求较低。虽然看不到炫目的图形特效，但能获得最为基本的轻量级桌面环境使用体验，并启动并管理应用程序。
采用Lxde桌面的Lubuntu系统
对于用户来说，要获得最理想的Lxde使用体验搭配Lubuntu一同使用。
七、Xfce
从传统角度讲，Xfce仅次于GNOME与KDE的第三大人气选项，它在轻量化水平上稍优于KDE与GNOME。而在GNOME 3正式发布之后，Xfce已经成为最顶尖的“传统”Linux桌面环境。
采用Xfce桌面的Xubuntu系统
相比之前提到的桌面，Xfc面对Lxde和MATE的竞争。Lxde轻量化效果更出色，而Cinnamon在功能集丰富度方面更突出。从这个角度讲，MATE的功能更为齐备，在轻量级水平上则与Xfce基本持平。目前Xfce发展速度已放缓，最好与Xubuntu配合使用。
由此，通过直接启动特定Linux发行版的方式体验各类不同桌面环境。或将桌面环境安装现有Linux系统之上，并在登录界面中进行可用桌面环境切换，出色的灵活性正是Linux最大的亮点，这些仅是众多Linux桌面环境中的一部分，希望通过介绍找到最适合自己的选项。
转载来源：http://server.zol.com.cn/537/5373142.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65f05f8e8a30b72981cc55d8a9a08622/" rel="bookmark">
			Invalid configuration for cluster creation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用ruby启动redis集群时，报错：
&gt;&gt;&gt; Creating cluster *** ERROR: Invalid configuration for cluster creation. *** Redis Cluster requires at least 3 master nodes. *** This is not possible with 8 nodes and 192 replicas per node. *** At least 579 nodes are required. 倒数第二行说192个replicas
说明我的格式写错了：
解决：
结果：
&gt;&gt;&gt; Creating cluster &gt;&gt;&gt; Performing hash slots allocation on 9 nodes... Using 3 masters: 192.168.2.136:7000 192.168.2.136:7001 192.168.2.136:7002 Adding replica 192.168.2.136:7003 to 192.168.2.136:7000 Adding replica 192.168.2.136:7004 to 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/65f05f8e8a30b72981cc55d8a9a08622/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9cd617a0c98e3cb0554cd87a0d809be/" rel="bookmark">
			markdown语法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 标题类 每级标题用"# title"表示，共支持6级标题；
2. 段落类 1、建议用换行符控制；
2、用"&lt;p&gt;&lt;/p&gt;"控制；
3. 列表 无序列表 用"+ "或者"* "表示，子项目用tab键进行缩进；
abcedf 有序列表 用"1. "表示，列表项自动递增，与数字无关，子项目用tab键进行缩进；
123
456 4. 字体样式 加粗用"**text**"表示； 也可以应用"__text__ "表示；
bold fold
斜体用"*"或者"_"表示；
italic fold 5. 表格 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 colum 2colum 3row1row2 6. 代码块 用1~2个反引号表示行内插入，3个反引号表示代码块插入，成对出现，即2、4、6个反引号实现代码插入
hello world #行内插入
hello world #行内插入
hello world #代码块插入 7. 链接插入 &gt; 行内链接： [title](link) &gt; 参考链接： [title][index] [index]: link "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9cd617a0c98e3cb0554cd87a0d809be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/094ff7d2a669100657ca73606b1a6690/" rel="bookmark">
			Connection timed out和Connection refused的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：这两个异常报出的时候，说明客户端没法正常连接到服务端，但是两者还是有区别的。
1：Connection timed out 当得到 Connection timed out: connect 的时候表示TCP路由不正常，原因有很多，可能是服务器无法ping通，可能是服务器（防火墙等）丢弃了该请求报文包，也可能是服务器应答太慢，又或者存在间歇性的问题（这种情况很难从日志文件中排查问题）。
2：Connection refused 当得到Connection refused: connect 异常的时候表示从本地客户端到目标IP地址的路由是正常的，但是该目标端口没有进程在监听，然后服务端拒绝掉了连接。
一个成功的tcp链接将会看到Syn，Syn-Ack，Ack，这也就是我们预期的TCP三次握手。当使用tcpdump或wireshark抓包工具来探测发送过来的请求报文包时，Connection refused将会看到Syn,Rst。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b67e4d5f37584b713f0d426da1bc3681/" rel="bookmark">
			Configuration类的使用（扩充中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hadoop中的组件是通过Hadoop自己的配置API来配置的。一个Configuration类的实例代表配置属性及其取值的一个集合。Configuration类可以在org.apache.hadoop.conf包中找到。
每个属性由一个String来命名，而值的类型可以是多种类型之一，包括Java基本类型(如boolean、int、long和float)、其他有用的类型(如String、Class和java.io.File)及String的集合。Configuration从资源(即使用简单结构定义的名值对的XML文件)中读取其属性值。
一个简单的配置文件configuration-1.xml如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;color&lt;/name&gt; &lt;value&gt;yellow&lt;/value&gt; &lt;description&gt;Color&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;size&lt;/name&gt; &lt;value&gt;10&lt;/value&gt; &lt;description&gt;Size&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;weight&lt;/name&gt; &lt;value&gt;heavy&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;description&gt;Weight&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;size-weight&lt;/name&gt; &lt;value&gt;${size},${weight}&lt;/value&gt; &lt;description&gt;Size and Weight&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; configuration-2.xml：
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;color&lt;/name&gt; &lt;value&gt;black&lt;/value&gt; &lt;description&gt;Color&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;size&lt;/name&gt; &lt;value&gt;20&lt;/value&gt; &lt;description&gt;Size&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;weight&lt;/name&gt; &lt;value&gt;light&lt;/value&gt; &lt;final&gt;true&lt;/final&gt; &lt;description&gt;Weight&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;size-weight&lt;/name&gt; &lt;value&gt;${size},${weight}&lt;/value&gt; &lt;description&gt;Size and Weight&lt;/description&gt; &lt;/property&gt; &lt;/configuration&gt; 下面的代码使用Configuration的一个实例加载这两个xml文件(按照顺序加载)。
/** * addResource方法传入的参数可以是Path对象，引入具体的xml文件路径即可 */ //config.addResource(new Path("/Users/mymac/Desktop/configuration-1.xml")); /** * configuration的addResource(String str)方法，传入的xml文件名称，应放在项目src目录下 */ config.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b67e4d5f37584b713f0d426da1bc3681/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f29b27a47500c54d32993523db073e/" rel="bookmark">
			arcgis10.4安装包（含安装教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://pan.baidu.com/s/1PSL3fH0AUqQvHZhFAYQaJQ 密码：yq8y
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/440/">«</a>
	<span class="pagination__item pagination__item--current">441/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/442/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>