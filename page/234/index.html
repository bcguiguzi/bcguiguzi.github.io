<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce63a94711886c971c0ea5af59930b04/" rel="bookmark">
			Android-快捷键总结(Windows)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 复制类名或方法名
将光标放置名称上，使用快捷键ctrl+Alt+Shift+C合并代码 String name; name="123"; 通过快捷键Ctrl+Shift+J(光标位于第一行代码上)
String name="123"; 补全代码
Ctrl+Shift+Enter搜索
在当前页面搜索
Ctrl+F
在项目中查找
Ctrl+Shift+F
搜索文件
双击Shift替换
Shift+F6
所有该类名或方法名或参数名都会被替换重写
Ctrl + O
会显示该类中所有可以被重写的方法查看参数
在方法的括号中Ctrl+P可以查看该方法需要填入的参数生成构造方法
在已经在类中设置相应的全局参数之后，通过Alt+Insert可以选择相应的参数生成构造方法Getter和Setter
也是通过Alt+Insert注释
单行注释（多个单行注释）选中行 Ctrl+/
代码块注释 选中 Ctrl+Shift+/格式化代码
可以让代码看上去更加整洁
Ctrl+Alt+L其他
Ctrl+Z 撤销
Ctrl+Y 回退/删除该行
Ctrl+X 剪切，对应Ctrl+V使用
Ctrl+D 向下一行粘贴
Ctrl+A 全选 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7db4ffc975b413a7fa673bcedd2ab598/" rel="bookmark">
			DataV的飞线图全国各省会坐标地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		特别声明：只能自己使用，不可商用
进行底色处理的图片（该图从网络下载）
全国各省省会坐标如下：
export const mup_list = { centerPoint: [0.57, 0.42], relative: true, points: [ { position: [0.63, 0.33], text: '黑龙江省' }, { position: [0.55, 0.39], text: '内蒙古自治区' }, { position: [0.62, 0.38], text: '吉林省' }, { position: [0.60, 0.41], text: '辽宁省' }, { position: [0.57, 0.44], text: '天津市' }, { position: [0.58, 0.47], text: '山东省' }, { position: [0.56, 0.45], text: '河北省' }, { position: [0.54, 0.46], text: '山西省' }, { position: [0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7db4ffc975b413a7fa673bcedd2ab598/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f0f5913bf14b32e4fe314bf4e50281/" rel="bookmark">
			C/C&#43;&#43;中对结构体进行引用和指针定义所占用的内存大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; using namespace std;
struct Test
{
int a[5];
int *b;
//double &amp;b;
//char &amp;b;
};
int main()
{
Test test = {};
cout &lt;&lt; "引用结构体对象占用的内存空间字节大小为：" &lt;&lt; sizeof(test) &lt;&lt; endl;
Test *test1;
cout &lt;&lt; "指针结构体对象占用的内存空间字节大小为：" &lt;&lt; sizeof(test1) &lt;&lt; endl;
return 0;
}
结果：
引用结构体对象占用的内存空间字节大小为：32
指针结构体对象占用的内存空间字节大小为：8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec1f62cfe4d7f27b4121b26729aaac3/" rel="bookmark">
			Egg 服务搭建微信公众号的基础服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Egg 服务搭建微信公众号的基础服务 标题内容引入服务搭建(http配置Config配置代码实现控制层、路由 安装依赖 npm i co-wechat -s # or yarn add co-wechat # or cnpm i co-wechat -s Config配置代码 /* eslint valid-jsdoc: "off" */ 'use strict'; /** * 微信公众号对接配置内容 * * config/config.default.js * 当然这里面也有一些其他的配置，这里只展示 */ module.exports = appInfo =&gt; { config.wehcat = { token: 'token', // 基础配置的token信息 appid: 'appid', // 微信公众号的appid信息 encodingAESKey: 'encodingAESKey', // 微信公众号的encodingAESKey信息 } } 路由代码 'use strict'; /** * @param {Egg.Application} app - egg application */ module.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dec1f62cfe4d7f27b4121b26729aaac3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2fdf32b03fdd71e28996e60ee38115a/" rel="bookmark">
			网络设备二三层通信流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先，终端连接上网络设备，达成一个可以通信的硬件环境
假定主机是一台IP为192.168.1.1，掩码为255.255.255.0的电脑
首先，测试同网段地址，尝试ping 地址为192.168.1.2的电脑
本机首先会对192.168.1.2这个地址与自己本身的掩码进行运算
判定为同网段，于是查看自身的ARP表，是否有对应这个IP的MAC地址
若是存在，将目的MAC地址与目的IP封装进报文，发送出去
交换机与路由器在解封装后，会根据对应地址，查找自身的MAC表，从对应接口发出
若是主机ARP中不存在这个IP所对应的MAC，发送一个目的MAC地址全F的广播报文，询问与这个IP地址对应的主机是哪位。
此时，若是使用wireshark软件对交换机连接主机的端口进行抓包，可以看到
内容是 “who is 192.168.1.2,tell me” 的报文
交换机收到后，因为目的MAC是广播地址，所以也会接收，根据报文内容查找自己的ARP表
是否有对应的，若有，则回应主机一个对应的MAC地址
若无，在除这个发送来的接口外，所有属于同一个VLAN的接口转发这个报文
这个流程，也称为ARP解析协议，即根据目的IP地址查询目的MAC地址
然后是跨网段转发，这里需要有网关，因为要靠网关进行三层转发
这里假定ping 192.168.2.1
主机开头也会将目的IP与自身掩码运算，判断是否同一网段
发现是不同网段，于是发送目的IP为192.168.2.1，目的MAC地址为网关MAC地址的数据出去
*这里网关的MAC地址也是通过ARP解析协议获得的
网关收到后，发现目的MAC地址是自己，确认可以接收，于是解封装，去掉二层报文头部
发现目的IP地址与自己不同，于是查询路由表，根据目的IP地址重新封装后转发出去
这里封装的目的MAC地址，是下一跳地址的MAC
下一跳设备也重复这个流程，直到最后一跳设备，查询IP地址时发现和自己某个接口是直连网段
于是依据ARP表转发这个数据包
三层通信就完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551d116d60c7d619952bd1c341646125/" rel="bookmark">
			图像分割与边缘提取Matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像分割是把图像分成各具特性的互不重叠的区域，并提取出感兴趣目标的技术和过程。是图像处理过渡到图像分析的关键步骤，也是一种基本的计算机视觉技术。
文章目录 一、实验内容二、实验的实现1、主要设计思想2、实现算法及程序流程图3、源程序（包含必要的注释）（1）图像边缘检测（2）图像阈值分割 4、主要技术问题的处理方法5、实验结果及分析 一、实验内容 利用边缘检测法、阈值分割法进行图像分割，并分析图像分割后的视觉效果。
二、实验的实现 1、主要设计思想 边缘检测：Matlab存在相应边缘检测算子库，可以直接通过设置参数输入图像和算子名进行处理。
阈值检测：将输入图像转换为灰度值图像，根据灰度值设置不同阈值，通过设定不同的特征阈值，保留相应阈值以内的像素点，然后使用Matlab中提供的阈值分割函数，输入参数，图像和阈值来求得最终效果。
2、实现算法及程序流程图 3、源程序（包含必要的注释） （1）图像边缘检测 pic=imread('D:\pic\HG.jpg'); %读取当前路径下的图像 I=rgb2gray(pic); %图像灰度化 dl1=edge(I,'sobel'); %对图像进行“Sobel”边缘提取 dl2=edge(I,'prewitt'); %对图像进行“Prewitt”边缘提取 dl3=edge(I,'roberts'); %对图像进行“Roberts”边缘提取 dl4=edge(I,'log'); %对图像进行“Laplace”边缘提取 dl5=edge(I,'canny'); %对图像进行“Canny”边缘提取 subplot(3,2,1); imshow(I); title('原图'); %输出原图像 subplot(3,2,2); imshow(dl1); title('索贝尔sobel算子'); subplot(3,2,3); imshow(dl2); title('普瑞维特算子'); subplot(3,2,4); imshow(dl3); title('罗伯特算子'); subplot(3,2,5); imshow(dl4); title('log算子'); subplot(3,2,6); imshow(dl5); title('canny算子'); （2）图像阈值分割 Img=imread('D:\pic\HG.jpg'); %读取当前路径下的图像 I1=rgb2gray(Img); %图像灰度化 subplot(2,3,1);imshow(I1);title('灰度图像'); grid on; %显示网格线 axis on; %显示坐标系 [m,n]=size(I1); %测量图像尺寸参数 GK=zeros(1,256); %预创建存放灰度出现概率的向量 for k=0:255 GK(k+1)=length(find(I1==k))/(m*n); %计算每级灰度出现的概率，将其存入GK中相应的位置 end subplot(2,3,2),bar(0:255,GK,'g') %绘制直方图 title('灰度直方图') xlabel('灰度值') ylabel('出现概率') I2=im2bw(I,120/255); I3=im2bw(I,80/255); I4=im2bw(I,160/255); subplot(2,3,4),imshow(I2);title('直方图阈值T=120处理分割图像'); subplot(2,3,5),imshow(I3);title('直方图阈值T=80处理分割图像'); subplot(2,3,6),imshow(I4);title('直方图阈值T=160处理分割图像'); imwrite(I2,'05 直方图阈值120的分割图像.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/551d116d60c7d619952bd1c341646125/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e585ca1069525e3788d91346c5020366/" rel="bookmark">
			Android Studio JSON数据的初始化与解析访问 （JSON对象、JSON数组）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio中有JSONObject和JSONArray两种数据结构。JSONObject是数据对象，是下图展示的类型。即一个{}中有若干个属性和属性对应的值。
JSONArray是json数组。为如下的形式。一个[]中有若干个JSON对象，可看做数组的元素。
一、Json的初始化 如果要初始化一个Json对象，逐次使用JSONObject.put()函数即可。函数的第一个参数为属性名，第二个参数为属性的值。一个Json对象中如有多个属性，对一个Json对象连续使用若干次JSONObject.put()函数即可。
JSONObject json1 = new JSONObject(); JSONObject json2 = new JSONObject(); try { json2.put("2", 2); json2.put("3", 3); json1.put("one", "xxx"); json1.put("two", "yyy"); json1.put("four", json2); } catch (JSONException e) { e.printStackTrace(); } Log.e("结果",json1.toString());//以字符串形式输出 执行上面的代码初始化JSON变量，可以发现JSON1的结果如下所示。json对象中某个元素对应的值可以是数字、字符串，也可以是JSON变量。
JSON数组可以看做是一个数组，数组的元素是JSON对象。因此JSON数组的初始化方法类似。先用上述方法初始化每个json对象。再初始化一个新的JSON数组，用JSONArray.put()函数把前面初始化的JSON对象压入数组。
以下面的代码为例：
JSONObject json0 = new JSONObject();//json对象（数组元素） JSONObject json1 = new JSONObject();//json对象（数组元素） JSONArray json = new JSONArray();//json数组 try { json0.put("2", 2); json0.put("3", 3);//初始化元素0的json变量 json1.put("one", "xxx"); json1.put("two", "yyy"); json1.put("four", json0);//初始化元素1的json变量 json.put(json0);//元素0压入数组 json.put(json1);//元素1压入数组 } catch (JSONException e) { e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e585ca1069525e3788d91346c5020366/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d00090bf5684043e10dbaef1bdc441/" rel="bookmark">
			树莓派4B上多版本python切换（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主树莓派上有两个版本的python，一个是python2.7, 一个是python3.9
注：上面也有2.7版本的python，但python2并没有pip模块，只有python3的pip模块。
curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py python2 get-pip.py 可通过上面命令语句来安装python2的pip模块。 注：若pip3未安装，则可通过如下命令安装（3.6指的python3的版本，若是其它版本，则修改其即可）
curl https://bootstrap.pypa.io/pip/3.6/get-pip.py -o get-pip.py python3 get-pip.py 指定版本安装库时可以如下语句
python2 -m pip install 库的名称 如下安装的是keras 完毕后可看到，keras已经安装上了。
下面再通过源码方式去安装一个python3.7，以来验证多版本python3的管理问题。
先安装必要库
sudo apt-get install -y make build-essential libssl-dev zlib1g-dev sudo apt-get install -y libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm sudo apt-get install -y libncurses5-dev libncursesw5-dev xz-utils tk-dev 下载python3.7版本 sudo wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz 解压
sudo tar -zxvf Python-3.7.3.tgz 进入到解压缩后文件夹内，输入如下命令，这里会安装到指定的目录下，方便后期删除
sudo ./configure --prefix=/home/pi/python3.7 sudo make -j4 sudo make install 在sudo make install报错时，若出现报错：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d00090bf5684043e10dbaef1bdc441/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c508f402c5f5e4bad715b5970c421f9/" rel="bookmark">
			raspberryPi_继电器模块(relay)&#43;风扇模块(fan)连接原理图/硬件调试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 继电器模块型号和样式型号样式1：端口介绍左侧 右侧(指示灯侧)双侧图 样式2：DC/IN 引脚介绍 继电器的使用和接入风扇的可用性调试 ⛔注意测试代码触发电平code (new)code（old) 测试继电器模块可用性可选材料Fritzing 接线图 关于继电器的内部线路总结引脚对于电路的理解分析流程 硬件模块调试 继电器模块型号和样式 型号 jqc-3ff-s-z 样式1： 端口介绍 左侧 负载侧,该侧是接入负载以及专门给负载供电的一侧
负载可以是led小灯/小风扇等)
常开端公共端(配合另一个端口)常闭端 右侧(指示灯侧) 继电器受控信号部分(单片机接入到继电器)
IN(开发板型号控制端) 继电器供电部分
GND(任意合适电源负极)VCC(任意合适电源正极)
双侧图 样式2： DC/IN 引脚介绍 (单片机接入端)
DC（direct current)直流电（可以由单片机提供或者外接电源）
DC+：直流电正极DC-：直流电负极IN：接入单片机信号控制引脚 继电器的使用和接入 继电器接入单片机(step1)测试负载接入继电器(step2) 继电器负载侧的电源可以是外接电源
图中风扇部分电路（继电器负载部分）所标注的GND/5V 可以通过外接电源供电；也可以直接在单片机上的某对GND/VCC上(但是注意,电压要足)。 风扇的可用性调试 风扇需要足够的电压来驱动，一般就接在5v(vcc/gnd）但是风扇可以产生反电动势，对单片机可能造成损害，所以一般其中的一个管脚接在继电器的负载部分（您可以通过led等来调试继电器的可用性）风扇的负极是黑色（GND)/红色接入正极（vcc) ⛔注意 小风扇区分正负极（反接无效）ethernetW5100 堆叠时：不要压地过紧（可以那个卡片隔一隔，容易造成异常的电路问题） 测试代码 触发电平 编写此段代码时，我用的继电器是?电平触发闭合NO端;
以具体情况为准
code (new) int pinRelay = 5; //管脚D3连接到继电器模块的信号脚(TX) void setup() { // 为了提供串口显示，需要设置baud Serial.begin(9600); Serial.println("start test the electric relay the circuit..."); // 这一步不能忘记 pinMode(pinRelay, OUTPUT); //设置pinRelay脚为输出状态 //注意电压问题,3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c508f402c5f5e4bad715b5970c421f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca82142168ff2ca319cfc1b0ce27fa17/" rel="bookmark">
			HFSS 3D LAOUT PCB 裁剪，差分线，过孔仿真和优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我本身不是做天线设计的，所以HFSS这个软件给我主要还是做PCB级别的高速信号完整性仿真，一般2.5D的仿真软件无法对过孔和跨平面进行仿真。所以要借助三维电磁软件进行。今天就针对PCB进行裁剪。为什么要裁剪？以为如果把整个PCB一起仿真的话，应该要好几个月吧。所以为了加快仿真速度，必须进行裁剪仿真。
①candence的PCB可以直接导入。那么先导入brd文件，file-import-candence结果如下
②点击cutout，选中要仿真的net和参考平面。这里最好选creat new不然会把原文件覆盖掉。
注注意下参考面要勾选extents
③点击 Auto Generate,可以看到红框出现了裁剪的区域
④裁剪完结果如下，一些不必要的部分可以进行删减处理
⑤添加激励 ，选中U201，右键点击Model,可以自动添加同轴端口。同样的可以在另一个器件上也加上端口。
⑥开始仿真，这个速度非常慢，大概要2-3个小时（和电脑配置有关）
S21参数
TDR，可以看到过孔引起了阻抗突变，和预计一致。
⑦接下来做下差分线的优化，首先修正下叠层，这里扫描下H1的参数，最后使用0.0782这个值。 ⑧接下来优化过孔，调整孔间距的到0.3，增加回流孔地孔。这里试着看了下回流孔的距离，发现距离越近越好。看红色线，可以看到过孔已经改善到了92ohm ⑨接下来可以做下反焊盘的优化，可以看到反焊盘再35mil的时候效果最好。
10，至此优化完了（只调整了一边的孔，另一边是一样的，本文就不重复了），可以和最早的仿真结果做对比，最前面的孔已经优化，后面的孔并没有优化。
最后进行总结如下 ①导入PCB，裁剪需要的信号。
②查看TDR，找出阻抗不连续的点进行优化。
③对于线的话，可以调整叠层也可以调整线宽线间距。
④对于过孔的话，可以调整孔间距，反焊盘和增加回流孔，当然还有背转工艺什么的，这里没有涉及。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a149d185a5cb07d8eb9e27de5508ec58/" rel="bookmark">
			Quantization｜A White Paper on Neural Network Quantization (谷歌量化白皮书)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记一下谷歌量化白皮书的理解。
1 Introducation 本文介绍两种主要的category：
PTQ: post-training quantization: 只需要在正常训练后的参数上调超参数QAT: quantization-aware-training: 需要在训练网络的时候量化 2 Quantization fundanmentals 2.1 Hardware background 硬件如何计算一个矩阵乘法 y = W x + b y = Wx + b y=Wx+b? 如图，NN 加速器主要需要两组成部分：processing elements C n , m C_{n,m} Cn,m​ 和accumulators A n A_n An​ .计算的流程：
load bias value b n b_n bn​,
load weight values W n , m W_{n,m} Wn,m​ 以及 这层的输入 x m x_m xm​, 计算 C n , m = W n , m x m C_{n,m} = W_{n,m}x_m Cn,m​=Wn,m​xm​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a149d185a5cb07d8eb9e27de5508ec58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f052a958dd009717e7bc5342831563/" rel="bookmark">
			hbase shell命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、查询类1.1 查看表结构1.2 命名空间1.3 查看所有表1.4 扫描表（scan）1.5 获取行或单元数据（get） 2、统计表数据行数3、删除表其他查看状态查看帮助查看版本 1、查询类 1.1 查看表结构 describe ‘表名’
1.2 命名空间 # 查看所有命名空间 list_namespace # 查看具体的命名空间 describe_namespace 'namespace' # 查看命名空间下的所有表 list_namespace_tables 'namespace' 1.3 查看所有表 list
1.4 扫描表（scan） scan 'table_name',{ options } # 扫描所有数据 scan 'table_name' # 限制扫描数量 2 scan 'table_name',{LIMIT=&gt;2} # 设置扫描起点终点（根据rowkey） scan 'table_name',{ STARTROW =&gt; 'row10',ENDROW =&gt; 'row20' } # 根据时间戳扫描 TIMERANGE # 添加过滤 FITLER ps. STARTROW、ENDROW等需要大写
1.5 获取行或单元数据（get） （rowkey为row_index） # 获取数据表的指定行 # get 'namespace:table_name','row_index' # 读取dev空间test表的第十行（rowekey为10） get 'dev:test','row10' # 获取数据表指定行的指定列簇中中列的数据 # get 'namespace:table_name','row_index','column_cluster:column_name' # get 'namespace:table_name','row_index',{COLUMN=&gt;'column_cluster:column_name'} # 读取dev空间test表第五行col_1列簇中name列的数据（rowekey为5） get 'dev:test','row5','col_1:name' get 'dev:test','row5',{COLUMN=&gt;'col_1:name'} 2、统计表数据行数 count ‘表名’
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06f052a958dd009717e7bc5342831563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b8ec296efaf83412c4b1403359e809f/" rel="bookmark">
			mysql8.0安装初始化无反应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql8.0安装初始化无反应
问题：在下载mysql压缩包安装初始化时，mysqld --initialize --console回车无反应，mysql安装目录也不生成data文件夹。
检查电脑是否缺少必要插件：双击运行D:\mysql\bin**mysqld.exe**程序，报错缺少vcruntime140_1.dll
解决办法：安装缺少插件或直接安装微软常用运行库合集即可。
微软常用运行库合集
链接：https://pan.baidu.com/s/1I-LmBr0xkKODXoihjdkYFw
提取码：gtzt
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42ce1b16d1527cd9f92e7c8195438c87/" rel="bookmark">
			MinGW-w64 C/C&#43;&#43;编译器下载和安装的方法步骤(入门教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于在线安装方式下载较慢，所以可以选择直接下载离线包。
点击此链接：https://sourceforge.net/projects/mingw-w64/files/，进入下图1后将页面往下滑到图2区域，点击所需离线包名称（参照方法一第三步标注），然后就会弹出图3所示对话框，保存下载即可。离线包大约50MB（解压后500MB左右），下载一般只需半个小时，具体视乎网速情况而定
2.环境变量配置
如果下载完成后就进入Windows的命令窗口再次键入gcc，仍会是本文第一张图那样的提示。原因就在于还缺少系统环境变量配置这一环节。
右键计算机→属性→高级系统设置→高级→环境变量，然后鼠标双击系统变量中Path，或者选中后点击编辑，在变量值输入框的末尾输入英文分号后将MinGW-w64包目录下bin文件夹的全路径粘贴到后面，bin的后面有无斜杠均可，如下图：
此时再进入Windows的命令窗口键入gcc，将是另一番景象~~~
下载链接
https://www.jb51.net/softs/696088.html
3.小试牛刀
在本地新建一个.C和.CPP文件，然后在Windows命令窗口编译试试（习惯Linux命令后，在Windows如此编译操作，虽有区别，但大多数命令还是有联系的）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cccb3ff2308cd092e347a0358fa03cad/" rel="bookmark">
			（一）目标检测半自动标注：索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 说明： 如果yolov5的预训练权重已经包括了你所需要的类别，可直接进行自动标注，无需自行训练模型。
步骤： 1.安装与环境配置yolov5-6.0版本 yolov5-6.0 github链接：https://github.com/ultralytics/yolov5/tree/v6.0
2.标注数据进行模型训练 使用labelme进行标注
使用yolov5-6.0模型训练
3.使用训练好的模型进行自动标注 标注工具代码链接：https://github.com/mohenghui/detectAuto
4.xml转txt 标签格式转换： 5.去除未标注图像 条件：txt一定少于图像
6.labelimg检测标注后的效果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cec9d5e3be6814efa1c578e3f09da869/" rel="bookmark">
			MinGW-w64 - for 32 and 64 bit Windows
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://sourceforge.net/projects/mingw-w64/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4251ec7acdda7bd1713f11356a81e44/" rel="bookmark">
			神经网络-注意力机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 注意力简介 计算机视觉（computer vision）中的注意力机制（attention）主要是想让系统学会把注意力放在感兴趣的地方，具备注意力机制的神经网络能够自主学习注意力机制。近几年来，深度学习与视觉注意力机制结合的研究工作，大多数是集中于使用掩码(mask)来形成注意力机制。掩码的原理在于通过另一层新的权重，将图片数据中关键的特征标识出来，通过学习训练，让深度神经网络学到每一张新图片中需要关注的区域，也就形成了注意力。
1.1 引入注意力机制的原因 1、计算能力的限制：目前计算能力依然是限制神经网络发展的瓶颈，当输入的信息过多时，模型也会变得更复杂，通过引入注意力，可以减少处理的信息量，从而减小需要的计算资源。
2、优化算法的限制：虽然局部连接、权重共享以及池化 pooling 等优化操作可以让神经网络变得简单一些，有效缓解模型复杂度和表达能力之间的矛盾。但是，比如循环神经网络中的长序列输入，信息“记忆”能力并不高。
2 注意力机制的分类 1、聚焦式（Focus）注意力：是一种自上而下的有意识的注意力，“主动注意” 是指有预定目的、依赖任务的、主动有意识地聚焦于某一对象的注意力。
2、显著性（Saliency-Based）注意力：是一种自下而上的无意识的注意力，“被动注意” 是基于显著性的注意力，是由外界刺激驱动的注意，不需要主动干预，也和任务无关。池化（Max Pooling） 和 门控（Gating） 可以近似地看作是自下而上的基于显著性的注意力机制。
3 注意力的形式 注意力有两种形式，一种是软性注意力(soft attention)，另一种则是硬性注意力(hard attention)。
软性注意力更关注区域或者通道，而且软性注意力是确定性的注意力，学习完成后直接可以通过网络生成，最关键的地方是软性注意力是可微的，这是一个非常重要的地方。可以微分的注意力就可以通过神经网络算出梯度并且前向传播和后向反馈来学习得到注意力的权重。
硬性注意力与软性注意力不同点在于，首先硬性注意力是更加关注点，也就是图像中的每个点都有可能延伸出注意力，同时硬性注意力是一个随机的预测过程，更强调动态变化。当然，最关键是硬性注意力是一个不可微的注意力，训练过程往往是通过增强学习(reinforcement learning)来完成的。
注意力机制一般可以分为三步：一信息输入；二计算注意力分布；三根据计算的注意力分布来对输入信息进行处理。
令：
为输入向量 为N个输入样本 为查询向量或特征向量 为注意力变量，表示被选择信息的位置，比如 z = i 表示选择了第 i 个输入向量 3.1 软性注意力 软性注意力（Soft Attention）是指在选择信息的时候，不是从 N 个信息中只选择1个，而是计算 N 个输入信息的加权平均，再输入到神经网络中计算。
1、计算注意力分布 在给定 q 和 X 下，选择第 i 个输入向量的概率 为：
其中：
称为注意力分布
s(xi​,q)称为注意力打分函数
2、加权平均
注意力分布α i 可以解释为给定查询 q 时，第 i 个输入向量关注的程度，软性注意力选择机制是对它们进行汇总：
3.2 硬性注意力 硬性注意力（Hard Attention）是指只选择输入序列某一个位置上的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4251ec7acdda7bd1713f11356a81e44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f86781e2293286e28c5f2d85918d55a/" rel="bookmark">
			Retrofit2基础使用与解析：从使用步骤深入分析源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用步骤 步骤一 添加依赖、权限 dependencies { compile 'com.squareup.retrofit2:retrofit:2.0.2' // Retrofit库 compile 'com.squareup.okhttp3:okhttp:3.1.2' // Okhttp库 } 联网权限：
&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 步骤二 创建接收数据实体类 public class Reception { ... } 依据服务器返回的数据，建造实体类承载数据
步骤三 创建网络请求接口 public interface GetRequest_Interface { @GET("openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car") Call&lt;Translation&gt; 接口方法(); } 使用注解进行请求方式、参数的设置。
方法的返回值默认使用Call&lt;数据实体类&gt;。（使用RxJava时用Observable&lt;实体类&gt;）
步骤四 创建Retrofit实例 Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://fanyi.youdao.com/") // 网络请求基础Url地址 .addConverterFactory(GsonConverterFactory.create()) // 数据解析器 .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) // 网络请求适配器 .build(); 步骤五 创建网络请求接口实例 // 创建 网络请求接口 的实例 GetRequest_Interface request = retrofit.create(GetRequest_Interface.class); //对 发送请求 进行封装 Call&lt;Reception&gt; call = request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f86781e2293286e28c5f2d85918d55a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1978d999a7d001892094706bd8004e/" rel="bookmark">
			windows配置python2.7和python3.7(绿色免安装版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、下载安装包二、解压到任意指定文件夹三、解压后分别修改python.exe为python2.7和python3.7，并添加环境变量，方便调用四、python用不同版本pip安装库五、另附安装pip方法安装步骤： 总结 前言 一、下载安装包 python2和python3免安装安装包
二、解压到任意指定文件夹 三、解压后分别修改python.exe为python2.7和python3.7，并添加环境变量，方便调用 环境变量配置参考
四、python用不同版本pip安装库 Python2：python2 -m pip install XXX Python3：python3 -m pip install XXX 五、另附安装pip方法 pip官网
安装步骤： 安装包
下载 setuptools-0.6c11.tar.gz下载 pip-20.1.tar.gz解压 setuptools-0.6c11.tar.gz，pip-20.1.tar.gzcmd 进入 .\setuptools-0.6c11.tar\setuptools-0.6c11 目录下，执行 python setup.py installcmd 进入 .\pip-20.1 目录下，执行 python setup.py installPython 安装路径下 Scripts 路径加入系统环境变量重新打开命令行，pip -V 测试安装成果 总结 分享：
能力的提高离不开人的勤奋，勤奋是能力发展的重要条件。勤奋的人不懈地从事活动，他们刚毅顽强、百折不挠，促进了能力的发展和提高。能力与知识、技能是密切联系的。知识、技能是能力形成的基础，并能促进能力的发展。能力制约着掌握知识技能的快慢、深浅、难易和巩固程度，知识、技能的掌握又会导致能力的提高。能力是一种魅力和力量。注重才能的积累远比注重薪水的多少更重要，因为它是每个人最厚重的生存资本。自学能力在能力体系中占有重要的地位，是创造者的有力武器。努力培养和强化自学能力，才能使我们走上创造之路。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf35e005752749a7d933a9a3369eeb3e/" rel="bookmark">
			TLS 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、TLS 定义 SSL(Secure Sockets Layer) 安全套接层，是一种安全协议，经历了 SSL 1.0、2.0、3.0 版本后发展成了标准安全协议 - TLS(Transport Layer Security) 传输层安全性协议。TLS 有 1.0 (RFC 2246)、1.1(RFC 4346)、1.2(RFC 5246)、1.3(RFC 8446) 版本。
TLS 在实现上分为 记录层 和 握手层 两层，其中握手层又含四个子协议: 握手协议 (handshake protocol)、更改加密规范协议 (change cipher spec protocol)、应用数据协议 (application data protocol) 和警告协议 (alert protocol)。
二、HTTPS = HTTP over TLS 只需配置浏览器和服务器相关设置开启 TLS，即可实现 HTTPS，TLS 高度解耦，可装可卸，与上层高级应用层协议相互协作又相互独立。
三、加密 TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。
TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。
例如，在 HTTPS 协议中，客户端发出请求，服务端会将公钥发给客户端，客户端验证过后生成一个密钥再用公钥加密后发送给服务端（非对称加密），双方会在 TLS 握手过程中生成一个协商密钥（对称密钥），成功后建立加密连接。通信过程中客户端将请求数据用协商密钥加密后发送，服务端也用协商密钥解密，响应也用相同的协商密钥。后续的通信使用对称加密是因为对称加解密快，而握手过程中非对称加密可以保证加密的有效性，但是过程复杂，计算量相对来说也大。
四、 记录层 记录协议负责在传输连接上交换的所有底层消息，并且可以配置加密。每一条 TLS 记录以一个短标头开始。标头包含记录内容的类型 (或子协议)、协议版本和长度。原始消息经过分段 (或者合并)、压缩、添加认证码、加密转为 TLS 记录的数据部分。 分片 (Fragmentation) 记录层将信息块分割成携带 2^14 字节 (16KB) 或更小块的数据的 TLSPlaintext 记录。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf35e005752749a7d933a9a3369eeb3e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/233/">«</a>
	<span class="pagination__item pagination__item--current">234/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/235/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>