<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8237c885563fedfbc37159ab643ff99/" rel="bookmark">
			乌班图安装ftp
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装ftp
sudo apt-get install vsftpd 修改配置文件
sudo vi /etc/vsftpd.conf # Example config file /etc/vsftpd.conf # # The default compiled in settings are fairly paranoid. This sample file # loosens things up a bit, to make the ftp daemon more usable. # Please see vsftpd.conf.5 for all compiled in defaults. # # READ THIS: This example file is NOT an exhaustive list of vsftpd options. # Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's # capabilities.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8237c885563fedfbc37159ab643ff99/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/090f48c7ef4d18c210e01e754e35fcec/" rel="bookmark">
			乌班图静态指定IP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 乌班图静态指定IP
This is the network config written by ‘subiquity’ sudo vi /etc/netplan/00-installer-config.yaml ##进入配置文件 network: ethernets: enp1s0: dhcp4: false addresses: - 192.168.1.11/24 routes: - to: default via: 12.168.1.1 nameservers: addresses: - 192.168.1.1 - 114.114.114.114 dhcp6: false match: macaddress: 8c:dc:d4:6c:1b:2f addresses: - fe80::8edc:d4ff:fe6c:1b2f/64 version: 2 ~ ~ sudo netplan apply ##重启网卡 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaec4726fa9a38304091b6699f704be8/" rel="bookmark">
			PHP调用接口京东API封装的例子（ 获得JD商品详情，按关键字搜索商品， 按图搜索京东商品（拍立淘），获得店铺）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POST和GET是HTTP协议中两种最基本的请求方式。其主要差别在于传参方式、数据大小等方面，下面做详细介绍：
1. GET（获取）：从服务器获取资源或数据
当一个GET请求发生时，客户端发送一个请求给服务端，服务端会返回请求的内容。这个请求可以使用一个URL地址，在该地址后添加查询参数。
2. POST（提交）：向服务器提交数据并让其处理
当一个POST请求发生时，客户端将一个请求发送到服务端，并且包含了所有要提交的数据。这些数据可以位于HTML表单中，或者是通过JavaScript打包。
GET和POST的区别
- 数据传输方式：GET请求的数据是以查询字符在URL后面，而POST请求的数据则放在HTTP消息的消息体中。
- 使用场景不同：GET更适合用来获取数据，POST更适合用来提交数据。
- 数据长度限制：GET是有长度限制（限制是由浏览器和服务器设置的），POST没有长度限制。
- 编码方式：GET请求只接受ASCAII编码的字符，而POST请求支持多种类型的编码方式。
因此，你应该根据不同的情况选择适合的请求方式，GET和POST各自都有自己的优缺点。
GET：
/** * 通过URL获取页面信息 * @param $url 地址 * @return mixed 返回页面信息 */ function get_url($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL,$url); //设置访问的url地址 curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER,1);//不输出内容 $result = curl_exec($ch); curl_close ($ch); return $result; } POST：
/** * 模拟POST提交 * @param string $url 地址 * @param string $data 提交的数据 * @return string 返回结果 */ function post_url($url, $data) { $curl = curl_init(); // 启动一个CURL会话 curl_setopt($curl, CURLOPT_URL, $url); // 要访问的地址 curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE); // 对认证证书来源的检查 curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE); // 从证书中检查SSL加密算法是否存在 curl_setopt($curl, CURLOPT_USERAGENT, 'Mozilla/5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaec4726fa9a38304091b6699f704be8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b61512b1ab2a1df935648e69422bf209/" rel="bookmark">
			二层转发&amp;交换机工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据链路层的作用：
1、物理地址，网络拓扑的建立，维护，拆除
2、把数据封装在帧中，按顺序传送
3、差错恢复，重传，重新发送一次
4、流量控制，确保中间传输的稳定以及双方传输速率的匹配
数据链路层主要的工作：1.硬件地址寻址2、差错校验
二层转发 1、交换机主要工作在局域网内部转发数据帧，实现内部设备之间的通信
2、mac地址识别，找物理地址，根据mac的地址来转发数据帧
3、局域网内部设备（之间转发数据帧，在网络层是ip地址转发，故只能在二层工作）
转发的最终目的就是为了找到mac地址
识别一个以太网上的某个单独设备或一组设备的唯一标识
mac地址的长度：48bit表现形式：16进制
前24bit--厂家的编码
后24bit--生产批次
bit比特 最小单位
1byte（B）=8bit
1kb=1024B
1MB=1024kb
1GB=1024MB
二层转发只在同一网段转发：
1、在发送端，数据分成多个数据帧，每个数据帧一般不超过1500个字节
2、每个数据帧都会添加一个以太网帧头部信息，目的mac地址和源mac地址以类型，帧校验序列等信息
3、数据帧通过物理层设备（网卡），到交换机
4、在交换机上，根据mac地址进行转发查找要转发的设备，执行转发
5.目的设备也会走同样的步骤把自己的数据帧也发给源设备。
6.到达主机，目的主机会根据数据头部的mac地址判断，符合目的主机的mac地址，数据帧会接受下来
7.从数据帧中提取数据，进行处理。
交换机
交换机工作原理
1、交换源mac地址学习，源mac地址和接口号添加到mac地址表中
2、如果一致目标mac地址，则直接转发，不知道目标mac地址，泛洪广播数据帧
3、接收方回应广播，发回数据帧，交换机学习回应的mac地址记录在arp缓存表中
4、双方实现单播通信
（300s后地址会从缓存列表中删除）
交换机的四大功能：
1、学习功能----数据帧经过交换机，交换机会自动学习数据帧的mac地址
2、转发功能----数据帧经过交换机，会在mac表里查找数据帧的目的mac，查找成功会从相应的接口转发数据
3、查询功能（泛洪广播）--如果mac表中没有目的mac，会从接口转发相同的数据（泛洪）
4、刷新功能--mac地址表。300s刷新一次
交换机的执行命令
1、连线并启动设备
2、undo terminal monitor 用户模式下关闭系统提示
undo info -center enable 系统模式下关闭系统提示
3、sysname改名 4、sys（system -view） 系统视图
5、int e0/0/1 进去接口模式（用于在当前接口配置命令），输入q退出
6、undo ne（undo negotiation auto） 关闭自动协商
7、speed 调整双工功率
8、duplex full 全双工 duplex half 全双工
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b61512b1ab2a1df935648e69422bf209/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba6c5b6701555477c1127860ddd55974/" rel="bookmark">
			基于微信小程序的校园失物招领小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文末联系获取源码
开发语言：Java
框架：ssm
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql 5.7/8.0
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
浏览器：谷歌浏览器
小程序框架：uniapp
小程序开发软件：HBuilder X
小程序运行软件：微信开发者
一、前言介绍 随着信息化时代的到来，管理系统都趋向于智能化、系统化，微信小程序校园失物招领也不例外，但目前国内的市场仍都使用人工管理，市场规模越来越大，同时信息量也越来越庞大，人工管理显然已无法应对时代的变化，而微信小程序校园失物招领能很好地解决这一问题，轻松应对校园失物招领平时的工作，既能提高人力物力财力，又能加快工作的效率，取代人工管理是必然趋势。
本微信小程序校园失物招领以ssm作为框架，b/s模式以及MySql作为后台运行的数据库，同时使用Tomcat用为系统的服务器。本系统主要包括首页、个人中心、用户管理、发布人管理、物品类别管理、失物招领管理、寻物启事管理、认领验证管理、系统管理等功能，通过这些功能的实现能够基本满足日常校园失物招领管理的操作。
本文着重阐述了微信小程序校园失物招领的分析、设计与实现，首先介绍开发系统和环境配置、数据库的设计，接着说明功能模块的详细实现，最后进行了总结。
二、微信小程序框架 微信小程序的开发框架是微信所独有的一套框架，分为View视图层和App Service逻辑层两部分。框架提供了一种类似于Web中html语言的wxml语言，作为视图层的标签语言，用于构造页面的布局。另外提供了一种类似Web中css语言的WXSS语言，作为视图层的标签样式语言，用于表述页面的显示。而在逻辑层的框架，则同样使用了JS语言。微信小程序为了使开发者专注在代码的逻辑层面和数据处理上，还专门提供了两种解决方案，一种是事件，一种是数据的传输。这两种方案都位于小程序框架的视图层和逻辑层之间。用户在视图层进行交互之后，传递到逻辑层对数据进行处理，并返回数据到视图层向用户反馈。对于微信小程序视图层的开发设计，小程序官方提供了一系列的组件，这些基本组件可以极大的帮助开发者完成视图层的开发。同时，对于逻辑层的开发，小程序官方提供了一系列API来方便开发者请求一些额外功能。 三、总体设计 根据微信小程序校园失物招领的功能需求，进行系统设计。
前台功能：用户进入系统可以实现首页、失物招领、公告信息、我的等，在我的页面可以对失物招领、寻物启事、认领验证、在线客服等功能进行操作；
后台主要是管理员和发布人，管理员功能包括首页、个人中心、用户管理、发布人管理、物品类别管理、失物招领管理、寻物启事管理、认领验证管理、系统管理等；发发布人功能包括首页、个人中心、失物招领管理、寻物启事管理、认领验证管理等；
系统对这些功能进行整合，产生的功能结构图如下：
四、小程序端 4.1登录 用户通过输入账号和密码，选择角色并点击登录进行系统登录操作，如图所示。 4.2用户注册 在用户注册页面通过填写用户账号、用户姓名、密码、确认密码、性别、电话号码、校区等信息进行注册操作；如图所示。
4.3首页 用户登陆小程序端，可以对首页、失物招领、公告信息、我的等功能进行详细操作，如图所示。
4.4失物招领 在失物招领页面可以查看物品名称、物品编号、物品图片、物品类别、物品数量、丢失地点、拾得时间、当前位置、发布人账号、发布人姓名、电话号码、校区、物品描述等信息，如图所示。 4.5我的页面 在我的页面可以对失物招领、寻物启事、认领验证、在线客服等详细信息进行操作，如图所示。 五、后台功能模块 5.1登录页面 管理员，发布人通过输入用户名、密码，选择角色并点击登录进行系统登录操作，如图所示。
5.2管理员功能 管理员登陆系统后，可以对首页、个人中心、用户管理、发布人管理、物品类别管理、失物招领管理、寻物启事管理、认领验证管理、系统管理等功能进行相应操作，如图所示。
5.3用户管理 在用户管理页面可以对索引、用户账号、用户姓名、性别、头像、电话号码、校区等内容进行详情、修改或删除等操作，如图所示。 5.4发布人管理 在发布人管理页面可以对索引、发布人账号、发布人姓名、性别、头像、电话号码、校区等内容进行详情，修改或删除等操作，如图所示。 5.5物品类别管理 在物品类别管理页面可以对索引、类别等内容进行详情，修改或删除等操作，如图所示。 5.6失物招领管理 在失物招领管理页面可以对索引、物品编号、物品名称、物品类别、物品数量、物品图片、丢失地点、拾得时间、当前位置、发布人账号、发布人姓名、电话号码、校区等内容进行详情，修改或删除等操作，如图所示。 5.7寻物启事管理 在寻物启事管理页面可以对索引、物品编号、物品名称、物品类别、物品图片、遗失地点、遗失时间、物品状态、发布时间、用户账号、电话号码、用户姓名、校区等内容进行详情，修改或删除等操作，如图所示。 5.8认领验证管理 在认领验证管理页面可以对索引、物品编号、物品名称、物品特征、物品颜色、图片、物品大小、认领时间、用户账号、用户姓名、电话号码、发布人账号、发布人姓名、审核回复、审核状态等内容进行详情和修改操作，如图所示。 5.9系统管理 在公告信息页面可以对索引、标题、图片等内容进行详情，修改或删除等操作，还可以对轮播图管理，在线客服进行详细操作；如图所示。 六、发布人功能 发布人登陆系统后，可以对首页、个人中心、失物招领管理、寻物启事管理、认领验证管理等功能进行相应操作，如图所示。
6.1个人中心 在个人信息页面通过填写发布人账号、发布人姓名、性别、头像、电话号码、校区等内容进行个人信息修改操作，如图所示。
6.2失物招领管理 在失物招领管理页面可以对索引、物品编号、物品名称、物品类别、物品数量、物品图片、丢失地点、拾得时间、当前位置、发布人账号、发布人姓名、电话号码、校区等内容进行详情，修改或删除等操作，如图所示。 七、部分核心代码 7.1登录系统主要代码 form.on('submit(login)', function(data) { data = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba6c5b6701555477c1127860ddd55974/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a038c93ed13c1d6a4ca9fa685a8dedf9/" rel="bookmark">
			npm -np 包发布工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		np 包发布工具 发包工作np 工具np 使用问题：运行`test`报错np执行后，没有结果，也没报错？np执行报错，但是去npm上看，包已经发布了如果发现发布的版本有bug怎么办？ 先说一个例子：raect 举例
1、 首先有一个github仓库
2、需要发布在npm上
3、遵循语义化版本（Semantic versioning：如17.0.1, 较大变动递增高位，一般变动递增中位，较小变动递增低位）
4、每次更新都有一个git tag，即有不同版本号并存，同时在releases 中记录每次更新
发包工作 因此发布需要做的事：
1、运行测试用例（有的话）
2、更新 package.json 版本号
3、创建 git tag 和 release 记录变动
4、发布到github 和 npm
np 工具 以上步骤可以使用 np 工具快速完成，推荐使用国内镜像，不然可能很慢 或者 失败
国内镜像： npm config set registry https://registry.npm.taobao.org
安装：npm i np -g
使用 np 前提：
项目是一个Git 仓库、至少 push 过一次 、执行np时不能有未push提交的文件 np 使用 1、开发完成后，commit 提交
2、npm login 登陆 （发布必须）
3、运行 np 命令，选择版本增量方式，上下键到对应选项，enter，或自定义
注意：包名不要冲突，空间命名要和npm用户名一致，否则抛出异常
可能会提示：（可以忽略）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a038c93ed13c1d6a4ca9fa685a8dedf9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97e3766744a5247eba8103740fe410a7/" rel="bookmark">
			SpringMVC框架面试专题（初级-中级）-第五节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家一起探讨～如果可以帮到大家请为我点赞关注哦～后续会持续更新
问题：
1.Spring MVC框架中的消息转换器是什么？请举例说明如何使用消息转换器。
解析：
Spring MVC框架中的消息转换器是一种用于将HTTP请求和响应中的消息转换为Java对象的机制。当Spring MVC控制器处理请求时，它会根据请求的Content-Type（请求体的格式）和Accept（响应体的格式）头来选择适当的消息转换器。消息转换器将请求或响应中的消息转换为Java对象，使得在控制器中处理数据更加方便。
以下是一个使用Spring MVC框架中的消息转换器的示例：
@PostMapping("/createUser") public void createUser(@RequestBody User user) { // code to create user } 在上面的代码中，我们通过使用@RequestBody注解来告诉Spring MVC框架使用消息转换器将请求的消息转换为User对象。如果请求的Content-Type头是application/json，则Spring MVC框架将使用JSON消息转换器来将请求的消息转换为User对象。
另外，Spring MVC框架还提供了许多内置的消息转换器，例如：
StringHttpMessageConverter：将字符串转换为HTTP请求或响应的消息体。
-MappingJackson2HttpMessageConverter：将JSON数据转换为Java对象，或将Java对象转换为JSON数据。FormHttpMessageConverter：将表单数据转换为Java对象。ByteArrayHttpMessageConverter：将字节数组转换为HTTP请求或响应的消息体。 要自定义消息转换器，我们可以创建一个实现HttpMessageConverter接口的类，并在Spring MVC配置文件中进行配置。例如，以下代码演示了如何配置一个自定义的消息转换器来将XML数据转换为Java对象：
@Configuration public class AppConfig { @Bean public HttpMessageConverter&lt;Object&gt; xmlConverter() { MarshallingHttpMessageConverter converter = new MarshallingHttpMessageConverter(); XStreamMarshaller marshaller = new XStreamMarshaller(); converter.setMarshaller(marshaller); converter.setUnmarshaller(marshaller); converter.setSupportedMediaTypes(Collections.singletonList(MediaType.APPLICATION_XML)); return converter; } @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { converters.add(xmlConverter()); super.configureMessageConverters(converters); } } 在上面的代码中，我们创建了一个MarshallingHttpMessageConverter实例，并将其配置为使用XStreamMarshaller来进行XML数据转换。然后，我们将该消息转换器添加到Spring MVC配置文件中的configureMessageConverters方法中，以便在控制器中使用它来处理请求和响应。在这个例子中，我们指定了MediaType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97e3766744a5247eba8103740fe410a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37b74edbcbcba1d4bf4caeb7368c51f/" rel="bookmark">
			Spring中的Bean管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring中的Bean管理 Spring IOC容器 Spring框架主要是通过Spring容器实现的，Spring提供了相应的API来管理Bean，最常用的是BeanFactory和ApplicationContext
BeanFactory接口 这个接口采用Java的工厂模式，这个接口提供了创建和管理Bean的方法
方法名称描述getBean(String name)根据参数名称获取BeangetBean(String name,Class &lt;T&gt;type)根据参数名称，参数类型来获取Bean&lt;T&gt;T getBean(Class&lt;T&gt;requiredType)根据参数类型获取BeanObject getBean(String name,Object…oegs)根据参数名称获取BeanisTypeMatch(String name,Resolvable Typetype)判断是否有与参数名称、参数类型匹配的BeanClass&lt;T&gt;getType(String name)根据参数名称获取类型String[] getAliase(String name)根据实例的名称获取实例的别名数组boolean containsBean(String name)根据Bean的名称判断Spring容器是否含有指定的Bean ApplicationContext接口 该接口建立在BeanFactory接口的基础之上，丰富了BeanFactory接口的特性，添加了对国际化，资源访问，事件传播等方面的支持
这个接口可以为单例的Bean实行预初始化，并根据&lt; property &gt;元素执行setter方法，单例Bean可以直接使用，提升了程序获取Bean实例的性能
类名称描述ClassPathXmlApplicationContext从类路径加载配置文件，实例化ApplicationContext接口FileSystemXmlApplicationContext从文件系统加载配置文件，实例化ApplicationContext接口AnnotationConfigApplicationContext从注解中加载配置文件，实例化ApplicationContext接口WebApplicationContext从Web应用中使用，从相对于Web根目录的路径中加载配置文件，实例化ApplicationContex接口ConfigurableWebApplicationContext扩展了WebApplicationContext类，可以通过读取XML配置文件的方式实例化WebApplicationContext接口 Bean配置 在Spring中XML配置文件的根元素是&lt; beans &gt;,包含&lt; bean &gt;子元素，每个子元素可以定义一个Bean，通过&lt; bean &gt;元素将Bean注册到Spring容器中
&lt; bean &gt;元素中的常用属性 id 唯一标识符，Spring容器对Bean的配置和管理通过id属性完成，装配Bean时也需要根据id值获取对象name 可以为Bean指定多个名称class 只当Bean的具体实现类，其属性为对象所属类的全路径scope 设定Bean实例的作用范围 &lt; bean &gt;元素常用的子元素 &lt; constructor-arg &gt;可以为Bean的属性指定值，具有以下属性 index:用于设置构造参数的序号type:用于指定构造参数类型ref:用于指定参数值value:用于指定参数值(参数值也可以通过ref和value的子元素指定) &lt; property &gt;是调用Bean实例中的setter方法完成属性赋值，从而完成依赖注入 name:指定Bean实例中的属性名ref:用于指定参数值value:一样 ref:是上面两个元素的属性，用于指定Bean工厂中某个Bean实例的引用value:用于指定一个常量值&lt; list &gt; 用于指定Bean属性类型为List或数组&lt; set &gt; 指定属性类型为Set&lt; map &gt;同上&lt; entry &gt; 该元素是&lt; map &gt;的子元素，用于设置一个键值对。&lt; entry &gt;元素的key属性用于指定字符串类型的键，用ref和value子元素指定&lt; entry &gt;元素的值，或者value-ref又或者value指定&lt; entry &gt; 元素的值 Bean的实例化 构造方法的实例化 构造方法实例化是☞Spring容器通过Bean对应类中默认的无参构造方法来实例化Bean
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c37b74edbcbcba1d4bf4caeb7368c51f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d53ec62c7e4172e9ef3078976e624382/" rel="bookmark">
			4.hadoop集群扩容与hive异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异常处理 当我们使用sqoop同步数据时候，出现了异常。
Error writing file ‘/tmp/MYYEBa32’ (Errcode: 28 - No space left on device
INFO mapreduce.Job: The url to track the job: http://node3:8088/proxy/application_1681182527108_0002/ INFO mapreduce.Job: Running job: job_1681182527108_0002
INFO mapreduce.Job: Job job_1681182527108_0002
running in uber mode : false INFO mapreduce.Job: map 0%
reduce 0% INFO mapreduce.Job: map 100% reduce 0%
INFO mapreduce.Job: Job job_1681182527108_0002 failed with state FAILED due to: Task failed
task_1681182527108_0002_m_000000 Job failed as tasks
failed. failedMaps:1 failedReduces:0 killedMaps:0
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d53ec62c7e4172e9ef3078976e624382/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09459adaf57d5adb8c7679c75797810/" rel="bookmark">
			网络基础学习（第二章）：交换机基本原理与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据链路层 1.1、位于物理层与网络层之间：第二层
1.2、数据链路层的作用
● 物理地址，网络拓扑的建立；数据链路的建立、维护与拆除。
● 把数据封装在帧中进行帧包装、帧传输、帧同步—— MAC 头部、IP头部、协议（T/U）、上层数据。
● 差错恢复（重新发送）。
● 流量控制：确保中间传输的稳定以及双方传输速率的匹配。
二、以太网 2.1、工作在数据链路层
2.2、以太网的发展
2.3、以太网MAC地址
2.4、以太网帧格式
三、交换机的工作原理 3.1、交换机的转发原理
● 初始状态
● MAC地址学习（源mac地址和接口号添加到mac地址表中）
● 广播未知数据帧（若已知目标mac地址，则直接转发；反之，泛洪广播数据帧）
● 接收方回应（接收方回应广播，发回数据帧，交换机学习回应的mac地址记录在arp缓存表中）
● 交换机实现单播通信
3.2、交换机的四大功能
● 学习功能：数据帧经过交换机，交换机会自动学习数据帧中的MAC地址。
● 转发功能：数据帧经过交换机，会在MAC表查找数据真的目的MAC，查找成功，会以相应接口转发数据。
● 查询功能（泛洪广播）：若MAC表中没有目的MAC，会从接口转发相同的数据。
● 刷新功能：MAC地址表，300s刷新一次。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd4e7b8c4a14f89cf99296c90f8388b4/" rel="bookmark">
			基于SpringBoot的仓库管理系统设计与实现附带源码和论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要
当今时代是飞速发展的信息时代，在各行各业中离不开信息处理，这正是计算机被广泛应用于信息处理系统的环境计算机最大的好处在于利用它能够进行信息管理，使用计算机进行信息控制，不仅提高了工作效率，而且大大的提高了其安全性。尤其对复杂的信息管理，计算机能够充分发挥它的优越性。计算机进行信息管理与信息管理系统的开发密切相关，系统的开发是系统管理的前提库作为一总货品资源的集散地，货品的种类繁多，包含很多的信息数据的管理据调查得知，以前仓库进行信息管理的方式主要是基于文本、表格等纸介质的手工处理，对于货品的出入库情况的统计和核实等往往采用对账本的人工检查，对管理者的管理权限等不受约束，任何人都可查看，这样容易引起资料外泄另外，数据信息处理工作量大容易出错，由于数据繁多，容易丢失，且不易查找总的来说，缺乏系统、规范的信息管理手段.而且，一般的存储情况是记录在账本上的，仓库的工作人员和管理员也只是当时记得比较清楚，时间一长，如果再要进行查询，就得在众多的资料中翻阅查找了，这样造成费时、费力，如要对很长时间以前的货品进行更改就更加困难了.因此，很有必要建立一个仓库管理系统，使货品管理工作规范化，系统化，程序化提高信息处理的速度和准确性。
本文首先分析了仓库系统的背景，明确了本文的研究思路和方向，然后，按照软件工程项目的要求，进行了该项目的业务需求分析，并通过业务流程整理和问题分析，整理出系统的需求，根据分析结果进行了系统的建模，在需求分析的基础上，进行了系统的设，包括软件应用架构设计、网络架构设计以及业务逻辑设计，其间，以面向对象的理论为基础，运用PP进行系统的相关设计，在系统分析和设计的基础上，进行了系统的数据库设计，包括数据库建模E-R图和数据库逻辑设计，最后，对系统进行了开发和运行测试，开发了一个用户交互性能良好、功能实用、能满足当前需求以及可扩展的仓库系统，对开发的系统进行了相关的测试。
在本文的研究中，在系统的架构设计方面以及用户交互体验方面做了较多的工作，目标是开发出一个拓展性强、代码重用度高的系统，以便将来的拓展和维护，同时，提高系统的实用性及易用性，收到了比较好的效果。本文主要开发的部分包括有：仓库后台管理系统。
本系统运用了Spring,SpringBoot,SSM流行框架技术来对业务逻辑和数据持久化操作，在划分模块及确定各模块所需实现的功能，各模块之间的功能的协调和信息沟通，模块设计结束后的整合。此系统流程相对清晰，功能上主要完成对仓库的管理和各种操作，同时也实现了对系统管理员的增删操作。通过后期系统的不断完善和改造，优化界面并且修改系统漏洞，基本实现了各个功能模块。
【关键词】仓库管理系统，jsp编程技术，mysql数据库，SSM，Springboot
Abstract The current era is a rapidly developing information era, and information processing is indispensable in all walks of life. This is precisely the environment where computers are widely used in information processing systems. The greatest advantage of computers is that they can be used for information management and information control, not only improving work efficiency, but also greatly improving their security. Especially for complex information management, computers can give full play to their advantages.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd4e7b8c4a14f89cf99296c90f8388b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53753a595ef9492040e3c0abf8d67762/" rel="bookmark">
			nodejs开启多进程（简单实用，易看懂）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		讲一下node是如何开启多进程来提高应用程序的性能和可扩展性。常见的方法有以下几种
第一种
使用child_process模块创建子进程。这种方法通常用于执行一些耗时的计算任务，使用子进程可以将这些任务分配给不同的CPU核心进行并行处理
// process.js const child_process = require("child_process"); for (var i = 0; i &lt; 5; i++) { var workProcess = child_process.exec( "node son.js " + i, // 此处的i是传递到子进程中的值 function (err, stdout, stderr) { if (err) { console.log(err.stack); console.log(err.code); return; } console.log(stdout, "stdout"); console.log(stderr, "stderr"); } ); // 退出事件 workProcess.on("exit", function (code) { console.log(code, "子进程已退出"); }); } 子进程
// son const sum = process.argv[2]; console.log("子进程正在执行" + sum); 上面是采用child_process模块创建子进程，当然这只是其中的一种写法，还有其他写法就不一一列举了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53753a595ef9492040e3c0abf8d67762/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ea04efab791ebab54eb45368b0edb57/" rel="bookmark">
			正则表达式集合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、校验数字的表达式
1. 数字
2. n位的数字
3. 至少n位的数字
4. m-n位的数字
5. 零和非零开头的数字
6. 非零开头的最多带两位小数的数字
7. 带1-2位小数的正数或负数
8. 正数、负数、和小数
9. 有两位小数的正实数
10. 有1~3位小数的正实数
11. 非零的正整数
12. 非零的负整数
13. 非负整数
14. 非正整数
15. 非负浮点数
16. 非正浮点数
17. 正浮点数
18. 负浮点数
19. 浮点数
二、校验字符的表达式
1. 汉字
2. 英文和数字
3. 长度为3-20的所有字符
4. 由26个英文字母组成的字符串
5. 由26个大写英文字母组成的字符串
6. 由26个小写英文字母组成的字符串
7. 由数字和26个英文字母组成的字符串
8. 由数字、26个英文字母或者下划线组成的字符串
9. 中文、英文、数字包括下划线
10. 中文、英文、数字但不包括下划线等符号
11. 可以输入含有^%&amp;',;=?$\"等字符
12 禁止输入含有~的字符
三、特殊需求表达式
1. Email地址
2. 域名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4ea04efab791ebab54eb45368b0edb57/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42e16eca7d151d3a7b131548319f7132/" rel="bookmark">
			C# Webform Session登录身份验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IIS开启匿名访问，关闭Window身份验证【默认】
Login页面写 Session["标识符"]="Value";
如在登录按钮事件内写 Session[UserName]="Test"；
Main页面在Page_Load方法内写
protected void Page_Load(object sender, EventArgs e)
{
if (!IsPostBack)
{
if (Session["UserName"] == null)
{
//用户名不正确，返回登录界面
Response.Redirect("Login.aspx");
return;
}
if (Session["UserName"].ToString().Trim() != "Test")
{
//用户名不正确，返回登录界面
Response.Redirect("Login.aspx");
return;
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14920044e9d8805f83a4c4450a03e302/" rel="bookmark">
			uni-app开发应用时，如何进行页面布局和设计？【跨平台开发教程uniapp教程（米饭科技-app小程序h5源码）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录： uni-app开发应用时，如何进行页面布局和设计设计方法flex布局使用快速入门grid布局使用快速入门源码获取方法：会员学习群：【一对一答疑】 uni-app开发应用时，如何进行页面布局和设计 设计方法 在uni-app中，可以使用Vue.js的语法进行页面布局和设计。以下是一些基本的布局和设计方法：
使用flex布局：可以通过设置display:flex属性来实现，可以实现简单的自适应布局。
使用grid布局：可以通过设置display:grid属性来实现，可以实现更复杂的自适应布局。
使用CSS样式：可以使用CSS的各种属性，如position、float、margin、padding等来进行页面布局和设计。
使用组件库：可以使用uni-app自带的组件库或其他第三方组件库，如vant、element-ui等来进行页面设计。
需要注意的是，在进行uni-app开发时，需要考虑不同平台的兼容性，需要注意样式和布局在不同平台上可能会有所不同。
flex布局使用快速入门 Flex布局是一个强大的CSS布局方式，用于使网站在各种设备上都能够自适应，快速构建响应式网站。
举个例子，以下是一个使用Flex布局的基本代码：
.container { display: flex; flex-direction: row; justify-content: center; align-items: center; } .item { order: 1; flex-grow: 1; flex-shrink: 1; flex-basis: 100px; } 常用的flex布局属性有:
display:flex; // 定义一个flex容器flex-direction: row/column/row-reverse/column-reverse; // 定义主轴方向flex-wrap:nowrap/wrap/wrap-reverse; // 定义是否换行justify-content:flex-start/flex-end/center/space-between/space-around/space-evenly; // 定义主轴对齐方式align-items:flex-start/flex-end/center/baseline/stretch; // 定义交叉轴方向对齐方式align-content:flex-start/flex-end/center/space-between/space-around/stretch; // 定义多行交叉轴方向对齐方式 grid布局使用快速入门 Grid布局是CSS3新增的一种二维布局方式，可以用于复杂的页面布局场景。以下是Grid布局的快速入门步骤：
在父元素上定义grid容器，通过display:grid样式来定义。例如： .container { display: grid; } 接下来，需要定义网格行和网格列。可以使用grid-template-rows和grid-template-columns两个属性来分别定义。例如： .container { display: grid; grid-template-rows: 100px 200px; grid-template-columns: 1fr 2fr; } 上述代码定义了2行网格行和2列网格列，第一行高度为100像素，第二行高度为200像素，第一列宽度为1/3，第二列宽度为2/3。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14920044e9d8805f83a4c4450a03e302/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8a7606669e5d02c665f00eb7b46f188/" rel="bookmark">
			SpringMVC框架面试专题（初级-中级）-第四节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家一起探讨～如果可以帮到大家请为我点赞关注哦～后续会持续更新
问题：
1.Spring MVC框架中的Websocket支持是什么？请举例说明如何使用Websocket。
解析：
Spring MVC框架中的Websocket支持是指在Web应用程序中通过Websocket协议实现双向通信的功能。Spring MVC框架提供了一组组件和API来支持Websocket。
在Spring MVC框架中，Websocket支持主要涉及到以下几个组件和API：
WebSocketHandler：用于处理Websocket请求。TextMessage：用于封装Websocket消息的文本内容。BinaryMessage：用于封装Websocket消息的二进制内容。WebSocketSession：用于封装Websocket会话信息。@Controller：用于标识处理Websocket请求的控制器。@MessageMapping：用于映射Websocket请求的URL。@SendTo：用于将方法返回值发送到指定的Websocket订阅路径。STOMP：用于定义Websocket消息的格式和协议。 下面是一个使用Websocket的例子：
@Controller public class WebSocketController { @MessageMapping("/hello") @SendTo("/topic/greetings") public Greeting greeting(HelloMessage message) throws Exception { Thread.sleep(1000); // simulated delay return new Greeting("Hello, " + message.getName() + "!"); } @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry config) { config.enableSimpleBroker("/topic"); config.setApplicationDestinationPrefixes("/app"); } @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint("/hello").withSockJS(); } } public class HelloMessage { private String name; public String getName() { return name; } public void setName(String name) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8a7606669e5d02c665f00eb7b46f188/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d1b2752b22f4537eee4ccdc850cc651/" rel="bookmark">
			【QT网络-TCP】双端数据收发，QTcpSocket客户端数据接收并写入到文件中，能在PC和Ubuntu、Ubuntu和开发板之间通信
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、【客户端】Widget构造函数中连接信号槽 connect(tcpSocket, SIGNAL(readyRead()), this, SLOT(receiveMessages())); 二、【客户端】槽函数完成数据接收、显示、写入到文件 void Widget::receiveMessages() { //先存储下来,为tcpSocket-&gt;readAll()只能用一次，再次调用是返回空 QByteArray tmpByteArray = tcpSocket-&gt;readAll(); fileContent.append(" " + tmpByteArray); //接受消息并显示 ui-&gt;textBrowser-&gt;append("服务端：" + tmpByteArray); //QString fileName = QFileDialog::getOpenFileName(this, "选择文本", "/home/zyl"); //返回的是一个字符串（路径+文件名） //qDebug() &lt;&lt; fileName &lt;&lt; endl; //设置要打开的文件 //file.setFileName(fileName); //将数据写入到本地文件 QFile file("/home/zyl/test.txt.txt"); //打开文件 if(!file.open(QIODevice::ReadWrite)){ //文件打开失败 qDebug() &lt;&lt; "文件打开失败" &lt;&lt; endl; return; } //写文件 file.write是将写入的内容覆盖到文本内，如原文本内容为22222,写入111,结果文本内容为11122 file.write(fileContent); qDebug() &lt;&lt; tmpByteArray &lt;&lt; endl; //关闭文件 file.close(); } 三、传输数据界面展示 图1 服务端界面
图2 客户端界面
图3 文本内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1efa44c69a4718e37a3874def945bfda/" rel="bookmark">
			python的清华镜像源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在python中使用pip install命令往往会出现错误，这个时候不如使用国内的镜像源：
https://pypi.tuna.tsinghua.edu.cn/simple 从原来的直接pip install 到现在的：
pip install requests -i https://pypi.tuna.tsinghua.edu.cn/simple
其中requests是要安装的库名，根据自己的需求可以改变。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75bfbc4d40d773c5ec306fbbe54f0ee7/" rel="bookmark">
			如何从某个分支挑选某个提交快速合并到其他分支Cherry-Pick
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Cherry-Pick 适用场景：比如本地分支改了很多问题和需求，然后其中某个bug或者需求需要上生产。此时无需再在master上手动改一遍，直接Cherry-Pick即可。
一、将develop分支中某个提交快速合并到master分支中。 具体步骤：
1、将master分支checkout，然后update到最新 2、双击“develop分支，在右侧日志中找到需要合并的提交。 如下图，确保日志窗口中是你要更新的分支。
选中提交记录右键Cherry-Pick
3.查看master分支已经同步过去 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed8a71c99a5a8a62648f4f24e886b3c4/" rel="bookmark">
			微信小程序通过经纬度计算两点之间距离
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序中通过经纬度计算两点之间的距离km data:{ //当前定位位置 latitude: null, longitude: null, // 目的地坐标 latitude2: 116.403119, longitude2: 39.913607, } 2.计算距离函数
// 计算距离函数 Rad(d) { //根据经纬度判断距离 return d * Math.PI / 180.0; }, getDistance(lat1, lng1, lat2, lng2) { // lat1用户的纬度 // lng1用户的经度 // lat2商家的纬度 // lng2商家的经度 var radLat1 = this.Rad(lat1); var radLat2 = this.Rad(lat2); var a = radLat1 - radLat2; var b = this.Rad(lng1) - this.Rad(lng2); var s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed8a71c99a5a8a62648f4f24e886b3c4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/144/">«</a>
	<span class="pagination__item pagination__item--current">145/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/146/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>