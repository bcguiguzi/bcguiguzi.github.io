<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a60e4c66a90b6a871efc96d19772d06e/" rel="bookmark">
			[C&#43;&#43;]-字符串相加/字符串相乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.字符串相加
2.字符串相乘 1.字符串相加 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。
415. 字符串相加 - 力扣（LeetCode）
示例 1： 输入：num1 = "11", num2 = "123"
输出："134"
示例 2： 输入：num1 = "456", num2 = "77"
输出："533"
示例 3： 输入：num1 = "0", num2 = "0"
输出："0"
首先我们需要了解字符和数字之间的转换，需要了解ASCII码。其中字符'0'对应十进制48，字符'9'对应十进制57。将字符'x'转换为整型，可以使用'x' - 48 或者 'x' - '0' 。
首先需要将字符串尾部对齐相加（转换为int），保留进位，当较短字符串前几位时使用0代替。将所加的值尾插到新字符串中，最后将新字符串翻转即可得到结果。（若是一直头插，会一直挪动，导致效率低下）。具体代码如下
class Solution { public: string addStrings(string num1, string num2) { //计算num1，num2大小 int end1 = num1.size() - 1; int end2 = num2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a60e4c66a90b6a871efc96d19772d06e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2eec84c6294eb26d1d2cf203f6665ae3/" rel="bookmark">
			（四）ArcMap基础——要素的选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要素的选择 当要在已有的数据中选择部分要素时，ArcMap提供了三种方式：按属性选择、按位置选择及按图形选择。
目录 要素的选择一、按属性选择二、按位置选择三、按图形选择 一、按属性选择 通过设置 SQL 查询表达式，用来选择与选择条件匹配的要素。
(1)单击主菜单下选择–按属性选择，打开按属性选择对话框；
(2)选取执行选择时所依据的图层；
(3)指定表达式，可通过设置字段及其条件完成要素的选择。
例如，在演示数据中，我想要选择地类为果园的要素，首先打开按属性选择对话框，双击字段名”地类“，在运算符号中选择"=“，然后点击获取唯一值，得到所有的地类值，双击"果园”，此时的表达式为：“地类” = ‘果园’；最后点击确定，符合属性的要素会在视图中高亮显示。
二、按位置选择 可以根据要素相对于另一图层要素的位置进行选择。
请注意，要从与源图层中要素存在空间关系的图层 (或者一组图层) 中选择要素空间选择方法为源图层与目标图层之间的拓扑关系。
(1)单击选择按位置选择**，打开按位置选择对话框；
(2)在选择方法下拉菜单中设置选择方法；
(3)在目标图层列表框中勾选要选择要素的目标图层；
(4)指定与目标图层中具有一定空间关系的源图层；
(5)在空间选择方法中选择对应的空间关系规则。
例如，在演示数据中，我想要选择456图层中与123图层有相交的要素，首先打开按位置选择对话框，目标图层选择456，源图层选择123，选择方法为"与源图层要素相交"
三、按图形选择 按图形选择需要使用图形元素，图形元素不同于地理要素 (地理要素存储在图层中)，是在视图中临时绘制的图元。图形元素使用绘图工具在视图中绘制，可以通过绘制一个面状图元后，提取该面所包含的图层中的地图要素，一般情况下，会将该面所覆盖的点、线、面要素一并选择出来。
要使用此功能，请使用选择元素工具选择一个或者多个图形元素，选择主菜单选择按图形选择命令，完成提取。
按圆选择：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ac9b722e32fcb55e451744f7c350eeb/" rel="bookmark">
			Spring @Value的注解使用和原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 @Value注解在Spring开发中是一个使用很频繁的注解，在项目开发中，我们通常需要读取配置文件中的一些信息，对于SpringBoot项目，我们一般从yml文件中读取，如果我们自定义了配置文件，那么就可以配合@PropertySource注解来获取配置文件的配置项，当然，@Value不单单能读取配置文件，还能读取系统属性，还可以读取其他bean的属性，本章就来详细介绍@Value注解的使用和对源码进行分析。
使用 如下我们对value的使用进行详细介绍，value可以注入配置文件的属性，注入其它bean的属性，注册spring中自己实现的一些属性，比如操作系统信息。
属性类
MyProperties是一个bean，里面定义了一些属性，一般在项目中，如果需要全局使用某个配置信息，我们通常会定义一个属性类，然后在需要使用的地方直接注入，比如系统中我们需要存储大量的文件，文件是存储在文件服务器上面，数据库只存储文件所在文件系统的目录路径，而不会存储具体的ip地址，如果我们存储了能直接访问文件的链接，后续如果进行文件迁移，那么这些链接就不好处理，所以应该只存储文件在文件服务器的目录路径，那么返回给前端显示的时候，再获取文件服务器地址进行拼接就可以。
/** * 功能说明： 属性配置类 * &lt;p&gt; * Original @Author: steakliu-刘牌, 2023-04-27 10:08 * &lt;p&gt; * Copyright (C)2020-2022 steakliu All rights reserved. */ @Data @Component public class MyProperties { /** * 注入其他bean的属性 */ @Value("#{valueBean.username}") private String username; /** * 注入配置文件属性 */ @Value("${minio.url}") private String minioUrl; /** * 注入操作系统属性 */ @Value("#{systemProperties['os.name']}") private String os; } 复制代码 配置类
配置类主要就是使用@PropertySource注解来获取配置配置文件的属性。
@Configuration @PropertySource("classpath:minio.properties") public class ValueConfiguration { } 复制代码 配置文件minio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ac9b722e32fcb55e451744f7c350eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4630e785da97d894fe1a45ba2a25b85/" rel="bookmark">
			Oracle修改字段属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Oracle修改字段属性 今天项目上需要将数据库中的一个字段改为可为空，我清楚的记得Oracle修改字段属性的话都是需要将字段数据清空的，字段上有数据的话就不可更改字段属性，但是老大看到我的脚本后，问了一句修改为可空需要这么麻烦吗？我解释了一下，老大说不需要，直接改就可以，然后我试了一下真的可以，猜想可能是版本区别或者当初我记错了？哈哈哈，不再深究，在此只整理记录各属性修改条件以及修改的语句。
Oracle中的字段属性主要就是五种： 字段名称字段数据类型和长度字段是否可为空默认值注释 修改字段名称 --无论列是否有数据，都可以直接执行： ALTER TABLE TABLE_NAME(表名) RENAME COLUMN TB_NAME_OLD(旧的字段名) TO TB_NAME_NEW(新的字段名); 修改字段数据类型和长度 1. 假设列数据为空，则不管改为什么字段类型，都可以直接执行： ALTER TABLE TABLE_NAME(表名) MODIFY TB_NAME(字段名) DATA_TYPR(数据类型); 2. 假设列数据不为空，则需要将目标列置空后再修改： -- TABLE_NAME(表名) TB_NAME(列名) DATA_TYPE(数据类型) ALTER TABLE TABLE_NAME ADD TB_NAME_TEMP DATA_TYPE; --增加临时列 UPDATE TABLE_NAME SET TB_NAME_TEMP = TB_NAME; --备份要目标列的数据 UPDATE TABLE_NAME SET TB_NAME = NULL; --将目标列置空 ALTER TABLE TABLE_NAME MODIFY TB_NAME DATA_TYPE; --修改目标列的数据类型 UPDATE TABLE_NAME SET TB_NAME = TB_NAME_TEMP; --将数据恢复至目标列 ALTER TABLE TABLE_NAME DROP COLUMN TB_NAME_TEMP; --删除临时列 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4630e785da97d894fe1a45ba2a25b85/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca065ceb0deb23ba6e01d07c99a5d88/" rel="bookmark">
			前端程序员的职业发展规划与路线——ChatGPT的回答
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前端程序员的职业规划是？回答1： 作为一个前端开发程序员，您的职业发展路线可能如下：回答2：作为前端开发程序员，您的职业发展路线可能如下：回答3： 你的职业发展路线可能是这样的： 二、高级前端工程师应具备的能力回答1：请见如下对话回答2：请见如下对话。 三、其他问题 最近，chatGPT很热火，博主也玩了一下~
确实，它还可以写代码！
问了它几个关于职业发展的问题，与粉丝们分享，请见下文。
一、前端程序员的职业规划是？ 截图如下：
下面我就直接复制文字啦！是和它对话中获取到的。可参考：
回答1： 作为一个前端开发程序员，您的职业发展路线可能如下： 建立坚实的基础知识：包括HTML、CSS和JavaScript等前端技术栈的基础知识，以及Web标准和跨浏览器兼容性等基本概念。学习框架和库：现代的前端往往依赖于各种框架和库，如React、Vue、Angular、jQuery等。学会使用这些工具可以大幅提高您的生产力和代码质量。学习构建工具和打包工具：了解和掌握构建工具和打包工具（如Webpack、Gulp等）是前端开发不可或缺的一部分。这些工具可以帮助您自动化任务，提高开发效率。深入研究CSS：CSS是前端开发中重要的一环，通过学习CSS优化技巧、响应式设计原理，可以使网站在各种设备上呈现出更好的效果。学习移动端开发：随着移动互联网的普及，移动端开发越来越受到关注。了解移动端开发的技术和规范，如响应式设计、Rem/Em布局等，可以提升你的竞争力。参与开源项目：参与开源项目是提高技术水平、积累经验和拓宽人脉的好方法。通过为开源社区做出贡献，您可以得到更多的学习机会和认可。提高沟通能力：前端开发往往需要与UI设计师、后端工程师等不同背景的人员合作。因此，提高沟通能力也是重要的一步。 总之，一个成功的前端开发程序员需要持续学习和实践，并不断适应新的技术和趋势。
回答2：作为前端开发程序员，您的职业发展路线可能如下： 入门阶段：学习基本的Web技术，例如HTML，CSS和JavaScript，并了解常见的前端框架和库，例如React，Angular或Vue.js。
初级阶段：参加一些实习或者初级开发工作，以从实践中学习更多的知识和技能。在这个阶段，您可以进一步熟悉各种前端工具和技术，并构建自己的项目经验和作品集。
中级阶段：在这个阶段，您可能需要深入研究某些特定的领域或技术，例如移动应用程序开发、响应式设计或者前端性能优化等。您也可以开始关注前端领域的最新趋势，并学习如何将其应用到现有的项目中。
高级阶段：在这个阶段，您可以考虑成为一个专家级的前端工程师或者团队领导人。您需要拥有深厚的技术背景知识和丰富的项目经验，能够指导其他开发人员并协调整个团队的技术方向。
向管理层转型：如果您对管理和领导感兴趣，您可以考虑向管理层转型。在这个阶段，您需要具备良好的人际交往能力和组织能力，并且需要掌握一些领导和管理技能，例如项目管理、团队协作和谈判技巧。
回答3： 你的职业发展路线可能是这样的： 精通基础知识：前端开发有很多基础知识，包括HTML、CSS和JavaScript等。首先要熟悉这些基础知识并且能熟练运用。掌握框架和库：了解和掌握常用的前端框架和库，比如React和Vue.js等，可以提高你的工作效率和代码质量。深入学习某一个方向：前端开发是一个非常广泛的领域，包括Web应用程序、移动应用程序以及桌面应用程序等。你可以选择其中的某个方向进行深入学习，并逐步成为专家。学习后端开发知识：虽然前端开发主要涉及到客户端的开发，但是了解后端开发知识可以帮助你更好地与后端开发人员合作，提高工作协同效率。参加技术会议和交流活动：参加行业内的技术会议和交流活动，可以结交志同道合的朋友，扩大自己的人际网络，还可以了解最新的技术趋势。不断学习和更新知识：前端开发技术在不断更新和变化，要保持敏锐的观察力和学习能力，随时跟进最新的技术趋势。 总之，作为前端开发程序员，要不断提高自己的技能水平，并且紧跟技术的发展趋势。希望这些建议对你有所帮助！
由此看出，连它的回答都是“总—分—总”结构，符合中国人答题习惯，几个回答大概一致，并有不同阶段的划分。
二、高级前端工程师应具备的能力 回答1：请见如下对话 回答2：请见如下对话。 转为文字，如下：
1.HTML/CSS技术：掌握HTML/CSS的基本语法和语义化标签的使用，能够编写符合Web标准的页面，具备移动端响应式布局的实现能力，能够实现复杂的CSS动画效果。
2.JavaScript技术：掌握JavaScript的基础语法和ES6+的新特性，了解JavaScript面向对象编程和函数式编程的思想，能够使用JavaScript编写复杂的交互和动态效果，掌握常见的JavaScript框架和库，如React、Vue、Angular等。
3.前端工程化：了解前端工程化的概念和流程，熟悉常用的构建工具和自动化工具，如Webpack、Gulp、Grunt等，能够使用工程化工具完成前端项目的打包、优化、部署等工作。
4.前端性能优化：掌握前端性能优化的原理和方法，能够优化页面加载速度、减少HTTP请求次数、优化渲染流程等方面的性能问题，提升用户体验和网站访问速度。
5.前端安全：了解前端安全的基本概念和攻击方式，能够使用常见的安全防范措施和技术，如跨站脚本攻击（XSS）防范、跨站请求伪造（CSRF）防范、输入校验等，保障前端项目的安全性。
6.数据可视化：掌握常见的数据可视化库和技术，如D3.js、ECharts、Three.js等，能够使用数据可视化技术实现复杂的数据展示和交互。
7.移动端开发：了解移动端开发的特点和流程，掌握移动端开发的基本技术和框架，如React Native、Ionic、Flutter等，能够实现跨平台的移动应用开发。
8.后端技术：熟悉后端技术和Web开发的基础知识，了解常见的后端开发语言和框架，如Node.js、Python、Ruby on Rails等，能够与后端工程师有效配合，协同完成前后端分离项目的开发。
三、其他问题 webpack打包优化
移动端机型兼容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe748e21cc7fb3d406db408405b8e5a/" rel="bookmark">
			MySql中一条语句递归查询所有子节点，递归删除所有子节点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用什么技术 MySQL中可以使用WITH RECURSIVE关键字来实现递归查询。
二、表结构和数据背景 表结构
名类型注释namevarchar标签名称codevarchar标签codeparent_codevarchar父级标签codelevelint层级 label表中，level字段代表层级，更直观给大家展示数据
code是唯一标识
parent_code代表它的父级
现有数据如下 namecodeparent_codelevel第一级标签L0011第二级标签L002L0012第三级标签1L003L0023第四级标签1L004L0034第三级标签2L005L0023第四级标签2L006L0054 数据结构如下 第一级标签
└─ 第二级标签 (L002)
├─ 第三级标签1 (L003)
│ └─ 第四级标签1 (L004)
└─ 第三级标签2 (L005)
└─ 第四级标签2 (L006)
三、具体SQL实现 递归查询 传入最上层code，递归查询所有子节点
WITH RECURSIVE cte AS ( SELECT * FROM label WHERE code = '最上层的code' UNION ALL SELECT t.* FROM label t JOIN cte c ON t.parent_code = c.code ) SELECT * FROM cte; 递归删除 传入最上层code，递归删除最上层节点和对应所有子节点
WITH RECURSIVE cte AS ( SELECT code, parent_code FROM label WHERE code = '最上层的code' UNION ALL SELECT l.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fe748e21cc7fb3d406db408405b8e5a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18fb69d4d5fade2d34d665a7878e1356/" rel="bookmark">
			领域自适应(Domain Adaptation)方法综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 迁移学习的直观理解
2 迁移学习的种类
3 领域自适应简述
4 DA的研究方向
5 DA方法的种类
6 深度学习中的DA方法
6.1 基于差异的方法
6.2 基于对抗的方法
6.3 基于重构的方法
1 迁移学习的直观理解 人类容易在类似的任务上利用先前的经验，比如学过自行车就很容易学会摩托车，学会打羽毛球也能帮助学习打网球，学过小提琴也会对学习二胡有帮助。也就是把一个领域上学习的知识迁移到另一个领域上，目的也是让计算机有举一反三的能力（大概是实现AGI的一个重要的坎），或者是去尝试充分利用已经训练过的某个领域的知识来解决当前的任务（这样可以解决数据少的问题）。
在迁移学习中要强调源域（Source Domain）、源任务（Source Task）、目标域（Target Domain）和目标任务（Target Domain） 的概念。在普通机器学习方法里，源域和目标域是一样的，就是训练的是什么数据测试的也是这个领域的数据（比如“摄像头捕捉的行人图片”）；源任务和目标任务也是一样的，即希望模型能做什么事情，训练的就是做这件事（比如“分类猫和狗”）。而在迁移学习中源域和目标域可能是不一样的，源任务和目标任务也可能是不一样的（甚至可能一个是分类一个是回归），我的理解是源域-目标域、源任务-目标任务至少有一对不一样才能称为迁移学习。
2 迁移学习的种类 在2012年的SJ Pan的综述里将迁移学习按照有标记的样本的情况分为下面三大类，可以解决不同的问题。
3 领域自适应简述 Domain Adaptation是一种源任务和目标任务一样，但是源域和目标域的数据分布不一样，并且源域有大量的标记好的样本，目标域则没有（或者只有非常少的）有标记的样本的迁移学习方法。这样就是怎么把源域上从大量的有标记样本中学习的知识迁移到目标域上，来解决相同的问题，而目标域上能利用的大多只有没有标记的样本。
这里要解释一下“数据分布不一样”是什么意思，就比如下图中(a)组是不同来源的自行车和笔记本电脑的照片，有从购物网站下载的，也有数码相机拍的生活照，也有网络上获取的照片等，它们虽然都表达自行车和笔记本电脑，但是数据分布是不同的。
比如用(b)组的门牌号数据集SVHN去训练模型，去提取SVNH和MNIST的特征，然后将其可视化到一个平面内，是下图左边的样子，蓝色点是源域（SVNH）的样本，红色的点是目标域（MNIST）的样本，也就是说直接在源域上训练得到的分类器的分类边界无法很好的区分目标域的样本。而领域自适应这种迁移学习方法想达到的效果就是下图右边这样，让源域和目标域中的样本能对齐，这样模型就能在目标域上很好的使用了。
4 DA的研究方向 在领域自适应里面也会细分出很多方向。如果源域和目标域距离太大（比如源域是文字，目标域是图像），就可能需要进程多步的迁移，将这个非常大的迁移划分成一步一步的小段迁移，这就是下图中的多步领域自适应（Multi-step DA） 通过选择合适的中间域来转换成一个个单步领域自适应（One-step DA），这样就只要去研究单步迁移怎么做。
然后单步迁移又可以根据源域和目标域数据情况可以分成同质（Homogeneous，即数据空间一样，只是数据分布不一样）和异质（Heterogeneous，数据空间都不同）两种。
接下来，在同质或者异质的DA中又分别可以根据目标域数据的打标签情况分为监督的、半监督的、无监督的DA。学术界研究最多的是无监督的DA，这个比较困难而且价值比较高。
5 DA方法的种类 传统的的ML方法是最小化损失：
基于特征的自适应（Feature Adaption）是将源域样本和目标域样本用一个映射Φ 调整到同一个特征空间，这样在这个特征空间样本能够“对齐”，这也是最常用的方法：
基于实例的自适应（Instance Adaption）是考虑到源域中总有一些样本和目标域样本很相似，那么就将源域的所有样本的Loss在训练时都乘以一个权重（即表示“看重”的程度），和目标域越相似的样本，这个权重就越大：
基于模型参数的自适应（Model Adaption）是找到新的参数θ ′ 通过参数的迁移使得模型能更好的在目标域上工作：
如果目标域数据没有标签，就没法用Fine-Tune把目标域数据扔进去训练，这时候无监督的自适应方法就是基于特征的自适应。因为有很多能衡量源域和目标域数据的距离的数学公式，那么就能把距离计算出来嵌入到网络中作为Loss来训练，这样就能优化让这个距离逐渐变小，最终训练出来的模型就将源域和目标域就被放在一个足够近的特征空间里了。
这些衡量源域和目标域数据距离的数学公式有KL Divergence、MMD、H-divergence和Wasserstein distance等。
6 深度学习中的DA方法 注意，以下三种方法主体都属于5种基于特征的自适应方法。
6.1 基于差异的方法 例如经典的用于无监督DA的DDC方法，它是使用MMD（Maximum Mean Discrepancy） ，即找一个核函数，将源域和目标域都映射到一个再生核的Hilbert空间上，在这个空间上取这个两个域数据分别作均值之后的差，然后将这个差作为距离。用这个方法训练网络的Loss是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18fb69d4d5fade2d34d665a7878e1356/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00e88efa51a463884b65c170cc7ab425/" rel="bookmark">
			十四、Redis——数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 Redis数据结构-动态字符串
2 Redis数据结构-intset
​编辑小总结：
3 Redis数据结构-Dict
小总结：
4 Redis数据结构-ZipList
5 Redis数据结构-QuickList
小总结：
7 Redis数据结构-SkipList
小总结：
8 Redis数据结构-RedisObject
9 五种数据结构
1 Redis数据结构-动态字符串 我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。
不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：
1. 获取字符串长度的需要通过运算 2. 非二进制安全 3. 不可修改 Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。
2 Redis数据结构-intset 小总结： Intset可以看做是特殊的整数数组，具备一些特点：
Redis会确保Intset中的元素唯一、有序具备类型升级机制，可以节省内存空间底层采用二分查找方式来查询 3 Redis数据结构-Dict 我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。 Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）。
Dict的扩容
Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。
Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发哈希表扩容：
u 哈希表的 LoadFactor &gt;= 1 ，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程； u 哈希表的 LoadFactor &gt; 5 ； Dict的rehash
不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：
计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00e88efa51a463884b65c170cc7ab425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13ac16055f14c428ece9e2617bb93cee/" rel="bookmark">
			十三、Redis——最佳实践（Redis时参考的经验总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. Redis健值设计
1.1 优雅的key结构
1.2 拒绝BigKey
1.2.1、BigKey的危害
1.2.2 如何发现BigKey
1.2.3 如何删除BigKey
1.3、恰当的数据类型
​编辑 总结：
2、批处理优化
2.1、Pipeline
2.1.1、我们的客户端与redis服务器是这样交互的
2.1.2、MSet
2.1.3、Pipeline
小总结：
2.2、集群下的批处理
3 服务器端优化-持久化配置
4 服务器端优化-慢查询优化
4.1 什么是慢查询
4.2 如何查看慢查询
5 服务器端优化-命令及安全配置
6、服务器端优化-Redis内存划分和内存配置
7、服务器端集群优化-集群还是主从
1. Redis健值设计 1.1 优雅的key结构 Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：
遵循基本格式：[业务名称]:[数据名]:[id]长度不超过44字节不包含特殊字符 例如：我们的登录业务，保存用户信息，其key可以设计成如下格式：
这样设计的好处：
可读性强避免key冲突方便管理更节省内存： key是string类型，底层编码包含int、embstr和raw三种。embstr在小于44字节使用，采用连续内存空间，内存占用更小。当字节数大于44字节时，会转为raw模式存储，在raw模式下，内存空间不是连续的，而是采用一个指针指向了另外一段内存空间，在这段空间里存储SDS内容，这样空间不连续，访问的时候性能也就会收到影响，还有可能产生内存碎片 1.2 拒绝BigKey BigKey通常以Key的大小和Key中成员的数量来综合判定，例如：
Key本身的数据量过大：一个String类型的Key，它的值为5 MBKey中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB 那么如何判断元素的大小呢？redis也给我们提供了命令
推荐值：
单个key的value小于10KB对于集合类型的key，建议元素数量小于1000 推荐值：
单个key的value小于10KB对于集合类型的key，建议元素数量小于1000 1.2.1、BigKey的危害 网络阻塞 对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢数据倾斜 BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡Redis阻塞 对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞CPU压力 对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用 1.2.2 如何发现BigKey ①redis-cli --bigkeys
利用redis-cli提供的--bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与每个数据的Top1的big key。
命令：redis-cli -a 密码 --bigkeys
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13ac16055f14c428ece9e2617bb93cee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9af2762bcf2a9747ce3a8c42ac03202/" rel="bookmark">
			vxe-table &#43; ant design 实现 树形表格增删改、行上移、下移。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、功能说明1. 效果图2. 说明 二、实现三、导入 一、功能说明 1. 效果图 2. 说明 新增：新增表格父行新增：新增表格子行删除：删除父行更多下拉菜单（上移）：上移父行 / 子行更多下拉菜单（下移）：下移父行 / 子行编辑：父行只有名称列可编辑，子行没有限制。触发方式为点击单元格。 二、实现 &lt;template&gt; &lt;div class="box"&gt; &lt;span @click="addParent" style="margin-bottom:5px"&gt; &lt;a-icon type="plus-circle" style="margin-right:5px" /&gt;新增 &lt;/span&gt; &lt;a-spin :spinning="spinning"&gt; &lt;vxe-table border resizable auto-resize show-overflow highlight-hover-row highlight-current-row ref="xTable" row-id="id" max-height="500px" :data="tableData" :edit-config="{ trigger: 'click', mode: 'cell', activeMethod: activeMethod }" :tree-config="{ children: 'children' }" &gt; &lt;vxe-column field="name" title="名称" :edit-render="{}" tree-node&gt; &lt;template #edit="{ row }"&gt; &lt;vxe-input v-model="row.name" type="text"&gt;&lt;/vxe-input&gt; &lt;/template&gt; &lt;/vxe-column&gt; &lt;vxe-column field="code" title="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9af2762bcf2a9747ce3a8c42ac03202/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4816efb3ee12a994ee5cb2e1a5cfb37/" rel="bookmark">
			Unity编辑器--奇怪的数据缓存问题导致通信异常，需要每次进入场景时重新编译才正常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在unity里，最近出现了一个奇怪的问题，就是只能在编辑器环境下，运行1次HTTP通信，之后再运行，就收不到服务器数据了。看服务器数据，是返回给了Unity，但是unity无响应。
导出版本，无论是PC版，还是android版，都没有这个问题。所以出在编辑器上。
解决办法： 进入编辑器配置，Edit &gt; Project Settings &gt; Editor
然后去掉 Enter Play Mode Options 的勾选。
干脆连缓存也不要了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f5237ab0f3f5260ec6dd5eaf98ec63/" rel="bookmark">
			微信小程序 vue 滑块验证码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提：之前写的vue版滑块验证码，可以在h5和web使用，但是在微信小程序运行就有问题。因此进行一系列的修改
一、vue版滑块验证码实现地址
vue 图片拖拽验证码_周皮皮皮皮皮皮的博客-CSDN博客
二、微信小程序遇到问题
1. 小程序是没有window和document对象，所以要把之前代码中的document改成wx.createSelectorQuery()去获取dom，记住每一个dom都要写一遍wx.createSelectorQuery
2. 创建图片用createImage()
三、代码展示
1. code.vue（验证码组件）
&lt;template&gt; &lt;div id="slideVerify" class="slide-verify" :style="widthlable" onselectstart="return false;"&gt; &lt;canvas ref="canvas" type="2d" id="myCanvas" /&gt; &lt;canvas ref="block" type="2d" id="myBlock" class="slide-verify-block" :style="{ left: sliderLeft }" /&gt; &lt;van-icon class="slide-verify-refresh-icon el-icon-refresh" name="replay" @click="refresh" /&gt; &lt;div class="slide-verify-info" :class="{ fail: fail, show: showInfo }" @click="refresh"&gt; {{ infoText }} &lt;/div&gt; &lt;div class="slide-verify-slider" :style="widthlable" :class="{ 'container-active': containerActive, 'container-success': containerSuccess, 'container-fail': containerFail }" &gt; &lt;div class="slide-verify-slider-mask" :style="{ width: sliderMaskWidth }"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c3f5237ab0f3f5260ec6dd5eaf98ec63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/792c75120fae3eba64e086e22f53819b/" rel="bookmark">
			在Ubuntu20.04下安装MySQL 5.7.41
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天要在centos 7下运行OBS Studio，结果努力了好几天都运行不了。最后妥协了，决定在Ubuntu下安装。这样系统就要整体移植到Ubuntu，其中就包括了MySQL服务。这里把安装过程记录一下。
1、sudo apt update
更新一下安装源
2、sudo apt install -y mysql-server-5.7
安装过程需要输入两次mysql的root用户的密码
3、mysql -V
查看一下安装的MySQL版本
4、mysql -uroot -p
登录MySQL服务
5、use mysql;
6、update user set host='%', password_expired='N' where host='localhost';
设置用户不过期
7、update mysql.user set Host='%' where HOST='localhost' and User='root';
允许从本地和远程链接
8、update user set plugin="mysql_native_password" where user='root';
root用户在使用auth_socket插件 我们让他用mysql_native_password
9、set password=password('您要使用的密码');
重置一下密码
10、FLUSH PRIVILEGES;
加载使修改生效
11、sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf
把bind-address = 127.0.0.1 注释掉，取消链接IP限制
12、service mysql restart
重启MySQL
下面是在Ubuntu下卸载MySQL的命令：
1、sudo apt-get autoremove --purge mysql-server
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/792c75120fae3eba64e086e22f53819b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e43bdb3f21f4de4ff2a8268bed2163a/" rel="bookmark">
			SSH连接虚拟机报错问题解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天第一次尝试给第二台虚拟机配置静态ip时，发现SSH同时连接不上两台服务器，在网上找了一下解决方案
第一是检查防火墙是否出错
由于我防火墙没问题，就跳过了这一步
然后是检查ifcfg-ens33配置文件（/etc/sysconfig/network-scripts/ifcfg-ens32）是否配置有误，也没问题，但这里有值得注意的点
补充一下，子网掩码前面的几个255是规定有几位是写死的，比如我的ip是192.168.40.xxx ，子网掩码是255.255.255.0，子网ip就只能设置为修改xxx的值，前三位是固定的
这时候尝试ping 本地主机，出现了错误，无法连接本地主机，尝试各种方法后发现是网卡出了问题
如上位置找到网卡并重启后即可正常ping主机 但是SSH还是连接不上主机
于是在黑窗口执行如下指令
service sshd start
这时候连接主机的虚拟机成功连接了！
但是设置了其他静态ip的虚拟机不能成功连接
最后找到问题出在端口设置上
之前将端口设置成了23（以为和其他服务一样相同端口占用不能启动），将端口设置回和连接主机的虚拟机一样的22端口，终于成功连接（长舒一口气）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6c0273cafb30df0bb21cf97769f0ae0/" rel="bookmark">
			利用Floodlight进行DDOS攻击防御实验笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Floodlight Floodlight是Apache授权并基于JAVA开发的企业级OpenFlow控制器，当前最新版本是1.2。
Floodlight OpenFlow Controller -ProjectFloodlight：http://www.projectfloodlight.org/floodlight/
流表 把同一时间，经过同一网络中具有某种共同特征或属性的数据抽象为一个流。比如，一般将访问同一目的地址的数据视为一个流。流一般由网络管理员定义的，可以根据不同的流执行不同的策略。
流表是针对特定流的策略表项的集合，负责数据包的查找和转发。流表是交换机进行转发策略控制的核心数据结构。交换机芯片通过查找流表项来决策进入交换机网络的数据包执行适当的处理动作。可以将其理解为交换机收到数据包之后该做什么的一系列规则。 OpenFlow每个流表项由三个部分组成：用于数据包匹配的包头域（Header Fields），用于统计匹配数据包个数的计数器（Counters），用于对匹配的数据包如何处理的动作（Actions）
包头域：
OpenFlow流表的包头域（OpenFlow v1.1之后被称作匹配域），用于对交换机接收到的数据包的包头内容进行匹配。在OpenFlow v1.0中，流表的包头域中包括了12个元组（Tuple）：
（图片来源：Juniper Networks）
对应的中文解释：
计数器：
用于统计数据流量相关信息，可以针对交换机中的每张流表，每个数据流，设备端口，转发队列进行维护，用于统计数据流量的相关信息。
1）流表：统计当前活动的表项数，数据包查找次数，以及数据包匹配次数等。
2）数据流：统计接收到的数据包数、字节数、数据流持续时间等。
3）设备端口：统计接收到的数据包数，发送数据包数，接收字节数，发送字节数，错误发生的次数。
4）队列：发送的数据包数、字节数，溢出错误次数。
动作表：
用于指示交换机在收到匹配的数据包后，如何对其进行处理，每个流表项可以对应零到多个动作。
实验过程 在mininet 终端执行 h2 ping -f h1 模拟 Ping Flood Attack，会发现流量涨幅巨大。
调用Floodlight 的API 查询现有流表,返回为空：
添加一条静态流表，为了方便操作和查看，新建一个 ddos.json 的文件，将流表内容写入到这个文件，然后通过 API 进行提交 { "switch" :"00:00:00:00:00:00:00:01", "name" : "flow-mod-dropt", "cookie" : "0", "in _port" : "1", "priority" : "100" , "active" : "true" , "actions " : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6c0273cafb30df0bb21cf97769f0ae0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d11647a48fa456fe5deb8956bf37b82c/" rel="bookmark">
			呼吸灯的verilog实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		呼吸灯
1.简介
呼吸灯效果是小灯在一段时间内从完全熄灭的状态逐渐变到最亮，再在同样的时间段内逐渐达到完全熄灭的状态，并循环往复。这种效果就像“呼吸”一样，有张有弛，而且给人一种很舒服的感觉。其工作原理是利用PWM来控制小灯在相同时间段内的不同占空比， 即在同样小时间段内，小灯亮的时间依次增加到最大后再依次减小，从而实现渐亮到渐灭的“呼吸”效果。
2.波形图绘制
在画波形之前，我们先分析一下该如何才能让 led灯实现“呼吸”的效果。整个呼吸灯“呼吸”的效果分为两部分，一个过程是从灭到亮，另一个过程是从亮到灭。为了把复杂的问题简单化，我们把led整个“呼吸”的动作进行分解，先分析从灭到亮的过程，而从亮到灭则是与之相反的一个过程。
为了让“呼吸”的效果表达的比较完美，我们把从灭到亮的时间设置为1s，也就是led灯在1s的时间内完成从灭到亮的效果，同理从亮到灭也是一样的时间。
怎么该如何具体实现？首先我们需要在1s的时间内产生很多个时间相等的小段，然后控制每个时间小段中低电平持续的时间渐渐增加就可以了。为了让“呼吸”效果显得更加细腻，我们把1s的时间分成1000个时间相等的时间小段，每个小段的时间就是1ms，这1000个1ms的时间小段中低电平持 续的时间还不能相等，要有一个从少到多渐渐递增的关系，为了让1000个1ms的时间小段都不一样，我们就需要将1ms再分成1000个时间小段，那么每一个时间小段就是1us， 在逐渐变亮的过程中我们可以让led灯在第1个1ms的时间小段内亮0us，即全灭；第2个1ms的时间小段亮1us；第3个1ms的时间 小段亮2us，……，第998个1ms的时间小段亮997us，第999个1ms的时间小段亮998us，第1000个1ms的时间小段亮999us。在逐渐变灭的过程中同理，我们划分的等级越多，“呼吸”的就越顺畅，看上去的效果就越好，但是人眼的分辨率的有限的，当大于这个分辨率人眼就看不出来这种差异了。
下面我们开始进行波形的绘制，首先画出输入时钟和复位的波形，根据分析我们至少需要设计三个计数器，分别为用于计数从灭到亮1s时间的cnt_1s计数器、用于划分1000个1ms时间小段的cnt_1ms计数器和用于划分1000个1us时间小段的cnt_1us计数器。然后就是要确定每个计数器计数开始和清零的条 件。我们先画出cnt_1us计数器的波形，根据50MHz的时钟计算得需要计50个数，即计数器从0计数到49，只要不复位则计数器一直计数，cnt_1us计数器计数满即可清零。接下来就是产生cnt_1ms计数器的波形，我们想是不是可以利用已经产生好的cnt_1us计数器来产生cnt_1ms计数器呢？答案 是当然可以的，我们完全没有必要再重新产生一个计数1ms的计数器，而是利用已经做好的1us计数器，根据cnt_1us计数器的时间计算得每当cnt_1us计数器计数到49时cnt_1ms计数器加1，cnt_1ms计数器计数到999且cnt_1us计数器同时也计数到49时cnt_1ms计数器才能清零，如果 少了cnt_1us计数器计数到49这个条件，仿真时会发现最后一个1ms的时间小段是不够1ms时间的。我们也用同样的方法产生cnt_1s计数器，每当cnt_1ms计数器计数到999且cnt_1us计数器计数到49时cnt_1s计数器加1，cnt_1s计数器计数到999且cnt_1ms计数器计数到999 且cnt_1us计数器计数到49三个条件同时满足时cnt_1s计数器清零（条件如此多的原因和cnt_1us计数器的分析是相同的，编写代码仿真时可以观察效果）。
完全熄灭~完全点亮的波形图
cnt_1s计数器： 1s分成了1千份，每个T就是1ms，份数分的越大，呼吸效果越细腻
cnt_1ms计数器：计数1ms时的0—999单位是1Us,加一起就是1ms.以此类推，1s
cnt_1us计数器： 0.000 001 微秒/0.000_000_02s=50个
led_out： 当1ms计数值小于1s计数值时，给led低电平，这样低电平的时间越来越长
cnt_1s_en： 呼吸灯有两个部分组成，怎么区分2个过程尼？因此加入使能信号，初值为低电平,当1s计数器到最大值时进行取反，其他时刻保持不变，当使能信号为高电平时表示完全熄灭~完全点亮这个过程。
完全点亮~完全熄灭的波形图
3.代码
仿真代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e30afada5bb675511aa49a3ce9a70bf4/" rel="bookmark">
			VIIRS-NPP夜间灯光数据处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		夜间灯光数据处理通常包括以下步骤： 原始数据读取：将夜间灯光数据从NPP或VIIRS卫星获取。数据预处理：清除数据中的噪声等。灯光数据网格化：将原始数据转换为网格数据，以便于后续分析。灯光强度统计：对网格数据中的灯光强度进行统计。地理信息标记：为每个网格标记地理位置信息，以便于地理空间分析。可视化：将处理后的数据可视化，以便于更直观的理解和分析。
【来源：知乎】 数据预处理包含以下：
1.重投影：兰伯特等面积投影坐标系
{【投影栅格】输入和输出都是选择地理坐标系是World-WGS84坐标系；再次投影，投影坐标系选择Asian底下的第二个。}
2.重采样：【重采样】 使像元分辨率为500ｍ Nearest最邻近
3.裁剪：利用中国行政区划的矢量文件裁剪出夜间灯光图像的中国区域
4.灯光异常值处理：①最大灯光值处理
NPP-VIIRS月产品数据：
计划用月数据的avg_rade9h，年数据用vcm-orm-ntl.avg_rade9。
在每月的数据组合中，全球有许多地区不可能获得当月高质量的数据覆盖。这可能是由于云层的遮挡，尤其是在热带地区，或者是由于太阳光照，就像两极在各自的夏季所发生的那样。因此，这些数据的用户必须使用无云的观测文件，并且不能假定平均辐射率图像中的值为零意味着没有观察到光线。
版本1月度系列使用两种不同的配置全局运行。第一种方法排除了任何受杂散光影响的数据。第二组包括这些数据，如果辐射值经过了流光校正程序(参考)。这两个配置在文件名中分别表示为“vcm”和“vcmsl”。“vcmsl”版本，包括了经过光波校正的数据，将有更多的数据覆盖到两极，但质量将会降低。由用户决定哪一组最适合他们的应用程序。
vcm每个月的压缩包里包含3个文件，第一个是平均的DNB辐射率（扩展名avg_rade9.tif），第二个包含在平均中使用的无云观测的数量（文件扩展名cf_cvg.tif），第三个是不考虑云层覆盖的DNB观测的总数量(扩展名cvg.tif)
注：以上数据月产品介绍转载该博主：CSDN
记录：
1.ArcGIS预处理简单版：预处理
2.衡量GDP：衡量GDP
3.DMSP NTL夜间灯光指数EVI修正
4.论文参考： 《基于夜间灯光数据的重庆市城市扩张研究》
5.文档: NPP帮助文档
6.夜间灯光数据的处理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a3f221987e7feca438379546083130/" rel="bookmark">
			【leetcode速通java版】06——赎金信、三数之和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前 言
🍉 作者简介：半旧518，长跑型选手，立志坚持写10年博客，专注于java后端
☕专栏简介：代码随想录leetcode速通训练营java版本
🌰 文章简介：哈希表理论，leetcodeT383,T15
T383 赎金信 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。
(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)
分析这个题目和242.有效的字母异位词是一样的，你学会了吗？
class Solution { public boolean canConstruct(String ransomNote, String magazine) { // 维护一个字母的哈希表即可，因为只需要统计字母的频次，使用数组即可 int [] table = new int[26]; int temp = 0; char[] rChar = ransomNote.toCharArray(); char[] mChar = magazine.toCharArray(); for(int i = 0; i &lt; mChar.length; i++) { table[mChar[i] - 'a']++; } for(int i = 0; i &lt; rChar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a3f221987e7feca438379546083130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1805c1ac5bc685b942ed5c2a2072157f/" rel="bookmark">
			AOP和自定义注解的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AOP和自定义注解的使用 一、AOP的使用二、自定义注解 一、AOP的使用 关于aop的详解可参考以下几篇文章。
AOP统计接口访问次数
AOP记录接口调用次数
Spring中XML配置AOP ***
对于AOP的理解：
AOP通过代理的方式，通过预编译方式和运行期间动态代理实现程序功能的一种技术。通俗讲就是在给目标代码增加了触发器，开发人员可以控制在目标方法调用前（@Before）、抛出异常时（@AfterThrowing）、正常执行后（@AfterReturning）、最终结束（@After）、环绕通知（@Around，手动定义触发时机），在指定时机触发时织入新增代码。
通过不改动源码的情况下，加入增强逻辑，通常是：权限控制、事务控制、日志代码、性能监控。
/** * 通过AOP对数据共享/接入API进行监控统计 **/ @Component @Aspect public class APIMonitorHandler { private final static Logger log = LoggerFactory.getLogger(APIMonitorHandler.class); @Pointcut(value = "@annotation(com.fawkes.lhcity.common.annotation.APIMonitor) || " + "execution(public void com.fawkes.lhcity.modules.digital.projectreport.controller.*.*(int, java.lang.String))") public void pointCut(){} @After(value = "pointCut()") public void doAfter(JoinPoint joinPoint) { HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest(); //业务代码。。。 } @AfterThrowing(pointcut = "pointCut()") public void doAfterThrowing(JoinPoint joinPoint) { HttpServletRequest request = ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getRequest(); log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1805c1ac5bc685b942ed5c2a2072157f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15124ef9636c2f7bd180fa4af6919a1b/" rel="bookmark">
			CDN内容分发网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CDN内容分发网络1 定义2 优势2.1 稳定快速2.2 节约成本2.3 简单易用 3 CDN与传统的差距3.1 最后一公里传输质量3.2 成本3.3 源站压力 4 CDN衡量指标5 CDN工作原理6 基本概念7 应用场景8 使用限制8.1 加速域名备案8.2 内容审核8.3 域名8.4 IP源站8.5 缓存刷新类操作 9 计费方式10 配置服务10.1 开通CDN服务10.2 添加加速域名10.3 变更域名解析10.4 访客真实IP10.5 配置缓存过期时间10.6 验证生效10.7 停用删除加速域名10.8 刷新和预热10.9 访问控制10.9.1 Refer防盗链10.9.2 URL鉴权10.9.3 IP黑白名单 10.10 缓存命中率 CDN内容分发网络 1 定义 Content Delivery Network
建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络
替代传统以Web Server为中心的数据传输模式
比如在观看视频直播的时候
如果中心节点在上海，但是你在遥远的乌鲁木齐
那毫无疑问直播将会非常的卡顿
但是CDN就解决了这个问题
2 优势 CDN将源站资源缓存到阿里云全国各地的边缘服务器
供用户就近快速获取，提升用户体验，降低源站压力，避免网络拥塞，确保在不同区域、不同场景下加速网站内容的分发，提高资源访问速度
2.1 稳定快速 先进的分布式系统框架 :1500+全球节点充足的带宽、存储资源 :120T带宽能力稳定高效的性能指标 :毫秒级响应，搭配SSD存储更流畅完善的监控体系 :覆盖六大洲，主流运营商支持 2.2 节约成本 资源弹性扩展 :自主控制台丰富API，架构扩展便捷先付后用:按量付费，灵活切换计费方式 2.3 简单易用 自助化配置域名的添加、删除、修改、查询 遇到带宽压力，加速等方面，大概率要选CDN
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15124ef9636c2f7bd180fa4af6919a1b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/154/">«</a>
	<span class="pagination__item pagination__item--current">155/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/156/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>