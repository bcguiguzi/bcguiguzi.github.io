<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f1fe23c429968df1c11c5618fa1b073/" rel="bookmark">
			Debian9.12镜像下载及网络、软件源配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debian9.12安装、配置
文章目录 获取镜像虚拟机安装配置网络配置合适的仓库源更新软件包、安装所需工具、搭建环境Debian镜像下载链接其他资源 获取镜像 Debian9.12[Debian 9.12 官方原版镜像下载 | 任我乐 (renwole.com)]
使用迅雷下载磁力链接
虚拟机安装 参考 [虚拟机安装debian_云慕尧的博客-CSDN博客_debian虚拟机] 配置网络 cd /etc/network vim interface 双网卡配置： source /etc/network/interfaces.d/* # The loopback network interface auto lo ens192 ens192:1 iface lo inet loopback # The primary network interface allow-hotplug ens192 ens192:1 iface ens192 inet static address 172.21.1.8/16 iface ens192:1 inet static address 172.16.211.8/16 gateway 172.16.1.1 单网卡配置： source /etc/network/interfaces.d/* # The loopback network interface auto lo ens192 iface lo inet loopback # The primary network interface allow-hotplug ens192 iface ens192 inet static address 172.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f1fe23c429968df1c11c5618fa1b073/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0216341ffc281debf8ea8c5099706778/" rel="bookmark">
			什么是VPLS？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VPLS称为虚拟专用局域网业务（Virtual Private LAN Service），是共用网络中提供的一种点到多点的L2VPN业务，使地域上隔离的用户站点能通过MAN/WAN相连，并且使各个站点间的连接效果像在一个LAN中一样。它是一种基于MPLS和以太网的二层VPN技术，也被称为透明局域网业务TLS（Transparent LAN Service）。
VPLS的典型组网如上图所示，处于不同物理位置的用户通过接入不同的PE设备，实现用户之间的互相通信。从用户的角度来看，整个VPLS网络就是一个二层交换网，用户之间就像直接通过LAN互相连接在一起。
目的
随着企业的分布范围日益扩大以及公司员工的移动性不断增加，企业中VoIP（Voice Over IP）、即时消息、网络会议的应用越来越广泛，因此这些应用对端到端的数据通信技术有了更高的要求。端到端数据通信功能的实现依赖于一个能够支持多点业务的网络。
传统的ATM（Asynchronous Transfer Mode）、FR（Frame Relay）技术只能实现二层点到点互联，而且具有网络建设成本高、速率较慢、部署复杂等缺点。随着IP技术的发展，一种在IP（Internet Protocol）网络上提供VPN服务、可方便设定速率、配置简单的技术随之产生，这种技术即MPLS VPN技术。基于MPLS的VPN技术有两种，分别是MPLS L2VPN和MPLS L3VPN：
传统VLL（Virtual Leased Line）方式的MPLS L2VPN是在公网中提供一种点到点的L2VPN业务，不能直接在服务提供者处进行多点间的交换。
MPLS L3VPN网络虽可提供多点业务，但PE设备会感知私网路由，造成设备的路由信息过于庞大，对PE设备的路由控制性能要求较高。
针对以上问题，VPLS在传统MPLS L2VPN方案的基础上发展而成，是一种基于以太网和MPLS标签交换的技术：
由于以太网本身就具有的支持多点通信特点，使得VPLS技术可以实现多点通信的要求。
同时VPLS是一种二层标签交换技术，从用户侧来看，整个MPLS IP骨干网是一个二层交换设备，PE设备不需要感知私网路由。
因此，VPLS技术为企业提供了一种更加完备的多点业务解决方案。它结合了以太网技术和MPLS技术的优势，是对传统LAN全部功能的仿真，其主要目的是通过运营商提供的IP／MPLS网络连接地域上隔离的多个由以太网构成的LAN，使它们像一个LAN那样工作。
优点
充分利用运营商构建的IP网络资源，建设成本低。
充分继承以太网速率高的优势。
如果使用VPLS技术，企业无论LAN还是WAN，都可以只使用以太链路，实现快速和灵活的业务部署。
将企业网络的路由策略控制和维护权利交给了企业，增强了企业VPN网络的安全性和可维护性。
VPLS基本传输结构
整个VPLS网络就像一个交换机，它通过MPLS隧道在每个VPN的各个Site之间建立虚连接（PW），并通过PW将用户的二层报文在站点间透传。对于PE设备，它会在转发报文的同时学习源MAC并建立MAC转发表项，完成MAC地址与用户接入接口（AC接口）和虚链路（PW）的映射关系。
各组件概念如下：
AC（Attachment Circuit）接入电路，用户与服务提供商之间的连接，即连接CE与PE的链路。对应的接口只能是以太网接口。
PW（Pseudo Wire），虚电路，两个PE设备上VSI之间的一条双向虚拟连接。它由一对方向相反的单向的MPLS VC（Virtual Circuit，虚电路）组成，也称为仿真电路。
VSI（Virtual Switch Instance）虚拟交换实例，通过该实例，可以将接入电路映射到各条虚拟链路上。每个VSI提供单独的VPLS服务，根据MAC地址和VLAN Tag进行二层报文转发。VSI实现以太网网桥功能，并且能够中介PW。
PW Signaling，PW信令协议，VPLS实现的基础，用于创建和维护PW。PW信令协议主要有LDP和BGP。
Tunnel，隧道，用于承载PW，一条隧道上可以承载多条PW。隧道是一条本地PE与对端PE之间的直连通道，完成PE之间的数据透明传输，可以是MPLS或GRE隧道。
Forwarder，转发器，PE收到AC上送的数据帧，由转发器选定转发报文使用的PW。转发器相当于VPLS的转发表。
VPLS的基本传输结构如下图：
以VPN1中，CE1到CE3的报文流向为例，说明基本数据流走向：
CE1上送用户的二层报文，通过AC链路接入PE1；
PE1收到报文后，由转发器选定转发报文的PW；
PE1再根据PW的转发表项几隧道信息生成两层标签（内层私网标签用于标识PW，外层公网标签用于穿越隧道到达PE2）；
二层报文经公网隧道到达PE2，系统弹出私网标签；
由PE2的转发器选定转发报文的AC，将CE1上送的二层报文转发给CE3。
VPLS实现过程
CE之间报文的传输依赖于PE之间建立VSI以及VSI之间的PW。PE之间通过全连接的PW转发以太网帧。
在以太网上，为了避免环路，一般的二层网络都要求使能STP协议。但是对于VPLS网络来说使用PW全连接和水平分割转发来避免环路：
PE之间逻辑上全连接（PW全连接），也就是每个PE必须为每一个VPLS转发实例创建一棵到该实例下的所有其他PE的树。
每个PE设备必须支持水平分割转发来避免环路。如果从PW上收到报文，那么这个报文将不再向这个VSI关联的其他PW上转发，也就是说要求任意两个PE之间通过直接相连的PW通信，而不能通过第三个PE设备中转报文，这也就是PE之间逻辑上建立全连接（PW全连接）的原因。
VPLS网络中的PE设备包含控制平面和数据平面：
VPLS PE的控制平面主要实现PW的建立功能，包括：
成员发现：找到同一VSI中所有其他PE的过程。可以通过手工配置的方式实现，也可以使用协议自动完成，如BGP方式、BGP AD方式的VPLS。使用协议自动完成的发现方式成为“自动发现”。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0216341ffc281debf8ea8c5099706778/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fccf6d762463e0e25765173faf0edcb/" rel="bookmark">
			Pangolin&#43;Ubuntu20.04安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. cmake ..
2. make
3. sudo make install
git clone https://github.com/stevenlovegrove/Pangolin.git mkdir build cd build cmake .. make sudo make install 1. cmake .. ~/tools/Pangolin/build$ cmake .. -- The C compiler identification is GNU 9.4.0 -- The CXX compiler identification is GNU 9.4.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- Setting build type to 'Release' as none was specified.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fccf6d762463e0e25765173faf0edcb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/438de50f9b032a88fd3f9a9540e5a3c5/" rel="bookmark">
			UUID介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UUID Universally Unique Identifier：通用唯一识别码
使用某种规则，不是某种中心化的自增方式，来保证这个识别码的全局唯一性
生成规则： RFC4122来进行定义。
根据生日悖论，若每秒产生 10 亿笔 UUID，100 年后只产生一次重复的概率是 50%。如果地球上每个人都各有 6 亿笔 UUID，发生一次重复的概率是 50%。产生重复UUID 并造成错误的情况非常低，是故大可不必考虑此问题。
最早被用于阿波罗网络计算系统(Apollo Network Computing System) 和微软的 Windows 平台，如今 OpenStack 也广泛的使用它来标志计算、存储和网络等资源
GUID ：
微软按照 UUID 的规则实现的一套方法。目的：保证全局唯一性。微软已经使用 GUID 在 Windows 的 COM，ActiveX 等技术上了。注意： UUID 本质是有多种版本的，GUID 也是在不同的使用场景实现的是不同的 UUID 版本，比如 COM 是使用 UUID 版本1 进行实现的 1、构成： 长度：128bit 16字节，换算成16进制数（32个16进制）加上中间杠隔开
格式：xxxx xxxx-xxxx-Mxxx-Nxxx-xxxx xxxx xxxx(8-4-4-4-12)
M：UUID版本，1，2，3，4，5
N：8、5、a、b
可变因子
时间戳时钟序列节点信息(机器)—MAC地址 1.1、时间戳 Timestamp
60bit 无符号数
version为1：1582-10-15 00:00:000000000 到当前UTC时间，每隔100纳秒加1对于无法获取UTC时间的系统，统一采用localtime。（实际上一个系统时区相同就可以了）。time_low：0-31bit，32bittime_mid: 32-47bit,16bittime_hi_and_version: 包含两部分，version和time_h1 version 占用 bit 数为4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/438de50f9b032a88fd3f9a9540e5a3c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6221126ff1837f5c413d965412e1e9e/" rel="bookmark">
			Doxygen&#43;Graphviz&#43;Ubuntu20.04安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Doxygen官网：https://github.com/doxygen/
Doxygen is the de facto standard tool for generating documentation from annotated C++ sources, but it also supports other popular programming languages such as C, Objective-C, C#, PHP, Java, Python, IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, and to some extent D. Doxygen also supports the hardware description language VHDL.
Doxygen can help you in three ways:
It can generate an on-line documentation browser (in HTML) and/or an off-line reference manual (in LaTeX) from a set of documented source files.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6221126ff1837f5c413d965412e1e9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0cdf0490d65dfc8ba3f0523b0aba8f9/" rel="bookmark">
			【最新】cuDNN在CUDA11.7&#43;Ubuntu20.04下的安装及卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CUDA11.7已经安装好了，现在安装cuDNN
1、卸载
（1）查询
sudo dpkg -l | grep cudnn
$ sudo dpkg -l | grep cudnn ii cudnn-local-repo-ubuntu2004-8.6.0.163 1.0-1 amd64 cudnn-local repository configuration files ii libcudnn8 8.6.0.163-1+cuda11.8 amd64 cuDNN runtime libraries ii libcudnn8-dev 8.6.0.163-1+cuda11.8 amd64 cuDNN development libraries and headers ii libcudnn8-samples 8.6.0.163-1+cuda11.8 amd64 cuDNN samples （2）卸载
$ sudo dpkg -r libcudnn8-samples (Reading database ... 227274 files and directories currently installed.) Removing libcudnn8-samples (8.6.0.163-1+cuda11.8) ... $ sudo dpkg -r libcudnn8-dev (Reading database .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0cdf0490d65dfc8ba3f0523b0aba8f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a6628dca8933593a3bba5b2e2364593/" rel="bookmark">
			Vue Element-ui Table表格排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.表格中有时候会有排序的需求，如果只针对当前页进行排序，那么前端就可以实现排序，在对应需要排序的字段中，使用sortable字段即可。 &lt;el-table-column prop="date" label="日期" width="180" sortable //在需要排序的字段中，添加sortable，就可以在前端实现当前页中的排序 :default-sort="{prop: 'date', order: 'ascending'}" //default-sort指定的默认排序,默认用date这一列排序,排序为升序,默认的排序也是升序。这个语句根据自己的需求可要可不要。 &gt; &lt;/el-table-column&gt; 二.存在分页的情况时，前端仅仅使用sortable当前页排序已经不能满足我们的需求，无法对所有数据进行排序。这时候我们就要使用后端排序。 给el-table设置事件@sort-change=“onSortChange” &lt;el-table :data="dataList" border style="width: 100% height="calc(100vh - 250px)" @sort-change="onSortChange"&gt; //onSortChange为排序发生改变时调用的方法 &lt;/el-table&gt; 给需要排序的表格设置属性sortable=“custom” &lt;el-table-column label="操作时间" prop="opTime" sortable="custom" //sortable="custom"表示使用的排序为后端排序 :sort-orders="['ascending', 'descending']" // sort-orders接收一个数组,用来指定点击可排序表头时排列的顺序, &gt; //默认是['ascending', 'descending', null]点击时先升序ascending,再点击降序descending,再点击不排序null, &lt;/el-table-column&gt;	//按表格的默认索引排.可以自己设置排列顺序 。 //根据自己的需求可选择写不写这个语句，不写则默认是['ascending', 'descending', null] 声明 onSortChange() //点击时间排序 onSortChange(column){ console.log("column____________",column); //打印出传入的column，发现里面有3个数据 this.listQuery.sortType= column.order === "ascending" ? 1 : column.order === "descending" ? 0 : "" //将sortType设置为与后端约定的排序值，1为升序，0为降序，null为默认不排序 this.getList() }, 打印出传入的column，发现里面有3个数据，分别代表的意义是：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a6628dca8933593a3bba5b2e2364593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a3240ec712d15bd8e68c66f6333a80d/" rel="bookmark">
			nnUnet: 使用自己(自定义)网络训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、简介二、准备工作2.1 硬件需求2.2 调试环境2.2.1 路径2.2.2 parser 三、训练3.1 构建网络3.2 修改配置3.2.1 initialize3.2.2 initialize_network3.2.3 __init__ 四、注意事项参考资料 一、简介 nnUnet是有监督的医学图像分割绕不开的话题（虽然看到有些文章对比实验没加nnUnet？可能比不过？ ），其卓越的性能和简易的方法，为相关研究者提供了一项强有力的工具。然而，由于高度封装性，在原先代码中嵌入自定义网络进行训练，并不是十分方便（至少对我来说 ）。本文旨在分享一点在使用nnUnet训练自定义网络过程中的一点经验，可能存在纰漏（？？？），欢迎在讨论区交流！
二、准备工作 2.1 硬件需求 nnUnet的建议环境是Linux，若使用Windows，需修改路径相关代码（斜杠和反斜杠的替换），很麻烦（不推荐）。博主是在Ubuntu环境中使用Pycharm进行nnUnet的学习。
2.2 调试环境 nnUnet官方推荐的使用方法是在命令行，但这不方便初学者学习。因为只用过Pycharm调试代码（菜！），所以为了满足自己的需求（？），以便于用Pycharm的傻瓜式调试按钮，修改了部分代码： nnunet/paths.py 和 nnunet/run/run_training.py
2.2.1 路径 位于***nnunet/paths.py***文件中，将三个变量路径修改为自己的路径。custom_是博主自己定义的文件，大家可以随意实现。
from custom_ import custom_config base = custom_config['base'] preprocessing_output_dir = custom_config['preprocessing_output_dir'] network_training_output_dir_base = custom_config['network_training_output_dir_base'] 2.2.2 parser 位于***nnunet/run/run_training.py***文件中，这里nnUnet训练代码的入口(!!!)。由于不是命令行调用方式，需要将parser进行修改，添加 “-” 并设置 default 值。
parser = argparse.ArgumentParser() parser.add_argument("-network", default='2d') parser.add_argument("-network_trainer", default='nnUNetTrainerV2') parser.add_argument("-task", default='666', help="can be task name or task id") parser.add_argument("-fold", default='0', help='0, 1, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a3240ec712d15bd8e68c66f6333a80d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c00f28074ea31770be60096ce85fc4b/" rel="bookmark">
			Spring Boot 之 ORM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 ORM基本步骤起步依赖数据源DruidDruid 配置数据源监控 @Mapper@MapperScandao 和 mapper事务Spring 中事务SpringBoot 中事务 ORM ORM：Object Relational Mapping：对象关系映射 通过 MyBatis 操作数据库 基本步骤 添加 mybatis 起步依赖：完成 mybatis 对象自动配置，对象放在容器中pom.xml 配置文件中指定将 src/main/java 目录中的 xml 文件编译创建实体类创建 dao 接口 定义数据库操作方法 创建对应的 mapper.xml 文件 进行 sql 语句编写 创建 service 层 创建 service 接口和实现类调用 dao 的方法完成数据库操作，实现具体业务逻辑 创建 controller ，访问 service 方法实现业务写 application.properties 配置文件 配置数据库连接信息 起步依赖 三方提供的 SpringBoot 依赖以第三方名开始 SpringBoot 提供的依赖 以 spring 为开始 id 添加起步依赖之后相关依赖都已经被导入 添加 mybatis 依赖mysql 驱动依赖 数据源 配置 MySQL 数据源信息 默认使用框架中封装的连接池：Hikari spring: # 配置数据源，默认框架中封装的 HikariDataSource datasource: #自定义数据源类型 type: com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c00f28074ea31770be60096ce85fc4b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6253af55ebaff17fc6c8b175ef6fd1b/" rel="bookmark">
			Spring Boot 之 Swagger
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SwaggerSwagger介绍版本 使用依赖常用注解说明配置类 皮肤定制 Swagger Swagger介绍 Swagger 是一套基于 OpenAPI 规范构建的开源工具 OpenAPI Specification，OAS帮助设计、构建、记录以及使用 REST API OpenAPI 规范是在2015年由OpenAPI Initiative 捐赠给 Linux 基金会 该规范创建了 RESTful 接口规范通过有效映射与之关联的所有资源和操作来轻松开发和使用 API 主要部分 Swagger Editor 基于浏览器的编辑器可以编写 OpenAPI 规范 Swagger UI 会将编写的 OpenAPI 规范呈现为交互式的 API 文档使用浏览器来查看并且操作 Rest API Swagger Codegen 通过为 OpenAPI（以前称为 Swagger）规范定义的任何 API 生成服务器存根和客户端 SDK 来简化构建过程 SpringBoot 项目整合 swagger 需要用到两个依赖（旧版） 用于自动生成 swagger 文档 springfox-swagger2 用于帮助自动生成描述 API 的 json 文件 ``springfox-swagger-ui` 将描述 API 的 json 文件解析出来用一种更友好的方式呈现出来 新版只需要 SpringBoot 起步依赖 springfox-boot-starter 版本 新版本和老版本的区别主要体现在以下 4 个方面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6253af55ebaff17fc6c8b175ef6fd1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fb90b6f53360f15b9e654c1fcb4a7a8/" rel="bookmark">
			Spring Boot 整合 ...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Redis使用StringRedisTemplate序列化设置 RedisTemplate 序列化 DubboDubboZookeeperapi项目服务提供者消费者执行 对于 Redis 、 dubbo 本人还未正式开始学习，仅简单记录 Spring Boot 整合其的方式作为笔记
Redis NoSql 数据库，常用作缓存使用（cache）常用数据类型：String、hash、set、zset、listRedis 是一个中间件，独立的服务器 Java中常用客户端：Jedis、Iettuce、Redisson Spring、SpringBoot 中有 RedisTemplate 类处理和 Redis 交互 StringRedisTemplate、RedisTemplate 两个类 windows 版本 Redis
放到非中文路径redis.server.exe：启动服务端 不要关闭 redis-cli.exe：启动客户端 访问 redis 中的数据 使用 SpringBoot 使用 Redis
创建 SpringBoot 项目
&lt;!-- redis 的起步依赖 在项目中使用 RedisTemplate：StringRedisTemplate 操作 redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- data-redis 使用 lettuce 客户端 --&gt; 程序中使用 RedisTemplate 类的方法实际就是调用 lettuce 客户端中的方法 application.properties 中配置 redis 的信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fb90b6f53360f15b9e654c1fcb4a7a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0285f3af98392a821e16e22940124bbc/" rel="bookmark">
			Spring Boot 之 SpringSecurity、Shiro
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 安全框架SpringSecurity特点配置请求拦截配置类常用方法 权限认证内存认证JDBC 认证LDAP用户存储 MyBatisUserServceSecurityConf 表单登录验证状态权限 shiro核心组件特点配置MyControllerRealmShiroConfigShiro 过滤器过滤器分类 常见shiro异常页面 安全框架 安全框架：对访问权限进行控制 安全性包括用户认证（Authentication）和用户授权（Authorization）两部分 用户认证：指验证某个用户是否为系统中的合法主体 即用户能否访问该系统一般要求用户提供用户名和密码，系统通过校验用户名和密码来完成认证过程 用户授权：指验证某个用户是否有权限执行某个操作 不同用户所具有的权限是不同的一般系统为不同的用户分配不同的角色，而每个角色则对应一系列的权限 SpringSecurity Spring Security：在架构上将认证与授权分离，并提供了扩展点 充分利用 Spring IoC（控制反转），DI（依赖注入）和 AOP（面向切面编程）功能为应用系统提供声明式的安全访问控制功能，减少了为系统安全控制编写大量重复代码的工作确保基于 Spring 的应用程序提供身份验证和授权支持与 Spring MVC 有很好地集成 ，并配备了流行的安全算法实现捆绑在一起 对 Web 资源进行保护，最好于 Filter；对方法调用进行保护，最好于 AOP Spring Security 在进行用户认证以及授予权限时通过各种各样的拦截器来控制权限的访问，从而实现安全 特点 Spring Security 对 Web 安全性的支持大量地依赖于 Servlet 过滤器 过滤器拦截进入请求，并且在应用程序处理该请求之前进行某些安全处理 Spring Security 提供有若干个过滤器，能够拦截 Servlet 请求 并将请求转给认证和访问决策管理器处理，从而增强安全性 根据需要使用适当的过滤器来保护自己的应用程序 要使用 Servlet 过滤器且令其正常工作必须在 web.xml 文件中使用 &lt;filter&gt; 和 &lt;filter-mapping&gt; 元素配置 但并不适用于使用依赖注入进行的配置 FilterToBeanProxy 是特殊的Servlet过滤器 将委托转发给 Spring 应用程序上下文中的一个 Bean 来完成 被委托的 Bean 几乎和 Servlet 过滤器一样 实现 javax.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0285f3af98392a821e16e22940124bbc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b5415d71256512b82535bdba9074016/" rel="bookmark">
			Vue配置文件中的proxy中配置多个接口地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 这里以axios发请求为例子,这里是两个不同接口地址
axios.post('http://10.0.195.176:8889/api/admin/info/list') axios.post('http://10.0.195.179:7777/api/admin/info/list') 2.这时我们使用axios进行前设置（适用于target相同的代理）
​ // 一般在全局设置里引入，例如main.js，方便第二行的配置被每一个axios请求识别 import axios from "axios"; // 只要发送axios请求，就在请求前加入/api的开头 axios.defaults.baseURL = "/api"; ​ 3.这时我们还需要在vue.config.js中添加你需要的后台接口地址
proxy: { '/api': { target: `http://xx.x.xxx.xxx:xxxx`, ws:true, changeOrigin: true, pathRewrite: { '^/api': '' }, }, // detail: https://cli.vuejs.org/config/#devserver-proxy [ process.env.VUE_APP_BASE_API]: { target: `http://xx.x.xxx.xxx:xxxx`, ws:true, changeOrigin: true, pathRewrite: { [ process.env.VUE_APP_BASE_API]: '' }, secure: false }, }, 4.这时他就会用api代替我们的地址
我们在axios请求接口是的url
url:`api/aaa/info//list`,
5,此时显示接口调用成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7912af8cbc17b5baa07bb9c2914d9b84/" rel="bookmark">
			c&#43;&#43;基础知识第十天：结构体嵌套结构体，结构体作函数参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、结构体嵌套结构体
结构体内的成员可以是另一个结构体（访问时用.访问到不能访问为止）
1、例如：每个老师指导一个学员，一个老师的结构体中嵌套一个学生的结构体
#include&lt;iostream&gt; using namespace std; #include&lt;string&gt; //结构体嵌套结构体 //1、定义结构体(先告诉系统有这样一个数据类型） struct student { string name; int age; int score; }; struct teacher { int id; string name; int age; struct student stu; }; int main() { //创建老师 teacher t; t.id = 10000; t.name = "老王"; t.age = 50; t.stu.name = "小汪"; t.stu.age = 18; t.stu.score = 100; cout &lt;&lt; "老师姓名：" &lt;&lt; t.name &lt;&lt; " " &lt;&lt; "老师职工编号：" &lt;&lt; t.id &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7912af8cbc17b5baa07bb9c2914d9b84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7853ccb66171e2f7ab650dd67a174dfa/" rel="bookmark">
			CentOS 7 下升级 OpenSSL &#43; OpenSSH【在线 yum 安装依赖】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS 7 下升级 OpenSSL + OpenSSH【在线 yum 安装依赖】 文章目录 CentOS 7 下升级 OpenSSL + OpenSSH【在线 yum 安装依赖】当前版本查看OpenSSHOpenSSL 安装 Telnet 防止 ssh 无法登录【yum 安装 &amp;&amp; 配置】安装 telnet-server启动 telnet 服务配置 SELinux &amp;&amp; Firewalld 服务测试 Telnet 登录 升级 OpenSSL卸载老版本安装包安装编译依赖包备份 ssh 目录下载 OpenSSL 新版本安装包编译 &amp;&amp; 安装 OpenSSL验证安装结果 升级 OpenSSH下载 OpenSSH 新版本安装包解压安装包编译 &amp;&amp; 安装 OpenSSH验证安装结果 启动 &amp;&amp; 验证 ssh 服务启动服务配置开机启动验证 sshd 开机启动配置 ssh 允许 root 远程登录 遇到问题未关闭 SELinux 导致 ssh 无法登录 参考 当前版本查看 OpenSSH [root@localhost ~]# ssh -V OpenSSH_7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7853ccb66171e2f7ab650dd67a174dfa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d710515e77b892ee35fd9a26914651f/" rel="bookmark">
			Linux终端指令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 进程状态查看磁盘状态-分区df查看磁盘状态mkfs 分区格式化mount 挂载滴水成冰 进程状态查看 功能指令备注显示进程信息top实时显示占用进程显示完整进程信息top -c包含路径信息设置信息更新次数top -n 3更新三次后终止更新设置信息更新时间top -d 3更新周期为3秒以累积模式显示程序信息top -S以批处理模式显示程序信息top -b 磁盘状态-分区 功能指令备注磁盘使用情况df -h显示卷组的相关属性vgdisplay用于显示LVM卷组的信息。如果不指定”卷组”参数，则分别显示所有卷组的属性。比如卷组大小、状态、UUID、物理卷最大数量和逻辑卷最大数量等信息。如果不指定卷组名称，那么显示所有卷组的属性。语法 vgdisplay(选项)(参数) 选项 -A：仅显示活动卷组的属性； -s：使用短格式输出的信息。 参数 卷组：要显示属性的卷组名称 例： vgdisplay vg1000 #显示卷组"vg1000"的属性动态扩展LVM卷组vgextend它通过向卷组中添加物理卷来增加卷组的容量。LVM卷组中的物理卷可以在使用vgcreate命令创建卷组时添加，也可以使用vgextend命令动态的添加。语法：vgextend(选项)(参数) 选项：-d：调试模式； -t：仅测试。 参数： 卷组：指定要操作的卷组名称； 物理卷列表：指定要添加到卷组中的物理卷列表。 实例：vgextend vg2000 /dev/sdb2 #将物理卷"/dev/sdb2"加入卷组"vg2000"扫描显示LVM卷组列表vgscan查找系统中存在的LVM卷组，并显示找到的卷组列表。vgscan命令仅显示找到的卷组的名称和LVM元数据类型，要得到卷组的详细信息需要使用vgdisplay命令。 语法：vgscan(选项) 选项：-d：调试模式； --ignorerlockingfailure：忽略锁定失败的错误。vgcreate：创建vg vgreduce：在vg内删除PV vgchange：设置vg是否启动 vgremove：删除vg扫描具有PV的硬盘pvscan扫描系统中连接的所有硬盘，列出找到的物理卷列表。 pvdisplay：显示系统中的pv状态 pvremove：移除pv属性，让该分区不具有pv属性 pvcreated: 创建PV 实例：pvcreated /dev/sda1 /dev/sda2-d 调试模式 -e 仅显示属于输出卷组的物理卷 -n 仅显示不属于任何卷组的物理卷 -s 短格式输出 -u 显示UUID扫描LVM逻辑卷lvscan使用lvscan指令可以发现系统中的所有逻辑卷，及其对应的设备文件。 选项：-b：显示逻辑卷的主设备和次设备号。显示LVM逻辑卷空间属性lvdisplay用于显示LVM逻辑卷空间大小、读写状态和快照信息等属性。如果省略"逻辑卷"参数，则lvdisplay命令显示所有的逻辑卷属性。否则，仅显示指定的逻辑卷属性。 参数：逻辑卷：指定要显示属性的逻辑卷对应的设备文件 实例：lvdisplay /dev/vg1000/lvol0 #显示指定逻辑卷的属性lvextend：增加LV的容量 lvreduce：在LV里面减少容量 lvremove：删除一个lv lvresize：对LV进行容量大小的调整创建和维护分区表fdisk语法：fdisk [必要参数] [选择参数] 必要参数： -l 列出素所有分区表 ; -u 与 -l 搭配使用，显示分区数目 。 选择参数： -s&lt;分区编号&gt; 指定分区 ； -v 版本信息 。 菜单操作说明： m ：显示菜单和帮助信息 a ：活动分区标记/引导分区 \ d ：删除分区 l ：显示分区类型 \ n ：新建分区 p ：显示分区信息 \ q ：退出不保存 t ：设置分区号 \ v ：进行分区检查 w ：保存修改 \ x ：扩展应用，高级功能 df查看磁盘状态 语法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d710515e77b892ee35fd9a26914651f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ec90b712824e793e52f579f43bd00f7/" rel="bookmark">
			Batch Normalization理解总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题的提出 在训练深度神经网络时，随着梯度的下降，网络中的参数会不断更新。当前面网络的参数发生微小变化时，随着每一层的前向传播（线性层和激活函数等）而会使该微小的变化随网络的加深而变大，同时参数的改变会使得每一层的数据分布发生变化，这就是 Internal Covariate Shift（内部协变量偏移）。由于内部协变量偏移问题，后面层的网络需要不断调整以适应前面层输入数据分布（参数）的变化，因而在训练网络时需要使用低的学习率并且谨慎选择初始化参数，这使得模型训练的很慢。而且，在深度神经网络中，若使用饱和非线性激活函数（sigmoid，tanh等），可能会导致梯度消失。
举两个例子：例1：如图一，当输入两组数据大小相差很大时（x1&gt;&gt;x2），在x2上梯度下降快，但在x1上无明显变化。其梯度下降图左下方所示，传统做法是对输入数据进行特征缩放，使其梯度下降如图右下方所示。但由于ICS（内部协变量偏移），若对每层做特征缩放，则很难达到所有层同步变化，因而我们必须降低学习率，谨慎选择初始化参数，致使网络训练较慢。
图一 图二 例2：以使用sigmoid激活函数为例，如上图2二所示，当输入信号值很大（右侧蓝色虚线所标）或者输入信号很小（左侧蓝色虚线所标）时，梯度接近于零，因而容易产生梯度离散现象。
二、以往的解决办法——白化 白化是机器学习规范数据分布的方法，主要有PCA白化和ZCA白化。它们的目的是去除特征间的相关性，并且使得输入特征分布具有相同的均值和方差。PCA白化和ZCA白化的主要区别是PCA处理后数据服从均值为0，方差为1的标准正态分布；ZCA处理后数据服从均值为0，方差为任意一个值的正态分布。白化通过固定输入特征的分布，加速了模型的训练，但白化也存在一定的问题，如：计算成本高，改变了神经网络本身层的数据表达能力（表达意义）。
三、Batch Normalization的直观思想 BN就是将打乱的数据集分为若干batch，对于每一个batch单独做normaliazation，使其输入特征服从均值为0，方差为1的标准正态分布。为了保证数据能够表达出原有的含义，对normalization后的数据作线性变换，使其能够表达出原有含义。BN的目的就是通过改变输入数据分布来得到较优梯度。
normalization：
线性变换：
四、Batch Normalization步骤 在训练集上，BN步骤为，输入一个mini-batch，求出mini-batch的均值和方差，进行标准化处理，线性变化（变换和平移）。
在测试集上，记录训练集上每个batch均值的期望和方差的期望作为测试集的均值和方差。
使用训练好的β，γ进行线性变换
训练一个Batch Normalization网络完整算法
注：μ，𝞼 由batch中的data决定；β，γ 是网络中的参数，是学习得到的；ε防止方差为0，保持数值的稳定性。
五、Batch Normalization的优缺点 优点： 1、对模型初始化和超参数的影响不敏感。如下图所示，将参数乘以k倍，最后结果不变。
2、加速模型的收敛，能使用大的学习率。
3、有一定的正则化作用，不用dropout，减少正则化的使用，不易过拟合。batch中的数据都是从总体样本中抽样，但不同的mini-batch的均值方差不同，这就相当于增加了随机噪声，与dropout关闭神经元带来噪声类似，有一定正则化效果。
4、去除局部响应归一化（Alexnet用到的方法），相当于做了数据增强。
缺点： 1、batchsize 选择要慎重，太小的batch可能得到的均值方差不准确，影响训练。
2、不太适用于RNN。
参考 1、https://arxiv.org/abs/1502.03167 《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》
2、https://www.bilibili.com/video/BV1Ey4y1y7g1/?share_source=copy_web&amp;vd_source=18dcc28103cc0293145a663372a414fa
3、Batch Normalization(批量归一化)的作用_真心乖宝宝的博客-CSDN博客_批量归一化的作用a
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0534f87be7b94427ad59a799a6b0a5c5/" rel="bookmark">
			How to fix “__dirname is not defined in ES module scope“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I stumbled on this error while I used __dirname inside a ES module.
In an ES module, you cannot use __dirname.
Using __dirname in a Node script you can get the path of the folder where the current JavaScript file resides, and many Node.js projects use this.
But if you use it inside an ES module, you can’t use this, as the infamous “__dirname is not defined in ES module scope” error shows up.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0534f87be7b94427ad59a799a6b0a5c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082a508adf294234e0068209010d64a5/" rel="bookmark">
			二层转发原理详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是二层转发 二层转发就是基于MAC地址进行数据包转发。 1. 二层指的就是网络七层模型中的数据链路层 2. 数据链路层传输的数据单元叫 – 帧 以太帧格式
前两个字段分别是目的地址和源地址字段。第3个字段是2字节的类型字段，用来标识上一层是什么协议(0x800：IP协议，0x0806：ARP协议等)。第4个字段是数据字段，长度在46-1500字节之间。最后一个字段是CRC检验字段，存放4字节的帧检测序列FCS。校验范围是目的地址、源地址、类型、数据字段。
MAC帧长度最小为64字节，数据字段最小为46字节，如果不够，则自动加0填充。
3. MAC 地址 MAC地址也就是物理地址，大小为48位，6个字节，前24位是厂商代码，后24位为序号，比如H3C厂商代码为00-0f-e2。
单播地址：第一个字节最低位为0，如 00-0f-e2-00-00-06多播地址：第一个字节最低位为1，如 01-0f-e2-00-00-06广播地址：48位全为1，如ff-ff-ff-ff-ff-ff 4. 冲突域与广播域 冲突网络（冲突域）：连接在同一个到导线上的所有工作站点集合，一个节点发出的报文其余节点都能收到，从而产生冲突。广播网络（广播域）：限制以太网广播报文的范围，一个站点发送一个广播报文其余站点都可以收到。 5. 转发 基于MAC地址转发：主要是根据原MAC、目的MAC、MAC地址表进行业务转发（详细见原理）。基于VLAN转发：为了解决广播域的问题引入了VLAN机制进行隔离。 二、二层转发原理 1. 转发原理及流程 原理：基于原MAC、目的MAC、MAC地址表进行业务转发
流程：PC_A 与 PC_B通信
① PC_A 发送 ARP 请求给交换机1来尝试获取计算机B的mac地址（基于以太网的通信必须在数据帧中指定目标MAC地址才能通信）
②交换机1 收到广播帧（ARP请求）后，会将他发给除接收端口外的所有端口，也就是flooding了。
③计算机B 收到 ARP 后，回复 MAC 地址给A。
④计算机A 收到 B 的MAC地址后，写入以太帧目的MAC中，开始业务传输。
⑤交换机1 收到 PC_A 发出的以太帧后，会进行查表。如果查到，就按照MAC地址表指定的端口转发；查不到的话就进行广播转发。
附：查表流程 附：MAC地址学习流程（以下流程按照地址表中未学习到介绍，学习到的话直接转发）： ① PC_A 发送的以太帧进入交换机（假设与A连的端口是1，与B连的端口是2）
② 交换机查表，无相应信息
③ 交换机将收到 “以太帧的端口和源MAC地址” 学习到MAC转发表
④ 利用目的MAC转发，查表发现，MAC转发表中无 “目的MAC” 的对应信息
⑤ 广播，其他端口收到后丢弃，目的为以太帧中DMAC的设备接收
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/082a508adf294234e0068209010d64a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1eb1d9f72414711c186d925ae50f6df7/" rel="bookmark">
			什么是 TypeScript？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在今天的教程中，我们将一起来了解什么是 TypeScript ，以及它相对于原生 JavaScript 的一些优势。
TypeScript 简介
TypeScript 是 JavaScript 的超集。
TypeScript 建立在 JavaScript 之上。首先，我们编写 TypeScript 代码。然后，我们使用 TypeScript 编译器将 TypeScript 代码编译为纯 JavaScript 代码。
拥有纯 JavaScript 代码后，我们可以将其部署到 JavaScript 运行的任何环境中。
TypeScript 文件的扩展是 .ts ，而不是 JavaScript 文件的 .js 扩展名。
TypeScript 使用 JavaScript 语法，并添加了额外的语法来支持类型。
如果我们的 JavaScript 程序没有任何语法错误，那么，它也是一个 TypeScript 程序。这意味着所有的 JavaScript 程序都是 TypeScript 程序。
如果我们要将现有的 JavaScript 代码库迁移到 TypeScript，这将非常有用。
下图展示了 TypeScript 和 JavaScript 之间的关系：
为什么选择 TypeScript
TypeScript 的主要目标是：
将可选类型引入 JavaScript。
在当前 JavaScript 的基础上实现未来 JavaScript 的计划功能，即 ECMAScript Next 或 ES Next。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1eb1d9f72414711c186d925ae50f6df7/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/201/">«</a>
	<span class="pagination__item pagination__item--current">202/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/203/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>