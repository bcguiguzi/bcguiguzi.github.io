<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32fd51bee299766bfeac886499ac1f0/" rel="bookmark">
			7.1 可视化图表 (5%)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		业务图表决策树 分成了4类：比较、序列、构成、描述类
1.比较类：不同对象、项目间 大小多少，好坏关系程度。（强调数值，标签具体数值）
地域VS地域—— 地图项目VS项目：柱形图、条形图、雷达图、词云图、树状图进度VS目标：流量表、进度图 2.序列类：描述的事项整体变化趋势；
时间的序列：随着时间，可用 折线图、面积图、柱状图
状态不同的序列：基于某个事项递进状态关系的序列——漏斗图
折线图——时间面积图——时间柱形图——时间漏斗图 ——事件递进状态的 3.构成类：一个事项由多个不同的子级对象构成的来描述权重大小；（强调占比，标签-百分比）
饼图堆积图百分比堆积图瀑布图等 4.描述类：数据与数据间的关联关系与分布情况
反映子级和父级之间展开的构成关系——关系图 （属于描述）
指标卡——一个卡片值描述一个，也属于描述
直方图盒须图散点图气泡图关系图——反映子级和父级之间展开的构成关系 1、比较类 2、序列类 3、构成类 4、描述类 注：直方图和柱状图的区别
1、描述数据类型的方式不同。直方图主要用于描述连续型数据的分布关系，其各矩形通常是连续排列的。柱状图则用于描述离散型或称名型数据，其各矩形（柱子）是分开排列的
2、表示数据多少的方式不同。直方图用矩形的高度表示频数或频率，宽度表示组距；柱状图用条形的高度表示频数或频率，宽度固定，用于表示类别，没有数值意义。
3、坐标轴上的标尺分点意义不同。直方图的横轴通常表示数据区间，纵轴表示分布情况；柱状图的横轴通常是分类轴，纵轴表示数据的大小。
4、图形的直观形状不同。直方图的各个矩形（直方块）之间紧密相连，没有间隙，当数据分布人数极少或没有时，可能出现断点；柱状图的各个柱子之间存在空隙，横轴的变量可调换位置，适用于项目数量较少的数据。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00c5f1e8476203f55a69e97763390595/" rel="bookmark">
			c#委托、lambda、事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lambda Lambda表达式是一种匿名函数，Lambda表达式通常以箭头“=&gt;”分隔左侧的输入和右侧的输出。
(parameter_list) =&gt; { statement_block } parameter_list 是由一个或多个参数组成的逗号分隔列表，每个参数都包括类型和名称，可以为空。
如果只有一个参数，只写参数名即可，不用圆括号。
Func&lt;int, int&gt; add = y =&gt; 1 + y;
如果是多个参数，把参数放在圆括号内。
Func&lt;int, int,int&gt; add = (x,y) =&gt; x + y;
statement_block 是Lambda表达式的主体。statement_block表示一段代码块，它可以包含多个语句，多个语句使用大括号包裹。
如果Lambda表达式只有一句语句，statement_block不需要花括号和return语句。
Func&lt;int, int,int&gt; add = (x,y) =&gt; x + y;
如果是含有多条语句，必须加上花括号和return语句。
Func&lt;int, int,int&gt; add = (x,y) =&gt;
{
X = x+1;
Y= y+1;
Return x+y;
} 常用的方法
Where Where方法是IEnumerable&lt;T&gt;接口的扩展方法，它筛选序列中满足指定条件的元素，返回满足条件的元素序列.
List&lt;int&gt; numbers = new List&lt;int&gt; { 1, 2, 3, 4, 5 };
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00c5f1e8476203f55a69e97763390595/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2276808dcf05f066735c896bc128eefd/" rel="bookmark">
			idea：springboot项目搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、创建项目
1、File → New → Project
2、Spring Initializr → Next
3、填写信息 → Next
4、web → Spring Web → Next
5、填写信息 → Finish
6、处理配置不合理内容
7、注意事项
7.1 有依赖包，却显示找不到依赖，刷新一下maven
7.2 idea版本
二、编写应用程序启动main
三、编写hello程序
四、项目运行和使用
4.1 启动项目
4.2 web访问
一、创建项目 1、File → New → Project 2、Spring Initializr → Next 3、填写信息 → Next 注：Type 选 Maven Project ，Java Version 是正常的。
4、web → Spring Web → Next 5、填写信息 → Finish 注：Project location 需要设置新目录，不然此项目会在指定目录下生成项目，而不会自动创建新目录。
6、处理配置不合理内容 7、注意事项 7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2276808dcf05f066735c896bc128eefd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f81c69de4fed995be246642e48eecb2/" rel="bookmark">
			PyTorch：深度学习的革命性框架
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在深度学习领域，PyTorch已经成为了一个革命性的框架。自2016年开源以来，它以其高效、灵活和易于使用的特性，迅速获得了研究者和开发者的青睐。PyTorch不仅简化了深度学习的复杂流程，还提供了丰富的功能和强大的扩展性，使得深度学习的应用更加广泛和深入。下面将从PyTorch的核心特性、应用场景、生态系统、与其他框架的比较以及未来发展等方面，对PyTorch进行详细介绍。
一、核心特性
动态计算图：与TensorFlow等静态计算图框架不同，PyTorch使用动态计算图。这意味着在构建神经网络时，可以更加直观地进行调试和开发。同时，动态计算图还支持更高级的控制流，使得模型的构建更加灵活。
高效GPU加速：PyTorch内置了高效的GPU加速功能，可以充分利用GPU的计算能力，加速模型的训练和推理。这使得大规模数据的处理和复杂模型的训练变得更加高效。
丰富的模型和库：PyTorch提供了丰富的预训练模型和库，涵盖了图像识别、自然语言处理、语音识别等多个领域。这些模型和库可以方便地进行迁移学习和微调，大大降低了深度学习的门槛。
简洁易用的API：PyTorch的API设计简洁明了，易于学习和使用。同时，它还支持Python编程语言的语法和特性，使得代码的编写更加简洁和高效。
二、应用场景
计算机视觉：PyTorch在计算机视觉领域有广泛的应用，如图像分类、目标检测、图像生成等。通过训练深度神经网络模型，可以实现对图像中物体和场景的自动识别和分类。
自然语言处理：PyTorch在自然语言处理领域也有出色的表现，如文本分类、情感分析、机器翻译等。通过构建复杂的神经网络模型，可以实现对文本数据的自动处理和理解。
语音识别：PyTorch可以用于语音识别和语音合成。通过训练声学模型和语言模型，可以实现将语音转换为文本或将文本转换为语音的功能。这在智能音箱、语音助手等领域有广泛的应用。
强化学习：PyTorch还支持强化学习算法的实现和部署。通过构建智能体（agent）和环境（environment）的交互模型，可以实现自动化决策和控制。这在游戏AI、自动驾驶等领域有巨大的潜力。
三、生态系统
PyTorch的生态系统非常庞大且活跃，这主要得益于其开源特性和强大的社区支持。以下是一些关键的组成部分：
开源社区：PyTorch拥有一个庞大的开源社区，全球各地的开发者和研究者都在为项目的发展做出贡献。这意味着用户可以快速获得帮助、解决问题以及分享自己的成果。
模型库：PyTorch提供了丰富的预训练模型和库，如TorchVision、TorchText和TorchAudio等。这些库涵盖了多个领域的应用场景，使得用户可以方便地进行迁移学习和微调。
开发工具：为了简化深度学习的开发流程，PyTorch还提供了一系列开发工具，如TensorBoardX（用于可视化模型训练过程）、PyTorch Lightning（用于简化复杂模型的训练）等。这些工具可以大大提高开发效率和代码质量。
四、与其他框架的比较
与其他深度学习框架相比，PyTorch具有以下优势：
易于学习和使用：PyTorch的API设计简洁明了，易于学习和使用。同时，它还支持Python编程语言的语法和特性，使得代码的编写更加简洁和高效。相比之下，TensorFlow的API设计较为繁琐，学习成本较高。
动态计算图：PyTorch使用动态计算图，使得模型的构建更加直观和灵活。而TensorFlow则使用静态计算图，需要在构建模型时先定义好计算流程，这在一定程度上限制了模型的灵活性。
高效的GPU加速：PyTorch内置了高效的GPU加速功能，可以充分利用GPU的计算能力。而TensorFlow虽然也支持GPU加速，但在某些场景下，其性能可能略逊于PyTorch。
然而，TensorFlow也有其独特的优势，如广泛的应用场景、强大的分布式训练能力等。因此，在选择深度学习框架时，需要根据具体的应用场景和需求进行权衡。
五、未来发展
随着人工智能技术的不断发展和创新，PyTorch将继续发挥重要作用。未来，我们可以期待以下几个方面的发展：
更多的应用场景：随着深度学习技术的不断进步和应用场景的拓展，PyTorch将在更多领域发挥重要作用。例如，在自动驾驶、医疗诊断、金融风控等领域，PyTorch有望取得突破性的进展。
更高效的计算能力：为了满足大规模数据处理和复杂模型训练的需求，PyTorch将继续优化其计算能力和内存管理。通过引入更先进的算法和硬件加速技术（如TPU、ASIC等），PyTorch将进一步提高模型的训练和推理速度。
更强大的生态系统：随着PyTorch生态系统的不断壮大和完善，我们可以期待更多优秀的开源项目、库和工具的涌现。这将进一步降低深度学习的门槛，促进人工智能技术的普及和发展。
总之，PyTorch作为一个功能强大、易于使用、高度灵活的深度学习框架，在人工智能领域发挥着重要作用。通过深入了解其核心特性、应用场景、生态系统以及与其他框架的比较等方面，我们可以更好地理解和应用这一革命性工具，为人工智能的发展做出贡献。
以下是10个与PyTorch相关的联系题（练习题）及答案，这些题目旨在测试对PyTorch基本概念和操作的理解：
联系题1
问题：PyTorch中的torch.Tensor和torch.tensor有什么区别？
答案：torch.Tensor是PyTorch中张量的基类，它通常用于创建新的张量类型。而torch.tensor是一个函数，用于根据给定的数据和数据类型创建一个新的张量。通常建议使用torch.tensor来创建张量，因为它允许你明确指定数据类型。
联系题2
问题：在PyTorch中，如何检查GPU是否可用？
答案：可以使用torch.cuda.is_available()函数来检查GPU是否可用。该函数返回一个布尔值，指示GPU是否可用于PyTorch操作。
联系题3
问题：解释一下PyTorch中的torch.nn.Module类及其作用。
答案：torch.nn.Module是PyTorch中所有神经网络模块的基类。它定义了神经网络的基本结构和功能。通过继承torch.nn.Module类并实现其forward方法，可以创建自定义的神经网络层或模型。这个类还提供了许多有用的方法和属性，如parameters()和cuda()，用于管理模型的参数和设备分配。
联系题4
问题：在PyTorch中，如何将模型转移到GPU上？
答案：首先，需要检查GPU是否可用（使用torch.cuda.is_available()）。然后，可以通过调用模型的to(device)方法将模型转移到GPU上，其中device是一个指向GPU的设备对象（如torch.device('cuda:0')）。例如：model = model.to(device)。
联系题5
问题：解释一下PyTorch中的优化器（Optimizer）及其作用。
答案：优化器是PyTorch中用于更新模型参数的算法。它根据损失函数计算出的梯度信息来调整模型的权重和偏置，以最小化或最大化某个目标函数。PyTorch提供了多种内置的优化器，如SGD、Adam和RMSprop等。这些优化器具有不同的更新规则和超参数设置，可以根据具体的应用场景进行选择。
联系题6
问题：在PyTorch中，如何进行模型的训练、验证和测试？
答案：模型的训练通常涉及多个迭代周期（epochs），在每个周期中，使用训练数据对模型进行前向传播、计算损失、进行反向传播并更新模型参数。验证是在每个周期结束后使用验证数据集评估模型的性能，以监控过拟合和选择最佳模型。测试是在最终模型选择后使用测试数据集评估模型的性能，以评估其在未见过的数据上的泛化能力。在PyTorch中，可以使用循环和条件语句来控制训练、验证和测试的过程，并使用适当的损失函数和优化器来更新模型参数。
注意：以下题目涉及具体的代码实现，因此将提供简化的代码示例作为答案的一部分。
联系题7
问题：编写一个PyTorch代码片段，创建一个简单的全连接层（线性层）。
答案：
python
import torch.nn as nn # 创建一个全连接层，输入特征数为10，输出特征数为5 linear_layer = nn.Linear(in_features=10, out_features=5)
联系题8
问题：编写一个PyTorch代码片段，构建一个简单的卷积神经网络（CNN）。
答案：
python
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f81c69de4fed995be246642e48eecb2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a0030978dd9f92d06a78cbffa63515d/" rel="bookmark">
			查看Linux特定用户组的所有用户
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Linux中查看属于特定用户组的所有用户的命令，可以使用以下几种方法：
通过 /etc/group 文件： 打开 /etc/group 文件并查找你想要查询的用户组，该文件每一行代表一个用户组及其成员。例如，要查看名为 developers 的用户组有哪些用户，你可以执行以下命令并手动查看输出结果中的用户名部分：
grep developers /etc/group 输出格式类似：developers:x:1001:user1,user2,user3,...
其中，冒号分隔的部分分别是组名、密码占位符（大多数情况下是x）、GID和用户列表。
使用 getent 命令： 这个命令可以直接显示出用户组及其成员列表，更方便且结构清晰：
getent group developers 同样会返回类似于上述 /etc/group 查看的结果。
使用 grep 和 cut 等组合命令： 如果你想从 /etc/group 中提取出仅仅的用户列表，可以结合 grep 和 cut 或者其他文本处理工具：
grep developers /etc/group | cut -d: -f4- 这将只显示与 developers 组关联的用户列表。
使用 members 工具（如果已安装）： 有些系统上可能会提供一个名为 members 的命令行工具，专门用来列出指定用户组中的所有成员：
members developers 请根据你的具体环境选择合适的命令进行操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f536bd84ffd2701cc4cfb604f54b18b9/" rel="bookmark">
			093|如何缓解家长的“教育焦虑”? 别人家的孩子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		国庆假期，旅游或者在家休息可能是绝大多数人的选择。不过，我也注意到，一些有娃的家庭，国庆假期也没闲着，有带孩子上课外班的；有带孩子参加亲子营的。得到上的刘润老师，更牛，跟我说这个假期他要带着11岁的儿子一起去走戈壁，培养孩子的意志力。
我把他的计划跟身边有娃的朋友、家人分享，没想到引发了焦虑：有的朋友回家就和老公说，你瞧瞧别人家，11岁就开始培养孩子的意志力了，咱们是不是也应该做点什么？
像这样的焦虑，现在特别普遍。每个家长心里不仅有一个“别人家的孩子”，而且还有一个“别人家的家长”，总有追赶不完的目标。往往搞得孩子也累，家长也累。这种情况，怎么缓解呢？
就这个话题，我和得到上《小学生家长必修课》的主理人沈祖芸老师聊了一下。聊完之后我发现，其实有不少让家长焦虑的问题，在她眼里根本就不是问题。对于缓解焦虑，沈老师也给了几个具体建议。今天的《邵恒头条》，就来跟你分享一下沈老师的观点。
沈老师认为，想缓解教育焦虑，家长们要学会做的第一件事，就是给孩子的成长设定合理的预期，学会和现阶段的问题和平相处。
对于很多家长来说，焦虑的首要源头，往往是发现了孩子身上有这样那样的问题——比如孩子注意力不集中，上课不认真，怎么办？孩子做作业磨蹭，不会管理时间怎么办？孩子性格内向，跟同学搞关系搞不好，怎么办？等等。
平时就这些问题去咨询沈老师的人不少，但是她发现，家长90%以上的求助问题，都是孩子成长中必然会发生的问题。而按照教育学的规律来看，大多数成长中的问题要靠成长本身的力量去解决。
比如说，刚上一二年级的孩子注意力只能集中几分钟，必然上课的时候会走神，或者小动作不断；另外，孩子在那个阶段还没有时间长短的概念，必然不会规划和安排时间等等。这些问题，都能随着孩子的成长逐渐被解决。
所以，当家长发现孩子遇到某种问题或者缺乏某种品质的时候，首先得告诉自己，保持平稳的心态。如果回忆一下，可能自己小时候也出现过这类问题。你可以问问自己，这些问题是什么时候消失的，现在这些问题还会出现在自己身上吗？你现在对孩子的期待，是否是她／他这个年龄段的合理预期？
沈老师在她的得到课程《小学生家长必修课》里，按照年龄拆分了小学期间每个阶段的合理期待。比如说在时间管理上，一、二年级，你可以鼓励孩子对要做的事情，排列出优先级——是先玩游戏还是先做作业？但是如果你想让他对每件事要花多少时间完成有个概念，那可能要等到三、四年级再培养。而如果你想让孩子对一周的时间做出安排，那到了五、六年级做这件事更合适。
而且，沈老师还建议，在制定每一个方案的时候，别期待一步到位，而是要为孩子搭建一个能一步步往上攀的“脚手架”。
用注意力的问题来举例吧。如果你想培养孩子的专注，那么一开始你可以先从孩子感兴趣的领域入手，让他看喜欢的书坚持专注5分钟。然后，可以聚焦在写作业上，练习专注15分钟。最后，再帮孩子对重要但兴趣不够的领域进行管理，比如练字或者做计算题。
在这个过程里，要对孩子的成果及时肯定。比如说，沈老师建议，你可以给孩子画一张台阶图，每一级台阶设定5分钟、10分钟、30分钟等等，每达到一级就画上成功的标志。用这种方式让孩子清晰地看见成长进步的轨迹，达到激励的效果。
听到这，你可能会问了，如果是比较听话的孩子，那可能会愿意攀着家长给搭的“脚手架”，一步步往前进。但很多家长最头疼的，恰恰是孩子不听话，不按照家长的想法来，这时候怎么处理呢？焦虑的另外一个重要来源，就是“失控感”，觉得孩子成长的过程，并不受自己掌控，怎么办？ 沈老师的建议是，家长应该把对孩子的掌控欲，转化为对自我的审视，先做到“掌控自己”，再谈改变孩子。
大部分时候，家长总是单向要求孩子去做到，但很少思考自己能不能做得到。假如孩子犯了错，家长的第一反应是去批评他，而不是思考这个问题背后，自己的问题在哪里。
比如说，很多家长觉得孩子写作业拖拉，面对这个问题怎么办？
首先，你要检查自己有没有做事拖延的习惯。因为很多时候，孩子都在观察和模仿你的行为。如果发现自己也有这样的问题，你不妨和孩子相互监督，结伴纠正。
然后，你要看看孩子的拖拉，是不是你带来的问题。举个例子来说吧，有时候孩子在学校就把作业完成了，回到家想玩会儿手机游戏。但很多家长就会想着给孩子报个班或者买点课外练习册，把他的时间填满。这对孩子来说就是一个很消极的暗示。孩子接收的信息是，原来我作业做得越快，爸妈就会布置更多的作业，那何苦呢？我慢慢做，消磨一点时间多好。孩子都很聪明，他发现反正自己不能自由支配时间，做作业就会拖延。你看，孩子拖拉可能并不是源于他自己的习惯，而是因为你占据了他自由支配的时间。
好，这是沈老师给的第二条建议，与其整天琢磨着如何让孩子变得更好，不如先审视自己做得够不够好。
当然，还有不少家长的焦虑，是来源于老师的反馈。
像孩子上课不专心这种问题，往往都是家长从老师那里得到消息的。有时候老师还会很生气地叫家长来，说你家孩子不听课还影响到课堂正常秩序，干扰了其他同学。
一般来说，家长遇到这样的问题都会很着急，回到家就把孩子给批评一通。可是，沈老师看这个问题的视角不太一样，她常年给学校做顾问，所以她看问题的视角天然是从学校和老师的角度出发的。对这样的情况，她的建议是，作为家长，需要理解老师的真正诉求：找家长并不是投诉，而是在寻求你的帮助。你想啊，老师要维持严格的教学进度，而孩子们的学习程度有差异，时间紧，任务重。老师叫家长，是请家长在家庭层面去做努力。所以，面对老师的反馈，先别焦虑和忧心，而是要想一想怎么跟老师建立一种合作的关系，一起设计一个循序渐进的养成方案。
好了，在今天的《邵恒头条》里，我为你介绍了沈祖芸老师针对家长的教育焦虑提出的两个解决方案，一个是与问题和平相处，设定合理的预期；另一个，是把对孩子的焦虑转化为对自我的审视，从自己身上找到解决方案。
当然，要说到困扰家长的具体问题，那真是每个家庭各有不同。在沈老师的课程里，她探讨了一系列常见的情境，比如觉得老师对孩子关注度不够，怎么办？别的家长都给孩子报课外班了，你要不要给你们家孩子也报班？如果你感兴趣，可以去学习一下。 听了沈老师的分享，我自己的感受是，一个人要想缓解焦虑，最重要的是从固定性思维切换到成长性思维。有固定性思维的人，遇到一个问题或者一个挑战，往往会觉得孩子天性如此，比如我家孩子数学就是不行，我家孩子就是天性内向。而有成长性思维的人，遇到问题的时候会觉得这只是一个暂时的坎儿，未来总有解决方案。
https://www.dedao.cn/course/article?id=RQLYWyjMZoa0J1vvelXp4wvzDbO26B
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72e2e8bde08e26090f5c7678d434b37a/" rel="bookmark">
			Scala 之舞：林浩然与杨凌芸的 IDEA 冒险
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scala 之舞：林浩然与杨凌芸的 IDEA 冒险 The Dance of Scala: The IDEA Adventure of Lin Haoran and Yang Lingyun 在那个阳光明媚的日子里，林浩然如同一位英勇的探险家，踏入了 Scala 的 IntelliJ IDEA 开发环境的奇妙领域，他带着无畏的勇气，准备在代码的世界中掀起一场风暴。
On that sunny day, Lin Haoran, like a brave explorer, stepped into the wondrous realm of the Scala IntelliJ IDEA development environment. With fearless courage, he was ready to stir up a storm in the world of code.
他熟练地启动 IDEA，安装 Scala 插件，配置默认 JDK，每一个步骤都如行云流水，仿佛这是他早已熟悉的舞台。
He skillfully launched IDEA, installed the Scala plugin, and configured the default JDK.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72e2e8bde08e26090f5c7678d434b37a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/578448cb1bddaf6cbfb9e58d62ffb9a6/" rel="bookmark">
			考虑局部遮阴的光伏PSO-MPPT控制MATLAB仿真
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微❤关注“电气仔推送”获得资料（专享优惠）
简介
光伏电池阵列的输出特性曲线不是线性变化的。当光伏电池遮荫时，产生的功 率会不断变化，致使光伏电池阵列的输出功率不断变化，其输出特性曲线呈现多峰值的现象。
多峰值 MPPT 技术的产生是由于光伏发电系统的失配问题导致的。当光伏发 电系统处于失配状态时，其 P-U 输出特性曲线会变成一条多峰值的曲线，导致传统的单峰值 MPPT 控制算法跟踪到的最大功率点极有可能只是局部的极大值点， 并不是全局的极大值点，即造成算法失效；从而致使光伏发电系统的输出功率降低， 发电效率下降。
传统的光伏 MPPT 算法，如扰动观察法和电导增量法等，因其自身原理的缺陷，在太阳辐照度 不均匀的情况下易陷入局部解。为了解决陷入局部最优问题，近年来，国内外 研究 者 们 通 过 对 粒 子 群 优 化 ( particle swarm optimization，PSO) 算法的学习，针对光伏阵列 MPPT 进行了大量的研究。
粒子群算法的参数设置有着重要意义，可直接决定终止时间以及精确度。 为符合具体的目标要求合理设置参数，将详细介绍粒子群算法中参数的设置规 则如下：
（1）种群规模N：种群规模的大小直接影响算法的收敛时间。N比较小 则收敛时间较短，但算法很有可能陷入局部极值；N比较大时算法复杂度增
加，但精确性能够得到提高。
（2）粒子的最大速度Vmax：Vmax偏大则相应的算法寻优速度快，但是容 易发散越过最优值。尽管Vmax过小不会错过最优解，但粒子搜寻速度过慢并且
容易难于摆脱局部最优，降低算法效率。
（3）惯性权重w：惯性权重是粒子群算法中最为重要的研究参数，决定了当前粒子速度对于上代粒子的继承度，本章采用自适应惯性权重能够兼顾粒子的局部与全局寻优能力。在初始阶段采用较大的w能够防止算法陷入局部最 优，在算法后期采用较小的w提升收敛速度使收敛更加平稳。
（4）学习因子c1和c2：c1反映粒子趋向个体极值的比重，c2反映粒子趋向全局极值的比重。学习因子比较小时，粒子在接近目标区域时被拉回；学习 因子较大时，粒子搜索速度太快导致越过目标地区。
（5）空间维数E：待寻优问题中的变量的个数决定了空间的维数。 （6）适应度函数：通常直接将目标函数设为适应度函数。
对于光伏阵列系统采用粒子群算法寻找光伏阵列系统的最大功率点，将目 标函数设定为光伏阵列系统的输出总功率，粒子的位置表示光伏阵列的输出电 压值。
仿真模型
PSO-MPPT
U/V特性曲线
输出功率
参考文献
基于改进ＭＰＰＴ算法的局部阴影光伏阵列系统的研究——赵娟
光伏发电系统中多峰值 MPPT 控制算法研究——高震
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b5cc55f84bec8a6cbfa8370d5aef966/" rel="bookmark">
			论文翻译 - Are aligned neural networks adversarially aligned？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文链接：https://arxiv.org/pdf/2306.15447.pdf
Are aligned neural networks adversarially aligned？ Abstract1 Introduction2 Background3 Threat Model3.1 Existing Threat Models3.2 Our Threat Model 4 Evaluating Aligned Models with NLP Attacks4.1 Our Target: Aligned Chat Bots4.2 Prior Attack Methods4.3 Our Evaluation Setup4.4 Prior Attacks Results 5 Why do Existing NLP Optimization Attacks Fail?5.1 Our Test Set5.2 Prior Arracks Results 6 Attacking Multimodal Aligned Models6.1 Attack Methodology6.2 Experiments6.3 Quantitative Evaluation: Toxicity6.4 Qualitative Evaluation 7 Conclusion Abstract 现在大型语言模型被调整为和创建者的目标对齐，即“有用和无害”。这些模型应该对用户问题做出有益的反应，但拒绝回答可能导致伤害的请求。然而，对抗性用户可以构建输入来绕过对齐的尝试。在这项工作中，我们研究了当与构建最坏情况输入（对抗性示例）的敌手用户交互时，这些模型能在多大程度上还保持对齐。这些输入旨在使模型发出原本被禁止的有害内容。我们表明，现有的基于 NLP 的优化攻击不足以可靠地击破对齐的文本模型：但即使当前基于 NLP 的攻击失败了，我们还可以通过暴力破解找到对抗性输入。因此，当前攻击的失败不能证明在对抗性输入的攻击下对齐的文本模型仍能保持对齐。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b5cc55f84bec8a6cbfa8370d5aef966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a574d657fa9bf2d44b7e949a1f9e8b4/" rel="bookmark">
			Transformer——词向量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		词向量 在自然语言处理任务中，模型的输入大多为单个字或者词。但是字词都是自然语言的表述，对于以二进制为处理语言的计算机来说，其并不认识这个字词。所以需要将字词转换为计算机认识的数据。
转换的方法有很多，我们接下来将介绍其中最简单的一种：独热编码，这是一种将字词转换为计算机可以识别的数字向量的方式。
注：为什么不可以使用Unicode编码？其不也是唯一的吗？
Unicode编码是表示单个字的编码方式，但是在预模型中，很多词向量表示的是一个词，比如：“我” “有” “一只” “猫”
其中“一只”是一个词，其如果用Unicode编码表示，其长度维度和其他字词不一致。
One-Hot 独热编码 独热编码是一种将离散型（可以划分为n个类别）的数据转化为计算机能够理解的方式，其基本思想是在 n n n维向量空间中，使用 n n n个单位向量，每个单位向量代表一个类别。也就是说，如果我们有 n n n个类别，那么我们就会有一个长度为 n n n的向量，其中有一个元素为1，其余元素为0。这个1的位置就代表了这个类别在向量中的位置。
下面是“我” “有” “一只” “猫”的独热编码表示：
词语我有一只猫我1000有0100一只0010猫0001 独热编码虽然可以表示一个字词，但是假如说我的词库非常大。为了让每一个字词都在其中有着唯一的表示，我每个字词的表示就都是 n n n维的，这会带来极大的存储成本。同时，在独热编码中，每个单词都是由一个完全不同的向量表示的。这意味着相似的单词，其向量表示完全不同。这就导致我们在计算独热编码两两的相似度时，得到的欧氏距离都是相同的。
注1：词库：
也称为词汇表或字典，是用于自然语言处理（NLP）的基本工具之一。它是一个包含所有可能单词的集合，每个单词都有一个与之对应的索引。
注2：总结：独热编码在高纬度计算和语义信息表示上面有缺陷。
为了解决这个问题，我们需要引入一个新概念：词向量
词向量 词向量是一种用来表示单词的向量，它比独热编码更高级。词向量的长度通常比词库的大小要小得多，例如，我们可以用一个200维的向量来表示所有的单词，而不是使用一个100,000维的向量。此外，词向量可以捕捉到单词之间的语义关系，例如，“猫”和“狗”的词向量可能在向量空间中非常接近。
注：词向量的语义关系捕获
在自然语言处理（NLP）中，常见的词向量训练方法有Word2Vec、GloVe和FastText等。
在Word2Vec算法中，它通过学习预测上下文，使得语义相近的词在向量空间中靠得更近。GloVe算法则是通过利用全局统计信息（即词共现矩阵）来生成词向量。这种方法可以捕获到更丰富的词语共现信息，因此可以更好地表达词与词之间的关系。FastText算法则是通过考虑词的上下文信息以及词内部的字母级信息，从而更好地处理形态丰富的语言，以及处理词典中没有的词。 词向量是独热编码的一种改进和优化，其可以由独热编码 w x w_x wx​乘以权重矩阵 Q Q Q得到，公式如下：
w x ∗ Q = c x ( 词向量 ) w_x*Q=c_x(词向量) wx​∗Q=cx​(词向量)
上面的例子，可能会得到如下的词向量表示：
词语维度1维度2维度3我0.10.30.2有0.20.40.1一只0.40.10.3猫0.30.20.4 注：权重矩阵Q
权重矩阵Q是通过模型训练过程中的优化算法得到的。 以深度学习模型为例，权重矩阵Q是模型中的参数，通过反向传播和梯度下降等优化算法，不断调整这些权重，使得模型在训练数据上的预测误差最小。
word2vec Word2Vec是Google于2013年提出的一种用于生成词向量的两层神经网络模型。它的目标是根据给定的语境预测单词或根据单词预测语境。其主要用CBOW（Continuous Bag of Words）和Skip-Gram模型来做预测语境。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a574d657fa9bf2d44b7e949a1f9e8b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5590faecf65f06ea2c00574e875cf66f/" rel="bookmark">
			jetbrains历史版本下载地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是常用idea 开发工具，官网下载地址
phpstorm 历史版本
https://www.jetbrains.com.cn/phpstorm/download/other.html
pycharm 历史版本地址
https://www.jetbrains.com.cn/pycharm/download/other.html
IntelliJ IDEA 历史版本地址
https://www.jetbrains.com.cn/idea/download/other.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a2f1ebd0abe5a21cf003e7f7481c81a/" rel="bookmark">
			react-beautiful-dnd组件报Unable to find draggable with id
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题现象 项目中使用react-beautiful-dnd组件实现可拖拽，但拖了1次后可能会出现拖拽异常（元素拖不动），打开控制台会发现有报错
二、解决方案 给Draggable组件和其下方的div添加了key就正常了,以下是我自己简单写的一个demo，可供参考
import { useState } from 'react' import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd'; import './App.css' const mocklist = [ { label: 'item11', id:'aa', value: 'aa', color: 'red' }, { label: 'item22', value: 'bb', id:'bb', color: 'blue' }, { label: 'item33', value: 'cc', id:'cc', color: 'yellow' }, { label: 'item44', value: 'dd', id:'dd', color: 'pink' }, { label: 'item55', value: 'ee', id:'ee', color:'green' }, ] function App() { const [list,setList] =useState(mocklist); // 重新排序-更新列表 const reorder = (list, startIndex, endIndex) =&gt; { const result = [.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a2f1ebd0abe5a21cf003e7f7481c81a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f32af6e816d041fb045f6ecef029c927/" rel="bookmark">
			【深度学习】Pytorch基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		张量 运算与操作 加减乘除
pytorch中tensor运算逐元素进行，或者一一对应计算
常用操作
典型维度为N X C X H X W，N为图像张数，C为图像通道数，HW为图高宽。
sum()
一般，指定维度，且keepdim=True该维度上元素相加，长度变为1。升降维度
unsqueeze() 扩充维度 image = PIL.Image.open('lena.jpg').convert('RGB') transform = torchvision.tranforms.Compose([torchvision.transforms.ToTensor()]) img = transform(image) img = img.unsqueeze(0) sequeeze()将长度为1的维度抹除，数据不会减少。
将输入（图像）转换为张量，torchvision.transforms.ToTensor() class ToTensor: """Convert a ``PIL Image`` or ``numpy.ndarray`` to tensor. This transform does not support torchscript. tensor转换为cvMat 获得元素反归一化变换通道顺序 维度展开 # 除第1维，其他维展开 x = torch.flatten(x, 1) Variable view()方法
卷积输出N*C*H*W，输入全连接层，需要变形为N*size
torchvision import torchvision as tv # 查看网络的结构 features = tv.models.alexnet().features # 在dim=1上求和，第1维度压缩为1 torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f32af6e816d041fb045f6ecef029c927/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97563d2d81065746e659897a83a4418b/" rel="bookmark">
			基于“xxx” Androidx平台的驱动及系统开发 之 触摸板篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、基于全志 A133 Android10平台，适配1366x768 - ilitek2511触摸1、原理图分析2、驱动移植与适配3、补丁和资源文件 二、基于瑞芯微 RK3566 Android11平台，适配GT9XX触摸1、原理图分析2、补丁及资源文件 三、遇到的问题与解决1、基于amlogic Android9平台，使用（V-By-One接口LCD屏，USB接口触摸板）的一体式触摸屏2、基于RK3566 Android11平台，使用（LVDS接口LCD屏，I2C接口触摸板）的分离式触摸屏3、基于GT9XX触摸IC 触摸出现 -&gt; "点偏位" 或 "划线异常不连续"◕对该触摸驱动如何通过“CTP_CFG_GROUPx”这个配置组表更新到触摸IC寄存器内部的有些人可能是通过外部去对触摸进行矫正的，那么就需要把自动写入对应的配置信息组表功能给关了 4、在屏幕熄屏情况下做触摸唤醒屏幕功能，但是内核版本原因，无法使用原厂提供的手势识别功能 一、基于全志 A133 Android10平台，适配1366x768 - ilitek2511触摸 1、原理图分析 ilitek2511触摸使用的时I2C通信，因此重点关注SDA（数据）、SCK（时钟）、INT（中断）、RST（复位）这四个引脚即可。
2、驱动移植与适配 首先我们需要弄清除，触摸驱动是干嘛的，其实它只不过是通过I2C通信方式获取触摸板上触发的每个坐标点信息，通过事件方式上报，像这种通用的事件上报方式（触摸屏），上层的HAL、Framework等，原生Android或者原厂都是已经给做好了，已经只需要移植驱动层即可，一般别的层无需做修改的。
通过触摸IC厂商提供的驱动移植资料修改设备树，如下图原厂提供的设备树和我修改好的设备树。
设备树配置好后，直接将相关的驱动文件拷贝到 a\longan\kernel\linux-4.9\drivers\input\touchscreen 目录下创建的ilitek文件夹下即可，如下图所示。
通过以上操作，基本是已经将触摸驱动移植好了。
3、补丁和资源文件 下载链接
二、基于瑞芯微 RK3566 Android11平台，适配GT9XX触摸 1、原理图分析 2、补丁及资源文件 这里就不多分析了，直接给上补丁文件。
下载链接
三、遇到的问题与解决 1、基于amlogic Android9平台，使用（V-By-One接口LCD屏，USB接口触摸板）的一体式触摸屏 出现问题1：明明获取的USB设备，但是一直处于disconnected断开，一直打印不支持该USB设备，日志如下图所示
解决方法1：其实这个是控制板卡上的液晶屏的参数设置不对引起的，使得它们与触摸控制器不匹配，从而使触摸屏功能无法正常工作。因此只需要更具屏幕规格书修改屏幕参数即可。
2、基于RK3566 Android11平台，使用（LVDS接口LCD屏，I2C接口触摸板）的分离式触摸屏 出现问题1：因为触摸板和LCD屏是分离的，因此有可能出现整合者将触摸板和LCD屏摆放的起始方向不一致 或者 触摸板默认竖屏，而屏幕默认横屏， 这两种原因都会导致触摸和显示UI对不上。
解决方法1：在device/rockchip/3566x/目录下的build.prop文件中添加 persist.sys.touch.orientation=90， 如我设置90就是说将触摸板旋转方向为90度，这样就可以使UI和触摸板对上了。
3、基于GT9XX触摸IC 触摸出现 -&gt; “点偏位” 或 “划线异常不连续” 出现的问题1：在原厂提供的文档可以可知，一般每一种触摸IC都有对应的“CTP_CFG_GROUP”这个触摸配置组的，它作用就是优化矫正触摸的。
解决方法1：在drivers\input\touchscreen\gt9xxnew\gt9xx.h文件中将原厂提供的.cfg峰位文件内从内容替换对应CTP_CFG_GROUPx中的内容，如果不确定CTP_CFG_GROUPx是哪个，那可以选择最无脑的方法，将CTP_CFG_GROUP[1~n]中的内容都给替换掉即可。
◕对该触摸驱动如何通过“CTP_CFG_GROUPx”这个配置组表更新到触摸IC寄存器内部的 找到drivers\input\touchscreen\gt9xxnew\gt9xx.c这个文件，该文件是触摸主功能的驱动文件。
在goodix_ts_probe函数下找到如下图的函数调用：
通过该函数索引到函数实现的位置，这里我把源码贴出来，已注释方式解释了。
/******************************************************* Function: Initialize gtp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97563d2d81065746e659897a83a4418b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae854d5666af1ec41f586ec5d2899b9f/" rel="bookmark">
			Nacos基础（注册中心和配置中心）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考文章一、 配置管理1、添加依赖2、添加配置信息3、创建例子4、在Nacos创建配置命名空间：配置集配置id配置组加载多配置文件 二、注册中心2.1、添加依赖2.2、添加项目Nacos配置2.3、添加服务发现注解这个时候你启动Nacos 如果遇到跳转链接失效请在评论区留言
参考文章 个人笔记，不同意见，望有交流
直接可以点击跳转连接
作者 尚硅谷-
作者 Nacos官方网站
作者 阿里巴巴
文章默认Spring cloud环境搭建，默认你的Spring包已经引好
官方网站
前提安装启动Nacos 本次启动为单机版
启动命令为 startup.cmd -m standalone 开始吧 http://localhost:8848/nacos/
nacos/nacos登录名称/密码
一、 配置管理 阿里github文档
1、添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;version&gt;${latest.version}&lt;/version&gt; &lt;/dependency&gt; 注意：版本 2.1.x.RELEASE 对应的是 Spring Boot 2.1.x 版本。版本 2.0.x.RELEASE 对应的是 Spring Boot 2.0.x 版本，版本 1.5.x.RELEASE 对应的是 Spring Boot 1.5.x 版本。
2、添加配置信息 创建bootstrap.properties
添加最基础配置
spring.application.name= “你服务的名称” spring.cloud.nacos.config.server-addr= “你服务的地址” 类似127.0.0.1:8848 spring.cloud.nacos.config.namespace= 可以直接指向你命名空间里面 #不配置默认就走public命名空间中的对应的服务名称 NacosConfig主要通过dataId和group来唯一确定一条配置。
spring.application.name是构成 Nacos 配置管理 dataId字段的一部分。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae854d5666af1ec41f586ec5d2899b9f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f867917fef5cb01626034b38d27fa9af/" rel="bookmark">
			6.3 业务分析方法 (15%)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、业务分析方法 1、客户分析 用户从哪里来到哪里去；来源于各个渠道；
分析:
投入产出比：微博＞公众号
展示量：微博低于公众号；若增加品牌曝光率，可用公众号渠道
跳失率：微博低于公众号；用户注册兴趣高
注册用户成本;
从量的渠道上，微博优于公众号从质的渠道上，需更详细的。 2、行为效果分析 人——货——场
人——用户来源、活跃度、价值贡献
货——进销存、品类结构价格管理
场——线上（PC、群聊）、线下（综超、社区）
3、活动效果分析 4、日常销售分析 说明：在指定时间范围内，回顾日常经营性行为
二、业务分析模型 1、RFM模型 2、用户忠诚度模型 三、业务分析方法 1 树状结构分析 考虑从总体指标入手，逐层分解总体指标，形成下钻式树结构。
一般3-6层
树状结构分析：可以用到业绩评估等；
2、二八分析 80%的问题是20%的原因造成的。便于在项目管理中找出核心问题。
会结合帕累托图来呈现。
通过柱状图和折线图（0-100%）的结合来显示。
3、四象限分析 了解数据在两个核心要素下的表现，从而划分出具备不同特性的数据类型
四象限经典的模型——波士顿矩阵
销售增长率——市场对产品的需求力
市场占有率——产品在当前市场的占比如何
弱产品：即将放弃的产品
现金牛：市场趋于饱和，未来可能被淘汰；但当下占比很高
eg：多个渠道投放广告
核心指标：点击率、点击到用户注册成功的转化率
4、同期群分析 作用：衡量指定对象组在某一段时期内的持续性行为差异
同期群：相同时间内，具有相同特征属性的用户
同期群分析：量化行为指标，分析不同群体的该指标随时间的变化情况
【案列】
次日留存率——斜线 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86a2bd287516893f1fb19a1dd6ee58e4/" rel="bookmark">
			UE5 文字游戏（2） C&#43;&#43;实时读取CSV文件（游戏开始读取本地CSV剧本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.结构体代码 // Fill out your copyright notice in the Description page of Project Settings. #pragma once #include "CoreMinimal.h" #include "Engine/DataTable.h" #include "MyCharacterStats.generated.h" USTRUCT(BlueprintType) struct FMyCharacterStats : public FTableRowBase { GENERATED_BODY() UPROPERTY(EditAnywhere, BlueprintReadWrite) FString Name; UPROPERTY(EditAnywhere, BlueprintReadWrite) int32 Health; UPROPERTY(EditAnywhere, BlueprintReadWrite) int32 Attack; }; 2.写一个C++蓝图函数库
.h
// Fill out your copyright notice in the Description page of Project Settings. #pragma once #include "CoreMinimal.h" #include "Misc/Paths.h" #include "Serialization/Csv/CsvParser.h" #include "Misc/FileHelper.h" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86a2bd287516893f1fb19a1dd6ee58e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4c0ebb1959f0577a9df86dc3e19ce76/" rel="bookmark">
			c&#43;&#43;内存泄漏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 什么是内存泄漏？ 内存泄漏是当一个程序错误地管理内存分配的情况，在这种情况下，内存被分配给了程序，但在不再需要时没有被释放。这意味着内存不再可用，尽管它不再被使用。如果程序持续运行，泄漏会不断累积，最终可能耗尽系统的所有可用内存，导致性能下降甚至程序崩溃。
2. 泄露的是哪部分内存？ 泄露的内存通常是指程序员在堆上动态分配的内存没有被适当释放，导致程序失去了对这些内存块的引用，使得这些内存即使不再需要，也无法被操作系统回收。随着时间的推移，这些未释放的内存块会累积，造成内存泄漏。
在大多数现代操作系统和编程语言中，程序的内存分为几个不同的区域，常见的有以下几种：
1. 堆内存（Heap）：这是用于动态内存分配的区域，程序运行时可以从堆中分配任意大小的内存块。在C语言中，函数如`malloc()`、`calloc()`、`realloc()`和`free()`用于管理内存；在C++中，有`new`和`delete`操作符。内存泄漏经常发生在堆内存中，因为管理堆内存的责任在于程序员手上，他们必须显式地分配和释放内存。
2. 栈内存（Stack）：这是用于自动存储局部变量和函数调用信息的区域。当函数调用时，局部变量会被分配在栈上，当函数执行完毕后，这些变量会自动被清理。因此，栈内存通常不会发生内存泄漏，因为一旦函数返回，栈上的内存就会自动释放。
3. 全局/静态存储（Global/Static Storage）：这是用于存储全局变量和静态变量的内存区域。这些变量在程序启动时分配，在程序终止时释放。
4. 代码区（Code or Text Segment）：这是存储程序的机器指令代码的内存区域，只读。
3. 为什么会内存泄漏 内存泄漏存在多方面的因素，但大多数内存泄漏通常是因为程序错误或疏忽造成的，归纳总结后，存在以下几种（只是博主的理解，如果发现有缺失的部分，欢迎纠正）
1. 未释放分配的内存：在使用动态内存分配（如C/C++中的`malloc`/`new`）时，程序员有责任在不再需要分配的内存时释放它（使用`free`/`delete`）。如果程序员忘记释放内存，就会发生内存泄漏。
2. 丢失指针引用：如果覆盖了指向动态分配内存的唯一指针而没有先释放它，那么就无法再访问或释放这部分内存。
3. 程序逻辑错误：程序中的逻辑错误可能导致某些代码路径没有正确释放内存。
4. 循环引用：在使用自动内存管理（如垃圾收集）的编程环境中，两个对象可能相互引用，使得它们都无法释放，因为每个对象至少有一个活跃的引用。
5. 资源泄漏：资源泄漏（比如文件句柄、数据库连接）也可以导致内存泄漏，因为这些资源在打开时通常也会占用内存。
6. 外部库或系统的缺陷：程序员使用的外部库如果自身存在内存管理的问题，也可能导致内存泄漏。
4. 如何避免和减少内存泄露？
以下是博主常用的方式：
智能指针和资源获取即初始化（RAII）：使用智能指针（如`std::unique_ptr`,`std::shared_ptr
`等）可以帮助自动释放内存。RAII是一种在对象生命周期结束时自动释放资源的编程技术。
`std::shared_ptr在使用引用计数的智能指针时，要特别注意避免创建循环引用，它们可能导致内存泄露。如果必须使用，可以考虑`std::weak_ptr`来打破循环。
避免裸指针：尽量避免使用裸指针操作内存，改用上述的智能指针或者容器类。
内存管理工具：在开发过程中使用内存管理工具，如Valgrind等，定期检查内存泄露。
代码审查（工作中也可多方审查）：通过代码审查可以发现并修复可能导致内存泄露的问题。 使用池化和重用机制：对于频繁创建和销毁的对象，使用内存池可以减少内存碎片以及减少内存泄露的风险。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6f919bb69b2666d8333b0abde03381c/" rel="bookmark">
			Spring Cloud Alibaba一一SentinelResource
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SentinelResource 在定义了资源点之后，我们可以通过Dashboard控制台页面来设置限流和降级策略来对资源点进行保护。同时还能通过[**@SentinelResource**](/SentinelResource)****注解来制定出现异常时的处理策略
1、属性说明
value 资源名称、必须项、因为需要通过resource name找到对应的规则，这个是必须配置的。
blockHandler blockHandler对应处理BlockException的函数名称，可选项。blockHandler函数访问范围需要是public，返回的类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为BlockException。
fallback fallback函数名称，可选项，用于在抛出异常的时候提供fallback处理逻辑。fallBack函数可以针对所有类型的异常（Throwable）
blockHandlerClass blockHandler函数默认需要和原生方法在同一个类中，如果希望使用其他类的函数，则需要指定blockhandlerClass为对应的类的Class对象，注意对应的函数必须为static函数，否则无法解析。
fallbackClass fallBackClass的应用和blockHandlerClass类似，fallback函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定fallbackClass为对应的类的Class对象，注意对应的函数必须为static函数，否则无法解析。
2、自定义处理限流和业务异常
@GetMapping("/hello4") @SentinelResource(value ="hel1o4",blockHandler ="blockHandler",fallback ="fallbackHandler") public string hello4(Integer age){ int i = 10 / age; return "hello4"; } // hel13Handler方法的参数和返回值要和原方法一直，BlockException用来接收原方法的异常 public string blockHandler(Integer age,BlockException e){ return"资源被限流”; } //hel13Handler方法的参数和返回值要和原方法一直，Throwable用来接收原方法的异常(这里必须是Throwable用来接收原方法的异常，不能是exception) public string fallbackHandler(Integer age,Throwable e) { return"资源出现异常"; } 以上这种方式可以处理资源中的限流和业务异常了，但是发现异常处理类和业务代码耦合了，而且还没办法复用。
3、处理异常类和业务类解耦
@RestController @slf4j public class HelloController f @GetMapping("/hel1o4") @SentinelResource(value = "hello4", blockHandlerClass = MyBlockHandlerClass.class, blockHandler ="blockHandler", fallbackClass = FallbackHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6f919bb69b2666d8333b0abde03381c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a88f0c4786cfd4644e66ca2279a5dcd/" rel="bookmark">
			Spring Cloud Alibaba一一熔断降级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		熔断降级 一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方API等。例如，支付的时候，可能需要远程调用银联提供的API，查询摸个商品的价格，可能需要进行数据库查询，然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。
现代微服务架构都是分布式的，由于非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的若依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。
1、熔断策略
慢调用比例（平均响应时间）：选择以慢调用比例作为阈值，需要设置允许的慢调用RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。档单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测回复状态（HALF-OPEN状态），若接下来的一个请求响应时间小于设置的慢调用RT则结束熔断，若大于设置的慢调用RT则会再次被熔断。异常比例（ERROR_RATIO）：当单位统计时长（satIntervalMs）内请求数且大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是[0.0,1.0]，代表0%-100%。异常数（ERROR_COUNT）：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。 2、平均响应时间
平均响应时间超过5ms，后续的所有请求都会被熔断，熔断时间为5s，后续有一个请求响应时间小于5ms则结束熔断。
案例：定义一个接口休眠1s后返回内容，用Jemeter 3s内发送10个请求发现全部处理了，设置降级规则后发现只处理了部分请求，其他请求被熔断了。
3、异常比例
异常比例超过28%自动熔断，熔断时间为3s。
案例
int i = 0; @GetMapping("/hel1o1") public string hello1() ( 1++; //出现异常的概率为1/3 if (i % 3 == @){ throw new RuntimeException(); } return "hello1"; } 4、异常数
这里需要注意的是异常数量是按照封装来计算的，异常比例和平均响应时间都是秒级别的。
热点参数限流 热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的Top K数据，并对其访问进行限制。
比如：
商品ID为参数，统计一段时间内最常购买的商品ID并进行限制 用户ID为参数，针对一段时间内频繁访问的用户ID进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热电参数的资源调用生效。
1、定义接口
@GetMapping("/hel1o3") @SentinelResource("he11o3”) // 热点参数需要配置这个注解使用 public string hello3(string str1, string str2){ return "hello3 --&gt;"+str1+",--&gt;"+str2; } 2、设置限流规则
参数限流规则表示，hello3资源中第一个参数1s只能调用一次，超过阈值就限流。
3、限流后返回自定义兜底数据
@GetMapping("/hello3") @SentinelResource(value ="hello3",blockHandler ="hello3Handler") // 热点参数需要配需这个注解使用 public string hello3(string str1, string str2) { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a88f0c4786cfd4644e66ca2279a5dcd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/51/">«</a>
	<span class="pagination__item pagination__item--current">52/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/53/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>