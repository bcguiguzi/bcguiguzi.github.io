<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2173f3e5d5ed38383c9704a1f1f329/" rel="bookmark">
			语言循环结构小明摘苹果_木兰编程语言入门教程之五——数据结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程不求全面，各个方面点到即止。目标是尽快对木兰编程语言的功能有基本的了解。所有内容在此验证过。欢迎反馈/提交PR。
之前的章节：
一、浅介二、控制走向三、函数和类型四、模块 五、数据结构 5.1 列表 列表操作，包括计数、搜索、倒序、添加、排序，等等。
&gt; fruits = ['橙子', '苹果', '梨子', '香蕉', '猕猴桃', '苹果', '香蕉'] &gt; fruits.count('苹果') 2 &gt; fruits.count('柑橘') 0 &gt; fruits.index('香蕉') 3 &gt; fruits.index('香蕉', 4) 6 &gt; fruits.reverse() &gt; fruits [香蕉, 苹果, 猕猴桃, 香蕉, 梨子, 苹果, 橙子] &gt; fruits.append('葡萄') &gt; fruits [香蕉, 苹果, 猕猴桃, 香蕉, 梨子, 苹果, 橙子, 葡萄] &gt; fruits.sort() &gt; fruits [梨子, 橙子, 猕猴桃, 苹果, 苹果, 葡萄, 香蕉, 香蕉] &gt; fruits.pop() 香蕉 用列表实现队列，可以用collections.deque：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2173f3e5d5ed38383c9704a1f1f329/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6cf2d1c1898b7ec505ef618049f4bfc/" rel="bookmark">
			win10 串口驱动下载链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用于windows下的串口驱动安装：https://sciologness.com/download/47462/usb-serial-ch341a.html
盗版stlink仿真器不要升级固件，很有可能废掉。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0949730d0591e5d56ab4f37897d6c0b/" rel="bookmark">
			我的软件渲染器终于初步完成了～
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		记录一个大好事：在 2021年第一个月的上旬，我的软件着色器终于初具雏形了～
中间参考了 很多 资料
最初是 知乎上的系列教程
https://zhuanlan.zhihu.com/p/141210744
这个教程是基于 OpenGL ，右手坐标系实现的。是翻译的 github 上一个叫做 tinyrender 的 教程。结合原版食用效果更佳～
原版 github 上的图片都 看不到了，所以结合这篇知乎上的教程看，也很帮助人理解。
当时觉得比较困难的地方是 矩阵的推导，看这篇教程的时候完全没有去理解。后来觉得这样不行，翻出来在家里吃灰的两本书仔细参考：
第一本是&lt;&lt;3D数学基础：图形与游戏开发&gt;&gt; .这本书重点看了矩阵推导的部分。
由于一开始我看的教程是 基于 右手坐标系的 OpenGL 习惯的教程，而这本书所有地方全都是相反的，我去花时间掰顺了这方面的知识。在矩阵计算时候分为两套：
标准一：
左手坐标系 ， 列矩阵（column major), 行向量， 向量 乘 Matrix 时 向量在左侧， 对向量做矩阵变换的时候 NewVertex = SrcVertex x Matrix1 x Matarix2 …
标准二：
右手坐标系，行矩阵(列矩阵的转置）， 列向量， Matrix 乘 向量时 向量在右侧， 对向量做矩阵变换的时候 NewVertex = … x Matrix2 x Matrix1 x SrcVertex
上面值得一提的是 列矩阵，行矩阵。书里面的所有推导都是基于标准一的，所以那些结论中的 变换矩阵，在转换到 标准二的时候，都需要做转置！这些都是我亲自用笔来计算 得出的结论，如果不做转置那么结果整个就是错误的！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0949730d0591e5d56ab4f37897d6c0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a469e6c3f9d3fde254e08aa1337961/" rel="bookmark">
			python中特殊含义标识符_Python可以定义与关键字相同的标识符吗？Python关键字列举...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，具有特殊功能的标识符称为关键字。关键字是Python语言自己已经使用的了，不允许开发者自己定义和关键字相同名字的标识符。Python中的关键字如下所示：
False await else import pass None
break except in raise True class
finally is return and continue for
lambda try as def from nonlocal
while assert del global not with
async elif if or yield
Python中的关键字，每个都代表不同的含义。如果大家想查看关键字的信息，可以输入help()命令进入帮助系统查看。示例代码如下：
&gt;&gt;&gt; help() # 进入帮助系统
help&gt; keywords # 查看所有的关键字列表
help&gt; return # 查看return这个关键字的说明
help&gt; quit # 退出帮助系统
猜你喜欢：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/170fdb0ee2f675e9a185957183ab11cd/" rel="bookmark">
			此上下文中不支持函数定义。请在代码文件中创建函数_JavaScript代码是怎么执行的？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 众所周知，JavaScript是单线程语言。所以JavaScript是按顺序执行的！
先编译再执行 变量提升 请看下面的例子：
console.log(cat) catName("Chloe"); var cat = 'Chloe' function catName(name) { console.log("我的猫名叫 " + name); } 按照得出的结论："JavaScript是按顺序执行的"来看，步骤如下：
执行第一句的时候，cat并没有定义，结果应该是抛出一个错误，然后结束执行。 Uncaught ReferenceError: cat is not defined 但实际的执行结果并不是这样：
不仅可以执行，catName()执行结果也输出了。
这种现象就是： 变量提升
从概念的字面意义上说，“变量提升”就是把变量和函数的声明移动到代码的最前面，变量被提升后，会给变量设置默认值--undefined。
调整之后的执行顺序如下：
首先执行var cat = undefined和function catName(){}然后执行console.log(cat) // undefined接着调用catName()最后给cat赋值cat = 'Chloe' 移动一词容易造成误解。实际在物理层面上代码的位置并没有改变。JavaScript是解析执行的语言，在执行前会先经过编译阶段。造成这种现象的原因是：JavaScript引擎在编译阶段中将变量和函数的声明放在了内存中。
执行上下文 变量提升（Hoisting）被认为是， Javascript中执行上下文 （特别是创建和执行阶段）工作方式的一种认识 在编译阶段，JavaScript会为上述代码创建一个执行上下文和可执行代码。 执行上下文是JavaScript执行一段代码时的运行环境，包含this、变量、对象以及函数等。
1、在编译阶段
JavaScript引擎会将var变量声明和函数声明等的变量提升内容放在变量环境中。接下来JavaScript引擎会把声明以外的代码编译为字节码--可执行代码。 2、执行阶段
执行到console.log(cat)时，JavaScript引擎在变量环境中查找cat这个变量，由于变量环境存在cat变量，并且其值为undefined，所以这时候就输出undefined。当执行到catName函数时，引擎在变量环境中查找该函数，由于变量环境中存在该函数的引用，所以引擎执行该函数，并输出执行结果。执行cat赋值，引擎在变量环境查找到cat变量，并进行赋值。 创建执行上下文的三种情况：
1、全局执行上下文：JS引擎在编译全局代码时，创建全局执行上下文。在当前页面中，全局执行上下文仅有一个。
2、函数执行上下文：在调用一个函数时，JS引擎会创建一个函数执行上下文。一般情况下，当函数执行完毕后就会销毁此函数执行上下文。
3、eval函数执行上下文：执行eval函数时，也会创建一个执行上下文。
调用栈 JS引擎通过栈的数据结构来管理多个执行上下文。
栈是计算机科学中的一种抽象数据类型，只允许在有序的线性数据集合的一端（称为堆栈顶端，英语：top）进行加入数据（英语：push）和移除数据（英语：pop）的运算。因而按照后进先出（LIFO, Last In First Out）的原理运作 在一个执行上下文创建好后，JS引擎就会它压进栈中。管理执行上下文的栈结构就称为调用栈，或者执行上下文栈。
请看下面例子：
function foo() { var a = 0 console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/170fdb0ee2f675e9a185957183ab11cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d70dee6a09c8d91abde494a85175950c/" rel="bookmark">
			语言 router_Go语言之pprof的性能调优”燥起来“
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在计算机性能调试领域里，profiling 是指对应用程序的画像，画像就是应用程序使用 CPU 和内存的情况。 Go语言是一个对性能特别看重的语言，因此语言中自带了 profiling 的库，这篇文章就要讲解怎么在 golang 中做 profiling。
Go性能优化 Go语言项目中的性能优化主要有以下几个方面：
CPU profile：报告程序的 CPU 使用情况，按照一定频率去采集应用程序在 CPU 和寄存器上面的数据Memory Profile（Heap Profile）：报告程序的内存使用情况Block Profiling：报告 goroutines 不在运行状态的情况，可以用来分析和查找死锁等性能瓶颈Goroutine Profiling：报告 goroutines 的使用情况，有哪些 goroutine，它们的调用关系是怎样的 采集性能数据 Go语言内置了获取程序的运行数据的工具，包括以下两个标准库：
runtime/pprof：采集工具型应用运行数据进行分析net/http/pprof：采集服务型应用运行时数据进行分析 pprof开启后，每隔一段时间（10ms）就会收集下当前的堆栈信息，获取各个函数占用的CPU以及内存资源；最后通过对这些采样数据进行分析，形成一个性能分析报告。
注意，我们只应该在性能测试的时候才在代码中引入pprof。
工具型应用 如果你的应用程序是运行一段时间就结束退出类型。那么最好的办法是在应用退出的时候把 profiling 的报告保存到文件中，进行分析。对于这种情况，可以使用runtime/pprof库。 首先在代码中导入runtime/pprof工具：
import "runtime/pprof" CPU性能分析 开启CPU性能分析：
pprof.StartCPUProfile(w io.Writer) 停止CPU性能分析：
pprof.StopCPUProfile() 应用执行结束后，就会生成一个文件，保存了我们的 CPU profiling 数据。得到采样数据之后，使用go tool pprof工具进行CPU性能分析。
内存性能优化 记录程序的堆栈信息
pprof.WriteHeapProfile(w io.Writer) 得到采样数据之后，使用go tool pprof工具进行内存性能分析。
go tool pprof默认是使用-inuse_space进行统计，还可以使用-inuse-objects查看分配对象的数量。
服务型应用 如果你的应用程序是一直运行的，比如 web 应用，那么可以使用net/http/pprof库，它能够在提供 HTTP 服务进行分析。
如果使用了默认的http.DefaultServeMux（通常是代码直接使用 http.ListenAndServe(“0.0.0.0:8000”, nil)），只需要在你的web server端代码中按如下方式导入net/http/pprof
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d70dee6a09c8d91abde494a85175950c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d96a6ef82591f07bf599693c54ff827/" rel="bookmark">
			讲解如何在HTML中添加背景图片?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在HTML中，我们可以使用两种不同的方法在HTML网页上显示背景图片：
使用背景属性（HTML标签）
使用CSS内部样式表
提示：HTML 5不再支持标签的background属性，建议使用CSS在Html文档中添加背景图片。
使用背景属性
使用Background属性在Html文档中添加背景图片。按照以下步骤，我们可以轻松实现。
步骤1：我们在文本编辑器中键入HTML代码，或者用文本编辑器打开现有的HTML文件。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;奔月教程(runoon.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;使用Background属性添加背景图片&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 步骤2：将光标移动到HTML文档中的开始标签内，输入背景属性，如下所示：
&lt;body background=" "&gt; 步骤3：输入要添加的图片的路径，如果图片存储在与HTML文件同一目录中，请输入以下路径：
&lt;body background="image.jpg"&gt; 如果我们的图像存储在任何其他目录中，则输入该图像的正确路径。如下所示：
&lt;body background="/home/images/image.jpg"&gt; 如果我们的图片在互联网上，那么我们也可以使用URL添加图片，如下所示：
&lt;body background="https://www.runoon.com/img/background7.jpg"&gt; 如果图像小于页面，图像会进行重复。
步骤4：最后，在文本编辑器中保存HTML文件或HTML代码。
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;奔月教程(runoon.com)&lt;/title&gt; &lt;/head&gt; &lt;body background="/img/background7.jpg"&gt; &lt;h1&gt;使用Background属性添加背景图片&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5fcf0076b51114623ab342391369d72/" rel="bookmark">
			关于while...else和for...else看完不懵逼了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. while…else 记住三句话就可以了: 第一句：遇到while循环里有break，就绝对不会执行else语句里的代码块。 i = 1 while i &lt; 3: print (i, " 小于 5") i = i + 1 if i == 2: break else: print (i, " 大于或等于 5") # 遇到break不会执行else里的代码块 # 打印结果： 1 小于 5 第二句：while循环正常运行结束后，会执行else语句。 # 验证 while 正常循环时候，会执行else i = 1 while i &lt; 3: print(i, " while正常执行") i = i + 1 else: print(i, " else执行了") 执行结果：
1 while正常执行 2 while正常执行 3 else执行了 第三句：遇到continue，else也会执行。 i = 1 while i &lt; 3: print (i, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5fcf0076b51114623ab342391369d72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e6a4b006bd2931787e15f781f09f30a/" rel="bookmark">
			史上最详细最简单的冒泡排序，一学就会，一看就懂，一面试就懵！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么叫冒泡排序 依次比较两个相邻的子元素，如果他们的顺序错误就把他们交换过来，重复地进行此过程直到没有相邻元素需要交换，即完成整个冒泡。
现在设定一个数组，元素为 2,4,3,1 我们需要通过冒泡最终排序成1,2,3,4 用图来说明一下:
那首先我们就对第一个元素2和第2个元素4进行比较，如果第一个元素大于第2个元素则交换位置，否则不交换 于是我们编写代码如下
int[] arr = new int[] { 2, 4, 3, 1 }; if(arr[0]&gt;arr[1]){//第一个元素大于第2个元素则执行交换，否则不做操作 int temp = arr[1]; arr[1] = arr[0]; arr[0] = temp; } 执行后发现不需要交换，于是得到顺序如下
再来处理第2个元素和第3个元素： 于是我们代码编写如下：
int[] arr = new int[] { 2, 4, 3, 1 }; if(arr[0]&gt;arr[1]){ int temp = arr[1]; arr[1] = arr[0]; arr[0] = temp; } if(arr[1]&gt;arr[2]){ int temp = arr[2]; arr[2] = arr[1]; arr[1] = temp; } 执行后发现，4大于3 需要交换位置，交换完后顺序如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e6a4b006bd2931787e15f781f09f30a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d696b84b5f91921214bd50ea9bf88ae/" rel="bookmark">
			模型的自相关系数计算_（CFA详解）自回归模型中的常见错误：以估计英特尔毛利润率为例...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果时间序列是协方差平稳的并且误差是不相关的，我们可以使用普通最小二乘法来估计自回归模型。但是，当自变量包含因变量的过去值时，我们先前的序列相关检验Durbin–Watson检验得出的结果是无效的。
因此，对于大多数时间序列模型，我们不能使用Durbin–Watson统计量。但是，我们可以使用其他检验来确定时间序列模型中的错误是否序列相关。该检验是残差自相关和残差自相标准误的t检验。为了进行系统的讲解，我们接下来将先讨论自相关，然后再讨论残差自相关。
时间序列的自相关是该序列的值与其自身过去值之间存在相关性，其中k代表滞后的周期数。当k= 1时，自相关显示该变量在一个周期内与其在前一周期存在相关性。例如，第k阶自相关(ρk)为
其中E代表期望值。注意，当k= 0时，等式为Cov(xt，xt-k)。这意味着ρk的绝对值小于或等于1。
当然，我们无法直接观察自相关系数ρk，因此我们需要对ρk进行估计。我们用其估计值x替换xt的期望值x，以计算自相关系数。时间序列xt的k阶估计自相关(^ρk)为
与时间序列的自相关定义类似，我们可以将时间序列模型的残差自相关系数定义为
我们假设时间序列模型中残差期望值为0。
通过检验残差的自相关是否与0显著不同，可以确定我们是否使用了正确的时间序列模型。如果检验结果为真，则不能正确指定该模型。我们使用残差的样本自相关及其样本方差来估计误差自相关。
滞后的残差自相关系数等于0的原假设是基于该滞后的残差自相关和残差相关的标准误，该标准误等于1/√T，其中T是观测值的数量。如果我们在一个时间序列中有100个观测值，则每个估计的自相关的标准误为0.1。通过将滞后的残差自相关系数除以其标准误1/√T，我们可以进行残差自相关系数等于0的原假设的t检验。
我们如何利用误差自相关的信息来确定是否正确指定了自回归时间序列模型？我们可以使用简单的三步法。首先，估计一个特定的自回归模型，例如AR(1)模型。其次，计算残差的自相关。第三，检验以查看残差自相关是否与0不同。如果显著性检验显示残差自相关与0显著不同，则模型未被正确指定，我们可能需要对其进行修改。
现在，我们提供一个案例来演示此三步方法的工作原理。
案例 预测英特尔公司的毛利润率
分析师决定使用时间序列模型来预测英特尔公司的毛利润率[(销售额-销售成本)/销售额]，使用1999年第二季度到2013年第四季度的季度数据。但是，分析师并不知道预测毛利率的最佳模型是什么，但姑且认为当前期间的值与前一个时期的值相关。下面，我们开始构造一个一阶自回归模型,AR(1): 毛利润率t=b0 + b1 (毛利润率t-1)+εt。下表显示了AR(1)模型的结果，以及模型残差的自相关性。
在回归方程中，截距(^b0=0.1795)和毛利率的滞后系数(^b1=0.7449)都非常显著。截距的t统计量约为2.8，而毛利率的滞后系数的t统计量大于8。
该模型具有59个观测值和两个参数，57个自由度。在0.05显著性水平下，t统计量的临界值约为2.0。因此，我们必须拒绝截距等于0(b0= 0)且滞后系数等于0(b1=0)的原假设。但是这些统计数据有效吗？尽管上图中显示了Durbin–Watson统计信息，但当自变量包括因变量的过去值时，不能将其用于检验序列相关性。正确的方法是检验该模型的残差是否是序列相关的。
在上表的底部，显示了残差的前四个自相关系数以及每个自相关的标准误和t统计量。样本具有59个观测值，因此每个自相关的标准误为1/√59= 0.1302。前四个自相关中没有一个t统计量的绝对值大于1.1137。
因此，我们可以得出以下结论：这些自相关均不与0显著不同。因此，我们可以假设残差没有序列相关，并且模型已正确指定，并且可以有效地使用普通最小二乘法来估计参数。
接下来，将如何使用它来预测下一个时期的英特尔毛利率呢？估计的方程为毛利润率t=0.1795 + 0.7449(毛利润率t-1)+εt。在任何期间，残差的期望值为0。因此，该模型预测，在t+1期间的毛利率将为毛利润率t+1= 0.1795 +0.7449(毛利润率)。例如，如果本季度的毛利润率为65％(0.65)，该模型预测下一个季度的毛利润率将增加到0.1795+ 0.7449(0.65)=0.6637或66.37％。另一方面，如果当前的毛利润率为75％(0.75)，则该模型预测，在下一季度，毛利润率将降至0.1795+ 0.7449(0.75)=0.7382或73.82％。
本文由“边际实验室”原创，如需转载请务必注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eff414bb2ecad0988b9521408f029277/" rel="bookmark">
			微信小程序使用scroll-view自定义下拉刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言： 很多朋友在进行小程序开发时，需要做下拉刷新功能，大部分人是直接使用系统的下拉刷新功能的。
在 .json文件中设置 { "enablePullDownRefresh": true } 使用onPullDownRefresh()监听用户下拉操作，实现刷新操作；
也可以通过wx.startPullDownRefresh和wx.stopPullDownRefresh触发和关闭页面下拉刷新； 一般人使用该方法就可以做出下拉刷新的效果，但是这个方法也有其缺点：
没有办法自定义动画效果。该下拉刷新只能出现在最顶部，例如：
当下拉刷新需要在全部、待付款、待发货、待收货这几个tab下面时，系统的下拉刷新就无法满足需要，我们就需要使用scroll-view来自定义下拉刷新。 用scroll-view内refresher-enabled属性开启自定义刷新 属性类型默认值必填开启自定义下拉刷新最低版本refresher-enabledbooleanfalse否开启自定义下拉刷新2.10.1refresher-thresholdnumber45否设置自定义下拉刷新阈值2.10.1refresher-default-stylestring“black”否设置自定义下拉刷新默认样式，支持设置 black 、 white 、 none， none 表示不使用默认样式2.10.1refresher-backgroundstring“#FFF”否设置自定义下拉刷新区域背景颜色2.10.1refresher-triggeredbooleanfalse否设置当前下拉刷新状态，true 表示下拉刷新已经被触发，false 表示下拉刷新未被触发2.10.1bindrefresherpullingeventhandle否自定义下拉刷新控件被下拉2.10.1bindrefresherrefresheventhandle否自定义下拉刷新被触发2.10.1bindrefresherrestoreeventhandle否自定义下拉刷新被复位2.10.1bindrefresheraborteventhandle否自定义下拉刷新被中止2.10.1 实现下拉刷新方法 wxml设置：
&lt;scroll-view scroll-y style="width: 100%;height:100%;" refresher-enabled="{{true}}" refresher-threshold="{{100}}" refresher-default-style="black" refresher-background="white" refresher-triggered="{{triggered}}" bindrefresherrefresh="onScrollRefresh"&gt; &lt;/scroll-view&gt; refresher-enabled设置为true表示启用自定义下拉刷新，refresher-threshold为100表示下拉刷新的下拉高度为100, refresher-default-style选black，这个样式是默认的，和系统的也一致，refresher-background背景颜色选白色，refresher-triggered表示下拉刷新状态，onScrollRefresh是下拉刷新事件。
Js设置：
/** * 页面的初始数据 */ data: { triggered: false, }, //用户下拉动作 onScrollRefresh: function () { var that=this; setTimeout(function(){ that.setData({ triggered: false, }) },2000); }, 当下拉时triggered会自动变为true，2000毫秒后手动将triggered变为false下拉刷新就会弹回去。
最后效果：
这样就可以做出简易的自定义下拉刷新了，朋友们可以自己尝试一下自定义下拉刷新，尝试更多功能。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db9d2ed835cea3b822972f5ebf9362e/" rel="bookmark">
			html内容被背景图片遮住怎么办_div被iframe遮住的几种情况及解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		类似结构：
复制代码代码如下:
http://caibaojian.com"&gt;&gt; 第一种：透明背景被遮住
当div使用透明的背景时，无论是使用(opacity或者rgba格式)，除了chrome，其它浏览器都出现div被iframe遮住的情况。
解决方法：
div使用不透明背景或者使用透明的背景图片。
第二种：ie8中z-index失效
在ie中，iframe里引入video视频播放会导致div的z-index无效，即div的z-index无论设为多少，均被iframe遮住。来源
解决方法：
给iframe地址加一个参数wmode=opaque，假如地址是：http://caibaojian.com 则对应改为：http://caibaojian.com?wmode=opaque。
flash在其他元素后面
另外顺便看到flash也有这个z-index失效的问题，同样是给flash加一个上面的参数
复制代码代码如下:
或者
复制代码代码如下:
https://cdn.css-tricks.com/FlashAnimation.swf" type="application/x-shockwave-flash" wMode="Transparent"&gt;
附录iframe的一些参数
border
复制代码代码如下:
设定围绕图文框的边缘宽度
frameboder
复制代码代码如下:
设置边框是不否为3维(0=否，1=是)
height,width
复制代码代码如下:
设质边框的宽度和高度
scrolling
复制代码代码如下:
是否有滚动条(yes,no,auto)
src
复制代码代码如下:
指定iframe调用的文件或图片(html,htm,gif,jpeg,jpg,png,txt,*.*)
总结
以上就是这篇文章的全部内容，希望对大家的学习或者工作带来一定的帮助，如果有问题大家可以留言交流。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09e328f00b4b14db3e9cd20211d9fb33/" rel="bookmark">
			笔记本连接显示器后没有声音_外接显示器后没声音怎么回事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		外接显示器后没声音怎么回事
外接显示器后没声音的解决方法：
1.
调整显示器的输入模式和笔记本的输出模式。
用
hdmi
线连上显示器以后，需要吧显示器调成
hdmi
输入模
式
(hdmi input mode)
，通常显示器都会有快捷的按钮切换输入模
式的。
然后笔记本按
fn
键
+f5(
我的笔记本是
f5
，有些可能是
f2
或
者
f4)
，
可以切换输出模式，
如果你只希望外接显示器显示，
那就
选
hdmi
那个。如果是两个屏幕都显示就选笔记本
+hdmi
。
2.
关闭
hdmi
声音输入
打开显示器的菜单
(menu)
，
通常会有声音的选项，
选关闭
hdmi
音频输入。因为我的显示器带音箱，所以放视频会有声音，但是
开音乐播放器会没有声音。这是因为视频播放是笔记本显卡通过
hdmi
连接，有音频输入，而音乐播放器通过声卡来播放。
3.
设置默认扬声器
因为关闭了
hdmi
的音频输入，
所以即使显示器即使带音箱也
没声音了。我们需要设置由笔记本的声卡来播放声音。打开控制
面板，开启
realtek
高清晰音频管理器，设为默认设备。这样音
频就可以从声卡输出了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efb486e399a95261c676a553b4b9f648/" rel="bookmark">
			新手坐高铁怎么找车厢_坐高铁时如何快速找到自己车票上的车厢和座位! 说出来你都不敢相信...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在我国大力在发展高铁行业。慢慢的以前的绿皮火车由于速度缓慢，乘坐环境较差就被高铁所挤下去了，人们越来越愿意乘坐高铁出行。毕竟高铁速度上是火车的数倍，而且环境也非常好。但是大家坐高铁什么的时候是不是都遇到过一个很棘手的问题？就是要找到自己的车厢和座位号往往是一件很头疼的事。如何快速的找到车票上的车厢座位号呢？下面我们就来简单说一说。
首先我们进站的时候，第一个要找的是自己的车厢所在位置。当我们进站来到了铁路沿线时。要多留心车站上面的标注和地下的指示线。往往这些标志上面都会写了相应的车厢位置，凭借这个你就会很容易的找到了自己的车厢了。当然，大家还要留心的是一般一个停靠点会有两种颜色的车厢号标识。
不过不用担心，因为这个时候会有广播提醒你，你所坐的列车是属于哪个颜色对应的车厢号。这个时候一定要留心倾听。还有提醒一下大家，就算你走错了车厢也没有太大关系，但是你一定要上车。因为如果你不上车你就错过了这个班次的车，就只能再重新买票了。
如果你只是上错了车厢那没有关系，你可以向列车员询问自己所在的车厢具体位置，然后在车子上慢慢的找到你所对应的车厢。这样你还能找到你的座位，还能安静稳定的到达目的地。
另外一点就是自己的座位号了，这一点很比较方便，不会像车厢那么容易让人混淆。座位号一般是由数字和字母搭配而成。只要你找对了相应的车厢号进入车厢之后，这些座位号码都会在每一排的座位上面显示。而且一般字都会写得很大，都能看得很清楚。这时候你只需要找和你车票上对应的数字和字母一样的就可以了。因为只有数字和字母，所以对于一些不识字的朋友们找起来也不是很麻烦。
随着高铁技术的日新月异地发展。我们出行时已再也不必再像以前一样背着一个大包四处奔跑去寻找车厢了。现在的我们只需要提前来到车站，在相应的地标线上找到自己对应的车厢号，安静等待车子来到就好了。上车后，所有的座位号也都给你标得清清楚楚，凭借车票上的信息找到对应的座位号。
然后来到座位上把座椅调宽，安静舒适的躺下小睡一会儿，不过多久列车就会到达你所需要到的目的地啦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2a0be97822e7049d81c30f3705b6258/" rel="bookmark">
			是什么调性_调、调式、调性、离调、转调、调关系都是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、调、调式、调性
说起调、调式、调性这几个概念，很多人一脸困惑，到底啥意思呢？这三个概念怎么区别呢？
(一)调
我们知道，钢琴有88个键，每个键都发出一个固定音高的乐音，我们把这88个键发生的88个乐音组成的体系，叫乐音体系。注意，这是指物理意义的、纯静态的固定频率声波振动的乐音音高概念。
调有两种含义，一种与乐音体系有关，特指一组音的音高位置，例如C调，就是指由基本音级CDEFGAB所组成的音高位置就叫C调。另外一种含义指调式主音的音高位置即调高。例如C自然大调，就是指这个自然大调的主音音高在C这个音级上。
(二)调式
如果你在键盘上乱弹一气，会感到音响杂乱无章，全然没有所谓的优美动听的音乐从指尖流淌而出的感觉。但是如果你如果只弹钢琴的黑键，那声音感觉立刻就变了，一股中国风的音响扑面而来，这又是怎么回事呢？
原因就在于如果你只弹黑键，你就构造出了一个五声音阶的音响世界。五声音阶属于调式范畴。
那什么是调式呢，所谓调式就是指一个有主音的音群，一般不超过七个音，按照一定的音程关系及稳定与不稳定的关系所组成的一个体系。乐音体系里的乐音音级与调式体系里调式音级区别是非常大的，乐音音级仅指物理音响高度，是静态的独立的音高。而调式内的各音级都是相互关联的，每个音之间都有指向性，例如导音强烈的指向主音。调式内各音级的音程关系是固定的，如自然大调时的导音和主音关系是小二度或者大七度的关系，这个音程关系是固定的。
调式有很多体系和类型，影响比较大的有三种调式体系：即中古调式体系、五声性调式体系、大小调式体系。中古调式体系主要使用在巴洛克音乐以前的音乐作品中。五声性调式主要使用在东亚一些国家的民族音乐中。大小调式体系主要使用在欧洲古典音乐当中。大小调体系是使用最广泛的调式体系。
每一种调式体系下又有很多调式类型，例如大小调体系中有自然大调、和声大调、旋律大调、自然小调、和声小调、旋律小调等。
除了这些常用的调式体系外，还有一些特殊的个性化的调式类型，例如全音调式、布鲁斯调式、巴托克调式等等。
(三)调性
那什么是调性呢？刚才我们知道了调式这个概念，调式指的是一个体系，一组音的相对关系，是一个抽象的音组体系。这个音组体系必须建立在某一个确定的高度上，调式才有意义。一个调式中只要主音的音高确定之后，其余各音的音高也就确定下来了，所以调性指的就是调式主音音高加上调式类别就是调性这个概念的含义。所谓调性其实就是调式类别建立在特定音高上所体现出来的音响特性。我们经常听到这样的标题G大调弦乐小夜曲、#c小调即兴幻想曲，这些标题就是告诉你这些曲子的调性色彩。而这个调性音响色彩是作曲家所钟爱的所喜欢的，如果把这样的乐曲转调演奏，作曲家是非常不高兴的，因为这就改变了乐曲的调性色彩了，音乐的音响色彩感觉就会发生质的变化。
二、离调、转调
所谓离调，顾名思义就是离开调性，谁离开调性，一般是指某1个或2个和弦离开调性，离开什么调性，离开主调性，这一两个和弦离开主调性暂时到了副调性，而副调性的主和弦又是主调性的调内自然音和弦，所以，离调的侧重点在和弦及和声进行上，调性变换的因素体现在和弦身上。
所谓转调，顾名思义就是转换调性，谁转换调性，是乐思转换调性陈述，一段或一句乐思原本在C大调上陈述，到了第二段或第二句转换到另外一个调性上例如G大调上去陈述。转调的侧重点在调性色彩的转换上。
例如下面的谱例一，三四小节交界处的两个和弦是C大调V43/VI-VI和声进行，这是一个典型的离调，其侧重点在于V43/VI这个和弦身上，这个和弦显示出了a小调的调性因素，配合后面的a小调的主和弦显示出a小调的正格进行和声语汇，但a小调的主和弦又是主调性C大调的调内VI级和弦，这个进行依然在C大调的整体调性范畴内来陈述，所以这个地方是离调，而非转调。再看五至八小节，乐思逐渐地从C大调转换到G大调去陈述，并且在G大调上用全终止式完满收束。这个侧重点就不是和弦而是乐思的整体调性转换陈述。
谱例一
三、调的关系
调之间的关系，一般有以下三种情况：
1.相同音列关系 就是音列相同，主音不同，例如关系大小调或平行调关系。
2.相同主音关系 就是主音相同，调式类型不同，例如同主音大小调。
3.主和弦之间的关系以及相同因素(共同和弦)的多少所分的远近关系
这是斯波索宾《和声学教程》中所提出的调性关系分类观点，它按照这个标准把调性的远近关系分成了以下四种： (1)近关系调、一级关系调
这种调关系相差一个升降号，以自然音体系为基础。
(2)次近关系调、二级关系调 这种调关系相差二个升降号，有两个共同和弦。
(3)远关系调、三级关系调 这种调关系在和声调式上有一个共同和弦。
(4)最远关系调、四级关系调 这种调关系在自然调式和和声调式中都没有共同和弦。
四、总结
调有两种含义，第一种含义指一组音的音高位置。另外一种含义指调式主音的音高位置即调高。
调式是指一个有主音的音群，一般不超过七个音，按照一定的音程关系及稳定与不稳定的关系所组成的一个体系。
调性指的就是调式主音音高加上调式类别，也就是调式类别建立在特定音高上所体现出来的音响特性。
离调是指一两个和弦离开主调性暂时到了副调性，离调的侧重点在和弦及和声进行上，调性变换的因素体现在和弦身上。
转调就是乐思转调调性陈述，转调的侧重点在调性色彩的转换上。
调之间的关系，一般有相同音列关系的关系调或平行调关系、相同主音关系的同主音大小调关系和按相同因素(共同和弦多少)来分的远近关系这三种调关系。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbcb6101f292b9e0af4b5a9b0ef60ce4/" rel="bookmark">
			python 天天向上续以七天为周期_python3的一些实例（3.1-3.8）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python语言程序设计基础(嵩天版)，第三章程序练习题
3.3写出来有疑问，就先不贴出来了
#3.1重量计算，月球上物体的体重是在地球上的16.5%,
#假如你在地球上每年增长0.5kg，编写程序输出未来十年你在地球和月球上的体重状况。
import math
myweight=eval(input("请输入当前体重："))
weightgrowth = 0.5
for i in range(10):
myweight=myweight+0.5
myweightmoon=0.165*myweight
print("1.在地球上的体重增长至:{:.2f}\n2.在月球上的体重增长至:{:.2f}".format(myweight,myweightmoon))
#3.2
"""天天向上续，尽管每天都坚持，但人的能力发展并不是无限的，
他符合特定模型，假设能力增长符合如下带有平台期的模型：以七天为周期
连续学习3天能力值不变，从第四天开始至第七天每天能力增长为前一天的1%
如果七天中有一天间断学习，则周期从头计算。当初始能力值为1时，
连续学习365天后的能力值是多少？
"""
import math
s=1.0
for i in range(1,366):
if i%7 in [4,5,6,0]:
s=s*1.01
print("连续学习365天后的能力值为：{:.2f}".format(s))
#3.4回文数判断
n=input("请输入一个5位数字")
if n == n[::-1]:#a[::-1]相当于 a[-1:-len(a)-1:-1]，也就是从最后一个元素到第一个元素复制一遍。所以你看到一个倒序的东东。
print("{}是回文数".format(n))
else:
print("{}不是回文数".format(n))
#3.5田字格的绘制
for i in range(11):
if i in (0,5,10):
print("+----------+----------+")
else:
print("| | |")
#3.6
import time
scale=5
print("starting",end='')#print()会自动换行，end属性默认为换行符\n，此时将end属性改为‘’，就不会自动换行了。
for i in range(scale+1):
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbcb6101f292b9e0af4b5a9b0ef60ce4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d5e9a57a2f150b4fdfd05d484ce9806/" rel="bookmark">
			51单片机冒泡排序_采用冒泡法编写51单片机排序程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		试设计一个子程序，其功能为将(R0)指出的内部RAM中6个单字节正整数按从小到大的次序重新排列。
悬赏分：10 - 解决时间：2010-5-7 22:59
;========================================
最佳答案：
下列程序使用冒泡法排序，经过KEIL仿真测试通过。
ORG 0000H
;------------------------下面先准备6个数字
MOV 40H, #8AH
MOV 41H, #3BH
MOV 42H, #0B9H
MOV 43H, #47H
MOV 44H, #29H
MOV 45H, #0AFH
CALL SORT6 ;调用排序子程序
SJMP $ ;停止，此时可以观察排序结果
;-------------------------------------
SORT6: ;排序子程序
MOV R6, #5 ;6个数字，比较5次
S1:
MOV R0, #40H ;起始地址
MOV B, R6
MOV R7, B
CLR PSW.5 ;交换标志清零
S2:
MOV B, @R0 ;取出前一个数
INC R0
MOV A, @R0 ;取出后一个数
CJNE A, B, S3 ;后－前
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d5e9a57a2f150b4fdfd05d484ce9806/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94c5f59fc25bddb4e6fcd02b3066958a/" rel="bookmark">
			Linux Graphics 周刊（第 9 期）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很抱歉！Linux Graphics 周刊可能要烂尾了！正所谓鱼和熊掌不可兼得，写周刊的时间也占据了我个人学习精进的时间，后期将还是回归到以 DRM 博客为主的文章发表。如果你对 Linux Graphics 周刊感兴趣，可以给我私信或留言，共同参与到 Linux Graphics 周刊的撰写中来，为我分担一份力，也帮助自己拓展技术视野。
导读
dma-buf: 添加 sysfs 统计节点fbdev: UDLFB 驱动将被移除drm/vkms: Add setup and testing informationZink: 添加 Tessellation Shader 的支持微软向 Mesa 添加 SPIR-V to DXIL 的转换库，用于支持 WebGPUMesa-21 将开始支持 Direct3D-12 ，仅限于 WSL 环境Lavapipe：新增 VK_EXT_transform_feedback 扩展支持Mesa 21.0 删除了 Classic OSMesa树莓派：V3DV Vulkan 驱动已支持 Wayland 窗口系统树莓派：Mesa 21.0 优化 OpenGL 驱动的 Blit 操作XWayland 21.1 将从 X.Org Server 中剥离出来Wayland 1.19 即将发布Weston 新增 YUV 测试 demoCollabora: A Wayland driver for WineKhronos：Vulkan SDK、Tools 和 Drivers 已添加对光线追踪的支持RenderDoc 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94c5f59fc25bddb4e6fcd02b3066958a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9fff979eb677a82b6bf5825de0991ac/" rel="bookmark">
			无法加载模块:public_UE4插件与模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模块需要依赖项目 一般是引用项目做上层逻辑
插件独立与项目 并不依赖于项目 一般用作单独的功能 逻辑 每一个插件里最少有一个模块
"Modules": [ //模块依赖 每一个插件内最少有一个模块
{
"Name": "Task", //模块名字 "Type": "Developer", // 模块类型
"LoadingPhase": "Default" //加载阶段
}
Type :: ↓
/** * Environment that can load a module. */ namespace EHostType { enum Type { Runtime, //任何情况下都会加载 RuntimeNoCommandlet, //任何情况都会加载 但是不会加载命令 RuntimeAndProgram, //任何情况都会加载 小程序 CookedOnly, // Developer, // 开发模式使用 打包不会调用 Editor, // 编辑器启动时加载 EditorNoCommandlet, //不加载命令 Program,	//!&lt; Program-only plugin type ServerOnly, ClientOnly, // NOTE: If you add a new value, make sure to update the ToString() method below!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9fff979eb677a82b6bf5825de0991ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0481675d00a81c597b6d8106f32b20d0/" rel="bookmark">
			函数式编程初窥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 分享几个比较好的总结归纳 什么是函数式编程思维?函数式编程初探什么是函数式编程思维？ - 用心阁的回答 - 知乎 还有一个关于函数式编程的地位的：反对函数式编程的政治正确 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/344/">«</a>
	<span class="pagination__item pagination__item--current">345/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/346/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>