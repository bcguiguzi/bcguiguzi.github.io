<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b62f34979660483065b52b3728f41c7d/" rel="bookmark">
			ArcGIS Engine基础（29）之加载arcgis server切片地图服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法(ArcGIS 地图服务）：
直接调用arcgis server rest服务地址。
以IMapServerRESTLayer接口直接调用arcgis server rest服务，rest形式的切片服务一样可以加载。但如果是通过矢量范围面先进行切片后发布成地图服务，然后把影像切片缓存拷贝到该矢量地图服务的缓存下时，使用该方式无法读取到切片缓存图层，只能获取到矢量范围面图层。
IMapServerRESTLayer pRestLayer = new MapServerRESTLayerClass(); pRestLayer.Connect("http://localhost:6080/arcgis/rest/services/JX2021Y04IMG/MapServer"); ILayer pLayer = pRestLayer as ILayer; 第二种方法(wmts服务）：
以OGC的wmts标准方式进行加载。
格式url示例：http://localhost:6080/arcgis/rest/services/JX2021Y02IMG/MapServer/WMTS/1.0.0/WMTSCapabilities.xml
private ILayer OpenWMTS(string pURL) { ILayer layer = null; ESRI.ArcGIS.esriSystem.IPropertySet pPropertyset = new ESRI.ArcGIS.esriSystem.PropertySetClass(); pPropertyset.SetProperty("url", pURL); IWMTSConnectionFactory pWMTSFac = new WMTSConnectionFactoryClass(); IWMTSConnection pWMTS = pWMTSFac.Open(pPropertyset, 0, null); IWMTSConnectionName pWmtsConnectionName = pWMTS.FullName as IWMTSConnectionName; //下面的也可以 //IWMSConnectionName pWmsConnectionName = new WMSConnectionNameClass(); //pWmsConnectionName.ConnectionProperties = pPropertyset; ILayerFactory pLayerFactory = new WMTSLayerFactoryClass(); if (pLayerFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b62f34979660483065b52b3728f41c7d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52da5378fc8e834f0f811dcdeef57c6/" rel="bookmark">
			Linux——【ftp环境搭建】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 FTP（File Transfer Protocol）是文件传输协议，主要是用来进行文件的传输，尤其是大型文件的传输使用 FTP 更是方便。比如在RedHat Enterprise Linux操作系统中，用户可以在RHEL服务器上建立一个FTP服务器，然后就可以通过网络从服务器上传下载文件。
一：搭建FTP服务 服务器端（server) 将服务器端的网卡设置为VMnet1模式，并查看服务器端虚拟机的IP地址：
1.设置YUM YUM（yellowdog updater modified）是一个基于RPM却胜于RPM的管理工具，用户使用YUM可以更轻松的管理REHL系统中的软件——可以使用YUM来安装或卸载软件，也可以利用YUM来更新系统或者是利用YUM源来搜索一个未安装的软件。
创建挂载目录：
[root@server dly]# mkdir /dvd 挂载目录：
[root@server dly]# mount /dev/sr0 /dvd 配置yum文件：
当使用某一个YUM下载源是，必须先设置好YUM，YUM的配置文件可以分为：YUM工具的配置文件和YUM下载源的自定义文件。其中YUM工具的配置文件为 /etc/yum.conf ，而YUM下载源定义文件存储在/etc/yum.repos.d/ 目录中，并且文件必须以.repo作为扩展名。
[root@server dly]# vim /etc/yum.repos.d/dvd.repo YUM下载源案例：
进入编辑页面写入如下命令，注意文件路径一定不要写错，否则ftp安装包无法下载！
YUM的配置参数：
参数说明name用于定义YUM源的完整名称baseurl指定YUM源的urlenable是否启用YUM源gpgcheck安装这个YUM源终端软件包前是否检查RPM软件包的数字签名gpgkey软件包数字签名的密钥mirrorlist定义映像（mirror）站点列表 有关yum命令在文末稍做补充
2.安装ftp并完成vsftpd服务器的配置文件的修改： 完成YUM配置，就可以通过yum来安装ftp软件啦，yum install 软件对软件进行安装时，YUM会自动检查该软件包的依赖性，这时如果想要安装该软件以及相应的多有软件包，可以在该命令后面加入参数 -y，即：yum install 软件 -y
[root@server dly]# yum install vsftpd.x86_64 -y 重启ftp服务并设置开机自启：
[root@server dly]# systemctl restart vsftpd [root@server dly]# systemctl enable vsftpd 检查ftp的状态：
[root@server dly]# systemctl status vsftpd 关闭防火墙自启：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52da5378fc8e834f0f811dcdeef57c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1886cdd22c66e2bdf0a542dd58720d68/" rel="bookmark">
			TCP三次握手四次挥手简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 TCP三次握手四次挥手简介 图解三次握手、四次挥手 建立连接：三次握手 关闭连接：四次挥手 上图传递过程中出现的几个字符（SYN,ACK,FIN,seq,ack）各代表什么意思
SYN，ACK，FIN存放在TCP的标志位(标志位一共有6个字符，这里就介绍这三个)：
SYN： 代表请求创建连接，所以在三次握手中前两次要SYN=1，表示这两次用于建立连接，至于第三次什么用，在疑问三里解答。
FIN： 表示请求关闭连接，在四次分手时，我们发现FIN发了两遍。这是因为TCP的连接是双向的，所以一次FIN只能关闭一个方向。
ACK： 代表确认接受，从上面可以发现，不管是三次握手还是四次分手，在回应的时候都会加上ACK=1，表示消息接收到了，并且在建立连接以后的发送数据时，都需加上ACK=1,来表示数据接收成功。
seq: 序列号，什么意思呢？当发送一个数据时，数据是被拆成多个数据包来发送，序列号就是对每个数据包进行编号，这样接受方才能对数据包进行再次拼接。
ack: 这个代表下一个数据包的编号，这也就是为什么第二请求时，ack是seq+1，
TCP协议和UDP协议的区别 TCP协议是有连接的，有连接的意思是开始传输实际数据之前TCP的客户端和服务器端必须通过三次握手建立连接，会话结束之后也要结束连接。而UDP是无连接的。
TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性，但是UDP不保证按序到达，甚至不保证到达，只是努力交付，即便是按序发送的序列，也不保证按序送到。
TCP协议所需资源多，TCP首部需20个字节（不算可选项），UDP首部字段只需8个字节。
TCP有流量控制和拥塞控制，UDP没有，网络拥堵不会影响发送端的发送速率
TCP是一对一的连接，而UDP则可以支持一对一，多对多，一对多的通信。 TCP面向的是字节流的服务，UDP面向的是报文的服务。
TCP介绍和UDP介绍 为什么需要三次握手 如果发送两次就建立连接话，那么只要客户端发送一个连接请求，服务端接收到并发送了确认，就会建立一个连接。
可能出现的问题：
如果一个连接请求在网络中跑的慢，超时了，这时客户端会从发请求，但是这个跑的慢的请求最后还是跑到了，然后服务端就接收了两个连接请求，然后全部回应就会创建两个连接，浪费资源！
如果加了第三次客户端确认，客户端在接受到一个服务端连接确认请求后，后面再接收到的连接确认请求就可以抛弃不管了。
为什么关闭连接却是四次握手 关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了。
什么是TIME_WAIT状态（2MSL状态）有什么意义 MSL 即 Maximum Segment Lifetime ，也就是报文最大生存时间，引用《TCP/IP详解》中的话：“它(MSL)是任何报文段被丢弃前在网络内的最长时间。”那么，2MSL也就是这个时间的2倍。需要明白的是，当TCP连接完成四个报文段的交换时，主动关闭的一方将继续等待一定时间(2-4分钟)，即使两端的应用程序结束。
意义：
为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK 报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。就是防止已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。 常见的应用中使用到的协议 常见的应用中有哪些是应用TCP协议的，哪些又是应用UDP协议的，为什么它们被如此设计？
以下应用一般或必须用udp实现？
多播的信息一定要用udp实现，因为tcp只支持一对一通信。
如果一个应用场景中大多是简短的信息，适合用udp实现，因为udp是基于报文段的，它直接对上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输效率。
如果一个应用场景重性能甚于重完整性和安全性，那么适合于udp，比如多媒体应用，缺一两帧不影响用户体验，但是需要流媒体到达的速度快，因此比较适合用udp
如果要求快速响应，那么udp听起来比较合适
如果又要利用udp的快速响应优点，又想可靠传输，那么只能考上层应用自己制定规则了。
常见的使用udp的例子：ICQ,QQ的聊天模块。
以qq为例的一个说明（转载自知乎）
登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内网传文件采用了P2P技术。总来的说：
登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会有一个TCP连接来保持在线状态。和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。如果消息发送失败，客户端会提示消息发送失败，并可重新发送。如果是在内网里面的两个客户端传文件，QQ采用的是P2P技术，不需要服务器中转。 因特网应用中用到的协议 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adec3f45534ea33ed48c3baa8436c438/" rel="bookmark">
			2022-11 vue：组件带额外参数 - watch和created - props写法 - html中当前时间
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.element组件携带额外参数 使用==$event== 标注原参数
(e1,e2,e3) = &gt; {
return eventsName(e1,e2,e3,额外参数)
}
2.组件中watch和created先后顺序以及实际应用 页面：
说明：在页面上引用，visible直接赋值为true即可；在弹窗中调用，dialog一定要加上close关闭回调，这样组件在关闭后重新打开，才能检测到visible的变化，触发watch
组件：
说明：watch监听属性，如果不加immedite，则created先执行；if(newName) 是为了防止组件在关闭的时候，watch监听到值的改变执行不必要的请求；deep为开启深度监听，在此处可不写
3.props写法 4.html中当前时间 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb395fd8d8e13779c10c22ce3ad8c477/" rel="bookmark">
			CSS鼠标悬浮图片放大效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当鼠标移入图片时，图片变大。父容器宽高不变。
效果：
鼠标移入前：
鼠标移入后：
代码：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39ea0b871f534620fb6ffe46e09b4ffa/" rel="bookmark">
			Typora&#43;腾讯云建立远程图床
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Typora+腾讯云建立远程图床 1.安装PicGo 一款功能非常强大的图床的工具，支持SM.MS、腾讯COS、GitHub图床、七牛云图床、Imgur图床、阿里云OSS、gitee等多种图床平台。下载 下载地址：https://github.com/Molunerfinn/PicGo/releases
根据自己电脑配置进行选择安装包，一般安装PicGo-Setup-2.3.0-beta.7-ia32.exe。
特点：
PicGo最大的特点是，可以和Typora结合使用，配置好关联之后，Typora写文章时，如果需要穿插图片，只需要将图片复制粘贴到Typora的编辑区域，就自动通过PicGo上传到指定图床，得到外网能访问的URL并展示。
可以选择多个图床进行搭建——下面用的是腾讯云图床
2.腾讯云购买资源包 链接：腾讯云
一般新用户会赠送半年的资源包、而且很实惠、比gitee、github上传简单多了
进入腾讯云 选择适合自己的进行购买 新用户获取免费资源包 半年的期限
建立存储桶列表 填写相关信息——点击创建成功 到个人用户点击访问管理 查看API密钥管理 打开本地的PICGO——腾讯云COS 对应的进行填写
然后返回腾讯云——进入存储桶列表——填写区域
一切就绪后点击默认图床即可
添加快捷键 进入PICGO设置中-添加快捷键
本地截图（qq截图就可以）通过快捷键就可以直接上传云端
3.配置Typora 见图片
点击验证
设置成功
最后就可以专注自己的文档内容了，就不用担心图片的问题，之前写笔记总是出现别人无法看到图片、上传博客也无法看到图片的问题！通过图床的搭建就可以很轻松的解决这些问题了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bde8fc205ffc4af2da27ea222ffc0414/" rel="bookmark">
			Spring系列--IOC详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 IOC概念优点底层原理工厂模式XML配置文件 IOC接口IOC操作基于XML方式其它类型属性注入（xml）集合类属性注入 IOC容器初始化FactoryBeanBean生命周期实例化初始化使用中销毁 Bean的作用域xml自动装配外部属性文件基于注解方式 源码探究循环依赖 IOC 概念 控制反转、依赖注入，相当于咱不需要自己创建对象，不需要关注对象创建的过程了，要啥对象直接向Spring容器索要即可（Spring 通过反射创建），而我们只需要告诉它需要什么样的对象（bean，bean定义，xml或者注解配置）
控制反转，把对象创建和对象之间的调用过程交给Spring管理，为了降低耦合度。
优点 控制反转和依赖注入降低了应用的代码量。
松耦合，便于维护。
支持加载服务时的饿汉式初始化和懒加载。
单例模式可以分为懒汉式和饿汉式。
懒汉式就是创建对象时比较懒，先不急着创建对象，在需要加载配置文件的时候再去创建。
饿汉式就是在系统初始化的时候我们已经把对象创建好了，需要用的时候直接拿过来用就好了。
惰性加载机制（或懒加载、延时加载），也就是说只有当使用到这个实例的时候才会创建这个实例
底层原理 XML解析、工厂模式、反射。 原始方式：耦合度非常高
工厂模式 XML配置文件 IOC接口 IOC思想基于IOC容器完成，IOC容器底层就是对象工厂。
Spring提供两种实现IOC容器的方式：
BeanFactory：IOC容器的基本实现，Spring内部的接口，一般不提供开发人员使用。
特点：加载配置文件的时候并不会创建bean，在用到的时候才会创建。 ApplicationContext：BeanFactory的子接口，提供更多强大功能，一般开发人员使用。
特点：加载配置文件的时候同时创建bean。ApplicationContext接口实现类 FileSystemXmlApplicationContext(“盘符路径（绝对路径）”)ClassPathXmlApplicationContext(“src目录下类路径”) IOC操作 基于XML方式 Spring 创建对象
创建普通类，类里面创建普通方法
public class User{ public void add(){ system.out.println("add...."); } } 创建Spring配置文件，在配置文件中创建对象，新建base.xml配置文件
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--配置User对象创建--&gt; &lt;bean id="user" class="com.spring5.User"&gt;&lt;/bean&gt; &lt;/beans&gt; 在Bean标签有很多属性，常用的属性：id、class、name
创建对象的时候，默认也是执行无参数构造方法,若没有无参构造则报错。
Spring注入属性
DI 依赖注入，注入属性
第一种注入方式：使用set方法进行注入
原始方法一：创建类，定义属性和对应的set方法
public class Book { private String bname; private String bauthor; public void setBname(String bname) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bde8fc205ffc4af2da27ea222ffc0414/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f9961c38f8533688cd948151d03e86/" rel="bookmark">
			EasyDSS启动后443端口未被占用，访问不了https网页是什么原因？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在此前的文章中和大家分享过关于EasyDSS出现服务无法启动情况的解决办法，感兴趣的用户可以翻阅我们往期的文章进行了解。EasyDSS视频直播点播平台支持Flash、H5播放，可兼容多操作系统，搭配RTMP高清摄像头，可将设备的实时流推送到平台上，实现无人机视频直播，可应用在城市航拍、农业植保、森林防火、秸秆焚烧、电力巡检等场景中。
有用户反馈在现场使用中，开启https后，并没有占用443端口，导致访问不了https页面，请求我们协助排查。
今天和大家分享一下排查及解决办法。
1）调试使用进程启动EasyDSS，并且查看本地Windows，查看是否有https的端口占用：
2）如上图所示，没有进程占用本地的443端口，所以判断为https服务并没有运行。那么我们来检查https是否打开默认为false，如图：
3）显示为true，表明用户现场已经将https服务启动，但是EasyDSS没有占用443端口。查看ini配置文件可以了解到，用户没有配置https的证书：
4）申请https证书后，将证书的绝对路径填写到对应的参数后（证书一般为nginx的证书）：
5）配置完证书后重启EasyDSS，再次查询端口占用，此时EasyDSS已经占用443端口了：
6）测试EasyDSS，此时已经可以正常登录https页面了：
EasyDSS视频能力灵活，可拓展性强，使用场景也非常丰富，除了在线教育、视频直播点播方面的应用之外，还可以拓展到无人机、物联网、物流仓储、移动监控等多个领域。此外，为了便于用户二次开发与集成，我们也提供了API接口供用户使用。感兴趣的用户可以前往演示平台进行体验或部署测试。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b8e5a35c30a4c47a56e47cb05c84076/" rel="bookmark">
			ES6详细讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、ES6相关介绍 1.1、什么是ES6 1995年的美国，有一家名为netscape(网景)的公司打造了一款主要用于check验证的脚本语言，而恰在此时，Sun公司的java语言火的一塌糊涂，netscape公司为蹭其热度，便将该脚本语言命名为 JavaScript。不料 JavaScript居然被越来越多的人使用，后效仿大秦的货币统一政策将其提交给国际标准组织ECMA。
该组织发布的标准被称做ECMAScript。 2015年6月发布的版本称为ECMAScript2015，简称ES6。从ES6开始，该组织每年会发布一个版本，版本号比年份最后一位大1，至今最新版本为ES12。
ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准 1.2、学前必知词汇 语法糖：又称糖衣语法，指不改变语言的本质功能，只是使编程变的更加简洁。而本课程后续所学习的很多ES6的新特性大多也都是由一粒粒语法糖所构成，所以ES6的一些新特性并不是真的“新”，只是试图简化语法而已。简言之：ES6是一大盒语法糖，解决了以前ES5很多难受的地方。
Babel：Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。这意味着，你可以用ES6的方式编写程序，又不用担心现有环境是否支持。相信未来浏览器会逐渐对其提供原生的支持。
1.3、为什么要学习ES6 ES5语言先天不足，通过学习ES6可以将其很多丑陋的部分进行隐藏。包含了很多超棒的新特性，可以简化很多复杂的操作，从而大大提高开发效率。为后面学习vue、react以及小程序做好充足准备。目前大部分公司的项目都在使用ES6，它是前端发展的趋势，就业必备技能之一。 1.4 严格模式 1.4.1 介绍 ES5 除了正常运行模式（又称为混杂模式），还添加了第二种运行模式：“严格模式”（strict mode）。
严格模式顾名思义，就
是使 JavaScript 在更严格的语法条件下运行。
1.4.2 作用 消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为消除代码运行的一些不安全之处，保证代码运行的安全为未来新版本的 JavaScript 做好铺垫 1.4.3 使用 在全局或函数的第一条语句定义为: 'use strict'
如果浏览器不支持，只解析为一条简单的语句, 没有任何副作用
1.4.4 语法和行为改变 必须用 var 声明变量，不允许使用未声明的变量禁止自定义的函数中的 this 指向 window创建 eval 作用域对象不能有重名的属性（Chrome 已经修复了这个 Bug，IE 还会出现）函数不能有重复的形参新增一些保留字, 如: implements interface private protected public使用call、apply传第一个参数为null或undefined时，this值不会跳转到全局对象 1.5 Object 扩展方法 var obj = { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b8e5a35c30a4c47a56e47cb05c84076/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9faf05e41e94b1d2c731ca6935f972b8/" rel="bookmark">
			day03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day03
1文件 FHS（Filesystem Hierarchy Standard）文件系统层级标准
文件系统：存储设备指定存放数据文件的方法和数据结构
/ 所有数据文件
bin 所有用户都可以执行的命令文件
sbin 只有管理员才可以执行的命令文件
lib 32位数据的库文件
lib64 64位数据的库文件
sue 核心资源文件
root root（管理员）用户家目录
home 所有普通用户的家目录
boot 系统加载引导相关所有文件
dev 设备目录文件
etc 系统中所有的配置文件
opt 自定义软件的安装路径
proc 系统内核相关的进程信息
sys 硬件驱动程序
run 应用程序文件的进程
srv 服务程序文件的路径
tmp 临时目录
var 动态可变化的数据文件路径
2文件相关的操作命令 (1) 同一路径下不能有两个相同的文件名
（2）严格区分大小写
（3）文件命令不能以/字符命令
（4）文件命名字符不能超过255字符
touch 创建 文本文件
当一个路径下不存在该文件通过touch可以创建一个普通文本文件
当一个路径下存在该文件就改变该文件的时间信息
stat FILENAME 文件详细属性信息
touch FILENAME
touch a b c touch {1,2,3,4} touch {1..10}(两个点表示省略) eg: touch /root/a b c(a文件在/root/其他文件在当前路径创建) touch /root/{1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9faf05e41e94b1d2c731ca6935f972b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74ede840ab99ef1dd742699da63a5198/" rel="bookmark">
			CSS3 动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变形 transform 在CSS3中，动画效果包括3个部分：变形（transform）、过渡（transition）、动画（animation）
translate()平移 transform: translateX(x);　/*沿x轴方向平移*/ transform: translateY(y);　/*沿y轴方向平移*/ transform: translate(x, y);　/*沿x轴和y轴同时平移*/ scale()缩放 transform: scaleX(x);　/*沿x轴方向缩放*/ transform: scaleY(y);　/*沿y轴方向缩放*/ transform: scale(x, y);　/*沿x轴和y轴同时缩放*/ 当x或y取值为0~1时，元素进行缩小；当x或y取值大于1时，元素进行放大。
skew() 倾斜 倾斜也有3种情况：skewX()、skewY()、skew()。
参数x表示元素在x轴方向的倾斜度数，单位为deg（即degree的缩写）。如果度数为正，则表示元素沿x轴方向逆时针倾斜；如果度数为负，则表示元素沿x轴方向顺时针倾斜。
参数y表示元素在y轴方向的倾斜度数，单位为deg。如果度数为正，则表示元素沿y轴方向顺时针倾斜；如果度数为负，则表示元素沿y轴方向逆时针倾斜。
rotate()旋转 transform: rotate(angle); 参数angle表示元素相对于中心原点旋转的度数，单位为deg。如果度数为正，则表示顺时针旋转；如果度数为负，则表示逆时针旋转。
transform-origin改变中心原点 在CSS3变形中，任何元素都有一个中心原点。默认情况下，元素的中心原点位于x轴和y轴的50%处。
CSS3的各种变形（平移、缩放、倾斜等）都是以元素的中心原点进行变形的。
我们可以使用transform-origin属性来改变元素的中心原点。
transform-origin属性取值有两种：一种是“长度值”，另一种是“关键字”。当取值为长度值时，单位可以为px、em和百分比等。当取值为关键字时，transform-origin属性取值跟background-position属性取值是相似的。
过渡 transition 我们可以使用transition属性将元素的某一个属性从“一个属性值”在指定的时间内平滑地过渡到“另一个属性值”，从而实现动画效果。
CSS变形（transform）呈现的仅仅是一个“结果”，而CSS过渡（transition）呈现的是一个“过程”。
transition: 过渡属性 过渡时间 过渡方式 延迟时间;
凡是涉及CSS3过渡，我们都是结合:hover伪类来实现过渡效果的。
我们可以使用transition-timing-function属性来定义过渡方式。所谓“过渡方式”，指的是动画在过渡时间内的速率变化方式。
transition-property:border-radius,background-color; transition-duration:1s; transition-timing-function:linear; transition-delay: 0s; 上面这段代码可以等价于：
transition:all 1s linear 0s; 当transition-property属性定义为all时，CSS3会自动判断哪些属性是作为过渡效果的属性，相对来说更加简单方便。
由于transition-delay属性是一个可选属性，因此当transition-delay取值为0s时，这个参数可以省略。
transition:all 1s linear; 动画 animation ▶ 对于transition属性来说，它只能将元素的某一个属性从一个属性值过渡到另一个属性值。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74ede840ab99ef1dd742699da63a5198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/668c98bc4349334390d43c284627b7cc/" rel="bookmark">
			旋转的骰子（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.动画——旋转的骰子 上一次我们做了一个旋转的骰子（参看第2讲），这次我们想要点击按钮，让骰子旋转到特定的点数停下来！
2.分析需求——庖丁解牛 a.立方体特定的朝向对应着特定的旋转角度
骰子显示特定点数，无非就是旋转骰子，让特定点数的面朝向屏幕外侧
b.通过自定义属性控制旋转角度
利用css属性选择器，将特定属性值和骰子旋转样式，建立一一对应关系
c.通过类进行动画控制
通过添加类，删除类，启动动画
d.添加控制按钮，触发动画
添加6个按钮，点击，触发筛子旋转，方便调试
3.旋转特定角度，露出特定平面 4.自定义属性的设置 与表达式
“与”表达式（&amp;&amp;），准确的说是“逻辑与”表达式，形式为： A &amp;&amp; B &amp;&amp; C。
其中A，B，C为子表达式，子表达式数目不限，只有所有的子表达式都为true，整个表达式的值才为true.
判断为true的常见类型：
布尔值true，非零数值，对象，字符串
判断为false的常见类型：
布尔值false，数值0，空对象（null)，未定义变量（undefine)
与表达式是可以赋值给给其他变量的，它的值的分两种情况：
• 如果整个表达式的值为 true ，则整个表达式的值，是 最后一个为 true 的，子表达式的值 ； • 如果表达式的值为 false ， 则整个表达式的值，为 第一个为 false 的子表达式的值 。 如下图所示
5.动画的开启/结束 6.测试按钮 7.更多思考 我们可以制作一个骰子，然后通过单一按钮，进行随机投掷，这样就变成了一个有趣的小游戏
8 代码 注意代码中引用jquery-1.12.4.js，可自行到官网下载
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;Rotate Dice&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="./styles.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="dice"&gt; &lt;div class="vertical"&gt; &lt;div class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/668c98bc4349334390d43c284627b7cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31b67b3741f1c0c644a90a1b0423efdc/" rel="bookmark">
			HTML、CSS学习笔记小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1，HTML
1.1 简单介绍
1.2 快速入门
1.3 基础标签
代码演示：
1.4 图片、音频、视频标签
代码演示：
1.5 超链接标签
代码演示：
1.6 列表标签
代码演示：
1.7 表格标签
代码演示：
1.8 布局标签
代码演示：
1.9 表单标签
1.9.1 表单标签概述
1.9.2 form标签属性
代码演示：
1.10 表单项标签
代码演示：
2，CSS
2.1 概述
2.2 css 导入方式
目录结构：
代码演示：
2.3 css 选择器
代码演示：
1，HTML 1.1 简单介绍 HTML 是一门语言，所有的网页都是用HTML 这门语言编写出来的，也就是HTML是用来写网页的，像某东、某宝、某夕夕等网站有很多网页。
&gt;&gt;&gt;这些都是网页展示出来的效果。而HTML也有专业的解释
==HTML(HyperText Markup Language)：超文本标记语言：==
超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容
如上图看到的页面，我们除了能看到一些文字，同时也有大量的图片展示；有些网页也有视频，音频等。这种展示效果超越了文本展示的限制。
标记语言：由标签构成的语言
之前学习的XML就是标记语言，由一个一个的标签组成，HTML 也是由标签组成 。我们在浏览器页面右键可以查看页面的源代码，如下可以看到如下内容，就是由一个一个的标签组成的：
这些标签不像XML那样可以自定义，==HTML中的标签都是预定义好的，运行在浏览器上并由浏览器解析，==然后展示出对应的效果。例如我们想在浏览器上展示出图片就需要使用预定义的 img 标签；想展示可以点击的链接的效果就可以使用预定义的 a 标签等。
HTML 预定义了很多标签，由于我们是Java工程师、是做后端开发，所以不会每个都学习，页面开发是有专门的前端工程来开发。那为什么我们还要学习呢？在公司中或多或少大家也会涉及到前端开发。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31b67b3741f1c0c644a90a1b0423efdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5721250dadae61e0b950c4d97cfc0a8f/" rel="bookmark">
			机器学习-正样本加权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在loss上进行加权，加权方式：在交叉熵的前项上乘上加权的系数。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562adf2dff0d96c7063ff983a3b39feb/" rel="bookmark">
			Windows 10 SDK版本2104 (最新10.0.20348.1) 详细安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装需求：Cef3 编译需要
chromiumembedded / cef / wiki / BranchesAndBuilding — Bitbucket
下载及安装步骤：
1.官网下载最新：Windows SDK 和模拟器存档 | Microsoft Developer
2.安装（另外一种通过VS安装）
我看没有10.0.20348.0这个版本，于是就从官网下载安装包单独安装SDK
选择对应版本，安装开始（最新版10.0.20348.1）
点击 Accept
也不知道哪些该用哪些不该用，默认选择吧。磁盘空间要足够哦。点击 Install
安装过程中，等待结束。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/802090ca8e2967e9eabcad6b37bfd466/" rel="bookmark">
			O’Shea基于深度学习调制识别代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Convolutional Radio Modulation Recognition Networks 论文代码复现 1. 数据集下载 数据集生成源代码（需要GNU Radio来实现，如需安装学习参考主页相关教程）
链接: https://github.com/radioML/dataset
现成的数据集下载（来自DeepSig公司主页）
链接: https://www.deepsig.ai/datasets
一般来说，RADIOML 2016.10A就可以满足需求，其他数据集将消耗更大的硬件需求。
2. 原论文 链接: https://arxiv.org/abs/1602.04105
3. 软硬件约束 1.tensorflow2，keras2
2.gpu：RTX3080Ti，cpu：Intel Xeon E5-2690 v4
4. 代码 （1）导包，本来我是tf2，后来为了适应tf1版本，加了几行代码，现在tf1应该可以用。
from tensorflow.compat.v1 import ConfigProto from tensorflow.compat.v1 import InteractiveSession config = ConfigProto() config.gpu_options.allow_growth = True session = InteractiveSession(config=config) import h5py import numpy as np #import theano as th import os,random import pickle,random, sys import tensorflow as tf tf.compat.v1.enable_eager_execution() from tensorflow import keras import matplotlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/802090ca8e2967e9eabcad6b37bfd466/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/740947b8509cced2d581f596912b3d58/" rel="bookmark">
			python基础之程序执行原理（科普）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 一、计算机的三大件二、计算机执行三、python程序的执行原理四、程序的作用 `
一、计算机的三大件 1.cpu：本质上是一块超大规模集成电路；
2.内存：存储设备，临时存储数据；
3.硬盘：永久性存储数据；
二、计算机执行 在计算机中真正负责程序执行的是cpu，程序保存在硬盘中，一个可以执行的程序内容是cpu可以识别的0101这种机器语言又可以叫做机器代码，当我们运行程序时会先将硬盘中程序内容复制（加载）到内存中cpu在内存中调用执行。
三、python程序的执行原理 cpu翻内存中的python解释器中的python程序
我们都知道，使用C/C++之类的编译性语言编写的程序，是需要从源文件转换成计算机使用的机器语言，经过链接器链接之后形成了二进制的可执行文件。运行该程序的时候，就可以把二进制程序从硬盘载入到内存中并运行。
但是对于Python而言，Python源码不需要编译成二进制代码，它可以直接从源代码运行程序。Python解释器将源代码转换为字节码，然后把编译好的字节码转发到Python虚拟机（PVM）中进行执行。接下来，通过一张图来描述Python程序的执行过程，如图1所示。
在图1中，当我们运行Python文件程序的时候，Python解释器会执行两个步骤：
（1）把源代码编译成字节码
编译后的字节码是特定于Python的一种表现形式，它不是二进制的机器码，需要进一步编译才能被机器执行，这也是Python代码无法运行的像C/C++ 一样快的原因。如果Python进程在机器上拥有写入权限，那么它将把程序的字节码保存为一个以.pyc 为扩展名的文件，如果Python无法在机器上写入字节码，那么字节码将会在内存中生成并在程序结束时自动丢弃。在构建程序的时候最好给Python赋上在计算机上写的权限，这样只要源代码没有改变，生成的.pyc文件可以重复利用，提高执行效率。
（2）把编译好的字节码转发到Python虚拟机（PVM）中进行执行
PVM是Python Virtual Machine的简称，它是Python的运行引擎，是Python系统的一部分，它是迭代运行字节码指令的一个大循环，一个接一个地完成操作。
四、程序的作用 用来处理数据；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab4d45004d51a8663c57b072abc91e4/" rel="bookmark">
			错误记录2022.11.22
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		default argument given for parameter 2 of 上面的问题可能是在函数的声明处和函数的定义处都指定默认值，这两处都指定了默认值的话，就会导致语法错误。
解决方法：任意去掉一个默认值就可以，声明处或者定义处。
Some tactics do not have sufficient workspace memory to run. Increasing workspace size may increase performance, please check verbose output. 上面的问题就是典型tensorrt中setworkspace设置的太小，没有优化好。它根据你给的大小，只会还给你一个当前条件下最优的优化效果。
在tensorrt编译阶段，每个layer都去寻找最优解，trt会在所有的解空间中搜寻最优的优化实现，不同的实现其使用的显存大小是不同的，这个workspace就是约束显存的使用量的。
有时候我们会看到出现优化策略无法进行的警告，这就是由于显存开的太小没法找到最优解。直接显示给出防止编译时出现不确定，造成使用超出预期的内存空间。
如果你不加限制有可能会造成系统中途内存挂掉。实际简单理解就是你如果不去给出一个明确的大小去限制这个，到时候有些层会尽力优化从而耗尽你的内存（显卡），你的内存就会挂掉。但是有个矛盾的地方就是你给的太小，优化不到位，就是性能会差一些。目前最新的8.4版本就不需要再给出workspace了。
config-&gt;setMaxWorkspaceSize(3.0f * (1 &lt;&lt; 30)); // 1&lt;&lt;30:1024mb 1&lt;&lt;28:256mb
cannot allocate an object of abstract type“xx” 上面的问题可能是在类继承，基类存在纯虚函数，而派生类没有全部重载纯虚函数。
解决方法：在基类中申明的虚函数，在派生类中必须继承并实现。这样在new一个派生类时才不会报该错误。
cannot call member function ‘***’ without object 当直接引用某个类的方法，没有创建对象，因为这里面的其他函数都是static，是写在头文件中的，没有实际的object，所以必须也要定义成static。
或者新建一个对象，再使用该对象的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7026915bd38f8881c9ea087879e46787/" rel="bookmark">
			Nginx负载均衡配置、限流配置、Https配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 负载均衡 1. 用法 通过proxy_pass 可以把请求代理至后端服务，但是为了实现更高的负载及性能， 我们的后端服务通常是多个， 这个是时候可以通过upstream 模块实现负载均衡。
使用的模块为：【ngx_http_upstream_module】，具体配置可以根据模块名去查找文档。
负载均衡的算法有：
ll：轮询ll+weight： 轮询加权重ip_hash : 基于Hash 计算，用于保持session 一至性 该算法下权重失效url_hash: 静态资源缓存，节约存储，加快速度（第三方） 该算法下权重配置失效least_conn ：最小链接数least_time ：最小的响应时间，计算节点平均响应时间，然后取响应最快的那个，分配更高权重 2. 参数 upstream 相关参数如下：
server 反向服务地址加端口weight 权重，默认是1，越大权重就越大max_fails 失败多少次认为主机已挂掉则，踢出 （默认配置10s，即服务器宕掉，会自动剔除）fail_timeout 踢出后重新探测时间backup 备用服务，当其他非backup的机器全部宕机或者繁忙的时候，才会启动这台机器。down 表示当前Server不参与负载max_conns 允许最大连接数slow_start 当节点恢复，不立即加入,而是等待 slow_start 后加入服务对列。 upstream myApiTest { server localhost:9001 weight=10; server localhost:9002 weight=5; server localhost:9003 max_fails=3 fail_timeout=30s; server localhost:9004 backup; server localhost:9005 down; } 3. 案例 事先准备：
有三个同样的api服务，分别部署在9001、9002、9003端口下，比如：访问 http://localhost:9001/Home/GetMsg，会返回 【 获取成功，当前端口为：9001】，其它端口类似。
要求：
Nginx监听8080端口，接收到8080端口的请求，按照响应的算法进行转发到9001-9003端口。　(1). 轮询
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7026915bd38f8881c9ea087879e46787/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf5d4c8237f0f8779c28cf1eca63714/" rel="bookmark">
			54_Pandas将DataFrame、Series转换为字典 (to_dict)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		54_Pandas将DataFrame、Series转换为字典 (to_dict) pandas.DataFrame、pandas.Series可以使用to_dict()方法转换为字典（dict类型对象）。
对于pandas.DataFrame，参数orient可以用来指定pandas.DataFrame的行标签索引、列标签列和值如何分配给字典的键和值。
在 pandas.Series 的情况下，它被转换为以标签作为键的字典。
此处解释以下内容。
pandas.DataFrame to_dict() 方法 指定字典的格式：Argument orient转换为 dict 以外的类型：Argument into 从 pandas.DataFrame 的任意两列生成字典pandas.Series to_dict 方法 转换为 dict 转换为 dict 以外的类型：Argument into 创建以下 pandas.DataFrame 作为示例。
import pandas as pd import pprint from collections import OrderedDict df = pd.DataFrame({'col1': [1, 2, 3], 'col2': ['a', 'x', '啊']}, index=['row1', 'row2', 'row3']) print(df) # col1 col2 # row1 1 a # row2 2 x # row3 3 啊 它导入 pprint 以使输出更易于查看，并导入 OrderedDict 以通过参数解释类型规范。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ccf5d4c8237f0f8779c28cf1eca63714/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/194/">«</a>
	<span class="pagination__item pagination__item--current">195/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/196/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>