<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a94487206d4d55de559f60a4cebd6b/" rel="bookmark">
			微信小程序动态计算文本高度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说 直接上代码 一.wxml结构页面，里边的文字替换成自己需要的即可 &lt;view class="speak_top_blue_text {{showAll?'negotiation_info_text_showAll':'negotiation_info_text_showPartton'}} {{bigFont?'bigFont10':''}}"&gt; &lt;view class="needToQueryHeight"&gt; 留言前请先阅读以下条款： &lt;text&gt; 一、不得发表违反中华人民共和国宪法和法律、违反改革开放和四项基本原则的言论； 二、不得发表造谣、诽谤他人的言论； 三、不得发表未经证实的消息，亲身经历请注明； 四、请勿发表任何形式的广告，企业推广产品或服务； &lt;/text&gt; &lt;/view&gt; &lt;block wx:if="{{showAll}}"&gt; &lt;view class="negotiation_info_downarrow" bindtap="showAll"&gt; &lt;image src="../../icons/uparrow.png" class="downarrow {{bigFont?'bigImg4':''}}"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt; &lt;block wx:else&gt; &lt;!-- 文字超过5行显示此部分内容 --&gt; &lt;view class="negotiation_info_downarrow" bindtap="showAll" wx:if="{{hasAll}}"&gt; &lt;image src="../../icons/downarrow.png" class="downarrow {{bigFont?'bigImg4':''}}"&gt;&lt;/image&gt; &lt;/view&gt; &lt;/block&gt; &lt;/view&gt; 二.css页面 .negotiation_info_text_showAll { height: 100%; } .negotiation_info_text_showPartton { overflow: hidden; /* 显示5行 */ /* height: calc(60rpx * 5); */ overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5a94487206d4d55de559f60a4cebd6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d013758bb34aead2c2580b6d8c2fac4f/" rel="bookmark">
			GPON概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GPON PON网络架构GPON的网络基本性能参数PON的优势GPON的数据复用方式GPON的下行数据GPON上行数据DBA概念SR-DBA的实现方式 PON网络架构 PON是一种点到多点，P2MP结构的无源光网络。
GPON：gigabit-capable passive optical netwrok 千兆比特无源光网络
PON的组成：
ONU/ONT：光网络单元/终端
ODN：由分光器和光纤组成，光分配网络
OLT：光线路终端
GPON的网络基本性能参数 上行速率1.24416约为1.25G
下行速率2.4832约为2.5G，可以升级为10GPON
最大的物理传输距离是：20KM
最大逻辑距离：60KM
最大分离器比：1：128
PON的优势 带宽大，可扩展性好
点对多点，节省主干光纤
光纤损耗低，覆盖范围广
无源光网络，OPEX（运营支出）低，线路上没有有源器件，免维护和电耗
GPON的数据复用方式 在之前的PON技术中，线路只能进行单向传输（通过不同的速率），但是在GPON之中，实现了单纤双向传输。
GPON实现单光纤的双向传输，使用的是WDM技术。
WDM技术就是通过不同的光的波长，然后将信号合并到同一根光纤之中，实现多信道通信。
上行是1310nm，下行是1490nm。
下行采用的是广播的技术，上行采用的TDMA技术，也就是时分复用。
GPON的下行数据 GPON的下行帧长为固定的125微秒，下行是广播的方式，所有的ONU都可以收到相同的数据，但是通过GEM PORTID可以区分不同的ONU数据，ONU通过过滤来接收属于自己的数据。
GPON上行数据 TDMA，通过时分复用的方式进行传输，上行链路被分为不同的时隙，根据下行帧的upstream bandwidth map字段给每个ONU分配上行时隙。
因为在现实生活中不会说所有的ONU/ONT到达OLT的距离都一致，所以需要在逻辑上让他们的距离都一样。
使用RTD与EQD技术，使得各个ONU发送的数据帧都是同步的，不会产生数据冲突。
由此可以引出一个DBA，动态带宽分配，可以在微秒或者是毫秒级的时间间隔内完成对上行带宽的动态分配的机制。
DBA概念 动态带宽分配，DBA可以在毫秒或者是微秒级的时间间隔内完成对上行带宽的动态分配机制。
SR-DBA的实现方式 OLT周期性的从各个用户终端收集带宽需求信息。
OLT根据ONU发送的DBA报告，然后根据DBA的逻辑算法，发送一个BW MAP给ONU的调度器。
ONU的调度器根据带宽、优先级等因素，决定每个时隙分配多少带宽给ONU。
然后ONU调度器再向上行链路进行发送。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b344f28ee36a4ab76d336f61dd03871/" rel="bookmark">
			接入网概述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接入网概述 接入网基本概念接入网“最后一公里”解决方案数字用户线xDSL技术的发展与特点xDSL的局限性PON网络架构小结 接入网基本概念 在家里终端设备连接ONT然后进入接入网，这个接入网大概在2-20km左右，中间是通过光纤进行连接，是无源的，其中光纤或者铜线可以通过架空、管道或者是直埋的方式进行布置。
也就是ONT—光、铜----BAS
接入网“最后一公里”解决方案 传统解决方案：数字用户线（xDSL）
新趋势：光纤接入，FTTx（Fiber To The X）
数字用户线xDSL技术的发展与特点 经历了很多迭代：
ADSL（Asymmetric Digital Subscriber Line）： ADSL 是最早的 xDSL 技术之一，于1990年代末引入。它在上行和下行方向上的传输速率不对称，下行速率较高，适用于从互联网下载内容。
HDSL（High-bit-rate Digital Subscriber Line）： HDSL 于1990年代早期出现，提供了对称的传输速率，适用于需要高速上传和下载的业务，如企业使用的数据传输。
SDSL（Symmetric Digital Subscriber Line）： SDSL 是对称传输速率的 xDSL 技术，它提供相等的上行和下行速率，适用于需要平衡上传和下载的应用。
VDSL（Very-high-bit-rate Digital Subscriber Line）： VDSL 是在2000年代初引入的技术，具有更高的传输速率，适用于高清视频流、在线游戏等高带宽需求。
VDSL2： VDSL2 是 VDSL 的升级版本，通过增加频谱和优化调制方式，提供了更高的传输速率和更远的传输距离。
G.fast： G.fast 是一种高速 xDSL 技术，可以在短距离内提供极高的传输速率，适用于楼宇和小区等密集住宅区域。
因为xDSL是通过铜线进行传输，随着光纤的出现，xDSL逐渐变的劣势，但是在某些场景仍然使用xDSL。
xDSL的局限性 实验表明，对于xDSL技术，总存在一个矛盾：距离与带宽之间的矛盾，二者之间成反比。
也就逐渐引出了使用光纤代替铜线的架构。
PON网络架构 ONU在ODN的光纤网络架构之下，通过POS（无源分光器）进行传输，最终到达OLT，OLT进行汇聚。在ONU与OLT之间是没有电的，也就是一个无源光网络。
PON（Passive Optical Network）是一种光纤网络架构，用于在用户和中心节点之间传输光信号，实现高速宽带接入。PON 架构使用光纤进行信号传输，具有高带宽、低延迟和灵活性等优势。
通俗解释：想象一条光纤就像是一根超级细的管道，能够传输光信号，而这些光信号就像是数据的信息，比如网页、视频等。PON 架构就像是把这根光纤分成很多支管道，每个用户都有一支管道连接到中心。这样，每个用户都可以通过自己的“光管道”获取快速的互联网连接，就像是在光纤上搭了一条“高速光快车道”。因为这个架构不需要太多的电子设备，所以叫做“被动光网络”，简称 PON。这种架构能够让很多用户同时使用高速的网络，就像大家同时通过各自的“光快车道”行驶，不会相互影响。
小结 小结一下就是，使用xDSL技术的铜线正在逐渐进行退化，然后光纤占据了主导地位，也就是光进铜退，然后再是PON架构，通过在ONU与OLT之间假设一个无源的光网络，然后进行传输。PON架构有效的将光纤带宽共享给了多个用户，同时降低了网络的复杂性与成本。
还有一点PON架构下的用户是共享带宽的，假设一根光纤可以传输5M流量，下面接了5个人，那平均一个人就可以获得1M的流量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/841af9507c1397a01c90970bebc00480/" rel="bookmark">
			FBB简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FBB FBB简介FBB组网名词解释FBB组网（从下至上）小结 FBB简介 FBB：Fixed BroadBand，固定宽带网络，是一种依托线缆介质进行传输的地面有线网络，区分与MBB，MBB是移动网络。
MBB是天上一张网，频谱、天线、基站等。
FBB是地上一张网，特点是使用线缆，铜线，光纤等等。一般是不会轻易移动的。
FBB组网 FBB的组网分为三大部分，分别是：接入网、城域网、骨干网。骨干网再往外就是服务端了。
PC与Phone连接ONT，Optical Network Terminal，光网络终端，用于将光信号转化为电信号，并且连接用户设备到光纤网络。可以通过有线铜线或者是无线wifi等方式相连。
TV则是与STB，Set-Table Box，机顶盒相连。
STB通过有线或者是无线的方式与ONT相连。
最终ONT与ODN，Optical Distribute Network，光分配网络，相连。在光纤通信系统中，ODN 扮演了连接中心节点与终端用户之间的桥梁角色。
ODN再与OLT，Optical Line Terminal，光线路终端，负责汇聚来自不同终端的光信号，将他们一起处理，然后传输出去。
ONT与OLT之间通常通过光纤进行连接。
名词解释 BAS：Broadband Access Server，宽带接入服务器，连接用户设备与互联网之间的桥梁。在DSL网络之中，可以理解为铜线网络，是通过铜线与用户终端设备相连。如果是光纤网络，用户终端设备可能会通过光纤连接到ONT，而不用BAS进行中间连接。
DSLAM：Digital Subscribe Line Access Multiplexer，数字用户线路接入复用器。就是将连接的多个用户的DSL信息进行汇聚，并且处理，然后分配带宽，并且进行管理。
SR：Service Router，服务路由器。提供信息管理、路由、Qos等等。
OSN：Optical Switch Network，光交换网络。这是一种基于光信号的通信网络，使用在不同的光纤通道之间进行传输光信号，实现高速、大容量的传输。
OTN：Optical Transport Netwrok，光传输网络。OTN是一种高速的光纤通信网络，用于在长距离的大容量的传输。
OLT：Optical Line Transport，光线路终端，作为一个汇聚设备，用于连接内部终端传来的光信号，然后传输出去到城域网。
FBB组网（从下至上） 接入网：终端设备与汇聚设备之间相互连接，涉及到的设备有：DSLAM、ONT、OLT等等。
城域网：分为接入层：BAS，BroadBand Access Server，宽带接入服务器，SR，Service Router，服务路由器。
汇聚层：AR，汇聚路由器
核心层：IDC，Internet Data Center，互联网数据中心，用于存储数据，CR，Core Router核心路由器。
骨干网：在城域网上面就是骨干网。
小结 FBB指的是，Fixed BroadBand，即固定带宽。
FBB组网主要有有线接入网，数通城域网，数通骨干网，光传送网。
个人理解一下，终端设备通过介质连接ONT，然后ONT开启了光纤网络，然后将信号都传送给OLT，然后OLT对ONT传输过来的信号进行一个汇聚的作用，然后传送到城域网进行传输。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2de29f6fe642fba61664bf86a8a16b0a/" rel="bookmark">
			GO很牛？Python性能不如GO语言当他为何霸榜编程语言第一？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go 语言为何强大 Go 语言（也称为 Golang）是一种现代编程语言，受到了广泛关注，原因在于其独特的特性和优势。以下是 Go 语言相对于 Python、Java、C++ 和 C 的一些优势和缺陷：
优势：
简洁易学：Go 语言的语法简单，易于学习。它摒弃了许多传统语言中的复杂特性，例如继承、泛型和异常处理。这使得 Go 代码更易于阅读和维护。
并发性能：Go 语言内置了对并发的支持，通过 goroutine 和 channel 实现。goroutine 是一种轻量级线程，可以轻松创建数百万个，并且 Go 语言的运行时会自动进行调度。channel 是一种用于在 goroutine 之间传递数据的同步原语。Go 语言的并发模型使得编写高性能并发程序变得简单。
快速编译：Go 语言的编译速度非常快，使开发过程更加高效。与 C++ 等需要花费大量时间进行编译的语言相比，Go 语言可以大大缩短开发周期。
静态类型和垃圾回收：Go 语言是静态类型语言，可以在编译时捕获许多错误。同时，Go 语言还具有垃圾回收功能，使得内存管理变得更加简单。
跨平台：Go 语言支持跨平台编译，可以轻松为不同操作系统和架构构建程序。
标准库丰富：Go 语言拥有丰富的标准库，涵盖了网络编程、加密、文件处理等许多领域。
缺陷：
泛型缺失：Go 语言目前尚不支持泛型编程，这使得在编写某些类型的代码时可能需要使用接口和类型断言，牺牲了一定的类型安全性和性能。
库生态相对较弱：虽然 Go 语言的标准库丰富，但与 Python、Java 等成熟语言相比，其第三方库生态仍有待加强。
学习曲线：虽然 Go 语言简洁易学，但对于习惯了面向对象编程的开发者来说，学习 Go 语言的并发模型和接口编程可能需要一定时间。
性能：虽然 Go 语言的性能优于 Python 和 Java，但与 C 和 C++ 相比，Go 语言在某些场景下的性能可能略逊一筹。
总之，Go 语言在并发性能、编译速度、简洁性等方面具有优势，但在泛型支持和库生态等方面仍有待提高。Go 语言适用于网络编程、微服务、分布式系统等领域，但在一些对性能要求极高或需要复杂泛型支持的场景中，可能不如 C++ 或 Java。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2de29f6fe642fba61664bf86a8a16b0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5af5f786f555ad5af064efe409efd98/" rel="bookmark">
			systemd-journal 占用内存的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近发现部分 Debian 机器的 systemd-journal 占用了非常多内存。这和 Debian 对其的 错误配置有关系（查了一下其他发行版，有和 Debian 一样的配置的也有和 Debian 不一样 的配置的，说明这个配置有争议）。
systemd-journal 简介 systemd-journal 是 systemd 引入的系统日志记录工具。其优势是：
使用二进制保存日志，有压缩，体积小可以记录启动早期，磁盘还没挂载之前，rsyslog 还没启动时候的系统日志有索引，可以快速搜索索引包含了多种类型，可以方便使用多种维度，以及他们的组合，进行搜索，包含但不限 于： 时间PID程序可执行文件路径service 名称用户内核错误级别显示的时候，可以针对不同等级做高亮，可以转换日志时间戳可以针对日志设置用户访问权限控制会对日志做校验，用户无法修改任何日志，日志也不能伪造用户、processid 等敏感信息可以设置 rotate 和最大体积等各种限制，也可以比较方便地手工清理指定时间之前的日 志支持 syslog 的所有日志级别支持复制日志并转发到 rsyslog 由于可以方便地过滤某个时间段的所有程序的日志，所以 journal 特别适合 debug 一些多 种环境下，会有多个日志源的复杂问题，可以按时间顺序将所有日志源共同打印出来，从而 清晰地观察到各种应用程序之间的交互顺序。
其缺点是：
不支持 rsyslog 的复制日志和转发过滤等功能 由于游戏需要 rsyslog 的转发过滤，因此我们一般都会打开 rsyslog，因此在 Debian 中， 日志会首先到达 systemd-journal，并且被保存为 journal 文件，同时再转一个副本给 rsyslog，由 rsyslog 控制写到 /var/log/ 目录下，或者游戏项目自行设置的其他路径 下。
systemd-journal 的配置 在 /etc/systemd/journald.conf 下面。支持的配置项还是比较多的。具体可以参考 man 5 journald.conf
systemd-journal 的使用 使用 journalctl 命令。具体参数可以 man 1 journalctl 查看。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5af5f786f555ad5af064efe409efd98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13955b48c0a32660a12c4824bf126c2e/" rel="bookmark">
			航顺HK32F030M怎么样 航顺HK32F030M应用领域介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		航顺HK32F030M是一款基于ARM Cortex-M0+内核的32位微控制器，具有高性能、低功耗、经济适用等特点。以下是颖特新关于航顺HK32F030M的详细介绍：
一、性能表现
航顺HK32F030M采用ARM Cortex-M0+内核，主频最高可达64MHz，具有出色的计算能力和数据处理能力。其指令集简洁高效，易于编程和维护，同时具有低功耗、小面积和低成本等优点，能够满足各种智能家居、智能家电、智能锁、个护产品、便携电源等领域的应用需求。
二、外设资源
航顺HK32F030M具有丰富的外设资源，包括多个定时器、PWM输出、输入捕捉、UART、SPI、I2C等通信接口，以及多个GPIO接口和中断控制器，可以满足各种嵌入式系统的需求。此外，航顺HK32F030M还内置了高速存储器和大容量Flash存储器，可以存储程序代码和数据，并支持在线编程和擦除操作。
三、开发工具
航顺HK32F030M提供丰富的开发资源和工具，包括开发板、编译器、调试器等，同时也提供完善的软件开发平台和操作系统支持，方便开发者进行开发和调试。此外，航顺还提供全面的技术支持和服务，帮助用户解决技术问题和优化系统设计。
四、可靠性
航顺HK32F030M采用先进的生产工艺和严格的质量控制，确保产品性能稳定与安全可靠。同时，航顺HK32F030M也具有高兼容性和可移植性，可以方便地与市场主流型号进行软硬件兼容。此外，航顺HK32F030M还通过一系列严格的质量控制和测试，确保产品的稳定性和可靠性。
五、性价比
航顺HK32F030M不仅具有高性能、高可靠性，同时也具有优秀的性价比。相比其他同类型产品，航顺HK32F030M具有更优的价格和更丰富的外设资源，可以为用户提供更经济的解决方案。此外，航顺还提供周到的售后服务和技术支持，帮助用户解决各种问题，提高产品的可靠性和稳定性。
航顺HK32F030M是一款基于ARM Cortex-M0内核的32位微控制器，具有高性能、低功耗、经济适用等特点，能够满足各种智能家居、智能家电、智能锁、个护产品、便携电源等领域的应用需求。
其特点如下：
航顺HK32F030M使用ARM Cortex-M0内核，最高工作频率为32 MHz。
内置16 KByte Flash、448 Byte EEPROM和2 KByte SRAM，可通过配置Flash控制器寄存器实现中断向量在16 KByte空间内的重映射。
除电源、地以外的所有引脚都可以作为GPIO、外设IO或外部中断输入，在引脚数量受限应用场景中，提供了尽可能多的引脚信号数量。
内置了多种通信接口，包括1路高速(最高4 Mbit/s)USART、1路高速(最高16 Mbit/s)SPI/I2S、1路高速(最高1 MHz)I2C。
内置了1个16位高级PWM定时器（共4路PWM输出，其中3路带死区互补输出）、1个16位通用PWM定时器（共4路PWM输出）和1个16位基本定时器（定时输出CPU中断）。
内置了模拟电路，包括1个12位1MSPS ADC（有效精度8位）、1个上/下电复位电路（POR/PDR）和1。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/191f394296c53662aef9c80223975845/" rel="bookmark">
			在vite中如何解决跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章主要说明在vite中如何解决跨域问题，相信你看完这篇文章会有更深的理解。
产生原因 当你看到下图这个爆红的时候，就说明你遇到了跨域问题，如下图：
相信有很多人刚开始跟我一样担心跨域会很复杂，咱们不妨先看看跨域产生的原因。跨域问题是由浏览器的同源策略引起的，当你发送请求的源（协议，域名，端口号）跟目标服务器的源存在差异时就会产生跨域问题。
看完原因咱们就知道了是源的差异导致了跨域问题，那消除差异不就能解决跨域问题，下面咱们来消除源的差异。
解决办法 在使用vite创建项目的时候会产生一个vite.config.js配置文件，在vite.config.js的defineConfig中添加代理，添加如下代码：
server: { proxy: { '^/api': { target: '协议地址端口', //目标源，目标服务器，真实请求地址 changeOrigin: true, //支持跨域 rewrite: (path) =&gt; path.replace(/^\/api/, "/api"), //重写真实路径,替换/api } } } 其中 '^/api' 的作用是，当读取到本地请求路径（可以理解为通过axios发送请求时的baseURL）中的 /api 时 ，将其转化为target中的目标源，changeOrigin:true 表示支持跨域，rewrite是根据真实路径重写处理之后的，api路径，如果真实请求路径的目标源后面有api，咱们也添加上api，如果有其他东西，同理进行添加，确保代理之后的请求地址与真实请求地址一致，这样问题就得到解决了。
个人思考 有个伏笔就是跨域问题是由于浏览器的同源策略导致，那么服务器与服务器之间就不受这个影响，咱们不使用代理之前，请求到底发送出去了吗。实际是发送出去了，并且服务器将结果返回到浏览器了，但是咱们的请求不同源，浏览器就不把结果给我们，通过代理来告诉浏览器同源了，浏览器才把数据给咱们，所以必须保证真实请求路径是准确的，这样才能拿到想要的数据。
打个比方吧，你对班主任讲语文老师想要期中考试的成绩单，班主任打印完成绩单了，现在班主任手里有成绩单了，但不能给你呀，等你再对班主任讲你是语文课代表的时候，班主任把成绩单给你了，当然无论你是不是真的语文课代表，你都通过语文老师赋予课代表这个身份拿到了成绩单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b03b8d68de34d3c03ba5b7ea1dbc30e6/" rel="bookmark">
			群辉nas看剧设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先打开NAS的后台页面，打开“控制面板”
然后依次点开“文件服务--SMB--高级设置”，在最小SMB协议后面的方框选择“SMB1"，然后点击”保存“按钮即可，这里这样设置的原因是因为还有很多旧设备只支持SMB1（我几年前的电视盒子就是这样，如果不在这里打开SMB1，就搜寻不到NAS），不过它有个弊端就是安全性不高，所以这也是现在微软官方宣布，以后的Windows系统不会再支持SMB1最大的原因。
设置NFS：NFS协议是一种分布式文件系统协议，我们在NAS上设定好以后，就可以直接访问并打开我们指定的内容了。它的优点是相对SMB传输效率高，并且也稳定，但是没有加密授权，所以安全性不高。
不过对于我们观影来说，对比上面的SMB，它可以外挂字幕，这对于我们观看没有字幕的原盘电影就非常有用了，还有一个就是它可以指定共享的文件夹，这个对于隐私什么的还是很方便。
群晖上设置好了，我们基本就成功了一大半，剩下的我们基本上打开电脑/手机/电视就可以直接观看了。
首先也是找到“控制面板--文件服务--NFS”，群晖的NFS默认是关闭的，我们这里需要勾选并启用它，之后点击右下角的“应用”按钮。
然后接着点击控制面板中的“共享文件夹”，选中我们需要NFS共享的文件夹，然后依次选择“编辑--NFS权限--新增”，然后在弹出的“新增NFS规则”页面按照上图设置，完成后点击“保存”按钮。
然后就能在“NFS权限”下面看到我们刚刚添加的一条规则，并且一定要记下该页面下方的“装载路径”，因为我们在任何播放终端，只要选择了NFS协议，都会用到这个装载路径。
同理，你可以以NFS的形式共享其它的文件夹。到这里群晖NAS的NFS也设置完成了。
设置DLNA:这个是数字生活网络联盟的缩写，是由索尼 、 英特尔 、 微软等发起成立的一个非营利性的、合作性质的商业组织。太专业的东西我不知道，我们小白也没必要知道，简单的说，通过DLNA共享协议，我们只需要建立好索引，就能直接在各类终端上访问并读取了。
需要说明的是，通过DLNA共享协议，我们可以直接点开就能使用，不需要任何密码。所以大家在使用的时候需要注意安全问题。不过它有个优点，和NFS一样，也是可以自由设定我们共享的文件夹。
群晖NAS默认只是将“photo""music""video"这三个文件夹共享出来了，所以我们需要在”控制面板--索引服务“中添加更多的文件夹。直接点击”索引文件夹--新增“
完成之后在接下来的页面点击”保存“按钮。
到这里，群晖上的设置基本完成了。
安卓或者鸿蒙用户，直接使用【VLC】APP，免费又好用。按照上图的顺序也是可以轻松的获取NAS里面的内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89de705358ea87f6c56f4434baf36f2d/" rel="bookmark">
			面向对象pygame2048小游戏&#43;源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.2048介绍 2048是一款数字拼图游戏，游戏的目标是通过在方格中滑动相同数字的方块，使它们合并成更大的数字方块，最终达到2048这个数字。每次滑动都会导致所有的方块朝滑动的方向移动，没有空间移动或合并时游戏结束。这款游戏简单而富有挑战性，需要智力和策略来达到更高的分数。
游戏规则：
1. 在4乘4的方格上，每移动一步会随机在空位出现2或4；
2. 相同的数字碰撞可以合成两倍的数字；
3. 游戏的最终目的是合成2048这个数字。
话不多说直接上源码。（注意同级文件夹需要自己添加图片和字体然后才可以运行）
2.python源码 import sys import pygame import random colors = { 2: (238, 228, 218), 4: (237, 224, 200), 8: (242, 177, 121), 16: (245, 149, 99), 32: (246, 124, 95), 64: (246, 94, 59), 128: (237, 207, 114), 256: (237, 204, 97), 512: (237, 200, 80), 1024: (237, 197, 63), 2048: (237, 194, 46), } class Util: """ 工具类 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89de705358ea87f6c56f4434baf36f2d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a52f3b9faba1c9289edd75a0d29bb16/" rel="bookmark">
			ubuntu搭建telnet服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ubuntu搭建telnet服务 - 知乎
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f933ebec221a5b6320aa9c047c6a56/" rel="bookmark">
			ubuntu linux开启telnet服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		telnet是一种用于远程控制连接的应用层协议，可以使拥有服务器特权权限的用户在远程服务器上运行终端程序并进行文件传输等操作。如想在Linux系统上安装Telnet服务，应当搭建Telnet客户端和Telnet服务器，具体步骤如下：
#### 1、服务的安装
安装Telnet服务的第一步是在Linux服务器上安装Xinetd程序。Xinetd是一个网络服务守护进程，它支持众多的TCP/IP协议，其中包括Telnet服务。如果你的系统中没有Xinetd，首先要安装它，请在终端中输入下面的命令：
`sudo apt-get install xinetd`
#### 2、配置Telnet服务
在安装完Xinetd后，我们可以在/etc/xinetd.d/下看到有用来配置Telnet服务的 telnet 文件，我们可以使用vi（或者你能完成这一工作的任何其他编辑器）打开该文件并编辑 Telnet 服务参数。
`vi /etc/xinetd.d/telnet`
打开文件后，应将其中的 ‘ disable = yes’ 改成 ‘ disable = no’ ，这样服务就会被激活。
#### 3、重载Xinetd
为了使修改生效，我们需要重启 Xinetd，这样才能在端口 23 上开发 Telnet 服务。
`sudo /etc/init.d/xinetd reload`
#### 4、验证
可以使用 telnet 命令在本机上验证Telnet服务是否开启。
`telnet localhost`
如果出现用户登录界面，说明 Telnet 服务开启成功。此时可以使用Telnet登录Linux系统，输入用户名和密码进行登录，就可以在远程机器上执行操作了。
经过以上四个步骤，我们就可以成功安装Telnet服务，使服务器可以接受远端的Telnet连接。Telnet不仅仅可以进行远程连接，也可用于系统调试，网络管理，修改配置文件等操作，是日常系统维护的重要工具。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f55e1ad2411446399741f3f368c850e/" rel="bookmark">
			【LangChain】Memory
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概要 大多数LLM应用都有对话界面。对话的一个重要组成部分是能够引用对话中先前介绍的信息。至少，对话系统应该能够直接访问过去消息的某些窗口。更复杂的系统需要有一个不断更新的世界模型，这使得它能够执行诸如维护有关实体及其关系的信息之类的事情。
我们将这种存储过去交互信息的能力称为“记忆”。 LangChain 提供了许多用于向系统添加记忆的实用程序。这些实用程序可以单独使用，也可以无缝地合并到链中。
记忆系统需要支持两个基本操作：读和写。回想一下，每个链都定义了一些需要某些输入的核心执行逻辑。其中一些输入直接来自用户，但其中一些输入可以来自用户。在给定的运行中，一条链将与其记忆系统交互两次。
在收到初始用户输入之后但在执行核心逻辑之前，链将从其记忆系统中读取并增加用户输入。
在执行核心逻辑之后但在返回答案之前，链会将当前运行的输入和输出写入记忆，以便在将来的运行中引用它们。
将记忆构建到系统中 任何记忆系统中的两个核心设计决策是：
状态如何存储如何查询状态 存储：聊天消息列表(Storing: List of chat messages) 任何记忆的基础都是所有聊天交互的历史记录。即使这些不全部直接使用，也需要以某种形式存储。
LangChain记忆模块的关键部分之一就是用于存储这些聊天消息的一系列集成，从记忆列表到持久数据库。
聊天消息存储：如何使用聊天消息以及提供的各种集成
查询：聊天消息之上的数据结构和算法（Querying: Data structures and algorithms on top of chat messages） 保留聊天消息列表相当简单。不太直接的是建立在聊天消息之上的数据结构和算法，它们提供了最有用的消息的视图。
一个非常简单的记忆系统可能只返回每次运行的最新消息。稍微复杂一点的记忆系统可能会返回过去 K 条消息的简洁摘要。更复杂的系统可能会从存储的消息中提取实体，并且仅返回有关当前运行中引用的实体的信息。
每个应用程序对于如何查询记忆可能有不同的要求。记忆模块应该可以轻松地开始使用简单的记忆系统，并在需要时编写您自己的自定义系统。
记忆类型：构成LangChain支持的记忆类型的各种数据结构和算法
开始使用 我们来看看LangChain中的记忆到底是什么样子的。在这里，我们将介绍与任意记忆类交互的基础知识。
我们来看看如何在链中使用ConversationBufferMemory。 ConversationBufferMemory 是一种极其简单的内存形式，它仅将聊天消息列表保存在缓冲区中并将其传递到提示模板中。
from langchain.memory import ConversationBufferMemory memory = ConversationBufferMemory() memory.chat_memory.add_user_message("hi!") memory.chat_memory.add_ai_message("whats up?") 从memory中返回哪些变量(What variables get returned from memory) 在进入链之前，从内存中读取各种变量。它有特定的名称，需要与链期望的变量保持一致。你可以通过调用memory.load_memory_variables({})来查看这些变量是什么。
请注意，我们传入的空字典只是实际变量的占位符。如果您使用的memory类型取决于输入变量，您可能需要传入一些变量。
memory.load_memory_variables({}) 结果：
{'chat_history': "Human: hi!\nAI: whats up?"} 在本例中，您可以看到 load_memory_variables 返回单个key: history。这意味着您的链（可能还有您的提示）期望输入名为：history的key。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f55e1ad2411446399741f3f368c850e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e90e378150bdf6add66aacb358c17df/" rel="bookmark">
			java.sql.SQLRecoverableException: Io 异常: Undefined Error
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错图片： 报错原因： 本机计算机用户的名字是中文的，如果不修改计算机用户的名字，可以修改VM options。
具体操作： 1.打开编辑配置
2.VM options设置 -Duser.name=user
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57ad3b671e1c36adfc60e686100e990e/" rel="bookmark">
			Sql Server常用命令整理篇：修改表字段属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在数据库表中有大量数据的时候，无法修改数据的字段的长度
ALTER TABLE tableName ALTER COLUMN columnName decimal(7,1) not null; 可以通过sql server设置进行调整
修改主键的属性方法，先取消列的主键，然后修改字段记得加上not null，然后通过sql添加主键，key1、key2属性为 not null即不能勾选允许为空
ALTER TABLE 表名 ADD CONSTRAINT PK_主键名称 PRIMARY KEY (列名1,列名2) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4bc4efb82813d7300c0b1242475b47/" rel="bookmark">
			在传奇游戏界面添加或删除自定义功能按钮
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本教程是以HERO引擎和非凡登录器(原猎鹰登录器)为例进行示范，其他引擎请自行进行测试，。
自定义功能按钮就是在游戏界面中处于小地图，组队等按钮上面的一排可自定义进行功能设置的按钮，如图中所示，用方框选中的就是想要达到的效果。
以下是具体添加方法：
首先要下载下面我们给大家准备好的一个附件，Gameplan.wil，此附件便是那存放那些自定义功能按钮图片的文件。
用WIL编辑器打开该文件，然后就会看到存放的按钮图片，具体图片编号为72——91，每两张图片为一个按钮，分别代表"未按下状态"和"按下状态"时按钮的样子。
所以这20张图片理论可以添加10个自定义功能按钮，但是，从我的测试中最多却只能添加6个按钮，至于6个以后为何添加不上还有待本人继续学习。
也有可能是引擎不支持，如果大家有知道如何添加6个以上的，欢迎在论坛或在文章下面回帖。
如图中所示，选中的蓝色区域即是自定义功能按钮的图片位置。从72号图片开始，每相临的两个图片为一组，图片的样子可修改成自己想要的样子。
图片按钮弄好了，接下来就是功能的添加。
找到引擎M2如下路径：查看-&gt;列表信息-&gt;其他设置-&gt;用户命令自定义，这里便是功能实现的接口。
首先在“命令名称”栏里写上"功能1"，注意，这里必须填写"功能1"这几个字符，不能修改。然后“命令编号”栏里填1，这里的数字可以修改，如果你以前已经添加过其他的自定义命令，那避免重复可填写其他数字。
然后打开版本服务端文件的下列路径：D:\MirServer\Mir200\Envir\market_def，在其下找到QFunction-0.txt文件，打开。
然后按如下格式开始添加功能，
[@usercmd1]
#IF
#ACT
你要实现的功能
这里“usercmd”后面的“1”就对应上面我们在用户命令自定义里“命令编号”那里填写的“1”，如果你的是其他数字，就必成相应数字，一定要对应。
如此方法分别添加"功能2"对应编号2................想要添加几个就添加几个。
然后，在D:\MirServer\Mir200\Envir\market_def下找到QFunction-0.txt文件。打开后添加下面脚本：
"功能2"按钮对应脚本：
[@usercmd2]
#IF
#ACT
你要实现的功能
"功能3"按钮对应脚本：
[@usercmd3]
#IF
#ACT
你要实现的功能
在添加的时候一定要先看看你的QFunction-0.txt里先前有没有[@usercmdX]，后面的编号是不是已经用过了，如果有正在使用的，那么将正在用的编号改为其他的，因为功能按钮的编号必须从1开始，其他的自定义命令要给该功能按钮让位
会遇到的问题基本都解决，大家有不懂的可以私信联系我，留下你们的问题和方式，我会回复大家。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c2725b737ea5b2d514c3e03d8b7ecd/" rel="bookmark">
			ThreadLocal的基本使用，以及它是如何保证线程安全
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.为什么会产生线程安全问题？
在多线程的环境当中，线程之间的变量它一般都是共享的。在堆中会维护共享的数据存储区域，这个区域数据为所有多个线程共享，能够访问并修改变量，所以多线程环境下，可能会存在线程安全问题。
2.使用ThreadLoacl实现线程隔离
ThreadLoacl会为当前线程维护一个变量副本，该变量副本只能被当前线程使用，其它线程无法访问该副本，因此能够解决线程安全问题。
ThreadLocal提供了三个常用方法，一个是set();添加变量；get()获取变量，以及remove()移除变量。
public class HostHolder { // 创建ThreadLocal，存放user对象 private ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;User&gt;(); public void setUser(User user) { // 调用set传入user对象 users.set(user); } public User getUser(){ // 调用get()获取user对象 return users.get(); } public void clearUser() { // 移除user对象 users.remove(); } } 上面的user对象，是我在项目中需要保护的资源，user对象存放的是用户的信息，为用户独享，所以需要保证线程安全。
3.ThreadLocal如何保证线程安全？
主要是用到了ThreadLoaclMap对象，这个对象是当前线程维护的变量副本，为当前线程共享。它是一个哈希表，维护了当前线程所有的ThreadLocal对象；hash表的key就是ThreadLocal对象的哈希值，value就是要存储的变量。具体如下图：
上述代码中，ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;User&gt;();
hash表的key就是 users对象的hash值，而value就是 users.set(user);方法传入的user对象。
set()方法源码如下：记住一个线程内ThreadLocalMap对象只有一个，初始为null，第一次往里添加元素时才初始化。
public void set(T value) { // 获取当前线程 Thread t = Thread.currentThread(); // 获取ThreadLocalMap对象 ThreadLocalMap map = getMap(t); // 因为ThreadLocalMap的对象初始为空，第一次添加元素时才会初始化 // 所以需要判空 if (map !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c2725b737ea5b2d514c3e03d8b7ecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62e3e746fcd96251a4b0162c0a599944/" rel="bookmark">
			Windows端口占用问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Windows端口占用问题 1、检查端口是否已被占用（端口举例：10000） 【Windows+R】打开【运行】窗口
点击【确定】打开【cmd】窗口
输入【下方命令】，然后【回车】
netstat -aon | find "10000" 可以看到端口【10000】已被进程【2912】占用
2、停止进程，解决端口被占用问题（端口举例：10000） 输入【下方命令】然后【回车】
taskkill -f -pid 2912 可以看到进程【2912】已经被停止，端口占用问题已解决
3、壁纸分享 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1e9a2233925db220ed7513134c49fd7/" rel="bookmark">
			成绩管理系统（java实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计一个成绩管理系统，要求完成以下功能：
（1）能按学期和班级完成对学生成绩的录入和修改
（2）能按班级统计学生的成绩，求学生的总成绩和平均分
（3）能根据学生的平均成绩进行排序
（4）能查询学生成绩和不及格科目
（5）能打印学生名单
（6）能按班级输出学生成绩单
import java.util.Scanner; class Student1 { String num; String name; int cla; int c1; int c2; int c3; int c4; int term; float aver; int sum; } public class StudentManagementSystem2 { private static final int MAX_STUDENTS = 80; private static Student[] stu = new Student[MAX_STUDENTS]; private static int numStudents = 0; public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int choice; do { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1e9a2233925db220ed7513134c49fd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed0dd7429057e9230b0b3744a9a5ff25/" rel="bookmark">
			C# 连接Sql Server 数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		class DataBaseUtil{ static string dataSource = "server = 数据库地址; database=数据库表名;uid=用户;pwd=密码";//数据库连接字符串 public static SqlConnection GetConnection() { SqlConnection conn = new SqlConnection(dataSource); try { conn.Open(); } catch (Exception e) {throw;} return conn; } public static DataTable Query(string sql) { DataTable dt = new DataTable(); SqlConnection sqlConnection = GetConnection(); try { SqlDataAdapter sqlDataAdapter = new SqlDataAdapter(sql, sqlConnection); sqlDataAdapter.Fill(dt); } catch (Exception e) { throw; } finally { sqlConnection.Close(); } return dt; } public static int UpDate(string sql) { int i = 0; SqlConnection sqlConnection = GetConnection(); SqlTransaction sqlTransaction = sqlConnection.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed0dd7429057e9230b0b3744a9a5ff25/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/120/">«</a>
	<span class="pagination__item pagination__item--current">121/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/122/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>