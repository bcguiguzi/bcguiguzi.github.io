<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927034c5323f9296ae6fd60f2ac35807/" rel="bookmark">
			MATLAB与Arcgis技术层面实现城市灯光中心转移可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MATLAB实现夜间灯光数据的灯光中心获取 普遍来说，城市中心被认为是与周边地区相比，拥有较高人口密度、就业规模和经济聚集度的城市区域（Giuliano and Small，1991），是一座城市经济文明的聚集区，是各种社会经济要素在空间上集聚的结果。总的来说，城市中心就是人类活动比周围都要活跃的城市区域（Tammaru，2001），表现在夜间灯光影像上就是高值像元（Chen et al.，2017），即在一定的城市空间范围内，该像元的夜间灯光亮度值比周围的所有像元都要大[6]。
目前大尺度空间的城市中心区域空间边界的确定主要依靠统一的阈值方法，下述方法提取的是中心点[6]。（值得注意的是，根据生活经验来说，独立工厂通常也具有较大的光亮值并且其通常可能被误提取为中心）
（一）MATLAB代码
由于遥感影像本身具备图像值矩阵与坐标元素结构体两部分的复杂性以及研究区四周几乎不存在中心出现的可能性，暂不考虑边界像素的遍历问题，多次采用不同边长方形核实验后，采用25*25核进行遍历。
%获取文件绝对路径 File = 'D:\matlab\code\Plight\20202.tif'; %本处提供核大小更改交互（仅支持奇数边长方形核） len = input('请输入奇数边方形核边长：'); ck = (len-1)/2; %读取tiff文件的影像矩阵与坐标系文件 [A,R] = geotiffread(File); %获取投影坐标系 info = geotiffinfo('D:\matlab\code\Plight\20202.tif'); [r,c] = size(A); %创建一个与影像矩阵同大小的outPut矩阵 outPut = ones(size(A)); %将output矩阵值全赋为-1，避免与原数据相减时误提取灯光中心 outputR = outPut .*(-1); %处理过程 for i = (ck+1):(r-ck) for j = (ck+1):(c-ck) MatC = A((i-ck):(i+ck),(j-ck):(j+ck)); MatMax = max(MatC(:)); for k = (i-ck):(i+ck) for l = (j-ck):(j+ck) outputR(k,l) = MatMax; end end end end %输出图像 fprintf('数据处理完毕，正在导出！\n'); geotiffwrite('centralLight2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/927034c5323f9296ae6fd60f2ac35807/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/359e1f2afc56a843e491e0580661308f/" rel="bookmark">
			JSON字符串与List集合相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JSON字符串与List集合相互转换 场景:
JSON字符串转List集合与List集合转JSON字符串
使用的jar包是fastjson-1.2.41.jar
1.JSON字符串转List集合操作
public static &lt;T&gt; List&lt;T&gt; parseArray(String text, Class&lt;T&gt; clazz) { try { return JSON.parseArray(text, clazz); } catch (Exception e) { } return Collections.emptyList(); } 2.List集合转JSON字符串操作
public static String toJSONString2(Object obj) { JSONArray jsonObj = (JSONArray) JSONArray.toJSON(obj); return jsonObj.toJSONString(); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f21889e3271ab7025dc0b6a62ed5097/" rel="bookmark">
			树莓派中将可执行文件变成命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步，写一个hello world的程序，通过gcc hello.c -o hello ，生成hello的可执行文件
第二步，在自己用户的家目录下（cd ~） ,然后vi .bashrc ,在最后面添加上
alias hello='hello的目录'
第三步，source .bashrc ，重新加载一下
接着再命令行输入hello就能看到hello world了。
（这种方法切换用户后就不行了）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/779f23687819c823792f84c9eaf95954/" rel="bookmark">
			windows电脑如何设置定时关机？电脑设置定时关机的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在使用电脑时可以为电脑设置一个定时关机，既省时又省力，那么具体应该如何操作呢？
第一种方法——创建任务计划程序 1、点击“开始”，在搜索框内输入“任务计划程序”。
2、进入任务计划程序界面点击右侧的“创建基本任务”，在弹出对话框的名称一栏输入“定时关机”，然后点击下一步。
3、在触发器设置界面可以根据需要选择“每天”、“每周”等，以“每日”为例，用户可以选择关机的具体时间。
4、设置好时间后点击下一步会出现对话框，点击“浏览”，找到 C:\Windows\System32\shutdown.exe，在添加参数选项后输入 -s（关机命令），之后点击“下一步”，再点击“确定”即可。
第二种方法——电脑的运行窗口 按住“win+r”组合键打开电脑的运行窗口，在运行框内输入 shutdown-s＋关机的时间，如 shutdown-s7200 表示两个小时后关机，7200 的单位是秒。如果用户想取消定时关机，需要打开运行对话框输入 shutdown-a。
第三种方法——定时关机3000 用户如果觉得上述方法比较麻烦，可以下载夏冰加密软件研发的定时关机3000，软件支持包括关机、重启、注销等在内的14种定时任务，同时还可设置11种执行条件。
在定时关机界面点击“添加任务”，即可在弹窗中设置需要执行的任务以及条件。
软件还拥有“电脑管理”功能，可以禁止电脑打开指定程序或窗口。
同时还支持“时间限制”，即在指定时间段内禁止使用电脑或网络。
夏冰加密软件官网：文件加密-文件夹加密-U盘移动硬盘加密-夏冰加密软件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cbc63884cf4f30192d353e90d036c13/" rel="bookmark">
			Mybatis Plus @TableId(value = “id“,type = IdType.AUTO) 自增无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 提示：学习Mybatis plus：
@TableId(value = "id",type = IdType.AUTO) private Integer id; 设置id 自增，使用insert 发现报错
Cause: org.h2.jdbc.JdbcSQLIntegrityConstraintViolationException: NULL not allowed for column "ID";
原因 未知
解决方案： 提示：创建表的时候设置上 表自增：
AUTO_INCREMENT
CREATE TABLE user ( id INT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id) ); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/362611d7c5e3b08d9c6c4fb33daabce5/" rel="bookmark">
			【element】el-carousel走马灯一个页面放多个元素展示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【element】el-carousel走马灯一个页面放多个元素展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96c9da61c555ca8200c6832e20459088/" rel="bookmark">
			学术写作科研工具推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在写论文，然后过程中觉得一些工具可以提升效率，所以就简单总结一下，以后也会逐渐更新
Ccf deadlines：我该赶哪个ddl呢？
一些主要ccf A、B、C类会议的截稿日期都会被统计显示在此哦，看看你想投哪个会吧~IEEE Trans 模板选择器：如果你想投IEEE Trans期刊，可以到这里找到合适的Latex Templets哦Overleaf：论文就要大家一起写~
可以在线编辑Latex文章，最主要的功能是可以很便利的将自己的project分享给别人，当需要师兄或者老师帮忙改论文的时候，或者多人合作写论文的时候，用来协作很方便。TexStudio：做一个写论文的强迫症孤狼！（官网打不开就进链接2）
为什么有了overleaf还要安装TexStudio呢？这是因为overleaf采用的编译方式是远程请求服务，所以交互会有延迟，对于我这种修改两个字就想看看成文效果的强迫症患者，使用本地编译的TexStudio会更加方便，当然了，你也可以先在本地使用TexStudio写初稿，然后再将project打包上传overleaf，然后共享给他人。Google Translate：谷歌翻译——你的论文是我写的！
新手写论文一般要先用中文构思（毕竟是母语），我的写法是先用中文写，然后翻译，之后再修改英文并实时查看对应的中文翻译结果，因为审稿人可能就是翻译给你审的哦hhhh（定语从句、状语从句巴拉巴拉）。DeepL：我自称全世界最准确的翻译CopyTranslater：Copy and Translate
开启监听剪贴板就可以复制实时翻译哦，在写introduction的时候可以用它来快速阅读论文。Connected papers：我帮你查询论文之间的关联~
Explore connected papers in a visual graph， 可视化相关论文之间的引用关联情况，用来写intro和background哦。Typora：Latex公式笔记小能手
用它记笔记很方便哦，我是先使用typora写一个大纲，并且大致写一些公式（类似草稿），然后再往paper tex里写，这样就不会把论文写的乱七八糟哦。Latexlive ：什么？你不知道公式用latex怎么写？快来找我
支持类似World的公式编辑方法，生成对应的 latex code，新手对latex公式不熟练可以把它当字典用哦。Table Generator：从Excel到Latex table
可以将实验数据放在Excel中记录，然后复制到Table Generator，实现一键Latex表格代码生成。Pitaya：我免费帮你改语法错误哦~Grammly：我免费改错，润色收费哈
可以结合两个纠错平台共同参考使用。wordtune：这句话我为你润色了好几个版本，挑一个合适的吧QuillBot：我也是英文润色大师哦Linggle：当你不明确如何用英语表达一件事的时候，来找我Netspeak：上一个人会的我也会，选我！Draw.io：画图可以试试我哦，支持Latex公式Flaticon：我是一个很好用的 icon 图标网站，用来画图不错哦Thenounproject：我发誓，没人比我更懂 icons ！Texworks：双屏写论文神器
为什么有了overleaf和TexStudio还要单独使用Texworks呢？因为Texworks的编译之后的pdf和latex源文件编辑界面是分两个窗口显示的，这就意味着你可以在双屏条件下，左源码，右pdf实时交互，而且由于全屏显示源码界面和pdf界面，会很清晰。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80b06e817ba5c8885073950343f30d50/" rel="bookmark">
			Ansible中的角色使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
ansible 角色简介
创建目录结构
role存放的路径在配置文件ansible.cfg中定义
例：vsftpd的安装和部署
ansible—galaxy命令工具
安装网络源
install local roles 安装本地roles
ansible 角色简介 *Ansible roles 是为了层次化，结构化的组织Playbook
* roles就是通过分别将变量、文件、任务、模块及处理器放置于单独的目录中，并可以便捷地include它们
* roles一般用于基于主机构建服务的场景中，在企业复杂业务场景中应用的频率很高
* 以特定的层级目录结构进行组织的tasks、variables、handlers、templates、files等；相当于函数的调用把各个功能切割 成片段来执行。
创建目录结构 ansible-galaxy init apache ansible-galaxy list
role存放的路径在配置文件ansible.cfg中定义 roles_path = ~/.ansible/westos （默认目录：/etc/ansible/roles）
roles目录结构
files
存放copy或script等模块调用的函数
tasks
定义各种task，要有main.yml，其他文件include包含调用
handlers
定义各种handlers，要有main.yml，其他文件include包含调用
vars
定义variables，要有main.yml，其他文件include包含调用
templates
存储由template模块调用的模板文本
meta
定义当前角色的特殊设定及其依赖关系，要有main.yml的文件
defaults 要有main.yml的文 件，用于设定默认变量
tests
用于测试角色
例：vsftpd的安装和部署 配置文件中的内容
tasks/main.yml
vars/main.yml
handlers/main.yml
templates/vsftpd.conf.j2
ansible—galaxy命令工具 * Ansible Galaxy 是一个免费共享和下载 Ansible 角色的网站，可以帮助我们更好的定义和学习roles。
* ansible-galaxy命令默认与https://galaxy.ansible.com网站API通信，可以查找、下载各种社区开发的 Ansible 角色
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80b06e817ba5c8885073950343f30d50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c629ff8d164fdbc3f2360e2b17be1c/" rel="bookmark">
			@Test单元测试注入bean 3种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. @ContextConfiguration @ContextConfiguration Spring整合JUnit4测试时，使用注解引入多个配置文件
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = {CachingConfig.class})
如下：
@Resource
private CacheManager cacheManager;
是CachingConfig的bean
@RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes = {CachingConfig.class}) public class ExampleBeanTest { private ExampleBean exampleBeanUnderTest; @Resource private CacheManager cacheManager; @Before public void setUp() { exampleBeanUnderTest = new ExampleBean(); } } 2. @SpringBootTest 在类上添加以下代码：
@RunWith(SpringRunner.class) @SpringBootTest(classes = {项目启动类.class}) 在执行test之前会先执行启动项目，后对象会被注入到单元测试所在类中
3. @Before private ExampleBean exampleBeanUnderTest;
@Before
public void setUp() {
exampleBeanUnderTest = new ExampleBean();
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e83021a43be6d7dfd35e75e4f8d7613e/" rel="bookmark">
			QT之多个界面相互切换 (stackedWidget控件)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		stackedWidget控件： 可以自由在多个widget切换，可以通过点击顶部菜单，显示不同界面，在实际开发中应用很广泛。
1. 添加控件， 在设计界面左侧添加 stackedWidget控件
2. 增加几个 widget 界面
3. 将这几个 widget 插入到 stackedWidget
首先定义 一个枚举量， 存放每个界面的编号
enum eStackedWidgetID{eForm1 = 0,eForm2,eForm3}; // 页码编号 在添加时候，建议用 insertWidget 而不用 addWidget，这样在切换界面时候不容易出错，调整顺序和增加新界面时候， 只需修改上面的枚举，其他不用修改。
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow) { ui-&gt;setupUi(this); m_form1 = new Form1(this); m_form2 = new Form2(this); m_form3 = new Form3(this); ui-&gt;stackedWidget-&gt;insertWidget(eForm1,m_form1); ui-&gt;stackedWidget-&gt;insertWidget(eForm2,m_form2); ui-&gt;stackedWidget-&gt;insertWidget(eForm3,m_form3); ui-&gt;stackedWidget-&gt;setCurrentIndex(eForm1); } MainWindow::~MainWindow() { delete ui; } void MainWindow::on_pushButton_clicked() { ui-&gt;stackedWidget-&gt;setCurrentIndex(eForm1); } void MainWindow::on_pushButton_2_clicked() { ui-&gt;stackedWidget-&gt;setCurrentIndex(eForm2); } void MainWindow::on_pushButton_3_clicked() { ui-&gt;stackedWidget-&gt;setCurrentIndex(eForm3); } 界面效果就不展示了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7415ab8b12153fed89abde88d82a97f/" rel="bookmark">
			MySQL-数据库事务详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、事务的ACID特性
二、事务的状态
三、使用事务
3.1、事务完成的过程
3.2、显示事务
3.3、隐式事务
3.4、事务隔离级别
3.4.1、事务问题
3.4.2 SQL的隔离级别
四、事务日志
4.1、redo 日志
4.2、undo日志
一、事务的ACID特性 原子性：事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚；基础。一致性：数据从一个合法性变化成另一个合法性，这种状态是指语义上的，跟业务要求有关，需要满足约束，例如转账时超出总额；手段。隔离性：一个事务执行时不能被其他事务干扰，使用的数据对于其他并发的事务是隔离的，并发执行的各个事务之间不能互相干扰；约束条件。持久性：一个事务一旦提交，它对数据库中数据的改变是永久的，接下来的数据操作和故障不应该对其有任何影响。目的。 二、事务的状态 活动的：事务对应的数据库操作正在执行过程中时；部分提交的：事务中的最后一个操作执行完成，但由于操作是在内存中执行的，所造成的影响并没有刷新到磁盘时，此时的状态为部分提交状态；失败的：事务处于活动的或者部分提交的状态时，可能遇到某些错误无法继续执行，此时为失败的状态；中止的：事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。回滚完成时的状态；提交的：部分提交的数据修改持久化到磁盘上。 三、使用事务 3.1、事务完成的过程 步骤一：开启事务
步骤二：一系列的DML操作
步骤三：事务结束的状态：提交的状态(COMMIT）、中止的状态(ROLLBACK)
3.2、显示事务 步骤一：开启 使用关键字：start transaction 或 begin
start transation 后面可以跟：read only / read write (默认) / with consistent snapshot（启动一致性读）
步骤二：保存点
3.3、隐式事务 autocommit:是否自动提交
3.4、事务隔离级别 多个请求分布在不同事务中，可能同时请求更改一条数据，这时需要一种机制权衡并发性和隔离性。
3.4.1、事务问题 脏写：一个事务A修改B未提交事务，此时B回滚，A修改的数据是无效的； 脏读：事务A读到了B未提交的事务，之后B回滚，A读取的内容是临时且无效的； 不可重复读：事务A读取一个字段，事务B更新一个字段，之后A再读同一个字段，值不同； 幻读：事务A从表中读取一个字段，事务B插入一些行，A再读同一个表就会多出几行； 3.4.2 SQL的隔离级别 mysql默认是可重复度隔离级别。
# 查看隔离级别 show variables like 'tx_isolation'; show variables like 'transaction_isolation'; # 设置隔离级别 set [global|session] transaction isolation level 隔离级别; set [global|session] transaction_isolation ='隔离级别' # 中划线链接 四、事务日志 实现事务特性的机制。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7415ab8b12153fed89abde88d82a97f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67d7075ecc29dd0b066dcfe51fc4d270/" rel="bookmark">
			Android启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安卓的启动流程 安卓的启动流程大致分为几个阶段。
1、BootRom：启动电源以及系统启动。
当电源按下时，引导芯片代码从预定义的地方（固化在ROM中）开始执行。加载引导程序BootLoader到RAM，然后执行。
2、引导程序Bootloader
引导程序BootLoader是在android操作系统开始运行前的一个小程序，他的主要作用是把系统OS拉起来并运行。
3、Linux kernel启动
当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当内核完成系统设置时，它首先在系统文件中寻找init.rc文件，并启动init进程。
4、init进程启动
初始化和启动属性服务，并且启动Zygote进程。
5、Zygote进程启动
创建Java虚拟机并为Java虚拟机注册JNI方法，创建服务器端Socket，启动SystemServer进程。
6、systemserver进程启动
启动Binder线程池和SystemServiceManager，并且启动各种系统服务。
7、Launcher进程启动
被SystemServer进程启动的AMS会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到界面上。
下面介绍安卓世界的启动流程即从init进程开始讲起。
init进程的启动 首先Bootloader引导程序启动完Linux内核后，会加载各种驱动和数据结构，当有了驱动以后，开始启动Android系统，同时会加载用户级别的第一个进程init。启动该进程首先进入到system/core/init/目录下的main.cpp文件中，执行main方法。
51 int main(int argc, char** argv) { 52 #if __has_feature(address_sanitizer) 53 __asan_set_error_report_callback(AsanReportCallback); 54 #endif 55 // Boost prio which will be restored later 56 setpriority(PRIO_PROCESS, 0, -20); 57 if (!strcmp(basename(argv[0]), "ueventd")) { 58 return ueventd_main(argc, argv); 59 } 60 61 if (argc &gt; 1) { 62 if (!strcmp(argv[1], "subcontext")) { 63 android::base::InitLogging(argv, &amp;android::base::KernelLogger); 64 const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); 65 66 return SubcontextMain(argc, argv, &amp;function_map); 67 } 68 69 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67d7075ecc29dd0b066dcfe51fc4d270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11324ca557e6c60cecb0aeccffa443b0/" rel="bookmark">
			H5跳转微信公众号解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.适用场景 适用H5跳转公众号的场景
2.跳转方案 微信内H5跳转 微信内可链接直接跳转公众号关注页。
登陆微信公众平台，F12打开浏览器控制台console输入wx.commonData.data.uin_base64
https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=上方步骤输出的内容#wechat_redirect
该链接可直接在微信内进入公众号关注页（非公众号客户端不支持）。
微信外部H5跳转 微信外部浏览器无法链接直接打开公众号。
可采用 H5页面——&gt;唤起微信小程序——&gt;小程序引导页——&gt;公众号客服的跳转流程。
申请企业认证小程序后，对接小程序跳转能力
官方提供了几种跳转能力，推荐使用urlLink，获取到https跳转链接，兼容性更好。
接口可直接返回跳转链接，但是每个链接只能一个用户使用，有效期最长30天，可结合redis缓存实现。
h5页面点击直接跳转小程序链接，将唤起微信公众号小程序，
小程序页面展示微信公众号关注引导页面，用户点击直接进入公众号。可在公众号发布一篇推文，插入公众号名片二维码等元素，使用小程序web-view组件展示，快速实现引导页。
用户可通过点击公众号蓝色字体，公众号名片或扫码进入公众号。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/809533678bdf5f71da063e2d7904f250/" rel="bookmark">
			ECharts设置x轴刻度间隔的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECharts设置x轴刻度文字间隔的两种方法 背景 最近在写一个echarts数据看板，要在一个页面中展示多张图表，所以留给每张图表的尺寸就很小。这也就使得图表x轴的刻度文字全部挤到一起了，废话不多说，直接上图看效果。
右边的图标就是x轴刻度标签文字被挤到一起了，左边是该过之后的效果。
解决方法 想要达到上面图片中左边的效果方法不止一种。
最笨的方法 如果空间够的话直接将echart所在的div层尺寸设置得大一些，grid对象也同理，只要展示的空间足够宽，刻度标签自然就不会挤到一起。开个玩笑哈，能找到这类文章的，都是需要在有限的空间里解决间隔的问题
方法一: x轴的标签属性axisLabel下利用interval设置间隔
官方文档是这样说的：
通过设置interval的值，来达到按指定间隔显示或者不显示，或者使用回调函数，回调函数返回的布尔值决定指定索引的标签是否显示。这也是网上能找到的最普遍的答案，可惜没能解决我的问题。
官方文档上写的是在类目轴中有效，而我的x数据轴类型是“time”。所以只能再想其他方法
方法二： 为axisLabel. formatters添加回调函数改变标签文字
formatters属性是用来设置文字格式的，既然可以用来设置文字格式，那我把需要隐藏的文字改为空字符串不就行了。
思路一通代码就简单了，先看看回调函数怎么用
官方文档上说函数有两个参数，一个是索引一个是值。注意，这里的索引并不是我们x轴数据的索引，而是图标刻度的索引。举个例子，我的数据集是每秒钟电表的读数，那么一个小时就是3600条，如果是数据集索引的话就应该是0到3599，实际上，我们从没看到过一个数据轴上有那么多刻度。
我们图表数据轴的标签数量是echarts在渲染的时候自动生成的，但是数量还真不好说而且即便是同一个图表不同时间也不一样，一般也就十来个。
来看一下我写的回调函数：
// 通过formatter设置时间刻度间隔 function time_label_formatter(value,index) { // console.info(index); let remainder = index % 3; if (remainder == 0) { return "{HH}:{mm}"; } else{ return ""; } } 我的时间类型数据在赋值给配置项数据集之前已经做过数据清洗，本身就是Date类型，所以没有在函数内再做数据转换
我先把所有的标签索引打印出来，发现是0到16，那么按照间隔设置为3或者4就好了。思路就是这样，看到这里的朋友可以根据自己的实际情况调整一个间隔数就可以了。
最后看一下配置项series参数：
xAxis:[ { type:"time", gridIndex:0, axisLabel： { rotate:-45, formatter:time_label_formatter }, }, { type:"time", gridIndex:1, axisLabel: { rotate:-45, formatter:time_label_formatter } } ], 先自我介绍一下，小编13年上师交大毕业，曾经在小公司待过，去过华为OPPO等大厂，18年进入阿里，直到现在。深知大多数初中级java工程师，想要升技能，往往是需要自己摸索成长或是报班学习，但对于培训机构动则近万元的学费，着实压力不小。自己不成体系的自学效率很低又漫长，而且容易碰到天花板技术停止不前。因此我收集了一份《java开发全套学习资料》送给大家，初衷也很简单，就是希望帮助到想自学又不知道该从何学起的朋友，同时减轻大家的负担。添加下方名片，即可获取全套学习资料哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410f76b044e8bad2ba1331373c78dcb0/" rel="bookmark">
			还在纠结报表工具的选型么？来看看这个
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据信息化的应用与项目中，通常都会遇到报表需求，数量少的，零星需要做的，可能手工就搞定了，数量多的，长期做的，基本都会选用一个报表工具，因为长期做，就必须考虑成本了，找一个称手的工具来降本增效是非常重要的
报表工具有那么多，那就得选型，选起来复杂就会纠结，选起来简单就没什么纠结的了
比如想选一台二手车，这事情就很复杂，很难，得找懂车的人来选，发动机功能好不好，漏不漏油，有没有出过事故，各部位的情况都得考察到才可以，还得了解价格行情，这样的选型就会很纠结，因为它选起来太复杂了，稍有不慎就可能花了冤枉钱了
再比如想选个手机，这事情就很简单，直接各电商旗舰店挑个看着顺眼的再看看价格是否可接受就可以了，这样的选型就没啥好纠结的，因为选起来很简单，功能都差不多，而价格也是公开透明的
报表工具的选型也一样，有纠结的时候，也有不纠结的时候
之前选型非常纠结 选型纠结是因为要对功能和价格之间做权衡，不能只看一样，怎样权衡是个难题，就会纠结
如果有个功能无穷好，价格无穷低的产品，那当然就不纠结了，但没有
比如开源，属于价格无穷低，但是功能很差劲，学起来用起来费劲不说，还有很多东西做不了，都得工程师手工再去开发，最后导致总成本反而更高
功能好的通常价格也贵，虽然说是物有所值，但仍然纠结，因为这功能是不是真用得上？用不上就白买了。项目有大有小有简单有复杂，都用功能好的，似乎也不划算，都用功能差的，又肯定有不满足的，给每个项目都匹配上一个功能正好的？这得费多大的时间成本才能做到呢，既需要仔细考察每个项目的需求，又需要去分析厂商每个版本的不同，而且万一没看准，项目需求有漏考察的或者变复杂了，再想换功能好的，这又得重新和厂商去谈判，技术加商务又得耗费一大把时间，这基本上没有可操作性，只好自己加大开发成本对付，而这又是常有的事，特别是性能相关的事并不容易事先考查清楚
何况还有价格不透明的问题，要在各厂商之间周旋博弈才能搞清真实价格。而且，这次能拿到的价格，下次就不一定了。如果谈长期合作锁定价格，谈判又很复杂，一是自己也不知道能有多少项目可以做，不能随意承诺，二是厂商也不愿意给个全包的价格，持续的从每个项目每个节点上创收才符合厂商的利益
今年用了，明年价格不合适了，想换都换不了了
总之，很难很纠结
了解润乾不再纠结 价怼开源 前面说到的选型困难和纠结，归根结底大部分都是因为价格造成的，价格高就怕选错，就得慎之又慎，价格不透明就怕选贵，就得耗费大量精力去做价格谈判，如果价格低一些，再透明一些，这些难题就会简单很多
现在好了，润乾报表实行互联网化营销了，价格低了，也透明了，本来润乾报表的功能也很好，这样选型的纠结就没有了润乾报表的功能好，这不需要证明，因为它已经有二十多年的历史了，早已是经历过无数用户选择并验证过的了
润乾报表的价格还接近无穷低，虽然不是0，但也接近了。本来价格就很低，还针对开发商推出的“工具版”，一年只需要3W就可以不限项目数，不限节点，不限用户的去使用润乾报表的最高版本！
相当于每年用不到一个工程师一个月的成本，就把润乾报表研发团队承包了，当成自己的报表研发部了， 所有项目都能享受最高最新功能，还能享受支持服务，也是爽歪歪了
再也不用费劲去给各个项目选择版本了，都用最高版本就OK了
润乾报表的价格体系还是透明的，对所有用户都公开透明，这就让交易变得简单，再也不用耗费巨大精力做商务谈判了，更不用担心以后项目多了厂商会趁机涨价了，因为3W一年的价格是固定的，无须承诺，自动长期锁定了
有了润乾报表的价格作为参考，即使是买别的工具，谈价格时候也就有底了，谈起来也就不难了
有这样公开透明的足够低的价格，选起来也就没什么纠结的了
质冠商用 价格清晰明了了，功能还不放心？那么我们再来漫游一下功能
功能全面易集成
润乾报表是标准的J2EE应用，非常易于集成，各类中国式复杂报表、统计图、DBD大屏、手机报表、数据填报采集、打印导出它都可以做，还支持各类数据源
各类中国式复杂报表
大屏
各类统计图
打印
各类数据源支持
润乾报表不仅仅是功能完整，而且…
开发效率高
买工具就是为了提升开发效率的，光能做出来还不行，还得做的快才可以，润乾报表对于复杂报表的开发效率在业界是公认的快的
润乾报表开发效率高在哪里，可以参考：
怎样考察报表工具的开发效率？
性能好
润乾报表性能好，更是一直以来在业界被公认的
润乾报表快在哪里，可以参考：
怎样提高报表呈现的性能
开源BI
说了很多功能和性能，其实大部分产品也还有个外观风格是不是顺眼匹配的问题？润乾报表这方面如何呢？
报表是个被集成的组件，向业务用户呈现报表也是程序员画的，想呈现出什么样的外观都没有问题，所以不存在这个问题
但和报表相关的BI却有这个问题，虽然说国内这些BI产品的功能都差不多，从这个方面上看也没什么好选的。但BI是一个界面为主的软件，各软件都有自己的外观风格和操作方式，这些是否和用户的系统匹配，是否符合用户的习惯呢，不匹配时能修改吗，改造难度有多大，这些确实还有选型的必要和意义，而且选起来可能更难，因为它比报表还贵，更少不了纠结了
而润乾报表又是个例外，它里面也有BI，但竟然直接开源免费了，数据功能都做好，外观想怎么改就怎么改，不用纠结外观匹配 ，更不用纠结价格了
其实润乾报表一直都是行业里选型标准的制定者，最开始润乾率先提出并解决了“中国式复杂报表”的制作难题，让选型人员知道，报表工具必须能做中国式复杂报表才可以，后来报表做起来简单了，但随着大数据时代的到来在数据准备阶段又总遇到问题，影响了开发效率，润乾报表又开发出了SPL计算层，让选型人员知道，报表数据准备阶段的难题，应该有个计算层来处理才会更好
润乾专注报表20年，20年前它的功能是各厂商模仿的对象，也是选型人员用来检验各产品功能的标尺
20年后，同样还是这样，功能照着润乾报表去选就行了，不用纠结了
总结 还是那句话，如果有个功能无穷好，价格无穷低的产品，那选型当然就不用纠结了
润乾报表就是接近这个理想的存在，它的功能接近无穷好，因为它一直是行业的功能标杆，它的价格也接近无穷低，因为它一年3W就可以不限数量、节点的去使用最高版本，平摊下来单套的成本可能都不过百
功能全面、低价透明的润乾，已经逐渐让大家都形成了一种共识：选报表，就按着润乾报表的功能和价格去选就行了，报表工具的选型，再也没什么好纠结的了
润乾报表资料 润乾报表官网润乾报表下载 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc3e0d25524ea33fe076f1dfe4886ad3/" rel="bookmark">
			【IDEA】报错：Package ‘java.lang‘ is declared in module ‘java.base‘, which is not in the module graph
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天初步学习idea的时候，跟随课程写了很多代码。写的过程中idea就一直在报错，报错情况如下：
Package 'java.lang' is declared in module 'java.base', which is not in the module graph
打开project目录，显示从初始文件夹开始就全部在报错。
后来经过老师提醒，该文件夹实际上是一个模块，没有放在一个工程中。
因此重新创建一个新的工程，再把这个文件夹放入工程文件夹中，重新打开，idea就停止报错了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d8499f5c0a414600988f2ba6e6aa7c8/" rel="bookmark">
			RabbitMQ多种问题出现的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		消息丢失 1、只要订单完成我们就会发送一条消息给MQ，这个途中突然MQ服务器网络中断，导致消息无法抵达
做好容错方法需要在消息发送前加上异常处理
try { rabbitTemplate.convertAndSend("order-event-exchange", "order.release.other", orderTo); } catch (Exception e) { //将没法送成功的消息进行重试发送 } 还可以将消息存入数据库，把失败的消息定期重新再发一遍
2、当消息发送给MQ，通过Brock通过交换机抵达队列，MQ关机了，只有抵达队列才能实现消息持久化
这时候需要使用生产者的确认机制
只要消息收到了会自动持久化，如果进入另一个回调方法说明报错了，需要修改数据库使消息重发
3、自动ACK的状态下。消费者收到消息，但没来得及消息然后宕机
一定开启手动ACK，消费成功才移除，失败或者没来得及处理就noAck并重新入队
消息重复# 1、消息消费成功，事务已经提交，ack时，机器宕机。导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者
在ack的时候宕机，导致消息没有确认，又需要重新发送
2、消息消费失败，由于重试机制，自动又将消息发送出去
关闭订单的时候，没有成功，又重新进入队列再次执行，这种是可以允许的
解决办法：
消费者的业务消费接口应该设计为幂等性的。比如扣库存有工作单的状态标志使用防重表（redis/mysql），发送消息每一个都有业务的唯一标识，处理过就不用处理rabbitMQ的每一个消息都有redelivered字段，可以获取是否是被重新投递过来的，而不是第一次投递过来的 判断当前消息是否是第二次及以后被派发过来的
消息积压# 消费者宕机积压消费者消费能力不足积压发送者发送流量太大上线更多的消费者，进行正常消费上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理 这也是实现了柔性事务-可靠消息+最终一致性解决方案
做好消息确认机制（生产者、消费者）+手动确认机制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aea7d8d9cce17ef6b999e402344a11a1/" rel="bookmark">
			1001 害死人不偿命的(3n&#43;1)猜想（JAVA）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……
我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？
输入格式： 每个测试输入包含 1 个测试用例，即给出正整数 n 的值。
输出格式： 输出从 n 计算到 1 需要的步数。
输入样例： 3 输出样例： 5 实现代码（JAVA）： import java.util.Scanner; /** * @author yx * @date 2022-07-12 0:06 */ public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n=scanner.nextInt(); int ans=0; while (n!=1) { if ((n &amp; 1) == 1) { n = (3 * n + 1) / 2; } else { n /= 2; } ans++; } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aea7d8d9cce17ef6b999e402344a11a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/760ecd214cc40d3c9417a3cfe6ad6ee3/" rel="bookmark">
			Ansible中的任务执行控制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一.循环
1.简单循环
2.循环散列或字典列表
二.条件
when: - 条件1 - 条件
多条条件组合
三.触发器
四.处理失败任务
1.ignore_errors
2.force_handlers
3.changed_when
4.failed_when
5.block
测试练习
磁盘划分
2.建立userlist.yml中的用户，并且使用户密码加密，
一.循环 循环迭代任务
1.简单循环 - name: test play
hosts: westos
tasks:
- debug:
msg: "{{item}}"
loop:
- westos
- linux
- lee
2.循环散列或字典列表 - name: test play
hosts: westos
tasks:
- debug:
msg: "{{item.name}} {{item.age}}"
loop:
- { name: westos, age: 18 }
- { name: linux, age: 19 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/760ecd214cc40d3c9417a3cfe6ad6ee3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b344e128516eaa8d391ebd695988049/" rel="bookmark">
			Java基础之lambda表达式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lambda表达式 文章目录 Lambda表达式lambda 表达式重要特征 函数式接口功能型函数式接口消费型函数式接口供给型函数接口断言型函数接口 方法引用StreamStream意义strema执行流程生成流 forEachmapfilterlimitsorted并行（parallel）程序Collectors统计完整实例 lambda 表达式 Lambda 表达式，也称为闭包，是推动 Java 8 发布的最重要新特性
Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）使用 Lambda 表达式可以使代码变的更加简洁紧凑 lambda 表达式的语法格式如下：
(parameters) -&gt; expression ; (parameters) -&gt;{ statements; }; 重要特征 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。可选的大括号：如果主体包含了一个语句，就不需要使用大括号。可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。 @FunctionalInterface //定义接口时添加该注解表示函数式接口 new Thread( //将lambda表达式作为参数传入方法，构建线程对象 () -&gt; { int a = 0; while(a &lt; 10){ System.out.println(++a); } } ).start(); /** (): 函数式接口中唯一抽象方法的参数；参数类型自动匹配, 可指定，只有一个参数时可忽略() 然后跟 -&gt; {} 方法体{ }：表示方法中的具体实现，仅一句实现语句可省略{} */ // 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b344e128516eaa8d391ebd695988049/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/224/">«</a>
	<span class="pagination__item pagination__item--current">225/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/226/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>