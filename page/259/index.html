<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc1465067769e5d87b61cf937d663fae/" rel="bookmark">
			Vuex入门(一)—— state,mapState,...mapState对象展开符详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 知识不足的地方赶快点击学习呦~~~
Vuex入门(一)—— state,mapState,…mapState对象展开符详解
Vuex入门(二)—— mutations详解
Vuex入门(三)—— getters,getters,…getters对象展开符详解
Vuex入门(四)—— action和…mapActions详解
Vuex入门(五)—— 封装module全网最全详解(带源码)
Vuex入门(六)——mapState, mapGetters, mapMutations, mapActions全网最全详解终结篇(带源码)
Vuex官网:https://vuex.vuejs.org/zh/guide/#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84-store
1.store.js Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库
import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) export default new Vuex.Store({ state: { // 类似于 data num:1000000, count: 1, name: '小明', sex: '男', from: '中国' }, mutations: { // 类似于计算属性 computed increment(state) { // 把上面state对象当参数传入,取对象里面的进行操作 state.count++ }, decrement(state) { state.count-- } }, actions: {}, modules: {} }) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc1465067769e5d87b61cf937d663fae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da335513f790eab428c558e57529b855/" rel="bookmark">
			Pytorch安装方法（使用清华源安装）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		step1：先安装anaconda anaconda下载地址 一般按默认选项一步一步安装即可，安装完成之后，在开始列表找到Anaconda Prompt打开，可以看到（base）C:\Users\Zlw，表示安装成功。
注1：anaconda 与miniconda的区别： anaconda和miniconda同为conda官方推荐的conda工具。anaconda和conda的关系，就像github和git的关系，anaconda不光包含了conda命令行软件，还包含了多如牛毛的预装python包，以及令人瞠目结舌的黑科技全家桶。我们装anaconda主要是冲着conda管理python运行环境比较方便的原因，以及它那一大堆预装包。
注2：CUDA与Jupyter的安装： anaconda内部集成了这两个，因此不需要单独安装，安装好anaconda即可。
step2：访问pytorch官网,选择需要的版本，来安装pytorch 以下为windos10下建议选项
将Run this Command conda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch 复制到anaconda prompt中运行，即可开始安装下载。
补充说明：
在用conda安装软件的过程中还会经常遇到的一个问题，就是：软件太大老是下载中断
我要下载一个软件，conda会告诉我这个软件底层依赖好几个其他的软件，需要将它们一起下载安装，这个时候这一大堆软件中可能有几个体量很大，上百MB，很容易下着下着网络连接就中断了，而conda有没有断点下载功能，一旦下载中断，conda就会终止安装进程退出运行。
1、首先是添加清华镜像channel
2、安装的指令，主要是把官网指令
conda install pytorch torchvision cudatoolkit=11.3 -c pytorch 后面的-c pytorch删掉，-c pytorch的意思是，安装下载的channel强制为pytorch官网的channel。所以需要删除才能走清华镜像的channel。
最后，我们转战清华源安装,运行以下命令:
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes # reference # https://mirror.tuna.tsinghua.edu.cn/help/anaconda/ step3：测试pytorch是否安装成功 在anaconda prompt中输入以下指令来测试：如果返回true即表示该pytorch可以在显卡中运行
import torch torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da335513f790eab428c558e57529b855/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e8207d939670701091bdbc60d36696b/" rel="bookmark">
			蓝桥杯学习记录||ALGO-996 车的放置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		车的放置 问题描述
在一个n*n的棋盘中，每个格子中至多放置一个车，且要保证任何两个车都不能相互攻击，有多少中放法(车与车之间是没有差别的)
输入格式
包含一个正整数n
输出格式
一个整数，表示放置车的方法数
样例输入
2
样例输出
7
数据规模和约定
n&lt;=8【样例解释】一个车都不放为1种，放置一个车有4种，放置2个车有2种。
解析：从样例可以看出‘车’是被放在格子里面的，而不是点上。我们可以自由选择摆放车的个数，以达到最多的摆法。 解法：其实可以用概率论的方法解题
当棋盘为n * n 时，我们可以选择的棋子数为0 ~ n ,
棋子数为0 这算一种
棋子数为i 可以摆法的种数：
在n行格子中选择i行进行摆放就是C(i,n)
然后在摆放i个棋子时，第一个棋子有n种选择（n个列可以选），第二个有n-1种选择…就是A(i,n)
写代码时公式可以化简为 下图 ；cal（）就是A的计算函数
#include&lt;stdio.h&gt; int n; int sum = 0; //看上图 int cal(int x){ int factor=1,i; for(i=n;i&gt;n-x;i--){ //求分子 factor*=i; } factor *= factor; //分子平方 for(i=x;i&gt;=1;i--){ //除于i的阶层 factor/=i; } return factor; //求出A } int main(){ int i; scanf("%d",&amp;n); sum=1 + n*n; //先把摆放0个和摆放1个的加上 for(i=2;i&lt;=n;i++){ sum+=cal(i);//表示用 i 个车 } printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e8207d939670701091bdbc60d36696b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2be259d74a4ed2b483a181c9d66023d4/" rel="bookmark">
			Neo4j基础理论、Linux安装与Windows安装以及CQL语法（增删改查、排序、分页、去重）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是Neo4j？ Neo4j是一个开源的 无Shcema的 基于java开发的 图形数据库，它将结构化数据存储在图中而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。程序数据是在一个面向对象的、灵活的网络结构下，而不是严格、静态的表中,但可以享受到具备完全的事务特性、企业级的数据库的所有好处。
数据库排名
二、Neo4j 模块构建 1、Neo4j 主要构建块 节点属性关系标签数据浏览器 节点
节点是图表的基本单位。 它包含具有键值对的属性
属性
属性是用于描述图节点和关系的键值对
Key =值
其中Key是一个字符串 值可以通过使用任何Neo4j数据类型来表示
关系
关系是图形数据库的另一个主要构建块。 它连接两个节点，如下所示
这里Emp和Dept是两个不同的节点。 “WORKS_FOR”是Emp和Dept节点之间的关系。
因为它表示从Emp到Dept的箭头标记，那么这种关系描述的一样
Emp WORKS_FOR Dept
每个关系包含一个起始节点和一个结束节点。
这里“Emp”是一个起始节点。
“Dept”是端节点。
由于该关系箭头标记表示从“Emp”节点到“Dept”节点的关系，该关系被称为“进入关系”到“Dept”节点。并且“外向关系”到“Emp”节点。
像节点一样，关系也可以包含属性作为键值对。
标签
Label将一个公共名称与一组节点或关系相关联。 节点或关系可以包含一个或多个标签。 我们可以为现有节点或关系创建新标签。 我们可以从现有节点或关系中删除现有标签。
从前面的图中，我们可以观察到有两个节点。
左侧节点都有一个标签：“EMP”，而右侧节点都有一个标签：“Dept”。
这两个节点之间的关系，也有一个标签：“WORKS_FOR”
注： -Neo4j将数据存储在节点或关系的属性中。
2、Neo4j的主要应用场景 社交媒体和社交网络
当使用图形数据库为社交网络应用程序提供动力时，可以轻松利用社交关系或根据活动推断关系。查询社区聚类分析，朋友的朋友推荐，影响者分析，共享和协作关系分析等推荐引擎和产品推荐系统
图形驱动的推荐引擎通过实时利用多种连接，帮助公司个性化产品，内容和服务。内容和媒体推荐，图形辅助搜索引擎，产品推荐，专业网络，社会推荐。身份和访问管理
使用图形数据库进行身份和访问管理时，可以快速有效地跟踪用户，资产，关系和授权。查询访问管理，资产来源，数据所有权，身份管理，互连组织，主数据，资源授权金融反欺诈多维关联分析场景
通过图分析可以清楚地知道洗钱网络及相关嫌疑，例如对用户所使用的帐号、发生交易时的IP地址、MAC地址、手机IMEI号等进行关联分析。 3、Neo4j环境搭建 Neo4j环境Linux下搭建
(1).切换到Linux下 到安装目录neo4j 上传安装包 或者 下载安装包
使用 ftp 工具上传neo4j-community-3.5.17.tar 到 liunx 下或者 wget https://neo4j.com/artifact.php?name=neo4j-community-3.5.17-unix.tar.gz
(2). 解压
tar -xvf neo4j-community-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2be259d74a4ed2b483a181c9d66023d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ecac1c20e27239d4bd84271eb55283/" rel="bookmark">
			Cesium 之加载ArcGIS Server 4490切片服务（含orgin -400 400）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于ArcGIS Server发布的切片服务，在地理坐标系中Cesium默认只支持wgs84的4326坐标系，无法通过ArcGisMapServerImageryProvider直接加载CGCS2000的4490坐标系，虽然可以使用WebMapTileServiceImageryProvider加载符合OGC标准的WMTS类型，但只能针对于原点在orgin X: -180.0Y: 90.0的情况，对于原点在orgin X: -400.0Y: 400.0时还是无法正常加载，为了能够实现加载，以下通过修改源码方式来达到目的。
笔者以Cesium 1.91版本为例。
目录
1、修改ArcGisMapServerImageryProvider类
2、修改GeographicTilingScheme类
3、定义2000椭球参数
4、底图调用实现
1、修改ArcGisMapServerImageryProvider类 在metadataSuccess方法中修改
（1）读取切片模式时增加支持wkid 4490坐标系的判断，同时将切片信息也传入，目的是为了后面在获取行列号xy时，可以通过读取切片信息，使用自定义方法改写行列号的获取方式。
else if (data.fullExtent.spatialReference.wkid === 4490) { that._tilingScheme = new GeographicTilingScheme({ ellipsoid: options.ellipsoid, tileInfo: data.tileInfo, rectangle: that._rectangle }); that._tilingScheme._tileInfo = data.tileInfo;//附加自定义属性 } 如截图所示：
（2）增加最大层级定义（用来限制最大可缩放多少层级，达到一定层级后不显示，根据项目需要为可选修改项）
//修改最大层级定义
that._maximumLevel = defaultValue(options.maximumLevel, data.tileInfo.lods.length - 1);
（3）矩阵范围定义中 增加wkid 4490坐标系判断。
2、修改GeographicTilingScheme类 （1）增加4490坐标系的椭球、矩阵范围等定义，4490坐标系默认椭球为CGCS2000，矩阵范围为（-180，-90，180，90），开放矩阵范围的目的就是为了支持自定义的origin原点。
if (defined(options.tileInfo) &amp;&amp; defined(options.tileInfo.spatialReference) &amp;&amp; defined(options.tileInfo.spatialReference.wkid) &amp;&amp; options.tileInfo.spatialReference.wkid == 4490) { this._tileInfo = options.tileInfo; this._ellipsoid = defaultValue(options.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8ecac1c20e27239d4bd84271eb55283/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8616069d6dfe24dcd3a0dec1bf435a62/" rel="bookmark">
			输入一个整数n，控制台输出n行“*”金字塔的形状（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输出金字塔形状
public class Test_06 { public static void main(String[] args) { Scanner sc =new Scanner(System.in); System.out.println("请输入一个数字"); int n = sc.nextInt(); //接收用户输入的数字 for (int i = 1; i &lt;= n; i++) { //控制行数，从1行开始循环到第n行 for (int j = 1; j &lt;= n - i; j++) { //每行的空格循环 System.out.print(" "); //每一行的空格 } for (int k = 1; k &lt;= 2 * i - 1; k++) { //控制*的输出都为奇数 System.out.print("*"); } System.out.println(); } } } 结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8616069d6dfe24dcd3a0dec1bf435a62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2f895e861edfe5f72fc15ae80367379/" rel="bookmark">
			node&#43;ts后端项目使用pm2部署篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为是typescript项目 所以首先要把代码编译成js让node执行,这里使用ts提供的编译器tsc即可
tsc -w 会编译到dist目录,然后扔到服务器里,把package.json也扔进去,然后npm install安装项目的依赖
然后项目同文件夹弄一个app.json文件供pm2进行启动
常用的几个pm2命令:
pm2 delete all 关闭所有实例 pm2 list 显示所有实例 pm2 start app.json 根据app.json启动项目 pm2 logs 查看服务日志 pm2 restart id 重启某个id的实例 pm2 start id 启动某个id的实例 pm2配置:nodejs pm2 json配置apps - 简书
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d01cc58419aa148d9676f7419d23dd9/" rel="bookmark">
			8.1 Python 类 对象 属性 方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8.1 Python 类 对象 属性 方法 8.1.1 什么是类？ 类的中文释义：许多相似或相同事物的综合。这些事物各不相同，但具有一些共同的特征或行为。
生活中的类
植物类：百合花、玫瑰花、栀子花。
水果类：苹果、橘子、西瓜。
车：面包车、轿车、跑车。
Python中的类
整数类：1，2，3。
浮点数类：1.1，2.2，3.3。
1、2、3这些数据都属于整数（int）类，虽然值各不一样，但都有能进行加减运算的相同点。
‘1’、‘2’、'3’这些数据都属于字符串（str）类，虽然值各不一样，但都有能进行拼接的相同点。
使用 type 函数查看Python数据类型
# 1、2 属于整数(int)类 print(type(1)) print(type(2)) # '1'、'2'、属于字符串(str)类 print(type('1')) print(type('2')) &lt;class 'int'&gt; &lt;class 'int'&gt; &lt;class 'str'&gt; &lt;class 'str'&gt; class [klɑːs] ：类别、分类、班级。
class 在Python中就代表类别。
我们之前学的数据类型像整数、浮点数、字符串、列表、元组等实际上就是不同的类别。
&lt;class 'int'&gt;表示类别为整数。
&lt;class 'str'&gt;表示类别为字符串。
8.1.2 什么是对象？ 类是对一类事物的概括。
类里的每一事物或每个单独的个体就是对象。
我不是很喜欢吃水果。——水果是类。
我不喜欢吃苹果。——苹果是对象。
你买车了吗？——车是类。
我买的宝马车。——宝马车是对象。
1、2都是整数（int）。——整数是类，1和2是对象。
8.1.3 类的作用 类的作用：类可以创建出一个具体的对象。
类是抽象的，对象是具体的。
我们这样理解类
类就是模板，是设计图纸。
类 = 设计图纸
工人根据汽车的设计图纸可以生产出款式、颜色、型号各不相同的汽车。
类就是制造汽车的图纸。
图纸不能上路行驶，类是抽象的不能直接使用的。它的作用就是负责生产汽车，即创建对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d01cc58419aa148d9676f7419d23dd9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb0d5eab2c993ada3df9e383bd1e43a7/" rel="bookmark">
			jwt实现登录验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jwt实现登录验证 一、什么是jwt二、为什么需要jwt三、jwt的组成1.头部header2.payload 负载3.Signature 签名 四、jwt的实现方式java-jwtjjwt 后端工具类 一、什么是jwt JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。
简要说明：前段传验证信息到后端，后端验证通过，返回一个对象，只不过这个对象是加密的，每次请求的时候，请求头带上token,里面封装了对象的信息，我们只需要用拦截器进行拦截，解析token,后端就可以知道是谁登录。
二、为什么需要jwt cookie和session的缺点：
session都存储在服务端内存集群环境中需要额外处理。ip_hash，分布式，session......
user -&gt; u1,u2,u3 csrf:Cross-site request forgery, cookie被截获后可能发生跨站点请求伪造cookie的跨域（前后端分离）读写不方便 jwt的优点：解决cookie和session的缺点 三、jwt的组成 一个 JWT 实际上就是一个字符串，它由三部分组成，头部、载荷与签名
1.头部header { "alg": "HS256", "typ": "JWT" } alg: 签名算法，常用HS256,具体支持可参考jwt官网: https://jwt.io/
typ: token令牌的类型,统一写成JWT
2.payload 负载 也是一个 json 的对象，下面是官方字段：
iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 当然也可以定义一些其他字段：
{ "sub": "1234567890", "name": "John Doe"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb0d5eab2c993ada3df9e383bd1e43a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f170eb9585961260f4946d37a33a9888/" rel="bookmark">
			从源码读懂 Handler 的原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Handler 的工作原理二、Handler 中 postDelay 方法的原理为什么不采用延时发送消息的方式实现 postDelay 方法 三、在线程中新建 Handler 之前为什么要先调用 Looper.prepare()四、为什么在主线程新建 Handler 不需要先调用 Looper.prepare()五、主线程的 loop 是一个死循环，为什么不会发生 anr六、一个线程有两个 Handler 的时候，其中一个 Handler 调用 removeCallbacksAndEqualMessages() 是否会影响另一个 Handler七、一个线程有两个 Handler 的时候，Looper 在处理消息的时候如何进行分配八、为什么创建 Message 对象的时候推荐优先使用 obtain() 获取 一、Handler 的工作原理 Handler 的正常运作依赖于三个组件：MessageQueue，Handler，Looper。
MessageQueue 是一个消息队列，用于存放消息（Message），当我们创建 Handler 时，Handler 会持有一个 Looper，Looper 中有一个死循环 loop ，loop 会不断的从消息队列中取出消息并进行处理。
我们通过 Handler 的 sendMessage()，removeMessages() 等方法向消息队列添加或移除消息，通过 handleMessage() 对消息进行具体的处理。
Handler 构造函数：
public Handler(@Nullable Callback callback, boolean async) { ... mLooper = Looper.myLooper(); //Looper对象 if (mLooper == null) { throw new RuntimeException( "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f170eb9585961260f4946d37a33a9888/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0962ca881dc36c45d0c0c4a3ae44065e/" rel="bookmark">
			09_BatchNormal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于B站课程28_P2 从零实现 import torch from torch import nn from d2l import torch as d2l # X输入 gamma, beta待学习参数 moving_mean, moving_var全局均值、方差 # eps避免出零，不要去改其值 momentum用来更新moving_mean, moving_var通常取0.9 def batch_norm(X, gamma, beta, moving_mean, moving_var, eps, momentum): # 通过is_grad_enabled来判断当前模式是训练模式还是预测模式 if not torch.is_grad_enabled(): # 如果是在预测（inference推理）模式下，直接使用传入的移动平均所得的均值和方差 X_hat = (X - moving_mean) / torch.sqrt(moving_var + eps) else: assert len(X.shape) in (2, 4) # 如果X.shape为2是全连接层，4为卷积层。 3为1D卷积，5为3D卷积。 if len(X.shape) == 2: # 第一维batch，第二维特征 # 使用全连接层的情况，计算特征维上的均值和方差 mean = X.mean(dim=0) var = ((X - mean) ** 2).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0962ca881dc36c45d0c0c4a3ae44065e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30e8680dd8c734d2cf02593483ccf707/" rel="bookmark">
			网络攻防——被攻击日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一次被攻击日志 1.引言2.被攻击原因3.被攻击损失4.反击5.防卫6.额外学到的知识 1.引言 ​ 没想到有一次自己也会被别人攻击，莫名非常高兴，哈哈哈哈，从某种意义上证明自己又提高了。
2.被攻击原因 ​ 项目写的比较简单，写的快，直接就不用密码给部署了，没有ip限制，更没有密码，数据库用的是mongoDB甚至没有修改端口号，攻击简直轻而易举。当然也有一些可能的原因，我们的项目没有接口，于是去别的网站使用别人的接口，可能是每天都在请求别人的数据，别人来“问候问候”我了，哈哈哈哈。展示效果如下：
3.被攻击损失 ​ 笑死我了，这个大佬不知道他攻击的数据库是最不值钱的数据库，首先是个demo，其次为了保证数据实时性，里面的数据采用的是删除全部数据，然后重新写入最新数据（洗库）。
4.反击 ​ 这个怎么能白挨打，首先访问我的服务器特别是mongoDB是会留下日志的，因此下载mongoDB的日志文件，由于攻击必定会留下部分的数据库语句，所以搜索留下的集合名称"READ__ME_TO_RECOVER_YOUR_DATA"，找到了ip:
​ 拿到项目里面的每个人的ip地址，对比一下，发现不是，项目成员都没学这个，确认这个ip不对劲，ping一下，还活着：
搜索一下这个ip地址，发现在国外：
目测可能是代理，刚好最近学了点网安，嘿嘿，拿着就是干！
等下，为了做个人，先看看是不是来自我爬取接口的网站，毕竟这还是有求于人，“回访”一下确实不道德，这里ping一下看看ip，发现是mac地址，额，不慌找度娘：
好像是说这个ping是有操作的，可以选择-6 和-4 两种参数，因此换一种方式来ping，成功了，得到的效果如下（该网站对我们项目有恩，故不展示相关信息）：
好啦，现在就确认了不是我们项目相关的ip地址，首先利用Goby扫描目标ip地址拿到端口:
发现都是不能访问的：
5.防卫 （1）设置必要的数据库用户名和密码；
（2）修改自己网站重要工具的端口；
（3）设置必要的ip访问限制。
6.额外学到的知识 ​ 很开心这个大佬攻击我，提高自己的安全意识，很赞赏作为大佬那种责任感，没有删我的数据库和其他恶意攻击（当然我也不确定是不是还干了什么）。我相信有朝一日我也能够“回访一下，以表谢意”。其他学到的知识如下：
（1）使用健康上网连接工具的话，本质上自己的ip地址不会发生改变，只是自己多进了一个局域网；
（2）要提高自己的安全防范意识，数据库应该设置密码和ip访问权限，就像这样，根据里面的提示更换重要服务的端口并使用密码爆破插件，黑掉来访者：
（3）极大加深了mongoDB在管理上的理解，有兴趣的话，可以看看我这篇文章：
MongoDB数据库的密码和权限问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68d5780076dd90d2c4b6ddb436b872c9/" rel="bookmark">
			Fragment基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读目录
1. Fragment概述 1.1 介绍1.2 Fragment基本生命周期2. Fragment使用 2.1 静态加载2.2 动态加载Fragment2.3 使用注意点3. Fragment与Activity联动3.1 回退栈4. Fragment与Activity通信 4.1 传递数据给Fragment4.2 传递数据给Activity5. Fragment间通信 5.1 setArguments()5.2 同Activity不同Container的Fragment交互 正文
回到顶部
1. Fragment概述 1.1 介绍 Fragment是一种可以嵌入在活动中的UI片段，能够让程序更加合理和充分地利用大屏幕的空间，出现的初衷是为了适应大屏幕的平板电脑，可以将其看成一个小型Activity，又称作Activity片段。
使用Fragment可以把屏幕划分成几块，然后进行分组，进行一个模块化管理。Fragment不能够单独使用，需要嵌套在Activity中使用，其生命周期也受到宿主Activity的生命周期的影响
官方定义如下：
A Fragment represents a behavior or a portion of user interface in an Activity. You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activities. You can think of a fragment as a modular section of an activity, which has its own lifecycle, receives its own input events, and which you can add or remove while the activity is running.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68d5780076dd90d2c4b6ddb436b872c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d528037864fd8336a451a93b7121b7a/" rel="bookmark">
			mysql&#43;mycat&#43;keepalive&#43;haproxy高可用集群(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql+mycat+keepalive+haproxy高可用集群搭建 集群架构图 开局一张图，内容全靠编
这是mysql+mycat+keepalive+haproxy高可用集群搭建系列...
2.mysql部署高可用-mysql安装.md
3.mysql部署高可用-一主三从.md
4.mysql部署高可用-主主互备.md
填坑总结 坑一： Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work. 问题背景：
检查从服务器复制功能状态，执行命令show slave status \G，发现error
mysql&gt; show slave status \G *************************** 1. row *************************** Slave_IO_State: Master_Host: 192.168.1.150 Master_User: copy Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 437 Relay_Log_File: mysql-154-slave-relay-bin.000001 Relay_Log_Pos: 4 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: No Slave_SQL_Running: Yes Last_IO_Errno: 1593 Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d528037864fd8336a451a93b7121b7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d836a07b4cea6949493b28f102eee6/" rel="bookmark">
			4195 线段覆盖（差分）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题描述：
在一个坐标轴上有 n 条线段。每条线段的每个端点的坐标都为整数。可能存在退化成点的线段。线段之间可以相互交叉、嵌套甚至重合。请你计算，对于每个 k∈{1，2，…，n}，坐标轴中共有多少个整数坐标的点满足恰好被 k 条线段覆盖。注意，左右端点分别为 li，ri 的线段覆盖点 x 当且仅当 li ≤ x ≤ ri。
输入格式
第一行包含整数 n。接下来 n 行，每行包含两个整数 li，ri，表示一条线段的左右端点。
输出格式
一行 n 个整数，其中第 i 个整数表示坐标轴中满足恰好被 i 条线段覆盖的整数坐标的点的数量。
数据范围
前三个测试点满足 1 ≤ n ≤ 3。
所有测试点满足 1 ≤ n ≤ 2 × 10 ^ 5，0 ≤ li ≤ ri ≤ 10 ^ 18。
输入样例1：
3
0 3
1 3
3 8
输出样例1：
6 2 1
输入样例2：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d836a07b4cea6949493b28f102eee6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56f83e71df743123fada8ce99828700/" rel="bookmark">
			UE4 打开系统的文件选择窗口|打开windows文件选取窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UE4中打开文件窗口等桌面平台支持功能的接口类 IDesktopPlatform
IDesktopPlatform::OpenFileDialog(const void* ParentWindowHandle, const FString&amp; DialogTitle, const FString&amp; DefaultPath, const FString&amp; DefaultFile, const FString&amp; FileTypes, uint32 Flags, TArray&lt;FString&gt;&amp; OutFilenames, int32&amp; outFilterIndex ) virtual bool OpenFileDialog(const void* ParentWindowHandle, const FString&amp; DialogTitle, const FString&amp; DefaultPath, const FString&amp; DefaultFile, const FString&amp; FileTypes, uint32 Flags, TArray&lt;FString&gt;&amp; OutFilenames, int32&amp; outFilterIndex ) = 0; /** * Opens the "save file" dialog for the platform * * @param ParentWindowHandle	The native handle to the parent window for this dialog * @param DialogTitle	The text for the title of the dialog window * @param DefaultPath	The path where the file dialog will open initially * @param DefaultFile	The file that the dialog will select initially * @param Flags	Details about the dialog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e56f83e71df743123fada8ce99828700/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8179a5813686b663ec3b568a5c93086c/" rel="bookmark">
			Retrofit2简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Retrofit是什么？ 确切的讲，Retrofit是对okhttp的进一步封装，是一个现在比较火的网络请求框架。
二、使用步骤 1.引入库 implementation 'com.squareup.retrofit2:retrofit:2.9.0' 2.创建一个interface，我们将这个interface取名为HttpBinService 代码如下（示例）：
package hk.hkiot.okhttp; import okhttp3.ResponseBody; import retrofit2.Call; import retrofit2.http.Field; import retrofit2.http.FormUrlEncoded; import retrofit2.http.GET; import retrofit2.http.POST; import retrofit2.http.Query; public interface HttpBinService { @POST("post") @FormUrlEncoded Call&lt;ResponseBody&gt; startPost(@Field("username") String username, @Field("pwd") String pwd); @GET("get") Call&lt;ResponseBody&gt; startGet(@Query("username") String username, @Query("pwd") String pwd); } 我们定义了startPost和startGet方法，其返回类型为retrofit的Call类型，尖括号里是okhttp的ResponseBody类型，@GET/@POST 注解的作用是声明采用GET/POST的方法进行网络请求。
startGet方法中添加参数在方法括号内添加@Query，后面是参数类型和参数字段，Retrofit会把两个字段拼接到接口中，追加到"/get"后面。比如：baseUrl为https://www.httpbin.org/，那么拼接网络接口注解中的地址后变为：https://www.httpbin.org/get，我们需要传入的username=testusername，pwd=123456，那么拼接参数后就是完整的请求地址：https://www.httpbin.org/get?username=testusername&amp;pwd=123456。
startPost方法则需要在头部添加@FormUrlEncoded注解，表示请求实体是一个From表单，每个键值对需要使用@Field注解，使用@Field添加参数，这是发送Post请求时，提交请求的表单字段，必须要添加的。
3.接下来就可以就可以进行网络请求了 public class MainActivity extends AppCompatActivity implements View.OnClickListener { private Button getAsynBtn; private Button postAsynBtn; private Retrofit retrofit; private HttpBinService httpBinService; private static final String TAG = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8179a5813686b663ec3b568a5c93086c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7967282b5e1a519121d2d8f49b57d2e6/" rel="bookmark">
			Android Studio构建新项目错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio构建gradle 新项目错误 报错 Build file 'D:\Android\WeatherApp\build.gradle' line: 3 Plugin [id: 'com.android.application', version: '7.1.2', apply: false] was not found in any of the following sources: * Try: Run with --info or --debug option to get more log output. Run with --scan to get full insights. * Exception is: org.gradle.api.plugins.UnknownPluginException: Plugin [id: 'com.android.application', version: '7.1.2', apply: false] was not found in any of the following sources: - Gradle Core Plugins (plugin is not in 'org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7967282b5e1a519121d2d8f49b57d2e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b72872aaa7b72930d6f1b36a68385e5c/" rel="bookmark">
			artisan migrate 报错 Illuminate\Database\QueryException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： 在进行 php artisan migrate 的时候报错：
Illuminate\Database\QueryException SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 1000 bytes (SQL: alter table `users` add unique `users_em ail_unique`(`email`)) 原因分析： MySql支持的utf8编码最大字符长度为3字节，如果遇到4字节的宽字符就会出现插入异常。三个字节UTF-8最大能编码的Unicode字符是0xffff，即Unicode中的基本多文种平面（BMP）。因而包括Emoji表情（Emoji是一种特殊的Unicode编码）在内的非基本多文种平面的Unicode字符都无法使用MySql的utf8字符集存储。
这也应该就是Laravel 5.4改用4字节长度的utf8mb4字符编码的原因之一。不过要注意的是，只有MySql 5.5.3版本以后才开始支持utf8mb4字符编码（查看版本：selection version();）。如果MySql版本过低，需要进行版本更新。
解决方案： 1.升级MySql版本到5.5.3以上。在 /app/providers/AppServiceProvider.php里添加：
use Illuminate\Support\Facades\Schema; public function boot() { Schema::defaultStringLength(191); } 2.将数据库里的表删掉，重新执行 php artisan migrate
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a57b9cc0c995eb3a48a38d1d4d195ab/" rel="bookmark">
			java调用webservice，自动生成代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webService远程调用 一.WebService介绍 一.WebService介绍 1、WebService定义
顾名思义就是基于Web的服务。
它使用Web(HTTP)方式，接收和响应外部系统的某种请求，从而实现远程调用。
web service能解决：
* 基于Web的服务：服务器端整出一些资源让客户端应用访问（获取数据）
* 一个跨语言、跨平台的规范（抽象）
* 多个跨平台、跨语言的应用间通信整合的方案（实际
2、webservice理解
我们可以调用互联网上查询天气信息Web服务，然后将它嵌入到我们的程序(C/S或B/S程序)当中来，
当用户从我们的网点看到天气信息时，他会认为我们为他提供了很多的信息服务，
但其实我们什么也没有做，只是简单了调用了一下服务器上的一段代码而已。
WebSerice可以将你的服务(一段代码)发布到互联网上让别人去调用,
也可以调用别人机器上发布的WebService,就像使用自己的代码一样。
什么时候使用web Service： 同一家公司的新旧应用之间不同公司的应用之间
如天猫网与中通物流系统交互一些提供数据的内容聚合应用：天气预报、股票行情 3、webservice调用的预备知识
(1)XML—Extensible Markup Language 扩展性标记语言
XML，用于传输格式化的数据，是Web服务的基础。
namespace-命名空间。
xmlns=“http://www.xr.com” 使用默认命名空间。
xmlns:xr=“http://www.xr.com”使用指定名称的命名空间。
(2)WSDL—WebService Description Language Web服务描述语言。
通过XML形式说明服务在什么地方－地址。
通过XML形式说明服务提供什么样的方法 – 如何调用。
(3)SOAP—Simple Object Access Protocol(简单对象访问协议)
SOAP作为一个基于XML语言的协议用于有网上传输数据。
SOAP = 在HTTP的基础上+XML数据。
SOAP是基于HTTP的。
SOAP的组成如下：
Envelope – 必须的部分。以XML的根元素出现。
Headers – 可选的。
Body – 必须的。在body部分，包含要执行的服务器的方法。和发送到服务器的数据。
4、webservice服务网址
Webservice服务网站：http://www.webxml.com.cn
5、WSDL解析
点开webservice网站上的手机归属地查询里的
http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl
查看wsdl对服务器的描述
Wsdl文档从下往上读
wsdl:service—所有请求服务的站点集合
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a57b9cc0c995eb3a48a38d1d4d195ab/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/258/">«</a>
	<span class="pagination__item pagination__item--current">259/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/260/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>