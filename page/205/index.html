<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8172f5d8409fa84ed9856b05dc3c47ee/" rel="bookmark">
			C&#43;&#43;中的unordered_map用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 简介
unordered_map是一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。
key值应该是唯一的，key和value的数据类型可以不相同。
unordered_map存储元素时是没有顺序的，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效，平均可以在常数时间内完成。
unordered_map查询单个key的时候效率比map高，但是要查询某一范围内的key值时比map效率低。
可以使用[ ]操作符来访问key值对应的value值。
2 简单使用
std::unordered_map&lt;std::string, std::int&gt; umap; //定义
umap.insert(Map::value_type("test", 1));//增加
//根据key删除,如果没找到n=0
auto n = umap.erase("test") //删除
auto it = umap.find(key) //改
if(it != umap.end()) it-&gt;second = new_value; //map中查找x是否存在
umap.find(x) != map.end()//查
//或者
umap.count(x) != 0
for(auto x:unomap)//遍历整个map，输出key及其对应的value值
{
x.second = 0; cout&lt;&lt;x.second&lt;&lt;endl;//全是 000；; }
cout&lt;&lt;x.second&lt;&lt;endl;//回复原来的数值的。
彻底改变：使用find彻底找到这个数值，然后在进行改，可以保证作用域是整个程序。
for(auto x:unomap)//遍历整个map，输出key及其对应的value值
{
auto it = umap.find(key) //改
if(it != umap.end()) it-&gt;second = new_value; } #include &lt;iostream&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8172f5d8409fa84ed9856b05dc3c47ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d007c84dd830ccbdc32a111feddddad/" rel="bookmark">
			c语言各数据类型的范围与精度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各数据类型的范围与精度 基本类型字节数位数取值范围（二进制）取值范围（十进制）大概范围（十进制）精度(取决于尾数的范围)byte1 byte8 bit − 2 7 -2^7 −27 ~ 2 7 − 1 2^7 - 1 27−1 − 128 -128 −128 ~ + 127 +127 +127short2byte16bit − 2 15 -2^{15} −215 ~ 2 15 − 1 2^{15} - 1 215−1 − 32767 -32767 −32767 ~ + 32768 +32768 +32768 3.2 ∗ 1 0 4 3.2*10^4 3.2∗104int4byte32bit − 2 31 -2^{31} −231 ~ 2 31 − 1 2^{31} - 1 231−1 − 2147483648 -2147483648 −2147483648 ~ + 2147483647 +2147483647 +2147483647 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d007c84dd830ccbdc32a111feddddad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40b6a7905e07c865e6cd4d0c42f29561/" rel="bookmark">
			antd a-tree-select搜索功能和a-select搜索功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 a-select要搜索功能需要加上 show-search :filter-option="searchBrand" 下面是绑定的搜索方法
a-tree-select要实现搜索功能 不需要单独写方法 加上这两个属性就可以搜索了，name是通过name这个字段进行搜索 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffabe5c5dccfa21faa65d992413e31de/" rel="bookmark">
			NVIDIA-Docker安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		然后，进行免秘钥配置：
sudo addgroup --system docker
sudo adduser $USER docker
newgrp docker
Ubuntu18.04：
1 安装docker-ce：
https://docs.docker.com/engine/install/ubuntu/
2 GPU驱动安装：如果没有按照驱动
https://github.com/NVIDIA/nvidia-docker/wiki/Installation-(Native-GPU-Support)
3 安装 NVIDIA docker 驱动 :安装 CUDA toolkit
https://github.com/NVIDIA/nvidia-docker
centos安装docker：
https://www.cnblogs.com/yufeng218/p/8370670.html
https://blog.csdn.net/u010349092/article/details/107514401
docker run --gpus all nvidia/cuda:9.0-base nvidia-smi
4 安装
sudo apt-get install nvidia-container-runtime
5 然后重启下docker
sudo systemctl daemon-reload
sudo service docker restart
这里可以选择具体哪个版本 可以在
https://hub.docker.com/r/nvidia/cuda/tags?page=6
中查询
例如:https://www.cnblogs.com/journeyonmyway/p/11234732.html
注释:
以为tensoflow1.14.0只支持cuda10.0 所以
sudo docker pull nvidia/cuda:10.0-cudnn7-devel
进入容器:
1.安装conda/
sudo docker run -it --gpus all -P --name dl-base -v pwd:/host nvidia/cuda:10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffabe5c5dccfa21faa65d992413e31de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c5481ff595a199a9acd27c89bdceea/" rel="bookmark">
			7.4任务实践STM32F401RE ：中断方式检测按键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		任务内容：采用中断方式检测按键B1的状态，按键按下后执行如下操作:翻转指示灯LD2的状态
硬件原理：按键B1由引脚PC13控制：按键按下时为下降沿触发方式，释放时为上升沿触发方式。指示灯LD2由引脚PA5控制：PA5输出高电平，开启指示灯；PA5输出低电平，关闭指示灯。
目录
一，proteus 放置器件
1. 新建项目
2. 选择器件
3. 开始连线
二，STM32cubeMX 进行工程文件的预配置
1. 新建工程文件选择
2. 分析题意 设置引脚
3. 配置完成生成工程文件跳转keil5
三，Keil 编写具体实现代码
1. 编写实现的中断函数
2. 开始仿真
一，proteus 放置器件 1. 新建项目 Next-----next----
两次默认下一次即可
选择创建 firmware project
Cortex-M4
STM32F401RE
Finish 完成
2. 选择器件 我们需要 led灯 按键 电阻
搜索 LED-RED BUTTON RES 双击添加
3. 开始连线 分析题意
引脚PC13 控制按键B1
引脚PA5 控制LD2
最终连接如下图所示
3.1你可能会遇到的问题
1).如何放置器件？
点击器件后 在点击合适的位置两下 即可放下 线与线的连接 建议直线连接 可适当调整器件的位置
2).led灯选择角度位置怎么调？
可以rotate 进行调整角度的问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5c5481ff595a199a9acd27c89bdceea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bdaedeb2e00e1f8a0a014907e0c5093/" rel="bookmark">
			Web3.0是什么？带你解析Web3.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有人还在研究什么是元宇宙和NFT，那个概念已经过时了，据说现在流行的是Web3.0和DAO。如果你只想了解关于Web3.0的观点，那么先简明扼要的告诉你，Web3.0是未来。但就2022年人类科技水平的发展来看，你目前接触到的，向你兜售通过Web3.0赚钱概念的人，大多只是盯紧了你的钱包，下面我们详细了解一下什么是Web3.0。
Web 3.0，第三代互联网，意思是由DLT（分布式账本技术）支援，基于区块链的去中心化网路世界，也将是驱动元宇宙的基础建设技术。
在Web 3.0世界里，所有权及掌控权均是去中心化，建设者和用户都可持有NFT等代币而享有特定网路服务。Web 3.0能否在可见将来成为主流，仍是未知之数。但全球区块链技术热潮带动下，Web 3.0不再是纸上谈兵的理论或流行用语，而是颠覆网路世界的科技革命。
一、什么是Web3.0？ 万维网的发明者伯纳斯·李很早就提出了Web3.0的概念。他认为Web3.0是语义网，英文是Semantic Networks，其愿景是语义网能够使用本体论，分析互联网上的所有数据，允许机器在没有人工干预的情况下处理许多任务。这个就不展开解释了，因为现在大家熟知的Web3.0不是这个概念。虽然个人认为语义互联网更靠谱，但你现在听到的web3.0，它还不是这个意思，区块链出现之后，很多人把web3.0视为一种分权式网络，Decentralized Networks之后，又大幅简化，保留了一个最关键的概念——去中心化。
第一，为什么需要Web3.0？ 那你看一下现在的Web1.0和Web2.0都有哪些问题。Web1.0就是最早的Web，别人建好了网站，你只能看，比如早期的雅虎，每个人看的页面都是一样的新闻，至于放哪些内容，都是网站编辑们说了算，就像是电子化的报纸，这个比较古老了。Web2.0的典型就像是新浪微博和抖音，你不仅可以看，而且还可以发内容，而且你看的内容呢，也是根据你自己的使用习惯，平台个性化推送给你的。
你会不会觉得Web2.0其实已经挺好的了，为啥要整个Web3.0呢？
综上所述，你现在是不是觉得这Web2.0真的是一秒钟都呆不下去了？得想个办法颠覆这个扯淡的技术。正巧，Web3.0刚好就是来解决这些问题的，他就是那个救世主。让用户完全控制自己创造的内容价值，通过用户自己认同的协议进行分配。通俗的来讲就是把钱分给干活儿的人，那么为了达到这个目标，Web3.0涉及的最核心技术有哪些呢？
区块链、数字钱包、NFT、智能合约、DAO、DeFi，首先，为了证明互联网上你创作的内容是你的。第一步，得有一个你的概念，你在数字世界需要有身份，那么当前你在互联网上的身份是什么呢？每到一个网站或者使用一个新的APP，你需要注册一个账号，而这个就是你的Web2.0时代的身份。各个网站的身份他是不互通的，比如说你的微信账号就不能用来登录淘宝，这个身份本质上是当前平台后台数据库中的一个ID，也就是唯一标识。
第二，Web3.0涉及的最核心的技术有哪些？ 换句话讲，平台会是什么样的形式呢？用户打开Web3.0模式下的小视频平台，需要用数字钱包来授权一下。发布作品的时候呢，需要通过区块链进行数字资产的确权，也就是生成NFT，这个NFT存在用户的数字钱包下,而平台如果想要访问你的NFT，首先要获得你的授权,平台获得的广告收益，通过提前约定好的公开透明的智能合约，自动分配给内容创作者。
Web3.0时代的平台，或者说公司就是DAO，比如说大家到时候觉得，做一个类似抖音的小视频平台很有价值，于是大家通过DAO来众筹数字货币作为启动资金，如果你缺钱，又非常想做这件事儿，这不是问题。DeFi去中心化金融可以贷款给你，当然前提是你得有抵押物，你投入的数字货币的多少，也代表你在这家公司的话语权和投票权，所有的规则通过投票来确定，利益分配方式通过智能合约来自动执行。
如果有人想要偷偷改变利益分配方式，那不可能的，因信息都写代码里，而且上链了，一旦触发自动执行，可以说是相当的公平，毕竟区块链的本质，就是为了解决信任的问题，利益的产生和分配，不再通过虚无缥缈的道德和良心。而是将整个价值产生和消费的过程数字化，然后通过不可篡改的机制，并且极大的降低了执行的成本，不需要扯皮取证、仲裁和法院，这就是Web3.0的时代。
第三，Web3.0的时代，发财的机会是什么？ 虽然我不知道谁说的能代表真正的未来，但是你现在看到大陆上的那些公司或者数字货币，以及有些评论区里教你赚钱的，不是针对谁，有一说一都是骗子。Web3.0是个有意思的技术方向，但是现在还面临太多的问题和风险，比如说完全的去中心化，先不谈在国家这种组织还存在的情况下，是不是有可能存在。
就事论事来讲，如果有一些谣言或者威胁社会和谐的言论，完全的管控不了，这真的好吗？还有数字钱包，你的全部身家就放在其中，万一哪天你把密钥搞丢了。你的肉身拿身份证，反正是取不回来的，毕竟数字的钱包只认你的密钥，而不认你的肉身，这样真的合理吗？对于一家以DAO的形式组织起来的公司，投票决策和合约执行都是公开透明的，但这是提升公司成功率的核心因素吗？
看过《乌合之众》这本书讲到，一个群体整体表现出来的特征就是情绪化、无异议和低智商，而这显然不是一个成功企业该有的特征。另外，目前的世界数字化的部分还是非常少的，人在物理世界里的勾心斗角和尔虞我诈，区块链是不知道的。这些问题不是无解，只是解法还没有达成共识。
总结一下，对于一个新的理念，态度不要过于的二极管。事物的发展大多是阴中有阳，阳中有阴的。我个人对Web3.0未来还是很乐观的，虽然不完美，但有很多思路，能解决大家的不少问题。Web3.0的概念会随着物理世界整体数字化的进程，发挥越来越大的价值。就目前来看，Web3.0还是非常早期的状态，如果他真的是未来，那就先关注下，等起飞的那一刻，尽早冲进去。如果他不是未来，就关注下周围的人，不要被早早割了韭菜。
还记得NFT和元宇宙，这些概念吗？他们没有消失。只是没那么火了，Web3.0、NFT、区块链以及元宇宙都是非常相关的概念，你有足够的时间去理解和消化这些概念。比特币和去中心化的概念，从2009年初就诞生了，但现在已经过去了13年，大家仍然还在摸索这个技术的实际应用场景的过程中。但你可以发现，这个概念之前只在小众范围流传，即刻慢慢发展成了普通大众皆知的状态。
二、Web3.0的世界 Web3.0能给我们带来的东西就充满想象力，因为你可以创造任何现实世界中已经相当成熟的东西，链上充满了新大陆。比如去中心化金融(DeFi)，数字艺术品(NFT)，链上游戏(GameFi)等。
三、周星驰亲自下场招人，Web3.0究竟是什么？ 10月18日，60岁的演员周星驰首度开通社交平台账号，发文表示要亲自招聘web3人才。他在白板上写下“请人”，并在图片下附言：“在漆黑中找寻鲜明出众的Web3人才”。对于人才要求，周星驰写道：“熟悉Web3、有项目管理经验、有头脑又宅心仁厚”，且工作范畴是助他建造创意未来，并称会亲自选人。
Web3.0是渐行渐近的新一代价值互联网，是用户与建设者共建共享的新型经济系统，Web1.0为“可读”（read），Web2.0为“可读+可写”（read+write），而Web3.0将是“可读+可写+拥有”（read+write+own）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2397734b522c9d907ea0cd0c5b9316cd/" rel="bookmark">
			笔记｜李沐-动手学习机器学习｜现代卷积神经网络（视频24-30）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记｜李沐-动手学习机器学习｜现代卷积神经网络（视频24-30） AlexNet (视频24）主要改进：AlexNet架构AlexNet复杂度d2l代码btw VGG主要改进：VGG块从lenet到VGG 网络中的网络NiN主要改进：NiN块架构代码 含并行连接的网络GoogLeNet（视频27）回顾主要改进：Inception块GoogLeNet 批量归一化（视频28）批量规范层的从零实现批量规范层的框架实现课程QA搬运 ResNet残差块（Residual Block）ResNet块Residual到底是怎么处理梯度消失，训练到1000层的？ Kaggle竞赛 AlexNet (视频24） 随着数据量增大，可以用更深的网络去挖掘数据里更加复杂的信息。
AlexNet赢得了ImageNet数据集比赛的优胜。而其实AlexNet可以理解为一个更加复杂更大的LeNet。
主要改进： 丢弃法ReLuMaxPooling 计算机视觉方法论的改变（CV主要关心如何进行特征提取）
不再那么关注人工特征提取，而是端到端地学习
AlexNet架构 第一个卷积层
第二个卷积层以及第3、4、5个卷积层（比LeNet多了3个卷积层）
两个隐藏层+一个输出层
AlexNet的两个隐藏层显然大很多
更多细节（这些细节有助于更好地训练网络）
激活函数由Sigmoid变为ReLU两个Dense（4096）之后加入了丢弃层数据增强（卷积对于位置（光亮）敏感，所以在输入数据中输入更多的变种） AlexNet复杂度 AlexNet可学习参数的个数上多了10倍左右
d2l代码 d2l用的数据集是灰度图像数据集Fashion-MNIST，所以代码中的
通道量是1而非3；resize = 224来模拟ImageNet数据集对图片像素大小； 李沐老师的：
训练速度比lenet慢了。4190.6 examples/sec on cuda
btw 从代码上看alexnet和lenet没什么区别，但就是这些，跨度了20年。绝大部分的cnn论文想要证明自己的模型效果好，还是会使用ImageNet数据集。 VGG 前面AlexNet的最大问题是，他虽然是胖版的LeNet，但是很不规则，比如当我们想要进一步加深加大网络结构，不知道具体应该如何设计。所以需要整个框架要有更好的设计思路，这就是VGG在干的事情。
主要改进：VGG块 核心思想：使用可重复的块来配置深度神经网络
用大量3*3的卷积层形成一个块，然后多个块堆叠产生最后的网络。
使用VGG块的数量不同，得到VGG-11(包含8个卷积层，3个全连接层)VGG-16、VGG-19…
圆点的大小越大，占用的内存越多
从lenet到VGG 网络中的网络NiN （现在用的不多，但是有提出很多重要的概念）
前面的网络，在最后都使用了很大的全连接层，a)会占用很大的空间，b)占用很大的计算带宽，c)还容易带来过拟合（这一层就把所有参数给学习掉了）。
主要改进：NiN块 这两个1x1的卷积层，其实是相当于全连接层。唯一的作用就是对通道进行了一下融合。
架构 代码 在这里还看不太出来1x1卷积有什么好处。但是在googlenet上体现的更明显。
含并行连接的网络GoogLeNet（视频27） 回顾 主要改进：Inception块 Input和Output高宽不变，通道数叠加
蓝色的块才是真的用来提取特征信息的
inception块不仅增加了多样性（大量不同设置的卷积层），而且参数变少了
GoogLeNet 批量归一化（视频28） 之前存在的问题：顶部变化快，底部变化慢。但是底部变了，顶部也要变，从而导致收敛变慢。
回顾：均值和方差在每一层都会变化
批量归一化的思想：固定小批量的均值和方差，然后再做额外的调整
批量规范层的从零实现 批量规范层的框架实现 为了更好理解如何[应用BatchNorm]，下面我们将其应用(于LeNet模型)（ :numref:sec_lenet）。 回想一下，批量规范化是在卷积层或全连接层之后、相应的激活函数之前应用的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2397734b522c9d907ea0cd0c5b9316cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/369d1740104cbd40902090a359adf095/" rel="bookmark">
			STM32使用外部中断控制led灯亮灭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、所需环境软硬件1、软件2、硬件 二、中断介绍三、STM32CubeMX新建项目1、引脚配置2、配置EXIT3、配置SYS4、配置GPIO5、创建项目 四、Keil编写代码及烧录五、实现效果六、总结 一、所需环境软硬件 1、软件 STM32CubeMX
Keil
FlyMcu
以上软件均可在网上上免费下载到
2、硬件 STM32F103最小系统板一块
面包板一块
导线若干
led小灯泡一个
二、中断介绍 中断是由内核外部产生的，一般由硬件引起，比如外设中断和外部中断等。
处理器和外部设备的数据传输方式：
中断的全过程：
中断过程执行的示意图：
处理器根据不同中断的重要程序设置不同的优先级：
中断被响应的过程：
GPIO引脚的外部中断触发方式：
中断程序的编程步骤：
这里我们只需完成第五步：编写中断服务程序
中断服务任务处理通过用户编写的回调函数来实现：
三、STM32CubeMX新建项目 和之前一样，选择自己芯片的型号，我这里是STM32F103C8T6
这里需要一个GPIOB端口充当开关的角色，使用一根导线连接端口和电平，接高电平时，LED亮灯；接低电平时，LED灭灯。
1、引脚配置 A4输出控制灯的亮灭,设置为GPIO_Output
A1持续输出高电平,设置为GPIO_Output
A7持续输出低电平,设置为GPIO_Output
B5模拟开关,设置为GPIO_EXTI5
并且为PA4和PB5引脚起个名字，方便后续代码引用。
https://s17.aconvert.com/convert/p3r68-cdx67/0ixoa-par3t.gif
2、配置EXIT 3、配置SYS 4、配置GPIO 改变PB5引脚的触发模式
5、创建项目 四、Keil编写代码及烧录 在main.c中编写回调函数，回调函数就是中断程序执行的函数。
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){ if(GPIO_Pin == SWITCH_Pin){ //获取B5的电位 GPIO_PinState pinState = HAL_GPIO_ReadPin(SWITCH_GPIO_Port,SWITCH_Pin); //低电位 if(pinState==GPIO_PIN_RESET) HAL_GPIO_WritePin(LED_A4_GPIO_Port,LED_A4_Pin,GPIO_PIN_RESET);//把A4变为低电位 //高电位 else HAL_GPIO_WritePin(LED_A4_GPIO_Port,LED_A4_Pin,GPIO_PIN_SET);//把A4变为高电位 } } 使用FlyMcu烧录成功:
五、实现效果 可见，开关接高电平时LED灯变亮了，开关接低电平时LED灯灭了。因为外部电路的存在，LED灯一直是常亮的。
六、总结 使用外部中断模拟开关控制LED灯亮，首先需要弄懂中断控制的原理，因为有STM32CubeMX软件的帮助，我们只需要编写回调函数来设置中断后运行的程序。总的来说还是比较简单。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb61205d2c8d952951bcf141cab7dc0/" rel="bookmark">
			java 中 byte a = 1； a &#43;= 1和 a = a &#43; 1 有什么区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		byte a = 1; a += 1; System.out.println(a); a += 1; 会被编译为：byte a = (byte)(a + 1);
而 a = a + 1 呢？编译时会报错。
因为 1 默认是 int 类型 byte + init 类型会隐私转换为 int 类型，将 int 类型直接分配给 byte 类型就会报错
一般会采用强制转换的形式：a = (byte) (a + 1);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3cbadf9906293022a5bb1dc3f46060/" rel="bookmark">
			java 中 byte 溢出详解，为什么 byte 130 结果为 -126
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Main { public static void main(String[] args) { byte b = (byte) 130; System.out.println(b); // -126 } } 必备知识： 原码、反码、补码
原码：
就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。
反码：
正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。
补码：
正数的补码与其原码相同；负数的补码是在其反码的末位加1。
回到正题
在 java 中 byte 130 的 130 默认是 int 类型（十进制），int 类型占用 4 个字节。
将十进制的 130 转化为二进制值为：
00000000 00000000 00000000 10000010 使用 byte 130 意思是强制类型转换，会将 int 类型强制转换为 byte 类型，强制转化过程会进行截取，结果为：
10000010 通过截取后的结果可以看到，符号位（最高位）为 1，说明这是一个负数
在计算机中所有的数据都是以补码的形式出现。所以求出截取后的数据的补码即可。
原码：10000010 反码：11111101 原码变反码，最高位符号位不变，其他位取反，0变1,1变0 补码：11111110 反码变补码，末位加 1 求得 原码：10000010 的补码为 补码：11111110
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b3cbadf9906293022a5bb1dc3f46060/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b63343de6ac2b539fc1a75eedad922cd/" rel="bookmark">
			RaspberryPi树莓派分区扩容根目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派在安装后SD卡的分区只有一部分空间在使用，如果要使用全部分区必须扩容
1.如果是raspbian系统 直接使用命令
raspi-config 1.选择 Advanced Options
2.选择 Expand Filesystem
3.重启即可扩容
2.非官方系统方法 1.查看块设备
lsblk 确认挂载在/目录的块设备 记住类型 2.使用命令
#1.使用parted分区工具 parted #2.按p打印分区情况 p #3.扩容分区 3是p命令获得的分区number 100%的意思是100%的空闲空间 resizepart 3 100% 3.resizepart成功后resize分区
#ext使用resize2fs xfs使用xfs_grows resize2fs /dev/mmblk0p3 4.lsblk查看分区情况已经扩容成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48268b3703ded3321ae20e3680c43880/" rel="bookmark">
			Tomca和Servlet简单配置和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Tomcat 1.目录介绍 bin:专门用来存放Tomcat服务器的可执行程序。conf：专门用来存放Tomcat服务器的配置文件lib：专门用来存放Tomact服务器的jar包logs：专门用来存放Tomcat服务器运行时输出的日志信息temp：专门用来存放Tomcat运行时产生的零食数据webapps：专门用来存放部署的web工程work：是Tomcat工作时的目录，用来存放Tomcat运行时jsp范围为Servlet的源码 1.IDE配置Tomcat
注意花红的：因为TOmcat里面会有许多工程，这意思是我们要访问到次工程，而次工程叫啥。
打开默认会访问到webapp工程下的Index.html而不是在webapp下面的包下面的inde.html。如果在webapp工程下的index.html则直接会报出404.
2.Servlet 1.什么是Servlet 是javaweb三大组件之一。分别是servle,Filter（过滤器），listener（监听器）接收客户端发过来的请求并响应数据给客户端。 2.如何在idea使用 1.创建一个类实现servlet接口 package com.miao.tong.li; import javax.servlet.*; import java.io.IOException; public class test implements Servlet { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { System.out.println("我来处理数据啦"); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } } 2.在web中的web.xml配置servlet的路径 &lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48268b3703ded3321ae20e3680c43880/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e13cbc47dbd8a650e7a1c5c567184a80/" rel="bookmark">
			Linux Crond服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux Crond服务 标题内容crond定义，作用，特点crond配置参数说明crondcrontab命令方法crondcrond服务的注意事项 crond定义，作用，特点 crond定义与作用 Linux系统定时任务是由cron(crond)系统服务来控制的。服务如下: [root@cess-master01 ~]# systemctl status crond ● crond.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled) Active: active (running) since Mon 2022-10-17 10:24:03 CST; 5 days ago Main PID: 14999 (crond) Tasks: 1 Memory: 7.3M CGroup: /system.slice/crond.service └─14999 /usr/sbin/crond -n Oct 17 10:24:03 cess-master01 systemd[1]: Started Command Scheduler. Oct 17 10:24:03 cess-master01 systemd[1]: Starting Command Scheduler... Oct 17 10:24:03 cess-master01 crond[14999]: (CRON) INFO (Syslog will be used instead of sendmail.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e13cbc47dbd8a650e7a1c5c567184a80/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddd3e726025a4e59ab97456a4aa906de/" rel="bookmark">
			注意力机制Attention详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意力机制Attention详解 一、前言 2018年谷歌提出的NLP语言模型Bert一提出，便在NLP领域引起热议，之所以Bert模型能够火出圈，是由于Bert模型在NLP的多项任务中取得了之前所有模型都不能达到的出色效果。那么Bert模型它是如何提出的呢？我们来追溯Bert模型的发展历史：
首先Bert模型是基于Transformer提出的，Transformer同样是谷歌团队在2017年发表的论文 《Attention is all you need》 中提出，Transformer又是基于attention机制，注意力（Attention）机制由Bengio团队于2014年提出。而目前大部分attention模型都是依附于Encoder-Decoder框架进行实现。因此，我们要讲解Bert，必须要从Encoder-Decoder框架开始说起。
二、注意力Attention简述 什么是注意力： 对于人类来说，视野非常开阔，但焦点往往只有小部分范围，甚至一个点，这就叫做注意力。它可以帮助人类在众多的信息中去筛选对人类有帮助的信息。
注意力机制的核心目标是： 从众多信息中选择出对当前任务目标更关键的信息，将注意力放在上面。
三、Encoder-Decoder框架 上图是最常见的Encoder-Decoder框架图，在文本处理和语音识别的Encoder部分通常采用RNN模型；在图像处理的Encoder部分通常采用CNN模型。
举个栗子： 机器翻译
英文：Tom chase Jerry
中文：汤姆 追逐 杰瑞
对应在图中，输入序列 {x1=Tom，x2=chase ，x3=Jerry} ，经过Encoder，被编码成语义编码C，语义编码是一块高度抽象的内容。
这里的语义编码C的编码方式是啥呢？
编码方式有很多种，在NLP中常见的RNN/LSTM/以及它们的变种，这里我们以RNN为例。
输入序列{x1,x2,x3,x4}，通过RNN生成隐藏层的状态值{h1,h2,h3,h4}，最简单的办法可以直接采用最后时刻输出的ht作为C的状态值，这里也就是h4作为语义编码C的值，也可以将所有时刻的隐藏层的值进行汇总，然后生成语义编码C的值，这里就是C=q(h1,h2,h3,h4)，q是非线性激活函数。
再通过Decoder将其解码为中文内容，同样解码也可以采用RNN/LSTM/以及它们的变种进行解码。Encoder编码和Decoder解码的方式可以任意搭配。
解码完成后输出序列 {Y1=“汤姆”，Y2=“追逐”，Y3=“杰瑞”}。在此过程中，每次生成一个目标单词，每个目标单词的有效信息都不一样，例如“杰瑞”，与之最重要的信息是“Jerry”，其他的可以看作成噪声或者相关度不大的信息。
相比于注意力机制而言，还有一种分心模型：
体现在翻译输出时，对于输入贡献的注意力是一样的。例如翻译：“杰瑞”时，“Tom”，“chase”，“Jerry”三者贡献的注意力相同（同一个C）。
分心模型的计算：
Y1 = f ( C ) ； Y2 = f ( C ，Y1 ) ； Y3 = f ( C ，Y1，Y2 )
引入注意力机制之后：
此时会分配不同的语义编码C，语义编码C会告诉输入哪一个更为相关。
引入注意力机制后的计算：
Y1 = f1 ( C1 ) ； Y2 = f1 ( C2 ，Y1 ) ； Y3 = f1 (C3 ，Y1，Y2 )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddd3e726025a4e59ab97456a4aa906de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57bc26a1ad4c4bc9697644d658c7d129/" rel="bookmark">
			微信小程序跳转页面的不同方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序如何进行页面切换呢？
一，使用声明式导航 1.对于tabbar页面的跳转（若不明白tabbar可自行百度）
使用switchTab进行跳转
在wxml中输入
&lt;navigator url="/pages/message/message" open-type="switchTab"&gt;非tabbar页面的跳转&lt;/navigator&gt;
其中/pages/message/message是跳转的地址，跳转方式是switchTab
2.对于非tabbar页面的跳转
使用navigator进行跳转
在wxml中输入
&lt;navigator url="/pages/info/info" open-type="navigate"&gt;tabbar页面的跳转&lt;/navigator&gt;
其中/pages/info/info是跳转的地址，跳转方式是navigate
3.返回到上一个页面
在一个页面的wxml中输入
&lt;navigator open-type="navigateBack" delta="1"&gt;返回上一个页面&lt;/navigator&gt;
注意：要想返回到之前页面，open-type的类型必须是：navigateBack
而delta后的数字表示的是要返回的层数
二，使用编程式导航 1.在wxml中添加一个button组件（即按钮）
&lt;button bindtap="tiaozhuan" &gt;tiaozhuan2 &lt;/button&gt; //这是使用bindtap进行触摸，就是你点击这个按钮便会执行操作“tiaozhuan”
2.在js文件中添加名字为“tiaozuan”的函数，其中函数中使用wx.navigateTo指令
tiaozhuan() {
wx.navigateTo({
url: '/pages/lunbotu/lunbotu' //url后面是跳转地址（备注不要复制进去）
})
}
正如上面使用声明式导航说的，跳转到非tabbar页面的时候用navigateTo，而跳转到tabbar页面的时候用switchTab，这里便不做赘述，懂得都懂。（若不明白tabbar可自行百度）
最后就是“后退”环节了 1.在wxml中添加一个button组件（即按钮）
&lt;button bindtap="goback"&gt;后退&lt;/button&gt;
2.接着在js文件中定义“goback”函数
goback() {
wx.navigateBack({
delta:1 //这里的delta表示后退的页面数量，如果只退一个的话可以不写delta
})
}
以上是我对微信小程序的学习，若各位有发现问题，请多多指教！阿里嘎多！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6374fae9a5c4ab667ae962a5aec5012/" rel="bookmark">
			Ubuntu 查看内核版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dpkg --get-selections | grep linux-imagedpkg --get-selections | grep linux-image1、查看当前内核
方法一：sudo cat /proc/version
方法二：sudo uname -a
$ sudo cat /proc/version Linux version 5.15.0-50-generic (buildd@lcy02-amd64-009) (gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0, GNU ld (GNU Binutils for Ubuntu) 2.34) #56~20.04.1-Ubuntu SMP Tue Sep 27 15:51:29 UTC 2022 $ sudo uname -a Linux r********* 5.15.0-50-generic #56~20.04.1-Ubuntu SMP Tue Sep 27 15:51:29 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux $ sudo uname -r 5.15.0-50-generic 内核版本5.15.0-50-generic
2、查看可用内核
方法一：dpkg --get-selections | grep linux-image
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6374fae9a5c4ab667ae962a5aec5012/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a898e9b8f7a1d10799a4cddbfac586a/" rel="bookmark">
			集成电路/微电子/电子科学与技术 在IEEE上可以参考的期刊会议总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.会议 IEEE International Solid-State Circuits Conference，简称：ISSCC，国际固态电路会议
（顶会，每年仅有200篇左右）
IEEE International Electron Devices Meeting，简称：IEDM，国际电子器件会议
IEEE Symposia on VLSI Technology and Circuits，简称：VLSI，超大规模集成电路研讨会
European Solid-State Circuit Conference，简称：ESSCIRC，欧洲固态电路会议
IEEE Asian Solid-State Circuits Conference，简称：A-SSCC，亚洲固态电路会议
Hot Chips: A Symposium on High Performance Chips，简称：Hot Chips，高性能芯片研讨会
IEEE International Symposium on Circuits and Systems，简称：ISCAS，电路系统研讨会
IEEE/ACM International Symposium on Microarchitecture，简称：MICRO，微架构
International Symposium on Computer Architecture，简称：ISCA，计算机体系架构
International Symposium on High-Performance Computer Architecture，简称：HPCA，高性能计算机架构
International Conference on Architectural Support for Programming Languages and OperatingSystems，简称：ASPLOS，编程语言和操作系统的体系结构支持国际会议
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a898e9b8f7a1d10799a4cddbfac586a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a7a91b126ef696b064a0b26e7380679/" rel="bookmark">
			CS域与PS域的简介及区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、CS域CS的三个阶段CS的交换方式CS域的使用场景 二、PS域PS域的传输方式PS域的使用场景 CS域与PS域的区别三、总结 前言 我们了解到的数据传输有两个域，分别是CS域和PS域。我们常说的CS域就是电路交换域，通常用于语音通话，在2G和3G中都有应用到；我们常说的PS域就是分组交换域，通常用于数据业务，在3G、4G和5G中都有应用到。而还有一个IMS（IP多媒体子系统），相当于是PS域上的一个子系统，IMS的存在可以让用户在PS域上同时使用语音通话和数据业务。
一、CS域 CS（Circuit Switched）域，即电路交换域。首先需要建立一条传输数据的连接，建立完成之后开始数据的传输，此连接不会断开，直到数据传输完毕，才可以释放掉连接。所以一条链路只电路交换的特点是独占一条链路，一直用于数据传输。可靠性很高，但不高效。
这就相当于是小时候玩的听筒游戏，两个纸杯子之间连着一条线，两个人通话过程中，这条链路是不能断开的，直到通话结束。
CS的三个阶段 电路交换一般需要有三个过程：建立连接、数据传输、释放连接。
建立连接：建立一条用于电路交换的链路；数据传输：链路建立完成，用于数据传输；释放连接：链路使用完成之后，需要释放该链路。
由于电路交换是建立一条链路，专用于数据传输，直到数据传输完成，再释放连接。所以使用电路交换域进行数据传输的传输时延将会很低，但同时也存在一个很严重的缺陷，由于该链路一直存在，将会非常占用资源。 CS的交换方式 电路交换的几种常用交换方式，分别是：TDS（Time Division Switching，时分交换）、SDS（Space Division Switching，空分交换）和FDS（Frequency-Division Switching，频分交换）。
时分交换：利用时分复用原理，通过时隙交换网络完成话音的时隙搬移，从而做到入线和出线间话音交换的交换方式。空分交换：是在空间位置上选择出线并建立连接，通信完毕后拆除连接。频分交换：是指通过转换频带对频分复用信号的交换。 CS域的使用场景 因为现在基本上已经没有使用到1G的情况了，所以1G情况排除在外。
2G场景下是只连接了CS域；而在3G场景下，同时使用了CS域和PS域。
Q： 为什么3G是同时使用的两个域呢？
A： 因为在3G时代可以连接网络，进行数据传输（这时候就可以使用手机聊QQ啦）；但是也不能放弃掉手机的基本功能，打电话，所以就同时使用了两个域。
Q： CS域和PS域是两个不同的域，为什么3G可以同时使用这两个域呢？
A： 3G在使用这两个域的时候，是分开使用的。即在通话的时候，连接到CS域，在使用数据的时候，连接到PS域。
二、PS域 PS域（Packet Switch）表面意思就是分组交换。PS 域不能直接进行语音业务，PS业务就是常见的数据业务，也包括流媒体业务、VOIP等等。具有高效的传输效率，但可靠性没有CS域那么高。
PS域的传输方式 PS的传输方式是使用分组交换的方式进行的。
所谓的分组交换就是一组一组的数据，封装成为一个数据包，再以一个一个的数据包的形式进行数据传输的。与CS不同的是，PS没有一条固定的链路进行数据传输，换句话说，PS域的一条链路可以提供多个用户传输数据，只是可能不同用户使用链路的时间不同。所以PS域没有CS域的三个阶段。相对于CS域来说，PS域就提高了数据传输的效率。
PS域的使用场景 上文中又说到，3G中是使用了PS域的；现在的4G和5G是完全使用的PS域。
Q： 上文中说道PS域不能直接进行语音业务，并且4G和5G完全使用的是PS域，那么4G和5G是怎么完成通话的呢？
A： 在4G 刚开始的时候，正常使用数据的时候还是走的PS域，但是在接通电话或者拨打电话的时候，就会回落到2G或者3G上进行通话，这个现象叫做CSFB（CS fallback）；而在后来的4G中，可以通过IMS进行接通或拨打电话，此时的通话称为VoLTE call。在5G上也沿用4G的这个方案。
Q： 现在已经发展到5G了，为什么还保留着2G呢？
A： 第一点是因为现在中国还有很多老人是使用的2G手机，第二点是因为它牵扯语音通话，2G基站覆盖面较广 ，很多偏远地区都有2G网络，如果取消2G网络基站，很多偏远地区可能连电话都打不了。我们通常认为通话是手机最基本的要求，所以还是选择保留2G。
CS域与PS域的区别 Tips： 第二代通信系统的核心网仍然以电路交换为基础，因此，语音业务仍然是其主要承载业务，随着各种增值业务的不断增长，二代系统也可以传输低速的数据业务。
三、总结 CS域一般是用于语音业务的，应用于2G、3G中，其中2G的核心网只有CS域，而3G的核心网则是CS域和PS域。PS域一般是用于数据业务的，也可以通过IMS用于语音业务——VoLTE。CS域和PS域传输数据的方式不同，CS域是通过一条链路进行传输的，需要有连接建立、数据传输和连接释放这三个过程；PS域是通过数据包的形式进行数据传输的。 tips：以上文章为个人学习总结，望大佬们批评指正！
（文章中图片来自网络，如有侵权，请联系删除，谢谢。）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ebd9795681f504ba3fa841598ed83e/" rel="bookmark">
			位移运算法的解释与hashMap的应用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习jdk1.8版本的hashMap源码时，我们能看到一行常量
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 该常量是用于定义hashMap的默认初始容量大小。根据注释中，大小为16.
但是它的定义方式并非是写为16，而是采用了"1 &lt;&lt; 4"的方式来定义。
这个其实就是采用位移运算的方式来指定其结果为16，
位移运算分为三种，左移运算、右移运算、无符号右移运算
其中的双箭头"&lt;&lt;"是位移运算中的左移运算。
关于三种运算的不同，参考这两篇：
https://blog.csdn.net/mizepeng/article/details/123852209
https://blog.csdn.net/weixin_43222122/article/details/104299203。
那么此处，"1 &lt;&lt; 4"为何就等于16？简单解释下，
其中的1，从10进制转换为二进制后也是1，此时再移动四位，最终在二进制中就会成为10000，
此时再把10000换成10进制，那么就是16.
。
看了原理图是不是清晰明了了，还可以通过再举个例子，来更加通俗易懂的解释左位移运算：
a &lt;&lt; b，依据a转为二进制后的值，在其后面加上b个0.
比如 3 &lt;&lt; 4。
3的二进制是11，11+4个0为110000.
110000的10进制就是48了
回到原题，hashmap采用位移运算的意义是什么呢？意义就在于速度更快。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e55fb29056e5d09da326e1028bdb8b08/" rel="bookmark">
			axios异步问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		情景介绍 做了一个点击按钮，屏蔽表格中一行信息的功能。
问题发现 调用后端接口后，后端会将屏蔽的数据去掉，然后前端再次请求获取剩下的数据刷新页面。
已经封装好了 获取表格数据getData 和 屏蔽数据delData，结果在点击屏蔽按钮后，获取到的数据已经没有那一条记录了，但是页面上的那条记录没有消失。
shieldData() { const param ={}; delData(param).then(res =&gt; { // 这一步返回值屏蔽成功 console.log(res); })； // 重新获取表格数据并渲染到页面 this.getData(); } 问题分析 请教同事后了解，因为axios请求是异步的，而执行时是先执行完同步，再执行异步，所以上面的代码实际执行顺序是：getData() -&gt; delData
问题解决 异步的问题，要让getData再delData执行之后，将getData放到delData.then()中。
shieldData() { const param ={}; delData(param).then(res =&gt; { // 这一步返回值屏蔽成功 console.log(res); // 重新获取表格数据并渲染到页面 this.getData(); })； } 总结 注意异步的执行顺序，后执行的放到.then()中去。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/204/">«</a>
	<span class="pagination__item pagination__item--current">205/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/206/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>