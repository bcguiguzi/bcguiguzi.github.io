<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2264b26a595cb5fb30d03fef24b9a4fa/" rel="bookmark">
			前端与后端交互中需要注意的要点和解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端与后端交互是Web开发中的关键部分，它涉及到数据传输、用户认证、安全性等方面的考虑。以下是前端与后端交互的注意点、要点和解决方法：
1. API设计和文档
要点：确保后端API的设计清晰、一致，有详细的文档。解决方法：使用常见的API设计标准（如RESTful），创建易于理解的API文档，例如使用Swagger或API Blueprint。 2. 数据格式
要点：前后端需要统一的数据格式，通常使用JSON。解决方法：确保前后端都能正确地序列化和反序列化JSON数据。使用前端库（如axios、Fetch）来处理数据的请求和响应。 3. 跨域问题
要点：跨域请求可能会受到浏览器的限制。解决方法：后端可以配置CORS（跨源资源共享）来允许特定的域名访问API。另外，使用JSONP、代理服务器或WebSocket等方法也可以解决跨域问题。 4. 安全性
要点：防止跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等安全漏洞。解决方法：实施安全性最佳实践，如输入验证、输出编码、使用HTTPS、生成随机CSRF令牌等。 5. 用户认证与授权
要点：确保只有授权的用户能够访问敏感数据和功能。解决方法：使用认证机制（如JWT、OAuth）来验证用户身份，然后在后端进行授权检查，控制用户的权限。 6. 错误处理
要点：处理前端与后端之间的通信错误和异常。解决方法：在API中使用合适的HTTP状态码，如200、400、401、404、500等，以及具体的错误消息。前端应该根据不同的状态码采取相应的行动。 7. 性能优化
要点：降低前后端通信的延迟，减少网络请求的次数。解决方法：使用HTTP/2或HTTP/3来减少请求的开销，合并请求，启用缓存，采用延迟加载等策略来提高性能。 8. 异步通信
要点：前端与后端通信通常是异步的，需要处理回调或Promise。解决方法：使用Promise、async/await或回调函数来管理异步操作，确保数据的一致性和可靠性。 9. 调试和监控
要点：在开发和生产环境中监控和调试前后端通信。解决方法：使用开发工具和监控系统，记录请求和响应，以便快速诊断和解决问题。 10. 版本控制
要点：确保前后端的代码和API版本保持一致。解决方法：使用语义化版本号控制API版本，定期升级前后端代码，并确保向后兼容性。 前端与后端交互是Web开发中的重要环节，合理的设计和良好的实践能够确保应用程序的可维护性、性能和安全性。通过以上要点和解决方法，可以帮助你更有效地处理前后端交互。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a051379dba758aedef599342bb15f20/" rel="bookmark">
			android 常用查看手机信息命名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. adb shell wm size
Physical size: 1600x480
2. adb shell wm density
Physical density: 160
3：打开window 动态调试开关
dumpsys window -d enable a
AMS log开关命令：adb shell dumpsys activity log x on user版本请如下打开AMS log开关:
/frameworks/base/services/core/java/com/android/server/am/ActivityManagerDebugConfig.java
static boolean DEBUG_ALL = false; //置为true
4：readelf -t fingerprint.default.so 读取elf文件段信息
readelf --string-dump=".sunwave.version" fingerprint.default.so 从版本段获取版本信息
5:打开与关闭mtklog
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name start --ei cmd_target 7
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name stop --ei cmd_target 7 userdebug 抓systrace, 需要打开mtklog
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a051379dba758aedef599342bb15f20/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a687cd9214540b95603076857e85d71/" rel="bookmark">
			Vue2中使用Pinia
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue2中使用Pinia 1.初始化配置 # main.js import Vue from 'vue' import App from './App.vue' import pinia from './stores/index' import { PiniaVuePlugin } from 'pinia' Vue.use(PiniaVuePlugin) new Vue({ render: h =&gt; h(App), pinia, }).$mount('#app') 2.模块化开发 新建stores文件，建立入口文件index.js
# index.js import { createPinia } from 'pinia' export * from './nodules/useUserStore' const pinia = createPinia() export default pinia stores文件下新建nodules模块文件(有点类似dva中的model.ts)
在nodules中新建useUserStore.js文件
# useUserStore.js import { defineStore } from 'pinia' export const useUserStore = defineStore('store', { state: () =&gt; { return { tagslist: [{ title: '首页', key: 'home', closable: false }, { title: '用户中心', key: 'home', closable: false }, { title: '讨论', key: 'home', closable: false }], } }, actions: { changeTagList(obj) { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a687cd9214540b95603076857e85d71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df219304157e017dddacabd2366b9ef2/" rel="bookmark">
			如何才能让一套组件库兼容vue2和vue3？（基本思路）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 距离Vue3在2020年9月18日第一次发布到现在，已经过去了将近三年时间，虽然目前许许多多的新项目都开始使用vue3作为主要开发语言，但是因为旧项目比较庞大臃肿，很多的业务中项目、模块等都非常多，贸然升级的成本和风险都较高，所以公司中的许多老项目依旧是vue2的，那么如何去用同一套标准UI的组件库来兼容vue2和vue3就成了一个需要解决的问题。因为细节和代码会比较多，这里给大家提供一下最佳学习的大致的解决思路。
当然，最简单的方案实际上还是开发两套组件库，就像是Vue组件的标杆，Element ui ⇒ Element Plus。
解读2. x 和 3.x的版本 首先其实从版本特性上来说，一共我们可以分为三种情况
@vue/composition-api + Vue 2 ≈ Vue 3Vue 2.7 (因为组件式API在2.7就被支持了)Vue 3.x 兼容方案 因为再去兼容传统的vue2(非2.7版)的成本和付出和收入并不成正比，所以我们指的兼容实际上是只vue2.7与vue3兼容，而且我们的兼容方案实际上是去向着vue3靠近，利用我们自己写的兼容代码去抹平vue2.7到vue3的差异。想知道具体差异可以在迁移文档中查看。
总体方案其实差不多，基本就是安装判断所在环境具体版本，使用该版本的产物。
在开发环境的组件脚手架中(编译兼容方案) 其实总体的思路都是一样的，判断所在环境具体版本，然后使用该版本的代码。
所以，首先我们要做的是需要安装两个版本的Vue以及会用到的相关插件
```bash npm i vue2@npm:vue@^2.7.14 vue3@npm:vue@^3.2.45
npm i @vitejs/plugin-vue@2.0.0 npm i @vitejs/plugin-vue2@2.2.0
npm i @vue/compiler-sfc-vue2@npm:@vue/compiler-sfc@^2.7.14 npm i @vue/compiler-sfc-vue3@npm:@vue/compiler-sfc@^3.2.45
npm i @vitejs/plugin-vue-jsx @vitejs/plugin-vue2-jsx ```
然后在vite的配置中对应需要转换和判断的部分都要进行一次vue版本判断并且去使用对应的版本，如下面的例子。
javascript resolve: { extensions: ['.ts', '.tsx', '.js', '.vue', '.less', '.css'], alias: { vue: isVue3() ? path.resolve( path.dirname(require.resolve('vue3')), 'dist/vue.runtime.esm-bundler.js' ) : path.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df219304157e017dddacabd2366b9ef2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13e52c317569accc33bda3e3c8ed8e66/" rel="bookmark">
			前端面试八股文【很经典 很全面 字字珠玑】【建议收藏&#43;关注】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CSS篇1.说一下 CSS 的盒模型2.CSS 选择器的优先级？3.隐藏元素的方法有哪些？4.px 和 rem 的区别是什么？5.重绘重排有什么区别？6.让一个元素水平垂直居中的方式有哪些？7.CSS 的哪些属性哪些可以继承？哪些不可以继承？8.有没有用过预处理器？9. CSS样式文件引入的方式有哪些? link和@import的区别是?10.display属性有什么作用？它有哪些值？11. 介绍一下页面元素定位中的绝对定位、相对定位、流动定位、浮动定位，并阐述他们的区别12.谈谈你见过的浏览器不兼容问题？如何使用IETest?13.display:none和visibility:hidden的区别是14.html5有哪些新特性，如何处理html5对低版本的兼容问题 Javascript 篇1.浏览器加载文件(repaint/reflow)2.cookie、localstorage和sessionStorage的区别3.浏览器本地存储与服务器端存储之间的区别4. src和href的区别?5. bind函数的兼容性6. 解释下事件代理7.解释下js中this是怎么工作的?8.什么是闭包? 闭包有什么作用?9. 什么是伪数组？10.undefined和null的区别, 还有undeclared:11. 简述事件冒泡机制。12.解释下为什么接下来这段代码不是 IIFE(立即调用的函数表达式)：function foo(){ }();?13. 请指出 document load 和 document ready 两个事件的区别。15.浏览器端的js包括哪几个部分?16.DOM包括哪些对象?16.1 常用的DOM方法:16.2 常用的DOM属性 17. js有哪些数据类型?18.基本类型与引用类型有什么区别?19. 关于js的垃圾回收20.动画有哪些实现方法?21.浅拷贝22.深拷贝23. 说一下原型链24. new 操作符具体做了什么？25.script 标签里的 async 和 defer 有什么区别？26. setTimeout 最小执行时间是多少？27. promise 的内部原理是什么？它的优缺点是什么？28.promise 和 async await 的区别是什么？29.浏览器的存储方式有哪些？30.token 存在 sessionstorage 还是 loaclstorage？31. token 的登录流程。32.页面渲染的过程是怎样的？33.DOM 树和渲染树有什么区别？34.精灵图和 base64 的区别是什么？35.svg 格式了解多少？36.HTTP 协议规定的协议头和请求头有什么？37.说一下什么是“同源策略”？38.防抖和节流是什么？39.有没有做过无感登录？40.大文件上传是怎么做的？ Vue篇1. 生命周期1.1 有哪些生命周期1.2首次进入页面或者组件，会执行哪些生命周期1.3在哪个阶段产生\$el，$data1.4 第n（n&gt;1）次进入组件会执行哪些生命周期 2.对keep-alive的理解3.v-if 和 v-show的区别4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13e52c317569accc33bda3e3c8ed8e66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffc5730b8e6de4e76afbaad3350a5f36/" rel="bookmark">
			【原创】Python之Flask简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python之Flask简介 Flask是一个轻量级的Python Web框架，适用于搭建简单而灵活的Web应用程序。本文将为你介绍Flask框架的基础知识，并演示如何使用Flask构建一个简单的Web应用。
Flask的特点 Flask具有以下几个特点，使其成为广受欢迎的Web框架之一：
简单易用：Flask的设计理念是尽可能简单，并遵循Python的哲学。它提供了简洁的接口和灵活的扩展点，使开发者可以快速上手并构建Web应用。
轻量级：由于Flask的核心功能比较精简，因此它的代码量相对较少。这使得Flask非常适合构建简单的、小型的Web应用。
灵活可扩展：Flask采用了模块化的设计，开发者可以根据需求选择并安装插件和扩展，从而增加额外的功能和特性。
丰富的生态系统：Flask拥有庞大且活跃的社区，提供了大量的扩展、插件和文档，使开发者能够更加高效地构建Web应用。
安装和配置Flask 在开始使用Flask之前，需要先安装和配置它。可以按照以下步骤进行：
使用pip命令（假设你已经安装了Python）安装Flask：
pip install flask 创建一个新的Python文件，例如app.py，并导入Flask模块：
from flask import Flask 初始化Flask应用程序：
app = Flask(__name__) 编写一个简单的Flask应用 下面以一个简单的问候应用为例，介绍如何编写一个Flask应用。
from flask import Flask app = Flask(__name__) @app.route('/') def hello(): return 'Hello, Flask!' if __name__ == '__main__': app.run() 以上代码实现了一个简单的Web应用。首先，使用@app.route('/')装饰器指定了路由URL为根路径(‘/’)时的处理函数。在hello()函数中，返回了一个简单的问候消息。最后，通过app.run()运行应用。
运行Flask应用 要运行Flask应用，可以在终端中执行以下命令：
python app.py Flask应用将在本地启动，并监听默认端口5000。打开浏览器，并访问http://localhost:5000，即可看到显示的问候消息。
扩展Flask应用 Flask提供了大量的扩展，使你可以轻松地添加各种功能和特性。
例如，可以使用flask_sqlalchemy扩展来添加数据库支持，使用flask_wtf扩展来实现表单验证等。可以通过pip命令安装这些扩展。
pip install flask_sqlalchemy pip install flask_wtf 具体使用方法和示例可以参考Flask的官方文档和扩展文档。
结论 Flask是一个简单而灵活的Python Web框架，适用于搭建简单而灵活的Web应用程序。它的简单易用和灵活可扩展性使其成为很多开发者喜爱的选择。希望本文能帮助你快速入门和理解Flask框架，并能用它构建出你期望的Web应用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84b6a32a794fb4b3d50a8b9cf8d7e791/" rel="bookmark">
			L Grayscale Confusion【2023牛客多校第10场】【拓扑排序】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：“范式杯”2023牛客暑期多校训练营10 —— L Grayscale Confusion 题意：给定 n 个三元组 ( r i , g i , b i ) 。构造一个长度为 n 的数组 w， 使得 ①w1 = w 2 ②对于任意 i, j ，若 r i &gt; r j , g i &gt; g j , b i &gt; b j ，则 w i &gt; w j 输出任意合法构造均可。 思路： AC代码： #include&lt;bits/stdc++.h&gt; using namespace std; int n, r[1005], g[1005], b[1005], in[1005], q[1005], hh = 0, tt = -1, ans[1005]; int e[1000005], ne[1000005], h[1000005], idx; void add(int a, int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } bool small(int x, int y){ return r[x]&lt;r[y] &amp;&amp; g[x]&lt;g[y] &amp;&amp; b[x]&lt;b[y]; } signed main(){ memset(h, -1, sizeof h); cin&gt;&gt;n; for(int i = 0; i&lt;n; ++i) scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84b6a32a794fb4b3d50a8b9cf8d7e791/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bea6d26e5893dd16f4fdb99b108ab130/" rel="bookmark">
			英语写作中“导致”、“引起”cause、bring about、lead to、result in、result from等的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、在cause、bring about、lead to、result in和result from 中：
cause一般指引起坏的结果；
bring about可以指引起好的、或坏的结果；
lead to、result in主要指引起（导致）坏的结果，有时也可以指引起中性、或好的结果；
result from多指一个坏结果由什么引起，也可用于一个好结果由什么引起。
二、除result from 外，这些expressions 的用法比较简单，有下列两种：
to cause/bring about/lead to/ result in a bad result (consequence problem error shortage deficit ……)
或者：
to be caused/to be brought about 例句：
In deep learning, insufficient data would cause/bring about/lead to/result in overfitting.（在深度学习中，数据不足会引起过拟合。）
Not every effort brings about/lead to/results in a desired outcome. （并不是那个努力都能导致（产生）想要的结果。）
Why we protect data? It’s not just because there are adversaries on the Internet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bea6d26e5893dd16f4fdb99b108ab130/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b9be5d9c60042014db06b2f6bca244/" rel="bookmark">
			【Yolov8标注数据集】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Yolov8自动标注数据集教程 1 前言2.1 手动标注数据集2.2 划分数据集2.3 Yolov8环境配置2.3.1 Yolov8下载2.3.2 Yolov8环境配置 2.4 Yolov8模型训练，得到初步的检测模型2.4.1 训练方式2.4.2 训练过程中遇到的问题 3 使用初步的检测模型实现自动数据集标注3.1 使用初步的检测模型生成labels3.1.1 修改default.yaml的参数配置，以保存由模型预测得到的labels的.txt文件3.1.2 预测待自动标注的数据集 3.2 微调labels 1 前言 使用Yolov8自动标注自己的数据集，大致步骤：
（1）首先，先手动标注一部分数据集，进行模型训练，得到初步的检测模型；
（2）然后，使用初步的检测模型实现自动数据集标注。具体而言，将需要自动标注的数据集，通过预测predict的方式，生成labels，并使用标注工具对labels进行微调。
接下来，将详细介绍Yolov8自动标注数据集的具体步骤。
2.1 手动标注数据集 标注工具推荐两种，分别为在线标注网站MakeSense{MakeSense具体标注教程}和离线软件labelImg{ labelImg具体标注教程}。
不过，在进行手动标注数据集之前，还需要批量将视频转为图像序列，具体代码如下：
# 导入所需要的库 import cv2 import os import numpy as np datasets_path = ["/home/y/Code/.../1/04_20200423_100708_5f.mp4", "/home/y/Code/.../1/04_20200423_101346_5f.mp4", "/home/y/Code/.../1/04_20200423_102826_4f.mp4" ] # 保存图像序列的文件夹 root_image_path = r"/home/y/Code/test/dataset/" # 定义保存图片函数 # image:要保存的图片名字 # addr；图片地址与相片名字的前部分 # num: 相片，名字的后缀。int 类型 def save_image(image, addr, num): address = addr + str(num) + '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6b9be5d9c60042014db06b2f6bca244/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce360bcbab04ccf4ad7eab60fbdecc9/" rel="bookmark">
			将点云数据投影到图像上并生成带有颜色的激光雷达点云：Python实现指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 引言 点云数据在许多应用领域，例如地理信息系统、自动驾驶汽车、机器人、3D建模等领域都有重要应用。这种数据通常是3D空间中的点集，其中每个点都具有三维坐标。但是，通过将点云数据投影到2D图像上并为其添加颜色，我们可以更容易地可视化和分析这些数据。
在本文中，我们将探讨如何使用Python将点云数据投影到图像上并为其添加颜色。具体的实现细节和完整的项目代码将在后面提供。
2. 基本概念
2.1 点云数据 点云数据是三维空间中的点集。每个点可能包含位置（x, y, z）和其他关联数据，如颜色、强度或法线。
2.2 图像投影 将3D点云投影到2D图像上是通过一个数学变换实现的，该变换将每个3D点的坐标映射到2D图像上的一个点。这通常涉及到相机的内参和外参。
3. 使用Python将点云投影到图像上
3.1 准备工作
首先，我们需要安装必要的库。对于这个任务，numpy 和 opencv 是非常有用的。
pip install numpy opencv-python 3.2 读取点云数据
通常，点云数据可以存储在.pcd或.ply文件中。这里为简单起见，我们假设点云数据存储在一个numpy数组中。
import numpy as np # 假设点云数据是一个Nx3的数组，每行是一个点的x,y,z坐标 points_3d = np.load('points_3d.npy') 3.3 定义相机参数
为了投影3D点到2D图像上，我们需要定义相机的内参和外参。
# 假设的相机内参 fx, fy = 500, 500 # 焦距 cx, cy = 320, 240 # 主点 # 假设的相机外参 R = np.eye(3) # 旋转矩阵 t = np.array([[0], [0], [-1000]]) # 平移矩阵 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ce360bcbab04ccf4ad7eab60fbdecc9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19ce4d7fbe6f87ee9ea84372a12bec0a/" rel="bookmark">
			【QEMU】编译安装 qemu 8.0.4 及安装 Kylin V10 ARM64 版本全记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标 手头没有 ARM64 硬件环境，只能使用 X86 设备上模拟 Aarch64（Arm64）架构环境，用于安装国产 操作系统（例如：银河麒麟 Kylin V10）。
目前跨硬件架构的模拟器神器首选就是 qemu 了，可以模拟各种硬件环境。
我的思路：首先在 Windows 上使用 Vmware 安装 Kylin V10 X86_64 版本，然后在虚拟机内安装 qemu，最后使用 qemu 模拟 ARM 硬件 安装 Kylin V10 ARM64 版本，总体操作顺序如下图所示：
Windows -&gt; VMware -&gt; 安装 Kylin V10 X86_64 -&gt; 安装 qemu -&gt; 安装 Kylin V10 ARM64
注意： 你也可以在Windows 下直接使用 qemu 来模拟 arm 硬件，但运行性能比较差。需要使用 TAP-Windows 安装 tap 类型的虚拟网卡用来实现网络通讯，具体方法可 参考这篇文章。
使用Qemu在Windows上模拟arm平台并安装国产化操作系统 安装步骤 安装 Kylin V10 X86_64 版本及之前的步骤比较直观（注意需要安装 ‘带 UKUI GUI 的服务器’），这里就不作介绍，各位看官可自行百度。以下步骤全部在安装好的 Kylin V10 X86_64 系统下进行。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19ce4d7fbe6f87ee9ea84372a12bec0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e56c68ebb5cc941226a55e8024c31165/" rel="bookmark">
			Nexus（Maven管理器）下载和安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们以 Nexus 2.x 为例，演示 Nexus 的安装过程。
官方下载地址 1. 进入 Nexus 2.x 下载页面，根据本机操作系统，选择对应的版本进行下载，如下图所示。
2. 将下载 Nexus 安装包解压到本地磁盘，可获得 nexus-2.14.20-02 和 sonatype-work 2 个目录，如下图
其中：
nexus-2.14.20-02：该目录中包含了 Nexus 2.x 运行所需要的文件，如启动脚本、依赖 jar 包等。sonatype-work：该目录中包含了 Nexus 2.x 生成的配置文件、日志文件等。 3. nexus-2.14.20-02 中包含以下目录及文件。
nexus-2.14.20-02 目录说明，如下表所示。
子目录说明bin命令中心（启动命令，关闭命令）conf配置中心（管理着仓库列表、日志配置，以及安全设置）libNexus 的库文件，Nexus 运行时需要的 jar 包所在的目录logs存放日志文件nexusNexus 应用程序tmp存放Nexus 运行时产生的临时文件 4. .进入 \nexus-2.14.20-02\bin\jsw 文件夹，根须操作系统版本选择合适的目录，由于我的操作系统是 Windows 10 64 位，所以我选择 windows-x86-64 目录，如下图所示。
5. 进入 windows-x86-64 目录后可以看到如下文件。
其中：
console-nexus.bat：启动 Nexus 并在 DOS 命令行中展示启动过程。install-nexus.bat：将 Nexus 安装为 Windows 服务，开机自动启动。start-nexus.bat：启动 Nexus。stops-nexus.bat：停止 Nexus。uninstall-nexus.bat：与 install-nexus.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e56c68ebb5cc941226a55e8024c31165/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/539ada5130c054cbc71092e3050296f8/" rel="bookmark">
			微信小程序碰到情人节-我们结婚吧---【小程序花园】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信目录集链接在此：
详细解析黑马微信小程序视频–【思维导图知识范围】难度★✰✰✰✰微信小程序开发实战（第2版）入门–【开发实战（第2版）】★★✰✰✰ 不会导入/打开小程序的看这里：参考
微信小程序开发实战（第2版）入门–【开发实战（第2版）】
文章目录 本系列校训学习资源的选择本文效果图轮播图本案的轮播图代码官网的文档： 视图容器 /swiper 底部标签-tabBar知识点九宫格的实现 实际操练-轮播第一步，就是找到文件。第二步，先改动一下最显眼的代码第三步 狸猫换太子 实际操练-tabBar第一步，就是找到文件。第二步，先改动一下最显眼的代码第三步 ，可以换自己喜欢的图标 图标的注意事项图标资源打开小程序最简单，最无赖的手段 实际操练-九宫格本文章使用的鼠标方案：配套资源作业： 本系列校训 用免费公开视频，卷飞培训班哈人！打死不报班，赚钱靠狠干！
只要自己有电脑，前后项目都能搞！N年苦学无人问，一朝成名天下知！
学习资源的选择 黑马程序员微信小程序开发前端教程_零基础玩转微信小程序（130集）
https://www.bilibili.com/video/BV1nE41117BQ/
目录如下：
…
P303-微信小程序的环境准备08:21 00:00 到 05：16 获取APPid, 后面下载开发工具。
本文效果图 注：真实界面无外围的装饰
本例包含 了以下知识点：
底部标签-
九宫格
轮播图
在本文的最后也同样新介绍一套鼠标指针：从元气桌面的主题中提取出来，制成了单独安装的版本，不会安装的可以百度一下，本文最后也附了安装教程
情人节的鼠标方案，那必须是爱心之箭呀
轮播图 上一节的案例中也有介绍了。参考《微信小程序-轮播图-九宫格布局–【开发实战（第2版）】》
本案的轮播图代码 &lt;swiper indicator-dots="{{indicatorDots}}" autoplay="{{autoplay}}" interval="{{interval}}" duration="{{duration}}"&gt; &lt;block wx:for="{{imgUrls}}"&gt; &lt;swiper-item&gt; &lt;image src="{{item}}" class="silde-image" style="width:100%;height:176px;"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; 这是一般的小程序最常见的轮播图代码段。使用了block wx:for 的标签
页面全部代码在此：
&lt;view class="haibao"&gt; &lt;swiper indicator-dots="{{indicatorDots}}" autoplay="{{autoplay}}" interval="{{interval}}" duration="{{duration}}"&gt; &lt;block wx:for="{{imgUrls}}"&gt; &lt;swiper-item&gt; &lt;image src="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/539ada5130c054cbc71092e3050296f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371d6780c465922ef5bb0bce1a7cc0e5/" rel="bookmark">
			最新版本Anaconda下载及安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一.下载 1.进入Anaconda官网，官网地址：Anaconda | The World’s Most Popular Data Science Platform 2.点击Download,在C盘的“下载”目录处可以找到.exe文件 二.安装 1.右键.exe文件 --&gt; 以管理员的身份运行，点击Next 2.点击I Agree 3.可以选择All users，点击Next 4.可以点击Browse选择安装路径，也可以直接默认，点击Next 5.点击Install即可，等待安装 6.点击Next 7.点击Next 8.点击Finish 三.配置环境变量 1.右键此电脑 --&gt; 属性，点击高级系统设置 2.点击环境变量，找到系统变量里的Path，点击编辑 3.点击新建，在后面添加anaconda安装路径（之前安装选择的是默认就填默认路径，如果是自己选择的路径，就填选的路径）及 Scripts 我的anaconda安装路径为E:\Anaconda，所以我需要添加 E:\Anaconda E:\Anaconda\Scripts 4.点击确定就行 四.检验Anaconda是否安装成功 1.按win+R，输入cmd，点击确定，进入命令行窗口 2.输入conda --version 3.输入conda info 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a96476be5e4c4815609125463ace6b6/" rel="bookmark">
			MySQL之Explain详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Explain含义 Explain是SQL分析工具中非常重要的一个功能，它可以模拟优化器执行查询语句，帮助我们理解查询是如何执行的。分析查询执行计划可以帮助我们发现查询瓶颈，优化查询性能。
Explain作用 表的读取顺序SQL执行时查询操作类型可以使用哪些索引实际使用哪些索引每张表有多少行记录被扫描SQL语句性能优化 Explain语句返回列的各列含义： Explain返回列详解 数据准备 CREATE TABLE users (
id INT PRIMARY KEY AUTO_INCREMENT,
name VARCHAR(50) NOT NULL,
email VARCHAR(100) NOT NULL,
password VARCHAR(100) NOT NULL
)ENGINE = INNODB DEFAULT CHARSET = utf8;
CREATE TABLE products (
id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50) NOT NULL, price FLOAT NOT NULL
) ENGINE = INNODB DEFAULT CHARSET = utf8;
CREATE TABLE orders (
id INT PRIMARY KEY AUTO_INCREMENT,
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a96476be5e4c4815609125463ace6b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2202d448ef6a47ea87ebe2c1075d25d0/" rel="bookmark">
			MySQL所有基本操作详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一.MySQL的基本操作1.库操作1.1 查看数据库1.2 创建数据库1.3 使用数据库1.4 删除数据库 2.表操作2.1 创建表2.2 查看数据库中的表结构2.3删除数据库中的表结构2.4查询某个数据库内的所有表名 3.SQL中的数据类型3.1数值类型3.2字符串类型3.3日期类型 4.MySQL的增删改查4.1新增插入数据4.1.1基础的插入4.1.2指定列的的插入4.1.3多次数据的的插入4.1.4时间日期类型的插入 4.2查询数据SELECT4.2.1全列查找4.2.2指定列查找4.2.3 查询可以是表达式4.2.4指定别名 4.3去重DISTINCT4.4 查询结果排序ORDER BY4.4.1order by 子句4.4.2使用表达式及别名排序4.4.3可以对多个字段进行排序，排序优先级随书写顺序 4.5条件查询WHERE4.5.1比较运算4.5.2逻辑运算4.5.3between and4.5.4 in4.5.5模糊查询：LIKE4.5.6NULL 的查询：IS [NOT] NULL 4.5分页查询LIMIT4.6 修改语句UPDATE4.7删除DELETE 5.数据库约束5.1 约束类型5.2 NULL 约束和 NOT NULL约束5.3 UNIQUE：唯一约束5.4 DEFAULT：默认值约束5.5 PRIMARY KEY：主键约束5.6 FOREIGN KEY：外键约束 6.SQL的进阶操作6.1新增操作6.2聚合查询6.2.1 count6.2.2 SUM6.2.3 聚合函数搭配where表达式查询 6.3 group by 子句6.3.1分组6.3.2 分组之前条件筛选6.3.3 分组之后条件筛选having条件6.3.4 分组前查询与分组后查询结合 7.联合查询7.1多表查询一般实现的步骤7.2 内连接7.2.1通过from 表名1 ，表名2实现笛卡尔积7.2.2通过join.... on实现笛卡尔积 7.3 外连接7.4多表（三张以上）联合查询7.5 自连接7.6子查询7.6.1单行子查询7.6.2多行子查询 7.7 合并查询 一.MySQL的基本操作 首先sql操作中的关键字的是大小写不敏感的，create 和CREATE是一样的。
1.库操作 1.1 查看数据库 语法：
show databases; 示例：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2202d448ef6a47ea87ebe2c1075d25d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ed64f35199866ba6eb0a07a38473c2/" rel="bookmark">
			pcl欧式聚类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欧式聚类实现方法大致是：
1、找到空间中某点 p 1 p_1 p1​，用KD-Tree找到离他最近的n个点，判断这n个点到 p 1 p_1 p1​的距离。将距离小于阈值r的点 p 2 、 p 3 、 p 4 p_2、p_3、p_4 p2​、p3​、p4​…放在类Q里
2、在 Q ( p 1 ) Q(p_1) Q(p1​)里找到一点 p 2 p_2 p2​ ,重复步骤1
3、在 Q ( p 1 , p 2 ) Q(p_1,p_2) Q(p1​,p2​)找到一点，重复步骤1，找到 p 22 、 p 23 p_{22}、p_{23} p22​、p23​… 全部放进Q里
4、当Q再也不能有新点加入了，则完成搜索了
使用pcl库的欧式聚类：
std::vector&lt;pcl::PointIndices&gt; cluster_indices; pcl::EuclideanClusterExtraction ec; ec.setClusterTolerance (0.02); //设置近邻搜索的搜索半径为2cm ec.setMinClusterSize (100);//设置一个聚类需要的最少点数目为100 ec.setMaxClusterSize (25000); //设置一个聚类需要的最大点数目为25000 ec.setSearchMethod (tree);//设置点云的搜索机制 ec.setInputCloud (cloud_filtered); ec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7ed64f35199866ba6eb0a07a38473c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b11f7acbf97b071a40dde1d980347620/" rel="bookmark">
			Debian镜像及历史镜像（旧版镜像）下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debian 镜像地址 官方网址：https://www.debian.org/
历史镜像地址：http://cdimage.debian.org/cdimage/archive/
参考路径：http://cdimage.debian.org/cdimage/archive/12.0.0/amd64/iso-dvd/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d9b6ee7447ce0cf53622e356f93902e/" rel="bookmark">
			华为机试题16-购物单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述：购物单_牛客题霸_牛客网
此题比一般的0-1背包问题复杂一些，主要是多了附件的情况，而且要买附件的前提是已经买了主件，此处我们使用二维数组p存放物品的价格，二维数组v存放物品的价值（价格*重要度），其中第0列存放主件属性，第1列存放附件1的属性，第2列存放附件2的属性。
上述文字的操作就是为了将问题简化，最重要的是状态转移方程f[n][m]的编写，这里f[n][m]的含义表示：有n个主件，预算为m的情况下，能获得的最大满意度。将n转换成主件个数，有以下几种情况：
1、如果j&lt;p[i][0]，即如果预算j&lt;第i个主件的价格，则f[i][j]=f[i-1][j]，因为第i个主件买不起
2、如果j&gt;=p[i][0]，即如果预算j&gt;=第i个主件的价格，则又要比较买了第i个主件和不买第i个主件的大小，取最大值
现在将附件加以考虑，如果买了第i个主件，在资金约束条件下，总共有4种情况：
2.1 仅买主件
2.2 主件+附件1
2.3 主件+附件2
2.4 主件+附件1+附件2
综合考虑以上五种情况，取其中的最大值赋给f[i][j]即可
以下为代码实现
#include &lt;stdio.h&gt; #define N 60 /* N 表示可购买物品的个数, 题目描述不会超过60 */ #define M 32000 /* M 表示总钱数, 题目描述不会超过32000 */ int price[N][3]; int value[N][3]; int f[N][M]; /* 状态转移表达式，根据题意开辟最大的空间 */ static int max(int a, int b) { return (a &gt; b ? a : b); } int main() { int m; /* m表示scanf格式化输入的总预算 */ int n; /* n表示scanf格式化输入的总物品个数 */ int i, j; /* 下标i, j用于遍历for循环 */ int p1; /* p1表示scanf格式化输入的物品价格 */ int w; /* w表示scanf格式化输入的物品重要度 */ int z; /* z表示scanf格式化输入的物品属性，物品是主件还是附件。如果 z=0 ，表示该物品为主件，如果 z&gt;0 ，表示该物品为附件，z是所属主件的编号 */ int p[N][3]; /* p表示每个物品的价格，共3列，第0列表示主件的价格，第1列表示附件1的价格，第2列表示附件2的价格，下同 */ int v[N][3]; /* v表示每个物品的满意度，共3列，略 */ int temp[5]; /* 分别表示5种情况的满意度 */ scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d9b6ee7447ce0cf53622e356f93902e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/393adbc67a061fac59fbbb294327ec87/" rel="bookmark">
			永磁同步电机矢量控制（三）——电流环 PI 参数整定(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、电流环PI参数整定2、电流环带宽选择3、电流环带宽的测试方法 前面我们把电流环的闭环传递函数整定成了典型的二阶系统。这里我们再简化处理下电流环，把电流环闭环传递函数整定成一阶惯性环节。 1、电流环PI参数整定 首先，我们忽略上节电流环传递函数框图中的延迟环节和逆变器环节，这样电流环的开环传递函数为：
注意：电机电压方程的耦合项可以作为前馈，和电机模型里的反电势进行抵消；或者有的设计不加前馈，就是单纯的PI调节器，那么就靠PI调节器的积分快速累积去和电机模型里的反电势进行抵消。
那么电流开环传递函数为：
我们通过选取合适的PI参数来实现零极点对消，使其降阶变为一阶惯性系统，如下：
那么电流的开环传递函数简化为：
这样就化成了典型的一阶系统的开环传函，其闭环传函为：
这里wc为电流环带宽，单位rad/s。
2、电流环带宽选择 一般电流环带宽选取为PWM开关频率f的1/(10~20)之间。
也就是电流环带宽可以设置为200~1000 HZ之间。
3、电流环带宽的测试方法 电流环的带宽，可以先通过仿真确认，实际实验中，可通过阶跃响应的上升时间或者正弦响应的伯德图确认。
类比一阶RC低通滤波电路
fc为一阶低通滤波器的截止频率，tr为上升时间 ，其定义为输出稳定值10%-90%的时间差。
推导下公式的由来：
总结下：本节是在不考虑电流控制回路中的延迟，来设计电流环的PI参数的，而实际系统中，延时是真实存在的，这样的话，按理想情况下（不带延时）设计的带宽参数和实际的系统带宽是不相等的，而且两者之间存在较大的偏差，甚至有2、3倍的关系。虽然我们在电流环 PI 参数整定(一)中有考虑延时，但是没有具体讲解考虑延时后，带宽的设计和PI参数的整定。下一节我们就讲这个。见：永磁同步电机矢量控制（三）——电流环 PI 参数整定(三)
参考文章：https://www.zhihu.com/question/404520965/answer/1381263518
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/118/">«</a>
	<span class="pagination__item pagination__item--current">119/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/120/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>