<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be4469a0a1c97094d4201154ecf3ac5d/" rel="bookmark">
			100ah蓄电池多少度电
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、理论上可以存1.2度电。
2、蓄电池，是指放电后，能够用充电的方式使内部活性物质再生——把电能储存为化学能;需要放电时再次把化学能转换为电能。将这类电池称为蓄电池(Storage Battery)，也称二次电池。
3、瓦是功率单位，符号: W，千瓦是功率单位，符号:KW，1千瓦=1000瓦;欧姆定律: P=UI，即功率(瓦) =电压(伏)*电流(安)功率=12*100=1200;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/551a5bb337edbb8819a46dbfca5c0bc5/" rel="bookmark">
			LaTex 排版相关记录--1 参考文献排版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		找到latex代码中的 \bibligraphystyle{}，然后根据下面的各种需求进行替换
\bibliographystyle{unsrt}%样式同plain，只是按照引用的先后排序，参考文献会根据在正文中引用的先后顺序自动排列
\bibliographystyle{plain}%按字母的顺序排列，比较次序为作者、年度和标题
\bibliographystyle{plainat}
\bibliographystyle{unsrtnat}
\bibliographystyle{alpha}%用作者名首字母+年份后两位作标号，以字母顺序排序
\bibliographystyle{abbrv}%类似plain，将月份全拼改为缩写，更显紧凑
\bibliographystyle{ieeetr}%国际电气电子工程师协会期刊样式
\bibliographystyle{acm}%美国计算机学会期刊样式
\bibliographystyle{siam}%美国工业和应用数学学会期刊样式
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/270980a7d2a6e0fd5b6c3ed7ec7f4648/" rel="bookmark">
			云服务部署kafka 报错：“docker run“ requires at least 1 argument.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建kafka我们需要分两步走：
前沿：请大家注意在云服务器上部署任何新的服务一定要注意在对应云安全配置上开放此端口号
1、使用docker 先拉取 zookeeper，因为kafka对zookeeper是强依赖
命令：docker pull zookeeper:3.4.14
创建容器指令：docker run -d --name zookeeper -p 2181:2181 zookeeper:3.4.14
docker安装kafka
命令：docker pull wurstmeister/kafka:2.12-2.3.1
创建容器：
docker run -d --name kafka \
--env KAFKA_ADVERTISED_HOST_NAME=192.168.200.130 \
--env KAFKA_ZOOKEEPER_CONNECT=192.168.200.130:2181 \
--env KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.200.130:9092 \
--env KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \
--env KAFKA_HEAP_OPTS="-Xmx256M -Xms256M" \
-p 9092:9092 wurstmeister/kafka:2.12-2.3.1
这里需要注意一下有一个小坑，如果你之前一直是部署在自己电脑的虚拟机上的最后-p的命令使用的是--net=host wurstmeister/kafka:2.12-2.3.1，--net=host，直接使用容器宿主机的网络命名空间， 即没有独立的网络环境。它使用宿主机的ip和端口。但你要部署在云服务上就必须单独设置映射的端口号外加wurstmeister/kafka:2.12-2.3.1（-p 9092:9092 wurstmeister/kafka:2.12-2.3.1）
如果没有设置就会报错："docker run" requires at least 1 argument.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d421d9d2a8a59eb1eade19fa98f149a8/" rel="bookmark">
			Flutter动态化实现思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter的动态化可以通过在Flutter应用程序中集成可编程的UI组件来实现，例如将Dart代码作为字符串从服务器端下载并评估，从而生成新的UI元素。下面是一些设计思路和代码实现：
使用Flutter的自定义渲染器（Custom Renderer）：您可以编写一个自定义渲染器，该渲染器将解析从服务器或其他来源下载的UI描述，并使用Flutter Framework API构建UI元素。这种方法需要更多的开发工作，但它提供了更大的灵活性和控制权。
使用Flutter Widget树序列化：Flutter Widget树可以序列化为JSON格式，并可以发送到移动设备上的Flutter应用程序。您可以使用此功能，从远程服务器下载UI树并将其反序列化为真实的Flutter组件树。
使用Flutter插件：在Flutter中，插件是一个独立的、客户端库，在Flutter应用程序中运行。您可以编写一个插件，使其可以从云服务器下载所有UI元素并展示给用户。
以下是使用第二种方法的简单代码示例：
在远程服务器上创建一个JSON文件，其中包含Flutter Widget树的描述。 { "type": "Column", "children": [ { "type": "Text", "text": "Hello" }, { "type": "Text", "text": "World" } ] } 在Flutter应用程序中发送HTTP请求，下载此JSON文件并将其转换为Flutter组件树。 class MyApp extends StatefulWidget { @override _MyAppState createState() =&gt; _MyAppState(); } class _MyAppState extends State&lt;MyApp&gt; { List&lt;Widget&gt; widgets = []; Future&lt;void&gt; fetchData() async { // Send HTTP request to remote server and get JSON data final response = await http.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d421d9d2a8a59eb1eade19fa98f149a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9528a92782da24e2b5c8ca492fcc519c/" rel="bookmark">
			Go 语言
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		菜鸟教程——GO语言
文章目录 1.概念1.1 特色1.2 结构1.3 Go程序 2.基本语法2.1 标记2.2 行分隔符2.3 注释2.4 标识符2.5 变量2.6 +连接2.7 关键字2.9 格式化字符串2.10 类型转换2.10.1 基本类型转String2.10.2 strconv函数 2.11 输入2.11.1 fmt.Scanln()获取2.11.2 fmt.Scanf() 获取 3.数据类型4.变量4.1 概念4.2 使用方法4.2.1 指定变量类型(声明后若不赋值，使用默认值)4.2.2 根据值自行判定变量类型4.2.3 省略var4.2.4 多变量声明 5.运算符5.1 算术运算符5.2 关系运算符5.3 逻辑运算符5.4 位运算符5.5 赋值运算符5.6 其他运算符 6.条件语句6.1.1 单分支6.1.2 双分支6.1.3 多分支6.1.4 switch分支 7.循环语句7.1 for 循环7.2 Range定义 8.函数8.1 参数8.2 用法8.3 方法8.4 递归 9.变量作用域1.局部变量2.全局变量3.形式参数 10.数组10.1 一维数组10.2 多维数组10.3 函数传递数组10.3.1 形参设定数组大小10.3.2 形参未设定数组大小 10.4 切片10.4.1 定义10.4.2 make()函数10.4.3 切片初始化10.4.4 len() 和 cap() 函数10.4.5 append() 和 copy() 函数 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9528a92782da24e2b5c8ca492fcc519c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2beda0a47e263c869240007354d40943/" rel="bookmark">
			虚幻引擎 虚拟直播，实时渲染直播画面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备过程 需要的软件： obs
UE4.27
软件所用插件： offworld 官网地址：Amaze your audiences with the next generation of digital content
鼠标移至Products,点击下方的Unreal Engine Live-Streaming Tooklkit（虚幻引擎直播工具）
点击下方free download 点击之后稍微等一会，等待版本跳出，选择Toolkit的版本，这里我们选择4.27引擎版本，插件版本为v0.75.57，下载内容为zip，完成之后点击free download，登录即可下载
同时将下方的OBS Studio插件同样下载，点击下载之后，会跳转到GitHub
选择开始最新版，选择第一个exe，点击即可下载
最后一个插件，StreamFX，这是一个obs插件
GitHub - Xaymar/obs-StreamFX: StreamFX is a plugin for OBS® Studio which adds many new effects, filters, sources, transitions and encoders! Be it 3D Transform, Blur, complex Masking, or even custom shaders, you'll find it all here.
进来后点击code，之后点击下载zip
解完压缩后，将文件改名
将改完名字的文件放入下方的文件目录下
设置OBS 打开OBS，点击下方加号新建媒体（或者直播源）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2beda0a47e263c869240007354d40943/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fc785af022c36a305bbbc9432129cde/" rel="bookmark">
			nginx: [warn] the “ssl“ directive is deprecated, use the “listen ... ssl“ directive instead in /
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因： nginx在1.15.x版本之后不再使用 ssl on;
解决方法： ssl on; 要去掉，将 listen 443; 改为 listen 443 ssl;
原配置文件:
worker_processes 1;
events {
worker_connections 1024;
}
http {
include mime.types;
default_type application/octet-stream;
sendfile on;
keepalive_timeout 65;
server {
listen 80;
server_name localhost;
}
server {
# 监听443 端口
listen 443;
# 配置域名
server_name xxxx.com;
# 开启SSL验证
ssl on;
# 指定 ssl 证书路径
ssl_certificate /opt/ssl/xxxx.pem;
# 指定私钥文件路径
ssl_certificate_key /opt/ssl/xxxx.key;
# 客户端可复用会话的时间
ssl_session_timeout 5m;
# 指定启用的加密器类型，默认 ssl_ciphers HIGH:!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6fc785af022c36a305bbbc9432129cde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee3b396475c27a931d7b9557bedfa91b/" rel="bookmark">
			Linux内核调试打印
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内核编译
以jetson nano为例
配置环境环境变量
export CROSS_COMPILE=aarch64-linux-gnu- export LOCALVERSION=-tegra 选择deconfig配置文件，deconfig在arch/arm64/configs下
make ARCH=arm64 tegra_defconfig 编译
make ARCH=arm64 -j4 内核调试打印
调试信息级别宏，文件在根目录下 include/linux/kern_levels.h
include/linux/printk.h
内核调试打印，使用printk(KERN_INFO “\n INFO Level \n”); //指定打印的级别 （数字越小，优先级越高。
怎么让内核打印都输出文件名、函数和行号？
pr_info(“zhao-debug: %s, %s,%d —\n”, FILE,func,LINE);
怎么自定义宏调试？修改底层打印函数，并添加所在的文件、函数和行号。
#define yh_notice(fmt, ...) \ do { printk(KERN_NOTICE pr_fmt(fmt),##__VA_ARGS__); \ printk(KERN_DEBUG "zhao-debug notice:%s %s %d",__FILE__,__func__,__LINE__); } while (0) 输入 dmesg ,可以查看开机内核打印的信息。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287e6188d50f8dac0ea8890b8407e085/" rel="bookmark">
			Linux—— 将持久存储附加到容器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、准备永久存储位置
容器中的存储具有临时性，这意味着移除容器后，其内容会丢失。如果容器重新启动时必须保留容器所使用的数据，则临时存储就不够了。因此必须为容器提供持久存储。
二、从容器主机提供持久存储
为容器提供持久存储的一种简单方式是使用容器主机上的目录来存储数据。
podman可以在正在运行的容器内挂载主机目录。 移除容器时 ，系统不会回收容器主机目录的内容，新容器可以挂载它以访问数据。
三、准备主机目录
在准备主机目录时， 必须对其进行配置，以便容器内的进程可以访问它。
目录配置涉及:
1、配置目录的所有权和权限。
2、设留适当的SELinux 上下文。
容器内的应用所使用的用户帐户必须具有主机目录的访问权限。确保在主机目录上设置正确的权
限，以便应用可以访问。
还必须为主机目录配置适当的SELinux上下文类型，控制容器可访问的主机系统的文件。如果容器化层中存在安全漏洞，则这层额外保护会阻止容器内运行的应用访问共享目录之外的主机文件。对于以root用户身份在根容器内运行的应用，这种保护尤为重要。
如果没有SELinux提供这种额外保护，这些应用将对主机系统上的所有文件具有root访问权限，并且能够同时威胁主机和其他容器。启动容器时，podman可以设置主机目录的SELinux上下文。
四、挂载卷
在创建和配置主机目录后，下一步是将此目录挂载到容器。要将主机目录挂载到容器，可添加-v
选项到podman run命令，并指定主机目录路径和容器存储路径，其中用冒号分隔。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87dc9a1cc89aa026a1bd6d96a8628e01/" rel="bookmark">
			服务器报sql语句错误，IDEA报端口占用异常，记录一下解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一开始是访问服务器的时候报了sql语句异常
检查了一下发现是标签里多打了一个')' ，将问题改正后依旧报sql异常而且内容一模一样，这时候查看了IDEA报错
端口8080无法连接，但是提供的链接又是可以正常访问8080端口资源的 尝试了重启后重新加载IDEA
报错页面可以正常访问了，但每次都要重启当然不行，于是检查后发现，重启后第一次打开的服务器并不会报端口连接异常，而是从第二次开始访问出现，推测是服务器关闭不正常导致的（之前嫌烦把提示窗口关闭了，后面都是直接close服务器） ，将服务器stop后关闭，后续打开服务器端口连接异常消失，且服务器能够正常刷新
总结：正常关闭资源是个好习惯，引以为戒 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cca903ff4b44c00b7a0a794f7375223/" rel="bookmark">
			asp.net&#43;sqlserver超市会员管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(1) 系统管理
系统管理主要是对会员及其权限进行管理，不能每个人都有相同的权限，会员有会员的权限，管理员可以对整个系统进行操作。用户可以在其权限下进行合理的操作。系统管理员可能为每个用户设定组，可以对每个组设定权限，因此这个模块起到了很重要的作用。
① 权限设置-管理员管理
管理员管理主要是对用户进行会员管理，对其进行添加、修改、查询、删除、设置权限，确定所具有的职能。
② 权限设置-会员管理
会员可以进行个人信息查询，积分查询，积分商品兑换，积分历史记录；还可以在会员吧进行留言，浏览商品兑换消息，服务和投诉等。
③ 修改密码
用户进入系统可以对自己的密码进行修改。 (2) 会员吧
给会员提供了一个开放的环境、沟通的一个桥梁，会员们之间进行交流，购物的心德，大家互相交换信息，了解商家最新的消费活动，使大家购物更有目的性。
(3) 会员卡管理
会员卡管理这个模块主要功能是会员卡类型的管理(包括：普通会员卡，金卡，银卡，白金卡，VIP会员卡)，获取和修改收费规则。
(4) 会员信息管理
会员信息管理是系统的核心模块，这个模块主要包括员工信息查询、修改、添加、显示、删除。
① 会员信息查询
会员信息查询主要是根据会员卡号或者是身份证号对会员个人信息查询，在这个表格中可以看到会员所有注册信息，办卡时间，联系电话，姓名，邮箱，会员卡类型等信息。
② 会员信息添加
管理员对会员注册的信息进行输入记录，将数据保存到数据库中的会员表中。
③ 会员信息修改
对会员信息进行修改，例如：联系电话、家庭住址等。将修改后的信息保存到数据库会员表中。
(5) 收费管理
它主要包括积分查询，统计，积分历史记录查询。
根据会员卡号对积分查询，系统自动进行积分统计，将结果显示在表格上，同时将求得的积分保存到数据库积分表的总积分字段下。
积分历史记录查询时会员在刷卡后，经过系统将刷卡记录采集回来，管理员可以查看到每个会员刷卡的所得的积分，积分日期，积分类型等。本会员管理信息系统主要是以实际的业务流程为背景而设计的，页面整洁，使用方便。该系统使用Visual Studio.NET作为开发工具，用SQL Server作为后台数据库服务器。本系统是基于B/S（Browser/Server）架构的系统，主要以会员信息管理和收费管理为核心。本系统的开发和应用，从各方面都体现了当代社会信息管理的智能化和科学化，化简了繁琐的工作模式，提高了工作效率，避免了大量重复性的工作。
整个系统由会员信息管理模块、收费管理模块、会员卡类型管理模块和会员吧组成。整个系统能够独立运行，符合当今社会的发展。
目 录
摘要 III
Abstract IV
前 言 1
1 绪论 2
1.1 系统的背景 2
1.1.1 系统的提出 2
1.1.2 系统的意义 2
1.2 系统的研究目标 2
1.3 技术实现手段 3
1.3.1 ASP.NET简介 3
1.3.2 SQL Server简介 3
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cca903ff4b44c00b7a0a794f7375223/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c6116bb48dac1158fd6721edf5856b/" rel="bookmark">
			React is not defined解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 组件未引入React报错React is not defined 神奇的是代码内并没有用到React的地方 必需要导入React才不报错 看着就很奇怪 原因是因为React创建组件需要使用到React上的一个方法createClass创建组件 在babel-loader的@babel/preset-react预设里写个配置即可不用导入也不报错:
// 这里是把babel-loader的配置抽取到了babel.config.js中: module.exports = { ... presets: [ [ '@babel/preset-react', { runtime: 'automatic', // 加上这行配置 }, ], ] } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/969503ace2ae10de202e926fdc97604c/" rel="bookmark">
			cnpm安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、确认npm是否安装成功：win+R，输入cmd，打开命令窗口
2、 命令行窗口输入：node -v,显示有版本号，则安装成功
3、安装cnpm:输入npm install -g cnpm -registry=https://registry.npm.taobao.org
4、安装完成后，输入cnpm -v,检查是否安装成功
如果出现cnpm不是内部或者外部命令提示，请继续以下操作
5、 配置环境变量
打开系统环境变量，增加如下配置，则修改成功
回到命令行窗口输入cnpm -v,则配置成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb8602ef961e8bde7a5ca3af0f7706ba/" rel="bookmark">
			leetcode 142 环形链表II 证明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d012129ed3b2e7f7d747d5fa2309bac9/" rel="bookmark">
			ChatGPT扩展系列之跨平台桌面客户端ChatBox
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为什么需要 ChatBox？ 直接使用 ChatGPT API (OpenAI API) 是比较困难的，需要了解编程与接口调用，而且用起来不够方便。ChatBox 可以帮助你处理所有的底层调用。ChatBox 还帮你在本地保存了所有的聊天记录和 prompt，防止在线服务的数据丢失。ChatBox 还可以帮助你设计、调试和管理 prompt，让你更好地操作 AI 模型。 ChatGPT Plus 的平替（平民替代品）？ 可行。比起 ChatGPT Plus，同样来自 OpenAI 的开发者API服务可以得到完全一样的效果，而且还有以下好处：
比起 ChatGPT Plus 每月 20 美金的固定收费，开发者 API 是按量付费的，总体使用费用更低开发者 API 可以更加直接地使用 ChatGPT 背后的模型，比如使用更灵活的 prompt 角色调试、参数调试 下载 【各个平台的安装包下载点这里】
ChatGPT API密钥：【获取自己的KEY】没有就创建一个
配置： 将密钥复制到此
完成
支持平台： Mac: 请下载 .dmg, .tar 文件，已经支持 x64, arm64(compatibility with x64, tested)Windows: 请下载 .msi 文件Linux: 请下载 .AppImage, .deb 文件 Roadmap AI 聊天与会话管理 聊天消息与会话的本地存储 会话消息内容的格式美化（markdown） Streaming 打字机特效 API Host 配置 自动生成标签页的标题 消息清理的按钮 夜间模式 消息的 token 估算 GPT4 的支持 中文（简体、繁体） 代码块的复制按钮 停止生成的按钮 标签页的拖拽排序 Prompt 与参数配置More… 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a622e652dd0f128a81b171cfda5577e9/" rel="bookmark">
			LaTex 连字符多篇连续引用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		将文献 [1, 2, 3, 4] 变成 [1-4]
对elsevier模板而言，在文献部分加入如下代码即可！
\biboptions{numbers,sort&amp;compress}
其他情况，可参考： https://www.cnblogs.com/yymn/p/13552511.html：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdcf33579953e1c3bb711b8fd6d20d72/" rel="bookmark">
			解决：minIO部署之后出现 AccessDenied 显示错误 ：This XML file does not appear to have any style information
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示错误具体如下：
你会发现你的数据库和minIO一切正常该有的数据都有了，但是就是没有办法访问图片同时前端页也没有办法实现回显；
错误就在于minIO默认是private 我们需要把它设置成public
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02c87a3d0d47e1951a6c91b0fe2f58c8/" rel="bookmark">
			Spring Session Redis 修改默认的序列化方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、配置Spring-session-redis 的关键配置如下： &lt;!-- 设置Cookie domain 和 名称 --&gt; &lt;bean id="defaultCookieSerializer" class="org.springframework.session.web.http.DefaultCookieSerializer"&gt; &lt;property name="domainName" value="${sso.cookie.domain}"/&gt; &lt;property name="cookieName" value="${sso.cookie.name}"/&gt; &lt;property name="cookieMaxAge" value="${sso.cookie.maxage}" /&gt; &lt;property name="cookiePath" value="${sso.cookie.path}" /&gt; &lt;!--&lt;property name="domainNamePattern" value="^.+?\\.(\\w+\\.[a-z]+)$"/&gt;--&gt; &lt;/bean&gt; &lt;!-- 配置spring session --&gt; &lt;bean class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"&gt; &lt;!-- session超时设置 --&gt; &lt;property name="maxInactiveIntervalInSeconds" value="${spring.session.expiration}" /&gt; &lt;property name="cookieSerializer" ref="defaultCookieSerializer" /&gt; &lt;/bean&gt; 二、查看 RedisHttpSessionConfiguration 源代码如下： @Bean public RedisTemplate&lt;Object, Object&gt; sessionRedisTemplate( RedisConnectionFactory connectionFactory) { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;Object, Object&gt;(); template.setKeySerializer(new StringRedisSerializer()); template.setHashKeySerializer(new StringRedisSerializer()); if (this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02c87a3d0d47e1951a6c91b0fe2f58c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8885239e2480f365802575d1a6d63016/" rel="bookmark">
			flink任务处理下线流水数据，数据遗漏不全（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flink任务处理下线流水数据，数据遗漏不全(一)
后续问题跟踪
Test3 只接受T4301的数据
一切正常
Test2 接受所有T11的数据
一切正常
2023-04-07 08:15日 1、Job任务的验证(整个铜线) T43-1正确
T43-2 少一个
T43-3正确
T43-4正确
2、Test2 （T43主题） T43-1 、T43-3、T43-4都正确，T43-2少一个；
3、Test3 (T43-1主题) T43-1全部正确
为什么会少一个T43-2凌晨3点的数据呢？ 用chunjun的代码与自己写的代码测试写入chunjun表和tjn_test表，都少T43-2凌晨3点的数据 以上证明与数据量无关！！！ 继续观察chunjun代码与自己写的，时间长了会如何？？？谁的稳定性更强！！！ 查看了日志，发现有一个错误 java.sql.SQLSyntaxErrorException: Unknown column 'NaN' in 'field list' at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:120) at com.mysql.cj.jdbc.exceptions.SQLError.createSQLException(SQLError.java:97) at com.mysql.cj.jdbc.exceptions.SQLExceptionsMapping.translateException(SQLExceptionsMapping.java:122) at com.mysql.cj.jdbc.ClientPreparedStatement.executeInternal(ClientPreparedStatement.java:953) at com.mysql.cj.jdbc.ClientPreparedStatement.execute(ClientPreparedStatement.java:370) at com.zaxxer.hikari.pool.ProxyPreparedStatement.execute(ProxyPreparedStatement.java:44) 用Bing查看了这个错误，我发现是转换为int float类型数据异常。但是报错的日志仅仅指向sql语句而不是某个转换的代码，所以我猜测是数据插入到mysql表中发生冲突。
表中有三个字段是浮点类型的，最大的可能是spec和weight；
chunjun的代码运行一直并未报错，存储到数据库都正常的；说明与weight无关！！
我觉得是spec这里，若获取的spec是空字符串的话，那么转化为float类型就会报错；
我好像知道了，这里代码有问题；既然是null，怎么可能获取到，转换自然有问题
我觉得出现这个错误的原因是在spec这里有问题、还有本身存在bug，把null转换为float异常
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3be3b1e61c0e94f493314d24bf3fa6b8/" rel="bookmark">
			homebrew安装和使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Homebrew是什么？ Homebrew官网：
英文： https://brew.sh 中文： https://brew.sh/index_zh-cn Homebrew是MacOS（或 Linux）的软件包管理器。
通过它，我们可以方便的对Mac上的各种应用软件进行管理，例如：安装、更新、查看、搜索、卸载等。
Homebrew，可谓是Mac神器，几乎每一位Mac使用者都会安装它。
用Homebrew官网的一句话总结：
Homebrew 使 macOS（或您的 Linux 系统）更完整。 二、Mac上安装Homebrew Homebrew 3.0.0版开始，正式支持Apple M1芯片，M1用户放心安装！ 第一步： 打开终端。不知道如何打开终端的朋友，请参考：
爱码士：MacBook使用笔记：打开终端38 赞同 · 2 评论文章正在上传…重新上传取消
第二步： 在终端命令行窗口输入安装命令。
这里需要特别说明几点内容。
下面是Homebrew官方给出的安装命令：（如果没有VPN，不要使用此命令安装！）
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" 通常情况下，官网给出的指令会报错： curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused 因为这是国外网站，由于GFW（中国长城防火墙）的存在，如果没有vpn，是无法访问的，所以连接被拒绝！
别着急，有办法解决！
只要我们从国内镜像网站安装，就一切OK了。
以下为国内安装Homebrew的正确姿势：(基于gitee上某大神的自动安装脚本)
/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)" 回车执行指令后，根据提示操作。具体包括以下提示操作：
（1）选择下载镜像
根据需要选择下载源，例如，我这里选择中科大下载源，就输入‘1’，回车。
（2）确认删除旧版本
如果存在旧版本，会弹出删除旧版本提示，输入"Y"，回车。
（3）输入开机密码（用于mac确认第三方应用安装）
（4）安装git
如果之前没有安装过git，会终止homebrew安装，弹出git安装提示，点击“安装”。
这里如果没有弹出安装git的对话框,也可以去提示的网站下载手动安装,下载地址复制终端中的提示即可
（5）再次执行homebrew安装指令
耐心等待git安装完成后，再次运行homebrew安装指令，重新根据提示操作即可。
安装需要一段时间，过程中，可以在终端看到脚本执行了那些操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3be3b1e61c0e94f493314d24bf3fa6b8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/159/">«</a>
	<span class="pagination__item pagination__item--current">160/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/161/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>