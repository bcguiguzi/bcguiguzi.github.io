<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b335c231ff42dcd5d564d0d00ef0fb3/" rel="bookmark">
			远程服务器的基础操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		远程服务器的基础操作 1. SSH 配置免密登录 在本地 PC 端终端输入命令：ssh-keygen
然后在 C 盘的用户文件夹下 .ssh 中生成两个文件：id_rsa (私钥)、id_rsa.pub (公钥)
登录远程服务器配置 ssh 的免密登录
在 .ssh 目录下新建 authorized_keys 文件
将 id_rsa.pub 中 ssh 公钥的内容写入到该文件：
至此 ssh 免密登录验证登录配置完成。
2. 如何查看远程服务器 gpu 的占用率 在 gpu 环境下直接通过命令 nvidia-smi 查看显存利用率和 GPU 的利用率
可以看到这种查看方式很不直观，而且显示的信息很大程度被折叠。这里推荐使用 python 内置的一个模块 gpustat，安装方式直接使用 pip install gpustat 即可。
然后通过终端命令：gpustat -i -p 就可以查看当前 gpu 环境下所有的卡序、型号、GPU 利用率 和显存的使用情况等，而且这些信息是实时更新的。
如果想退出该环境，使用快捷键 Ctrl + C 即可退出。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc6c94d7379b8acc98b7e0116d0947d/" rel="bookmark">
			python-windows命令行启动appium及杀掉对应接口进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 windows命令行启动appium及杀掉对应接口进程一.环境配置1.安装命令行版appium2.安装appium-doctor检测3.python安装Appium-Python-Client：4.定位uiautomatorviewer.bat5.查看主包名主类名Activity 二.python-appium启动app1.appium启动一加计算器相关参数：2.windows查看端口 三.windows杀掉对应进程 windows命令行启动appium及杀掉对应接口进程 本人环境前置条件：手机设备为真机一加7 Pro，使用的应用为一加计算器
一.环境配置 1.安装命令行版appium npm可以使用淘宝镜像下载更快，如下命令为全局安装
npm --registry http://registry.npm.taobao.org install appium -g 2.安装appium-doctor检测 npm --registry http://registry.npm.taobao.org install appium-doctor -g 验证:cmd输入appium-doctor
3.python安装Appium-Python-Client： pip install Appium-Python-Client 验证：cmd输入 appium -v
4.定位uiautomatorviewer.bat 使用定位工具uiautomatorviewer.bat，如果遇到报错请看我这篇博客
编写一个uiautomatorview截屏获取.uix工具_梦无矶的博客-CSDN博客
也可以使用appium的定位，还有weditor。
关于python版uiautomator2中的weditor
python语言实现的一个app自动化测试框架
安装uiautomator2：
pip install -U uiautomator2 初始化命令（往手机上推送apk包）：
python -m uiautomator2 init 安装定位工具weditor：
pip install -U weditor 安装完成之后，命令行运行:weditor --help确认是否安装成功。
命令行输入：weditor 会自动打开一个浏览器 进行连接手机设备定位。
init出错的话可以看我这篇博客：
关于uiautomator2-ATX安装失败教程
5.查看主包名主类名Activity 可以查看我这篇博客：
查看主包名主类名Activity
二.python-appium启动app 1.appium启动一加计算器相关参数： d = {} d['platformName'] = 'Android' d['deviceName'] = udid #填写你的设备id,adb devices显示的那个 d['appPackage'] = 'com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcc6c94d7379b8acc98b7e0116d0947d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04013530e891a9b3b8bb777945222dcb/" rel="bookmark">
			endnoteX9插入文献时出现{，#}这样的乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
endnote插入文献时出现{，#}这样的乱码，当即重新建立了一个endnote文件夹，仍然出错
解决
将instant formatting is off改为instant formatting is on：
但是把还会出现问题弹出这个界面：
就很难受，搞了一下午看了一个CSDN的帖子，也忘了在哪来，记录下
文章中出现了{}，{}是变量默认的符号，所以出现冲突。
可以这样解决：
点击下面的
改成这样就好了，出现这样的原因是跟你论文中的东西匹配了
好了完美解决
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/286435c6f7abd8a7c17b8e5981cd375c/" rel="bookmark">
			axios请求后端拿不到数据的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 问题场景问题原因 要点1要点2 问题分析解决方案 解决方案一解决方案二解决方案三解决方案四解决方案五解决方案六 问题场景 场景很简单，就是一个正常 axios post 请求：
axios({ headers: { 'deviceCode': 'A95ZEF1-47B5-AC90BF3' }, method: 'post', url: '/api/lockServer/search', data: { username, pwd } }) 后台说没有接收到你的传参。
这就有点奇怪了，我看了一下浏览器的请求信息是 OK 的，参数都是有的，而且之前这样用 axios 也没有这个问题。
但是这个接口是通用的，别人都用了，是 OK 的，接口没问题。
问题原因 要点1 原因就是这次的接口使用 java spring mvc
并且在这个方法上使用了注解 @RequestParam
那么这个是什么意思呢，这个是只能从请求的地址中取出参数，也就是只能从 username=admin&amp;password=admin 这种字符串中解析出参数。
要点2 我们还可以看到我们这次请求的 Content-Type：
application/json;charset=UTF-8 关于这一点需要说明的是：
1、axios会帮我们 转换请求数据和响应数据 以及 自动转换 JSON 数据
2、在 axios 源码中发现下面这段内容：（很关键）
我们知道在做 post 请求的时候，我们的传参是 data: {...} 或者直接 {...} 的形式传递的，嗯，就是下面这两种形式
【第一种形式】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/286435c6f7abd8a7c17b8e5981cd375c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4859a594cfdfa99d21cf01a3dcd889d8/" rel="bookmark">
			【Dialog】elementul Dialog组件点击空白处不关闭，点击空白处执行方法，点击关闭按钮执行方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题: 有时候我们可能需要把dialog组件用来封装成一个组件，引入到我们的另一个父组件内，这样我们就需要传值了，而点击空白处点击关闭叉叉之类的他默认的都是直接改变dialogVisible的值为false。但是，因为是组件引入了，所以直接改变值会报错，需要用$emit去改父组件的变量为false才行。这里就用到提供的一个关闭前的方法了。
点击空白处不关闭 核心语句：:close-on-click-modal=“false”
这句话意思就是是否可以点击空白处关闭，false为不关闭
&lt;el-dialog title="选择题" :visible.sync="dialogVisible" :modal="false" top="3vh" width="600px" :close-on-click-modal="false" &gt; 点击空白处执行方法，点击关闭按钮执行方法 核心语句：:before-close=“Cancel”
这句话代表关闭前执行的方法
因为点击空白处和点击关闭的叉叉按钮，都是会触发关闭的方法，所以我们直接在关闭前方法内写你需要执行的代码就可以了。
这里注意如果是组件传值的，你不能用关闭方法，elementul的dialog组件提供了一个close的关闭回调，这个你写了是会执行方法，但是还是会报错。报错原因就是因为你先点击触发了不允许直接改变子组件的变量的报错，然后再执行的关闭方法触发父组件的方法把变量改成为false然后弹框关闭了，这样效果确实是关闭成功了，但是会一直报错，可能会出现其他问题，所以不建议用这个方法，要用关闭前的。这样不会有报错。
&lt;el-dialog title="选择题" :visible.sync="dialogVisible" :modal="false" top="3vh" width="600px" :before-close="Cancel" &gt; Cancel(){ this.$emit('CancelDialog',false) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3aeab42b53601e9e4fdb4bf403f97d6c/" rel="bookmark">
			MAAC注意力模块简要笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MAAC注意力模块笔记 MAAC的主要思想是通过有选择的注意其他智能体的信息，来为每个智能体学习一个critic。每个智能体询问其他智能体有关它们观察和动作的信息，并把此信息纳入对自己值函数的估计中。每个智能体都由一个critic，但是所有critic使用一个共享的注意模块。
为了计算每个智能体i的 Q i ψ ( o , a ) Q_i^ψ (o,a) Qiψ​(o,a)，critic接收所有的观察和动作。把除了智能体i以外的所有智能体记作 j j j， Q i ψ ( o , a ) = f i ( g i ( o i , a i ) , x i ) Q_i^ψ (o,a)=f_i (g_i (o_i,a_i ),x_i) Qiψ​(o,a)=fi​(gi​(oi​,ai​),xi​)就是有关以下三部分的函数：
智能体 i i i的观察;智能体 i i i的动作; j j j的贡献。 x i x_i xi​是除 i i i外每个智能体value的加权和：
x i = ∑ ( j ≠ i ) α j v j x_i=∑_{(j≠i)} \alpha_jv_j xi​=∑(j​=i)​αj​vj​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3aeab42b53601e9e4fdb4bf403f97d6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ce80e9211aca4ece1f0831de4f1933/" rel="bookmark">
			wfdb读取不同后缀的数据文件（ECG）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 一，读取.hea文件（几乎没用）二，读取record数据(.dat)（数据）三，读取.art文件（标签）四，读取.qrs文件 一，读取.hea文件（几乎没用） 这个文件是数据的注释文件，但是注释的内容在后面的几个文件里也有。所以说这个文件用处不大。
from IPython.display import display import wfdb record = wfdb.rdheader('database/04015') display(record.__dict__) 二，读取record数据(.dat)（数据） 这个函数是读取数据的文件（很重要），我们应该仔细了解rdrecord()函数的用法。
from IPython.display import display import wfdb record = wfdb.rdrecord('database/04015') display(record.__dict__) rdrecord()与rdann（）用法相似
提出的这几个参数是经常用到的。给我们的数据通常是几个小时的心电数据，把数据直接作为神经网络的输入是不合理的。所以我们要截取数据，这就用到了sampfrom和sampto参数了。
我们应该知道
数据有几种信号：我们知道我们想要的信号类型时，我们才可以去取得相应的数据。相应信号的数据：有时我们要取其中的一种或多种数据。
三，读取.art文件（标签） from IPython.display import display import wfdb annotation = wfdb.rdann('database/04015', 'atr') display(annotation.__dict__) 这里是重点
这里的symbol和sample参数对应的数据很重要。一个是一段时间内数据对应的标签，一个是一段时间内采样的时间点。
四，读取.qrs文件 这个文件也是一个注释文件，与.art文件类似。
from IPython.display import display import wfdb annotation = wfdb.rdann('database/04015', "qrs") display(annotation.__dict__) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b74915cea2178c119a536d34eba4e8b4/" rel="bookmark">
			Python 实现Excel 转 JSON
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python Excel 转 JSON 代码：
import xlrd #需要1.2.0版本的，2.0以上的版本只能读取.xls类型的文件 import csv # 读取文件(.xlsx .xls .csv) 然后返回字典数据 def readFile(filePath): try: fileType = filePath.split(".")[-1] print(f'{filePath}\t{fileType}') if fileType == 'xlsx' or fileType=='xls': res = [] wb = xlrd.open_workbook(filePath) sh = wb.sheet_by_index(0) title = [] for item in sh.row_values(0): title.append(item) data = [] # 实现第一行为key，剩下的为value 转为字典了 [[data.append({title[index]: transfer(sh.row_values(it)[index]) for index in range(0,len(title))})] for it in range(1,sh.nrows)] return data elif fileType == "csv": data = [] with open(filePath) as csvfile: rows = csv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b74915cea2178c119a536d34eba4e8b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c0f1630d09935d306f0ff6bf4e509a8/" rel="bookmark">
			bootstrap-fileinput分片上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		bootstrap-fileinput是基于bootstrap的文件上传插件，在5.0版本中新增了分片上传功能，注意，一定要大于等于5.0的版本才有分片上传的功能！对于需要上传大文件，但是NG网关又无法放开包大小限制的情况，就可以使用分片上传。
开启分片上传 使用分片上传功能需要在bootstrap-fileinput的初始化中加入以下配置：
enableResumableUpload: true, resumableUploadOptions: { testUrl: "/site/test-file-chunks", chunkSize: 1024, // 1 MB chunk size }, 其中resumableUploadOptions是可选的。testUrl用来配置获取已完成上传分片编号的地址，如果需要断点续传则配置，不需要可不配置。chunkSize用来配置分片大小，默认是2MB。
服务端代码 分片上传模式下，服务端处理器的参数和返回值与直接上传有所不同。以抓娃为例，参数如下：
public class ChunkUploadParamVO { private String fileId; //文件ID，格式：文件大小_文件名 private String fileName; //文件名 private String fileRelativePath; //文件路径 private long chunkIndex; //分片编号 private long fileSize; //文件大小 private long chunkSize; //分片大小 private long chunkSizeStart; //分片偏移字节数 private long chunkCount; //总分片数 private long retryCount; //重试次数 private MultipartFile fileBlob; //分片内容 } 分片上传响应结构示例：
public class ChunkUploadResultVO { private long chunkIndex; //已上传完成分片编号 private String error; //错误信息 } 另外需要注意的是分片并不是严格按顺序到达服务端的，所以依赖当前分片编号与总分片数判断文件是否上传完是不可靠的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c0f1630d09935d306f0ff6bf4e509a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0ad7bff57f5b009cbc1ab4e260a9e202/" rel="bookmark">
			c：rand()和time函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rand rand函数使用线性同余法实现随机数，是伪随机数，由于周期较长（至少是32767），因此在一定范围内可以看成是随机的。 int rand(void) : stdlib.h 返回[0,RAND_MAX]范围的整数，ANSI C只规定了函数rand的返回值类型（即int）和返回值上界（即RAND_MAX），也就是说，任何一个具体的实现，只要RAND_MAX不超过其所在平台int的正向最大值都是允许的（不然返回值发生溢出），例如，
在VC++2010和MinGW GCC TDM 5.1 32bit中，RAND_MAX=32767=0x7FFF，即short int的正向最大值。
在CentOS 7的GCC 4.8.2 x86_64中，RAND_MAX=2147483647=0x7FFFFFFF，即其int的正向最大值。
其中RAND_MAX这个宏定义位于stdlib.h中
在rand函数内，维护着一个计数器，每次调用rand函数都会使计数器+1，然后计数器与种子发生运算，返回[0,RAND_MAX]中的一个整数，这也导致了每次运行相同的rand函数总是返回相同的值，如，
int i; for (i=0;i&lt;10;i++){ printf("%d\n",rand()); } 每次运行，得到的10个随机数都相同。
void srand(unsigned int) : stdlib.h 依据传入的无符号整数，来设置对应的随机数种子，这个随机数种子是全局的变量，能够被rand函数读取，能够被srand函数修改。
time.h time_t time(time_t *) : time.h 返回从Unix元年（1970年1月1日0点）到当前时间所经过的秒数.
日历时间，即机器时，1970年之后的秒数
UTC，GMT，世界标准时间（经度0），中国是UTC+8
epoch：时间点，当前机器时
clock tick：时钟计时单元，一个时钟计时单元的时间长短是由CPU控制的。一个clock tick不是CPU的一个时钟周期，而是C/C++的一个基本计时单位（单位为毫秒）
typedef __time64_t time_t; : types.h typedef __int64 __time64_t; : types.h #define __int64 long long : _mingw.h time函数获取秒数有两种方式，
1.直接通过函数的返回值获取秒数，
2.通过传入一个time_t类型的地址，函数会将秒数也保存到这个地址上，
当传入的指针是NULL或0时，函数只通过返回值返回秒数。
由于秒数总是在向前变化，所以可以利用time函数的返回值来作为srand的传入参数。
在写这篇文章时，time(0)返回的值是1583975156，在unsigned int范围内。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab7afb3b06351eda8aeb8a41a7d80a58/" rel="bookmark">
			安装miktex&#43;winedit
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言 在使用latex写作编辑英文论文时，最近被安利推荐miktex+winedit，来实现写作工具的准备。
网上资料显示，用Latex排版文档，首先要用文本编辑器编辑好tex文档，然后通过各种程序编译，得到pdf文档用于打印或者阅读，基本的排版流程如下图：
一般我们经常用pdflatex 或者xelatex 程序直接从tex 文件生成pdf 文件。如果是中文tex 文档，优先使用xelatex 程序编译。
2.软件安装 1.安装miktex
下载地址：http://www.miktex.org/download。按照步骤安装，新版Latex会自带文档编辑器TeXworks。
提供windows版本的下载文件
2.安装winedt
下载地址：http://www.winedt.com/download.html。选择WinEdt 10.3 (64-bit)下载，安装。按照步骤安装，在完成时，增加勾选关联关于Tex的项。
3.激活winedt
目前最新的版本为10.3版本，未激活状态下免费试用30天，网上有修改注册表的方法，但是目前针对新版本好像无效，如果有兴趣可以点击这里进行研究。
网上大佬提供的注册码为：
在安装完成后，运行WinEdt ，依次打开Help &gt;&gt; Register WinEdt… 在弹出的对话框里包含Name,Code,Date。对应填入以下信息：
Name：Cracker TeCHiScyCode：1130140925535334280Date：不用填 binggo~~安装完成，下一步就是根据论文模板，一步步学习具体的使用和操作方法啦~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e212436b773457e2a5627d540c6aae/" rel="bookmark">
			线程死锁例子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		代码：
/* 实现线程死锁的例子 */ public class DeadLockDemo { private static final Object resource1 = new Object();//资源 1 private static final Object resource2 = new Object();//资源 2 public static void main(String[] args) { new Thread1().start(); new Thread2().start(); } static class Thread1 extends Thread { @Override public void run() { synchronized (resource1) { System.out.println(Thread.currentThread() + "get resource1"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread() + "waiting get resource2"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01e212436b773457e2a5627d540c6aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d57acbe9f763f04442413785159a53d4/" rel="bookmark">
			记录一波h5新增的一些js常用实用的api方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		延迟加载JS------defer="defer" &lt;script src="js/b.js" defer="defer"&gt;&lt;/script&gt;
&lt;script src="js/jquery.js" defer="defer"&gt;&lt;/script&gt;
&lt;script src="js/c.js" defer="defer"&gt;&lt;/script&gt;
注：通过defer="defer"让指定的js在其他js运行后再执行，如果像上述所有的都加上即没有任何作用
异步加载js-----async =“async” &lt;script src="js/b.js" async ="async"&gt;&lt;/script&gt;
&lt;script src="js/a.js" async ="async"&gt;&lt;/script&gt;
&lt;script src="js/c.js" async ="async"&gt;&lt;/script&gt;
注：所有的js全部同时加载，因为很可能存在出现未定义等等错误，不推荐试用
HTML5 - js高级选择器 querySelecor可以跟jq样，直接选择任何css选择器，但只能获取一组中的第一个，IE8+支持，querySelecorAll获取全部（querySelector返回的是一个对象，querySelectorAll返回的一个集合(NodeList)）
document.querySelectorAll('.red')
获取class列表属性-----classList
length : class的长度
add() : 添加class方法
remove() : 删除class方法
toggle() : 切换class方法//当前元素如果有这个clss就移除，没有就加上
例如：
&lt;body&gt;&lt;!--身体--&gt;
&lt;div id="div" class="div1 div2 div3"&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
var div = document.getElementById("div");
alert(div.classList);弹出所有class名称
alert(div.classList.length);弹出当前class个数
div.classList.add("div4");增加class名为div4
div.classList.remove("div2","div3");删除class="div2 div3"
div.classList.toggle("div4");自动判断当前元素clss，如果有这个clss就移除，没有就加上
&lt;/script&gt;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aca032fc6f1e54c9286cbc094c56c2f7/" rel="bookmark">
			Informer pytorch 代码解读（1）Encoder
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0.对整体的架构进行分析
整个架构和Transformer是差不多的，但是Encoder层有堆叠，对Encoder进行分析发现，他整个部分的结构大体分为
（1）白色的部分，稀疏注意力的计算。
（2）蓝色的卷积层，进行信息的提取。
1.整个Informer的部分的代码如下主要由三个部分组成
（1）红色部分是词编码
（2）绿色部分是Encoder
（3）蓝色部分是Decoder​
2.对于encoder
3.Conv_layer部分
0.对整体的架构进行分析 整个架构和Transformer是差不多的，但是Encoder层有堆叠，对Encoder进行分析发现，他整个部分的结构大体分为 （1）白色的部分，稀疏注意力的计算。 （2）蓝色的卷积层，进行信息的提取。 对Encoder部分进行展开如下图。
1.整个Informer的部分的代码如下主要由三个部分组成 （1）红色部分是词编码 （2）绿色部分是Encoder （3）蓝色部分是Decoder 2.对于encoder 红色部分的代码时EncoderLayer层，也就是主要的attention的计算层。
绿色部分是卷积层，主要是进行信息的提取和维度的变短。
查看Encoder包括的attn_layer的信息，发现attn_layer就是一个EncoderLayer，而一个EncoderLayer还包括一个注意力的计算和两个卷积层，以及两个标准化层和dropout层，两个卷积是512 - 2048 - 512 所以一个EncoderLayer层对于向量来说维度是不变的，在接下来也会有体现。但是Encoder还包括一个额外的卷积层也就是上图的绿色的部分，经过绿色的卷积层维度会变化 ，在接下来的代码中也会有体现。
一个Encoder包括两个EncoderLayer和一个卷积层，这个卷积层的数量是比EncoderLayer层的数量少一个的。 这时候传入的x的维度是（32，96，512），来计算attention。
进入atten.py来进行详细的计算
到达红色部分的时候query和keys以及values的尺度都是由
（32，96，512）-》（32，96，8，64）规范的格式是（32，96，H，d model / H）也就进行了分多头
这里传入的queries，keys以及values都是（32，96，8，64）的维度的。而经过transpose过后的都是（32，8，96，64）维度的。因为这里传入的都是encoder的输入，所以queries和keys都是一样的，所以L_Q和L_K也都是一样的，都是96的长度。U_part是对L_K进行log得到的是25，u是对L_Q进行log，得到的也是25。
接下来进行到了红色的这部分也就是前期的log以及queries和keys的准备工作都完成了，下面开始进行prob_QK的计算。传入的数据：
scores_top, index = self._prob_QK(queries, keys, sample_k=U_part, n_top=u)，queries和keys都是原始的queries和keys，而sample_K是抽样出来为了计算n_top的K，sample_K是为了n_top来服务的。 接下来进入prob_QK的计算工作，前面都是在为了prob_QK的计算做参数的准备。
这里传入的Q，K的维度都是（32，8，96，64）
(1) K_expand = K.unsqueeze(-3).expand(B, H, L_Q, L_K, E) 这一步得到K_expand，是（32，8，96，96，64）的维度的 (2) index_sample = torch.randint(L_K, (L_Q, sample_k)) 这一步得到的index_sample的维度是（96，25）的维度 (3) K_sample = K_expand[:, :, torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aca032fc6f1e54c9286cbc094c56c2f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fce410cbebad78759f0b081f41d99f75/" rel="bookmark">
			RTKLIB专题学习(六)---单点定位应用(二)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTKLIB专题学习(六)—单点定位应用(二)
上一篇RTKLIB专题学习(六)—单点定位应用(一)我们使用最小二乘以及抗差最小二乘对单点定位进行定位效果分析，发现在存在粗差情况下，抗差最小二乘可以获得更加可靠、准确的结果
那么，今天这篇博文，我们来看一下，将卡尔曼滤波应用到单点定位中，会是怎样的结果
首先为了便于理解，先放上卡尔曼滤波的基本流程：
也要说一下卡尔曼滤波在单点定位中相对于最小二乘的优点：
我们直接用实测站的单点定位来分析最小二乘和卡尔曼滤波的定位效果：
WLS(加权最小二乘)
卡尔曼滤波（KF）
两者定位误差曲线对比：
两者定位点分布对比：
KF
LS
两者定位精度对比：
从上面结果可以看出，在单点定位中引入卡尔曼滤波确实能够有效提升精度啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60f41d5e670954e68b2007ede88d2e93/" rel="bookmark">
			详解TCP四次挥手（断开TCP连接过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在讲述TCP四次挥手，即断开TCP连接的过程之前，需要先介绍一下TCP协议的包结构。
TCP协议包结构：
这里只对涉及到四次挥手过程的字段做解释
（1） 序号（Sequence number）
我们通过 TCP 协议将数据发送给对方，就比如 hellotcp，这一串字节流，假设被拆分成了三个 TCP 报文段，第一个报文段携带了 hel，第二个报文段携带了 lot，第三个报文段携带了 cp，这三个报文段不一定是按照顺序送到对端的，那么对端收到这三个段是如何确定他们的顺序的呢？此时序号的意义就体现在这里。
TCP 连接中，为传送的字节流（数据）中的每一个字节按顺序编号。也就是说，在一次 TCP 连接建立的开始，到 TCP 连接的断开，你要传输的所有数据的每一个字节都要编号。这个序号称为字节序号。
举个例子：如果一个 TCP 报文段的序号为 101，它携带了 50 字节的数据，就表示这 50个字节的数据的字节序号范围是 [101, 150]，该报文段携带的第一个字节序号是 101，最后一个字节序号是 150。
（2） 确认号（Acknowledge number）
TCP传输的对端通过回复一个确认号，来表示确认已经接收到了某个 TCP 段。
举个例子：比如之前发送方发送的序号为 101 的 TCP 段，这个段携带了 50 字节数据，则接收方应当回复的确认号是 151，它表示接收方已经收到了字节序号为150之前的数据，现在期望你发送字节序号为 151 以及以后的数据。
（3）ACK
是一个TCP协议报文中的标志比特位，如果置1表示这个报文段是一个回复确认报文。
注意：为了防止混淆确认号与ACK，一般确认号写作ack，而ACK就写为ACK。
（4）FIN
同样是一个TCP协议报文中的标志比特位，如果置1表示该报文段用来断开TCP连接。
介绍完TCP协议报文的一些基本字段，我们可以来叙述TCP四次挥手的过程了。
TCP四次挥手流程图：
数据传输结束后，通信的双方都可以释放连接。现在A和B都处于ESTABLISHED状态。
（1）第一次挥手
A的应用程序先向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN置1，其序号seq=x。这时A进入**FIN-WAIT-1（终止等待1）**状态，等待B的确认（请注意：TCP规定，FIN报文段即使不携带数据，它也要消耗一个序号）。
（2）第二次挥手
B收到连接释放报文段后即发出确认，确认号是ack=x+1，序号为seq=y。然后B就进入**CLOSE-WAIT（关闭等待）**状态。TCP服务器进程这时应通知高层进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并未关闭。这个状态可能会持续一些时间。
A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。
（3）第三次挥手
若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段需要置FIN=1。现假定B的序号为z（在半关闭状态B可能又发送了一些数据）。B还必须重复上次已发送过的确认号ack=x+1。这时B就进入了LAST-ACK（最后确认）状态，等待A的确认。
（4）第四次挥手
A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack=z+1，而自己的序号是seq=u+1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号）。然后进入到TIME-WAIT（时间等待）状态（请注意：现在TCP连接还没有释放掉。必须经过时间等待计时器设置的时间2MSL（MSL：最长报文段寿命）后，A才进入到CLOSED状态）。
常见面试问题一：为什么是四次握手，不能是三次握手吗？
答：与之前需要三次握手的原因类似，如果只是三次挥手，那就相当于服务器端发送完第三次挥手的报文后直接进入CLOSED（关闭）状态，假如此时网络出现问题，丢失了第三次挥手的报文，相当于客户端没有收到，那他依旧认为连接没有结束，在一段时间没有收到第二次ACK应答报文后，他会重新发送请求断开连接的报文，但是服务器端已经关闭，不会再接收报文，又形成了类似死锁的情况。
常见面试题二：为什么有CLOSE-WAIT状态？
答：因为服务器端收到断开TCP连接请求时，有可能还有数据没有向客户端发送完毕，需要一段时间来把所有信息传输完毕。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60f41d5e670954e68b2007ede88d2e93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0aad4e39aff1dec2ab651703179b4ac/" rel="bookmark">
			微信小程序实现调查问卷表单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序问卷调查表单 功能演示：
20220408_202155
index.wxml
&lt;view id="container-top"&gt; &lt;view id="container-img"&gt; &lt;swiper indicator-dots="true" autoplay="true" interval="3000" indicator-active-color="black"&gt; &lt;swiper-item&gt; &lt;image src="../../img/1.png" class="img"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../img/2.png" class="img"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;image src="../../img/3.png" class="img"&gt;&lt;/image&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/view&gt; &lt;form bindsubmit="formsubmit" bindreset="formreset"&gt; &lt;view&gt;1、输入你的学号&lt;/view&gt; &lt;input type="text" placeholder="请输入你的学号" name="code"/&gt; &lt;view&gt;2、输入你的姓名&lt;/view&gt; &lt;input type="text" placeholder="请输入你的姓名" name="name"/&gt; &lt;view&gt;3、你是用手机的最大用途是什么&lt;/view&gt; &lt;checkbox-group name="use"&gt; &lt;block wx:for="{{items}}" wx:for-item="item" wx:key="index"&gt; &lt;label&gt;&lt;checkbox value="{{item.val}}"/&gt;{{item.val}}&lt;/label&gt; &lt;/block&gt; &lt;/checkbox-group&gt; &lt;view&gt;4、每天使用手机多少小时&lt;/view&gt; &lt;slider value="0" show-value max="24" name="time"/&gt; &lt;view&gt;5、平常打不打球&lt;/view&gt; &lt;radio-group name="ball"&gt; &lt;label&gt;&lt;radio value="打"/&gt;打&lt;/label&gt; &lt;label&gt;&lt;radio value="不打"/&gt;不打&lt;/label&gt; &lt;/radio-group&gt; &lt;view&gt;6、谈谈目前课程所得&lt;/view&gt; &lt;input type="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0aad4e39aff1dec2ab651703179b4ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb089a09b050970f86faac2ae043ec2f/" rel="bookmark">
			MapReduce的基本工作原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MapReduce的基本模型和处理思想： 三个层面上的基本构思
1.如果对付大数据处理：分而治之
对相互之间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取分而治之的策略。
2.上升到抽象模型：Mapper与Reduce
MPI等并行计算方法缺少高层并行编程模型，程序员需要自行指定存储，计算，分发等任务，为了克服这一缺陷，MapReduce借鉴了Lisp函数式语言中的思想，用Map和Reduce两个函数提供了高层的并发编程模型抽象。
3.上升到架构：统一架构，为程序员隐藏系统层细节
MPI等并行计算方法缺少统一的计算框架支持，程序员需要考虑数据存储、划分、分发、结果收集、错误恢复等诸多细节；为此,MapReduce设计并提供了同意的计算框架，为程序员隐藏了绝大多数系统层面的处理系统。
大数据分而治之
建立Map和Reduce抽象模型
借鉴函数式程序设计语言Lisp中的思想，定义了Map和Reduce两个抽象的操作函数：
Map:(k1:v1)-&gt;[(k2:v2)]Reduce:(k2:[v2])-&gt;[(k3:v3)] 每个map都处理结构、大小相同的初始数据块，也就是（k1:v1）,其中k1是主键，可以是数据块索引，也可以是数据块地址；
v1是数据。经过Map节点的处理后，生成了很多中间数据集，用[]表示数据集的意思。而Reduce节点接收的数据是对中间数据合并后的数据，也就是把key值相等的数据合并在一起了，即(k2:[v2])；再经过Reduce处理后，生成处理结果。
例如要把一个统计一篇英语文章中各个单词出现的次数
1.有一个待处理的大数据，被划分成大小相同的数据库(如64MB)，以及与此相应的用户作业程序。
2.系统中有一个负责调度的主节点(Master)，以及数据Map和Reduce工作节点(Worker).
3.用户作业提交个主节点。
4.主节点为作业程序寻找和配备可用的Map节点，并将程序传送给map节点。
5.主节点也为作业程序寻找和配备可用的Reduce节点，并将程序传送给Reduce节点。
6.主节点启动每一个Map节点执行程序，每个Map节点尽可能读取本地或本机架的数据进行计算。(实现代码向数据靠拢，减少集群中数据的通信量)。
7.每个Map节点处理读取的数据块，并做一些数据整理工作(combining,sorting等)并将数据存储在本地机器上；同时通知主节点计算任务完成并告知主节点中间结果数据的存储位置。
8.主节点等所有Map节点计算完成后，开始启动Reduce节点运行；Reduce节点从主节点所掌握的中间结果数据位置信息，远程读取这些数据。
9.Reduce节点计算结果汇总输出到一个结果文件，即获得整个处理结果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b8acba7153c697e82a17a3dc837c9c/" rel="bookmark">
			lambda表达式和匿名内部类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例：
public class MultiThread { public static void main(String[] args) throws ExecutionException, InterruptedException { MultiThread multiThread = new MultiThread(); // FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() { // @Override // public Integer call() throws Exception { // int i = 0; // for (; i &lt; 100; i++) { // System.out.println(Thread.currentThread().getName() + "的循环变量i的值：" + i); // } // return i; // } // }); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;( (Callable&lt;Integer&gt;) ()-&gt; { int i = 0; for ( ; i &lt; 100; i++) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b8acba7153c697e82a17a3dc837c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bbd5e1a2d4268931260a944c4e003c8/" rel="bookmark">
			蓝桥杯第十二届省赛JAVA C组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[填空题]试题 A ：ASC 本题总分：5 分
【问题描述】
已知大写字母 A 的 ASCII 码为 65，请问大写字母 L 的 ASCII 码是多少？
答案是：76。
小技巧： ALT键 + ASCII码 可以输出对应的字符
可以用来验证答案
[填空题]试题 B: 空间 本题总分：5 分
【问题描述】
小蓝准备用 256MB 的内存空间开一个数组，数组的每个元素都是 32 位二进制整数，如果不考虑程序占用的空间和维护内存需要的辅助空间，请问256MB 的空间可以存储多少个 32 位二进制整数？
【题解】
刚拿到是有点懵，多读几遍发现就是让进行单位转换
基本知识是 MB &gt; KB &gt; Byte &gt; bit(位)
都是 1 ：1024的关系
所以
256MB*1024 = 262144KB262144KB * 1024 = 268,435,456Byte​ 又因为 8 bit(位) = 1Byte,所以 32bit = 4Byte​ 答案：268435456 Byte / 4 Byte = 67108864 [填空题]试题 C: 卡片 本题总分：10 分
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bbd5e1a2d4268931260a944c4e003c8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/250/">«</a>
	<span class="pagination__item pagination__item--current">251/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/252/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>