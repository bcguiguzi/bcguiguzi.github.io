<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba5e7829f63ffdcc50f799fa90bbe124/" rel="bookmark">
			矩阵运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include &lt;iostream&gt; using namespace std; struct Matric { int row, low; int matric[100][100]; Matric(int x, int y) :row(x), low(y) {} }; //矩阵相加 void add(Matric x, Matric y) { Matric a = Matric(x.row, y.row); for(int i=0;i&lt;100;i++)//初始化矩阵 for (int j = 0; j &lt; 100; j++) { a.matric[i][j] = 0; } //相加操作 for (int i = 0; i &lt; a.row; i++) for (int j = 0; j &lt; a.row; j++) { a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba5e7829f63ffdcc50f799fa90bbe124/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67ba1d9128315204ffdf3cc7a04536ee/" rel="bookmark">
			long和Long的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		long是基本数据类型,没有属性方法,只能进行数学运算，而Long是long相对应的引用数据类型，也是包装类，它有方法和属性。
一个没方法属性，一个有方法属性,这就是它们的区别。
类里面有方法和属性，而基本数据类型里面没有方法和属性。
看看下面的例子：
/** * @Author: chuxia0811 * @Date: 2021/3/12 22:50 * @Description : */ public class LongAndlong { public static void main(String[] args) { long a = 1; Long a1 = new Long(1); Long a2 = new Long(1); if (a == a1 ){ System.out.println("a与a1相等"); } if (a == a2 ){ System.out.println("a与a2相等"); } if (a1 == a2 ){ System.out.println("a1与a2相等"); } if (a1.equals(a2)){ System.out.println("a1与a2 equals相等"); } } } a与a1相等 a与a2相等 a1与a2 equals相等 由此也能看出，Long定义的变量为一个Long类型的对象；对应的是对象的引用地址，而long定义的变量为一个长整形数值的数值变量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67ba1d9128315204ffdf3cc7a04536ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e3de061082e0fca4ab63334ce884568/" rel="bookmark">
			关于向日葵Linux端、win10版本交互“连接已断开”问题的解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近日安装向日葵win10客户端与Ubuntu18客户端，安装过程简单，此处不描述。
安装后注册账号，在win、U客户端正常登录，也可以手机安装手机App，过程此处不描述。有问题可以留言。
在进行远程协助时遇到了通过Win10客户端控制Ubuntu客户端，以及手机App控制Ubuntu客户端时出现了“连接断开”和“正在进入远程桌面”的提示。经过一番痛苦的搜索，终于在https://blog.csdn.net/weixin_45085810/article/details/105574360?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2&amp;utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-2 博客下找到了解决方案：
但是我发现在使用 sudo install lightdm 命令时，总是通不过，因为本人是Linux小白。
尝试了安装lightdm，最后用
sudo apt install lightdm 解决了lightdm的问题。
最后总结解决方法为：
sudo apt-get update sudo apt-get upgrade sudo apt install lightdm 然后重启。
问题解决。
感谢@llp858759099 @Hapi@大神
转自：https://blog.csdn.net/llp858759099/article/details/105631019
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0154f71dd46075f4d10dbd06b90d8753/" rel="bookmark">
			php 面向对象的理解,我对php面向对象的细微理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 对象------由一个或者或个类组成
2 类------包括(1)类方法(2)类属性
3 实例化对象-----可以输出(1)类方法(2)类属性
4类的属性----就是类中定义的变量名
5类的方法----就是类中自定义函数
6实例化对象-----就是把类 变成对象 来实现 访问类中的 ,方法功能和属性
7类中自定义一个函数----在类中自定义一个函数,那么这个自定义函数 就称为 类的方法 通过这个方法 在类实例化后,能实现输出某种功能
8对象的功能扩展----对象通过 增加类.可以无限扩展 对象的功能
(三)我理解面向对象的杂谈
(1) ‘类’(封装成一个功能CLASS)--》实现‘方法’或者功能
多个类封装--》形成‘对象’
(2) 多个‘类’封装成一个功能菜单--》形成一个‘对象’--》由‘类’的功能菜单来实现---》 ‘方法’或功能，
(3) 多个‘类’封装成一个功能菜单--》形成一个‘对象’--》这个对象就有了 '方法' 和功能---》就有了性能 '属性', 比如 电脑的品牌,电脑的性能,电脑的功能
(4) 每个对象,封装后就有了 '功能',以后就不需要在去开发 '类'，
(5)只有一个 '类',也可以说成一个对象
‘类’(封装成一个功能CLASS)--》实现‘方法’或者功能
多个类封装--》形成‘对象’
多个‘类’封装成一个功能菜单--》形成一个‘对象’--》由‘类’的功能菜单来实现---》‘方法’或功能，
多个‘类’封装成一个功能菜单--》形成一个‘对象’--》这个对象就有了'方法'和功能---》就有了性能'属性', 比如 电脑的品牌,电脑的性能,电脑的功能
每个对象,封装后就有了'功能',以后就不需要在去开发类，
有一个类,也可以说成一个对象
1 对象由一个或者或个类组成
2 类包括(1)类方法(2)类属性
3 实例化对象可以输出(1)类方法(2)类属性
以上是大纲或介绍,如需要完整的资料或者如不符合您的要求,请联系技术人员qq:58850198咨询
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87067a54235c75355777b4e83508710f/" rel="bookmark">
			Java中找不到符号是啥意思,什么会导致Java中找不到符号错误？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每当您需要在当前程序中使用外部类/接口(用户定义的或内置的)时，都需要使用import关键字将这些类导入当前程序中。
但是，在导入任何类时-如果您要导入的类/接口的路径对JVM不可用。
如果您在import语句中提到的绝对类名不正确(包括包和类名)。
如果已导入使用的类/接口。
您将看到一个异常提示“找不到符号……”。
示例
在下面的示例中，我们尝试从键盘(System.in)中读取一个表示用户名的字符串值。为此，我们使用Java.Util包的扫描器类。public class ReadingdData {
public static void main(String args[]) {
System.out.println("Enter your name: ");
Scanner sc = new Scanner(System.in);
String name = sc.next();
System.out.println("Hello "+name);
}
}
编译时错误
由于我们在程序中使用了名为Scanner的类，因此未将其导入程序中。在执行时，此程序生成以下编译时错误-ReadingdData.java:6: error: cannot find symbol
Scanner sc = new Scanner(System.in);
^
symbol: class Scanner
location: class ReadingdData
ReadingdData.java:6: error: cannot find symbol
Scanner sc = new Scanner(System.in);
^
symbol: class Scanner
location: class ReadingdData
2 errors
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87067a54235c75355777b4e83508710f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73fe1e00ee600253ec8cb266c0abc6f7/" rel="bookmark">
			复杂网络度分布（幂律分布）图Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 无向图 直接使用networkx所提供的相关函数。
代码 import matplotlib.pyplot as plt # 导入科学绘图包 import networkx as nx import numpy as np adj = np.loadtxt('adj.txt', dtype=np.int) # 邻接矩阵 G = nx.from_numpy_matrix(adj) # 网络图 print("某个节点的度:", G.degree(0)) # 返回某个节点的度 # print("所有节点的度:",G.degree())#返回所有节点的度 # print("所有节点的度分布序列:",nx.degree_histogram(G))#返回图中所有节点的度分布序列（从1至最大度的出现频次） degree = nx.degree_histogram(G) # 返回图中所有节点的度分布序列 print(degree) x = range(len(degree)) # 生成X轴序列，从1到最大度 y = [z / float(sum(degree)) for z in degree] # 将频次转化为频率 plt.figure(figsize=(5.8, 5.2), dpi=150) plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签 plt.xlabel("Degree", size=14) # Degree plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73fe1e00ee600253ec8cb266c0abc6f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd01143a2ed11b2ce9d35e002a8392b8/" rel="bookmark">
			JVM介绍（针对JDK8&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JVM介绍（针对JDK8+） 关系图如下运行时数据区JVM栈 (Java Virtual Machine Stacks)堆内存 (Heap Memory)方法区（元空间） (Metaspace)本地方法栈 (Native Method Stacks)程序计数器 (Program Counter (PC) Register) 之前整理过一篇jdk7以前版本的jvm，然后有朋友建议更新一下。实在不好意思，本人比较懒，好多东西只是记录在本地会更新到网上，今天咱们先简单聊一下jdk8+后jvm的的变动信息
关系图如下 有图可知，一个java文件首先由java编译器编译为class文件，在由类加载器加载到运行时数据区内，（类加载器和运行时数据区都属于jvm的概念，面试时不要丢掉任何一部分哦）。
运行时数据区 JVM栈 (Java Virtual Machine Stacks) 每当启动一个新线程的时候，java虚拟机都会为它分配一个java栈。java以栈帧为单位保存线程的运行状态。虚拟机只会对java栈执行两种操作：以栈帧为单位的压栈或者出栈。
一个栈帧包含：局部变量、操作数栈、动态链接、方法出口等信息
堆内存 (Heap Memory) 存储的是对象实例和数组，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。
jvm只有一个堆区（heap）被所有线程共享
堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。
方法区（元空间） (Metaspace) jdk8+以后，JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）
元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存
元空间中存储的数据：常量、8大基本数据类型、静态变量(static、final）、类信息（字节码信息）、即时编译器编译后的代码
本地方法栈 (Native Method Stacks) 和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。
Java官方对于本地方法的定义为methods written in a language other than the Java programming language，就是使用非Java语言实现的方法，但是通常我们指的一般为C或者C++，因此这个栈也有着C栈这一称号。一个不支持本地方法执行的JVM没有必要实现这个数据区域。本地方法栈基本和JVM栈一样，其大小也是可以设置为固定值或者动态增加，因此也会对应抛出StackOverflowError和OutOfMemoryError错误。
在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。
程序计数器 (Program Counter (PC) Register) 用于保存当前线程执行的内存地址。
由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。
先简单介绍到这里，后期会补充类加载的相关信息，上面描述如有问题，欢迎伙伴们提示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73403ef5990443d8af305e42d7e5290f/" rel="bookmark">
			列表数据导出成Excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、下载xlsx库
npm i xlsx --save
2、项目中引入xlsx库文件
import * as XLSX from ‘xlsx’;
3、定义导出方法
handleDownload=(dataSource) =&gt; { // dataSource为需要导出的数据 // tableColumn为table的表头列 const tableColumn=[ {title:"列1",dataIndex:'col1',value:1}， {title:"列2",dataIndex:'col2',value:2}， {title:"列3",dataIndex:'col3',value:3}， {title:"列4",dataIndex:'col4',value:4} ] // 自定义下载的header，注意是数组中的数组哦 const exportCols = tableColumn.filter((item) =&gt; !item._ignore); const Header = [exportCols.map((item) =&gt; item.title)]; //以下是处理导出数据的内容（将datasource中多余的内容去掉，和header的字段要一一对应上） const exportArr = dataSource.map((item) =&gt; { const obj = {}; //定义一个空对象接收处理后的数据 exportCols.forEach((col) =&gt; { let value = item[col.dataIndex]; obj[col.dataIndex] = value; }); return obj; }); // 官方文档中的描述：converts an array of arrays of JS data to a worksheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73403ef5990443d8af305e42d7e5290f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55aafa86b89aba72e634483d027b635f/" rel="bookmark">
			python入门练习-列表练习20210311（列表分割）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列表中可以有若干个元素，并且可以通过下标（次序）来访问元素；列表元素可以通过赋值更新；变量也可以作为下标查询元素。 输入
list1=[“goole”,“robot”,1997,2000] #列表元素可以为文本，也可以为数字
list2=[1,2,3,4,5,6,7]
print(“list1[0]:”,list1[0])
list1[2]=2001 #更新列表中下标为2的元素
a=2
print(“更新后的第三个元素为：”,list1[a])
结果 更新后的第三个元素为： 2001
4.in可以判断列表是否包含某元素
输入
lst=[1,2,3,“4”,5]
print(4 in lst,3 in lst,“4” in lst )
结果False, True,True - 实例练习 输入两个整数求和
输入
s=input()
numbers=s.split() #split表示分割
print(int(numbers[0])+int(numbers[1]))
结果框 3 4
结果 7
补充如下图
课堂习题
练习1：
print(input().split()[2][1])
概念理解：首先输入列表，拆分列表，列表中下标为2的元素，第二个元素中下标为1的元素
eg：下图 结果为：2
练习2：输出X的三角形阵列
a=input()
print(" “+a) #此处“”内两个空格，用+目的是让空格与a直接连接
print(” "+a+a+a)
print(a*5)
练习3：输出（a+b）*c的值
s=input().split() #输入列表并拆分
a,b,c=int(s[0]),int(s[1]),int(s[2]) #将元素分别赋值给abc
print((a+b)*c) #运算公式
练习4：倒序输入的三位数，eg输入100，要求输出001
n=input()
print(n[2]+n[1]+n[0])
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6b243d7047b52ff2aa2360834fc9aa1/" rel="bookmark">
			ModuleNotFoundError: No module named ‘picamera‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.On Windows, execute: set READTHEDOCS=True
2'.On Unix based systems, execute: export READTHEDOCS=True
3.Now execute: pip install picamera
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f862b0dc7b48b3314deb02d68bcb1e0/" rel="bookmark">
			分解质因子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1，用质数筛选法确定一定范围内所有质数
2.用质数对该数进行质数分解
#include&lt;vector&gt; #include &lt;iostream&gt; #include&lt;cmath&gt; using namespace std; vector&lt;int &gt; p; bool ifPrime[10000]; //质数筛选法 void isPrime() { for (int i = 0; i &lt; 10000; i++) { ifPrime[i] = true; } for (int i = 2; i &lt; 10000; i++) { if (ifPrime[i] ) { p.push_back(i); for (int j = i * i; j &lt; 10000; j += i) { ifPrime[j] = false; } } } return; } //x质因子个数 void coutPrime(int x) { int answer = 0; for (int i = 0; i &lt; p.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f862b0dc7b48b3314deb02d68bcb1e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/469ab4c13b2d3a28f4890b4c4e0c8963/" rel="bookmark">
			X进制转化为10进制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include &lt;iostream&gt; #include&lt;string&gt; using namespace std; //X进制数会有字母表示，例如16进制 string str; int charToInt( char x) { if (x &gt;= '0' &amp;&amp; x &lt;= '9') { return x-'0'; } else { return x - 'A' + 10; } } //X进制 void reserve(string s,int x) { int num = 0; for (int i = 0; i &lt; s.size(); i++) { num *= x; num += charToInt(s[i]); } cout &lt;&lt; num; } int main() { cin &gt;&gt; str; reserve(str, 16); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2028aea41ccae41da1fb746c77b3f15/" rel="bookmark">
			php71w fpm,CentOS升级/安装PHP7.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先卸载旧版本PHP：
yum remove php*
接着安装epel：
yum -y install epel-release
更新软件源(centos自带的软件源没有PHP7)：
根据系统版本安装！！
//Centos 5.X：
rpm -Uvh http://mirror.webtatic.com/yum/el5/latest.rpmCentOs 6.x：
rpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm
//CentOs 7.X：
rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm
rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm
执行清理，否则会出现skip-broken：
yum clean
安装php7.1和拓展：
yum install php71w php71w-fpm php71w-cli php71w-common php71w-devel php71w-gd php71w-pdo php71w-mysql php71w-mbstring php71w-bcmath
设置开机自启：
chkconfig --levels 235 php-fpm on
开启PHP-FPM服务：
service php-fpm start
安装完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b19531cc6cf3ee6a8820570bbb9f4e7/" rel="bookmark">
			camera2 API使用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于Camera2 API的学习，可以参考Google官方提供的demo
拍照demo：
https://github.com/googlearchive/android-Camera2Basic
视频录制demo：
https://github.com/googlearchive/android-Camera2Video
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ac78865ec7dcf244138c95775d6a776/" rel="bookmark">
			百度一 29 岁程序员因“篡改数据”被抓
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理 | 王晓曼
出品 | 程序人生 （ID：coder _life）
近日，中国裁判文书网公布了一起非法控制计算机信息系统、给赌博网站“大开方便之门”的案件，涉及金额达374万元。
据案件显示，在百度时代网络技术（北京）有限公司担任研发工程师的陈某，出生于1992年，利用其职务之便，超越权限，通过篡改数据、编写脚本等方式，违规通过了735个媒体网站账号加入“百度联盟”的申请，致使公司374万元广告分成遭到损害。
经查，陈某在2017年9月至2018年3月的半年间，以审核每个网站300元的价格，据此收受他人给予的人民币235935.4元。
为“挣外快”，92年程序员被“拉下水”
根据裁判文书显示，2015年9月16日，陈某入职百度时代网络技术（北京）有限公司，担任研发工程师，所在部门为展示广告平台部的union团队，主要负责展示广告平台部流量端系统的开发工作，权限范围是百度联盟流量端系统的功能开发以及日常上线与维护。
陈某负责该系统的开发与维护工作，无权审核媒体资质，也没有权限对媒体审核服务器计算机系统程序里的数据进行非研发、调试和维护性需要的修改。
2017年8月，自称刘某的男子通过微信联系到陈某，称有“私活”可以“挣外快”，问其能否做快速审核（审核网站是否能有资质承接百度联盟广告），但被陈某拒绝了。
没过多久，刘某从哈尔滨到了北京，在对外经贸大学附近一个饭馆约陈某吃饭，说还是想做审核网站的事情，需要使用百度在职员工的权限，帮助其快速通过审核网站。
这一次，陈某动摇了。他找刘某要了9000元钱，审核每个网站300元，共审核30个。
程序员改当“审核员”，篡改数据违规“开绿灯”
百度公司进行网站审核的正常方式是审核部门的员工，依据联盟业务审核标准，对百度联盟风险防控平台待审核联盟潜在客户进行审核。联盟的网站需要通过两道审核，方可上线。
正常流程是客户提交网站先过机器审核策略，机器审核策略过滤掉问题网站（如包含无ICP备案，网址打不开等情况的），将没有触犯机器审核策略的网站推送至人工待审列表中，最终上线需要经过人工审核。
按照流程，百度公司与任何媒体进行广告合作，应该首先由媒体通过流量端系统进行登记网站信息，而后由公司业务审核部门员工进行审核，对符合合作标准的媒体才能通过审核，这些合作媒体后续才能通过百度系统投放线上百度接入的广告，从而获得百度公司的广告分成。
但陈某就职于展示平台广告部，工作职责不包括审核工作。
据裁判文书显示，陈某违规登录联盟风控平台篡改了待审核客户的状态，将不能通过审核的网站直接变更为审核通过状态，从而直接上线。
陈某使用的其中一种方式是通过CURL命令调用流量端系统的媒体审核接口，另一种是通过编写脚本批量操作的方式调用了流量端系统的媒体审核接口，从而篡改数据。
据悉，经过陈某走“绿灯”通过的网站内容，甚至涉及到赌博、彩票等业务。
事情败露，陈某当场承认违规操作获利
2018年2月27日，百度公司相关部门发现在风控平台审核媒体时，部分媒体无法进行正常审核操作。
经排查发现，这些媒体在UNION平台中是审核通过状态，但这些媒体在风控平台和UNION平台的审核状态不一致，可能存在人工调用审核接口使这些媒体绕过业审，有异常审核通过的情况存在；
进一步排查分析，发现疑似存在陈某在相关机器上进行了工作职责不相符合的操作，对部分没有经过业审审核的媒体，进行了“媒体审核通过”的操作，异常审核通过的媒体有735个，分成金额3745054元。
2018年3月2日，百度公司相关部门将上述情况以电子邮件形式发送给百度时代网络技术（北京）有限公司职业道德委员会。
公司得知此事后，于2018年3月5日指派相关工作人员找到陈某商谈此事，他当场就承认了通过CURL命令调用流量端系统的媒体审核接口，以及通过编写脚本批量操作的方式调用了流量端系统的媒体审核接口，从而篡改数据，使得部分媒体获利的情况。
公安机关于2018年3月11日接到百度公司报案称公司员工陈某涉嫌破坏计算机信息信息系统犯罪，后于同年4月20日将前往百度公司接受约谈的被告人陈某传唤到案。
法院这样判
北京市海淀区人民法院一审认为，陈某违反国家规定，对计算机信息系统中存储、处理的数据进行修改，后果特别严重，其行为已构成破坏计算机信息系统罪，应予惩处。
法院指出，被告人陈某利用其工作便利，在没有得到单位授权，也不是基于对单位计算机信息系统进行研发、维护、调试等工作需要的情况下，而是为了谋取其个人私利，超越其工作权限，采用技术手段擅自调用媒体接口，违规使大量网站通过媒体资质审核，将待审核的数据变更为审核通过的数据，系违规修改百度时代网络技术（北京）有限公司计算机信息系统内所存储、处理的相应分类数据的范围，因此该行为符合破坏计算机信息系统罪中对破坏行为的定义。
鉴于被告人陈某犯罪以后主动投案，到案后能如实供述其所犯罪行，系自首，且积极退缴全部违法所得，并赔偿了所在单位因本案而支出的信息技术服务费，亦取得了所在单位的谅解，有较好的悔罪表现，故本院对其依法减轻处罚。
最终，被告人陈某以犯破坏计算机信息系统罪，被判处有期徒刑一年九个月，并没收所有违法所得。
参考链接：
https://wenshu.court.gov.cn/website/wenshu/181107ANFZ0BXSK4/index.html?docId=07dfdd695dd945c49f1cacd7000e6e91
对此你怎么看？欢迎在评论区和我们聊聊！
更多开发轶事，欢迎戳下方二维码关注程序人生公众号！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8155a1f4b82b52f8cd24068a1320513c/" rel="bookmark">
			unordered_map 简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 无序映射（Unordered maps）是用于存储键值和映射值组合成的元素的关联容器，并允许基于其键快速检索各个元素。在unordered_map中，键值通常用于唯一地标识元素，而映射值是具有与该键关联的内容的对象。键的类型和映射的值可能会有所不同。
头文件 在使用unordered_map时，需要引入头文件：
#include &lt; unordered_map &gt; 内部实现 unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。
与map对比 map
优点：
有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作；
红黑树，内部实现一个红黑树使得map的很多操作在O(lgn)的时间复杂度下就可以实现，因此效率非常的高。
缺点：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间
应用场景：对于那些有顺序要求的问题，用map会更高效一些
unordered_map
优点：因为内部实现了哈希表，因此其查找速度非常的快缺点：哈希表的建立比较耗费时间应用场景：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map 总结
内存占有率的问题就转化成红黑树 VS Hash表，还是unordered_map占用的内存要高；但是unordered_map执行效率要比map高很多；对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的。 unordered_map的使用 unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。
#include &lt;iostream&gt; #include &lt;unordered_map&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std; int main() { //注意：C++11才开始支持括号初始化 unordered_map&lt;int, string&gt; myMap={{ 5, "张大" },{ 6, "李五" }};//使用{}赋值 myMap[2] = "李四"; //使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。 myMap.insert(pair&lt;int, string&gt;(3, "陈二"));//使用insert和pair插入 //遍历输出+迭代器的使用 auto iter = myMap.begin();//auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator while (iter!= myMap.end()) { cout &lt;&lt; iter-&gt;first &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8155a1f4b82b52f8cd24068a1320513c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e664db911c0bfe9c52f7021c935e1a00/" rel="bookmark">
			MATLAB 使用共空间模式 CSP 和支持向量机 SVM 做脑电分类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络上找到的代码，自己做了简单的修改，跑通之后分享出来做学习交流，找不到原作者的链接了，在这里只能表示一下感谢。
共空间模式 CSP
公共空间模式算法的基本原理是利用矩阵的对角化，找到一组最优空间滤波器进行投影，使得两类信号的方差值差异最大化，从而得到具有较高区分度的特征向量。
支持向量机 SVM
支持向量机模型将样本表示为在空间中的映射的点，这样具有单一类别的样本能尽可能明显的间隔分开出来。所有这样新的样本映射到同一空间，就可以基于它们落在间隔的哪一侧来预测属于哪一类别。
数据集bci comp 1
函数文件目录：
先特征提取，然后分类
代码： 分类 %% 主函数 clc; clear all; run_FeatureExtract disp('####### Training The SVM Classsifier ##########') load dataCSP.mat load labels_data_set_iii.mat %% X为训练集， T测试集， Y训练标签 %% SVM model = fitcsvm(X,Y); [fpredict1,fpredict2] = predict(model,T); fpredict=[fpredict1,fpredict2]; acc=size(find((fpredict1-y_test)==0),1)/size(y_test,1); fprintf(strcat('acc=',num2str(acc*100),'%%')); 结果：
特征提取函数： run_FeatureExtract：
% Extract Common Spatial Pattern (CSP) Feature close all; clear; clc; load dataset_BCIcomp1.mat EEGSignals.x=x_train; EEGSignals.y=y_train; Y=y_train; classLabels = unique(EEGSignals.y); CSPMatrix = learnCSP(EEGSignals,classLabels); nbFilterPairs = 1; X = extractCSP(EEGSignals, CSPMatrix, nbFilterPairs); EEGSignals.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e664db911c0bfe9c52f7021c935e1a00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2ef538cdee4019d15dd73f2e1d7004c/" rel="bookmark">
			Ubuntu能够ping通，但不能ssh登录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在虚拟机开启Ubuntu，但是却没法连接
检查了ssh是否启动
检查了22端口号
检查了ping都没问题
最后使用这个解决：
ssh -v 服务器的ip 输入yes回车，然后重新使用ssh连接工具就行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eb437268318d4512532c1186c5b1e6b/" rel="bookmark">
			小狼-Windows10将默认输入法删除掉，只留一个输入法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		是不是感到输入法之间来回切换很麻烦呢，那么如何将输入法设置成自己喜欢的输入法呢，当然最好的办法就是把其他的都删除掉，只留下自己喜欢的一个咯
现在就来看看如何操作吧
1.在搜索框找到输入语言，找到语言设置(控制面板或者哪里都可以)
2.点击箭头指向处
3.点击下方删除按钮即可删除啦，我这里默认输入法已经删除了，所以这里已经看不到了哦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d919ec18159a8ccaeded346bd42c6c91/" rel="bookmark">
			php get有长度限制吗,HTTP中GET长度问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		曾做过一个plist的接口，需要将参数编码后放在URL上传递，编码后的URL很长，长到让人担心这么传有没有问题？要弄清这个问题得先弄明白HTTP报文请求格式，借用网上一张图片： 一个HTTP请求由四部分组成：Request Line、Headers、空行和Request Body。见下面GE
曾做过一个plist的接口，需要将参数编码后放在URL上传递，编码后的URL很长，长到让人担心这么传有没有问题？要弄清这个问题得先弄明白HTTP报文请求格式，借用网上一张图片：
一个HTTP请求由四部分组成：Request Line、Headers、空行和Request Body。见下面GET示例：
可以看到GET请求时，数据放在Request Line中Request-URI传递；若发送POST请求时，数据则放在Request Body中传递，不同的地方决定了其享受不同的待遇。
HTTP手册上是这么说的：
HTTP协议不会对URI做任何限制，服务端必须能处理不限长度的URI，如果不能处理则返回414
The HTTP protocol does not place any a priori limit on the length of a URI. Servers MUST be able to handle the URI of any resource they serve, and SHOULD be able to handle URIs of unbounded length if they provide GET-based forms that could generate such URIs. A server SHOULD return 414 (Request-URI Too Long) status if a URI is longer than the server can handle (see section 10.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d919ec18159a8ccaeded346bd42c6c91/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/332/">«</a>
	<span class="pagination__item pagination__item--current">333/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/334/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>