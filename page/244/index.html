<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fd73208c2dad784e8660688674a878e/" rel="bookmark">
			元器件学习（1）：船型开关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 简介种类特点内部构造接线关于三脚带指示灯 简介 船型开关也叫翘板开关，是通过跷跷板一样交替按下操作按钮的两端来连接和断开电气电路的开关。多用于打开和关闭设备主电源的用途。英文：“Rocker Switch”。
种类 单刀单掷：1个动触点和1个静触点。只有1通道单刀双掷：1个动触点和2个静触点，（可分别接通两边的静触点）双刀单掷，2个动触点和2个静触点，有2个通道双刀双掷，2个动触点和4个静触点，有4个通道 （可分别接通两边的2个静触点） 特点 小型却可实现高容量开闭可通过视觉确认开/关状态 内部构造 接线 关于三脚带指示灯 可以使用万用表电阻档检测开关是否无损。
开关动作时两个脚的电阻为零的是控制脚和火线脚；开关没有动作时有一定电阻的是火线脚和零线脚；电阻无限大的是控制脚和零线脚。 来的火线接开关的L，来的零线接N。灯的两条线，一个接船型开关的另一空脚，一条线接零线N。
它内部只有一组开关通断，其中边上一个是灯引线，接另一电源的。接法是，两头接220伏，中间接要控制的负载。
参考自：
1、带灯船型开关接法
2、船型开关坏了怎么修 船型开关内部结构图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a443c8e0f634b81bac92f7da5184340d/" rel="bookmark">
			防止sigmoid和tanh激活函数溢出的C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 上一期，我们介绍了softmax函数的C++实现，但是考虑到sigmoid和tanh函数也是带 e e e的次幂，所以现在我们来考虑该函数的防止溢出实现。
sigmoid函数 原理 该函数的公式为：
1 1 + e − x \frac{1}{1+e^{-x}} 1+e−x1​
在 x ≥ 0 x\geq 0 x≥0的时候， e − x ≤ 1 e^{-x} \leq 1 e−x≤1，不会溢出，但是在 x &lt; 0 x &lt; 0 x&lt;0的时候，就有可能溢出了。所以在 x &lt; 0 x&lt;0 x&lt;0时，我们可以做如下变换：
1 1 + e − x = 1 ⋅ e x ( 1 + e − x ) ⋅ e x = e x e x + 1 \frac{1}{1+e^{-x}}=\frac{1\cdot e^x}{(1+e^{-x})\cdot e^x}=\frac{e^x}{e^x+1} 1+e−x1​=(1+e−x)⋅ex1⋅ex​=ex+1ex​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a443c8e0f634b81bac92f7da5184340d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824195685ce3396e6be150a3782dacde/" rel="bookmark">
			【2】谷歌2021模型量化白皮书《A White Paper on Neural Network Quantization》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 google模型量化白皮书 导读离线量化（PTQ）量化范围设置Min-max方法Mean squared error（MSE）Cross entropyBN based range setting方法比较 Cross-Layer Equalization（CLE）Absorbing high biasesBias correction经验偏差校正分析偏差校正 AdaRound 导读 上篇博客我们介绍了模型量化的硬件背景和基础知识，也了解到模型量化主要分为两类：离线量化（PTQ）和感知量化（QAT）。这一节主要跟大家一起了解离线量化。
离线量化（PTQ） PTQ算法的工作原理：给定一个训练好的精度FP32的网络，在不使用训练pipeline的前提下直接将其转换为一个定点精度网络。 离线量化不需要额外的数据或只需要一个小的校准集（通常很容易获得）。因为无需使用pipeline，离线量化基本不需要超参数微调，这使得工程人员可以通过一个叫做 "black-box"方法的API去量化训练好的模型。
PTQ中比较基础且重要的步骤是为每一个量化器寻找最好的量化范围。接下来使用多种常见的方法寻找好的量化参数，然后发现PTQ过程中容易出现的问题并给出解决问题的技术方法。
量化范围设置 在网络量化过程中，变量 x x x 通过量化和重新量化两步得到与之接近的 x ^ \hat{x} x^ :
x ^ = q ( x ; s , z , b ) = s [ c l a m p ( ⌊ x s ⌉ + z ; 0 , 2 b − 1 ) − z ] \hat{x}=q(x;s,z,b)=s[clamp(\left \lfloor {\frac{x}{s}} \right \rceil + z; 0, 2^b-1)-z] x^=q(x;s,z,b)=s[clamp(⌊sx​⌉+z;0,2b−1)−z]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824195685ce3396e6be150a3782dacde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c6b3213a13dbc5568eab655d3989c5/" rel="bookmark">
			Java基础：ArrayList、LinkedList、Vector的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景。
这篇文章主要介绍了ArrayList、LinkedList、Vector详细教程,本文通过图文并茂的形式给大家介绍的非常详细，对大家的学习或工作具有一定的参考借鉴价值，需要的朋友可以参考下。放假在家里休息，闲来无事，想巩固巩固自己的基础知识。Java基础这个我会一直更新的，希望大家关注 收藏 点赞。
二、概述：
1.ArrayList：
ArrayList 是动态数组，动态的意思是可以随时增加数组长度，众所周知，普通数组的长度是定死的，想要增加长度，就必须重新定义一个固定长度的数组，然后在把元素加进去，但是ArrayList可以随意增加或删除元素，这就让我们在操作的时候变得更灵活，动态数组每个元素都有一个下标，也就是标识这个元素的位置，通过这个下标，计算机就可以知道这个元素存放在内存的哪个位置，所以ArrayList 想要遍历查找某个元素的时候很快就能找到！而且，ArrayList也是线程不安全的
2.LinkedList:
LinkedList的底层就是用双向链表实现的，因为链表本身是无序的，所以LinkedList 插入或者删除都很快，但是要查找或者遍历的时候就会很慢，因为双向链表每次查找某个元素的时候都会在内部遍历一遍，直到找到那个指定下标的元素为止，另外，LinkedList 的内存占用要比ArrayList大，因为LinkedList除了存储数据之外，还存储了2个指针，一个指向前一个元素，一个指向后一个元素。
3.Vector:
总体来说，Vector除了是线程安全的之外，Vector 和 ArrayList 的底层存储结构基本相似，但又不完全相同。
4.ArrayList和LinkedList区别：
1）相同点： LinkedeList和ArrayList都实现了List接口。 ArrayList和LinkedList是两个集合类，用于存储一系列的对象引用(references)。 2）不同点： ArrayList底层的实现数组，而LinkedList是双向链表。 ArrayList进行随机访问所消耗的时间是固定的，因此随机访问时效率比较高。 LinkedList是不支持快速的随机访问的，但是在插入删除时效率比较高。 5.ArrayList和Vector区别：
1）相同点： ArrayList和Vector都是用数组实现的。 默认初始化大小都是10 2）不同点 Vector多线程是安全的，而ArrayList不是。Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比； 两个都是采用的线性连续空间存储元素，但是当空间不足的时候，两个类的增加方式是不同的。（ArrayList每次存储时会检查空间大小，不够时会扩充为原来的1.5倍，Vector会扩充为原来空间的2倍） Vector可以设置增长因子，而ArrayList不可以。 ArrayList有三个构造方法，Vector有四个构造方法。 6.ArrayList、LinkedList、Vector区别网格图：
7.ArrayList,Vector, LinkedList 的存储性能和特性：
ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数 据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组 元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全）。
通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数 据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插 入速度较快 。
ArrayList 在查找时速度快，LinkedList 在插入与删除时更具优势。
8.简述：
ArrayList,Vector 底层是由数组实现，LinkedList 底层是由双线链表实现，从底层的实现可以得出它们的性能问题，
ArrayList,Vector 插入速度相对较慢，查询速度相对较快，而LinkedList 插入速度较快,而查询速度较慢。
再者由于 Vevtor 使用了线程安全锁，所以ArrayList 的运行效率高于 Vector。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10c6b3213a13dbc5568eab655d3989c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/095d2a39fae10c250061399a508365c3/" rel="bookmark">
			数据结构之链表练习题(leetCode）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.移除链表元素（203）2.删除排序链表中的重复元素（83）3.删除排序链表中的重复元素 II（82）4.反转链表(206)5.链表的中间结点（876）6.链表中倒数第k个节点（剑指 Offer 22）7.回文链表8.合并两个有序链表（21）9.分割链表（02.04）10.相交链表（160）11.环形链表(141)12.反转链表 II(92) 1.移除链表元素（203） 题目: 给你一个链表的头节点 head 和一个整数val，请你删除链表中所有满足Node.val == val的节点，并返回新的头节点。
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
方法一：这道题是删除链表中所有等于val的元素，需要考虑两种情况。
头节点是要删除的节点，这时候我们循环判断head的值，但是head不能为空，这样就是链表中没元素了。头节点确定不是要删除的结点，我们就遍历链表判断后面的值，因为我们找的是前驱结点，所以我们要保证待删除的结点不能为空，否则会造成空指针异常。造成了pre遍历到最后一个结点，已经没有要判断的结点了。 public ListNode removeElements(ListNode head, int val) { while(head != null &amp;&amp; head.val == val){ head = head.next; } for (ListNode pre = head; pre != null; pre = pre.next) { while(pre.next != null &amp;&amp; pre.next.val == val) { pre.next = pre.next.next; } } return head; } 方法二：递归
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/095d2a39fae10c250061399a508365c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaa0e0e8eafeff7bd9e9da1732647852/" rel="bookmark">
			用矩阵快速幂计算斐波那契数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景介绍 递推式和矩阵乘法 斐波那契数列有递推公式
F n + 2 = F n + 1 + F n n ∈ N F_{n+2}=F_{n+1}+F_{n} \enspace n \in \mathbb{N} Fn+2​=Fn+1​+Fn​n∈N
我们可以把这个计算过程抽象成一个矩阵运算的过程。
[ F n + 2 F n + 1 ] = [ 1 1 1 0 ] ⋅ [ F n + 1 F n ] \begin{bmatrix} F_{n+2}\\ F_{n+1} \end{bmatrix} = \begin{bmatrix} 1\enspace 1\\ 1\enspace 0 \end{bmatrix} \cdot \begin{bmatrix} F_{n+1}\\ F_{n} \end{bmatrix} [Fn+2​Fn+1​​]=[1110​]⋅[Fn+1​Fn​​]
那么对于第 n n n项，我们有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aaa0e0e8eafeff7bd9e9da1732647852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92031ee9c042493b28df80672eb57e3/" rel="bookmark">
			MySql进阶索引篇01——深度讲解索引的数据结构：B&#43;树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度讲解索引的数据结构：B+树 1.索引介绍1.1 为什么使用索引1.2 索引的优缺点 2.从零开始设计索引2.1没有索引时怎么查询数据2.2 基于页的目录项的简单索引2.3 InnoDB索引设计方案2.3.1 迭代1：目录项的数据页(目录页)2.3.2 迭代2：多个目录页2.3.3 迭代3：目录页的目录页 3.索引类型3.1.聚簇索引3.2 二级索引3.3 联合索引3.4.InnoDB的B+树注意事项3.4.1 根页面位置万年不动3.4.2 内节点中目录项记录具有唯一性3.4.3 一个页面最少要存储两条记录 4.MyISam的索引方案4.1 不同存储引擎索引的区别4.2 MyISam索引的原理4.3 MyISam与InnoDB索引方案的对比4.4 索引方案与索引优化的关系 5.索引的代价6.B+树与常见的查找数据结构对比6.1 Hash结构6.2 二叉搜索树6.3 AVL树6.4 B树6.6 B+树6.7 R树 1.索引介绍 1.1 为什么使用索引 索引是存储引擎中一种用于快速找到数据的存储结构，他就像《新华字典》的目录，可以使我们查每个字的速度大大提升。
下面将
结合计算机的存储带大家深入理解索引的优点。下图左边使一个磁盘，在这个磁盘中存放数据是随机的，如果要查找某条数据，需要在整个磁盘空间进行扫描，十分耗时。下图右边(表格部分)改进了这一做法，在磁盘中开辟了一块连续的存储空间，数据也是连续存储，如果我们需要找第六条数据，只需要进行顺序访问，时间复杂度是O(n).
还可以改进吗？当然可以，结合我们熟悉的二分查找算法，我们可以使用二叉搜索树来优化。如下图，只要构造一颗二叉树，让左子树的值比右子树的小即可。同样是要查找之前的第六条数据，也就是89，只需要查找2次就可以了。其时间复杂度为 O ( l o g 2 n ) O(log_2n) O(log2​n)
实际上，MySQL数据库的索引就是建立了一棵B+树(其它存储引擎不一定)，比上面的二叉搜索树更加复杂一点。左图转为右图就与索引的创建过程类似，它的创建有利于减少查找数据时的磁盘I/O次数,提高查找速度。注意，这里提到的磁盘I/O其实是很耗时的。因此它的减少会大大提升我们的时间性能。
1.2 索引的优缺点 (1)优点
减少磁盘I/O,提升数据查找速度(主要原因)创建数据的唯一约束，会自动创建该数据的唯一索引，保证数据库中每一行数据的唯一性对有依赖关系的子表与父表进行联合查找时，可以加快表与表连接(通过主键关联)，提升查找速度(后面将讲解)在建立分组(group by)与排序(order by)时，可以减少减少查询中分组与排序的时间，降低cpu的消耗 (2)缺点
创建与维护索引需要时间，并且随着索引中数据字段的增减，所耗费时间也会增加索引需要占用磁盘空间进行存储降低了更新数据表的速度(增、删、改都需要动态的维护索引) 注：在实际的生产中，如果需要批量的删除、增加、修改数据，可以先把索引删除，完成操作后再重新的建立索引。
2.从零开始设计索引 从Mysql5.5之后使用的存储引擎默认为InnoDB，因此我们以InnoDB为例，从0开始设计、迭代索引。
2.1没有索引时怎么查询数据 如果查询一条数据，我们可以使用如下查询语句：
select [列名] from [表名] where [过滤条件] (1)在同一个页进行查询
如果数据量不是很多，可以在一个页存储完(16kb)，查询有两种情况：
按照主键查找，因为主键是有序的，可以使用二分法查找，时间复杂度为 O ( l o g 2 n ) O(log_2n) O(log2​n)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92031ee9c042493b28df80672eb57e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc80edb55565b81faa1ba9efa83d9edb/" rel="bookmark">
			vsCode注释快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 文章目录 系列文章目录前言一、pandas是什么？二、使用步骤1.你也可以选择代码，使用上方菜单的【编辑】来手动注释代码。 前言 VScode怎么注释掉一段代码 快捷键直接搞定
一、pandas是什么？ 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。vscode注释的快捷键：“Ctrl + /”和“Alt+Shift+A”。vscode中进行注释的方法：1、单行注释，使用“Ctrl + /”，或者先按“CTRL+K”，再按“CTRL+U”；2、块注释，使用“Alt+Shift+A”。
1、单行注释：
Ctrl + /
或 先按CTRL+K，再按CTRL+U
取消单行注释：
Ctrl + /
或 先按CTRL+U，再按CTRL+K
2、块注释
Alt + Shift + A
vscode介绍
vscode（全称visual studio code）是一个运行于 Mac OS X、Windows和 Linux 之上的，针对于编写现代 Web 和云应用的跨平台源代码编辑器软件。
该编辑器也集成了所有一款现代编辑器所应该具备的特性，包括语法高亮（syntax high lighting），可定制的热键绑定（customizable keyboard bindings），括号匹配（bracket matching）以及代码片段收集（snippets）。Somasegar 也告诉笔者这款编辑器也拥有对 Git 的开箱即用的支持。
该编辑器支持多种语言和文件格式的编写，截止2019年9月，已经支持了如下37种语言或文件：F#、HandleBars、Markdown、Python、Jade、PHP、Haxe、Ruby、Sass、Rust、PowerShell、Groovy、R、Makefile、HTML、JSON、TypeScript、Batch、Visual Basic、Swift、Less、SQL、XML、Lua、Go、C++、Ini、Razor、Clojure、C#、Objective-C、CSS、JavaScript、Perl、Coffee Script、Java、Dockerfile。
二、使用步骤 1.你也可以选择代码，使用上方菜单的【编辑】来手动注释代码。 以上就是VScode注释掉一段代码的操作方法了，是不是非常的简单，如果说你的注释快捷键与其他软件有冲突，那么你可以前往快捷键设置中来手动设置顺手的注释快捷键。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41c87d45cf86f5a286d859a73b06a46f/" rel="bookmark">
			Latex中嵌入bib参考文件，完整使用bib的方法听语音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考 Latex中嵌入bib参考文件，完整使用bib的方法听语音 - 云+社区 - 腾讯云
第一步：在你要编写的tex文件的同一目录下新建一个文本文档，命名为*.bib（你自由命名，后缀为bib，如nonlinear.bib）
第二步：搜索论文的bib引用内容（如在https://dblp.uni-trier.de/中搜索工程技术类论文，在搜索栏输入要搜索的论文标题（如：Cryptanalysis and improvement of 2 mutual authentication schemes for Session Initiation Protocol）），
将鼠标移至红色方框中的向下箭头处，找到bibtex，点击bibtex即可出现下面内容，再将红色圈起来的内容复制粘贴到*.bib文件中，点击保存bib文件
第三步：打开tex文件，在 \end{dobument}前面输入：
\bibliographystyle{文献风格}%这里的风格可以从下面8中里面选一个，也可以根据latex模板提供的风格
\bibliography{bib文件名} 如：\bibliographystyle{plain}
\bibliography{nonlinear}
%%%%%%%%%%%%%%%%%%%%%%
LaTeX 标准选项及其样式共有以下8种风格：
plain，按字母的顺序排列，比较次序为作者、年度和标题.
unsrt，样式同plain，只是按照引用的先后排序.
alpha，用作者名首字母+年份后两位作标号，以字母顺序排序.
abbrv，类似plain，将月份全拼改为缩写，更显紧凑.
ieeetr，国际电气电子工程师协会期刊样式.
acm，美国计算机学会期刊样式.
siam，美国工业和应用数学学会期刊样式.
apalike，美国心理学学会期刊样式.
%%%%%%%%%%%%%%%%%%%%%%
第四步：切记！！！在tex文件里，必须引用所有文献即一定输入要引用的文献\cite{...},文中没有引用哪个文献，在参考文献中就不会显示那个文献。如，引用第一个图中的文献，引用名称为下面红线上方大括号后面第一个逗号前的所有内容
第五步：最后编译阶段：
1.用latex编译tex文件，
2.用bibtex编译tex文件，（这里是tex文件，不是编译bib文件）
3.用latex再次编译tex文件（如果没有显示正确，可再用latex编译一下就可以）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c3b4fc87d8734603c42d4cabf28a69/" rel="bookmark">
			数据库基础之视图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、视图
1.1、为什么使用视图
1.2、视图的规则和限制
2、创建视图
2.1、利用视图简化复杂的联结 2.2、用视图重新格式化检索出的数据
2.3、用视图过滤不想要的数据
2.4、使用视图与计算字段
1、视图 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。
说明：DBMS支持 Microsoft Access不支持视图，没有与SQL视图一致的工作方式。因此，本次的内容不适用Microsoft Access。 MySQL从版本5起开始支持视图，因此，本次的内容不适用较早版本的MySQL。 SQLite仅支持只读视图，所以视图可以创建，可以读，但其内容不能更改。
理解视图的最好方法是看例子。用下面的SELECT语句从三个表中检索数据：
输入: SELECT cust_name, cust_contact FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num AND prod_id = 'RGAN01'; 此查询用来检索订购了某种产品的顾客。任何需要这个数据的人都必须理解相关表的结构，知道如何创建查询和对表进行联结。检索其他产品（或多个产品）的相同数据，必须修改最后的WHERE子句。
现在，假如可以把整个查询包装成一个名为ProductCustomers的虚拟表，则可以如下轻松地检索出相同的数据：
输入:
SELECT cust_name, cust_contact FROM ProductCustomers WHERE prod_id = 'RGAN01'; 这就是视图的作用。ProductCustomers是一个视图，作为视图，它不包含任何列或数据，包含的是一个查询（与上面用以正确联结表的相同查询）。
提示：DBMS的一致支持 所有DBMS非常一致地支持视图创建语法。
1.1、为什么使用视图 我们已经看到了视图应用的一个例子。下面是视图的一些常见应用。
重用SQL语句。简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道其基本查询细节。使用表的一部分而不是整个表。 、保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限。更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 创建视图之后，可以用与表基本相同的方式使用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至添加和更新数据（添加和更新数据存在某些限制，关于这个内容稍后做介绍）。
重要的是，要知道视图仅仅是用来查看存储在别处数据的一种设施。视图本身不包含数据，因此返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。
注意：性能问题 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时需要的所有检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，性能可能会下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。
1.2、视图的规则和限制 创建视图前，应该知道它的一些限制。不过，这些限制随不同的DBMS而不同，因此在创建视图时应该查看具体的DBMS文档。 下面是关于视图创建和使用的一些最常见的规则和限制。
与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。对于可以创建的视图数目没有限制。创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予。视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。许多DBMS禁止在视图查询中使用ORDER BY子句。有些DBMS要求对返回的所有列进行命名，如果列是计算字段，则需要使用别名。视图不能索引，也不能有关联的触发器或默认值。有些DBMS把视图作为只读的查询，这表示可以从视图检索数据，但不能将数据写回底层表。详情请参阅具体的DBMS文档。有些DBMS允许创建这样的视图，它不能进行导致行不再属于视图的插入或更新。例如有一个视图，只检索带有电子邮件地址的顾客。如果更新某个顾客，删除他的电子邮件地址，将使该顾客不再属于视图。这是默认行为，而且是允许的，但有的DBMS可能会防止这种情况发生。 提示：参阅具体的DBMS文档 上面的规则不少，而具体的DBMS文档很可能还包含别的规则。因此，在创建视图前，有必要花点时间了解必须遵守的规定。
2、创建视图 理解了什么是视图以及管理它们的规则和约束后，我们来创建视图。 视图用CREATE VIEW语句来创建。与CREATE TABLE一样，CREATE VIEW只能用于创建不存在的视图。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c3b4fc87d8734603c42d4cabf28a69/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464f7c4122978d9818a2699705170468/" rel="bookmark">
			vue报错——[vue/require-v-for-key]Elements in iteration expect to have ‘v-bind:key‘ directives.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[vue/require-v-for-key]
Elements in iteration expect to have 'v-bind:key' directives.
[vue/require-v-for-key]
迭代中的元素期望具有“v-bind：key”指令。
在v-for循环中，
&lt;li v-for="n in imgData"&gt; &lt;img :src=n.url /&gt; &lt;/li&gt; 会报错
解决方法：
在v-for循环后加上:key=""。Vue 2.2.0+的版本里，当在组件中使用v-for时，key是必须的
&lt;li v-for="n in imgData" :key="n"&gt; &lt;img :src=n.url /&gt; &lt;/li&gt; 参考：https://blog.csdn.net/ITarmi/article/details/108917360
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9389c78ba6807a1ee4449094e11157c0/" rel="bookmark">
			谈谈Vue的生命周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、引入生命周期二、生命周期流程分析 1.初始 beforeCreate()created()2.挂载 beforeMount()mouned()3.更新 beforeUpdate()updated()4.销毁 beforeDestroy()destroyed()三、常用的生命周期钩子总结 一、引入生命周期 Vue的生命周期，指Vue的实例从初始化创建到最终销毁的整个过程。
在整个生命周期中的各个阶段，会执行各个阶段所对应的一些特殊命名(不可修改)的回调函数，我们称之为生命周期钩子，引入官方文档Vue生命周期的流程图如下：
Vue生命周期共有八个生命周期钩子，下面我通过这八个生命周期钩子对生命周期的流程进行大致分析：
二、生命周期流程分析 1.初始 初始阶段流程（如图）：
当我们通过new Vue()创建Vue实例时，生命周期还未真正开始，下面我们进入第一个环节：Init Events &amp; Lifecycle: 初始化Vue中的许多事件，做准备工作，生命周期将从这里开始。就好比与新生的婴儿呱呱坠地，此刻正由护士天使进行各项检查及清洗等准备工作。
在初始化(Init)生命周期(Lifecycle)及各项事件(Events)的准备工作完成后，诞生了我们第一个生命周期钩子：beforeCreate()，当它执行完毕后，我们进入了下一个环节：Init injections &amp; reactivity：初始化Vue中的数据监测和数据代理（通过实例对象代理data中的数据）下面介绍beforeCreate()
beforeCreate() 顾名思义，就是“创建前”，创建的是啥呢？通过以上流程图及文字分析，创建的是Vue中的数据监测和数据代理。该钩子函数横在了Init Events &amp; Lifecycle与nit injections &amp; reactivity环节的中间，也就是在该钩子函数执行时，Vue还未进行数据监测和数据代理的环节
举个栗子：
&lt;script&gt; Vue.config.productionTip = false; const vm = new Vue({ el:'#root', data: { n:1 }, methods: { add() { this.n++; } }, beforeCreate() { console.log('此时数据代理还未开始,无法通过vm访问data中数据和methods中方法!'); console.log(this); debugger; } }); &lt;/script&gt; 运行结果：
分析：我们在钩子函数beforeCreate()中打印Vue实例对象并设置断点（防止继续执行，Vue走完它的生命周期），打开控制台，我们发现date中的数据 n 及methods中的 add() 方法还未在实例对象vm中找到，说明此时Vue还未对配置项中的数据进行监测和代理，于是我们取消断点继续执行，让Vue走完整个流程，可以发现实例对象vm已经存有了数据n及方法add()，如下图：
created() 同理，就是“创建后”，由生命周期图分析：也就是初始化数据监测和数据代理完毕后执行该生命周期钩子，此时我们已经可以通过Vue实例对象访问Vue中的数据了
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9389c78ba6807a1ee4449094e11157c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1edf7a31d6f5dacc7adf5b64d566fc2/" rel="bookmark">
			第6讲 Android Camera性能分析 如何通过perfetto抓取trace
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本讲是Android Camera性能分析专题的第6讲，我们介绍如何通过perfetto抓取trace，包括如下内容：
启动Tracing服务通过命令行方式抓取perfetto trace 通过python脚本抓取perfetto trace通过perfetto命令抓取perfetto trace通过UI方式抓取perfetto trace 视频在线观看：
极客笔记：极客笔记在线课程 加入知识星球与更多Camera同学交流
– 星球名称：深入浅出Android Camera
– 星球ID: 17296815
启动Tracing服务 从Android P开始Android引入perfetto，在Android R才默认打开Tracing服务
打开方法
Android P和Android Q才需要手动先打开 # Needed only on Android 9 (P) and 10 (Q) on non-Pixel phones. adb shell setprop persist.traced.enable 1 adb reboot 确认相关服务是否正常启动
HWPCT:/ $ ps -A |grep -iE "traced" nobody 1016 1 46520 2444 0 0 S traced nobody 1017 1 46520 2624 0 0 S traced_probes 通过命令行方式抓取perfetto trace 通过python脚本抓取perfetto trace 抓取perfetto的python脚本
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1edf7a31d6f5dacc7adf5b64d566fc2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd5eb436a469949fdaa7775b6e920c3e/" rel="bookmark">
			华为手机安装软件出现签名不一致
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原来的官方软件卸载即可安装
现在的软件--华为鸿蒙系统到设
置-系统与更新-关闭纯净模式即
可安装
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5680ad069573d0562f83d71151e80cd/" rel="bookmark">
			Tabnine 和 Codota 选择对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2022年4月
官网已说明：Codota 即将停用 - 我们建议安装 Tabnine 插件。
Codota 插件地址 页面说明如下：
翻译后 重要的： Codota 现在是 Tabnine！
好消息，我们发布了下一代 AI 代码完成 - Tabnine。
Codota 即将停用 - 我们建议安装 Tabnine 插件。在 Tabnine.com上查看。
Tabnine 支持所有语言并使用更强大的机器学习模型为您提供更好的代码完成。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/171ca6391f6ba035da8bcfab625c2333/" rel="bookmark">
			二层交换机转发原理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 目录
1 802.1Q定义
1.1 LAN
1.2 VLAN
1.2.1 VLAN定义
1.2.2 802.1Q tag
2 二层转发流程
当报文中的源mac在mac地址表中不存在时，会生成新的mac地址表项。
5 出口vlan过滤
6 出口vlan处理
2.2 Vlan Table的内容
2.3 PVID
2.1 Mac地址表的学习
2.1 Mac地址表的洪泛
2.1 单播与广播
2.2 Mac地址表的查找
2.3 Mac地址表的老化
2.4 Mac地址表的迁移
2.6 Mac地址表的冲突
2.7 Mac地址表的特殊机制
2.5.1 Mac地址表的源查找
2.5.2 Mac地址表的Class ID
2.5.3 Mac地址表的源hit
3 IVL与SVL
4 Acces .Trunk.Hybird
1 定义 1.1 LAN LAN(Local Area Network):局域网，同一个局域网内的终端可以通信。
1.2 VLAN 1.2.1 VLAN定义 VLAN(Virtual LAN)：即虚拟局域网，这项技术可以根据功能、应用或者管理的需要将局域网内部的设备逻辑地划分到一个个网段中，从而形成一个个虚拟的工作组，并且不需要考虑设备的实际物理位置。 IEEE 颁布了 IEEE802.1Q 协议以规定标准化VLAN 的实现方案，交换机的 VLAN 功能即按照 802.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/171ca6391f6ba035da8bcfab625c2333/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e840f85c47eb9d2c7fe130536730ccab/" rel="bookmark">
			在Chrome中拦截替换远程js资源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题背景 在进行日常前端开发时，我们经常需要在Chrome浏览器中调试JavaScript代码。如果是本地代码，调试和修改起来自然都很容易，但调试和修改一个线上页面则是另外一回事了。一方面是因为线上代码一般都经过打包，难以阅读；另一方面则因为浏览器默认不支持直接修改远程脚本（有些脚本使用断点调试可能比较麻烦，比如代码中使用了new Date()语句，或者需要查看一个很复杂的变量对象，这时console.log会是一个很好的工具，但如何注入console.log语句是一个问题）。第一个问题基本上是难以避免的，但第二个问题其实是可以通过Chrome提供的工具大大降低难度的，它就是调试工具source中的override代码重写工具。
使用override重写远程脚本 首先我们打开任意一个网页，比如Vue的官网。打开f12可以看到里面引用了很多js脚本，假设我们现在想修改其中的vue.js脚本文件进行一些在线调试：
要进行脚本替换，首先我们需要找到要替换的脚本文件，查看它的完整路径。比如这里我们可以点击Headers：
然后我们在本地任意位置新建一个文件夹，命名随意，假设名为top。在top文件夹内，我们按照要替换的脚本的路径，新建完全一样的路径（从域名开始，不包括协议），比如这里就是top &gt; cn.vuejs.org &gt; js &gt; vue.js：
我们可以将远程的代码粘贴到本地的这个vue.js内，然后进行任意修改，比如写入console.log语句等（根据需要，甚至可以放入任意的脚本，它将替换远程的vue.js加载和执行）。接下来我们看如何使用这个本地js替换远程js。
我们点击浏览器开发者工具中的Sources工具，点击左上角的Overrides工具：
点击“select folder for overrides”，选择刚才本地新建的top文件夹，此时浏览器会弹出提示，询问是否授予浏览器访问该文件夹的权限，我们点击允许：
此时我们的top文件夹将被加载到浏览器内：
network中显示的黄色警示图标表明当前请求中的某些资源已被本地文件重写，这也表示我们的重写成功了。接着我们在浏览器左上角的刷新按钮右键（需保持f12开启），选择“清空缓存并硬性重新加载”，远程脚本就会替换为我们本地的脚本文件：
比如我们在本地的vue.js顶部加入console.log语句，然后控制台就会进行输出：
至此我们就实现了远程脚本的替换，可谓非常简单实用！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/364c5ace9af9381dc82dc6eb500710a2/" rel="bookmark">
			用C&#43;&#43;实现softmax函数(面试经验)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 今天面试字节算法岗时被问到的问题，让我用C++实现一个softmax函数。softmax是逻辑回归在多分类问题上的推广。大概的公式如下：
i n p u t : { x 1 , x 2 , ⋯ , x n } s o f t m a x ( x t ) = e x t ∑ i = 1 n e x i input: \{x_1, x_2,\cdots, x_n\}\\ softmax(x_t)=\frac{e^{x_t}}{\sum_{i=1}^{n}e^{x_i}} input:{x1​,x2​,⋯,xn​}softmax(xt​)=∑i=1n​exi​ext​​
即判断该变量在总体变量中的占比。
第一次实现 实现 我们用vector来封装输入和输出，简单的按公式复现。
vector&lt;double&gt; softmax(vector&lt;double&gt; input) { double total=0; for(auto x:input) { total+=exp(x); } vector&lt;double&gt; result; for(auto x:input) { result.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/364c5ace9af9381dc82dc6eb500710a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f5466048f747668414f82ab32adc001/" rel="bookmark">
			AndroidStudio编译报错`General error during conversion: Unsupported class file major version 61`
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近升级了一下android studio，发现运行工程报错General error during conversion: Unsupported class file major version 61
错误的原因是：Java 编译器 版本和Android sdk版本不匹配
看了一下自己的电脑JDK版本，居然是JavaVersion.VERSION_17，而工程build.gradle文件中是要求JavaVersion.VERSION_1_8，那就是自己JDK版本太高导致
点击gradle Settings，进入JDK配置页面
配置正确的JDK版本，重新编译工程，正常运行。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6137495c4ea1e2374b9d2025c13291/" rel="bookmark">
			jq回调地狱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="JQuery.js"&gt;&lt;/script&gt; &lt;script&gt; // 拿到a的数据后才去请求b，拿到b的数据后再去请求c 这就叫回调地狱 // 像这种回调嵌套回调的写法就叫回调地狱 // $.ajax({ // method: "get", // url: "data.json", // success(res) { // console.log(res); // $.ajax({ // method: "get", // url: "data2.json", // success(res) { // console.log(res); // $.ajax({ // method: "get", // url: "data3.json", // success(res) { // console.log(res); // }, // }); // }, // }); // }, // }); //jq的ajax本身就是一个promise对象 // $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef6137495c4ea1e2374b9d2025c13291/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/243/">«</a>
	<span class="pagination__item pagination__item--current">244/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/245/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>