<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec7ff26d7b8dd064d807c691466f0d36/" rel="bookmark">
			Java基础知识（知识点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Java是一种高级计算机语言，是可以编写跨平台应用软件、完全面向对象的程序设计语言。
2、Java划分为三个技术平台：Java SE、Java EE、Java ME
Java SE是桌面应用，Java EE是web应用，平台企业版，Java ME是手机应用，平台微型版
3、Java语言的特点：简单易用、安全可靠、跨平台（通过Java虚拟机实现）、面向对象、支持多线程、自动进行垃圾回收(c语言没有)。
Java引入了虚拟机的概念，通过虚拟机（JVM）可以在不同的操作系统上运行Java程序，从而实现跨平台特性。
4、所有的可执行文件都在bin文件夹下
5、bin目录：该目录用于存放一些可执行程序，如javac.exe(Java编译器)、java.exe(Java运行工具)、jar.exe（打包工具）和 javadoc.exe（文档生成工具）
javac.exe是Java编译器工具，它可以将编写好的Java文件编译成Java字节码文件(可执行的Java程序)。就是将.java文件编译成.class文件。
java.exe是Java运行工具，它会启动一个Java虚拟机(JVM)进程，专门负责运行由Java编译器生成的字节码文件(.class文件)
6、db目录：db目录是一个小型数据库
7、include目录：在启动时引入一些C语言的头文件。
8、jre目录：此目录时Java运行时环境的根目录，它包含Java虚拟机、运行时的类包、Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。
jre只负责编写，不负责编译(只有java没有javac)
9、lib目录：为Java类库或库文件，是开发工使用的归档包文件
10、src文件夹：放置JDK核心类的源代码。
1、PATH配置bin文件夹的目录
2、PATH环境变量用于存储Java的编译和运行工具所在的路径。
3、因为Hello World.class字节码文件不是二进制的，不能直接执行，所以需要进行解析。
4、解析器使用“java HelloWorld”命令启动Java虚拟机运行程序，Java虚拟机首先将编译好的字节码问价加载到内存，这个过程称为类加载。
5、Java通过虚拟机，一次编译，到处运行。
6、Java程序通过Java虚拟机可以实现跨平台特性，但是Java虚拟机并不是跨平台的。
7、一个Java文件编译后一定生产一个class文件(❌)
一个Java文件可以有很多类，一个类对应一个class文件，有几个类就编译生成几个class文件。
8、一个文件中只能有一个公共类(public 修饰的类)
9、一个Java文件中可以没有公共类，但是一旦有了公共类，那么公共类的名字一定要和文件名保持一致。
1、Java的三大体系是：Java EE、Java SE、Java ME
2、Java程序的运行环境简称：JRE
3、编译Java程序需要使用 javac 命令
4、javac.exe和java.exe两个可执行程序存放在JDK安装的目录下的 bin 目录下。
5、Path环境变量用来存储Java的编译和运行工具所在的路径，而classpath环境变量则用来保存Java虚拟机要运行的“,class”文件路径。
6、Java.util包含Java中大量工具类、集合类，例如：Arrays、List、Set等。
7、JDK工具包括：Java编译器、Java运行工具、Java文档生成工具、Java打包工具。
8、.class文件可以在Java虚拟机中运行。
9、java.exe命令的作用是Java解释器
1、标识符：经常需要在程序中定义一些符号来标记一些名称，如包名、类名、方法名、参数名、变量名等，这些符号被称之为标识符。
标识符可以由任意顺序的大小写字母、数字、下画线(_)和美元符号( $ )组成，但是标识符不能以数字开头，也不能是Java中的关键字，也不能和JDK中的类同名。否则会在编译的时候出错
2、Java中的命名约定：
1⃣️：包名所有的字母一律小写。
2⃣️：类名和接口名每个单词的首字母都要大写，例如：ArrayList。
3⃣️：常量名的所有字母都大写，单词之间用下画线连接，例：DAY_OF_MONTH。
4⃣️：变量名和方法名的第一个单词首字母小写，从第二个单词开始每个单词首字母大写(驼峰命名法)，例：lineNumber
5⃣️：尽量使用有意义英文单词来定义标识符。
类型名占用空间取值范围byte8位(1个字节)-27~27-1short16位(2个字节)-215~215-1int32位(4个字节)-231~231-1long64位(8个字节)-264~264-1float32位(4个字节)1.4E-45～3.4E+38，-1.4E-45～-3.4E+38double64位(8个字节)4.9E-324～1.7E+308， -4.9E-324～-1.7E+308char每个字符变量占用2个字节Unicode每个Unicode码占用16个字节 3、为一个float类型的变量赋值的时候，所赋值的后面一定要加上F或者f
而在为一个double类型的变量赋值的时候，可以在后面加上D或者d，当然这个double类型的后面可以不加D或者d。
4、Java的字符类型采用的是Unicode编码方案，每个Unicode码占用16个字节。
5、对于char类型的赋值时需要使用一对单引号括起来，而且单引号中必须有且只能有一个字符。
6、Java中不能使用1、0表示真假，只能用true、false表示真假，而c语言用非0表示真，用0表示假，C语言中没有true、false。
范围小的能够自动转换为范围大的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec7ff26d7b8dd064d807c691466f0d36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b3a39e58feb29c339947d30f1d6f535a/" rel="bookmark">
			JAVA对Json数据的解析(Gson&amp;FastJson)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中对json数据的处理可以分为以下两种
将Java中的对象快速的转换为JSON格式的字符串.将JSON格式的字符串, 转换为Java的对象. 而本文介绍的解析方式是Gson和FastJson，而Gson和FastJson都需要引入jar包，下载链接如下
阿里云盘链接百度网盘链接 提取码：6666 而对于如何引入jar文件，可以参考我另一篇文章：IDEA引入jar文件
首先就是Gson，Gson是谷歌针对于Json数据处理而诞生的一种解析方式，而FastJson则属于阿里。
1.Gson (1) 将Java中的对象转换为JSON格式的字符串 使用Gson处理json数据很简单，只需要使用toJson方法就可以将对象转换成json格式的字符串，首先我们创建一个Book对象，其属性包含以下几个，然后生成相应的set/get/tostring方法和构造方法
private int id; //id private String name; //图书名 private String author; //作者 private String info; //简介 private double price; //价格 然后创建一个Book对象，使用toJson方法
Book book = new Book(1,"新年快乐","张三","嘿嘿哈哈",18.8); //创建图书对象 String s = new Gson().toJson(book); //使用Gson的toJson方法将Book对象转换为Json字符串 System.out.println(s); //打印图书对象，以toString方法进行输出 打印结果如下，即为json格式字符串
{"id":1,"name":"新年快乐","author":"张三","info":"嘿嘿哈哈","price":18.8} (2) 将JSON格式的字符串转换为Java中的对象 只需要使用fromJson方法就可以很轻松的将json字符串转换为对象，这里以上方的json字符串为例转换成Book对象
Book book = new Gson().fromJson("{\"id\":1,\"name\":\"新年快乐\",\"author\":\"张三\",\"info\":\"嘿嘿哈哈\",\"price\":18.8}", Book.class); //将json字符串转换为Book对象 System.out.println(book); 输出结果为
Book{id=1, name='新年快乐', author='张三', info='嘿嘿哈哈', price=18.8} 当然，在没有要转换的对象的时候，也可以将json字符串转换为java中的字典
(3) 将JSON格式的字符串转换为Java中的集合 json字符串是以键值对形式存储的，因此将其转换为Map
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b3a39e58feb29c339947d30f1d6f535a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83afbe331a63a2ed00179ecc6a856cb3/" rel="bookmark">
			写在2021最后一天
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.总体感受 在2021的最后一天晚上，依旧坐在办公室，梳理了一下今年的生活、工作、学习，发现今年过得挺平淡的，但又丝丝带着点幸福，这就是正常人生。说平淡其实一方面是疫情防护常态化，心态已放轻松，而正常的工作与管理，没有太多波澜，个人没有什么输出（懒了…）。说幸福其实是看着我的小女儿一天天长大，每天都带着幸福感。
2.今年小收获 虽然过得平淡，但还是有点小收获的：
生活方面：家里终于装修完毕，了却心中一件大事。工作方面：今年对技术部门的管理及规范进行了加强，如开发规范优化、实行代码审查机制、统一文档管理，提升了开发效率。技能方面：进一步加强文件存储技术（对象存储、分块、秒传、接口鉴权等）。直播相关技术熟悉（SRS、WebRTC，FFMpeg）。云服务使用（图像识别、手机验证码、对象存储、云服务器）。大数据相关技术初步理解与实践（理解数仓概念，并在实际项目中实践建数仓）。 3.个人小感悟 关于健康 健康的体魄是一切的前提，之前不是有句话说健康是1，其它所有是0，如果没有健康这个1，其他条件再多也只是0。没有健康就没有一切。对于疾病，我觉得特意记住三个关键词：提前预防、及时处理、加强保障。今年我父亲由于健康问题进行了一次小手术，让我深深感受到这三个词的重要性。平时注意饮食，注重锻炼，定时体检（特别是老人）是有效的提前预防措施。一旦发现问题及时处理，切忌讳疾忌医，时间越长，麻烦越大。交纳医保，熟悉医保报销流程，才能做到好的保障。
关于认知 “几乎所有人一开始都是这样的：享受努力奋斗的状态，却少有产出作品的意识”，这是我在《认知驱动》这本书记录下来的一句话，对我触动很大，这不是自己觉得很努力，即还是觉得没有成长的根源吗？以输出驱动输入，产出对别人有价值的产品，才能说明自己有成长。自己需要的并不是每天读多少书，看多少视频课程，听多少音频教程，而是用这知识已解决了多少实际问题，输出了多少个作品，得到多少反馈。
关于团队 在创业公司带领着十几个人的技术小团队，需要有一定的管理知识，其中很重要的一点是需要规范化开发流程，这也是今年的重点，包括开发流程规范、代码评审流程、git使用规范，开发文档管理、发布流程规范等等，只有流程化，才能减少不必要的沟通，才能提升效率。
关于架构 当今互联网还在快速发展，软件开发的架构已经经历了好几个阶段，原始的分布式时代、单体系统时代、SOA时代、微服务时代、后微服务时代、无服务时代。这是《凤凰架构》一书中所提及的介绍，让人看清当前的趋势。而对于分布式架构而言，远程访问、事务处理、负载均衡、安全性、缓存、持久化存储等是基础，因此在做架构时，需要考虑这些基础点相关的技术融合。
关于时代 身处于这快速发展的时代，如果自己够努力，总能赶上时代的红利。做为程序员，如果说互联网是一波波的浪潮，自己能否成为其中一朵浪花。这又回到自我认知的问题，如果没有产出的价值，没有人会认识到你，只有能有价值的产品，才能通过交换来推动自己走向风口。
4.明年期望 新的一年有新的期望，希望2021年我家小公主依然可以快乐健康成长，家人平安健康。而对自己的期望是提升自己的认知能力，技术领导力、架构能力及大数据开发技能，强化产出思维。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcd677469dc35b18825c8686652d355a/" rel="bookmark">
			一、在树莓派和Ubuntu上配置Qt &#43; OpenCV的交叉编译环境——3. OpenCV的交叉编译（OpenCV4.5.0）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在树莓派和Ubuntu上配置Qt + OpenCV的交叉编译环境——3. OpenCV的交叉编译（OpenCV4.5.0） 本系列导航
1. 对交叉编译的基本理解
2. Qt的交叉编译（带EGLFS支持）
3. OpenCV的交叉编译（OpenCV4.5.0）
文章目录 在树莓派和Ubuntu上配置Qt + OpenCV的交叉编译环境——3. OpenCV的交叉编译（OpenCV4.5.0）前言一、在PC上准备交叉编译器二、在PC上安装依赖库三、在PC上下载OpenCV源码四、在PC上交叉编译OpenCV源码五、在树莓派上配置环境变量六、测试交叉编译总结 前言 完成Qt的交叉编译之后，已经可以把PC端编译好的可执行文件放到树莓派上执行了。这篇博客说的是，如果想要在开发Qt程序的时候调用OpenCV的库，而且仍然需要交叉编译，应该怎么做。
说明：
硬件设备
树莓派 Raspberry Pi 4B，镜像版本为2021-01-11-raspios-buster-armhf-full；
PC端的Ubuntu18.04（在VMware 16.0 Pro虚拟机上运行）。软件版本
Qt 5.14.2
OpenCV4.5.0 一、在PC上准备交叉编译器 因为目标机仍然是树莓派，可以直接用编译Qt的交叉编译器。其下载，环境变量配置详见：2. Qt的交叉编译（带EGLFS支持）中的 二、1. 在PC上下载交叉编译器并配置环境变量。
完成交叉编译器的准备之后，你的PC上应该有一个这样的cross-compile-tool文件夹。
并且，在PC上的terminal输入：
arm-linux-gnueabihf-g++ -v sudo arm-linux-gnueabihf-g++ -v 都应该有正常的版本信息输出。
二、在PC上安装依赖库 因为博主之前在PC上装过OpenCV（非交叉编译），所以已经装过一些依赖库了，这里还是把之前装过的和新安装的都列出：
更新。
sudo apt update sudo apt upgrade 安装cmake及其图形化界面（这个是一定要有的）。
sudo apt install cmake sudo apt install cmake-qt-gui 使64位系统兼容32位系统。
sudo apt install lib32ncurses5 lib32z1 这些是之前装过的（可能并不需要）。
sudo apt install build-essential sudo apt install git libgtk2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcd677469dc35b18825c8686652d355a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffe646c8d947f6574ed1e72c198c41b5/" rel="bookmark">
			【全栈开发实战小草看书之Web端（十一）公司管理】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全栈开发实战小草看书之Web端（十一）公司管理 列表代码文件（pages/sys/company/Index.vue） &lt;template&gt; &lt;div&gt; &lt;div class="row"&gt; &lt;el-button type="danger" @click="remove()"&gt;删除&lt;/el-button&gt; &lt;el-button type="primary" @click="open(0, 'Edit')"&gt;增加&lt;/el-button&gt; &lt;el-button type="primary" @click="list"&gt;刷新&lt;/el-button&gt; &lt;/div&gt; &lt;el-table ref="table" :data="data.records" border highlight-current-row @selection-change="select"&gt; &lt;el-table-column type="selection" align="center"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="编码" prop="id" header-align="center"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="名称" prop="name" header-align="center"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="电话" prop="phone" header-align="center"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="地址" prop="addr" header-align="center"&gt;&lt;/el-table-column&gt; &lt;el-table-column label="操作" width="150px" align="center"&gt; &lt;template #default="scope"&gt; &lt;el-button type="primary" circle icon="edit" title="编辑" @click="open(scope.row.id, 'Edit')"&gt;&lt;/el-button&gt; &lt;el-button type="danger" circle icon="delete" title="删除" @click="remove([scope.row.id])"&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination background v-model:page-size="params.size" :total="data.total" v-model:current-page="params.current" layout="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffe646c8d947f6574ed1e72c198c41b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1595db51907e991409d5f3c02631859/" rel="bookmark">
			TFTP与FTP的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 、TFTP与FTP区别介绍 1.FTP 是完整、面向会话、常规用途文件传输协议。而 TFTP 用作 bones bare - 特殊目的文件传输协议。
2.交互使用 FTP。 TFTP 允许仅单向传输的文件。
3.FTP 提供身份验证。而TFTP 不。
4.FTP 使用已知 TCP 端口号： 20 的数据和 21 用于连接对话框。 TFTP 用于 UDP 端口号 69 其文件传输活动。
5.因为 TFTP 不支持验证 WindowsNT ，所以FTP 服务器服务不支持 TFTP。
6.FTP 依赖于 TCP，是面向连接并提供可靠的控件。 TFTP 依赖 UDP，需要减少开销, 几乎不提供控件。
一种FTP服务器：WFTPD 下载地址：http://www.onlinedown.net/soft/42978.htm
TFTP服务器工具：tftpd32 下载地址：http://xiazai.zol.com.cn/detail/34/337562.shtml
二、TFTP介绍 简单文件传送协议TFTP(Trivial File Transfer Protocol)是一个TCP/IP协议族中一个很小且易于实现的文件传送协议。TFTP也是使用客户服务器方式，但它使用UDP数据报，因此TFTP需要有自己的差错改正措施。
TFTP的主要特点是：
（1）每次传送的数据PDU中有512字节的数据，但最后一次可不足512字节。
（2）数据PDU也称为文件块(block)，每个块按序编号，从1开始。
（3）支持ASCII码或二进制传送。
（4）可对文件进行读或写。
（5）使用很简单的首部。
（6）TFTP只支持文件传输而不支持交互；
（7）TFTP没有一个庞大的命令集；
（8）没有列目录的功能；
（9）也不能对用户进行身份鉴别。
TFTP的工作很像停止等待协议。
例如：
（1）发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。
（2）发完数据后在规定时间内收不到确认就要重发数据PDU。
（3）发送确认PDU的一方若在规定时间内收不到下一个文件块，也要重发确认PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1595db51907e991409d5f3c02631859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35d24c735ff1824452fb18fc815b4f78/" rel="bookmark">
			从零开始：调用MapReduce进行单词的词频统计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信大家在复习英语相关考试时，都会很关注也很想知道试题中出现频率较高的单词是哪些从而提高复习的命中率对吧？今天我就告诉大家一个方法，使用MapReduce对指定文本进行单词的词频统计。那接下来我就带领大家从零开始一步步搭建环境，到最后的结果呈现，Let's go!
前置环境：
虚拟机Ubuntu系统
首先第一步要做的是Hadoop的生态安装： 1.在Oracle VM VirtualBox安转Ubuntu linux系统
2. 安装SSH、配置SSH无密码登陆
2.1因为ubuntu默认已经安装SSH client,所以只需安装SSH server: 命令：Sudo apt-get install openssh-server
2.2安装SSH服务后使用ssh localhost命令登陆本机
2.3 为了方便不用每次登陆SSH都需要密码，所以就将其配置成无密登陆。首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中
之后再次使用localhost命令登陆则无需输入密码
3. 安装Java环境
首先在ubuntu的hadoop用户下创建一个Downloads的文件夹用于存放JDK的压缩包
JDK文件使用FileZilla传输到虚拟机Ubuntu里刚创建的Downloads文件夹下
然后接着创建在/usr/lib目录下创建一个jvm的文件夹，将刚才Downloads目录里的JDK压缩包解压到jvm目录下
JDK文件解压后使用cd /usr/lib/jvm进入jvm的目录，再ls命令查看一下解压后的情况
接着使用vim编辑器将以下内容添加到hadoop用户的环境变量配置文件中
保存.bashrc文件并退出vim编辑器。然后，继续执行source ~/.bashrc命令让配置生效，之后使用java -version命令查看是否成功安装
4. 安装Hadoop 2
首先通过FileZilla把Hadoop文件传输到Ubuntu里hadoop用户下的“Downloads”文件夹目录下
接着将Hadoop解压到/usr/local/里，并查看确认是否解压成功
解压后将文件夹名改为 hadoop 并修改文件权限
最后输入以下命令检查Hadoop是否可用，可用则会显示hadoop的版本信息
5. Hadoop伪分布式配置
Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。
Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35d24c735ff1824452fb18fc815b4f78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5b773b3933a63f95c9bcacb04533a88/" rel="bookmark">
			selenium driver关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sys.meta_path is None, Python is likely shutting down
self.driver.quit()，无法关闭chromedriver，会导致内存泄露。即使程序结束，chromedriver也会一直占用内存；如果你出现了上诉错误，你可以通过windows的任务管理器，可以看到chromedriver进程还在运行。
bug说明: https://github.com/SeleniumHQ/selenium/issues/8571
我的driver关闭代码
def __del__(self): try: # 关闭浏览器 self.driver.quit() except: # dos命令杀死chromedriver进程即可 os.system("taskkill /F /im chromedriver.exe") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b13544e18be82ddd4d07a3cf83d3f572/" rel="bookmark">
			Linux系统移植：U-Boot 启动流程（中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统移植：U-Boot 启动流程（中） 一、board_init_f 函数详解 board_init_f 函数是 _main 函数初始化中调用的重要函数之一，函数主要有两个工作：
初始化一系列外设，比如串口、定时器，打印一些消息初始化 gd 的各个成员变量，本质上 uboot 是 linux 的引导文件，引导完成后 linux 会在 DRAM 前面的地址区域启动，为了防止 linux 启动后对 uboot 进行干扰，uboot 会将自己重定位到 DRAM 最后面的地址区域 拷贝之前肯定要给 uboot 各部分分配好内存位置和大小，比如 gd 应该存放到哪个位置，malloc 内存池应该存放到哪个位置等。这些信息都保存在 gd 的成员变量中，因此首先要对 gd 的这些成员变量做初始化
此函数定义在文件 common/board_f.c 中：
void board_init_f(ulong boot_flags) { #ifdef CONFIG_SYS_GENERIC_GLOBAL_DATA /* * For some archtectures, global data is initialized and used before * calling this function. The data should be preserved. For others, * CONFIG_SYS_GENERIC_GLOBAL_DATA should be defined and use the stack * here to host global data until relocation.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b13544e18be82ddd4d07a3cf83d3f572/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2811f6d3f120d950cee175858bc1225/" rel="bookmark">
			python运行后显示，＜input＞:1: SyntaxWarning: “is“ with a literal. Did you mean “==“?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原因：
从 python 3.8 开始，使用 is 和 is not 运算符时，会抛出 SyntaxWarning 语句警告信息。
解决方法：
建议将对应语句中is/is not用== 和 != 代替。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177b6b362cb977f42102b74503d9eb3d/" rel="bookmark">
			烟花Python （动态）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 非原创，借鉴学习，加油！ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d7279086de667911dbfc64c9825571/" rel="bookmark">
			圣诞树Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa4d9a6d0c1693408473f393b66d62ba/" rel="bookmark">
			python 爱心代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903bdb4d1c05ab838435d64fee0d6446/" rel="bookmark">
			梦飞openmv py-AI机器视觉_自主开发openmv底层固件和硬件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.openmv是什么？
openmv是国外团队开发的基于STM32的一款机器视觉模块，openmv是一个开源项目，所有的代码和硬件均以MIT协议开源，它可以利用micropython进行上层应用代码的开发，旨在像arduino一样简单编程就能实现各种图像识别的功能，虽然STM32不是专用图像视频处理器，但是其作为一款MCU表现的超强的图像处理性能仍然可以做很多事情。在此感谢中国团队星瞳科技对openmv的推广、使用方法和使用技巧做出了巨大的贡献；
2.为什么要自主开发openmv？
首先，想开发一款openmv的初衷是它太好玩了，最开始也买了好几个模块去玩，后来了解一些硬件构造成本和原理后觉得这个价格实在受不了，一个简单的硬件电路板和各种配件是普通学生玩不起的，这阻挡了非常多热爱学习又资金有限的玩家；
其次，最新的openmv源码在图像识别的算法上基本没有太多有用的更新，除了当初的颜色（连通域算法）/形状（霍夫变换）/二维码（zbar）/人脸（haar_casecade）/模板匹配（CNN）/二值化分割（canny算子）/线性回归/HOG特征/keypoints跟踪/标签识别等等常用的图像分割和识别算法，后来增加的machine learning和深度学习框架基本没有实际应用价值（3层神经网络，帧率4-5帧，只能演示用一下）；
最后，为什么不在传统机器视觉的应用上再上前一步呢？其实所有的深度学习，前处理和后处理都离不开传统算法，甚至有时我们需要使用传统算法和AI结合才能完成一个复杂的应用。我们希望能做出一款能学习也能实际应用的产品，而不是仅仅是所谓的正版商家盈利的手段（根据MIT 开源协议，openmv没有正版之说，购买key只是个IDE验证和向openmv团队的捐赠）。
3.梦飞oepnmv做了哪些？
（1）基于STM32F407的openmv
梦飞小梦在STM32F407上实现了openmv的程序支持，官方源码中已不再支持openmv1代，但是其实openmv2代的性能（STM32F427）除了内存多几十KB之外，其他硬件资源和STM32F407并无区别，并且F407也支持CCM快速内存和DCMI接口，于是将F407的硬件资源分配按照openmv2的资源分配重新编写一个omvboadrconfig.h头文件和更改了bootload中的boot地址分配，以及支持了内部FLASH映射成U盘的操作，并开放了模板匹配和光流的算法，使其在QQVGA分辨率下支持大部分传统视觉算法，在STM32F407VGT6上实现了openmv的固件；代码功能可以相当于openmv3，为此，我也整理了关于openmv源码下载，Linux环境安装，源码编译，各部分分解，代码流程等文档。
（2）基于STM32H7的openmv4
在STM32F4上尽管实现了openmv，但是其处理性能和分辨率限制还是大大降低了可玩性，因此我又在高性价比的STM32H750上做文章，由于STM32H750VBT6具备实际使用2MB的FLASH和1MB的存储，硬件资源上和H743一致，唯一的区别就是H750的功耗比H743高，发热量也大一点，但是并不影响它出色的处理性能和高性价比；于是，利用开源的STM32H7_openmv代码，在其上面进行二次开发；并制作了配套的openmv硬件，
支持OV7670摄像头接口（2.54排插接口，支持ov7670/7725/2640/5640等）
8MB_QSPI_FLASH，2路5V舵机驱动接口，两路串口，4路单独的PWM输出可控制电机，8ping SPI LCD接口，SD卡，SW下载口，并且可以通过IO口复用配置成各种功能;
硬件上最大的特点就是：使用起来无需任何转接板，也无需SD卡外置了flash，能直接保存大量的py代码
基于openmv源码的应用开发具体完成以下一些内容（后续会逐步将这些应用开发开源出来）：
1）支持OV7670的驱动（期间查看了一份Linux的ov7670摄像头驱动），将其分辨率从VGA,CIF,QVGA,QCIF的全部分辨率下窗口设置函数全部支持（标准帧率24M时钟配置下QQVGA/VGA 15FPS，CIF/QCIF30FPS），有些ov7670可以支持倍频48MHz，灰度图像可以达到60fps；相比于OV7725价格低太多，并且作为图像识别的帧率也够（一般openmv的图像识别帧率不会超过30帧）；
2）支持了ST7735的驱动，ST7735是一个通用的TFT液晶屏，将STM32上面的液晶屏配置代码和横屏纵屏设置加入openmv源码，可以支持通用的8pin接口ST7735液晶屏，而不用购买openmv官方接口的液晶屏
3）移植了cubeAI的mnist手写数字识别
利用openmv源码中提供的mnist手写字体识别神经网络算法，在STM32_CUBE AI中配置和生成了STM32运行代码，移植到openmv中，添加cubeai的编译器，编译成功后可在openmv中使用mnist手写数字识别的算法（其实cubeai相比tenserflow、caffe等框架更容易实现神经网络，并且支持的是ARM-cortex-M4/M7底层架构，ST官网中有现成的转换工具，因此一些简单的深度学习使用CUBE_AI是一个不错的选择）
4）openmv例程整理
尽管IDE上自带了很多例程，但是在实际应用的时候，可能还需要外接传感器和设备，因此我整理了众多的openmv例程，包括ST7735/ST7789 py代码驱动、OV5640自动聚焦、形状识别（圆/矩形/三角形）、颜色识别追踪、人脸识别追踪、超声波测距、图像定高测距（乒乒球测距）、车牌识别（模板匹配）、人脸比对（LBP特征）、光流/视觉定位、板球系统、电磁炮系统、红外热成像测温等等众多openmv例程
5）openmv视觉小车
我们在openmv上开发了一套智能履带小车，采用L298N驱动和金属底盘安装的履带车，并搭配SG90/MG90S云台，可以实现云台自动追踪和小车前后左右同时跟踪，大大增加了其可玩性，并且整套售价达到了官板的1/3，这也算是一个巨大的进步了 ；
6）openmv机械臂
梦飞智能基于自主开发的openmv，制作了基于openmv的三自由度机械臂，并能通过机械臂进行目标识别和抓取操作
7）openmv WiFi图传模块
梦飞openmv还配套制作了WiFi图传模块，基于ESP12 arduino开发，将图像通过SPI接收，然后用webserver发送出去，可以在手机上显示，VGA最快能做到10fps，QVGA能到18fps，QQVGA-25fps，基本上达到了实时的效果，比AT-WINC1500快了不知道多少倍，由于ESP8266的低功耗，整体模块功耗为5V-0.25A。
8）openmv LCD模块
基于ST7735 LCD液晶屏，使用通用的8pin -LCD可接入openmv，并调用openmv底层的函数，可以支持RGB显示和灰度图显示
9）openmv 摄像头转接板
基于梦飞openmv的设计，可以支持不同ov系列的摄像头，因此制作了24pin dvp转2.54接口的摄像头转接板，可以把OV7670/7725/2640/5640/3640等等dvp摄像头转接后接入openmv
10）openmv双轴云台
尽管有开源的3D打印云台，但是精度问题和转接板问题，使用太麻烦，于是基于航模的fpv两轴云台进行打孔和改造，使用SG90/MG90s舵机安装后能直接插在openmv，实现颜色，二维码，人脸追踪等玩法
4.我们还可以做些什么？
1)底层资源优化
其实STM32H7的处理性能远不止于此，因为openmv底层使用的是内部SRAM作为算法运行内存空间，如果将重要的处理算法放在TCM快速内存中运行将提升一倍的处理性能；
2）算法应用
基于现有的机器视觉算法，我们还可以实现很多应用功能
车牌识别（车牌定位、二值化分割、字符分割、畸变矫正、字符匹配等），H7的性能完全足够处理车牌识别的算法，尽管处理分辨率不会很大，可以应用于路边智能停车；
人体检测（图像二值化分割、腐蚀、膨胀、边缘提取、目标矩形框检测、矩形框筛选），基于视觉分割提取人体目标位置；采用MLX90640红外图像基于温度信息的图像将会对人体检测的准确率大大提升，可应用与智能家居，体温检测，防火防灾领域；
车道线提取（图像滤波，canny算子二值化，霍夫变换，线段提取，ROI区域选择，输出车道线位置），可应用于自动驾驶控制；
工业缺陷检测（利用图像分割算法进行缺陷提取和定位等算法）。。。等等，其实还可以做很多实际应用；
最后，，，，，，上一张图，openmv技术交流群，718304823，加群请备注从哪里获取的群号哦
梦飞openmv视觉小车（咸鱼或淘宝搜索，梦飞openmv或梦飞智能，进我的主页查看）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a612690fb51da81e2d55867269ed639a/" rel="bookmark">
			机器学习基本算法思想和步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、EM算法二、 线性回归公式三、 K-means算法四、正则化五、 boosting和bagging六、 深度学习的定义，特征七、 生成式和判别式模型八、 SVM九、 SVM概念十、 BP神经网络十一、 决策树十二、 stacking十三、 特征选择十四、 异常检测18-Lecture15-XV. Anomaly Detection十五、 推荐系统Recommender Systems 一、EM算法 EM算法是一种迭代优化策略，由于它的计算方法中每一次迭代都分两步，其中一个为期望步（E步），另一个为极大步（M步），所以算法被称为EM算法（Expectation Maximization Algorithm）。其基本思想是：首先根据己经给出的观测数据，估计出模型参数的值；然后再依据上一步估计出的参数值估计缺失数据的值，再根据估计出的缺失数据加上之前己经观测到的数据重新再对参数值进行估计，然后反复迭代，直至最后收敛，迭代结束。
EM就是最大期望算法（Expectation Maximization Algorithm，又译期望最大化算法），是一种迭代算法，用于含有隐变量（latent variable）的概率参数模型的最大似然估计或极大后验概率估计。比如先假定男生身高平均1.7 方差0.1 然后求将ABCDEFG归类，分到1.7左边右边，重新求方差，反复迭代，直到不再变化。
二、 线性回归公式 单变量线性回归
模型假设
代价函数
梯度下降
多变量线性回归
模型假设
代价函数
梯度下降
三、 K-means算法 选取划分数量K值，随机选择集合D中的k个点作为初始的聚簇中心，对于其他样本点，计算其与各个簇中心的距离，将它们划入距离最近的簇；采用迭代重定位技术，重新计算簇的平均值，对样本点进行重新分配，不断重复这个过程，直到簇中心的变化在给定条件的阈值内或者与前一次一样，得到最终的聚类中心和聚类结果。
聚类：一种无监督学习的方法，实质是依据某种距离度量，使得同一聚簇之间的相似性最大化，不同聚簇之间的相似性最小化，即把相似的对象放入同一个聚簇中，把不相似的对象放到不同的聚簇中。聚类和分类不同，聚类的输入对象不需要带有类别标签，最后组成的分类是由使用的算法决定的。
K-means优点：简单、移动、伸缩性良好
k-means的缺陷和解决办法：
1、 对初始聚簇中心位置敏感:随机
2、 对K值的选择敏感：多次运行通过合适的准则从结果中挑选最合适的K值
3、 仅能获得局部最优解：基于不同的聚簇中心多次运行算法；对收敛解进行受限的局部搜索
4、 非凸聚类：对数据进行缩放；选择与数据集更匹配的距离度量；用别的算法与k-means形成配套
5、 对噪声点敏感：预处理和后处理
6、 产生空聚簇：从最大的聚簇中“偷出”一些点来重新初始化空聚簇的聚簇中心
四、正则化 logistic回归模型
我们对图1a所示的数据采用简化的线性logistic回归模型进行两分类，即
（1） 考虑一个正则化的方法，即最大化
注意只有w2被惩罚。则当C很大时，如图1(b)所示的4个决策边界中，哪条线可能是有该正则方法得到的？L2、L3和L4 可以通过正则w2得到吗？
答：
L2不可以。当正则w2时，决策边界对x2的依赖越少，因此决策边界变得更垂直。而图中的L2看起来不正则的结果更水平，因此不可能为惩罚w2得到；
L3可以。w22相对w12更小（表现为斜率更大），虽然该决策对训练数据的log概率变小（有被错分的样本）；
L4不可以，当C足够大时，我们会得到完成垂直的决策边界（线x1 = 0或x2轴）L4跑到了x2轴的另一边使得其结果比其对边的结果更差。当中等程度的正则时，我们会得到最佳的结果（w2较小）。图中L4不是最佳结果，因此不可能为惩罚w2得到。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a612690fb51da81e2d55867269ed639a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/511772f792e669f10ba92fa3d7dc0c24/" rel="bookmark">
			TypeScript基础类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		//1.任意类型：any；声明any的变量可以赋予任意类型的值。 //变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查 let x:any = 1; //数字类型 x = 'I am who I am'; //字符串类型 x = false; //布尔类型 //2.字符串类型:string;一个字符系列，使用单引号（'）或双引号（"）来表示字符串类型。反引号（`）来 //定义多行文本和内嵌表达式。 let name:string = "Runoob"; //3.数字类型：number；双精度64位浮点值，它可以用来表示整数和分数 let binaryLiteral:number = 6; //4.布尔类型：boolean；表示逻辑值：true和false。 let flag:boolean = true //5.数组类型：声明变量为数组。 //在元素类型后面加上[] let arr:number[] = [1,2]; //或者使用数组泛型 let arr:Array&lt;number&gt; = [1,2]; //6.元组：元组类型用来表示已知素数量和类型的数组，各元素的类型不必相同， //对应位置的类型需要相同。 let x:[string,number]; x=['Runoob',1] //7.枚举 enum:枚举类型用于定义数值集合 enum Color {Red,Green,Blue}; let c:Color=Color.Blue; console.log(c); //输出2 //8.void：用于标识方法返回值的类型，表示该方法没有返回值 function hello():void { alert("Hello Runoob"); } //9.null：表示对象值缺失 //null是一个只有一个值的特殊类型。表示一个空对象引用。用typeof检测null返回是object。 //10:undefined:用于初始化变量为一个未定义的值。 //undefined是一个没有设置值的变量，typeof一个没有值的变量会返回undefined.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/511772f792e669f10ba92fa3d7dc0c24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43ba0c754a07b9e7068b50ab7ae95dc2/" rel="bookmark">
			为什么公司要求使用TypeScript而不是JavaScript
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在过去的几年里，TypeScript的流行度一直在增加。它是2020年最有前途的五种语言之一。最大的前端框架之一Angular正在使用TypeScript。大约60%的JS程序员已经在使用TypeScript，22%的人希望尝试。
首先我了解到，TypeScript是JavaScript的超集，主要提供可选的静态类型，类和接口。其中一个重要好处是使IDE能够在你键入代码时提供更丰富的环境来发现常见的错误。实际上一项研究表明，TypeScript可以检测到15%的JavaScript错误。
我们都知道JavaScript语言属于弱类型语言，它对于类型要求并不高，甚至可以通过赋值操作修改变量的类型。
TypeScript强制要求程序员去声明数据类型，你如果不按照它的规则去写，它就报错给你。在大型应用系统中这是好事，这样便于维护开发。
而且TypeScript有以下的优点：
TypeScript增加了代码的可读性和可维护性
类型系统实际上是最好的文档，大部分的函数看类型的定义就可以知道如何使用了可以在编译阶段就发现大部分错误，这总比在运行时候出错好增强了编译器和IDE的功能，包括代码补全、接口提示、跳转到定义、重构等 TypeScript非常包容
TypeScript是JavaScript的超级，.js文件可以直接重命名为.ts即可即使不显式的定义类型，也能够自动做出类型推论可以定义从简单到复杂的几乎一切类型兼容第三方，即使第三方库不是用TypeScript写的，也可以编写单独的类型文件供TypeScript读取。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69b71a4a12c1620dcf1d2418c741646a/" rel="bookmark">
			VS warning LNK4099:未找到 PDB 的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		举例: “warning LNK4099: 未找到 PDB“vc120.pdb”(使用“sqlite3d.lib(sqlite3secure.obj)”或在“D:\test\Debug\vc120.pdb”中寻找)；正在链接对象，如同没有调试信息一样”。 使用VC时链接了第三方静态库, 并且第三方静态库(一般是开源的三方库)是在一个solution下的多个project, 当然, 网上基本都是这么回答的, 其实本质原因是因为这些开源库一般都会通过各种方式修改solution和project的默认路径把二进制生成到同一个目录下, 比如lib, 而我们自己平时简单的静态库工程是不怎么修改默认工程配置的.由于每个开源库的作者有自己的工程组织方式, 但导致LNK4099的最终原因无非是PDB路径问题
解决方案 a. 如果确认不需要PDB, 即不需要调试开源库, 完全可以在设置里将/Zi或/ZI去掉, 这样即能消除warning也能提升开源库编译速度 b. 如果需要调试开源库, 方法也不复杂 b.1. 将开源库project里的C/C++-&gt;General-&gt;Debug Information Format 设置为Zi或ZI(两者区别请自行google, Zi就够用了, 只是高版本的VS默认都是ZI) b.2. 然后在C/C++-&gt;Output Files-&gt;Pragram Database File Name 设置为(OutDir)(OutDir)(TargetName).pdb, (有些2B开源库这里设置的跟VS默认的是一样的比如(IntDir)vc(IntDir)vc(PlatformToolsetVersion).pdb, 但把IntDir改成了同一个目录, 每个project生成出来的pdb名字路径都是一致的, 当然就会出问题), 这里需要注意的是, 一定要确保(OutDir)(OutDir)(TargetName)是有意义的, 个别开源库完全不用vs自带的宏, 甚至个别开源库需要configure之后才生产vc project, 甚至是绝对路径, 但你所要确保的是, 目录必须跟生成的.lib是同一个, 文件名(不包括扩展名)必须是和生成的xxx.lib的xxx是一致的. 之后你要做的就是把每个project的debug&amp;release都按照如上改好再编译就ok了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/034ecbccc9a80bbbbe8feb9541535e33/" rel="bookmark">
			stop-hbase.sh关闭不了，一直处于等待状态。（已解决）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天关闭HBase时，输入stop-hbase.sh命令一直处于等待状态。
stopping hbase…
解决办法是：
先输入hbase-daemon.sh stop master命令
再输入stop-hbase.sh命令。
这样hbase就可以成功关闭。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bde2ee6d6522020f9fa63db713c5c80/" rel="bookmark">
			ADKAR模型简介(转）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ADKAR变革模型是由Jeff Hiatt创建，由认知、渴望、知识、能力、巩固五要素组成。它是一种目标导向的变革管理模型，用以指导个人和组织变革。其可应用到各种各样的变革中来推动变革的成功。
ADKAR模型实例
接下来我们通过一个生活中的减肥实例，来说明ADKAR模型实操。
Awareness认知：张小姐早上起床，一称体重是70KG，但是相对她的身高而言，健康的体重应该在45KG左右，从数据上看她已经严重超出指标了!在这一环节，张小姐意识到自己体重超标的事实，但认知归认知，她可能依然会像往常一样，该吃吃，该喝喝，不做任何控制。
Desire渴望：张小姐参加公司年度体检，体检医生告诉她已经是中度脂肪肝，如果不减肥，将会转变成重度脂肪肝，而且患上糖尿病、高血压等疾病的概率会很大。在这一环节，张小姐意识到了问题的严重性。因此打算开始采取减肥行动了!
Knowledge知识：张小姐打算通过调整自己的饮食结构再配合运动进行减肥。但她对健康的饮食方法和科学运动方法一无所知，她购买了相关书籍进行阅读，关注了很多减肥博主的视频号。也参加了很多健康饮食及科学运动的讲座。她开始知道怎样打造适合自己的健康饮食及科学运动计划。在这一环节，张小姐掌握了健康减肥的必要知识，但她真的能够将它应用到日常生活中并坚持下来吗?
Ability能力：开始采取行动，张小姐一日三餐按照制定的健康饮食计划执行，并且每天按照计划配合科学运动，张小姐风风火火的开始了她的科学减肥之旅，她是否可以持之以恒的减肥，我们拭目以待。这一步很棒，张小姐开始将知识转化为行动。
Reinforce巩固：张小姐非常自律并且不断地通过PDCA评估优化自己的饮食结构及运动方式，几个月过去了，她发现健康饮食加运动，已经成为了一种习惯，体重也开始有明显的变化，体重渐渐降到了标准体重，脂肪肝也没了!至此，健康饮食+科学运动已经成为了一种固化的习惯，张小姐的减肥行动也取得了显著的成果，张小姐也因为自己的努力改变而感到非常高兴，并且计划一直持续下去。
通过以上实例发现，通过专注ADKAR五个阶段中的每个阶段，其可有效的规划个人和组织的变革。
使用ADKAR模型将有助个人和组织有效的计划新的变革，也有助于诊断识别现有变革失败的问题点，从而可以采取纠正行动。模型的每一步都概述了个人/组织通过变革的成功旅程，并提供了一个结果导向的变革管理活动。例如，行为者对变革没有必要性的认知，则将需要制定一个沟通计划来推进变革必要性的认知。因此，这种结果导向的方法将增加变革成功的机率。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/271/">«</a>
	<span class="pagination__item pagination__item--current">272/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/273/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>