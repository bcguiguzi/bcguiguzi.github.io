<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61cd1b7f8178211cdd4f5ba9fe9b89ad/" rel="bookmark">
			基于YOLOv8的目标检测半自动标注脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于YOLOv8的目标检测半自动标注脚本 1.本项目文件结构如下：2.目标检测自动化标注脚本3.如果想将xml和图像文件分离，可使用如下脚本: YOLOv8安装、训练见这篇文章【YOLOv8教程】（手把手详细版，支持训练自定义数据集），包含环境配置、数据配置、训练、预测、验证、导出
1.本项目文件结构如下： ├── README.md ├── README.zh-CN.md ├── class_index.py ├── config.py ├── create_xml.py ├── docker ├── docs ├── examples ├── mkdocs.yml ├── requirements.txt ├── setup.cfg ├── setup.py ├── tests ├── ultralytics 2.目标检测自动化标注脚本 只需要一个脚本文件即可完成费时费力的标注工作
创建creat_xml.py，创建位置见上述目录，其中内容如下：
from lxml.etree import Element, tostring, parse from lxml.etree import SubElement as subElement import torch from ultralytics import YOLO class Yolov8Detect(): def __init__(self, weights, img_size=960, conf_thresh=0.2, iou_thresh=0.5, batchsize=16): cuda = True if torch.cuda.is_available() else False self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61cd1b7f8178211cdd4f5ba9fe9b89ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56ecb6e215feec3aed155862f0b953e0/" rel="bookmark">
			一阶RC低通滤波器的离散化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、一阶RC滤波电路1.1、一阶RC电路的时域分析1.2、一阶RC电路的频域分析 2、一阶RC低通滤波器的离散化3、一阶低通数字滤波器的Simulink仿真 前面我们讲了一阶系统传函的标准形式和时域响应。今天说下生活中对应的一个一阶系统——一阶RC低通滤波器。
1、一阶RC滤波电路 1.1、一阶RC电路的时域分析 电容的电流：
基尔霍夫电压定律得：
u i u_{i} ui​的单位是V，时间常数 τ \tau τ =RC； 解微分方程得：
看下时域下的响应曲线：
假设电容初始电压值为0 ，R=1K，C=4.7uF ，ui=1V ，T=RC 那么V(τ)=0.632 V。
1.2、一阶RC电路的频域分析 再变化下：
看下幅频和相频特性曲线：
幅频特性图的对数表示：
由上可以看出：
当ω&lt;ωc时，幅值是平行于坐标的直线，基本无衰减；当ω&gt;&gt;ωc时，是斜率与-20dB/十倍频成比例的一条直线；当ω=ωc时，增益衰减至0.707，即-3dB，相位滞后45度，对应低通滤波器，该频率通常被称为截止频率 当使用一个一阶RC低通滤波器的时候，如果信号频率等于截止频率的时候，有个45°的延迟，就会涉及到相角的补偿。
2、一阶RC低通滤波器的离散化 对上面的微分方程拉氏变换得：
再通过z变换（方法很多，如一阶前向差分、双线性变换等，这里用一阶后向差分法）
从上面的式子：
可以看出，这个是数字一阶低通滤波器常见的形式。其中等式右边的两个系数相加等于1，即
R C T s + R C + T s T s + R C = 1 , T s 为采样周期 \frac{RC}{T_{s}+RC}+\frac{T_{s}}{T_{s}+RC}=1,T_{s}为采样周期 Ts​+RCRC​+Ts​+RCTs​​=1,Ts​为采样周期,截止频率 f c = 1 2 π R C f_{c}=\frac{1}{2\pi RC} fc​=2πRC1​。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56ecb6e215feec3aed155862f0b953e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04335399c8016e245650ae2d905157f3/" rel="bookmark">
			基于张量补全的交通数据复原文献汇总（最新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于传感器故障和通信故障等因素导致的交通数据缺失严重制约了ITS的发展与应用。如何准确、高效地恢复缺失数据已成为ITS的一个关键问题。近年来，LRTC（低秩张量补全）的方法已被广泛应用于交通数据补全。本文将介绍几篇最新的关于交通数据补全的文献。欢迎批评指正！
1、LRSSRTC（2022） 文献：A Novel Spatiotemporal Data Low-Rank Imputation Approach for Traffic Sensor Network
期刊：IEEE Internet of Things Journal
作者：Xiaobo Chen, Shurong Liang, Zhihao Zhang, Feng Zhao
摘要：物联网 （IoT） 具有通过改善乘客体验、安全性和效率来改变运输业的巨大潜力。然而，交通传感器网络收集的时空数据经常受到缺失值（MV）的影响，这会影响系统的整体性能。因此，MV的准确回收对于物联网在运输中的成功应用至关重要。在本文中，我们通过将低秩张量完成（LRTC）和稀疏自表示集成到一个统一的框架中，提出了一种新的MVs插补模型。这样，可以很好地利用全局多维相关性以及样本自相似性进行插补。为了求解所提出的模型，该文遵循乘子交替方向法（ADMMs）原理，提出了一种复杂的求解算法。重要的是，通过分析问题结构，可以有效地实施ADMM中的每个步骤。此外，为了为模型选择合适的参数，该文提出一种基于对偶谐波生成策略的改进和谐搜索启发式算法，充分考虑当前和谐记忆中包含的信息。对两个真实世界的交通数据进行了实验，以评估所提出的方法。结果表明，与经典矩阵/张量补全算法和其他竞争算法相比，该方法显著提高了插补性能。 主要思想：使用加权SNN建模全局低秩结构，使用稀疏自表示来建模局部特性（周期性）。
2、TBTC（2023） 文献：Transforms-based Bayesian Tensor Completion Method for Network Traffic Measurement Data Recovery
期刊：IEEE Transactions on Network Science and Engineering
作者：Zecan Yang, Laurence T. Yang, Lingzhi Yi, Xianjun Deng, Chenlu Zhu, Yiheng Ruan
摘要：网络流量测量被视为下一代网络系统的基石。其目的是监控网络流量并为流量工程提供数据支持。因此，从全网角度监控流量数据尤为重要。然而，网络业务的激增导致了网络流量的爆发式增长，这给全网流量的衡量带来了重大挑战。因此，如何从部分流量数据推断全网流量极为重要。该文提出一种基于变换的贝叶斯张量补全（TBTC）方法来推断网络流量数据。首先，将缺少条目的异构网络流量数据根据时间维度和其他属性组织成观测张量;其次，利用稀疏层次先验诱导因子张量的侧切片稀疏性，使得观测张量的输卵管秩可以估计;进一步，提出了一种用于模型学习的变分贝叶斯推理方法，并提出了一种高效的更新方法。最后，在实验中实现了基于线性变换的张量完成模型的两种算例。在两个真实网络流量数据集上的实验结果验证了所提方法能够高效、准确地恢复网络流量数据。
主要思想：基于贝叶斯理论，将缺失张量表示为两个因子张量的余弦变换积/任意可逆线性变换的张量-张量积，然后用TNN进行优化求解。
余弦变换积：
任意可逆线性变换的张量-张量积
3、ManiRTD （2023） 文献：Manifold Regularized Tucker Decomposition Approach for Spatiotemporal Traffic Data Imputation
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04335399c8016e245650ae2d905157f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f009fd2f3bb78279104fd5ff2d57f18/" rel="bookmark">
			Android 13 以太网开发总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 13 以太网开发总结 前言 相较于Android12，Android13将以太网相关功能整合到ConnectivityService里，将以太网的核心源码从framework上移到packages/modules/Connectivity下，功能也做了相关更新。
一、具体变更 1、对于Android13以前的版本的方法做了限制，不允许Android13以上的版本使用。如设置以太网参数的方法和获取以太网参数的方法。
2、增加了以太网开关的方法setEthernetEnabled()。
3、新增了车机项目更新以太网参数的方法updateConfiguration()。
4、新增以太网状态变更通知机制。
二、合入mainline后以太网开发思路 1、由于合入mainline后，ConnectivityService会被替换，以前开发使用的在EthernetService里实现新接口的方法行不通了。 2、如何获取以太网状态变更： 以前是通过判断以太网节点eth0是否存在来判断以太网是否连接，在Android13上是行不通的。但是通过阅读源码发现，Android13版本的以太网帮你实现了以太网状态变更后通知的机制，当EthernetService处理完以太网插拔事件、网络配置更新事件、以太网开启关闭事件后会主动调用
InterfaceStateListener通知所有监听。
通过实现他的接口就可监听以太网状态的变更，可以监听到以太网的状态state、路由role、网络配置IpConfiguration 。
public interface InterfaceStateListener { /** * Called when an Ethernet interface changes state. * * @param iface the name of the interface. * @param state the current state of the interface, or {@link #STATE_ABSENT} if the * interface was removed. * @param role whether the interface is in client mode or server mode.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f009fd2f3bb78279104fd5ff2d57f18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0240675f118b13257796e5dff64c3f75/" rel="bookmark">
			QT QVerticalSpacer 弹簧控件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文详细的介绍了QVerticalSpacer控件的各种操作，例如：新建界面、控件布局、隐藏控件、设置宽高、添加布局、其它参数、.h源文件、cpp源文件、其它文章等等操作。
实际开发中，一个界面上可能包含十几个控件，手动调整它们的位置既费时又费力。布局管理器可以完成两件事：自动调整控件的位置，包括控件之间的间距、对齐等；当用户调整窗口大小时，位于布局管理器内的控件也会随之调整大小，从而保持整个界面的美观。
本系列QT全面详解文章目前共有二十六篇，本系列文章较为详细的讲述了QT控件的基础操作和使用，也谢谢大家的关注、点赞、收藏。
本文作者原创，转载请附上文章出处与本文链接。
QT QVerticalSpacer 弹簧控件目录
1 新建界面
2 控件布局
3 隐藏控件
4 设置宽高
5 添加布局
6 其它参数
7 .h源文件
8 .cpp源文件
9 其它文章
1 新建界面 2 控件布局 #include &lt;QHBoxLayout&gt; #include &lt;QVBoxLayout&gt; #include &lt;QPushButton&gt; QPushButton* pushButton; QPushButton* pushButton_2; QVBoxLayout* vBoxLayout_2; Title = "QT QVerticalSpacer CSDN 双子座断点 "; Version = "V 1.0 "; BlogText = "https://blog.csdn.net/qq_37529913?type=lately/"; setWindowTitle(Title + Version + BlogText); vBoxLayout_2 = new QVBoxLayout; pushButton = new QPushButton("QPushButton"); pushButton_2 = new QPushButton("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0240675f118b13257796e5dff64c3f75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd0e089ac28b3caec722631ffa57fc79/" rel="bookmark">
			javascript百炼成仙 第一章 掌握JavaScript基础01 初入宗门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前些天发现了一个巨牛的人工智能学习博客，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转
乐阳村，处于脚本大陆东部的边缘地带，民风淳朴，村民日出而作，日落而息。这一日清晨，所有村民来到村庄的门口，正在为一个十五六岁的少年送别。只见那少年虽然身体瘦弱，可是目中绽放出异彩，身躯虽不壮实，倒也挺拔。
“叶小凡，你是我们全村人的骄傲，百年来唯一一个具备修行JavaScript甲等资质的孩子！马上会有千鹤派的大人来接你，今后你一定要认真修行，给我们全村的人争光！”
他叫叶小凡，几天前通过了修行资质的检验，符合修行JavaScript的资质。
“千鹤派！”叶小凡眼前一亮，语气中伴随着激动，两眼放光。千鹤派，在脚本大陆，已是数一数二的大门派，每一个宗门弟子都能够修炼一种神奇的功法——JavaScript，修成之后，威力之大，足以翻山倒海，称霸一方天地！
不多时，天气风云变化，一道长虹降下，瞬间变为一人。他身穿一件玄青色玉锦衣服，腰间绑着一根白色蟠离纹革带，一头黑发如云发丝，有着一双清澈明亮的眼眸，身形颀长，当真是气宇轩昂温文尔雅。
“你就是叶小凡？”男子淡淡开口，神识一扫，惊讶地发现，此子的修行资质竟为甲等，眼中闪过一丝惊讶。
“在下林元青，千鹤派青山院掌尊，你既然通过了考核，具备修炼资质，即刻你随我上山，不得有误。”
叶小凡当下便告别众人，在林元青的术法之下，随即化为一道长虹飞天而去。留下了一脸震撼的村民。
千鹤派分为三个大院，分别为青山院，绿水院，以及神秘的玄冰院。每个院都有一个掌尊，那林元青，赫然便是青山院的掌尊！掌尊地位之高，仅次于大长老，大长老之上，又有太上长老。几乎只是两三个呼吸的时间，林元青已经带着叶小凡，来到了千鹤派。叶小凡两眼一花，仿佛上一刻还在村子口，下一刻就看到了千鹤派的阁楼。
“这里是？”叶小凡这一辈子都没有见过如此宏伟的建筑，忍不住开口。一想到今后可以在这里修行，更是兴奋。哈哈，我叶小凡今后一定能突破层层障碍，成就JavaScript一代大师！
“这里是千鹤派青山院。”林元青招来仆从，给叶小凡随意找了一个住处，又给了一卷功法，吩咐了几句，似乎还有其他要事，就立即化为一道长虹离去了。
叶小凡拿起功法一看，赫然写着“JavaScript基础修炼要诀”几个银光大字，眼中放出异彩，一想到村中父老乡亲那期盼的眼神，便下定决心，不混出个名头，绝不回去！
下一节：javascript百炼成仙 第一章 掌握JavaScript基础 1.2直接量
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56653609d7400100dd9b72ff662f85ee/" rel="bookmark">
			半监督语义分割论文学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Semi-Supervised Semantic Segmentation with Cross-Consistency Training 1.1 motivation 一致性训练的目的是在应用于输入的小扰动上增强模型预测的不变性。因此，学习的模型将对这样的小变化具有鲁棒性。一致性训练的有效性在很大程度上取决于数据分布的行为，即集群假设，其中类必须由低密度区域分隔。在语义分割中，在输入中，我们没有观察到低密度区域的存在，，而是在编码器的输出中，观察到了这种现象。基于这一观察，我们建议在应用于编码器输出的不同形式的扰动上加强一致性。
1.2 本文主要贡献 提出了一种用于半监督语义分割的交叉一致性训练（CCT）方法，其中预测的不变性在注入到编码器输出中的不同扰动上得到加强。
•作者建议并对各种类型的扰动进行详尽的研究。
•作者扩展了作者的方法，使用弱标记数据，并利用不同域的像素级标签来联合训练分割网络。
•作者通过广泛而详细的实验结果证明了作者方法的有效性，包括与最新技术的比较，以及通过详细的消融研究对作者方法的深入分析。
1.3 网络框架 整个网络大致分为上下两个分支，共包含一个encoder， 一个main decoder和 K 个辅助decoder。
有标签的(pixel-level labeled)数据由上分支处理，无标签的数据由上下两个分支共同处理。
对于有标签的数据，可以直接用交叉熵。
对于大量无标签的(unlabeled)数据，图片 xu 经过和上分支共享的encoder得到 z和main decoder，得到“参照”（main decoder的输出）。同时 z 分别经过K个扰动并进入对应的辅助decoder中，得到K个输出，这K个输出分别和main decoder的输出对比，并使用均方误差函数计算无监督损失 Lu。
Semi-Supervised Building Footprint Generation With Feature and Output Consistency Training 这篇文章的motivation以及一些观察非常nice~
2.1 introduction 最先进的基于一致性训练的方法利用了师生框架。具体而言，学生模型应用于未标记样本，而教师模型应用于同一样本的扰动版本。然后，在两个模型的输出之间施加一致性，以提高学生模型的性能。然而，当训练期间输出不完全正确时，这两种模型之间的性能仍存在一定差距。受特征图可以捕获更具歧视性的上下文信息的启发，作者通过提出一种新的一致性损失来进一步提高一致性训练的性能，该损失测量学生模型和教师模型的特征图和输出之间的差异。通过这样做，它可以提供一个强大的约束来规范网络的学习。
基于一致性训练的方法的有效性在很大程度上取决于数据分布的行为，即集群假设，其中类必须由低密度区域分隔。然而，分离类的低密度区域不在输入范围内，这解释了为什么半监督是语义分割的一个具有挑战性的问题，可以观察到，对于自然图像，在编码器的输出端存在分离类的低密度区域，因此建议在该位置分配扰动。然而，对于具有低空间分辨率的遥感图像，作者观察到分离类别的低密度区域的存在在编码器的中间特征表示中，而不是编码器的输入或输出中。（这个好棒！！从下图可以看出来，C作为编码器的输入，其实是不满足聚类假设的，d作为中间特征层可以看出满足聚类假设，e作为高级语义特征，也看不出满足聚类假设）受这一观察结果的启发，在这项工作中，作者建议在编码器内的某个深度对应用于特征表示的扰动进行一致性，其中该深度应与遥感图像的空间分辨率和研究区域内单个建筑物的平均尺寸一致。
这项工作有三方面的贡献。
1） 作者提出了一种用于建筑足迹生成的半监督网络，这在当前文献中尚未得到充分解决。当注释样本不足时，所提出的方法可以利用大量未标记的数据来提高模型的性能。
2） 作者提出的方法将特征和输出的一致性训练集成到统一的目标函数中，从而制定了一个有效的端到端训练框架。与其他竞争对手相比，作者的方法有了显著的改进。
3） 观察到分离类别的低密度区域位于编码器中的中间特征表示内，作者提出了一种指令，其中根据输入遥感图像的空间分辨率和研究区域中单个建筑物的平均大小，将扰动应用于编码器内某个深度处的特征表示。
2.2 网络架构 作者整体的网络架构还是很好理解的，首先是一个主分割网络，由encoder-decoder构成，对于有标签的数据，利用标签对其输出进行监督。这里用的是一个bootstrapped cross-entropy loss ，具体如下：
对于无标签影像，① 首先经过encoder生成，将输入到主分割网络的decoder中，得到，② 其次，如在introduction中提到的那样，对于遥感影像，其聚类假设体现在中间特征图中，因此，此处对中间特征图添加扰动得到（一般最多的是对输入扰动或者encoder的输出扰动，这里是对中间特征图扰动），将输入到encoder后续的网络中，最后得到encoder的输出，将这个输入到辅助decoder中，得到预测结果.
关于无标签的影像的损失设置分为两个部分，和，其中
3. Semi-supervised semantic segmentation needs strong, varied perturbations 这篇文章核心看了3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56653609d7400100dd9b72ff662f85ee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac36b1a745448e16a600be41e83d7e19/" rel="bookmark">
			XSS 与 CSRF 与 SQL注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、CSRF(跨站请求伪造) 跨站请求伪造(Cross-site request forgery)，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。
如：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
flask 模仿csrf攻击 与 保护:https://www.cnblogs.com/love2000/p/13678360.html
攻击原理及过程 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；
在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；
用户未退出网站A之前，在同一个浏览器中，打开一个Tab页访问网站B；
网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。
网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。
场景模拟 （1）场景一
假设你正在购物，看重了某个商品，商品 id 是 100 。
同时这个商品的付费接口时 xxx.com/pay?id=100，但是没有任何验证。
这个时候我是攻击者，我看中了一个商品，id 是 200 。
那么，我如何让你来为我付款？
这个时候我像你发送了一封邮件，邮件标题很是吸引人。
但邮件正文隐藏着 &lt;img src = "xxx.com/pay?id=200"&gt; 。
你一查看邮件，一点击，就帮我购买了 id 是 200 的商品。
（2）场景二
要完成一次 CSRF 攻击，受害者必须依次完成两个步骤：
登录受信任网站 A ，并在本地生成 Cookie 。 在不登出 A的情况下，访问危险网站 B 。
看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。
是的，确实如此，但是呢，你可能没办法保证以下情况不会发生哦！
比如：你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac36b1a745448e16a600be41e83d7e19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c1ab32ca52aa5aa7d72e81dea8d626/" rel="bookmark">
			各种好用的免费快递物流API 接口分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 全国快递物流查询：1.提供包括申通、顺丰、圆通、韵达、中通、汇通等600+快递公司在内的快递物流单号查询。2.与官网实时同步更新。3.自动识别快递公司。全国快递物流地图轨迹查询：【H5物流轨迹、单号识别】通过物流单号和收寄件地址，自动评估物流时效，并在地图中展示包裹运输轨迹。包括顺丰、圆通、申通等主流快递公司。自动识别快递公司及单号，实时查询，稳定高效，服务器毫秒响应，数据及时准确。跨境国际快递物流查询：支持900+物流商，提供实时查询和单号订阅API接口。稳定高效，为跨境电商平台、独立站、软件服务商提供优质服务。快递可达校验：根据收件地址和快递公司，结合当地疫情管控校验地址能否派送，减少商家因打印禁运地区的订单而造成的资损。物流时效性查询：预估从下单开始直到收到货物的时间，计算物流的时效性快递鸟（Kdniao）：支持国内外快递公司的查询。快递100：支持国内主流快递公司的查询。阿里云物流智能：支持国内外快递公司的查询。顺丰速运开放平台：可以查询顺丰速运的快递信息。快递魔方：支持多家国内外快递公司的查询。一米鲜快递查询：支持查询多家快递公司的信息。飞鸽快递查询：可以查询飞鸽快递的物流信息。全峰快递开放平台：可以查询全峰快递的物流信息。京东物流开放平台：可以查询京东物流的快递信息。 其他常用的API 推荐： IP归属地-IPv4区县级：根据IP地址查询归属地信息，包含43亿全量IPv4，支持到中国地区（不含港台地区）区县级别，含运营商数据。IP归属地-IPv6区县级：根据IP地址（IPv6版本）查询归属地信息，包含国家、省、市、区县和运营商等信息。IP应用场景-IPv4，IPv4应用场景是获取IP场景属性的在线调用接口，具备识别IP真人度，提升风控和反欺诈等业务能力。IP应用场景基于地理和网络特征的IP场景划分技术，将IP划分为含数据中心、交换中心、家庭宽带、CDN、云网络等共计18类应用场景。IP行业-IPv4，用于查询IP地址所属的行业类型。高达50余种行业，政府、军事、教育、交通、医疗、金融等，为用户分析提供帮助。IP代理识别，用于检查用户是否使用VPN、代理或Tor连接，覆盖全球全量IPv4。手机在网状态：支持传入三大运营商的号码，查询手机号在网状态，返回在网等多种状态。手机号码在网时长 ： 查询手机号码的在网时长查询，支持三网手机号，返回从开户到目前使用的时间范围，有助于精准营销和风险控制。手机号码归属地：可根据手机号码查询其省市区、运营商区号行政区划代码等信息。 上亿条数据囊括最新的170、166、147等号段，更新及时、准确度高。空号检测：通过手机号码查询其在网活跃度，返回包括空号、实号、停机、库无、沉默号、风险号等状态。手机号码归属地和运营商查询：中国手机号码归属地和运营商查询，为您提供最新的中国移动、中国电信、中国联通所有手机号码归属地等功能， 输入手机号码至少前7位，可查该手机号码归属地、所属号段、手机卡类型。空号检测：通过手机号码查询其在网活跃度，返回包括空号、停机等状态。反欺诈（羊毛盾）：反机器欺诈，检测异常IP、异常手机号。中英文敏感词过滤：敏感词库包含中英文，现在基本上所有的网站都需要设置敏感词过滤，似乎已经成了一个网站的标配。历史上的今天：看看历史上的今天，都发生了什么重大事件。查历史上的指定日期发生的事情，包括国家大事、国际大事、政府重要决策部署等图文详情内容。万年历：获取公历日期对应的农历、农历节日节气、天干地支纪年纪月纪日、生肖属相、宜忌、星座等信息。支持查询未来15天。中文繁简转换：输入想要转换简繁体的中文汉字，然即可将正体繁体字、中文简体字或QQ非主流繁体字转换翻译汉字繁简体周公解梦：周公解梦大全，周公解梦查询，免费周公解梦。将图片转换成漫画风格：会自动为你将照片转换成漫画风格，无须使用Photoshop 等图片编辑软件、无须任何技术基础。输入图片的url，即可得到漫画风格的图片。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6bf0003ab79ccfeb588dcca2f7ea7d6/" rel="bookmark">
			什么是西储大学数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		西储大学数据集（Wine Quality Dataset）是一个广泛用于机器学习和数据分析的开放数据集之一。该数据集是由西储大学（Case Western Reserve University）的一位研究者提供的。
该数据集包含了红葡萄酒和白葡萄酒的化学特征信息以及相应的质量评分。这些化学特征包括酸度、挥发性酸度、柠檬酸、残糖、氯化物、游离二氧化硫、总二氧化硫、密度、pH值、硫酸盐、酒精含量等。
数据集中的每个样本都有一个质量评分，评分范围从0到10。质量评分是基于专家品酒师对葡萄酒的感官评价而得出的。
这个数据集被广泛用于葡萄酒品质预测的机器学习任务。研究人员和数据科学家可以使用这个数据集来构建模型、预测葡萄酒的质量，或者进行特征分析和数据可视化。
需要注意的是，西储大学数据集存在两个版本，分别是红葡萄酒数据集和白葡萄酒数据集。这两个数据集在特征和样本数量上略有不同，但都可以用于类似的任务和分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf965513cda435d1ae623abb5c9fd865/" rel="bookmark">
			React封装Modal组件(小demo)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		React封装Modal组件(小demo) 原理 利用ReactDOM.createPortal([children_Dom],[father_Dom])api动态添加Modal弹框到body中
源码 import React, { useEffect, useState } from "react" import ReactDOM from "react-dom" import './index.scss' const Modal = (props) =&gt; { // 第一次渲染dom 走生命周期 还会在渲染拿值 // console.log(props, 1114) const [target, setTarget] = useState(null) // console.log(target, 1111, target) useEffect(() =&gt; { setTarget(document.querySelector('body')) // 选择你要添加的目标dom }, []) useEffect(() =&gt; { // console.log("show change", props.show) }, [props.show]) if (!props.show) return null // false 就返回null const close = () =&gt; { console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf965513cda435d1ae623abb5c9fd865/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8a1fe4a4445b8204014bd7a4b093f711/" rel="bookmark">
			【信号调制】使用不同的分类器（逻辑回归分类器、决策树、随机森林、全连接密集层和CNN）来训练模型，以预测不同信噪比值下信号的调制类型（Python代码实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		👨‍🎓个人主页：研学社的博客 💥💥💞💞欢迎来到本博客❤️❤️💥💥
🏆博主优势：🌞🌞🌞博客内容尽量做到思维缜密，逻辑清晰，为了方便读者。
⛳️座右铭：行百里者，半于九十。
📋📋📋本文目录如下：🎁🎁🎁
目录
💥1 概述
📚2 运行结果
​
🎉3 参考文献
🌈4 Python代码实现
💥1 概述 使用不同的分类器（逻辑回归分类器、决策树、随机森林、全连接密集层和CNN）来训练我们的模型，以预测不同信噪比值下信号的调制类型。
📚2 运行结果 x_pts = [] for i in range(-20,20, 2): x_pts.append(i) x_pts = np.array(x_pts) plt.plot(x_pts, tree_accuracy) plt.plot(x_pts, logistic_reg_accuracy) plt.plot(x_pts, forest_accuracy) plt.plot(x_pts, dnn_accuracy) plt.plot(x_pts, cnn_accuracy) plt.grid(True) plt.title('Accuracies of {}'.format(type)) plt.xlabel('SNR') plt.ylabel('Accuracy') plt.legend(['decision tree', 'logistice regression', 'random forest', 'DNN','CNN'], loc='upper left') plt.show() at SNR: -20 Accuracy: 0.10116666666666667
at SNR: -18 Accuracy: 0.10416666666666667
at SNR: -16 Accuracy: 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8a1fe4a4445b8204014bd7a4b093f711/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2863a90f4c07748c94785709e12e1a36/" rel="bookmark">
			Vue 中 watch(监听属性) 和 computed(计算属性) 的对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue 中的监听属性 watch 和计算属性 computed 都有监听的作用，但具体的适用场景和方法是由区别的
computed computed 相当于定义一个变量，这个变量接收其后函数的返回值，函数里面的属性值经过计算返回给函数前面的变量，当函数里面的属性发生变化的时候，就会触发这个函数进行计算，更新computed 定义的变量，并将计算后的结果进行缓存，在函数里面的属性没有发生变化的情况下，都会调用缓存中的数据。
compute中定义的变量都是新的变量，这个变量可以直接在代码中进行使用，而不是在props/data中进行定义，更注重的是计算而得的变量。
计算属性(computed)不能进行异步操作因为计算属性(computed)是通过return返回值传递参数 异步操作的时候return是没有意义的。
computed 的方法里面的属性值发生变化，触发计算函数，并将计算结果进行缓存，在返回给变量，和watch的顺序刚好是相反的。
import { computed, defineComponent } from 'vue' export default defineComponent({ setup({ const name = ref&lt;any&gt;('') const ristName = ref&lt;any&gt;('') const lastName= ref&lt;any&gt;('') // 添加watch监听 name.value = computed(() =&gt; { // fristName 或者 lastName变化触发方法，重新计算，从而改变name的值 return fristName + lastName }) return { name, ristName, lastName } }) }) 适用环境：一个数据受多个数据影响的场景。
watch watch像是一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个 property。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2863a90f4c07748c94785709e12e1a36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e2445b4f23415bc8aae9d93997e3fb0/" rel="bookmark">
			go语言操作MySql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 go语言操作MySql1.1引入相关依赖1.2使用MySql驱动1.3测试MySql连接1.4CRUD1.4.1创建数据库1.4.2创建表1.4.3插入数据1.4.4查询数据1.4.5更新数据1.4.6删除数据 1.5完整代码示例1.6MySql事务1.6.1什么是事务1.6.2事务的特性1.6.3事务的方法1.6.4简单实现 go语言操作MySql 1.1引入相关依赖 import ( "database/sql" _ "github.com/go-sql-driver/mysql" ) 1.2使用MySql驱动 package main import "database/sql" func main() { dsn := "username:password@tcp(localhost:3306)/database_namecharset=utf8mb4" // 不会校验账号密码是否正确 // 注意！！！这里不要使用:=，我们是给全局变量赋值，然后在main函数中使用全局变量db db, err := sql.Open("mysql", dsn) if err != nil { return } // 尝试与数据库建立连接（校验dsn是否正确） err = db.Ping() if err != nil { return } defer db.Close() } 注意：username、password 和 database_name 替换为你的实际数据库用户名、密码和要创建的数据库名称。`
1.3测试MySql连接 package main import ( "database/sql" "fmt" "log" ) func main() { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e2445b4f23415bc8aae9d93997e3fb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8b820e77318d8628659ff80d1e58693/" rel="bookmark">
			TrueNAS配置虚拟机网卡
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TrueNAS支持运行虚拟机，但会出现虚拟机可以访问外网，却不能和主机的TrueNAS通讯。
这时，需要重新配置TrueNAS的网卡设置。
1. 原来的主机网卡配置
我的这台TrueNAS主机有两个以太网卡，目前使用的是enp4s0，IP地址192.168.31.200/24
2. 原来的虚拟机openwrt网卡配置
3. 修改主机网卡配置
1）编辑enp4s0，把该网卡的静态IP删除
2）新建一个桥接网卡
新建的桥接网卡名称必须叫做brX，X是一个随意的数字，并且要增加一个alias别名，实际就是IP地址。我把IP设置成了跟原来enp4s0一样的IP地址192.168.31.200/24
3）测试 &amp; 保存
做了以上设置之后，在网络的页面就会出现test change，先test change，然后刷新一下页面，再save change。需要注意的是，1）和2）两个步骤做完之后，才能test change，不能设完一个就test一次。
4. 修改虚拟机网卡配置
把虚拟机网卡的设置NIC to Attach改为brX即可。这样，只要虚拟机中的IP地址和HOST中IP地址是同一网段，即可互相ping通。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/552c865c63811c12a32ea34d70106ebc/" rel="bookmark">
			The connection to the server xx:6443 was refused - did you specify the right host or port?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天打开数据库的时候发现无法连接，然后发现kubectl无法使用。kubelet服务是正常运行的。
尝试重启Docker服务。重启失败。
[root@liufeifei ~]# systemctl restart docker
Job for docker.service failed because the control process exited with error code. See “systemctl status docker.service” and “journalctl -xe” for details.
根据提示，执行以下命令：journalctl -xe
imjournal: fclose() failed for path: ‘/var/lib/rsyslog/imjournal.state.tmp’: No space left on device [v8.24.0-5
执行top命令，再输入大写M，按照内存排序。rsyslogd占用了23.1%的内存。
systemctl status rsyslog
查询rsyslog服务的运行状态。
我将/var/log/journal路径下的文件夹都删除掉。
重启rsyslog服务。
重启docker服务，正常运行。kubectl服务恢复，数据库连接恢复。
参考：
rsyslog 占用内存高解决方法
解决rsyslog服务占用内存过高
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be0afb8c9c497026ffe356ea19b837e0/" rel="bookmark">
			umijs
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、umijs二、项目创建三、(内置)less和antd四、路由搭建配置式路由：约定式路由： 五、路由跳转及参数传递路由参数获取路由权限 六、网络请求内置umi-request模块axios发送请求 七、数据管理内置 [dva](http://dvajs.com/)搭建异步请求数据 effects 一、umijs umijs：开发文档：
umi=react+less+antd(实现按需加载)+umi-request+dva（react+redux-saga）
二、项目创建 (1)先在本地创建项目名字
mkdir myapp &amp;&amp; cd myapp (2)执行创建
$ yarn create @umijs/umi-app # 或 npx @umijs/create-umi-app (3)下载依赖
yarn install (4)启动项目
yarn start 三、(内置)less和antd umijs内置了less和antd，无需再配置相关环境，直接使用就行
import s from './index.less'; import {Button} from "antd"; export default function IndexPage() { return ( &lt;div&gt; &lt;h1 className={s.title}&gt;Page index&lt;/h1&gt; &lt;Button type='default'&gt;按钮&lt;/Button&gt; &lt;/div&gt; ); 配置主题色，只需要指定颜色就可以了,umirc.ts文件可以完成所有配置项
// umirc.ts import { defineConfig } from 'umi'; export default defineConfig({ .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be0afb8c9c497026ffe356ea19b837e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5b2ac6aae979d0c2fa0647bc5b8683b/" rel="bookmark">
			C&#43;&#43;初阶 — vector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、vector的介绍及使用
1. vector的介绍
2. vector的使用
2.1 vector的定义
2.2 vector iterator 的使用 2.3 vector 空间增长问题 2.3 vector 增删查改
二、vector（简易）的模拟实现以及会出现的问题
1. vector的核心框架
2. 构造函数，push_back和reserve
3.迭代器和下标访问[ ]
4. pop_back和empty
5. resize
6. insert
7. erase
8. swap 和析构函数
9. 构造函数多种使用场景
10. 拷贝构造和赋值重载
一、vector的介绍及使用 1. vector的介绍 1. vector是表示可变大小数组的序列容器。
2. 就像数组一样，vector也采用的连续存储空间来存储元素。也就是意味着可以采用下标对vector的元素 进行访问，和数组一样高效。但是又不像数组，它的大小是可以动态改变的，而且它的大小会被容器自 动处理。
3. 本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小 为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是 一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大 小。
4. vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存 储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是 对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。
5. 因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增 长。
6. 与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末 尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list 统一的迭代器和引用更好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5b2ac6aae979d0c2fa0647bc5b8683b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edbe69ade5803b7e29b993fbea63364f/" rel="bookmark">
			OpenWrt 软路由解析公网IPV6域名访问家庭NAS的问题答疑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、非要使用 Padavan 或者 OpenWrt固件的软路由才能IPV6公网访问吗？
答：这个并不是这样的，一般家用路由器都无法放行防火墙规则，这种情况当然无法实现IPV6公网访问，但是少部分路由器是可以的，只要有防火墙设置功能基本都可以，再打开路由器的端口映射，DZM，UPNP这些就可以了，如果你要实现IPV6公网访问的话，一般给你的NAS开DZM主机就可以了，不需要你做其余的端口映射，UPNP等操作。
2、什么是端口映射
答：端口映射就是将内网中的主机的一个端口映射到外网主机的一个端口，提供相应的服务。当用户访问外网IP的这个端口时，服务器自动将请求映射到对应局域网内部的机器上。
3、什么是DZM主机
DMZ是英文“demilltarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”它是为解决安装防火墙后外部网络不能访问内部网络服务器的问题， 而设立的一个非安全系统与安全系统之间的缓冲区，这个缓冲区位于企业内部网络和外网网络之间的小网络区域内，在这个小网络区域内可以放置一些必须公开的服务器设施，如企业WEB服务器、FTP服务器和论坛等，另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络，因为这种网络部署，比起一般的防火墙方案，对攻击者来说又多了一道关卡。
4、什么是UPNP
UPNP开启后能方便智能监控设备直接透传到因特网，无需做烦琐的映射端口设置，UPNP开启后能方便智能网络存储设备与因特网进行数据传输，节省手动设置时间，路由器UPnP功能用于实现局域网计算机和智能移动设备，通过网络自动彼此对等连接，而且连接过程无需用户的参与。不建议普通用户开启路由器UPnP功能，开启后发热量会增加，对路由器寿命有不利影响。
5、我的路由器可以刷Padavan 或者 OpenWrt固件吗？
答：并不是任何路由器都是可以刷这些固件系统的，刷Padavan 或者 OpenWrt需要路由器一些条件达到要求，并且有适配该设备的Padavan或OpenWrt固件才行，具体的大家可以去“恩山无线论坛”哪里有很多的此类固件。
6、群晖NAS可以使用Padavan或OpenWrt软路由IPV6公网访问吗？
答：当然可以的，教程大同小异，如果您参考以上的教程基本都可以实现，但是大多数都会卡在路由器上面，搞定路由器就没啥问题了。
7、威联通NAS可以使用Padavan或OpenWrt软路由IPV6公网访问吗？
答：当然可以的，教程大同小异，如果您参考以上的教程基本都可以实现，但是大多数都会卡在路由器上面，搞定路由器就没啥问题了。
8、什么叫黑群晖？
答：黑群晖的意思就是利用家用淘汰的电脑，笔记本电脑或者自己购买机箱配件来安装群晖NAS系统，都可以实现公网IPV6访问​。
群晖科技操作系统 DiskStation Manager 简称(DSM)，DSM 是基於 Linux 开发的, Linux 是一套免费使用和自由传播的类 Unix 操作系统，不是购买了群晖的 NAS 而是在普通电脑上装群晖 nas 的系统就叫”黑群晖”。
9、什么叫白群晖？
答：就是购买群晖官方正版，不过官方正版卖的设备虽然带正版白群系统，其设备性能太低，还是建议使用组装机，淘汰的台式机来做，当然了要注意把握组装机的功耗。
还有就是黑群晖系统怎么安装，系统文件在哪里下载，后面有时间再给大家做个教程出来，目前各位只能百度搜索参考学习了​。
10、阿成使用的什么配置黑群晖​？
答：目前学长使用的是自己买硬件来组装的黑群晖设备，自己安装的黑群晖系统，下面便是学长的NAS设备。
以下是配置情况
机箱：买的拓普龙NAS8，8盘位机箱，该机箱最大支持24×24的主板
处理器​：E3-1240L V5 低功耗25W 无集成显，黑群晖不需要显卡
主板：X150 或 ​ C232 芯片组的主板
内存：ddr4 2666 8G 买酷兽光威这些都可以
硬盘：60G的SSD，PDD上面25块钱，60G群晖系统盘够了 + 5个4T的机械硬盘
显卡：黑群晖不需要显卡
电源：益横250W金牌小1U，买益横，海韵这些都可以
CPU散热器：买不高于65cm的
延长线：需要买主板和CPU延长线各一条
PCIE转SATA卡：由于主板只有6个SATA，而我们有8个硬盘位，买个PCIE转SATA卡4口的足够用了，免驱动，即插即用
网卡​：主板只有一个千兆网卡，不够用的可以买个PCIE转网卡插上去，学长买的双网卡万兆电口浪潮网卡，70左右，免驱动即插即用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/edbe69ade5803b7e29b993fbea63364f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbfc0cc293f96c0b4afb8710f22b3123/" rel="bookmark">
			Golang Channel 实现原理与源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Do not communicate by sharing memory; instead, share memory by communicating.
通过通信来共享内存，而不是共享内存来通信
安全访问共享变量是并发编程的一个难点，在 Golang 语言中，倡导通过通信共享内存，实际上就是使用 channel 传递共享变量，在任何给定时间，只有一个 goroutine 可以访问该变量的值，从而避免发生数据竞争。
本文关键是对Channel 实现原理进行分析，并附带源码解读，基于源码分析能更加理解Channel实现的过程与原因，对于源码关键步骤及变量给出了注释，不需要完全读懂源码的每个变量及函数，但可以从代码的异常处理角度来理解Channel，就能明白为什么channel的创建、写入、读取、关闭等流程需要分为多种情况。
1.Channel 数据结构 1.1 hchan结构体 读 channel 的源码，可以发现 channel 的数据结构是 hchan 结构体，包含以下字段，每个字段的含义已注释：
type hchan struct { qcount uint // 当前 channel 中存在多少个元素； dataqsiz uint // 当前 channel 能存放的元素容量； buf unsafe.Pointer // channel 中用于存放元素的环形缓冲区； elemsize uint16 //channel 元素类型的大小； closed uint32	//标识 channel 是否关闭； elemtype *_type // channel 元素类型； sendx uint // 发送元素进入环形缓冲区的 index； recvx uint // 接收元素所处的环形缓冲区的 index； recvq waitq // 因接收而陷入阻塞的协程队列； sendq waitq // 因发送而陷入阻塞的协程队列； lock mutex	//互斥锁，保证同一时间只有一个协程读写 channel } 通过阅读 channel 的数据结构，可以发现 channel 是使用环形队列作为 channel 的缓冲区，datasize 环形队列的长度是在创建 channel 时指定的，通过 sendx 和 recvx 两个字段分别表示环形队列的队尾和队首，其中，sendx 表示数据写入的位置，recvx 表示数据读取的位置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbfc0cc293f96c0b4afb8710f22b3123/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/141/">«</a>
	<span class="pagination__item pagination__item--current">142/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/143/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>