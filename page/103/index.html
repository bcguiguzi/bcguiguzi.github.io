<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e170c3bdb3d074c1bca403198fcea5f9/" rel="bookmark">
			QRCode.js 生成二维码插件(vue2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 npm 或者 引入
npm install --save qrcode 或
&lt;script src="qrcode.js"&gt;&lt;/script&gt; 2. 引入
import QRCode from 'qrcodejs2' // 引入qrcode 3.页面
&lt;div id="qrcode"&gt;&lt;/div&gt; 4.调用传内容
// ts中报QRCode未声明的错可以这样声明： declare var QRCode: any; function makeQRCode(qrCodeContent){ var qrcode = new QRCode("test", { text: qrCodeContent, // 二维码内容 width: 128, height: 128, colorDark : "#000000", // 码的颜色 colorLight : "#ffffff", // 码的背景色 correctLevel : QRCode.CorrectLevel.H // 高度容错 }); // qrcode.clear(); // 可以清除二维码 // qrcode.makeCode("二维码的内容"); // 生成另外一个二维码 } 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e170c3bdb3d074c1bca403198fcea5f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5010bcf7c1ec8dac501714ba8bedb30f/" rel="bookmark">
			yolo格式转labelme格式并验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		yolo格式转labelme格式python to_json.py yolo标签路径 labelme标签路径 import os, sys, json, shutil import cv2 from glob import glob import numpy as np classes=['white', 'yellow', 'black'] def func(labels, w, h, jp): dic={} dic['version'] = '5.0.1' dic['flags'] = {} dic['imageData'] = None dic['imagePath'] = jp dic['imageHeight'] = h dic['imageWidth'] = w dic['shapes'] = [] if labels is not None: for l in labels: tmp = {} tmp['label'] = classes[l[0]] tmp['points'] =[[str(l[1]), str(l[2])], [str(l[3]), str(l[4])]] tmp['group_id']= None tmp['shape_type'] = 'rectangle' tmp['flags'] = {} dic['shapes'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5010bcf7c1ec8dac501714ba8bedb30f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42b566f6c355e777c4d8e17bc19d71e0/" rel="bookmark">
			图像处理（YOJ2.0中的题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目如上（至于YOJ2.0，那是我学校的做题网站）
先说一下感受吧：真的是爽死了，不过因为有提前打草稿（电纸书神！），所以中间的思路完全没出错，有什么错的话，也只有在输入上有问题。写了一个小时多，真的爽，希望以后能秒了
因为我有写注释，就不写解题思路了，核心就是一开始设置的两个数组，一个记录各点的数据，另一个记录坏点坐标（实际上你看名称也可以看得懂）
代码如下：
#include&lt;stdio.h&gt; #include&lt;math.h&gt; int main(void) { int m, n; scanf("%d%d", &amp;n, &amp;m); int data[n][m][4];//三个记数据，一个是否 int dead_pixel[m * n][3];//两个记坐标，一个是否 int num_of_dead_pixel = 0; //对数据预处理 for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { //输入 getchar(); getchar(); scanf("%d", &amp;data[i][j][0]); getchar(); getchar(); getchar(); scanf("%d", &amp;data[i][j][1]); getchar(); getchar(); getchar(); scanf("%d", &amp;data[i][j][2]); getchar(); //处理 if(data[i][j][0] + data[i][j][1] + data[i][j][2] == 0) { data[i][j][3] = 1; dead_pixel[num_of_dead_pixel][0] = i; dead_pixel[num_of_dead_pixel][1] = j; dead_pixel[num_of_dead_pixel][2] = 1; num_of_dead_pixel++; } else data[i][j][3] = 0; } } //开始修复 int num = num_of_dead_pixel; while(num) { for(int i = 0; i &lt; num_of_dead_pixel; i++) { if(dead_pixel[i][2]) { //相加 int all_R = 0, all_G = 0, all_B = 0;//计算上下左右的总和 double num_tmp = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42b566f6c355e777c4d8e17bc19d71e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec380c56b58944ae4c2e41e6bf205d5f/" rel="bookmark">
			基于LangChain的LLM应用开发3——记忆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		此情可待成追忆，只是当时已惘然。我们人类会有很多或美好或痛苦的回忆，有的回忆会渐渐模糊，有的回忆午夜梦醒，会浮上心头。
然而现在的大语言模型都是没有记忆的，都是无状态的，大语言模型自身不会记住和你对话之间的历史消息。根本用不着“时时勤拂拭”，天然就是“本来无一物”。每一次的请求交互、api调用都是独立的，完全没有关联。那些聊天机器人看起来有记忆，是因为借助代码的帮助，提供历史消息作为和LLM对话的上下文。嗯，就跟我们大脑不太够用了，要拿小本本或者打开Obsidian/Notion/语雀……来查找一样。（你去拜访某些单位，还可以看到前台拿着一本已经翻到包浆的小本子来查电话。）
所以，现在的大语言模型，就跟福尔摩斯一样，可能作为推理引擎更加好用：只要提供足够的上下文信息，那么即使坐在家中，也比愚蠢的苏格兰警探更清楚案情。（可以考虑打造一个叫“夏洛克”的大语言模型？ ）运筹帷幄之中，决胜千里之外。
本节我们就来看一下LangChain提供的4种Memory（记忆）组件（Vector data memory和Entity memory不展开），每种组件都有其适用场景。
主要的记忆组件 ConversationBufferMemory 这个记忆组件允许储存对话的消息，并且可以把消息抽取到一个变量。
ConversationBufferWindowMemory 这个记忆会保持K轮对话的列表。只保存最近的K轮对话。旧对话会清除。
ConversationTokenBufferMemory 这个记忆组件跟ConversationBufferWindowMemory差不多，同样把旧对话清除，只是是按Token的长度限制。
ConversationSummaryMemory 这个记忆组件会调用大语言模型，对旧的会话进行总结。
Vector data memory 这个组件把文本（来自会话或者其他地方的）保存到向量数据库，检索最相关的文本块。
Entity memories 调用LLM，记住关于特定实体的细节信息。
可以同时使用多个记忆组件，如调用会话记忆+实体记忆来检索个人信息。还可以将会话内容保存到传统数据库（如键值存储Redis或者关系数据库mysql等等），应用要落地这个是必不可少的。
下面来具体看每个组件的例子。
同样是先通过.env文件初始化环境，具体操作参考上一篇。
import os from dotenv import load_dotenv, find_dotenv _ = load_dotenv(find_dotenv()) # read local .env file import warnings warnings.filterwarnings('ignore') deployment = "gpt-35-turbo" model = "gpt-3.5-turbo" ConversationBufferMemory # from langchain.chat_models import ChatOpenAI from langchain.chat_models import AzureChatOpenAI from langchain.chains import ConversationChain from langchain.memory import ConversationBufferMemory llm = AzureChatOpenAI(temperature=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec380c56b58944ae4c2e41e6bf205d5f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70cc8565668ed94e408fabcca7c1fbc4/" rel="bookmark">
			GO学习之 数据库(mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GO系列 1、GO学习之Hello World
2、GO学习之入门语法
3、GO学习之切片操作
4、GO学习之 Map 操作
5、GO学习之 结构体 操作
6、GO学习之 通道(Channel)
7、GO学习之 多线程(goroutine)
8、GO学习之 函数(Function)
9、GO学习之 接口(Interface)
10、GO学习之 网络通信(Net/Http)
11、GO学习之 微框架(Gin)
12、GO学习之 数据库(mysql)
13、GO学习之 数据库(Redis)
14、GO学习之 搜索引擎(ElasticSearch)
15、GO学习之 消息队列(Kafka)
16、GO学习之 远程过程调用(RPC)
17、GO学习之 goroutine的调度原理
文章目录 GO系列前言一、简介二、准备操作三、Insert 操作四、Delete 操作五、Update 操作5.1 获取数据库链接5.2 更新操作 六、Select 操作五、事务六、总结 前言 按照公司目前的任务，go 学习是必经之路了，虽然行业卷，不过技多不压身，依旧努力！！！
数据持久化是必不可少的一部分，平日里开发，如果是专注于业务开发，那 99% 的工作也就是CRUD（增删改查）工程师了。
废话不多说，说了也没用，直接上手来操作，对数据库进行访问。
一、简介 对数据库操作，少不了各个语言对数据库操作的驱动，就像 JAVA 中有 mysql-driver 的驱动包，拉取下来就可以通过JDBC 对数据库操作了，当然 Spring、Mybatis 等框架也提供了对数据库很方便的操作。
那在 Go 中也是提供了驱动 github.com/go-sql-driver/mysql,我们通过 go get 拉取驱动来进行CRUD操作。
使用命令：go get github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70cc8565668ed94e408fabcca7c1fbc4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d263a66d9b6c5210e89c2ab748004a6/" rel="bookmark">
			PTrade财务数据获取函数的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前文介绍了PTrade的get_fundamentals函数，可以用于获取股票的财务数据。但在实际应用中，会遇到如下的问题。
前文我们通过将回测时间设置为2023-05-05进行回测调用get_fundamentals，得到如下查询结果：
secu_codepubl_dateend_dateoperating_revenue_grow_ratenet_profit_grow_ratesecu_abbr600900.SS2023-04-282023-03-3125.165718.0351长江电力601877.SS2023-04-292023-03-3147.3708132.9152正泰电器 可以看到长江电力的财报公告时间是2023-04-28，正泰电器的财报公告时间是2023-04-29。如果我们把回测时间调整为2023-04-20，查询的结果如下所示：
2023-04-20 08:30:00 - INFO - publ_date net_profit_grow_rate secu_abbr end_date \ secu_code 600900.SS NaN NaN NaN NaN 601877.SS NaN NaN NaN NaN operating_revenue_grow_rate secu_code 600900.SS NaN 601877.SS NaN 可以看到此时返回的结果为空。
我们调整回测时间发现，从2023-01-03开始到股票的2023年第一季度报告发布，get_fundamentals返回的数据均未空。当回测时间调整为2022-12-30时，查询的结果如下所示：
2022-12-30 08:30:00 - INFO - end_date net_profit_grow_rate operating_revenue_grow_rate \ secu_code 600900.SS 2022-09-30 -2.5688 2.0303 601877.SS 2022-09-30 21.2604 21.7318 publ_date secu_abbr secu_code 600900.SS 2022-10-31 长江电力 601877.SS 2022-10-29 正泰电器 对输出做一下整理：
secu_codepubl_dateend_dateoperating_revenue_grow_ratenet_profit_grow_ratesecu_abbr600900.SS2022-10-312022-09-30-2.56882.0303长江电力601877.SS2022-10-292022-09-3021.260421.7318正泰电器 可见，长江电力在2022-10-31发布的第三季度报，正泰电器在2022-10-29发布的第三季度报。
归纳总结一下，在调用get_fundamentals函数，且参数date设置为当前交易日时，查询返回的结果为上一季度的财务数据。
如果我们的需求是，查询最新的财务数据，那就需要对get_fundamentals进行改造，下一篇文章将进行具体介绍。
博客内容只用于交流学习，不构成投资建议，盈亏自负！
个人博客：http://coderx.com.cn/（优先更新）
项目最新代码：https://gitee.com/sl/quant_from_scratch
欢迎大家转发、留言。有微信群用于学习交流，感兴趣的读者请扫码加微信！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d263a66d9b6c5210e89c2ab748004a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c1f0155134b08121d382ca1a973374c/" rel="bookmark">
			英语写作中“一致的”、“相似的”、“相等的”identical similar equal等的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、identical 用于表示信息、内容等的一致性——完全一样，例如：
The messages they received were identical.（他们收到的信息完全一致。）
If the password you enter isn’t identical to one you register, you can’t pass authentication of your legitimacy.（如果你输入的口令与注册的口令不一致，你就不能通过合法性认证。）
The adversary forged a signature identical to the authentic one.（那个敌手伪造了一个和真实签名完全一样的签名。）
注意，identical 不能形容数、值。但是我们会见到：an identical number ，这里number 是数码、编号的意思，例如：
The number of this room is identical to that of next one.（这个房间的编号与隔壁房间完全一样。）
The original code and complement of a positive integer are identical.（正整数的原码和补码是一样的。）
二、equal 表示值、数的相等，这个用法很简单，不再举例。
三、similar 既可以表示信息、内容等的相似，也可以表示值、数的相似（接近、近似，与approximate 同义）。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c1f0155134b08121d382ca1a973374c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/371b15f11383c0171225c08012bfb8f1/" rel="bookmark">
			解决：ValueError: Unsupported ONNX opset version: 15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决在使用segment-anything项目，转onnx模型时的ValueError错误 在使用segment-anything时，想将pth模型转成onnx方便使用，但是总是报错，类似下面这种：
“File “/root/anaconda3/envs/s_samLabel/lib/python3.8/site-packages/torch/onnx/symbolic_helper.py”, line 748, in _set_opset_version
raise ValueError("Unsupported ONNX opset version: " + str(opset_version))
ValueError: Unsupported ONNX opset version: 17”
整了很久，应该还是版本的问题，用的python3.8+pytorch1.8+onnx==1.14.1+onnxruntime==1.16.1始终会报这个错误。
后来的解决办法是：
使用 python3.9.16 + torch==2.0.1 + onnx==1.14.1、onnxruntime==1.16.1
然后就转换成功了，所以用比较新的项目还是用比较新的版本吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a87ac576ba1a24b1d4d8b3e753c7bb/" rel="bookmark">
			UVM 验证方法学之interface学习系列文章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列文章，针对 interface 做了较全面的剖析，并结合实际工作中遇到的一些问题，以简单的例子形式，展示给读者，方便读者自行下载和修改，加深对interface的理解。文章中的例子，几乎涵盖了interface所涉及的常用用法，均取之于本人的多年工作经验收录。
由于本人能力有限，如有解析不当之处，敬请谅解，请评论处评论，我们共同学习共同进步。
UVM 验证方法学之interface学习系列文章（一）基础夯实https://mp.csdn.net/editor/html/116194886 UVM 验证方法学之interface学习系列文章（二）千奇百态https://mp.csdn.net/editor/html/116851731 UVM 验证方法学之interface学习系列文章（三）《类参数化的interface》https://blog.csdn.net/qq_16423857/article/details/116981797 UVM 验证方法学之interface学习系列文章（四）《interface 与VIP/UVC》https://blog.csdn.net/qq_16423857/article/details/117028972 UVM 验证方法学之interface学习系列文章（五）《interface backdoor 后门访问》https://blog.csdn.net/qq_16423857/article/details/117029015 UVM 验证方法学之interface学习系列文章（六）《interface 作探针》https://blog.csdn.net/qq_16423857/article/details/117029052 UVM 验证方法学之interface学习系列文章（七）《bind 操作（1）》https://blog.csdn.net/qq_16423857/article/details/117065529 UVM 验证方法学之interface学习系列文章（七）《bind 操作（2）》https://blog.csdn.net/qq_16423857/article/details/122588645 UVM 验证方法学之interface学习系列文章（七）《bind 操作（3）》https://mp.csdn.net/mp_blog/creation/editor/130686944
UVM 验证方法学之interface学习系列文章（八）《interface不小心引入X态问题》https://blog.csdn.net/qq_16423857/article/details/133959874
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09254788d2c08681c3b98c0835021197/" rel="bookmark">
			HTML 表格 表单的制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格 了解表格的作用掌握表格的编写 概述 表格是一种二维结构，横行纵列。
表格由单元格组成。
表格是一种非常“强” 的结构：
每一行有相同的列数（单元格），每一列有相同的行数（单元格）同一列的单元格，宽度（以最大的为准）相同，同列等宽；同行等高。 相关标签 table 标签 定义了表格框架。可以使用border 属性指定表格的边框宽度。可以使用width 属性指定表格的宽度，单位是px。可以使用height 属性指定表格的高度，单位是px。 tr 标签 定义了表格行。表格中有多少行，就需要写多少个&lt;tr&gt; 标签。 td 标签 定义了单元格。每一行中有多少个单元格，就需要些多少个&lt;td&gt; 标签。单元格的宽度，默认情况下与内容的宽度相同。默认情况下，单元格中内容都是左对齐的，可以使用text-align 来控制内容对齐方式。 绘制表格 基本表格 完整代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;3*3 基本表格&lt;/h1&gt; &lt;table border = 2&gt; &lt;tr&gt; &lt;td&gt;(1,1)&lt;/td&gt; &lt;td&gt;(1,2)&lt;/td&gt; &lt;td&gt;(1,3)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;(2,1)&lt;/td&gt; &lt;td&gt;(2,2)&lt;/td&gt; &lt;td&gt;(2,3)&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;(3,1)&lt;/td&gt; &lt;td&gt;(3,2)&lt;/td&gt; &lt;td&gt;(3,3)&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 跨行表格 完整代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09254788d2c08681c3b98c0835021197/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c1b53f768bef99a9c7824c4c736f15/" rel="bookmark">
			4 OpenCV实现多目三维重建（多张图片增量式生成稀疏点云）【附源码】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文是基于 OpenCV4.80 进行的，关于环境的配置可能之后会单独说，先提一嘴 vcpkg 真好用
1 大致流程 从多张图片逐步生成稀疏点云，这个过程通常包括以下步骤：
初始重建：
初始两张图片的选择十分重要，这是整个流程的基础，后续的增图都是在这两张图片的基础上进行的
对于输入图像，首先需要提取特征点（例如，SIFT、SURF或ORB特征点）。然后，通过匹配不同图像中的特征点，建立它们之间的对应关系通过两张图像之间的本质矩阵 E 估计相机的外参矩阵（旋转矩阵 R 和平移向量 T ），然后使用三角测量法计算出一些初始的三维点 具体操作可以查看我前面的博客
增量式重建：
从这开始，逐步增加图像，逐渐扩展三维点云
添加新的图像：将新的图像加载到重建流程中特征提取和匹配：对新的图像提取特征点并与先前图像匹配以获得新的匹配关系位姿估计：估计新图像相对于先前图像的相机位姿，通常使用 PnP（Perspective-n-Point）—— 在已知相机内参数 K 的前提下，用该角度下的三维点（object_points）与它们对应的图像点（image_points）坐标，估算出此时拍摄位置的信息三维点三角测量：使用新的匹配对和估计的位姿（R，T）来三角测量，生成新的三维点。点云合并：将新生成的三维点与先前的点云进行合并，构建一个更大的稀疏点云 全局点云优化：在稀疏点云已经生成后，可以使用全局点云优化技术，例如Bundle Adjustment，来提高点云的准确性
2 准备代码 之前文章中，我们讲所有代码都挤到了main函数中，十分不美观，现在我们进行一下代码的优化
由于才学C++，比较菜请见谅
2.1 Include.h 这里包含了所有用到的头文件和宏，方便之后使用
由于之后要用 Bundle Adjustment，所以引入了 ceres，具体环境配置之后可能会说（真的比较麻烦，强烈推荐 vcpkg ），其中大量的 #define 和 #pragma warning(disable: 4996) 都是关于 ceres 的报错的
#ifndef INCLUDES_H #define INCLUDES_H #define GLOG_NO_ABBREVIATED_SEVERITIES #define _CRT_NONSTDC_NO_DEPRECATE #define NOMINMAX #define _CRT_NONSTDC_NO_WARNINGS #pragma warning(disable: 4996) #include &lt;opencv2/opencv.hpp&gt; #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;fstream&gt; #include &lt;ceres/ceres.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88c1b53f768bef99a9c7824c4c736f15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8402177a695fcbbecf16f21d49b7783/" rel="bookmark">
			【C#】抽象类和接口的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		namespace cs { public partial class Program { public abstract class A { // static members // abstract and virtual modifiers are not allowed on fields public static int P1SF; protected internal static int PISF; internal static int InSF; protected static int P2SF; private static int P3SF; // You cannot use abstract / virtual modifier on static properties of an abstract class public static int P1S_P { get; set; } protected internal static int PIS_P { get; set; } internal static int InS_P { get; set; } protected static int P2S_P { get; set; } private static int P3S_P { get; set; } // You cannot use abstract / virtual modifier on static methods of an abstract class public static void P1S_M() { } protected internal static void PIS_M() { } internal static void InS_M() { } protected static void P2S_M() { } private static void P3S_M() { } // instance members // abstract and virtual modifiers are not allowed on fields public int P1_F; protected internal int PI_F; internal int In_F; protected int P2_F; private int P3_F; public int P1__P { get; set; } protected internal int PI__P { get; set; } internal int In__P { get; set; } protected int P2__P { get; set; } private int P3__P { get; set; } public abstract int P1_AP { get; set; } protected internal abstract int PI_AP { get; set; } internal abstract int In_AP { get; set; } protected abstract int P2_AP { get; set; } // abstract members cannot be private public virtual int P1_VP { get; set; } protected internal virtual int PI_VP { get; set; } internal virtual int In_VP { get; set; } protected virtual int P2_VP { get; set; } // virtual members cannot be private public void P1__M() { } protected internal void PI__M() { } internal void In__M() { } protected void P2__M() { } private void P3__M() { } public abstract void P1_AM(); protected internal abstract void PI_AM(); internal abstract void In_AM(); protected abstract void P2_AM(); // abstract members cannot be private public virtual void P1_VM() { } protected internal virtual void PI_VM() { } internal virtual void In_VM() { } protected virtual void P2_VM() { } // virtual members cannot be private } public interface I { // static members // abstract and virtual modifiers are not allowed on fields public static int P1SF; protected internal static int PISF; internal static int InSF; protected static int P2SF; private static int P3SF; // In C# 11 (.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8402177a695fcbbecf16f21d49b7783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57f54c93823b2fb1e151b0f5baf144f0/" rel="bookmark">
			RabbitMQ官方案例学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官方文档：RabbitMQ教程 — RabbitMQ (rabbitmq.com)
一、安装RabbitMQ服务 直接使用docker在服务器上安装
docker run -it -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.12-management 安装完成后，访问15672端口，默认用户名和密码都是 guest，即可进入 二、hello world——梦开始的地方 1. 介绍 RabbitMQ 是一个消息代理：它接受并转发消息。 你可以把它想象成一个邮局：当你把你想要邮寄的邮件放在邮箱里时， 您可以确定，邮递员最终会将邮件递送给您的收件人。 在这个类比中，RabbitMQ是一个邮政信箱，一个邮局和一个信件载体。RabbitMQ和邮局的主要区别在于它不处理纸张， 相反，它接受、存储和转发数据的二进制 blob - 消息。
2. 一些术语 生产者：消息的发送方
队列queue：本质上是一个大型的消息缓冲区
消费者：消息的使用方
Channel 频道：理解为操作消息队列的 client（比如 jdbcClient、redisClient），提供了和消息队列 server 建立通信的传输方法（为了复用连接，提高传输效率）。程序通过 channel 操作 rabbitmq（收发消息）
3. 编写代码 用 Java 编写两个程序;一个发送单个消息的生产者，一个接收的使用者并将消息打印出来。
（1）消息生产者： 编码过程：
先创建连接工厂，然后通过工厂创建连接，再通过连接创建channel。通过channel来绑定队列或者交换机，再用channel来生产或者消费消息。
channel.basicPublish("",QUEUE_NAME,null,msg.getBytes());
对于这行代码，可以看到消息是根据QUEUE_NAME路由到对应的队列。
import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.Connection; import com.rabbitmq.client.Channel; public class MQProducer { //设置队列名 private final static String QUEUE_NAME = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57f54c93823b2fb1e151b0f5baf144f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3bd237fd47c0d4cbcf81fc8f82cfde4/" rel="bookmark">
			数字信号处理---离散时间信号与系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、离散时间序列 离散时间序列信号是一个有序的时间集合，因此离散时间信号也称为离散时间序列。
1.1 序列的表示 离散时间序列一般用集合、解析表达式和图形三种方式表示。
集合表示法：，Z表示整数集合。
例如，x[n] = {1,2,3,4,5；n = 0,1,2,3,4}，一般简单表示为 x[n] = {1,2,3,4,5}。
解析表达式：如。
图形表示法：
1.2 序列的分类 按序列长度分为有限长序列、无限长序列 按序列周期性分为周期序列、非周期序列 按序列函数值分实数序列、复数序列还可分为能量序列、功率序列 1.3 常用时间序列 1.3.1 单位脉冲序列 1.3.2 单位阶跃序列 1.3.3 矩形序列 1.3.4 指数序列 其中，为实数或者复数。
(1)实指数序列
若均为实数，x[n]称为实指数序列。
延伸
当为负数时
可以表示为
由于
所以
也可以表示为
(2)复指数序列
若均为复数，x[n]称为复指数序列。
令,其中均为实数，则
进一步
1.4 序列的分解 时域中，任意离散时间序列都能表示为某些基本序列及其延迟的加权和，最常用的基本序列为单位脉冲序列，任意离散时间序列都可由单位脉冲序列表示：
二、离散时间系统 离散时间系统的作用是将给定的输入序列通过一定的运算处理转变为输出序列。
2.1 系统的表示 离散时间系统可由数学算子或变换表示，即系统的输出序列与系统输入序列之间的关系可表示为
2.2 系统的分类 系统的主要属性包括：记忆性、线性、时不变性、因果性和稳定性。据此可以将系统分为：有记忆系统与无记忆系统、线性系统与非线性系统、时变系统与时不变系统、因果系统与非因果系统、稳定系统与非稳定系统等，其中最重要的是线性时不变系统。
1. 无记忆系统 系统的输出只与当前时刻输入相关
2. 线性系统 满足叠加原理的系统称为线性系统。
例1： 例2：
例3： 3. 时不变系统 系统的性能不随时间的改变而改变
例1：
例2： 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3bd237fd47c0d4cbcf81fc8f82cfde4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dfeba7731a482542f647eb8074c5710/" rel="bookmark">
			云上智能驾驶三维重建最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		智能驾驶技术的不断发展，正在改变着我们的出行方式和交通系统。作为其中的一个关键技术，三维重建在智能驾驶系统中起着重要的作用。除去车端本身的感知、重建算法，自动驾驶技术的落地与发展需要庞大的云端重建能力支撑，火山引擎多媒体实验室通过行业领先的自研三维重建技术，结合强大的云平台资源与能力，助力相关技术在云端大规模重建、自动标注、真实感仿真等场景的落地与应用。
本文重点介绍火山引擎多媒体实验室三维重建技术在动态、静态场景的以及结合先进光场重建技术的原理与实践，帮助大家能更好的了解和认识云上智能三维重建如何服务智能驾驶领域，助力行业发展。
一、技术挑战与难点 驾驶场景重建需要对道路环境做点云级别的三维重建，与传统的三维重建技术应用场景相比，驾驶场景重建技术有以下难点：
车辆运行过程中的环境因素复杂且不可控，不同天气、光照、车速、路况等均会对车载传感器采集到的数据造成影响，这对重建技术的鲁棒性带来了挑战。
道路场景中经常会出现特征退化和纹理缺失的情况，例如相机获取到视觉特征不丰富的图像信息，或者激光雷达获取到相似性较高的场景结构信息，同时，路面作为重建中的关键要素之一，色彩单一且缺少足够的纹理信息，这对重建技术提出了更高的要求。
车载传感器数量较多，常见的有相机、激光雷达、毫米波雷达、惯导、GPS定位系统、轮速计等等，如何将多传感器的数据融合起来得到更精确的重建结果，对重建技术提出了挑战。
道路中存在运动车辆、非机动车、行人等动态物体，会对传统重建算法带来挑战，如何剔除动态物体对静态场景重建带来干扰，同时对动态物体的位置、大小、速度进行估计，也是项目的难点之一。
二、驾驶场景重建技术介绍 自动驾驶领域的重建算法通常会采用激光雷达、相机为主，GPS、惯导为辅的技术路线。激光雷达可以直接获取高精度的测距信息，能够快速得到场景结构，通过预先进行的激光雷达-相机联合标定，相机获取到的图像能够为激光点云赋予色彩、语义等信息。同时，GPS和惯导可以进行辅助定位，减少重建过程中因为特征退化而出现的漂移现象。但是，由于多线激光雷达售价较高，通常用于工程车辆，而在量产车上很难得到规模化的使用。
对此，火山引擎多媒体实验室自研了一套纯视觉的驾驶场景重建技术，包括静态场景重建、动态物体重建和神经辐射场重建技术，能够区分场景中的动静态物体，还原出静态场景的稠密点云，并突出路面、指示牌、红绿灯等关键要素；能够对场景中运动物体的位置、大小、朝向和速度进行有效的估计，用于后续的4D标注；能够在静态场景重建的基础上，使用神经辐射场对场景进行重建和复现，实现自由视角的漫游，可用于场景编辑和仿真渲染。这套技术解决方案不依赖激光雷达，且能够达到分米级的相对误差，用最小的硬件成本实现接近激光雷达的重建效果。
2.1 静态场景重建技术：剔除动态干扰、还原静态场景 视觉重建技术以多视角几何作为基础的理论依据，要求待重建的场景或者物体具有帧间一致性，即在不同图像帧中处在静止状态，因此需要在重建过程中剔除动态物体。根据场景中的不同要素的重要性，稠密点云中需要去除无关紧要的点云，而保留一些关键要素点云，因此需要事先对图像进行语义分割。对此， 火山引擎 多媒体实验室结合AI技术与多视角几何基本原理，搭建了一套先进的鲁棒、精确完整视觉重建算法框架。重建过程包括三个关键步骤 ：图像预处理、稀疏重建和稠密重建 。
静态场景.png 车载相机拍摄过程中处在运动状态，由于曝光时间的存在，采集到的图像中会随着车速提高而出现严重的运动模糊现象。另外，出于节约带宽和存储空间考虑，传输过程中会对图像进行不可逆的有损压缩，造成画质的进一步降低。为此， 火山引擎多媒体实验室使用了端到端的神经网络对图像进行去模糊处理，能够在抑制运动模糊现象的同时对图像质量进行提升。去模糊前后的对比如下图所示。
去模糊前（左） 去模糊后（右） 为了区分出动态物体，火山引擎多媒体实验室使用了基于光流的动态物体识别技术，能够得到像素级别的动态物体掩膜。在之后的静态场景重建过程中，落在动态物区域上的特征点将被剔除，只有静态的场景和物体将得到保留。
光流（左） 运动物体（右）
稀疏重建过程中需要同时计算相机的位置、朝向和场景点云，常用的有SLAM算法（Simultaneous localization and mapping）和SFM算法（Structure from Motion，简称SfM）。在不要求实时性的情况下，SFM算法能够得到更高的重建精度。但是，传统的SFM算法通常将每个相机当作独立相机来进行处理，而车辆上通常会在前后左右不同方向布置多个相机，这些相机之间的相对位置其实是固定不变的（忽略车辆振动带来的细微变化）。如果忽视相机与相机之间的相对位置约束，计算出来的各相机位姿误差会比较大。另外，当遮挡比较严重时，个别相机的位姿会难以计算。对此，火山引擎多媒体实验室自研了基于相机组整体的SFM算法，能够利用相机之间的先验相对位姿约束，以相机组作为整体来计算位姿，同时使用了GPS加惯导的融合定位结果对相机组中心位置进行约束，可有效地提高位姿估计的成功率和准确率，并能改善不同相机之间的点云不一致现象，减少点云分层现象。
传统SFM（左） 相机组SFM（右）
由于地面色彩单一、纹理缺失，传统的视觉重建很难还原出完整的地面，但是地面上存在车道线、箭头、文字/标识等关键要素，因此火山引擎多媒体实验室采用了二次曲面来拟合地面，辅助进行地面区域的深度估计和点云融合。和平面拟合相比，二次曲面更贴合实际道路场景，因为实际的路面往往并不是一个理想平面。以下是分别用平面方程和二次曲面方程来拟合地面的效果对比。
平面方程（左） 二次曲面方程（右） 将激光点云视作真值，并将视觉重建结果与之叠加，可以直观地衡量重建点云的准确性。从下图中可以看到，重建点云和真值点云贴合度非常高，经过测量得到重建结果的相对误差在15cm左右。
火山引擎多媒体实验室重建结果（彩色）与真值点云（白色） 以下是火山引擎多媒体实验室视觉重建算法和某主流商业重建软件的效果对比。可以看到，和商业软件相比，火山引擎多媒体实验室的自研算法重建效果更好、更完整，场景中的路牌、红绿灯、电线杆，以及路面上车道线、箭头等还原度非常高，而商业软件的重建点云非常稀疏，且路面大范围缺失。
某主流商业软件（左） 火山引擎多媒体实验室算法（右）
2.2 动态重建技术： 在图像上对物体进行3d标注十分困难，需要借助于点云，当车辆只有视觉传感器时，获取场景中目标物体的完整点云十分困难。特别是动态物体，无法使用传统的三维重建技术获取其稠密点云。为提供运动物体的表达，服务于4d标注，使用3d bounding box（以下简称3d bbox）对动态物体进行表示，通过自研动态重建算法获取每一时刻场景中动态物体的3d bbox姿态、大小、速度等，从而补全动态物体重建能力。
动态重建pipeline 对车辆采集的每一帧图像，首先提取场景中的动态目标，生成3d bbox的初始提议，提供两种方式：使用2d目标检测，通过相机位姿估计对应的3d bbox；直接使用3d目标检测。两种方式针对不同数据可以灵活进行选择，2d检测泛化性好，3d检测可以获得更好的初值。同时，对图像动态区域内部的特征点进行提取。获取单帧图像初始3d bbox提议及特征点后，建立多帧间数据关联：通过自研多目标跟踪算法建立物体匹配，并通过特征匹配技术对图像特征进行匹配。获取匹配关系后，将有共视关系的图像帧创建为局部地图，构建优化问题求解全局一致的目标bbox估计。具体地，通过特征点的匹配以及动态三角化技术，恢复动态3d点；对车辆运动建模，联合优化物体、3d点、相机之间的观测，从而获得最优估计的动态物体3d bbox。
2d生成3d（左二） 3d目标检测示例
多目标跟踪算法示例
动态重建结果demo
2.3 NeRF 重建：真实感渲染、自由视角 使用神经网络进行隐式重建，利用可微渲染模型，从已有视图中学习如何渲染新视角下的图像，从而实现照片级逼真的图像渲染， 即神经辐射场（NeRF）技术。同时，隐式重建具有可编辑、查询连续空间的特性，可以用于自动驾驶场景中自动标注、仿真数据构建等任务。使用NeRF技术对场景进行重建是非常有价值的。
火山引擎多媒体实验室融合神经辐射场技术与大场景建模技术。在具体实践中，首先针对数据进行处理，场景中的动态物体会使NeRF重建出现伪影，借助自研动静态分割、影子检测等算法，对场景中和几何不一致的区域进行提取，生成mask，同时利用视频inpainting算法，对剔除掉的区域进行修复。借助自研三维重建能力，对场景进行高精度的几何重建，包括相机参数估计以及稀疏、稠密点云生成。另外，对场景进行拆分以减小单次训练资源消耗，并可做分布式训练、维护。在神经辐射场训练过程中，针对室外无边界大场景，团队通过一些优化策略以提升该场景下的新视角生成效果，如通过在训练中同时优化位姿提高重建精度，基于哈希编码的层次化表达提升模型训练速度，借助外观编码提升不同时间采集场景的外观一致性等，借助mvs稠密深度信息提升几何精度等。团队同毫末智行合作，完成单路采集以及多路合并的NeRF重建，相关成果已在毫末AI Day发布。
动态物/影子剔除，填补
单摄像头nerf重建
自由视角+几何对比
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f09cc0634e84fe986b268f4b1c010ac9/" rel="bookmark">
			如何把Elasticsearch中的数据导出为CSV格式的文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言| 本文结合用户实际需求用按照数据量从小到大的提供三种方式从ES中将数据导出成CSV形式。本文将重点介Kibana/Elasticsearch高效导出的插件、工具集，通过本文你可以了解如下信息：
1，从kibana导出数据到csv文件
2，logstash导出数据到csv文件
3，es2csv导出数据到csv文件
一、Kibana导出工具 步骤1：点击Kibana；
步骤2：左侧选择数据，筛选字段；点击save，保存并命名
保存字段数据
命名
步骤3：右侧点击：share-&gt;csv reports。 一般根据数据文件大小，会花费不同的时间
生成CSV文件
步骤4：菜单栏：选择Management-&gt;Reporting-&gt;下载
下载并打开已存的文件
注意：当然使用Kibana导出会出现如下几个问题：比如要下载的文件太大，在保存对象生成CSV文件的过程中会出现如下信息：
下载的数据文件太大
如果在下载的时候出现这个问题，需要改一下Kibana配置文件，这个时候需要联系腾讯云售后给与支持。
修改kibana配置文件
当然，我们也可以使用kibana将一些其它保存在导航图的的对象下载下来，在Dashboard的右上角点击Inspect，再点击就可以导出对应可视化报表对应的数据。如下
导出可视化报表对应的数据
总结：kibana导出数据到CSV文件图形化操作方便快捷，但是操作数据不能太大，适合操作一些小型数据的导出。
二、使用logstash导出ES数据成CSV文件 步骤一：安装与ES对应版本的logstash，一般安装完后，默认就集成了logstash-output-csv插件
查看此插件
显然logstash-ouput-csv是在列表中。也就是说我们logstash支持csv格式的输出。我们建立如下的Logstash的配置文件：
定义Logstash事件配置文件
请注意上面的path需要自己去定义时候自己环境的路径。这里我们在fields里定义了我们想要的字段。通过如下命令启动logstash服务 ../bin/logstash -f ../path/convert_csv.conf
结论：Logstash不只光可以把数据传上Elasticsearch，同时它还可以把数据从Elasticsearch中导出。适合大量数据的导出。但是导出时间也会根据数据的大小而长短不一。
三、使用es2csv导出ES数据成CSV文件 可以去官网了解一下这个工具，https://pypi.org/project/es2csv/
用python编写的命令行数据导出程序，适合大量数据的同步导出，速度和效率都比较快。
安装这个过程参考上面的官方链接，如果出现无法安装pip命令，可以参考此链接：
https://www.cnblogs.com/wujf-myblog/p/9644278.html
具体的参数详解可以参考此链接：https://www.kutu66.com/GitHub/article_133864
常用参数如下：
-i 索引名
-q query dsl
-a 认证信息 格式：user: password
-u esurl 格式： http://ip:9200
-o 命名
-r qurey formated
具体执行一个命令操作一下：如下：
es2csv文件格式
因此，执行成功后，就回出现进度条的显示信息。如上图所示。
四、总结 以上3种方法是常见的ES导出到CSV文件的方法，实际工作中使用也比较广泛。大家可以多尝试。当然。elasticsearch-dump也能导，但是比较小众，相当于Mysqldump指令。如果要将ES导出到json格式可以使用它来进行操作，这里就不多说。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/775faf3e4fac01d61b083e37ba503c05/" rel="bookmark">
			Improving Image Generation with Better Captions
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本文是LLM系列文章，针对《Improving Image Generation with Better Captions》的翻译。
使用更好的字幕提高图片生成 摘要1 引言2 数据集重加字幕3 评估重加字幕的数据集4 DALL-E 35 局限性和风险 摘要 我们表明，通过对高度描述性生成的图像字幕进行训练，可以显著提高文本到图像模型的提示跟随能力。现有的文本到图像模型很难遵循详细的图像描述，并且经常忽略单词或混淆提示的含义。我们假设这个问题源于训练数据集中有噪声和不准确的图像字幕。我们通过训练一个定制的图像字幕师来解决这个问题，并使用它来重述训练数据集。然后，我们训练了几个文本到图像的模型，发现对这些合成字幕的训练可以可靠地提高提示跟随能力。最后，我们利用这些发现构建了DALL-E 3：一个新的文本到图像生成系统，并在旨在衡量提示跟随、连贯性和美观性的评估中对其性能进行了基准测试，发现它与竞争对手相比是有利的。我们发布了这些评估的样本和代码，以便未来的研究能够继续优化文本到图像系统的这一重要方面。
1 引言 2 数据集重加字幕 3 评估重加字幕的数据集 4 DALL-E 3 5 局限性和风险 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4a454195f029292d39e987e0c42cbc5/" rel="bookmark">
			gin框架39--重构 BasicAuth 中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		gin框架39--重构 BasicAuth 中间件 介绍gin BasicAuth 解析自定义newAuth实现基础认证注意事项说明 介绍 每当我们打开一个网址的时候，会自动弹出一个认证界面，要求我们输入用户名和密码，这种BasicAuth是最基础、最常见的认证方式，gin框架中提供了一种内置的方式，但它只能用内置的用户和密码，无法使用外部db中的用户和密码，这种方式很多时候是不友好的。
为此，本文根据gin.BasicAuth的原理对其就行重构，实现一个简单的newAuth中间件，该中间件可以代替默认的BasicAuth，并且可以按需更改为自定义查询函数，实现从外部db或者用户管理系统查询信息实现登录认证的功能。
gin BasicAuth 解析 博文 gin框架14–使用 BasicAuth 中间件 介绍了BasicAuth 中间件的基础使用方法，直接使用 gin.BasicAuth(gin.Accounts{“foo”: “bar”, “austin”: “1234”, “lena”: “hello2”, “manu”: “4321”, }) 即可，非常简单实用。
实际上当我们访问url的时候，它会从请求的 Authorization 中获取用户信息，并和gin.Accounts中内置用户对比，如果用户存在就将用户名称存放在Context的 Keys map结构中，方便后续查找或者获取用户信息；如果不存在就设置c.Header(“WWW-Authenticate”, realm), 并返回c.AbortWithStatus(http.StatusUnauthorized)，浏览器上的表现就是重新弹出输入用户名和密码的窗口 。
核心逻辑在 BasicAuthForRealm 方法中，如下所示:
func BasicAuthForRealm(accounts Accounts, realm string) HandlerFunc { if realm == "" { realm = "Authorization Required" } realm = "Basic realm=" + strconv.Quote(realm) pairs := processAccounts(accounts) return func(c *Context) { // Search user in the slice of allowed credentials user, found := pairs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4a454195f029292d39e987e0c42cbc5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e8fd6412a0c635ef6327272f65d50b7/" rel="bookmark">
			EI会议列表-IEEE主办-计算机方向国际学术会议推荐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		各位学者大家好，我是艾思科蓝会议的何秘书。
下面是给想发表EI会议，却不知道到哪里去找征稿通知的宝子们整理的信息。
国内外各大出版社/机构每年都筹备着成千上万个会议，以下是工科的。
IEEE会议列表，可以根据时间顺序，按照征稿通知和主题来选择和撰写投稿。
网址：Conferences Search (ieee.org)
https://conferences.ieee.org/conferences_events/conferences/search?q=*&amp;subsequent_q=&amp;date=all&amp;from=&amp;to=&amp;region=all&amp;country=all&amp;pos=69&amp;sortorder=asc&amp;sponsor=&amp;sponsor_type=all&amp;state=all&amp;field_of_interest=all&amp;sortfield=dates&amp;searchmode=basic&amp;virtualConfReadOnly=N
精选IEEE国际学术会议推荐：
第二届IEEE图像处理、计算机视觉与机器学习国际学术会议 - www.icicml.org
第三届人工智能与智能制造国际研讨会 - www.isaiim.com
第二届健康大数据与智能医疗国际会议 - ic-ichih.net
2023年第十七届国际复合医学工程学术会议 - http://www.ic-cme.com/
第二届云计算、大数据应用与软件工程国际学术会议 - http://www.ccbase.org/ 第十届电气工程与自动化国际学术论坛 - www.ifeea.info
2023智能通信与网络国际学术会议 - www.ic-icn.org
第五届信息与计算机前沿技术国际学术会议 - WWW.ICFTIC.ORG
第三届电子信息工程与计算机技术国际学术会议 - www.eiect.org
第三届计算机科学与区块链国际学术会议 - www.iccsb.net
第六届IEEE机械工程与智能制造国际会议 - http://www.wcmeim.org
第三届新能源与电力工程国际学术会议 - www.icnepe.org
第三届通讯技术与信息科技国际学术会议 - www.ic-icctit.org
第三届智能通信与计算国际学术会议 - www.ic-icc.org
第四届智能电网与能源工程国际学术会议 - http://www.meeting-sgee.org/
第三届电气工程与控制科学国际学术会议 - www.ic2ecs.com
第五届机器人、智能控制与人工智能国际学术会议 - www.ic-ricai.org
第五届国际科技创新学术交流大会 - www.iaecst.org
第五届机器学习、大数据与商务智能国际会议 - www.mlbdbi.org
第三届计算机科学、电子信息工程和智能控制技术国际会议 - www.ic-cei.org
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e8fd6412a0c635ef6327272f65d50b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eef40bf5a69da185427418d8fced6b18/" rel="bookmark">
			Appium环境搭建（集齐Windows和MacOS的宝藏内容）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Appium环境搭建目录 Windows系统环境下安装Node.js安装JDK及环境变量配置添加环境变量 安装SDK添加环境变量 安装Appium可通过三种方法安装安装 **appium-doctor**在CMD获取软件信息Appium 连接软件的字段问题解决方法 MacOS系统环境下安装xcode安装依赖安装WebDriverAgent运行WebDriverAgent windows 安装 tidevice常用的tidevice命令如下： 总结一下MacOS下踩过的坑 Windows系统环境下 安装Node.js 点击进入Node.js官网下载
下载安装包安装,然后一路狂点下一步就可以了
安装完成后，在终端中输入node -v,显示对应的版本号则表示安装成功。
C:\WINDOWS\system32&gt;node -v v18.12.0 安装JDK及环境变量配置 点击进入JDK官网下载
注意！！！默认的安装位置C:\Program Files\Java不要进行修改。
添加环境变量 依次点击高级系统设备&gt;环境变量&gt;系统变量&gt;新建
变量名：JAVA_HOME
变量值最好是点击浏览目录去找，不要自己手动输入，避免文件夹名输入错误，或者路径输入错误造成找不到路径。
变量值：你的jdk安装目录下的jdk1.8.0_351文件夹（版本号不一样名字里的数字也会有差别），变量名尽量不要手动输入，建议点击浏览目录，找到该文件夹，点击“确定”按钮。
在系统变量中找到变量名为“Path”，选中“Path”，点击“编辑”按钮。
在下图窗口点击“新建”按钮，复制粘贴这三个环境变量（注意！！！是复制粘贴，不要输入，防止出错）。
%JAVA_HOME%\bin %JAVA_HOME%\lib\tools.jar %JAVA_HOME%\jre\bin 依次点击“确定”按钮。
在终端中输入java或javac，出现以下界面则说明安装成功
安装SDK 点击进入SDK官网下载
依次点击AndroidSDK工具&gt;SDK Tools&gt;选择对应的电脑系统进行下载即可。
安装时记得在下图页面选择“Install for anyone using this computer”。
一路默认，不要修改其他内容。
安装完成后，会自动弹出如下图页面，若未弹出或关闭了，点击安装目录下的SDK Mansger.exe文件，即可打开。
除这四个以外，其他可装可不装。
安装成功后，SDK安装目录文件夹应如下图。
添加环境变量 变量名：ANDROID_HOME
变量值最好是点击浏览目录去找，不要自己手动输入，避免文件夹名输入错误，或者路径输入错误造成找不到路径。
变量值：你的sdk安装目录下的android-sdk文件夹。
在系统变量中找到变量名为“Path”，选中“Path”，点击“编辑”按钮。
在下图窗口点击“新建”按钮，复制粘贴这三个环境变量（注意！！！是复制粘贴，不要输入，防止出错）。
%ANDROID_HOME%\tools %ANDROID_HOME%\platform-tools 在终端输入 adb version
C:\WINDOWS\system32&gt;adb version Android Debug Bridge version 1.0.41 Version 29.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eef40bf5a69da185427418d8fced6b18/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/102/">«</a>
	<span class="pagination__item pagination__item--current">103/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/104/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>