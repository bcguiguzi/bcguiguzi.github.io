<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f19206c976bdbb38442ed079975416/" rel="bookmark">
			数组去重-Map实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Map简介 基本API更完善的Hash结构二、数组去重总结 一、Map简介 ES6以前，JavaScript通过Object的方式实现“键/值”式的存储(Hash结构)，也就是使用对象属性作为键再通过属性来引用值。
ES6新增了一种Map集合类型的新特性，基于此特性，JavaScript有了正真的“键/值”存储机制。
基本API 使用new关键字和Map构造函数创建一个空映射通过给Map构造函数传入一个可迭代对象，在创建的同时初始化实例 // 创建空映射 const map_1 = new Map(); // 创建并初始化实例 const map_2 = new Map([ ["key_1", "value_1"], ["key_2", "value_2"], ["key_3", "value_3"] ]); Map实例的属性与操作方法
size：获取映射中键值对的数量set(key, value)：添加新的键/值对get(key)：读取键对应的值has(key)：判断是否有某个键get(key)：读取键对应的值delete(key)：删除某个键clear()：清空 浅浅尝试一下(示例如下:)
const m = new Map(); m.set("firstName", "Matt") .set("secondName", "KD") .set("lastName", "Frisbie"); console.log(m.size); // 3 console.log(m.has("firstName")); // true console.log(m.get("firstName")); // Matt m.delete("firstName"); console.log(m.size); // 2 console.log(m.has("firstName")); // false console.log(m.get("firstName")); // undefined m.clear(); console.log(m.size); // 0 Map实例的遍历方法
keys()：返回以插入顺序生成的键迭代器values()：返回以插入顺序生成的值迭代器entries()：返回以插入顺序生成的键/值对迭代器forEach()：迭代Map的所有成员 浅浅尝试一下(示例如下:)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f19206c976bdbb38442ed079975416/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8994e3748961b833740ae0d4ea338c8/" rel="bookmark">
			java家谱氏族宗谱管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		管理员也分为站长和普通管理员.其中，站长可以通过相应的界面赋予或者取于自己的宗族文化开始关注起来，各地宗谱纷纷重修，也为宗族文化带来了新的活力.随着科技的发展和人们对于精神文明的需求，宗谱作为中华五千年来最具有平民色彩的文献也需要融入信息化的进程.因此，创建一个氏族宗谱管理系统对于继承这一文化是十分重要的.本系统通过创建家族树来显示氏族成员之间的血缘关系．本系统的实现，将会填补我国信息化进程中在平民文化上的空白，继续继承和发展我国特色的平民氏族文化．
从明代开始，民间大族纷纷开始编纂宗谱，各地同宗之间的联系也更为紧密，宗族文化开始了一个飞跃的发展.但是从清末到新中国文革期间，由于战乱和文化方针的阻扰和破坏，宗族文化陷入低潮.随着社会的发展，自九十年代以来，人们对本系统名为氏族宗谱管理系统，主要实现氏族血缘关系图和家族信息发布系统.系统共分为三个部分
——氏族宗谱模块、信息发布模块和管理员模块.游客在未登录的情况下可以浏览氏族宗谱家族树（血缘关系图）、查询氏族成员之间的血缘关系和会员在信息发布系统发布的信息；游客可以通过系统右上角注册按钮进入注册界面，注册成系统会员之后，用户可以在血缘关系图界面点击查看摸个成员的具体信息；在信息发布系统，会员能发布信息、回复他人的信息.管理员可以在管理界面添加、修改和删除氏族成员和管理信息发布系统.同时，
宗谱，又称族谱、家乘、祖谱、家谱等.一种以表谱形式，记载一个以血缘关系为主体的家族世系繁衍和重要人物事迹的特殊图书体裁.宋代以前，宗谱只作为官吏铨选和巨姓望族婚姻门第参考的依据；宋元时代，民间开始为了说世系、序长幼、辨亲疏、尊祖敬宗开始编纂宗谱，宗谱的编纂逐渐由官方垄断走向民间私修，但是未形成风气；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4375d90913e90e723dea270c53b13d8b/" rel="bookmark">
			vscode配置c#环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载.NetCore SDK终端dotnet -h 检查是否安装成功打开vscode dotnet new console创建一个c#项目配置launch.json和tasks.json文件修改 launch.json中的 "program":"${workspaceFolder}/bin/Debug/net6.0(net版本)/项目名.dll",–打开文件夹查看目录名F5编译运行 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6a1eadbc7a24760bb12dd9fe7c3e819/" rel="bookmark">
			Python数据分析可视化和大模型的随想
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是智能？ 我们今天所说的人工智能，即AGI，实质上距离我们大多数人所想的AI还差之甚远，今天所谓的“智能”是挖掘信息，实现预测的意思。其整个流程是Data---&gt;Information---&gt;Knowladge---&gt;Wisdom,其实就是用简单的Data实现最复杂的Wisdom的过程，我们就称之为“智能”
关于数据 数据是智能的基础，Π——圆周率，一个永不重复，永无止境的数据，其中包含了所有的数字组合，经过转化就是所有的文本组合，包括我们读过的每一本书，我们讲过的每一句话，我们的生日，身份证号码，我们的生平事迹......这就是数据。关于数据的研究可以分为三类：Vector（向量）、Matrix（矩阵）和Tensor（张量），即一维数组，二维数组和多维的数组
什么是数据挖掘？ “数据挖掘是从大型数据库中自动地发现有用信息的过程”。数据挖掘任务可以分为四个方面
预测建模关联分析聚类分析异常检测 预测建模包括回归和分类，回归简单来讲就是由数据到方程的映射，解决的是产生数据的根本的问题。而分类就是我们了解的人脸识别、声音识别、情感分析、语音识别等任务。而这些任务的实现是基于模型的，即由训练集和测试集产生的模型得出结果
关联分析是由模型的反馈得出事物间的联系，最常见的案例就是啤酒和尿布的关联销售
聚类分析是无监督的学习，是基于数据的相似性和差异性进行分类的步骤
异常检测可以检测出异常或缺失的数据
常见的分类算法：决策树、KNN、BAYES、SVM和我们熟知的神经网络
常见的聚类算法：Kmeans、凝聚层次聚类和DBSCAN
泰坦尼克号数据的分析 下载好数据集，导入Pycharm就可以进行分析啦
数据：
分析结果：
生还和舱位等级的关系
生存和死亡人数的比例
各年龄段生还和罹难的人数比例
各因素间的相关性分析
关于大模型 大模型时未来人工智能和机器学习领域的重点，采用预训练模型+微调的范式进行对AI的训练是现在的主流做法。所谓的预训练模型就是数据的迁移，利用可共享的现成数据进行训练，而后期的微调则是根据产品特点进行的个性化训练。解决数据处理速度的问题一般使用数据蒸馏的方法
数据蒸馏
大模型作诗
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d652bdb6212d4ad0de5e8800821c38/" rel="bookmark">
			Visual Studio Code的下载和安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本章介绍Vue 开发使用的工具 Visual Studio Code 的下载和安装 概述 VSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。该软件支持语法高亮、代码自动补全（又称 IntelliSense）、代码重构、查看定义功能，并且内置了命令行工具和 Git 版本控制系统。用户可以更改主题和键盘快捷方式实现个性化设置，也可以通过内置的扩展程序商店安装扩展以拓展软件功能。
在 Stack Overflow 组织的开发者调查中，Visual Studio Code 被认为是最受开发者欢迎的开发环境。
免费！漂亮！智能！功能全！好用！易用！
1、Visual Studio Code的下载和安装 1.1 百度搜索 VsCode，进入官网:https://code.visualstudio.com/ 1.2 下载Visual Studio Code 点击下载软件
2、Visual Studio Code的下载和安装 2.1 安装Visual Studio Code 本文以windows为例。
双击安装包，下一步
2.2 自定义安装路径 2.3 安装完成 3、安装 Visual Studio Code 常用插件 auto code 、chinese简体中文包 、Eslint前端语法检查、html css、javaScript、live Server实时服务器、open in browser浏览器、Vuter开发vue。安装后重新启动 Visual Studio Code。
至此 Visual Studio Code 下载安装完毕。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ffc218937fafeedf7f35959716b8f50/" rel="bookmark">
			如何用Python代码绘制赏月美景？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		再过几天就是八月十五了，又迎来了一年一度的中秋节。在我国大部分地区，中秋节是仅次于春节的传统节日、象征着团圆安康。在这天，天上的月亮会格外的大、格外的圆，我们吃到嘴里的月饼也比平常要甜。
吃月饼本来就是中秋节里最有仪式感的一件事情，它寄托着亲人的祝福，也承载着人们对美食的传承，更是对于中华民族优良传统文化的传承。 还没有开始买月饼的小伙伴们不要担心哟，接下来有超详细的月饼攻略，花样多、款式多，简直不能太赞了！	使用turtle库绘制月亮、云朵、山以及古诗，游戏模块使用pygame库，配上美美的背景音乐。
1. 导入所需要的库，分别是turtle库、time库和pygame库 ''' Function: 中秋赏月 Author: 向阳逐梦 微信公众号: maker星球 ''' import turtle import time import pygame 使用import导入需要使用的函数库，实现需要的功能。本文章实现的功能是绘制月亮、云朵和山川的图案和显示古诗句。 2. 绘制月亮和云朵 def drawMoon(): #绘制月亮 turtle.penup() #画笔拿起 turtle.goto(-150, 0) turtle.fillcolor((255, 215, 0)) #圆月的颜色 turtle.pendown() #画笔放下 turtle.begin_fill() turtle.circle(112) turtle.end_fill() #turtle.begin_fill()到turtle.end_fill() 颜色填充 def drawCloud(): #绘制云朵 turtle.penup() turtle.goto(-500, 200) turtle.fillcolor((245, 245, 245)) turtle.pencolor((255, 255, 255)) turtle.pensize(5) turtle.pendown() turtle.forward(250) def cloud(mode='right'): for i in range(90): turtle.pensize((i+1)*0.2+5) turtle.right(1) if mode == 'right' else turtle.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1ffc218937fafeedf7f35959716b8f50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37d4137c1b957439b759c432169951fa/" rel="bookmark">
			给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。
思路 通过观察，m位数 * n位数的结果最多是 (m + n)位，并且由于int类型数据的局限性，不能用普通乘法得到相应的结果，
所以可以考虑构建一个(m + n)位的string数组保存num1 和num2 每一位相乘的结果，并且考虑进位。
实现 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;sstream&gt; using namespace std; string multiply(string num1, string num2) { string str1 = "0"; if (num1.compare("0") == 0 || num2.compare("0") == 0) { } else { int n = num1.size(); int m = num2.size(); vector&lt;int&gt; num(m + n); for (int i = m - 1; i &gt;= 0; i--) { for (int j = n - 1; j &gt;= 0; j--) { int temp = (num1[j] - '0') * (num2[i] - '0'); num[i + j + 1] += temp; } } //最后一位不需要进位，所以从倒数第二位开始 for (int i = m + n - 2; i &gt;= 0; i--) { num[i] += num[i + 1] / 10; num[i + 1] = num[i + 1] % 10; } if (num[0] == 0) { num.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37d4137c1b957439b759c432169951fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a2571eefe249a4376d1afcf12853c8/" rel="bookmark">
			基于控制台的DVD管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用java控制台完成DVD管理系统，包括用户的登录、注册、增删改查。 一、主界面的设计 代码展示
package DVDSystem; import java.util.Scanner; public class DVDmain { public static void main(String[] args) { demo01(); } private static void demo01() { // TODO Auto-generated method stub System.out.println("*********欢迎来到DVD管理系统************"); System.out.println("-----------------------------------"); System.out.println(" 1.登陆"); System.out.println(" 2.注册"); System.out.println(" 3.退出"); System.out.println("-----------------------------------"); System.out.print("请选择对应的数字:"); Scanner sc = new Scanner(System.in); int input = sc.nextInt(); switch(input) { case 1: //	1.登录 Signin.showSignin(); System.out.println("已退出，欢迎下次再来！"); break; case 2: //	2.注册 LogOn.showLogOn(); System.out.println("已退出，欢迎下次再来！"); break; case 3: //	3.退出 System.out.println("已退出，欢迎下次再来！"); break; default: System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a2571eefe249a4376d1afcf12853c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2ed7bd4089fab283d5a47202aecf6cd/" rel="bookmark">
			三、仪表读数识别算法的开发——2.实现方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		仪表读数识别算法的开发——2. 实现方案 本专题导航，Click Me
文章目录 仪表读数识别算法的开发——2. 实现方案前言正文总结 前言 在实现方案这一部分，笔者并不打算详细描述算法实现。因为…
OpenCV已经提供了相当强大的图像处理库函数，我们只需分析图像的特点，就可以有针对性地对图像进行处理。因此这并不是一个共性的问题，而是需要“定制化”解决的个性问题；更重要的原因是“基于机器视觉的仪表读数识别系统”专题来自于一个真实的项目，因此处理的目标图像以及其中的技术细节不方便提供。 正文 用一张思维导图概括笔者所用的方案，以及一些相关的、简单的图像处理基础知识，如下图所示。
基于H/S/V单通道图像的数显区域分割流程，如下图所示。
总结 ✿✿ヽ(°▽°)ノ✿本系列完结撒花✿✿ヽ(°▽°)ノ✿
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6591aedb2ede9db9596e22487e6f21e/" rel="bookmark">
			flutter 问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、listview 上下有空白间隔：MediaQuery.removePadding包裹
MediaQuery.removePadding(context: context, removeBottom: true, removeTop: true, child: ListView.builder( shrinkWrap: true, physics: NeverScrollableScrollPhysics(), itemCount: 5, itemBuilder: (context, index){ return AssetsImage('home-bg-top.png', fit: BoxFit.fitWidth,); }, ) ) 2、flutter 打包Android debug和release包如果出现部分功能不一致，可能为 Flutter1.17以后增加了自带混淆功能。（在开发阿里百川功能时遇到的问题总结）
解决两种方式：
1）增加flutter plugins在Android中proguard-rules.pro中的混淆配置
2）关闭混淆
minifyEnabled false //删除无用代码 useProguard false //代码压缩设置 shrinkResources false //删除无用资源 signingConfig signingConfigs.config proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' 3、ios pod install 慢，导致部分库导入不成功。
在podfile中增加：source 'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git'
pod库版本低会导致部分flutter库导入不成功(jpush_flutter),解决(更新最新库)
pod repo update master ios运行或打包错误，一部分原因需要在android studio devices运行一遍，再在xcode中运行解决 4、微信相关，fluwx 3.4.2
1）微信5.4.3开始jcenter关停。需要在根目录build.gradle增加mavenCentral()
2) Android端由于kotlin版本问题导致：org.jetbrains.kotlin.codegen.CompilationException: Back-end (JVM) Internal error: wrong bytecode错误。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6591aedb2ede9db9596e22487e6f21e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/452fb00571e2ddaa9cf59c97bb7a18cf/" rel="bookmark">
			springboot配置读取顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、项目准备二、验证三、探究原理1.读取顺序2.源码梳理 总结 前言 本文主要阐述一下微服务结合配置中心、启动命令入参、本地文件都存在的情况的一个读取顺序及相同属性的赋值问题。主要用于记录自己学习情况，大神勿喷，谢谢
一、项目准备 1.创建一个springboot项目，接入nacos注册中心和配置中心。
2.在项目根目录下创建application.yml和config/application.yml，在项目目录resources下创建application.yml、config/application.yml、bootstrap.properties文件在各个文件中添加不同的配置属性
3.在各个配置文件中添加同一个属性，赋不同的值。
4.将配置中心配置好，并在配置中心添加两个属性，一个不同于其他的值，一个和步骤3的属性一致，但值不同。
5.在idea中配置启动参数操作同配置中心。
步骤1、2、3验证各个本地配置文件的读取情况以及取值顺序
步骤4验证在有配置中心的情况下读取和取值顺序
步骤5验证在启动命令传参的情况下读取和取值顺序
二、验证 @RestController public class UserController { @Value("${com.jy}") private String path; @Value("${com.jy.test}") private String test; @Value("${file.config.application.demo}") private String fileConfigApplicationDemo; @Value("${file.application.demo}") private String fileApplicationDemo; @Value("${config.application.demo}") private String classpathConfigApplicationDemo; @Value("${application.demo}") private String classpathApplicationDemo; @Value("${bootstrap.demo}") private String classpathBootstrap; @Value("${com.test.demo}") private String comTestDemo; @Value("${com.nacos.demo}") private String comNacosDemo; @RequestMapping("/test") public String getNameById(String id){ System.out.println("测试接口入参，id="+id); System.out.println("测试文件读取顺序--所有配置相同属性的值:"+path); System.out.println("测试文件读取顺序--不同属性之根目录config下的值:"+fileConfigApplicationDemo); System.out.println("测试文件读取顺序--不同属性之根目录application文件的值:"+fileApplicationDemo); System.out.println("测试文件读取顺序--不同属性之项目目录config下的值:"+classpathConfigApplicationDemo); System.out.println("测试文件读取顺序--不同属性之项目目录application文件的值:"+path); System.out.println("测试文件读取顺序--不同属性之项目目录bootstrap文件的值:"+classpathBootstrap); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/452fb00571e2ddaa9cf59c97bb7a18cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecee044e7e6f1c858b55941cb574debe/" rel="bookmark">
			详解TCP如何确保可靠传输（确认应答，重传机制，滑动窗口，流量控制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TCP确保可靠传输的机制 TCP协议格式TCP的可靠传输检验和确认应答(序列号)重传机制超时重传RTO超时时间设置 快速重传选择确认 SACKD- SACK 滑动窗口窗口大小流量控制窗口关闭 / 探测糊涂窗口综合症累计确认延迟应答捎带应答 TCP协议格式 源端口和目的端口各占2字节、
序号: 占4字节，范围 [0 ~ 232-1]，使用 mod 232计算（即序号到232-1下一个为0）。TCP面向字节流，在传输的字节流中每个字节都按顺序编号，整个传送的字节流的起始序号在建立连接时设置（三次握手）。
首部序号字段的值是本报文发送数据起始序号（第一个字节的序号）
确认序号：占4字节，是期望收到对方下一个报文段的起始序号(对方发送第一个数据字节的序号)
确认序号 = 对方前一条发送的起始序号 + 数据长度（字节）
若确认号=N,则表明:到序号 N-1 为止的所有数据都已正确收到。
数据偏移：4位首部长度，即报文数据的起始处距离报文的起始处有多远（因为首部长度不确定）。4位二进制所能表示最大值为1111，即15；数据偏移的单位是32位（4字节），所以TCP首部最大长度15*4 = 60字节（即选项小于等于40字节）
保留位：6位
窗口：16位窗口大小（2字节）。是指发送本报文方的接收窗口大小；窗口值告诉对方：从本报文段首部的确认号算起，接受方允许对方数据的发送量（字节）；因为TCP全双工通信，接收方数据缓存空间是有限的
窗口值是接收方让发送方设置其发送窗口大小依据
紧急指针:占2字节。仅在URG=1时才有意义，指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据)。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。
选项（变长）
MSS 是TCP连接双方每次发送数据的最大值 （TCP报文段长度 - TCP首部长度）
有MSS，IP就不用在对数据进行分片，也受数据链路层MTU（最大传输单元）的限制
ip header + tcp header + MSS &lt;= MTU
TCP的可靠传输 TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。
检验和 检验和
占2字节。检验和字段检验的范围包括首部和数据这两部分。和UDP一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。伪首部的格式与图中UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6(TCP的协议号是6)，把第5字段中的UDP长度改为TCP长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6，则相应的伪首部也要改变。
UDP伪首部格式
通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。
确认应答(序列号) 回顾序号与确认序号概念
即发送方发送消息需要接收方确认；本质上是对序号的确认，就是通过确认序号告诉发送方下一次需要发送的数据，也表明上一个序号及之前的数据都收到了
上述过程中，只要发送端有一个包传输，接收端没有回应确认包（ACK包），都会重发。或者接收端的应答包，发送端没有收到也会重发数据。这就可以保证数据的完整与可靠。
重传机制 TCP 针对数据包丢失的情况，会用重传机制解决。
接下来说说常见的重传机制：
1.超时重传 2.快速重传 3.SACK
超时重传 重传机制的其中一个方式，在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecee044e7e6f1c858b55941cb574debe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bdff4fa801a2fd9ba56daf04f42fd1c/" rel="bookmark">
			解决pycharm无法使用install package
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前是这个情况啥也没有
setting -&gt;install package
就这个样
我想安装requests 包 而事实是 我之前已经使用pip下载好了
如果你已经下载好了包，只是无法识别
可以直接将 包含该包 的\Lib\site-packages 这个文件夹复制下来
之后替换新项目的 \venv\Lib下的site-packages
之后再打开就可以正常运行了
而且这些包也识别过来了
这样我也能拿着pip 从cmd安装包再通过复制来续命了。
相当于不是解决这个bug，但是提供了一种绕开该bug的方式。
当然直接从setting里下载失败这个bug还需要再看看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c23b68d75b5fe8ca8e65843c7578bebc/" rel="bookmark">
			uniapp报错：Cannot find module ‘@babel/parser‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下载↓ npm i -D @babel/parser 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/720965e0d2f178fd9a6b4e83e130910e/" rel="bookmark">
			IDEA常用快捷键汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、Ctrl 部分2、Alt 部分3、Shift 部分4、Ctrl + Shift 部分5、Ctrl + Alt 部分6、主函数快捷键7、打印语句快捷键 sout8、查找快捷键 Ctrl + F9、万能键Alert + Enter10、for循环的快捷键11、Ctrl + N 搜索类12、Ctrl + Shift + N 强力搜索13、Ctrl + H 查看类的继承关系14、Alt + 7 快速查看类的结构信息15、Ctrl + R 文本替换16、其他 1、Ctrl 部分 快捷键介绍Ctrl + F在当前文件进行文本查找（必备）Ctrl + R在当前文件进行文本替换（必备）Ctrl + Y删除光标所在行内容，Ctrl+X 也可以（必备）Ctrl + Z撤销（必备）Ctrl + D快速向下复制当前行的内容（必备）Ctrl + W递进式选中代码(可以先选中光标所在的一部分代码，连续按这个快捷键会在原来的基础上继续扩展被选中的内容)（必备）Ctrl + E显示最近打开的文件记录列表Ctrl + G在当前文件跳转到指定位置处Ctrl + Q光标所在的变量/类名/方法/方法名等上面（也可以在提示补充的时候按），显示文档内容Ctrl + U前往当前光标所在的方法的父类的方法/接口定义Ctrl + B进入光标所在的方法/变量的接口或是定义处，等效于Ctrl + 左键单击（必备）Ctrl + O选择可重写的方法Ctrl + I选择可继承的方法Ctrl + /注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号（必备）Ctrl + F1在光标所在的错误代码出显示错误信息Ctrl + F3跳转到所选中的词下一个引用位置Ctrl + F4关闭当前编辑文件Ctrl + -折叠代码Ctrl + +展开代码Ctlr + Tab编辑窗口切换，如果在切换的过程中又加上delete，则是关闭对应选中的窗口Ctrl + Enter只能分隔行Ctrl + Delete删除光标后面的单词或是中文句Ctrl + BackSpace删除光标前面的单词或是中文句Ctrl + End跳到文件尾Ctrl + Home跳到文件头Ctrl + [移动光标到当前所在代码的花括号开始位置Ctrl + ]移动光标到当前所在代码的花括号结束位置Ctrl + 左方向键光标跳转到当前单词/中文句的左侧开头位置Ctrl + 右方向键光标跳转到当前单词/中文句的右侧开头位置Ctrl + 前方向键等效于鼠标滚轮向前效果Ctrl + 后方向键等效于鼠标滚轮向后效果 2、Alt 部分 快捷键介绍Alt + shift +向上 向上移动选中的代码Alt + Insert代码自动生成，如生成对象的 set/get方法，构造函数，toString（）等（必备）Alt + 左方向键按左方向切换当前已打开的文件视图Alt + 右方向键按右方向切换当前已打开的文件视图Alt + 前方向键当前光标跳转到当前文件的前一个方法名位置Alt + 后方向键当前光标跳转到当前文件的后一个方法名位置 3、Shift 部分 快捷键介绍Shift + F4对当前打开的文件，使用新Windows窗口打开，旧窗口保留Shift + F6对文件/文件夹 重命名 4、Ctrl + Shift 部分 快捷键介绍Ctrl + Shift + F根据输入内容查找整个项目 或 指定目录内文件 （必备）Ctrl + Shift + R根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）Ctrl + Shift + J自动将下一行合并到当前行末尾 （必备）Ctrl + Shift + Z取消撤销 （必备）Ctrl + Shift + W递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）Ctrl + Shift + N通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）Ctrl + Shift + /代码块注释 （（必备）Ctrl + Shift + U对选中的代码进行大 / 小写轮流转换 （必备）Ctrl + Shift + Enter自动结束代码，行末自动添加分号 （必备）Ctrl + Shift + Alt + V无格式粘贴Ctrl + Shift + Alt + N前往指定的变量/方法Ctrl + Shift + -折叠所有代码Ctrl + Shift + +展开所有代码Ctrl + Shift + F12编辑器最大化 5、Ctrl + Alt 部分 快捷键介绍Ctrl + Alt + S打开 IntelliJ IDEA 系统设置Ctrl + Alt + L格式化代码，可以对当前文件和整个包目录使用（必备）Ctrl + Alt + O优化导入的类，可以对当前文件和整个包目录使用（必备）Ctrl + Alt + I光标所在行 或选中部分进行自动代码缩进，有点类似于格式化 6、主函数快捷键 在类中输入psvm 或者main,然后IDEA自动提醒main（），敲击回车即可自动生成~
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/720965e0d2f178fd9a6b4e83e130910e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc14f8fc84c8d560b8387dc992e8d29f/" rel="bookmark">
			linux 安装protobuf
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
下载protobuf: 安装依赖
解压，进入目录，，生成配置脚本
生成Makefile文件
从Makefile读取指令, 安装
更新共享库缓存
查看软件的安装位置，是否安装成功
下载protobuf: https://github.com/protocolbuffers/protobuf/releases
https://download.csdn.net/download/xiangjai/86506906
安装依赖 sudo yum install autoconf automakers lib tool curl make g++ unzip 解压，进入目录，，生成配置脚本 cd protobuf sudo ./autogen.sh 生成Makefile文件 可以加上安装路径：--prefix=path ，默认路径为 /usr/local/ sudo ./configure 从Makefile读取指令, 安装 sudo make sudo make check sudo make install 更新共享库缓存 sudo ldconfig 查看软件的安装位置，是否安装成功 which protocol proton --version 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c01fd1f1b6536efc2105fd8fe73389f8/" rel="bookmark">
			‘scp‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OS：win10
方法一：设置 应用和功能-&gt;可选功能-&gt;添加功能
方法二：命令安装 以管理员身份打开powershell
# 查看当前是否安装 Get-WindowsCapability -Online | Where-Object Name -like 'OpenSSH*' # 安装 Add-WindowsCapability -Online -Name OpenSSH.Client Add-WindowsCapability -Online -Name OpenSSH.Server # 启动服务 cd Windows\System32\OpenSSH Start-Service sshd 参考 安装 OpenSSH
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a0a6f7ef1ab828d520c20151c5c4658/" rel="bookmark">
			ninja编译方法介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		痛点现状 首先要了解安卓编译原理：
安卓编译在原先安卓6.0纯MakeFile编译的传统流程前，8.0版本新增了四个步骤：
1.Soong的自举(bootstrap)。这个步骤会编译Soong的核心组件。
2.收集Android.bp并生成out/soong/build.ninja文件。
3.收集Android.mk并生成out/build-.ninja与out/combined-.ninja文件。
4.执行Ninja文件，进行编译。这个combined-*.ninja文件，就是真正的执行入口。
可以发现：在开发过程中，开发者最经常使用的mm、mma等单模块编译功能，就会执行上面所有步骤、极其耗时。而实际上在不改变Android.bp和Android.mk编译脚本文件时，我们是不需要执行前三步的、只需要执行第四步，因此针对安卓编译流程，我们开发了一个ninja的脚本，能直接执行第四步，以此节省大量编译耗时。
优化思路 整编项目后，在不改变Android.bp和Android.mk编译脚本文件时，将我们的ninja编译脚本放在服务器bin目录下、配置环境变量后可以使用ninja指令进行模块单编译，极大提升编译速度、缩短时间成本，一些需要长时间编译的模块，编译时间缩短甚至达到90%。
配置方法 为了方便使用ninja编译，写了一个ninja脚本，放到任意路径，然后配置环境变量。
例如：~/samba/code/ninja
在.bashrc添加环境变量
exportPATH=$PATH:/home/shu5_zhang/samba/code。
再编写ninja文件：
#!/bin/bash ninja(){ ninja_bin="$ANDROID_BUILD_TOP/prebuilts/build-tools/linux-x86/bin/ninja" #ninja_build_file="$ANDROID_BUILD_TOP/out/build-$TARGET_PRODUCT.ninja" ninja_build_file="$ANDROID_BUILD_TOP/out/combined-$TARGET_PRODUCT.ninja" if [! -f $ninja_build_file] then echo "can't find ninja buildfile $ninja_build_file" exit -1 fi if [! -f $ninja_bin] then echo "can't find ninja binary $ninja_bin" exit -1 fi $ninja_bin -f $ninja_build_file $1 } #usage:ninja&lt;modulename&gt; ninja$* 效果展示 使用mmm单编libsurfaceflinger.so需要12分钟，使用ninja后只需要1分钟，时间缩短率达到91.7%。
ninja脚本编译和平台无关，所有项目都可以使用ninja脚本编译，而且与模块类型无关，ninja编译kernel、framework、service都是一样的，只不过把make指令换成ninja使用，操作简便、效果明显！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cffc1d7fad9c55d589d5f78b9e6bc0b/" rel="bookmark">
			一文搞懂CDN（内容分发网络），涉及HTTP静态资源、DNS支持、GSLB（全局负载均衡）、云服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是 CDN ？
全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 内容分发网络 。CDN让用户实现了对资源的就近访问，从而达到最优的访问效率。
内容 ：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。分发网络 ：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。 类似于京东的仓储运输体系，当我们在自营店下单时，会选择就近的仓库进行选货配送。
二、CDN实现效果？
假设现在用户需要获取网站中某个视频资源，在没有CDN的情况下，所有的用户请求都需要到源站处理，并从源站下载资源。
2.1 没有CDN
在这种场景下会带来几个问题：
由于存在跨运营商的问题，会有较大的延迟；其次是跨地域的问题，数据的往返时间也会随着增加，并可能影响到业务的使用体验；最后，当大量的用户请求都通过源站进行处理时，无疑会给源站点带来巨大的压力，严重的情况下甚至可能压垮站点。 2.2 使用了CDN
而在使用CDN的场景中，访问请求的架构将如下图所示。对于源站的资源请求会被分配到CDN位于各地的边缘节点，用户根据就近访问原则到分配的节点去请求资源，从而获得最优的访问效率。
三、CDN的工作原理
CDN的技术实现需要DNS的支持，这里涉及到与DNS有关的两个名词：A纪录与Cname纪录。
A纪录：即Address记录，用于指定域名与对应的IP地址记录，例如: www.test.com --&gt; 10.10.10.10。当访问这类记录的域名时，DNS服务器会解析出相应的IP地址，并返回给到客户端。Cname纪录：也称为别名记录，用于指定域名与另外一个域名的解析关系，例如：www.aaa.com --&gt; www.bbb.com。 当访问这类域名时，DNS首先会将域名解析为对应的别名记录，然后再通过该别名去解析对应的IP地址，最后返回给到客户端。该类型的用途在于可以将自身域名委托给到第三方做解析，在CDN等场景中会经常用到。 3.1 在不使用CDN的情况下
我们通常是在DNS上配置A记录，即将域名解析到源站IP。此时，当客户端访问域名时，将使用以下的流程：
3.2 使用CDN后
源站域名解析将配置为Cname，即将域名解析到CDN域名，并最终由CDN厂商的GSLB分配IP。此时，整体的访问流程变成如下所示，浏览器将到CDN节点请求资源。
3.3 加速功能的实现
主要由GSLB（全局负载均衡器）与缓存系统两个主要功能系统来处理。
3.3.1. GSLB
GSLB系统可以基于智能的DNS技术来实现，相比于传统DNS具有功能更加强大、更加智能的特点。GSLB根据预先配置好的策略，为用户分配最适合的节点地址。基于成本和带宽的调度、基于服务等级的调度。
3.3.2. 缓存系统
缓存系统最基本的工作单元就是许许多多的Cache节点(缓存服务器），Cache节点负责直接响应最终用户的访问请求，把缓存在本地的内容快速提供给用户。同时 ，Cache节点也会与源站进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。
四、CDN应用场景
1. 网站加速
主要针对门户网站、电商等业务场景，如网易、淘宝等站点。这类站点往往有着非常多的的静态内容文件（文本、图片等），CDN可对其进行加速处理，从而显著改善页面响应时间，提升用户的使用体验。
2. 文件下载加速
文件下载加速是CDN的一项重要功能，常见的场景有软件补丁包发布、游戏安装包获取等，这类文件容量大，下载的过程中容易给源站带来性能和带宽压力。通过CDN的方式，可以有效分担这些压力，并提高客户端的下载效率。
3. 流媒体加速
流媒体加速的方式是通过将流媒体内容推送到离用户最近的边缘节点，使得用户可以就近获取内容，从而提高视频传输质量、缩短访问时间，节省骨干网络的流量。流媒体加速包含直播和点播两种，此类模式适用于各类音视频网站和应用，如：抖音、爱奇艺等。
4. 全站加速
主要针对动态内容较多的站点，通过智能路由、协议优化等动态加速技术，提升客户端到源站的网络效率，便于快速获取动态资源。
五、CDN带来的收益
1. 节省成本投入
CDN通过广泛部署的节点对流量进行分摊处理，对于静态资源的命中率通常达到90%以上，这极大的减少了源站的带宽及服务器资源需求，可较大的降低企业成本投入。
在不使用CDN的场景下，往往需要准备足够应付流量波峰的资源来应对，这样会造成资源的较大浪费。而CDN使用按量付费的模式，可有效降低这种资源浪费的情况。
2. 提升用户体验
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cffc1d7fad9c55d589d5f78b9e6bc0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e70bc682cdab9c895506620d462a8d20/" rel="bookmark">
			redis数据库ACL安全策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis ACL安全策略介绍ACL命令 ACL安全策略介绍 Redis ACL 是访问控制列表的缩写，它允许在可执行的命令和可访问的密钥方面限制某些连接。它的工作方式是，连接后，客户端需要提供用户名和密码进行身份验证。如果身份验证成功，则连接将与给定用户以及该用户具有的限制相关联。可以配置 Redis，以便已使用“默认”用户对新连接进行身份验证（这是默认配置）。作为副作用，配置默认用户只能为未显式进行身份验证的连接提供特定的功能子集。
ACL命令 实战操作
acl setuser a1—新建用户 不带密码
2.新建用户 带密码
acl list—列出所有用户
user 代表是用户
default 代表默认用户（反之 为自己创建的用户）
on 代表激活（反之off,默认新增的为off）
nopass 代表不需要密码
~* 代表可以访问的key
+@all 代表可以操作的command
Key的说明
acl getuser lz --得到一个用户的详细信息
给用户赋权限
acl setuser lz allkeys +@all —给lz用户授予所有权限
注意：-@all表示没有任何权限；+@all表示有所有权限
允许和禁止调用命令
+&lt;command&gt;：将命令添加到用户可以调用的命令列表中。
-&lt;command&gt;：将命令从用户可以调用的命令列表中移除。
+@&lt;category&gt;：允许用户调用 类别中的所有命令，有效类别为@admin，@set，@sortedset等，可通过调用ACL CAT命令查看完整列表。特殊类别@all表示所有命令，包括当前和未来版本中存在的所有命令。
-@&lt;category&gt;：禁止用户调用 类别中的所有命令。
+&lt;command&gt;|subcommand：允许使用已禁用命令的特定子命令。
allcommands：+@all的别名。包括当前存在的命令以及将来通过模块加载的所有命令。
nocommands：-@all的别名，禁止调用所有命令。
允许或禁止访问某些Key
&lt;pattern&gt;：添加可以在命令中提及的键模式。例如和 allkeys 允许所有键。
* resetkeys：使用当前模式覆盖所有允许的模式。如： ~foo:* ~bar:* resetkeys ~objects:* ，客户端只能访问匹配 object:* 模式的 KEY。
为用户配置有效密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e70bc682cdab9c895506620d462a8d20/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/217/">«</a>
	<span class="pagination__item pagination__item--current">218/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/219/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>