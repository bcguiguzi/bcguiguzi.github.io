<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d02cfeb4034b29cdc64d7a11b860619/" rel="bookmark">
			【A】RHEL 6 中误删 libc.so.6 文件后恢复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【Q】:RHEL 6 中 误删 /lib64/libc.so.6 库文件后
libc.so.6 简介 libc.so.6 是Linux系统（RHEL/CentOS）发行版系统中位于/lib64/目录下的GNU C (GLIBC-x.xx)标准库文件链接文件。一般是链接到同目录下的 libc-2.xx.so文件，具体版本号取决于系统版本情况。
可以使用如下命令查看 libc-x.xx.so文件中包含的GLIBC主库版本
strings /lib64/libc-2.12.so |grep -Eo “^GLIBC_.*”
删除libc.so.6后现象 删除此文件后，最直观的现象是：基本系统中绝大部分命令都无法正常使用（这应该是因为Linux系统是C开发的），执行常用的ls、pwd、cd等命令都会报错：
ls：error while loading shared libraries: libc.so.6: cannot open shared object file: No such file or directory 如何恢复 恢复此文件有三种方式：
方法1： 如果误删操作后，当前的shell还在登录状态，则直接执行：
# sln /lib64/libc-2.12.so /lib64/libc.so.6 说明：
/lib64/libc-2.12.so 文件是误删 libc.so.6 前已存在于/lib64 目录下的；如删libc.so.6之前，不知道/lib64/下的libc-x.xx.so 文件具体版本，我个人有两个办法：
a. 找个同系统版本的另一台服务器，查一下；
b. 从libc-2.12.so 开始尝试，如果不存在，就尝试libc-2.13.so …sln此命令是 创建一个源文件的静态符号链接目标文件。 方法2： 如果误删除操作后，当前的shell还在登录状态，也可以使用如下方式：
# LD_PRELOAD=/lib64/libc-2.12.so ln -s /lib64/libc-2.12.so /lib64/libc.so.6 说明：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d02cfeb4034b29cdc64d7a11b860619/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21de8f81eeb1b42baecbb3b9ea1db62d/" rel="bookmark">
			backtrader 数据源相关的几个问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		backtrader 是量化分析中最好框架之一，方便，功能强大。
使用backtrader之前（其他所有回测框架也一样），首先需要解决数据来源问题。
一般的文档大都一来就拿别的数据来作为示例，真正说到点子的并非很多。
本文针对自己遇到的几个问题捋一捋，希望有助于使用者。
一、数据来源
1、tushare
挖地兔的tushare是股市分析的必备数据来源，最近改善后变成了pro版，也从免费版变成了需要积分才能使用，不过好在获取基本的数据，只要注册后基本就可以使用
优点：数据准确，取数方便
缺点：没有港股等数据，需要一定积分，有一定次数限制。
方法：
（1）旧接口
ts.get_k_data(code,autype='qfq',start=start,end=end) 每次使用都会提示你接口马上要过去，请用新接口替换；前复权的参数似乎没有用了，
（2）新接口
ts.set_token('xxxx token') #请用申请到的token取代 pro = ts.pro_api() ts.pro_bar(ts_code=sCode, adj=sadj,start_date=sDate, end_date=eDate) # 带入参数 具体就不说了，可以参考挖地兔的文档。注意的是调用次数有限制。
2、东方财富
另一个数据源是各个网站，我自己使用感觉东方财富不错，基本上看得到的数据都能拿到。
其他如新浪等，虽然有一些接口，但网上语焉不详，大部分只有个别例子，Yahoo数据本来是比价受欢迎，可惜经常会因为在国外被墙，没办法使用。
例如：
tushare 缺少的港股数据，东方财富可以比较简单抓到：
def getHKCode(sDate,eDate): # 根据开始和结束日期获取港股数据 url = "http://datainterface3.eastmoney.com/EM_DataCenter_V3/api/GDZC/GetGDZC?tkn=eastmoney&amp;cfg=gdzc&amp;secucode=&amp;fx=&amp;sharehdname=&amp;pageSize=500&amp;pageNum=1&amp;sortFields=BDJZ&amp;sortDirec=1&amp;startDate="+sDate+"&amp;endDate="+eDate response=requests.get(url) items={} items=response.text items=eval(items) item=items["Data"][0] lsData=[] for i in item["Data"]: i=i.split('|') lsData.append(i) return lsData 这种例子很多，而且获得数据也很快。不过东方财富估计是雇佣了不同的人写不同的接口，并没有统一的标准，需要每个接口数据导出来后自己分析。
二、读入数据
1、读入办法
（1）dataframe 数据，最典型的是从tushare读取数据。
#使用tushare旧版接口获取数据 def get_data(code,start='2010-01-01',end='2020-03-31'): df=ts.get_k_data(code,autype='qfq',start=start,end=end) df.index=pd.to_datetime(df.date) df['openinterest']=0 df=df[['open','high','low','close','volume','openinterest']] return df start=datetime(2010, 3, 31) end=datetime(2020, 3, 31) # 加载数据 df = get_data('000001') data = bt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21de8f81eeb1b42baecbb3b9ea1db62d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf55078cdd3204a11d9d0e3336a3a250/" rel="bookmark">
			❤️ 单例模式：中秋佳节C站陪你不孤单 ❤️
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、C++ 单例模式总结与剖析1.1 什么是单例 二、C++单例实现2.1 基础要点2.2 C++ 实现单例的几种方式2.2.1 有缺陷的懒汉式2.2.2 线程安全、内存安全的懒汉式单例 （智能指针，锁）2.2.3 最推荐的懒汉式单例(magic static )——局部静态变量2.2.4 函数返回引用 2.3 单例的模板2.3.1 CRTP 奇异递归模板模式实现 三、使用场景 前言 系列文章的开始主要目的在于学习和分享，在浏览众多的教程过程中，发现了一位大佬的文章说的十分深入，观看他的其他内容也颇有深度，我愿称之为“精通c++”，你懂我意思吧🐶。在本篇文章中大量采用了原文的描述，也从易于阅读和传播的角度做了一些改进，希望大家都能有所收获，参考原文地址连接。
一、C++ 单例模式总结与剖析 单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。
本文对C++ 单例的常见写法进行了一个总结, 包括懒汉式、线程安全、单例模板等； 按照从简单到复杂，最终回归简单的的方式循序渐进地介绍，并且对各种实现方法的局限进行了简单的阐述，大量用到了C++ 11的特性如智能指针, magic static，线程锁; 从头到尾理解下来，对于学习和巩固C++语言特性还是很有帮助的。
1.1 什么是单例 单例 Singleton 是设计模式的一种，其特点是只提供唯一一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;
具体运用场景如： 设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;
数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;
二、C++单例实现 2.1 基础要点 全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）线程安全禁止赋值和拷贝用户通过接口获取实例：使用 static 类成员函数 2.2 C++ 实现单例的几种方式 2.2.1 有缺陷的懒汉式 懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。
#include &lt;iostream&gt; // version1: // with problems below: // 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf55078cdd3204a11d9d0e3336a3a250/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a691e18da31489bec327f000ada176/" rel="bookmark">
			Vmware 虚拟机在 windows10 启动蓝屏问题小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		发现在window 10 版本 中启动 虚拟机会出现蓝屏 问题解决
解决办法:
&gt;1.. 路径: Control Panel\All Control Panel Items\Programs and Features:
windows 程序管理 左边选项找到 启动关闭windows功能: Turn windows features on or off
将 Hyper-v 关闭 ---------------------------------------------------------------------------------------------------
&gt;2: services 中找到关于 Hyper-V的所有服务关闭
---------------------------------------------------------------------------------------------------
&gt;3. Win + R 输入 gpedit.msc 找到: administrator Templates
System
Device Guard Turn on Virtualization Based Security
将其设置为disable
也可以使用命令:
Win + X 输入 bcdedit/set hypervisor launchtype off
---------------------------------------------------------------------------------------------------
&gt;4. 将所有虚拟机的启动设置, 的自动连接都关闭: 如 Network Adaptor , USB , Sound Card , Printer 的 Connect at power on 勾选掉, 禁用所有自动硬件链接的使用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0a691e18da31489bec327f000ada176/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/852cc7d716aaa6b578b1e3c1ce9a611b/" rel="bookmark">
			RandomAccessFile详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RandomAccessFile是Java 输入/输出流体系中功能最丰富的文件内容访问类，它提供了众多的方法来访问文件内容，它既可以读取文件内容，也可以向文件输出数据。与普通的输入/输出流不同的是，RandomAccessFile支持"随机访问"的方式，程序可以直接跳转到文件的任意地方来读写数据。
RandomAccessFile可以自由访问文件的任意位置。RandomAccessFile允许自由定位文件记录指针。RandomAccessFile只能读写文件而不是流。 RandomAccessFile类中包含一个游标（文件指针：隐含数组的索引），用以标识当前读写处的位置（文件指针开始位于文件头(也就是0处)，当读/写了n个字节后，文件记录指针将会向后移动n个字节。），RandomAccessFile可以自由移动该游标。
RandomAccessFile包含了如下两个方法来操作文件记录指针。
➢ long getFilePointer()：返回文件记录指针的当前位置。(native方法)
➢ void seek(long pos)：将文件记录指针定位到pos位置。(调用本地方法seek0)
RandomAccessFile类有两个构造器：
RandomAccessFile(String name, String mode)： RandomAccessFile(File file, String mode) 创建一个随机访问文件的流：
（1）构造器1中name会转换为构造器2中的file，RandomAccessFile(String name, String mode)等价于RandomAccessFile(new File(name), String mode)
（2）mode – 访问模式
➢ "r"：以只读方式打开指定文件。如果试图对该RandomAccessFile执行写入方法，都将抛出IOException异常。
➢ "rw"：以读、写方式打开指定文件。如果该文件尚不存在，则尝试创建该文件。
➢ "rws"：以读、写方式打开指定文件。相对于"rw"模式，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。
➢ "rwd"：以读、写方式打开指定文件。相对于"rw"模式，还要求对文件内容的每个更新都同步写入到底层存储设备。
"rws"和"rwd"模式的工作方式与FileChannel类的force(boolean)方法非常相似，传递true和false两种参数来实现，但它们始终适用于每个 I/O 操作，因此通常更有效。 如果文件驻留在本地存储设备上，则当此类方法的调用返回时，可以保证该调用对文件所做的所有更改都将写入该设备。 这对于确保在系统崩溃时不会丢失关键信息非常有用。 如果文件不在本地设备上，则不提供此类保证。
“rwd”模式可用于减少执行的 I/O 操作的数量。 使用“rwd”只需要更新要写入存储的文件内容； 使用“rws”需要更新文件内容及其要写入的元数据，这通常至少需要再进行一次低级 I/O 操作。
如果有安全管理器，则调用其checkRead方法，并以file参数的路径名作为其参数，以查看是否允许对文件进行读访问。 如果模式允许写入，还会使用路径参数调用安全管理器的checkWrite方法，以查看是否允许对文件进行写访问。
RandomAccessFile类的read()方法和write()方法和流的操作执行上没有太大区别。
注意：
RandomAccessFile依然不能向文件的指定位置插入内容，如果直接将文件记录指针移动到中间某位置后开始输出，则新输出的内容会覆盖文件中原有的内容。如果需要向指定位置插入内容，程序需要先把插入点后面的内容读入缓冲区，等把需要插入的数据写入文件后，再将缓冲区的内容追加到文件后面。
/** * 向指定文件的指定位置插入指定的内容 * * @param fileName 指定文件名 * @param pos 指定文件的指定位置 * @param insertContent 指定文件的指定位置要插入的指定内容 */ public static void insert(String fileName, long pos, String insertContent) throws IOException { RandomAccessFile raf = null; //创建一个临时文件来保存插入点后的数据 File tmp = File.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/852cc7d716aaa6b578b1e3c1ce9a611b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8971eaeca922a51ae71ba2adf475516/" rel="bookmark">
			Python的数据类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.Python3中有六个标准的数据类型
数字、字符串、列表、元组、字典、集合 其中分为可变类型和不可变类型： 可变数据：列表、字典、集合 不可变数据：数字，字符串，元组 2.列表和字典的区别
相同点： 1.都是可变类型 2.都是可迭代的 不同点： 1.字典的key是不可变对象 2.字典的存储空间大于列表 3.字典的查询效率高于列表 3.列表和元组的区别
相同点： 1.都是可迭代的 不同点： 1.列表可变，元组不可变 2.列表是动态的，长度大小不固定，可以进行增删改查 3.元组是静态的，长度在初始时已经确定不能更改 4.列表和集合的区别
相同点： 1.都是可变类型 不同点： 1.列表是有序的且元素不唯一，可以根据索引进行切片 2.集合是无序的且元素唯一 3.重复元素在集合中自动被过滤 5.字典和集合的区别
相同点： 1.字典和集合都没有索引，不能进行切片和根据索引进行操作 2.都是可变类型 不同点： 1.字典是键值对的形式 2.集合没有对应的value值 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc38e2efc009eb96b27cb2654113e73e/" rel="bookmark">
			QT通过Tcp发送接收自定义结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随便写的写构体，对齐问题没考虑
#ifndef _DATA_COMM_H_ #define _DATA_COMM_H_ #include &lt;stdio.h&gt; typedef int INT32; typedef	short SHORT; typedef long LONG; typedef float FLOAT; typedef double DOUBLE; typedef	char CHAR; typedef	unsigned char UCHAR; typedef unsigned short UINT16; typedef unsigned int UINT32; typedef unsigned long ULONG; typedef	unsigned long long UINT64; enum Major:uint16_t { english=0, math, Electronic, art }; enum class WorkType:uint16_t { teacher=0, police, WhiteCollar, farmers }; typedef struct { uint16_t Grade; Major major; uint16_t Room; } Student;// #pragma pack (1) typedef struct { uint16_t workingyears; WorkType workType; uint16_t Years; uint16_t Sex; } Workers;// #pragma pack (1) #endif 把这些再封装到一个结构体中
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dc38e2efc009eb96b27cb2654113e73e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf980c6868692cb608fce33f9852411/" rel="bookmark">
			半监督学习笔记（二）：一致性正则化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Introduction 原文链接
https://arxiv.org/abs/2006.05278v2https://arxiv.org/abs/2006.05278v2
昨天的更新讲了一下半监督学习的Overview部分，简要的复习一下：
半监督学习的概念：大部分数据没有标注，少部分数据有标注，然后半监督学习要对这些数据执行良好的分类任务。
半监督学习的方法：一致性正则化，代理变量，生成模型，基于图的方法。
半监督学习的基本假设：平滑性假设、聚类假设、流形假设
半监督学习的相关问题：主动学习、迁移学习和域适应、弱监督学习、从噪声中学习。
半监督学习算法的衡量：共享信息、高质量监督基线、与迁移学习比较、考虑类分布的不匹配、改变标记数据的数量、用较小的验证集。
今天学习第二章：一致性正则化(Consitency Regularization)
首先要说明，什么是正则化？
首先，我们要肯定一个事实：神经网络存在着欠拟合和过拟合的事实。欠拟合，就是模型不能良好的拟合函数的特征，而过拟合，就是函数对模型拟合的太好了。导致给予了过多的关注在每个数据的细节方面，而忽略了数据的整体特征。而正则化，就是为了解决这个问题的。那么一致性是什么意思呢？让我们回想一下聚类假设：假设这两个点在同一类（或者距离十分的接近），他们的输出也会接近。一致性就是为了使得训练的函数fθ有如下性质：任意给定两个输入和 ，假设他们的欧式距离足够近，那么他们的输出和能够相近。所以组合起来，一致性正则化，就是为了让函数能有这样的性质。
那么，用于度量这个一致性正则化效果的指标有哪些呢？对于训练神经网络而言，在损失项上加一个L2-norm即可，但这是对于模型中的参数值的。对于半监督学习而言，也有L2-norm，但这求的是两个输入,以及他们的输出和之间的距离：
除了MSE，还有其他的距离，比如Kullback-Leiber divergence(KL)和JenSen-Shannon divergence。
那接下来，我们就来介绍一些一致性正则化模型.
一致性正则化模型 2.1 Ladder Networks. 这是一个最简单的一致性正则化模型，核心思路很简单：如果需要网络对噪声不敏感，那不如训练的时候就直接加上噪声！然后把噪声项放到损失函数里面去。核心架构如下：
原理也很简单，假设神经网络是一个编码层，那么Ladder Networks就加入了解码层，编码层分成两部分，一部分是干净的编码层，x输入后直接输出y，另一部分是x输入后，在批次归一化时中加入噪声，然后输出被污染后的输出，然后再进入解码层，还原出在编码层中的每一个输出，能还原的越好，就说明网络编码的越好，损失也就越低。这就是半监督学习的损失函数计算，最后公式如下：
其中，第一个求和与平均是对该迷你批次中的每一个x代到后面表达式的计算值进行求平均，第二个求和是对每一个输入，对在decoder和无污染模型的每一层输出计算平方损失函数，再乘以一个系数，这就对不同层数的重要性进行了区分。
那么这只是半监督学习-一致性正则化中的损失函数计算，整体的损失当然还要有给定的，因此最后的计算结果为：
这种编码结构可以在卷积神经网络中很好的应用，通常在卷积神经网络的最后一层是全连接层，正好可以通过这种方式来代替，而前面的特征提取部分则不用改动。
然而，这种方法对计算量要求十分的大，每一次迭代中，大概需要三倍的计算量。那么，接下来让我们看看2.0版本是怎么样的吧！
2.2 Pi-Model 在神经网络的学习中可以知道，其实在神经网络中加入dropout层可以很好的防止过拟合，因为这能减少各个神经元之间的相互依赖性。加入了dropout层之后，在每一次minibatch迭代中都随机的Unable一些神经元，在多次迭代的训练中还能起到集成学习的作用，这样能大大的提高网络预测的准确性。因此dropout也是一个正则化的好方法，那么对于无监督学习而言，同时，对数据进行增强（对于图像数据而言，可以有仿射变换或者裁剪）也是一个好方法。那么pi-model就是这两个方法的一个应用。
算法流程如下：
首先还是一个输入及其标签，经过增强后产生两个输出和，经过一个带有dropout层的神经网络之后输出两个值y1和y2,当然，这两个值在形式上是等价的，因此，只需要取一个和标签y1求交叉熵（对于分类问题而言），然后对这两个值本身取求MSE，再乘上一个权重，最后相加，就成了最终的输出。公式如下：
其中，w是一个权重函数。在训练初期时，因为模型很不稳定，因此无监督学习的误差不是很有用，可能会造成随机预测的结果。所以在初期会很小，大概经过20%的次数迭代之后，会到达一个最大值λ。
但这种模型仍然存在着问题，主要为：网络每次只考虑了单个迷你批次的输入，而没有考虑所有数据的信息。从采样的角度来看，采样得到的数据集是对真实分布的一种采样，从一般情况来看，采样频率至少要大于等于奈奎斯特率才能还原真实分布，但多数情况我们是没有办法达成的，而minibatch更是对采样得到的数据集的一种估计，他与真实的数据分布的差距自然会更大。而在minibatch的训练中，只有多个minibatch的共同训练，相互影响，才能使得对真实数据的分布估计的更加准确。因此，单单考虑一个minibatch是不够的，所以说，对于无监督损失的衡量，就诞生了时间集成方法。
2.3 时间集成（Temporal Ensembling） 关于时间集成方法，它对每一个无监督的输出，它都计算了其指数的加权平均,计算公式如下：
从直观上看，每一个的更新都是对之前的数据的值与当前值的加权平均，这样模型就很好的记住了之前的输出就能相互学习。
做个比喻，当然就是温故而知新了，当我们在复习备考时，一次minibatch就相当于做一套套题，梯度下降就相当于订正这张试卷，但是对于每一次新的minibatch，我们就不再复习之前的错误，因此时间久了我们就会忘掉前面做的卷子，这样效率就很差。指数平滑法就是利用了这种“复习”的思路，当前的卷子要订正，之前的错题也要整理。
算法流程图如下：
α就是一个动量项，α越小，之前的信息对网络的影响就越小，当α=0时，时间集成模型退化为pi模型。一个输入经过增强和有dropout层的神经网络，分别与之前的输出，标签计算平方损失函数和交叉熵，最后带上权值相加成为最后的loss。 当然，光这样是不够的。在这里我们很容易能关注到一个问题：在初始化的时候，=0，但是此时输出不为0，在初始几次迭代中，这样计算出来的MSE值会很大，同时因为网络没有训练好，所以说还是按照老规矩，公式更新如下：
T是训练迭代次数。这是什么意思呢？在开始训练的时候，时间集成模型会退化至pi-model。这样的训练方法也有两个好处：一个是只需要一次前向传播，就可以计算出最后的结果，这大大的减少了计算时间（在深层网络中，一次前向传播的时间开销是很大的），另外该通过指数加权平均法也很好的防止了模型的不一致性。但是这样也有缺点：这需要有大量的内存来保存所有训练实力的预测集，对于大数据集的情况来看，这样对训练的要求也是很高的。
Pi-model和时间集成模型都采取了集成学习的思想。然后也采取了teacher-student的训练思路，不过是自己当老师，自己当学生，也就是有监察机制（想象这是一个政府部门的话，就是加了纪委），能比较好的解决抽样与分布的问题。但是，这也造成了一些问题：由于加权的原因，假设α值设的很大，那么新的新学到的信息需要完全被模型考虑到，需要经过很长的时间。而α值设的很小，之前的信息又不会被考虑的那么充分，那么导致一次的误差只会在一次minibatch训练中得到更新。
而且这个模型也有问题，因为在每一次训练中，都是“自己教自己”，用政府来类比，内部的纪委是不够的，它还要接受群众来监督。而自己教自己的结果是什么呢？假设在某一次训练中，无监督的损失的权重超过了有监督的损失，那模型就会被阻止学习新的信息，比如预测相同的目标。转而只把精力投入在无监督损失的优化当中。因此，对于模型预测的目标还是需要进行优化，方法如下：
仔细的选择噪声，而不是仅仅选择加性或乘性噪声。仔细的选择导师模型，这个导师模型要对生成的学习目标负责，而不是简单的用学生模型来“自己教自己”。 为了实现这些目标，Mean teachers就出现了。
2.4 Mean teachers Mean teachers，顾名思义，就是“平均值教师”。这是什么意思呢？就是对模型也做一次指数加权平均！通过EMA之后生成了，这样模型就会更加稳定，然后再对加入一个噪声。因为是通过加权平均得到的，因此跟相比会更加稳定和可靠，也是对于真实的映射fθtrue的更好的估计。所以，对加入噪声，所得到的输出也会更加稳定和可靠。也能更好的与的输出求平方损失，最后进行反向传播。
上图就是Mean teachers算法的流程，从整体设计思路上来看，同样是一个集成学习的进阶版。模型参数θ的更新公式如下：
上式就是一个简单的指数加权的公式，模型的损失函数计算如下
当然上面的模型还是有一些问题。随着训练次数的不断增加，每一次参数的更新也在不断的减小，可能也就前20%参数变化的最大，后面可能基本没怎么变。再利用指数加权平均的方法，那么teacher-model最终会收敛至student-model。所以说，如何解决这个问题呢？
2.5 Dual Students 为解决以上问题，双学生模型应运而生！所谓双学生模型，就是两个网络初始化的策略不同，参数不同。就相当于大家的目标都是高考的话，之前的模型都是一个学生在自嗨，现在就变成了两个学生在相互竞争，这两个学生的初始状态（比如天赋、智商）等，就是由不同的初始化策略得到的。在训练的过程中，每个学生都把自己对题目x做出的答案y交给对方。判断哪个学生更加好的策略，我们应采取如下方法：
是权值，第一个是一致性正则化的损失，两个模型对迷你批次中每一个输入求输出，再求这两个输出之间的平方损失函数，再对每一个输入的平方损失函数求平均。第二个表达式就是对于预测标签的损失。
1.给学生正常的输入x和带扰动的输入，模型应该有相同的输出：
2.这两个输出都是十分的可靠的，他们都应该远离决策边界。对于分类问题来说，可以通过观察最后softmax后的输出来比较。
对于两个模型，他们的损失函数计算公式如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf980c6868692cb608fce33f9852411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f6c5e0f70bf37902046955fd6bfe2ae/" rel="bookmark">
			vue &#43; springboot前后端分离跨域cookie
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 前后端分离，请求后端的时候直接请求后端url发现每次请求的sesssionid都不一样，导致缓存数据获取失败
使用 webpack-dev-server进行开发时，webpack启动了一个运行在 node 上的 web 服务器，此时开发环境访问对应的端口时 (以 8080 举例) ，浏览器返回的 vue 页面是 webpack处理后的结果。
跨域。简单来说，在使用 ajax 请求与当前页面不同来源的数据时，浏览器会拦截服务器发回的响应。在开发环境下，“当前来源”就是 http://127.0.0.1:8080，向任何其它地址或端口的请求都会被视作跨域，从而被浏览器拦截。
webpack-dev-server 的 proxy 是为了简化开发环境下的跨域请求配置。在上述情景中，注意被拦截的是发往“其它来源”的请求，而发往“当前来源”的不会被拦截，此处的“当前来源”则是作为开发服务器的 webpack。webpack的思路就是基于此的，当发现符合在 devServer proxy 中配置好的请求格式时，将该请求拦截下来，由自己去请求服务器获取响应，然后把该响应返回给前端页面，即相当于一个传话筒。
编译打包后，前端页面成为了单独的静态资源，webpack-dev-server被抽离出去了。但是资源要被访问，那必然还是需要有另一个 web 服务器来装载它，这个服务器常见的就是 nginx。所以，如果想要让线上的 vue 页面也能正常访问服务器，那么只需要配置 nginx，告诉它同样的事，即“当我访问某个 url 时，由你来做实际的请求，然后把结果告诉我”。
解决方法 一、axios设置baseurl（后端服务地址）以及跨域带cookie 1、前端部分 axios设置config的baseurl为后端服务器的访问地址
同时在vue引入axios的位置添加以下代码，否则会出现每次访问后端cookie中的sessionid不一样
import axios from 'axios' axios.defaults.withCredentials = true;// 允许跨域携带cookie 2、后端过滤器配置允许跨域 response.setHeader("Access-Control-Allow-Origin",request.getHeader("Origin"));//支持跨域请求 response.setHeader("Access-Control-Allow-Methods", "*"); response.setHeader("Access-Control-Allow-Credentials", "true");//是否支持cookie跨域 注意：设置了axios.defaults.withCredentials = true;之后依然没有带上cookie信息，在chrome 80版本之后，谷歌把cookie的SameSite属性，从None改成了Lax。这时候，会导致cookie因为跨站而导致不会自动带上！所以需要后台在请求返回的时候 添加设置SiteSame 属性为 None
SiteSame 介绍
最新的chrome，设置null会默认成lax吧。但是如果设置samesite为NONE,又需要设置secure。https支持secure，http不行。samesite设置为null，确实去到浏览器默认就是Lax，就像domain一样，默认不设置，默认就是当前接口的domain。 这个问题最好的解决方法还是前端那边用vue配置webpack，或者nginx之类的，从协议，域名，端口上保持一致，就不存在任何跨域问题了
修改SiteSame值
Cookie c = new Cookie("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f6c5e0f70bf37902046955fd6bfe2ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e454e5ee969c78a3ef8fb6195c2d28f/" rel="bookmark">
			POI-SheetName中的特殊字符导致excel数据导出异常
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 概述 今天在使用之前正常的excel数据导出功能，突然出现异常。
异常栈信息：
[org.apache.poi.ss.util.WorkbookUtil.validateSheetName(WorkbookUtil.java:151), org.apache.poi.hssf.record.BoundSheetRecord.setSheetname(BoundSheetRecord.java:104), org.apache.poi.hssf.model.InternalWorkbook.setSheetName(InternalWorkbook.java:562), org.apache.poi.hssf.usermodel.HSSFWorkbook.setSheetName(HSSFWorkbook.java:705), com.qskj.print.printcommon.service.PrintCdkeyLibraryServiceImpl.excelExport(PrintCdkeyLibraryServiceImpl.java:678), com.qskj.print.printcommon.service.PrintCdkeyLibraryServiceImpl$$FastClassBySpringCGLIB$$c626d21b.invoke(&lt;generated&gt;), org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218), org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771), org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163), org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749), org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88), com.qskj.print.printcommon.component.AOP.doInputOutputLogging(AOP.java:117), com.qskj.print.printcommon.component.AOP.doServiceLogging(AOP.java:79), sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method), sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62), sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43), java.lang.reflect.Method.invoke(Method.java:498), org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644), org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633), org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70), org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186), org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749), org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95), org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186), org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749), org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691), com.qskj.print.printcommon.service.PrintCdkeyLibraryServiceImpl$$EnhancerBySpringCGLIB$$5e47ff74.excelExport(&lt;generated&gt;), com.qskj.print.printweb.controller.operate.CdkeyLibraryController.excelExport(CdkeyLibraryController.java:100), com.qskj.print.printweb.controller.operate.CdkeyLibraryController$$FastClassBySpringCGLIB$$a4dd882f.invoke(&lt;generated&gt;), org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218), org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771), org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163), org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749), org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88), com.qskj.print.printcommon.component.AOP.doInputOutputLogging(AOP.java:117), com.qskj.print.printcommon.component.AOP.doControllerLogging(AOP.java:74), sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method), sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62), sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43), java.lang.reflect.Method.invoke(Method.java:498), org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644), org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633), org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70), org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186), org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749), org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95), org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186), org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749), org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691), com.qskj.print.printweb.controller.operate.CdkeyLibraryController$$EnhancerBySpringCGLIB$$7e921a57.excelExport(&lt;generated&gt;), sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method), sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62), sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43), java.lang.reflect.Method.invoke(Method.java:498), org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190), org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138), org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105), org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:878), org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:792), org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87), org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040), org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943), org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e454e5ee969c78a3ef8fb6195c2d28f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae8f499dc4a4ff03823995d82ec8897/" rel="bookmark">
			react中useRef详细总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是useRef const refContainer = useRef(initialValue); 1 返回一个可变的 ref 对象，该对象只有个 current 属性，初始值为传入的参数( initialValue )。返回的 ref 对象在组件的整个生命周期内保持不变当更新 current 值时并不会 re-render ，这是与 useState 不同的地方更新 useRef 是 side effect (副作用)，所以一般写在 useEffect 或 event handler 里useRef 类似于类组件的 this 简单示例 需求： 点击 button 的时候 选中文本框
实现：
import React, { MutableRefObject, useRef } from 'react' const TextInputWithFocusButton: React.FC = () =&gt; { const inputEl: MutableRefObject&lt;any&gt; = useRef(null) const handleFocus = () =&gt; { // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aae8f499dc4a4ff03823995d82ec8897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b3174f5ebab4fc641be5d3636677bfc/" rel="bookmark">
			JavaScript 媒体查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先在 CSS3 中引入的媒体查询构成了响应式 Web 设计的核心组件。应用程序应根据每种类型设备(如手机、平板电脑、笔记本电脑、台式计算机)的限制进行定制，媒体查询提供了一种根据正在查看应用程序的设备大小设置视口尺寸的简便方法。
媒体查询允许您根据屏幕大小不同的视口尺寸，还可以帮助您为不同的设备不同的样式属性，包括设置方案、字体样式、设置和动画、边框和动画，以及您可能认为的几乎任何其他 CSS 属性。
一些前端开发人员乍一看忽略了一个事实，即 JavaScript 也支持媒体查询。虽然不像 CSS 媒体查询那样流行，但 JavaScript 媒体查询提供了灵活性和许多优势，可以使它们成为某些用例的更好选择。
JavaScript 媒体查询的好处 我们首先需要知道的，使用 JS 媒体查询的好处有哪些。
JavaScript 媒体查询有以下两个主要优势：
灵活性： 您可以通过编程方式将媒体查询合并到 JavaScript 代码中，以便它们仅在特定事件开始时或满足特定条件时触发。使用仅限 CSS3 的方法，媒体查询描述的更改将对每个屏幕大小调整事件生效。 方便性： JavaScript 媒体查询使用与使用 CSS 时相同的语法。 考虑一下：如果你想动态改变不同屏幕尺寸的属性，你会怎么做？
你可能正在挠头，坚持这样做会很好：
// 我们希望根据屏幕大小的变化执行的函数 function foo() { if (window.innerWidth &lt; 1024) { /* TODO */ } } // 设置一个侦听器 window.addEventListener('resize', foo) 在上面的代码块中，我们有一个 if 语句，该语句基于小于 1024 的 window.innerWidth(即桌面显示的标准屏幕大小)。据推测，该方法应该在应用程序在比台式计算机小的设备上运行的任何时候运行。
不幸的是，这种方法成本高昂，因为它会在每次调整大小时触发，而不仅仅是在用户在手机或平板电脑上打开应用程序时触发。没错 — 用户在桌面计算机上手动调整屏幕大小时，此方法将随时运行。过多的此类操作最终会导致应用程序延迟。
值得庆幸的是，我们有完美的 API 来处理动态情况和响应设计：matchMedia API。
基本上所有的浏览器都支持 matchMedia，以下是 Can I Use 给出的支持情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b3174f5ebab4fc641be5d3636677bfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42d58af1438a9a9c95478926dddbba4b/" rel="bookmark">
			NDT定位实践总结（参数含义及设置）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这篇是关于无人车通过NDT匹配提前建好的点云地图的介绍，主要依托于这个ROS项目。
NDT简介 NDT是利用已有的高精度点云地图和激光雷达实时测量数据实现高精度定位的技术。它通过比较激光雷达扫描得到的点云和已经准备好的地图点云来实现定位。
NDT并没有比较两个点云点与点之间的差距，而是先将参考点云（即高精度地图）转换为多维变量的正态分布，如果变换参数能使得两幅激光数据匹配的很好，那么变换点在参考系中的概率密度将会很大。因此，可以考虑用优化的方法求出使得概率密度之和最大的变换参数，此时两幅激光点云数据将匹配的最好。
如上图中，灰色的点为预先建立好的点云地图，黄色点为当前扫描的点，二者实现正确匹配即可确定车辆的位置。
NDT参数设置 项目链接：https://github.com/AbangLZU/ndt_localizer
主要需要修改的参数如下： map_loader.launch中：
&lt;arg name="roll" default="0.0" /&gt; &lt;arg name="pitch" default="0.0" /&gt; &lt;arg name="yaw" default="0.0" /&gt; &lt;arg name="x" default="0.0" /&gt; &lt;arg name="y" default="0.0" /&gt; &lt;arg name="z" default="0.0" /&gt; 这些参数代表ndt中map坐标系相对于原先建的地图的原点的偏移；
ndt_localizer.launch中：
trans_epsilon
即设置变换的 ϵ（两个连续变换之间允许的最大差值），这是判断我们的优化过程是否已经收敛到最终解的阈值
step_size
即设置牛顿法优化的最大步长。
resolution
即设置网格化时立方体的边长，网格大小设置在NDT中非常重要，太大会导致精度不高，太小导致内存过高，并且只有两幅点云相差不大的情况才能匹配。
max_iterations
即优化的迭代次数，我们这里设置为35次，即当迭代次数达到35次或者收敛到阈值时，停止优化。
converged_param_transform_probability
匹配失败的阈值。
points_downsample.launch中：
leaf_size为降采样时选取的立方体的边长（单位为m），在这个立方体中只保留一个点。这个一般根据激光雷达的线数来设定：如果采用16线的激光雷达，那么leaf_size设置为1-2m合适；如果采用32及以上，可以设置为2-3m。
输出 终端输出中，有个trans_prob参数，它也是transform_probability话题的内容，值越大表示匹配效果越好。
converged_param_transform_probability设置时，如果设置为3，表示trans_prob大于3即表示匹配成功。一般情况下，匹配比较好的时候大于6，甚至7。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf44109a8279437b19d516db136acac/" rel="bookmark">
			RSA加密 — 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：http://blog.csdn.net/zhaoyanjun6/article/details/120316606
本文出自【赵彦军的博客】
文章目录 推荐RSA 简介RSA 常用的加密填充模式实际运用注意事项实战RSA/ECB/PKCS1Padding 封装类RSA 默认实现 Https 证书签名认证过程 推荐 AES加密 — 详解
RSA 加密 — 详解
RSA 简介 RSA——非对称加密，会产生公钥和私钥，公钥在客户端，私钥在服务端。公钥用于加密，私钥用于解密。
RSA 其实是三位数学家名字的缩写，1977年，三位数学家 Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的"非对称加密算法"。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。
在1977年的RSA论文里，提到分解一个75位十进制数字大约需要104天。人类的技术进步是如此惊人！
当攻方的矛越来越锋利时，守方的盾就必须越来越厚重。所以，1024比特RSA已经不安全，应用系统不应该使用少于2048比特的公钥 值。而当需要高安全性时，选择4096比特RSA。
RSA 常用的加密填充模式 RSA/None/PKCS1PaddingRSA/ECB/PKCS1Padding Java 默认的 RSA 实现是 RSA/None/PKCS1Padding , 默认实现如下：
Cipher cipher = Cipher.getInstance("RSA"); 使用模式方式的 Cipher 生成的密文总是不一致的 ，Bouncy Castle的默认 RSA 实现是 RSA/None/NoPadding 。
为什么 Java 默认的 RSA 实现每次生成的密文都不一致呢，即使每次使用同一个明文、同一个公钥？这是因为 RSA 的 PKCS #1 padding 方案在加密前对明文信息进行了随机数填充。
实际运用注意事项 1、一般由服务器创建秘钥对，私钥保存在服务器，公钥下发至客户端
2、公钥是二进制数据，怎么下发给客户端呢？
第一种方式：服务器把二进制数据写入文件，然后把文件传给客户端。由客户端从文件读取二进制数据。
第二种方式：服务器把二进制数据转成 base64 字符串，客户端获取到 base64 字符串后，再转码为二进制数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf44109a8279437b19d516db136acac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef6691544965a0a0d7fc10b0e6309959/" rel="bookmark">
			angular获取DOM元素的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		angular中在’@angular/core’库中通过提供Renderer2和ElementRef中实现了有关于DOM的操作，但是，angular中不推荐直接操作dom元素，通过变量结合内置指令是当前操作DOM的最好实践
获取DOM元素
通过模板变量名获取单个DOM元素
@ViewChild 通过模板变量名获取DOM元素
ViewChild是属性装饰器，用来从模板视图中获取匹配的元素。视图查询在 ngAfterViewInit 钩子函数调用前完成，因此在ngAfterViewInit钩子函数中，才能正确获取查询的元素。
import { Component, ViewChild, AfterViewInit } from '@angular/core'; @Component({ selector: 'my-app', template: ` &lt;h1&gt;Welcome to Angular World&lt;/h1&gt; &lt;p #greet&gt;Hello {{ name }}&lt;/p&gt; `, }) export class AppComponent { name: string = 'Semlinker'; @ViewChild('greet') greetDiv: ElementRef; ngAfterViewInit() { console.log(this.greetDiv.nativeElement); } } 2、通过ElementRef获取DOM元素
通过css选择器获取单个DOM 并设置属性
import { ElementRef} from '@angular/core'; export class AppComponent { constructor( private el:ElementRef){} ngOnInit(){ console.log(this.el.nativeElement); this.el.nativeElement.querySelector('.btn1').style.height = '300px'; } } 通过css选择器获取多个DOM 并设置属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef6691544965a0a0d7fc10b0e6309959/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/468f88ba0cb7214e3d8c9bf268708a95/" rel="bookmark">
			色彩校正（CCM）和伽马校正（Gamma）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1、色彩矫正（CCM）
2、伽马校正（Gamma）
1、色彩矫正（CCM） 色彩校正（Color Correction ）是指用相同的方法改变图像中的所有像素的颜色值，以得到不同得显示效果。图像采集系统在获得数字图像时，由于一起或环境光照或人为因素的影响，采集的图像往往与原始图像有很大差别。颜色校正可以在一定程度上减少这种差别。 利用 RGB 颜色模型可以方便地调整图像的 RGB 分量值，这对校正偏色很有用。色彩校正的基本原理如下： 其中， Mij 表示各颜色的校正矩阵，一般利用标准色卡的对比实验来得到。 2、伽马校正（Gamma） 在处理 RGB 图像时经常遇到的一个问题是色彩的准确度问题，即 RGB 图像往往会因为显示硬件的不同而出现不一致的结果。这样导致的问题是，在某一操作平台制作好的图像，显示到另外一台机器上，效果却差相当多。这是因为并非所以的显示器都是相同的，常常会因为显示器摆放的位置，显示器周围的光照或者亮度的调整值不同，而产生不同的显示效果理论上来说，RGB 各数值与实际屏幕上所显示的色彩应该是一模一样的。但是，实际情形上并非如此。实际影响这种结果的因素，统称 Gamma。每一台显示器的 Gamma 值都不尽相同，因此即 使某一个色彩能够吻合，但是其余的色彩却可能出现差别，由此导致显示效果的差别。 Gamma 校正是一种非常重要的颜色处理方法。其基本思想是，对 R ， G ，B 每一个色彩空间进行分段，在每一段中利用线性函数来校正。这一系列的线性函数的产生，是基于对 Gamma 曲线的补偿，即利用一系列线性函数来代替 Gamma 曲线关于函数 y=x 的对称曲线。 Gamma矫正对图像有显著的影响，不同的Gamma曲线可以取得不同的效果。 Gamma矫正模块主要是对图像进行亮度空间非线性的转化，从而来适配相应的图像显示设备。Gamma矫正会影响到整个图像的对比度。对比度越高，整个图像的通透性越好，让人眼视觉效果更加明显。Gamma矫正也会影响到图像的色彩，对比度越高，整个图像的色彩饱和度也越高。 另外通过Gamma校正能够提高图像对比度。同时也分为全局gamma和RGBgamma。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2813f4571fbfa9607d9abe96d4d4b305/" rel="bookmark">
			服务的新建和规格解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前只针对systemctl 和systemd，关于service，后续补充对比!
服务 —— Linux下运行的软件我们通常把他注册为服务， 这样我们就可以通过命令开启、关闭以及保持开机启动等功能。
1、linux(以CentOS7为例)的服务systemctl脚本存放在:/usr/lib/systemd/,有系统（system）和用户（user）之分,需要开机不登陆就能运行的程序，存在系统服务里，即：/usr/lib/systemd/system目录下。
2、CentOS7的每一个服务以.service结尾，
一般会分为3部分：[Unit]、[Service]和[Install]
示例：
#vim /usr/lib/systemd/system/test.service
[Unit] ------主要是对这个服务的说明
Description=java test project ------用于描述服务
After=test.service ------用于描述服务类别/服务的启动顺序，在某种条件达到后才执行
[Service] ------ 一些具体运行参数的设置
Type=forking ------给当前的服务单元设置进程的启动类型
Simple、forking、oneshot、dbus、notify
User=users -------设置服务运行的用户
Group=users -------设置服务运行的用户组
PIDFile=/usr/local/test/test.pid -------存放PID的文件路径
ExecStart=/usr/local/test/bin/startup.sh -----服务的具体运行命令【绝对路径】
ExecReload= --------重启命令【绝对路径】
ExecStop=/usr/local/test/bin/shutdown.sh -----停止命令【绝对路径】
PrivateTmp=true ---------给服务分配独立的临时空间
[Install]
WantedBy=multi-user.target -----服务安装的相关设置，可设置为多用户的
3、首先使用systemctl start [ 服务名(也是文件名) ] 可测试服务是否可以成功运行，
如果不能运行则可以使用systemctl status [ 服务名(也是文件名) ]查看错误信息和其他服务信息，然后根据报错进行修改，直到可以start，如果不放心还可以测试restart和stop命令。接着，只要使用systemctl enable xxxxx就可以将所编写的服务添加至开机启动即可。
4、systemctl常用命令
systemctl enable test.service --------设置为开机自启动，使某服务自动启动；
systemctl disable test.service --------使某服务不自动启动
systemctl start test.service --------启动某服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2813f4571fbfa9607d9abe96d4d4b305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b6284039a733f629cd9931ff2f48e28/" rel="bookmark">
			runtime error: addition of unsigned offset to 0x602000000130
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		runtime error: addition of unsigned offset to 0x6020000001
出现了小于0的下标
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04661a3ba60a7b04dc8798a8b5cea1f6/" rel="bookmark">
			unity局域网打开关闭电脑，解决关机后无法再开启的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
一、前言：（ps:unity版本2018.3.0）
最近做了一个展厅类的项目，需要通过局域网打开关闭电脑，还要将控制器打包成苹果ipad。记录下我在做项目中的坑。
二、重点的坑：
1、打开电脑还好，网上一搜一大堆，用的udp发送mac值打开电脑，关闭电脑找了很久，最后自己做了个小工具，电脑端开机自启即可，手机端的服务器发送udp指令，小工具接收到指令，然后再执行关机
2、很坑的一点是，当我通过代码关闭电脑后，再去点击开机按钮却发现无法开机了，但是我手动关闭电脑再通过手机开机，却可以开机。（源码中这个问题已经解决）
三、使用步骤
1、win+R，进入cmd
2、输入ipconfig/all，找到mac地址，开机需要
​​​​​​​​
替换到源码的这个地方，点击开机即可开机，当然需要你的网卡支持网络唤醒功能
然后就是关机，关机小插件也是带源码的，如果想直接用的话，可以直接用我打包出来的，这个是没有shell黑色对话框的，直接点击就会在后台运行，如果想做到完全控制可以把这个小工具放到开机自启程序里面，为了可以关闭不同的电脑，设置里面的Message TXT,同时设置服务器里面的发送指令就可以关闭不同的电脑了
四、源码
源码
​
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2516dfb10bd469fe88f5bf3242e988e2/" rel="bookmark">
			AES加密 — 详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处：http://blog.csdn.net/zhaoyanjun6/article/details/120285594
本文出自【赵彦军的博客】
文章目录 推荐AES 简介对称加密加密模式填充模式常见填充模式PKCS5Padding到底是什么？ 偏移量字符集实际工作中的加密流程AES 加密/解密 注意的问题实战AES加解密AES默认实现类AES随机加密 推荐 AES加密 — 详解
RSA 加密 — 详解
AES 简介 DES 全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS）AES 密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES（Data Encryption Standard），已经被多方分析且广为全世界所使用。 为什么 DES 被废弃？
我们知道数据加密标准（Data Encryption Standard: DES）的密钥长度是56比特，因此算法的理论安全强度是2的56次方。但二十世纪中后期正是计算机飞速发展的阶段，元器件制造工艺的进步使得计算机的处理能力越来越强，DES将不能提供足够的安全性。
简单来说，DES标准的秘钥长度要求太短，安全性不够。
为什么AES算法被称为 Rijndael 算法？
1997年1月2号，美国国家标准技术研究所（National Institute of Standards and Technology: NIST）宣布希望征集高级加密标准（Advanced Encryption Standard: AES）[3]，用以取代DES。AES得到了全世界很多密码工作者的响应，先后有很多人提交了自己设计的算法。最终有5个候选算法进入最后一轮：Rijndael，Serpent，Twofish，RC6和MARS，下图分别为其中的5位作者。最终经过安全性分析、软硬件性能评估等严格的步骤，Rijndael算法获胜。
为什么AES算法安全性高？
AES的区块长度固定为128位，密钥长度则可以是128 bit，192 bit 或256位 bit 。换算成字节长度，就是密码必须是 16个字节，24个字节，32个字节。AES密码的长度更长了，破解难度就增大了，所以就更安全。
对称加密 对称加密 ： 也就是加密秘钥和解密秘钥是一样的。非对称加密 ： 也就是加密秘钥和解密秘钥是不一样的。 AES 是对称加密算法，优点：加密速度快；缺点：如果秘钥丢失，就容易解密密文，安全性相对比较差
RSA 是非对称加密算法 ， 优点：安全 ；缺点：加密速度慢
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2516dfb10bd469fe88f5bf3242e988e2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/289/">«</a>
	<span class="pagination__item pagination__item--current">290/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/291/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>