<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03d39bb43ba197381523e584698dade8/" rel="bookmark">
			mvn package、mvn install和mvn deploy区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mvn package、mvn install和mvn deploy区别 区别运行jar 区别 mvn package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库
mvn install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库
mvn deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库
运行jar mvn package # 将项目打包(会自动编译的)
cd target # 进入打包后的jar包的目录
java -jar xxx.jar # 启动jar包
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/376f1250f492bdfddf6b92f8f82328f2/" rel="bookmark">
			python程序的基本结构包括_Python 程序基本架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python的一般程序基本架构为：输入，处理，输出，这三块。
输入：包括两个内容，变量赋值与输入语句
处理：包括算术运算，逻辑运算，算法处理这三方面
输出：包括打印输出，写入文件，写入数据库这三块
下面举两个例子具体了解一下Python的程序基本架构
1
输入：变量赋值
处理：算术运算
输出：打印输出x = 12 #变量赋值x=12
y = 13 #变量赋值y=13
z = x + y #算术运算
print(z) #打印输出
25
2
输入：输入语句
处理：算法处理（函数处理）
输出：打印输出str1 = raw_input("Input a string :") #输入语句，raw——input是一个函数，他的作用是将键盘输入的字符，把输入的结果赋值给str1，后面（）内的是提示字符串，它的作用是增强交互界面的友好性
Input a string : #输入51cto网站
print (str1) #打印输出n = len（str1） #len函数作用查看字符个数，将结果赋值给n
print （n） #使用print查看字符个数
13 #51cto网址字符个数13个
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7e3deccfd31ae166866055013ba708c/" rel="bookmark">
			python程序基本结构总结_python总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结python的基本语法、程序结构、函数和模块学到的知识点，
一、python基本语法
1 ’数据类型：，整数int、浮点数float、复数、字符串、逻辑值等。比如，逻辑值仅包括True/False，是用来在if/while等语句做判断的
2.变量：用来存储可变的值，同其他的解释型编程语言一样。变量的命名规则：大小写英文、数字和下划线，且不能用数字开头。比如：i=1 print i
3 运算：Python中的算术运算符主要有 +（加法），-（减法或者取反），*（乘法），/（整除） ，% （取余），**（乘方）在这里要注意的是，整除运算和取余运算。
对于字符串来说，最常用的有+和两种运算，+表示把两个字符串进行连接，表示连乘。在Python中，逻辑运算符分别是and、or和not（这个跟C语言中的逻辑运算符不一 样），真为True，假为False。
二、程序结构
1 if语句，比如：
执行if语句内的程序
a = input("a:")= input("b:")if(a &gt; b):rint a, " &gt; ",
跳过if语句
a = input("a:")
= input("b:")
if(a &gt; b):
rint a, " &gt; ",
rint a, " &lt; ",
if else语句
a = input("a:")
= input("b:")
if(a &gt; b):
rint a, " &gt; ",
else:
rint a, " &lt; ",
2 for语句，它是Python中最强大的循环结构，比如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7e3deccfd31ae166866055013ba708c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719d8aed74a05940aa1dcb8eb99083c6/" rel="bookmark">
			Qt dock小部件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天复习发现的一个dock部件，这是一个非常好用的拖拉界面的部件。
其一：分页。
在这之前我自己写过类似浏览器的添加页签（也包括那个 关闭按钮，这边dock可以自己自定义控件）。
当时也用到了许多知识点，过程写的稍显复杂。（需要用QMap键值对来存取，每一个页面对应一个html等等。。。）现在发现可以直接使用dock小部件来完成这项功能。
其二：拖拉窗口。
将分页拖拉出来，这也是浏览器的功能之一。稍显可惜的是前面我说我自己做过类似浏览器分页的这款功能，但我当时并没有考虑到这个技术点，所以也并不知道自己写这个轮子的复杂过程。希望我有机会还是接着把那个项目按这个需求给补充完。
接下来贴上代码~~~~
#include "dockwindows.h" #include &lt;QTextEdit&gt; #include &lt;QDockWidget&gt; DockWindows::DockWindows(QWidget *parent) : QMainWindow(parent) { setWindowTitle(tr("DockWindows")); //设置主窗口的标题栏文字 QTextEdit *te = new QTextEdit(this); //定义一个QTextEdit 对象作为主窗口 te-&gt;setText(tr("Main Window")); te-&gt;setAlignment(Qt::AlignCenter); setCentralWidget(te); //将此编译框设为主窗口的中央窗体 //停靠窗口 1 QDockWidget *dock = new QDockWidget (tr("DockWindow1"),this); dock-&gt;setFeatures(QDockWidget::DockWidgetMovable);//可移动 dock-&gt;setAllowedAreas(Qt::LeftDockWidgetArea|Qt::RightDockWidgetArea); QTextEdit *te1 = new QTextEdit(); /* dock小部件可以被用户在dock之间移动 */ te1-&gt;setText(tr("Window1,The dock widget can be moved between docks by the user" "")); dock-&gt;setWidget(te1); addDockWidget(Qt::RightDockWidgetArea,dock); //停靠窗口 2 dock = new QDockWidget (tr("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/719d8aed74a05940aa1dcb8eb99083c6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5fbc8d09aead26869c4ec62fc1f6252/" rel="bookmark">
			python中uniform函数_python scipy stats.uniform用法及代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		均匀连续随机变量。
在标准形式下，分布均匀[0, 1]。使用参数loc和scale，在上获得均匀分布[loc, loc + scale]。
作为一个实例rv_continuous类，uniform对象从中继承了通用方法的集合(完整列表请参见下文)，并使用特定于此特定发行版的详细信息来完善它们。
例子：
&gt;&gt;&gt; from scipy.stats import uniform
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, ax = plt.subplots(1, 1)
首先计算一下：
&gt;&gt;&gt; mean, var, skew, kurt = uniform.stats(moments='mvsk')
显示概率密度函数(pdf)：
&gt;&gt;&gt; x = np.linspace(uniform.ppf(0.01),
... uniform.ppf(0.99), 100)
&gt;&gt;&gt; ax.plot(x, uniform.pdf(x),
... 'r-', lw=5, alpha=0.6, label='uniform pdf')
或者，可以调用分发对象(作为函数)以固定形状，位置和比例参数。这将返回固定固定给定参数的“frozen” RV对象。
冻结发行版并显示冻结的pdf：
&gt;&gt;&gt; rv = uniform()
&gt;&gt;&gt; ax.plot(x, rv.pdf(x), 'k-', lw=2, label='frozen pdf')
检查的准确性cdf和ppf：
&gt;&gt;&gt; vals = uniform.ppf([0.001, 0.5, 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5fbc8d09aead26869c4ec62fc1f6252/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb4106f5c55f37fc0d7c66120c073ec2/" rel="bookmark">
			为什么我共享的文件别人看不到_高能！腾讯会议共享屏幕还能这么用！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯会议在使用过程中大概最常用的功能就是屏幕共享了，教育培训、产品销售、企业产品培训都需要用到屏幕共享。
无论是分享PPT，还是自己的屏幕内容，屏幕共享功能都是必不可少的，但是大家一定不清楚平时使用最多的屏幕共享功能还有以下这些黑科技，今天小巴来给大家盘点一下腾讯会议屏幕共享的黑科技功能。
很多小伙伴可能都不知道屏幕共享是可以进行批注的，在共享屏幕或是共享应用时，支持共享者在共享时同步批注。
除此之外，视频共享还支持水印功能，以防止在开大型会议时对于一些有价值的资料直接被截图并外传，加上水印就会有效防止一些截图被用作商业用途，这里也帮大家整理出了如何设置水印。
参考以下两种方法设置：
方法一：会议创建者在预定会议时，勾选“开启屏幕共享水印”
方法二：会议创建者在会议中点击“设置”，在常规设置中，选择“开启屏幕共享水印”
任一参会者进行屏幕共享后，观看者的屏幕会显示其个人信息防止截屏泄漏会议机密。
这里小伙伴们也不必担心如果开启水印的话别人看到自己的姓名和电话，开启屏幕共享水印后，每个人看到的屏幕水印都是自己的信息，相互看不到对方的信息的。
另外一个大家高度关注的问题就是腾讯会议共享音视频文件是否能够支持声音播放？使用腾讯会议开会共享视频、音频文件时，支持同时共享电脑声音。
但需要注意的是仅Windows1.2.5及以上版本支持共享声音，这里小伙伴在遇到声音不能共享的时候可以先看一下是否是软件的版本不够，如果说网络条件足够的话还是建议大家及时进行软件的升级。
共享声音的操作步骤是这样的：需要通过腾讯会议Windows客户端，在会议中进行操作，任一Windows端参会者均可进行操作。
首先打开本人的麦克风，点击“共享屏幕”，勾选“同时共享电脑声音”，点击“确认共享”即可，在共享屏幕时记得勾选。
介绍完以上两大屏幕共享黑科技之后再给大家分享一些小知识点。
要点一：可以通过共享屏幕功能将自己手机屏幕显示的界面共享到会议中。若不想别人看到个人隐私信息（如微信、QQ等消息通知），建议提前将手机软件通知类等功能关闭。
要点二：腾讯会议共享屏幕功能仅支持一人进行共享，主持人可以终止当前共享。主持人也可以根据实际使用情况进行共享操作的权限设置：仅主持人可以共享或是全体成员都可以共享。
要点三：小伙伴们想在看共享屏幕的同时查看其它参会者的视频画面是支持的，开启屏幕共享后大画面显示共享屏幕内容，上方小画面显示其他人视频画面，可以通过点击右上角切换模式。
本期的分享就到这里了，看完这次的分享小伙伴们可以在下次会议中实验一下这些小功能，或者有一些其他的玩法也可以在评论区进行讨论哦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b94036e5e735d5f32d5bd6ca7832c255/" rel="bookmark">
			python调用bat_python windows 远程执行bat
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本机环境：Win 10，python3.6
远程机器: Win7、WinServer
因python在windows上执行需要用到 wmi 模块。
wmi 模块下载地址：https://sourceforge.net/projects/pywin32/files/pywin32/Build%20221/
请对照自己python实际运行环境下载模块
import wmi
def sys_version(ipaddress, user, password):
conn = wmi.WMI(computer=ipaddress, user=user, password=password)
for sys in conn.Win32_OperatingSystem():
print ("Version:%s" % sys.Caption.encode("UTF8"),"Vernum:%s" % sys.BuildNumber) #系统信息
print (sys.OSArchitecture.encode("UTF8") ) # 系统的位数
print (sys.NumberOfProcesses) # 系统的进程数
try:
filename = r"C:\Users\admin\Desktop\1.bat" # 此文件在远程服务器上
cmd_callbat = r"cmd /c call %s" % filename
conn.Win32_Process.Create(CommandLine=cmd_callbat) #执行bat文件 Win32_Process.Create
except Exception as e:
print(e)
if __name__ == '__main__':
sys_version(ipaddress="192.168.1.x", user="xxx", password="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b94036e5e735d5f32d5bd6ca7832c255/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9383f86ab383b8aeaf86b1f30865f4/" rel="bookmark">
			python布尔类型运算_python布尔运算记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0为假，1为真。
and 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值,即如果x 为假（0），则打印假（0），否则打印y的值。
a=10 b=20 c=0
a and c=10 and 20 =20(10,非0，为真，打印y(20)).
c and a=0 and 10 =0 (x=0,为假，为0)
c and b and c =10 and 20 and 0 (x非0，非假，打印最后一个y的值0）
a and c and b =10 and 0 and 20 (当对比到0 and 20时，x=0,打印假（0），对比结束)
orx or y布尔"或"- 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。
10 or 20 如果 10(x)不是0值 ，显示10（x）,否则打印 y值20
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9383f86ab383b8aeaf86b1f30865f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03bfd8392139d410f579fe9a38796e06/" rel="bookmark">
			python提取数据库数据_Python 获取 datax 执行结果保存到数据库的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行 datax 作业，创建执行文件，在 crontab 中每天1点（下面有关系）执行：
其中 job_start 及 job_finish 这两行记录是自己添加的，为了方便识别出哪张表。
#!/bin/bash
source /etc/profile
user1="root"
pass1="pwd"
user2="root"
pass2="pwd"
job_path="/opt/datax/job/"
jobfile=(
job_table_a.json
job_table_b.json
)
for filename in ${jobfile[@]}
do
echo "job_start: "`date "+%Y-%m-%d %H:%M:%S"`" ${filename}"
python /opt/datax/bin/datax.py -p "-Duser1=${user1} -Dpass1=${pass1} -Duser2=${user2} -Dpass2=${pass2}" ${job_path}${filename}
echo "job_finish: "`date "+%Y-%m-%d %H:%M:%S"`" ${filename}"
done
# 0 1 * * * /opt/datax/job/dc_to_ods_incr.sh &gt;&gt; /opt/datax/job/log/dc_to_ods_incr_$(date +\%Y\%m\%d_\%H\%M\%S).log 2&gt;&amp;1
# egrep '任务|速度|总数|job_start|job_finish' /opt/datax/job/log/
datax 执行日志：
job_start: 2018-08-08 01:13:28 job_table_a.json
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03bfd8392139d410f579fe9a38796e06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fecf12e5e6a29082349e1c3a9b49d5d5/" rel="bookmark">
			openwrt软路由安装qbittorrent_软路由之openwrt挂载硬盘和开启共享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现在的软路由，基本都可以加装一块2.5寸的普通笔记本硬盘，这对于有家庭局域网多台设备之间有轻度的文件共享需求来说，可以说软路由挂载SAMBA文件共享，是比较经济划算的解决方案。 一、挂载硬盘 在安装好硬盘之后，首先需要系统&gt;&gt;&gt;挂载点挂载好硬盘。
首先，在已挂载的文件系统中，查看是否已经自动挂载了; 如果没有自动挂载，则进入到系统&gt;&gt;&gt;挂载点，然后在挂载点处查看是否自动挂载了加装的硬盘，如果没有，点击添加; 设置挂载点-存储区: 启用此挂载点：勾选UUID：勾选挂载硬盘（根据硬盘大小区分）挂载点：/mnt/sdb1(sdb1根据实际需要修改数字，也许是sdb2) 保存并应用 二、硬盘分区 在我们安装好硬盘之后，使用ssh登录到软路由后台，输入分区命令：fdisk /dev/sdb1，命令中的sdb1根据实际的挂载硬盘的序号填写
输入p，显示现有分区信息 输入n，新建分区，然后再输入p新建主分区，根据提示完成分区的创建，警告输入y，然后输入p查看分区是否成功，最后输入w保存退出 三、格式化分区 格式化命令：mkfs.ext4 /dev/sdb1如无法格式化，先取消共享、挂载，命令为：umount /dev/sdb1 /mnt/sdb1 四、配置SMB网络共享 进入网络存储&gt;&gt;&gt;网络共享： 设置共享目录： 名称：随便根据自己的喜好设置目录：/mnt/sdb1（上面挂载设置的位置）允许用户：空只读：不勾选可浏览：勾选允许匿名用户：勾选文件权限：均为0777 修改编辑模板： 注释掉invalid users = root(前面加一个#号即可) 保存并应用 五、本地映射SMB网盘 打开我的电脑，在地址栏输入192.168.1.1(请根据你实际设置的后台地址输入)，按回车进入 右键需要挂载的sdb1，点击映射网络驱动器，点击完成 All Well done! Enjoy yourselves! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d125669248a6fb4f356144df2c68fe71/" rel="bookmark">
			天梯赛 L2 练习题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		习题 L1-064 估值一亿的AI核心代码 (20分)L2-001 紧急救援 (25分)L2-002 链表去重 (25分)L2-004 这是二叉搜索树吗？ (25分) （二叉搜索树：前序遍历建树）L2-006 树的遍历 (25分) （二叉树：后序 + 中序 建树）L2-007 家庭房产 (25分) （并查集维护）L2-008 最长对称子串 (25分) （Manachar模板）L2-010 排座位 (25分) （并查集 + 两个关系的判断）L2-011 玩转二叉树 (25分) （二叉树：中序遍历 + 前序遍历 建树）L2-012 关于堆的判断 (25分) （最小堆的构造）L2-013 红色警报 (25分) （连通块判断）L2-014 列车调度 (25分) （set 的应用）L2-016 愿天下有情人都是失散多年的兄妹 (25分) （dfs）L2-018 多项式A除以B (25分) （待补）L2-028 秀恩爱分得快 (25分) （细节题）L2-029 特立独行的幸福 (25分) （模拟）L2-030 冰岛人 (25分) （简单图） L1-064 估值一亿的AI核心代码 (20分) 题目链接
题意：按题意处理字符串
思路：有空格的处理，要好好讨论清楚。然后就是 “I”、“you” 互换的处理
#include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; const int maxn=1e5+5; int q; string s; void solve(string&amp; s,string s1,string s2) { int len=s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d125669248a6fb4f356144df2c68fe71/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9b0f1faa50400f35e14290e6d4cd492/" rel="bookmark">
			python的程序结构_python之程序结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、控制结构
if a&gt;b: #注释 ，多行注释可以用 '''多行注释'''
result=a-b
elif a
result=b-a
else:
result=0
while a&lt;100:
if a==30:
continue
if a&gt;50:
break
print(a)
pass #nop
while a&lt;100:
print(a)
for eachnum in [1,2,3]:
print(eachnum)
def add(a=1,b=2):
return (a+b)
2、函数结构
def addnum (a,b=1,*c,**d): #位置参数，默认参数，元组参数，字典参数，顺序不能改变
print "a is "+str(a)+" b is "+str(b)
sum=a+b;
print "para in c"
for every_para in c:
print every_para
sum=sum+every_para
print "para in d"
for every_key in d.keys():
print every_key+" value "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9b0f1faa50400f35e14290e6d4cd492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/69518264d4af3ab2e1f07d01fbb558a1/" rel="bookmark">
			shell 无法使用spawn_Shell脚本编程与运行
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		同传统的编程语言一样，shell提供了很多特性，这些特性可以使你的shell脚本编程更为有用。
一.创建Shell脚本
一个shell脚本通常包含如下部分：
1.首行
第一行内容在脚本的首行左侧，表示脚本将要调用的shell解释器，内容如下：
#!/bin/bash
#！符号能够被内核识别成是一个脚本的开始，这一行必须位于脚本的首行，/bin/bash是bash程序的绝对路径，在这里表示后续的内容将通过bash程序解释执行。
2.注释
注释符号# 放在需注释内容的前面，如下：
注释符号# 放在需注释内容的前面
3.内容
可执行内容和shell结构
可执行内容和shell结构
二.Shell脚本的执行
1.输入脚本的绝对路径或相对路径
/root/helloWorld.sh./helloWorld.sh 2.bash或sh +脚本
bash /root/helloWorld.shsh helloWorld.sh 注：当脚本没有x权限时，root和文件所有者通过该方式可以正常执行。
3.在脚本的路径前再加". " 或source
source /root/helloWorld.sh. ./helloWorld.sh 区别：第一种和第二种会新开一个bash，不同bash中的变量无法共享
但是使用. ./脚本.sh 这种方式是在同一个shell里面执行的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf46baf7843d70c34cdd945a03974307/" rel="bookmark">
			浅谈无线网络在未来工厂中应用的可能性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		工业设施中网络连接存在的问题 统计数据表明，由于升级更换设备所需的成本和人们“设备没坏旧无需更新”的观念等多种原因，很多普通工厂仍然在车间内使用传统旧设备和工艺流程，这使得工厂在现代化生产中面临很多挑战。
由于在跨工厂传输数据时需保证网络连接的可靠性，且在设备与集中存储的数据或处理平台进行通信时需保证不存在干扰，因此现有设备都广泛使用有线连接的方式，它们没有无线连接功能。
工业自动化过程中需要确保网络连接的可靠性，但现有的无线网络如3G和4G网络主要是为移动和计算通信而设计的，所以它无法提供自动化和互操作性所需的可靠的低延迟和高带宽数据传输。这种局限性意味着，在5G网络到来之前，人们仍然得依赖有线连接来实现工业4.0。
无线网络与工业4.0的未来 5G的引入有望解决依赖无线网络运行工业流程或运营时遇到的许多挑战。需要注意的是，与5G之前的其他无线迭代不同，5G无线网络框架是专为工业应用设计的，这意味着5G无线网络将提供低延迟、高带宽和最佳可靠性。
5G的先进可靠性意味着无线网络最终可以在工业环境中取代有线网络，并推动工业4.0的未来。为了让大家更理解这个观点，下面我们来谈谈5G网络、4G网络和有线网络之间的一些区别。
5G网络比4G网络更智能、更快、更高效或更可靠。5G预期的传输速度约为每秒10千兆比特，而4G目前的传输速度为每秒1.45千兆比特。(然而，目前5G已实现的性能与在不久的将来用户将享受到的理论优势之间仍存在一定差距)在延迟方面，4G实际上为数据传输提供了40到50毫秒的低延迟，而5G的延迟测量几乎为零。
在比较5G和4G时，无线网络对设备互联的支持能力也需要列入考虑中。4G网络在一平方英里内支持大约10万台设备，而5G网络可以支持超过100万台设备。网络容量不够大会对设备连网有影响，就像在拥挤的地方您会发现您的移动设备无法连上网络。而随着5G技术的发展，它的连接性得以增强，预计可为未来跨行业部署的数十亿个IoT网络提供支持。
支持4G和5G网络的基础设施对着这两种无线网络提供的连接吞吐量有重大影响。4G网络依赖于支持网络通信的基站，设备离基站越远，接入4G网络就越困难。而5G网络是依靠蜂窝站点来扩大其覆盖范围的，这些蜂窝单元是一个个的小盒子，很容易安装在高墙，灯杆和塔上。因此，随着5G单元安装的增加，能接入5G网络的设备也越来越多，网络容量也越来越大。5G网络将能够在最偏远的地区运行，因为与在偏远地区建立4G塔的成本相比，5G网络的基础设施简单且价格低廉。
诸如现代以太网之类的有线网络具有低延迟（大约10毫秒）的特点，这使它们成为工业设施的首选。虽然这个延迟比4G提供的要低，但与5G无线网络相比还是相形见绌。还有众多因素影响有线网络的部署，比如部署距离、范围的限制，以及面积很大的工厂的布线成本。
与有线网络不同，无线网络不受范围或工业设施大小的限制，只要设备具备无线连接功能，接入无线网络就像将智能手机连接到互联网一样简单。对于旧设备，工厂现场将诸如IoT硬件和人机界面（HMI）之类的边缘设备集成在一起即可实现连接。这些边缘设备可以在将旧设备连接到集中式网络的同时捕获旧设备的数据。
结论 无线网络提供的低延迟、高带宽、通用性和可承受性意味着无线网络将很快在工业设施中取代有线网络的使用。随着5G网络的大规模推广，以前的无线迭代所面临的诸如可靠性等传统挑战将不再困扰工厂，自动化工厂也将从中获益。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39fd7f5ac409d7d67316cb2815d2d2a0/" rel="bookmark">
			使用VLC 在PC端搭建RTSP环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明： 本文是我在工作中遇到的关于环境搭建问题后的一些总结，希望可以对你有所帮助。
介绍： 搭建方法：
1） 搭建 VLC 软件，点击媒体菜单，选择“流”选项，如下图：
2）点击添加选择需要加载的测试流文件：
3）选择“串流”
4）点击下一步：
5）选择在本地播放，之后选择选择 RTP /MPEG Transport Stream,然后添加，如下图：
6）rtsp的端口为8554，同时需要设置路径，这里设置为“/1”(这个数据可以随便写，但是一定要写)，如下图：
7）下图中取消激活转码选择；
8）最后选择 流，环境搭建完成：
9） PC端测试，在PC终端输入ipconfig命令，找到所用网络的IP地址：
10） 再开一个VLC，选择打开网络串流：
11）输入在步骤中设置的URL：rtsp://:8554/1 或者 rtsp://192.168.0.104:8554/1 （这里的IP地址为上面ipconfig获得的） 之后点击播放：
11）效果图（左边为发送端，而右边为接收端）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f10264b06daba5560eeefd19d60fb5/" rel="bookmark">
			Odoo14免费开源ERP：企业客户档案信息自动补全功能演示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在企业信息化系统的基础数据维护当中，尤其是潜在客户档案的信息收集是极其非常痛苦的事情，好在近些年拥有了企查查、企信宝等工具后，使得这样的信息收集变的相对容易，但录入的工作依然对操作人员极其痛苦，并且频繁出错，造成后续的客户转换后的销售开票等一系列的工作困扰。
为此作为全球排名第一的免费开源ERP Odoo亚太金牌服务机构开源智造咨询有限公司，结合国内的实际业务场景和实际服务的客户反馈需求，开发了本地化的应用解决方案并向全网用户免费开源下载，用于客户档案信息的自动补全方案，帮助企业收集客户信息收集变的更加容易和高效。
方案演示 1、先在Odoo系统的客户档案新建当中输入“今日头条”可以看到系统会模糊查询到今日头条关联的全称公司信息及统一社会信用代码。我们这里假设选择上海今日头条科技有限公司这条信息。如下功能截图：
2、选择上海今日头条科技有限公司后，我们可以发现客户的注册地址信息、企业统一社会信用代码、注册联系电话等信息都自动填充补全到了客户档案当中，如下功能截图：
上述就是该功能的方案演示，我们在这里做了针对企查查，天眼查，企信宝等国内企业信息大数据业务平台的数据对接，在录入客户主体信息时会自动触发接口去获取企业注册信息的填充，考虑到实际业务场景中，客户会有相关的信息修改及人工，保留了可以修改编辑的扩展。
相信大家看到了开源智造为Odoo在中国本地化落地应用的努力，欢迎大家一键三连，转发、评论、点赞，您的支持是我们最大的前进动力！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98a7d243ab2131a77bbe627505c1cab7/" rel="bookmark">
			docker host模式拿到nginx远程ip端口_docker网络模式实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker有四种网络模式，分别为Bridge、Host、Container、None。Bridge为docker的默认网络模式。这里我分享下Bridge、Host、Container模式下容器的创建及启动。
Bridge模式：当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。这样容器间就可以相互通信。
docker0
创建容器后，查看容器信息
容器信息
Bridge模式很好理解，而且在创建容器时，也不用指定，因为他是默认的。
Host模式：如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。这里我拿tomcat测试下
拉取tomcat8
由于host模式下使用的是宿主机的IP和端口，所以要注意宿主机有没有把端口开启的问题。如何打开端口，比如8080端口。
开启8080端口
firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload 通过host创建容器
docker run -d --net=host --name to1 94e31e5297d1 94e31e5297d1为tomcat8的镜像ID
host模式下创建容器
container模式：这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己网卡，配置自己的IP，而是和一个指定的容器共享IP，端口范围。
这里我拿nginx和tomcat为例，先创建一个nginx容器，并开启80、8080端口
docker run -d --name nginx -p 80:80 -p 8080:8080 7743d9092020 7743d9092020为nginx镜像ID
创建nginx容器
分别访问80和8080端口
80端口
8080端口
8080不好使，是因为我们还没有开启。使用container创建tomcat8容器。
docker run -d --name to1 --net=container:nginx 94e31e5297d1 nginx：是我上面nginx的名称
94e31e5297d1：是tomcat8镜像ID
container创建tomcat8容器
访问8080
以上就是3种模式的基本用法、后期分享更多docker方面的内容
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9eab57dec1c7c99d21247f0c57c20722/" rel="bookmark">
			使用VLC 在PC端搭建RTP环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明： 本文是我在工作中遇到的关于环境搭建问题后的一些总结，希望可以对你有所帮助。
介绍： 搭建方法：
1） 搭建 VLC 软件，点击媒体菜单，选择“流”选项，如下图：
2）点击添加选择需要加载的测试流文件：
3）选择“串流”
4）点击下一步：
5）选择在本地播放，之后选择选择 RTP /MPEG Transport Stream,然后添加，如下图：
6）目标设置页面填入地址，如 239.1.1.1，端口设置 5004
7）下图中取消激活转码选择；
8）最后选择 流，环境搭建完成：
9） PC端测试，再开一个VLC，选择打开网络串流：
10）输入在步骤中设置的URL：rtp://@239.1.1.1:5004 之后点击播放：
11）效果图（左边为发送端，而右边为接收端）：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcb7136e30fe0f437f61abb7c69b1e52/" rel="bookmark">
			Android Studio 模拟器一段时间后Toast不显示，System UI isn‘t responding等问题简单解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Step1: 进入AVD Manager
Step2：点击对应虚拟设备项最右边的倒三角
Step3：选择Wipe Data后再次启动模拟器（会清空所有个人数据）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ef329c6573bf5fe6599d9f2631eeb8d/" rel="bookmark">
			Hbuilder中如何快速输入注释标签_11   HTML5特性、转义字符和注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成长是一辈子的事儿！大家好！我是时问新(前几天改了名字，现在觉得还是用时问新这个名字更好点)。分享前端、Python等技术，以及个人成长路上的那些事儿。
HTML5中有一些特性需要我们知道。
空白折叠现象
空白折叠现象有两种：
1、就是文字和文字之间的多个空格、换行会被折叠成一个空格。
2、标签的“内壁”和文字之间的空格会被忽略。
接下来我具体的演示一下，第1种空白折叠现象到底是怎么回事。
打开vscode，这次我在之前创建的第三个网页.html里面写代码来演示。
我先生成一个HTML5的骨架，如下图：
然后我在body里面写一个p标签，在这个p标签里面随便写一段文字："不矜细行，终累大德。"我在"不矜细行"后面打好多个空格，然后再给"终累大德"换行，如下：
Document 不矜细行， 终累大德。 然而在浏览器中的效果如下：
"不矜细行"和"终累大德"之间仅仅只有一个空格。
也就是说，文字和文字之间的空格和换行无论有多么复杂，无论有多少个空格、有多少次换行，都会被折叠成一个空格，这就是空白折叠现象。
接下来我再演示一下第2中空白折叠现象到底是怎么回事。
我再写一个p标签，里面写上文字："吉光片羽"，然后在起始标签和这句话的开头之间打上很多空格，在这句话的结尾和结束标签之间也打上很多空格，如下：
Document 不矜细行， 终累大德。
吉光片羽 然后在浏览器中，看的的效果如下：
这个现象说明，在标签的"内壁"和文字之间，无论打多少空格，在浏览器中显示时，都不会有空格。
所以，空白折叠现象的真正意义是：如果你想给文字换行，无论你在代码里面如何打空格，打换行，都不会起作用，只有通过标签的语义和特性才能实现。
也就是说，如果你想给某些文字换行，你就在这些文字外面包裹个p标签就行，但是你在编辑器的代码里面，无论怎么换行，在浏览器中都不会起作用。
转义字符
为了说明转义字符的作用，我先演示一个小例子：我把前面为了演示空白折叠现象的代码都删除掉，直接在body里面写上这样一句话："我们知道
Document 我们知道 然后看到浏览器中的效果是这样：
是不是很奇怪？明明我写的是这样一句话："我们知道
这是因为浏览器把
那么，如何才能在浏览器中显示出
这就需要转义字符。
常见的转义字符：
也就是说，你想在浏览器中显示一个小于号，你就在代码中写，那么你想在浏览器中显示
其实更简单的写法是：
Document 我们知道 此时浏览器显示效果：
也就是说，在代码中，我用转义字符把p标签的小于号破坏掉了，这样浏览器就不会把它看做一个标签了。
也就是说，浏览器看到代码中直接写小于号、大于号的
再来看看另外两个转义字符 和©
表示空格，而且不会被折叠，前面说了，在HTML5中，文字之间的多个空格会被折叠，但是你用转义字符 来表示空格，就不会被折叠。
©表示版权符号。
接下来看看 和©的效果。
Document 我们知道 空格 哈喽 你好
版权符号 ©
我在哈喽和你好之间用转义字符 来表示空格，总共写了8个空格，不会被折叠成1个空格：
注意：转义字符不要忘记写分号。
HTML注释
任何编程语言的代码，注释都是非常重要的。它可以为自己或他人日后阅读代码提供提示。
HTML的代码，注释的语法是这样的：
HTML的注释，在vscode中，可以使用快捷键ctrl+/来输入。
HTML的注释，在代码中是这样的：
meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;Document 我们知道 空格 哈喽 你好
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ef329c6573bf5fe6599d9f2631eeb8d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/356/">«</a>
	<span class="pagination__item pagination__item--current">357/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/358/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>