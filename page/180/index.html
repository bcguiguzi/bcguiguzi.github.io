<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f47d77b5e2cd7027ea0b6fc59f1c4a38/" rel="bookmark">
			系统编程之多进程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一章 系统编程之多进程
第二章 系统编程之进程间的 管道 通信（1）
第二章 系统编程之进程间的 信号 通信（2）
第二章 系统编程之进程间的 共享内存 通信（3）
第二章 系统编程之进程间的 信号量 通信（4）
第二章 系统编程之进程间的 消息队列 通信（5） 目录
系列文章目录
前言
一、多进程
1. 相关的理论概念
2. linux提供的跟进程有关的接口函数 2.1 进程的创建
2.2 进程的退出
2.3 进程的回收
2.4 获取当前进程的ID号，获取父进程的ID号
3.在一个进程中调用执行另外一个进程
3.1 system()函数
3.2 exec函数族
补充： 1 进程的状态改变
2 线程跟进程的关系
总结
​​​​
前言 系统调用是由操作系统实现提供的所有系统调用所构成的集合即程序接口或应用编程接口 (Application Programming Interface，API)。是应用程序同系统之间的接口。系统功能调用是操作系统提供给程序设计人员的一种服务。
一、多进程 1. 相关的理论概念 进程：一个正在运行的程序，系统中就会产生一个对应的进程，动态的概念，在内存中运行。程序：编译器编译得到的二进制程序，静态的概念，存储在电脑的磁盘上。父进程：你调用fork这个函数，创建出来的就是子进程，调用fork的进程就是父进程。 子进程：fork产生的都是子进程。进程的ID号(pid)：类似于进程的"身份证号"。linux中可用 ps aux查看pid和进程名COMMAND僵尸进程：僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源.。进程的组成： 栈，堆，数据段，代码段，进程控制块(PCB--》process contrl block) 进程控制块： 指的是系统中定义的一个结构体，该结构体用于存储进程运行时候的状态信息。进程组：多个进程组成的一个集合。 // 进程控制块结构体
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f47d77b5e2cd7027ea0b6fc59f1c4a38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b721f741771159e9c4521c9356c04c/" rel="bookmark">
			java接口和内部类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组合关系 在一个类中，包含另一个类的对象，可以完成代码的复用
设计原则合成聚合复用原则：能使用组合关系实现代码的复用，尽量使用组合关系，而少用继承关系
一、接口 1.1 接口的概念 一套规范，一套行为 根据规范设计产品，可以做到适配性
like a 关系
1.2 语法格式 接口的定义
[访问修饰符] interface 接口名 { //定义的方法都是抽象方法 void usb(); //定义常量 public static final int MAX = 1; } 接口中的数据成员，全是公有的静态常量
接口里面只能定义抽象方法，抽象方法默认提供了public abstract 修饰符
类和接口的关系：class 类名 implements 接口名
在jdk1.8之前，接口中的方法，全部是公有的抽象方法
接口不是类，没有构造方法，不能实例化
接口可以实现多继承
一个接口可以被多个类实现
一个类可以实现多个接口
一个类可以在继承一个父类的同时，实现一个或多个接口 ：class 类名 extends 父类 implements 接口1[接口2....]
1.3 接口的应用 接口的多态
接口的多态：把实现类声明成接口类型
接口名 对象名 = new 实现类名();
接口和抽象类
接口不能含非抽象方法，抽象类可以
一个类可以实现多个接口，但只能继承一个直接父类
接口之间可以多继承，是一套纯粹的规范
继承是要求要有两个关系类，对于无关的可以实现同一个接口
二、内部类 2.1 简介 在一个类中，定义另一个类，称作内部类内部类可以访问外部类中的属性和方法，不需要创建外部类的对象外部类要访问内部类的属性民和方法，需要创建内部类的对象如果内部类有和外部类同名变量和方法，则内部类的变量和方法优先级更高外部类，修饰符 public default内部类，修饰符 public protected default private 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38b721f741771159e9c4521c9356c04c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de6bb12d4fd9ec95bd62c69c835a1001/" rel="bookmark">
			关于Latex参考文献引用顺序排序问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近写论文，参考文献排序一直不是顺序排序，引用参考文献方式有两种一种是将参考文献写在BIB文件里，还有一种就是直接写在TEX文件之中。今天排版的时候发现直接写在TEX文件里的话，用了\bibliographystyle{unsrt}，但是参考文献顺序并没有按照引用顺序来排，写在BIB文件里的，这时候就按顺序来排了。
直接写在TEX文件：
\begin{thebibliography}{10} \bibtem{ref1} Chaos in neurons and its application: {{Perspective}} of chaos engineering. Chaos: An Interdisciplinary Journal of Nonlinear Science,(2012)22:047511. \end{thebibliography} \"ref1" 在文章中引用的标签 直接写的好处就是所写及所见。
回到上面那个问题，直接写的话引用顺序有问题，这个时候我们既想要拥有直接写的效果，又想要按顺序排序怎么办呢。即直接将参考文献写在BIB文件中，在TeXtstudio里面 tools-Command-Bibtex运行，会生成bbl文件，我们在bbl文件上修改，bbl文件里显示的参考文献格式就是最终在文章中呈现的格式，我们可以直接在上面修改就行了。但是千万别更新，不然会恢复到没改之前的格式。
其实我们最好是写在BIB文件里，BiB文件还可以生成bbl，我们还可以修改。要是直接写在Tex文件中，万一哪里出错了，想要改，如果要重新写在BiB文件中，很麻烦。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/020501de30d59833b01b756a447166ad/" rel="bookmark">
			【CS 143 Compiler】Assignment 4.1：阅读源码 &amp; 理解任务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		汇编码布局 Spim 手册中的图示如下，编译器输出的 目标文件（Object File）布局为：
代码存放在 .text 段，而代码的总入口是 _start ，_start 会做一些准备工作(包括初始化垃圾处理程序, 初始化 Main 函数) 最后调用 Main 对象实例 中的 main 方法 开始执行 COOL 程序.
_start 作为入口符号是链接器的默认设置（也可以自定义）。参考：A Whirlwind Tutorial on Creating Really Teensy ELF Executables for Linux (muppetlabs.com)
_start 也是大多数编程语言的 runtime 的入口函数。_start 作为引导程序，包括一些准备工作，然后引导进入主程序。参考： gcc - What is the use of _start() in C? - Stack Overflow
runtime 不一定是和主程序并行的进程或线程，也包括为主程序代码作准备工作和收尾的辅助代码。
目标代码如何运行 下面就是引导程序 _start。根据 COOL 手册中提示， runtime 代码包含在 [cool root]/lib/trap.handler 中。_start 作为开始入口，必然也在其中。
.globl __start __start: li	$v0 9 # 指定系统调用代码 9: sbrk move	$a0 $zero # $a0 用来指定 sbrk 的入参, 这里值为 0, 表示分配内存大小 syscall	# sbrk: 程序启动时, 向 OS 申请一块内存, $v0 保存了这块内存的地址 move	$a0 $sp	# initialize the garbage collector li	$a1 MemMgr_REG_MASK move	$a2 $v0 jal	_MemMgr_Init	# sets $gp and $s7 (limit) 初始化了垃圾处理程序 la $t9 _exception_handler	# Exception: Set uncaught Exception Address la	$a0 Main_protObj	# create the Main object jal	Object.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/020501de30d59833b01b756a447166ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d02a60d612c4e4fecab19c6f5b12e95/" rel="bookmark">
			linux SSH服务器搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：linux SSH服务器搭建，使得windows可以通过SSH远程登录到linux系统终端，以操作linux系统，及其内部资源
环境：Oracle VM VirtualBox + Xubantu 步骤：
1.安装ssh
apt-get install openssh-server 2.xshell或者cmd上尝试进行连接，命令格式：
ssh 用户名@虚拟机ip 3.接受并保存主机秘钥：
4.连接失败后重新尝试连接，在弹出的窗口中输入linux的root密码：
效果展示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8e0e4744ac6368e470fd339d5f355bc/" rel="bookmark">
			【OpenMMLab】图片分类发展简史
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、发展简述 图片分类是CV领域的基础任务，也是检测、分割、追踪等任务的基石。简而言之，图片分类就是给定一张图片，判断其类别，一般而言所有的候选类别是预设的。
从数学上描述，图片分类就是寻找一个函数，将图片像素值映射为类别。对人类而言，丰富的先验知识让我们可以实下意识的进行判断。而对于计算机，如何根据抽象的像素数值判断其分类并不容易。
在深度学习之前，其典型做法是先人工设计特征，再通过机器学习模型或浅层网络结构进行训练。特征的设计严重依赖于经验和试验，虽然提出了HOG、SIF等特征算子，但在图像分类上的准确率并不理想。
随着神经网络的训练变得可行，人们从繁琐的特征工程中解脱出来，可以让大参数量的模型来自己完成特征的抽取和分类工作。
在 2012 年的竞赛中,来自多伦多大学的团队首次使用深度学习方法, 提出了AlexNet，一举将错误率降低至 15.3% ，而传统视觉算法的性能已经达到瓶颈，2015 年,卷积网络的性能超越人类。
围绕着加大网络深度提升预测效果、降低CNN卷积核参数量、提升模型效率等关键命题，科学家们先后提出了VGG、GoogLeNet、ResNet、EfficientNet等具有里程碑意义的模型。
在2020年之前，绝大多数的图像分类模型均借助于CNN技术，其网络架构也相对固定，包含卷积核、残差、池化单元和线性层等基本模块。
从2020年起，在自然语言处理大放异彩的Transformer模型结构开始被引入CV领域，并凭借其优异的表现迅速风靡CV圈。
另一方面，在CNN时代，绝大部分模型均是建立在ImageNet数据集上，虽然这是个大规模的1000分类数据集，但仍具有其局限性。随着Transformer在CV领域的快速发展，NLP大模型中被广泛采用的自监督、弱监督学习也开始在CV领域发力，诸如MAE（自监督）、SimCLR（对比学习）、CLIP（多模态）这样的工作极大的拓展了CV模型的外延。
二、展望 这是最好的时代，神经网络技术的快速发展极大的提高了AI的能力，让人们期待更好的未来。
这是最坏的时代，AI的发展让从业者们还是思考自己的发展。
但无论如何，历史的浪潮已经来临，无法阻挡，我们唯有去拥抱技术的发展和进步，努力成为这个浪潮里的一颗小水滴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57120980c8f45ef125808f1d41c6c1eb/" rel="bookmark">
			图像检索｜经典论文阅读｜快速入门｜综述学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这里是【来一块葱花饼】，这次带来了图像检索综述的技术学习，欢迎关注，与你分享~
本文主要参考总数论文《Deep Learning for Instance Retrieval: A Survey》（2022年更新过，主要内容来自于2020年）
感兴趣的同学，也可以先看看我的另一篇笔记，对图像检索研究做了一个评估，图像检索｜经典方法｜快速入门｜综述
文章目录 Abstract1 INTRODUCTION1.1 Summary of Progress since 20121.2 Key Challenges 2 GENERAL FRAMEWORK OF IIR3 POPULAR BACKBONE DCNN ARCHITECTURES4 RETRIEVAL WITH OFF-THE-SHELF DCNN MODELS4.1 Deep Feature Extraction4.1.1 Network Feedforward Scheme4.1.2 Deep Feature Selection4.1.3 Feature Fusion Strategies 4.2 Feature Embedding and Aggregation4.2.1 Matching with Global Features4.2.2 Matching with Local Features4.2.3 Attention Mechanism4.2.4 Hashing Embedding 5 RETRIEVAL VIA LEARNING DCNN REPRESENTATIONS5.1 Supervised Fine-tuning5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57120980c8f45ef125808f1d41c6c1eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c2d44ecfe1a8d2f2881b789ab48a70f3/" rel="bookmark">
			图像检索｜经典方法｜快速入门｜综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，这里是【来一块葱花饼】，这次带来了图像检索快速入门的技术分享，欢迎关注，与你分享~
感兴趣的同学，看完本文后，也可以看看我的一篇综述解读，更加全面，图像检索｜经典论文阅读｜快速入门｜综述学习
一.概述 1.图像检索就是以图搜图
2.主要分为两类。
第一个是追求所谓的相似，也就是从gallery里去找到相似或者相同的，常见的人脸识别，行人再识别，商品检索，草图检索，都是属于这个范畴，目前的深度学习方法，更多的就是追求如何获得更好的feature，这些领域，其实方法都是可以通用。
第二个就是传统领域需要做的一个match的问题，即如果某个建筑在一张图里出现，假使其在另外一张图里只出现一半，或者在某个角落里出现，能否再次找到。如果直接采用cnn特征，很有可能找到的轮廓相似的建筑物，而非相同的建筑物。这种情况下，一般是切成patch再分别抽特征，当然后面faster rcnn出来之后，可以在最后的feautre map上直接划分。也可以对feature map的特征做vlad或者fv的编码再检索。一般论文里的标题都是CBIR，instance retrieval这种。
3.图像检索有基于内容的检索（nlp）、也有基于图像的检索（cv），我们讨论的是cv
4.图像检索近些年没有什么进展，但是一直有人做。
二.图像检索sota模型 来自paperswithcode.com：
三.相关博客 迄今为止（2020年），图像检索(Image Retrieval)领域历年来都有哪些优秀的研究工作呢？ - WALL-E的回答 - 知乎
另外，还有一篇很好的综述：SIFT Meets CNN:A Decade Survey of Instance Retrieval–2017年发表
码字不易，都看到这里了不如点个赞哦~
这里是【来一块葱花饼】，你的点赞+收藏+关注，就是我坚持下去的最大动力~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c740ccdf01d63ab7f51bf94e1602b25f/" rel="bookmark">
			系统编程之进程间的消息队列通信（5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 第一章 系统编程之多进程
第二章 系统编程之进程间的 管道 通信（1）
第二章 系统编程之进程间的 信号 通信（2）
第二章 系统编程之进程间的 共享内存 通信（3）
第二章 系统编程之进程间的 信号量 通信（4）
第二章 系统编程之进程间的 消息队列 通信 （5） 目录
系列文章目录
一、消息队列
1、消息队列的原理
2、结构体定义
3、相关的接口函数
(1)申请创建消息队列
(2)通过消息队列收发信息
(3)删除，获取，设置消息队列的属性
4、使用实例 （1）发送端代码
（2）接收端代码
总结
一、消息队列 1、消息队列的原理 消息队列是一种先进先出的队列型数据结构，实际上是系统内核中的一个内部链表。消息被顺序插入队列中，其中发送进程将消息添加到队列末尾，接受进程从队列头读取消息。多个进程可同时向一个消息队列发送消息，也可以同时从一个消息队列中接收消息。发送进程把消息发送到队列尾部，接受进程从消息队列头部读取消息，消息一旦被读出就从队列中删除。 查看消息队列： ipcs -q 删除消息队列： ipcrm -q 消息队列的ID号
2、结构体定义 消息队列中消息本身由消息类型和消息数据组成，通常使用如下结构。
struct msg { long mtype; //消息类型
char mtext[1]; //真实的信息 }
3、相关的接口函数 (1)申请创建消息队列 #include &lt;sys/msg.h&gt; int msgget(key_t key, int msgflg); 返回值：成功 返回消息队列的ID 失败 -1 key ：键值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c740ccdf01d63ab7f51bf94e1602b25f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af6ba233c7c69d7886546aa83ea79feb/" rel="bookmark">
			新手上路~VUE3&#43;Element-PLUS dialog弹出框重置表单不生效问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		遇到问题：添加操作，dialog弹出框里面的表单 清空不生效！！！
父组件 核心代码 &lt;tempalte&gt; &lt;roleDialog ref="roleDialogRef" @refresh="getTableData()"/&gt; &lt;/template&gt; &lt;script setup lang="ts"&gt; // 打开新增弹窗 import {defineAsyncComponent, ref} from 'vue'; const roleDialogRef = ref(); // 引入组件 const roleDialog = defineAsyncComponent(() =&gt; import('/@/views/system/organization/roleJurisdiction/dialog.vue')); const onOpenAddPerson = (type: string) =&gt; { roleDialogRef.value.openDialog(type); }; // 打开修改弹窗 const onOpenEditDic = (type: string, row: RowRoleJurisdictionType) =&gt; { roleDialogRef.value.openDialog(type, row); }; &lt;/script&gt; 子组件 核心代码 &lt;script setup lang="ts"&gt; const state = reactive({ ruleForm: { name: '', // 角色名称 roleCode: '', // 角色编码 description: '',	// 角色描述 }, }) // 打开弹窗 const openDialog = (type: string, row: RowRoleJurisdictionType) =&gt; { if (type === 'edit') { state.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af6ba233c7c69d7886546aa83ea79feb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e6f648a85bc52620a3169e8ea4fc889/" rel="bookmark">
			git 合并提交
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先输入git log接着输入git rebase -i &lt;commit id&gt;接着在log的pick修改为squash，默认在最下方(最新的提交commit id)修改为squash,其中squash为保留当前提交，同时把分支上一个与当前squash的有冲突用git status查看文件冲突，合并冲突之后，git add &lt;有冲突文件&gt;接着继续合并冲突git rebase --continue如果有冲突继续步骤3~步骤5，一直到上传successfully最后查看修改的log列表，也就是git log如果没有问题就输入git push --force origin &lt;分支名称&gt; 如果只是合并不是最新提交的几个分支，也是git rebase -i &lt;要合并的commit id&gt; 同时显示log ,将 相关的commit的pick 修改为squash 即可，然后重复步骤3--步骤5， 没问题之后就继续步骤6~步骤7 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d1c1c8c4c11d6d8c25a0615036ad11/" rel="bookmark">
			ElementUI中Dropdown 下拉菜单el-dropdown-item 点击事件无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直接在el-dropdown-item上添加click事件，点击后没有任何反应
在click后添加native修饰符，则可解决问题。代码如下
在给Vue组件（el-dropdown-item就是一个组件）绑定事件的时候，必须加上native修饰符才能生效，native可以监听根元素的原生事件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/690f381558a1617a902535863059f814/" rel="bookmark">
			手把手教Anaconda，pytorch、tensorflow安装、虚拟环境搭建及jupyter、pycharm编译器配制（后附安装包供下载）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于深度学习的初学者，最头疼的是入门时的环境配制，经过自己几轮的卸载与安装，将最常用的安装版本及编辑器进行整理，分享各位，同时也方便自己以后回头复习。
我自己的电脑是拯救者Y7000，查看电脑显卡类型，右击电脑属性，点击设备管理器，即可产看显卡类型。
查看CUDA版本命令，键盘Win+R, 输入cmd，按回车，输入nvidia-smi，回车即可。 可以看到我这里的CUDA版本号最高支持是11.7，后面下载CUDA的时候小伙伴们一定要注意自己下载的版本低于或等于自己电脑CUDA版本。有了这些硬件准备，开始安装吧。 1 Anaconda安装 首先查看自己是否安装了conda，键盘Win+R, 输入cmd，按回车，输入conda -V，查看版本号。
这里我已经安装好，下面将其卸载掉，重新安装。
进入应用，找到Anaconda直接将其卸载掉。
卸载后，再次查看版本，输入conda -V，conda已经卸载完成。
下载Anaconda,直接搜索，进入官网， 依次点击，选择与自己电脑对应的版本，进行下载。
已经下好conda安装文件
右击，以管理员身份运行，进行安装。
默认安装路径可以自己将C盘改成D盘
一定要勾选添加环境变量！点击Install，安装
等待安装.......
这里两个方框都不勾选，防止打开其他网页。
再次查看Anaconda是否安装成功
恭喜你，到这一步Anaconda已经成功安装完成！
2 Anaconda创建虚拟环境 进行深度学习时会调用各个不同的库，或者使用不同的深度学习框架pytorch或tensorflow，这时我们需要创建不同的虚拟环境，用于安装对应的深度学习框架。
首先使用conda创建虚拟环境 输入activate，激活，进入base环境。
输入conda create -n pytorch1 python=3.7 #指定python版本号创建名为pytorch1虚拟环境
输入y
创建完成
base环境输入conda activate pytorch1，进入创建的虚拟环境。
可以在创建的环境查看python的版本，输入python，为3.7.1正是我们创建的版本。
exit()，退出，输入conda deactivate，回到base环境，查看python版本，是3.7.4和Anaconda的版本对应。
同理，创建tensorflow虚拟环境也是如此，命名为自己喜欢的名字，如 tf1 即可。
3 编译器（IDLE）pycharm的安装 建议安装pycharm，笔者尝试了vscode，不能调用jupyter，于是放弃，可以解决的小伙伴，还请评论区指导。
直接搜索pycharm官网。
学生经过认证可以下载专业版（文末附已下载好的安装包），这里只是介绍如何下载
找到安装包，右键以管理员身份安装
可以改路径安装在D盘
安装完毕，找到pycharm运行一下
找到上一步创建虚拟环境的路径，我的的 D:\Anaconda\envs\pytorch1\python.exe，选择解释器
测试代码
print('hello world') a=2 b=3 c=a*b print(c) 4 CUDA安装（10.1版本，安装版本一定低于自己电脑CUDA版本） 如果已经安装，请卸载，只需保留NVIDIA Geforce, NVIDIA PhysX, NVIDIA图形驱动程序。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/690f381558a1617a902535863059f814/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1badeb0be74264f3c7464531df84606/" rel="bookmark">
			【寒假训练/Java】贪心专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 题目链接题目列表快输A - 最小生成树B - [USACO 2006 Oct S]Fence RepairC - moneyD - 大吉大利，今晚吃鸡——枪械篇E - 世界上最可爱的珂朵莉F - 牛牛的排序G - 牛牛的朋友H - 货币系统（完全背包）I - [CQOI2014]通配符匹配（DP&amp;字符串哈希）J - 牛牛学括号K - [HAOI2008] 糖果传递（数学&amp;贪心）L - 青蛙（二分）M - 吃货（二分） 题目链接 贪心专题-牛客链接
比赛密码：202302010213
题目列表 快输 import java.io.*; import java.util.*; public class Main { public static void main(String[] args) { out.flush(); } static class FastReader{ BufferedReader br; StringTokenizer st; String tmp; public FastReader() { br=new BufferedReader(new InputStreamReader(System.in)); } String next() { while(st==null||!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1badeb0be74264f3c7464531df84606/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/787a5f215300566823ea75cb4b354379/" rel="bookmark">
			throw 和 throws 的区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、throw：是真实抛出一个异常。
二、throws：是声明可能会抛出一个异常
区别：
区别一：throw 是语句抛出一个异常；throws 是方法抛出一个异常；
throw语法：throw &lt;异常对象&gt;
在方法声明中，添加throws子句表示该方法将抛出异常。
throws语法：[&lt;修饰符&gt;]&lt;返回值类型&gt;&lt;方法名&gt;（[&lt;参数列表&gt;]）[throws&lt;异常类&gt;]
其中：异常类可以声明多个，用逗号分割。
区别二：throws可以单独使用，但throw不能；
区别三：throw要么和try-catch-finally语句配套使用，要么与throws配套使用。但throws可以单独使用，然后再由处理异常的方法捕获。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c2564c2459f6d9cf0d2860fbbf9391/" rel="bookmark">
			vite vue-quill 构建基本案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		示例图 注意事项：如果没有使用后端接口时，插入图片的时候总是会插在最前面，使用了就不会了
Vue 前端 安装版本 "dependencies": { ... "@ssumo/quill-resize-module": "^1.0.1", "@vueup/vue-quill": "^1.0.1", "quill-image-paste-module": "^1.0.6", ... }, 安装Quill相关 &gt; npm install @vueup/vue-quill@1.0.1 &gt; npm install quill-image-paste-module@1.0.6 &gt; npm install @ssumo/quill-resize-module@1.0.1 之所以使用 @vueup/vue-quill ,是因为使用 vue-quill-editor 老是有一堆报错
imports of undefined，undefined (reading 'register')之类的
参考文档 vue-quill 基本格式案例
https://blog.csdn.net/weixin_44892327/article/details/127625100
https://blog.csdn.net/qq_33674679/article/details/128128291
自定义上传图片到服务器、粘贴图片上传至服务器、拖拽图片上传至服务器的功能
https://www.npmjs.com/package/quill-image-paste-module
图片、视频缩放大小
https://github.com/scrapooo/quill-resize-module
具体使用方法见参考文档，写的很详细了
main.js import { createApp } from 'vue'; import App from './App.vue'; // 导入vue富文本编辑器 import { QuillEditor } from '@vueup/vue-quill' import '@vueup/vue-quill/dist/vue-quill.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c2564c2459f6d9cf0d2860fbbf9391/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29bdd9ac71eb9d65912c22dd80eb1cdf/" rel="bookmark">
			lua中的逻辑运算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 lua中的逻辑运算只有：and or not
not的结果总是只返回true或false，例如
local a=10 print(not a) 打印的结果是 false local b=nil 或者 local b=false print(not b) 打印的结果是true and和or支持短路运算规则，只是运算结果不是true或false，而是运算符左右两边的值，也就是说结果是最后一次进行判断的那个值，例如
print(10 and 20) --结果为20，因为10为真，and会继续计算后面的20 print(nil and 20) --结果为nil，因为nil为假，and提前结束运算 print(10 or 20) --结果为10，因为10为真，or提前结束运算 print(nil or 20) --结果为20，因为nil为假，or会继续运算 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf1dba52c11f59d788bf18cfd62eac6/" rel="bookmark">
			字符串乘方（c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个字符串 a 和 b，我们定义 a×b 为他们的连接。
例如，如果 a=abc 而 b=def， 则 a×b=abcdef。
如果我们将连接考虑成乘法，一个非负整数的乘方将用一种通常的方式定义：a0=``(空字符串)，a(n+1)=a×(an)。
输入格式 输入包含多组测试样例，每组测试样例占一行。
每组样例包含一个由小写字母构成的字符串 s，s 的长度不超过 100，且不包含空格。
最后的测试样例后面将是一个点号作为一行。
输出格式 对于每一个 s，你需要输出最大的 n，使得存在一个字符串 a，让 s=an。
输入样例： abcd aaaa ababab . 输出样例： 1 4 3 c++代码：
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; int main() { string a; while(cin&gt;&gt;a,a!=".") { int len=a.size(); for(int i=len;i&gt;0;i--) { if(len%i==0)//找到最大公约数i，此时i为组数 { int m=len/i;//每组数据有m个字符 string c; string b=a.substr(0,m);//截取第一段平分为i组的字符串 for(int j=0;j&lt;i;j++) c+=b;//把第一组字符串乘i倍，也就是i组相加为c if(c==a)//判断相加后的c与原字符串a是否相等 { cout&lt;&lt;i&lt;&lt;endl; break; } } } } return 0; } c语言代码以后补充
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac6c97fbe89781b1a00828701a9af3d0/" rel="bookmark">
			如何采用conda配置python虚拟环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、创建python虚拟环境二、配置刚创建的虚拟环境三、将虚拟环境配置到相应项目 一、创建python虚拟环境 首先选中要配置环境的文件
如下：
在此处输入cmd按回车
此处我创建一个环境名为hands3dtext，环境版本为3.7.2的初始环境
conda create -n hands3dtext python==3.7.2 创建成功如下：
二、配置刚创建的虚拟环境 首先激活刚创建的虚拟环境
conda activate hands3dtext 如上前面小括号显示表示激活成功，此时正处于虚拟环境
接下来就可以安装所需的一切包和库
注意安装前要确认安装cpu还是gpu的版本
此处我需要安装mediapipe
注意：安装mediapipe首先安装opencv,终端执行
conda install opencv-contrib-python 上一条可能出错可以采用下面这样采用国内清华镜像源
pip install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple 然后安装mediapipe，终端执行
conda install mediapipe 我还需要安装tqdm模块（根据个人需要）
conda install tqdm 如果觉得安装太慢可以切换国内镜像源进行安装，执行如下命令即可
conda config --remove-key channels conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/pytorch/ conda config --set show_channel_urls yes pip config set global.index-url https://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac6c97fbe89781b1a00828701a9af3d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f56aaacbd127db1cfac093552c5c4a4/" rel="bookmark">
			Elasticsearch学习-父子文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		elasticsearch父子文档处理 join 一、背景二、需求三、前置知识四、实现步骤 1、创建 mapping2、添加父文档数据3、添加子文档4、查询文档 1、根据父文档id查询它下方的子文档2、has_child返回满足条件的父文档3、has_parent返回满足父文档的子文档 五、Nested Object 和 join 对比六、参考文档 一、背景 在我们工作的过程中，有些时候我们需要用到父子文档的关系映射。**比如：**一个问题有多个答案、一本书籍有多个评论等等。此处我们可以使用 es 的 jion数据类型或 nested来实现。此处我们使用join来建立es中的父子文档关系。
二、需求 我们需要创建一个计划(plan)，计划下存在活动(activity)和书籍(book)，书籍下存在评论(comments)。
即层级结构为：
plan / \ / \ activity book | | comments 1234567 三、前置知识 每一个mapping下只能有一个join类型的字段。父文档和子文档必须在同一个分片(shard)上。即： 增删改查一个子文档都必须和父文档使用相同的 routing key。每个元素只能有一个父，但是可以存在多个子。可以为一个已经存在的 join 字段增加新的关联关系。可以为一个已经是父的元素增加一个子元素。 join数据类型在elasticsearch中不应该像关系型数据库那种使用。而且has_child和has_parent都是比较消耗性能的。
只有当 子的数据 远远大于 父的数据时，使用join才是有意义的。比如：一个博客下，有多个评论。
四、实现步骤 1、创建 mapping PUT /plan_index { "settings": { "number_of_shards": 3, "number_of_replicas": 1 }, "mappings": { "properties": { "plan_id":{ "type": "keyword" }, "plan_name":{ "type": "text", "fields": { "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f56aaacbd127db1cfac093552c5c4a4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/179/">«</a>
	<span class="pagination__item pagination__item--current">180/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/181/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>