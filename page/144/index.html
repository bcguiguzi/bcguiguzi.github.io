<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13546245f11d8e562448baa0dcc398de/" rel="bookmark">
			vue3中的watch和watchEffect
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两种写法的区别是：
watch 需要你明确指定依赖的变量，才能做到监听效果。
而 watchEffect 会根据你使用的变量，自动的实现监听效果。
watch: // Vue3 的写法 &lt;template&gt; &lt;div&gt;{{ count }}&lt;/div&gt; &lt;div&gt;{{ anotherCount }}&lt;/div&gt; &lt;button @click="onClick"&gt; 增加 1 &lt;/button&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, watch } from 'vue'; const count = ref(1); const onClick = () =&gt; { count.value += 1; }; const anotherCount = ref(0); // 注意这里 // 需要在这里， // 明确指定依赖的是 count 这个变量 watch(count, (newValue) =&gt; { anotherCount.value = newValue - 1; }) &lt;/script&gt; watchEffect // Vue3 的写法 &lt;template&gt; &lt;div&gt;{{ count }}&lt;/div&gt; &lt;div&gt;{{ anotherCount }}&lt;/div&gt; &lt;button @click="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13546245f11d8e562448baa0dcc398de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71847bfbb2a625ad79b5fe721289f0df/" rel="bookmark">
			Android13蓝牙 停用绝对音量功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android13蓝牙 停用绝对音量功能 文章目录 Android13蓝牙 停用绝对音量功能一、前言二、代码实现分析过程1、查看SettingsLib源码资源2、查看原生Setitntgs 相关字符（1）xml 布局文件中的显示（2） java 代码文件中的控制串口上控制： 三、总结 一、前言 Android13 Tv大屏设备出现了连接蓝牙后，蓝牙音箱声音特别大，并且调节蓝牙声音后，断开连接，再重新连接蓝牙声音还是很大。
从网上看到是可以打开设置里面的 “停用绝对音量功能” 进行规避这个问题。
看下网上对”停用绝对音量功能“的说明：
有时连接了蓝牙耳机，会出现声音突然变大的情况，这就是开启了绝对音量功能的原因。 如果“停用绝对音量功能”开启，那么蓝牙耳机的音量和手机的音量就是相互独立的。 如果“停用绝对音量功能”关闭，那么蓝牙耳机的音量和手机的音量就是相互同步的。(默认) 下面是原生Settings 中的字符串显示和图片：
上面的画面具体位置在开发者选项中，不过也有的手机是没有这个选项的。比如华为手机！
具体字符串：
停用绝对音量功能 停用蓝牙绝对音量功能，以防在连接到远程设备时出现音量问题（例如音量高得让人无法接受或者无法控制音量等）。 网上看了下，没几个对实现控制代码进行分析的，刚好看了一圈代码，顺便分享一下。
二、代码实现分析过程 开发者选项中是有这个选项的，但是在Settings 里面未找到 开关的字符串，不过通过SettingsLib 工程可以看到对应的字符串。
1、查看SettingsLib源码资源 文件位置和对应资源：
framework\base\packages\SettingsLib\res\values-zh-rCN\strings.xml &lt;string name="bluetooth_disable_absolute_volume" &gt;"停用绝对音量功能"&lt;/string&gt; 2、查看原生Setitntgs 相关字符 （1）xml 布局文件中的显示 文件位置和对应布局文件：
packages\apps\Settings\res\xml\development_settings.xml &lt;SwitchPreference android:key="bluetooth_disable_absolute_volume" android:title="@string/bluetooth_disable_absolute_volume" android:summary="@string/bluetooth_disable_absolute_volume_summary" /&gt; （2） java 代码文件中的控制 Java文件位置：
packages\apps\Settings\src\com\android\settings\development\BluetoothAbsoluteVolumePreferenceController.java private static final String BLUETOOTH_DISABLE_ABSOLUTE_VOLUME_KEY = "bluetooth_disable_absolute_volume"; 所以 控制“停用绝对音量功能”的代码基本可以确定是在 BluetoothAbsoluteVolumePreferenceController.java 这个类里面了。
继续查看Java文件，发现代码：
//prop字符串 static final String BLUETOOTH_DISABLE_ABSOLUTE_VOLUME_PROPERTY = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71847bfbb2a625ad79b5fe721289f0df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4d2fa68efe3ccecabd07aaaa5fb8430/" rel="bookmark">
			AttributeError: partially initialized module ‘cv2‘ has no attribute ‘gapi_wip_gst_GStreamerPipeline‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于opencv报’gapi_wip_gst_GStreamerPipeline’ 错误
说明
在使用opencv时报
AttributeError: partially initialized module ‘cv2’ has no attribute ‘gapi_wip_gst_GStreamerPipeline’ (most likely due to a circular import)
原因
在更新安装其他库的时候把opencv更新到了最新的版本
解决方案
降低opencv版本
#查看opecv版本 pip install opencv-python== ERROR: Could not find a version that satisfies the requirement opencv-python== (from versions: 3.4.0.14, 3.4.8.29, 3.4.9.31, 3.4.9.33, 3.4.10.35, 3.4.10.37, 3.4.11.39, 3.4.11.41, 3.4.11.43, 3.4.11.45, 3.4.13.47, 3.4.14.51, 3.4.14.53, 3.4.15.55, 3.4.16.57, 3.4.16.59, 3.4.17.61, 3.4.17.63, 3.4.18.65, 4.1.2.30, 4.2.0.32, 4.2.0.34, 4.3.0.36, 4.3.0.38, 4.4.0.40, 4.4.0.42, 4.4.0.44, 4.4.0.46, 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4d2fa68efe3ccecabd07aaaa5fb8430/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a66617163e4548ea740a32a67d8686e/" rel="bookmark">
			Linux环境下运行Tess4j进行OCR识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Tess4j&amp; Tesseract OCR简介 Tess4J 是一个基于 Tesseract OCR 引擎的 Java 接口，可以用来识别图像中的文本。Tesseract 是一个由 Google 开发的开源 OCR 引擎，可以识别多种语言的文本。Tess4J 将 Tesseract 引擎的优势和简单性与 Java 的可移植性和易用性相结合，是一个非常强大的 OCR 解决方案。
Tess4J 提供了丰富的 API，可以很方便地进行图像处理和文本识别。它支持多种格式的图像文件，包括 BMP、PNG、JPEG、GIF 和 TIFF 等格式。Tess4J 还可以进行图像预处理，例如裁剪、缩放和二值化等，以提高文本识别的准确性。
Tess4j官网：https://tess4j.sourceforge.net/usage.html
Tesseract OCR代码库：https://github.com/tesseract-ocr/
2.Tess4j的简单案例 引入依赖 首先引入maven依赖：
&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.tess4j&lt;/groupId&gt; &lt;artifactId&gt;tess4j&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; 代码案例 下面是一段简单的代码案例：
// 新建工具对象 ITesseract iTesseract = new Tesseract(); // 设置语言 这里设置简体中文 iTesseract.setLanguage("chi_sim"); // 设置训练数据路径 iTesseract.setDatapath("D:\\tessdata"); // 提取图片中的文字 String result = iTesseract.doOCR(new File("D:\\test.png")); 上面设置了语言是简体中文，需要去tesseract-ocr语言库中下载预训练数据。
下载语言库 语言库下载地址：https://github.com/tesseract-ocr/tessdata
这里下载简体中文(chi_sim.traineddata)预训练数据。
3.Windows上运行ITesseract类 经过上面步骤后，可以在Windows上直接运行代码案例，因为Tess4J在Windows上是开箱即用的。下面看一下原因。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a66617163e4548ea740a32a67d8686e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c18c9eea56da14828dd13d665ca89fe5/" rel="bookmark">
			Linux环境搭建OpenCV运行java-cv代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Windows系统运行java-cv代码 安装OpenCV 在Windows安装OpenCV比较简单，进入官网，进入releases，选择Windows版本，下载执行文件，然后一步一步执行可视化安装即可。
OpenCV官网：https://opencv.org
安装完成后，安装目录如下：
进入build目录:
进入java目录：
可以看到opencv-460.jar包，这个后续会用到。
进入x64目录：
这里的opencv_java460.dll是后续Native类会调用的动态链接库。
运行java-cv进行人脸检测 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.bytedeco&lt;/groupId&gt; &lt;artifactId&gt;javacv&lt;/artifactId&gt; &lt;version&gt;1.5.8&lt;/version&gt; &lt;/dependency&gt; 添加opencv-460到类路径 打开IDEA的工程结构界面，将opencv-460.jar包添加到依赖库中。
配置opencv_java460.dll 后续代码需要加载dll文件，所以需要将opencv_java460.dll放到path路径中，Windows系统，直接放到C:\Windows\System32目录即可。
代码案例 下面的代码进行人脸检测：
// 加载本地库 System.loadLibrary(Core.NATIVE_LIBRARY_NAME); // 新建人脸识别类对象 CascadeClassifier faceDetector = new CascadeClassifier("D:\\haarcascade_frontalface_alt.xml"); // 原始照片 Mat image = Imgcodecs.imread("D:\\test.png"); MatOfRect faceDetections = new MatOfRect(); // 进行人脸检测 faceDetector.detectMultiScale(image, faceDetections); 上面代码主要分为四个步骤：
从系统中加载native库创建人脸识别类对象读取图片进行人脸检测 OpenCV 库中的人脸检测功能，需要用到haarcascade_frontalface_alt.xml 特征分类器文件，该文件包含了一系列针对人脸的分类器，可以用于识别图像或视频中的人脸区域。
代码调用链分析 下面来分析一下下面这段代码(加载本地库)的调用链路：
System.loadLibrary(Core.NATIVE_LIBRARY_NAME); 通过libname加载本地库：
public static void loadLibrary(String libname) { Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname); } 查看libname取值：
public static final String NATIVE_LIBRARY_NAME = getNativeLibraryName(); private static String getNativeLibraryName() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c18c9eea56da14828dd13d665ca89fe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5670294a68185167a941be4ee3aff24/" rel="bookmark">
			基于HTTP/HTTPS协议的京东 API接口的接入示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		京东API是一个基于HTTP/HTTPS协议的RESTful API，用于访问京东的开放数据资源。开发者可以利用该接口获取商品、价格、库存、运费、评价等信息，并且可以进行订单交易、物流跟踪等操作。接入京东API前，需要先申请API Key和Secret Key，申请地址为：https://jos.jd.com/apiconsole/register/index.action 。
在获取到API Key和Secret Key之后，可以按照以下步骤进行接入：
1.建立连接并授权验证
首先，在请求京东API之前，需要建立连接并进行授权验证。授权方式有两种：OAuth2.0 和 AppKey验证。根据实际情况选择适合自己的验证方式。具体步骤如下：
(1)OAuth2.0授权验证
使用OAuth2.0授权验证方式时，需要先获取Access Token。获取方式包括授权码模式、密码模式、刷新令牌模式等。授权码模式和密码模式可参考官方文档进行获取。获取Access Token后，就可以使用该Token进行API接口访问。请求示例：
```python
import requests
# 设置请求头部信息
headers = {"Authorization": "Bearer &lt;access_token&gt;"} # 构造请求URL
url = "https://api.jd.com/routerjson" # 构造请求参数
params = { "method": "jingdong.afsservice.channel.get", "app_key": "your_app_key", "timestamp": "2018-07-31 16:54:34", "v": "2.0", "360buy_param_json": "{\"type\": \"afs_reason\"}" } # 发送请求
response = requests.post(url, params=params, headers=headers) ``` (2)AppKey验证
使用AppKey验证方式时，需要在请求头部信息中传递AppKey和AppSecret。请求示例：
```python import requests # 设置请求头部信息 headers = {"Content-Type": "application/x-www-form-urlencoded", "AppKey": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5670294a68185167a941be4ee3aff24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7398c46dedaeeaa276c26c9148234a0/" rel="bookmark">
			kali-渗透攻击tomcat服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		kali-渗透攻击tomcat服务：
Apache tomcat的理解：
Apache tomcat是世界上使用最广泛的java web应用服务器之一，绝大多数人都会使用tomcat的默认配置。默认配置中会有一个向外网开放的web应用管理器，管理员可以利用它在服务器中启动、停止、添加和删除应用。
1.打开靶场中的Tomcat Server 在kali linux的firefox浏览器中输入http://192.168.193.132:8080/manager/html
靶机中有一个Tomcat Server服务在运行，端口是8080，通过浏览器进行访问。
2.在Kali linux中启动msf并加载爆破模块 打开msfconsole控制台
命令：use auxiliary/scanner/http/tomcat_mgr_login
3.下面对刚刚使用的Tomcat_mgr_login模块进行详解： 1 **BALNK_PASSWORDS**:为每个账号提供一个空密码测试 2 **PASSWORD**:设置这个可以只针对该密码进行多用户测试 3 **PASS_FILE**:输入你想要使用的密码字典路径 4 **Proxies**:为了避免被检测到源地址，可以使用代理功能 5 **RHOSTS**:填写要被测试的主机地址（可以是多个，以空格分隔。也可以是一个清单文件） 6 **RPORT**:设置目标Tomcat运行的端口 7 **STOP_ON_SUCCESS**:当破解成功后停止攻击 8 **TARGERURI**:可设置管理界面的目录路径 9 **USERNAME**:设置要测试的用户名字（可以是单个，也可以是一个字典）10**USER_PASS_FILE**:使用 "用户名/密码" 格式的字典文件11**USER_AS_PASS**:尝试使用测试中的用户名作为密码 GetShell
4.如何理解show options 1.显示选项 backtrack 渗透命令 svn update 升级 show options 显示选项 show payloads 显示装置 2.查看选项 . setg function 全局设置 show options 查看选项 show advanced 查看高级选项 ..
show options —— 显示需要设置的项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e7398c46dedaeeaa276c26c9148234a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0ffd3e12cab6614aef3743b2b21b174/" rel="bookmark">
			微信小程序反编译教程获取源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景： 开发的时候需要一些素材，发现小程序(.wxapkg)里有一些图标或背景图很好看，但又没办法直接获取到（小程序里如果打包时候直接集成进去的fiddler是无法监听到网络请求的），于是研究小程序结构，决定通过代码解放小程序...
开工 以 厦门植物园 小程序为例
首先打开电脑上小程序的位置
注：为了便于找到可以把小程序先移除再重新打开，这样就会在本地出现一个最新日期的小程序文件
下载文章上部的微信小程序 反编译小工具
点击选择文件按钮选择对应的小程序目录如下图
点击 打开按钮即可解压，下图中的文件夹即是 小程序反编译后的代码
代码解析及原理 这个反编译的原理就是 利用这个文件的一个 组织结构，文件的存储结构进行分析，这个原理是网上网友（代码果）分享的，如果一般人 真的无法知晓这个小程序的编译结构！
第一步 重新组织文件结构
string fileName = openFileDialog.FileName; byte[] source = this.FileContent(fileName); string miniAppFlag = Encoding.UTF8.GetString(source.Take(6).ToArray&lt;byte&gt;()); this.textBox2.AppendText("文件选择：" + fileName + "\r\n"); bool needUnEncrypt = miniAppFlag == "V1MMWX"; string appId = this.GetStr(fileName, "Applet\\\\", "\\\\"); if (needUnEncrypt) { if (string.IsNullOrEmpty(appId)) { this.textBox2.AppendText("疑似非小程序,请重新选择！\r\n"); } else { this.outFileName = "\\" + appId + ".wxapkg"; this.textBox2.AppendText("文件解密中...\r\n"); string salts = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0ffd3e12cab6614aef3743b2b21b174/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b67e173f8ab53ab55b2da70a311e84c/" rel="bookmark">
			【数据库】MySQL的ReadView
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：【数据库】MySQL的ReadView_thesprit的博客-CSDN博客_mysql readview
MySQL的ReadView 前言
1、根据事务的隔离级别，我们已经知道读未提交、读已提交、可重复读、串行化，随着隔离级别的加强，能解决脏写、脏读、不可重复读、幻读的问题。
2、InnoDB 是 MySQL(mysql-5.1版本后) 默认的存储引擎，InnoDB 默认的隔离级别就是可重复读。在这个隔离级别下，开启事务之后，多次读写同一行数据，读到的值永远是一致。
3、当 MySQL 执行写操作之前，会把即将被修改的数据记录到 undo log 日志里面。MySQL可从 undo log 日志中，读取到原插入、修改、删除之前的值，最终把值重新变回去，这就是回滚操作。
undo log 版本链
1、undo log 版本链是基于 undo log 实现的。undo log 中主要保存了数据的基本信息，比如说日志开始的位置、结束的位置，主键的长度、表id，日志编号、日志类型
此外，undo log 还包含两个隐藏字段 trx_id 和 roll_pointer。trx_id 表示当前这个事务的 id，MySQL 会为每个事务分配一个 id，这个 id 是递增的。roll_pointer 是一个指针，指向这个事务之前的 undo log。
2、例子
执行：
INSERT INTO student VALUES (1, '张三'); 产生：
继续执行：
UPDATE student SET name='李四' WHERE id=1; 产生：
继续执行：
UPDATE student SET name='王五' WHERE id=1; 产生：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b67e173f8ab53ab55b2da70a311e84c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e340fd96b6c67ab15bb73984c26773a7/" rel="bookmark">
			leetcode 222. 完全二叉树的节点个数 分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cd7481a881c0b2646bbb071e2e0b28/" rel="bookmark">
			面试官95%会问的接口测试知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		接口测试最近几年被炒的火热了，越来越多的测试同行意识到接口测试的重要性。接口测试为什么会如此重要呢？ 主要是平常的功能点点点，大家水平都一样，是个人都能点，面试时候如果问你平常在公司怎么测试的，你除了说点点点，还能说什么呢，无非就是这个项目点完了点那个项目， 这就是为什么各行各业的只要手指能点得动的人都来转行软件测试了。面试的时候面试官希望你除了点点点，还能更深入一点的思考页面上看不到的功能，也就是接口测试了。接口是看不见的，但是可以访问！
HTTP, HTTPS协议 什么是DNS DNS是域名系统（Domain Name System），DNS是用来做域名解析的，它会在你上网输入网址后，把它转换成IP，然后去访问对方服务器；没有它，你想上百度就要记住百度的IP，但有了DNS的处理，你只需要记住对应网站的域名，即网址就可以了。
HTTP协议 HTTP协议：超文本传输协议，是基于TCP的协议，默认为80端口。它的作用是用来规定客户端和服务器的数据传输格式。是一种用于请求与响应模式的、无状态、无连接 的应用层协议。 由于HTTP协议是一种请求-响应模式，所以一般需要关注HTTP请求和HTTP响应。
怎么抓取HTTPS协议 使用fiddler工具抓取HTTPS，具体操作请查看文末领取教程
说出请求接口中常见的返回状态码 1xx -- 信息提示（表示临时的响应。客户端在收到常规响应之前，准备接收一个或多个1xx响应）
2xx -- 成功（表明服务器成功地接受了客户端请求）
3xx -- 重定向（客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求）
4xx -- 客户端错误（发送错误，客户端有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份证验证信息）
5xx -- 服务器错误（服务器由于遇到错误而不能完成该请求）
常见的返回码有：
200 OK - [GET]：服务器成功返回用户请求的数据
201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功
202 Aceepted - [*]：表示一个请求已经进入后台排队（异步任务）
204 NO CONTENT - [DELETE]：用户删除数据成功
400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作
401 Unauthorized -[*] ：表示用户没有权限（令牌、用户名、密码错误）
403 Forbidden -[*] ：表示用户得到授权（与401错误相对），但是访问被禁止
404 NOT FOUND -[*]：用户发出的请求针对得到是不存在的记录，服务器没有进行操作，该操作是幂等的
406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60cd7481a881c0b2646bbb071e2e0b28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e1c85bf5dc847e05b62ab58a1462e75/" rel="bookmark">
			分布式网络通信框架（十二）——zookeeper简介与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 zookeeper（后文简称zk）提供功能有：服务注册中心、全局服务命名、以及分布式锁。
RPC服务会被发布到不同的服务器上，本项目zk的作用就是找到某一个RPC服务在哪一个服务器上，提供服务注册发现功能。
zk的数据如何组织？ znode 每个znode节点都只存储简单的byte字节数组，一般存少量状态信息，默认数据上限为1MB，我们项目中用来存服务的IP:PORT.
zk的Client常用的命令 Client常用的命令有ls 、get、 create、set 、delete
服务注册之后，注册中心和各个服务实例直接建立Session，要求实例们定期发送心跳，有一个心跳计数（定时增加），收到实例心跳后心跳计数恢复，一旦心跳计数超过某一特定值，则认为实例挂了，删除该实例。
临时性ephemeral节点，rpc节点超时未发送心跳消息，zk会自动删除临时性节点；
永久性节点，rpc节点超时未发送心跳消息，zk不会自动删除永久性节点。
zk会在在1/3的Timeout时间向服务提供方发送ping心跳消息，可以使用tcpdump进行测试：sudo tcpdump -i lo port 2181
zookeeper安装和基本使用 tar -zxvf zookeeper-3.4.10.tar.gz jyhlinux@ubuntu:~/share/zookeeper-3.4.10$ cd conf/ jyhlinux@ubuntu:~/share/zookeeper-3.4.10/conf$ mv zoo_sample.cfg zoo.cfg 使用vim修改zk的配置文件zoo.cfg，将数据目录改为自己指定的路径
/home/jyhlinux/share/zookeeper-3.4.10/data 运行zk的Server端程序（后台运行）
jyhlinux@ubuntu:~/share/zookeeper-3.4.10/bin$ ./zkServer.sh start 运行zk的Client程序
jyhlinux@ubuntu:~/share/zookeeper-3.4.10/bin$ ./zkCli.sh zk的Client常用的命令有：ls、get、 create、set 、delete
使用例子：
[zk: localhost:2181(CONNECTED) 0] ls / [zookeeper] # 查看 zookeeper目录 下有一个子节点 quota [zk: localhost:2181(CONNECTED) 5] ls /zookeeper [quota] #获取 /zookeeper/quota节点信息， 数据长度为0，孩子数为0 [zk: localhost:2181(CONNECTED) 9] get /zookeeper/quota cZxid = 0x0 ctime = Thu Jan 01 08:00:00 CST 1970 mZxid = 0x0 mtime = Thu Jan 01 08:00:00 CST 1970 pZxid = 0x0 cversion = 0 dataVersion = 0 aclVersion = 0 ephemeralOwner = 0x0 dataLength = 0 numChildren = 0 # 根目录下创建了mprpc节点，值为20 [zk: localhost:2181(CONNECTED) 10] create /mprpc 20 Created /mprpc # zk删除父节点需要先把子节点删除 [zk: localhost:2181(CONNECTED) 2] create /mprpc/servic 22 Created /mprpc/servic [zk: localhost:2181(CONNECTED) 3] delete /mprpc Node not empty: /mprpc [zk: localhost:2181(CONNECTED) 4] delete /mprpc/servic [zk: localhost:2181(CONNECTED) 5] delete /mprpc [zk: localhost:2181(CONNECTED) 6] # zk不能一次创建多级目录，要逐级创建 [zk: localhost:2181(CONNECTED) 10] create /userServiceRpc 22 Created /userServiceRpc [zk: localhost:2181(CONNECTED) 14] create /userServiceRpc/service_1/service_1_1 22 Node does not exist: /userServiceRpc/service_1/service_1_1 [zk: localhost:2181(CONNECTED) 15] create /userServiceRpc/service_1 11 Created /userServiceRpc/service_1 [zk: localhost:2181(CONNECTED) 16] create /userServiceRpc/service_1/service_1_1 22 Created /userServiceRpc/service_1/service_1_1 zk的原生开发API编译安装 ~/share/zookeeper-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e1c85bf5dc847e05b62ab58a1462e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58b50dea22af8d6c31975f9e9f179c56/" rel="bookmark">
			申请虚拟VISA卡ONEKEY保姆级教程来了！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面：本人之前为了亲自开通plus会员找了很多教程，发现目前的教程都有些不太详细，也踩了不少坑，所以为了广大酷友顺利用上强大的GPT4，我根据本人的开通经验做了一篇细致的教学
开通前我们需要准备以下工具：OneKey Card、okx、Google 身份验证器
说明：
OneKey Card是一款Visa虚拟卡，用于支付账单，该卡需要虚拟货币进行充值
okx是一款虚拟货币交易平台，用于购买虚拟货币来向OneKey Card进行充值
OneKey介绍
国内最大的冷钱包厂商Onekey不久前推出了Visa虚拟卡。因为OneKey Card支持OpenAI的绑定，能够用来开通ChatGPT Plus，并且会比Depay容易不少。
先说一下，Onekey是做硬钱包出身，前不久刚完成A+轮融资，有纳斯达克上市的coinbase公司背书，这次进军虚拟卡业务，公测期间活动力度还是不小的。OneKey相比Depay算是大厂，而且目前公测暂时没月费。
第一步：注册Onekey Card
1.点击注册链接：https://card.onekey.so/?i=BWGR4R，进入注册界面,点击 [ sign in with Google ] ，直接使用谷歌账户注册。
2.账号注册后，点击[ Activate ]激活开通。卡片类型选VISA
3. 实名KYC认证。按网页步骤进行实名认证，基本信息添加完毕后，点击 [ Next ]
此时需要进一步认证，点击 [ Please complete face verification ]，使用VX扫码进行自动验证。完成后，您的邮箱将收到一封认证完成的邮件。
值得一提的是——凡是中心化的产品都需要做KYC认证，这是合规必须要面临的动作，不必有过多的顾虑。
4.认证完成后，需要绑定 Google 身份验证器，才能开始使用，点击右上角3个点，选security，绑定google auth二次验证。安装谷歌验证码App并扫描二维码，抄写备份密钥（此密钥可让您在手机丢失时恢复您的 Google 身份验证器）。
输入谷歌验证码和邮箱验证码，完成绑定。
5. 点击卡下方的top up，公测期间，充值至少20 USDC用于激活，目前只支持USDC。
第二步：自己摸索 或者 评论区见
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3724a5c942c01d418ae9c00ca073385b/" rel="bookmark">
			ES6—ES13新语法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ES6—ES13语法总览 一、ES6 新特性（2015）1. let和const（1）重新赋值（2）块级作用域（3）变量提升（4）重复声明 2. 解构赋值（1）数组解构（2）对象解构（3）其他解构赋值 3. 模板字符串4. 函数默认参数（1）函数length属性值（2）参数作用域 5. 箭头函数6. 扩展运算符7. Symbol（1）避免常量值重复（2）避免对象属性覆盖 8. 集合 Set9. Map10. 模块化（1）export 导出模块（2）import 导入模块（3）导入导出复合用法（4）模块的继承 11. 字符串方法（1）includes()（2）startsWith()（3）endsWith()（4）repeat() 12. 数组方法（1）reduce()（2）filter()（3）Array.from（1）fill() 二、ES7 新特性（2016）1. Array.includes()2. 指数操作符 三、ES8 新特性（2017）1. padStart()和padEnd()（1）padStart()（2）padEnd() 2. Object.values()和Object.entries()3. 函数扩展 四、ES9 新特性（2018）1. for await…of2. Promise.finally3. 对象的扩展运算符4. 对象的 Rest 五、ES10 新特性（2019）1. trimStart() 和 trimEnd()2. flat()和flatMap()（1）flat()（2）flatMap() 3. Object.fromEntries()（1）将数组转成对象（2）将 Map 转成对象 4. Symbol描述5. toString()6. catch 六、ES11 新特性（2020）1. BigInt2. 空值合并运算符（??）3. 可选链操作符（?.）4. Promise.allSettled5. String.matchAll() 七、ES12 新特性（2021）1. String.replaceAll()2. 数字分隔符3. Promise.any4. 逻辑赋值操作符 八、ES13 新特性（2022）1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3724a5c942c01d418ae9c00ca073385b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1628a8592795f329db9c3d9fd329be1/" rel="bookmark">
			Java语言----二叉树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、二叉树
1.1 二叉树概念
1.2 两种特殊的二叉树
1.3二叉树的性质
二 、二叉树的实现
2.1第一种 使用数组
2.2第二种 使用链表实现
2.2.1二叉树代码构建
2.2.2二叉树的基本操作
三、二叉树的三种遍历
3.1递归方法实现 前、中、后遍历
3.2非递归方法实现 前、中、后遍历
总结
😽个人主页： 博客-专业IT技术发表平台 (csdn.net)
🌈梦的目标：努力学习，向Java进发，拼搏一切，让自己的未来不会有遗憾。
🎁欢迎各位→点赞👍 + 收藏⭐ + 评论📝+关注✨
本章讲解内容：二叉树
来源于百度 使用编译器：IDEA
一、二叉树 1.1 二叉树概念 二叉树：一种 非线性 的数据结构，为结点的一个有限集合。
有限集合分类：1、或者为空 2、由一个根节点加上两棵别称为 左子树 和 右子树 的二叉树组成
重要知识：
1、树的深度或高度：树的最大层次。如上图：该二叉树高度为3。
2、结点的度：1个结点含有的子树个数。如上图：结点1的度为2，分别为2和4的左右子树。
3、父亲结点：拥有子树的结点。如上图：1便有2和4的子树，所以为父亲结点。
4、孩子结点：一个结点的的子树结点便为孩子结点。如上图：2是1的孩子结点。
5、叶子结点：无子树的结点。如上图：3、5、6的结点无子树，为叶子结点。
6、根结点：最开始的结点。如上图：1为根结点，每个二叉树只有一个根结点。
1.2 两种特殊的二叉树 1. 满二叉树 : 一棵二叉树，如果 每层的结点数都达到最大值，则这棵二叉树就是满二叉树 。也就是说， 如果一棵 二叉树的层数为K，且结点总数是 2^k-1 ，则它就是满二叉树。 2. 完全二叉树 : 一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，从0开始编号，编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同。 红色数字，代表的是结点序号，数组实现时使用 完全二叉树更为重要，因为堆便是在此基础上实现的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1628a8592795f329db9c3d9fd329be1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f99924dfd5e7ff1ce1a7d90eed952b7/" rel="bookmark">
			使用DirBuster寻找敏感文件和目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DirBuster是一个多线程的应用程序，设计用于暴力破解Web 应用服务器上的目录名和文件名的工具。
目录
一·实验准备.
1.在VMware上打开OWASP_Broken_Web_App，查看靶场的IP，我的IP是192.168.17.130，如下图所示：
二、爆破字典准备
1.在kali linux的指定目录下新建dir_dictionary.txt并输入参数：
二、在kali linux中用图形界面打开dirbuster
1.在菜单栏中打开dirbuster
2.在OWASP DirBuster中设置参数：
3： 查看Results选项卡的参数： （结果是根据字典中的内容找出来的目录或文件）
4.总结：
一·实验准备. 1.在VMware上打开OWASP_Broken_Web_App，查看靶场的IP，我的IP是192.168.17.130，如下图所示： 二、爆破字典准备 1.在kali linux的指定目录下新建dir_dictionary.txt并输入参数： 1.1：先双击进入 Home，右击新建文档，文档名字为：dir_dictionary.txt
1.2：新建成功
1.3：输入文档， 并保存退出：
1.4：文档的位置root/dir_dictionary.txt
dir_dictionary.txt是爆破目录的字典，只要字典足够好（量大质量高），没有网站破不了。本次实验dir_dictionary.txt中的内容是：
info
server-status
server-info
cgi-bin
robots.txt
phpmyadmin
admin
login
二、在kali linux中用图形界面打开dirbuster 1.在菜单栏中打开dirbuster 2.在OWASP DirBuster中设置参数： 2.1：Target URL：输入要探测网站的地址（注意的是这个地址要加上协议，看网站是http还是https）将目标 URL 设置为 http://192.168.17.130:80/
2.2： Work Method：选择工作方式 Use GET requests only（是get请求） Auto Switch（HEAD and GET）（是自动选择）
一般选auto switch的自动选择，它会自行判断是使用head方式或get方式。
2.3：Number of Threats 选择扫描线程数 一般设置为30，我将本次实验线程数设置为20，（大家可自行设置，看看不同设置后运行的效果）
2.4：select scanning type 选择扫描类型：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f99924dfd5e7ff1ce1a7d90eed952b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4eccaaa17f6e1bc8950e3992705c35e9/" rel="bookmark">
			mysql解压缩安装的详细步骤
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql解压缩安装的详细步骤 1、下载压缩包，地址1（官网下载）：https://www.mysql.com/downloads/
官网下载方法如下：
2.解压压缩包到自己喜欢的文件夹中；（以我为例是D:\newdream\mysql\mysqlserver，后文以安装路径代替）
3.设置环境变量，右键我的电脑 -&gt;属性 -&gt;高级系统设置 -&gt;环境变量 -&gt;在系统变量中找到path，点击编辑，添加 “；安装路径\bin；”。（路径前后以分号隔开“；”如：D:\newdream\mysql\mysqlserver\bin；）
4.回到安装目录，在目录中新增一个记事本，将名称改为my，后缀改为.ini
5.以记事本的方式打开my.ini，添加以下内容：
[mysqld] port = 3306 basedir=D:/newdream/mysql/mysqlserver datadir=D:/newdream/mysql/mysqlserver/data max_connections=200 character-set-server=utf8 default-storage-engine=INNODB sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [mysql] default-character-set=utf8 注：basedir和datadir后的路径为自己目录的路径
我的路径是D:/newdream/mysql/mysqlserver；
一定注意要将路径中的“\”改为“/”
6.以管理员身份打开cmd窗口
输入如下路径更改执行位置：
切换盘符： D: 即可
cd (安装目录下bin目录的路径）
如：cd /newdream\mysql\mysqlserver\bin
7.输入以下命令安装sql服务：
mysqld -install
执行命令后弹出提示Service successfully installed. 表示安装成功（若未用管理员打开cmd，此处会不通过）
8.输入以下命令初始化sql服务：
mysqld --initialize-insecure --user=mysql
执行命令后会在目录下生成data文件并创建root用户
9.输入以下命令启动sql：
net start mysql
执行后会有如下提示：
MySQL服务正在启动…
MySQL服务已经启动成功。
10.输入以下命令进入sql更改密码
mysqladmin -u root -p password
弹出Enter password:
此时系统无密码，可以直接回车，然后设置新密码，在重复输入一次。设置密码完成。
11.输入mysql -u root -p password进入sql。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2339d12b00498aa830c0147d9fc03a31/" rel="bookmark">
			Linux 学习笔记（七）：时间片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、时间片概念 时间片（timeslice）又称为 “量子”（quantum）或 “处理器片”（processor slice），是分时操作系统分配给每个正在运行的进程微观上的一段 CPU 时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。
简单来说，时间片就是 CPU 分配给各个程序的时间，即该进程允许运行的时间。如果进程在时间片结束时还在运行，则 CPU 将被强制剥夺并分配给另一个进程；如果进程在时间片结束前就阻塞或结束，则 CPU 会在阻塞或结束时当即进行切换。
二、并行计算 说到并行计算，尤其是单台计算机的并行计算，一定要先建立时间片的概念。
现在使用的的操作系统基本都是多任务操作系统（Windows、Linux、Mac OS X 等），它们允许同时运行多个进程 —— 例如，我们可以在打开音乐播放器听音乐的同时用浏览器浏览网页并下载文件，这样看来播放器和浏览器是同时运行的。
但事实上，虽然一台计算机可能有多个 CPU ，但是同一个 CPU 在一个时刻永远只能运行一个任务，而不可能真正地同时运行多个任务。
三、如何实现并行计算 实现这种同时运行的 “假象” ，其实是操作系统按照一定的策略，定期给每个活动的进程执行其内部程序的机会，并且每次只执行一小段时间，然后操作系统利用中断强行退出运行，并将当前程序信息压栈，然后转去执行下一个进程的一小段程序。
通过这样不断快速的循环切换，每个程序都得到了执行。由于切换时间非常短，在用户看来，就是很多程序在同时的执行，这就模拟了并行计算。
现在新的多核 CPU 以及超线程 CPU ，内部有超过 1 个的 CPU 执行体，它们运行时就不是模拟并行计算，而是真的有两个及以上的程序同时被执行 这里我们只需要理解 —— 程序是被操作系统片段执行的，每个片段就是一个时间片。在只考虑一个 CPU 的情况下，时间片使得这些进程 “看起来像” 同时运行的，实则是轮番穿插地运行。时间片通常都很短（Linux上为5ms－800ms），所以用户并不会感觉到进程的切换。
由于是片段执行，我们需要知道，自己的程序在运行时并不是独一无二的。在用户看来很顺畅的工作，其实是由一个个的执行片段构成的。在我们眼中相邻的两条语句甚至同一条语句中两个不同的运算符之间，都有可能插入其他线程或进程的动作。
四、时间片的分配 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间。当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。
也就是说，一个系统中所有的进程分配到的时间片长短并不是相等的，尽管初始时间片基本相等（其实 Linux 系统中，初始时间片也不相等，而是各自父进程的一半）。
系统通过测量进程处于 “睡眠” 和 “正在运行” 状态的时间长短来计算每个进程的交互性，交互性和每个进程预设的静态优先级（Nice 值）的叠加即是动态优先级。动态优先级按比例缩放就是要分配给对应进程时间片的长短。一般地，为了获得较快的响应速度，交互性强的进程（趋向于 I/O 消耗型）分配到的时间片要长于交互性弱的（趋向于处理器消耗型）进程。
五、时间片的长度 从一个进程切换到另一个进程是需要一定时间的 —— 保存和装入寄存器值及内存映像、更新各种表格和队列等都是需要时间的。
假如进程切换（process switch）【有时也称为上下文切换（context switch）】，需要 5 毫秒，再假设时间片设置为 20 毫秒。则 CPU 在做完 20 毫秒有用的工作之后，还将花费 5 毫秒来进行进程的切换。也就是说 CPU 时间的 20%（ 5/(20+5) ）都浪费在管理开销上。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2339d12b00498aa830c0147d9fc03a31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee9ed73c07ffbbeba9d9ffc235e89f73/" rel="bookmark">
			IT行业实用的学习网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1GitHub：所有开发者都去用！！
21024搜索：这是一款专门问开发者定制的搜索引擎，里面收集的都是技术文章
3 git：与 GitHub 搭配使用，方便管理代码版本。
4 sourceforge：是一个开源软件开发平台和仓库，里面包含大量开源软件，是值得用使用的一个软件下载平台。
5W3school：包含各类语言的学习教程，资料非常全面。前端开发常用。
6菜鸟教程：是国内的免费编程学习网站，涉及的编程语言也比较多，整体还是不错的。
⑦博客园：博客园算是国内元老级的博客论坛了，里面的内容还算比较纯粹，适合开发者学习使用。
8CSDN：日常遇到的一些问题或者学习可以在对应的博客找到答案。
9掘金：是面向全球中文开发者的技术内容分享与
交流平台。后端，前端，安卓，ios，人工智能，开发工貝等文章都有
051CTO：是中国领先的I技术在线学习平台和
中国最大的1T技术社区之一，技术博客可以多看看，后端，前端，安卓，ios，人工智能，开发工具，数据库等学习都有。
①⑦B站：中国最大的学编程的好平台
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13249cdc4af1ae39e8a8b61b1a994abb/" rel="bookmark">
			SpringMVC框架面试专题（初级-中级）-第八节
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		欢迎大家一起探讨～如果可以帮到大家请为我点赞关注哦～后续会持续更新
问题：
1.Spring MVC框架中的MyBatis集成是什么？请举例说明如何集成MyBatis。
解析：
Spring MVC框架中的MyBatis集成是指通过Spring框架将MyBatis框架集成到Spring MVC应用程序中，从而实现数据访问层和Web层的无缝整合。通过MyBatis集成，开发者可以使用MyBatis来管理数据访问，从而提高应用程序的性能和可维护性。
以下是一个简单的示例，展示如何在Spring MVC中集成MyBatis：
1.添加MyBatis和相关依赖
在pom.xml文件中添加MyBatis和相关的依赖，如下所示：
&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;${mybatis-spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; 其中，${mybatis.version}、${mybatis-spring.version}和${mysql.version}是版本号变量，需要根据实际情况进行设置。
2.配置数据源和SqlSessionFactory
在Spring配置文件中配置数据源和SqlSessionFactory，如下所示：
&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatis_demo" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="password" /&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="mapperLocations" value="classpath*:mapper/*.xml" /&gt; &lt;/bean&gt; 上述代码中，我们定义了一个DriverManagerDataSource对象作为数据源，并设置了连接信息和用户名密码。同时，我们定义了一个SqlSessionFactoryBean对象，并将其依赖于数据源对象，并设置了Mapper文件所在的路径。
3.配置Mapper扫描器
在Spring配置文件中配置Mapper扫描器，如下所示：
&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/13249cdc4af1ae39e8a8b61b1a994abb/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/143/">«</a>
	<span class="pagination__item pagination__item--current">144/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/145/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>