<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c914d16ca255727d019f8c3cfa52d0eb/" rel="bookmark">
			ES6 数组常用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实例方法 at() 长久以来，JavaScript 不支持数组的负索引，如果要引用数组的最后一个成员，不能写成arr[-1]，只能使用arr[arr.length - 1]。
这是因为方括号运算符[]在 JavaScript 语言里面，不仅用于数组，还用于对象。对于对象来说，方括号里面就是键名，比如obj[1]引用的是键名为字符串1的键，同理obj[-1]引用的是键名为字符串-1的键。由于 JavaScript 的数组是特殊的对象，所以方括号里面的负数无法再有其他语义了，也就是说，不可能添加新语法来支持负索引。
为了解决这个问题，ES2022 为数组实例增加了at()方法，接受一个整数作为参数，返回对应位置的成员，并支持负索引。这个方法不仅可用于数组，也可用于字符串和类型数组（TypedArray）。
const arr = [5, 12, 8, 130, 44]; arr.at(2) // 8 arr.at(-2) // 130 如果超出范围，at() 返回undefined
const sentence = 'This is a sample sentence'; sentence.at(0); // 'T' sentence.at(-1); // 'e' sentence.at(-100) // undefined sentence.at(100) // undefined flat()，flatMap() 数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。
[1, 2, [3, 4]].flat() // [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 [1, 2, [3, [4, 5]]].flat() // [1, 2, 3, [4, 5]] [1, 2, [3, [4, 5]]].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c914d16ca255727d019f8c3cfa52d0eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a78d53a05abcef4566fdae09979c5b66/" rel="bookmark">
			mysql笔记：18. 示例数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 employeesworldsakilaairportdbmenagerie MySQL示例数据库是MySQL官方提供的开源项目，旨在帮助用户学习和实践MySQL数据库。一个示例数据库可以提供真实的数据库环境，一般包含了多个表格，每个表格都有不同的结构和数据。通过使用示例数据库，用户可以通过实际操作来学习和理解MySQL数据库的各种功能和特性。 MySQL官方网站提供了以下几个示例数据库：employee、world、sakila、airportdb以及menagerie。这些数据库既可以用于日常学习和测试，也可以作为我们设计数据库时的一个参考。 MySQL链接如下： Example Databases employees Employees是一个经典的员工管理数据库。
Employees数据库由Patrick Crews和Giuseppe Maxia开发，包含了分布在六个独立表（dept_emp、dept_manager、titles、salaries、employees 以及 departments）上的大量数据（约160MB），总共约400万条记录。该结构与多种存储引擎类型兼容。Employees数据库还支持分区表。
除了基本数据外，Employees数据库还包括一套测试，这些测试可以在测试数据上执行，用于验证初始数据的完整性。
安装使用方式：
$&gt; unzip test_db-master.zip $&gt; cd test_db-master/ $&gt; mysql -t &lt; employees.sql 相关表的关系如下：
world world是一个小型的简单数据库，提供了一组包含世界国家和城市信息的表，主要用于基础查询测试。它包含了 country、countrylanguage 以及 city 表。
三个表的关系如下：
sakila Sakila示例数据库最初由MySQL AB文档团队的前成员Mike Hillyer开发。它是一个在线 DVD 出租商店数据库，为各种 MySQL 文档、书籍、教程、文章、示例等提供了一个标准数据库模式；同时，它还可以用于突出演示MySQL 的一些功能特性，例如视图、存储过程和触发器。
关系图如下：
airportdb airportdb数据库是一个大型数据集，它改编自Stefan Proell、Eva Zangerle和Wolfgang Gassler开发的Flughafen数据库。旨在与Oracle云基础设施（OCI）和热浪上的MySQL数据库系统一起使用。该数据库的大小约为2GB，由14个表组成，共包含55983205条记录。
关系如下：
menagerie menagerie 数据库是一个小型的动物数据库，包含 pet 和 event 表。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39dcf62df33cfe0cb7a63a5af7944ab/" rel="bookmark">
			Linux常见开源同步工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统之间经常需要文件同步，一个好的文件同步工具省时省力，这里介绍几款开源的Linux文件同步工具
1. rsync：
rsync 是Linux上一个功能强大的命令行工具，可以在不同的服务器之间同步文件和目录。通过 rsync，你可以实现增量同步、备份、镜像等功能，非常适合用来同步大量数据。在 Linux 上，你可以使用 rsync 命令轻松实现文件同步。
2. Syncthing：
Syncthing 是一款开源的文件同步工具，支持多种操作系统，包括 Linux。Syncthing 使用点对点的方式同步文件，不需要中心服务器，保证了数据的安全性和隐私性。通过 Syncthing，你可以在多台设备之间实现文件同步，支持多种同步方式和设置选项。
3. FreeFileSync：
FreeFileSync 是一款免费的开源文件同步和备份工具，可以在 Windows、Linux 和 macOS 上使用。FreeFileSync 提供了直观的用户界面，支持双向同步、增量备份、过滤规则等功能，方便用户快速同步文件和目录。
4. Rclone：
Rclone 是一个命令行工具，可以在不同的云存储服务和本地文件之间进行同步和传输。Rclone 支持多种云存储服务，包括OneDrive 等，也支持 SFTP、WebDAV 等协议。在 Linux 上，你可以使用 Rclone 轻松实现不同存储之间的文件同步。
5. Unison：
Unison 是一款双向文件同步工具，可以在不同的操作系统上使用。Unison 提供了图形界面和命令行两种方式，支持快速同步和比较文件版本，同时可以处理冲突和同步失败的情况。在 Linux 上，你可以通过 Unison 实现多台设备之间的文件同步。
6. 私有云存储Owncloud：
Owncloud 是一种自托管云存储平台，你可以将数据保存在自己的服务器上，保证数据的安全性和隐私性。Owncloud 同样可以在 Linux 上使用，并且提供了丰富的插件和扩展功能，满足各种不同需求。
7. 云存储方案：
云存储方案可以随时随地访问，你只需要安装客户端，登录你的账号，就可以轻松同步文件到云端，方便在不同设备之间共享和访问文件。不好处是免费的空间小，不过这些云存储商对企业客户都有专门的解决方案，可以尝试选用。
以上是一些常见的用于 Linux 的文件同步工具，它们具有不同的特点和功能，可以根据你的具体需求选择适合的工具来实现文件同步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ba793e778c8210ce4deaa7e5ac612a6/" rel="bookmark">
			Hadoop大数据应用：Linux 部署 MapReduce 与 Yarn
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实验
1.环境
2.Linux 部署 MapReduce
3.Linux 部署 Yarn
4.Linux 调用大数据集群分析数据
二、问题
1.hadoop 的启动和停止命令
2.HDFS 使用命令
一、实验 1.环境 （1）主机
表1 主机
主机架构软件版本IP备注hadoop NameNode （已部署）
SecondaryNameNode （已部署）
ResourceManager
hadoop
2.7.7192.168.204.50 node01 DataNode（已部署）
NodeManager
hadoop
2.7.7192.168.204.51node02 DataNode（已部署）
NodeManager
hadoop
2.7.7192.168.204.52node03 DataNode（已部署）
NodeManager
hadoop
2.7.7192.168.204.53 (2) 查看jps进程
NameNode节点查看
[root@hadoop hadoop]# jps DataNode节点查看（node01）
DataNode节点查看（node02）
DataNode节点查看（node03）
（3） web页面访问
http://192.168.204.50:50070/ http://192.168.204.50:50090/ http://192.168.204.51:50075/ 访问系统
2.Linux 部署 MapReduce (1)备份
[root@hadoop hadoop]# cp mapred-site.xml.template mapred-site.xml （2）查看mapreduce配置文件
https://hadoop.apache.org/docs/r2.7.7/ https://hadoop.apache.org/docs/r2.7.7/hadoop-mapreduce-client/hadoop-mapreduce-client-core/mapred-default.xml （3）修改配置文件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ba793e778c8210ce4deaa7e5ac612a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f95558742b9e2dacc06572a8bf7e789/" rel="bookmark">
			ES6 Nunber类型、Math对象扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		二进制和八进制表示法 ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。
0b111110111 === 503 // true 0o767 === 503 // true // 非严格模式 (function(){ console.log(0o11 === 011); })() // true // 严格模式 (function(){ 'use strict'; console.log(0o11 === 011); })() / Number.isFinite(), Number.isNaN() ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity
Number.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite('foo'); // false Number.isFinite('15'); // false Number.isFinite(true); // false Number.parseInt(), Number.parseFloat() ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 // ES5的写法 parseInt('12.34') // 12 parseFloat('123.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f95558742b9e2dacc06572a8bf7e789/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d97ff1a3dc7b3ee5ee0fbdc6469e781/" rel="bookmark">
			Windows提示“无法删除文件：无法读源文件或磁盘”怎么办？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当用户在Mac电脑上创建一个文件，又将文件共享到Windows系统后，该文件可能无法被Windows正常识别和使用，并且在删除时出现“无法删除文件：无法读源文件或磁盘”的提示，这可能和Windows不支持Mac电脑创建的某些文件名有关。除此之外，也有可能和以下几个因素有关：
●要删除文件已损坏。
●文件所在的磁盘有坏道。
●USB端口或移动硬盘数据线出现问题，从而影响电脑删除外部磁盘中的文件，可尝试更换端口或数据线。
了解完可能造成该故障的原因之后，下面我们可以参照以下几种方法尝试解决这类问题。
如何解决“无法删除文件：无法读源文件或磁盘”？ 1、重启计算机
如果您的Windows计算机第一次出现此类故障，您可以尝试重新启动计算机去解决，推荐您使用电脑里的重启按钮直接进行重启的操作，重新启动有助于计算机自行处理此类错误，并将设备恢复到最佳的工作状态。
2、检查磁盘错误并修复
Windows系统自带了检查磁盘错误的功能，您可以直接使用磁盘检查工具扫描无法删除文件的目标磁盘并修复故障。以下是详细的操作步骤：
步骤1：打开“我的电脑/此电脑”，右键点击需要修复的磁盘并选择【属性】。在属性窗口中切换至【工具】选项，并单击【检查】按钮。
步骤2：接下来，在错误检查界面里选择【扫描并修复驱动器】选项，之后等待扫描并根据提示修复即可。
3、使用chkdsk工具修复坏道
chkdsk是Windows系统检查磁盘当前状态的一个实用工具，它可以显示磁盘状态、内存状态和指定路径下指定文件的不连续数目，另外还可以修复磁盘。借助chkdsk工具修复磁盘非常简单，具体操作步骤如下：
步骤1：运行计算机，在左下角搜索框内直接搜索【cmd】，并选择【以管理员身份运行】打开命令提示符工具。
步骤2：在打开的命令提示符窗口里，输入命令【chkdsk X: /r /f】（X指无法删除的文件所在的硬盘驱动器号；/r和/f是chkdsk参数，/r可查找坏扇区并恢复可读的信息；/f将尝试修复磁盘上的所有错误），并按【Enter】键以修复错误。待磁盘故障修复完成之后，重启计算机检查该问题是否已解决。
4、转移其他文件再格式化目标磁盘
如果以上方法均无法解决问题，您还可以将磁盘内的其他重要文件转移/复制到其它磁盘当中，之后再对故障磁盘进行格式化的操作，以达到删除目标文件的目的。下面我们就在磁盘管理程序中执行磁盘的格式化操作吧。
步骤1：运行计算机，之后同时按下键盘的【Windows+X】键。然后在弹出的列表中，选择【磁盘管理】选项。
步骤2：接下来，找到需要格式化操作的磁盘，鼠标右键单击它并选择【格式化】选项。
步骤3：选择需要的文件系统： FAT32、NTFS或exFAT ，勾选【执行快速格式化】，点击【确定】，然后按照指示完成格式化的过程。格式化将清空磁盘中的所有数据，包括您想删除的目标文件。
以上就是解决“无法删除文件：无法读源文件或磁盘”的方法，希望对您有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6115a0fecd3881491ff7ce86f76ae51/" rel="bookmark">
			基于单片机的电子琴设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于单片机的电子琴设计 摘 要
读书、看电影、听音乐，都是最常见的丰富内心世界的良剂。听音乐，作为陶冶情操、提升境界最便捷的方式，正受到越来越多人们的欢迎。音乐可以很轻松的融入各种场合，给人们带来很轻松的氛围，只有真正的接触它，才可以真正的感受到它的魅力。
本次设计正是基于这样的一种考虑，将实现一种简易电子琴的制作，考虑到市面上的电子琴因型号各异，款式各异，所以在价格方面也会有很大的差别，而这次设计将结合电子琴的功能性以及实用性将成本降至最小化来进行制作。本次设计主要用到的芯片是STC89C51，系统里包含了几大核心模块主要有按键模块 、扬声器模块、数码管模块等。
此次设计主要能实现的功能是：键盘上有12个按键，上面8个分别代表不同的音符键，当触发到某一个按键时扬声器会发出对应的音符，这样只要有完整的乐谱，就可以弹奏出非常美妙的音乐。此外剩下的4个按键是功能键。此次系统的设计不仅涉及到硬件方面还涉及到软件方面，所以得从两方面展开巩固系统。
关键词：STC89C51单片机 电子琴 键盘
Design of electronic organ based on single chip microcomputer
Abstract
Reading, movies, listening to music are a good dose of the most common rich inner world.To listen to music, as the mold sentiment, enhance the realm of the most convenient way, is being more and more people’s welcome。Music can be very easy to integrate into various occasions, to give people a very relaxed atmosphere, only the real contact with it, you can really feel its charm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f6115a0fecd3881491ff7ce86f76ae51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58156a0b9843d8853c4ccbe1e69f9bdc/" rel="bookmark">
			VulnRecap 3/11/24 – JetBrains 和 Atlassian 问题仍然存在
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
行进 4, 2024
JetBrains 服务器问题持续存在新漏洞
行进 5, 2024
苹果新漏洞需要快速修补
VMware 漏洞影响 ESXi、Workstation 和 Fusion
行进 6, 2024
思科针对安全客户端漏洞提供修复版本
针对 OpenEdge 漏洞发布概念验证
行进 8, 2024
Confluence 漏洞的利用仍在继续
行进 4, 2024 JetBrains 服务器问题持续存在新漏洞 漏洞类型: 身份验证绕过.
问题: 两个身份验证绕过漏洞, CVE-2024-27198 和 CVE-2024-27199, 允许未经身份验证的攻击者利用 JetBrains TeamCity 服务器。 更严重的 CVE-2024-27198 允许威胁行为者接管整个服务器。 Rapid7 的研究人员于 2 月下旬发现了这些漏洞，并于 3 月发布了相关信息 4.
这些是与过去回顾中提到的不同的 JetBrains 漏洞。 我们在过去几个月中发现了多个漏洞，但这些都是新漏洞，不要与 2023 年的 CVE 混淆。新漏洞的潜在利用可能包括在 TeamCity 服务器上远程执行代码.
JetBrains 发布了 详细的博客文章 解释了发现漏洞的具体时间、与Rapid7的冲突以及JetBrains对发布漏洞信息的立场。 其立场是，立即向公众发布漏洞数据，使威胁行为者能够在客户有足够的时间修补问题之前利用这些问题.
然而, Rapid7 的政策 认为静默修补限制了经验丰富的 IT 专业人员参与保护网络和信息系统的方式。 由于这些差异，JetBrains 决定不与 Rapid7 协调披露漏洞信息.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58156a0b9843d8853c4ccbe1e69f9bdc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b6a584ea75f11295ee7a4607109f515/" rel="bookmark">
			网络原理（网络协议初识）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.网络通信基础
1.1IP地址
1.2端口号
1.3认识协议
1.4五元组 1.5 协议分层
2.TCP/IP五层（或四层）模型
2.1网络设备所在分层
2.2网络分层对应
3.封装和分用
1.网络通信基础 网络互连的目的是进行网络通信，也即是网络数据传输，更具体一点，是网络主机中的不同进程间，基于网络传输数据。 1.1IP地址 IP地址主要用于标识网络主机、其他网络设备（如路由器）的网络地址。简单说， IP 地址用于定位主机 的网络地址 。 IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”（也就是4个字节），如： 01100100.00000100.00000101.00000110 通常用“点分十进制”的方式来表示，即 a.b.c.d 的形式（a,b,c,d都是0~255之间的十进制整数）。如：100.4.5.6。
1.2端口号 在网络通信中，IP地址用于标识主机网络地址，端口号可以标识主机中发送数据、接收数据的进程。简 单说：端口号用于定位主机中的进程。 端口号是0~65535范围的数字，在网络通信中，进程可以通过绑定一个端口号，来发送及接收网络数据。
其中：0 ~ 1023 为 知名端口号 ，这些端口预留给服务端程序绑定广泛使 用的应用层协议， 22端口：预留给SSH服务器绑定SSH协议 21端口：预留给FTP服务器绑定FTP协议 23端口：预留给Telnet服务器绑定Telnet协议 80端口：预留给HTTP服务器绑定HTTP协议 443端口：预留给HTTPS服务器绑定HTTPS协议 1.3认识协议 协议，网络协议的简称，网络协议是网络通信（即网络数据传输）经过的所有网络设备都必须共同遵从 的一组约定、规则。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互 通信交流。通常由三要素组成： 1. 语法：即数据与控制信息的结构或格式； 2. 语义：即需要发出何种控制信息，完成何种动作以及做出何种响应； 3. 时序，即事件实现顺序的详细说明。 协议（protocol）最终体现为在网络上传输的数据包的格式 计算机之间的传输媒介是光信号和电信号。通过 " 频率 " 和 " 强弱 " 来表示 0 和 1 这样的信息。要想传递 各种不同的信息，就需要约定好双方的数据格式。 1.4五元组 在TCP/IP协议中，用五元组来标识一个网络通信： 1. 源IP：标识源主机 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b6a584ea75f11295ee7a4607109f515/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da50410eae4b4af654c56aa91266c8e0/" rel="bookmark">
			ping命令常用参数以及traceout命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言:
1.ping命令
1.1ping命令的作用:
1.2ping命令常用的子命令
1.3ping -n命令
1.4ping -t命令 ​编辑
1.5ping -c命令
1.6ping -i 命令
2.traceroute 2.1tracetoute作用:
2.2具体语法：
2.3具体案例:
traceroute www.example.com
致谢:
前言: 在网络诊断和管理中，ping命令和tracert（Windows系统）或traceroute（Linux系统）命令是两个非常基础且常用的工具。它们可以帮助我们检查网络连接的可用性，了解数据包在网络中的传输路径，以及识别可能存在的网络问题。本博客将介绍这两个命令的常用参数，并通过实例演示如何使用它们进行网络诊断
1.ping命令
1.1ping命令的作用:
ping命令是一个用于测试网络连接的简单工具。它通过发送ICMP回显请求消息到目标主机，并等待接收回显应答来检测两台计算机之间的连通性。
1.2ping命令常用的子命令 ping -n ping -t ping -c ping -f ping -i ping -p 1.3ping -n命令 此命令代表着向指定ip地址发送一定次数的数据 此命令的格式为:
ping -n 次数 ip地址或者域名
如图1-1所示
图1-1
1.4ping -t命令 ping -t &lt;目标地址或域名&gt;
此命令将持续发送 ICMP Echo 请求消息到 www.example.com，直到您手动停止命令的执行。
使用 -t 参数有助于实时监测网络连接的稳定性和延迟情况。如图1-2所示
图1-2 1.5ping -c命令
ping -c 数据包的数量 传输的数据包的数量，并在完成指定数量的请求后自动停止。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da50410eae4b4af654c56aa91266c8e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033d072f0e4d5bf34ec34265af5c4a78/" rel="bookmark">
			Python 查找并高亮PDF中的指定文本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在处理大量PDF文档时，有时我们需要快速找到特定的文本信息。本文将提供以下三个Python示例来帮助你在PDF文件中快速查找并高亮指定的文本。
查找并高亮PDF中所有的指定文本查找并高亮PDF某个区域内的指定文本使用正则表达式搜索指定文本并高亮 本文将用到国产第三方库 - Spire.PDF for Python，该库提供 PdfPageBase.FindText() 方法可用于查找PDF中的特定文本，然后再使用 PdfTextFind.ApplyHighLight() 方法为匹配到的文本设置指定的高亮颜色以突出显示。
在运行接下来提供的示例代码之前，先通过pip安装Spire.PDF for Python库：
pip install Spire.PDF Python 查找并高亮PDF中所有的指定文本 步骤：
加载PDF文档遍历其中的页面查找所有指定的文本遍历所有查找到的文本并设置高亮颜色保存文档并关闭 代码：
from spire.pdf import * from spire.pdf.common import* # 加载PDF文档 pdf = PdfDocument() pdf.LoadFromFile("南极洲.pdf") # 遍历PDF中所有页面 for i in range(pdf.Pages.Count): page = pdf.Pages.get_Item(i) # 查找所有指定文本 result = page.FindText("南极", TextFindParameter.IgnoreCase) # 高亮匹配的文本 for text in result.Finds: text.ApplyHighLight(Color.get_Lime()) # 保存结果文件 pdf.SaveToFile("查找高亮PDF文本.pdf") pdf.Close() 输出：
Python 查找并高亮PDF某个区域内的指定文本 步骤：
加载PDF文档获取指定的PDF页面指定一个矩形区域查找矩形区域内的指定文本遍历查找到的文本并设置高亮颜色保存文档并关闭 代码：
from spire.pdf import * from spire.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/033d072f0e4d5bf34ec34265af5c4a78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7913b66c1b3b31da7fe001dace10a9a6/" rel="bookmark">
			应用服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、应用服务器概述（一）什么是应用服务器（二）主流Java应用服务器 二、Apache Tomcat服务器（一）下载与安装1、下载2、安装 （二）目录说明（三）配置环境变量（四）查看Tomcat版本（五）启动Tomcat服务1、命令方式2、图形界面 （六）访问Tomcat管理页面（七）运行示例程序1、示例页面2、Servlet示例3、JSP示例4、WebSocket示例 （八）关闭Tomcat服务 一、应用服务器概述 （一）什么是应用服务器 应用服务器是管理运行应用程序的软件框架，提供安全性、可靠性和高性能环境，支持企业级应用的构建、部署与托管。 （二）主流Java应用服务器 Tomcat: 一个流行的开源Web应用服务器，由Apache Software Foundation的Jakarta项目组开发。它主要用于部署和管理Java Servlet和JSP (JavaServer Pages)技术构建的动态Web应用程序。作为一个轻量级的容器，Tomcat提供了对最新Servlet和JSP规范的支持，这得益于与Sun公司的合作。由于其先进的技术和稳定的性能，Tomcat被广泛认可并使用在各种规模的项目中。同时，作为免费软件，Tomcat降低了开发成本，使得它尤其适合预算有限的项目或个体开发者。此外，Tomcat还具有高度可移植性，可以运行在多种操作系统上，这使得它非常适合在不同环境下进行开发和部署。
GlassFish: 一个开源的应用服务器，由Oracle公司支持。它提供了全面的Java EE（现在称为Jakarta EE）支持，并具有可扩展性、高性能和安全性。
Jetty: 一个轻量级、开源的Java HTTP服务器和Servlet容器，支持HTTP/2.0, WebSocket等协议，常用于嵌入Web应用和作为Web工具。
JBoss: 一个开源的、基于Java EE的应用服务器，遵循LGPL许可，可以免费用于商业应用。JBoss是开源社区中一个非常活跃的项目，它提供了一整套企业级服务，包括对EJB（Enterprise JavaBeans）的支持，以及对Java EE规范的实现。JBoss的特点在于它的AOP（面向切面编程）框架，这使得开发者可以在不改变原有代码的基础上，为普通Java类添加企业级的服务。这种动态AOP框架是通过在类加载时使用Javassist库对字节码进行操作来实现的。
二、Apache Tomcat服务器 （一）下载与安装 1、下载 访问Apache官网：https://www.apache.org访问Tomcat页面：https://tomcat.apache.org/下载Tomcat 10在Windows上64位的Tomcat安装包下载apache-tomcat-10.1.19-windows-x64.zip到本地 2、安装 将tomcat安装包解压到指定目录 - D盘根目录 （二）目录说明 bin [binary]: 用于存放批处理和shell脚本conf [configuration]: 用于存放Apache Tomcat相关配置文件lib [library]: Apache Tomcat服务器依赖项目库目录，包含服务器运行环境所需的jar包webapps: Apache Tomcat默认Web应用程序部署目录，war包将会放在该目录 （三）配置环境变量 CATALINA_HOME = D:\apache-tomcat-10.1.19PATH = %CATALINA_HOME%bin;..... （四）查看Tomcat版本 执行命令：version.bat （五）启动Tomcat服务 1、命令方式 在命令行窗口执行命令：startup.bat 2、图形界面 双击bin目录里的startup.bat文件图标 （六）访问Tomcat管理页面 访问http://localhost:8080 （七）运行示例程序 1、示例页面 打开示例页面：http://localhost:8080/examples/ 2、Servlet示例 http://localhost:8080/examples/servlets/第一个示例：Hello World 单击【Execute】链接，查看运行结果单击【Source】链接，查看源代码 3、JSP示例 http://localhost:8080/examples/jsp/Basic Arithmetic示例 单击【Execute】链接，查看运行结果单击【Source】链接，查看源代码 4、WebSocket示例 http://localhost:8080/examples/websocket/index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7913b66c1b3b31da7fe001dace10a9a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed95a2c5b3ee5b82eeb38e40eb1347d/" rel="bookmark">
			UDP数据报套接字编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.1UDP编程原理 对于UDP协议来说，具有无连接，面向数据报的特征，即每次都是没有建立连接，并且一次发送全部数据报，一次接收全部的数据报。Java中使用UDP协议通信，主要基于DatagramSocket类来发送或接收数据报套接字，并使用DatagramPacket作为创建的UDP数据报，DatagramPacket类对象就是UDP协议中Socket的数据报。 1.2 DatagramSocket API DatagramSocket 是UDP Socket，用于发送和接收UDP数据报。
(1) DatagramSocket 构造方法： (2)DatagramSocket 方法： 1.3DatagramPacket类 （1）DatagramPacket构造方法 构造方法如下：
（2）DatagramPacket普通方法 2.1服务器端代码 public class EchoServer {//服务器端 //1、创建一个DatagramSocket对象 DatagramSocket socket = null; public EchoServer(int port) throws SocketException {//服务器端需要自己指定端口号 socket = new DatagramSocket(port);//这么写就是手动指定端口号 //socket = new DatagramSocket();//这么写就是系统自动分配端口号 } public void start() throws IOException { System.out.println("服务器启动..."); while (true){ DatagramPacket requestPacket = new DatagramPacket(new byte[4096],4096); //requestPacket这个对象是用来承载数据的，在创建的时候需要创建一块内存空间来保存数据 socket.receive(requestPacket); //当前完成的receive之后，数据是以二进制的形式存储到DatagramPacket中 //还需要把这个二进制的数据转化成字符串的形式 String request = new String(requestPacket.getData(),0,requestPacket.getLength()); //范围为0到requestPacket.getLength()，requestPacket.getLength()表示数据的真实长度 //2、根据请求，计算响应（服务器端最核心的作用） String response = process(request); //3、把响应写回到客户端 //搞一个响应对象，DatagramPacket //把DatagramPacket构造刚才的数据，再通过send返回 DatagramPacket responsePacket = new DatagramPacket(response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ed95a2c5b3ee5b82eeb38e40eb1347d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d0c7435340cc13e57fe06dfbb5d3a84/" rel="bookmark">
			vue的axios教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ajax技术：不重新加载整个页面的情况下，异步地与服务器进行通信，并更新页面的部分内容 Ajax（Asynchronous JavaScript and XML）是一种使用 JavaScript 向服务器发送和接收数据的技术。
Ajax 的工作原理基于以下关键组件：
XMLHttpRequest 对象：XMLHttpRequest 是浏览器提供的 API，用于创建 HTTP 请求，并与服务器进行通信。通过 XMLHttpRequest 对象，您可以发送请求（例如 GET、POST、PUT、DELETE 等），并接收响应数据。
事件监听器：Ajax 使用事件监听器来处理异步请求的状态变化。这些事件包括请求已发送、请求已完成、请求失败等。您可以为 XMLHttpRequest 对象添加事件监听器来处理这些事件。
回调函数：Ajax 通常使用回调函数来处理异步请求的响应数据。您可以在请求成功时调用一个回调函数来处理响应数据，或在请求失败时调用另一个回调函数来处理错误。
服务器端处理：服务器端通常使用后端技术（如 PHP、Python、Node.js 等）来处理 Ajax 请求，并返回相应的数据。服务器端可以处理请求、查询数据库、执行操作，并将结果返回给客户端。
XMLHttpRequest 虽然 XMLHttpRequest 在其名称中包含了 “XML”（可扩展标记语言）一词，但它实际上并不仅限于与 XML 数据进行通信。这个名称的起源可以追溯到早期的 Web 开发阶段，当时 XML 是一种流行的数据格式，用于在 Web 上交换数据。因此，XMLHttpRequest 最初被设计为用于与服务器进行 XML 数据的异步交换。
然而，随着 Web 技术的发展，人们开始意识到 XMLHttpRequest 不仅可以用于 XML 数据，还可以与其他类型的数据进行通信，例如 JSON、HTML、纯文本等。由于 XMLHttpRequest 提供了灵活的 API，可以发送任意类型的 HTTP 请求和接收任意类型的响应，因此它在 Web 开发中变得非常普遍，不仅限于与 XML 相关的用例。
因此，尽管 XMLHttpRequest 在其名称中包含了 “XML” 一词，但它实际上是一个通用的 HTTP 客户端，可以用于与服务器进行各种类型的数据交换，而不仅仅局限于 XML 数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d0c7435340cc13e57fe06dfbb5d3a84/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d5c8d418e1711645de9df3c71e8038e/" rel="bookmark">
			AI-线性回归模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线性回归应用场景 房价预测，通过分析房地产市场的历史数据，如房屋大小、位置、建造年份等因素，线性回归可以帮助预测未来房价的走势。
销售额预测，企业可以利用线性回归模型来预测产品的销售额，这通常涉及到产品价格、市场营销预算、季节性因素等变量的分析。
贷款额度预测，金融机构可以使用线性回归来评估客户的信用风险，并据此决定贷款额度。
线性回归(Linear regression) 线性回归是一种利用直线方程对变量之间关系进行建模的回归分析方法。
定义：线性回归分析用于研究两个或多个变量之间的关系，其中一个是自变量，另一个是因变量。在这种方法中，目标是找到一个线性方程，即一个直线，该直线能够尽可能好地预测因变量基于自变量的值。公式：线性回归模型通常表示为 ( y = wx + b )，其中 ( y ) 是因变量，( x ) 是自变量，( w ) 是权重（斜率），而 ( b ) 是偏差（截距）。这个方程描述了自变量和因变量之间的直线关系。最小二乘法：为了找到最佳的 ( w ) 和 ( b ) 值，通常采用最小二乘法。该方法通过最小化实际数据点和回归线之间的平方差来求解这些参数。 期末成绩：0.7×考试成绩+0.3×平时成绩 特征值与目标值之间建立了一个关系，这个关系可以理解为线性模型 。 sklearn中， 线性回归的API在linear_model模块中 sklearn.linear_model.LinearRegression()
LinearRegression.coef_：回归系数 代码 from sklearn.linear_model import LinearRegression x = [[80, 86], [82, 80], [85, 78], [90, 90], [86, 82], [82, 90], [78, 80], [92, 94]] y = [84.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d5c8d418e1711645de9df3c71e8038e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d9573cd36de6e395ae8a0dfe11c5fe3/" rel="bookmark">
			Node.js入门基础—day01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人名片：
😊作者简介：一名大二在校生
🤡 个人主页：坠入暮云间x
🐼座右铭：给自己一个梦想，给世界一个惊喜。
🎅**学习目标: 坚持每一次的学习打卡
文章目录 初识node.js什么是node.js？如何查看node.js是否安装成功？终端中的快捷键：Node.js 应用是由哪几部分组成的?Node.js的优缺点JavaScript与Node.js的区别？ 创建Node.jsNode.js 应用是由哪几部分组成的?一、使用 require 指令来加载和引入模块二、创建服务器 模块化编程什么是模块化？为什么模块化？非模块化的弊端？模块化开发的优点？Node.js的核心模块Node.js全局函数Node.js的全局变量consoleNode.js的模块加载机制 初识node.js 什么是node.js？ Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。
Node.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。
注意：
1.浏览器是JavaScript的前端运行环境
2.Node.js是JavaScript的后端运行环境
3.Node.js是无法调用DOM和BOM等浏览器内置API
如何查看node.js是否安装成功？ 1.打开命令行工具，在里面输入node -V和npm -v，如下图所示，安装成功则显示版本号，如果报错则说明没有安装成功，可以官网node.js中重新下载
终端中的快捷键： ● 使用↑键，可以快速定位到上一次执行的命令
● 使用tab键，能够快速补全路径
● 使用esc键，能够快速清空当前已输入的命令
● 输入cls命令，可以清空终端
● 输入ctrl+c命令,可以终止终端
Node.js 应用是由哪几部分组成的? require 指令：在 Node.js 中，使用 require 指令来加载和引入模块，引入的模块可以是内置模块，也可以是第三方模块或自定义模块。
**创建服务器：**服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。
接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0d9573cd36de6e395ae8a0dfe11c5fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa56bc11b46e65aa70d1f77c1a12f305/" rel="bookmark">
			RabbitMQ 模拟实现【四】：虚拟主机设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 虚拟主机设计虚拟主机分析交换机和虚拟主机之间的从属关系核心 API发布消息订阅消息应答消息消费者管理类 虚拟主机设计 虚拟主机分析 类似于 MySQL 的 database，把交换机，队列，绑定，消息…进⾏逻辑上的隔离，⼀个服务器可以有多
个虚拟主机~，此处我们项⽬就设计了⼀个虚拟主机（VirtualHost）来提供 API 供上层调用
咱们这里采取的方案是,在客户提供的交换机等的身份标识(交换机名字),前加上虚拟机的名字. 即 客户要在虚拟机
VirtualHostA中创建交换机 exchangeC,咱们服务器存储的交换机名字是 VirtualHostAexchangeC.
交换机和虚拟主机之间的从属关系 ⽅案⼀：参考数据库设计，“⼀对多”⽅案，⽐如给交换机表，添加个属性，虚拟主机 id/name⽅案⼆：交换机的名字 = 虚拟主机名字 + 交换机的真实名字（按照⽅案⼆，也可以去区分不同的队列，进⼀步由于，绑定和队列和交换机都相关，直接就隔离开了，再进⼀步，消息和队列是强相关的，队列名区分开，消息⾃然区分开。） 核心 API 发布消息 发布消息API:
其实就是生产者将消息发送给对应的交换机,交换机再根据不同的转发规则,转发给与之相绑定且符合规则的消息队列.绑定关系 Binding 中有一个 bindingKey 属性消息 Message 中 有一个 routingKey 属性 下面就来讲解一下三种交换机的转发规则已经这两个 Key 的不同含义.
直接交换机 DIRECT 转发规则
在直接交换机中,bindingKye是无意义的,routingKey是要转发到的队列的队列名.直接交换机的转发规则, 是无视 bindingKey的,即 直接交换机是否与这个队列绑定都没有关系,而直接将消息转发到 routingKey指定的队列名的队列中. 扇出交换机 FANOUT 转发规则
在扇出交换机中,bindingKye是绑定的要转发的队列,routingKey是无意义的.扇出交换机的转发规则,是将收到的消息转发到与之绑定的所有队列中.与bindingKye和routingKey是没有任何关系的. 主题交换机 TOPIC 转发规则
在主题交换机中,bindingKey是创建绑定时,给绑定指定的特殊字符串(相当于一把锁),routingKey是转发消息时,给消息指定的特殊字符串(相当于一把钥匙).主题交换机的转发规则,是将收到的消息的routingKey与绑定的所有队列中的 bindingKey 进行匹配,当且仅当匹配成功时,才将消息转发给该队列. 匹配规则 - AMQP 协议
routingKey规则
由数字,字母,下划线组成，使用 . 将routingKey分成多个部分.bindingKey规则
由数字,字母,下划线组成，使用 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa56bc11b46e65aa70d1f77c1a12f305/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f45619b6db6fc5f5ed1560b253ac695/" rel="bookmark">
			vue3速查笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、创建Vue3.0工程1.使用 vue-cli 创建2.使用 vite 创建 二、常用 Composition API1.拉开序幕的setup2.ref函数3.reactive函数4.Vue3.0中的响应式原理vue2.x的响应式Vue3.0的响应式 5.reactive对比ref6.setup的两个注意点7.计算属性与监视1.computed函数2.watch函数3.watchEffect函数 8.生命周期9.自定义hook函数10.toRef 三、其它 Composition API1.shallowReactive 与 shallowRef2.readonly 与 shallowReadonly3.toRaw 与 markRaw4.customRef5.provide 与 inject6.响应式数据的判断 四、Composition API 的优势1.Options API 存在的问题2.Composition API 的优势 五、新的组件1.Fragment2.Teleport3.Suspense 六、其他1.全局API的转移2.其他改变 七、组件通信Propsemitsexpose / ref$attrsv-modelslot插槽provide / injecteventBusVuex / Pinia 一、创建Vue3.0工程 1.使用 vue-cli 创建 官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create
## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ## 安装或者升级你的@vue/cli npm install -g @vue/cli ## 创建 vue create vue_test ## 启动 cd vue_test npm run serve 2.使用 vite 创建 官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f45619b6db6fc5f5ed1560b253ac695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daffe4c0494aa5b02c09aec01e1bf900/" rel="bookmark">
			如何写出让同事骂娘的代码？教你20个小妙招
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 GitHub 上有一个项目，它描述了「最佳垃圾代码」的十九条关键准则。从变量命名到注释编写，这些准则将指导你写出最亮眼的烂代码。
为了保持与原 GitHub 项目一致的风格，下文没有进行转换。读者们可以以相反的角度来理解所有观点，这样就能完美避免写出垃圾代码。
项目地址：https://github.com/trekhleb/state-of-the-art-shitcode
当然，以下十九条垃圾代码书写准则并没有面面俱到，如果读者们发现有一些难以忍受的烂代码习惯，也可以发表你的看法。
💩 第一条：打字越少越好 如果我们键入的东西越少，那么就有越多的时间去思考代码逻辑等问题。如下所示，「Good」表示遵循该规则的示例，Bad 表示没遵循该规则的示例。
Good 👍🏻
let a = 42; Bad 👎🏻
let age = 42; 💩 第二条：变量/函数混合命名风格 我们需要混合命名方法与变量，这样才能体现命名的多样性。
Good 👍🏻
let wWidth = 640; let w_height = 480; Bad 👎🏻
let windowWidth = 640; let windowHeight = 480; 💩第三条：不要写注释 反正代码都看得懂，为什么要写注释？或者说，反正没人看我的代码，为什么要写注释？
Good 👍🏻
const cdr = 700; Bad 👎🏻
More often comments should contain some ‘why’ and not some ‘what’. If the ‘what’ is not clear in the code, the code is probably too messy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daffe4c0494aa5b02c09aec01e1bf900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d043ae9d479d4c55ddea653a43591dd3/" rel="bookmark">
			【LeetCode每日一题】2789. 合并后数组中的最大元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 [2789. 合并后数组中的最大元素](https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations/)思虑：代码： 2789. 合并后数组中的最大元素 思虑： 1.因为要合并的条件之一是，num[i]&lt;=num[i+1].所以将最后一个元素当做初始的值
2.从倒数第二个元素开始遍历，不断进行合并后面的元素
3.直到发现num[i]的元素，要大于后面所有合并的值，将合并的最大值更新为此时的num[i]
4.重新开始遍历合并。
代码： public long maxArrayValue(int[] nums) { int n = nums.length; long sum = nums[n - 1]; for (int i = n - 2; i &gt;= 0; i--) { if (nums[i] &lt;= sum) { sum += nums[i]; }else { sum = nums[i]; } } return (long) sum; } 点击移步博客主页，欢迎光临~
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/22/">«</a>
	<span class="pagination__item pagination__item--current">23/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/24/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>