<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e4dd23c889cbd1701226cb113a2b2ea/" rel="bookmark">
			vue通用后台管理系统（四）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		四、用户管理页面及登录页面 1. 用户管理页面 （1）用户管理页面及form组件介绍 用户管理页面分为三个部分：右上侧的表单搜索区，可以对用户进行搜索过滤；中间是列表的展示区，包含用户的姓名、年龄、性别、出生日期、地址和操作（对每一行数据进行编辑和删除）以及分页；左上角的新增区，可以新增用户信息
elementui----提供form表单、Pagination分页
（2）用户管理页面功能form页面编写 点击新增会弹出一个信息框，进行用户信息的新增
elementUI ----Dialog对话框 ,form表单....ui框架真的好方便啊
//User.vue &lt;template&gt; &lt;div class="manage"&gt; &lt;el-dialog title="提示" :visible.sync="dialogVisible" width="50%"&gt; &lt;!-- 用户的表单信息 --&gt; &lt;el-form ref="form" :inline="true" :model="form" label-width="80px"&gt; &lt;el-form-item label="姓名"&gt; &lt;el-input placeholder="请输入姓名" v-model="form.name"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label="年龄"&gt; &lt;el-input placeholder="请输入年龄" v-model="form.age"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-from-item label="性别"&gt; &lt;el-select v-model="formInline.sex" placeholder="请选择"&gt; &lt;el-option label="男" value="1"&gt;&lt;/el-option&gt; &lt;el-option label="女" value="0"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-from-item&gt; &lt;el-form-item label="出生日期"&gt; &lt;el-date-picker v-model="form.birth" type="date" placeholder="选择日期"&gt; &lt;/el-date-picker&gt; &lt;/el-form-item&gt; &lt;el-form-item label="地址"&gt; &lt;el-input placeholder="请输入地址" v-model="form.addr"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;span slot="footer" class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e4dd23c889cbd1701226cb113a2b2ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2235e24c6a060e8f8827d94d238acd0/" rel="bookmark">
			VSCode&#43;GDB&#43;Qemu调试ARM64 linux内核教程。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用VSCode、GDB和QEMU进行ARM64 Linux内核调试时，你可以按照以下步骤进行操作：
安装所需软件：
下载并安装VSCode，这是一种常用的开发工具，可用于编写、调试和管理代码。下载并安装GDB，这是一种功能强大的调试器，可用于调试应用程序和内核。下载并安装QEMU，这是一种虚拟化工具，可用于模拟ARM64架构的处理器和运行Linux内核。 配置VSCode插件：
在VSCode中安装"Native Debug"插件，它提供了与GDB的集成调试功能。 准备内核和根文件系统：
下载适用于ARM64架构的Linux内核源代码，并编译生成内核映像文件（例如 Image文件）。准备一个根文件系统镜像，其中包含了用于运行Linux的必要文件和配置。 创建VSCode调试配置：
在VSCode中创建一个 .vscode文件夹，并在其中创建一个 launch.json文件。 在 launch.json文件中配置调试器。以下是一个示例配置：
{ "version": "0.2.0", "configurations": [ { "type": "gdb", "request": "launch", "name": "Debug Linux Kernel", "target": "&lt;path_to_kernel_image&gt;", "cwd": "${workspaceRoot}", "gdbpath": "&lt;path_to_gdb&gt;", "gdbArgs": [ "--qemu", "-machine", "virt,gic-version=max", "-cpu", "max", "-s", "-S" ], "autorun": [ "target remote :1234", "symbol-file &lt;path_to_kernel_image&gt;" ] } ] } 在上述配置中，将 &lt;path_to_kernel_image&gt;替换为你编译生成的内核映像文件的路径，将 &lt;path_to_gdb&gt;替换为GDB可执行文件的路径。
启动QEMU和GDB调试器：
在终端中执行以下命令，启动QEMU模拟器并等待GDB连接：
qemu-system-aarch64 -M virt -cpu max -kernel &lt;path_to_kernel_image&gt; -s -S 在上述命令中，将 &lt;path_to_kernel_image&gt;替换为你编译生成的内核映像文件的路径。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2235e24c6a060e8f8827d94d238acd0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38fef9185b8d56ef57c13c732e8b30f3/" rel="bookmark">
			Repeater和Intruder的国产化平替Web Fuzzer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c30cf6e8eb27c787100aae19f42dc49/" rel="bookmark">
			卷积神经网络识别人脸项目—使用百度飞桨ai计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		卷积神经网络识别人脸项目的详细过程 整个项目需要的准备文件：
下载链接：
链接：https://pan.baidu.com/s/1WEndfi14EhVh-8Vvt62I_w
提取码：7777
链接：https://pan.baidu.com/s/10weqx3r_zbS5gNEq-xGrzg
提取码：7777
1、模型推理文件
2、模型转换文件
1、数据集准备 数据集的文件夹格式如下图：一共两个文件夹
images文件夹装所有的图片，图片需随机打乱和编号
labels文件夹内是对图片进行打标签操作的标签
打标签使用的是labelimg，安装过程可自行百度
open Dir是打开存放图片的路径，我们这里就是images文件夹
Change Save Dir是存放标签的路径，我们这里选择labels文件夹
打标签模式选择YOLO
然后点击Create RectBox选择关键位置就可以打标签了。
然后是上一级文件夹格式：
其中sex文件夹包括了上面两个文件夹
classes.txt是打标签是生成的，包括了标签的顺序和种类，这里的男女识别classes.txt内部就是：
man woman gen.py是用于随机提取出训练集和测试集
运行gen.py后，生成了train.txt，val.txt两个txt
train.txt就是训练集，包括了训练集的图片路径名称
val.txt同理
然后来到主文件夹中：
点击路径，运行cmd:
运行python yolov5_2_coco.py ，生成的文件夹保存到相应路径中
python yolov5_2_coco.py --dir_path D:\Pycharm\code\YOLO2COCO\dataset\YOLOV5 打包数据集，然后压缩后上传到百度飞桨ai数据集平台
2、模型训练 点击创建项目：
项目创建成功后，启动环境，选择一个GPU：
新建一个notebook文件，然后重命名为ppyoloe
上传PaddleYOLO文件
然后将上传的文件重命名为PaddleYOLO
然后进入此文件夹
cd /home/aistudio/PaddleYOLO 然后根据自己的模型实际情况，修改下图文件，num_classes是分类的种类，这里一共两种，所以改为2
dataset/sex是存放数据的位置，按实际情况修改，我这里是男女识别数据集，所以文件夹命名为sex
因为配置文件中要求数据放到dataset/sex里面，所以需要把数据集放置到此处。
新建一个mask文件夹，把解压过后的数据文件夹拖到mask里面。
粘贴到dataset文件夹下，注意红色框的路径。
如果想要修改迭代次数，在此处修改：
/home/aistudio/PaddleYOLO/configs/ppyoloe/_base_/optimizer_80e.yml epoch: 40 表示迭代次数为40次
输入下列代码，开始训练
第二行代码如果出错，权限不够，后面加上 --user
pip install -r requirements.txt --user 模型训练标志，此时是0 epoch
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c30cf6e8eb27c787100aae19f42dc49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecbee21891af5d665e09ecce9f4c3e52/" rel="bookmark">
			js实现两个大数的相加
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当两个数的值超出int类型最大值时相加就会产生精度丢失 但是如果是字符串是不会丢失精度的 所以可以从个位开始按位想加最后拼起来
function bigIntAdd(x, y) { const len = Math.max(x.length, y.length) // 取较长的数为要补0的长度 // 将数的位数对齐 x = x.padStart(len, '0') y = y.padStart(len, '0') let flag = '0' // 记录每个位相加时要进的位 const queue = [] // 存储结果 // 倒序从个位开始逐位相加 for (let i = len - 1; i &gt;= 0; i--) { const charX = x.charAt(i) const charY = y.charAt(i) // 求和时要加上上一次的进位 const sum = Number(charX) + Number(charY) + Number(flag) // 十进制加法满十进一 判断是否要进1位 不进位则为0 flag = sum &gt;= 10 ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ecbee21891af5d665e09ecce9f4c3e52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e60a81a20a68000077a6ac126fa649d2/" rel="bookmark">
			利用ChatGPT提高代码质量的5种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文首发于公众号：更AI (power_ai)，欢迎关注，编程、AI干货及时送!
5个可以提升你日常工作效率的ChatGPT特性 如何利用它提高代码质量 **ChatGPT已经彻底改变了开发代码的方式。**然而，大多数软件开发人员和数据专业人员仍然没有使用ChatGPT来提高和简化他们的工作。
这就是为什么我在这里列出了5种不同的特性，可以在你的日常工作中提高效率和质量。
你可以在你的日常工作中使用它们。让我们一起发现如何做到这一点 👇🏻
⚠️ 警告：你永远不应该在ChatGPT中使用关键代码或信息。
#1. 生成你的代码骨架 ChatGPT是我在从头开始构建新项目时的秘密武器。只需要几个提示，它就可以生成我需要的代码骨架，包括我选择的技术、框架和版本。它不仅每次至少为我节省一个小时左右的工作时间，而且还有助于保持我的文档 —— 或团队的文档 —— 的组织和更新。就像团队中有一双额外的手！
例如，假设我想要使用一些外部API。我可以要求ChatGPT为我草拟一个初始的代码结构。
生成整合外部API的初始代码框架，使用Python语言。
ChatGPT立刻就给出答复：
ChatGPT聊天截图。ChatGPT为我提供了一个代码骨架。
或者我甚至可以要求一个使用Selenium抓取LinkedIn的骨架，ChatGPT给我以下输出。
from selenium import webdriver from selenium.webdriver.common.keys import Keys import time # 初始化web驱动程序 driver = webdriver.Firefox() # 导航到LinkedIn driver.get(\"https://www.linkedin.com/\") # 查找电子邮件和密码输入字段 email = driver.find_element_by_id(\"username\") password = driver.find_element_by_id(\"password\") # 输入你的凭证 email.send_keys(\"YOUR_EMAIL\") password.send_keys(\"YOUR_PASSWORD\") # 点击登录按钮 driver.find_element_by_xpath(\"//button[@type='submit']\").click() # 等待页面加载 time.sleep(5) # 导航到所需用户的个人资料 driver.get(\"https://www.linkedin.com/in/USER_PROFILE_NAME\") # 从页面中提取你想要的信息 name = driver.find_element_by_xpath(\"//span[@class='inline t-24 t-black t-normal break-words']\"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e60a81a20a68000077a6ac126fa649d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441b582a8f6bc130188017136da5aaba/" rel="bookmark">
			Qt事件系统：鼠标事件和滚轮事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 QMouseEvent - 鼠标事件 QMouseEvent 类用来表示一个鼠标事件，当在窗口部件中按下鼠标、释放鼠标和移动鼠标指针时，都会产生鼠标事件 QMouseEvent。利用 QMouseEvent 类可以获知鼠标是哪个键按下释放了、鼠标指针的当前位置等信息。通常是重定义窗口部件的鼠标事件处理函数来进行一些自定义的操作。
Qt 中的 QMouseEvent 一般只涉及按下鼠标、释放鼠标和移动鼠标指针等操作，而对鼠标滚轮的响应则通过 QWheeEvent 来处理。鼠标移动事件只会在按下鼠标按键的情况下才会发生，除非通过显式调用。QWidget::setMouseTracking() 函数来开启鼠标轨迹，这种情况下只要鼠标指针在移动，就会产生一系列的 Qt 鼠标事件。 QMouseEvent 的传递
多个重叠的窗口在实现里好比一个递归的倒立树，鼠标事件会沿着鼠标指针所在的父窗口的链表向上传递，直到某个窗口调用 accept() 函数进行事件处理，否则该事件将被过滤销毁掉。
如果想要鼠标指针所在的父窗口不接收该事件，则可以调用函数 ignore() 予以忽略。如果一个鼠标事件传递给鼠标指针所在的窗口，而该窗口的 QT::WA_NoMousePropagation 位置为TRUE，则该事件不会通过父窗口继续向上传递。可以使用 QWidget::setEnabled() 来开启/关闭对应的窗口是否接受键盘和鼠标事件。 鼠标事件实例
鼠标事件使用的时候，加头文件 &lt;QMouseEvent&gt;，然后在头文件中重写这些函数：
#include &lt;QMouseEvent&gt; protected: // 鼠标按下事件 void mousePressEvent(QMouseEvent * event); // 鼠标释放事件 void mouseReleaseEvent(QMouseEvent *event); // 鼠标移动事件 void mouseMoveEvent(QMouseEvent *event); 然后就是在源文件中去实现具体的逻辑了：
// 鼠标按下事件 void MainWindow::mousePressEvent(QMouseEvent * event) { if(event-&gt;button() == Qt::LeftButton) { qDebug() &lt;&lt; "左键按下" ; } else if(event-&gt;button() == Qt::RightButton) { qDebug() &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/441b582a8f6bc130188017136da5aaba/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6c78d508409731c94030420c862a6a1/" rel="bookmark">
			MySQL(详细)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是数据库?
数据库操作
表操作
数据库约束
表的设计
聚合查询
分组查询
联合查询 (多表查询)
索引
事务
JDBC
什么是数据库? 数据库是一类软件 , 它是用来组织、保存、管理数据的.组织这些数据也是为了后续进行增删查改.
MySQL 是一款开源免费的数据库. 是一个 " 客户端服务器 " 结构的程序 .
MySQL 服务器为了更好的组织数据 , 把要存的数据划分为多个数据集合 , 这些数据集合也称为 "数据库" , 每个数据库里 会存在许多" 表 " ,(这些表类似于 excle 表格 , 有许多行 列 , 有表头用来描述每一列是什么意思 ) , 每个表里有许多条记录 (record) , 每个记录也就是一行 (row) , 每一行这里又有很多列 (column) , 每个列也称为字段 (field) .
数据库操作 通过SQL语句来操作数据库.
在写 sql 时 , sql 的关键字大小写是不敏感的 , 不论是 大写 还是 小写就是可以的.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6c78d508409731c94030420c862a6a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00403c10ecd4e63047d06c6147ac039a/" rel="bookmark">
			Python程序结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 顺序结构
2. 分支结构
3. 循环结构
1. 顺序结构 顺序结构：python是一门解释型语言，它的执行过程一般是解释一行，执行一行。
2. 分支结构 2.2 分支结构 分支结构基本语法
if 条件表达式
语句一
语句二
语句三
......
条件表达式就是计算结果必须为布尔值的表达式
表达式后面的冒号不能少
注意if后面出现的语句，如果属于if语句块，则必须同一缩进等级
条件表达式结果为True执行if后面的缩进的语句块
2.2 双向分支 if…else…表达
语法结构：
if条件表达式:
语句一
语句二
...
else:
语句一
语句二
...
2.3 多路分支 很多分支的情况，叫多路分支
if 条件表达式：
语句1
…
elif 条件表达式：
语句1
…
elif 条件表达式：
语句1
…
else:
语句1
… …
elif可以有好多个，根据实际情况
else可选
多路分支最多只会执行一种情况
3. 循环结构 循环结构：python中循环结构有两种：while循环和for循环，while循环一般应用在普通循环条件控制，for循环一般应用在序列数据循环。循环结构中有几个关键字：break关键字：用在循环结构中，执行此关键字时跳出当前循环。Contiune关键字：结束此次循环，直接开始下一次循环。else关键字：应用在循环结束后，当循环执行过程中没有执行break关键字，循环结束后执行else关键字中的代码。如果执行了break关键字，则循环结束后不执行else关键字中的代码。循环结构可以减少源程序重复书写的工作量(代码量)，用来描述重复执行某段算法的问题，这是程序设计中最能发挥计算机特长的程序结构。
break：代表终止整个循环结构
continue：代表中止当前本次循环，继续下一次循环
Python中循环结构分为两类，分别是 while 和 for .. in
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/00403c10ecd4e63047d06c6147ac039a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f75a026c67a74e2dece9b349269fdee/" rel="bookmark">
			【c&#43;&#43;修行之路】IO流架构及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言输入输出库文件读写序列化与反序列化结语 前言 大家好久不见，今天一起来学习c++中的IO流。
输入输出库 这两张架构图略显复杂，这里给出一张比较清楚的IO流架构图：
也就是说，我们平时使用的诸如cin、cout、cerr、clog都是来自 &lt;iostream&gt; 这个头文件下的，他们分别是
&lt;istream&gt; 头文件下的istream和ostream的实例对象。
&lt;istream&gt; 头文件里的iostream继承了istream和ostream两个类，因此在 &lt;fstream&gt; 和 &lt;sstream&gt; 类里的fstream和sstream都兼具对应的io功能。
文件读写 这里顺便说明一下：友元的实现是编译器通过特殊机制授权让这个函数能拿到类的成员的，而不是通过this指针拿到的，而istream其实就是basic_istream&lt;char, char_traits&lt;char&gt;&gt;的一个别名.
class Date {	//友元关系不会被继承 friend istream&amp; operator &gt;&gt;(istream&amp; in, Date&amp; date); friend ostream&amp; operator &lt;&lt;(ostream&amp; out, const Date&amp; date); public: Date(int year = 1, int month = 1, int day = 1) :_year(year) , _month(month) , _day(day) {} operator bool() { if (_year == 0) return false; return true; } private: int _year; int _month; int _day; }; //输入重定向 // //decltype(cin)&amp; operator &gt;&gt;(decltype(cin)&amp; no,const Date&amp; date) //basic_istream&lt;char, struct std::char_traits&lt;char&gt;&gt;&amp; operator &gt;&gt;(decltype(cin)&amp; no, const Date&amp; date) //basic_istream&lt;char&gt;&amp; operator &gt;&gt;(decltype(cin)&amp; no, const Date&amp; date) istream&amp; operator &gt;&gt;(istream&amp; in, Date&amp; date) { //cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f75a026c67a74e2dece9b349269fdee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5c55e508390806c17853420109f42f0/" rel="bookmark">
			常见python报错整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		'int' object has no attribute 'startwith'：函数使用的数据格式错误
'list' object is not callable：
callable()是python的内置函数，用来检查对象是否可被调用，可被调用指的是对象能否使用()括号的方法调用，类似于iterable（）
在如上代码中，由于变量list和函数list重名了，所以函数在使用list函数时，发现list是一个定义好的列表，而列表是不能被调用的，因此抛出一个类型错误
pop() takes at most 1 argument (2 given)：参数设置过多
Python错误：TypeError: 'list' object is not callable_Big_quant的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d179046ebf13f321eec01431ccfaca24/" rel="bookmark">
			MATLAB结构体
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
创建结构体
1. 使用语法创建结构体：
2. 使用字段数组和值数组：
3. 逐个为字段赋值：
访问方式
1. 使用点号操作符：
2. 使用索引操作符：
3.使用变量访问
常用函数
`isfield`函数
`rmfield`函数
`fieldnames`函数
MATLAB中的结构体是一种数据结构，相当于一个容器，用于存储和组织相关的数据和信息。结构体是一种灵活的方式，可以将不同类型的数据存储在一个单独的变量中，并对其进行访问和操作。
当创建结构体时，可以使用不同的方式指定字段名和字段值。
创建结构体 以下是几种常见的方式：
1. 使用语法创建结构体： s = struct('field1', value1, 'field2', value2, ...) name = 'John'; age = 30; city = 'New York'; person = struct('name', name, 'age', age, 'city', city); 2. 使用字段数组和值数组： fields = {'field1', 'field2', ...}; values = {value1, value2, ...}; s = cell2struct(values, fields, 2); fields = {'name', 'age', 'city'}; values = {'John', 30, 'New York'}; person2 = cell2struct(values, fields, 2); 可以看出其效果与方法一一致。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d179046ebf13f321eec01431ccfaca24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4778f1a3016fc0b3083ff76d92a6d990/" rel="bookmark">
			AIGC文生图：stable-diffusion-webui部署及使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 stable-diffusion-webui介绍 Stable Diffusion Web UI 是一个基于 Stable Diffusion 的基础应用，利用 gradio 模块搭建出交互程序，可以在低代码 GUI 中立即访问 Stable Diffusion
Stable Diffusion 是一个画像生成 AI，能够模拟和重建几乎任何可以以视觉形式想象的概念，而无需文本提示输入之外的任何指导Stable Diffusion Web UI 提供了多种功能，如 txt2img、img2img、inpaint 等，还包含了许多模型融合改进、图片质量修复等附加升级。通过调节不同参数可以生成不同效果，用户可以根据自己的需要和喜好进行创作。我们可以通过Stable Diffusion Web UI 训练我们自己的模型，它提供了多种训练方式，通过掌握训练方法可以自己制作模型。 2 stable-diffusion-webui安装部署 2.1 conda环境安装 conda环境准备详见：annoconda
2.2 运行环境构建 git clone https://github.com/AUTOMATIC1111/stable-diffusion-webui.git cd stable-diffusion-webui conda create -n sdw python=3.9 conda activate sdw pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118 注意：pytorch版本下载，根据本地环境选择对应的版本，下载地址：地址
2.3 模型下载 （1）模型文件
模型下载地址：地址，下载完成后，按下面的目录存放
mkdir -p models/Stable-diffusion/ mv /opt/v1-5-pruned-emaonly.safetensors models/Stable-diffusion/ （2）通过proxy下载，解决下载慢或下载失败的问题
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4778f1a3016fc0b3083ff76d92a6d990/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62476720b7a9b676a01d3daba15cde9e/" rel="bookmark">
			Ansible Vault加密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 加密host加密敏感数据 加密host 我们有时候需要非免密登陆，往往这样才是正式环境，免密登陆机器有着不安全性。
但是，ansible要控制远程主机，就要在/etc/ansible/host文件中去写响应的用户名加密码。如下：
[web] example.com ansible_user=your_username ansible_password=your_password 在这个例子中，我们定义了一个名为web的主机组，并为example.com指定了用户名和密码。当您运行Ansible playbook时，Ansible会使用提供的用户名和密码连接到远程主机。
将密码明文写在Ansible inventory文件中是不安全的做法，因为其他人可以访问该文件并获取密码。为了提高安全性，您应该考虑使用其他身份验证方法，例如SSH密钥对。如果您必须使用密码进行身份验证，请确保安全地存储您的密码，并在必要时更改它们。
另外，如果您使用的是较新版本的Ansible（2.5或更高版本），则建议使用Vault来加密您的密码。Vault是Ansible提供的一种安全存储敏感信息的方法。
那么怎么加密呢？
ansible-vault encrypt /etc/ansible/hosts New Vault password: your_password_file Confirm New Vault password: your_password_file 就发现cat /etc/ansible/hosts非正常文件内容，而是一些无关数字。
如何调用呢？
将文件密码保存到文件，并且给予600权限，保护文件
cat "your_password_file" &gt;/etc/ansible/.ansible_host_passwd chmod 600 /etc/ansible/.ansible_host_passwd ansible all -m ping --vault-password-file /etc/ansible/.ansible_host_passwd 就能使用了。
加密敏感数据 Ansible Vault 是一个用于加密敏感数据的工具，例如密码、私钥、API 密钥等。以下是 Ansible 使用 Vault 加密密码的示例：
创建一个 Vault 文件
ansible-vault create passwords.yml 此命令将打开一个编辑器并提示输入密码。在编辑器中，添加以下内容：
--- db_password: mysecretpassword 保存并关闭文件。
加密已有文件中的密码
如果您已经有一个包含密码的文件，并且希望加密密码，请运行以下命令：
ansible-vault encrypt path/to/passwords.yml 此命令将提示您输入密码并使用该密码加密文件中的密码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62476720b7a9b676a01d3daba15cde9e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5bc3b8994b0daadcc41813ad88f41948/" rel="bookmark">
			【学习笔记】Windows 下线程同步之互斥锁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言环境简介相关函数CreateMutexWait 函数ReleaseMutexCloseHandle 其他互斥锁的名字未命名互斥锁的同步互斥锁的意外终止临界区对象 示例参考 前言 本文所涉及的同步主要描述在 Windows 环境下的机制，和 Linux 中的同步机制有一定的联系，但注意并不完全相同。类似于，Windows 和 Linux 按照自己的方式实现了操作系统中同步机制的概念本文记录的是 Windows 下的互斥锁同步机制，但在 Windows 的同步机制中，其中很多的概念和逻辑同样适用于事件（Event），信号量，计时器等其他同步机制 环境 OS：winIDE：Visual Studio 2015 简介 简介：互斥锁是一种同步对象，当没有任何线程拥有互斥锁时，互斥锁处于有信号（signaled）状态，当互斥锁被某个线程拥有，则它处于无信号状态（nonsignaled）。
顾名思义，互斥锁就是一种为了达到访问共享资源而互斥目的的锁。比如生活中，公共厕所就是一种共享资源，公厕一次只能有一个人使用，使用者在使用的时候就会关门上锁，使用完之后需要开门释放锁。对于每个使用者来说，这个锁一次只能被一个人占有
特点
任何一个互斥锁，一次只能被一个线程拥有可以跨进程使用，即进程间同步 适用场景：同步一些共享资源，比如共享内存（shared memory）
相关函数 CreateMutex 作用：创建或打开命名或未命名的互斥锁对象。如果某互斥锁已经被创建，当再次使用 CreateMutex 操做该互斥锁，实际的操作等效于 OpenMutex，但通过 GetLastError 会返回 ERROR_ALREADY_EXISTS 标识语法 HANDLE CreateMutexA( [in, optional] LPSECURITY_ATTRIBUTES lpMutexAttributes, [in] BOOL bInitialOwner, [in, optional] LPCSTR lpName ); 参数 lpMutexAttributes，为 NULL 时，句柄不能被子进程继承bInitialOwner，为 true 时，创建该互斥锁的线程获取该互斥锁lpName，互斥锁的名字，为 NULL 时，为未命名互斥锁，关于未命名互斥锁如何传递见下方“未命名互斥锁的同步” Wait 函数 Wait 函数是一系列提供类似功能的等待函数（如 WaitForMultipleObjects），该函数的作用是请求某个互斥锁的使用权，若没有获取到，则阻塞等待函数的返回值表明等待函数因为某些原因返回，而不是正常的互斥锁信号转换多个线程等待互斥锁时，只有一个线程会被随机选择获取互斥锁 ReleaseMutex 作用：释放控制权，释放后，互斥锁变为有信号状态语法 BOOL ReleaseMutex( [in] HANDLE hMutex ); 参数：hMutex 是要释放的互斥锁句柄 CloseHandle 作用：关闭句柄，本文中即关闭互斥锁
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5bc3b8994b0daadcc41813ad88f41948/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/133819c7ee6afc6a5cf6c0ee7751860c/" rel="bookmark">
			Vue3的从入门到实战的培训教程大纲
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Vue3的从入门到实战的培训教程大纲 第一部分：Vue3入门 Vue框架概述
介绍Vue的历史和特点解释Vue的MVVM架构 Vue3的新特性
对比Vue2和Vue3的主要差异强调Vue3的性能改进和优化 安装与配置Vue3
下载和安装Vue CLI创建一个新的Vue项目介绍Vue项目的目录结构 Vue实例与模板语法
创建Vue实例解释Vue的模板语法和指令介绍Vue中的数据绑定和事件处理 组件开发
创建和注册Vue组件组件之间的通信（props和events）使用Vue的单文件组件开发方式 第二部分：Vue3进阶 Vue3响应式系统
Vue3的响应式原理使用Vue3的Composition API 路由管理与导航
安装和配置Vue Router创建和管理路由实现导航和路由守卫 状态管理与Vuex
安装和配置Vuex创建和管理全局状态在组件中使用Vuex 表单处理与验证
使用Vue3的表单处理技术表单数据绑定和验证自定义表单组件 Vue3的动画与过渡
使用Vue3的过渡和动画实现元素的淡入淡出、滑动等效果 第三部分：Vue3实战项目 项目概述与需求分析
选择一个实际项目案例分析项目需求和功能 项目架构与组织
设计项目的组件结构实现项目的路由和状态管理 开发项目功能模块
实现项目的核心功能模块使用Vue3的高级特性优化代码 项目调试与优化
调试Vue3项目的常见问题优化Vue3项目的性能和用户体验 部署与发布项目
打包和部署Vue3项目将项目发布到线上服务器 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4138ecd979cb25f42c1497a15951f8b/" rel="bookmark">
			rocketmq使用mqtt协议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、安装rocketmq二、打包rocketmq-mqtt三、配置rocketmq-mqtt四、初始化操作五、启动六、测试 前言 rocketmq从4.9.3开始，可以兼容mqtt协议，需要安装编译一个rocketmq-mqtt工程，参考：https://rocketmq.apache.org/zh/docs/4.x/mqtt/02RocketMQMQTTQuickStart/
一、安装rocketmq 需要安装rocketmq4.9.3以上的版本
安装过程略
broker.conf配置文件中添加参数，开启多队列分发特性
enableLmq = true enableMultiDispatch = true 二、打包rocketmq-mqtt 安装maven配置环境变量
过程略
下载并打包
git clone https://github.com/apache/rocketmq-mqtt cd rocketmq-mqtt mvn -Prelease-all -DskipTests clean install -U cd distribution/target/ target下是打包的包 三、配置rocketmq-mqtt 下面例子中 ROCKETMQ所在机器192.168.33.22，ROCKETMQ-MQTT服务所在机器172.16.10.160
修改conf/connect.conf
mqttPort=1883 enablePrometheus=true 修改conf/meta.conf
IP换成要运行服务的机器的
selfAddress=172.16.10.160:25000 membersAddress=172.16.10.160:25000 修改conf/service.conf
metaAddr的IP换成要运行服务的机器的
username和secretKey配置了要记住，mqtt生产者要使用它做认证
eventNotifyRetryTopic=xx //notify重试topic，提前创建
clientRetryTopic=xx //客户端消息重试topic，提前创建
NAMESRV_ADDR的IP换成RocketMQ nameserver服务所在机器的IP
username=test secretKey=test NAMESRV_ADDR=192.168.33.22:9876 eventNotifyRetryTopic=eventNotifyRetryTopic clientRetryTopic=clientRetryTopic metaAddr=172.16.10.160:25000 四、初始化操作 创建topic
mqadmin updatetopic -c {cluster} -t {topic} -n {namesrv} 上面配置的eventNotifyRetryTopic和clientRetryTopic也必须创建
实际执行如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4138ecd979cb25f42c1497a15951f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6088e21b7e2d883545453bbafa3a4fe3/" rel="bookmark">
			rpm包名,软件包名,程序名和rpm包,源码包的安装说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
RPM包的命名规则
Linux_RPM包详解 什么是RPM包
RPM包的特点
RPM包的安装
RPM常用选项
编译安装和软件包安装
为什么linux安装程序 都要放到/usr/local目录下？
linux configure 的 --prefix 参数的作用
rpm包的卸载与安装
RPM命令的--nodeps 和--force参数解释
yum 下载全量依赖 rpm 包及离线安装（终极解决方案）
RPM包的命名规则 示例：bind-9.8.2-0.47.rc1.el6.x86_64.rpm #rpm包名
1.name，如：bind，是软件包的名称
2.version，如：9.8.2-0，是软件的版本号，版本号格式通常为“主版本号.次版本号.修正号”。47，是发布版本号，表示这个rpm软件包是第几次编译生成的
3.arch，如i386，是表示包适用的硬件平台，目前rpm支持的平台有：i386，i586，i686，sparc和alpha
4..rpm和.src.rpm，是rpm包类型后缀，rpm是编译好的二进制包，.src.rpm是源码包
5.特殊名称：
（1）el*：表示发行商的版本，el6表示这个软件包是在rhel6.x/centos6.x下使用；
（2）devel：表示这个rpm包是软件的开发包
（3）noarch：说明这样的软件包可以在任何平台安装和运行，不需要特定的硬件平台
例如 httpd-manual- 2.0.40-21.i386.rpm
httpd-manual ----- 软件包名称
2 ----- 主版本号
0 ----- 次版本号
40 ----- 次版本号
21 ----- 编译的次数
i386 ----- 适合的平台
rpm ----- 说明是一个RPM包
地址：https://www.cnblogs.com/yatolovefantasy/articles/13666958.html#_labelTop
#############################################################################
rpm包名软件包名程序名的说明：
[root@iZbp16mm3xbwen89azh9ffZ ~]# rpm -qf `which mkfs.ext4` #显示文件是什么软件包安装的
e2fsprogs-1.42.9-13.el7.x86_64 2fsprogs-1.42.9-13.el7.x86_64.rpm为rpm包名，e2fsprogs为软件包名，mkfs.ext4为应用程序名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6088e21b7e2d883545453bbafa3a4fe3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28537e14fd109f62c73af202f811c4ac/" rel="bookmark">
			java线程池ThreadPoolExecutor
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、概念
二、工作原理
1. 初始化线程池
2. 提交任务
3.ThreadPoolExecutor的参数列表
处理方式有4种
处理方式总结
三、创建线程池的两种方案
1.ExecutorService接口的实现类ThreadPoolExecutor自己定义线程池
用Runnable接口的实体类来接
用Callable接口的实体类来接
2.Executors(线程池的工具类）方法newFixedThreadPool(int 线程数量)
两种方式的优缺点
四、两种终结线程池的方法
shutdown（）
shutdownNow（）
五、来聊聊一些小细节
说到临时线程，临时线程什么时候被调用呢？上面的代码中可以看到一共出书了三次线程池对象，拿到了4个数据的变化，
总结
一、概念 线程池就是一个可以复用线程的技术，线程池可以解决线程冗余的问题，如果每个用户都要创建一个新线程来处理，当数量多了会影响系统的性能。这篇文章主要说了线程池的执行流程，临时线程什么时候开始工作，创建线程池的方式。
二、工作原理 线程池由线程池管理器、任务队列和一组工作线程组成。 比如有3个线程对6个任务，那么为了复用线程，一个线程处理完一个任务以后不会销毁，而是处理下一个任务。
1. 初始化线程池 线程池管理器创建一定数量的工作线程，并将它们放入线程池中等待任务。
ThreadPoolExecutor tp = new ThreadPoolExecutor( 3,//线程数 10,//最大线程数=线程数+临时线程 1000,//临时线程的保留时间 TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(6),//等待队列长度 6 Executors.defaultThreadFactory(),//生产线程的工厂 new ThreadPoolExecutor.AbortPolicy() ); 2. 提交任务 当有任务需要执行时，应用程序通过将任务提交给线程池管理器来执行。任务可以是一个实现Runnable或Callable接口的对象。
class MyRunnable implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+"~~"); } } MyRunnable mr = new MyRunnable(); tp.execute(mr); 3.ThreadPoolExecutor的参数列表 new ThreadPoolExecutor(
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28537e14fd109f62c73af202f811c4ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9219786514dec9d5d53721c32dec8b88/" rel="bookmark">
			vue通用后台管理系统（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三、Home组件 1.Home组件布局 整个页面布局分为左右两个部分------element-ui中的Layout 布局，以及自适应、鼠标移入时阴影效果的实现------element-ui中的Card卡片布局
span：表示左右侧页面所占用的比例，一共是24份
flex布局：能让相邻的两行内容在一行显示
（1）左侧部分布局--用户信息展示部分 ①内容的构建--左侧上面部分
②样式的调整---左侧上面部分
.user { display: flex; align-items: center; //垂直居中 img { margin-right:40px; width: 150px; height: 150px; border-radius: 50%; } .userinfo { .name { font-size: 32px; margin-bottom: 10px; } .access{ color: #999999; } } } ③内容的构建--左侧下面部分
④样式的调整--左侧下面部分
.user { padding-bottom: 20px; margin-bottom: 20px; } .login-info { p { line-height: 28px; font-size: 14px; color:#999999; span { color: #666; margin-left: 60px; } } } （2）左侧部分布局--home购买统计部分 数据展示一般使用table、鼠标移入有高亮显示----element-ui中的Table表格组件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9219786514dec9d5d53721c32dec8b88/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/129/">«</a>
	<span class="pagination__item pagination__item--current">130/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/131/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>