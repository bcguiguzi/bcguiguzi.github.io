<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e356dffdf5f6c09e2a44a0c8a6c5859/" rel="bookmark">
			大数据面试要点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据面试训练题： 数据库： 数据库中join可以替换成子查询修改缺省值：alter table 表名 alter column 字段名 set default 默认值全文索引：select *from table where mactch(列名) against(‘关键字’)关系型数据库中，用来表示实体间联系的是二维表mysql的几种语言： 数据查询语言（DQL）查询表数据数据操作语言（DML）修改表数据数据控制语言（DCL）管理权限数据定义语言（DDL）修改表结构事务处理语言（TPL）处理事务 stuff（原字符，开始位置，删除长度，插入字符） linux： find -name ‘abc’ ：寻找文件夹下名字为abc的文件
grep -ri ‘abc’:匹配二进制文件里含有abc的文件
权限：-rwx–r-wx
0位：文件类型
1-3位：所有者拥有该文件的权限（r：可读，w：可写，x：可执行）
4-6位：所属组（同用户组的）拥有该文件的权限
7-9位：确定其他用户拥有该文件的权限
用户管理相关的配置文件：
/etc/passwd:存放用户的UID name密码过期时间，修改时间等等
/etc/shadow:存放密码密文
/ect/group:存放用户所属组的情况
可以重启的命令：
shutdown -r nowrebootinit6 top：查看内存
查看磁盘存储情况:df -h
查看磁盘IO读写情况：iotop
查看端口占用情况：netstat -tunlp|grep 端口号
查看进程：ps aux
Hadoop： 序列化和反序列化：
序列化：就是把内存中的对象，转换成字节序列以便于存储（持久化）和网络传输
反序列化：将收到的字节序列或者磁盘的持久化存储数据，转换成内存中的对象
mapreduce过程: 分片、格式化数据源：
将文件进行拆分，每一片大小为128M，每一片对应一个map任务，每一个任务会执行一个自定义的map（）函数，然后将分好的分片格式化成键值对形式的数据
执行MapTask：
每个Map任务都有一个内存缓冲区（缓冲区大小为100M），Map任务处理的中间结果，会写入内存缓冲区中，写入缓冲区的数据达到80%就会将溢出数据写入磁盘里，溢写过程中，MapReduce框架会对Key进行排序，如果中间结果比较大，会形成多个溢写文件，最后的缓冲区数据也会全部写入磁盘形成一个溢写文件，如果是多个溢写文件，最后将合并所有的溢写文件为一个文件
执行Shuffle过程
Shuffle会将MapTask输出的处理结果数据，分发给ReduceTask，并在分发的过程中，对数据按Key进行分区和排序
执行ReduceTask
输入ReduceTask的数据流是&lt;key,{value list}&gt;形式，用户可以自定义reduce（）方法进行逻辑处理，最终以&lt;key，value&gt;的形式输出
写入文件
MapReduce框架会自动把ReduceTask生成&lt;key,vlaue&gt;传入OutputFormat的write方法，实现文件的写入操作
shuffle过程： shuffle在map阶段也有，reduce阶段也有
从map产生输出到reduce消化输入的过程
分为map阶段和shuffle阶段：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e356dffdf5f6c09e2a44a0c8a6c5859/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15cee53ea12082579ab6cf7e9432163c/" rel="bookmark">
			Android -- WiFi的NUD检测机制浅析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android -- WiFi的NUD检测机制浅析 这段时间遇到几次WiFi连接后，突然断连的问题，最后发现是由于Android的NUD检测机制导致的。NUD(Neighbor Unreachable Detection,邻居不可达检测)的底层实现还是依赖kernel，Android层有服务建立通信，当kernel检测到当前网络与周边的neighbor不可达时，就会发送消息通知上层，上层处理msg、最后WiFi会transfer到Disconnect STATE，最后导致网络自己断开，这会影响用户体验，让用户产生困扰。
这里我们主要介绍一下Android FWK中关于NUD的流程，以便加深对这个流程的了解，这样可以方便我们后续解决相关的问题，或者加些小定制。
当用户点击WiFi开关，打开WiFi后，WiFiStateMachine会进入ConnectMode，准备处理用户的连接请求：
class ConnectModeState extends State { @Override public void enter() { Log.d(TAG, "entering ConnectModeState: ifaceName = " + mInterfaceName); mOperationalMode = CONNECT_MODE; setupClientMode(); if (!mWifiNative.removeAllNetworks(mInterfaceName)) { loge("Failed to remove networks on entering connect mode"); } mScanRequestProxy.enableScanningForHiddenNetworks(true); mWifiInfo.reset(); mWifiInfo.setSupplicantState(SupplicantState.DISCONNECTED); mWifiInjector.getWakeupController().reset(); mNetworkInfo.setIsAvailable(true); if (mNetworkAgent != null) mNetworkAgent.sendNetworkInfo(mNetworkInfo); // initialize network state setNetworkDetailedState(DetailedState.DISCONNECTED); // Inform WifiConnectivityManager that Wifi is enabled mWifiConnectivityManager.setWifiEnabled(true); // Inform metrics that Wifi is Enabled (but not yet connected) mWifiMetrics.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15cee53ea12082579ab6cf7e9432163c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e048f96220157127231dbbf8fb83ec2/" rel="bookmark">
			c#foreach语句中break 和continue的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在foreach中使用break时，会结束整个foreach循环；在foreach中使用 continue时，会结束当前的循环，继续下一轮的循环，并不会跳出整个循环； Demo:
public static void ContinueAndBreakInForeach() { List&lt;int&gt; list = new List&lt;int&gt;(); for (int i = 0; i &lt; 5; i++) { list.Add(i); } Console.WriteLine("break in foreach statement \n"); foreach (int item in list) { if (item == 2) { break; } else { Console.Write(item + "\t"); } } Console.WriteLine("\n continue in foreach statement"); foreach (int item in list) { if (item == 2) { continue; } else { Console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e048f96220157127231dbbf8fb83ec2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75cc2fdbf44a5ac1b9ea5b48e51f195/" rel="bookmark">
			B树和B&#43;树详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		B树、B+树看这一篇就够了 @[TOC](B树、B+树看这一篇就够了) 引言B树什么是B树以及B树是怎么来的B树的基本性质B树的新增和删除B树的插入B树的删除 B+树什么是B+树以及为什么要有B+树B+树的基本性质B+树的查找 B树与B+树的比较B+树的优势B树的优势两者的细节对比 B树与B+树在实际代码中的应用总结 引言 在实际的编程学习中我们经常可以在各种框架、算法中看见B树、B+树的身影。特别是在数据库的数据库引擎中，它们更是占据着重要的地位。 下面我将通过B树、B+树的由来、作用、操作以及它们在实际中的应用依次进行详细说明。
B树 什么是B树以及B树是怎么来的 我们学习B树之前我们一般都学习过了二叉排序树与二叉平衡树这两种数据结构。对于一棵二叉排序树来说，当我们要查询我们需要的数据时，我们最多只需要比较树高的次数就可以判断我们所要找的关键字是否在树中。因此二叉排序树是已经是一个相当优秀的查找算法了。在树排列比较好的情况下甚至我们的查找次数不会超过log2n次(n为数据的总数)。
但是这里存在了一个问题，但就是在我们的实际使用中，我们面对的数据总量通常是海量的，一个二叉查找树先不论其在极端情况下（每棵树只有一个孩子）的查找情况，即便是在最好的情况下（平衡树或完全二叉树）查找树也会因为数据量太大而造成树高过高，即找一个数据依旧需要花费更多时间。因此我们在这里引入了多叉排序树来解决问题。
多叉排序树我们不一定可以搜到，因为这理论上不是一种常见的数据结构，而是属于简化版的B树，属于一种概念，其树形如下图（4叉查找树）。
由于多叉树每个结点都能存在多个数据以及拥有有多个分支（n叉查找树每个结点最多有n个分支，n-1个元素），因此对于同样一个数量级的数据来说，多叉树可以有效地减少查找树的树高即只需要查找少量次数就可以找到我们要的数据。
但是此时又有一个问题，那就是如果在某些情况下每个结点内的关键字太少，那么多叉查找树依旧会退化回二叉查找树，即由于每个结点内元素太少导致的树高过高。这样的查找效率依旧很低。如下图
因此我们引入一个新的策略，即规定除了根结点外，（m叉查找树）任何结点至少有⌈m/2⌉-1个关键字。这样可以保证这棵树至少不会变的很高。
至于为什么根结点除外，是因为做不到根结点符合条件（只有一个元素的时候就不可能完成这条性质）
但是此时还有一个问题，当一棵m叉查找树在满足上述条件时，每个结点只存在一棵子树，那么树高的问题依旧无法避免。如下图。
因此我们引入最后一条策略来保证查找效率，即规定对于任何一个结点，其所有子树的高度要一致，也就是保证我们m叉查找树的绝对平衡。这样我们的m叉查找树才会拥有最好的查找效率。
上述的最终得到的就是我们的==B树==了
B树的基本性质 在看完上面关于B树的由来后，我们应当能够理解B树的几条性质了
B树，又称多路平衡查找树。B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树要么是空树，要么满足以下性质：
每个结点，至多 有m棵子树，即至多含m-1个关键字若根结点非终端结点，则至少有两棵子树除根结点外，所有非叶子结点至少有⌈m/2⌉，即至少含有⌈m/2⌉-1个关键字所有叶子结点都出现在同一层次上，并不带信息（即NULL）。即绝对平衡 典型的B树(4阶)如下图所示：
B树的新增和删除 B树的插入 针对m阶高度h的B树，插入一个元素时，首先在B树中是否存在，如果不存在，则在终端结点中插入该新的元素。
若该节点元素个数小于m-1，直接插入；若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中 - 间两个随机选取）插入到父节点中；重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1； 下面是往B树中依次插入
6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4
的演示动画：
B树的删除 B树的删除相对于插入来说较为复杂。
删除分为两种情况：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75cc2fdbf44a5ac1b9ea5b48e51f195/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3edb493d48752e125aa4c003770bd3a7/" rel="bookmark">
			因果表征学习最新综述：连接因果科学和机器学习的桥梁
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导语 处于信息时代的我们，有幸经历了轰轰烈烈的以数据为中心的大数据革命（涉及机器学习，深度学习及其应用，例如 Alpha-Go, GPT-3, 自动驾驶等），深刻改变了我们生活的方方面面。如今另外一场相对不那么广为人知，但是同样重要的因果革命正在进行，它以因果科学中心并席卷了各个领域，尤其是人工智能。近日，一篇探索让 AI 系统攀登因果之梯的深刻综述文章“Torwards Causal Representation Learning”引起了大家广泛的关注。该文章可以视作 Bernhard Schölkopf 2019 年的 Judea Pearl 亲自点赞文章 “Causality for Machine Learning ”的姐妹篇，并且结合了 Yoshua Bengio 等人在表征学习上的深度思考，是因果结合机器学习的必读佳作，是2021年因果表征学习的第一课。
这篇名为Towards Causal Representation Learning的综述文章由因果领域领军人物马普智能系统所所长Bernhard Schölkopf及深度学习三巨头之一的Yoshua Bengio等人撰写。顾名思义，何为因果表征causal representation呢？其又拥有怎样优良的性质使我们想要学习因果表征呢？
为了回答这些问题，让我们从表征学习说起。表征学习Representation Learning是机器学习中的重要问题，良好的表征是机器学习算法成功的重要条件；正因如此，近十年来深度学习借助神经网络强大的表达能力、海量的数据以及强大的算力，自动地从数据中学习表征，取代了传统的人工制作的特征，取得了瞩目的成就。由深度学习三巨头之二的Yoshua Bengio和Yann LeCun牵头创办的深度学习顶会，即命名为国际学习表征会议International Conference on Learning Representations，足见表征学习的重要性。
尽管深度学习在近十年极大地推动了机器学习的发展，但是仍有许多问题亟待解决，例如将知识迁移到新问题上的能力。许多关键问题都可以归结为OOD(out-of-distribution)问题。因为统计学习模型需要独立同分布(i.i.d.)假设，若测试数据与训练数据来自不同的分布，统计学习模型往往会出错。然而在很多情况下，i.i.d.的假设是不成立的，而因果推断所研究的正是这样的情形：如何学习一个可以在不同分布下工作、蕴含因果机制的因果模型(Causal Model)，并使用因果模型进行干预或反事实推断。
我们可以很自然地想到将因果推断的优点结合到机器学习中，然而现实没有这么容易。因果模型往往处理的是结构化的数据，并不能处理机器学习中常见的高维的低层次的原始数据，例如图像。为此，让我们回到最初的问题，因果表征即可理解为可以用于因果模型的表征，因果表征学习即为将图像这样的原始数据转化为可用于因果模型的结构化变量。因果表征学习就是连接因果科学与机器学习的桥梁，解决这一及相关问题，就可以很好地将因果推断与机器学习结合起来，构建下一代更强大的AI。
接下来，我们就跟随作者的思路，详细地探讨描述物理世界的不同模型的层次，统计模型与因果模型的区别包括模型的能力相关的假设及挑战，学习因果模型所必需的独立因果机制原则，学习因果模型的方法，如何学习因果表征，以及从因果的角度重新审视了诸多机器学习的挑战并指出了因果带来的启示。
Level of causal modeling 谈及对自然现象建模，自然而然就可想到黄金标准——微分方程组。它根据时间的演变建模物理机制，可以让我们预测物理系统未来的行为，推断干预的效果以及预测变量间的统计相关性；还可以提供物理本质，让我们可以解读因果结构。
如果说微分方程是对物理系统全面详尽的表述，那么统计模型(Statistical Model)可被看作表面的粗糙的描述。它无法预测干预的效果，但是的优点在于通常可以从观察数据中学习，而前者通常需要专家来提出。因果建模则存在于这两个极端之间，它期望能够像物理模型一样预测干预的效果，但同时可以在一些假设下，通过数据驱动的方法找到这样的模型，来取代专家知识。
基于上文的表述，表一给出了模型的分类与层级，并且给出了分级的依据——越高层的模型拥有更多更强的能力，这些能力从低到高分别是：在i.i.d.条件下预测的能力，在分布偏移/干预下预测的能力，回答反事实问题的能力，是否蕴含物理本质。接下来首先讨论这些能力，并在下一个章节具体解析统计模型与因果模型的区别。具体地说，基于统计模型的机器学习模型只能建模相关关系，而相关关系往往会随着数据分布的变化而变化；而因果模型所建模的因果关系则是更本质的，反映数据生成机制的关系，这样的关系是更鲁棒的，具有OOD泛化的能力。
在独立同分布条件下预测的能力
统计模型只是对现实的粗浅描述，因为它们只关注关联关系。对于样本和标签，我们可以通过估计来回答这样的问题：“这张特定照片中中有狗的概率是多少？”，“给定一些症状，心力衰竭的概率是多少？”。这样的问题是可以通过观察足够多的)产生的i.i.d.数据来回答的。尽管机器学习算法可以把这些事做得很好，但是准确的预测对于我们的决策是不够，而因果科学提供了一个尚未完全探索的补充。举例来说，鹳出现的频率是和欧洲的人口出生率正相关的，我们的确可以训练一个统计学习模型来通过鹳的频率预测出生率，但显然这两者并没有什么直接的因果关系。统计模型只有在i.i.d.的情况下才是准确的，如果我们做任何的干预来改变数据分布，就会导致统计学习模型出错。
在分布偏移/干预条件下预测的能力
我们进一步讨论干预问题，它是更具挑战性的，因为干预会使我们跳出统计学习中i.i.d.的假设。继续用鹳的例子，“在一个国家中增加鹳的数量会增加该国的出生率吗？”就是一个干预问题。显然，人为的干预会使得数据分布发生变化，统计学习依赖的条件就会被打破，所以它会失效；另一方面，如果我们可以在干预的情况下学习一个预测模型，那么这有可能让我们得到一个对现实环境中的分布变化鲁棒的模型。实际上这里所谓的干预并不是什么新鲜事，很多事情本身就是随时间变化的，例如人的兴趣偏好，或者模型的训练集与测试集本身就有分布的不匹配。对神经网络的鲁棒性，已经有越来越多的关注，成为了一个与因果推断紧密连接的研究话题。作者认为对于在分布偏移下预测的研究不能只局限于在测试集上取得高准确率，如果我们希望在实际决策中使用学习算法，那么我们必须相信在实验条件改变的情况下，模型的预测也是有效的。笔者认为，作者在此处的意思是，实际应用中的分布偏移是任意多样的，仅仅在某些测试集上取得好效果不能代表我们可以在任何情况下都信任该模型，它可能只是恰好符合这些测试集的偏置。
为了使我们可以在尽可能多的情况下信任预测模型，就要采用具有回答干预问题能力的模型，至少统计学习模型是不行的。
回答反事实问题的能力
反事实问题涉及到推理事情为什么会发生，想象不同行为的后果，并由此可以决定采取何种行为来达到期望的结果。回答反事实问题更加困难的，但也是对于AI非常关键的挑战。如果一个干预问题是“如果我们说服一个病人规律的锻炼，那么它心力衰竭的概率会如何变化？”，那么对应的反事实问题就是“如果这个已经心力衰竭的病人一年前就开始锻炼，那他还会心力衰竭吗？”。显然回答这样的反事实问题对于强化学习中的智能体是很重要的，它们可以通过反思自己的决策，制定假说，再通过实践验证，就像我们的科学研究一样。
数据的特点：观察的—干预的，结构化的-非结构化的
数据的形式往往决定了我们可以推断什么样的关系。作者将数据分为两个维度：观察的与因果的，人工总结的（结构化的）与原始的（非结构化的）。
观察的与干预的数据 一个极端情况是，我们常假设的从同一个分布中i.i.d.采样的观察数据，但这样的条件很少能被严格的满足；另一个极端是在已知的不同的干预下的产生的数据。在这两者之间，是偏移或者干预未知的数据。
结构化的与非结构化的数据 在传统的AI中，数据常被假设为高层有语义的结构化变量，它们有些可能对应着潜在图中的因果变量。而非结构化原始数据是指那些无法直接提供因果信息的数据，例如图像。
尽管统计模型比因果模型要弱，但是它们可以同时有效地在结构化或者非结构化学习。另一方面，尽管只从观察数据中学习因果关系的方法是存在的，但常常还是需要从多个环境中收集数据，或者需要能够做干预。至此，我们已经可以一窥问题的核心：因果模型具有回答干预问题和反事实问题的能力，然而只能用于结构化的数据，ML模型虽然可以从raw data中有效的学习，但却逃不出i.i.d.设定的桎梏，那么如何将两者结合，使机器学习突破当前的瓶颈呢？答案即如本文题目所言Towards Causal Representation Learning！因果表征学习，即从非结构化的数据中提取出可以用于因果推断的结构化变量。一言以蔽之，如果解决了因果表征学习的问题，就克服了因果推断领域和机器学习领域间的最关键障碍，就可构建下一代更强大的AI。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3edb493d48752e125aa4c003770bd3a7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/890e7b46571af1096698c8fa8c70a326/" rel="bookmark">
			Altium designer报错解决（Access violation at address 000000013D19D944 in module ‘IntegratedLibrary.DLL‘）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 添加库之后，再次使用Altium designer 进行元器件库相关的操作会报错：
Access violation at address 000000013D19D944 in module ‘IntegratedLibrary.DLL’. Read of address 0000000000000000 at 000000013D19D944.
问题解决 环境变量问题。
win+R，运行%AltiumSystemLibrary%, 如果没有弹出来库文件所在路径，则需要添加环境变量：
变量名： AltiumSystemLibrary
值：【altium designer库文件所在路径】
比如：
添加完成后，再次运行%AltiumSystemLibrary%确认一下，成功后重启AD解决。
问题分析 打开注册表路径：
计算机\HKEY_CURRENT_USER\SOFTWARE\Altium\Altium Designer {xxxxx}\DesignExplorer\Preferences\IntegratedLibrary\Loaded Libraries
发现库文件都是使用环境变量进行索引的，所以必须添加这个变量。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242c4b166f0788c5df8ba5b11557895a/" rel="bookmark">
			Spark启动：WARN util.Utils: Your hostname, ... resolves to a loopback address: ...； using ... instead
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 项目场景：问题描述：原因分析：解决方案： 项目场景： 系统：Ubuntu20.04
Hadoop版本：Hadoop3.3.1
Spark版本：Spark3.2.0
问题描述： 在启动 spark-shell 时，出现如下输出：
hadoop@fzqs-Laptop:/usr/local$ spark-shell 2021-12-09 23:49:14,625 WARN util.Utils: Your hostname, fzqs-Laptop resolves to a loopback address: 127.0.1.1; using 10.132.13.98 instead (on interface wlo1) 2021-12-09 23:49:14,626 WARN util.Utils: Set SPARK_LOCAL_IP if you need to bind to another address Setting default log level to "WARN". ...... 原因分析： 这里是 spark 的本地 IP 地址未绑定导致的警告，其中 using 10.132.13.98 instead (on interface wlo1) 其中的 10.132.13.98 就是 spark 默认选择的本地 IP 地址，这里需要我们记住自己的这个 IP 地址（你的电脑上的输出，不是我的！）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242c4b166f0788c5df8ba5b11557895a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1765b248fccaec6eb43400c5238c7e91/" rel="bookmark">
			日更第15天：Linux常用命令之watch用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 命令简介 watch 命令是一个非常牛叉的工具，它可以用于监控系统的运行情况，只需要简单的命令操作，就可以帮助我们更好的运维和监控系统。
我们先来听一听官方的解释：可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令。
这里，使用大白话给大家解释一下：
帮你长时间监控一个命令的运行结果帮你处理重复的任务，解放你的双手 2. 英文含义 watch : 看; 注视; 观看; 观察; (短时间)照看，看护，照管; 小心; 当心; 留意; 3. 语法格式 watch [options] command 4. 选项说明 选项选项说明-b, --beep被监测的命令退出码非零时，发出哔哔声-c, --color解释 ANSI 颜色和样式序列-d, --differences[=]高亮显示变化的区域(最近两次更新之间的差异)-e, --errexit被监测的命令退出码非零时，并在按键之后退出-g, --chgexit被监测的命令输出发生变化时退出-n, --interval 指定每隔秒时间执行一下程序（默认2秒|不能低于0.1秒|单位：秒 ）-p, --precise尝试精确地按照指定的间隔进行一次命令监视-t, --no-title关闭watch命令在顶部的时间间隔-x, --exec将命令传递给 exec 而不是 sh -c-h, --help查看帮助信息-v, --version查看版本信息 5. 示例说明 -v：查看版本信息 [root@iZ ~]# watch -v watch from procps-ng 3.3.15 -h：查看帮助信息 [root@iZ ~]# watch -h Usage: watch [options] command Options: -b, --beep beep if command has a non-zero exit -c, --color interpret ANSI color and style sequences -d, --differences[=&lt;permanent&gt;] highlight changes between updates -e, --errexit exit if command has a non-zero exit -g, --chgexit exit when output from command changes -n, --interval &lt;secs&gt; seconds to wait between updates -p, --precise attempt run command in precise intervals -t, --no-title turn off header -x, --exec pass command to exec instead of "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1765b248fccaec6eb43400c5238c7e91/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bf21fc9ad9a96558e2dd5c52e4fe0b0/" rel="bookmark">
			日更第13天：Linux常用命令之cat用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 命令简介 cat 命令官方的解释是用来连接所有指定文件并将结果写到标准输出。简单理解它最基本的功能是可以查看文件的内容。除此之外，我们还可以利用cat来创建文件或者把几个文件内容进行合并输出。功能简单实用性强，值得你去使用！！！
2. 英文含义 cat = concatenate 连接的意思 3. 语法格式 cat [选项]... [文件]... 4. 选项说明 选项选项说明-A, --show-all显示不可打印字符，行尾显示“$”-b, --number-nonblank对非空输出行编号（和-n相似，差异在于对空白行不编号）-n, --number对输出的所有行从1开始编号-s, --squeeze-blank当遇到有连续两行以上的空白行，就代换为一行的空白行-T, --show-tabs将 TAB 字符显示为 ^I–help显示此帮助信息并退出–version显示版本信息并退出 5. 示例说明 查看某文件内容 cat 文件 [root@iZ test]# ls source.log [root@iZ test]# cat source.log kksks skks sksks ksks kss 查看source.log 的文件内容加上行号 [root@iZb test]# cat -n source.log 1	kksks 2	skks 3	sksks 4	ksks 5	kss 6 cat -s 文件连续两行以上的空白行，就代换为一行的空白行 [root@iZ test]# cat source.log kksks skks sksks ksks kss [root@iZ test]# cat -s source.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3bf21fc9ad9a96558e2dd5c52e4fe0b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b502a698bad2d6a5f3b0b32c23e575e6/" rel="bookmark">
			日更第12天：Linux常用命令之cd用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是胖邰。
今天是星期六，工作了一周，大家好好放松放松，出去转转，毕竟身体是革命的本钱。出门之前，让我们花几分钟时间了解Linux最最最常用的基本命令 cd 命令。我说 最最最应该没人会反对吧！！！
1. 命令简介 cd 命令可以带你去你所期望的地方，可以切换当前目录到指定的目录下。这里理解好切换两字，那么你离掌握它只剩下1%的进度了。
2. 英文含义 cd = change directory 切换目录、更改目录、更换目录、转换目录 3. 语法格式 cd [目录名] 其中目录名代表你想要去的地方 5. 示例说明 切换至系统根目录：cd / [root@iZ ~]# cd / [root@iZ /]# ls -l 总用量 20 lrwxrwxrwx 1 root root 7 6月 22 13:06 bin -&gt; usr/bin dr-xr-xr-x. 5 root root 4096 12月 2 15:34 boot drwxr-xr-x 19 root root 2880 6月 22 13:06 dev drwxr-xr-x. 102 root root 8192 12月 3 23:14 etc drwxr-xr-x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b502a698bad2d6a5f3b0b32c23e575e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8eea1bd7cb3351b1a4a035ec62c2cd/" rel="bookmark">
			日更第11天：Linux常用命令之chmod用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是胖邰。今天是挑战的第11天，真没想到自己能坚持过半，先表扬一下自己。这次文章主要介绍使用chmod的用法。来吧，让我们一起了解下。
1. 命令简介 chmod 命令是用来修改某个文件或文件夹的权限，我们知道，在Linux系统中，文件和文件夹都有自己的属性和权限，分别为 文件所有者、文件所属组、其他用户的读访问、写访问、执行访问权限，简称为 r、w、x 或者 4，2，1 表示。
在Linux系统中，文件的基本权限由3类用户9个字符组成，每个用户身份分别包含同样的 r、w、x 3个权限，通过将3个权限对应的数字相加来确定文件所具备的权限。当前，只有文件所有者和root用户才可以修改文件或者文件夹的权限。
每个模式字符串匹配格式 "[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+" u：表示文件所有者g：表示文件所属组（表示与文件所有者属于同一个群体）o：表示其他用户a：表示三者皆有-：表示取消权限+：表示增加权限=：表示唯一设定权限r：表示读访问w：表示写访问x：表示执行访问X：表示只在文件夹或已对某些用户具有执行权限s：表示在执行时设置用户或组IDt：表示限制删除标志或粘性位时执行/搜索 数字模式组合介绍 另外，在这里我们要特别强调一下 读访问、写访问、执行访问权限 分别对文件和文件夹存在的差异
权限对文件作用 读访问：表示可读取对应文件的实际内容，比如我们使用之前的tail命令来查看内容写访问：表示可新增、编辑以及修改文件中的内容执行访问：表示文件具有被系统执行的权限，只要文件具备执行访问权限（可执行文件） 权限对文件夹的作用 读访问：表示具有读取文件夹结构的权限，也就是说可以看到文件夹中有哪些文件和子文件夹，一旦具备读权限，就可以使用 ls 命令来查看文件夹中的内容信息写权限：可以对文件夹进行创建（新建文件或者文件夹）、删除（已存在文件或者文件夹）、修改（已存在文件或者文件夹修改名称）、移动的权限（可以移动此文件夹下的文件和文件夹的位置），比如我们使用 rm、mv 等命令执行权限：我们知道，文件夹是不能够直接被运行的，对其赋予执行权限表示可进入此文件夹下，也就是我们常用的 cd 命令的作用 2. 英文含义 chmod = change mode 改变方式、改变模式、变更方式 3. 语法格式 chmod [选项]... 模式[,模式]... 文件... chmod [选项]... 八进制模式 文件... chmod [选项]... --reference=参考文件 文件... 将每个文件的权限模式变更至指定模式。 使用 --reference 选项时，把指定文件的模式设置为与参考文件相同。 4. 选项说明 -c 或 --changes 文件权限已修改后，显示其更改动作-f 文件权限无法修改时，不显示错误信息-v 或 --verbose 显示每个文件或文件夹权限变更的执行流程资料–reference=参考文件 使用参考文件的模式而非给定模式的值-R 或 --recursive 递归修改文件和目录–help 显示此帮助信息并退出–version 显示版本信息并退出 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8eea1bd7cb3351b1a4a035ec62c2cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e97bb3ddab8a7a3da71fe11a94ebfea2/" rel="bookmark">
			cJSON的使用（通过解析头文件和官方示例）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先列举一下头文件和官方示例，在官方示例中标记常用的头文件包涵的函数
cJSON.h /* Copyright (c) 2009-2017 Dave Gamble and cJSON contributors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e97bb3ddab8a7a3da71fe11a94ebfea2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98ad09e0b130095273078e5088f1c310/" rel="bookmark">
			C#反编译后窗体设计器无法打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Winform工程反编译后，设计器会出现无法打开的问题，可能需要修改几点：
对所有System.Windows.Forms.命名空间里面的控件需要全命名空间的声明,例如base.AutoScaleMode = AutoScaleMode.Font;
就要改成base.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
而TextBox textBox1; 也要改成private System.Windows.Forms.TextBox textBox1;属性问题：比如一个叫Names的属性被反编译后，可能还原为的set_Names(names)，get_Names()方法，逐个替换可能很慢，可采用正则表达式整体替换。 对于set_Xxx(xxx)方法，可替换 set_{[a-z]*}\( 为 \1 = ( 对于get_Xxx()方法，可替换 get_{[a-z]*}\(\) 为 \1 ref改为out等，再修复个别被误换的方法。
委托和回调函数问题：一般会被还原为add_Xxx(MethodsName)方法，需要改为+= MethodsName资源问题：需要使用.Net Framework SDK 下的 resgen.exe 工具，反编译嵌入资源文件*.resources为*.resx文件，
语法为：ResGen.exe .resources .resx，然后将.resx包含入项目，就会自动和同名的窗体文件.cs关联，如果没有关联可采用先排除再添加大法，搞定。窗体设计器识别问题：需要把以下代码
ComponentResourceManager manager = new ComponentResourceManager(typeof(ClassName));
替换为
System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ClassName));
窗体设计器才能正常识别。未能分析方法“InitializeComponent”。分析器报告以下错误:“Invalid symbol kind: NamedType”。请查看任务列表以了解潜在的错误。
找到报错的窗口的designer.cs 文件中 InitializeComponent这个方法，其中this.Name=nameof(xxxxxx);这一行，改为：this.Name=“xxxx”;部分无法解决的语法错误，可通过其他反编译软件生成后，对比逻辑解决。部分无法识别的错误，通过代码清理重新打开，可能解决。 最后，推荐使用ILSpy，以上部分问题会在生成时解决。
以上部分转载于此网址：https://www.cnblogs.com/verygis/archive/2008/12/02/1346072.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1422286e1820e5b5fdb62dfa5930b7ed/" rel="bookmark">
			nodejs读取excel文件内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 npm install exceljs
const ExcelJS = require('exceljs');
(async () =&gt; {
const workbook = new ExcelJS.Workbook();
await workbook.xlsx.readFile(__dirname + "/nihao.xlsx");
const sheet = workbook.worksheets[0];
console.log(sheet.rowCount)
sheet.eachRow(function (row, rowNumber) {
// console.log(row.values.length)
// console.log('Row ' + rowNumber + ' = ' + JSON.stringify(row.values));
let user = { name: row.values[1], married: row.values[2], age: row.values[3] };
console.log(user)
});
})()
执行 node demo01.js
PS H:\nodetest\np\excel&gt; node .\demo01.js
2
{ name: 'jialiu', married: 'yihun', age: 38 }
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1422286e1820e5b5fdb62dfa5930b7ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93f2da264fc9c60306b90899536e6f1d/" rel="bookmark">
			OpenLayers 3引入和使用（Html版）：创建一个地图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenLayers 3引入和使用（Html版） 一、OpenLayers 3下载 1、OpenLayersg 3官网 http://openlayers.org/
2、OpenLayers 3下载地址（github） https://github.com/openlayers/openlayers/releases
3、下载文件选择 如果你不需要研究源码和例子，只用下载第一个 v6.9.0-dist.zip，下载解压后，里面包含ol.css，ol.js，ol.css.map，ol.js.map，这四个文件。
我们用到的只需要ol.css，ol.js两个文件
如果需要学习和研究源码，可以下载后面的三个文件。
二、一个简单的地图 1、地图项目结构 2、map.html &lt;!Doctype html&gt; &lt;html xmlns='http://www.w3.org/1999/xhtml'&gt; &lt;head&gt; &lt;meta http-equiv='Content-Type' content='text/html;charset=utf-8'&gt; &lt;meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'&gt; &lt;meta content='always' name='referrer'&gt; &lt;title&gt;OpenLayers 3 :创建一个地图&lt;/title&gt; &lt;link href='ol.css ' rel='stylesheet' type='text/css'/&gt; &lt;script type='text/javascript' src='ol.js' charset='utf-8'&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='map' style='width: 1000px;height: 800px;margin: auto'&gt;&lt;/div&gt; &lt;script&gt; /** * 创建地图 */ new ol.Map({ // 设置地图图层 layers: [ //创建一个使用Open Street Map地图源的图层 new ol.layer.Tile({ source: new ol.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93f2da264fc9c60306b90899536e6f1d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c47d90af513af542b8413107f0616afe/" rel="bookmark">
			PYQT5|Pyside2 QSS界面美化教程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PYQT5|Pyside2 QSS界面美化教程详解
QSS 概念 点击这里，边看视频讲解，边学习以下内容
前面，我们开发的程序界面有点简陋。
大家点击这里，下载一个白月黑羽实战班学员开发的程序界面代码，解压后，拖动里面的main.ui界面文件到Qt设计师里面。
像这样
要让产品更好看一些，通常就是指定界面元素的 显示样式 。比如指定颜色、字体、间距。
像这样
Qt有种定义界面显示样式的方法，称之为 Qt Style Sheet ，简称 QSS
如果你学习过Web网页开发，就会发现这个名词和 CSS 特别的相似。
没错，它的 语法和用途 和 CSS 特别的相似。
我们来看上图对应的示例
如果在设计师界面上 最上层的 MainWindow 对象 styleSheet 属性指定如下的内容
QPushButton { color: red ; font-size:15px; } 就会发现，所有的按钮上的文字都变成了红色的，并且字体变大了。
注意这个指定界面元素 显示样式的 语法，由 selector 和 declaration 组成。
花括号前面的 部分，比如示例中的 QPushButton 称之为 selector。
花括号后面的 部分，比如示例中的
{ color: red ; font-size:15px; } 称之为 Properties （样式属性）
selector 选择器 点击这里，边看视频讲解，边学习以下内容
花括号前面的 部分称之为 selector（中文可以叫 选择器），用来 告诉Qt 哪些特征的元素 是你要设定显示效果的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c47d90af513af542b8413107f0616afe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55e9115b18949e8f54ac8863675c0e40/" rel="bookmark">
			2021-12-8数字通信的过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字信号的传输：数字基带传输 与 数字频带传输
两者之间需要传输的信号都为基带信号(信源（信息源，也称发终端）发出的没有经过调制（进行频谱搬移和变换）的原始电信号，其特点是频率较低，信号频谱从零频附近开始，具有低通形式。)
在数字基带系统中可以直接传输基带信号，但是并非所有的基带信号都适合直接在信道上传输。(数字基带信号的码型：二元码(NRZ码,BNRZ码,RZ码,差分码)，1B2B码(双向码，密勒码，传号反转码))
在数字频带系统中不能直接传输基带信号，频带系统一般用于远距离传输，需要将数字基带信号进行调制(对应数字通信系统系统模型中的调制)，将信号载到较高的频段，更适合传输。
数字通信系统模型
**
## 数字基带通信 与 数字频带通信的关系 **
数字基带传输系统是数字频带传输系统的基础。
数字基带传输系统模型：
基带信号调制模型：
数字频带传输系统模型：
调制方式：线性调制（幅度调制）、非线性调制（频率调制和相位调制）
以正弦波为载波：
① 幅度调制——幅移键控（ASK）
② 频率调制——频移键控（FSK）
③ 相位调制——相移键控（PSK）
图片来自：
https://www.bilibili.com/read/cv4035989/ 出处：bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/255d8ddd38845df87bd2ce980d7f098f/" rel="bookmark">
			flink （一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着互联网的不断发展，行业内对于数据的处理能力和计算的实时性要求都在不断增加，随之而来的是计算框架的升级。经过了十余年开源社区的不断演进，现在计算框架已经从第一代的雅虎开源的Hadoop体系进化到目前主流的Spark框架，这两套框架的计算主要是从强依赖硬盘存储能力的计算发展到了内存计算，大大增强了计算力。随着5G时代的到来，未来都将会是万物互联，各种各样的设备都会与网络连接起来，会有大量的数据产生。以后这些数据都将需要做实时分析，下一代计算引擎，也就是第三代计算引擎，将会从计算实时性的角度突破，也就是Flink框架。
1.什么是 Flink Apache Flink 是一个分布式大数据处理引擎，可对1.有限数据流和2.无线数据流进行有状态计算。可部署在各种集群环境，对各种大小的数据规模进行快速计算。
名词解释：
有限数据流：即数据已经产生，数据大小已经确定。数据有限，可以做离线计算；无限数据流：即数据流一旦产生，不知道什么时候结束。比如：数据实时写入到Kafka。数据无限，可以做实时计算。 1.1.Flink设计初衷 Flink 设计之初，就是为实时计算而设计的。但是因为其计算引擎过于强大，所以也可以做离线计算。它可以部署在各种各样的集群中，比如 Flink自己的 standalone 集群，flink on yarn部署，Flink 还可以跑在K8S上，Flink 还可以跑在各种各样的集群上。Flink为了开发测试比较方便，还可以使用单机模式。可以对各种大小规模的数据进行快速计算。特点就是：快。
2.Flink特点 批流统一支持高吞吐、低延迟、高性能的流处支持带有事件事件的窗口（Window）操作支持有状态计算的 Exactly-once 语义支持高度灵活的窗口（Window）操作，支持基于 time、count、session 窗口操作支持具有 Backpressure 功能的持续流模型支持基于轻量级分布式快照（Snapshot）实现的容错支持迭代计算Flink 在 JVM内部实现了自己的内存管理支持程序自动优化：避免特定情况下 Shuffle、排序等昂贵操作，中间结果有必要进行缓存。 3.Flink 与其他框架的对比 框架优点缺点Storm低延迟吞吐量第一、不能保证 exactly-once、编程 API 不丰富Spark Streaming吞吐量高、可以保证 exactly-once、编程 API 丰富延迟较高Storm低延迟、吞吐量高、可以保证 exactly-once、编程API丰富(具有Storm+Spark优势)快速迭代中，API 变化比较快 Spark Spark 就是为离线计算而设计的，在Spark生态体系中，不论是流处理还是批处理，底层引擎都是Spark Core。Spark Streaming 将微批次小任务不停地提交到 Spark 引擎，从而实现准实时计算，Spark Streaming 只不过是一种特殊的批处理而已。
Flink Flink 就是为实时计算而设计的，Flink 可以同时实现批处理和流处理，Flink 将批处理（即有界数据/离线处理）视作一种特殊的流处理。
Flink 部署，可以使用本地Local模式，也可以使用Cluster集群模式(可以部署 standalone，yarn上，也可以部署在cloud 云上)。
4.Flink 架构体系简介 Flink 真正用来做执行操作的，叫做 Worker。进程在不同的环境模式下运行，进程名称不同。如：使用 Standalone集群模式启动，JobManager 叫做 StandaloneSessionClusterEntrypoint，TaskManager叫做 TaskManagerRunner,使用 yarn 集群启动，进程名称又会有所不同。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/255d8ddd38845df87bd2ce980d7f098f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9919e58fd9b098a9368233d419624d2f/" rel="bookmark">
			【看课必备】MOOC C语言进阶——翁恺 链表笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
初识链表
链表的增加
链表的函数
代码细节分析
链表的搜索，删除，清除。
链表的搜索
链表的删除
链表的清除
MOOC原视频地址：C语言程序设计进阶_浙江大学_中国大学MOOC(慕课)
初识链表 typedef struct _node{ int value; struct _node *next; }Node; 简单来说，一个结点（note）由两部分组成，分别是value和point。其中point指向另一结点。 链表的增加 这个部分如果有不懂的请结合注释或者私信我哦。（其实更推荐看更下面一段代码，更加工程化。）
typedef struct _note { int value; struct _note *next; }Note; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() { int number; do { Note* head = NULL;	//假设初始为空链表 Note* last = NULL; //链表的最后 scanf_s("%d", &amp;number); Note* p = (Note*)malloc(sizeof(Note)); //定义出新的结点 p-&gt;value = number; //注意，此时并没有连接进链表 p-&gt;next = NULL; if (last) { while (last-&gt;next) { //找到最后一个结点 last = last-&gt;next; //让last等于最后结点的指针 } last-&gt;next = p; //连接新结点 } else { head = p; //刚开始是空链表，先让head等于新的结点 } } while (number !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9919e58fd9b098a9368233d419624d2f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a130bcfdaa119558875367977c1d960/" rel="bookmark">
			Retrofit2讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Retrofit2学习 前言：一. 概述：二：注解1. 请求方法注解2. 请求头注解3.请求参数注解4.请求和响应格式(标记)注解 三：注解详解1. @GET、@Query、@QueryMap的使用2.@POST、@FormUrlEncoded、@File、@FileMap、@Body的使用3.@Path4.@HTTP5.@Url6.@Streaming7.@Multipart、@part、@PartMap8. 有关MediaType方法 四：实例讲解实例4.1(演示GET请求)实例4.2（演示POST请求） 前言： 本文使用的网络请求API:
get请求：“https://devapi.qweather.com/v7/weather/now?location=101010100&amp;key=a5cf6ab782a14013b08fb92a57dd2f72”
此为和风天气的一个接口， 直接用浏览器登录查看返回json数据。
post请求：https://v2.alapi.cn/api/dog
此为ALAPI网站提供学者练习使用的一个API
一. 概述： 注意：
准却来说Retrofit是一个RESTful的HTTP网络请求的封装原因：网络请求的工作本质上是Okhttp完成，而Retrofit仅负责网络请求接口的封装 App应用程序通过 Retrofit 请求网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作在服务端返回数据之后，OkHttp 将原始的结果交给 Retrofit，Retrofit根据用户的需求对结果进行解析 Retrofit的优点：
超级解耦 ，接口定义、接口参数、接口回调不在耦合在一起可以配置不同的httpClient来实现网络请求，如okhttp、httpclient支持同步、异步、Rxjava可以配置不同反序列化工具类来解析不同的数据，如json、xml请求速度快，使用方便灵活简洁 二：注解 Retrofit使用大量注解来简化请求，Retrofit将okhttp请求抽象成java接口，使用注解来配置和描述网络请求参数。大概可以分为以下几类，我们先来看看各个注解的含义，再一一去实践解释。
1. 请求方法注解 请求方法注解说明@GETget请求@POSTpost请求@PUTput请求@DELETEdelete请求@PATCHpatch请求，该请求是对put请求的补充，用于更新局部资源@HEADhead请求@OPTIONSoptions请求@HTTP通过注解，可以替换以上所有的注解，它拥有三个属性：method、path、hasBody 2. 请求头注解 请求头注解说明@Headers用于添加固定请求头，可以同时添加多个，通过该注解的请求头不会相互覆盖，而是共同存在@Header作为方法的参数传入，用于添加不固定的header，它会更新已有请求头 3.请求参数注解 请求参数注解说明@Body多用于Post请求发送非表单数据，根据转换方式将实例对象转化为对应字符串传递参数，比如使用Post发送Json数据，添加GsonConverterFactory则是将body转化为json字符串进行传递@Filed多用于Post方式传递参数，需要结合@FromUrlEncoded使用，即以表单的形式传递参数@FiledMap多用于Post请求中的表单字段，需要结合@FromUrlEncoded使用（当存在多个表单时使用此注解，减少方法中参数的个数）@Part用于表单字段，Part和PartMap与@multipart注解结合使用，适合文件上传的情况@Query用于Get请求中的参数@PartMap用于表单字段，默认接受类型是Map&lt;String,RequestBody&gt;，可用于实现多文件上传@Path用于Url中的占位符@QueryMap与Query类似，用于不确定表单参数 4.请求和响应格式(标记)注解 解释：此注解添加至方法前声明此请求有发送表单，上传文件或下载大文件等动作。
标记类注解说明@FromUrlCoded表示请求发送编码表单数据，每个键值对需要使用@Filed注解@Multipart表示请求发送form_encoded数据(使用于有文件上传的场景)，每个键值对需要用@Part来注解键名，随后的对象需要提供值@Streaming表示响应用字节流的形式返回，如果没有使用注解，默认会把数据全部载入到内存中，该注解在下载大文件时特别有用 三：注解详解 概述：我们先来解释注解的使用和需要注意的问题(具体的使用步骤后面会给出)。上面提到注解是用来配置和描述网络请求参数的，我们来逐个讲解一下，首先创建网络接口类：
Retrofit将okhttp请求抽象成java接口，采用注解描述和配置网络请求参数，用动态代理将该接口的注解“翻译”成一个Http请求，最后执行Http请求。注意：接口中的每个方法的参数都要用注解标记，否则会报错。 简单来说，我们需要先创建一个用于网络请求的接口，通过为接口中定义的请求方法添加不同的注解实现不同的网络请求功能。
如：创建网络请求接口ApiService
public interface ApiService { } 1. @GET、@Query、@QueryMap的使用 此get请求使用前言中的get请求网址
无参的get请求 public interface ApiService { @GET("https://devapi.qweather.com/v7/weather/now?location=101010100&amp;key=a5cf6ab782a14013b08fb92a57dd2f72") Call&lt;*&gt; getCall(); } @GET 请求方法注解，get请求，括号内的是请求地址，Url的一部分Call&lt;*&gt; 返回类型，*表示接收数据的类，一般自定义,下文展示本接口接受数据类型的类getCall() 接口方法名称，括号内可以写入参数 此为网络接口最简单的一种形式，这是一个没有网络参数的get请求方式，需要在方法头部添加@GET注解，表示采用get方法访问网络请求，括号内的是请求的地址(Url的一部分，也可以是完整的Url，如上文) ，其中返回类型是Call&lt;*&gt;，*表示接收数据的类，如果想直接获取ResponseBody中的内容，可以定义网络请求返回值为Call，ResponseBody是请求网络后返回的原始数据，如果网络请求没有参数，不用写。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a130bcfdaa119558875367977c1d960/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/275/">«</a>
	<span class="pagination__item pagination__item--current">276/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/277/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>