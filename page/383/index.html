<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d438f58336a2abc28e6ce14a6ddd5e/" rel="bookmark">
			C&#43;&#43; delete 和 deallocate 的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		delete 和 deallocate 的区别 delete是释放动态内存
成员函数中 new的动态内存
deallocate是释放对象内存
成员所占的内存
using namespace std; class preson{ public: person(){ ptr=new int[10]; } ~person(){ delete ptr;} private: int *ptr; }; int main(){ while(1){ Person *p=new person; allocator&lt;person&gt; a; a.deallocate(p.sizeof(person)); } return 0; } 运行结果：程序崩溃
结论：
上述代码，如果deallocate能把所有的内存都释放干净，那么程序将会一直进行下去，因为空间不会增加，但是程序崩溃了，就是因为有没有释放的内存，而那个内存正是每次创建person的时候构造函数new的内存。，deallocate只释放了创建对象时的内存，new的动态内存没有释放掉，如果调用析构函数，delete掉通过new制造出来的动态内存，则程序便可以运行下去。
求点赞👍👍👍
原创不易，点赞容易。
您的鼓励就是我的最大动力！！！。
本篇博客到此结束，谢谢大家观看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfb506e6759c24717f662e1390799abe/" rel="bookmark">
			&amp;&amp; ||运算符右边的表达式将不会被执行的情形（GO语言）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 Go 语言中，&amp;&amp; 和 || 是具有快捷性质的运算符，当运算符左边表达式的值已经能够决定整个表达式的值的时候（&amp;&amp; 左边的值为 false，|| 左边的值为 true），运算符右边的表达式将不会被执行。利用这个性质，如果你有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧以减少不必要的运算。
利用括号同样可以升级某个表达式的运算优先级。
在格式化输出时，你可以使用 %t 来表示你要输出的值为布尔型。
布尔值（以及任何结果为布尔值的表达式）最常用在条件结构的条件语句中，例如：if、for 和 switch 结构（第 5 章）。
对于布尔值的好的命名能够很好地提升代码的可读性，例如以 is 或者 Is 开头的 isSorted、isFinished、isVisible，使用这样的命名能够在阅读代码的获得阅读正常语句一样的良好体验，例如标准库中的 unicode.IsDigit(ch)（第 4.5.5 节）。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73c04c6b3de0c1d8ce61827db23250eb/" rel="bookmark">
			OpenCV自学记录（7）—— 直方图均衡化详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV自学记录（7）—— 直方图均衡化详解 1、什么是直方图？1.1灰度直方图1.2彩色直方图 2、直方图均衡化2.1灰度直方图均衡化和局部直方图均衡化2.2 彩色图像直方图均衡化 写在前面的话，昨天去参加了一个面试，面试管说现在好多人都在学计算机视觉方面的技术，但大部分都是只是效仿，有点东施效颦的意思。想想自己确实也是这样，最终幸运的是成功通过了面试，我一定会珍惜这次机会，进入公司之后一定要跟大佬学习更多，在毕业之前达到合格线！！！还有很长的路要走，道阻且长。
1、什么是直方图？ 很久以前就知道直方图均衡化可以提高图片的对比度，然后。。。。就没有然后了。。。一直这样眼高手低也是自己感觉学的不少但真正工作的时候又发现自己还差的远的原因。。。
直方图提供了图像的统计信息，为了理解多种空域增强技术的内涵提供了铺垫。直方图是数值数据分布的精确图表现形式。
首先，我们要明白直方图统计的是什么：横轴：代表从黑到白的影调；纵轴：代表像素量。也就是说，直方图统计的是“照片中”不同影调的像素量多少。也就是说，直方图只统计多少，不统计在哪儿。
1.1灰度直方图 灰度直方图是关于灰度级分布的函数，将数字图像中的所有像素，按照灰度值的大小，统计其出现的频率。其中，横坐标是灰度级，纵坐标是该灰度级出现的频率。能够很直观的展示图像中灰度级的整体分布情况，对图像的后续处理有很好的指导作用。
灰度直方图绘制代码：
import cv2 as cv import matplotlib.pyplot as plt img_ = cv.imread('001.jpg') plt.figure("lena") arr=img_.flatten() plt.subplot(1, 2, 1) n, bins, patches = plt.hist(arr, bins=256, normed=1, facecolor='green', alpha=0.75) plt.subplot(1, 2, 2) plt.imshow(img_) plt.show() 1.2彩色直方图 所谓的彩色直方图就是将RGB通道分割开来，对三个通道分别进行直方图绘制。
from PIL import Image import numpy as np import matplotlib.pyplot as plt src=Image.open('001.jpg') r,g,b=src.split() plt.figure("lena") ar=np.array(r).flatten() plt.hist(ar, bins=256, normed=1,facecolor='r',edgecolor='r',hold=1) ag=np.array(g).flatten() plt.hist(ag, bins=256, normed=1, facecolor='g',edgecolor='g',hold=1) ab=np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73c04c6b3de0c1d8ce61827db23250eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/048ff5d5b1c311e587fc0fa2e0dcb847/" rel="bookmark">
			计算机网络原理笔记 精整理 第六章 应用层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算机网络原理笔记 精整理 第六章 应用层 6.1域名系统DNS6.1.1什么是域名6.1.2域名的结构6.1.3Internet中的域名服务器6.1.4域名解析过程 6.2动态主机配置协议DHCP6.2.1静态地址和动态地址应用场景6.2.2DHCP地址租约6.2.3DHCP租约生成过程6.2.4DHCP地址租约更新 6.3Telnet协议6.3.1 Telnet协议工作方式 6.4RDP（远程桌面协议）6.4.1远程桌面协议RDP 6.5超级文本传输协议HTTP6.5.1 http协议6.5.2 统一资源定位符号-URL6.5.3 绝对路径和相对路径6.5.4 HTTP协议版本6.5.5 HTTP请求报文和响应报文6.5.7 Cookie6.5.8 通过代理服务器访问网站 6.6文件传输协议FTP6.6.1 FTP主动模式和被动模式 6.7 电子邮件6.7.1 电子邮件发送和接收过程6.7.2电子邮件信息格式6.7.3 SMTP协议6.7.4 POP3协议和IMAP协议 6.1域名系统DNS 6.1.1什么是域名 整个Internet网站和各种服务器数量众多，各个组织的服务器都需要给一个名称，这就很容易重名。如何确保Internet上的服务器名称在整个Internet唯一呢？这就需要Internet上有域名管理认证机构进行统一管理。如果你的公司在互联网上有一组服务器（邮件服务器、FTP服务器、Web服务器等），你需要为你的公司先申请一个域名，也就是向管理认证机构注册一个域名。
域名的注册遵循先申请先注册为原则，管理认证机构要确保每一个域名的注册都是独一无二、不可重复的。
6.1.2域名的结构 一个域名下可以有多个主机，域名全球唯一，主机名+域名肯定也是全球唯一的，主机名+域名称为完全限定域名（FQDN）。
QDN是Fully Qualified Domain Name的缩写, 含义是完整的域名。例如，一台机器主机名（hostname）是www, 域名后缀（domain）是51cto.com, 那么该主机的FQDN应该是www.51cto.com.。
6.1.3Internet中的域名服务器 6.1.4域名解析过程 6.2动态主机配置协议DHCP 6.2.1静态地址和动态地址应用场景 6.2.2DHCP地址租约 6.2.3DHCP租约生成过程 6.2.4DHCP地址租约更新 更新方法
6.3Telnet协议 6.3.1 Telnet协议工作方式 6.4RDP（远程桌面协议） 6.4.1远程桌面协议RDP 6.5超级文本传输协议HTTP 6.5.1 http协议 6.5.2 统一资源定位符号-URL 常见的两种URL 6.5.3 绝对路径和相对路径 6.5.4 HTTP协议版本 6.5.5 HTTP请求报文和响应报文 6.5.7 Cookie 6.5.8 通过代理服务器访问网站 6.6文件传输协议FTP 6.6.1 FTP主动模式和被动模式 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/048ff5d5b1c311e587fc0fa2e0dcb847/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/180f1ad0ae78003d3301ecadc7c2328d/" rel="bookmark">
			Linux-hostname查看及修改
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统信息 [root@suhw ~]# cat /etc/redhat-release CentOS Linux release 7.7.1908 (Core)	hostname命令 该用于显示和设置系统的主机名称。使用该命令设置主机名后，系统并不会永久保存新的主机名，重新启动机器之后还是原来的主机名。如果需要永久修改主机名，建议使用hostnamectl
# 查看当前hostname [root@suhw ~]# hostname suhw # 临时修改hostname [root@suhw ~]# hostname suhw-test #查看系统中记录的hostname，发现并没有发生改变 [root@suhw ~]# cat /etc/hostname suhw-host hostnamectl命令 该命令是centos7后才引入的
# hostnamectl -h -h --help 显示帮助 --version 显示安装包的版本 --transient 修改临时主机名 --static 修改瞬态主机名 --pretty 修改灵活主机名 -P --privileged 在执行之前获得的特权 --no-ask-password 输入密码不提示 -H --host=[USER@]HOST 操作远程主机 Commands: status 显示当前主机名设置 set-hostname NAME 设置系统主机名 set-icon-name NAME 为主机设置icon名 set-chassis NAME 设置主机平台类型名 在CentOS7中有三种定义的主机名:
静态的（static）: 也称为内核主机名，是系统在启动时从/etc/hostname内自动初始化的主机名；瞬态的（transient）：是在系统运行时临时分配的主机名；灵活的（pretty）：允许使用特殊字符的主机名 查看hostname 通过hostname查看当前会话的主机名 [root@suhw ~]# hostname suhw 通过hostnamectl status查看静态主机名 [root@suhw ~]# hostnamectl status Static hostname: suhw Icon name: computer-vm Chassis: vm Machine ID: d430cb960ac24f48a0ddf1ee9434ef4c Boot ID: b2e53a86ef4e4184a6477f35f41824dc Virtualization: kvm Operating System: CentOS Linux 7 (Core) CPE OS Name: cpe:/o:centos:centos:7 Kernel: Linux 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/180f1ad0ae78003d3301ecadc7c2328d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a63d2482c8b4319fcb63ab7a0702296/" rel="bookmark">
			使用ndt配准实现简单的激光里程计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		激光里程计 1、原理2、几点需要注意的1. 关键帧的选取2. 更新当前帧pose3. 设置guess_pose 3、效果4、参考5、代码 1、原理 读入每一帧的点云，和地图做ndt配准，得到当前帧的pose，使用这个pose作为下一帧配准的guess_pose，如果当前帧是关键帧（关键帧如何选取？- 根据与上一关键帧的距离或者每隔几帧设置为关键帧），那么更新地图并且将当前帧更新为关键帧。
2、几点需要注意的 1. 关键帧的选取 当前帧距离上一个关键帧的位移超过阈值（1m），则认为当前帧为关键帧。
// 如果当前帧和上一帧的平移超过了min_add_scan_shift_,那么更新地图,并更新previous帧,发布地图 // .否则,previous帧不变 double shift = sqrt(pow(current_pose_.x - previous_pose_.x, 2.0) + pow(current_pose_.y - previous_pose_.y, 2.0)); if (shift &gt;= min_add_scan_shift_) { map_ += *transformed_scan_ptr; previous_pose_.x = current_pose_.x;previous_pose_.y = current_pose_.y;previous_pose_.z = current_pose_.z; previous_pose_.roll = current_pose_.roll;previous_pose_.pitch = current_pose_.pitch;previous_pose_.yaw = current_pose_.yaw; ndt.setInputTarget(map_ptr); sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2); pcl::toROSMsg(*map_ptr, *map_msg_ptr); ndt_map_pub_.publish(*map_msg_ptr); } 2. 更新当前帧pose ndt结束后根据输出的矩阵来更新当前帧的pose
// 配准后的输出点云 pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;); ndt.align(*output_cloud, init_guess); // 这个点云是经过下采样的,我们不使用 t_localizer = ndt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a63d2482c8b4319fcb63ab7a0702296/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98e2c6694b70258726812fa462617315/" rel="bookmark">
			c&#43;&#43;中double型的最大值和最小值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DBL_MAX：double型的最大值
DBL_MIN：double型的最小值
FLT_MAX：float型的最大值
FLT_MIN：float型的最小值
1、负值取值范围为-1.79769313486231570E+308到-4.94065645841246544E-324；
2、正值取值范围为4.94065645841246544E-324到1.79769313486231570E+308。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a6672f5778892c369721b4e5de36a70/" rel="bookmark">
			完成一个IDEA web项目（二）登录功能实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（二）登录功能实现 1. 编写前端页面 若jsp页面中文乱码：在jsp中指定页面显示的编码为GBK
添加page命令
&lt;%@ page language="java" contentType="text/html; charset=GBK" %&gt; 参考：https://www.cnblogs.com/beijiguangyong/archive/2012/03/31/2437124.html
*其他所有出现编码的地方也要改掉
2. 编写login.jsp，并设置为首页 login.jsp
&lt;%@ page language="java" contentType="text/html; charset=GBK" %&gt; &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="GBK"&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="${pageContext.request.contextPath}/studentServlet" method="post"&gt; &lt;div class="errorInfo"&gt;${error}&lt;/div&gt; &lt;p&gt;学号：&lt;input type="text" size="20" name="stuNo"&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type="password" size="20" name="stuPwd"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="登录"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 设置为首页：
web.xml添加
&lt;!-- 设置欢迎页面 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 3. 编写dao层用户登陆的接口 StudentDao
public interface StudentDao { //得到要登录的研究生 public Student getLoginStudent(Connection conn,String stuNo) throws SQLException; } 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a6672f5778892c369721b4e5de36a70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc5e75176d589a043b229a3b1e2c6c4c/" rel="bookmark">
			Servlet中写了注解@WebServlet但访问servlet报404错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 以前一直用的eclipse，web.xml文件自动生成的，没自己改过。
这次web.xml是先创建maven项目再添加web配置时，随便从一个web4.0项目里拷贝来的，然后就出问题了。
Servlet中写了注解@WebServlet("xxxx")，但访问servlet时报404错误。
看了web的确是3.0以上的，没找到问题在哪，看了篇博客解决了：https://www.cnblogs.com/iCheny/p/10976735.html
原web.xml（出问题的）
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0" metadata-complete="true"&gt; &lt;/web-app&gt; 用Servlet注解的话把metadata-complete改成false
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0" metadata-complete="false"&gt; &lt;/web-app&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e33a9eb9f4662b3642dcc8fa0d94095/" rel="bookmark">
			Andriod P DNS解析不了问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.目前在AndriodP 上 WIFI连接外部热点，可以ping IP 地址，但是不能ping baidu, 初步判断是dns解析出了问题
2.getprop | grep dns后，发现 也已经设置了dns
msmnile_gvmq:/ # getprop | grep dns
[init.svc.mdnsd]: [running]
[net.dns1]: [192.168.43.1]
[net.dns2]: [114.114.114.114]
[net.dns3]: [8.8.8.8]
[ro.boottime.mdnsd]: [8268090830]
ping -I waln0 www.baidu.com 还是 报错“ping: unknown host www.baidu.com”
添加：
[net.wlan0.dns1]: [114.114.114.114]
[net.wlan0.dns2]: [8.8.8.8]
[net.wlan0.dns3]: [192.168.43.1]
结果还是一样ping 不同baidu.
3.ping -I wlan0 www.baidu.com 的时候logcat 输出log 发现：
05-28 15:35:41.194 801 23746 D NetworkMonitor/NetworkAgentInfo [WIFI () - 103]: PROBE_DNS connectivitycheck.gstatic.com 66ms OK 203.208.40.127
05-28 15:35:41.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e33a9eb9f4662b3642dcc8fa0d94095/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be1651a42c88254ecd6f630282e9f746/" rel="bookmark">
			Macbook Pro 外接显卡实现Tensorflow GPU运行之环境配置（重点）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Macbook Pro 外接显卡实现Tensorflow GPU运行–环境配置 MacOS 重装外接显卡（内屏输出）环境配置（重点）👆Tensorflow GPU 配置 环境配置 准备工作 显卡：GTX 1080TI 11G显卡坞：Mantiz （技嘉的Gamingbox应该也可以）显卡欺骗器（有条件的配个外屏吧，毕竟外屏转内屏输出损耗还是挺大的）MacOS：雷电3接口 安装步骤 macOS 系统安装（见blog1）CUDA配置cuDNN配置Tensorflow配置（见blog4） CUDA加速 准备列表 资源版本号MacOS10.13. 6（17G65）GPU driverNIVIDIA Web Driver 387.10.10.40.105CUDA driver9.2（396.148 ）cuDNNcudnn-9.2-osx-x64-v7.2.1.38Xcode9.2 注意⚠️：相关驱动版本以及编译环境工具必须配套对应！
步骤
关闭SIP：重新启动macOS，并同时按住Command和R进入Recovery OS；
在Utilities菜单中启动Terminal；
在Terminal中执行命令：
$ csrutil disable;
重新启动后进入Recovery OS 在Utilities中启动Terminal 执行命令：
$ csrutil status
确认状态为disable
安装GPU驱动
在Terminal中执行：
sudo curl -s "https://api.github.com/repos/mayankk2308/purge-wrangler/releases/latest" | grep '"browser_download_url":' | sed -E 's/.*"([^"]+)".*/\1/' | xargs curl -L -s -0 &gt; purge-wrangler.sh &amp;&amp; chmod +x purge-wrangler.sh &amp;&amp; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be1651a42c88254ecd6f630282e9f746/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac88e6f354c24583ce5b8e18fd0254a8/" rel="bookmark">
			haspMap源码分析之-链表拆分问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Jdk1.8 hashmap在扩容的时候，为什么当将一个链接拆分成两个链表的时候，key的hash值和oldCap与为0时，放在原来下标j位置，不为0时，放在下标j+oldCap位置？
一、源码： /** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac88e6f354c24583ce5b8e18fd0254a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcacb1476263c9ae88667d3f0799fc16/" rel="bookmark">
			列出HBase所有的表的相关信息，例如表名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.hbase.*;
import org.apache.hadoop.hbase.client.*;
import java.io.IOException;
public class Test_1 {
public static Configuration configuration;
public static Connection connection;
public static Admin admin;
/**
* @param args
*/
//建立连接
public static void init(){
configuration = HBaseConfiguration.create();
configuration.set("hbase.rootdir","hdfs://localhost:9000/hbase");
try{
connection = ConnectionFactory.createConnection(configuration);
admin = connection.getAdmin();
}catch (IOException e){
e.printStackTrace();
}
}
//关闭连接
public static void close(){
try{
if(admin != null){
admin.close();
}
if(null != connection){
connection.close();
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcacb1476263c9ae88667d3f0799fc16/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbca40bdae428611890980f1bdc9cf50/" rel="bookmark">
			Docker Swarm实现跨宿主机容器间访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Docker Swarm实现跨宿主机容器间访问 背景：
在SerA服务器，运行了一个任务调度系统xxl容器ConA。
在SerB服务器，运行了一个SpringBoot服务ConB，注册到任务调度系统中。
在任务调度系统中，看到的调度器节点IP是SerB服务器分配给ConB容器的IP地址。 导致任务调度系统调度失败，提示ConB地址链接不上。
分析下来，是由于ConA和ConB是跨宿主机的容器，无法通信。
网上看到了很多方案，包括Overlay网络、OpenvSwitch、consul方案等，最终使用Docker Swarm解决了，发现很简单，过程如下。
1. 初始化swarm 在主节点运行docker swarm init，初始化swarm。
docker swarm init # Swarm initialized: current node (0r4xjgtu4nd9txrsbfn1lo5gu) is now a manager. # # To add a worker to this swarm, run the following command: # # docker swarm join \ # --token SWMTKN-1-0q35cj5j0va82a0t3mhkbesirqb6lqgqlkmznbwx1ojbou4u75-ejrors77ezcw25nmy9g90u9a0 \ # 172.16.0.226:2377 # # To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbca40bdae428611890980f1bdc9cf50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d76b0e0193c587ea75edafea1204a4d0/" rel="bookmark">
			【OpenCV实战】车牌识别（OCR）中字符分割的两种方法Python实现（总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【OpenCV实战】车牌识别（OCR）中字符分割的两种方法Python实现 总的来说1、基于连通域（边缘特征）的字符分割2、基于像素直方图的字符分割2.1代码一：2.2代码二： 车牌识别是一个经典项目了，车牌的字符分割是很重要的一部分，字符分割的思想在其他项目中同样有很重要的作用。有必要针对字符分割的思路和实现过程做一个记录。
本篇博客的对象是
目的是实现车牌的字符分割。
总的来说 车牌识别的字符分割可以有两种思路：
（1）基于连通域（边缘特征）的字符分割：通过形态学处理是的各个字符成为一个整体（主要针对汉字），通过边缘检测获取每一个字符的轮廓，即可实现字符分割。
（2）基于像素直方图的字符分割：对图片进行二值化处理，统计水平方向和竖直方向上各行各列的黑色像素的个数，根据像素的特点确定分割位置，完成字符分割。
1、基于连通域（边缘特征）的字符分割 思路比较简单，根据轮廓特征分割。话不多说，直接上代码
import cv2 from matplotlib import pyplot as plt img_ = cv2.imread('Resources/test1.png') # 读取图片 img_gray = cv2.cvtColor(img_, cv2.COLOR_BGR2GRAY) # 转换了灰度化 # 形态学操作 kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2)) image = cv2.dilate(image, kernel) # 查找轮廓 contours, hierarchy = cv2.findContours(image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) words = [] word_images = [] for item in contours: word = [] rect = cv2.boundingRect(item) x = rect[0] y = rect[1] weight = rect[2] height = rect[3] word.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d76b0e0193c587ea75edafea1204a4d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67b6859115af2e465364eb1ae5c84537/" rel="bookmark">
			JDK 8 转成 JDK 11 时会出现‘(程序包r 已在模块 xxx中声明, 但该模块未导出它)’
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在把某个项目从jdk 8 换成 jdk 11 ，
IDEA操作
将 8 换成 11 ，这是要指定系统安装的路径来的 （1）然后打包时，会出现：
[3,22] 程序包 com.sun.crypto.provider 不可见
[ERROR] (程序包 com.sun.crypto.provider 已在模块 java.base 中声明, 但该模块未导出它)
我好像记得 jdk 9 之后就没有这个了，所以jdk 11 应该也没有这个。
（2）解决方式其实很简单，直接删除了
因为根本不用这种标准的类型。
重新打包就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17dd0ba05c4ead7595d3c17629ba53f9/" rel="bookmark">
			Linux 延时函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 有一些延时函数写法非常占用CPU，比如while(gettime()&gt;timeSet){}，在Linux中应当尽量使用系统调用执行延时，在延时等待期间执行一次进程调度，降低延时函数的CPU占用率。
Linux中的延时函数有sleep，usleep和nanosleep，以及select。
1、sleep sleep()调用alarm()来设定报警时间，调用sigsuspend()将进程挂起在信号SIGALARM上。
2、usleep usleep()有可能会影响信号，用于延迟挂起进程。
3、nanosleep nanosleep()是Linux系统调用，使进程进入TASK_INTERRUPTIBLE，脱离就绪队列，然后进行一次进程调度再由内核在规定的时间后发送信号来唤醒这个进程调用进程睡眠，nanosleep()精度不是很高。
4、select select的精度是微妙，比较精确，将相关参数传递给内核。
5、推荐使用的函数 void delayms (unsigned int howLong) { struct timespec sleeper, dummy ; sleeper.tv_sec = (time_t)(howLong / 1000) ; sleeper.tv_nsec = (long)(howLong % 1000) * 1000000 ; nanosleep (&amp;sleeper, &amp;dummy) ; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae6a28275ff963dd6770c2b9f55ed95d/" rel="bookmark">
			【OpenCV实战】基于HSV的颜色分割Python实现（含Python代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一周没有更新博客了，这一周的时间内加强了对机器学习和图像处理的学习。学的有点混乱，有必要记录一下。
深度学习可以解决很多问题，但有时候深度学习和图像处理相结合才能有更好的效果：比如，在进行交通信号灯检测时，用目标检测模型确定信号灯位置后，对信号灯进行颜色分割再识别可大大提高准确率。
机器学习领域中有句话：数据和特征决定了模型的上限，而算法只不过是逼近这个上限而已，所以了解机器学习的常用算法，熟悉机器学习中的特征工程是很有必要的。
【OpenCV实战】基于HSV的颜色分割实现（含Python代码） 1、什么是HSV2、代码实战2.1 createTrackbar使用方法及步骤2.2 代码详解 3、总结 1、什么是HSV 我们知道RGB颜色模式，通过不同的配比可以形成不同的颜色。HSV也是一种颜色模式，其模型如图所示
通过图示我们也能够看到，他和RGB颜色模型相似，也是由三个属性决定颜色，H、S、V分别是色彩、深度、明暗，按着图中方向的变化，其对应的颜色也会改变，三者也同样是有取值范围的：
H（色调）：用角度度量，取值范围为0°～360°S（饱和度）：表示颜色接近光谱色的程度。通常取值范围为0%～100%，值越大，颜色越饱和。V（明度）：表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。 HSV空间中三个指标相互独立，能够非常直观的表达色彩的明暗，色调，以及鲜艳程度，方便进行颜色之间的对比，所以经常在HSV中进行颜色的分割识别。在HSV中各个颜色的范围见下表
2、代码实战 从网上下载了一张交通信号灯的图片，如图
我们的目的是进行颜色分割，将我们感兴趣的区域提取出来以方便下一步的操作。
2.1 createTrackbar使用方法及步骤 在开始实际操作之前，来了解一下createTrackbar。createTrackbar是Opencv中的API，其可在显示图像的窗口中快速创建一个滑动控件，用于手动调节阈值，具有非常直观的效果。可以直接观察阈值选择的效果，并确定想要的阈值。
使用Trackbar我们要了解两个函数；
（1）创建滑动条函数
一个滑动条只能用于一个参数，如果需要改变多个参数，可以使用多个滑动条。
cv2.createTrackbar(trackbarName, windowName, value, count, onChange) 各参数意义：
trackbarName：滑动空间的名称；
windowName：滑动空间用于依附的图像窗口的名称；
value：初始化阈值；
count：滑动控件的刻度范围；最小值默认为0。
onChange：回调函数（所谓回调函数即每次修改滑动条后，需要传入新变量的函数）的名称，其定义如下：
onchange：void foo（int，void*）。
其中第一个参数是滑动条位置，第二个参数是用户数据（请参见下一个参数）。如果回调是空指针，则不调用回调，但只更新值
用户数据：按原样传递给回调的用户数据。它可以用来处理滑动条事件而不使用全局变量。
（2）获取滑动条的值函数
cv.getTrackbarPos获取滑动条位置处的值
g = cv2.getTrackbarPos(trackbarName2, windowName) #第一个参数为滑动条1的名称，第二个参数为窗口的名称。 注意：需要在回调函数内部采用函数cv.getTrackbarPos获取滑动条位置处的值，不然如果存在多个滑动条时，函数无法获取更新后的参数值。
2.2 代码详解 import cv2 # 滑动条的回调函数，获取滑动条位置处的值 def empty(a): h_min = cv2.getTrackbarPos("Hue Min","TrackBars") h_max = cv2.getTrackbarPos("Hue Max", "TrackBars") s_min = cv2.getTrackbarPos("Sat Min", "TrackBars") s_max = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae6a28275ff963dd6770c2b9f55ed95d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02ce35be2dcd741bb68aca7c92356e94/" rel="bookmark">
			#Java学习#习题三
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 判断题单选题函数题写出派生类构造方法（Java）根据派生类写出基类（Java）人口统计 编程题通过键盘输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数数组元素交换集体评分jmu-Java-03面向对象基础-01-构造函数与toString 其他JAVA学习的内容见：目录
判断题 1-1.用static修饰的变量是类变量。
T
1-2.如果一个成员变量被修饰为final的，就是常量，常量必须赋给初值，而且不能再发生变化。
T
final修饰的类也不能派生子类
1-3.对于abstract类，不能创建该类的对象。
T
必须构造子类
1-4.有的类定义时可以不定义构造函数，所以构造函数不是必需的。
F
所有的类必须有构造函数，如果没有显式构造函数，java默认构造一个空的无参无方法体的构造函数
1-5.一个Java类可以有多个父类。
F
一个Java类只能有一个父类但可以有多个父接口
1-6.package语句必须放到java程序的最开始。
T
1-7.一个类的非静态方法可以访问静态成员变量。
T
1-8.一个类的静态方法不可以访问该类的非静态成员变量。
T
1-9.构造函数名应与类名相同，返回类型为void。
F
前半句正确，构造方法没有返回值类型，它的作用只是初始化
1-10.子类如果想使用父类的构造方法，必须在子类的构造方法中使用，并且必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句
T
单选题 2-1.以下关于构造函数的描述错误的是（ )
A.构造函数的返回类型只能是void型。
B.构造函数是类的一种特殊函数，它的方法名必须与类名相同。
C.构造函数的主要作用是完成对类的对象的初始化工作。
D.一般在创建新对象时，系统会自动调用构造函数。
A
构造方法没有返回值类型
2-2.下面哪个函数是public void aMethod(){…}的重载函数？( )
A.void aMethod( ){...}
B.public int aMethod(){...}
C.public void aMethod ( ){...}
D.public int aMethod ( int m){...}
D
2-3.下列方法头中哪一个不与其他方法形成重载(overload)关系?（ ）
A.void mmm()
B.void mmm(int i)
C.void mmm(String s)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/02ce35be2dcd741bb68aca7c92356e94/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5f498206281bfdb1c223bb701fb0da4/" rel="bookmark">
			Linux下CPU时间片，CPU使用率分析，while和sleep分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、时间片
简单来说就是CPU分配给各个程序的时间,使各个程序从表面上看是同时进行的,而不会造成CPU资源浪费。在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。但是在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。
二、Task调度
时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法是时间片调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结束，则CPU 当即进行切换。调度程序所要做的就是维护一张就绪进程列表，当进程用完它的时间片后，它被移到队列的末尾。
时间片轮转调度中唯一有趣的一点是时间片的时长。从一个进程切换到另一个进程是需要一定时间的–保存和装入寄存器值及内存映像，更新各种表格和队列 等。假如进程切换(process switch) - 有时称为上下文切换(context switch)，需要5毫秒，再假设时间片设为20毫秒，则在做完20毫秒有用的工作之后，CPU将花费5毫秒来进行进程切换。CPU时间的20%被浪费 在了管理开销上。
为了提高CPU效率，我们可以将时间片设为500毫秒。这时浪费的时间只有1%。但考虑在一个分时系统中，如果有十个交互用户几乎同时按下回车键，将 发生什么情况？假设所有其他进程都用足它们的时间片的话，最后一个不幸的进程不得不等待5秒钟才获得运行机会。多数用户无法忍受一条简短命令要5秒钟才能 做出响应。同样的问题在一台支持多道程序的个人计算机上也会发生。
从这我们可以看出,时间片设得太短会导致过多的进程切换，降低了CPU效率；而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100毫秒通常是一个比较合理的折衷。
cpu执行了一个任务后，如果该任务还没有结束，那么又会重新放回Task Queue再度轮回。
实际上Task指的是线程，所以，一个进程开启多个线程会使CPU花更多的时间在该进程上面，但是开启太多的线程也是徒劳的。比如4核CPU，进程开启了8个线程，那么CPU能同时处理4个Task，其余4个还是在队列里面等待，即便如此，多余的4个线程还是有作用的，它使该进程抢占了CPU更多的时间片。
三、CPU占用率
使用 top 命令查看系统CPU使用率，主要看标红的地方，我的虚拟机为单核CPU。
数据3秒一刷新，看个大概就行。
total 就是总的任务数。
running 表示在Task Queue中的任务数。
sleeping 为阻塞的任务，比如调用了sleep, epoll_wait, select, accept 等带有阻塞属性的方法；sleeping 任务需要等到阻塞结束了才会放回到Task Queue
us 表示用户进程占用的比例，sy 表示系统进程占用的比例。
CPU的使用率可以理解为每个时间片被充分利用的综合程度。假设时间片为100ms，那么在1s之内会有10个时间片被分配到不同线程(假设不考虑上下文切换的时间)，如果有8个线程执行了100ms还没结束，有2个线程执行了10ms就结束了，那么CPU使用率大致为 （8*100 + 2 * 20）/ 1000 = 84%
再比如4个50ms，6个60ms，那么使用率为 （4*50 + 6*60）/ 1000 = 56%
再看下面几个程序，本机上其他程序消耗CPU几乎为0.
1、CPU瞬间100%
因为当前进程的每个时间片都被充分利用了，并且每次又重新回到队列。
while(true){ }; 2、CPU占用率0%
sleep调用将会使当前进程处于未就绪状态，也就不在Task Queue里面，直到睡眠时间到，将会放回到队列尾部，可能的表现就是：执行5ms，睡眠1s。。。这样一来它几乎没怎么占用CPU。
while(true){ sleep(1); }; 3、CPU占用率0%
原理和2是一样的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5f498206281bfdb1c223bb701fb0da4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/382/">«</a>
	<span class="pagination__item pagination__item--current">383/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/384/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>