<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143077e5d9b7cbeac11076a523ff6a10/" rel="bookmark">
			功能测试--APP专项测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		功能测试--APP专项测试 兼容性--云测平台模拟器兼容性怎么做安装卸载升级干扰测试推送规则--push推送服务器(是否按照规则去推送)手机端 用户体验 兼容性–云测平台模拟器 手机型号不同品牌商,不同机型(华为P30)操作系统版本:分辨率屏幕 1.尺寸:5.1. 5.5 4.7
2.类型: 刘海屏 水滴屏 曲面屏 折叠屏
网络: 移动数据 和 WiFi应用兼容性 手机硬件: 手机上的物理按键(音量键 home键 电源键)
外部硬件: 蓝牙设备 有线设备
操作系统设置: wlan 时间 定位
其他APP: 具有后台播放功能的APP,例如音乐
兼容性怎么做 安装 正常场景 1.从不同渠道安装
2.不同操作系统安装
3.不同的路径安装(手机\SD卡)
异常场景 中断安装(关机 断网),中断之后能否恢复安装
存储空间不足安装
安装时手动取消或暂停.恢复之后是否能正常安装
正在运行时能否覆盖安装(后台运行\前台运行:需要考虑是否会打断用户操作)
低版本覆盖高版本
卸载后再安装(卸载后是否会清除数据)
卸载 正常卸载(手机卸载\使用第三方软件卸载)
运行时卸载(后台运行)
取消卸载(第三方软件\二次弹窗确认时取消)
中断卸载(关机)
卸载后数据残留(给用户提示确认,如果用户同意残留,可以保留数据;如果用户拒绝残留,不可以保留数据)(如果不
做任何确认提示,默认需要清空残留数据)
升级 从临近版本升级(上一次发布的版本)
跨版本升级(历史发布过的版本)
从不同渠道升级
升级成功提醒(红点提示\消息提示)
升级前是否提醒(消息推送提示升级\强制升级不提醒)
当前版本是否具有升级能力(n升级n+1,升级规则)
干扰测试 接打电话
收发短信
查看应用推送(其他软件的推送\当前软件的推送)
连接蓝牙设备
接收文件弹窗提醒(确认接收\拒绝接收)
切换网络(移动数据和WiFi自动切换)
手机自带应用(打开相机\手电筒\计算器)
低电提醒
插拔充电器(充电动画)
推送规则–push 推送服务器(是否按照规则去推送) 推送内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/143077e5d9b7cbeac11076a523ff6a10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6010b9b585a46c7aa4d09da6e9753889/" rel="bookmark">
			EdgeSAM: Prompt-In-the-Loop Distillation for On-Device Deployment of SAM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 EdgeSAM: Prompt-In-the-Loop Distillation for On-Device Deployment of SAM
EdgeSAM论文：https://arxiv.org/pdf/2312.06660.pdf
EdgeSAM代码：https://github.com/chongzhou96/EdgeSAM
1 概述 作者在对各种蒸馏策略进行深入剖析后，证实了task-agnostic的编码器蒸馏难以完全吸收SAM所掌握的全部知识。鉴于此，EdgeSAM巧妙地循环运用bbox与point提示词，并同步对提示词编码器和Mak解码器进行蒸馏，以确保蒸馏模型能够精准地掌握提示词与Mask之间错综复杂的关联。EdgeSAM是首个能在iPhone 14上以超过30 FPS运行的SAM变体。
在2080Ti上，相比原生SAM，EdgeSAM推理速度快40倍；在iPhone14上，相比MobileSAM，EdgeSAM推理速度快14倍，达到了38.7fps。 2 EdgeSAM EdgeSAM的目标是将SAM的功能转移到一个更为紧凑的模型中，使得在边缘设备上的部署变得可行。因此，EdgeSAM保留了SAM的编码器-解码器架构，并旨在保持零样本交互式分割（通过框和点提示）的性能。EdgeSAM的核心是在知识蒸馏过程中考虑提示词，以便学生模型接受任务特定的指导，并专注于更难的训练目标，如更精细的边界。为此引入了一种动态提示词采样策略，旨在实现三个关键目标：（1）从初始提示词（无论是框还是点）中动态生成一组多样化的提示词组合；（2）准确识别学生模型在掩膜内表现不准确的区域，从而将其注意力集中在这些特定部分；（3）迫使教师模型（即SAM）产生高质量的掩膜，以提供更精确的指导。
2-1 仅编码器知识蒸馏 Encoder-Only Knowledge Distillation 由于学生模型和SAM图像编码器的下采样步长和特征通道并不一致，MobileSAM移除了学生模型最后两个阶段的下采样操作，并使用一个投影层来对齐通道维度。EdgeSAM构建了一个小型FPN（特征金字塔网络），将特征上采样到所需的分辨率，并与前几个阶段的特征进行逐元素相加来保持下采样层不变，最后也使用投影层进行通道对齐。
实验发现，使用不同的backbones、更长的训练计划或者使用为密集预测任务设计的蒸馏损失并没有表现出明显的性能提升。
2-2 循环Prompt知识蒸馏 Prompt-In-the-Loop Knowledge Distillation SAM的掩膜解码器是一个双流双向转换器，其中来自图像编码器的输出特征图f作为其中一个流的输入，而稀疏提示嵌入p与四个掩膜标记m和一个IoU标记c连接在一起，作为另一个流的输入。稀疏提示可以是正/负点的任意组合以及一个单独的框，用于指示用户感兴趣的对象。
作者观察到，微调掩膜解码器会对零样本泛化能力构成挑战。也就是说，使用特定组合的提示进行训练会破坏其在推理时使用未训练过的提示组合时的能力。因此引入了一种循环Prompt知识蒸馏。这种策略旨在实现三个关键目标：（1）从初始提示（无论是框还是点）中动态生成一组多样化的提示组合；（2）准确识别掩膜内学生模型表现不准确的区域，从而将这些特定部分作为焦点；（3）迫使教师模型（即SAM）生成高质量的掩膜，以提供更精确的指导。策略如下：
从初始提示开始。以相同的概率，从SA-1B数据集中提供的框或点提示中选取一个，作为教师和学生模型解码器的输入。接着，我们识别出教师和学生模型掩膜预测不一致的区域。如下图所示，以教师的输出为参考，在标记为假负的区域中均匀采样新的正点提示，或在识别为假正的区域中采样新的负点提示。然后，将这些新采样的点与现有的提示组合起来，用于下一次解码迭代。值得注意的是，每个提示都会导致四个不同粒度级别的掩膜预测。其中不一致性是在具有最高IoU分数的教师掩膜与其对应的学生掩膜之间计算的。
实验表明，相比于依赖专门用于密集预测的损失或基于查询的方法进行蒸馏，在蒸馏过程中动态地将适当的提示组合输入到掩膜解码器中更为有效。提出的循环提示蒸馏方法优先使用策略性提示来增强学习过程。
2-3 粒度先验 Granularity Priors 由于SA-1B是一个类别无关、多粒度、自动标注的数据集，其标注分布可能与由人力密集标注的数据集（如COCO）存在很大差异。
因此，对于模糊提示词，如单点，SAM很难确定所需的输出粒度。如下图所示，使用框提示词时，SAM可以轻松地确定目标粒度。
构建了一个轻量级的区域提议网络（RPN）[41]，该网络由特征金字塔网络（FPN）和一个共享检测头组成。RPN在特定数据集（例如COCO）上进行训练，以捕获其粒度先验。在推理过程中，合并那些中心点为点提示词的K个最近邻（根据置信度得分加权）的提议框。最后，将合并后的框与点输入一起作为提示词，输入到掩膜解码器中。
3 Experiments 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0044a3c82ac787c50f4f215a547abaf8/" rel="bookmark">
			视觉信息处理与FPGA实现第三次作业-7人表决器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、模块端口图 二、代码 `timescale 1ns / 1ns module vote_7(person1,person2,person3,person4,person5,person6,person7,out); input person1,person2,person3,person4,person5,person6,person7 ; output out ; assign out=(person1+person2+person3+person4+person5+person6+person7&gt;= 4) ? 1 : 0; endmodule 三、testbench `timescale 1ns / 1ps module vote_7_tb(); reg person1,person2,person3,person4,person5,person6,person7; wire result; vote_7 vote_7( .person1 ( person1 ), .person2 ( person2 ), .person3 ( person3 ), .person4 ( person4 ), .person5 ( person5 ), .person6 ( person6 ), .person7 ( person7 ), .out ( result ) ); initial begin //The truth table for a 7-bit binary has a total of 128 entries.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0044a3c82ac787c50f4f215a547abaf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52221d1174455287b8e55d66666b0ef1/" rel="bookmark">
			Java毕业设计-基于spring boot开发的实习管理系统-毕业论文&#43;答辩ppt（附源代码&#43;演示视频）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、毕设成果演示（源代码在文末）二、毕设摘要展示1.开发说明2.需求分析3、系统功能结构 三、系统实现展示1、前台功能模块2、后台功能模块2.1 管理员功能2.2 教师功能2.3 学生功能2.4 实习单位功能 四、毕设内容和源代码获取总结 Java毕业设计-基于spring boot开发的实习管理系统-毕业论文+答辩ppt（附源代码+演示视频） –
前言 随着信息技术的飞速发展，Java语言作为一种成熟、稳定且功能强大的编程语言，已经广泛应用于企业级应用、移动开发、大数据处理等多个领域。作为本科大学生，我们在学习Java编程语言的过程中，不仅掌握了其语法规则和编程技巧，更重要的是学会了如何利用Java解决实际问题，实现软件系统的设计与开发。
本次毕业设计旨在通过实际项目的开发，将我们在大学期间所学的Java编程语言知识与实践相结合，进一步加深对Java语言的理解和应用。毕业设计的宗旨在于培养我们的独立思考能力、团队协作精神和创新能力，提升我们解决实际问题的能力，为未来的职业发展打下坚实的基础。
在毕业设计中，我们将综合运用Java编程语言、数据库技术、前端开发技术等，设计并实现一个具有实际应用价值的软件系统。通过需求分析、系统设计、编码实现、测试维护等阶段的实践，我们将全面提升自己的软件开发能力，为未来的学习和工作积累宝贵的经验。
一、毕设成果演示（源代码在文末） 二、毕设摘要展示 1.开发说明 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql 5.7（一定要5.7版本）
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
浏览器：谷歌浏览器
2.需求分析 利用springboot、Java、MyEclipse和mysql数据库等知识点，结合相关设计模式、以及软件工程的相关知识，设计一个实习管理系统，来进行记录用户的信息，以及系统信息的增删改查的功能，根据实现需求，系统需完成这些基本功能：
（1）系统合理显示系统首页界面，管理员界面，实习单位界面，教师界面和学生界面等界面。
（2）管理员，实习单位，教师和学生所有的信息都保存与数据库中。
（3）对实习管理信息能够进行查询、修改、删除、添加等操作。
3、系统功能结构 三、系统实现展示 1、前台功能模块 实习管理系统，用户进入到系统首页，可以查看首页，系统公告，个人中心，后台管理等内容进行操作
学生注册；在学生注册页面中输入学生学号，学生姓名，密码，确认密码，年级，联系电话，院系，专业等内容进行用户注册操作；
个人中心；在个人中心页面中输入学生学号，学生姓名，密码，年级，班级，性别，联系电话，院系，专业等内容进行更新信息
2、后台功能模块 后台用户登录，通过填写注册时输入的用户名、密码、选择角色等信息进行登录操作，
2.1 管理员功能 管理员登录进入实习管理系统可以查看首页，个人中心，班级管理，学生管理，教师管理，实习单位管理，实习作业管理，教师评分管理，单位成绩管理，系统管理等功能进行详细操作
班级管理；在班级管理页面中可以查看索引，班级等内容，并进行详情，修改和删除操作
学生管理；在学生管理页面中可以查看索引，学生学号，学生姓名，年级，班级，性别，联系电话，院系，专业等内容，并进行详情，修改和删除操作；
教师管理；在教师管理页面中可以查看索引，教师工号，教师姓名，性别，职称，联系电话等内容，并进行详情，修改或删除操作；
实习单位管理；在实习单位管理页面中可以查看索引，单位名称，单位性质，地址，负责人，联系电话，邮箱，单位地址等内容，并进行详情，修改和删除操作
教师评分管理；在教师评分管理页面中可以查看索引，单位名称，单位地址，教师工号，教师姓名，学生学号，学生姓名，实习评分，批改时间等内容，并进行详情，修改和删除操作；
2.2 教师功能 教师登录进入实习管理系统可以查看首页，个人中心，实习作业管理，教师评分管理等功能进行详细操作，
个人中心；在个人中心页面通过填写教师工号，教师姓名，性别，职称，联系电话等内容进行个人信息修改操作；
实习作业管理；在实习作业管理页面中可以查看索引，实习岗位，单位名称，单位地址，学生学号，学生姓名，班级，专业，院系，教师工号，教师姓名，实习时间，实习报告等内容，并进行详情或教师评分操作；
2.3 学生功能 学生登录进入实习管理系统可以查看首页，个人中心，实习作业管理，教师评分管理单位成绩管理等功能进行详细操作，
实习作业管理；在实习作业管理页面中可以查看索引，实习岗位，单位名称，单位地址，学生学号，学生姓名，班级，专业，院系，教师工号，教师姓名，实习时间，实习报告等内容，并进行详情，修改或删除操作；
单位成绩管理；在单位成绩管理页面中可以查看索引，学生学号，学生姓名，工作态度，任务完成率，工作积极性，考核结果，单位名称，提交时间等内容，并进行详情操作；
2.4 实习单位功能 实习单位登录进入实习管理系统可以查看首页，个人中心，实习作业管理，单位成绩管理等功能进行详细操作，
个人中心；在个人中心页面通过填写单位名称，单位性质，地址，负责人，联系电话，邮箱，单位地址等内容进行个人信息修改操作；
实习作业管理；在实习作业管理页面中可以查看索引，实习岗位，单位名称，单位地址，学生学号，学生姓名，班级，专业，院系，教师工号，教师姓名，实习时间，实习报告等内容，并进行详情或单位成绩操作。
四、毕设内容和源代码获取 Java毕业设计-基于spring boot开发的实习管理系统-毕业论文+答辩ppt（附源代码+演示视频）：https://download.csdn.net/download/u014740628/88855009
总结 通过本次毕业设计，我们不仅巩固了所学的Java编程语言知识，还学会了如何将理论知识应用于实际项目中。我们设计的软件系统具有一定的实际应用价值，这让我们对自己的能力充满了信心，也为未来的职业发展打下了坚实的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cd21259044de457f5fee30b0b2d0b2c/" rel="bookmark">
			应对恶意IP攻击的有效方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今数字化时代，网络攻击已经成为了互联网安全的重大挑战之一。恶意IP攻击是网络安全领域中的一种常见威胁，它可能导致数据泄露、服务中断、系统瘫痪等严重后果。因此，有效地应对恶意IP攻击至关重要。IP数据云将深入探讨如何应对恶意IP攻击，并提供一些有效的方法和建议。
IP风险画像查询：IP66_ip归属地在线查询_免费ip查询_ip精准定位平台
1. 实施强大的防火墙策略
防火墙是网络安全的第一道防线，可以监控和控制网络流量，阻止恶意IP地址的访问。通过配置防火墙规则，可以限制来自恶意IP地址的访问，并阻止恶意流量进入网络。
2. 使用IP地址黑名单
建立和维护IP地址黑名单是一种常见的应对恶意IP攻击的方法。黑名单中包含已知的恶意IP地址，当网络流量经过时，系统会与黑名单进行比对，识别并阻止来自这些IP地址的访问。
3. 实施入侵检测系统（IDS）和入侵防御系统（IPS）
入侵检测系统（IDS）和入侵防御系统（IPS）可以监测和阻止网络中的恶意行为和攻击。IDS可以检测恶意IP攻击的行为特征，发出警报并记录相关信息；而IPS则可以主动阻止恶意IP攻击，保护网络安全。
4. 进行实时流量分析和监控
通过实时流量分析和监控，可以发现潜在的恶意IP攻击，并及时采取措施进行应对。利用流量分析工具和机器学习算法，可以实现对异常流量的实时监测和分析，有效应对恶意IP攻击。
5. 加强日志记录和审计
加强网络设备和系统的日志记录和审计，记录网络流量、访问行为等信息，有助于发现和追踪恶意IP攻击，为后续的调查和应对提供重要线索。
6. 参与威胁情报共享
参与威胁情报共享可以获取来自全球范围内的恶意IP地址信息，为及时识别和应对新出现的威胁提供重要支持。通过共享威胁情报，可以获取更多的恶意IP地址信息和相关威胁情报，提高恶意IP攻击的识别准确度和及时性。
恶意IP攻击是网络安全领域中的一种常见威胁，可能对组织的网络安全造成严重影响。有效地应对恶意IP攻击需要综合利用多种方法和技术，包括实施强大的防火墙策略、使用IP地址黑名单、实施入侵检测系统和入侵防御系统、进行实时流量分析和监控、加强日志记录和审计，以及参与威胁情报共享等。只有综合运用这些方法，才能有效地保护网络安全，抵御恶意IP攻击的威胁。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c7a9420937541655c0ab9b148509dbb/" rel="bookmark">
			Android apk 打包及签名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android apk打包及签名主要分为3步：
1. 生成签名key store
➜ ~ keytool -genkey -v -keystore meet.jks -alias meet -keyalg RSA -keysize 2048 -validity 10000
keytool参数详解： -genkey：指示keytool生成一个新的密钥对。
-v：显示详细输出信息。
-keystore meet.jks：指定生成的Keystore文件名为meet.jks，你可以自定义文件名。
-alias meet：指定别名为meet，你同样可以自定义别名。
-keyalg RSA：指定密钥算法为RSA。
-keysize 2048：指定密钥的长度为2048位。
-validity 10000：指定证书的有效期限为10000天。
2. 在app的build.gradle中添加签名配置
//签名配置
signingConfigs {
release {
keyAlias 'meet'
keyPassword '123456'
storeFile file('/Users/holyli/AndroidProjects/Meet/app/src/main/jks/meet.jks')
storePassword '123456'
}
}
buildTypes {
release {
proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
//shrinkResources true
//是否启动ZipAlign压缩
zipAlignEnabled true
//Demo需要给同学们使用则暂不混淆
//是否混淆
minifyEnabled
//签名
signingConfig signingConfigs.release
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c7a9420937541655c0ab9b148509dbb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbd6173bb9d1b41946d92740e2b32ae5/" rel="bookmark">
			数据结构：详解【顺序表】的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 顺序表的定义 顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况下采用数组存储。动态顺序表与数组的本质区别是——根据需要动态的开辟空间大小。
2. 顺序表的功能 动态顺序表的功能一般有如下几个：
初始化顺序表打印顺序表中的数据检查顺序表的容量顺序表头部插入数据顺序表尾部插入数据顺序表头部删除数据顺序表尾部删除数据顺序表任意位置插入数据顺序表任意位置删除数据顺序表中查找数据顺序表中修改指定位置数据顺序表的销毁 3.顺序表各功能的实现 3.1 创建顺序表
typedef int SQDateType;//对int进行重命名，可增加代码的普适性。 typedef struct SeqList { SQDateType* a; size_t size; //有效数据 size_t capacity;//容量的空间大小 }SL;//对这个结构体重命名为SL，书写方便 3.2 初始化顺序表
由于建立顺序表后并没有原始空间，所以我们自行动态开辟空间，又因为后续要进行扩容，所以我们必须初始化容量大小。
void SeqListInit(SL*ps) { ps-&gt;a = (SQDateType*)malloc(sizeof(SQDateType) * 4);//初始化开辟4个int类型的空间 //检查是否开辟成功 if (ps-&gt;a == NULL) { printf("malloc fail!\n"); return; } ps-&gt;capacity = 4;//初始化容量大小为4 ps-&gt;size = 0; } 3.3 打印顺序表中的数据
对顺序表进行增删查改等操作后，我们要把数据打印在控制台以便观察。
void SeqListPrint(SL* ps) { //判断顺序表中是否有数据 assert(ps-&gt;size &gt; 0); for (int i = 0; i &lt; ps-&gt;size; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbd6173bb9d1b41946d92740e2b32ae5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e75fa56ca24013d00fbe67acd8062833/" rel="bookmark">
			【数据结构】堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、树的介绍以及堆
1.树
2.二叉树以及堆
二、堆的实现
1.heap.h
2.heap.c 1)堆的初始化和销毁
2） 堆的插入
3）堆的删除 4）取堆顶数据
5）堆的数据个数
6）堆的判空
3.test.c 一、树的介绍以及堆 1.树 在了解堆前，我们先来看看树的概念，树是一种非线性的数据结构，它是由n（n&gt;=0）个有限结点（树中的每个元素称为结点）组成的一个具有层次关系的集合。把它叫做树是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
特点：
⭐有一个特殊的结点，称为根结点，根结点没有前驱结点
⭐除根结点外，其余结点被分成M（M&gt;0）个互不相交的集合T1、T2、……、Tm，其中每一个集合Ti（1 &lt;= i &lt;= m）又是一个结构与树类似的子树。每棵子树的根结点有且仅有一个前驱，可以有0个或多个后继
⭐树是递归定义的
需要注意的是：树形结构中，子树不能有交集，否则就不是树形结构。
接下来看看有关树的相关概念：
结点的度：一个结点含有的子树的个数称为该结点的度，例如上图中的A，其结点的度为6
叶结点或终端结点：度为0的结点称为叶结点，如上图中：B、C、H、I...等为叶结点
非终端结点或分支结点：度不为0的结点，如上图中：D、E、F...等结点为分支结点
双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点，如上图中：A是B的父结点
孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点，如上图：B是A的孩子结点
兄弟结点：具有相同父结点的结点互称为兄弟结点，如上图：B、C是兄弟结点
树的度：一棵树中，最大的结点的度称为树的度，如上图：树的度为6
结点的层次：从根开始·定义起，根为第1层，根的子结点为第2层，以此类推
树的高度和深度：树中结点的最大层次，如上图：树的高度为4
堂兄弟结点：双亲在同一层的结点互为堂兄弟，如上图：H和I互为堂兄弟结点
结点的祖先：从根到该结点所经分支上的所有结点，如上图：A是所有结点的祖先
子孙：以某结点为根的子树中任一结点都称为该结点的子孙，如上图，所有结点都是A的子孙
森林：由m（m&gt;0）棵互不相交的树的集合称为森林
树的表示：
树的表示方法有很多，最常用的是孩子兄弟表示法。
typedef int DataType;
struct Node
{
struct Node* _firstChild1; // 第一个孩子结点
struct Node* _pNextBrother; // 指向其下一个兄弟结点
DataType _data; // 结点中的数据域
};
2.二叉树以及堆 二叉树是一种特殊的树形结构，在普通的树形结构中，除了根结点外，每个结点都可能有很多的直接后继，且每个结点都有且只有一个直接前驱。然而，在二叉树中，每个结点的度（即直接后继的数量）不超过2，也就是说，每个结点最多有两个子结点，通常称为左孩子和右孩子。此外，二叉树的子树分左右，且左右次序不能交换，这也是它与普通树的一个主要区别。
特殊的二叉树：
1）满二叉树：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为k，且结点总数是2^k-1（2^0 + 2^1 + 2^3 +.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e75fa56ca24013d00fbe67acd8062833/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/576cf1b7f94b54b6fc4160c72e4cf9d2/" rel="bookmark">
			服务器硬件基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器硬件是支持服务器运行的基础设施，它与普通的个人电脑硬件有所不同，主要表现在以下几个方面：
一、中央处理器（CPU）： 服务器CPU往往支持多线程和多核心，以满足同时处理多个请求的需要。服务器CPU的类型多种多样，它们根据性能、核心数量、线程数量、功耗和价格等因素进行分类。以下是一些常见的服务器CPU类型：
x86架构：这是目前最常见的服务器CPU架构，由英特尔和AMD公司生产。支持32位和64位运算，兼容性和软件生态良好。x86服务器CPU通常分为多个系列，如英特尔的Xeon和AMD的EPYC系列。ARM架构：ARM处理器通常用于移动设备，但近年来，ARM推出的服务器级CPU也渐渐受到关注，因其高能效比和适用于云服务的特性。如亚马逊的Graviton和华为的鲲鹏系列。Power架构：由IBM开发，主要用于IBM自己的服务器产品线，以及一些高端企业和政府部门服务器。Power架构CPU在处理大量数据和复杂计算方面表现出色。MIPS架构：曾经用于一些高端服务器，但现在已经被x86和ARM架构所取代。Alpha架构：主要用于科学计算和高端服务器，但已经逐渐被x86架构取代。SPARC架构：主要用于Sun Microsystems的服务器产品，现在主要由Oracle维护。 在选择服务器CPU时，需要考虑以下因素：
核心和线程数：多核心和多线程可以提供更好的并行处理能力和性能。时钟频率：CPU的时钟频率决定了其处理能力，高频率通常意味着更好的性能。缓存大小和类型：更大的缓存可以提高数据访问速度，L3缓存通常对性能影响较大。功耗和热设计功耗（TDP）：高功耗CPU通常性能更强，但也会产生更多热量。指令集和支持的特性：不同的CPU支持不同的指令集，如SSE、AVX等，这些指令集可以提高特定类型的计算效率。接口类型：确保CPU与主板插槽兼容，如LGA 1151、Socket AM4等。品牌和可靠性：选择知名品牌通常能保证更好的性能和稳定性。 根据服务器的应用场景，如云计算、大数据、高性能计算等，选择合适的CPU类型和规格是确保服务器高效运行的关键。
二、 内存（RAM）： 服务器需要大量的内存来处理大量的数据和请求。服务器内存通常比个人电脑的要大，有的服务器甚至配备了几百GB甚至TB级别的内存。
在服务器系统中，内存作为存储器，能够存储正在运行的程序和操作系统的数据。服务器的内存容量大、支持ECC（Error-correcting code）技术，能够高速地处理数据请求，适合高性能计算和大数据处理需求。服务器的内存管理和优化对于服务器的运行效率和性能有着至关重要的影响。如果内存使用不当或者出现故障，可能会导致服务器的运行速度变慢，甚至发生系统崩溃。
同时，内存的监控和管理也对于服务器的运行状态和稳定性有着关键的影响。一些监控工具能够实时地监测服务器的内存使用情况，一旦发现内存使用过量或者出现其他异常，就能够及时地进行处理，保证服务器的正常运行。
三、存储设备： 硬盘驱动器（HDD）：传统的机械硬盘，适合存储大量数据，但速度相对较慢。固态驱动器（SSD）：没有机械运动部件，读写速度快，但成本相对较高。服务器通常会使用多块SSD组成RAID阵列，以提高数据处理速度和保障数据安全。随机存取存储器（RAM）：用于快速存储和访问数据，但数据在断电后会丢失。 四、磁盘阵列： 磁盘阵列（Disk Array）是一种将多个磁盘驱动器组合起来提供更大存储容量、更高的数据传输速率和更佳的数据冗余性的技术。其中，最著名的磁盘阵列技术就是RAID（Redundant Array of Independent Disks）。
RAID是一种由多个物理硬盘组成的逻辑单元，这些硬盘可以是一个或多个硬盘组合。RAID通过将数据分布在多个硬盘上，提供了一种提高存储性能和数据保护的方法。RAID有多个级别，每个级别都采用了不同的数据分布和保护策略。
以下是一些常见的RAID级别：
RAID 0：也称为striping，数据被分成小块并分布在多个硬盘上，可以提高读写速度，但没有任何数据冗余，如果一个硬盘损坏，所有数据都会丢失。RAID 1：也称为mirroring，数据被完全复制到多个硬盘上，提供了很好的数据保护，但存储容量只有所有硬盘的总容量的一半。RAID 5：数据和奇偶校验信息被分布和存储在所有硬盘上，提供了数据保护和较高的存储效率，至少需要三个硬盘。RAID 6：类似于RAID 5，但增加了第二个奇偶校验信息，可以支持两个硬盘同时损坏，需要至少四个硬盘。RAID 10：结合了RAID 0的striping和RAID 1的mirroring，数据被分块并镜像到多个硬盘上，提供了高速度和良好的数据保护，但成本较高。
选择RAID的级别取决于你的需求，例如，如果你需要更高的性能，可以选择RAID 0或RAID 5。如果你需要更好的数据保护，可以选择RAID 1或RAID 6。如果你需要两者兼备，可以选择RAID 10。 除了RAID之外，还有其他磁盘阵列技术，例如：
JBOD（Just a Bunch of Disks）：没有冗余或分条的简单磁盘集合，性能和数据保护都不如RAID。NAS（Network Attached Storage）：通过网络连接的磁盘阵列，通常用于家庭或小型企业，提供文件存储和共享服务。SAN（Storage Area Network）：高性能的磁盘阵列，通过网络连接，通常用于大型企业，提供 block 级别的存储访问。
磁盘阵列和RAID技术在现代数据存储中扮演着重要角色，它们为我们提供了更大的存储空间、更高的数据访问速度和更佳的数据保护。 五、网络接口卡（NIC） 服务器通常需要更高的网络带宽和更低的网络延迟。服务器网络接口卡可以提供更高的网络速度和更好的网络稳定性。
六、其它 1 冗余电源供应：为了确保服务器不因电源问题而宕机，服务器通常配备有冗余电源，甚至多重冗余电源。
2. 散热系统：服务器产生的大量热量需要高效的散热系统来保持温度平衡，通常包括大型风扇、散热片和液冷系统等。
3. 冗余和故障转移能力：服务器硬件设计时考虑了高度的冗余性，包括电源、网络、存储等方面的冗余，以及支持故障转移和负载均衡的能力。
4. 扩展性：服务器硬件通常设计为易于升级和扩展，比如支持额外硬盘、内存条、网络接口卡等。
5. 可靠性：服务器的硬件要求比个人电脑的硬件高，其设计的重点是保证长时间的稳定运行，减少故障发生的概率。
6. 安全性能：服务器硬件还应考虑物理安全，如屏蔽辐射、防电磁干扰、防盗等设计。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/576cf1b7f94b54b6fc4160c72e4cf9d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51e4dfd1845bf9b02cfd1a54a1b88c9c/" rel="bookmark">
			斐讯N1装宝塔做服务器-完美环境版nginx&#43;apache
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		n1盒子怎么降级刷入Armbian_5.77自行百度吧，太多教程了
使用nginx，N1剩余空间1G左右，使用apache，N1空间剩余1.5G左右，按需求选择挂载U盘或硬盘
使用方法： 1.将armbian5.77 写入U盘中
2.N1 U盘启动
3.根目录新建ddbr文件夹
4.将BACKUP-s9xxx-emmc.img.gz上传至ddbr目录下(无须解压)
依次输入ddbr-r-y 回车等待完成，poweroff关机，拔出U盘重启即可。
系统账号root 密码centos
宝塔登录地址ip:8888 账号admino 密码password
卸载Nginx -Tengine2.2.4，安装Nginx1.16，不然有些网页404
U盘格式化为fat32格式
fdisk -l 查看u盘盘符
将下面命令中的sda替换成u盘的盘符
mount -t vfat -o umask=000 /dev/sda /mnt/
设备连接无线网教程 通过SSH或者连接显示器登陆
输入命令
yum install -y NetworkManager-wifi
安装好了之后
输入reboot重启
重新登陆
输入命令nmtui
选择activate a connection进入选择无线网输入密码连接即可。
运行FRP客户端： 使用 screen 创建一个会话，名字就叫 sakurafrp
screen -S sakurafrp
接着你将会看到终端内容被清空了，此时就可以开始运行客户端了。
输入命令
./frpc_linux_arm
然后输入访问密匙，选择线路，客户端就会开始运行了。
内网穿透注册地址https://www.natfrp.com/，免费解析5条记录，稳定性用起来不错，可以推荐
按下 Ctrl + A + D 就可以将会话隐藏在后台执行。
当你需要切换回这个会话的时候，输入命令
screen -r sakurafrp
设置开机自启 cat &gt; /etc/systemd/system/frp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/51e4dfd1845bf9b02cfd1a54a1b88c9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55ae8f6a01646117e53e2250af7df92a/" rel="bookmark">
			matlab 中文比较case
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.matlab %区别 cc='大学' %as两个字符 dd='大学' cc==dd ans = 1×2 logical array 1 1 cc1="大学" %as一个字符整体 dd1="大学" cc1==dd1 ans = logical 1 2.实际应用 问题：simple不精确匹配
‘康奈尔大学’——‘康乃尔大学’，如果两个中文字符之间有60%的相似度，就把它们列出来。
[m,n] = size(US) [m1,n1] = size(xsun) %%US，xsun分别为两种排名后的大学列表，xsrk是xs排名在学术排名的位置（xsrk可不管） AC = cell(161,3); ac = 1 for i = 1:m l1 = length(US(i)); a = US{i}; for j = 1:m1 b = xsun{j}; c = xsrk(j); l2 = length(xsun(j)); count = 0; for x = 1:l1 for y = 1:l2 if a(x) == b(y) %一个个单字比较，如'康' count = count +1; end end end if count/l1 &gt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55ae8f6a01646117e53e2250af7df92a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac23477f996425902ab441d0b314e079/" rel="bookmark">
			Could not use APOC procedures
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错内容： Traceback (most recent call last): File "/root/anaconda3/envs/sakura/lib/python3.9/site-packages/langchain_community/graphs/neo4j_graph.py", line 205, in __init__ self.refresh_schema() File "/root/anaconda3/envs/sakura/lib/python3.9/site-packages/langchain_community/graphs/neo4j_graph.py", line 248, in refresh_schema for el in self.query( File "/root/anaconda3/envs/sakura/lib/python3.9/site-packages/langchain_community/graphs/neo4j_graph.py", line 232, in query data = session.run(Query(text=query, timeout=self.timeout), params) File "/root/anaconda3/envs/sakura/lib/python3.9/site-packages/neo4j/_sync/work/session.py", line 313, in run self._auto_result._run( File "/root/anaconda3/envs/sakura/lib/python3.9/site-packages/neo4j/_sync/work/result.py", line 181, in _run self._attach() File "/root/anaconda3/envs/sakura/lib/python3.9/site-packages/neo4j/_sync/work/result.py", line 301, in _attach self._connection.fetch_message() File "/root/anaconda3/envs/sakura/lib/python3.9/site-packages/neo4j/_sync/io/_common.py", line 178, in inner func(*args, **kwargs) File "/root/anaconda3/envs/sakura/lib/python3.9/site-packages/neo4j/_sync/io/_bolt.py", line 849, in fetch_message res = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac23477f996425902ab441d0b314e079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c195f75529094bcb86fe544f88874e1/" rel="bookmark">
			OpenCV 笔记(26)：图像的透视变换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 图像的透视变换 1.1 简介 图像的透视变换（Perspective Transformation）是指将图像投影到一个新的视平面（Viewing Plane），也称作投影映射（Projective Mapping）。
透视变换是一种非线性变换，它可以将一个二维坐标系中的点映射到三维坐标系中的点，然后再将其投影到另一个二维坐标系中的点。透视变换可以改变图像中的形状，并可以模拟真实世界中的透视效果。
仿射变换可以看成是透视变换的特殊情况，下图是对几何变换的总结。
几何变换的总结.png 透视变换的应用：
图像矫正 透视变换可以用于矫正图像的透视失真，例如由于拍摄角度或镜头畸变导致的图像倾斜或拉伸。
图像配准 透视变换可以用于将两张或多张图像进行配准，使其具有相同的几何形状。这在医学图像处理、卫星图像处理等领域有着重要的应用。
3D 建模 透视变换可以用于将二维图像投影到三维空间，从而生成三维模型。
图像增强 透视变换可以用于调整图像的视角，使其看起来更具吸引力。
图像合成 透视变换可以用于将不同的图像合成在一起，创建新的图像。
特效 透视变换可以用于创建各种特效，例如虚拟场景、3D 动画等。
1.2 原理 透视变换的定义为将图像中的所有点按照一定的透视关系映射到新的图像中。
透视变换.png 透视关系可以由一个3x3的透视变换矩阵来表示，透视变换的矩阵如下：
其中，、、、 表示线性变换，、 表示平移变换，、 表示透视变换。
透视变换的过程为：
此时，得到的不是最后的坐标，还需要进一步转换：
最终的坐标为：
重新回顾一下整个透视变换的过程：
不难看出看出仿射变换是透视变换的一种特殊情况。
2. 透视变换的应用 2.1 商品图位置矫正 下面的代码，对图中的没有摆正的商品通过透视变换将其对齐，然后在原图中将商品放正。主要用到了 OpenCV 的 findHomography()、warpPerspective()函数进行透视变换。findHomography()函数用于计算两个平面之间进行透视变换的矩阵，warpPerspective() 函数用于对图像进行透视变换。
#include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;opencv2/imgproc.hpp&gt; using namespace std; using namespace cv; bool ascendSort(vector&lt;Point&gt; a,vector&lt;Point&gt; b) { return contourArea(a) &gt; contourArea(b); } long pointSideLine(Point &amp;lineP1, Point &amp;lineP2, Point &amp;point) { long x1 = lineP1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c195f75529094bcb86fe544f88874e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a0c9bfe28c5727a01c4abbaca7729ad/" rel="bookmark">
			RUST 每日一省：rust logo收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rust的logo集合，看看有没有你喜欢的，挑一个吧；
GitHub - XuHugo/rust-logo: Collection of logo images for all rust languages
下边只是挑选了几个，更多的还是看github吧。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/432bc64575e056b75a77d314e6ecca0b/" rel="bookmark">
			Guava Cache LoadingCache 基本使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一. 添加依赖 &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;27.1-jre&lt;/version&gt; &lt;/dependency&gt; 二. 创建CacheLoader LoadingCache&lt;Long, String&gt; cache = CacheBuilder.newBuilder() //缓存池大小，在缓存项接近该大小时， Guava开始回收旧的缓存项 .maximumSize(GUAVA_CACHE_SIZE) //设置过期策略 .expireAfterWrite(10, TimeUnit.MINUTES) //设置刷新策略 .refreshAfterWrite(10, TimeUnit.MINUTES) //移除监听器,缓存项被移除时会触发 .removalListener(new RemovalListener &lt;Long, String&gt;() { @Override public void onRemoval(RemovalNotification&lt;Long, String&gt; rn) { //执行逻辑操作 } }) //开启Guava Cache的统计功能 .recordStats() .build(cacheLoader); CacheLoader&lt;String, String&gt; cacheLoader = new CacheLoader&lt;String, String&gt;() { //expire后或第一次加载时 调用 @Override public String load(String key) throws Exception { return ""; } //refresh时调用 @Nullable @Override public ListenableFuture&lt;String&gt; reload(String key, HostInfo oldValue) throws Exception { return super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/432bc64575e056b75a77d314e6ecca0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcbe5c6a594ae4de1371f0436a52b80f/" rel="bookmark">
			Haproxy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Haproxy一、关于Haproxy1、Haproxy介绍2、Haproxy 主要特性3、常见的Haproxy负载均衡策略4、LVS、Nginx、HAproxy的区别 二、安装haproxy1、yum 安装2、第三方yum仓库安装3、编译安装3.1 解决lua环境3.2 编译安装 haproxy 三、配置文件详解1、global配置1.1 状态页1.2 指定进程线程个数1.3 cpu亲缘性1.4 多进程和线程1.5 日志 2、Proxies配置2.1 Proxies配置-defaults2.2 Proxies 配置 -listen 简化配置2.3 Proxies 配置 -frontend2.4 Proxies 配置 -backend Haproxy 一、关于Haproxy 1、Haproxy介绍 HAProxy是法国开发者威利塔罗(Willy Tarreau)在2000年使用C语言开发的一个开源软件，是一款具备高并发(一万以上)、高性能的TCP和HTTP负载均衡器，支持基于cookie的持久性，自动故障切换，支持正则表达式及web状态统计，目前最新TLS版本为2.2。
HAProxy是可提供高可用性、负载均衡以及基于TcP和HTTP应用的代理，是免费、快速并且可靠的一种解决方案。HProxy非常适用于并发大(并发达1w以上) web站点，这些站点通常又需要会话保持或七层处理。HAProxy的运行模式使得它可以很简单安全的整合至当前的架构中，同时可以保护web服务器不被暴露到网络上。
支持功能：
TCP 和 HTTP反向代理SSL/TSL服务器可以针对HTTP请求添加cookie，进行路由后端服务器可平衡负载至后端服务器，并支持持久连接支持所有主服务器故障切换至备用服务器 keepalive支持专用端口实现监控服务支持停止接受新连接请求，而不影响现有连接可以在双向添加，修改或删除HTTP报文首部字段响应报文压缩支持基于pattern实现连接请求的访问控制通过特定的URI（url）为授权用户提供详细的状态信息 2、Haproxy 主要特性 可靠性和稳定性非常好，可以与硬件级的F5负载均衡设备相媲美最高可以同时维护40000-50000个并发连接，单位时间内处理的最大请求数为20000个，最大处理能力可达10Git/s支持多达8种负载均衡算法,同时也支持会话保持支持虚拟机主机功能，从而实现web负载均衡更加灵活支持连接拒绝、全透明代理等独特的功能拥有强大的ACL支持,用于访问控制; sendfile其独特的弹性二x树数据结构，使数据结构的复杂性上升到了0(1)，即数据的查寻速度不会随着数据条日的增加而速度有所下降；支持客户端的keepalive功能，减少客户端与haproxy的多次三次握手导致资源浪费，让多个请求在一个tcp连接中完成支持TCP加速,零复制功能,类似于mmap机制支持响应池(response buffering)支持RDP协议基于源的粘性，类似nginx的ip hash功能，把来自同一客户端的请求在一定时间内始终调度到上游的同一服务器;·更好统计数据接口，其web接口显示后端集群中各个服务器的接收、发送、拒绝、错误等数据的统计信息详细的健康状态检测，web接口中有关于对上游服务器的健康检测状态，并提供了一定的管理功能基于流量的健康评估机制基于http认证基于命令行的管理接口日志分析器，可对日志进行分析 3、常见的Haproxy负载均衡策略 官方文档
http://cbonte.github.io/haproxy-dconv/2.4/configuration.html#4-balance roundrobin，表示简单的轮询 rr
static-rr，表示根据权重
leastconn，表示最少连接者先处理
source，表示根据请求源IP
uri，表示根据请求的URI，做cdn需使用
url param，表示根据请求的URl参数’ balance url param’requires an URL parameter name
hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求
rdp-cookie (name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求
静态调度算法：不管后端服务器，按照调度器的算法进行分配
动态调度算法：会考虑后端服务器的负载情况（直接动态的调整算法，发送指令给进程，直接生效）
4、LVS、Nginx、HAproxy的区别 调度算法的区别 nginxhaproxylvs（四层）rrrrrr加权轮询static-rrwrr（加权）ip hash最小连接数源地址hash（SH）url hashsource（根据源地址）目的地址hash（DH）cookie hash根据请求来调度默认wlc 加权最小连接数fair根据cookie来调度lc 最小连接最小连接数根据请求头初始连接高权重优先（SED）每个人都有一个连接后，再使用初始连接高权重（NQ） IVS基于Linux操作系统实现软负载均衡，而HAProxy和Nginx是基于第三方应用实现的软负载均衡
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcbe5c6a594ae4de1371f0436a52b80f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d39b7ab4936b4de2c0ed0692b611bb96/" rel="bookmark">
			Python爬虫基础学习-互联网、HTTP与HTML
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		互联网或者叫国际网（Internet），是指网络与网络之间所串连成的庞大网络，这些网络以一组标准的网络TCP/IP协议族相连，连接全世界几十亿个设备，形成逻辑上的单一巨大国际网络。它是由从地方到全球范围内几百万个私人的、学术界的、企业的和政府的网络所构成，通过电子，无线和光纤网络技术等等一系列广泛的技术联系在一起。这种将计算机网络互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的网络。
【提示】 互联网并不等于万维网（WWW），万维网只是一个基于超文本相互链接而成的全球性系统，且是互联网所能提供的服务其中之一。互联网带有范围广泛的信息资源和服务，例如相互关系的超文本文件，还有万维网的应用，支持电子邮件的基础设施，点对点网络，文件共享，以及IP电话服务。
HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准。通过使用网页浏览器、网络爬虫或者其他的工具，客户端可以发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。 通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息或者其他信息。 HTTP的请求方法有很多种，主要包括: HEAD，与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的内容部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。POST，向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求文本中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。PUT ，向指定资源位置上传其最新内容。DELETE ，请求服务器删除Request-URI所标识的资源。TRACE ，回显服务器收到的请求，主要用于测试或诊断。OPTIONS ，这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*'来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。CONNECT， HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。 HTML则是指== 超文本标记语言==（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。与HTTP不同的是，HTML是一种基础技术，常与CSS、JavaScript一起被众多网站用于设计令人赏心悦目的网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现方式，使之成为一种标记语言而非编程语言。 HTML元素是构建网站的基石。HTML允许嵌入图像与对象，并且可以用于创建交互式表单，它被用来结构化信息——例如标题、段落和列表等等，也可用来在一定程度上描述文档的外观和语义。HTML的语言形式为尖括号包围的HTML元素（如），浏览器使用HTML标签和脚本来诠释网页内容，但不会将它们显示在页面上。 HTML可以嵌入如JavaScript的脚本语言，它们会影响HTML网页的行为。网页浏览器也可以引用层叠样式表（CSS）来定义文本和其他元素的外观与布局。维护HTML和CSS标准的组织万维网联盟（W3C）鼓励人们使用CSS替代一些用于表现的HTML元素。HTML标记包含标签（及其属性）、基于字符的数据类型、字符引用和实体引用等几个关键部分。HTML标签是最常见的，通常成对出现，比如&lt;h1&gt;与 &lt;/h1&gt;。这些成对出现的标签中，第一个标签是开始标签，第二个标签是结束标签。两个标签之间为元素的内容，有些标签没有内容，为空元素，如 &lt;img&gt;。 HTML另一个重要组成部分为文档类型声明，这会触发标准模式渲染。HTML文档由嵌套的HTML元素构成。它们用HTML标签表示，包含于尖括号中，如 &lt;p&gt; 在一般情况下，一个元素由一对标签表示：“开始标签”&lt;p&gt;与“结束标签”&lt;/p&gt;。元素如果含有文本内容，就被放置在这些标签之间。 在开始与结束标签之间也可以封装另外的标签，包括标签与文本的混合。这些嵌套元素是父元素的子元素。 开始标签也可包含标签属性。这些属性有诸如标识文档区段、将样式信息绑定到文档演示和为一些如&lt;img&gt;等的标签嵌入图像、引用图像来源等作用。 一些元素如换行符&lt;br&gt;，不允许嵌入任何内容，无论是文字或其他标签。这些元素只需一个单一的空标签（类似于一个开始标签），无须结束标签。 许多标签是可选的，尤其是那些很常用的段落元素&lt;p&gt;的闭合端标签。HTML浏览器或其他媒介可以从上下文识别出元素的闭合端以及由HTML标准所定义的结构规则，这些规则非常复杂。
因此，一个HTML元素的一般形式为：&lt;标签 属性1="值1" 属性2="值2"&gt;内容&lt;/标签&gt;。一个HTML元素的名称即为标签使用的名称。注意，结束标签的名称前面有一个斜杠“/”，空元素不需要也不允许结束标签。如果元素属性未标明，则使用其默认值。
HTML 标题
HTML 标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签来定义的。 实例 &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;h2&gt;这是一个标题&lt;/h2&gt; &lt;h3&gt;这是一个标题&lt;/h3&gt; HTML 段落
HTML 段落是通过标签 &lt;p&gt; 来定义的。 实例 &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另外一个段落。&lt;/p&gt; HTML 链接
HTML 链接是通过标签 &lt;a&gt; 来定义的。 实例 &lt;a href="https://www.runoob.com"&gt;这是一个链接&lt;/a&gt; 提示:在 href 属性中指定链接的地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d39b7ab4936b4de2c0ed0692b611bb96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9167b4af33b85b4ad71c4eb24fae918/" rel="bookmark">
			机试:偶数分解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述:
代码示例:
#include &lt;bits/stdc++.h&gt; using namespace std; int main(){ //	算法思想1:遍历小于该偶数的所有素数,存入数组中,遍历数组找出两个数之和等于偶数的数 int n; cout &lt;&lt; "输入样例" &lt;&lt; endl; cin &gt;&gt; n; int nums[n]; int k = 0; for(int i = 2; i &lt;= n; i++){ bool tag = true; for(int j = 2; j &lt;= sqrt(i); j++){ if(i % j == 0){ tag = false; break; } } if(tag == true){ nums[k++] = i; } } //	for(int i = 0; i &lt; k; i++){ //	cout &lt;&lt; nums[i] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9167b4af33b85b4ad71c4eb24fae918/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12a7ca4971f31cb9ad2309e4377a4f28/" rel="bookmark">
			数据分析案例- Netflix 电影和电视节目数据集可视化分析（文末送书）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🤵‍♂️ 个人主页：@艾派森的个人主页
✍🏻作者简介：Python学习者
🐋 希望大家多多支持，我们一起进步！😄
如果文章对你有帮助的话，
欢迎评论 💬点赞👍🏻 收藏 📂加关注+
目录
1.项目背景
2.数据集介绍
3.技术工具
4.导入数据
5.数据可视化
6.总结
文末推荐与福利
1.项目背景 随着视频流媒体服务的兴起和发展，如Netflix、Hulu、Amazon Prime等，人们对电影和电视节目的需求和观看习惯发生了变化。Netflix作为全球最大的视频流媒体服务提供商之一，拥有庞大的电影和电视节目库，涵盖了各种不同类型和风格的内容。
对Netflix的电影和电视节目数据集进行可视化分析，不仅可以帮助我们更深入地了解Netflix平台上的内容分布、受众偏好和趋势，还可以为内容创作、推荐系统优化以及市场营销策略提供重要的参考和决策支持。
具体而言，通过对Netflix数据集的可视化分析，可以探索以下方面：
内容类型分布： 分析Netflix平台上电影和电视节目的类型分布情况，了解哪些类型的内容更受欢迎，以及不同类型之间的数量和比例。
上线时间分析： 探索Netflix上不同年份和季度上线的电影和电视节目数量和趋势变化，分析新内容的增长速度和趋势。
评分和受欢迎程度： 分析Netflix内容的评分分布情况，了解受欢迎程度高的电影和电视节目特征，以及用户对不同类型内容的评价偏好。
国家/地区分布： 研究Netflix内容的国家/地区分布情况，了解不同国家/地区内容的数量和类型，以及可能存在的地域特色和差异。
内容时长分析： 分析Netflix电影和电视节目的时长分布情况，了解用户对不同时长内容的偏好和观看习惯。
通过以上分析，可以为Netflix及其他视频流媒体服务提供商提供有益的洞察，帮助他们更好地理解用户需求，优化内容选择和推荐系统，提升用户体验，增强竞争力。因此，对Netflix电影和电视节目数据集进行可视化分析具有重要的研究意义和实际应用价值。
2.数据集介绍 本数据集来源于Kaggle，是 Netflix 电影和电视节目数据集，原始数据集共有8790条，10个变量，各变量含义如下：
show_id：展出ID
type：内容（电视节目或电影）
title：标题
director：节目或电影的导演
country：节目或电影的国家/地区
date_added：添加到 Netflix 的日期
release_year：内容发布年份
rating：评级或限制
duration：内容持续时间
listed_in：内容类型
3.技术工具 Python版本:3.9
代码编辑器：jupyter notebook
4.导入数据 导入第三方库并加载数据集
import numpy as np import pandas as pd import matplotlib.pyplot as plt import seaborn as sns df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12a7ca4971f31cb9ad2309e4377a4f28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84549e48969170301ec92c30868709fb/" rel="bookmark">
			华为鸿蒙系统接入实人认证 蚂蚁蚁盾提供技术支持
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着华为千帆计划持续推进，鸿蒙生态日渐完善。近日，华为自研的鸿蒙操作系统与蚂蚁数科、阿里云合作开发的实人认证产品完成适配。这意味着基于鸿蒙系统开发的 App 可以 0 门槛接入该实人认证产品，鸿蒙用户可以无感享受到和安卓、IOS 系统一样的便捷验证服务。据了解，这也是市面上第一个适配鸿蒙系统的实人认证产品。
实人认证产品兼容鸿蒙系统，让华为在系统层面建立起了纵深链接的能力，大量原生 App 将依托这一金融级的实人认证服务链接用户身份，提供高效、便捷的产品体验。记者了解到，该产品的主要研发来自蚂蚁数科的安全科技团队蚁盾。
蚁盾依托于蚂蚁集团 10 多年在生物识别技术上的沉淀以及大规模商业场景验证，实人认证准确率达到 99%，目前已经被多款“国民级”App 集成。在安全性方面，该产品具备人脸算法对抗、人脸保镖设备切面对抗、链路传输对抗、图像防伪对抗和安全策略对抗等多层安全体系，能够有效拦截图片、视频以及深度伪造技术（Deepfake）攻击，国内唯一获得了 iBeta国际安全组织最高等级Level2认证。
今年 1 月 18 日，华为正式发布鸿蒙星河版操作系统（HarmonyOS NEXT），这标志着一个完全独立、不与安卓系统兼容的原生版鸿蒙系统正式面世，来自行业生态的 200 余个鸿蒙原生 App 正在加速开发，包括支付宝、美团、京东、小红书等头部应用。
与此同时，蚂蚁集团、中国银联、科大讯飞等公司与华为的底座能力协同发力，为开发者提供高效的全链路开发工具，开发工作量最高可减少90%，帮助行业加速应用鸿蒙化开发。记者注意到，支付宝、蚂蚁数科旗下移动开发平台 mPaaS、蚁盾实人认证产品先后与华为鸿蒙达成合作，从工具和应用层面形成了“让开发者用 mPaaS 开发鸿蒙应用、让用户通过蚁盾实人认证服务链接鸿蒙、让支付宝原生应用诞生在鸿蒙”的生态服务能力。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/28/">«</a>
	<span class="pagination__item pagination__item--current">29/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/30/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>