<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19fc8cb78130b0824ef04a13b255a892/" rel="bookmark">
			漂泊不定的人生，终究在层层浪花中，站稳了跟脚，姐成功了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 博主本人是15年毕业的，在校期间自学的Android，在小城市待了三年，小城市IT不太发达，倒闭了两家公司，然后去了杭州谋生，待了一年，结果又倒闭了！可谓是一直颠簸流离，漂泊不定。
这次就想找个大公司，不想再折腾了，想稳定一点，同时大公司技术底蕴也比较强，想多学习学习，提升自己。
于是乎，在去年十月份我毅然决然前往了北京，面试了百度。
正文 10月14日北京面试，成功报喜已！！！（快乐的事情就要提前说，以下是我面试的大致内容，十分感谢之前收到一位朋友的礼物，至于是什么，文末有公布）
百度 一面： 算法：给你n个数，找到最大的m个数equals和hashcode说一下线程创建的方法？线程池原理说一下？线程同步的方法？HashMap说一下？百度贴吧的子帖的实现方法（主帖里面的评论帖，分别从数据库和移动端两个方面来说一下）如果在一个论坛主界面有很多帖子，并且在主界面上都显示这些帖子的图片（每个帖子9张），怎样避免OOM。（讲了两个思路，一个思路是展示缩略图，点击展示大图，另一个是横向ListView，滑动查看更多，滑出范围对Bitmap进行回收）。图片压缩过程和缓存相关说一下？LinkedHashMap跟HashMap的差别是什么？底层原理是什么？ 二面： 算法：给你一个字符串，判断是不是标准的ip地址。（我写完一个之后，说让我把所有的测试用例写出来，发现有几个遗漏掉了，面试官说，让我根据这些测试用例重新再写一下，考察代码扩展优化能力。）自我介绍，聊聊项目，问我数据来源和数据库设计比较多。（项目上聊的比较多）举了个数据库联合查询的例子，写个简单的SQL语句。（join）TCP的三次握手说一下？为什么是三次握手？为什么是四次挥手？TCP的滑动窗口原理知道吗？（我说原理不清楚，但是我知道他解决的是什么问题。）hashMap是线程安全吗？如何实现线程安全？Android的持久化存储方式说一下？Android的启动模式和场景说一下？Android的ANR知道吗？怎么避免？内存溢出和内存泄露说一下（中间有提了下Handler） 三面： 自我介绍，项目介绍项目中你遇到最大的问题是什么？怎么解决的？（感觉是压力面，会把你说的话往不好的方向诱导，中间多次解释）了解生产者消费者模式吗？他主要解决的是什么问题？队列数目为0的时候是怎样的？描述一下整体过程中线程的状态，怎么实现的是线程同步，不要用sychronized来说。（emmm，设计模式一直是我的薄弱的地方，了解的不够深入，回答一点后就立马再被追问，被怼的很惨）平时有什么兴趣爱好？有没有男朋友？报的上海，如果调岗到北京怎么看？有什么想问我的吗？ 最后 碎碎念：=。= 嗷嗷嗷，聊一聊百度的面试感觉。由于是老早之前面试的了，面试题目其实记得不太清楚了，应该遗漏了不少，就只写了记得的那些。
印象给我最深的就是三面的面试官。当时面到他的时候，其实已经很累了，他看我过来就直接帮我倒水，让我别急着自我介绍，先把水喝了再说。QAQ 人真的太好了。
其实面试难度都还好，大多还是看你的设计思路，中间聊项目也是。
13日坐高铁去的北京，14日面了一上午，三面完，正好是中午，发现周边最近的景点是圆明园，就去那边溜达了一下，晚上回杭州。=。= 也没觉得出来面试，就当来旅游一回，不亏不亏。
至于前文所说的礼物是什么呢？也就是在面试前狠狠刷了一波百度朋友给的社招面试题，在面试过程中这本面试题可谓是帮我了老大的忙了，如果没有它，可能都不会拿到这么好的工作，接下来我就分享出来给大家。
目录 内容挺多，就不一一展示了，需要的可以扫描下方二维码添加免费获得。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9677f656ef18734db16bf01e4de265a0/" rel="bookmark">
			mysql表空间回收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回收方法 1. alter table tb_test engine=innodb;
2. optimize table tb_test；
3. gh-ost/pt-osc
alter table tb_test engine=innodb 原理介绍 MySQL5.6 开始采用 Inplace 方式重建表，Alter 期间，支持 DML 查询和更新操作，语句为 alter table t engine=innodb, ALGORITHM=inplace;之所以支持 DML 更新操作，是因为数据拷贝期间会将 DML 更新操作记录到 Row log 中。
重建过程中最耗时的就是拷贝数据的过程，这个过程中支持 DML 查询和更新操作，对于整个 DDL 来说，锁时间很短，就可以近似认为是 Online DDL。
执行过程：
1、获取 MDL（Meta Data Lock）写锁，innodb 内部创建与原表结构相同的临时文件
2、拷贝数据之前，MDL 写锁退化成 MDL 读锁，支持 DML 更新操作
3、根据主键递增顺序，将一行一行的数据读出并写入到临时文件，直至全部写入完成。并且，会将拷贝期间的 DML 更新操作记录到 Row log 中
4、上锁，再将 Row log 中的数据应用到临时文件
5、互换原表和临时表表名
6、删除临时表
alter table、analyze table和optimize table区别 alter table tb_test engine = innode；（也就是 recreate）就是 Online DDL 重建表过程；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9677f656ef18734db16bf01e4de265a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73d6d09f0f7f381bc3db4dbabaad17f3/" rel="bookmark">
			解决VS Code编辑运行C/C&#43;&#43;代码文件中文乱码问题；修改编码为GBK
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 参考文章问题描述解决方法 参考文章 VSCODE C语言终端输出中文乱码编码设置
问题描述 VS Code默认文件编码时UTF-8，这对大多数情况是没有问题的，却偏偏对C/C++有问题。如果以UTF-8编码保存C/C++代码，那么只能输出英文，另外使用不同的编辑器打开改代码时，中文注释也可能会乱码。
解决方法 文件 ⇒ 首选项 ⇒ 设置，点击右侧图标，打开setting.json
在setting.json中添加两项
"[cpp]": { "files.encoding": "gbk" }, "[c]": { "files.encoding": "gbk" } 以后新建.c .cpp文件时，将默认为GBK编码，中文不会乱码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b277cf60a539e256b77345115e1315e/" rel="bookmark">
			Android：进程运行中被收回权限
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		流程如图：
MainActivity 跳转至 MainActivity2 再跳转至 MainActivity3MainActivity3跳转至 设置，收回权限一路返回 运行log如下 // 一路跳转，打开设置，收回权限 com.miss.soullink E/MainActivity: == onCreate == 25149 com.miss.soullink E/MainActivity: == onCreate == savedInstanceState null com.miss.soullink E/MainActivity2: == onCreate == 25149 com.miss.soullink E/MainActivity3: == onCreate == 25149 // 返回时的 com.miss.soullink E/MainActivity3: == onCreate == 27596 com.miss.soullink E/MainActivity2: == onCreate == 27596 com.miss.soullink E/MainActivity3: == onDestroy == MainActivity3 com.miss.soullink E/MainActivity: == onCreate == 27596 com.miss.soullink E/MainActivity: == onCreate == savedInstanceState Bundle[{android:viewHierarchyState=Bundle[mParcelledData.dataSize=944], androidx.lifecycle.BundlableSavedStateRegistry.key=Bundle[{}], android:lastAutofillId=1073741823, android:fragments=android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b277cf60a539e256b77345115e1315e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5a60555633923c5c4d4410610f0aa66/" rel="bookmark">
			＜自然语言处理-基于预训练模型的方法＞ 思维导图（更新中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;自然语言处理-基于预训练模型的方法&gt; 文章目录 &lt;自然语言处理-基于预训练模型的方法&gt;前言一、绪论二、自然语言处理基础 前言 思维导图是我按照《自然语言处理-基于预训练模型的方法》整理而成
因为有些章节的内容比较多我就觉得还是整理一下才没有白看，于是做了思维导图，应该会继续更新（如果有时间的话）
书籍豆瓣链接：https://book.douban.com/subject/35531447/ 一、绪论 二、自然语言处理基础 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb209f9a3e0f04b060bed1c5d106762c/" rel="bookmark">
			万事俱备，SSH依然连接不上VMware虚拟机，救命之法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前期配置过程 1.VMware中虚拟网络编辑器配置NAT模式
2.虚拟机的网络适配器设置为NAT模式
3.本地连接中VMware Virtual Ethernet Adapter for VMnet8根据1中IP地址进行设置
4.打开虚拟机，根据1中配置修改IP地址、网关等信息
5.安装SSH服务，修改sshd_config配置文件，成功启动，端口监听成功
6.关闭虚拟机防火墙
7.关闭本地防火墙
8.service network restart
本地和虚拟机能够ping通，但是ssh连接仍然失败
二、解决方法 1.删除Vmware虚拟网络编辑器中的原有网络，还原默认设置，重新设置网络
2.禁用本地网络适配器Adapter for VMnet8，然后重新启动VMnet8
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fc6e7f8316619e8fda4e47c735d18cd1/" rel="bookmark">
			GIT更新流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.git pull 更新代码到最新的版本（建议每次写代码 提交代码，更新代码，反正有事没事都PULL一下）
git pull 之后如果有下新代码会提示 如果已经是最新的 提示 up to date
2.git stattus 把本地代码和上传的最新的代码对比不一样的部分会以红色显示出来
3.git add . 添加这些代码 输入完之后不会提示什么
4. git commit -m "标识符（随便输入什么以作标记）"
5. git push -u origin 分支（origin后空格输入要提交的分支名字） 回车之后 显示提交百分比完了之后就成功啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/288a52ee3e532b724c1ed3ab4344ac44/" rel="bookmark">
			Linux 网卡 Bonding 配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、bonding技术 简介
bonding(绑定)是一种将n个物理网卡在系统内部抽象(绑定)成一个逻辑网卡的技术，能够提升网络吞吐量、实现网络冗余、负载等功能，有很多优势。
Linux 系统下支持网络 Bonding,也叫 channel Bonding,它允许你将 2 个或者更多的网卡绑定到一起,成为一个新的逻辑网卡,从而实现故障切换或者负载均衡的功能,具体情况要取决于 mode 参数的具体配置。
Linux系统bonding技术是内核层面实现的，它是一个内核模块(驱动)。使用它需要系统有这个模块, 我们可以modinfo命令查看下这个模块的信息, 一般来说都支持。
modinfo bonding bonding的七种工作模式
bonding技术提供了七种工作模式，在使用的时候需要指定一种，每种有各自的优缺点.
balance-rr (mode=0) 默认, 有高可用 (容错) 和负载均衡的功能, 需要交换机的配置，每块网卡轮询发包 (流量分发比较均衡).
active-backup (mode=1) 只有高可用 (容错) 功能, 不需要交换机配置, 这种模式只有一块网卡工作, 对外只有一个mac地址。缺点是端口利用率比较低
balance-xor (mode=2) 不常用
broadcast (mode=3) 不常用
802.3ad (mode=4) IEEE 802.3ad 动态链路聚合，需要交换机配置，没用过
balance-tlb (mode=5) 不常用
balance-alb (mode=6) 有高可用 ( 容错 )和负载均衡的功能，不需要交换机配置 (流量分发到每个接口不是特别均衡)
详细说明请参考网络上其他资料，了解每种模式的特点根据自己的选择就行, 一般会用到0、1、4、6这几种模式。
二、RHEL6 下的 Bonding 配置: 在所有的 RHEL 版本下,目前都不支持在 NetworkManager 服务协作下实现 Bonding 配置.所以要么直接关闭 NetworkManager 服务,并取消其开机启动,要么在所有涉及 Bonding 的网卡配置文件中(包含ethx 或者 bondY),显式地添加一行:NM_CONTROLLED=no
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/288a52ee3e532b724c1ed3ab4344ac44/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ead2baebff2c4e1d41404e0b15042a00/" rel="bookmark">
			图形化渗透测试工具 -- GUI_Tools
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		感谢利刃信安的无私分享。。。
软件获取方式，公众号后台回复：20211025
一、下载后，解压
二、需要用到python的wx模块
安装wx模块：pip install -U wxPython
三、运行该软件
python GUI_Tools.py
禁止非法，后果自负
欢迎关注公众号：web安全工具库
欢迎关注视频号：之乎者也吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/464f272c5d1d6b621a953102204c86d0/" rel="bookmark">
			常见开关电源优缺点对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关注+星标公众号，不错过精彩内容
素材来源 | 网络
本文主要讲述常见的开关电源拓扑结构特点和优缺点对比。
常见的拓扑结构，包括Buck降压、Boost升压、Buck-Boost降压-升压、Flyback反激、Forward正激、Two-Transistor Forward双晶体管正激等。
常见的基本拓扑结构
一、基本的脉冲宽度调制波形
这些拓扑结构都与开关式电路有关。
基本的脉冲宽度调制波形定义如下：
二、常见的基本拓扑结构
1、Buck降压
把输入降至一个较低的电压。
可能是最简单的电路。
电感/电容滤波器滤平开关后的方波。
输出总是小于或等于输入。
输入电流不连续(斩波)。
输出电流平滑。
2、Boost升压
把输入升至一个较高的电压。
与降压一样，但重新安排了电感、开关和二极管。
输出总是比大于或等于输入(忽略二极管的正向压降)。
输入电流平滑。
输出电流不连续(斩波)。
3、Buck-Boost降压-升压
电感、开关和二极管的另一种安排方法。
结合了降压和升压电路的缺点。
输入电流不连续(斩波)。
输出电流也不连续(斩波)。
输出总是与输入反向(注意电容的极性)，但是幅度可以小于或大于输入。
“反激”变换器实际是降压-升压电路隔离(变压器耦合)形式。
4、Flyback反激
如降压-升压电路一样工作，但是电感有两个绕组，而且同时作为变压器和电感。
输出可以为正或为负，由线圈和二极管的极性决定。
输出电压可以大于或小于输入电压，由变压器的匝数比决定。
这是隔离拓扑结构中最简单的。
增加次级绕组和电路可以得到多个输出。
5、Forward正激
降压电路的变压器耦合形式。
不连续的输入电流，平滑的输出电流。
因为采用变压器，输出可以大于或小于输入，可以是任何极性。
增加次级绕组和电路可以获得多个输出。
在每个开关周期中必须对变压器磁芯去磁。常用的做法是增加一个与初级绕组匝数相同的绕组。
在开关接通阶段存储在初级电感中的能量，在开关断开阶段通过另外的绕组和二极管释放。
6、Two-Transistor Forward双晶体管正激
两个开关同时工作。
开关断开时，存储在变压器中的能量使初级的极性反向，使二极管导通。
主要优点：每个开关上的电压永远不会超过输入电压；无需对绕组磁道复位。
7、Push-Pull推挽
开关(FET)的驱动不同相，进行脉冲宽度调制(PWM)以调节输出电压。
良好的变压器磁芯利用率——在两个半周期中都传输功率。
全波拓扑结构,所以输出纹波频率是变压器频率的两倍。
施加在FET上的电压是输入电压的两倍。
8、Half-Bridge半桥
较高功率变换器极为常用的拓扑结构。
开关的驱动不同相，进行脉冲宽度调制以调节输出电压。
良好的变压器磁芯利用率——在两个半周期中都传输功率。而且初级绕组的利用率优于推挽电路。
全波拓扑结构,所以输出纹波频率是变压器频率的两倍。
施加在FET上的电压与输入电压相等。
9、Full-Bridge全桥
较高功率变换器最为常用的拓扑结构。
开关以对角对的形式驱动，进行脉冲宽度调制以调节输出电压。
良好的变压器磁芯利用率——在两个半周期中都传输功率。
全波拓扑结构，所以输出纹波频率是变压器频率的两倍。
施加在 FETs上的电压与输入电压相等。
在给定的功率下，初级电流是半桥的一半。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/464f272c5d1d6b621a953102204c86d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/596ea8ac58b53a18a6429431a1bf6b79/" rel="bookmark">
			记录如何将阿里云ECS主机以镜像方式迁移到线下机房vmware esxi主机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简单记录一下步骤：
参考：https://dev-tang.com/post/2020/03/esxi-vmdk.html
第一步：登录阿里云控制台，创建自定义镜像；
第二部：导出刚刚创建的镜像到本地机房；
导出方法：可以先将镜像导出到oss然后在本地服务器安装ossutil工具下载下来，也可以生成oss链接后本地下载；
第三部：在本地服务器安装qemu工具，用于将raw镜像格式转换成vmdk格式
https://qemu.weilnetz.de/w64/?spm=5176.2020520101image.help.12.22204df52hFOsQ
qemu-img convert -f 源类型 -O 目标类型 源磁盘映像路径 输出磁盘映像路径 C:\Users\Administrator&gt;qemu-img convert -f raw E:/libo_m-m5ee1lz26rgaa4r6hpga_system.raw -O vmdk E:/system.vmdk 第四部：将vmdk格式镜像上传至esxi主机存储中
第五步：通过shell等ssh工具登录esxi主机将vmdk格式镜像转换成esxi可用的vmdk格式；
来到刚刚上传镜像的路径 [root@localhost:/vmfs/volumes/609bfee9-53fdf634-c027-2cea7fec4202/主机镜像vmdk] vmkfstools -i system.vmdk -d thin out-system.vmdk Destination disk format: VMFS thin-provisioned Cloning disk 'system.vmdk'... Clone: 100% done. 第六步：创建虚拟机，添加“已有磁盘”选则刚刚转换好的vmdk磁盘镜像；
第七步：开机登录，修改IP等信息；
修改网卡参数
将阿里云ECS镜像迁移到线下后还需要修改网卡配置，修改后重启发现不能保存配置，这时候需要如下操作：
安装cloud-init后，打开/etc/cloud/cloud.cfg文件。 vim /etc/cloud/cloud.cfg 按i进入编辑模式，在Example datasource config之前增加disabled配置（在配置文件中添加如下2行）。 network: config: disabled 参考：https://help.aliyun.com/document_detail/57803.html?spm=5176.smartservice_service_chat.0.0.292549f7bjpKSy&amp;scm=20140722.S_help%40%40%E6%96%87%E6%A1%A3%40%4057803.S_os%2Bhot.ID_57803-RL_cloudDASinit-OR_helpmain-V_2-P0_0#title-i2d-05c-a4i 第八步：卸载镜像中在阿里云上的软件
卸载云顿、云监控、云助手（参见阿里云）
可参考：https://www.laozuo.org/13023.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff4043065ccc2ead6a2d1496a2129b7e/" rel="bookmark">
			Hive执行异常org.apache.hadoop.hdfs.BlockMissingException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天hive在执行的时候出现了报错，内容如下：
Caused by: org.apache.hadoop.hdfs.BlockMissingException: Could not obtain block: BP-2040810143-192.168.144.145-1612269795515:blk_1077591653_3851069 file=/hbase/data/default/cycle_middle_data/c4cc4a321e4779c75d810ba0698079c3/info/395d0f3895cf407b88921f9cbc8a54de at org.apache.hadoop.hdfs.DFSInputStream.refetchLocations(DFSInputStream.java:880) at org.apache.hadoop.hdfs.DFSInputStream.chooseDataNode(DFSInputStream.java:863) at org.apache.hadoop.hdfs.DFSInputStream.chooseDataNode(DFSInputStream.java:842) at org.apache.hadoop.hdfs.DFSInputStream.fetchBlockByteRange(DFSInputStream.java:998) at org.apache.hadoop.hdfs.DFSInputStream.pread(DFSInputStream.java:1361) at org.apache.hadoop.hdfs.DFSInputStream.read(DFSInputStream.java:1325) at org.apache.hadoop.fs.FSDataInputStream.read(FSDataInputStream.java:93) at org.apache.hadoop.hbase.io.hfile.HFileBlock.positionalReadWithExtra(HFileBlock.java:808) at org.apache.hadoop.hbase.io.hfile.HFileBlock$FSReaderImpl.readAtOffset(HFileBlock.java:1568) at org.apache.hadoop.hbase.io.hfile.HFileBlock$FSReaderImpl.readBlockDataInternal(HFileBlock.java:1772) at org.apache.hadoop.hbase.io.hfile.HFileBlock$FSReaderImpl.readBlockData(HFileBlock.java:1597) at org.apache.hadoop.hbase.io.hfile.HFileReaderImpl.readBlock(HFileReaderImpl.java:1488) at org.apache.hadoop.hbase.io.hfile.HFileBlockIndex$CellBasedKeyBlockIndexReader.loadDataBlockWithScanInfo(HFileBlockIndex.java:340) at org.apache.hadoop.hbase.io.hfile.HFileReaderImpl$HFileScannerImpl.seekTo(HFileReaderImpl.java:852) at org.apache.hadoop.hbase.io.hfile.HFileReaderImpl$HFileScannerImpl.reseekTo(HFileReaderImpl.java:833) at org.apache.hadoop.hbase.regionserver.StoreFileScanner.reseekAtOrAfter(StoreFileScanner.java:347) at org.apache.hadoop.hbase.regionserver.StoreFileScanner.reseek(StoreFileScanner.java:256) ... 19 more at org.apache.hadoop.hbase.ipc.AbstractRpcClient.onCallFinished(AbstractRpcClient.java:387) at org.apache.hadoop.hbase.ipc.AbstractRpcClient.access$100(AbstractRpcClient.java:95) at org.apache.hadoop.hbase.ipc.AbstractRpcClient$3.run(AbstractRpcClient.java:410) at org.apache.hadoop.hbase.ipc.AbstractRpcClient$3.run(AbstractRpcClient.java:406) at org.apache.hadoop.hbase.ipc.Call.callComplete(Call.java:103) at org.apache.hadoop.hbase.ipc.Call.setException(Call.java:118) at org.apache.hadoop.hbase.ipc.NettyRpcDuplexHandler.readResponse(NettyRpcDuplexHandler.java:162) at org.apache.hadoop.hbase.ipc.NettyRpcDuplexHandler.channelRead(NettyRpcDuplexHandler.java:192) at org.apache.hbase.thirdparty.io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:359) at org.apache.hbase.thirdparty.io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:345) at org.apache.hbase.thirdparty.io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:337) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff4043065ccc2ead6a2d1496a2129b7e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b94f5818439ecdf866b56c958da2bb8/" rel="bookmark">
			＜a-tree-select＞多选树组件的输入搜索功能清空
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 树型选择控件多选支持搜索的时候，输入文字，可以对树进行筛选：
&lt;a-tree-select class="w260" multiple placeholder="请选择业务分类" v-model="queryParam.businessTypeIdList" allowClear :filterTreeNode="filterTreeOption" @change="businessTypeChange" treeDefaultExpandAll &gt; &lt;a-tree-select-node v-for="i in businessTypesList" :value="i.id" :disabled="disabled" :title="i.name" :key="i.id" &gt; &lt;a-tree-select-node v-for="item in i.children" :filterTreeNode="filterTreeOption" :value="item.id" :title="item.name" :key="item.id" &gt; &lt;/a-tree-select-node&gt; &lt;/a-tree-select-node&gt; &lt;/a-tree-select&gt; 直接清空控件绑定的值，即将v-modal绑定的queryParam.businessTypeIdList值置为空，输入的内容没有被清空。
那么想要清空输入的搜索内容，可以使用以下方法：
在&lt;a-tree-select&gt;控件中绑定以下属性：
:searchValue="searchvalueBusinessType" 这样获取到输入的内容之后，在想要清空的时候直接将输入内容置为空即可。 这里还有一个问题，就是虽然输入的内容被绑定为searchvalueBusinessType了，但是页面展示有问题，所以还需要绑定一个属性，用来接收输入的动作：
@search="businessTypeSearch" businessTypeSearch(value){ this.searchvalueBusinessType = value } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b69bafd113b406b7053b42c729f73cf/" rel="bookmark">
			Servlet类的部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要想让Web服务器使用Servlet类编译后的字节码文件创建Servlet对象处理用户请求，必须先为Web服务器部署。部署Servlet目前有两种方式；1.在web.xml中部署；2.基于注解的方式部署Servlet。
一、在web.xml中部署
在JavaWeb中创建一个Servlet类，代码如下：
package Servlet; import javax.servlet.*; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.PrintWriter; public class FirstServlet extends HttpServlet { private static final long serialVersionUIO = 1L; @Override public void init(ServletConfig config) throws ServletException { super.init(config); } public void service (HttpServletRequest request, HttpServletResponse response)throws IOException { response.setContentType("text/html;charset=utf-8"); PrintWriter out = response.getWriter(); //out.println("&lt;html&gt;&lt;body&gt;"); out.println("在web.xml中部署Servlet-------红乐"); //out.println("&lt;body&gt;&lt;html&gt;"); } } 然后在项目中找到web.xml
在&lt;web-app&gt;&lt;/web-app&gt;中添加如下内容：
&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt; &lt;servlet&gt; &lt;!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b69bafd113b406b7053b42c729f73cf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e62f0b162d12bceddea611161ef4000/" rel="bookmark">
			深度学习框架的发展历程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 现在深度学习框架已经这么多了，为什么还有这么多人不断推出新的深度学习框架？
这个问题问的非常好，想要看看目前为什么这么多深度学习框架的出现，还真的不得不回头看看深度学习框架出现的历史趋势，然后去理解目前深度学习发展，给框架带来的要求，就会明白除了政治因素之外，新的深度学习框架推出原因。
首先我们来看看AI框架具体有什么用呢？
AI在现实生活中发挥的作用越来越多，不知不觉我们用的越来越多的产品都内嵌了AI功能，包括我现在给你们录制视频的字幕，都是纯AI算法进行识别和时间轴对齐的。就好像，不提自家产品有AI功能，都显得落伍了。下面来随机看看几款产品。
在全球迎来移动互联网后，基本上人手一台移动手机，一台手机算上前后置摄像头，动辄像华为P50 Pro有6个摄像头，少则前置摄像头1个后置摄像头1个。移动视觉领域的发展当然离不开AI的身影。以花瓣视频剪辑APP为例，视频里面的人脸贴图功能，当XXX明星出轨X、吸毒X、睡粉X，这时候需要后台剪辑小哥人工和谐掉，使用了AI人脸贴上马赛克功能后，“妈妈再也不但担心我要加班打码了”。当然这个功能，不是单凭一个算法，就可以实现。首先，我们需要有一个算法，这个算法只是一些数学公式，接着使用AI框架提供的接口，来实现这些数学公式，实现完后，我们还需要使用AI框架，长期稳定地在手机里面小小的一块芯片上运行，这就需要AI软件对硬件资源的调度、跟操作系统的协同。
所以，简单来说AI框架，就是实现数学算法的软件工具，释放硬件澎湃的算力。
到了第二点，下面来看看AI发展过程当中，所使用到的一些工具。
20世纪30年代，通用计算机还没有出现之前，实际上人们还不知道“算法”是什么。不过，当时数学领域中已经有很多问题都是跟“算法”密切相关，有大量跟计算性理论相关的研究。
正是这个年代，图灵在二战的时候思考智能与可计算问题，提出了图灵机，用于任何人类能够完成的逻辑推理和计算过程，从而慢慢形成算法的概念。在这之前，“计算”能力是被视为与“思考”相类似的人类抽象能力，大家一时间很难接受“计算”可以被如此简单的模型所概括。
1943年，麦卡洛克(W.S.McCulloch)和 皮兹(W.Pitts) 联合发表的论文里面，给出了人工神经元的第一个数学模型，神经网络第一个模型(MCP模型)的提出，也只是单纯一个数理逻辑概念。那时候，世界上第一台计算机还没有诞生。图灵只是给智能和算法进行了定义和思考。
1957年我国大跃进年代，Rosenblatt 提出由两层神经元组成一个神经网络，称之为感知器(Perceptrons)，并且在他的论文里面详细地介绍感知器的具体硬件实现电路方案，还具体地给出了感知器具体学习算法，就是利用梯度下降法，对损失函数计算极小值，求出可将输入数据进行，线性划分的分离超平面，从而求得感知器模型。 1986年，美国IBM发布了第一台笔记本电脑，同一年里Geoffrey Hinton发表了能够在多层感知器(MLP)上快速计算梯度的反向传播(Back propagation)算法，也就是我们经常说的BP算法，这时候Hinton不需要自行实现硬件，而是基于微型计算机的操作系统之上的算法程序来实现的。 了解完算法的定义、计算机的出现到深度学习算法的发展，现在来看看AI框架的发展历程，聊聊AI框架的出现原因和对AI产业的意义。
进入2010年后，随着深度学习的使用越来越广泛，于是便开始出现了AI框架，通过软件来快速实现深度学习算法。从图中，我们可以看到Theano作为第一个支持深度学习框架，到了2012年开始后，开始慢慢每隔1-2年就出现两三个新的AI框架。
早期学术界针对深度学习框架主要有Theano、ConvNet、Caffe和Torch等。刚推出的时候主要是面向学术研究而设计，进行一些小规模的原型算法研究，像是Theano能够利用符号化式语言定义深度学习算法公式，然后运行在硬件设备上。而2012年Alex觉的Theano并不能进行分布式和并行计算，于是使用C++实现了ConvNet框架，实现AlexNet算法，并且利用两块GPU进行并行加速训练和推理功能，最终赢得2012年ImageNet图像分类比赛冠军。
人工智能正是在近十几年来形成革命性地爆发。从学术理论研究，到生产应用的产品化开发过程中，通常会涉及到多个不同的步骤，这使得人工智能开发，依赖的环境安装、部署、测试，以及不断迭代改进算法准确性，推理性能调优的工作变得非常繁琐耗时。AI框架从学术的研究，慢慢随着深度学习只能做个简单的文字识别分类，到图像目标检测、语义分割，扩展到文字识别、文字生成，语音翻译等不同的领域，乃至现在的AI+科学计算，在电磁仿真、蛋白质折叠、移动视觉等应用范围也越来越广。
既然AI这么火，流程这么复杂，为了简化、加速和优化AI的流程，于是产业界开始纷纷入局AI，开发并完善了多个基础的平台和通用工具，这时候AI的基础软件开始被称为深度学习框架或者AI框架。有了这些基础的平台和工具，就可以避免大家重复发明轮子，专注于AI领域的算法研究和产品创新。到现在为止，产业界有Google领导的TensorFlow，Amazon选择押注的MXNet，Facebook倾力打造的PyTorch，Huawei主推开源的MindSpore等不同的AI框架出现。
如果你要问我，这么多框架应该选择哪个？还真不好说，因为AI还在快速发展，前几年出现的框架，到现在为止，基本上剩下图中黄色的，仍然活跃在业界，大部分都AI框架都沉寂下去了。
----
最后便是未来AI框架的研究意义和挑战。
AI开发者追求的是易用，尤其在训练方面，易用框架的生态会建立得非常快。由于AI领域发展很快，新特性的快速支持，能够吸引更多开发者和研究者留存。性能方面，反而在前期对开发者来说不是那么重要，因为在训练上更关注开发的效率、算法原型设计的效率，更少关注的是硬件成本。
对推理部署来说，在实际的生产业务系统里，希望追求极致的性能。推理业务对企业来说，部署量非常大的，假如能够把性能做好，5个百分点的性能提升能节省5%的硬件成本和耗电量，还可以减少机房部署的额外开销，对于企业来说是实际的账面收益。
由此可见，训练测讲究易用性，端侧讲究性能。一方面，AI框架在训练测，开始逐渐地跟端侧推理融合，推理框架直接基于芯片运行，脱离可操作系统还可以进行少量的学习，赋能芯片智能。另外一方面，随着AI在安全、大模型、科学计算、物理模拟、蛋白质折叠等场景对AI应用领域的拓展，会新增越来越多的功能。
[AI系统] 1.3 AI框架的兴起
欢迎大家关注我的知乎和Bilibili账号：ZOMI酱 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1415c0998dd4a79ef445613692de3065/" rel="bookmark">
			2021-10-25
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 示例程序 #include &lt;stdio.h&gt; int main(int ac, char **av) { int localfn(int a) { return a+ac; } int (*fptr)(int) = localfn; printf("%d\n", fptr(-1)); return 0; } 编译 1
gcc trampoline.c -z execstack -o t ./t 0 编译2
gcc trampoline.c -z noexecstack -o t ./t [1] 1499 segmentation fault ./t 参考文献 https://www.win.tue.nl/~aeb/linux/hh/protection.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534aab6005fa7be9d34308225a0f2ef2/" rel="bookmark">
			空心五角星python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef414e9a9c51f9f8d6aa4aff7bb8d35/" rel="bookmark">
			❤️2万字带你走进python爬虫requests库，史上最全！！❤️
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 requests 库简介 Requests 是一个为人类设计的简单而优雅的 HTTP 库。 requests 库是一个原生的 HTTP 库，比 urllib3 库更为容易使用。 requests 库发送原生的 HTTP 1.1 请求，无需手动为 URL 添加查询串， 也不需要对 POST 数据进行表单编码。相对于 urllib3 库， requests 库拥有完全自动化 Keep-alive 和 HTTP 连接池的功能。 requests 库包含的特性如下。 ❖ 1Keep-Alive &amp; 连接池 ❖ 国际化域名和 URL ❖ 带持久 Cookie 的会话 ❖ 浏览器式的 SSL 认证 ❖ 自动内容解码 ❖ 基本 / 摘要式的身份认证 ❖ 优雅的 key/value Cookie ❖ 自动解压 ❖ Unicode 响应体 ❖ HTTP(S) 代理支持 ❖ 文件分块上传 ❖ 流下载 ❖ 连接超时 ❖ 分块请求 ❖ 支持 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ef414e9a9c51f9f8d6aa4aff7bb8d35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84051bca4968f04626a4477e02050566/" rel="bookmark">
			在Android studio上开发APP之后，连接模拟器或者是打包APK发送给手机之后，找不到应用图标，但是手机里已经显示安装了。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 项目场景： 刚开始学习Android studio的时候，就自己模拟做了一个能连接起打电话的程序，就是运用setData（）方法，然后在AndroidManifest.xml中进行活动注册，注册如下：
&lt;data android:scheme="tel" /&gt; 问题描述： 连接模拟器或者是打包成APK发送给手机，都是可以安装，但是不显示应用图标，但在设置或者手机管家都是可以看到安装过了。 原因分析： 原因就是activity中的intent-filter用了不同的data和action属性。intent-filter必须满足所有的属性才通过这种方式启动。当我们设置了不同的data和action。就会通过两种方式启动，所以不能放在一起
解决方案： 我发现我这行代码不管用，我就直接给注释了。然后现在连接模拟器之后都是有图标的。所以我认为可以通过增加
&lt;intent-filter&gt; 代码段 &lt;/intent-filter&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d18e7ae67cd457ab2da8cbb2ab831b26/" rel="bookmark">
			AXI4协议学习：架构、信号定义、工作时序和握手机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1 AXI是什么？2 AXI怎么工作？3 AXI协议3.1 架构3.1.1 通道定义3.1.2 接口与互连（interconnect）3.1.3 Register slices 3.2 基本事务3.2.1 突发读示例3.2.2 重叠突发读示例3.2.3 突发写示例3.2.4 事务顺序 3.3 额外的功能 4 信号定义4.1 全局信号4.2 写地址通道信号4.3 写数据通道信号4.4 写响应通道信号4.5 读地址通道信号4.6 读数据通道信号4.7 低功耗接口信号4.8 字段定义的简单说明：4.9 AXI-Lite与AXI-stream的接口 5 通道握手机制5.1 握手过程5.2 通道之间的关系5.3 通道握手信号之间的依赖关系 6 AXI4相关文件7 需要学习的文件 UG1037 不是 高级微控制器总线结构（advanced micro controller bus architecture，AMBA）ARM AXI4规范的替代品，而是说明：
可用于创建基于AXI的IP的Xilinx工具。被Xilinx采用的AXI功能。将现有设计改为AXI接口的向导文件。 XIlinx 从Spartan-6和Virtex-6开始使用 高级可扩展接口(Advanced eXtensible Interface,AXI)。
1 AXI是什么？ AXI是 ARM AMBA的一部分。
AMBA 是 ARM 1996年首次引入的一种微控制器总线。2003年发行的AMBA3.0 引入了AXI。2010年发行的AMBA4.0 包含了AXI的第二版：AXI4。
Xilinx使用的就是AXI4接口。
AXI4接口的四种类型：
AXI4（AXI4-Full）: 满足高性能内存映射（memory-mapped）需求。支持256长度突发（burst）传输。AXI4-Lite: 对于简单的、低吞吐量的内存映射通信(例如，与控制寄存器和状态寄存器之间的通信)。不可突发传输。AXI4-Stream: 用于高速流数据。不需要地址，允许无限的数据突发大小。 AXI4的好处：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d18e7ae67cd457ab2da8cbb2ab831b26/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/284/">«</a>
	<span class="pagination__item pagination__item--current">285/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/286/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>