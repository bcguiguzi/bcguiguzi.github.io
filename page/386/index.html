<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e7fbb041cfc4fe9ec2124aad2d776a/" rel="bookmark">
			以太坊智能合约开发基础概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 智能合约调用方式 消息调用( Message Calls) 合约可以通过消息调用的方式来调用其它合约或者发送以太币到非合约账户合约可以决定在其内部的消息调用中,对于剩余的gas,应发送和保留多少如果在内部消息调用时发生了out-of-gas异常(或其他任何异常),这将由一个被压入栈顶的错误值所指明;此时只有与该内部消息调用一起发送的gas会被消耗掉 委托调用(Delegatecall） 一种特殊类型的消息调用目标地址的代码将在发起调用的合约的上下文中执行,并且msg.sender和 msg.value不变可以由此实现“库”( library):可复用的代码库可以放
在一个合约的存储上,通过委托调用引入相应代码 合约的创建和自毁 通过一个特殊的消息调用create calls,合约可以创建其他合约(不是简单的调用零地址)
合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 selfdestruct;合约账户上剩余的以太币会发送给指定的目标,然后其存储和代码从状态中被移除
智能合约开发语言（solidity） 部署智能合约的流程 solidity 智能合约源码使用编译器编译字节码，同时产生智能合约的二进制接口规范(Application binary Interface,简称ABI)通过交易(Transaction)的方式将字节码部署到以太坊网络，向0x0 地址发送交易，该交易类型为创建合约类型,每次部署成功都会产生一个新的智能合约账户（内部账户）使用javascript编写DAPP 通过web3.js +ABI去调用智能合约中的函数来实现数据的读取和修改
solidity 编译器 Remix
remix 是基于 web浏览器solidity IDE ,https://remix.ethereum.org/ solcjs
solc是solidity 源码库构建目标之一，命令行编译器可以使用npm安装solidity 编译器 solcjs, npm install -g solc 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce3eb576a5a7f21be96e6b9ccb54251b/" rel="bookmark">
			Fiddler常用QuickExec命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fiddler的QuickExec功能可以通过命令，帮助快速定位会话；
位置：Fiddler会话底部。快捷键：alt+q
1.=responsecode：快速选择指定http状态码。例如输入“=504”点击回车，fiddler会把会话列表中所有的http状态码为504的全部选中
2.=method：快速查找指定http请求方法。例如输入“=get”；
3.@host：快速选择主机中包含指定内容的会话。例如输入“@baidu”，那么baidu.com就会被选中；
4.bold ：执行命令后，抓取到的请求url包含的指定内容会被加粗显示。例如输入“bold baidu”
5.？search：搜索符合条件的url。例如“？baidu.com”符合条件的会被选中
6.cls或者clear：清除所有会话；
7.dump：保存所有会话；
8.quit：退出软件；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c43c680320e53fbbacad445ba861f3b8/" rel="bookmark">
			OpenGL with QtWidgets：练习之绘制2D环形进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.实现思路 这里主要涉及几个点：绘制圆环，绘制文字，动画，抗锯齿。
绘制圆环网上有些人是计算好圆边的顶点后传入的，我这里直接在片段着色器里根据距离圆心的距离来渲染的圆环。
void main() { float len = abs(sqrt(pow(thePos.x,2)+pow(thePos.y,2))); float alpha = abs(len-0.75); alpha = (alpha&gt;0.15)?0.0:1.0; FragColor = vec4(0.4,0.1,0.6,alpha); } 绘制文字的话，网上有的人是先绘制到纹理上再渲染问题，不过 Qt 的 QOpenGLWidget 类可以配合 QPianter 使用。因为是 2D，我直接使用 QPianter 绘制的文字。这里面也遇到问题，就是 QPainter 绘制的文字和在别的画布上呈现的效果不一样，最后选择的微软雅黑效果才好点。
void CircleProgressBar::paintGL() { QPainter painter(this); painter.setPen(Qt::white); painter.setFont(QFont("Microsoft YaHei",16)); const QString text_val=QString::number(progress*100,'f',2)+" %"; const int text_x=width()/2-painter.fontMetrics().width(text_val)/2; const int text_y=height()/2+painter.fontMetrics().height()/2; painter.drawText(text_x,text_y,text_val); } 动画我使用的属性动画而不是 QTimer，让 Qt 来决定刷新的时机。
抗锯齿我参照了网上的一些方式，比如多重采样什么的都没效果，最后用的 smoothstep 函数来实现的圆环部分的抗锯齿。
（参照：Shader smoothstep使用_冠位仓鼠--慕白-CSDN博客_smoothstep）
void main() { float len = abs(sqrt(pow(thePos.x,2)+pow(thePos.y,2))); //float alpha = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c43c680320e53fbbacad445ba861f3b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ed3d29535ffb84ee188fd5af938a2a/" rel="bookmark">
			vs2019整理代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 CTRL+KCTRL+F 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6261dd75bb78ec23db81d17c1edc536/" rel="bookmark">
			OpenCV自学记录（6）——python实现连通域处理函数cv2.connectedComponentsWithStats（）和cv2.connectedComponents（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV自学记录（6）——连通域处理函数cv2.connectedComponentsWithStats（）和cv2.connectedComponents（） 1、两个函数介绍1.1什么是连通域1.2cv2.connectedComponents（）1.3cv2.connectedComponentsWithStats（） 2、代码实践3、总结 1、两个函数介绍 总得来说，connectedComponents()仅仅创建了一个标记图（图中不同连通域使用不同的标记，和原图宽高一致），connectedComponentsWithStats()可以完成上面任务，除此之外，还可以返回每个连通区域的重要信息–bounding box, area, andcentroid。
1.1什么是连通域 连通区域一般是指图像中具有相同像素值且位置相邻的前景像素点组成的图像区域。连通区域分析是指将图像中的各个连通区域找出并标记。
连通区域分析是一种在CVPR和图像分析处理的众多应用领域中较为常用和基本的方法。例如：OCR识别中字符分割提取（车牌识别、文本识别、字幕识别等）、视觉跟踪中的运动前景目标分割与提取（行人入侵检测、遗留物体检测、基于视觉的车辆检测与跟踪等）、医学图像处理（感兴趣目标区域提取）、等等。也就是说，在需要将前景目标提取出来以便后续进行处理的应用场景中都能够用到连通区域分析方法，通常连通区域分析处理的对象是一张二值化后的图像。
1.2cv2.connectedComponents（） 函数各参数意义：
num_objects, labels = cv2.connectedComponents(image) 参数介绍如下：
image：也就是输入图像，必须是二值图，即8位单通道图像。（因此输入图像必须先进行二值化处理才能被这个函数接受）
返回值：
num_labels：所有连通域的数目
labels：图像上每一像素的标记，用数字1、2、3…表示（不同的数字表示不同的连通域）
1.3cv2.connectedComponentsWithStats（） 这个函数的作用是对一幅图像进行连通域提取，并返回找到的连通域的信息：retval、labels、stats、centroids
num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(image, connectivity=8, ltype=None) 参数介绍如下：
image：也就是输入图像，必须是二值图，即8位单通道图像。（因此输入图像必须先进行二值化处理才能被这个函数接受）
connectivity：可选值为4或8，也就是使用4连通还是8连通。
ltype：输出图像标记的类型，目前支持CV_32S 和 CV_16U。 返回值：
返回值：
num_labels：所有连通域的数目
labels：图像上每一像素的标记，用数字1、2、3…表示（不同的数字表示不同的连通域）
stats：每一个标记的统计信息，是一个5列的矩阵，每一行对应每个连通区域的外接矩形的x、y、width、height和面积，示例如下： 0 0 720 720 291805
centroids：连通域的中心点
2、代码实践 两个代码的用处是共通的，cv2.connectedComponentsWithStats函数返回的信息量更大，所以这里展示它的应用。
import cv2 import numpy as np # 读入图片 img = cv2.imread("001.jpg") # 中值滤波，去噪 img = cv2.medianBlur(img, 3) gray = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6261dd75bb78ec23db81d17c1edc536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c481d0bc6e9f6a47dd30c855f0b40403/" rel="bookmark">
			Ubuntu18.04中settings里Network界面中的Wired选项不见了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		害！！！也不知咋回事，settings软件里Network界面中的Wired选项突然就不见了，真叫人捉急，这可咋办，虚拟机也不能联网了！！！
从网上找了找资料，下面这个方法可以解决问题：
在终端中输入以下命令：
sudo service network-manager stop
sudo rm /var/lib/NetworkManager/NetworkManager.state
sudo service network-manager start
sudo gedit /etc/NetworkManager/NetworkManager.conf
把false改成true
sudo service network-manager restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/413fc2a040eb36340c180887e96335c4/" rel="bookmark">
			Go使用chromedp库操作headless-chrome爬取&#34;JS画出来的&#34;网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着类似Vue、Angular这类通过JS将web页面"画"出来的前端框架的流行，爬取网页不再像以前那样随便发个GET请求，解析HTML就能搞定了。对于使用这类框架制作的SPA(Single Page Web Application)网站来说，必须使用一个全功能浏览器将JS脚本执行一遍才能获得想要的数据，除此之外别无他法。这里我们介绍如何使用Go语言的chromedp库来操作headless-chrome模拟浏览器操作，然后抓取网页数据的方案。
"无头"Chrome与远程调式协议 所谓headless-chrome，是Chrome浏览器的无GUI的命令行版浏览器。虽然没有UI，但是功能上跟我们日常使用的Chrome是没有任何区别的。从Chrome的59版本开始，无头浏览器就已经在安装Chrome的时候自动装好了。例如在MacOS上，我们可以直接通过终端调用chrome将HTML代码直接输出到控制台：
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --headless --disable-gpu --dump-dom https://www.sogou.com 有了这东西以后其实就能做很多事了，如果你只是想爬取JS生成的网页内容，通过shell脚本，或者其他任何编程语言，都可以使用这种方式获取到完整的html，然后再进一步解析获取数。但是如果你想模拟一下用户的操作，比如表单提交、截图等操作，这就不好办了。这就需要chrome能够提供一种远程交互协议, 然后允许各编程语言通过次协议进行通讯，这就是远程调试协议Remote Debugging Protocol。
幸运的是我们并不需要学习协议的具体内容，Go有一个chromedp第三方库，允许我们以更简单的编程的方式通过远程调试协议操作Chrome，github地址：https://github.com/chromedp/chromedp
使用方法和注意事项 现在网上很多例子都是只爬取一个页面的例子，然而实际中我们经常需要按一定规则爬取整个网站，这时候就涉及到Chrome实例的复用问题，总不能跟其他博客说的那样每爬取一个网页都要销毁、打开Chrome吧，效率太低了。
在爬取之前，我们需要做一些重要的设置，比如要自定义User-Agent，因为默认情况下headless-chrome会很实在的在UA中标记出来自己是headless的，这样就有可能被目标网站拒绝。其次是要禁用图片加载，因为通过测试发现，如果网页中有动态GIF, chromedp会卡住，原因未知。禁止图片加载即可解决问题。设置的方式如下：
options := []chromedp.ExecAllocatorOption{ chromedp.Flag("headless", false), // debug使用 chromedp.Flag("blink-settings", "imagesEnabled=false"), chromedp.UserAgent(`Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36`), } options = append(chromedp.DefaultExecAllocatorOptions[:], options...) Chrome初始化代码如下：
c, _ := chromedp.NewExecAllocator(context.Background(), options...) // create context chromeCtx, cancel := chromedp.NewContext(c, chromedp.WithLogf(log.Printf)) // 执行一个空task, 用提前创建Chrome实例 chromedp.Run(chromeCtx, make([]chromedp.Action, 0, 1)...) 可以看到chromedp是严重依赖于go的context包的，如果不熟悉context的使用最好先去研究一下。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/413fc2a040eb36340c180887e96335c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6acc3dc234e815816f9602b2076984b/" rel="bookmark">
			什么是OPC UA？为什么它会继续使用？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 开放平台通信(OPC)和OPC 统一架构(OPC UA)是促进可编程逻辑控制器(PLCs)、人机接口(HMIs)、服务器、客户端和其他机器之间的数据交换的标准，以实现互联互通和信息流。
当然，这种互连性和通信性对于制造工厂来说是必不可少的，因为有许多不同类型的设备，设备和机械正在测量过程参数，生成数据或记录数据。
当前，制造业的互联互通和沟通日益受到重视。机器，服务器，客户端和设备并非独立运行。另外，当一个人拥有不同的设备，软件，PLC，HMI和机器时，它们各自以自己的格式生成数据时，则需要对这些数据进行解释。简单来说，OPC是一种翻译器，可以理解来自不同来源的数据，并以每个来源所需和理解的格式来回发送数据。
从历史上看，经典的OPC由三个主要的独立协议组成，分别是OPC历史数据访问（OPC HDA），OPC数据访问（OPC DA），OPC警报和事件 （OPC A＆E）以及其他协议，这些协议被许多人采用在制造业中的互连性需求。但是，经典的OPC依赖于平台，并且依赖于基于Windows的技术。OPC UA是经典OPC的主要后继产品，其主要优点之一是它与平台无关，因此可以轻松地与Windows，Linux，Mac，Android和其他平台结合使用，这对于其中机器和系统的制造业非常重要。通常在不同的平台上运行。它还将所有单独的协议组合为一个规范，因此简化了。OPC UA的其他主要优势在于，它可以轻松部署，数据交换是安全的，可以容纳旧系统以及现有基础架构并具有可扩展性。适应遗留系统的能力可满足那些不一定有预算购买新设备和IT基础架构的工厂的需求，这在制造方面是另一个主要优势。因此，OPC UA已在过程控制，石油和天然气，食品和饮料，废物管理和制药行业中被应用。
OPC UA在制造业中的作用 制造业具有许多复杂的操作和通信要求。机器，传感器，服务器，客户端，应用程序和不同的设备产生大量的输出和数据点。经常需要在机器和设备之间交换数据，并最终进行分析以提高生产率，减少浪费，增加利润并确定新的价值链和商业模式。另外，在许多情况下，经常需要考虑地理环境。例如，考虑一个场景：其中食品和饮料公司在不同的工厂生产肉，奶酪和其他乳制品。每个工厂都有自己的系统，设备和产品线。该公司已决定，在保持符合安全标准的同时，他们需要专注于减少废物和提高生产率。为了实现这些目标，各个工厂必须向远程服务器发送大量数据，并且这些服务器将需要能够从其接收的多个源中了解不同的数据。此外，该公司还开发了一种运行在Linux上的报告应用程序，可以根据工厂数据生成趋势。开发了另一个应用程序，该应用程序可在Windows上运行并分析报告应用程序确定的趋势。然后，该应用程序根据趋势为机械建议新的设置，以实现公司减少废物和提高生产率的目标。当然，这种情况下的主要挑战将是数据交换，解释和交付。OPC UA解决方案将是解决这一难题的理想解决方案。该公司可以设置OPC UA服务器，这些服务器将能够从不同位置的所有不同机器和设备接收数据，并将数据转换为报告应用程序可以使用的格式。此外，服务器还能够在Linux上运行的报告应用程序和Windows上运行的应用程序之间进行通信。最后，OPC UA服务器可以按照所需的特定格式将机器的最终，调整后的建议设置发送回工厂和工厂中的机器。这样，该公司将能够以经济高效的方式实现其目标。如以上场景所示，OPC UA在制造业中的主要作用实际上是促进通信和打破工业通信中的传统壁垒。
OPC UA将继续在制造业中使用的主要原因 OPC UA将继续在制造业中被采用和利用的主要原因是：
它实现了智能制造它有助于降低设备与机械之间的通信复杂性，从而提高工厂的整体效率它可以轻松容纳旧系统，新机器和产品线它是跨平台的它不是专有格式它可以接收和解释来自不同来源的多个数据点
显然，OPC UA将会保留下来，并且该标准会定期更新以包括其他技术和新标准，例如移动技术和 JSON。制造业是一个竞争激烈的领域，在这个领域中运营的公司必须始终如一地生产高质量的产品，以保持竞争优势。因此，为了保持领先地位，该领域的许多公司正在投资各种新颖的创新技术。OPC UA解决了制造业所面临的许多关键挑战，最终实施OPC UA标准可减少浪费，提高利润并减少运营支出。因此，它处于良好的位置并能够满足日新月异的制造业的需求。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87ddbd5e26c8dc067d925e232c8e6f53/" rel="bookmark">
			完美解决安装Eclipse2020-3报错问题及正确安装，冲冲冲！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下面这个图是直接Down的zip 真的不管乎，，，别用VPN了，来康康下面的操作吧！
我已经提前下载了JDK等只需要搞这个Eclipse，望周知。
实在下不下来也可以直接提取下边这个链接，我的版本是 eclipse-jee-2020-03-R-incubation-win32-x86_64
链接：https://pan.baidu.com/s/1PMUFgyt-zH1DeQOryIL74A
提取码：k01j 什么用Vpn（得现下载），真的不很好用，最简单的就是下面的操作！！！细品好吗？ 好呀 通往AC的时光机，点这个直接下载吧小哥哥们 https://www.eclipse.org/downloads/packages/ 解压下载的东东！！OK 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79d4f44dd706c9302d982e3c266368ab/" rel="bookmark">
			OpenCV自学记录（5）——凸包检测和凸缺陷
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV自学记录（5）——凸包检测和凸缺陷 1、凸包检测与凸缺陷定义2、opencv相关实现函数3、代码实践4、总结 1、凸包检测与凸缺陷定义 凸包是将最外层的点连接起来构成的凸多边形，它能包含点击中所有的点。物体的凸包检测常应用在物体识别、手势识别及边界检测等领域。
凸包检测常常用在轮廓分析之后。对二值图像进行轮廓分析之后，可以构建每个轮廓的凸包，构建完成之后会返回该凸包包含的点集。根据返回的凸包点集可以绘制该轮廓对应的凸包。一般来说，凸性曲线总是凸出来的，至少是平的。如果有地方凹进去了就被叫做凸性缺陷。下图可以更加直接的了解凸包和凸缺陷的定义：
2、opencv相关实现函数 OpenCV中提供了函数convexHull 用于对物体轮廓凸包进行检测，函数convexityDefect进行凸缺陷的检测。首先来了解一下各参数意义：
hull = cv2.convexHull(points, clockwise, returnpoints) 各参数意义：
points：输入的轮廓点集
clockwise：方向标志，如果设置为True，输出的凸包是顺时针方向的，否则为逆时针方向。
returnPoints：是否返回点集
hull : 输出凸包结果，当参数returnPoints为ture的时候返回凸包的顶点坐标是个点集、returnPoints为false的是返回与凸包点对应的轮廓上的点对应的index
下面这个函数可以帮助我们找到凸缺陷：
convexityDefects = cv2.convexityDefect(contour， convexhull) 注意：进行凸检测时，凸包检测中的returnPoints要设置为False
凸缺陷返回一个数组，每一行包含值是起点，终点，最远的点，到最远点的近似距离，返回的前三个点都是轮廓索引。
contour： 检测到的轮廓，可以调用findContours函数得到
convexhull：检测到的凸包，可以调用convexHull函数得到。
convexityDefects：输出参数，检测到的最终结果，返回一个数组，其中每一行包含的值是[起点，终点，最远的点，到最远点的近似距离]。前三个点都是轮廓索引。
前三个值得含义分别为：凸缺陷的起始点，凸缺陷的终点，凸缺陷的最深点（即边缘点到凸包距离最大点）
3、代码实践 我们可以在一张图上显示轮廓的凸包和凸缺陷。
我们将起点和终点用一条红线 连接，在最远点画一个蓝色的圆圈，要记住的是返回结果的前三个值是轮廓点的索引。 所以我们还要到轮廓点中去找它们。前三个值得含义分别为：凸缺陷的起始点，凸缺陷的终点，凸缺陷的最深点（即边缘点到凸包距离最大点）。
凸包检测和凸缺陷检测的代码如下：
# 凸包检测和凸缺陷 import cv2 as cv # 读取图像 src1 = cv.imread("000.jpg") # 转换为灰度图像 gray = cv.cvtColor(src1, cv.COLOR_BGR2GRAY) # 二值化 ret, binary = cv.threshold(gray, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU) # 获取结构元素 k = cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79d4f44dd706c9302d982e3c266368ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/282993f87d398d48d10cd810cbfac191/" rel="bookmark">
			计算机网络【五】广播通信&#43;以太网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局域网的拓扑 广域网使用点到点通信
局域网使用广播通信
可以随意向网络中添加设备。
总线网星形网，使用集线器。现在多使用星形网络。环状网树形网
其中匹配电阻用来吸收总线上传播的信号。 共享通信媒体 静态划分信道 频分复用、时分复用、波分复用、码分复用
可以让计算机充分使用介质来使用信号。可是这种方法太过麻烦。
动态媒体接入技术（多点接入） 随机接入(以太网使用)受控接入 CSMA/CD协议 广播通信：所有的计算机都能收到其他计算机发送的信息（就算不是发给自己的也可以收到，但是不接受）
载波监听多点接入/碰撞检测协议：CSMA/CD协议
多点接入：许多计算机以多点接入的方式链接在一根总线上
载波监听：每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据。如果有则暂时不要发送数据，以免发生碰撞。
碰撞检测 当几个站同时在总线上发送数据时，总线上的信号电压摆动值会增大（互相叠加）当一个站检测到信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞（冲突）。发生碰撞时，总线上传输的信号产生了严重的失真，无法从中会付出有用的信息。每一个发送数据的站一旦发现总线上出现了碰撞就要立即停止发送免得继续浪费网络资源，然后等待一段随机事件再次发送。 传播时延对载波监听的影响 发送信号的计算机检测到冲突（碰撞）最多是两倍的传播时延
CSMA/CD协议的特征 只能半双工通信（集线器这样的设备要求网卡必须是半双工通信）每个站在发送数据之后的一小段时间内（两倍传送时间）以内，均存在遭遇碰撞的可能性这种不确定性导致以太网的平均通信量原小于以太网的最高数据率。 争用期 争用期就是两倍的端到端传输时延 τ \tau τ。如果在争用期期间没有检测到碰撞就不会发生碰撞。
以太网的争用期取51.2微妙为争用期对于10Mb/s以太网，争用期内可以发送512bit(64字节)。因此10Mb/s的以太网在发送数据时如果前64字节没有发生冲突则后续的数据就不会发生冲突10Mb/s以太网规定了最短有效帧长为64字节，凡长度小于64字节的帧都是由于冲突而异常终止的无效帧 。同理，100Mb/s以太网最短有效帧长为640字节。最短有效帧长与传输时延和带宽有关。因此以太网规定局域网网线长度不能超过100m 二进制指数类型退避算法 确定基本退避时间，一般是争用期 2 τ 2\tau 2τ确定参数k: k = m i n [ 重 传 次 数 , 10 ] k=min[重传次数,10] k=min[重传次数,10]从整数集合[0,1,… 2 k − 1 2^k-1 2k−1]中随机取出一个数，记为r。重传所需要的时延就是r倍的基本规避时间，即 2 r τ 2r\tau 2rτ。当重传16次仍不能成功时即丢弃该帧，并向高层报告。 以太网 只要满足CSMA/CD(载波监听多点接入/碰撞检测)协议的局域网都叫做以太网
后来将数据链路层分为两个子层。逻辑链路控制LLC子层（已经被取消了），媒体介入控制MAC子层（网卡中含有）
以太网提供的服务是不可靠的交付，即尽最大努力的交付。
当接收站收到有差错的数据帧时就丢弃该帧，其他什么也不做。差错的纠正由高层来（传输层）决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这时一个重传的帧。
集线器 集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已经大大提升了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/282993f87d398d48d10cd810cbfac191/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0607430ce00dcd56af48d6657031c87f/" rel="bookmark">
			js键盘事件在vue-cli上的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、在mounted建立监听事件，主要是在进入页面就要监听，监听单页面是要使用局内监听，全局监听会影响到一些页面的滑动，比如我的后台是使用element-admin，全局监听时影响到了左侧栏的上下滑动，效果不理想
window.addEventListener('keydown', this.keyUpDownEvent)
2、在destroyed建立销毁事件，主要是离开页面就销毁监听
window.removeEventListener('keydown', this.keyUpDownEvent)
3、键盘监听方法keyUpDownEvent方法
keyUpDownEvent(event) { const vm = this if (event.keyCode === 38) { event.preventDefault() } else if (event.keyCode === 40) { event.preventDefault() } } keyCode表示的是键码，我整理了一下键码有如下：
keycode 8 = BackSpace BackSpace keycode 9 = Tab Tab keycode 12 = Clear keycode 13 = Enter keycode 16 = Shift_L keycode 17 = Control_L keycode 18 = Alt_L keycode 19 = Pause keycode 20 = Caps_Lock keycode 27 = Escape Escape keycode 32 = space space keycode 33 = Prior keycode 34 = Next keycode 35 = End keycode 36 = Home keycode 37 = Left keycode 38 = Up keycode 39 = Right keycode 40 = Down keycode 41 = Select keycode 42 = Print keycode 43 = Execute keycode 45 = Insert keycode 46 = Delete keycode 47 = Help keycode 48 = 0 equal braceright keycode 49 = 1 exclam onesuperior keycode 50 = 2 quotedbl twosuperior keycode 51 = 3 section threesuperior keycode 52 = 4 dollar keycode 53 = 5 percent keycode 54 = 6 ampersand keycode 55 = 7 slash braceleft keycode 56 = 8 parenleft bracketleft keycode 57 = 9 parenright bracketright keycode 65 = a A keycode 66 = b B keycode 67 = c C keycode 68 = d D keycode 69 = e E EuroSign keycode 70 = f F keycode 71 = g G keycode 72 = h H keycode 73 = i I keycode 74 = j J keycode 75 = k K keycode 76 = l L keycode 77 = m M mu keycode 78 = n N keycode 79 = o O keycode 80 = p P keycode 81 = q Q at keycode 82 = r R keycode 83 = s S keycode 84 = t T keycode 85 = u U keycode 86 = v V keycode 87 = w W keycode 88 = x X keycode 89 = y Y keycode 90 = z Z keycode 96 = KP_0 KP_0 keycode 97 = KP_1 KP_1 keycode 98 = KP_2 KP_2 keycode 99 = KP_3 KP_3 keycode 100 = KP_4 KP_4 keycode 101 = KP_5 KP_5 keycode 102 = KP_6 KP_6 keycode 103 = KP_7 KP_7 keycode 104 = KP_8 KP_8 keycode 105 = KP_9 KP_9 keycode 106 = KP_Multiply KP_Multiply keycode 107 = KP_Add KP_Add keycode 108 = KP_Separator KP_Separator keycode 109 = KP_Subtract KP_Subtract keycode 110 = KP_Decimal KP_Decimal keycode 111 = KP_Divide KP_Divide keycode 112 = F1 keycode 113 = F2 keycode 114 = F3 keycode 115 = F4 keycode 116 = F5 keycode 117 = F6 keycode 118 = F7 keycode 119 = F8 keycode 120 = F9 keycode 121 = F10 keycode 122 = F11 keycode 123 = F12 keycode 124 = F13 keycode 125 = F14 keycode 126 = F15 keycode 127 = F16 keycode 128 = F17 keycode 129 = F18 keycode 130 = F19 keycode 131 = F20 keycode 132 = F21 keycode 133 = F22 keycode 134 = F23 keycode 135 = F24 keycode 136 = Num_Lock keycode 137 = Scroll_Lock keycode 187 = acute grave keycode 188 = comma semicolon keycode 189 = minus underscore keycode 190 = period colon keycode 192 = numbersign apostrophe keycode 210 = plusminus hyphen macron keycode 211 = keycode 212 = copyright registered keycode 213 = guillemotleft guillemotright keycode 214 = masculine ordfeminine keycode 215 = ae AE keycode 216 = cent yen keycode 217 = questiondown exclamdown keycode 218 = onequarter onehalf threequarters keycode 220 = less greater bar keycode 221 = plus asterisk asciitilde keycode 227 = multiply division keycode 228 = acircumflex Acircumflex keycode 229 = ecircumflex Ecircumflex keycode 230 = icircumflex Icircumflex keycode 231 = ocircumflex Ocircumflex keycode 232 = ucircumflex Ucircumflex keycode 233 = ntilde Ntilde keycode 234 = yacute Yacute keycode 235 = oslash Ooblique keycode 236 = aring Aring keycode 237 = ccedilla Ccedilla keycode 238 = thorn THORN keycode 239 = eth ETH keycode 240 = diaeresis cedilla currency keycode 241 = agrave Agrave atilde Atilde keycode 242 = egrave Egrave keycode 243 = igrave Igrave keycode 244 = ograve Ograve otilde Otilde keycode 245 = ugrave Ugrave keycode 246 = adiaeresis Adiaeresis keycode 247 = ediaeresis Ediaeresis keycode 248 = idiaeresis Idiaeresis keycode 249 = odiaeresis Odiaeresis keycode 250 = udiaeresis Udiaeresis keycode 251 = ssharp question backslash keycode 252 = asciicircum degree keycode 253 = 3 sterling keycode 254 = Mode_switch 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a069e9496441a1e194cdc6e5974b009/" rel="bookmark">
			spark sql on hive报错FAILED: Execution Error, return code 3 from org.apache.hadoop.hive.ql.exec.spark.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spark sql on hive报如下的错误
ob failed with org.apache.spark.SparkException: File ./hiveforudf-0.0.5-SNAPSHOT-jar-with-dependencies.jar exists and does not match contents of .../hiveforudf-0.0.5-SNAPSHOT-jar-with-dependencies.jar FAILED: Execution Error, return code 3 from org.apache.hadoop.hive.ql.exec.spark.SparkTask. Spark job failed during runtime. Please check stacktrace for the root cause.
发现where 条件一多，就报上面的错误，应该是内存不够导致的，故增加了内存的大小,然后就不报错了。
set spark.executor.memory=6g;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79df230f4a971bf96b61e9300c0cdd0a/" rel="bookmark">
			linux  rsyslog 系统日志转发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、rsyslog 介绍 ryslog 是一个快速处理收集系统日志的程序，提供了高性能、安全功能和模块化设计。rsyslog 是syslog 的升级版，它将多种来源输入输出转换结果到目的地，据官网介绍，现在可以处理100万条信息。
特性：1.多线程
2.支持加密协议：ssl，tls，relp
3.mysql、oracle、postgreSQL
4.等等..
二、实践部署 2.1 环境图
2.2.rsyslog server上部署操作
安装rsyslog 程序（rsyslog默认已经在各发行版安装，如果系统中没有的话，可以用yum 进行安装，如下：）
[root@opm ~]# yum install rsyslog -y 编辑rsyslog配置文件，路径 /etc/rsyslog.conf,修改前最好先备份一份，修改后的文件内容如下
[root@opm log]# grep -v "^#" /etc/rsyslog.conf | grep -v "^$" $ModLoad imuxsock # provides support for local system logging (e.g. via logger command) $ModLoad imjournal # provides access to the systemd journal $ModLoad immark # provides --MARK-- message capability $ModLoad imudp $UDPServerRun 514 $ModLoad imtcp $InputTCPServerRun 514 $WorkDirectory /var/lib/rsyslog $AllowedSender tcp, 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79df230f4a971bf96b61e9300c0cdd0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbcc76e2246ddb4750208ba643172a4d/" rel="bookmark">
			Word 中空格有大有小，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近改论文调格式，遇见这种Word中空格大小不一致，区别很大的情况，感觉不够美观，改成空格间距一致方法如下：
选中空格异常的段落，右键
段落 -&gt; 中文版式 -&gt; 勾选允许西文在单词中间换行 -&gt; 取消勾选自动调整中文和西文的间距和自动调整中文和数字的间距。
需要注意的一个问题是这样可能会导致在英文单词中间换行，导致意思发生改变，如单词被分开请在第二行开头添加“ - ”表示单词连接。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40e820454861c6203bf525d1ba7322a1/" rel="bookmark">
			ubuntu 18.04 编译octomap
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		源码位置 https://github.com/OctoMap/octomap/blob/devel/octovis/README.md
commit 74c48ae on Apr 26, 2020.
本机系统Ubuntu 18.04，qt5，cmake 3.14.6。
编译 libQGLViewer for octovis 直接cmake configure octomap会报出无法编译libQGLViewer的错误，忽略该错误会导致octovis不能编译，尝试手工编译libQGLViewer。具体报错信息如下
-- QGLViewer includes found in /home/yaoyu/Libraries/octomap/octovis/src/extern/QGLViewer -- QGLViewer library not found. -- Trying to build libQGLViewer from source in /home/yaoyu/Libraries/octomap/octovis/src/extern/QGLViewer -- generating Makefile using qmake -- building library (this may take some time...) make: *** No targets specified and no makefile found. Stop. CMake Warning at octovis/CMakeModules/FindQGLViewer.cmake:111 (MESSAGE): Could not find libQGLViewer.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40e820454861c6203bf525d1ba7322a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/edf803626765b6ef0779da31a568444c/" rel="bookmark">
			树莓派4B安装散热片和小风扇以及亚克力外壳安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、安装散热片：
二、安装亚克力外壳以及风扇
可能要注意的问题：小风扇正负极线接树莓派针脚的卡槽可能无法插入，建议用小刀削掉一些材料如图：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61596875cd6c94603ad6f69e82f75093/" rel="bookmark">
			在vs中通过函数检测是否内存泄漏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 判断方法 在程序vs编写代码，在想要追踪的方法结尾，使用_CrtDumpMemoryLeaks()函数可以检测是否内存泄漏。推荐在main函数结尾使用，追踪范围更大。
#include &lt;iostream&gt; int main() { char* c1 = (char*)malloc(15); delete c1; char* c = (char*)malloc(15); char* c3 = (char*)malloc(15); _CrtDumpMemoryLeaks(); } 通过f5调试执行完成后，在输出窗口，注意是输出窗口，不是控制台窗口,看到如下提示就表示有内存泄漏了。
Detected memory leaks! Dumping objects -&gt; {153} normal block at 0x00F04D68, 15 bytes long. Data: &lt; &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD {152} normal block at 0x00F092F0, 15 bytes long. Data: &lt; &gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD Object dump complete.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61596875cd6c94603ad6f69e82f75093/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6936ee7fa44f57aa90f2d27a4f2f2084/" rel="bookmark">
			初识Wayland（X、Mir）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【声明】下图copy自wikipedia，如有侵权请告知。
在介绍Wayland之前，先熟悉一下X与Mir，简单来说，同样作为显示服务，X是一个老派的庞然大物，Wayland是一颗节节高的芝麻，Mir是一个颇受争议的新秀，其它的显示服务还包括Android的SurfaceFlinger，MacOS家族的Quartz Compositor等。
1、Mir
【参考ubuntu-wiki】https://wiki.ubuntu.com/Mir
【参考wikipedia】https://en.wikipedia.org/wiki/Mir_(software)
Mir是一种计算机显示服务，用于Linux操作系统，由Canonical开发，2013年3月4日公开，计划替代Ubuntu上的X窗口系统，开发Unity 8，不过随着Ubuntu 18.04 LTS的发行，Canonical宣称Unity 8将不再支持GNOME，Mir与其竞争者Wayland各行其道，主要投资于IoT项目，其它应用还包括SDL、GTK+、Qt5等，另外，Mir争议颇多，如其License为GPLv3。在架构方面，Mir像Wayland一样，基于EGL，并且使用了一些始于Wayland的基础套件，如Mesa的EGL实现、Jolla的libhybris，以及兼容于X的基于XWayland的XMir，此外，Mir还有一些基础套件延用自Android，如input框架、Protocol Buffer等等。下图是Mir的基本组成及架构。
2、X
【参考x.org-wiki】https://www.x.org/wiki/
【参考wikipedia】https://en.wikipedia.org/wiki/X_Window_System
X即X11、X Window System，是用于在类UNIX的操作系统上的位图显示的窗口系统，提供了GUI环境的基本框架，可以在显示设备上绘制、移动窗口，通过鼠标、键盘、触摸屏与用户交互。X由X.Org Foundation维护，遵守MIT协议，当前参考实现为X.Org Server。在架构方面，X使用了C/S模型，客户端和服务器可以在同一个机器上，也可以在不同的机器上，X作为Server为应用程序这个Client提供显示和I/O服务，基本结构如下图所示。
上面提到的X.Org Server是X显示服务的一种开源实现，对应的客户端实现为Xlib或XCB，XCB旨在取代Xlib。
3、Wayland
【参考wayland】https://wayland.freedesktop.org/
【参考wikipedia】https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)
Wayland是一个显示服务协议，服务端为Wayland Compositor，把X的X Server和Compositor合二为一，旨在替换X，作为类Unix操作系统上更现代、简介的窗口系统，遵守MIT协议，提供了Wayland Compositor的参考C语言实现Weston。下面是Wayland官网文档给出的架构简图，与上面的X架构简图对比，少了两个传输步骤。
近些年，Linux桌面图形渲染接口移植到了Linux内核组件，如DRI、DRM，目的是提供一个更加灵活、高性能的图形系统。Wayland由一个协议和参考实现Weston组成，GTK+和Qt使用了Wayland取代X，其它的许多应用程序也期望得到Wayland的支持。Wayland目前还不像X一样是网络透明的，将来将会支持这个特性，实现手段可能是像VNC一样的pixel-scraping，或者像RDP、SPICE、X一样发送一个rendering command stream，或者使用Wayland Server代理来发送压缩的图片给真正的Compositor。Wayland发起人解释了为什么不扩展X而是创建Wayland，X已非常臃肿，许多模块已都移植到了Linux内核，剩下的还有许多功能也都不常用。下面是使用了Wayland的一个图形系统简图。
Wayland协议为Client-Server模式，客户端为图形应用程序，请求屏幕上像素缓冲区的显示，服务器为Compositor，控制这些缓冲区的显示。Wayland参考实现Weston包括两层协议，一个为low-level或wire协议，基于消息，主要就是IPC，如Linux Domain Socket，这层协议为手动写的C语言实现；另一个是high-level协议，处理客户端和Compositor需要交换的消息，以实现窗口系统的基本功能，这层协议是基于对象的异步协议，包括全局对象和非全局对象，从规定格式的XML文件中自动生成，可以灵活地动态扩展或者用于错误验证。Wayland参考实现包括两部分，libwayland-client和libwayland-server，其架构简图如下所示。
Wayland协议在其源码protocol/wayland.xml中定义，下面列出了一部分。
除了Wayland的核心协议外，还有一些扩展协议，如管理Compositor中Surface的XDG-shell协议，车载娱乐系统IVI-shell协议。
Wayland协议不包括渲染API，而是使用DRM，这需要客户端在同Compositor共享的缓冲区中渲染窗口，在这种情况下，客户端有更多选择，如图形渲染库Cario和OpenGL，或者是支持Wayland的高级图形库GTK+和Qt，以及Freetype字体渲染引擎等等。渲染缓冲区结果存放在wl_buffer对象中，这个对象与具体的实现相关，但必须是客户端和Compositor共享的。如果客户端使用软描画（CPU），结果存储在系统内存中，客户端和Compositor可以使用共享内存传递缓冲区数据而不需要额外的拷贝工作，接口为wl_shm、wl_shm_pool，这种方法的缺陷是拷贝数据到GPU以进行显示，造成图形描画性能下降。所以，最常见的做法是使用硬件（GPU）加速API直接渲染到video memory，这些API如OpenGL、OpenGL ES、Vulkan，客户端和Compositor可以使用特殊的句柄共享这块GPU缓冲区，这样就避免了拷贝数据到GPU的耗时工作，而且Compositor还可以使用同一个API对屏幕上将显示的最终场景进行合成优化。渲染完成并且缓冲区共享之后，Wayland客户端通知Compositor显示缓冲区的渲染结果，这需要客户端绑定缓冲区，缓冲区存放了Surface对象的渲染结果，然后发送commit请求给这个Surface，把对相应缓冲区的有效操作传递给Compositor。下面是包括了渲染API的结构图。
Weston是Wayland显示服务的参考实现，只支持Linux，因为依赖于Linux内核的一些模块，如KMS、GBM、udev等，input处理依赖于evdev，buffer处理依赖于GBM，从上图中可以看出，还有一些其他实现，如Clayland等。
下面是Wayland与libinput的结构图。
现在，许多软、硬件都支持Wayland，Wayland的流程程度越来越广。
最后，Wayland与X的区别可参照https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)。
————————————————
版权声明：本文为CSDN博主「evoo」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/iEearth/article/details/72790086
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6af60be5c048d109dc8f6b8afc6d93a8/" rel="bookmark">
			WebSSH神器sshwifty的安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章最初发表在XJHui’s Blog，未经允许，任何人禁止转载！
为使您获得最好的阅读体验，强烈建议您点击 这里 前往 XJHui’s Blog 查看！
WebSSH工具 初衷 9.9买的一年服务器，不用实属可惜由于是计算机专业实验课经常需要用到linux系统，苦于每次上实验都要被虚拟机各种问题困扰浪费时间博客已经搭建好了，完全可以把弄好的WebSSH嵌进去（别想太复杂，其实就是给个入口） SSH和WebSSH工具 因为在搭建博客的时候经常用到SSH，自己对它的理解就是它能实现“远程登陆”，刚看了百度其实这种想法不对。
SSH(Secure Shell是专为远程登录会话和其他网络服务提供安全性的协议。
我在用的SSH工具是Xshell（免费版本对我来说足以），通过Xshell输入用户名和密码就能远程登陆服务器。
通过上面的介绍，应该对WebSSH工具有了一点点的猜想。
WebSSH工具说白了就是把Xshell放到网页上，用户不需要安装，有个联网的浏览器就能控制服务器。
慎重考虑 本博客教程使用的WebSSH工具，虽是GitHub开源项目，但安全性较客户端（Xshell一类的）肯定是不够的，使用者请自行注意保护个人隐私安全。搭建该WebSSH工具需要云服务器。需要linux命令基础（会vim足够）。文章随长但也是为了让小白也能掌握，有些不得不啰嗦几句。 本博客的任务清单已在最后列出，清单未完成前会持续更新…
WebSSH神器Sshwifty 项目简介：Web SSH &amp; Telnet (WebSSH &amp; WebTelnet client)
作者DEMO：https://sshwifty.herokuapp.com（可以点进去体验一下，注意保护个人隐私）
个人Sshwifty：https://webssh.xingjiahui.top (安全起见暂时不开放)
点击访问项目地址，感谢作者！
有能力可以直接去看官方文档（小白还是建议老老实实看我教程，能少走些坑）。
安装步骤 下载sshwifty
$ wget https://github.com/niruix/sshwifty/releases/download/0.2.2-beta-release-prebuild/sshwifty_0.2.2-beta-release_linux_amd64.tar.gz 注：如果下载速度慢，可以尝试本地下载后使用Xftp上传到服务器（速度飞快）
由于服务器都在国外（我其实也不清楚，速度慢就是在国外），所以这里提供两个不限速下载链接：
sshwifty_0.2.2-beta-release_linux_amd64.tar.gzXftp 感谢蓝奏云！
Xftp使用方式很简单：先登录服务器，后拖拽上传（下图）：
解压sshwifty
$ tar -xzvf sshwifty_0.2.2-beta-release_linux_amd64.tar.gz 复制可执行文件到指定目录并赋予执行权限
$ cp sshwifty_linux_amd64 /usr/local/bin/sshwifty $ chmod +x /usr/local/bin/sshwifty 生成默认配置文件：
$ cp sshwifty.conf.example.json /etc/sshwifty.conf.json 感谢：iMike
本地运行 启动 sshwifty，命令行输入：
$ sshwifty 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6af60be5c048d109dc8f6b8afc6d93a8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/385/">«</a>
	<span class="pagination__item pagination__item--current">386/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/387/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>