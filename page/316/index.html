<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc1418664355ecd3e82dc57c4dab2a0c/" rel="bookmark">
			基于PHP的大学生问卷调查系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 项目介绍 基于PHP的大学生问卷调查系统
数据库mysql ，可搭建在phpstudy下，实现快速部署！
二 主要功能 用户
1 登录
2 填写问卷
管理员
1 登录
2 问卷/问题(增删改查)
3 问卷统计结果(按选择结果百分比显示)
4 问卷回收情况(参与用户和未参与用户)
5 可批量导入用户
三 系统界面 四 系统源码及部署 1 数据库文件 db_survey.sql
2 数据库配置文件 conn/config.php
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bcc99142b6bbcc0b97b78e7b42f6427/" rel="bookmark">
			SPI、UART、RS232、RS485、IIC五种嵌入式总线讲解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		请去看B站视频
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0da85b751fdb5bd4c734f41b736a287b/" rel="bookmark">
			django显示404页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 在app目录下创建templates文件夹，将404html文件放在该文件夹下
二 修改settings.py
DEBUG = False ALLOWED_HOSTS = ['*'] 接下来访问不存在的url就会显示404页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce1466556e2b0a1c32bf3f21f5c5eacb/" rel="bookmark">
			Qt项目ui文件中新添加的控件在代码中不识别的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在学Qt框架的信号槽，然后发现在ui中加的控件，通过ui-&gt; 找不到，没有识别，于是上网查找了一下问题
解决方法
添加ui控件后，执行程序，退出程序，将debug目录下的ui_XXXX.h拷贝到程序目录下，重新打开就可以使用新添加的控件。
如果不行不行就清理一遍重新构建。
再不行就按住ctrl，鼠标点击存在的控件名进入ui头文件，然后退出一遍。
我采用重新构建的方法，解决的了问题 就是下面这个小锤子，编译器为Qt Creator
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f54ec2a30c5ed38fcf08f414c77a39f/" rel="bookmark">
			解决多线程间共享变量线程安全问题的大杀器——ThreadLocal
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一期，讲到了关于线程死锁、用户进程、用户线程的相关知识，不记得的小伙伴可以看看：字节跳动面试官问我：你知道线程死锁吗？用户线程、守护线程的概念与区别了解吗？
这期，我们来聊一聊一个在Java并发编程中很重要的类：ThreadLocal 在多线程应用程序中，对共享变量进行读写的场景是很常见的。如果不使用一定的技术或方案，会引发各种线程安全的问题。常见解决线程安全的方式有synchronized、volatile等方式，但synchronized对性能的开销大，volatile不能保证原子性，所以这里介绍一个 解决多线程间共享变量的线程安全问题 的方法——ThreadLocal
一、ThreadLocal的作用 多线程访问同一个共享变量时特别容易出现并发问题，特别是在多个线程需要对共享变量进行写入时。为了保证线程安全，一般使用者在访问共享变量时需要进行适当的同步，如图 1-3 所示
同步的措施一般是加锁，但加锁会在一定程度上增加系统的复杂度以及影响系统的性能。
为了解决多线程间共享变量的线程安全，ThreadLocal应运而生。
当创建一个ThreadLocal变量时，访问这个变量的每个线程都有这个变量的一个本地副本，当多个线程操作这个变量时，实际上就是操作自己本地内存里面的变量，从而避免了线程安全问题。图 1-3 就变成了 图1-4 如图：
二、Threadlocal的使用示例 讲完了理论的东西，我们来通过下面的例子体会下ThreadLocal的神奇之处吧
public class ThreadLocalTest { private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) { Thread thread1 = new Thread(() -&gt; { threadLocal.set("本地变量1"); print("thread1"); System.out.println("线程1的本地变量的值为:"+threadLocal.get()); }); Thread thread2 = new Thread(() -&gt; { threadLocal.set("本地变量2"); print("thread2"); System.out.println("线程2的本地变量的值为:"+threadLocal.get()); }); thread1.start(); thread2.start(); } public static void print(String s){ System.out.println(s+":"+threadLocal.get()); } } 执行结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f54ec2a30c5ed38fcf08f414c77a39f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e90f786bd48e7bc31222c142a21dfe42/" rel="bookmark">
			Qt Creater快速定义函数的快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.简介 在Qt creator中编写函数的时候，在头文件编写了函数，需要在相应的cpp文件中编写对应的函数定义实现，如果每次都需要手动的敲击全部的代码，这会非常的耗时耗力，显得很方便，这时候就需要巧妙的利用好Qt creator这款IDE的快捷功能了
2.小技巧 现在我在mainwindow.h 中定义一个dataPlus函数，如图
然后鼠标移动到函数的末尾，按下Alt+Enter，就会出现如下画面 点击在mainwindow.cpp下添加定义 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d75fd65f9d7b43e407b56b2b9bc96c42/" rel="bookmark">
			双检锁方式实现的线程安全的单例模式中，第二个if有必要吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		双检锁方式实现的线程安全的单例模式代码：
class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null) instance = new Singleton(); } } return instance; } } 分析一下上述代码：
最里面的if体现了懒汉这两个字：需要时再创建synchronized 的作用是防止并发时instance 多次实例化最外层的if是防止synchronized拖慢执行效率 问题来了
两个if同时写，第二个if还有必要吗？ 当然有！
两个if都是必须的。如果刚开始有两个线程同时调这个方法，这个两个线程同时进入第一个if，但是只有一个进入到了synchronized里面，然后初始化instance，再退出来。然后第二个线程再进入synchronized里面，此时instance已经初始化了，如果没有第二个if，instance就会再次初始化，导致创建多个实例。
简单来说就是第一个if判断过instance==null之后，instance可能还会变化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14bb08dc443bcb32a80537136ea3f37d/" rel="bookmark">
			Vue相关
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、屏幕适配
1）安装 lib-flexible ：
npm install lib-flexible --save-dev 在main.js中引入lib-flexible import 'lib-flexible' 2） 安装 px2rem-loader
npm install px2rem-loader --save-dev vue.config.js配置，重新运行
module.exports = { css: { loaderOptions: { css: {}, postcss: { plugins: [ require('postcss-px2rem')({ // 以设计稿750为例， 750 / 10 = 75 //remUnit: 75 remUnit: 37.5 //适配vant }), ] } } }, }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/380fefb04acf25dd55391d299f383064/" rel="bookmark">
			数据君的量化技术-番外篇 认识 datafeeds
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有感兴趣量化技术，特别是大数据、人工智能在量化中的应用的童鞋们可以关注我的公众号，脚本代码如果排版不清楚请看公众号：
馨视野（datahomex）：
在【第三篇认识backtrader】里，我们提到backtrader是一个量化交易框架，它提供了丰富的接口供开发者使用，支持量化交易的所有环节，包括数据加载、策略开发、策略回溯、实时交易。
数据是机器学习和量化交易的基础或者原料，所以数据处理是最基础也是必不可少的一个组件，今天我们就详细来讲解一下backtrader的datafeeds组件，总共分为4个部分：
backtrader 数据格式
data feed 生成方式
data feed 访问方式
lines 访问方式
init和next 函数
一、backtrader 数据格式
现在大家都在谈论大数据，因为大家越来越意识到数据的重要性，我们日常生活中无时无刻不在产生数据，如购买记录、和朋友通话、刷个朋友圈、日常驾驶出行等等，程序是对现实世界的抽象，现实产生的数据最终会以特定的形式和结构被存储到计算机世界里。
总之，数据结构是所有程序开发的基础，不同的系统平台对数据格式会有不同的要求，如大家常用的excel二维表的形式，pandas有dataframe、series，java有arraylist、hashmap，spark有rdd、dataset等等。
backtrader作为量化交易框架也有特定的数据格式，就是“data feed” 或 “data feeds"，每一个"data feed"大家可以想象成一张二维表格，类似excel表或dataframe。
backtrader通过datafeeds组件将外部数据加载到cerebro，并以data feed格式输送给我们开发的策略。
datafeeds支持的外部数据源很多，包括第三方api(yahoo、Quandl等）,csv文件，pandas的dataframe等，用的最多的就是csv和dataframe
二、data feed 生成方式
在【第三篇认识backtrader】，我们基于pandas dataframe的数据生成data feeds，代码如下：
cerebro = bt.Cerebro() //创建Cerebro实例 ​ # 从本地数据库获取数据，生成pandas dataframe from sqlalchemy import create_engine import pandas as pd import time engine = create_engine('mysql://root:123456@127.0.0.1/stock?charset=utf8mb4') conn = engine.connect() sql=("select * from huobi_daily") df = pd.read_sql(sql,engine) df['date'] = df['id'].apply(lambda x:time.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/380fefb04acf25dd55391d299f383064/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa34c54642a0885e1b9f39bd3d45043d/" rel="bookmark">
			2021-06-09 MARKDOWN编辑器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写自定义目录标题 欢迎使用Markdown编辑器新的改变功能快捷键合理的创建标题，有助于目录的生成如何改变文本的样式插入链接与图片如何插入一段漂亮的代码片生成一个适合你的列表创建一个表格设定内容居中、居左、居右SmartyPants 创建一个自定义列表如何创建一个注脚注释也是必不可少的KaTeX数学公式新的甘特图功能，丰富你的文章UML 图表FLowchart流程图导出与导入导出导入 欢迎使用Markdown编辑器 你好！ 这是你第一次使用 Markdown编辑器 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。
新的改变 我们对Markdown编辑器进行了一些功能拓展与语法支持，除了标准的Markdown编辑器功能，我们增加了如下几点新功能，帮助你用它写博客：
全新的界面设计 ，将会带来全新的写作体验；在创作中心设置你喜爱的代码高亮样式，Markdown 将代码片显示选择的高亮样式 进行展示；增加了 图片拖拽 功能，你可以将本地的图片直接拖拽到编辑区域直接展示；全新的 KaTeX数学公式 语法；增加了支持甘特图的mermaid语法1 功能；增加了 多屏幕编辑 Markdown文章功能；增加了 焦点写作模式、预览模式、简洁写作模式、左右区域同步滚轮设置 等功能，功能按钮位于编辑区域与预览区域中间；增加了 检查列表 功能。 功能快捷键 撤销：Ctrl/Command + Z
重做：Ctrl/Command + Y
加粗：Ctrl/Command + B
斜体：Ctrl/Command + I
标题：Ctrl/Command + Shift + H
无序列表：Ctrl/Command + Shift + U
有序列表：Ctrl/Command + Shift + O
检查列表：Ctrl/Command + Shift + C
插入代码：Ctrl/Command + Shift + K
插入链接：Ctrl/Command + Shift + L
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa34c54642a0885e1b9f39bd3d45043d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96009054337d3e074d4f266f9b456444/" rel="bookmark">
			Android 中的线程池
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android 中的线程池： 线程池的优点： 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。能够对线程进行简单管理，并提供定时执行以及指定间隔循环执行等功能。 ThreadPoolExecutor Android 中的线程池的概念来源于 Java 中的 Executor，Executor 是一个接口，真正的实现为 ThreadPoolExecutor。ThreadPoolExecutor 的构造方法中的参数直接影响线程池的功能特性。
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize 线程池的核心线程数。默认情况下，核心线程会在线程中一直存活，即使它们处于闲置状态。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于 corePoolSize;
如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行。
maximumPoolSize 线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于 maximumPoolSize。
keepAliveTime 非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设置为 True 时，keepAliveTime 同样会作用于核心线程。
unit 用于指定 keepAliveTime 参数的时间单位，这是一个枚举，常用的有 TimeUnit.MILLISECONDS(毫秒)、TimeUnit.SECONDS(秒)以及 TimeUnit.MINUTES(分钟)等。
workQueue 线程池中的任务队列，通过线程池的 executor 方法提交的 Runnable 对象会存储在这个参数中。当线程池中的线程数超过它的 corePoolSize 的时候，线程会进入任务队列等待。
什么是阻塞队列。 队列： 队列是一种特殊的线性表，它只允许表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样（先进先出），队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为对头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。
阻塞队列： 支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 ThreadPoolExecutor 执行任务时大致遵循如下规则： 如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。如果在步骤 2 中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程规定的最大值，那么会立刻启动一个非核心线程来执行任务。如果步骤 3 中线程数量已经达到线程池规定的最大值，那么就拒绝执行任务，并调用 RejectedExecutionHandler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96009054337d3e074d4f266f9b456444/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24e81fd9de17f0598b933c28e433dafa/" rel="bookmark">
			C#捕获windows关机事件，在系统关机前做一些自己想做的事
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方案1
/// &lt;summary&gt; /// 窗口过程的回调函数 /// &lt;/summary&gt; /// &lt;param name="m"&gt;&lt;/param&gt; protected override void WndProc(ref Message m) { switch (m.Msg) { //此消息在OnFormClosing之前 case WindowsMessage.WM_QUERYENDSESSION: //MessageBox.Show("WndProc.WM_QUERYENDSESSION.我要阻止系统关闭！"); //this.Close(); //this.Dispose(); //Application.Exit(); m.Result = (IntPtr)1; //阻止Windows注销、关机或重启 break; default: break; } base.WndProc(ref m); } 方案2
protected override void OnFormClosing(FormClosingEventArgs e) { switch (e.CloseReason) { case CloseReason.ApplicationExitCall: e.Cancel = true; MessageBox.Show("拦截关闭要求事件！"); break; case CloseReason.FormOwnerClosing: e.Cancel = true; MessageBox.Show("拦截自身关闭事件！"); break; case CloseReason.MdiFormClosing: e.Cancel = true; MessageBox.Show("拦截MDI窗体关闭事件！"); break; case CloseReason.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24e81fd9de17f0598b933c28e433dafa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37449ada158ff6749ea97489c47ff36/" rel="bookmark">
			15个Java面试题含答案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在任何Java面试当中多线程和并发方面的问题都是必不可少的一部分。如果你想获得更多职位，那么你应该准备很多关于多线程的问题。
他们会问面试者很多令人混淆的Java线程问题。面试官只是想确信面试者有足够的Java线程与并发方面的知识，因为候选人中有很多只浮于表面。现在引用Java5并发包关于并发工具和并发集合的问题正在增多。那些问题中ThreadLocal、Blocking Queue、Counting Semaphore和ConcurrentHashMap比较流行。
打开百度APP看高清图片
15个Java多线程面试题及回答
1) 现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对”join”方法是否熟悉。这个多线程问题比较简单，可以用join方法实现。
2) 在Java中Lock接口比synchronized块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？
lock接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像ConcurrentHashMap这样的高性能数据结构和有条件的阻塞。Java线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。
3) 在java中wait和sleep方法的不同？
通常会在电话面试中经常被问到的Java线程面试问题。最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。
4）用Java实现阻塞队列。
这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用Java线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用wait()和notify()方法来实现阻塞队列，你可以要求他用最新的Java 5中的并发类来再写一次。
5）用Java写代码来解决生产者——消费者问题。
与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在Java中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。
6）用Java编程一个会导致死锁的程序，你将怎么解决？
这是我最喜欢的Java线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写deadlock free code（无死锁代码？），他们很挣扎。只要告诉他们，你有N个资源和N个线程，并且你需要所有的资源来完成一个操作。为了简单这里的n可以替换为2，越大的数据会使问题看起来更复杂。通过避免Java中的死锁来得到关于死锁的更多信息。
7) 什么是原子操作，Java中的原子操作是什么？
非常简单的java线程面试问题，接下来的问题是你需要同步一个原子操作。
8) Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？
自从Java 5和Java内存模型改变以后，基于volatile关键字的线程问题越来越流行。应该准备好回答关于volatile变量怎样在并发环境中确保可见性、顺序性和一致性。
9) 什么是竞争条件？你怎样发现和解决竞争？
这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于Java竞争条件的文章。在我看来这是最好的java线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。
10) 你将如何使用thread dump？你将如何分析Thread dump？
在UNIX中你可以使用kill -3，然后thread dump将会打印日志，在windows中你可以使用”CTRL+Break”。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。
11) 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
这是另一个非常经典的java多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级Java面试的第一轮被问到。这个问题的回答应该是这样的，当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码。阅读我之前写的《start与run方法的区别》这篇文章来获得更多信息。
12)Java中你怎样唤醒一个阻塞的线程？
这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了IO阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c37449ada158ff6749ea97489c47ff36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6e8b54b8e29339e03670b675c0e1cb4/" rel="bookmark">
			100&#43;道Java经典面试题（面中率高）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java是一个支持并发、基于类和面向对象的计算机编程语言。下面列出了面向对象软件开发的优点：
代码开发模块化，更易维护和修改。代码复用。增强代码的可靠性和灵活性。增加代码的可理解性。面向对象编程有很多重要的特性，比如：封装，继承，多态和抽象。下面的章节我们会逐个分析这些特性。
封装
封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。
下面列出了使用封装的一些好处：
通过隐藏对象的属性来保护对象内部的状态。提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。禁止对象之间的不良交互提高模块化。参考这个文档获取更多关于封装的细节和示例。
多态
多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。
继承
继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。
抽象
抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。
抽象和封装的不同点
抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。
常见的Java问题
1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。
Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。
2.JDK和JRE的区别是什么？
Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。
3.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？
“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。
4.是否可以在static环境中访问非static变量？
static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。
5.Java支持的数据类型有哪些？什么是自动拆装箱？
Java语言支持的8中基本数据类型是：
byteshortintlongfloatdoublebooleanchar自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。
6.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？
Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。
7.Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？
当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。
Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。
Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。
8.Java支持多继承么？
不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。
9.接口和抽象类的区别是什么？
Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。抽象类可以在不提供接口方法实现的情况下实现接口。Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。也可以参考JDK8中抽象类和接口的区别
10.什么是值传递和引用传递？
对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。
对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。
Java线程
11.进程和线程的区别是什么？
进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
12.创建线程有几种不同的方式？你喜欢哪一种？为什么？
有三种方式可以用来创建线程：
继承Thread类实现Runnable接口应用程序可以使用Executor框架来创建线程池实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。
13.概括的解释下线程的几种可用状态。
线程在执行过程中，可以处于下面几种状态：
就绪(Runnable):线程准备运行，不一定立马就能开始执行。运行中(Running)：进程正在执行线程的代码。等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。睡眠中(Sleeping)：线程被强制睡眠。I/O阻塞(Blocked on I/O)：等待I/O操作完成。同步阻塞(Blocked on Synchronization)：等待获取锁。死亡(Dead)：线程完成了执行。14.同步方法和同步代码块的区别是什么？
在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。
15.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？
监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。
16.什么是死锁(deadlock)？
两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。
17.如何确保N个线程可以访问N个资源同时又不导致死锁？
使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。
Java集合类
18.Java集合类框架的基本接口有哪些？
集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。
Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：
Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。19.为什么集合类没有实现Cloneable和Serializable接口？
克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。
20.什么是迭代器(Iterator)？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6e8b54b8e29339e03670b675c0e1cb4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5167b7cebdd174b6a805b8e2fb38bec0/" rel="bookmark">
			Java面试题总结，（含答案）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java OOP面试题108道
1、什么是B/S架构？什么是C/S架构
（1）B/S(Browser/Server)，浏览器/服务器程序
（2）C/S(Client/Server)，客户端/服务端，桌面应用程序
2、Java都有哪些开发平台？
（1） JAVA SE：主要用在客户端开发
（2）JAVA EE：主要用在web应用程序开发
（3）JAVA ME：主要用在嵌入式应用程序开发
3、什么是JDK？什么是JRE?
（1）JDK：java development kit：java开发工具包，是开发人员所需要安装的环境
（2）JRE：java runtime environment：java运行环境，java程序运行所需要安装的环境
4、Java语言有哪些特点
（1） 简单易学、有丰富的类库
（2） 面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高）
（3）与平台无关性（JVM是Java跨平台使用的根本）
（4） 可靠安全
（5）支持多线程
打开百度APP看高清图片
Java集合/泛型面试题24道
ArrayList和linkedList的区别
Array(数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。
Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据,(因为删除数据以后, 需要把后面所有的数据前移)
缺点: 数组初始化必须指定初始化的长度, 否则报错
例如:
int[] a = newint[4];//推荐使用int[] 这种方式初始化int c[] = {23,43,56,78};//长度：4，索引范围：[0,3]
List—是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。
List有两个重要的实现类：ArrayList和LinkedList
ArrayList: 可以看作是能够自动增长容量的数组
ArrayList的toArray方法返回一个数组
ArrayList的asList方法返回一个列表
ArrayList底层的实现是Array, 数组扩容实现
LinkList是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于
ArrayList.当然,这些对比都是指数据量很大或者操作很频繁。
Java异常面试题8道
1、Java中异常分为哪两种？
2、异常的处理机制有几种？
3、如何自定义一个异常
4、try catch fifinally，try里有return，finally还执行么？
5、 Excption与Error包结构
6、Thow与thorws区别
7、Error与Exception区别？
8、error和exception有什么区别
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5167b7cebdd174b6a805b8e2fb38bec0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4537fb6ce57363be275e15064923265f/" rel="bookmark">
			Java程序员面试题（12专题5000解析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、多线程&amp;并发面试题（108道）
1、Java中实现多线程有几种方法
2、继承Thread类
3、实现Runnable接口。
4.ExecutorService. Callable.Future有返回值线程
5、基于线程池的方式
6、4种线程池
7、如何停止一个正在运行的线程
8、 notify0和notifyAll0有什么区别?
9、sleep()和wait(有什么区别?
10、volatile是什么?可以保证有序性吗?
11、Thread类中的start(和run(方法有什么区别?
12、为什么wait, notify 和notifyAll这些方法不在thread类里面?
13、为什么wait和notify方法要在同步块中调用?
14、Java中interrupted和islnterruptedd方法的区别?
15、Java中synchronized和 ReentrantLock有什么不同?
16、有三个线程T1,T2,T3,如何保证顺序执行?
17、SynchronizedMap和ConcurrentHashMap有什么区别?
18、什么是线程安全
19、Thread类中的yield方法有什么作用?
20、Java线程池中submit(0和execute(方法有什么区别?
21、说—说自己对于synchronized关键字的了解
22、说说自己是怎么使用synchronized关键字，在项目中用到了吗synchronized关键字最主要的三种使用方式
23、什么是线程安全?Vector是一个线程安全类吗?
24.volatile关键字的作用?
25、简述—下你对线程池的理解
打开百度APP看高清图片
二、JVM面试题（87道）
1、java中会存在内存泄漏吗，请简单描述。
2、64位JVM中，int的长度是多数?
3、Serial 与 Parallel GC之间的不同之处?
4、32位和64位的JVM， int类型变量的长度是多数?
5、Java 中 WeakReference 与 SoftReference的区别?
6、JVM选项-XX:+UseCompressedOops有什么作用?为什么要使用
7、怎样通过Java程序来判断JVM是32位还是64位?
8、32位JVM和64位JVM的最大堆内存分别是多数?
9、JRE、JDK、JVM及T之间有什么不同?
10、解释Java堆空间及GC?
11、JVM内存区域
12、程序计数器(线程私有)
13、虚拟机栈(线程私有)
14、本地方法区(线程私有)
15、你能保证GC执行吗?
16、怎么获取Java程序使用的内存?堆使用的百分比?
17、Java 中堆和栈有什么区别?
18、描述一下JVM加载class 文件的原理机制
19、GC是什么?为什么要有GC?
20、堆(Heap-线程共享)-运行时数据区
21、方法区/永久代(线程共享)
22、JVM运行时内存
三、Mysql面试题（83道）
1、数据库存储引擎2. InnoDB (B＋树)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4537fb6ce57363be275e15064923265f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/177ae8d5b0ff577695c0abefe0fd193c/" rel="bookmark">
			Latex中引用文献的排序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用latex写期刊时，会遇到引用文献的排序问题。
一般来说期刊需要我们引用期刊自带的引用格式，也就是会使用期刊自带的.bst文件
\bibliographystyle{css.bst}
如果引期刊自带的引用格式，其参考文献的引用排序就会按照它的要求来，并不会按照引用顺序
假如我们要按照引用顺序来编号引用，该怎么办？
很多帖子说可以加入
\bibliographystyle{unsrt} 让其按照引用顺序排序，但是试了一下不管用。因为会.bst文件中的引用顺序冲突。
所以我们要去修改.bst文件中的引用排序
具体步骤如下：
（1）打开xx.bst文件
（2）找到两行“SORT”代码（一定是大写的）
例如
（3）删除这两行，保存
（4）重新编译即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ae8c3859de2a401cfd85376917ae94a/" rel="bookmark">
			所有方向你要的资料干货这都有，从入门到实战！【CSDN宝藏资料图鉴第一期】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 CSDN 是全球知名的开发者社区，创建于1999年，经过20来年的知识文档积累已然成为中文开发者的知识宝库；从基础的法入门到蜕变实战案例、从神秘前沿技术到清晰的实践步骤，可以说CSDN是你找寻资料的最佳宝库，只要你想得到，在这里就可以找得到！
今天我们就来深拔一期有质量的专栏和资源，这些专栏作者可能有些是在校大学生、有些是某领域内的行内大牛，但并不影响他们的文章通俗易懂并且富有深度。从在校大学生我们看到了新一代的奋进，从领域大牛身上我们也看到了无私的技术分享，希望有质量的文章越来越多，共同为行业的进步出一份力。
宝藏图鉴 宝藏链接 大话系列之C语言Java基础入门滚雪球学 PythonPython OpenCV爬虫100例教程嵌入式系统2020智能车竞赛专栏基础电子使用PyQt开发图形界面Python应用Qt开发Python+TensorFlow人工智能python数据分析实战量化基础到我要拿 Python 炒股票, 然后惊呆所有人!数据对接-ETL之StreamSet学习之旅php问题解决方案腾讯云开发雷学委NodeJS系列量化投资神器-backtrader源码解析-从入门到精通列Spring Boot 2.x 最佳实践Scala游戏系统设计数据结构入门蓝桥杯各年模拟题及真题蓝桥杯试题 基础练习 BASIC1-30夜深人静写算法RDKit |化学信息学与AILife Sciences.AIDrugAIUnity基础知识学习Java游戏实例大全Unity 之 UGUI控件详解unity 宝藏级解决方案小狮子前端Vue进阶小册JavaScript基础内功冰河的渗透实战笔记-冰河.pdf运维面试秘籍数据可视化_Echarts软件工程SEO优化秘籍 作者及干货介绍 启蒙阶段 方向： C语言
作者： 1_bit
作者介绍： CSDN博客专家、蓝桥签约作者、2020年博客之星TOP5、CSDN新手导师。
专栏链接： 大话系列之C语言
专栏介绍： 对话模式的教学、幽默、有趣，深受好评！
————————————————————————————
方向： JAVA
作者： 布小禅
作者介绍： 哈喽大家好，我是布小禅，一个网络专业却对编程极其感兴趣的IT小白，目前在学习Java，以自学为主，B站，C站为辅，期待你的关注，每天跟着我进步一点点，日后，可能我们就是大佬了哦。
专栏链接： Java基础入门
专栏介绍： 本专栏适合于零基础小白学习Java（因为博主本人也是零基础小白），以幽默风趣的，容易理解的语言，讲述Java基础内容，看了我的专栏，你绝对会对Java有一个自己的理解。不过因为博主水平有限，本专栏仅供入门！
————————————————————————————
方向： Python+图像识别
作者： 梦想橡皮擦
作者介绍： 梦想橡皮擦之擦姐，游戏行业研发出身，现任某千万月活 APP 产品经理。她有10年互联网从业经验，写过代码，干过测试，做过管理，创过业。曾2019年主导 Python 爬虫 100 例专栏，是2020年滚雪球学 Python 发起者，也是2021年 Python OpenCV 365 天取经计划发起者。
专栏链接：
滚雪球学 PythonPython OpenCV爬虫100例教程 专栏介绍： 从本篇博客开始，我将真正的从 0 到 1，完完整整给你写一套 Python 语言的教程，把如何快速学会 Python 技巧告诉你。 滚雪球学 Python，力求在知识面完整的程序上，用轻松的文风为大家献上 Python 学习的盛宴，使用爬虫进行实战，100个案例助你成为爬虫高手，后期进阶到 OpenCV，365 天完成国内顶尖的 Python OpenCV 自学之旅，与橡皮擦一起来吧。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ae8c3859de2a401cfd85376917ae94a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/903e3c0e35dfc5f31274fb1a7e20723e/" rel="bookmark">
			30分钟学会Flutter动画开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、flutter动画组成要素和载体二、常用的四种动画的实现三、列表组动画Group Animation的实现四、第三方动画框架的介绍和使用结束语 前言 动画是UI交互的重要组成部分，精心设计的动画会让用户界面感觉更直观、流畅，能改善用户体验。flutter作为跨平台的UI框架，对动画提供了良好的支持和简单轻松的实现，本文对flutter动画的类型和动画方式以及第三方的动画框架做一点总结，希望对大家有所帮助。
Flutter的动画支持可以轻松实现各种动画类型。许多widget，特别是Material Design widgets， 都带有在其设计规范中定义的标准动画效果，但也可以自定义这些效果。
一、flutter动画组成要素和载体 flutter动画一般有4部分要素组成，分别是Animation、AnimationController、Curve、Tween。它们的关系如下图：
Animation&lt;T&gt;：代表一个动画，是动画的核心类，可以从通过animation.value拿到当前动画的值，以及读取到当前当前动画的状态（例如它是开始、停止还是向前或向后移动）
AnimationController：顾名思义就是动画的控制器，可以控制动画的开始、停止、向前向后还有重复执行等操作。在页面销毁的时候，记得要调用controller的dispose方法，否则会有内存泄漏的风险。
Curve：动画运动过程中的速率的曲线，比如可以定义匀速运动，先快后慢、先慢后快等。
Tween：动画的取值范围，默认是0.0~1.0，如果需要定义动画不同的类型和范围，可以通过Tween的begin和end来指定。
Tween通过animate方法可以生成指定区间的全新动画。
所以，四个要素组合起来，一般的动画定义代码为：
final AnimationController controller = AnimationController(duration: const Duration(milliseconds: 500), vsync: this); final Animation curve = CurvedAnimation(parent: controller, curve: Curves.easeOut); Animation&lt;int&gt; animation = IntTween(begin: 0, end: 255).animate(curve); 动画定义完成之后，在UI树中需要一个动画的载体来完成动画。flutter承载动画的组件是AnimatedWidget和ImplicitlyAnimatedWidget，为了方便开发者开发动画，AnimatedWidget和ImplicitlyAnimatedWidget提供了很多子类，AnimatedWidget的子类概览如下图：
AnimatedWidget和ImplicitlyAnimatedWidget的区别就是：AnimatedWidget需要开发者自己定义一个animation传递给它，并且自己管理AnimationController，而ImplicitlyAnimatedWidget只需要给它设定一个目标值和duration，它就会开始动画，并且内部自己管理一个AnimationController，简化了操作。
二、常用的四种动画实现 一般场景下，常用到的动画主要有以下四种：渐隐渐现动画、位移动画、旋转动画、放大缩小动画。
在flutter中，这四种动画都有对应的封装类
渐隐渐现动画 -- FadeTransition
位移动画 -- SlideTransition
旋转动画 -- RotationTransition
放大缩小动画 -- ScaleTransition
它们的用法都是类似，首先是定义一个animation，然后将animaton作为关键参数传给对应的AnimatedWidget。
下面就透明度动画和位移动画做一个简单的示例，其他两种动画都是类似的用法
首先是创建一个透明动画对象和位移动画对象：
AnimationController _controller; Animation&lt;double&gt; _animation; Animation&lt;Offset&gt; _offsetAnimation; @override void initState() { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/903e3c0e35dfc5f31274fb1a7e20723e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b4fa2aa8f5241ffb546305bac7176cb/" rel="bookmark">
			linux驱动：genirq: Flags mismatch irq
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		调试中断的时候出现这个问题：
主要原因是中断号冲突了，解决办法：
再查看：
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/315/">«</a>
	<span class="pagination__item pagination__item--current">316/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/317/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>