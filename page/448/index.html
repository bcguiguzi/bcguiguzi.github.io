<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f72ef4ed5e463808544cf57f5c422d2e/" rel="bookmark">
			使用npm命令提示: &#39;npm&#39; 不是内部或外部命令，也不是可运行的程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装nodejs时候，有时候我们会把它安装在d盘或别的盘时，经常会遇到npm环境变量没有配好，需要自己手动去配置。
在安装完nodejs后输入node --version查看安装是否成功，若成功会出现下图
接着我们在使用npm安装依赖的时候有时候会出现“'npm' 不是内部或外部命令，也不是可运行的程序”的提示，此时我们先查看环境变量
知道3所指的路径，你会看到下图只有一个etc文件，没有马赛克部分内容，没有npm文件。
发现问题后，我们在环境变量中添加我们安装的npm命令行执行文件路径
我的是安装在D:\Program Files\nodejs下（如下图）
则添加此路径的环境变量，按下图步骤
添加完后便可使用npm命令
Python正确的学习路线，你一定不知道的薪资翻倍秘诀
如何从8K提至20K月薪，你要掌握学习那些技能
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a1b899ce3c18a70ae4b5337c00e58da/" rel="bookmark">
			Cloudera Hadoop运维管理与性能调优
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 [url=https://blog.csdn.net/qq_30004245/article/details/78211493]Cloudera Hadoop运维管理与性能调优[/url] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac3a9ac79c0b210aa93797a2b17ff104/" rel="bookmark">
			安装VMWare时出现的错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、第一个问题 尝试创建目录 C:\Public\documents\SharedVirtual Machines时发生错误如图: 这个问题的解决方法我竟然在网上找不到，然后我突发奇想，既然无法创建这个目录，那我帮你创建一个不就好了，然后我就手动创建了一个，没想到竟然不报错了，后来想了想，可能是文件夹权限的问题，不过已经解决了，我就没有尝试，有兴趣的可以试一试是不是权限问题。
二、第二个问题 这个问题我在网上找到了：警告1909。无法创建快捷方式VMware Workstation Pro.Ink。解决方法（附 VMware_workstation 12的安装方法） 可惜的是，我按照上面的步骤仍然无法解决问题。 后来我又突发奇想，既然我无法创建快捷模式，那我不创建快捷模式不就可以了： 然后就莫名其妙的成功了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8851d07be40dc1bf81e1734ad4df51d/" rel="bookmark">
			html5的canvas知识总结（8）isPointInPath、isPointInStroke、解决canvas高分屏模糊、非零环绕原则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. ctx.isPointInPath(80,80)：判断点是否在上面路径的区域内。
ctx.isPointInStroke(80,50)：判断点是否在上面路径的边缘线上。
浏览器支持情况：
（1）Internet Explorer 9、Firefox、Opera、Chrome 以及 Safari 支持 isPointInPath() 方法。
注释：Internet Explorer 8 或更早的浏览器不支持 &lt;canvas&gt; 元素。
（2）isPointInStroke支持情况：
可以通过getImageData来替换isPointInStroke的不足，一个用stroke描边的方式绘制的图形，只有边线是有色的，通过getImageData判断某个点，是否透明，来判断该点是否在边缘线上。
data[3] 的值是128，所以该点在边缘线上。
isPointInPath方法采用了非零环绕原则：判断p点是否在一个区域内，从点p向外做一条射线（可以任意方向），多边形的边从左到右经过射线时环绕数-1，多边形的边从右向左经过时环绕数+1，最后环绕数不为0，即表示在多边形内部。
第一步：按顺时针或逆时针给每个边画一个方向箭头；
第二步：点p向任意方向，做一条射线；
第三步：左、上方向的+1，右、下方向-1；
如果和不是0，就在区域中。
2. 解决canvas高分屏模糊
在分辨率比较高的屏幕，比如：iPhone6、iPhone6s、mac等屏幕，canvas绘制的是位图，会在分辨率高的屏幕产生模糊。
解决办法：
&lt;canvas width="200" height="200" id="canvas1"&gt;&lt;/canvas&gt; #canvas1 { width: 100px; height: 100px; border: 1px solid black; } 这样对于canvas来说，就是2:1比例的内容，分辨率会提高两倍。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975aa656ee39c29a68ed20fcd8c1b46c/" rel="bookmark">
			Android中的注解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在很多三方库的源码中都看到注解，注解它不能改变我们的代码，但是注解提供了很多代码外的额外信息，这片文章主要来总结下我们平时在Android开发中用到的一些注解：
#一、java sdk中的注解
##系统内置标准注解
###Override
Override表示标注的方法已经重载了父类的方法。同时也起到了一个断言的作用。比如我们写了一个跟父类方法名称一样的方法时而没有标注Override的时候，编译器通常就会报错。
###Deprecated
Deprecated表示方法已经过时，根Override一样也是一个标记型的注解。
当我们继承或者实现的父类里面的一个标注为Deprecated的方法，虽然子类的方法中没有标注Deprecated，但是编译器仍然会警告。
###SuppressWarning
SuppressWarning的作用：抑制编译器产生警告信息。
@SuppressWarnings(“unchecked”) 抑制单类型的警告
@SuppressWarnings(value={“unchecked”, “rawtypes”}) 抑制多类型的警告
@SuppressWarnings(“all”)抑制所有警告
##元注解
###@Target
@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。
作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）
取值(ElementType)有：
1.CONSTRUCTOR:用于描述构造器
2.FIELD:用于描述域
3.LOCAL_VARIABLE:用于描述局部变量
4.METHOD:用于描述方法
5.PACKAGE:用于描述包
6.PARAMETER:用于描述参数
7.TYPE:用于描述类、接口(包括注解类型) 或enum声明
###@Documentation
用来描述其他类型的一些注解应该作为共有程序的api
###@Rentension
Retention(保留)注解说明,这种类型的注解会被保留到那个阶段. 有三个值:
1.RetentionPolicy.SOURCE —— 这种类型的Annotations只在源代码级别保留,编译时就会被忽略
2.RetentionPolicy.CLASS —— 这种类型的Annotations编译时被保留,在class文件中存在,但JVM将会忽略
3.RetentionPolicy.RUNTIME —— 这种类型的Annotations将被JVM保留,所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用.
###@Inherited
它指明被注解的类会自动继承
#二、Android Support Annotation中的注解
以下注解只有在android.support.annotation包当中
###@Nullness
@Notnull表示函数的返回不可以为null
@Nullable 表示函数的参数或者返回可以为null
如果我们编写了一个方法，它有可能是会返回null的，这时候方法上面又有@Nullable的注解，那么这个时候编译器提示我们warning。
###@ResouceType
定义传入的资源id的类型。比如通常用@StringRes要求传入的int类型的资源id是一个字符床的资源。
###@Threading
指定耗时操作时在哪个线程中进行的。
###@CallSuper
指定方法在调用的同时去调用父类的方法
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0455e979c45aa10ced6d8eb7a961d6a/" rel="bookmark">
			工具网站收藏(持续更新)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公共maven库 http://mvnrepository.com/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85b3e04572d513e710c1f2c39a258ede/" rel="bookmark">
			使用 .gitlab-ci.yml 配置作业
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		整理一下 .gitlab-ci.yml 文件的配置
原文档地址
job job 是一组具有约束的作业，可以指定无限数量的 job 。
job 被定义为具有任意名称的顶级元素，并且始终必须至少包含该 script 子句。
job 必须具有唯一的名称，下面是一些保留的关键字不可以作为 job 的名称。
image services stages types before_script after_script variables cache 作业由定义作业行为的参数列表定义
关键词是否必须描述scriptyes定义由Runner执行的shell脚本extendsno定义此 job 将继承的配置条目imageno使用 Docker 镜像servicesno使用 Docker 服务stageno定义 job 阶段（默认：test）typenostage 的别名variablesno在 job 级别定义 job 变量onlyno定义为其创建 job 的 git refs 列表exceptno定义未创建 job 的 git refs 列表tagsno定义用于选择Runner的标记列表allow_failureno允许 job 失败，失败的 job 不会贡献 commit statuswhenno定义何时运行 job 。可以是 on_success，on_failure，always 或 manualdependenciesno定义 job 所依赖的其他 job ，以便您可以在它们之间传递 artifactsextendsnojob artifacts 依赖列表cacheno定义后续运行之间应缓存的文件列表before_scriptno覆盖 job 前执行的一组命令after_scriptno覆盖 job 后执行的一组命令environmentno定义此 job 完成部署的环境名称coverageno定义给定 job 的代码覆盖率设置retryno定义在发生故障时可以自动重试 job 的次数 extends 在 GitLab 11.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85b3e04572d513e710c1f2c39a258ede/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e52b9ad44a91be6930c6b6681fb62e1c/" rel="bookmark">
			OMNI协议介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OMNI OMNI是创建和交易定制数字资产和货币的平台。它是一个建立在最受欢迎、严格审核、最安全的Bitcoin之上的软件层。OMNI交易是比特币交易，使用比特币链上的下一代功能。Omni Core是一个增强的Bitcoin，它提供了Bitcoin的所有特性以及Omni的一些高级特性。
使用OMNI，很容易创建令牌来表示定制货币或资产，并通过Bitcoin 进行交易。OMNI提供高效而简单创建令牌的功能，使其成为成为基于比特币的令牌首选。这种关系可以认为使ETH之于Token。
OP_Return 在BTC锁定脚本中，只要是以OP_Return开头的都属于“备注信息”。这种信息属于备注，不会被节点解析出来的。
但是OP_Return数据位于BTC区块内，这个数据是不可篡改和区块里的交易信息一样。我们可以认为，交易加OP_Return，这两个信息就会是在全世界唯一性地存在。这样就避免应用它时产生双花的问题。
OP_Return就是Omni协议成立的关键。
铸币与交易 有了OP_Return和Bitcoin这两大利器，我们可以很容易的构建起来BTC的Token。
1、我们发一笔带自定义OP_Return数据的交易，交易的输入是自己控制私钥的地址A，输出有两个，第一个输出还是地址A，即这笔交易是自己发给自己，第二个输出是一个OP_Retrun数据。这个OP_Return数据写的意思就是“使用地址A当成创世账户，给这个账户注入6亿个XQ货币”。
2、BTC节点不会去识别这个OP_Return里的数据的。这时候Omni会来解析这个OP_Return数据。解析出账户A，余额6亿XQ。
3、比如支付给地址B 1亿个币。使用地址A构造一笔BTC交易，输入是地址A，输出之一是地址B，金额为0聪，带上矿工费，第二个输出是一个OP_Return，里面的数据写会被解析为“账户A向账户B支付1亿个币”。同理OP_Return里的数据，在BTC网络是不会被处理的，还是需要Omini进行解析。
看个列子，8a061e68212cb8d84e9bf029085ff508465141c376e3b6d46fee4b1ef26d4a7d，第一张先看一下btc浏览器。第二张图看一下omni浏览器
omni浏览器
这是比较简单的Omni协议实现的代币的原理，代币其实还增加一些其他高级功能，比如锁定功能，自动化转币功能。想要详细了解的可以看这里：https://github.com/OmniLayer/spec
在BTC上，现在一共有400种代币。下面是这些币的列表，但只有USDT有人在用。
https://www.omniexplorer.info/properties/production
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e740c8381fda06edb2b014223edf130b/" rel="bookmark">
			养兔子
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一只成熟的兔子每天能产下一胎兔子。每只小兔子的成熟期是一天。 某人领养了一只小兔子，请问第N天以后，他将会得到多少只兔子。 输入描述: 测试数据包括多组，每组一行，为整数n(1≤n≤90)。 输出描述: 对应输出第n天有几只兔子(假设没有兔子死亡现象)。 输入例子: 1 2 输出例子: 1 2 分析这个题 就知道前 i-1 天的数量 加上 i-2天的数量就好
#include&lt;bits/stdc++.h&gt; #include&lt;algorithm&gt; using namespace std; long long int a[100]; int main() { long long int num; memset(a,0,sizeof(a)); a[1]=1; a[2]=2; while(scanf("%lld",&amp;num)!=EOF) { long long int nm=0; if(num==1) cout&lt;&lt;a[num]&lt;&lt;endl; if(num==2) cout&lt;&lt;a[num]&lt;&lt;endl; if(num&gt;2) { for(int i=3;i&lt;=num;i++) { nm=(a[i-1]+a[i-2]); a[i]=a[i-1]+a[i-2]; } cout&lt;&lt;nm&lt;&lt;endl; } } return 0; } ///当测试样例为46时 最后结果是错误的 ///容易溢出 所以用long long int 来存取 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/abdce0e161ddcef91404930f8782f84e/" rel="bookmark">
			vue&#43;axios 开发环境与生产环境配置请求接口，本地开发和线上开发有多个请求地址怎么处理？上线后自动获取ip,不需改请求地址可运用多个项目中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 配置本地开发环境接口：
进入到项目目录config文件中index.js ；当页面有多个不同地址时此可以重定向，下图中会出现报错的就是路径问题，
创建所有httpUrl接口请求。举例后台请求地址为：192.168.11.12:80/omc/login ,第一个/omc;页面请求地址写为/omc/login，请求地址为192.168.11.11：80/node/list 第二个/api 页面请求地址要写成/api/node/list
2.配置开发环境
为了更加方便的在打包压缩后还能找到文件地址，在static下创建configip文件; 下图中window.location.hostname可以动态获取到ip名称；URL对象里面可以写多个地址，
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c81646e267d06bd22beb712039a27d8d/" rel="bookmark">
			vue&#43;axios&#43;bolb下载文件，获取文件流乱码解决方法，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.首先封装了下载文件get请求方式，其中用element-ui 的提示信息Message，文件引入
import axios from "axios";
import {Message} from 'element-ui'；
// 封装下载请求 返回文件流
export function dowLoadHTTP(url, params = {}) {
return new Promise((resolve, reject) =&gt; {
axios.get(url,params)
.then((response) =&gt; {
if (response) { // 判断请求
resolve(response);
} else {
Message.error('数据请求失败');
}
})
.catch((err) =&gt; {
reject(err);
Message.error('数据请求失败' + error);
});
});
}
2. 获取文件并下载文件 import {dowLoadHTTP} form 'url'// 此url写第一步封装请求文件地址
dowLoadHTTPt('http://www.baidu.com',{
responseType: 'blob', // 表明返回服务器返回的数据类型, 没有会乱码
params: {}// 里面是请求参数
})
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c81646e267d06bd22beb712039a27d8d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7ba238f55feba340775c3814155723/" rel="bookmark">
			Android 界面加载卡顿严重，Skipped 56 frames! The application may be doing too much work on its main thread
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在APP开发中，出现了部分界面卡顿十分严重的情况，日志中报 说明在主线程做了太多的耗时操作。 应当注意: 不应在主线程中进行耗时操作，比如网络请求，很复杂耗时的计算，对数据库的访问以及数据修改等。应该另开辟子线程将之放入到子线程中。控件的刷新应在主线程中进行操作。 同时，如果在页面加载了很多的图片资源，或图片资源很大的时候，应该尽可能的将资源的获取设置在代码中绑定，而不是在layout文件中直接写明。 改成在activity中绑定。 .setImageResource（）等同于在xml文件中设置图片的background。 同时如果是加载的图片很多的话，可以使用图片加载框架，比较好用。诸如Glide。框架一般情况下我们只需要使用一个，功能大多数是重复的，Glide的性能和便捷性很棒。具体使用，详情请看郭神的博客，这是一个系列篇。
————————————————————- 后记 在改变了图片的加载模式之后，应该会有很大的提升，但是假如还是不够流畅，不够灵活的话，那应该就是我们的程序优化不够，在主线程还是做了太多的工作。仔细看一下代码，将耗时操作尽可能的移出主线程。
同时，一个重大发现，如果加载的图片不需要太大分辨率的话，可以适当的等比例降低像素值（画图中有这个功能） 再在程序中加载的时候有奇迹般的进步。 我是从1500*1500 降到了 200*200，尴尬的一批，改完之后就和德芙巧克力一样，柔顺的很。 如果是自己的找的资源，或者是背景图的话，很可能会忽略这一点，可以看一下自己的是不是太大了，超过了需求 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56e16c86227789d930d3ce4321cf5690/" rel="bookmark">
			ARM架构服务器centos7.4上yum安装k8s教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境说明
[root@k8s-master ~]# uname -a Linux slave1 4.11.0-22.el7a.aarch64 #1 SMP Sun Sep 3 13:39:10 CDT 2017 aarch64 aarch64 aarch64 GNU/Linux [root@k8s-master ~]# cat /etc/redhat-release CentOS Linux release 7.4.1708 (AltArch) 主机名IP功能k8s-master10.2.152.78masterk8s-node110.2.152.72 node
2、修改master和node的hosts文件
[root@k8s-master ~]# vim /etc/hosts 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 10.2.152.78	k8s-master 10.2.152.72	k8s-node1 3、安装ntp实现所有服务器间的时间同步
$：yum install ntp -y $：vim /etc/ntp.conf 21 server 10.2.152.72 iburst #目标服务器网络位置 22 #server 0.centos.pool.ntp.org iburst #一下三个是CentOS官方的NTP服务器，我们注释掉 23 #server 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/56e16c86227789d930d3ce4321cf5690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c4d1db4704973c6ff6f262ab7f0eaef/" rel="bookmark">
			分屏状态下分出的屏幕提示超出显示范围
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天笔记本想要分屏，但是连接上后提示超出显示范围，我用的戴尔的笔记本，联想的显示器，显示器提示分辨率为1680*1050@60HZ。但是开始调整屏2的分辨率后依然无效。之后发现除了在显示设置里面调整分辨率，还要在显卡设置里面调整。
将内置显示器切换成数字式电视机，之后根据提示设置分辨率和刷新频率。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/947e5c75c9af0d53b93740b9b755b071/" rel="bookmark">
			Unity Socket网络编程(TCP) 简单例子-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开发工具：Visual Studio、Unity
开发语言：C#
【服务器端】
在VS创建一个C#空项目
代码如下：
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net.Sockets;
using System.Net;
namespace NetworkServer
{
class Program
{
static void Main(string[] args)
{
/*创建一个socket对象*/
//寻址方式 套接字类型 协议方式
Socket tcpSocket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);
/*绑定监听消息IP和端口号*/
IPAddress ip = IPAddress.Parse("127.0.0.1");
EndPoint endPoint = new IPEndPoint(ip, 6000);
tcpSocket.Bind(endPoint);//向操作系统申请一个ip和端口号
Console.WriteLine("服务器端启动完成");
/*开始监听客户端的连接请求*/
tcpSocket.Listen(100);//最多可以接收100个客户端请求
Socket socket = tcpSocket.Accept();//暂停当前线程，知道接收到客户端发来的连接请求；当接收到客户端的连接请求后，在本地服务器创建一个socket与客户端连接，并返回出来
Console.WriteLine("有个客户端连接进来");
/*向客户端发送消息*/
string messge;
messge="你好,我有什么可以帮助到你吗";
var date=ASCIIEncoding.UTF8.GetBytes(messge);
socket.Send(date);
/*从客户端接收消息*/
byte[] bt=new byte[1024];//设置一个消息接收缓冲区
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/947e5c75c9af0d53b93740b9b755b071/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de3007bb65bc67f1e39ce7c83111444/" rel="bookmark">
			上拉和下拉的解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.什么是上下拉电阻？
上拉电阻：把一个不确定的信号通过电阻连接到高电平，是电信号初始化为高电平。
下拉电阻：把一个不确定的信号通过电阻连接到地，使电信号初始为低电平。
本质：上拉是对器件注入电流，下拉是输出电流
2.上下拉电阻接线方法
上拉电阻接线方法
电阻R12将KEY1网路标识上拉到高电平，在按键s2没有按下的情况下key1将被钳制在高电平，从而避免了引脚悬空而引起的误动作。
下拉电阻接线方法
这里电阻R29将DIR下拉到低电平，在光耦没有导通的情况下DIR将被钳制在低电平，从而避免了引脚悬空而引起的误动作。
3.作用解释
提高电路稳定性，避免引起误动作。第一图中的按键如果不通过电阻上拉到高电平，那么在上电瞬间可能就发生误动作，因为在上电瞬间单片机的引脚电平是不确定的，上拉电阻R12的存在保证了其引脚处于高电平状态，而不会发生误动作。
提高输出管脚的带载能力。受其他外围电路的影响单片机在输出高电平时能力不足，达不到VCC状态，这会影响整个系统的正常工作，上拉电阻的存在就可以使管脚的驱动能力增强。这里特别强调如下：带片上I2C资源的单片机，其SCL和SDA引脚是开漏引脚，如果当做普通的GPIO来用的话，你会发现该引脚输出高电平极不稳定甚至因为负载的关系都无法正常输出高电平，这时候就需要在这两个引脚上加上拉电阻了。
4.参考文献
佚名. 单片机上拉电阻、下拉电阻的详解和选取[EB/OL]. http://www.51hei.com/mcu/3953.html. 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1e48a5293eeca1b7dc1e45ef3ce999/" rel="bookmark">
			GitHub上README.md文件的超链接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 超链接：[文本](地址)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc541787c44180813ab6a8423a041471/" rel="bookmark">
			JQuery（学习笔记七）JQuery仿京东产品详情页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主体模块
效果：
源码：
https://download.csdn.net/download/weixin_42363997/10653458
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f93e70246333cfdc518840a974070bb/" rel="bookmark">
			阿里云centos7服务器关于80端口和443端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天登录阿里云平台被告知我的服务器被别人在美国等地使用git登录过，我怀疑是我的密码泄露了，所以修改密码后重启服务器，随后写的小程序发现不能用了(小程序要求https方式访问)，排查了老半天，发现443端口不通，随后自己折腾了一下午，解决了，自己记录一下。
打开端口的步骤：
查看防火墙状态
firewall-cmd --state 2.打开防火墙
重启服务则会断开tcp会话。
systemctl restart firewalld firewall-cmd --reload 建议使用后一种“重载配置文件”。重载配置文件之后不会断掉正在连接的tcp会话，而
3.查看已经打开的端口
firewall-cmd --list-ports 4.打开443或80端口
firewall-cmd --add-port=443/tcp 开放通过tcp访问443 firewall-cmd --add-port=80/tcp 开放通过tcp访问80 5.80端口转发到8080（tomcat的默认端口为8080）,443转发到8443（https配置的端口为8443）
firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 firewall-cmd --add-forward-port=port=443:proto=tcp:toport=8443 ps：这里其实没必要转发，但是我修改tomcat中的文件将8080修改为80,8443修改为443，直接访问80或者443端口时就是不通。所以我只能通过转发。如果有知道的朋友留言告知一下，感激不尽！
6.开放阿里云平台上的配置安全组规则开放相应的端口
到这里应该就可以了。
下面是记录一下常用的防火墙命令
打开某端口
firewall-cmd --zone=public(作用域) --add-port=80/tcp(端口和访问类型) --permanent(永久生效) 查看防火墙状态
firewall-cmd --state 开启防火墙
systemctl start firewalld.service 关闭防火墙
systemctl stop firewalld.service 禁止开机启动启动防火墙
systemctl disable firewalld.service 检查是否允许伪装IP
firewall-cmd --query-masquerade 允许防火墙伪装IP
firewall-cmd --add-masquerade 禁止防火墙伪装IP
firewall-cmd --remove-masquerade 开放mysql端口
firewall-cmd --add-service=mysql 阻止http端口
firewall-cmd --remove-service=http 查看开放的服务
firewall-cmd --list-services 开放通过tcp访问3306
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f93e70246333cfdc518840a974070bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74099f772863b8b9acb2e051a224908d/" rel="bookmark">
			超好用的开发工具汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 此博客是为了收藏自己常用的一下链接，方便自己随时查看，也安利一些超好用的工具（是真的好用 界面也清爽 看了就神清气爽）
JAVA：
Hutool是一个Java工具包类库，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类 关键是Api是中文的中文的，不喜欢看英文的程序猿可以大胆的看这个了！！！mvnrepository --各种第三方的jar都可以去这里查找 ShowDoc 一个可以在线编辑Api文档工具 也可部署在自己的服务器，写接口文档超便捷JAVA 可以在线制作流程图 实时协作 H5:
超好用的在线前端工具，是我用的最全的，不要错过！！！ 包含JSON相关、加解密、网络IP、格式化、JAVA实体类转换、微信支付宝等常用的文档快捷入口、以及微信等平台工具等Swiper4 好用的轮播插件HBuilder-超好用的H5页面编辑器 写页面、样式超方便，还有提示，写起来嗖嗖嗖的腾讯js模板引擎-好用的h5数据交互模板 这个js模板引擎超好用，一般做公众号等h5的数据交互超便捷mescroll -好用的下拉刷新js插件 开发实用工具：
稳定、快速、免费的前端开源项目 CDN 加速服务 postman 一个好用的http请求工具 调试接口的好东西Fiddler 一个好用的抓包工具 简单好操作，比其他的抓包工具好使，界面也清爽Xshell 一个好用的SSH连接Linux工具 下载的时候可以注册个人免费版的在线JSON格式化工具 站长工具 种类很齐全，什么都有json转换、校验、格式化、加解密等Hijson 一个json格式化工具 很轻便随机密码生成器 其他便利工具：
一个在线制作favicon图标的工具草料二维码 一个在线生成二维码的工具 Everything --本地文件检索工具 超级快TeamViewer --远程连接 传输数据超快speedPan --可快速下载的百度网盘.snipaste --快捷截图贴图软件 第三方文档快捷入口：
微信公众号开发文档微信支付开发文档微信支付-统一下单微信小程序开发文档支付宝开发文档Linux 命令大全 还有各种相关Linux书籍推荐鸠摩搜书 很棒的电子书网站 提供在线阅读和多渠道保存下载 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/447/">«</a>
	<span class="pagination__item pagination__item--current">448/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/449/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>