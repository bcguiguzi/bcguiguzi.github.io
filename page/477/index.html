<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e709e8567d3916fec6520448a195da3/" rel="bookmark">
			自己实现MATLAB支持向量化输入输出的零阶修正贝塞尔函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 function [ y ] = Bessel0( x ) % 此函数用于计算0阶修正贝塞尔函数值 % 支持向量化输入输出 % 作用相当于MATLAB自带的库函数besseli(0,x) theta =0.001:0.001:2*pi; length(theta); t= repmat(x, length(theta), 1); t= reshape(t,1,[]); theta= repmat(theta, 1, length(x)); t= t .* cos(theta); t=reshape(t, [], length(x)); y=0.001/(2*pi) *sum(exp(t), 1); end 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e799defc53acba9aa56e842fa58f95/" rel="bookmark">
			Android集成华为推送的问题总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 公司最近想要把几个主流平台的推送进行一下整合,做一个DEMO出来,方便之后使用.做安卓开发的童鞋应该也都应该了解,自定义的服务基本上在APP被杀掉后也会被干掉(没有设置后台保护的情况下),所以要保证推送的及时和不失真,最好的方法还是去各大主流的手机厂商开发者网站去注册申请推送服务.
总结 关于集成华为推送的部分这里就不做介绍了.主要对集成华为推送服务后遇到的问题进行记录总结.希望可以帮助到同样遇到问题的童鞋.
总结一: 华为推送的初始化依赖Activity,所以不能在Application中进行初始化.
总结二: 华为推送服务中提供的透传消息是可能会丢失的.(当APP被杀死后,透传消息有时是收不到的,并且在重新启动APP后,透传消息也是收不到的,所以不推荐使用透传去做一些重要的功能)
总结三: 先看一下官方的Recevier:
public class HuaweiPushReceiver extends PushReceiver { private static final String TAG = "Huawei PushReceiver"; /** * 连接上华为服务时会调用,可以获取token值 * * @param context * @param token * @param extras */ @Override public void onToken(Context context, String token, Bundle extras) { String belongId = extras.getString("belongId"); String content = "get token and belongId successful, token = " + token + ",belongId = " + belongId; Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7e799defc53acba9aa56e842fa58f95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fbcc4d566d91265e3b504c3c6c76207/" rel="bookmark">
			ATM面向对象分析与设计之——顺序图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.顺序图综述 顺序图详细描述了用户和ATM 系统之间以及管理员和ATM系统之间的交互过程，其中对涉及了用户及管理员登录ATM系统，用户在系统上进行的存取款、转账、查询余额等多种操作进行结构化控制。 2.结构图详述 2.1用户部分 类：Client、ATM 对象：用户（主动对象）、银行。 消息描述：（以下涉及消息全为同步消息）。 （1）外层操作（登录系统、退出系统）： 1．用户向银行发送登录的消息。 2. 用户向银行发送操作消息的消息。消息格式为取款、存款、转账等操作。 3．用户向银行发送退卡的消息。 （2）登录： 在第一个交互区域，标识为（alt），表示该区域为条件执行区域，水平虚线将该区域分割为两个分区，用户若执行第一个分区，则向银行发送插卡的消息，用户若执行第二个分区，则向银行发送输入卡号的消息（即为无卡操作）。 在第二个交互区域，标识为loop(1,3),表示该区域可循环执行1到3次，在循环中，用户向银行发送输入密码的消息，银行向用户返回验证结果的消息，只要密码错误，循环就会继续，循环超过3次，则退出该区域。 (3) 取款 1.用户首先执行验证密码操作，流程引用（ref）图6中的循环分区。 2.密码正确状态下进入可选分区（opt），在用户向银行发送输入金额的消息后，进入条件执行分区（alt）。 3. 在条件执行分区中，银行判断当前操作账号所属银行与当前操作ATM所属银行是否一致,一致时，银行判断为同行卡，向用户发送支付现金的消息，不一致时，银行判断为跨行取款，向用户发送支付现金（扣取手续费）的消息，用户也可以选择跳过此分区（即放弃取款）。 （4）存款 1. 用户首先执行验证是否为同行卡操作，流程引用（ref）如7中的条件执行分区。 2. 若为同行卡，用户进入循环分区。若不是同行卡，则结束操作。 3. 在循环分区内，用户向银行发送放入现金的消息，银行向用户返回验证结果的消息，若放入现金不符合规则，循环继续，循环超过3次，则退出该区域。 （5）转账 1.用户首先执行验证密码操作，流程引用（ref）图6中的循环分区。 2.密码正确状态下，进入可选分区（opt），执行第一个循环分区操作，用户向银行发送输入对方卡号的消息，银行向用户返回验证结果的消息，若卡号错误，则循环继续，循环超过3次，则退出该区域。 3.卡号正确时，进入下一个循环分区，用户向银行发送输入金额的消息，银行向用户返回验证结果的消息，若金额不符合规则，循环继续，循环超过3次，则退出该区域。 4. 在条件执行分区（alt）中，银行判断当前操作账号所属银行与当前操作ATM所属银行是否一致,一致时，银行判断为同行卡，向用户发送转账的消息，不一致时，银行判断为跨行取款，向用户发送转账（扣手续费）的消息，用户也可以选择跳过此分区（即放弃转账）。 （6）查询余额 用户向银行发送查询的消息，银行向用户发送返回余额的消息。 （7）修改密码 1． 用户首先执行验证密码操作，流程引用（ref）图6中的循环分区。 2．用户进入循环分区，先向银行发送输入新密码的消息，再发送再次输入密码的消息，银行验证两次密码一致性后，向用户返回验证一致性的消息，若两次密码不一致，则循环继续，循环超过3次，则退出该区域。 （8）打印凭条 用户在操作完成之后，进入打印凭条条件执行分区（alt），在此分区中，水平虚线将该区域分割为两个分区，用户若执行第一个分区，则银行向用户发送打印凭条的消息，若用户执行第二个分区，则银行向用户发送返回的消息。 2.2ATM管理员部分 类：ATMadministrator、ATM 对象：管理员（主动对象）、银行。 消息描述：（以下涉及消息全为同步消息）。 （1）外层操作（登录系统、退出系统）： 管理员向银行发送登录的消息。 管理员向银行发送查询消息的消息。 银行向管理员返回显示消息的消息。 管理员向银行发送退卡的消息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8e490a7c80e7b4b66a1483e00191a99/" rel="bookmark">
			Android一些过时的(Deprecated)方法取代
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.ViewPager的 setOnPageChangeListener,新方法：addOnPageChangeListener 持续更新中……
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9caeb1ebb1dd44dbd19da4ede1f996f/" rel="bookmark">
			php实现的简单问卷调查系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		php实现的简单问卷调查系统 最近尝试用php写一个简单问卷调查系统，简单的实现自定义试卷题目，用户管理，普通用户和超级用户登录进入不同的界面，进行不同的操作。 废话不多说，直接看效果图吧： 下图是普通用户进入之后的进行答卷的操作效果如下： 下图是管理用户登录之后对后台数据进行管理操作的效果如下： 在其过程中碰到一个比较纠结的问题，就是mysql中文乱码的问题，注意在通过phpmyadmin建数据库时，其编码要为utf8_general_ci，再在表中各个要输入中文的字段的编码也要设置为utf8_general_ci，否则就会乱码，当然对mysql默认的编码配置，网上教程很多，这里就不做过多的介绍。 感兴趣的同学可以下载下来看看。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf358cd2e9a4a3a7c94df1c3dfe006f/" rel="bookmark">
			Android 延时操作的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Android开发中我们可能会有延时执行某个操作的需求，例如我们启动应用的时候，一开始呈现的是引导页面，3秒后进入主界面，这就是一个延时操作。
下面是实现延时操作的三种方法：
一、使用线程的休眠实现延时操作 new Thread(new Runnable() { @Override public void run() { Thread.sleep(1000); // 休眠1秒 /** * 延时执行的代码 */ } }).start(); 二、使用TimerTask实现延时操作 Timer timer = new Timer(); timer.schedule(new TimerTask() { @Override public void run() { /** * 延时执行的代码 */ } },1000); // 延时1秒 三、使用Handler的postDelayed()方法实现延时操作 new Handler().postDelayed(new Runnable() { @Override public void run() { /** * 延时执行的代码 */ } },1000); // 延时1秒 注：由于前两种在更新UI时，如果不使用消息处理机制的话，会报如下异常：Only the original thread that created a view hierarchy can touch its views.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf358cd2e9a4a3a7c94df1c3dfe006f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2cf8e44a634df801b54f0b7d8a0bf7c/" rel="bookmark">
			Single Shot Detection(SSD)bbox prediction相关的（超）参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考https://github.com/balancap/SSD-Tensorflow 记录SSD中与bbox prediction相关的（超）参数。 ssd_vgg_300.py SSDParameters( img_shape=(300, 300), num_classes=21, no_annotation_label=21, feat_layers=['block4', 'block7', 'block8', 'block9', 'block10', 'block11'], feat_shapes=[(38, 38), (19, 19), (10, 10), (5, 5), (3, 3), (1, 1)], anchor_size_bounds=[0.15, 0.9], anchor_sizes=[(21.0, 45.0), (45.0, 99.0), (99.0, 153.0), (153.0, 207.0), (207.0, 261.0), (261.0, 315.0)], anchor_ratios=[[2, 0.5], [2, 0.5, 3, 0.3333333333333333], [2, 0.5, 3, 0.3333333333333333], [2, 0.5, 3, 0.3333333333333333], [2, 0.5], [2, 0.5]], anchor_steps=[8, 16, 32, 64, 100, 300], anchor_offset=0.5, normalizations=[20, -1, -1, -1, -1, -1], prior_scaling=[0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2cf8e44a634df801b54f0b7d8a0bf7c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/117f153724f09a72f20ed74d576c7ce9/" rel="bookmark">
			腾讯云ubuntu配置ssl
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		腾讯云申请免费的SSL
域名解析那里设置腾讯云申请下来的记录号
下载腾讯云申请下来的证书
在ubuntu14.04上配置SSL证书
1.sudo a2enmod ssl
2.sudo service apache2 restart
3.sudo chmod 777 /etc/ssl
4.使用filezilla将下载的SSL证书上传到服务器文件夹/etc/ssl下面
5.cd /etc/ssl
6.sudo cp .crt文件 certs
7.sudo chmod 777 private
8.sudo cp .key文件 private
9.sudo chmod 710 private
10.sudo vim /etc/apache2/sites-enabled/000-default.conf
ServerName 域名
SSLEngine on
SSLCertificateFile /etc/ssl/certs/.crt
SSLCertificateKeyFile /etc/ssl/private/.key
SSLCACertificateFile /etc/ssl/bundle.crt
11.sudo /etc/init.d/apache2 force-reload
12.sudo /etc/init.d/apache2 restart
13.腾讯云添加安全组443端口
14.访问网站https://域名出现ssl连接错误
15.sudo vim /etc/apache2/sites-enabled/000-default.conf 80端口改为443
16. sudo vim /etc/init.d/apache2 restart
可以访问https了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d98c886e82e49af36cbd520ca44d5e32/" rel="bookmark">
			Vue2中的键盘事件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue2键盘事件：keydown/keyup...
1.使用
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;script src="vue.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; window.onload = function(){ var vm = new Vue({ el:'#box', methods:{ show:function(ev){ if(ev.keyCode == 13){ alert('你按回车键了'); } }, } }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt; &lt;input type="text" placeholder="请输入" @keyup="show($event)"&gt; &lt;input type="text" placeholder="请输入" @keyup.13="show($event)"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;当按下键盘的时候，执行show方法，然后再去执行相应的业务。 两个input的效果都是一样的 如果按13 也就是按键 enter 才会执行弹窗！！
@keyup.13 回车
@keyup.enter 回车
@keyup.left 左键
@keyup.right 右键
@keyup.up 上键
@keyup.down 下键
@keyup.delete 删除键
原文链接：http://www.cnblogs.com/zycbloger/p/6423132.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/329f2401e747d33e99c3c118bae80170/" rel="bookmark">
			机器学习各算法思想（极简版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		读到的一篇不错的文章，拿来和大家分享一下。 转自–头条公众号–极数蜗牛
（1）线性回归
回归最早是由高尔顿研究子女身高与父母身高遗传关系提出的，发现子女平均身高总是向中心回归而得名。其实“一分辛苦一分才”中就蕴含了线性回归算法思想，比较简单表现出才能与辛苦是正比关系。另外，经常听说“成功=3分才能+6分机会+1分贵人帮”，这是标准的线性回归方程，其中成功是因变量；才能、机会和贵人是自变量；而自变量前边的3、6和1是权重。
（2）K-聚类
中国有句古话是“物以类聚，人以群分”，其实已经蕴含了聚类算法的基本思想。比如说人，可以根据年龄分70后、80后、90后等；根据区域分北京、上海、广东等；根据性别分男和女。人可以根据不同特征属性进行划分，而在聚类算法中是根据不同方式来计算两个事物的距离，如欧氏距离、皮尔森相似度等。
假如根据年龄可以每10年份划分为70后、80后、90后等，也可以根据成长周期分童年、少年、青年、中年和老年。因此特征刻度大小决定了群体的范围，这反映在聚类算法中就是通过不同方法处理事物间距离，来确定事物属于哪个群体，如根据平均值、最大值等。
其中K值是表示划分群体的大小，如以区域为例，K=34，则划分为全国省份；K=7，则划分为东北，中原，华东，华北，华南，西北和西部等；K=2，则划分为南方和北方。
（3）K-邻近
中国还有句古话是“近朱者赤近墨者黑”，该句也蕴含了K-邻近算法的思想。比如判断一个人是否是有钱人，可以根据其最近联系的人群中，有钱人的比例来推测。这就需要解决两个问题，一是如何确定最近联系人，二是如何计算有钱人比例。这反映在K-邻近算法中就是首先确定不同事物样本的距离，然后确定K值的大小，根据K值内的有钱人占比，来预测未知用户的状态。
K值的大小将会直接决定预测结果，假如你有5个有钱人朋友，当K=8时，判定你为有钱人；但当K=12时，则判定你不是有钱人。因此在该算法中K的选择至关重要。
（4）朴素贝叶斯
“吃一亏长一智”反映了朴素贝叶斯算法思维，就是通过后验经验法，来对未知的预测。假如你经常买水果，发现10个青苹果里边8个都是酸的，而10个红苹果里有7个都是甜的，这种经验告诉以后再挑选苹果时，红苹果7/10是甜的，青苹果2/10是甜的，如果你喜欢甜的，那就选红苹果吧。
（5）决策树
在婚恋相亲时经常被问到“你有车吗？你有房吗？你有钱吗？”，这和决策树的思维过程极其相似。决策树是由树枝，树叶，节点组成的树型结构，其中每个节点就是一个问题或特征（如你有车吗？），每个树枝是问题的走向（如有），每个节点就是答案（相亲成功）。 （6）主成分分析
经常在网上看到两个字“干货”。那怎么定义“干货”，我觉得应该包括两方面：一是信息量大，二是没有废话。其实如何将“水货”制作成干货的过程，与主成分分析有异曲同工之妙。“干货”能够使原文到达“短小精悍”，而主成分分析能够实现数据集降维，即用较少维度表示原有样本含有的信息，两则都是通过其它语言或转变维度来表达原有信息。
“水货”变成“干货”就是将意思相近或相似的句子进行浓缩或提炼，也就是将“水货”里的的水分拧干；而主成分分析是根据样本集的协方差矩阵，通过线性变换将原数据映射到新的坐标系统，并将差异性较大特征值的保留，以到达降维目的。
（7）随机森林
“三个臭皮匠赛过诸葛亮”与随机森林算法内核类似。随机森林是是由一棵棵的决策树构成的，每决策树的形成都是随机的，它可以避免单一决策树过拟合和偏向的毛病。
再以相亲为例，对相亲对象要求，你可能看重“有房”“有车”“有钱”；你妈看重“有房”“孝顺”；你爸看重“事业”“顾家”“有车”等。其实你们每个人都是一个决策树，可根据自己判断标准决策出相亲对手是否“满意”，最后集合每个人的决策结果，来判断最后是否相亲成功。一个人相亲是决策树，全家人相亲就是随机森林。
（8）最大熵模型
“不要把鸡蛋放在一个篮子里”是最大熵模型比较朴素的说法，也反映了该算法的本质，就是对不确定的或未知的，尽量保持随机和均匀分布，能够将风险降到最低。其实在生活中大家应该都不自觉的应用了该模型。比如，去年P2P较火的时候，很多人被其高收益吸引，但由于P2P鱼龙混杂，又担心跑路；因此采取比较保险的举措，就是多投几家公司。
其实，熵是对无序状态的描述，而最大熵就是表示样本是均匀分布，可能性概率相同。
（9）AdaBoost
在学生时代，考试有个技巧就是构建自己的“错题本”，每次考试前都加强对“错题本”学习，通过不断强化“错题本”上题目，最终可能获得较高分数。其实这个学习过程与AdaBoost是算法逻辑是相同的。
假设每次考试作为一次模型训练，每道题目作为一个样本，分数作为预测准确率，而“错题本”就是预测错误的样本；当再次进行预测训练考试的时候，AdaBoost算法策略就是会对上次预测“错误的样本”加大权重，并以此不断迭代，通过多次训练，最后能够组合成一个较强的分类器（即考试高分）。
（10）关联规则
是否耳熟“我看你天赋异禀、骨骼惊奇，想来是百年难得一见的练武奇才”“贫道夜观天象，发现北斗星南移，天狼星耀青光，帝王星显现”等台词。其实这里边就蕴含了关联规则，通过经验积累发现骨骼与练武，北斗星与帝王等之间关联。
“用生辰八字来算命”虽然被成为伪科学，但偶尔能算准，这是这么回事？用关联规则算法就容易解释，首先理解两个概念支持度和置信度。
支持度是指A（某生辰八字）和B（某命运）同时发生的占比，如某生辰对应某命运的人数占总人数比值；置信度是指A发生后B发生的概率，如某生辰中当官的人数/某生辰总人数。如果置信度是100%，如果A发生，那么B一定发生。算命先生就将生辰和命运的置信度定为100%。
如果算命先生学过机器学习算法，就不会很肯定指出你将来一定当官，而是说你将来当官的支持度为20%，置信度为30%。
（11）逻辑回归
逻辑回归与线性回归都是广义线性模型，只所以在回归前加上“逻辑”，是因为他在线性回归的基础上穿上了一件马甲（转变函数）。比如人的成功公式： “成功=3分才能+6分机会+1分贵人帮”，但通过计算可能得出如1,5,99,200等各种数字，如果就想知道是否是成功人士，你就需要一个“成功评委”来对结果进行评价，最终输出量化指标，如成功率是80%，其中越接近100%，说明越成功。而这个“成功评委”就是一个转变函数。
（12）因子分析
中国有句古话是“三岁看老”和“性格决定命运”，这与因子分析的思维类似，就是将影响或决定事物的本质东西总结出来。网络上将有喝绿茶饮料，穿361运动鞋，周末在家打游戏，留着平头等特征行为的人，称为具有“屌丝”气质。因子分析过程也类似，就是对具有关联行为或相似事件，进行共性因子提取，将具有共同本质的特征行为归为一个因子。像土豪，即使有钱了，依然没有改变“土”的因子。
（13）人工神经网络
其实全国人民大会代表选举过程与人工神经网络运算流程是类似。首先由基层人民选取乡/县级人民代表，再有县级选举市级，由市级选举省级，最后产生全国人民代表。其实，在选举过程中，每个人/代表相当于人工神经网络的一个神经元，而县、市、省等行政级别，相当于人工神经网络的层级，最后选取的代表相当于输出结果。层级越多代表越复杂，深度学习就是多层神经网络。现在终于明白国家领导人考察农村，叫做深入基层。
（14）SVM（支持向量机）
以相亲为例，假如你根据学历，身高，年龄，相貌等指标，综合评估下来依然有较多候选人，你不知道这么办？这时候你闺蜜告诉你个方法：“就是看看他的父母和朋友情况”，这时候你豁然开朗，根据他的父母健康并是高官，朋友都年轻有为等指标，很快就确定了候选者。其实这个过程与SVM模型的思维逻辑相同的。SVM的核心思维就是将低维数据（一个人）映射到高维空间（多个人），从而实现数据可分（可选择）；你闺蜜的方法在SVM中就是核函数。这是一个拼“爹”的时代。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8df6f7b9d50c9190519a74d7ac4df5d/" rel="bookmark">
			Android源码--Settings之Preference布局的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 最近在研究Android源码Settings应用的时候发现里面使用了大量了的Preference布局，那么这个perference布局有什么特点呢。 Preference翻译为偏好，但理解为首先项更为合适，他可以把值用sharedPreference保存。 &lt;一&gt; Preference布局中常用的标签： 最近在研究Android源码Settings应用的时候发现里面使用了大量了的Preference布局，那么这个perference布局有什么特点呢。 Preference翻译为偏好，但理解为首先项更为合适，他可以把值用sharedPreference保存。 &lt;一&gt; Preference布局中常用的标签： PreferenceScreen:布局中的根节点，有点类似于LinearLayout,如果PreferenceScreen中嵌套PreferenceScreen，点击嵌套的PreferenceScreen会跳到另一个Screen。 PreferenceCategory:让布局更有层次感，比如图片中的红色字体部分。 &lt;二&gt; 常见的有CheckBoxPreference、EditextPreference、ListPreference等等。 &lt;三&gt; Preference的属性： key:每个preference的唯一标识，类似于view空间的ID，通过这个可以找到这个Preference控件
mListPreference=(ListPreference)findPreference("list"); title:Preference控件的标题，比如“语言” summary:Preference控件的子标题，比如“中国（简体）” defaultValue 默认值。例如，CheckBoxPreference 默认值可选“true”，表示默认选中状态； EditTextPreference 默认值写“110”，弹出的edit框中默认值为“110” enabled 表示该Preference控件是否可用状态 persistent 表示Preference所对应的值是否写入sharedPreference的文件中，true表示写入，false表示不写入 dependency 表示一个Preference(用A表示)的可用状态依赖另外一个Preference(用B表示)。B可用，则A可用；B不可用，则A不可用。写入的值为其他preference的key &lt;四、Preference监听事件&gt; Preference在activity中继承PreferenceActivity(API 11以后推荐PreferenceFragment )，PreferenceActivity中有一个总要的监听方法 onPreferenceTreeClick( ) 两个重要的监听接口： Preference.OnPreferenceChangeListener：onPreferenceChange( ) Preference.OnPreferenceClickListener: onPreferenceClick( )
那么这三个监听方法的执行顺序和区别又是什么呢？
当你点击Preference控件时首先会执行onPreferenceClick（）方法，它的返回值是boolean类型的，如果返回值为: true,该点击事件被消费掉，将不执行onPreferenceTreeClick( )方法 false,该点击事件没有被消费掉，将继续执行onPreferenceTreeClick( )方法
onPreferenceTreeClick( )的返回值也为Boolean类型，如果为： true:事件已经被成功消费，不用返回上一层继续执行，比如不会执行Preference里面的Intent跳转。 false:事件没有被消费，需要返回上一层继续执行，比如执行intent跳转。
onPreferenceChange( ) ，当preference控件的value改变时会触发这个监听方法，返回值为true就保存新值到sharedpreference中，返回值为false则不保存新值。
&lt;五、preference布局的添加已经控件的初始化&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e409a9d22ed805a74de90d5e4bd49269/" rel="bookmark">
			Android TypedValue.applyDimension()的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个方法的作用是 把Android系统中的非标准度量尺寸转变为标准度量尺寸 (Android系统中的标准尺寸是px, 即像素)
Android系统中的尺寸单位有: 标准单位: px (px是安卓系统内部使用的单位, dp是与设备无关的尺寸单位 )
非标准单位: dp, in, mm, pt, sp
TypedValue.applyDimension()方法的功能就是把非标准尺寸转换成标准尺寸, 如: dp-&gt;px: TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, context.getResources().getDisplayMetrics());
in-&gt;px: TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_IN, 20, context.getResources().getDisplayMetrics());
mm-&gt;px: TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_MM, 20, context.getResources().getDisplayMetrics());
pt-&gt;px: TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_PT, 20, context.getResources().getDisplayMetrics());
sp-&gt;px: TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 20, context.getResources().getDisplayMetrics());
如果你还是不太理解, 请看applyDimension()方法的源码: /** * Converts an unpacked complex data value holding a dimension to its final floating * point value. The two parameters &lt;var&gt;unit&lt;/var&gt; and &lt;var&gt;value&lt;/var&gt; * are as in {@link #TYPE_DIMENSION}.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e409a9d22ed805a74de90d5e4bd49269/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b85859dc4a31efa629ecf589280458/" rel="bookmark">
			区间覆盖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		区间覆盖问题 Time Limit: 1000MS Memory Limit: 65536KB Submit Statistic Problem Description 用i来表示x坐标轴上坐标为[i-1，i]的长度为1的区间，并给出n（1≤n≤200）个不同的整数，表示n个这样的区间。
现在要求画m条线段覆盖住所有的区间，
条件是：每条线段可以任意长，但是要求所画线段的长度之和最小，
并且线段的数目不超过m(1≤m≤50）。
Input 输入包括多组数据，每组数据的第一行表示区间个数n和所需线段数m，第二行表示n个点的坐标。
Output 每组输出占一行，输出m条线段的最小长度和。
Example Input 5 3 1 3 8 5 11 Example Output 7 Hint Author ///区间覆盖问题 #include&lt;stdio.h&gt; void asort(int a[],int n) { for(int i=0;i&lt;n-1;i++) { for(int j=0;j&lt;n-i-1;j++) { if(a[j]&lt;a[j+1]) { int t=a[j]; a[j]=a[j+1]; a[j+1]=t; } } } } int main() { int n,m; int a[210],b[210]; while(~scanf("%d %d",&amp;n,&amp;m)) { for(int i=0;i&lt;n;i++) { scanf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57b85859dc4a31efa629ecf589280458/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5714e3580cf9fb2d0a39c7f0905285ba/" rel="bookmark">
			2017华为实习生招聘面试经历（IT应用软件 c&#43;&#43;）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 由于我有华为软件精英挑战赛绿卡，所以直接二面。,
1，问了华为软件精英挑战赛的情况，自己的角色。
2，说一次自己印象比较深刻的项目。
3，问自己有没有遇到什么困难，压力。
4，对华为有什么了解
5，除了编程，对其他的是否感兴趣。
6，对Java编程是否熟悉，
7，问了成绩情况
8，问我有没有什么想问的？
然后我就问了这个岗位主要是负责华为哪些产品，是在哪个平台下，什么架构
Java，Python，主要是在Hadoop，也有spark，openstack。
最终结果：待更新，整个面试过程感觉还行吧。 20170422今天下午收到了通过了的短信，进入了资源池 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b54c152cbf3ffc29318988ee8d3080c/" rel="bookmark">
			golang string 和 int 的互相转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		string 转 int 要 import strconv import ( "fmt" "strconv" ) func test(x int, y string) string { var res string //strconv.Itoa 就是将 int 类型 转成 stirng res = strconv.Itoa(x) + y return res } int 转成 string func test2(x int, y string) int { //strconv.Atoi 就是将 string 类型 转成 int i, err := strconv.Atoi(y) if err != nil { panic(err) } i = i + x return i } 最后 测试一下 fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b54c152cbf3ffc29318988ee8d3080c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c471bbc412c8a1dffa27c8497bd751fa/" rel="bookmark">
			Retrofit2使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 A type-safe HTTP client for Android and Java,一种类型安全的Http联网构架。
出品公司Square，项目地址。
项目导入 compile 'com.squareup.retrofit2:retrofit:2.2.0' 需android 2.3以上
网络请求步骤 1.创建一个接口,设置请求的类型与参数 接口中创建一个方法，返回一个Call对象，泛型是网络请求返回的数据转换成实体类对象集合，用注解来确定请求是GET还是POST
public interface GitHubService { @GET("users/{user}/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user); } 2.创建一个Retrofit对象 baseUrl()方法一般放置地址的主体部分，以/结尾
Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .build(); 3.生成一个接口实现对象 调用retrofit的create方法，传入第一步创建的请求接口，生成一个请求接口的实现对象
GitHubService service = retrofit.create(GitHubService.class); 4.生成一个Call实例对象 调用请求接口的对象方法可以生成一个Call对象实例，到这一步就可以得到最后的请求地址了。
Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos("octocat"); 这是一个Get请求，传的是Path的参数，所以最后的请求地址拼接起来就是https://api.github.com/users/octocat/repos
5.发送请求 调用Call实例对象的方法就可以发送联网请求了，有两种方式，一种是同步请求，一种是异步请求。
同步请求 调用execute()方法，需要捕捉异常，返回结果的响应体，泛型为接口类中定义方法里返回类的泛型一样
try { Response&lt;List&lt;Repo&gt;&gt; response= repos.execute(); } catch (IOException e) { e.printStackTrace(); } 该方法源码解释
/** * Synchronously send the request and return its response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c471bbc412c8a1dffa27c8497bd751fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b00c6618bc6d4fb08e7850cf07a05359/" rel="bookmark">
			Gitlab部署CI并使用.gitlab-ci.yml配置您的作业(中文翻译)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文档描述了.gitlab-ci.ymlGitLab Runner用于管理项目作业的文件的用法。
如果您想快速介绍GitLab CI，请按照我们的 快速入门指南。
.gitlab-ci.yml 从版本7.12，GitLab CI使用YAML 文件（.gitlab-ci.yml）进行项目配置。它放置在存储库的根目录中，并包含如何构建项目的定义。
YAML文件定义了一组具有约束的作业，说明何时应该运行它们。作业被定义为具有名称的顶级元素，并且必须至少包含script子句：
job1: script: "execute-script-for-job1" job2: script: "execute-script-for-job2" 上述示例是具有两个单独作业的最简单的CI配置，其中每个作业执行不同的命令。
当然，命令可以直接（./configure;make;make install）执行代码，也可以test.sh在存储库中运行一个script（）。
工作由跑步者拾起并在跑步者的环境中执行。重要的是每项工作都是独立运作的。
YAML语法允许使用比上述示例中更复杂的作业规范：
image: ruby:2.1 services: - postgres before_script: - bundle install after_script: - rm secrets stages: - build - test - deploy job1: stage: build script: - execute-script-for-job1 only: - master tags: - docker 有一些保留keywords是不能被用作作业名：
关键词 需要 描述图片没有使用泊坞窗图像，满身是使用泊坞窗服务没有使用泊坞窗服务，覆盖在使用泊坞窗阶段没有定义构建阶段类型没有别名stages（已弃用）before_script没有定义在每个作业的脚本之前运行的命令after_script没有定义在每个作业的脚本之后运行的命令变量没有定义构建变量缓存没有定义应该在后续运行之间缓存的文件列表 形象和服务 这允许指定一个自定义的Docker映像和一个可以用于作业时间的服务列表。此功能的配置在 单独的文档中介绍。
before_script before_script用于定义在所有作业（包括部署作业）之前但在恢复工件之后应运行的命令。这可以是数组或多行字符串。
after_script 在GitLab 8.7中引入，需要Gitlab Runner v1.2
after_script用于定义将在所有作业之后运行的命令。这必须是一个数组或多行字符串。
阶段 stages用于定义作业可以使用的阶段。的说明书stages允许具有灵活的多阶段流水线。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b00c6618bc6d4fb08e7850cf07a05359/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09d19577a7a019d415292640823c85e1/" rel="bookmark">
			文件系统层次结构标准(FHS)(for Linux)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇文章为维基百科中关于FHS的译文，原文见 wiki:https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard
ubuntu中:http://manpages.ubuntu.com/manpages/precise/en/man7/hier.7.html
由spawpaw@hotmail.com翻译，转载需注明出处 原文备份：http://blog.csdn.net/qq_29753285/article/details/69790931 本文更新地址：http://blog.csdn.net/qq_29753285/article/details/69791332 (csdn解析markdown有点问题..有点影响阅读…) 像这类解释性的文章还是建议大家看原文。
Filesystem Hierarchy Standard (FHS)由linux基金会维护， 目前(2017-4-9)，FHS的最新版本为3.0，可从http://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf下载
文件系统层次结构标准-简介 开发者 Linux基金会 初始版本 1994年2月14日 最新版本 3.0 (2015年6月3日) 网站 官网
文件系统层次结构标准 (FHS) 定义了在类Unix系统中的目录结构和目录内容。它由Linux基金会维护，最新版为2015年六月三日发布的3.0版，仅用于Linux的各类发行版中。
目录结构 在FHS中，所有的（包括存储于不同物理/虚拟设备中的）文件和目录都存在于根目录 / 下。其中，部分目录仅当特定系统（如X Window）安装后才会存在。
下表中大部分目录都以相似的功能存在于所有的UNIX系统中。但是，以下的描述仅针对FHS，且对非Linux系统并非权威
/ 主层次结构的根&amp;&amp;整个文件系统的根目录 /bin 所有用户在单用户模式中必须具备的二进制命令文件，如 cat, ls, cp./boot Boot loader文件，如 kernels, initrd./dev　必要的 device 文件,如 /dev/null./etc 特定主机 全系统 的配置文件 一直以来,这个名字本身就有争议。在早期由Bell labs所撰写的UNIX实现文档中，/etc 被当作附加(etcetera)目录，因为历史上这个文件夹用来保存所有不属于其他地方的文件（但FHS限制/etc仅用于保存静态配置文件，不能保存二进制文件）。从早期的文档发布以来，这个文件夹的名字就被人们以不同的方式重新定义。最近的释义包括如”Editable Text Configuration” 或 “Extended Tool Chest”词源 /etc/opt　保存在/opt/中的插件包的配置文件/etc/sgml 处理SGML的程序（如catalogs）的配置文件/etc/X11 X Window System, version 11 的配置文件/etc/xml　处理xml的程序（如catalogs）的配置文件/home　用户的个人目录，包含保存的文件和个人设置等/lib /bin/ 和/sbin/ 中必须的依赖库/lib Alternate format essential libraries.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/09d19577a7a019d415292640823c85e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/481f973d44ac295382887fb0cecc07ce/" rel="bookmark">
			Filesystem Hierarchy Standard （Linux文件系统层次标准）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中文译文：文件系统层次结构标准(FHS)(for Linux) 本片文章的内容完全从wiki上复制过来,仅排版有所不同 , 完整内容请转至 wiki:https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard
由spawpaw@hotmail.com整理， 本文更新地址：http://blog.csdn.net/qq_29753285/article/details/69790931 Filesystem Hierarchy Standard (FHS)由linux基金会维护， 目前(2017-4-9)，FHS的最新版本为3.0，可从http://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.pdf下载
Filesystem Hierarchy Standard Developed by Linux Foundation Initial release 14 February 1994 Latest release 3.0 (3 June 2015) Website Official website
The Filesystem Hierarchy Standard (FHS) defines the directory structure and directory contents in Unix-like operating systems. It is maintained by the Linux Foundation. The latest version is 3.0, released on 3 June 2015. Currently it is only used by Linux distributions.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/481f973d44ac295382887fb0cecc07ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ba512d1ab5c5e302ebfd4a8ffb0990/" rel="bookmark">
			同一台服务器(电脑)运行多个Tomcat的设置方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 大多人在Windows平台用的Tomcat都是免安装版本的，很自然想到复制几份目录，就是在同一个电脑上跑多个Tomcat服务了。实际上是不可以的。经过如下方法就可以实现统一台服务器(电脑)上运行多个Tomcat的目的了。 1、配置电脑”环境变量” 单个Tomcat的配置步骤不再重述，直接从配置第二个Tomcat开始。对电脑”环境变量”做调整，增加环境变量CATALINA_HOMEB，值为新的tomcat的地址。 2、更改Tomcat的 catalina.bat、startup.bat、shutdown.bat 把如上提到的三个文件里的CATALINA_HOME常量改为CATALINA_HOMEB，参见下图： 3、修改server.xml内的三个端口 经过如上三个步骤就可以在同一台服务器(电脑)上同时运行多个Tomcat服务了，我这边是以两个Tomcat为例子来操作的，分别启动两个Tomcat的bin目录下的startup.bat， 运行效果如下图： 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/476/">«</a>
	<span class="pagination__item pagination__item--current">477/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/478/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>