<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68a95afb5fc94b75b94f7b7a27adec93/" rel="bookmark">
			Springboot过滤器和拦截器详解及使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、过滤器和拦截器的区别 1、过滤器和拦截器触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。
2、拦截器可以获取IOC容器中的各个bean，而过滤器就不行，因为拦截器是spring提供并管理的，spring的功能可以被拦截器使用，在拦截器里注入一个service，可以调用业务逻辑。而过滤器是JavaEE标准，只需依赖servlet api ，不需要依赖spring。
3、过滤器的实现基于回调函数。而拦截器（代理模式）的实现基于反射
4、Filter是依赖于Servlet容器，属于Servlet规范的一部分，而拦截器则是独立存在的，可以在任何情况下使用。
5、Filter的执行由Servlet容器回调完成，而拦截器通常通过动态代理（反射）的方式来执行。
6、Filter的生命周期由Servlet容器管理，而拦截器则可以通过IoC容器来管理，因此可以通过注入等方式来获取其他Bean的实例，因此使用会更方便。
过滤器和拦截器非常相似，但是它们有很大的区别
最简单明了的区别就是**过滤器可以修改request，而拦截器不能
过滤器需要在servlet容器中实现，拦截器可以适用于javaEE，javaSE等各种环境
拦截器可以调用IOC容器中的各种依赖，而过滤器不能
过滤器只能在请求的前后使用，而拦截器可以详细到每个方法**
区别很多，大家可以去查下
总的来说
过滤器就是筛选出你要的东西，比如requeset中你要的那部分
拦截器在做安全方面用的比较多，比如终止一些流程
网上有一张图片很不错，这里拷过来给大家看一下
过滤器（Filter） ：可以拿到原始的http请求，但是拿不到你请求的控制器和请求控制器中的方法的信息。
拦截器（Interceptor）：可以拿到你请求的控制器和方法，却拿不到请求方法的参数。
切片（Aspect）: 可以拿到方法的参数，但是却拿不到http请求和响应的对象
二、过滤器 两种方式： 1、使用spring boot提供的FilterRegistrationBean注册Filter 2、使用原生servlet注解定义Filter 两种方式的本质都是一样的，都是去FilterRegistrationBean注册自定义Filter
方式一: （使用spring boot提供的FilterRegistrationBean注册Filter ）
①、先定义Filter：
package com.corwien.filter; import javax.servlet.*; import java.io.IOException; public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // do something 处理request 或response // doFilter()方法中的servletRequest参数的类型是ServletRequest，需要转换为HttpServletRequest类型方便调用某些方法 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68a95afb5fc94b75b94f7b7a27adec93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3db6f70561db75ef6f53d280c2c6ecc/" rel="bookmark">
			【图形学】实验一 OpenGL基本绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验一 OpenGL基本绘制 实验内容 在Windows系统下完成OpenGL的环境配置，编译并成功运行你的OpenGL程序。在其中使用现代OpenGL中的着色器，绘制多个简单的二维图形，参考下图所示：
具体内容包括：
1. OpenGL的环境配置 参考上机实验1.1的内容，完成Visual Studio 集成开发环境的安装，GLUT库与GLEW库的编译与配置，工程项目的搭建。
我用的是Clion，配置的CMakeLists.txt
# cmake version cmake_minimum_required(VERSION 3.1) # c++11 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED ON) set(CMAKE_CXX_EXTENSIONS OFF) # vcpkg if(DEFINED ENV{VCPKG_ROOT} AND NOT DEFINED CMAKE_TOOLCHAIN_FILE) set(CMAKE_TOOLCHAIN_FILE "$ENV{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake" CACHE STRING "") endif() if(DEFINED ENV{VCPKG_DEFAULT_TRIPLET} AND NOT DEFINED VCPKG_TARGET_TRIPLET) set(VCPKG_TARGET_TRIPLET "$ENV{VCPKG_DEFAULT_TRIPLET}" CACHE STRING "") endif() # project project(main) # target aux_source_directory("./" PROJECT_SOURCES) add_executable(main ${PROJECT_SOURCES}) target_include_directories(main PRIVATE include) if(APPLE) # dependency include_directories(/System/Library/Frameworks) find_library(OpenGL_LIBRARY OpenGL) find_library(GLUT_LIBRARY GLUT) set(LIBS ${OpenGL_LIBRARY} ${GLUT_LIBRARY}) # link target_link_libraries(main ${LIBS}) else() # dependency find_package(GLEW REQUIRED) find_package(GLUT REQUIRED) # link target_link_libraries(main PRIVATE GLUT::GLUT) target_link_libraries(main PRIVATE GLEW::GLEW) endif(APPLE) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3db6f70561db75ef6f53d280c2c6ecc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89604b232844f5e7d910d03f33b2f6fb/" rel="bookmark">
			Redis持久化原理及最佳实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Redis是内存型数据库，但是为了数据安全，就需要有“数据持久化”（就是将数据存储在磁盘上）的机制，在备份方面提供了两种工具，分别为RDB(快照)和AOF(写日志)。
持久化方法 RDB: 将当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时只需要把dump.rdb这个文件放到redis的dir目录下，启动服务，将快照文件直接读到内存里。注意文件的优先级
AOF：记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。
如果把redis当作缓存使用的话，你甚至可以关闭持久化功能，让数据只在服务器运行时存在。(redis4.0混合持久化)
RDB 触发条件 redis&gt; save #同步，容易阻塞。文件策略:先生成一个新的文件，待同步完成，再替换老的文件
redis&gt; bgsave #异步，不会阻塞redis，但是会fork新进程。文件策略：先生成一个新的文件，待同步完成，再替换老的文件
save 900 1 触发条件 (建议禁用),触发bgsave
save 300 10 触发条件 (建议禁用),触发bgsave
save 60 10000 触发条件 (建议禁用),触发bgsave
全量复制，debug reload,shutdown时也是触发生成rdb文件 #触发bgsave
运作过程 当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作：
Redis 调用 fork() ，同时拥有父进程和子进程。
子进程将数据集写入到一个临时 RDB 文件中。
当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。
RDB优缺点 优点：备份文件非常紧凑，体积小，在恢复大数据集时的速度比AOF快。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89604b232844f5e7d910d03f33b2f6fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c116df4210de1ddb654d6ea73ed176e3/" rel="bookmark">
			Command vue init requires a global addon to be installed.   Please run yarn global add @vue/cli-in报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Command vue init requires a global addon to be installed.
Please run yarn global add @vue/cli-init and try again.
创建脚手架项目报错；
解决办法是npm install -g @vue/cli-init然后在创建；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8a92b298af49a04f9e9962125570fe2/" rel="bookmark">
			git push 时 报error: src refspec main does not match any.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题原因：
当前的本地git仓库为空仓库，需要将本地文件添加进本地git仓库，然后push。
解决方法：
在本地仓库执行：
git add . git commit -m "git init" git push -u origin master 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e16fdc69d3874cf1268c3f644416dd60/" rel="bookmark">
			xml文件给前端完成一个预览效果的功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：xml中的节点值不固定，一些固定的模板也就放弃了
2：用模板等解析又需要增加依赖，工程体积又会增加
3：直接将xml转html再转pdf遇到格式丑爆了，中文消失等问题
4：直接后台处理字符串返给前端，前端用一层一层的div来包裹解决显示问题。
java代码，对&lt;&gt; \t完成转义字符的处理，xml的file文件中每一行的显示效果符合html的解析方式
List&lt;String&gt; lines=Files.lines(Paths.get(filePath)).map(e-&gt;{ e=e.replaceAll("&lt;", "&amp;lt;") .replaceAll("&gt;", "&amp;gt;") .replaceAll("\t", "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;") .replaceAll("'", "&amp;quot;"); return e; } ).collect(Collectors.toList()); 前端代码
用异步返回的结果list遍历添加的div
'&lt;div style ="word-break:break-all;word-wrap:break-word; white-space:normal;border:0px solid black"&gt;' + response[i]+ "&lt;/div&gt;" 3。既然我的html出来了，我再试试直接用生成pdf的工具试试，引入依赖
&lt;!-- 引入xmlWorkHelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.itextpdf.tool&lt;/groupId&gt; &lt;artifactId&gt;xmlworker&lt;/artifactId&gt; &lt;version&gt;5.5.8&lt;/version&gt; &lt;/dependency&gt; 搬运网络代码稍加修改
参考了这位大佬的代码https://www.cnblogs.com/soren-wanglu/articles/10534638.html
public static File pdfProcess(String htmlString, String pdfFileAimPath) throws Exception { File file = new File(pdfFileAimPath); Document document = new Document(PageSize.A4); PdfWriter pdfWriter = PdfWriter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e16fdc69d3874cf1268c3f644416dd60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/263e38cda59c7d4a057487e733f156a7/" rel="bookmark">
			寄存器和存储器的区别_PLC S7-200存储器类型，你了解多少
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		变量存储器 V
变量存储器是最常用的存储器。可以用它存储程序执行过程中控制逻辑操作的中间结果，也可以用它来保存与工序或任务相关的数据。并且可以按位、字节、字或双字来存取变量存储区存储区中的数据。不同型号的CPU的V存储区的大小不一样。
标志存储器(位存储器) M
M存储区在功能和用法上与V存储区类似，但是M存储区很小，只有32个字节。M存储区有一点特殊，对于MBO-MB13这14个字节可设置成保存在EEPROM里永久保持
局部存储器 L
局部存储器和变量存储器很相似，但只有一处区别。变量存储器是全局有效的，而局部存储器只在局部有效。全局是指同一个存储器可以被任何程序存取( 包括主程序、子程序和中断服务程序)。局部是指存储器区和特定的程序相关联。
注意:局部存储器是根据需要由CPU动态分配的。当发生中断或者调用一个子程序时，CPU才会分配局部存储器给中断程序或子程序。局部存储器( TEMP和0UT)在分配时CPU不进行初始化，初值可能是任意的。所以在使用局部存储器时，一定要注意先附值，后使用。
系统存储器 SM
系统存储器为CPU与用户程序之间传递信息提供了一种手段。可以用这些系统存储器来选择和控制S7-200CPU的一些特殊功能。
例如：
SM0.0 ：始终接通
SM0.1 ：仅在首次扫描周期接通
SM0.2 ：如果保持数据丢失，接通一个扫描周期
SM0.3 ：从上电进入RUN模式时，接通1个扫描周期
SM0.4 ：针对1分钟的周期时间，时钟脉冲接通30s，断开30 s。
SM0.5 ：针对1s的周期时间，时钟脉冲接通0.5s， 断开0.5 s。
SM0.6 ：扫描周期时钟，一个扫描周期接通，下一个扫描周期关断
SM0.7 ：如果实时时钟设备的时间被重置或在上电时丢失(导致系统时间丢失) ,则该位将接通一个扫描 周期。 该位可用作错误存储器位或用来调用特殊启动顺序。
SM1.0 ：特定指令的操作结果=0时，置位为1
计数器 C
高速计数器 HC
计数器适用于低速度，例如：每秒几个或几十个脉冲信号。
高速计数器适用于高速度，例如：每秒几千或几万个脉冲信号。
累加寄存器 AC
累加器是可以像存储器一样使用的存储区。例如，可以用它来向子程序传递参数，也可以从子程序返回，以及用来存储计算的中间结果。S7-200提供4个32位累加器(ACO，AC1， AC2和AC3)。并且可以按字节、字或双字的形式来存取累加器中的数值。被访问的数据长度取决于存取累加器时所使用的指令
顺序控制继电器 S
在顺序控制过程中，用于组织步进过程的控制。
下图是S7-200 CPU存储器范围及其特性(摘自《S7-200 可编程序控制器系统手册》)
下图是S7-200 CPU的操作数范围(摘自《S7-200 可编程序控制器系统手册》)
注：文中如有侵权，私信小编删除
如有补充或指教，请在评论区留言，小编及时更正！！！
看都看了，给小编点个赞，关注一下！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d31b907b82e0dbebb11bccc8dad3d15/" rel="bookmark">
			小小程序员的第一篇笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python函数第一篇笔记 一、函数的定义：所谓函数，就是把具有独立功能的代码块组织成为一个小模块，在需要的时候调用。
1、输入输出函数
print函数：输出指定的汉字
print("hello python")	字符串相加连接：
print("hello","你好")# 使用”,“进行连接 print("he" + "llo")# 字符串相加，进行字符串的连接，且不产生空格 print(10+30)# 没有使用引号括起来，默认为数值，若是使用引号括起来，就是字符串 # 若是数值使用加号连接，默认是表达式进行计算，返回计算的结果 print("hello"+1) #会报错 # 不同类型的数据不能使用加号连接 # 不同类型的数据能够使用”,“进行连接 print("1 2 3",2+3) # 输入 # input() # 带有提示信息的输入 # name = input("请输入您的姓名：") # print(name) 2、input()函数
Python提供了一个input()函数，可以让用户输入字符串，并且存放在变量中，比如输入用户名
&gt;&gt;&gt; name = input("place enter your name") place input your name jean &gt;&gt;&gt; print("hello,", name) hello, jean 3、自定义函数
自定义函数通过def关键字定义。def关键字后就是函数的标识符也是函数名，函数提供的数日接口就是函数名后面的圆括号，圆括号中是变量名，在函数中称为参数，一个函数的参数数量视函数的功能决定。
二、python四种参数
1、位置参数
def fun1(a,b,c): print(a,b,c) fun1(1,2,3)#输出结果123 2、序列传参
def fun2(a,b,c): print(a,b,c) l=[1,2,3] t=(4,5,6) fun2(*1) fun2(*t)#输出结果123 456 3、关键字传参
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d31b907b82e0dbebb11bccc8dad3d15/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6ffcb95b5acd29839d83ed845801ec1/" rel="bookmark">
			第45届国际大学生程序设计竞赛(ICPC)亚洲网上区域赛模拟赛 E Eat Walnuts（区间dp）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链接：https://ac.nowcoder.com/acm/contest/8688/E
来源：牛客网
时间限制：C/C++ 2秒，其他语言4秒
空间限制：C/C++ 65536K，其他语言131072K
64bit IO Format: %lld
题目描述 As we all know, in the ACM ICPC held in 2017, the organizer of Xinjiang University presented a box of walnuts to each coach. Our coach is happy to share with the team members except Mr.Watermelon. He is going to test Mr.Watermelon with a game when Mr.Watermelon want to eat some walnuts.
He put some walnuts in a row and let Mr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6ffcb95b5acd29839d83ed845801ec1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60114a7174420aa4fb8ec870ad7d3f10/" rel="bookmark">
			Roboware Studio详细安装教程 （ROS kinetic）以及简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RoboWare Studio是一个ROS集成开发环境。它使 ROS开发更加直观、简单、并且易于操作。可进行ROS工作区及包的管理、代码编辑、构建及调试。
安装包下载 1 RoboWare官网：http://www.roboware.me/#/home（自己尝试过，暂时登不进去）
2 官方GitHub链接： https://github.com/TonyRobotics/RoboWare
准备工作 依次执行下边的命令，进行相关的准备工作，下面的部分将会详细解释的。
sudo apt-get install build-essential sudo apt-get install python-pip sudo python -m pip install pylint sudo apt-get install clang-format-3.8 安装前，请查看系统环境并确认：
（1）操作系统 为 Ubuntu。
（2）已完成ROS的安装配置。ROS安装步骤可参照官方网站：
http://wiki.ros.org/kinetic/Installation/Ubuntu （3）可使用 catkin_make 构建ROS包。若无法构建,可能需要运行：
$ sudo apt-get install build-essential （4）为支持 Python 相关功能，需要安装 pylint。
$ sudo apt-get install python-pip $ sudo python -m pip install pylint （5）为支持 clang-format 相关功能，需要安装 clang-format-3.8 或更高版本。
$ sudo apt-get install clang-format-3.8 安装 下载Roboware Studio最新版，在下载的文档下，鼠标右键调出终端输入：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60114a7174420aa4fb8ec870ad7d3f10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06dcced32fe476de058c2a32edce0467/" rel="bookmark">
			Python基础语法知识3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、序：2、输入函数input()3、Python中的运算符3.1 算术运算符3.2 赋值运算符（=）3.3 比较运算符3.4 布尔运算符3.5 位运算符中的左右运算符 1、序： 到现在访问量超过2000了，真的非常感谢各位的支持和鼓励，我也会继续和大家分享学习Python的相关知识和经验，也会用心写好每一篇文章，也希望各位看完后能够有所裨益，如我有任何纰漏各位前辈和同学也可以在评论区指出，我也一定会虚心接受并在后续改正，如对文章的编写有所建议也希望各位不吝赐教；好啦，下面开始我们今天的基础语法分享啦，可不要犯困哟。（ps：今天学习下了排版，可能会比之前美观一丢丢）
2、输入函数input() Python入门基础语法知识1中讲到了输出函数print(),为了实现人机交互当然少不了输入函数input()啦；输入函数input()的作用是：接受来自用户的输入；它的输入值得类型为str类型；通过=将输入的值进行储存，将输入的值储存在=左边的变量名中；由于input函数输入的是str类型，所以在特定情况需要进行数据类型的转化；详情见下述代码（下述input函数会比较基础，后续会有内容深入）： # 开发时间:2020/11/2 22:19 name=input('What\'s your name?') # 将输入的值储存在变量名name中 print(name) # 由于input函数输入的是str类型，所以在特定情况需要进行数据类型的转化 n1 = int(input('请输入第一个整数：')) # int(xxxxx) 将input输入的str类型转换成int（整数） n2 = int(input('请输入第二个整数：')) print(n1 + n2) 运行结果如下： E:\Python\python.exe E:/py/CSDN博客/语法3.py What's your name?Jack Jack 请输入第一个整数：3 请输入第二个整数：4 7 Process finished with exit code 0 3、Python中的运算符 3.1 算术运算符 算数运算符简单的为：加减乘除幂，由于加减乘除幂没太多值得注意的，所以不展开论述（我觉得主要是除法的除数不能为零）；除法的商的数据类型是float类型（就算除数和被除数都是整数且没有余数），输出结果也是浮点数；取余运算（%），简言之也就是取余数，其公式为：余数=被除数-除数*商；整除（//），整除的结果是小于等于（&lt;=）商的最小整数，如：5//2=2 （小于5/2的商2.5） 5//-2=-3 （小于5/-2的商-2.5），一正一负向下取整；详情见下述代码： # 开发时间:2020/11/2 22:19 # 算术运算符 print(1 + 1, '\t', 3 - 2, '\t', 3 * 2, '\t', 4 / 2,type(4/2)) # 为了避免文章页面过长，就将加减乘除放在一起 print(3 % 2, '\t', 15 % -6) # 取余运算 余数=被除数-除数*商 print(3 // 2, '\t', 3 // -2) # 取整运算 一正一负往下取整 运行结果如下： E:\Python\python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06dcced32fe476de058c2a32edce0467/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b2e882de6983cd006b1624c07fe80a2/" rel="bookmark">
			显存不足
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import tensorflow as tf
import numpy as np
import keras
config = tf.compat.v1.ConfigProto(allow_soft_placement=True)
config.gpu_options.per_process_gpu_memory_fraction = 0.3
tf.compat.v1.keras.backend.set_session(tf.compat.v1.Session(config=config))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2b1d3ff9f46f15f598f7baf352dde4c/" rel="bookmark">
			delphi 数字识别_基于STM32单片机的车牌识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系统介绍 使用STM32F103RCT6作为主控，摄像头使用OV7670（带FIFO）。STM32进行了16倍频。识别过程分别为：图像采集，二值化，识别车牌区域，字符分割，字符匹配。
识别过程分析 1.图像采集： 通过OV7670摄像头进行图像采集，采集的图像大小为320*240像素，像素格式为RGB565。每个像素由两字节组成，第一字节的高五位是Red，第一字节的低三位和第二字节的高三位组成Green，第二字节的低五位是Blue。
2.二值化： 二值化就是让图像的像素点矩阵中的每个像素点的灰度值为0（黑色）或者255（白色），让整个图片呈现出只有黑色和白色的效果。二值化后的图像中灰度值范围是0或者255。
怎样让像素点的灰度值转为0或者255？假如灰度值为220的一个像素点，二值化后应该为0还是255？这时候需要设定一个阈值来对像素点进行设置。
常用二值化方法：
1、取中值
设置阈值为127，灰度值小于127的为0，大于127的为255。这样设置计算量小，计算快。缺点也严重：在不同的图像中，颜色分布差别大，处理效果也不会很好。
程序开始之前设置R,G，B的阈值，通过阈值判断将像素设置为全黑（0x0000）或者全白（0xFFFF）.同时根据色彩的变化记录每一行的颜色跳变点，由此识别出车牌区域。
2、取平均值
像素点平均值 = （像素点1灰度值 + 像素点2灰度值 + …… + 像素点n灰度值） / n
3、双峰法
此方法适用于具有明显双峰直方图的图像，不适合直方图中双峰差别很大或双峰间的谷比较宽广而平坦的图像。该方法认为图像由前景和背景组成，在灰度直方图上，前景和背景会形成高峰，在双峰之间的最低谷处就是阈值。
3.识别车牌区域： 根据上一步的二值化，由于车牌区域跳变点多，由此可以得出车牌区域。分别记录车牌区域的上下高度。然后通过RGB-HSV颜色转换，识别出车牌区域的左右边界。
4.字符分割： 我国常见车牌以及排列顺序大部分都是按照如下设计的：汉字、英文字母、点、英文字母、阿拉伯数字、阿拉伯数字、阿拉伯数字、阿拉伯数字。基于这个规律，以及图像采集高度一致，设计了如下的分割方法：
1、在内存中开辟七个长为车牌长的七分之一和宽为车牌宽的区域
2、从车牌图像长边的巾问向下开始扫描车牌图像，并把扫描到的所有的点灰度值复制到0区域的第四个区域对应位置上。然后再从上向下扫描刚扫描过这一努的左边或右边，直到所扫描的这一峰上的所有点的灰度都是0时为止,并把这一竖认为是字符的分离处。
3、切割第五到第七个字符。方法就是，切割完了第四个字符之后，再依次扫描剩下的空间，直到所扫描的这一竖上的所有点的灰度值不全为0时，认为是字符的开始并依次扫描直到所扫描的这一竖上的所有点的灰度值全为0时认为是字符的结束。
4、切割第三到第四个字符。这两个字符的切割方式与第五到第七个字符一样。
5、切割第一到第二个字符。当第三个字符切割完之后，我们将遇到一个点，我们也把它看作一个字符，只不过这个点扫描之后就不要了。扫描完这个点之后，我们来切割第二个字符，它的切割方式与前面一样。切割完了第二个字符之后，再向左扫描，直到所扫描的这一竖上的所有点的灰度值不全为0时，认为是字符的开始，并依次扫描直到所扫描所有剩下的，并填到相应的位置，直到剩下的空间填满。经过粗分割后，可以得到一些单个字符区域和多余的空间。下一步我们将把这些多余的空间去掉。这将更有利于下一步字符的识别。
去除图像上多余空间：
车牌上的字符经过了粗切割所得到的是一些单的字符，但在分配空间时是按照车牌的宽和长的七分之一来分配的；所以这个空间可能大于字符应该占的空问。所以，要将多余空间去除。对于第一个字符从第一行开始向下扫描，把那些一行中所有的点的灰度值全为0的点去掉，直到扫描到有一行不全为0时为止。然后再从第一列开始向右扫描把那些一列中所有的点的灰度值全为0的点去掉，直到扫描到有一列不全为0时为止。接下来从最后一行开始向上扫描，把那些一行中所有的点的灰度值全为0的点去掉，直到扫描到有一行不全为0时为止。最后从最后一列开始向左扫描把那些一列中所有的点的灰度值全为0的点去掉，直到扫描到有一列不全为0时为止。重复上面的步骤完成剩下字符的切割
根据二值化的结果，以及记录的跳变点位置，对字符进行分割，同时记录字符的左右边界。
5.字符匹配： 对分割出来的字符进行归一化处理，这里用到图片的扩大算法，扩大之后逐一的去进行字符匹配。字符模板事前通过字模软件转换成二进制数据保存在数组中。最后根据匹配结果相似度最大的做为输出结果。
归一化图像就是要把原来各不相同的字符统一到同一尺寸。因为扫描进来的图像中字符大小存在较大的差异，而相对来说，统一尺寸的字符识别的标准性更强，准确率自然也更高。具体算法如下：先得到原来字符的高度和宽度，与系统已存字模的数据作比较，得出要变换的系数，然后根据得到的系数按照插值的方法映射到原图像中。
实物图 视频演示 基于STM32单片机的车牌识别系统设计_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili​ 原文阅读（原文文末获取资料） 基于stm32的车牌识别设计​ 免费分享海量学习资源​ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15b8fd63996ae44121b9e1b597eaaba/" rel="bookmark">
			双11哪款蓝牙耳机值得入手？高性价比游戏低延迟五款蓝牙耳机测评
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		真蓝牙耳机烂大街的今天，除了相差无几的价格，你有注意到无线之外的产品特征吗？当每一款无线蓝牙耳机都在说自己是真无线蓝牙时，谁才是你的那个它？
TWS是True Wireless Stereo的缩写，意为真正的无线立体声。该技术的实施基于芯片技术的发展。有线耳机现在可以摆脱线路，成为无线耳机！其从技术上来说是指手机通过连接主音箱，再由主音箱通过蓝牙无线方式连接从音箱，实现真正的蓝牙左右声道无线分离使用。
2016年9月苹果发布第一代AirPods，开启耳机无线化时代，TWS耳机迎来前所未有的发展机遇。
从市场份额来看，苹果TWS耳机处于领先位置，市场调研机构Counterpoint Research数据显示，2019年三季度，苹果单季度市场份额占比45%，大幅领先其他厂商，Counterpoint预测还显示，2019年全球TWS耳机出货量可达1.2亿台，同比增长160%，2020年TWS耳机出货量大概率可突破2亿台。
但是相对于苹果来说，很多安卓用户并不能很好的享受AirPods的乐趣，所以今天针对这个问题，小编特意盘点了几款苹果安卓通用的蓝牙耳机，想要入手蓝牙耳机的小伙伴希望能有一点参考。
第一款：击音F1
击音F1真无线蓝牙耳机支持蓝牙5.0芯片，传输距离比上一个版本提高了4倍之多，连接更加稳定，还拥有高品质双磁纯铜音圈+石墨烯超薄振膜，为耳机提供更好分辨率，无论你喜欢古典还是流行音乐，都能轻松hold住，加之芯片级EQ调制与腔体优化，数十轮的全频段调校，在音乐处理方面更加出色。
F1没有按键操作百分百代替了手机按键播控，只需要轻轻触摸耳机就能完成音乐的切换和通话的状态。延迟方面更是做到极致,吃鸡王者稳稳操作无压力，基本感受不到延迟，一键切换模式更是提高了娱乐的使用体验。耳机有三个模式可供切换，游戏模式、娱乐模式、影音模式，游戏模式下相比普通蓝牙5.0芯片延迟率降低42.9%，蓝牙4.2芯片延迟率降低81.8%，进一步提高连接稳定性，达到游戏蓝牙耳机行业的领先水平；影音模式下，提升2-3倍观影体验，轻松hold住蓝光4K画质。
击音F1搭载了DSP+CVC 8.0通话降噪技术，配合双麦克风降噪的采集，不管是安卓系统还是苹果系统，都能实现高清音质的通话体验，加上蓝牙5.0芯片的加持，信号传输更稳定，画音慢半拍也成了过去式。F1单次续航8小时，加上充电仓，总续航更是达到了35小时，即使出远门也无惧断电。
第二款：mifo O7
魔浪O7的充电仓，它采用了全金属的材质，手感很好，重量只有83.5克，很方便携带。外观经过六轴CNC内切外磨等数道工艺打造而成，并且边角圆润且富有质感，看上去非常上档次。
充电仓的电池容量为350毫安时，耳机的电池容量为40毫安时，耳机充满电就可以有7小时的续航能力，再加上充电仓，总续航能力可达28小时之多。
在配置方面，魔浪O7采用进口高通芯片，可以实现APT-X无损传输。并且内置有高通蓝牙5.0芯片，支持高清CD级APT—X无损传输，使得传输效率大幅提高，覆盖范围更加的广，传输速度更快。
第三款：华为freebuds Pro
华为FreeBuds Pro的耳机盒没有延续之前华为FreeBuds 3的圆形设计，而是采用了方圆之间，类似椭圆的设计，盒身的线条流畅柔和，PVC材质经金属哑光喷涂工艺处理后，握持的手感非常舒适，而大约60g的盒重也很轻盈。
耳机开启降噪功能后，周围鼎沸的环境音立刻就被压制到了很小，如果再搭配播放音乐的话，几乎就能不到周围的声音了。据说华为FreeBuds Pro的降噪深度达到了40dB，这比一般降噪耳机22dB-35dB的降噪深度优秀了不止一个档次，因此更能在嘈杂的环境中立刻还原出一个安静的声场空间。
第四款：dyplay ANC PODS
耳机整体采用入耳式加耳机柄搭配的结构，通体白色磨砂质感与收纳盒相呼应。耳机柄与音腔部分做了类似阶梯型的处理，层次感分明，也为这款耳机增加了一定的辨识度。
值得一提的是，dyplay ANC Pods耳机的音腔部分采用了金属材质的网罩，防腐蚀性更强，一定程度上也能够延长耳机的使用寿命。
dyplay ANC Pods耳机搭载了蓝牙5.0芯片，并配备了陶瓷天线，实际体验下来在半径10-15米范围内可以正常连接通信，属于中规中矩的水平。
音质方面，dyplay ANC Pods耳机双侧配备了10mm动圈单元，频响范围在20Hz-20kHz，并且支持多种蓝牙传输协议。
第五款：铁三角ATH-CK3TW
铁三角表示这款耳机采用高通的低延迟技术，搭载5.8mm驱动单元，耳机配备了触摸传感器，可以进行平滑触摸控制。声学参数方面，铁三角CK3TW的频响范围为20-20000Hz，灵敏度为98dB，阻抗为16Ω。
续航方面，铁三角CK3TW充满电后可以连续播放6小时，搭配充电盒可以实现30小时的综合续航时间。
佩戴上，铁三角ATH-CK3TW采用了沿人耳的圆形外形设计，硅胶耳塞也起到了良好的隔音作用并且能够稳定贴合耳朵轮廓，您只需要注意针对个人耳道大小选用合适的耳套就OK。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/655f33fdaad8e1def1ddb9244df4583a/" rel="bookmark">
			LeetCode C&#43;&#43; 判断n的阶乘后有多少个0,以及满足阶乘后K个0的数的个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 long trailingZeroes(long n) //判断n!结果末尾有多少个0 { long res = 0; for (long d = n; d / 5 &gt; 0; d = d / 5) { res += d / 5; } return res; } long leftBound(long target) { long low = 0; long high = LONG_MAX - 1; while (low &lt;= high) { long mid = low + (high - low) / 2; long temp = trailingZeroes(mid); if (temp &gt; target) { high = mid - 1; } else if (temp == target) { high = mid - 1; } else { low = mid + 1; } } return low; } long rightBound(long target) { long low = 0; long high = LONG_MAX - 1; while (low &lt;= high) { long mid = low + (high - low) / 2; long temp = trailingZeroes(mid); if (temp &gt; target) { high = mid - 1; } else if (temp == target) { low = mid + 1; } else { low = mid + 1; } } return high; } int preimageSizeFZF(int K) // 满足阶乘后K个0结尾的数的个数 { long r = rightBound(K); long l = leftBound(K); return r - l + 1; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/715a2cd5c96ca4b0d2ebb61518374799/" rel="bookmark">
			vue websocket  webRTC实现用户登录上下线功能 以及视频通话功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只是自己的理解，不是最好的解决办法，哈哈。
webRTC 和 WebSocket 要了解一下。。
WebRTC（Web Real-Time Communication）即网页即时通信，是一个支持网页浏览器进行实时语音对话或视频对话的API。WebSocket是一种在单个TCP连接上进行全双工通信的协议。在 WebSocket 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 首先实现用户登录以及用户列表是否在线。参考https://blog.csdn.net/qq_38455201/article/details/80374712
登录页面用onopen的连接websocket后onmessage会返回信息，其实应该是在全局去连接，因为我是个小demo就这样直接写了，前提是要用https 以及要有个websocket的服务
然后用户列表页面用onmessage去根据服务器返回的type 去更新当前的列表用户是否在线
this.socket = new WebSocket(this.socketUrl + this.$route.query.user) this.socket.onmessage = function (evt) { var received_msg = evt.data; console.log("数据已接收:" +received_msg); var obj = JSON.parse(received_msg); //1代表上线 2代表下线 3代表在线名单 4代表普通消息 if(obj.msgType==1 || obj.msgType == 3) { _this.onlineUsers = obj.onlineUsers; _this.updateOnlineTable() } if(obj.msgType==1){ var onlineName = obj.useName; _this.setMessageInnerHTML(onlineName+"上线了"); } else if(obj.msgType==2){ var offlineName = obj.useName; _this.offUsers = obj.useName _this.offOnlineTable() _this.setMessageInnerHTML(offlineName+"下线了"); } else if(obj.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/715a2cd5c96ca4b0d2ebb61518374799/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7726a54da438f241a8f03af3b7e519e/" rel="bookmark">
			项目实战：Qt编译Qt库以及使用C#调用Qt库，并实现C#集成Qt的tcp客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		若该文为原创文章，转载请注明原文出处
本文章博客地址：https://blog.csdn.net/qq21497936/article/details/109338289
各位读者，知识无穷而人力有穷，要么改需求，要么找专业人士，要么自己研究
红胖子(红模仿)的博文大全：开发技术集合（包含Qt实用技术、树莓派、三维、OpenCV、OpenGL、ffmpeg、OSG、单片机、软硬结合等等）持续更新中…（点击传送门）
Qt开发专栏：项目实战（点击传送门） 需求 1.Qt已经开发了应用，封装成Qt库，以供C#调用。
2.Qt的tcp客户端封装，以供C#调用，双向传递数据。
原理 1.使用QtCreator编译msvc版本的Qt库；
2.使用VS2017开发C#程序引入Qt库；
3.双向传递指针、传递数组；
相关博客 《项目实战：Qt编译Qt库以及使用C#调用Qt库，并实现C#集成Qt的tcp客户端》
《VS2017编写MFC库以及使用Qt调用MFC库方法》
《VS2017编写纯C库以及使用C#调用C库方法》
《Qt实用技巧：VS2017编写纯C库以及使用Qt调用C库方法》
《关于 C#调用C库Dll，有回调函数时，只执行一次回调函数就直接挂掉 的解决方法》
《关于 C#调用一个C/C++dll库运行时实现多个应用(静态变量区分) 的解决方法》
《关于 C#调用c库，将C#的byte[]传入C库的方法和将C库的char*向上传入C#的回调函数byte[] 的方法》
Demo 以下是集成客户端的演示：
工程模板 cSharpCallQtDllDemo_基础模板_v1.0.0.rar
cSharpCallQtDllDemo_定制连接服务器_传输数据.rar
入坑 入坑一：错误“未加载ucrtbase.pdb" 错误
解决
需要对Qt的库进行初始化操作并且到用windeployqt导入库先关的依赖性项。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9cee769fdeb94d394195eaee2a20261e/" rel="bookmark">
			数字信号处理实验一 T3
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字信号处理实验一 T3 题目要求原理具体实现代码 题目要求 一个连续的周期性方波信号频率为 200Hz，信号幅度在-1+1V 之间，要求在图形窗口上显示其 两个周期 的波形。以4kHz的频率对连续信号进行采样，编写程序生成连续信号和其采样获得的离散信号波形。
原理 数字信号处理ppt第一章
重点在于公式
w 0 = 2 π T T 0 w_{0}=2\pi \frac{T}{T_{0}} w0​=2πT0​T​
即用连续信号的周期和抽样信号周期求出数字频率。
本题中连续信号周期 T 0 = 1 200 s T_{0}=\frac{1}{200}s T0​=2001​s,抽样信号周期 T = 1 4000 s T=\frac{1}{4000}s T=40001​s。
如此求出 w 0 = 2 π T T 0 = π 10 r a d w_{0}=2\pi \frac{T}{T_{0}}=\frac{\pi }{10}rad w0​=2πT0​T​=10π​rad
我们在一个周期内会抽样 N = 2 π w 0 = 20 N=\frac{2\pi }{w_{0}}=20 N=w0​2π​=20个点。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9cee769fdeb94d394195eaee2a20261e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d84d4200dab619e84f325cd15bbc895/" rel="bookmark">
			Beego脱坑（十八）静态文件处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: Beego脱坑（十八）静态文件处理
tags: go，beego，orm
author : Clown95
刚接触beego的小伙伴，不知道有没有遇到这样的问题，在beego中使用的静态文件，并且路径设置的都正确，但是运行的时候，就是不能加载出来。
就说我自己在刚开始使用beego的时候，想要使用layui前端框架，但是运行时layui并没有被调用，改来改出，才发现layui被我放错目录了，我没有放在static目录中，最后把layui移动到static目录中网页才正确的加载。
Beego默认静态文件处理目录 这是因为，beego 把 static 注册为默认静态文件处理目录，静态文件只有
存放在这个目录中，才能被beego正确的加载。
StaticDir["/static"] = "static" 指定静态文件处理目录 有的小伙伴可能比较执着，或者项目上有其他要求,不想把静态文件放在static目录，beego也为我们提供了，指定静态文件处理目录的方法SetStaticPath。
使用方法是，在main.go 文件中的 beego.Run() 之前加入
beego.SetStaticPath("/layui", "layui") 如果我们需要指定多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射
beego.SetStaticPath("/down1", "download1") beego.SetStaticPath("/down2", "download2") 值得注意的是，使用SetStaticPath指定静态文件处理目录，并不影响static目录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2fba991fc4ca2431c7d3e7b5103f019/" rel="bookmark">
			QTcreator界面上显示pcl点云数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面说明下如何在Qt Creator的GUI界面上显示点云
前面有三篇博客讲了相关内容，这里在QTcreate编译器环境下再配置下PCL，并界面显示点云
至于QVTKWidgetPlugin.dll的获取及位置存放见前面系列博客
1. 新建一个test_QTcreator_show工程，界面上拖放一个Widget控件
2.右击控件，选择提升为，配置如下：
点击上图中的添加按钮
勾选上图中的复选框
然后在选择右下角的提升按钮，完毕。
再添加一个按钮，界面设计如下：
接下来进入test_QTcreator_show.pro，编辑后文件如下：
#------------------------------------------------- # # Project created by QtCreator 2020-10-31T15:48:04 # #------------------------------------------------- QT += core gui greaterThan(QT_MAJOR_VERSION, 4): QT += widgets TARGET = test_QTcreator_show TEMPLATE = app # The following define makes your compiler emit warnings if you use # any feature of Qt which has been marked as deprecated (the exact warnings # depend on your compiler). Please consult the documentation of the # deprecated API in order to know how to port your code away from it.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2fba991fc4ca2431c7d3e7b5103f019/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/360/">«</a>
	<span class="pagination__item pagination__item--current">361/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/362/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>