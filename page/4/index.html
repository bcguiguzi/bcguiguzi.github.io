<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64d3a526a0c0c082bc3cde854ed6c547/" rel="bookmark">
			蓝桥杯算法基础（23）：数组的操作（6道小题）java版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题7：排序数组中找和的因子 给定已排序数组，arr和k,不重复打印arr中所有相加和为k的不降序二元组 如输入arr={-8,-4,-3,0,2,4,5,8,9,10},k=10 输出(0,10)(2,8) 双指针 left=0; right=arr.length-1; left右移，若是arr[left]+arr[right]&lt;k,left++; 若是&gt;k,right--; 等于则输出 因为如果arr[left]+arr[right]&lt;k，arr[right]为最大的值，arr[left]加上arr[right]都小于k,则说明arr[left]太小，与后面任何一个数相加都小于k,所以left++ right与left一样，若是arr[left]+arr[right]&gt;k,则证明arr[right]太大了，与left后面的任何值相加都大于k 扩展:三元组呢？ i,j,g 首先，将数组排序，使用三指针法。 然后，使用三个指针i、j和g，分别指向数组中的第一个元素、第二个元素和最后一个元素。 在每一次迭代中，计算当前三个指针所指向的元素之和sum。 如果sum等于目标值，则将这个三元组加入结果集，并将指针i和j分别向右移动一位，k向左移动一位，并消重 如果sum小于目标值，则将指针j向右移动一位。 如果sum大于目标值，则将指针g向左移动一位。 //即先确定i的位置，j和k用双指针判断arr[j]+arr[g]==k-arr[i]; //注意j在i后第一个元素，k在最后一个位置 重复上述步骤，直到所有可能的三元组都被考虑过。 这种方法的时间复杂度为O(n^2)，其中n是数组的长度 题8:需要排序的子数组 给定一个无序数组arr,求出需要排序的最短子数组长度 要求:o(n) 如输入:arr={2,3,7,5,4,6},返回4，因为只有{7，5，4，6}需要排序 public int[] findSegment(int[] A,int n){ int p1=-1; int p2=-1; int max=A[0]; int min=A[n-1]; //扩展右端点，更新历史最高，只要右侧出现比历史最高低的，就应该将右边界扩展到此处 for(int i=0;i&lt;n;i++){ if(A[i]&gt;max) { max=A[i]; } //只要低于历史高峰，就要扩展需要排序区间的右端点 if(A[i]&lt;max) p2=i; } //找左端点，更新历史最低，只要左侧出现比历史最低高的，就将左边界扩展到此处 for(int i=n-1;i&gt;0;i--){ if(A[i]&lt;min){ min=A[i]; } if(A[i]&gt;min) p1=i; } if(p1==-1){//即都有序 return new int[]{0,0}//匿名数组（临时数组） } return new int[]{p1,p2};//返回区间p1到p2 } 题9按逆序排列的前k个数(topK) 求海量数据(正整数)按逆序排列的前k个数(topK),因为数据量太大，不能全部存储在内存中，只能一个一个地从磁盘或网络中上读取，请设计一个高效地算法来解决这个问题 第一行:用户输入k，代表要求topK 随后的N(不限制)行,每一行是一个整数嗲表用户输入的数据 用户输入-1代表输入终止 请输出topK，从小到大，空格分割 解决:大顶堆 static int[] heap; static int size=0; static int k; public static void main(String[] args){ Scanner sc=new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/64d3a526a0c0c082bc3cde854ed6c547/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6be08b5e5693f73784bbaeadaefb95/" rel="bookmark">
			2023年蓝桥杯模拟省赛——列名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
题目链接：2.列名 - 蓝桥云课 (lanqiao.cn)
思路
高级思路：进制转换
难点一
难点二
难点三
总结
题目链接：2.列名 - 蓝桥云课 (lanqiao.cn) 思路 先来看我的暴力的思路吧
主要有以下步骤：
初始化一个长度为3的数组res用于存放结果，并且定义一个变量 p 表示目前数组中的有效长度 - 1（即当前操作的位置）。变量p的初始值为0，表示当前数组的有效长度为1。
通过一个for循环生成2022次操作。操作主要分为两步：
第一步，判断当前数组中所有有效元素是否全部为26。如果是，就将数组的所有有效元素都重置为1，并且扩大数组的有效长度1位（即p加1）。
第二步，将有效位置（p位置）的元素加1。若此元素达到26，将该元素归零，并令前一个元素加1。若前一个元素也达到26，则会连带影响到再前一个元素，依此类推。
当循环完成2022次 after 操作后，我们会得到一个长度为3的数组，该数组中的元素值在1至26之间，可映射为字母序列。
这段代码就是通过特定的规则，生成一个特殊的字母序列。这个序列的特点是每个单词都不同，并且在字母顺序上是递增的。这个序列可以类比为一种自定义的26进制计数系统，每一位的取值范围是1-26，对应到字母就是A-Z，每次计数完成后，会在需要的时候往上进位。
package src; import java.util.Arrays; //1:无需package //2: 类名必须Main, 不可修改 public class Main { public static void main(String[] args) { // StreamTokenizer st = new StreamTokenizer(new BufferedReader(new // InputStreamReader(System.in))); int[] res = new int[] { 0, 0, 0 }; int p = 0; for (int i = 0; i &lt; 2022; i++) { // System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6be08b5e5693f73784bbaeadaefb95/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70082aedbc52b1ca41a1475b5f5284b2/" rel="bookmark">
			[数据集][目标检测]草莓成熟度检测数据集VOC&#43;YOLO格式412张3类别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据集格式：Pascal VOC格式+YOLO格式(不包含分割路径的txt文件，仅仅包含jpg图片以及对应的VOC格式xml文件和yolo格式txt文件)
图片数量(jpg文件个数)：412
标注数量(xml文件个数)：412
标注数量(txt文件个数)：412
标注类别数：3
标注类别名称:["flower","growth","mature"]
每个类别标注的框数：
flower 框数 = 410
growth 框数 = 671
mature 框数 = 851
总框数：1932
使用标注工具：labelImg
标注规则：对类别进行画矩形框
重要说明：暂无
特别声明：本数据集不对训练的模型或者权重文件精度作任何保证，数据集只提供准确且合理标注
下载地址：https://download.csdn.net/download/FL1623863129/88980863
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca9135cfbd315e51f0fac317fa0df4f7/" rel="bookmark">
			HTML与WXML 、 CSS与WXSS的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、HTML与WXML的区别？ （1）使用标签不同。HTML的块标签是&lt;div&gt;,WXML的块标签是&lt;view&gt;
（2）页面预览不同。HTML的页面是在浏览器中预览,WXML的页面是在微信开发者工具中预览
（3）标签和属性不同。WXML具有一些特定与微信小程序的标签和属性，例如&lt;view&gt;&lt;text&gt;等等
（4）结束符要求不同。WXML的单标签在结尾处必须加上“/”结束符
（5）语法模板不同。WXML提供了Vue.js的模板语法。但没有BOM和DOM
二、css与WXSS的区别？ （1）选择器不同。WXSS仅支持部分css选择器。例如class、id、element、并集、后代、伪类。但是WXSS不支持css的某些高级选择器，例如[attribute]
（2）样式不同。app.wxss里是全局样式。.wxss样式是局部样式。
（3）尺寸单位不同。由于不同手机的屏幕分辨率不同，css的px会出现屏幕不适应的问题。而微信小程序的rpx可以自适应的适配各种屏幕
（4）wxss设背景图时不能是本地图片，只能使用网络图片或Base64格式编码图片
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b08d221691c87da45dca99341943dac9/" rel="bookmark">
			python如何做线性回归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，你可以使用scikit-learn库进行线性回归。scikit-learn是一个强大的机器学习库，它提供了许多用于数据分析和数据挖掘的工具。
以下是一个简单的线性回归的示例：
# 导入所需的库 from sklearn.model_selection import train_test_split from sklearn.linear_model import LinearRegression from sklearn import metrics import numpy as np import pandas as pd # 假设你有一个包含两个列的数据集：'feature' 和 'target' # 这里我们使用一个简单的示例数据 data = { 'feature': np.random.rand(100), 'target': np.random.rand(100) } df = pd.DataFrame(data) # 分割数据集为训练集和测试集 X = df['feature'].values.reshape(-1,1) y = df['target'].values.reshape(-1,1) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0) # 创建线性回归对象 regressor = LinearRegression() # 使用训练集来训练模型 regressor.fit(X_train, y_train) # 使用测试集来测试模型 y_pred = regressor.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b08d221691c87da45dca99341943dac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12fa9e03213123b1e7a795e4c6f0222a/" rel="bookmark">
			MATLAB中的cell数组和结构体。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MATLAB中的Cell数组和结构体
MATLAB作为一种高级编程语言和数值计算环境，为用户提供了多种数据结构，以便更灵活、高效地处理数据。其中，cell数组和结构体是两种非常重要的数据结构，它们在MATLAB编程和数据管理中发挥着关键作用。以下是对这两种数据结构的详细解释，总计约2000字。
一、Cell数组
（一）概述
Cell数组是MATLAB中的一种特殊数组类型，它可以存储任意类型和大小的数据。与传统的数值数组不同，cell数组的每个元素（即每个“cell”）都可以包含不同类型和大小的数据，这使得cell数组成为处理异构数据的理想选择。
（二）创建和使用
在MATLAB中，可以使用花括号{}来创建和访问cell数组的元素。例如，C = {1, 'hello', [3 4; 5 6]}创建了一个包含三个元素的cell数组：一个数值、一个字符串和一个矩阵。要访问cell数组中的元素，可以使用索引和花括号，如C{1}将返回数值1。
（三）优势和局限
Cell数组的优势在于其灵活性。由于可以存储任意类型和大小的数据，因此非常适合处理复杂的数据集，如混合类型的数据、不同大小的矩阵等。然而，这种灵活性也带来了一定的局限性。由于cell数组中的元素类型和大小可以不同，因此在进行某些操作时（如数学运算），可能需要额外的处理或转换。
二、结构体
（一）概述
结构体是MATLAB中的另一种重要数据结构，它允许用户将不同类型的数据组合成一个单一的实体。与cell数组类似，结构体也可以存储异构数据，但结构体的组织方式更加结构化，每个字段都有明确的名称和数据类型。
（二）创建和使用
在MATLAB中，可以使用struct函数或点号.来创建和访问结构体的字段。例如，S = struct('name', 'John', 'age', 30, 'occupation', 'Engineer')创建了一个包含三个字段的结构体：name、age和occupation。要访问结构体的字段，可以使用点号或字段名称作为索引，如S.name将返回字符串'John'。
（三）优势和局限
结构体的优势在于其结构化的组织方式。通过使用具有明确名称的字段，可以更容易地理解和管理数据。此外，结构体还支持嵌套，即一个结构体的字段本身可以是另一个结构体或数组，这进一步增加了数据组织的灵活性。然而，与cell数组相比，结构体在处理异构数据时可能稍微复杂一些，因为需要为每个字段指定名称和数据类型。
三、比较与选择
Cell数组和结构体都是MATLAB中处理异构数据的强大工具，但它们在使用方式和适用场景上有所不同。Cell数组更加灵活，可以存储任意类型和大小的数据，适合处理不规则或复杂的数据集。而结构体则更加结构化，通过字段名称来组织数据，适合处理具有明确属性和关系的数据实体。在实际应用中，应根据具体需求和数据特点选择合适的数据结构。
四、总结与展望
总的来说，cell数组和结构体是MATLAB中两种重要的数据结构，它们在处理异构数据和复杂数据集时发挥着关键作用。通过灵活运用这两种数据结构，可以更高效、更直观地组织和管理数据，从而提高MATLAB编程的效率和质量。未来随着数据科学和人工智能的不断发展，对异构数据处理的需求将不断增加，cell数组和结构体等灵活数据结构的应用前景将更加广阔。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/574026b1bf8c286aca4d71978b43781d/" rel="bookmark">
			如何在MATLAB中处理图像和视频？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在MATLAB中处理图像和视频是一项复杂而强大的任务，涉及多个步骤和工具。MATLAB提供了丰富的函数和工具箱，使用户能够轻松地加载、处理、分析和显示图像和视频数据。
一、图像处理基础
加载图像：在MATLAB中，可以使用imread函数加载图像。例如，img = imread('filename.jpg')将加载名为'filename.jpg'的图像文件，并将其存储在变量img中。显示图像：使用imshow函数可以在MATLAB中显示图像。例如，imshow(img)将显示变量img中的图像。图像数据类型：MATLAB中的图像可以是多种数据类型，包括uint8、uint16、double和logical等。不同的数据类型适用于不同的图像处理任务。图像转换：使用im2double、im2uint8等函数可以在不同的数据类型之间转换图像。例如，img_double = im2double(img)将把uint8类型的图像转换为double类型。 二、图像处理操作
图像增强：MATLAB提供了多种图像增强技术，如直方图均衡化（histeq函数）、对比度调整（imadjust函数）和滤波（如高斯滤波、中值滤波等）。这些技术可以改善图像的视觉效果，提高图像的质量。图像变换：使用fft2、ifft2等函数可以对图像进行傅里叶变换和反变换，从而在频域内处理图像。此外，还可以使用imrotate、imresize等函数对图像进行旋转、缩放等几何变换。图像分割：MATLAB提供了多种图像分割方法，如阈值分割（imbinarize函数）、边缘检测（如Canny边缘检测算法）和区域生长等。这些方法可以将图像分成不同的区域或对象，便于进一步的分析和处理。特征提取：使用MATLAB中的图像处理工具箱，可以提取图像的各种特征，如纹理特征、形状特征、颜色特征等。这些特征在图像识别、目标跟踪等任务中具有重要意义。 三、视频处理基础
加载视频：在MATLAB中，可以使用VideoReader对象加载视频文件。例如，v = VideoReader('filename.mp4')将创建一个VideoReader对象，用于读取名为'filename.mp4'的视频文件。播放视频：使用play函数可以播放视频。例如，play(v)将播放VideoReader对象v中的视频。此外，还可以使用readFrame函数逐帧读取视频，并使用imshow函数显示每一帧图像。视频转换：与图像处理类似，可以使用MATLAB中的函数将视频帧转换为不同的数据类型或进行其他处理操作。例如，可以使用rgb2gray函数将彩色视频转换为灰度视频。视频分析：MATLAB还提供了多种视频分析方法，如运动检测、目标跟踪和光流计算等。这些方法可以帮助用户从视频中提取有用的信息，进行进一步的处理和分析。 四、高级图像处理和视频处理
图像处理应用：MATLAB中的图像处理工具箱支持许多高级应用，如图像去噪、图像修复、图像融合和超分辨率重建等。这些应用可以帮助用户改善图像质量、提取更多信息或实现特定的视觉效果。视频处理应用：类似地，MATLAB中的视频处理工具箱也支持许多高级应用，如视频稳定化、视频去噪和视频压缩等。这些应用可以帮助用户改善视频质量、减小文件大小或实现特定的视频效果。自定义函数和算法：除了使用MATLAB提供的内置函数和工具箱外，用户还可以编写自定义函数和算法来处理图像和视频。MATLAB的灵活性和强大的计算能力使用户能够实现各种复杂的图像处理和视频处理任务。与其他工具箱的集成：MATLAB还提供了许多其他工具箱，如深度学习工具箱、计算机视觉工具箱和信号处理工具箱等。这些工具箱可以与图像处理和视频处理工具箱集成使用，为用户提供更广泛、更强大的功能。 五、总结与展望
总的来说，MATLAB是一个功能强大的图像处理和视频处理工具。通过掌握MATLAB中的基本函数和工具箱，用户可以轻松地加载、处理、分析和显示图像和视频数据。此外，MATLAB还支持自定义函数和算法以及与其他工具箱的集成使用，为用户提供更大的灵活性和扩展性。随着技术的不断发展，MATLAB将继续在图像处理和视频处理领域发挥重要作用，为用户提供更高效、更便捷的工具和方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1720feb2bd3e2165bd3e21a59d10b987/" rel="bookmark">
			RuoYi-Vue开源项目2-前端登录验证码生成过程分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端登录验证码实现过程 生成过程分析 生成过程分析 验证码的生成过程简单概括为：前端登录页面加载时，向后端发送一个请求，返回验证码图片给前端页面展示
前端页面加载触发代码： import { getCodeImg } from "@/api/login"; created() { this.getCode(); this.getCookie(); }, // 1.页面初始化页面调用的验证码加载函数 getCode() { getCodeImg().then(res =&gt; { this.captchaEnabled = res.captchaEnabled === undefined ? true : res.captchaEnabled; if (this.captchaEnabled) { this.codeUrl = "data:image/gif;base64," + res.img; this.loginForm.uuid = res.uuid; } }); }, // 2.获取验证码API export function getCodeImg() { return request({ url: '/captchaImage', headers: { isToken: false }, method: 'get', timeout: 20000 }) } // 3.axios请求 const service = axios.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1720feb2bd3e2165bd3e21a59d10b987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62351737303e5d34737e7e1382d0c8ec/" rel="bookmark">
			【JVM】（内存区域划分 为什么要划分 具体如何分 类加载机制 类加载基本流程 双亲委派模型 类加载器 垃圾回收机制（GC））
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 内存区域划分为什么要划分具体如何分 类加载机制类加载基本流程双亲委派模型类加载器 垃圾回收机制（GC） 内存区域划分 为什么要划分 JVM启动的时候会申请到一整个很大的内存区域,JVM是一个应用程序,要从操作系统这里申请内存,JVM就需要根据,把空间,分成几个部分,每个部分各自有不同的功能作用.
具体如何分 堆 存放new出来的对象
方法区/元数据区，存放类对象（类加载之后，存放的位置）
栈 存放方法之间的调用关系
程序计数器 存放每个线程，下一条要执行的指令的地址
类加载机制 类加载基本流程 java代码会被编译成.class文件（包含一些字节码），java程序要想运行起来，就需要让jvm读取到这些.class文件，并且把里面的内容，构造成类对象，保存到内存的方法区中。所谓的执行代码就是调用方法。
书上和官方文档把类加载过程分成了5个步骤。
加载：找到.class文件，打开文件，读取到文件内容。验证：.class文件是一个二进制的格式。（某个字节，都是具有特定含义的），就需要验证你当前读到的这个格式是否符合要求。准备：给类对象分配内存空间。（只分配内存空间，没有初始化，此时空间上的内存的数值是0，此时如果尝试打印类的static成员，就是全0的）解析：针对类对象中包含的字符串常量进行处理，进行一些初始化操作。（java代码中用到的字符串常量在编译之后也会进入到.class文件中）这个过程也叫做：把“符号引用”（文件偏移量）替换成“直接引用”（内存地址）。初始化：针对类对象进行初始化，把类对象中需要的各个属性都设置好，还需要初始化好static成员，还需要执行静态代码块，还可能需要加载一下父类。 双亲委派模型 属于类加载中，第一个步骤“加载”过程中国，其中的一个环节。
负责根据全限定类名找到.class文件。
所谓的“双亲委派模型”就是一个查找优先级问题。
类加载器 是JVM中的一个模块，在JVM中内置了三个类加载器。
BootStrap ClassLoaderExtension ClassLoaderApplication ClassLoader 上述三个类加载有父子关系，3是子 2是父 3是爷。
双亲委派模型过程：
类加载的过程（找class文件的过程）
给定一个类的全限定类名，形如java.lang.String。从Application ClassLoader作为入口，开始执行查找的逻辑。Application ClassLoader，不会立即去扫描自己负责的目录（负责的是搜索项目点前目录和第三方库对应的目录）而是把查找的任务，交给他的父亲，Extension ClassLoader。Extension ClassLoader 也不会立即去扫描自己负责的目录，（负责的是JDK中一些扩展的库，对应的目录）而是把查找的任务，交给他的父亲，BootStrap ClassLoader。BootStrap ClassLoader 也不想立即扫描自己负责的目录，（负责的是标准库的目录），也想把任务交给它的父亲，结果发现自己没有父亲，因此BootStrap ClassLoader只能亲自负责扫描，标准库的目录。java.lang.String这种类就能够在标准库中，找到对应的.class文件，就可以进行打开文件，读取文件后续操作。此时查找.class文件的过程就结束了。但是，如果给定的类不是标准库的类，任务仍然会被交给孩子来执行。如果没有扫描到就会回到Extension ClassLoader。Extension ClassLoader就会扫描负责的扩展库的目录，如果找到，就执行后续的类加载操作，此时查找过程结束，如果没找到，还是把任务交给孩子来执行。没有扫描到，就会回到Application ClassLoader，Application ClassLoader就会负责扫描当前目录和第三方库的目录，如果找到，就会执行后续的类加载操作，如果没找到，就会抛出一个ClassNotFoundExcepton。 之所以搞这一套流程，主要目的是为了确保，标准库的类，被加载的优先级最高，其次是扩展库，最后是自己写的类和第三方库。
垃圾回收机制（GC） 让JVM自行判定，某个内存是否就不再使用了，如果这个内存后面确实不用了，JVM就会自动的把这个内存给回收掉，此时就不必要让程序员自己手动写代码回收。
GC这么好为什么C++不引入GC呢？
系统缺陷，需要一个/一些特定的线程，不停的扫描内存中的所有的对象，看是否能够回收。此时是需要额外的内存 + CPU资源的。C++要考虑能兼容一些配置特别低的系统。效率问题，这样的扫描线程，不一定能够及时的释放内存（扫描总是有一定周期的），一旦同一时刻，出现大量的对象都需要被回收GC产生的负担就会很大，甚至引起整个程序都卡顿。（STW问题 stop the world）。
GC是垃圾回收，GC回收的目标是内存中的对象，对于Java来说就是new出来的对象。栈里的局部变量，是跟随栈帧的生命周期走的。（方法执行结束，栈帧销毁，内存自然释放）
静态变量，生命周期就是整个程序，这个始终存在，就意味着静态变量是无需释放的。 GC可以理解成两个大的步骤：
找到垃圾 引用计数（Python PHP）
new出来的对象，单独安排一块空间，来保存一个计数器。
缺陷：
1.浪费内存
2.引用计数机制，存在“循环引用”问题。 此时第一个对象和第二对象互相引用，要想使用第一个对象，就需要先拿到第二个对象，如果想要拿到第二个对象，又得先拿到第一个对象，这里就非常像死锁。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62351737303e5d34737e7e1382d0c8ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/339127b32226b0dfeaae7af49b4c2c07/" rel="bookmark">
			小红书春招开始啦！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近，美团、字节、小红书等各个大厂都相继启动了春季校园招聘，看了一圈，发现小红书今年春招的技术岗还真不少。
技术类1 技术类2 技术类3 建议还没拿offer的和秋招已经拿上offer的同学投投看，毕竟小红书这几年作为互联网企业是真的处在上升期，校招生的待遇也是直冲Top1梯队了。
快点击“阅读原文”，去官网投投看吧～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a8423d33ad532a3e96cf8e789cd2158/" rel="bookmark">
			css常用选择器（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
选择器
1.类选择器（.class）
2.ID选择器（#id）
3.元素选择器（element）
4.后代选择器（element element）
5.子元素选择器（element &gt; element）
6.伪元素选择器（::before, ::after, ::first-line, ::first-letter等）
7.伪元素选择器（::before, ::after, ::first-line, ::first-letter等）
8.属性选择器（[attribute], [attribute=value], [attribute~=value], [attribute|=value]等）
9.相邻兄弟选择器（element + element）教程
10.通用选择器（*）教程
前言 这里主要介绍：
类选择器（.class）ID选择器（#id）元素选择器（element）后代选择器（element element）子元素选择器（element &gt; element）伪类选择器（:hover, :first-child, :nth-child(n), :not(selector), :checked, :disabled等）伪元素选择器（::before, ::after, ::first-line, ::first-letter等）属性选择器（[attribute], [attribute=value], [attribute~=value], [attribute|=value]等）相邻兄弟选择器（element + element）通用选择器（*） 选择器 1.类选择器（.class） 是一种在CSS中用来为具有相同类名的元素添加样式的选择器。以下是类选择器的使用教程：
在HTML中，为需要应用相同样式的元素添加相同的类名。例如：
&lt;p class="highlight"&gt;This is a paragraph with a highlight class.&lt;/p&gt; &lt;span class="highlight"&gt;This is a span with a highlight class.&lt;/span&gt; 在CSS中，使用类选择器来为具有相同类名的元素添加样式。例如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a8423d33ad532a3e96cf8e789cd2158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09eb2d7d1989a6ade16e5f413fb20539/" rel="bookmark">
			Linux: boot: latency启动延迟分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://elinux.org/images/6/64/Chris-simmonds-boot-time-elce-2017_0.pdf
https://www.hcltech.com/sites/default/files/documents/resources/whitepaper/files/an_insight_to_optimize_embedded_linux_boot_time_performance.pdf
无意看到这个启动延迟分析，虽然现在还没遇到类似的问题，但是可以放在这里。给以后做一个参考。看着有很多的工具可以用。
其实systemd也提供了一个工具，来查看systemd服务启动的一个时间分析。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72accdb9aee56872c946756b06c07d81/" rel="bookmark">
			算法——贪心
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		「贪心的本质是选择每一阶段的局部最优，从而达到全局最优」
贪心无套路
1. 分发饼干 贪心策略：
（1）局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩
（2）局部最优就是小饼干喂给胃口小的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩
代码实现：
// 冒泡排序 void sort(int *a, int len) { int flag = 1; for (int i = len - 1; flag &amp;&amp; i &gt; 0; i--) { flag = 0; for (int j = 0; j &lt; i; j++) { if (a[j] &gt; a[j + 1]) { flag = 1; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } } } int findContentChildren(int *g, int gSize, int *s, int sSize) { sort(g, gSize); sort(s, sSize); int j = 0; int sum = 0; for (int i = 0; i &lt; gSize; i++) { while (j &lt; sSize &amp;&amp; s[j] &lt; g[i]) { j++; } if (j &lt; sSize) { sum++; j++; } } return sum; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72accdb9aee56872c946756b06c07d81/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20fcc954880916c80ba3f46561ea50b7/" rel="bookmark">
			【开源】SpringBoot框架开发就医保险管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 科室档案模块2.2 医生档案模块2.3 预约挂号模块2.4 我的挂号模块 三、系统展示四、核心代码4.1 用户查询全部医生4.2 新增医生4.3 查询科室4.4 新增号源4.5 预约号源 五、免责说明 一、摘要 1.1 项目介绍 基于JAVA+Vue+SpringBoot+MySQL的就医保险管理系统，包含了科室档案模块、医生档案模块、预约挂号模块、我的挂号模块，还包含系统自带的用户管理、部门管理、角色管理、菜单管理、日志管理、数据字典管理、文件管理、图表展示等基础模块，就医保险管理系统基于角色的访问控制，给挂号管理员、患者角色使用，可将权限精确到按钮级别，您可以自定义角色并分配权限，系统适合设计精确的权限约束需求。
1.2 项目录屏 二、功能模块 2.1 科室档案模块 就医保险管理系统的科室档案模块是指系统中用于管理医疗机构的科室信息的功能模块。该模块主要用于记录和管理医疗机构内各个科室的相关信息，包括科室名称、科室编号、科室负责人、科室描述等。
系统管理员或具有相应权限的用户可以在系统中录入医疗机构的各个科室信息，包括科室名称、科室编号、科室负责人、科室描述等。用户可以通过科室编号或名称等关键字在系统中进行科室信息的查询，查看科室的详细信息和相关统计数据。系统管理员或具有相应权限的用户可以对科室信息进行编辑和更新，包括修改科室名称、科室负责人、科室描述等内容。系统管理员或具有相应权限的用户可以删除不需要的科室信息，确保系统中的科室信息保持最新和有效。系统可以对科室信息进行统计分析，生成科室数量、科室负责人统计等相关报表或图表，为管理决策提供依据。科室档案模块在就医保险管理系统中的作用是方便管理者对医疗机构内各个科室的信息进行维护和查询，提高工作效率，确保科室信息的准确性和完整性。
2.2 医生档案模块 就医保险管理系统的医生档案模块是指系统中用于管理医疗机构的医生信息的功能模块。该模块主要用于记录和管理医疗机构内医生的相关信息，包括医生姓名、医生编号、职称、专业领域、所属科室、联系方式等。
系统管理员或具有相应权限的用户可以在系统中录入医生的基本信息，包括姓名、编号、职称、专业领域等。用户可以通过医生姓名或编号等关键字在系统中进行医生信息的查询，查看医生的详细信息和相关统计数据。系统管理员或具有相应权限的用户可以对医生信息进行编辑和更新，包括修改姓名、职称、专业领域等内容。系统管理员或具有相应权限的用户可以删除不需要的医生信息，确保系统中的医生信息保持最新和有效。系统可以对医生信息进行统计分析，生成医生数量、职称统计等相关报表或图表，为管理决策提供依据。医生档案模块在就医保险管理系统中的作用是方便管理者对医疗机构内医生的信息进行维护和查询，提高工作效率，确保医生信息的准确性和完整性。
2.3 预约挂号模块 就医保险管理系统的预约挂号模块是系统中的一个重要功能模块，主要用于方便患者进行医院就诊的预约挂号操作，并且能够实现医院资源的合理分配和排班管理。
患者可以通过系统选择医院、科室和医生，并选择适合的就诊时间进行预约挂号。系统会根据医生的排班情况和患者的需求，提供可用的预约时间段供患者选择。医院可以通过系统设置医生的排班信息，包括工作时间、休息日、号源数量等。系统会根据医生的排班信息，在预约挂号时提供可用的时间段供患者选择。系统会记录每个医生的号源信息，并根据患者的预约挂号情况进行号源的管理和分配。在患者成功预约挂号后，系统会相应地减少医生的可用号源数量。系统会记录患者的预约信息，包括医院、科室、医生、就诊时间等。医院可以通过系统查看和管理患者的预约记录，包括确认、取消、修改预约等操作。系统可以根据医院的规定计算和管理挂号费用。患者可以通过系统支付挂号费用，同时系统也会记录患者的缴费信息。系统可以向患者发送预约挂号的提醒通知，包括预约成功通知、预约变更通知等，以确保患者及时了解就诊信息。通过预约挂号模块，就医保险管理系统能够提高医院的预约挂号效率，方便患者进行预约操作，并且能够更好地管理医生的排班和号源资源。
2.4 我的挂号模块 医保险管理系统的"我的挂号"模块是为患者提供个人就诊信息管理和查询的功能模块。患者可以通过"我的挂号"模块查询自己的就诊记录，包括已完成的就诊、待就诊的预约以及历史就诊记录等。这样患者可以方便地查看自己的就诊记录和相关信息。
患者可以通过该模块进行就诊预约的管理，包括查看已预约的就诊、取消预约、修改预约等操作。患者可以根据自己的需求对预约进行灵活管理。该模块还提供了就诊报告的查看功能，患者可以在线查看自己的就诊报告，如检验报告、影像报告等。这样可以方便患者及时查看自己的就诊结果。患者可以在"我的挂号"模块查看自己的就诊费用情况，包括已支付的费用、待支付的费用等。患者可以通过系统进行费用的支付和管理，提高就诊费用的透明度和便利性。系统可以向患者发送就诊提醒通知，包括就诊时间、就诊地点、医生信息等。这样可以帮助患者及时了解自己的就诊信息，提醒患者按时就诊。通过我的挂号模块，就医保险管理系统能够提供方便快捷的个人就诊信息管理和查询服务，帮助患者更好地管理自己的就诊记录和费用，提高就医体验和满意度。
三、系统展示 四、核心代码 4.1 用户查询全部医生 @RequestMapping(value = "/getAllByDepartmentId", method = RequestMethod.GET) @ApiOperation(value = "用户查询全部医生") public Result&lt;List&lt;Doctor&gt;&gt; getAllByDepartmentId(@RequestParam String departmentId){ QueryWrapper&lt;Doctor&gt; qw = new QueryWrapper&lt;&gt;(); qw.eq("department_id",departmentId); List&lt;Doctor&gt; doctorList = iDoctorService.list(qw); for (Doctor doctor : doctorList) { QueryWrapper&lt;DoctorNumber&gt; numberQw = new QueryWrapper&lt;&gt;(); numberQw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20fcc954880916c80ba3f46561ea50b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22b27dc1b7e8ec7a29382f1fd9d448a5/" rel="bookmark">
			linux驱动开发面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.linux中内核空间及用户空间的区别？ 记住“22”，两级分段两级权限。
例如是32位的机器，从内存空间看：顶层1G是内核的，底3G是应用的；从权限看：内核是0级特权，应用是3级特权。
2.用户空间与内核通信方式有哪些？用户获得内核信息方式有哪些？ 系统调用。proc。
3.系统调用是什么？ linux提供给应用层访问内核包括设备驱动、进程管理、内核参数的接口，例如字符设备驱动，对上层是统一的接口，对底层则由具体驱动实现。其本质是“门机制”，利用机器指令进入更高的特权空间（内核态）。
3.补-以read为例，描述系统调用的过程？ 对一个已创建的普通文件，要先谈open过程：vfs，fs，cache，通用块，IO调度，块驱动，物理块，从而拿到fops给到文件描述符，之后read就和底层读写相关起来了。
4.字符设备和块设备的区别，请分别列举一些？ 1.数据流2.系统接口(块有两套接口)
字符设备：串口、键鼠、摄像头
块设备：sd卡，u盘
5.uboot启动流程？ CTUFRC
CPU----&gt;&gt;TIM----&gt;&gt;UART/FLASH/DRAM----&gt;&gt;relocate_code----&gt;&gt;command
6.linux内核启动流程？ UMMISMB
uboot通过theKernel启动----&gt;&gt;Machine----&gt;&gt;MMU----&gt;&gt;Init----&gt;&gt;Setup----&gt;&gt;Mount----&gt;&gt;Busybox
7.linux调度原理？ 完全公平/多级反馈队列/基于优先级
优先级：很好理解。缺点：调度是遍历的，饥饿现象
多级反馈队列：超过一定时间下放到低优先级队列。特点：bitmap
完全公平：红黑树动态调整优先级(计算虚拟时间)
8.注册一个字符设备流程，代码层面？ cdev_init（cdev，fops）----&gt;&gt;register_chrdev(设备号，设备节点，fops)
9.创建设备节点？ mknod/启动脚本+mdev -s
10.释放资源要注意的？ 内存，ioremap，中断，定时器，工作队列等等要释放
11.内核函数mmap的实现原理，机制？ 将文件fd内容映射到进程虚拟内存进行读写，不必经过read/write
void* mmap ( void * addr , size_t len , int prot , int flags ,int fd , off_t offset )
12.遇到Oops？怎么处理的？ 当内核出错时(比如访问非法地址)打印出来的信息被称为 Oops 信息。
（未完待续）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ecfac59571c8b1abab787b1652bd288/" rel="bookmark">
			全域电商数据API接口采集突破堆人头的方式的数据采集实现高效稳定大批量的电商商品数据采集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		全域电商，是近几年的新趋势，几乎所有商家都在布局全域，追求全域增长。但商家发现，随着投入成本的上涨，利润却没有增加。
其中最为突出的是——商家为保证全域数据的及时更新，通过堆人头的方式完成每日取数任务时，产生的人力、时间成本和潜在的人工取数易出错、账号被封成本。
这里我们可以通过封装的电商API接口数据采集的方式，实现高效稳定大批量的电商商品数据采集。
第一步：注册封装好的电商API接口账号测试 [查看演示] API测试 注册 taobao.item_get 公共参数
名称类型必须描述keyString是调用key（必须以GET方式拼接在URL中）secretString是调用密钥api_nameString是API接口名称（包括在请求地址中）[item_search,item_get,item_search_shop等]cacheString否[yes,no]默认yes，将调用缓存的数据，速度比较快result_typeString否[json,jsonu,xml,serialize,var_export]返回数据格式，默认为json，jsonu输出的内容中文可以直接阅读langString否[cn,en,ru]翻译语言，默认cn简体中文versionString否API版本 请求参数
请求参数：num_iid=652874751412&amp;is_promotion=1
参数说明：num_iid:淘宝商品ID
is_promotion:是否获取取促销价
响应参数
Version: Date:2022-04-04
名称类型必须示例值描述 item
item[]1宝贝详情数据 第二步 根据语言编写接口请求代码 第三步 根据文档接入接口 参数说明
通用参数说明 参数不要乱传，否则不管成功失败都会扣费url说明 https://api-gw.onebound.cn/平台/API类型/ 平台：淘宝，京东等， API类型:[item_search,item_get,item_search_shop等]version:API版本key:调用key,测试key:test_api_keysecret:调用secret,测试secret:(不用填写)cache:[yes,no]默认yes，将调用缓存的数据，速度比较快result_type:[json,xml,serialize,var_export]返回数据格式，默认为jsonlang:[cn,en,ru] 翻译语言，默认cn简体中文secret:密钥 API:item_search 参数说明：
q:搜索关键字cat:分类IDstart_price:开始价格end_price:结束价格sort:排序[bid,bid,bid2,_bid2,_sale,_credit]
(bid:总价,bid2:商品价格,sale:销量,credit信用,加前缀为从大到小排序)page:页数page_size:每页宝贝数量，默认40seller_info:是否获取商家信息[yes,no],默认yes API:item_get 参数说明: num_iid:宝贝ID
此API目前支持以下基本接口：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/285dfc47ebcf2cb7efc612f9b6c10183/" rel="bookmark">
			论文阅读——SpectralGPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpectralGPT: Spectral Foundation Model
SpectralGPT的通用RS基础模型，该模型专门用于使用新型3D生成预训练Transformer（GPT）处理光谱RS图像。
重建损失由两个部分组成：令牌到令牌和频谱到频谱
下游任务：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7eb0605d1f78c9a8df99c88517423cc/" rel="bookmark">
			阿里云-零基础入门推荐系统 【特征工程】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 学习过程赛题介绍评价方式理解赛题理解制作特征和标签， 转成监督学习问题导包df节省内存函数训练和验证集的划分获取历史点击和最后一次点击读取训练、验证及测试集读取召回列表读取各种Embedding读取文章信息读取数据对训练数据做负采样将召回数据转换成字典制作与用户历史行为相关特征用户相关特征用户的设备习惯用户的时间习惯用户的主题爱好用户的字数偏好特征用户的信息特征合并保存用户特征直接读入文章的特征直接读入召回文章的主题是否在用户的爱好里面保存特征 期间报错解决方案汇总 学习过程 20年当时自身功底是比较零基础(会写些基础的Python[三个科学计算包]数据分析)，一开始看这块其实挺懵的，不会就去问百度或其他人，当时遇见困难挺害怕的，但22后面开始力扣题【目前已刷好几轮，博客没写力扣文章之前，力扣排名靠前已刷有5遍左右，排名靠后刷3次左右，代码功底也在一步一步提升】不断地刷、遇见代码不懂的代码，也开始去打印print去理解，到后面问其他人的问题越来越少，个人自主学习、自主解决能力也得到了进一步增强。
赛题介绍 该赛题是以新闻APP中的新闻推荐为背景， 目的是要求我们根据用户历史浏览点击新闻文章的数据信息预测用户未来的点击行为， 即用户的最后一次点击的新闻文章。
评价方式理解 最后提交的格式是针对每个用户， 我们都会给出五篇文章的推荐结果，按照点击概率从前往后排序。 而真实的每个用户最后一次点击的文章只会有一篇的真实答案， 所以我们就看我们推荐的这五篇里面是否有命中真实答案的。比如对于user1来说， 我们的提交会是：
user1, article1, article2, article3, article4, article5. 评价指标的公式如下：
假如article1就是真实的用户点击文章，也就是article1命中， 则s(user1,1)=1, s(user1,2-4)都是0， 如果article2是用户点击的文章， 则s(user,2)=1/2,s(user,1,3,4,5)都是0。也就是score(user)=命中第几条的倒数。如果都没中， 则score(user1)=0。 这个是合理的， 因为我们希望的就是命中的结果尽量靠前， 而此时分数正好比较高。
赛题理解 根据赛题简介，我们首先要明确我们此次比赛的目标： 根据用户历史浏览点击新闻的数据信息预测用户最后一次点击的新闻文章。从这个目标上看， 会发现此次比赛和我们之前遇到的普通的结构化比赛不太一样， 主要有两点：
首先是目标上， 要预测最后一次点击的新闻文章，也就是我们给用户推荐的是新闻文章， 并不是像之前那种预测一个数或者预测数据哪一类那样的问题数据上， 通过给出的数据我们会发现， 这种数据也不是我们之前遇到的那种特征+标签的数据，而是基于了真实的业务场景， 拿到的用户的点击日志 所以拿到这个题目，我们的思考方向就是结合我们的目标，把该预测问题转成一个监督学习的问题(特征+标签)，然后我们才能进行ML，DL等建模预测。
制作特征和标签， 转成监督学习问题 我们先捋一下基于原始的给定数据， 有哪些特征可以直接利用：
文章的自身特征， category_id表示这文章的类型， created_at_ts表示文章建立的时间， 这个关系着文章的时效性， words_count是文章的字数， 一般字数太长我们不太喜欢点击, 也不排除有人就喜欢读长文。
文章的内容embedding特征， 这个召回的时候用过， 这里可以选择使用， 也可以选择不用， 也可以尝试其他类型的embedding特征， 比如W2V等
用户的设备特征信息
构造监督数据集的思路， 根据召回结果， 我们会得到一个{user_id: [可能点击的文章列表]}形式的字典。 那么我们就可以对于每个用户， 每篇可能点击的文章构造一个监督测试集， 比如对于用户user1， 假设得到的他的召回列表{user1: [item1, item2, item3]}， 我们就可以得到三行数据(user1, item1), (user1, item2), (user1, item3)的形式， 这就是监督测试集时候的前两列特征。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7eb0605d1f78c9a8df99c88517423cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1bf078a7b0aadaa45906b8419baa148/" rel="bookmark">
			论文阅读_参数微调_P-tuning_v2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 P-Tuning PLAINTEXT
1 2 3 4 5 6 7 英文名称: GPT Understands, Too 中文名称: GPT也懂 链接: https://arxiv.org/abs/2103.10385 作者: Xiao Liu, Yanan Zheng, Zhengxiao Du, Ming Ding, Yujie Qian, Zhilin Yang, Jie Tang 机构: 清华大学, 麻省理工学院 日期: 2021-03-18 引用次数: 426 目标：大模型的 Prompt 构造方式严重影响下游任务的效果。离散化的 token 的搜索出来的结果可能并不是最优的，导致性能不稳定。本篇论文旨在探讨，如何提升预训练语言模型进行自然语言提示的有效性。
方法：作者提出了 P-Tuning，设计了一种连续可微的 virtual token（同 Prefix-Tuning 类似）。将 Prompt 转换为可以学习的 Embedding 层，用 MLP+LSTM 的方式来对 Prompt Embedding 进行处理。
结论：弥合 GPT 和 NLU 应用程序之间的差距 (2021 年)，P 调参后的 GPT 可以比在 NLU 调参的类似大小的 BERT 效果更好。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1bf078a7b0aadaa45906b8419baa148/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1651164bdc22a68efabcb6582b212b6/" rel="bookmark">
			简单高效多语言请求的主流电商平台API数据采集实时接口如何采集数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电商数据采集API功能概述：
1. 实时采集：1688采集能够自动从阿里巴巴和1688网站抓取商品信息，无需人工手动搜索，节省大量时间。
2. 商品筛选：用户可以根据需求设置采集条件，如价格、销量、信用度等，实现精准商品采集。
3. 数据导出：支持多种导出格式，如Excel、CSV等，方便用户将采集的数据进行进一步处理或分享。
4. 智能过滤：软件具备智能过滤功能，可自动过滤掉重复或无用的数据，提高采集效率。
5. 批量操作：支持批量下载、批量导出，轻松应对大规模数据采集需求。
6. 实时更新：商品信息实时更新，确保采集到的数据最新、最准确。
使用方法：
1. 注册测试登录：根据提示注册账号并登录。
2. 采集设置：根据需求设置采集条件，启动软件进行商品采集。
3. 数据导出：选择导出格式，即可将采集到的数据导出。
优势分析：
1. 提高效率：相比手工采集，软件自动执行任务，节省大量时间和精力。
2. 精准度高：通过筛选功能，精准采集所需商品信息，避免无用数据的干扰。
3. 降低成本：减少因手动搜索而产生的交通费、时间成本等支出。
4. 数据安全：实时更新数据，避免因数据泄露而产生的风险。
5. 多平台支持：不仅适用于阿里巴巴和1688平台，还可应用于其他电商平台。
总结：
使用便捷的数据采集与管理工具，能够帮助电商从业者提高工作效率，降低成本，并确保数据安全。无论你是新手还是资深电商从业者，都是你不容错过的好帮手。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/3/">«</a>
	<span class="pagination__item pagination__item--current">4/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/5/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>