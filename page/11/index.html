<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/28ac4798afae1292a4ec2e5129a07106/" rel="bookmark">
			力扣由浅至深 每日一题.06 删除有序数组中的重复项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		希望我们都能对抗生活的苦难，在乌云周围突破阴霾积极的生活
—— 24.3.16
删除有序数组中的重复项 提示
给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。
考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：
更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。 判题标准:
系统会用下面的代码来测试你的题解:
int[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i &lt; k; i++) { assert nums[i] == expectedNums[i]; } 如果所有断言都通过，那么您的题解将被 通过。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/28ac4798afae1292a4ec2e5129a07106/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45d3d55ebc222239d334011cf6f81bf0/" rel="bookmark">
			蓝桥杯算法基础（21）：（6道小题：奇数在左，第k个元素,超过一半的数字，最小可用ID，合并有序数组，逆序对个数）java版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题1:奇数在左 调整数组顺序使奇数位于偶数前面:输入一个整数数组，调整数组中数字的顺序，是的所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。要求时间复杂度为o(n).
1.可以用快排的思想，用双指针，左指针找偶数，右指针找奇数，两者交换，直到左右指针交叉 static void Sort1(int[] arr,int length){ int left=0; int right=length-1; while(left&lt;=right){ while(arr[left]%2==1)left++; while(arr[right]%2==0)right--; Util.swap(arr,left,right); } } 2.可以利用辅助空间，奇数放到左边，偶数放到右边 不过复杂度高一点 第k个元素 以尽量高的效率求出一个乱序数组中按数值顺序的第k个元素值 （伪代码） selectK(A,p,r,k){ q=partition(A,p,r);//主元的下标 qK=q-p+1;//主元是第几个元素 if(qK==k) return A[q]; else if(qK&gt;k){ return selectK(A,p,q-1,k); else return selectK(A,p+1,q,k-qK);//若是选右边，K需要有所变化，中间开始算第一个，k-qK找的是第k-qK而不是下标 } } partition(A,p,r);//快排求主元，将小于等于主元的放到数组左边，大于主元的放到右边 超过一半的数字 数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。 解法1:排序后返回arr[N/2] static void solve1(int[] arr){ Arrays.sort(arr); System.out.println(arr.length/2); } 解法2:hash统计（计数） static void solve2(int[] arr){ int maxcount=0,max=0; int arr1[arr.length];//默认值为0 for(int i=0;i&lt;arr.length;i++) arr1[arr[i]]++; for(int i=0;i&lt;arr.length;i++) { if(arr1[i]==0)continue; if(arr1[i]&gt;maxcunt) {maxdount=arr1[i]; max=i; } } System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45d3d55ebc222239d334011cf6f81bf0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf5524402512b3be580858048682c6d0/" rel="bookmark">
			C#，图论与图算法，图（Graph）的数据结构设计与源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为后面即将发布的大量有关“图”的算法与源代码都需要用到下面的这些基础数据，为避免大家去下载，特意先发布于此。
一、图（Graph）的基础知识 图（Graph）是一组对象的图示，其中一些对象对通过链接连接。互连对象由称为顶点的点表示，连接顶点的链接称为边。
形式上，图是一对集（V，E），其中V是顶点集，E是连接顶点对的边集。
图形数据结构
数学图可以用数据结构表示。我们可以使用顶点数组和二维边数组来表示图。在继续之前，让我们先熟悉一些重要的术语−
顶点− 图的每个节点都表示为一个顶点。在以下示例中，带标签的圆表示顶点。因此，A到G是顶点。我们可以使用下图所示的数组来表示它们。这里A可以通过索引0来标识。B可以使用索引1等进行识别。
边− 边表示两个顶点之间的路径或两个顶点之间的线。在以下示例中，从A到B、B到C等的线表示边。我们可以使用二维数组来表示数组，如下图所示。这里AB可以表示为第0行第1列的1，BC可以表示为第1行第2列的1，依此类推，其他组合保持为0。
邻接关系− 如果两个节点或顶点通过边相互连接，则它们是相邻的。在以下示例中，B与A相邻，C与B相邻，依此类推。
路径− 路径表示两个顶点之间的边序列。
二、图的基本操作 以下是图形的基本主要操作：
添加顶点 — 将顶点添加到图形中。
添加边 — 在图形的两个顶点之间添加边。
显示顶点 — 显示图形的顶点。
遍历 — 深度优先遍历，宽度优先遍历；
布局 — 图的布局算法
三、图的相关数据 1、节点 using System; using System.Text; using System.Collections; using System.Collections.Generic; namespace Legalsoft.Truffer.Algorithm { /// &lt;summary&gt; /// 图的结点（坐标）信息 /// &lt;/summary&gt; public class Node { /// &lt;summary&gt; /// 编号 /// &lt;/summary&gt; public int Id { get; set; } = 0; /// &lt;summary&gt; /// X坐标 /// &lt;/summary&gt; public double X { get; set; } = 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf5524402512b3be580858048682c6d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ff5d4b555734061ef9faee7956d8c1b/" rel="bookmark">
			【Python实用技能】建议收藏：自动化实现网页内容转PDF并保存的方法探索（含代码，亲测可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是同学小张，日常分享AI知识和实战案例欢迎 点赞 + 关注 👏，持续学习，持续干货输出。+v: jasper_8017 一起交流💬，一起进步💪。微信公众号也可搜【同学小张】 🙏 本站文章一览：
有时候，我们想要将一些网页数据下载到本地，一般有两种做法。
第一种，打开网页，将网页中的内容复制粘贴到本地新建的一个空白文档中。
第二种，打开网页，右键 —&gt; 打印，另存为PDF，如下图
第二种将网页保存成PDF的方法，能更好地保证网页内容的完整性和格式，看起来也比较美观，操作起来也比较方便。但是当URL数量多起来之后，这个重复的工作就比较枯燥了。
本文将探索自动化把URL列表所对应的网页打印成PDF文件的实现方法，内含完整代码，可直接运行使用，建议收藏备用。
文章目录 1. 自动化方法探索1.1 通过 pdfkit1.1.0 环境准备1.1.0.1 安装 pdfkit1.1.0.2 安装 wkhtmltopdf 1.1.1 实现代码1.1.2 实现效果1.1.3 踩坑 1.2 通过 selenium1.2.1 实现代码1.2.2 实现效果1.2.3 代码改进1.2.4 改进后效果1.2.5 踩坑 2. 该工作的意义与用途畅想 1. 自动化方法探索 1.1 通过 pdfkit 参考：https://blog.csdn.net/dchzxl/article/details/125363204
1.1.0 环境准备 1.1.0.1 安装 pdfkit pip install pdfkit 1.1.0.2 安装 wkhtmltopdf 下载地址：https://wkhtmltopdf.org/downloads.html
1.1.1 实现代码 import pdfkit path_wk = r'd:\\wkhtmltopdf\\bin\\wkhtmltopdf.exe' #你的wkhtmltopdf安装位置 config = pdfkit.configuration(wkhtmltopdf = path_wk) url = 'https://mp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ff5d4b555734061ef9faee7956d8c1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c57d5d267378140c7a0c5b10510ed3/" rel="bookmark">
			(())双圆结构扩展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.(())双圆结构扩展介绍 使用linux下(())双圆结构扩展并计算一个算术表达式的值时，如果表达式的结果为0，那么返回的退出状态码为1，或者是“假/false”；如果表达式的结果为一个非零值，那么返回的退出状态码为0，或者是“真/true”。这种情况和先前介绍的test命令和[]结构的行为正好相反。
2.(())双圆结构扩展样例 样例：
[root@elasticsearch ~]# vim double_circle.sh [root@elasticsearch ~]# [root@elasticsearch ~]# [root@elasticsearch ~]# cat double_circle.sh #!/bin/bash #(())结构可以用来计算并测试算术表达式的结果，退出状态将会与[]结构完全相反! (( 0 )) echo "Exit status of \"(( 0 ))\" is $?." (( 1 )) echo "Exit status of \"(( 1 ))\" is $?." (( 5 &gt; 4 )) echo "Exit status of \"(( 5 &gt; 4 ))\" is $?." (( 5 &gt; 9 )) echo "Exit status of \"(( 5 &gt; 9 ))\"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9c57d5d267378140c7a0c5b10510ed3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3629a2794ad9e06fed31d33d1bb2d074/" rel="bookmark">
			鸿蒙Harmony应用开发—ArkTS声明式开发（基础手势：ScrollBar）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		滚动条组件ScrollBar，用于配合可滚动组件使用，如List、Grid、Scroll。
说明：
该组件从API Version 8开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。
子组件 可以包含单个子组件。
接口 ScrollBar(value: ScrollBarOptions)
参数：
参数名参数类型必填参数描述valueScrollBarOptions是滚动条组件参数。 ScrollBarOptions对象说明 参数名参数类型必填参数描述scrollerScroller是可滚动组件的控制器。用于与可滚动组件进行绑定。directionScrollBarDirection否滚动条的方向，控制可滚动组件对应方向的滚动。
默认值：ScrollBarDirection.VerticalstateBarState否滚动条状态。
默认值：BarState.Auto 说明：
ScrollBar组件负责定义可滚动区域的行为样式，ScrollBar的子节点负责定义滚动条的行为样式。
滚动条组件与可滚动组件通过Scroller进行绑定，且只有当两者方向相同时，才能联动，ScrollBar与可滚动组件仅支持一对一绑定。
ScrollBarDirection枚举说明 名称描述Vertical纵向滚动条。Horizontal横向滚动条。 示例 // xxx.ets @Entry @Component struct ScrollBarExample { private scroller: Scroller = new Scroller() private arr: number[] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] build() { Column() { Stack({ alignContent: Alignment.End }) { Scroll(this.scroller) { Flex({ direction: FlexDirection.Column }) { ForEach(this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3629a2794ad9e06fed31d33d1bb2d074/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e54004f734be8ab38481467c822c7f7/" rel="bookmark">
			【毕业设计】基于springboot&#43;微信小程序的爱公益平台
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言一、毕设目录二、系统介绍三、系统架构四、系统环境五、系统页面展示小程序前台管理后台 结语 前言 【毕业设计】管理系统
🥇个人主页：@MIKE笔记
🥈文章专栏：毕业设计源码合集
⛄联系博主： wx：mikenote
一、毕设目录 https://space.bilibili.com/306719765/video
二、系统介绍 基于Spring Boot、MySQL和微信小程序的爱公益平台是一个用于公益活动的在线平台。下面是一个基本的架构设计和功能概述：
架构设计
后端（Spring Boot + MySQL） Spring Boot：用于构建后端RESTful API服务。
MySQL：用于存储用户信息、公益活动信息、捐赠记录等。
安全性：使用Spring Security进行权限管理和身份验证。
数据访问：使用MyBatis或JPA进行数据持久化。
前端（微信小程序） 界面设计：简洁明了的界面，易于用户使用。
交互逻辑：与后端API进行交互，获取和展示数据。
用户体验：优化用户体验，确保流畅操作。
功能概述
用户管理 注册/登录：用户可以通过微信小程序进行注册和登录。
个人信息管理：用户可以查看和编辑自己的个人信息。
公益活动展示 活动列表：展示当前正在进行的公益活动。
活动详情：展示活动的详细信息，包括活动背景、目的、进展等。
捐赠功能 选择捐赠活动：用户可以选择想要捐赠的公益活动。
捐赠金额选择：用户可以选择捐赠的金额。
捐赠记录：记录用户的捐赠信息，包括捐赠时间、金额等。
消息通知 活动更新通知：当活动有更新时，通知用户。
捐赠成功通知：用户捐赠成功后，发送通知。
后台管理 活动管理：管理员可以创建、编辑和删除公益活动。
用户管理：管理员可以查看和管理用户信息。
捐赠记录查看：管理员可以查看所有的捐赠记录。
开发流程
需求分析：明确平台需要实现的功能和用户体验。
设计数据库结构：根据需求设计MySQL数据库表结构。
搭建Spring Boot后端服务：创建RESTful API接口。
开发微信小程序前端：设计界面并实现交互逻辑。
前后端联调：确保前端和后端能够正常通信。
测试与优化：进行功能测试、性能测试和用户体验优化。
部署上线：将平台部署到服务器上，供用户使用。
注意事项
安全性：确保用户数据的安全性和隐私性。
性能优化：优化数据库查询和API性能，确保平台响应迅速。
用户体验：注重用户体验，确保平台易用且美观。
持续维护：定期更新和维护平台，确保稳定运行。
三、系统架构 后端: Spring Boot2.5.3、Mybatis前端：Vue2.0数据库：Mysql 四、系统环境 环境版本 / 下载系统win 10 /win 11JDK1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e54004f734be8ab38481467c822c7f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2a866dea6d73c6c89f9fb1373cc71b8/" rel="bookmark">
			7.Visual Studio的下载、安装、设置中文和配置环境解释器变量——《跟老吕学Python编程》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		7.Visual Studio的下载、安装、设置中文和配置环境解释器变量——《跟老吕学Python编程》 Visual Studio 简介Visual Studio 下载、安装、汉化、常用插件和激活Visual Studio 官网Visual Studio 下载在Windows上安装1.安装2.Visual Studio Installer3.耐心等待4.工作负荷选项5.单个组件选项6.语言包选项7.安装位置选项8.启动安装9.安装完成 在Mac OS X 上在UNIX/Linux上 Visual Studio 简介 ···
Visual Studio 是一款功能强大的开发人员工具，可用于在一个位置完成整个开发周期。 它是一种全面的集成开发环境 (IDE)，可用于编写、编辑、调试和生成代码，然后部署应用。 除了代码编辑和调试之外，Visual Studio 还包括编译器、代码完成工具、源代码管理、扩展和许多其他功能，以改进软件开发过程的每个阶段。
Visual Studio 为开发人员提供了功能丰富的开发环境，用于高效协作开发高质量代码。
基于工作负载的安装程序 - 仅安装所需内容功能强大的编码工具和功能 - 在一个位置生成应用所需的一切多语言支持 - 使用 C++、C#、JavaScript、TypeScript、Python 等编码跨平台开发 - 为任何平台生成应用版本控制集成 - 与团队成员协作开发代码AI 辅助开发 – 使用 AI 辅助更高效地编写代码 Visual Studio 下载、安装、汉化、常用插件和激活 Visual Studio 官网 https://visualstudio.microsoft.com
Visual Studio 下载 Visual Studio的官方网站下载地址
https://visualstudio.microsoft.com/zh-hans/downloads/
建议大家使用【社区版】，该版本是免费的
老吕用的是企业版，因为涉及到更深度的工作功能
在Windows上安装 1.安装 双击运行，看到如下窗口，然后点击继续
2.Visual Studio Installer 看到如下窗口，耐心等待
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2a866dea6d73c6c89f9fb1373cc71b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c266bfb93a8f9e53af8da5c313c6af4/" rel="bookmark">
			Hive Sql获取含有特殊字符key的json数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 hive表中json数据的key含有.符号，所以使用get_json_object(str,“$.key_1.key_2”)语法的时候就会获取到null。解法是通过json_to_map方法将json数据变成一个map结果，然后用key下标的方式获取值，代码
json_to_map(str)["key_1.key_2] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8dae5461997e58870d7b6ae939f951d1/" rel="bookmark">
			已解决org.apache.zookeeper.KeeperException.NodeExistsException异常的正确解决方法，亲测有效！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已解决org.apache.zookeeper.KeeperException.NodeExistsException异常的正确解决方法，亲测有效！！！
目录
问题分析
报错原因
解决思路
解决方法
检查节点存在性
幂等性设计
异常捕获处理
总结
博主v：XiaoMing_Java
问题分析 在使用Apache ZooKeeper进行节点（Znode）操作时，遇到org.apache.zookeeper.KeeperException.NodeExistsException异常通常表示尝试创建一个已经存在的节点。在分布式系统中，多个客户端可能同时尝试创建同一节点，当节点已被创建，随后的创建请求会导致这个异常。
报错原因 造成NodeExistsException的主要原因是：
节点已存在：在创建节点时，如果该节点已经存在，则会抛出此异常。并发操作：多个客户端或线程并发尝试创建相同的节点，第一个成功的操作之后，其他操作会触发异常。状态同步延迟：在分布式环境中，客户端与ZooKeeper服务器之间存在状态信息的延迟同步，可能导致客户端认为节点不存在而实际上已存在。 解决思路 针对NodeExistsException的处理策略如下：
检查节点存在性：在创建节点前检查节点是否已存在。幂等性设计：确保创建节点的操作是幂等的，即重复执行不会影响系统状态。异常捕获处理：妥善捕获NodeExistsException并根据业务逻辑决定后续行为。 解决方法 检查节点存在性 在尝试创建节点前，先判断节点是否存在，如果不存在再进行创建：
import org.apache.zookeeper.ZooKeeper; import org.apache.zookeeper.CreateMode; import org.apache.zookeeper.ZooDefs.Ids; public void createNodeIfNotExists(ZooKeeper zk, String path, byte[] data) throws Exception { if (zk.exists(path, false) == null) { // 判断节点是否存在 zk.create(path, data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // 创建节点 } } 幂等性设计 设计你的节点创建逻辑，使其具有幂等性。即使操作多次执行，也能确保不会引起错误：
public void createNodeIdempotent(ZooKeeper zk, String path, byte[] data) { try { zk.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8dae5461997e58870d7b6ae939f951d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/333ef06f139d4129b7b905bf7a095ff4/" rel="bookmark">
			【Flink SQL】Flink SQL 基础概念（三）：SQL 动态表 &amp; 连续查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Flink SQL 基础概念》系列，共包含以下 5 篇文章：
Flink SQL 基础概念（一）：SQL &amp; Table 运行环境、基本概念及常用 APIFlink SQL 基础概念（二）：数据类型Flink SQL 基础概念（三）：SQL 动态表 &amp; 连续查询Flink SQL 基础概念（四）：SQL 的时间属性Flink SQL 基础概念（五）：SQL 时区问题 😊 如果您觉得这篇文章有用 ✔️ 的话，请给博主一个一键三连 🚀🚀🚀 吧 （点赞 🧡、关注 💛、收藏 💚）！！！您的支持 💖💖💖 将激励 🔥 博主输出更多优质内容！！！
Flink SQL 基础概念（三）：SQL 动态表 &amp; 连续查询 1.SQL 应用于流处理的思路2.流批处理的异同点及将 SQL 应用于流处理核心解决的问题3.SQL 流处理的输入：输入流映射为 SQL 动态输入表4.SQL 流处理的计算：实时处理底层技术 - SQL 连续查询5.SQL 流处理实际应用：动态表 &amp; 连续查询技术的两个实战案例5.1 查询案例一5.2 查询案例二 6.SQL 连续查询的两种类型：更新（Update）查询 &amp; 追加（Append）查询7.SQL 流处理的输出：动态输出表转化为输出数据8.补充知识：SQL 与关系代数 1.SQL 应用于流处理的思路 在流式 SQL 诞生之前，所有的基于 SQL 的数据查询都是基于批数据的，没有将 SQL 应用到流数据处理这一说法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/333ef06f139d4129b7b905bf7a095ff4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7af75b8be986f57d7ddc3480aab77db/" rel="bookmark">
			【Flink SQL】Flink SQL 基础概念（四）：SQL 的时间属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Flink SQL 基础概念》系列，共包含以下 5 篇文章：
Flink SQL 基础概念（一）：SQL &amp; Table 运行环境、基本概念及常用 APIFlink SQL 基础概念（二）：数据类型Flink SQL 基础概念（三）：SQL 动态表 &amp; 连续查询Flink SQL 基础概念（四）：SQL 的时间属性Flink SQL 基础概念（五）：SQL 时区问题 😊 如果您觉得这篇文章有用 ✔️ 的话，请给博主一个一键三连 🚀🚀🚀 吧 （点赞 🧡、关注 💛、收藏 💚）！！！您的支持 💖💖💖 将激励 🔥 博主输出更多优质内容！！！
Flink SQL 基础概念（四）：SQL 的时间属性 1.Flink 三种时间属性简介2.Flink 三种时间属性的应用场景2.1 事件时间案例2.2 处理时间案例2.3 摄入时间案例 3.SQL 指定时间属性的两种方式4.SQL 事件时间案例5.SQL 处理时间案例 与离线处理中常见的时间分区字段一样，在实时处理中，时间属性也是一个核心概念。Flink 支持 处理时间、事件时间、摄入时间 三种时间语义。
三种时间在生产环境的使用频次 事件时间（SQL 常用） &gt; &gt; &gt; 处理时间（SQL 几乎不用，DataStream 少用） &gt; &gt; &gt; 摄入时间（不用）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7af75b8be986f57d7ddc3480aab77db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b2bad30209e33064f977531b7683fd1/" rel="bookmark">
			应用层_HTTP&amp;HTTPS
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在应用层中，协议一般是程序员定制的，但现在已经有了许多非常好用的协议，我们可以直接参考使用。其中http和https便是其中最常用的协议之一。
一.HTTP 超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。我们学习http协议，就要先了解这个协议请求与响应的格式。
1.1 URL URL是统一资源定位符，对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址，俗称网址。
我们访问互联网上的资源，即访问对应服务器上的一些资源。首先就必须要知道该服务器的ip地址和端口号，以及该服务上资源的具体位置。这些信息被组织在一起形成URL，于是我们就可以通过URL来访问目标服务器上的唯一资源。
URL通常是有协议名，域名，端口号，文件路径，查询参数构成。
协议名：通常是http/https，但由于http不安全，现在基本都是https域名：由域名解析系统最终会转换为ip地址端口号：http默认端口号为80，https为443，由浏览器自动指定文件路径：以/开始，这个/代表web根目录，以当前服务器的工作路径为基础查询参数：查询参数与文件路径通过?分割，参数之间通过&amp;分割。kv结构 urlencode与urldecode：
由于url中有一些特殊字符，比如：&amp; 汉字等，这些字符如果出现在查询参数中，浏览器会自动对其进行转换。反之，服务器会对url的转移字符进行解码获得实际字符。
* 将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY 格式
1.2 http请求 请求行：由三部分组成，以空格为分割，以\r\n为结尾，以区分请求行与请求报头请求报头：由若干行kv结构组成空行：用于区分http请求报头与有效载荷，以行为单位读取，读到空行表示报头读取结束有效载荷：防止用户提交的参数，可以没有
1.2.1 请求方法 POST: 通过正文部分提交参数等。html中，浏览器会根据表单(form)中的属性，封装不同请求方法的请求报文，将用户信息提交到服务端。GET：获取静态网页和通过URL的方式提交参数。GET方法提交参数不私密，POST提交参数私密一些，所有的登录注册支付都要使用POST方法提参。它们两个不是安全的，可以使用fiddler进行抓取浏览器请求
1.3 http响应 状态行：由三部分组成，以空格为分割，以\r\n为结尾，以区分状态行与响应报头响应报头：由若干行kv结构组成空行：用于区分http响应报头与有效载荷，以行为单位读取，读到空行表示报头读取结束有效载荷：携带用户请求的资源
1.3.1 http状态码 3XX：永久性重定向-更改浏览器的本地书签，临时重定向-不更改浏览器的地址信息 302：临时重定向307：临时重定向，使用get提交301：永久重定向 4XX：404-Not Found ，403-forbidden5XX：504-Bad Gateway 应用场景：
当你进入一个网页时，会自动跳转到另一个网页，这就是临时重定向 1.3.2 请求报头与响应报头属性： Host：x.x.x.x:port 主机ip+portConnection: keep-alive 长链接 在http/1.0中一个网页中可能包含许多不同资源，每个资源就会发起一次tcp连接，但这样效率太低，因此在http/1.1中只需要建立一次tcp连接，就可以将所有http请求发送到服务端。 user-agent：xxxxx 浏览器字段Content-Length： xxx 有效载荷长度，防止粘包问题Content-Type：xxx 有效载荷中的资源类型，如何解释 在百度中搜索Content-Type对照表，可以查看各种资源的类型 Location：xxxx 配合重定向使用referer：当前网页是从哪个网页跳转的Set-Cookie：xxxx
1.4 http的会话保持功能 http是无状态的！它只用来进行超文本传输。但是用户需要保持以前的状态，便于提高用户体验，所以http就要将用户是否在线要持续的记录下来，这就是http的会话保持。http的会话保持是通过cookie和session实现的。
客户端根据服务端发来的Set_Cookie信息，将cookie保存到本地文件/内存中。但这种方式有安全问题，当电脑被植入了木马病毒时，此时本地的cookie将会被黑客拿到，此时你的账号就会被盗用。现在用的是在服务端形成session对象（内存/文件），给客户端返回一个session id，用户再次访问服务端，将session_id提交到服务端，此时服务端根据session_id+ip进行用户身份核验。这个session_id是用特定算法形成的唯一值。
此时cookie信息保存在服务端，而不是客户端，一定程度上保证了用户信息的安全。如果黑客盗取了cookie的信息session id ，但是两次登录的ip地址不一样，就会识别到异常登录，释放session对象。
二.HTTPS HTTPS （全称：Hypertext Transfer Protocol Secure），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入SSL，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b2bad30209e33064f977531b7683fd1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b840a25f6b208f5e719050b824397266/" rel="bookmark">
			代码随想录算法训练营day61丨一刷总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一刷感觉还是收获挺大的，虽然依然很菜吧就是。
感觉对二叉树、KMP算法，回溯算法，贪心、动态规划，还有单调栈，都挺印象深刻。
二叉树作为一个很常用的数据结构，它经常和算法进行结合，就比如说打家劫舍III，就涉及到了二叉树的遍历问题，其实二叉树的很多题都需要遍历来解决，通常就是在递归遍历的时候，更新什么值或者传递信息进行类似于回溯算法，所以说二叉树的遍历是一个很重要的问题。遍历主要就是分为递归的遍历，还是用队列和栈来遍历，递归便利的话就必须是前中后序的遍历，如果用队列的话就是层序遍历。然后因为递归函数其实是用栈来实现的，所以说前中后序的遍历是可以用栈来实现的。但实际上，做题的时候经常用递归函数来遍历，因为比较方便，写起来也简单易懂。
Kmp算法主要是有记忆的比较，主要是用来找一个字符串里面有没有包含目标字符串的。它需要用next数组来进行跳转，跳转到具有相同前缀的地方， 其中重要的是对next数组求解。
回溯算法是套模板就行了，其实整体来说它的难题不是特别难。
贪心算法主要就是容易想到的很容易想到，但是不容易想到的是真不容易想到，它主要是靠积累的，这次训练营也是做了很多贪心算法的题，感觉自己收获很大。
动态规划真的是进行了好多好多章节，真的是做题做到崩溃了都，它有编辑距离问题，背包问题，股票问题都很复杂，我感觉最复杂的最难搞的其实是dp数组的定义，如果对dp数组的定义有很得到的见解的话，其实它的推导公式就会变得简单一些，但是关键这个dp数组的定义有时候就，可能我比较傻，反正就是想不到，但是最后文章里面也给出了dp数组的定义通常就是题目要求解的问题，其实做的几道题里面大多数都是这样，当然也有例外，还是得多做题积累。
最后就是单调栈的问题了，单调栈就是针对一个数组，要解决寻找他左右方的最值问题或者比它大的值什么的。最后做的那几道题都很难，但是仔细想想，其实也就是加深对单调栈的理解就能解决的事，其实还是要多做题。
最后的最后，我之前看别人的博客说有什么奖励，我就一直等着呢，然后没想到是写完了博客之后，还要有最后总结的这篇才会解锁奖励，还是期待。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a7c27dd94e3ae5807dc3d5cd319bf0d7/" rel="bookmark">
			Discourse 分类图片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以在 Discourse 上为分类添加图片。
进入分类编辑界面，然后选择 Image 标签。
在 Images 标签下，上传分类需要的图片。
图片大小 图片的大小是 Discourse 进行控制的，高度为 150 PX 像素。
如果上传的图片大于 150 px 的高度像素，那么 Discourse 将会把图片压缩到 150PX 像素。
如果上传的图片小于这个像素，那么图片将会进行拉伸。
为了图片有更好的效果，建议使用高度大于 150px 像素的图片。
Discourse 分类图片 - Discourse - iSharkFly
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8461c72cc89e064f03d35db84c3eb3f2/" rel="bookmark">
			计算机毕业设计-基于大数据技术下的高校舆情监测与分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		收藏和点赞，您的关注是我创作的动力
文章目录 概要 一、研究背景与意义1.1背景与意义1.2 研究内容 二、舆情监测与分析的关键技术2.1 robot协议对本设计的影响2.2 爬虫2.2.1 工作原理2.2.2 工作流程2.2.3 抓取策略2.3 scrapy架构2.3.1 scrapy：开源爬虫架构2.3.2 scrapy框架结构2.3.3 两种继承，两种爬虫模式 三、需求分析和系统总体架构3.2 系统需求分析3.2.1 业务需求分析3.2.2 功能性需求分析3.3 系统总体架构3.3.1 爬取对象分析3.3.2 模块设计 四、系统实现4.1爬虫模块4.1.1 环境搭建与前期分析4.1.2 系统爬取4.2数据分析模块4.3数据可视化模块4.3.1词云展示4.3.2热点话题词频4.3.3贴吧评论数量区间 五、 总结 概要 随着科技的飞跃式发展，通讯手段与交流方式不断更新，网络作为信息通讯的重要媒介，成为了高校学生沟通交流、发表观点的重要平台。高校学生通过利用网络公民自发形成的舆论圈，交流更为便捷，传播更为多元，使得高校舆情具有了随意性、直接性、偏差性、突发性四大特征，对社会中的舆情传播产生的影响不可小觑，所以高校需要及时掌握学生舆情的发展动态，可以及时做出有效的监管和正确的引导。
通过对高校网络舆情监测的实际需求分析和概要分析，本文在现有国内外舆情监测的基础上，构建了以python爬虫技术为基础的高校舆情监测与分析系统，并且根据高校管理人员的实际需求对系统做了详细的分析与设计，通过网络讨论平台获取大量舆情数据进行整合分析，从而实现多态势舆情的实时监控和舆情数据分析的可视化，其中包含媒体分析、热度分析、受众分析等。舆情监测与分析系统包括了四个模块：舆情关键字管理模块、舆情分析模块、舆情结果可视化模块、舆情报告模块。从舆情关键词建立到舆情报告的展示，高校舆情监测与分析系统将为高校管理人员提供准确高效的舆情发展态势，辅助高校了解学生内心动态，及时发展舆情的产生，调整高校的管理政策，促进学生的健康成长和高校的稳健发展。
关键词：高校舆情；网络爬虫；舆情监测；舆情分析
一、研究背景与意义 当互联网技术逐渐渗透进入社会的各种领域，已然成为社会中不可或缺的一部分。人们获取信息的途径以及日常交流也逐渐由线下转为线上，使得信息的传播速度呈指数式增长，同时随着生活条件的提升和互联网工具的普及，网民数量急剧增长，年龄趋于年轻化。其中作为生活得到初步自由的高校学生，他们是在网络上发表意见和关注社会热点的重要群体，因而高校学生对于网络舆情的爆发和推动起到关键性作用。由于高校学生涉世未深，长期处于校园生活，对社会热点的看法容易受到蛊惑和欺骗，从而在网络上肆意表达自己的情绪，对社会和学校造成严重的后果。随着大数据时代的到来，应用大数据技术分析网络舆情发展走向，遏制舆情的产生，是高校管理部门对舆情监测与分析的研究方向。
1.1背景与意义 随着信息时代的崛起，网络对人们的作用越来越大。几年之间，信息的传播还依靠传统的报纸、广播等方式传播，现如今网络时代的快速发展使得互联网成为信息最主流的传播途径。截止2019年6月，我国的网民规模高达8.54亿。人们可以通过网络平台及时获取信息，并且快速对信息做出反馈 舆情在网络中产生的方式，就是人们通过网络平台针对社会热点问题发表自己的看法和宣泄情绪的过程。网络舆情的要素包括：互联网、网民、热点事件、互动传播、情感。互联网舆情信息以公共媒体、自媒体为载体，围绕某个社会热点事件，通过网络传播的迅速性大量聚集情感信息，对相关管理部门产生一定的影响。
网络媒体具有极强的自由性，目前网络监管机制尚不完善，网民利用网络自由和可匿名的特点，肆意的在网络平台发表观点、宣泄情绪，使得网民的表达增加真实、顺畅。对于传统的信件报纸而言，网络可以直观的、迅速的看到社会问题，表达人们的心声，分享他人的意见。同时，网络又具有极强的交互性，网民通过参与社会热点问题的讨论或者向有关部门的反映，网民在交流互动的过程中，难免有时无法控制住自己的情绪，导致网络暴力事件频发，成为网络安全的一大隐患。由于消息是由网民自发性传播扩散，其中掺杂着浓厚的感情色彩，在传播的过程中背离信息原有的真实性，甚至有些为了达到目的故意歪曲事实，随着传播过程的积累，往往会形成强大的舆论，对社会甚至国家产生重大的影响，从而如何利用好网络弘扬社会正气，完善舆情监测分析系统，对舆情的产生提早发现，管理人员及时制定相应的解决方案，是新时代下国家的重点任务。对于高校来说，第一时
间监测到舆情发展动向，是高校掌握学生动态的重要因素，也是对学生的心理需求进行相应的疏导的首要前提。
1.2 研究内容 高校学生作为信息爆炸时代舆情产生和传播的主力军，对舆情的走向起到关键性作用，所以建立高校舆情监测与分析系统成为当下首要的任务，尤其是在当下信息多元化的时代。因此本文针对以上问题，设计一个高校的舆情监测与分析系统的模型和框架，并对模块和组件之间的关系完善了其主要功能。本文完成的工作包含以下内容：
1.通过对多所高校的管理人员的询问调查，在图书馆翻阅相关书籍，对高校舆情监测与分析系统的需求做出了分析，建立了一套高校舆情监测的系统框架，并且使用信息系统中常见的模块化思想对系统做出设计。
2.根据需求分析，对高校舆情监测与分析系统作了详细设计，对数据采集模块和数据分析模块做了详细的设计。
3.通过对高校学生的了解，贴吧是学生讨论、发表观点最集中的平台，对高校贴吧论坛进行帖子的规模爬取，得到数据分析所需要的数据。
4.对所得的数据进行敏感词分析，得到关键词在贴吧中的出现频率，进而反应某些舆情的出现。
本文的整体结构安排由五章构成，各章节安排如下。
第一章：绪论，阐述高校舆情监测与分析研究的背景，网络舆情中高校学生所占据的重要性，并阐述了舆情监测与分析国内外的研究现状。
第二章：高校舆情监测与分析的相关介绍，并对相关技术以及算法进行了介绍。如爬虫架构scrapy等。
第三章：系统需求分析与系统架构，通过对需求的分析和架构的设计，明确了系统的模块构成。然后对各个模块进行了介绍。
第四章：根据高校舆情监测与分析系统，对高校舆情检测结果的分析，展示了高校舆情监测与分析系统的部分界面。
第五章：总结与展望。总结了系统设计过程中的一些所思所想。然后对本系统的进一步研究方向进行了展望。
二、舆情监测与分析的关键技术 2.1 robot协议对本设计的影响 robot协议的全称为“网络爬虫排除标准”，网络站点通过Robot协议告知爬虫此站的网页哪些能进行爬取，哪些不能爬取。
robots.txt文件为robot协议最根本的表现。将网站视作交通信号的话，robots.txt则是某些路口的红绿灯“红灯禁行”或“绿灯可行”的信号，爬虫就是通过路口的汽车，根据信号灯的指示通行。
robot协议在法律中也没有强制的规定，更没有正式的协议表明，他只是爬虫技术中约定好的一种内部协议，更像是一种行业规范，爬取与被爬取者需要自觉遵守的协议[13]。当今社会大多数互联网企业都在遵循robot协议，很好的体现出互联网行业的一种契约精神。
如果此系统遵循robot协议，则此舆情监测系统将不能爬取到完整的数据。由于此爬虫系统不是用于商业利益而开发设计，仅仅作为研究学习使用，此系统为了数据的完整性获取，此爬虫系统需要不遵守robot协议。在scrapy架构中的setting.py文件中设置即可。
2.2 爬虫 2.2.1 工作原理 爬虫的含义是指一段自动的向互联网上某些网页发出请求并接收响应，根据一定规则继续爬取信息或从响应中提取出有用的信息的一段程序。爬虫的运行中会涉及到：网络请求、网络解析，其可以主要运行依托于以下几种技术。
URL（Universal Resource Identifier）：通用资源标识符，网络中每个资源都是由一个唯一的URL确定，根据URL也可以定位到网络中的唯一一个资源。
HTTP协议：超文本传输协议，此协议是网络中应用最为常见的一种协议，HTTP协议提供了发布与接收HTML页面的方法，由HTML语言编写的网页代码可由浏览器渲染成结构清晰的页面。
2.2.2 工作流程 一个传统的爬虫往往是从一批URL开始的，爬虫先请求这批URL的网页内容，得到正确的应答后，对页面内容进行解析，然后根据预先设计好的规则从网页中找到某些URL加入到请求队列中，或者从网页中定位到所需要的信息，并将信息进行封装保存。循环往复，不断从请求队列中提取URL进行请求，直至请求队列为空或某些其他情况导致爬虫程序终止为止
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8461c72cc89e064f03d35db84c3eb3f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6802827be0d3b39259b109889ff062a0/" rel="bookmark">
			eclipse自动生成注释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		windows-&gt;preference-&gt;java-&gt;code style-&gt;code templates
然后点这里
其他的什么注释可以在comment里面看
然后新建一个文件
写一个方法
然后在方法上面写/**
再按个回车，就自动生成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e85f47180bbd71982d563701c80992c/" rel="bookmark">
			Selenium 自动化 —— 使用WebDriverManager自动下载驱动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章 入门和 Hello World 实例 中，我们提供了一个最简单的 Selenium 上手的例子。
但是某一天，突然发现相同的代码居然运行报错了。这是怎么回事呢？
日志排查 日志中其实提示的很明显了：Chrome浏览器和Chrome WebDriver的版本不匹配。当前WebDriver只支持Chrome浏览器版本114.
先检查一下我们的Chrome WebDriver版本是114：
System.setProperty("webdriver.chrome.driver", "C:\\chromedriver-114\\chromedriver.exe"); 再检查Chrome浏览器的版本号，发现是122
原来是Chrome浏览器默认的自动升级，升级到了最新的版本。
遇到的问题 除了浏览器会自动升级导致出现问题，其实手动下载版本还有很多问题，比如相同的代码，换个环境就又要再次下载相应环境浏览器的版本对应的WebDriver了。
所以，能不能不要手动配置webdriver.exe，要是有一种机制能够自动下载指定的版本就好了。
就像我们电脑安装的360驱动大师一样，不用我们手动去下载驱动，能不能有这样的驱动大师？
幸运的是，还真有这样的机制，这就是WebDriverManager.
WebDriverManager驱动管理器 没有驱动管理器时，我们需要很多繁琐的工作：
查看浏览器版本手动下载对应版本的WebDriver驱动放到本地目录，代码中配置路径某天浏览器自动升级了重复 步骤1、步骤2、步骤3 想想都觉得麻烦。
但是有了WebDriverManager，它会自动得检测我们安装的Chrome浏览器（或者其它浏览器）的版本，然后自动下载对应版本的WebDriver。这个过程完全是自动的，把之前那些繁琐的工作都省去了。
WebDriverManager的使用 使用起来很简单，把我们第一篇博客中的代码做一点修改就可以了。
在pom.xml 引入webdrivermanager的依赖 &lt;dependency&gt; &lt;groupId&gt;io.github.bonigarcia&lt;/groupId&gt; &lt;artifactId&gt;webdrivermanager&lt;/artifactId&gt; &lt;version&gt;5.7.0&lt;/version&gt; &lt;/dependency&gt; 删掉手动配置WebDriver的代码 // System.setProperty("webdriver.chrome.driver", "C:\\chromedriver-114\\chromedriver.exe"); 添加配置驱动管理器的代码 WebDriverManager.chromedriver().setup(); 只需要这一行代码，其它代码和第一篇博客一样，不用做任何更改！
启动应用，程序运行正常！
观察控制台打印的日志，可以看到WebDriverManager会自动下载驱动！!
WebDriverManager检测到我们的Chrome版本是122，于是它会去自动下载122版本的驱动，然后配置。
Error reading commands.properties, using local instead Using chromedriver 122.0.6261.128 (resolved driver for Chrome 122) Downloading https://storage.googleapis.com/chrome-for-testing-public/122.0.6261.128/win64/chromedriver-win64.zip Extracting driver from compressed file chromedriver-win64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e85f47180bbd71982d563701c80992c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b5ccb70bcaf6d697e05fb13aa828421/" rel="bookmark">
			数位DP
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一，数位DP
二，模板实战
BZOJ 2757 Blinker的仰慕者
力扣 233. 数字 1 的个数
面试题 17.06. 2出现的次数
力扣 660. 移除 9
力扣 1215. 步进数
三，其他OJ实战
CSU 1642 Problem B
ACdream 1156 LCP SUM
力扣 2719. 统计整数数目
力扣 1012. 至少有 1 位重复的数字
一，数位DP 有一类奇特的DP问题，对象空间是一个整数集，而解空间是把每一位作为一维，在这样的高维空间内完成DP，这类问题叫数位DP
模板：
template&lt;typename Tin, typename Tkey = Tin&gt; class DpNum { public: DpNum(long long p = 1000000007) { this-&gt;p = p; um.clear(); usum.clear(); } // 求d进制下，[0,m]内满足条件的数的数量、总和 void run(int d, long long m, long long&amp; num, long long&amp; s) { long long mi = 1; int len = 1; while (mi &lt;= m / d)mi *= d, len++; num = 0; s = 0; cal(d, len, mi, m, init(), num, s); } protected: //以i开头，长为len，i前面的状态为in,是否可能有解 virtual bool check(int d, int len, const Tin&amp; in, int i) { if (len &lt;= 1)return false; return true; } //初始状态 virtual Tin init() { return Tin{}; } //前置状态末尾增加i，变成新的状态 virtual Tin getNewIn(int d, int len, long long mi, const Tin&amp; in, int i) { return in; } //从状态中提取key virtual Tkey getKey(const Tin&amp; in) { return Tkey{}; } //统计答案 virtual long long getNum(int d, const Tin&amp; in) { return 0; } // um[i][j][k]是以i开头，长为j的所有数中，满足k条件的数目 unordered_map&lt;long long, unordered_map&lt;long long, map&lt;Tkey, long long&gt;&gt;&gt;um; unordered_map&lt;long long, unordered_map&lt;long long, map&lt;Tkey, long long&gt;&gt;&gt;usum; long long p; private: //mi是d的len-1次方，mi&lt;=m&lt;mi*d，求d进制下，以i开头，长为len，i前面的状态为in的所有数中，满足条件的数的数量、总和 void dp(int d, int len, long long mi, int i, const Tin&amp; in) { if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b5ccb70bcaf6d697e05fb13aa828421/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01e968c274f37cd701c44ef5f9318c13/" rel="bookmark">
			JS：复制内容到剪贴板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 let text="复制的内容" const copy = async () =&gt; { try { await navigator.clipboard.writeText(text+"已复制"); ); } catch (err) { console.error("无法复制: ", err); } }; 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/10/">«</a>
	<span class="pagination__item pagination__item--current">11/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/12/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>