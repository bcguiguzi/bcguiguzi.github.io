<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e73b2ca2bb8ef691d1ed0110185c666/" rel="bookmark">
			ng-click获得当前元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ng-click获得当前元素，不多说直接看示例代码 1 2 3 4 5 {{ page }} function TestCtrl( scope) {scope.page = 1; scope.getData=function()console.log($scope.page); scope.GoPage = function (target) { $scope.page = target.getAttribute('data'); this.getData(); } } 话题2：angular.element()用法（这只是一个酱油） 在Control中，angular.element()返回一个jquery对象，如angular.element(document).ready(function(){}); 所以你可以对她做你对所有jquery对象可以做的事
返回指定元素的scope：var sidebar = document.getElementsById(‘sidebar’); var scope = angular.element(sidebar).scope();
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/725d7b2b4b10839d5690a1bc1fcde292/" rel="bookmark">
			【栈】 删数游戏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 删数游戏 时间限制: 1 Sec 内存限制: 128 MB 提交: 28 解决: 9 [提交][状态][讨论版] 题目描述 小明和小华玩一个游戏。小明写下一个N位的正整数，小华要删除其中的K位，求它能得到的最大的数是多少？ 输入 第一行两个整数N和K(1&lt;=K&lt;=N&lt;=500000) 接下来一个N位数，没有前导0. 输出 一行，表示剩下的最大的数。 样例输入 5 253019 样例输出 539分析： 方法其实就是贪心，从前往后找第一个递增的数，删掉这个数，但是这道题极其坑爹，有灰常多细节： 1：如果删数到了k个，退出循环 2：如果遍历完后删数没有达到k个，输出现有序列的前n-k个 3：等于的情况不删！ 例如：2213 删掉一个，应输出223而不是213 4：注意范围，常规方法要超时！ 所以为了避免每找到一个数就把后面的往前移，我们选择用栈来储存，实现如下：（一定要注意细节） #include&lt;cstdio&gt; #include&lt;stack&gt; using namespace std; int n,k,s; stack&lt;char&gt;a; int main() { char c[500005]; scanf("%d%d%s",&amp;n,&amp;k,c); a.push(c[0]); int i,o=0; for(i=1;i&lt;n&amp;&amp;s&lt;k;i++) { while(!a.empty()&amp;&amp;s&lt;k) if(a.top()&lt;c[i]) s++,a.pop(); else break; a.push(c[i]); } if(s==k)for(;i&lt;n;i++) a.push(c[i]); while(!a.empty()) c[o++]=a.top(),a.pop(); for(i=o-1;n-k&gt;=o-i;i--) printf("%c",c[i]); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54cd270bb053dfb38f327bd10caa5abd/" rel="bookmark">
			c语言初学--计算字符串中数字的最大长度并提取 以及输入两个子串 提取分别以这为开头和结尾的字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算字符串中数字的最大长度并提取
提取以输入子串为开头和结尾的字符串
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f79d0b584156b6069d9d44b8d64903/" rel="bookmark">
			Windows下Camtasia Studio的安装与卸载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 探索Android软键盘的疑难杂症 深入探讨Android异步精髓Handler 详解Android主流框架不可或缺的基石 站在源码的肩膀上全解Scroller工作机制
Android多分辨率适配框架（1）— 核心基础 Android多分辨率适配框架（2）— 原理剖析 Android多分辨率适配框架（3）— 使用指南
自定义View系列教程00–推翻自己和过往，重学自定义View 自定义View系列教程01–常用工具介绍 自定义View系列教程02–onMeasure源码详尽分析 自定义View系列教程03–onLayout源码详尽分析 自定义View系列教程04–Draw源码分析及其实践 自定义View系列教程05–示例分析 自定义View系列教程06–详解View的Touch事件处理 自定义View系列教程07–详解ViewGroup分发Touch事件 自定义View系列教程08–滑动冲突的产生及其处理
Windows下Camtasia Studio的安装 第一步：执行camtasia.exe 安装过程中请输入合理的用户名和序列号。
用户名：Admin 序列号：ZLACM-2YZ4K-D6CCA-CCC5M-L88CE
请注意：此为网络上流传最多的一组用户名和序列号，但已失效。 在淘宝上有许多销售Camtasia Studio序列号的商家，但是这些序列号的使用时效一般只有一个月，所以在购买前务必和卖家沟通和确认其有效时效。
第二步：修改RegInfo.ini文件的属性为只读 该文件的路径为:
C:\ProgramData\TechSmith\Camtasia Studio 8\RegInfo.ini
请注意：ProgramData可能被操作系统隐藏
第三步：修改hosts文件 该文件的路径为:
C:\Windows\System32\drivers\etc\hosts
在该文件的末尾添加如下两行文字：
127.0.0.1 activation.cloud.techsmith.com 127.0.0.1 oscount.techsmith.com
第四步：汉化Camtasia Studio 此步骤很简单，双击执行汉化补丁.exe即可
Windows下Camtasia Studio的卸载 第一步：取消RegInfo.ini文件的只读属性 该文件的路径为:
C:\ProgramData\TechSmith\Camtasia Studio 8\RegInfo.ini
请注意：ProgramData可能被操作系统隐藏
第二步：卸载Camtasia Studio 控制面板—&gt;程序—&gt;程序和功能—&gt;Camtasia Studio—&gt;双击卸载
第三步：重启计算机 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbe0bbe6bced8bfc3c1a7b5d93b4d1d6/" rel="bookmark">
			程序员11月书讯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		10月书讯中奖名单：_iorilan、极简、逆流的鱼yuiop、mlcjq、Marksinoberg。
好书推荐，在图灵书讯中选出你认为值得推荐的好书加推荐理由或推荐语，在文末评论里回复。下期书讯更新时，会在本期的书讯评论中选出若干优秀评论，获奖者可任选图灵书讯中的图书一本。
11月有13本新书上市，有重磅推荐3本，还有体验设计和平面设计3本，有纯技术类4本，还有数学和科普3本，涉猎甚广。
1.《决胜UX：互联网产品用户体验策略》 2.《黑客攻防技术宝典：浏览器实战篇》【含社区电子版】 3.《进化：从孤胆极客到高效团队》【含社区电子版】 4.《多设备体验设计：物联网时代产品开发模式 》【含社区电子版】 5.《匠心体验：智能手机与平板电脑的用户体验设计》【含社区电子版】 6.《设计也幽默：平面设计师的幽默指南》 7.《Docker——容器与容器云（第2版）》 8.《高性能Android应用开发》【含社区电子版】 9.《MySQL与MariaDB学习指南》【含社区电子版】 10.《Unity 5权威讲解》 11.《普林斯顿微积分读本（修订版）》 12.《未来的截面》 13.《中村俊辅：任意球大师的“察知力”》
特别推荐 ○ 决胜UX：互联网产品用户体验策略
作者：Jaime Levy 译者：胡越古 页数：268
顶级用户体验策略专家Jaime Levy二十余年真知灼见一个实践用户体验策略的可靠框架教你巧妙结合用户体验设计与商业策略，设计创新型产品，重塑职业生涯列举各种商业案例、故事以及对顶级策略专家的访谈，从不同视角深入理解用户体验策略 《决胜UX：互联网产品用户体验策略》特别为开发创新型产品设计，包含众多实用技巧。具体内容分为11章：第1章确定用户体验策略是什么；第2章确定用户体验策略的准则；第3~9章包括如何实践这些用户体验策略的技巧；第10章包含四个对全世界顶级策略专家的访谈；第11章是涵盖全书的总结。
特别推荐 ○ 黑客攻防技术宝典：浏览器实战篇
作者：Wade Alcorn ， Christian Frichot ， Michele Orrù 译者：奇舞团 页数：496
浏览器安全领域的先锋之作、浏览器攻击框架BeEF团队实战经验总结涵盖所有主流浏览器以及移动浏览器分三阶段、七大类讲解浏览器攻防方法 《黑客攻防技术宝典：浏览器实战篇》由世界顶尖级黑客打造，细致讲解了IE、Firefox、Chrome等主流浏览器及其扩展和应用上的安全问题和漏洞，介绍了大量的攻击和防御技术，具体内容包括：初始控制，持续控制，绕过同源策略，攻击用户、浏览器、扩展、插件、Web应用、网络，等等。它是你在实践中的必读参考指南，对实际开发具有重要指导作用，能够助你在浏览器安全领域有所作为。
北京的小伙伴们有福了，由图灵教育、360 0Kee Team、360奇舞团主办的“360黑客攻防技术分享会”11月19日就要开始了，活动详情及报名请戳链接：http://t.cn/RVdQsDE。
特别推荐 ○ 进化：从孤胆极客到高效团队 作者：Brian W. Fitzpatrick ， Ben Collins-Sussman 译者：金迎 页数：184
程序员版《人性的弱点》，提升职业生涯软技能现代版《人件》第一版《极客与团队》豆瓣评分8.4分，第二版更加一般化。也针对较新话题增加了一些新的章节，例如开放式办公场所、冒充者综合征，以及更新的沟通和领导技巧 《进化：从孤胆极客到高效团队》旨在提高人与人合作的能力。作者以其自身的经历为基础，阐明了团队合作的重要性，提出了加强合作的具体方法，并辅以实例进行了深入分析。全文主要从三个角度介绍了团队合作的方法：如何处理团队中有关人的方面；如何在良好或不佳的公司中工作；如何与用户合作以创造更优秀的产品。如果你想提高创新的效果和效率，那么本书就是答案。
打造最佳用户体验 ○ 多设备体验设计
作者：Michal Levin 译者：刘柏松 页数：224
谷歌高级用户体验设计师Michal Levin倾情打造用3C（一致性、连续性和互补性）设计方法构建产品生态系统一套多设备体验设计之路的路线图 《多设备体验设计：物联网时代产品开发模式》共8章，前半部分介绍了一个新的生态框架以及这个框架的基础——三种处理设备间关系的核心方法。后半部分探讨了衡量这些生态系统是否成功的方法，也探讨了如何克服目前在此领域中出现的一些问题。本书旨在探索设备联动生态系统的潜能、追求更好的多设备体验，从而提升用户体验。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbe0bbe6bced8bfc3c1a7b5d93b4d1d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7647810532bc2abbf9f5cc8273d8a25/" rel="bookmark">
			android framework浅析之activityManager：
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 sdk中对activityManager的描述: Interact with the overall activities running in the system. 和系统中所有的activity进行交互。 有六个内部类： 1.MemoryInfo 可以通过getMemoryInfo检索有关可用内存的信息 2.ProcessErrorStateInfo 您可以检索有关处于错误状态的任何进程的信息。 3.RecentTaskInfo 您可以检索有关用户最近开始或访问的任务的信息。 4.RunningAppProcessInfo 您可以检索有关正在运行的进程的信息。 5.RunningServiceInfo 您可以检索有关当前在系统中运行的特定服务的信息。 6.RunningTaskInfo 您可以检索有关系统中当前“正在运行”的特定任务的信息。 五个常量： 1.META_HOME_ALTERNATE 声明一个要卸载的包 2.MOVE_TASK_NO_USER_ACTION 不记录当前操作，所以当前activity不会收到用户离开的提示。 3.MOVE_TASK_WITH_HOME 将当前activity移动到task的后面， 4.RECENT_IGNORE_UNAVAILABLE 提供当前用户可用的任务列表 5.RECENT_WITH_EXCLUDED 返回所有任务列表。 其实Interact with the overall activities running in the system. 就解释了activityManager的作用。 主要是获取或者操作application、package、device、memory、process等的info。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846071fa7021aef98f71be342b95cad7/" rel="bookmark">
			Retrofit2源码解析（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、适用人群。会使用Retrofit，想更好更全面的了解Retrofit的童鞋。
二、解析 1、获取Retrofit实例
Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl, List&lt;Converter.Factory&gt; converterFactories, List&lt;CallAdapter.Factory&gt; adapterFactories, Executor callbackExecutor, boolean validateEagerly) { this.callFactory = callFactory; this.baseUrl = baseUrl; this.converterFactories = unmodifiableList(converterFactories); // Defensive copy at call site. this.adapterFactories = unmodifiableList(adapterFactories); // Defensive copy at call site. this.callbackExecutor = callbackExecutor; this.validateEagerly = validateEagerly; } 成员变量解释 1）callFactory 处理网络请求的工厂类，依赖于okhttp3.Factory 2）baseUrl 网络请求的基础地址 3）converterFactories 实例类转化工厂 4）adapterFactories CallAdapter生成工厂 5）callbackExecutor 回调的执行者，一个executor 6）validateEagerly 是否提前验证methods是实现自接口
这里着重说下converterFactories 和adapterFactories 的区别和作用 在Rxjava中，网络请求的接口一般是这种形式
public interface HttpLogin { @POST("account/login") XXX&lt;YYY&gt; login(@Body ZZZ body); } converterFactories 是负责文字和实体类互相转化，需要把http返回的body转成yyy实体类，以及把ZZZ实体转成字符串。 adapterFactories 是负责生成XXX实体类的适配器。在DefaultCallAdapterFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/846071fa7021aef98f71be342b95cad7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cb393cc1ba1e342a4b37f48a9581739/" rel="bookmark">
			Win10&#43;VS2015平台下OpenCV3.1.0的x86和x64平台的Debug与Release模式的编译与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		闲话
昨天晚上在新电脑上重新配置了OpenCV3.1，之前虽然也弄过，不过当时是初学者，只是照着网上的教程简单的配置了Debug模式下x86的运行环境（大部分的教程也只教了这种方式的配置......）。想着反正闲着没事，我就一口气把其余的几种模式都配置了，过程中虽然因为自己sb，出现了一些错误，不过还是比较轻松就配置完成了，下面开始进入正题。
环境与工具
操作系统：Win10专业版 版本号：1511
VS版本：Visual Studio Community 2015
OpenCV版本：3.1.0 下载地址：http://downloads.sourceforge.net/project/opencvlibrary/opencv-win/3.1.0/opencv-3.1.0.exe
Cmake3.3.1 下载地址：http://download.csdn.net/detail/mooneve/9668883
OpenCV解压与Cmake
把上面提供的东西下载后，首先把OpenCV解压
打开之后选择好解压目录，注意命名，不然到后面很容易弄混的。我设置的路径为：E:\opencv
解压出来之后是这样的
然后安装Cmake，安装步骤按照默认的走就可以了。安装完后，打开Cmake，点击右边的Browse Source按钮，选择到我们刚才解压出来的opencv的源码目录：E:/opencv/sources
然后下面的框选择build的库目录：E:/opencv_build_x86
注意：我这里会写上x86是为了与后面生成x64的库进行区别，不同的库里面的文件是有差别的，所以大家最好在生成的时候也区分一下。
选择好目录后，就可以点击上图红框标志的Configure按钮，然后会弹出一个界面让你选择使用什么编译器进行生成库，cmake默认是使用x86进行生成的，也就是下图的Visual Studio 14 2015。
当我们想生成x64的库的时候，就要点击下拉菜单，选择Visual Studio 14 2015 Win64。
话题回来，当我们选择好了x86的Visual Studio 14 2015后，就点击Finish按钮，然后cmake就会开始进行一堆处理了，就像下图。
等一段时间后，它就会出现下面的红色背景。
在红色背景的框中，找到WITH_TBB这一项，然后把钩给选上。接着就点击Generate按钮开始生成x86的库文件了。
我们打开刚才设置的 E:\opencv_build_x86 目录就会发现里面多出了许多的东西。
进行到这里，我们就把x86的库文件生成好了，接下来就是生成x64的库了，步骤其实和上面差不多，
只不过要重新设置一个目录 E:\opencv_build_x64
然后选择Visual Studio 14 2015 Win64进行生成。
同样要记住，在红色背景的框中，找到WITH_TBB这一项，然后把钩给选上。
最后同样得到了x64的库文件。
x86与x64库文件的Debug和Release模式编译
得到x86与x64库文件后，就开始要用vs2015进行编译了。首先我们进入x86的库目录E:\opencv_build_x64中，找到OpenCV.sln这一项，直接点击就会在vs中打开了。打开后解决方案的目录如下：
细心的话就会发现，这个项目在vs中只有win32的运行平台，而没有x64的，这也正好说明了这是x86的库。
我们首先选择上图中的Ddbug模式，然后在“解决方案”上右击选择“重新生成解决方案”，这样vs就会开始编译，生成x86平台的Debug模式下的文件，当然就是我们要的bin和lib。
当vs的输出中出现了下面的信息就代表编译完成了。 这个时候，我们进入E:\opencv_build_x86\bin\Debug 和 E:\opencv_build_x86\lib\Debug目录中，就可以看到生成的文件了。而在Release中则没有。
进行到这里，我们只是得到了x86平台下的Debug模式的文件，接下来当然就是Release模式下的了。步骤很简单，只是选择Release模式，然后在“解决方案”上右击选择“重新生成解决方案”。等待一段时间后，就Release模式下的bin和lib就同样得到了。
到这里我们就得到x86平台下的Debug 和Release模式的文件了。x64平台Debug 和Release模式的文件同样是用上面的方式生成。这里就不再重复了。
接下来就把生成的各种文件汇总吧！这样便于我们以后适用，而且除了生成的bin和lib外，其余的部分我们是用不到的，这些东西都可以删除掉，节约了相当一部分的硬盘空间（这些生成的文件占用了13.3G空间....）。当然，如果你以后使用的过程中想源码追踪的话，就当我没说。
把 E:\opencv_build_x86\bin 和 E:\opencv_build_x86\lib 这两个目录拷贝到E:\opencv\build\x86\vc14 目录中（这个目录是自己建立的）；
把 E:\opencv_build_x64\bin 和 E:\opencv_build_x64\lib 这两个目录拷贝到E:\opencv\build\x64\vc14 目录中覆盖。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cb393cc1ba1e342a4b37f48a9581739/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfb1817717e028fb2a42cc7dfd6f2a42/" rel="bookmark">
			js初学者常遇到的一个for循环中onclick问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先看一段代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;0&lt;/button&gt; &lt;button&gt;1&lt;/button&gt; &lt;button&gt;2&lt;/button&gt; &lt;button&gt;3&lt;/button&gt; &lt;button&gt;4&lt;/button&gt; &lt;script&gt; var btn=document.getElementsByTagName('button'); for(var i=0;i&lt;btn.length;i++){ btn[i].onclick=function(){ console.log(i); } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 然后运行一下，当时作为一名天真的js初学者理所当然的认为分别点击不同的额按钮，会分别的打印出0、1、2、3、4，然而事与愿为，现实和理想总是存在差距，点击不同的按钮，打印却都是5，百思不得其解，不科学啊！ 最后百度了一番才恍然大悟，原来console.log(i)里的i在循环完成的时候被赋值成了5，而每个按钮的onclick都被赋值了同一个function,也就是说每个function里的i指的是同一个i，i=5，自然每个点击都会打印出5，那么该怎么解决呢？！ 再看接下来这段代码：
&lt;script&gt; var btn=document.getElementsByTagName('button'); for(var i=0;i&lt;btn.length;i++){ (function(i){ //这个是function里i，即function的形参，也可以换成j，换成什么变量名都无所谓 btn[i].onclick=function(){ console.log(i); } })(i);//这是循环中的i,被作为参数传入 } &lt;/script&gt; 再运行这段代码，就可以得到你想要的效果，但是是为什么呢？ 知道了原因就好办了，利用闭包把每个function里的i都变成不同的i就行了，当时作为一名初学者还不懂闭包，也是后来才理解的。 循环中的function自调用，将循环中的i作为参数传入function中，此时，function中的i已经不是循环中的i了（这里有点绕，其实形参i，即function里的i换成什么变量名都行），而是在内存中开辟了一个内存空间存储了作为参数传进来的i的值，这样function中的就不会随着循环中的i的值的改变而改变了,就可以打印出你要的结果了。
怎么样？是不是很坑爹，这是一个很常见的问题，还望js的初学者们好好体会，我当时也是蒙蔽了好久！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78ccdc71df1e4a0d7872f54db776d958/" rel="bookmark">
			初学Android时遇到的一些错误及解决办法——之一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Attribute is missing the Android namespace prefix 命名空间前缀缺失 出现这样的错误的原因主要由以下几种：
a、属性定义时，命名前缀错误，这里的命名前缀错误又分为丢失前缀、前缀书写错误
（1）前缀丢失，比如定义一个TextVIew的属性时，android：id=，如果没有写android，便会报错这样错误，但是这个是显而易见的，一般我们不会犯下这个错误；
（2）前缀书写错误，比如定义控件的属性时，把android拼写错了，写成了andriod，由于自己的手误，写成了这样，而且不太容易被发现，以至于我们郁闷了很久，最后终于发现是这么一个低级的不能再低级的错误。
b、定义语法错误
比如我要在res下面建一个xml文件，把`&lt;book price="99.0" 出版日期="2008年"&gt;疯狂讲义&lt;/book&gt;`一句代码写成了`&lt;book&gt;price="99.0" 出版日期="2008年" 疯狂讲义&lt;/book&gt;` c、缺少一些关键语句 比如在tools:context=".MainActivity" 之前缺少xmlns:tools="http://schemas.android.com/tools" （这个tools命名空间可以用来预览一些布局属性的添加和删除后的效果） 具体可参考 tools:context=”.MainActivity的作用 还有 android xmlns:tools用法 Not targeting the latest versions of Android; compatibility modes apply. Consider testing and updating this version. Consult the android.os.Build.VERSION_CODES javadoc for details.
未定位到最新版本的Android; 兼容模式。 考虑测试和 更新此版本。 有关详细信息，请参阅android.os.Build.VERSION_CODES javadoc。
在提醒我们没有匹配使用最新的sdk版本，可能导致app在最新的系统上面无法利用最新的特性或功能，去掉这个警告的办法就是把uses-sdk标签中的android:targetSdkVersion属性改为你电脑上面最新的sdk版本，例如我的电脑上最新的sdk是android4.4，它的版本号是19，那么我应该写成“android:targetSdkVersion=”19””，这样就不会报错了，如果你电脑的sdk是android4.0，那么改为android:targetSdkVersion=”14”即可。 android:theme=”@android:style/Theme.Black.NoTitleBar” 这个语句是设置隐藏标题栏并且将界面背景设置为黑色，程序编译没有错，一运行就崩溃。
在网上搜索了一下解决办法：所有项目都是按照Androidstudio默认创建的Java或者xml，每个自动创建的java都继承了AppCompatActivity 只要将AppCompatActivity改写成Activity就可以了。（改完以后记得导入相应的包）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf2bacf1efb187088df2f6988e5b139e/" rel="bookmark">
			Get IT技能知识库 50个领域一键直达
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		成长的因素有很多，你知道知识图谱的作用吗？本文GET了当下最热门、最火爆的技术知识点，让你一库在手，技术全有！
众所周知，我们的每个知识库都是邀请专家精心绘制图谱，并依据每个图谱的知识结构，筛选该技术分支知识点下的优质资源，经特邀编辑一一审核、精心挑选后，形成该技术点的知识库。节省开发者学习时间和成本，最大化的满足和解决大家的日常技能问题，开发者还可以在上面绘制专属于自己的技能图谱（图谱+干货）。
成长的因素有很多，你知道图谱都作用吗？
操作系统
管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。
下载操作系统知识图谱高清大图 计算机网络
利用通信设备和线路将地理位置不同、功能独立的多个计算机系统互联起来，以功能完善的网络软件实现网络中资源共享和信息传递的系统，它是计算机基础知识的重要分支。
下载计算机网络知识图谱高清大图 算法与数据结构
数据结构是计算机存储、组织数据的方式，精心选择的数据结构可以带来更高的运行或者存储效率。算法是一系列解决问题的清晰指令，代表着用系统的方法描述解决问题的策略机制。两者均是研发工作的基础。
下载算法与数据结构知识图谱高清大图 Linux
Linux是一个免费的，基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它支持32位和64位硬件，且继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。
下载Linux知识图谱高清大图 嵌入式开发
嵌入式系统开发，即对于除了电脑之外的所有电子设备上操作系统的开发，开发对象有手机、掌上电脑、机电系统等。常用嵌入式系统包括WinCE、Linux、Android等，编程语言可采用C、C++或汇编语言。
下载嵌入式开发知识图谱高清大图 信息无障碍
信息无障碍，即任何人在任何情况下都能平等的、方便地、无障碍地获取、利用信息。其包括两个主要范畴：电子和信息技术无障碍及网络无障碍，并遵循国际标准WCAG2.0。
下载信息无障碍知识图谱高清大图 微信开发
微信开发即微信公众平台开发，将企业信息、服务、活动等通过微信网页的方式表现。开发者利用微信开放的技术接口可进行二次开发，将公众账号由一个媒体型营销工具转化成提供服务的产品。
下载微信开发知识图谱高清大图 虚拟现实（VR）
虚拟现实是一种可创建和体验虚拟世界的计算机系统，它综合利用计算机图形系统和各种现实及控制等接口设备，在计算机上生成的、可交互的三维环境中提供沉浸感觉的技术。
下载虚拟现实知识图谱高清大图 直播技术
中国已在2016年进入直播时代，这种成本低廉、互动性高、部署便捷、稳定可靠的方式，最初局限于游戏直播和在线聊天，而现在泛生活类、娱乐类直播开始逐渐流行。
下载直播技术知识图谱高清大图 大型网站架构
剖析大型网站技术架构模式，深入讲述大型互联网架构设计的核心原理，全面介绍大型网站架构需要的方方面面知识/技术。
下载大型网站架构知识图谱高清大图 区块链
区块链（Blockchain），比特币背后的技术，无需中心服务器，可实现各类存储数据公开、透明、可追溯。 下载区块链知识图谱高清大图 深度学习
深度学习的概念源于人工神经网络的研究，含多隐层的多层感知器就是一种深度学习结构。它是机器学习研究的一个新领域，模仿人脑机制来解释数据。
下载深度学习知识图谱高清大图 机器学习
机器学习是研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。它是人工智能的核心，是使计算机具有智能的根本途径。
下载机器学习知识图谱高清大图 软件测试
软件测试是在规定条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。它是帮助识别开发完成的计算机软件的正确度、完全度和质量的软件过程。是SQA的重要子域。 下载软件测试知识图谱高清大图 Android
Android是一个基于Linux内核的移动操作系统，由Google成立的Open Handset Alliance（OHA，开放手持设备联盟）持续领导与开发，主要设计用于触控荧幕移动设备如智能手机和平板电脑。 下载Android知识图谱高清大图 iOS
iOS是由苹果公司开发的移动操作系统。原名叫iPhone OS，因为iPad，iPhone，iPod touch都使用iPhone OS，所以2010 WWDC大会上宣布改名为iOS。
下载iOS知识图谱高清大图 .NET
.NET Framework是微软用于Windows的新托管代码编程模型，是一个 Microsoft Windows组件，用户可通过各种分发渠道获得它。 下载.NET知识图谱高清大图 C
C语言是一门通用计算机编程语言，应用广泛。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。
下载C语言知识图谱高清大图 C++
C++是在C语言基础上开发出的一种面向对象编程语言。其编程领域众广，常用于系统开发，引擎开发等应用领域，是至今为止最受广大程序员受用的最强大编程语言之一。
下载C++语言知识图谱高清大图 C#
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf2bacf1efb187088df2f6988e5b139e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd62bd49afad67e089caaa2da516b1aa/" rel="bookmark">
			Git add 常见用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git add git add [参数] [--] &lt;路径&gt;　//作用就是将我们需要提交的代码从工作区添加到暂存区，就是告诉git系统，我们要提交哪些文件，之后就可以使用git commit命令进行提交了。
为了方便下面都用 . 来标识路径， . 表示当前目录，路径可以修改，下列操作的作用范围都在版本库之内。
1.1 git add . 不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除
1.2 git add -u .
-u == --update ，表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。
1.3 git add -A .
-A == --all ， 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。
1.4 git add -i .
日常工作中了解前三个命令已足够能满足我们的使用需求了，但是了解一下这个交互式拣选操作也是不错的。这个命令它也是作用于版本库中已被跟踪的文件中的执行过修改与删除操作的文件。
git add -i
staged unstaged path
1: +0/-0 nothing Testfile
*** Commands ***
1: status 2: update 3: revert 4: add untracked
5: patch 6: diff 7: quit 8: help
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd62bd49afad67e089caaa2da516b1aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d37d95d3f3b5edf6b844fb7dece049c/" rel="bookmark">
			matplotlib tricks（关闭坐标刻度、坐标轴不可见）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 plt.gray()：只有黑白两色，没有中间的渐进色 0. plt.xticks 关闭坐标刻度：plt.xticks([])旋转刻度： plt.xticks(x, labels, rotation=70)plt.xticks(x, labels, rotation=‘vertical’) plt.xticks(x, labels, rotation=90) 1. 关闭坐标刻度（plt 与 AxesSubplot） plt
plt.xticks([]) plt.yticks([]) 关闭坐标轴：
plt.axis('off') 注意，类似的这些操作若想起作用，需要将其置于 plt.show() 之前，plt.imshow() 之后。
对于 ax（matplotlib.axes._subplots.AxesSubplot）
ax.set_xticks([]) ax.set_yticks([]) 2. 设置所要保存图像的 dpi dpi：Dots Per Inch plt.savefig(..., dpi=150) 3. 坐标轴不可见 frame = plt.gca() # y 轴不可见 frame.axes.get_yaxis().set_visible(False) # x 轴不可见 frame.axes.get_xaxis().set_visible(False) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fbe8eb038e18432b2d5b53af1e502b7/" rel="bookmark">
			Recyclerview使用notifyitemchanged方法会回到顶部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		categories.get(lastPosition).setSelected(false); categoryAdapter.notifyItemChanged(lastPosition); categories.get(position).setSelected(true); categoryAdapter.notifyItemChanged(position); lastPosition=position;
这是RecyclerView单选点击实现，当点击某个item的时候，RecyclerView回到顶部.
解决办法。使用
setHasFixedSize(true)方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c80d9a255b153e54da552875718d7952/" rel="bookmark">
			C语言编译过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 C语言程序从源代码到二进制行程序都经历了那些过程？本文以Linux下C语言的编译过程为例，讲解C语言程序的编译过程。
编写hello world C程序：
// hello.c #include &lt;stdio.h&gt; int main(){ printf("hello world!\n"); } 编译过程只需：
$ gcc hello.c # 编译 $ ./a.out # 执行 hello world! 这个过程如此熟悉，以至于大家觉得编译事件很简单的事。事实真的如此吗？我们来细看一下C语言的编译过程到底是怎样的。
上述gcc命令其实依次执行了四步操作：1.预处理(Preprocessing), 2.编译(Compilation), 3.汇编(Assemble), 4.链接(Linking)。
示例 为了下面步骤讲解的方便，我们需要一个稍微复杂一点的例子。假设我们自己定义了一个头文件mymath.h，实现一些自己的数学函数，并把具体实现放在mymath.c当中。然后写一个test.c程序使用这些函数。程序目录结构如下：
├── test.c └── inc ├── mymath.h └── mymath.c 程序代码如下：
// test.c #include &lt;stdio.h&gt; #include "mymath.h"// 自定义头文件 int main(){ int a = 2; int b = 3; int sum = add(a, b); printf("a=%d, b=%d, a+b=%d\n", a, b, sum); } 头文件定义：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c80d9a255b153e54da552875718d7952/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba5a7f1a44c2b253899302110ce5e6bb/" rel="bookmark">
			在OnDialogCreate方法中创建RecyclerView,item不铺满屏幕解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 item不铺满的原因是缺少parent参数，解决的方法是在RecyclerView外面添加一个Relativelayout,或者其他布局，重新编译就会看到Item已经铺满屏幕了 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b045209bfda1a9b3a10e323fe510cef/" rel="bookmark">
			jquery   给当前页面或者跳转后页面对应的导航栏添加选中样式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用jquery js 给当前页面或者跳转后页面对应的导航栏添加选中样式是项目中很常见的的效果，几乎每个网站都会用到， 这里有两种效果，一种是直接给当前页面对应的导航栏添加样式，当页面刷新或者跳转页面后样式会消失！ 另一种效果是即使刷新页面或者页面跳转以后导航栏选中样式仍然存在有效！
第一种效果：
&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function(){ $(".nav a").each(function(){ $(this).click(function(){ $(".nav a").removeClass("hover"); $(this).addClass("hover"); //hover表示被选中效果的类名 return false;//防止页面跳转 }); }); }); &lt;/script&gt; &lt;div class="nav"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="1.html" class="hover"&gt; 首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="2.html"&gt; 用户中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="3.html"&gt; 关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="4.html"&gt; 联系我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 第二种效果：
&lt;script type="text/javascript" src="js/jquery.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function(){ $(".nav a").each(function(){ $this = $(this); if($this[0].href==String(window.location)){ $this.addClass("hover"); //hover表示被选中效果的类名 } }); }); &lt;/script&gt; &lt;div class="nav"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="1.html" class="hover"&gt; 首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b045209bfda1a9b3a10e323fe510cef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9054eaa975f69da4ed7583c2fcf908f/" rel="bookmark">
			Android的数据存储方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		种种原因，我们每日一博的约定断了差不多一个月。原因有很多：开学啦，中秋啦，公司旅游啦，国庆啦........但今天我满血回归！坚持我们的每日一博！
按照约定，今天我们应该来聊聊 Binder、AIDL，但我博客的定位的基础中的基础，这两个属于稍微深点的东西，我们就不聊了。今天开始我们的第四点：Android的数据存储方式！
Android的数据存储方式，主要有五种：
一、Android本身的数据库：SQLite数据库，SQLite是一个轻量级的，跨平台的数据库。数据库中所有的信息都存储在单一文件内，占用内存小，并且支持基本SQL语法，是项目中经常被采用的一种数据存储方式，通常用于存储用户信息。
二、ShardPreferences，中文名应该可以翻译为：数据分区。这个本质是一个xml文件，以Map&lt;Object,Object&gt;形式存入手机内存中，常用于存储比较简单的参数设置，如QQ登录账号密码的存储，窗口功能状态的存储等，使用起来比较简单方便。
三、文件存储，数据以 I/O 流的形式把数据存入手机内存或者手机SD卡，可以存储大数据，如音乐，图片，视频等。
四、ContentProvider，内容提供者。是Android的四大组件之一，以数据库的形式存入手机，可以共享自己的数据给其他应用使用，相对于其他对外共享数据方式而言，ContentProvider统一了数据访问方式，使用起来更规范。
五、网络存储，把数据存储到服务器，不存储在本地，使用的时候直接从网络获取，避免了手机端信息丢失以及其他安全隐患。
SQLite数据库的使用很简单，首先需要创建一个类，继承SQLiteOpenHelper 类，并实现其onCreate() 和onUpgrade() 方法 ，代码如下
public class DBHelper extends SQLiteOpenHelper { private static final String DBName = "MyDb"; //声明一个数据库名 private static final int VERISON = 1; //声明一个数据库版本号 public DBHelper(Context context) { super(context, DBName, null, VERISON); } /* 对数据库表进行初始化，只会在第一次创建数据库表时执行，并且只执行一次 */ @Override public void onCreate(SQLiteDatabase db) { String sql = "create table demo(id int,name varchar(20))"; //书写创建表的SQL语句 db.execSQL(sql); //执行SQL语句，创建表 } /* 这个方法是进行数据版本的更新 */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } 然后我们创建一个数据库的操作类，其中要使用到SQLiteDatabase类，这个类有什么作用呢？ Android提供了一个名为 SQLiteDatabase的类（SQLiteOpenHelper 类中的 getWritableDatabase()和getReadableDatabase()方法返回这个类的对象）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9054eaa975f69da4ed7583c2fcf908f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52d0af56c219db2fddbb22a8e1366cf8/" rel="bookmark">
			图像处理matlab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数字图像的分类 根据特性分为： - 位图 通常用数字阵列来表示，常见的格式有BMP,JPG,GIF - 矢量图 是由矢量数据库来表示，常见的格式有PNG图像 根据每个像素所代表的信息不同分为： - 二值图像 0来表示黑色，1来表示白色—-越大越亮 - 灰度图像 所有的取值在0-255，然后值越大越白 - RGB图像 RGB颜色代码可以用16进制来书写 //两个16进制组成排列有256中可能 0XFF0000//表示红色R 0X00FF00//表示绿色G 0X0000FF//表示蓝色B 0X000000//表示黑色 0XFFFFFF//表示白色 0X808080//表示灰色 索引图像 他的诞生完全是为了省空间，但是怎么省去空间，我还是不知道（感觉相当于增量调制，用增加的量来表示代码） 像素 像素就是包含有图像的信息的一个最小的集合。
图像的空间分辨率 图像的空间分辨率（spatial Resolution）是指的图像中单位长度包含像素和点的数目，通常用像素/英寸（ppi）为单位来表示。例如72ppi就表示图像中每英寸包含72个像素或点
图像的灰度级/辐射计量分辨率 灰度级分辨率又叫做色阶，色阶是指的图像中可分辨的灰度级数目，色阶越少，可以颜色数目也越少。
邻域 数字图像中一些基本的性质： - 邻接性 - 连通性 - 区域与边界
基本图像操作 点运算和邻域运算 点运算是对图像中每个像素点进行同样的灰度变换 邻域运算（邻域变换）对图像中每个小范围（邻域内）像素进行灰度变换线性和非线性操作 细胞数组 在MATLAB中细胞数组就是可以在一个数组内部定义
&gt;&gt;cell={'a',12}; &gt;&gt;cell{1}='a'%用花括号进行索引 结构体 结构体就是一种聚合类型
struct.Name='David_Han'; struct.Age=23; struct = Name: 'David_Han' Age: 23 meshgrid()函数 meshgrid函数是拥有绘制三维曲面 绘制中心在原点的二维高斯函数的图像
u=[-10:0.1:10]; v=[-10:0.1:10];%取200个点 [U,V]=meshgrid(u,v); H=exp(-(U.^2+V.^2)./2/3^2); mesh(u,v,H)%用于出图 MATLAB中图像的读写 A=imread('C:\Users\Administrator\Desktop\1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/52d0af56c219db2fddbb22a8e1366cf8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/838ace00201341dc3fc3b035d5eb6af3/" rel="bookmark">
			MySQL优化详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MYSQL优化
MYSQL优化主要分为以下四大方面：
设计：存储引擎，字段类型，范式与逆范式
功能：索引，缓存，分区分表。
架构：主从复制，读写分离，负载均衡。
合理SQL：测试，经验。
一、存储引擎
在创建表的时候我们使用sql语句，Create table tableName () engine=myisam|innodb; 这里就指明了存储引擎是myisam还是innodb。存储引擎是一种用来存储MySQL中对象（记录和索引）的一种特定的结构（文件结构），处于MySQL服务器的最底层，直接存储数据。导致上层的操作，依赖于存储引擎的选择。地位如下图：
网络接口层：与客户端通信，比如传输数据等等。存储引擎层：存储数据的规则，方式。
本质：存储引擎就是特定的数据存储格式（方案）。
可以使用show engines命令来查看当前MySQL支持的存储引擎列表。
1、InnoDB存储引擎介绍
Mysql版本&gt;=5.5 默认的存储引擎，MySQL推荐使用的存储引擎。支持事务，行级锁定，外键约束。事务安全型存储引擎。更加注重数据的完整性和安全性。
（1）存储格式
数据，索引集中存储，存储于同一个表空间文件中。
数据：记录行。 索引：一种检索机制，也需要一定的空间，就相当于一本字典的目录。
示例： 创建一个test数据库，新建一张student表，选择存储引擎为innodb, 然后打开mysql的data下的test目录，发现有以下3个文件。
其中db.opt存放了数据库的配置信息，比如数据库的字符集还有编码格式。student.frm是表结构文件，仅存储了表的结构、元数据(meta)，包括表结构定义信息等。不论是哪个表引擎都会有一个frm文件。student.ibd是表索引文件，包括了单独一个表的数据及索引内容。
如果往表里插入了新的数据，则在mysql的data目录下会生成ibdata1文件，这个文件是存储了所有innodb表的数据。
关于innodb引擎的详细介绍：
使用innodb引擎时，需要理解独立表空间、共享表空间。
独立表空间：每个表都会生成以独立的文件方式来存储，每个表都一个.frm的描述文件，还有一个.ibd文件。其中这个文件包括了单独一个表的数据及索引内容，默认情况下它的存储在mysql指定的目录下。
独立表空间优缺点
优点：
每个表都有自己独立的表空间；每个表的数据和索引都会存储在各个独立的表空间中；可以实现单表在不同的数据进行迁移；表空间可以回收（除了drop table操作，表空不能自己回收）；drop table 操作自动回收表空间，如果对统计分析或是日值表，删除大量数据后可以通过 ：alter table tablename engin=innodb进行回缩不用的空间；对于使用inodb-plugin的innodb使用truncate table会使用空间收缩。；对于使用独立表空间，不管怎么删除，表空间的碎片都不会太严重。
缺点：
单表增加过大，如超过100G。对于单表增长过大的问题，如果使用共享表空间可以把文件分开，但有同样有一个问题，如果访问的范围过大同样会访问多个文件，一样会比较慢。对于独立表空间也有一个解决办法是：使用分区表，也可以把那个大的表空间移动到别的空间上然后做一个连接。其实从性能上出发，当一个表超过100个G有可能响应也是较慢了，对于独立表空间还容易发现问题早做处理。
共享表空间：某一个数据库所有的表数据，索引文件全部都放在一个文件中，默认这个共享表空间的文件路径在data目录下，默认的文件名为 ibdata1,初始化为10M。
共享表空间优缺点
优点：可以将表空间分成多个文件存放在各个磁盘上（表空间文件大小不受表大小的限制，如一个表可以分布在不同的文件上），数据和文件放在一起方便管理。
缺点：所有的数据和索引存放到一个文件中，将来会是一个很大的文件，虽然可以把一个大文件分成多个小文件，但是多个表及索引在表空间中混合存储，这样对一个表做了大量删除操作后表空间将有大量的空隙，特别是对统计分析、日值系统这类应用最不适合用共享表空间。
如何开启独立表空间？
查看是否开启独产表空间：
mysql&gt; show variables like '%per_table';
+-----------------------+-------+
| Variable_name | Value |
+-----------------------+-------+
| innodb_file_per_table | OFF |
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/838ace00201341dc3fc3b035d5eb6af3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/482/">«</a>
	<span class="pagination__item pagination__item--current">483/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/484/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>