<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15d0657534940d9ab92190e69b974e08/" rel="bookmark">
			直接下载：Windows 10正式版官方原版镜像！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文搜集整理微软官方发布的Windows 10正式版镜像下载链接，从RTM原始正式版开始，按照时间倒序排列，即越往上的越新。
注意：以下资源均来自于微软官方原版，ed2k可视为P2P下载链接。下载完成后务必进行SHA1校验，核对一致后再使用。所有操作系统默认均为试用版，如有正版密钥可以有效激活，本站不提供任何激活和相关服务。
谨记：不管从什么地方下载，文件名可以不一样，但是体积、SHA1校验码必须一致，尤其是后者，有一点不同的也不要安装。
关于ISO镜像如何制作启动盘、如何校验SHA，具体教程见本文文末。
【Windows 10 2018年9月更新正式版】
October 2018 Update，2018年10月发布，开发代号Redstone 5(RS5)，系统版本号Version 1809。
此为最新的官方正式版，可取代此前的RS4 2018年4月更新版、RS3秋季创意者更新版、RS2创意者更新版、RS1周年更新版、TH2更新版，以及最初的RTM正式版，推荐更新。
【64位简体中文消费版】
文件名：cn_windows_10_consumer_edition_version_1809_updated_sept_2018_x64_dvd_051b7719.iso
文件大小：4.48GB
SHA1：c8deade18822435d8d47011609c124496e94df71
下载地址：
ed2k://|file|cn_windows_10_consumer_edition_version_1809_updated_sept_2018_x64_dvd_051b7719.iso|4808400896|B740D15C0A6056F4955A37792AB92501|/
【32位简体中文消费版】
文件名：cn_windows_10_consumer_edition_version_1809_updated_sept_2018_x86_dvd_c904d6c8.iso
文件大小：3.32GB
SHA1：b21c1ef5445f0c0a185ab15eaf0e953b737ca55c
下载地址：
ed2k://|file|cn_windows_10_consumer_edition_version_1809_updated_sept_2018_x86_dvd_c904d6c8.iso|3564730368|B31577E3A3825925D4D7972457D5A264|/
【64位简体中文商业版】
文件名：cn_windows_10_business_edition_version_1809_updated_sept_2018_x64_dvd_fc5542c0.iso
文件大小：4.43GB
SHA1：b89fdc0e10f01d74aab91c0c0b0d3a9aedeff667
下载地址：
ed2k://|file|cn_windows_10_business_edition_version_1809_updated_sept_2018_x64_dvd_fc5542c0.iso|4758683648|874CBCF3C5F0719EA18303E9CABFA4BE|/
【32位简体中文商业版】
文件名：cn_windows_10_business_edition_version_1809_updated_sept_2018_x86_dvd_0d8cffa0.iso
文件大小：3.29GB
SHA1：06a589bbf9e2975daca63d2271f1f53000f17519
下载地址：
ed2k://|file|cn_windows_10_business_edition_version_1809_updated_sept_2018_x86_dvd_0d8cffa0.iso|3527944192|C23CD1EE37DD9E87D42874221CAE2C07|/
【Windows 10 2018年4月更新正式版】
April Update，2018年4月30日发布，开发代号Redstone 4(RS4)，系统版本号Version 1803。
此为最新的官方正式版，可取代此前的RS3秋季创意者更新版、RS2创意者更新版、RS1周年更新版、TH2更新版，以及最初的RTM正式版，推荐更新。
【64位简体中文消费版】
文件名：cn_windows_10_consumer_editions_version_1803_updated_march_2018_x64_dvd_12063766.iso
文件大小：4.39GB
SHA1：82091d67fff5b49726ffc22d35d9c1cbe81dc443
下载地址：
ed2k://|file|cn_windows_10_consumer_editions_version_1803_updated_march_2018_x64_dvd_12063766.iso|4714162176|FB8C05DE594CD7E58D88993652DD2102|/
【32位简体中文消费版】
文件名：cn_windows_10_consumer_editions_version_1803_updated_march_2018_x86_dvd_12063452.iso
文件大小：3.24GB
SHA1：d5e89fb54169f5a2e610c75813ce833a4cb9a4e4
下载地址：
ed2k://|file|cn_windows_10_consumer_editions_version_1803_updated_march_2018_x86_dvd_12063452.iso|3480692736|0EC3C40EF13D772798209981F18B6A5D|/
【64位简体中文商业版】
文件名：cn_windows_10_business_editions_version_1803_updated_march_2018_x64_dvd_12063730.is
文件大小：4.32GB
SHA1：e39b9347fc5be4a0548fb15e666fb92e0a965c6e
下载地址：
ed2k://|file|cn_windows_10_business_editions_version_1803_updated_march_2018_x64_dvd_12063730.iso|4634574848|5674B3586C866EB2F47D7736A1FDE27A|/
【32位简体中文商业版】
文件名：cn_windows_10_business_editions_version_1803_updated_march_2018_x86_dvd_12063369.iso
文件大小：3.19GB
SHA1：6250fdf0b91f64e114f4cfec7a75546974cf6feb
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15d0657534940d9ab92190e69b974e08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d254e5ec13ae78d85d1df83c70a8c48/" rel="bookmark">
			springboot项目打成war包记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景：现在手上的项目基本进入收尾期，有必要将前后端的项目打成包丢到服务器上的docker进行测试了。
springboot默认的打包方式为jar包，jar包的有优点是不需要更改的配置，并且内嵌了tomcat，如果打成jar包直接可以丢到docker中运行测试。但是考虑到前端代码只能打成war包，因此干脆也将后端代码打成war包和前端的代码一起放在tomcat容器中的webapps中运行就好了。这样也易于维护。
在后端代码达成war包的过程中遇到了几个坑，通过在网上搜索相关文章慢慢摸索成功打包发布，在此记录一下主要的打包步骤，给之后的自己和有需要的你作为参考。
1：添加tomcat依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 这一步是我遇到的第一个坑，当时按照相关的文章介绍，将spring-boot-starter-tomcat从web依赖中去掉。也就是像下面这样：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--&lt;exclusions&gt;--&gt; &lt;!--&lt;exclusion&gt;--&gt; &lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;--&gt; &lt;!--&lt;/exclusion&gt;--&gt; &lt;!--&lt;/exclusions&gt;--&gt; &lt;/dependency&gt; 如上图所示 我已经将去除的那段代码注释掉了。当时编译一直报错。因为我就没有去除而是直接在下面另外添加了tomcat相关的依赖了。
2：将jar包修改成war包 &lt;packaging&gt;war&lt;/packaging&gt; 3： 添加servlet相关依赖 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 4：修改启动类 package com.ahu.lock; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.boot.web.servlet.support.SpringBootServletInitializer; @SpringBootApplication public class LockApplication extends SpringBootServletInitializer { @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(LockApplication.class); } public static void main(String[] args) { SpringApplication.run(LockApplication.class, args); } } 5：定义最后生成war包的名称 &lt;build&gt; &lt;finalName&gt;lock&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d254e5ec13ae78d85d1df83c70a8c48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58c309e75b30668110e800c6a143f391/" rel="bookmark">
			Connected to the target VM, address:, transport: &#39;socket&#39;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前运行的程序都好好的，莫名其妙的出现了这个问题，因为改过配置，怀疑是程序哪里异常了。
解决方案：
打开editbreakpoint（ctrl+shift+F8），勾上any exception的复选框。缺点，如果勾选上了，任何exception都会有断点，比较心烦。
建议问题找到了还是去掉。我的问题就是配置logback中数据库的密码时，填写错误导致的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1bc6ac352123890d8cc680fc58925d8/" rel="bookmark">
			VS中目录含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		$(VC_ExecutablePath_x64); //项目是x64平台
$(WindowsSDK_ExecutablePath);
$(VS_ExecutablePath);
$(MSBuild_ExecutablePath);
$(VC_IncludePath);
$(VCInstallDir)UnitTest\include;
1.可执行文件目录： 生成VC++项目期间，搜索可执行文件时使用的路径
1.1 $(VC_ExecutablePath_x64)：D:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin，这里包含了VS的编译器cl.exe、链接器lk.exe和相应的dll。
1.2 $(WindowsSDK_ExecutablePath): c:\Program Files (x86)\Windows Kits\8.1\bin\x64\ ，这里包含了Windows Driver Kit(WDK)
1.3 $(PATH)：这个是环境变量-&gt;系统变量-&gt;PATH一致。包含了c:\Windows\System32，D:\opencv\build\x86\vc12\bin，D:\opencv\build\x64\vc12\bin等，这里存放的也是一些DLL文件。将工程Build后，Exe文件会动态加载其中的dll。这里面有个问题就是如果这些Path中有重复的文件怎么办，加载哪一个？
2.包含目录： 生成VC++项目期间，搜索包含文件时使用的路径
2.1 $(VC_IncludePath):包含了VC的一些.h文件，比如stdio.h和sstream等。
2.2 $(WindowsSDK_IncludePath)：WDK的一些头文件
2.3 其他：比如我们添加的OpenCV的一些头文件路径D:\opencv\build\include\opencv\
3.库目录： 生成VC++项目期间，搜索库文件时使用的路径
3.1 $(VC_LibraryPath_x64)：包含了VC的一些.lib文件
3.2 $(WindowsSDK_LibraryPath_x64)：包含了WDK的一些lib文件
3.3 其他：我们添加的OpenCV的一些Lib路径，比如d:\opencv\build\lib\Debug;D:\opencv\build\install\x64\vc12\lib
注意，库目录只是指明了lib的路径，具体用哪一个lib，需要在链接器-&gt;附加依赖项中添加，比如opencv_calib3d249d.lib等。
4.源目录 $(VC_SourcePath):C++ crt、afxmfc以及ucrt源文件目录
用别人的vs记得配路径！！
参考：https://blog.csdn.net/zinnc/article/details/51658214
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d10eb10b8a4596f9deff93fe43d008c/" rel="bookmark">
			Java split()方法简析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载请标明出处： 原文首发于： http://www.zhangruibin.com 本文出自 RebornChang的博客 厚颜打广告，博主个人博客地址传送门 ，欢迎来访 split方法的分类 关于Java中的split方法，这里大致分为三种：
假定字符串String = “1，2，，，，，”，使用不同的split方法的话，其效果如下面所示；
js中的split方法 使用的方法： var string = “1，2，，，，，”； var arr = []; arr = value.split(","); alert（arr.length）； 可以得到此时的arr数组的长度为6，也就是说，后面的那些逗号中间的空字符串，并没有trim掉；
Java中的使用方法 split（String regex） String offerCodes = “1，2，，，，，”; String[] offerCodeString = offerCodes.split(","); System.out.println("offerCodeString.length"+offerCodeString.length); 控制台打印出来的数组长度为2；
可以看到，单参数，按照指定字符进行分割的话，后面的那些空字符串都默认去掉了，那如果我想要后面的这些空字符串怎么办？看下面的这种split方法；
split（Sting regex,int limit） String offerCodes = “1，2，，，，，”; String[] offerCodeString = offerCodes.split(",",-1); System.out.println("offerCodeString.length"+offerCodeString.length); 控制台打印出来的数组长度为6；
也就是说没有把后面的空字符串去掉，但是为什么后面的参数填个-1呢？能不能换成其他的值？那这么想的话就有必要走一波源码了；
Java jdk1.8 split源码简析 源码注释 string字符串的split方法从JDK1.4中开始存在，来一波源码里面的表格：
源码中给出了示例字符串：“boo:and:foo”；然后，传入不同的参数，得到的结果如下：
RegexLimitResult:2 "boo", "and:foo" :5 "boo", "and", "foo" :-2 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d10eb10b8a4596f9deff93fe43d008c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c722af5a0d7b1111e2931e8df8f837a0/" rel="bookmark">
			VMware下安装并配置CentOS6.5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.安装空白虚拟机
2.安装CentOS
3.配置新的CentoOS
3.1 配置网络
3.2 关闭防火墙
1.安装空白虚拟机 进入VMware Workstation点击“创建新的虚拟机”，弹出新建虚拟机向导，默认选中“典型（推荐）”，点击“下一步。
在安装来源的选项中，选择“稍后安装操作系统”，点击“下一步”。
选择相应的客户机操作系统和对应版本，点击“下一步”。
设置虚拟机的名称和安装目录，点击“下一步”。
设置虚拟机磁盘，可根据自己实际情况进行调整磁盘大小，默认是20GB，我这里设置的是30GB；默认情况下是“将虚拟机磁盘拆分成多个文件”，便于移动虚拟机，但会降低虚拟机磁盘性能，为了提高虚拟机磁盘性能，我这里选择了“将虚拟磁盘存储为单个文件”。 点击“下一步”。
点击“自定义硬件”，可以自定义配置硬件设备，可以配置内存、处理器、网络、USB、声卡、打印机、显示器等内容。这里需要配置内存和网络。我这里设置的是2GB内存，网络连接采用桥接模式。
点击“关闭”。点击“完成”。至此创建一个空白的虚拟机完成了。新创建的虚拟机在工作空间中已经出现了。
2.安装CentOS 之前配置了空白的虚拟机，只是一个壳子，下面将加载CentOS镜像并安装。点击“编辑虚拟机设置”。
选择“CD/DVD”，左边选择使用“ISO镜像文件”，点击“浏览”，选择已经复制到当前虚拟机目录下的CentOS镜像（一定要提前将镜像复制好，多个虚拟机不要公用同一镜像文件）。点击“确定”。
配置好之后点击“开启此虚拟机”。开启之后进入安装画面，选择第一个“Install or upgrade an existing system”。
选择“Skip”，不进行测试。
进入系统配置页面，点击“Next”。
选择语言，选“Englist”就好，点击“Next”。
键盘选择“U.S English”，选择美式键盘，点击“Next”。
选择存储设备，选择“Basic Storage Devices”，基本存储设备。将系统装在本地的磁盘驱动器（硬盘）上。点击“Next”。
选择“Yes，discard any data”，丢弃所有数据，如果是新建的虚拟机，选择此项。
设置主机名Hostname，我这里设置的叫“workder1”，点击“Next”。
选择时区，这里只有上海时间，没有北京时间，点击“Next”。
设置root用户的密码，需要确认密码，要6位以上密码。如果设置的过于简单，会提示密码设置太简单，询问你是否使用，点击“User Anyway”。点击“Next”。
选择默认分区，点击“Next”。
系统会提示分区的数据会被修改，数据会丢失，由于我们是新建虚拟机，所以选择“Write changes to disk”。
系统进行安装。
出现下面的画面表示安装完成，点击“Reboot”重启系统。此时，系统已经安装完成。
3.配置新的CentoOS 进入系统需要输入用户名，密码，这里用root用户进行登录
3.1 配置网络 首先查看本机的网络配置，本机网络配置如下：
修改eth-0配置文件
vi /etc/sysconfig/network-scripts/ifcfg-eth0 修改如下配置：
BOOTPROTO=static ONBOOT=yes 增加如下配置：
IPADDR=192.168.31.116 NETMASK=255.255.255.0 GATEWAY=192.168.31.1 最终是这样的：
保存并退出。
然后重启网卡
service network restart 重启之后，查看网络配置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c722af5a0d7b1111e2931e8df8f837a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9b63da71133a3373eb2767046c72b52/" rel="bookmark">
			Ajax解析后台数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前台部分页面 &lt;h1&gt;登陆&lt;/h1&gt; &lt;div class="input_box"&gt; &lt;sapn &gt;&lt;i class="fa fa-user fs_20" style="margin: 14px 0 0 20px;float:left; color: #c7c7e0"&gt;&lt;/i&gt;&lt;/sapn&gt; &lt;div class="" style="height: 45px;"&gt;	&lt;input id="login_user" type="text" class="" value="" style="height: 45px;text-indent: 20px;font-size: 16px"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input_box"&gt; &lt;sapn &gt;&lt;i class="fa fa-lock fs_20" style="margin: 14px 0 0 20px;float:left;color: #c7c7e0"&gt;&lt;/i&gt;&lt;/sapn&gt; &lt;div class="" style="height: 45px;"&gt;	&lt;input id="login_key" type="text" class="" value="" style="height: 45px;text-indent: 20px;font-size: 16px"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; $("#login_button").click(function(){ var params = { "userMobile": $("#login_user").val(),//取出文本中的值 "userPass": $("#login_key").val(), } $.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9b63da71133a3373eb2767046c72b52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc431db810ddd559a3ca920b7deb99e2/" rel="bookmark">
			Java自带的线程池Executors.newFixedThreadPool
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。 在Java5之前，要实现一个线程池是相当有难度的，现在Java5为我们做好了一切，我们只需要按照提供的API来使用，即可享受线程池带来的极大便利。 Java5的线程池分好多种：具体的可以分为两类，固定尺寸的线程池、可变尺寸连接池。 在使用线程池之前，必须知道如何去创建一个线程池，在Java5中，需要了解的是java.util.concurrent.Executors类的API，这个类提供大量创建连接池的静态方法，是必须掌握的。
一、固定大小的线程池，newFixedThreadPool：
class TestThread extends Thread { private String flag; public TestThread(String flag) { this.flag = flag; } @Override public void run() { System.out.println(Thread.currentThread().getName() + "正在执行。。。" + flag); } } @Test public void fixedThreadPoolTest() { // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(5); // 创建线程 Thread t1 = new TestThread("111"); Thread t2 = new TestThread("222"); Thread t3 = new TestThread("333"); Thread t4 = new TestThread("444"); Thread t5 = new TestThread("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc431db810ddd559a3ca920b7deb99e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f670df70424663cc3738b44e93eca61/" rel="bookmark">
			Nodejs阿里云OSS获取STS 授权
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装依赖 yarn add axios yarn add urlencode yarn add crypto-js yarn add qs复制代码 导包
const axios = require('axios'); const urlencode = require('urlencode'); const CryptoJS = require('crypto-js'); const crypto = require('crypto'); const qs = require('qs');复制代码 代码实现
async function aliyunSTS2() { var params = { AccessKeyId: '阿里云AccessKeyId', Action: 'AssumeRole', Format: 'JSON', RoleArn: 'acs:ram::xxxxxxxx:role/xxxxxx', RoleSessionName: 'ann-sts-nodejs 此处自定义，注意字符限制 字母和-数字的组合', SignatureMethod: 'HMAC-SHA1', SignatureNonce: new Date().getTime().toLocaleString(),//随机字符串吧 SignatureVersion: '1.0', Timestamp: new Date().toISOString().replace(/\..+/,'') + 'Z', Version: '2015-04-01' } var CanonicalizedQueryString = qs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f670df70424663cc3738b44e93eca61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/018e7a86894bfcc2c317e6cfcc56ca33/" rel="bookmark">
			一个AI产品（数据挖掘）的产生过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		模型的训练一般包括以下步骤：
1：数据的输入： 一般使用pandas库，他有几种常用的读入不同文件类型的函数：
一般我使用read_csv(File_Path,[params]);（对应的文件类型为csv文件，这是数据挖掘中的常用文件格式）
2:数据的预处理： 1）：缺失值的处理： 使用方法可以用pandas下的imputing这个方法
但是其实自己根据实际问题（结合业务来进行填充可能要更好一些，如一些特征，本身他的缺失可能就意味着某种信息，如房屋数据里面的泳池，普通家庭可能是没有泳池的，如果该字段缺失可能说明该栋房屋本身就没有泳池）
上面的是本身缺失有意义的情况下：
那么在没有意义的情况下，我们又想此条数据保留下来，我们又改如何填充呢：
最好的方式就是根据不同的类别算出一个平均值或者众数，中位数，来进行填充，
具体该用什么值进行填充是需要进行实际测试的 ，这也就是数据挖掘过程中复杂的地方，但是这只是过程的复杂，并不是逻辑的复杂，
关于问题建模和优化问题的复杂，处理过程的多样性的复杂，你至少通过时间的积累，慢慢的总结出那种数据的处理方式带来更好的效果；（这也就是目前AI方向调包侠存在的价值所在，因为这一部分跟业务有特别紧密的联系，具体到了更加实际的问题）
至于后面的模型的选择和优化问题，那是正真更加高级的东西；本人还没有这方面的能力，鄙人目前也是调包调参侠一名；对别人的算法原理有一定的了解，知道什么问题该用什么问题，至于在再别人的模型的基础上优化出更加好的模型，还需要努力，
说一下模型的优化问题，就拿rnn来举例把，对于序列化的问题，一开始人是懵逼的，不知道怎么做，但是这时候大牛出现了，实现了一个rnn的算法来解决像时间这种序列化的问题；但是随着使用，rnn的问题又暴露了出来，对于很久之前的序列，rnn无法记住，没有记忆功能，如NLP（自然语言处理）中的一个问题：
eg: 今天上午有英语课，所以我应该带_____书；
很明显答案是英语书，如果用传统的rnn模型，由于没有记忆功能，训练得到我们答案的正确率不搞，好了，那这个时候我们该怎么办呢：
好了大牛又出现了，发明了一个LSTM(Long short term memory)模型，加入了门逻辑单元，有效的解决了对于之前内容的遗忘问题；
2）：数据的归一化（标准化）问题 数据归一化问题在特征区间差别太大时需要处理的问题；如房屋的价格特征：他的值可能最大能达到好几百万的程度，但是房屋的另外一个特征房价数可能只有几个，这时候就出现了数据值相差太大的问题：
我在用tensorflow做回归任务的时候遇到过，归一化和不归一化的相差结果确实有一定的差距；
但是看过一篇博客说，基于平方损失的最小二乘法不需要进行归一化，但是对于大多数的数值型的回归预测，基本使用的损失函数都是最小二乘法，
如果你拿不准，那就都试试之后看哪个效果更好一些；再进行选择；（毕竟这东西有点玄学，更偏向于实践，数据挖掘过程就是不断把假设进行测试的过程）
下面是关于一个关于需要进行归一化算法的总结：
数据需要归一化的机器学习算法
需要归一化的模型：
有些模型在各个维度进行不均匀伸缩后，最优解与原来不等价，例如SVM（距离分界面远的也拉近了，支持向量变多？）。对于这样的模型，除非本来各维数据的分布范围就比较接近，否则必须进行标准化，以免模型参数被分布范围较大或较小的数据dominate。
有些模型在各个维度进行不均匀伸缩后，最优解与原来等价，例如logistic regression（因为θ的大小本来就自学习出不同的feature的重要性吧？）。对于这样的模型，是否标准化理论上不会改变最优解。但是，由于实际求解往往使用迭代算法，如果目标函数的形状太“扁”，迭代算法可能收敛得很慢甚至不收敛。所以对于具有伸缩不变性的模型，最好也进行数据标准化。
有些模型/优化方法的效果会强烈地依赖于特征是否归一化，如LogisticReg，SVM，NeuralNetwork，SGD等。
不需要归一化的模型：
（0/1取值的特征通常不需要归一化，归一化会破坏它的稀疏性。）
有些模型则不受归一化影响，如DecisionTree。
ICA好像不需要归一化（因为独立成分如果归一化了就不独立了？）。
基于平方损失的最小二乘法OLS不需要归一化。
原文：https://blog.csdn.net/pipisorry/article/details/52247379 关于特征的归一化和标准化，pandas里面都有相应的库，再pandas.preprocess里面；
3）:最重要的一点就是关于异常值的检测了 异常值的检测关乎数据的质量问题，我觉得是最重要也是最难的问题的，因为一批数据的异常值往往很难定义，一条数据根据不同的判别方法，也可能表现出不同的效果，而且目前的异常值检测算法大多数对于阈值的确定需要自己的判断：（如基于距离的，基于密度的等）
下面说一下有哪些异常值的检测算法：
1）iforest：这是我比较推荐的一种异常值检测算法：因为它不需要你人为的设置一个阈值，在实际的测试效果也不错；
2）：基于距离的：KNN算法
3）：基于简单统计量的，如3σ原则，分位点原则等等；
3：特征工程部分 可以说特征工程是决定一个训练好模型好坏的决定性步骤，数据决定了你模型的上线，而模型算法只是逼近这个上线，有时你提炼出了一个关键特征之后，可能你的精度会有很大的提升：
1）：特征转换：常用的有log(np.log)变换（可以让特征更normal）对于数值类型的回归模型，如果越符合正太分布的标准，那么模型的精度就会越高；还有box-cox(scipy.state)
2）：离散特征（one_hot编码，label编码，）
3）：连续特征：离散化操作：分箱（bin）（有等频，和等距）
4）：对于一些原始看起来并没有用的特征，如日期：你可能需要通过特征衍生的方式将它转换成有用的特征，如：距离某一个具有重大时间点的天数这个特征；
5：特征组合：
1）如：经纬度特征，他俩组合起来就可以唯一确定一个点（也就是精确位置了）
2）：离散性之间：不同类别之间相互组合
3）连续型的变量之间：加减乘除等；
其实对于一些高级的框架，如tensorflow，他已经将这些方法封装起来了，详情的使用方法见：
https://mp.csdn.net/postedit/80933921
做完这些数据的处理之后，是的，我个人觉得这些其实都属于数据的处理；只是特征工程显得更加重要和复杂，更具有研究型，所以从数据数据处理中提出来，当成了一个单个的过程；
4：算法的选择 算法的选择情况有很多种情况：
1：根据实际的问题可以分为回归，分类，聚类前两者属于监督学习，聚类问题属于无监督的学习；
2：更具算法来分：可以分为机器学习和深度学习：
3：然后根据每一个算法适用领域又还可以分；；比如CNN多用于图像问题；RNN多用于语音识别问题等
5：参数的调节和bagging思想 由于这些方法有很多的超参数，所以你需要通过调参的方式对你的模型进行调整；对于机器学习而言，GridSearch（网格搜索是一个不错的选择，但是不是说把参数全部放进去就可以了，你需要针对不同算法的特点，对参数进行分组调参，这里以xgboost来举例子：如决策树中有两个参数是depth和 min_child_weight(树的深度和树的深度，最小孩子权重）这些都是决定树特性的，还有一些其他的参数；分开调节可以节约计算量，参数过多，如果全都一起调节，可能爬不动；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/018e7a86894bfcc2c317e6cfcc56ca33/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4e0ee2d9ed0ef9782cfbc1d2eda74c8/" rel="bookmark">
			Python学习笔记，51job数据清洗篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据清洗篇 思路：
1.主要分析的python资薪情况。而工资会有几种情况，如万/月；万/年；千/月；万以上/年；万以上/月；这明显就不方便我们分析。在这个我们统一转化为10k/月的形式进行分析。
2.明确目标，这里使用split,replace,lambda来进行数据清洗。
还是先上代码：
import pymysql import pandas as pda import numpy as npy import re import matplotlib.pylab as pyl import matplotlib.mlab as mlab import matplotlib.pyplot as plt #连接数据库 conn = pymysql.connect(host="127.0.0.1",user="root",passwd="lxw19961230",db="51job") sql = "select * from python_1" data = pda.read_sql(sql,conn) #筛选出有万和月的 wan_yue=[] #计数变量，统计万以上出现的次数 count1 = 0 data_money=data['money'].dropna() #统计万以上的数据 wan_yis=[] #统计万和年的数据 wan_nian=[] count3=0 for i in data_money: if '以上' in i and '月' in i: wan_yis.append(i) count1 += 1 continue if "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4e0ee2d9ed0ef9782cfbc1d2eda74c8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afbf7da2a0582b95a3976370995d0007/" rel="bookmark">
			这部关于 AI 的纪录片，还是值得一看的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纪录片《 AlphaGo 》（中文译名：阿尔法围棋），是由 Google 与 DeepMind 团队出品，纪录片导演 Greg Kohs 和团队精心制作完成。讲述了 DeepMind 团队带领 AlphaGo 与人类顶尖棋手展开对决的几场关键性比赛。 这部纪录片在去年自各个影展上小规模放映后，就收获了不少奖项，在今年出在 Netflix 公开播出，甚至在 IMDB 上一度取得 8.9 分的评分。
《AlphaGo 阿尔法围棋》，并不是 Google 出品的第一部影视作品，但却是第一部在海内外收获了无数奖项和好评的纪录片作品。
故事的主角：程序员 VS 棋手 纪录片中，讲述了 DeepMind 团队，在完成 AlphaGo 的早期版本后，邀请人类顶尖棋手对弈的过程。其中最重要的比赛便是 AlphaGo 对阵当时世界排名第一的韩国棋手李世石。
纪录片中的主要人物，就是 AlphaGo 的工程团队和几位棋手：
「我们团队都希望 DeepMind 能够成为 AI 界重要的前进力量，好比阿波罗登月计划那样。我们最大的愿景，就是通过人力去探索去塑造智能。」——Demis Hassabis (DeepMind 联合创始人 &amp; CEO)
Demis Hassabis 是 DeepMind 的创始人，同时自己也是国际象棋的选手，他自小练习国际象棋，13 岁已经成为国际大赛的亚军。这也是他组建 DeepMind 团队后，一直使用棋类进行 AI 训练的原因之一。在片中，他表现出了过人的领导力、对 AI 和围棋的敬畏和执着。
「李世石是非常出色的棋手，我很荣幸能够帮助 AlphaGo 和他对弈，我知道全世界都在期待这场比赛，AlphaGo 已经准备好了。」——黄士杰 (DeepMind 首席工程师)
来自台湾的黄士杰博士是 DeepMind 的首席工程师，不过他在片中往往很沉默，他的同事也解释了他比较内向，并不喜欢面对镜头。却不仅是 DeepMind 重要的灵魂人物，同时也是 AlphaGo 项目的主程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afbf7da2a0582b95a3976370995d0007/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8190b5a95a83f82d141ae2c439dac17f/" rel="bookmark">
			2018年10月21日训练笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天比赛，可以出的题有一道G题DP题，一道J题差分约束，都是我不擅长的，所以很不舒服，所以今天补了补，看了一点差分约束，借机看了看图论，找了一些资料，今天争取看完。然后DP题其实比赛时是没有往这方向想的，其实DP方法不难，但做法确实想不到，吸取经验吧。
然后模板还没整理完，主要还是一点数学的东西，毕竟其他知识点也不怎么会，其他知识点只要在于简单了解下，分辨出题型和思路，能和队友讨论讨论就很好。
昨天给18级讲课还是有所体会的：感觉讲课确实很累，想要讲好可是需要做好足够备课工作的。然后新生现在关键是要熟练语言工具，多练才行，得熟练这套编程规则，面对已给问题，学会用编程思想来思考。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6283085b9a50ccf6aff01c0421010de8/" rel="bookmark">
			solidity教程（一）搭建僵尸工厂
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title: solidity教程（一）基础
tags: solidity,eth
声明：本系列教程是整理cryptozombies
https://cryptozombies.io/zh而来。
人类，欢迎你
你认为你可以当一个合格的 CryptoZombie, 嗯？
这个教程会教你如何搭建一个以太网的游戏。
此课程为 Solidity 初学者设计，需要你对其他的程序语言有所了解（如 JavaScript)。
少年，准备开始了吗?
第1章: 课程概述 第一课你将创造一个"僵尸工厂"， 用它建立一支僵尸部队。
我们的工厂会把我们部队中所有的僵尸保存到数据库中工厂会有一个函数能产生新的僵尸每个僵尸会有一个随机的独一无二的面孔
在后面的课程里，我们会增加功能。比如，让僵尸能攻击人类或其它僵尸! 但是在实现这些好玩的功能之前，我们先要实现创建僵尸这样的基本功能。 僵尸DNA如何运作
僵尸的面孔取决于它的DNA。它的DNA很简单，由一个16位的整数组成：
8356281049284737
如同真正的DNA, 这个数字的不同部分会对应不同的特点。 前2位代表头型，紧接着的2位代表眼睛，等等。
注: 本教程我们尽量简化。我们的僵尸只有7种头型(虽然2位数字允许100种可能性)。以后我们会加入更多的头型, 如果我们想让僵尸有更多造型。
例如，前两位数字是 83， 计算僵尸的头型，我们做83 % 7 + 1 = 7 运算， 此僵尸将被赋予第七类头型。
第2章: 合约 从最基本的开始入手:
Solidity 的代码都包裹在合约里面. 一份合约就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.
一份名为 HelloWorld 的空合约如下:
contract HelloWorld { } 版本指令 所有的 Solidity 源码都必须冠以 “version pragma” — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6283085b9a50ccf6aff01c0421010de8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb624da6b91075178e2cfe32087a4cb0/" rel="bookmark">
			8.Python 学习系列--------Python 基本语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		三个内置必须要记住，Python stype help dir
目录
1 python一切皆为对象，因为现实
2.数据类型的组成
3。常用基本数据类型.
4.数据类型的可变和不可变
5.变量之赋值一切皆为引用，动态性与动态类型之为何不再动态
字符串认知与应用
认知1.字符串概念
一.len之需注意
二.转义符让文本更好处理
三.字符串前面跟着的小尾巴到底是什么东西
四.访问子字符串，序列来了。
五.替换字符串
六.字符串拼接
七.读写文本来了
1 python一切皆为对象，因为现实 包含了一系列的数据和操作这些数据的方法的一个整体，就叫作对象。
自行车
属性：手刹车，轮胎，脚踏板
方法：如何前进的方法，控制停止的方法，控制方向
实际内容 男人与女人的恋爱
男人与男人的恋爱
女人与女人的恋爱
方法1：一见钟情
2.数据类型的组成 组成3部分。
身份 id方法来看一看他的唯一标示符，内存地址靠这个哦！
类型 type来看一看。
值 数据项。
某书里的傲娇结论：python里一切都是指针，所以不用再考虑指针这个问题了！
3。常用基本数据类型. int 整型
boolean 布尔
string 字符串
list 列表
tuple 元祖
dict 字典
4.数据类型的可变和不可变 不可变类型：int，string,tuple
可变类型:list,dict
比较值是==，比较两边的类型值是不是一样的，类型是不是一样，数值是不是一样的
5.变量之赋值一切皆为引用，动态性与动态类型之为何不再动态 字符串认知与应用 认知1.字符串概念 认知2.ascii unicode utf8到底是啥，Python默认的编码都是ASCII码，方便 一.编码的问题 length是指大小，所占的空间的大小，
len(a)
转换编码，看看是不是对的
#coding=unf -8，Python2容易出问题 d = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb624da6b91075178e2cfe32087a4cb0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4312711fdb6631e9b4532054531dc566/" rel="bookmark">
			JAVA常用工具类(三)  SystemUtils类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的函数操作，基于commons-lang-2.5。
1.获取Java Home目录，返回File
SystemUtils.getJavaHome()
2.获取Java IO临时目录文件，返回File
SystemUtils.getJavaIoTmpDir()
3.获取Java版本，返回Float
SystemUtils.getJavaVersion()
相对应的还有getJavaVersionAsFloat()、getJavaVersionAsInt()
4.获取用户目录，返回File
SystemUtils.getUserDir()
5.获取获取用户主目录，返回File
SystemUtils.getUserHome()
6.判断当前Java版本是否满足要求，返回boolean。
SystemUtils.isJavaVersionAtLeast(float|int requiredVersion)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b460cd9a500ef68790315989ec097307/" rel="bookmark">
			JAVA基础 之 关于序列化与反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序列化Serializable，是指将JAVA对象转换为字符序列的过程，将对象的各属性保存起来，在适当的时候获取并使用。
反序列化是和序列化相反的过程，就是把字符序列转化为对象的过程。
在JAVA编码中被广泛提及，主要应用在以下情况中：
1.持久化存储数据；
2.进程间的远程通信。
JAVA对象Person的实例化seriaObject private static final String FILE_NAME="d:/test.txt"; //序列化 FileOutputStream fos = new FileOutputStream(FILE_NAME); ObjectOutputStream out=new ObjectOutputStream(fos); out.writeObject(seriaObject); out.close(); fos.close(); //反序列化 FileInputStream fis = new FileInputStream(FILE_NAME); ObjectInputStream in=new ObjectInputStream(fis); Object obj = in.readObject(); in.close(); fis.close(); 注意：
1.不可被序列化类型变量：static，transient
2.serialVersionUID不可随意修改，在反序列化的时候serialVersionUID被修改的话，会失败。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a99ac5613f8c0e6f00d81f0ba608bdcc/" rel="bookmark">
			throw和throws的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1：throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常) 调用者必须做出处理（捕获或继续抛出）
2：throws可以单独使用，但throw不能， throw要么和try-catch-finally语句配套使用，要么与throws配套使用。但throws可以单独使 用，然后再由处理异常的方法捕获。
3：throws主要是声明这个方法会抛出这种类型的异常，使其他地方调用它时知道要捕获这个异常，使得提醒必须做出处理。否则编译是不会通过的。 throw是具体向外抛异常的动作，所以它是抛出一个异常实例。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcea1e785a5a8beac3a360722e331b4b/" rel="bookmark">
			_exit和exit的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux的标准库函数中，有一套称作高级I/O的函数，我们熟知的printf 、fopen 、fread 、fwrite都在此列，他们也被称作缓冲I/O。其特征是对应每一个打开的文件，都存在一个缓冲区， 在内存中都有一片缓冲区，每次读文件会多读若干条记录，这样下次读文件时就可以直接从内存的缓存中取出，每次写文件时也仅仅是写入到内存的缓冲区，等待满足一定的条件（达到一定的数量，或者遇到特定字符，如换行和文件结束符EOF），再将缓冲区的内容一次性的写入文件，这样就大大增加了文件读写的速度，但也为我们编程带来了一点点麻烦，如果有些数据，我们认为已经写入了文件，实际上因为没有满足特定的条件，他们还只是保存在缓冲区内，这时我们用_exit函数直接将程序关闭，缓冲区中的数据就会丢失，反之，如果向保证数据的完整性，就一定要使用exit函数。
exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是图中的"清理I/O缓冲一项。
exit()函数定义在stdlib.h中，而_exit()定义在unistd.h中。exit()和_exit()都用于正常终止一个函数。但_exit()直接是一个sys_exit系统调用，而exit()则通常是普通函数库中的一个函数。它会先执行一些清除操作，例如调用执行各终止处理函数、关闭所有标准IO等，然后调用sys_exit。
_exit()　－－－　直接结束进程进入到内核中
exit()　－－－　清理I/O缓冲区后再退出进程
下面我就举个例子说明下吧，
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { int ret = 0; printf("I'm ok!\n"); printf("Good good study!"); _exit(0); } //执行输出： //I'm ok! #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { int ret = 0; printf("I'm ok!\n"); printf("Good good study!"); exit(0); } //执行输出： //I'm ok! //Good good study! （转者注：我在visual studio上运行，两个程序的输出结果一样，都输出两句话，不清楚为什么和作者的输出不一样？）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdb14eb5e25aa7c4c152292de31fbec2/" rel="bookmark">
			经典数字游戏——数独（Sudoku）解法的Python代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原创文章，转载请注明出处
导语 “数独是源自18世纪瑞士的一种数学游戏。是一种运用纸、笔进行演算的逻辑游戏。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3*3）内的数字均含1-9，不重复。” 1
比如这个数独，左上角有1个9，则红线标出的位置都不能再填9。
总的来说，数独是一个逻辑推理的数字游戏，规则简单，上手容易，逼格高端，提神健脑，是防痴呆、防迟钝的不二神器，应该勤做多练。但是本人是甘于懒惰的，所以写一个解法，让机器自动解数独。
思路 深度优先搜索，回溯搜索算法。
使用4个List，List1(9*9)按位置记录填入数独的数字，List2记录所有当前空白格的坐标，List3（9*9*9）按位置记录该位置1-9这9个数字是否可填（值为该行、该列和该宫某一数字出现的次数，比如List3[ 1 ][ 2 ][ 5 ]=3，表示第1行和第2列和(1,2)这一格所在宫共有3个5，值大于0表示该数字被占用不能填入，值等于0表示该数字未被占用可以填入），List4作为栈缓存每一次遇到分支时的List1、List2和List3。
寻找唯一解填入。唯一解是该空格只能填某一个数字，即对于List3[ i ][ j ][ x ]只有一个x（1-9中的某个数字）对应的值等于0。唯一解寻找完毕，寻找尝试解。尝试解是该空格可以有多种可能数填入。这里有一个规则是先尝试可能数少的，这样可以更快的找到答案，减少回溯次数。执行一步尝试解，List4则存入本次填数前的List1，List2，List3（要剪枝）。 循环执行1、2步，遇到无尝试解时，则从List4取最后一步状态，重新继续循环，循环跳出条件为List2为空。
代码 import numpy as np from copy import deepcopy import time import xlrd import xlwt StartTime=time.time() wb=xlrd.open_workbook(r'C:\Users\Administrator\Desktop\Python\Sudoku.xlsx') sheet=wb.sheets()[0] input_tmp=[] steps=0 #记录总步数 sudoku=[] #记录填写数字 sudoku_origin=[] #记录原始数字 SudokuRecord=[] #记录尝试记录 blanks_list=[] #记录空白格坐标 SudokuNum=[[[0 for x in range(9)] for y in range(9)] for z in range(9)] #记录每格可用数字 for m in range(1,10): for n in range(1,10): if sheet.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdb14eb5e25aa7c4c152292de31fbec2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/444/">«</a>
	<span class="pagination__item pagination__item--current">445/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/446/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>