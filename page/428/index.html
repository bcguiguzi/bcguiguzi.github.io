<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4292c4064d3af6c2bc653ac36d065500/" rel="bookmark">
			《网络安全等级保护基本要求》GB/T 22239-2019 等保2.0 pdf版下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019年5月13日，国家标准化管理委员会发布了新修订的《信息安全技术-网络安全等级保护基本要求》，这被很多人称为“等保2.0”。
我找了一份网上流传的《网络安全等级保护基本要求》待审稿和一份等保2.0的标准解读文件，供大家参考学习。
文件下载地址：https://github.com/7hmA3s/ClassifiedProtection
其中《网络安全等级保护基本要求》（GB/T 22239-2019）标准解读在公安部第三研究所网站上可以找到，网址为：http://netinfo-security.org/article/2019/1671-1122-19-2-77.html
转载于:https://www.cnblogs.com/dgjnszf/p/10862177.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8248f9b1a6bebbf7950bd6f7ebe42e26/" rel="bookmark">
			深度学习: one-stage/two-stage/multi-stage 目标检测算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Introduction
Detection主要分为以下三个支系：
- one-stage系 two-stage系 multi-stage系
主要算法 YOLOv1、SSD、YOLOv2、RetinaNet、YOLOv3 Fast R-CNN、Faster R-CNN R-CNN、SPPNet
检测精度 较低 较高 极低
检测速度 较快 较慢 极慢
鼻祖 YOLOv1 Fast R-CNN R-CNN
状态 已淘汰
Detection算法的几个task
对于不需要预生成RP的Detection算法而言，算法只需要完成三个任务：
特征抽取
分类
定位回归
对于有预生成RP的Detection算法而言，算法要完成的主要有四个任务：
特征抽取
生成RP
分类
定位回归
Detection算法的框架套路
multi-stage 算法
最早期的检测算法 (主要为R-CNN、SPPNet) 都属于multi-stage系。这个时候的Selective Serach、Feature extraction、location regressor、cls SVM是分成多个stage来各自单独train的。故谓之曰“multi-stage”： two-stage 算法
到了Fast R-CNN的时候，Feature extraction、location regressor、cls SVM都被整合到了一个network里面，可以实现这三个task一起train了。由于生成RP的task还需要另外train，故谓之曰“two-stage”： 到了Faster R-CNN中，虽然RPN的出现使得四个task可以一起被train，但是依然被归类为“two-stage”。（这个地方我也不是很理解。）
one-stage 算法
在YOLOv1中，“生成RP”这一任务被直接丢弃了。因此，整个算法只剩下了一个stage，故谓之曰“one-stage”： [1] 检测任务专题2: two-stage检测 [2] Object Detection–RCNN,SPPNet,Fast RCNN，FasterRCNN论文详解
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2cd6a8d68535914fbe05370e062fe4ac/" rel="bookmark">
			ex33 while循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		i = 0 numbers = [] while i &lt; 6: print("The number is %d." %i) #当前的i numbers.append(i) i += 1 print("Number now:",numbers ) #当前列表numbers的元素 print("At the bottom i is %d." %i) #执行i=i+1后的i for num in numbers: #这时numbers已经变成[0,1,2,3,4,5] print(num) 运行结果
PS E:\tonyc\Documents\Vs workspace&gt; cd ‘e:\tonyc\Documents\Vs workspace’; ${env:PYTHONIOENCODING}=‘UTF-8’; ${env:PYTHONUNBUFFERED}=‘1’; &amp; ‘D:\Anboot\Python\python.exe’ ‘c:\Users\tonyc.vscode\extensions\ms-python.python-2019.3.6558\pythonFiles\ptvsd_launcher.py’ ‘–default’ ‘–client’ ‘–host’ ‘localhost’ ‘–port’ ‘58393’ ‘e:\tonyc\documents\vs workspace\the hard way\ex33(while
循环).py’
The number is 0.
Number now: [0]
At the bottom i is 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2cd6a8d68535914fbe05370e062fe4ac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2dd3d5f997d87885495dbfa361ffe0c/" rel="bookmark">
			ex32 for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一个关于for循环的简单练习
the_count = [1,2,3,4,5] fruits = ['apples','oranges','pears','bananas'] change = [1,'pennies',2,'dimes',3,'quarters'] #for循环输出 for number in the_count: print("The number is %d." %number) for fruit in fruits: print("Do you like %s?" %fruit) #如果输出列表的包含多种格式，使用%r for i in change: #i在这里指的是列表change里面的所有元素 print("I got %r." %i) #创建一个空列表，使用range和append将列表元素添加到空列表中去 elements = [] #空列表 for i in range(0,6): print("Adding %d to the list." %i) elements.append(i) #添加0-6的元素到elements中，注意元素顺序是包头不包尾 for i in elements: #经过append之后，elements现在是[0,1,2,3,4,5] print("Elements is %d." %i) 运行结果
PS E:\tonyc\Documents\Vs workspace&gt; cd ‘e:\tonyc\Documents\Vs workspace’; ${env:PYTHONIOENCODING}=‘UTF-8’; ${env:PYTHONUNBUFFERED}=‘1’; &amp; ‘D:\Anboot\Python\python.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2dd3d5f997d87885495dbfa361ffe0c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a71c1513d4def10ee50eb8b1fcc5714/" rel="bookmark">
			JAVA visualVM 查看堆栈分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于在做nlp，用到standFord nlp，堆栈分配总是一处，所以需要这个，正好学习一下。
我用的是jdk8.5，位于 JDK 根目录的 bin 文件夹下，无需安装，直接运行即可,你要是没有，安装高点版本的JDK 6 Update 7 以后。
双击打开，
选中你的程序，可以进行查看堆栈分配，实时监控
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0955af22f1f032ac705f6357ac22e957/" rel="bookmark">
			C语言的sleep、usleep、nanosleep等休眠函数的了解与用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言的sleep、usleep、nanosleep等休眠函数的了解与用法 昨天晚上，无聊中捣鼓「死循环」小代码的时候，想用 休眠 函数来慢慢显示输出结果，免得输出结果闪得太快，看都看不清。
但是，使用 sleep 函数的话，最短的休眠时间段是一秒钟，要想看到比较大的输出结果的话，要等好久，于是就查了一下有没有休眠时间段更小的函数。很容易地就找到了两个，一个是 usleep ，一个是 nanosleep 函数。
因为是第一次使用，尤其是 nanosleep 函数的第一个参数是一个没见过的结构体数据类型，所以花了一点点时间去学习和探索背后的细节，当然了，对于俺目前的水平而言，也只是了解了函数本身层面的浅显的细节而已。
捣鼓下来，觉得内容也不少，而且还是挺有用的，就整理了一下，组合成文章，发布在这里，也方便自己以后的回顾学习。
引子 一个无聊的死循环小代码：
#include &lt;stdio.h&gt; int main(int argc, char const *argv[]) { for (char c = 0; c &lt; 128; c++) { printf("cool\n"); } return 0; } 以及 运行过程 展示版：
#include &lt;stdio.h&gt; #include &lt;time.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main(int argc, char const *argv[]) { struct timespec n_sleep; n_sleep.tv_sec = 0; //secondes, integer part sleep duration n_sleep.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0955af22f1f032ac705f6357ac22e957/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/646d348194f18325d213bcb47d9ae677/" rel="bookmark">
			python查看数据维度，查看数据类型type，dtype查看数据类型，ndim查看维度，
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看数据类型type，dtype查看数据类型，ndim查看维度
type(X_train) X_train.dtype) X_train.ndim 查看维度：
print(X_train.shape) 还可以用： print(np.shape(X_test)) 实际上都是利用了Numpy
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/980c2360adb19aef7ddca443af5cdca5/" rel="bookmark">
			基于bow的图像检索
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图像检索与识别 目录
图像检索与识别
Bag-of-words模型
Bag of features：基础流程
K-means聚类算法
Bag of features：学习特征词典
Bag of features：图像检索
实验过程
1.生成sift特征集并保存模型：
2.载入词汇，遍历图像并把特征投影到词汇上
3.测试
Bag-of-words模型 Bag-of-words模型的基本思想是假定对于一个文本，忽略其词序和语法、句法，仅仅将其看做是一些词汇的集合，而文本中的每个词汇都是独立的。简单说就是讲每篇文档都看成一个袋子（因为里面装的都是词汇，所以称为词袋，Bag of words即因此而来），然后看这个袋子里装的都是些什么词汇，将其分类。
比如说，通过一定数量（比如说100张）的猫或狗的图片，通过网络爬虫，算出特征描述值（假设有1000个特征值），再对特征向量进行聚类（如K-means聚类算法），从1000个聚类成几个特征，并且每个特征都是128维的，把聚类质心作为视觉词典。输入一张想要搜索的图片，用SIFT算法提取特征点，将几千个128维的特征向量进行归类，通过查找视觉词典，用视觉单词直方图表示图像，该模型便称为BOW模型（希望的结果是类内差距小，类间差距大的直方图）。
Bag of features：基础流程 特征提取学习“视觉词典visual vocabulary” 针对输入特征集，根据视觉词典进行量化 把输入图像转化成视觉词典（visual words）的频率直方图 构造特征到图像的倒排表，通过倒排表快速索引相关图像根据索引结果进行直方图匹配 K-means聚类算法 最小化每个特征值与其相对应聚类中心之间的欧氏距离
算法流程：
随机初始化K个聚类中心重复一下步骤直至算法收敛： 对应每个特征，根据距离关系赋值给某个中心/类别对每个类别，根据其对应的特征集重新计算聚类中心 Bag of features：学习特征词典 聚类是实现visual vocabulary/codebook的关键:k-means算法获取的聚类中心作为codevector（视觉词典）
视觉词典示例：
字典用于对输入图片的特征集进行量化：对于输入特征，量化的过程是将该特征映射到距离最近的codevector,并实现计数
Bag of features：图像检索 给定输入图像的BOW直方图，在数据库中查找 k 个最近邻的图像，对于图像分类问题，可以根据这k个近邻图像的分类标签， 投票获得分类结果：
参数设置： 视觉单词数量（K-means算法获取的聚类中心）一般为 K=3000~10000. 即图像整体描述的直方图维度为 3000~10000. 求解近邻的方法一般采用L2-范数：即 Euclidean 距离目前普适的视觉单词采用 Lowe 的SIFT特征描述子. 特征 点检测采用 DOG (Difference of Gaussians). 实验过程 数据集：pictures文件夹中分别有20张皮卡丘、11张可达鸭、10张小火龙、28张杰尼龟、31张胖丁的图片
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/980c2360adb19aef7ddca443af5cdca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4519b3c5a460dd0cba7d5554f2dc8676/" rel="bookmark">
			剑指Offer 滑动窗口的最大值(队列的最大值)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目一：滑动窗口的最大值
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}。
解析：针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}，如下图所示：
1、思路 我们可以使用一个双端队列deque。
我们可以用STL中的deque来实现，接下来我们以数组{2,3,4,2,6,2,5,1}为例，来细说整体思路。
数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。
第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。下一个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。
但是我们怎样判断滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标与当前处理的数字的下标之差大于或者相等于滑动窗口大小时，这个数字已经从窗口中滑出，可以从队列中删除。
整体过程示意图：
实现代码如下：
class Solution { public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) { vector&lt;int&gt; res; if(num.size() &lt; size || size &lt; 1) return res; deque&lt;int&gt; index; for(int i=0;i&lt;size;++i){ while(!index.empty() &amp;&amp; num[index.back()]&lt;=num[i]) index.pop_back(); index.push_back(i); } for(int i=size;i&lt;num.size();++i){ res.push_back(num[index.front()]); while(!index.empty() &amp;&amp; num[index.back()]&lt;=num[i]) index.pop_back(); if(!index.empty() &amp;&amp; i-index.front()&gt;=size) index.pop_front(); index.push_back(i); } res.push_back(num[index.front()]); return res; } }; 面试题59（二）：队列的最大值 // 题目：给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。例如， // 如果输入数组{2, 3, 4, 2, 6, 2, 5, 1}及滑动窗口的大小3，那么一共存在6个 // 滑动窗口，它们的最大值分别为{4, 4, 6, 6, 6, 5}， 解析：和上题思路相似，用双端队列去解决
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4519b3c5a460dd0cba7d5554f2dc8676/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c152536a254700abf760d6853c872ebd/" rel="bookmark">
			Flutter基础篇（9）-- 手把手教你用Flutter实现Web页面编写
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：本文是作者AWeiLoveAndroid原创，版权归作者AWeiLoveAndroid所有，侵权必究。如若转发，请注明作者和来源地址！未经授权，严禁私自转载！
前面一篇文章介绍了Flutter for Web，这里就详细的讲解一下如何使用Flutter实现Web页面的编写。让大家10分钟之内快熟上手实践。
如果不想看文章，也可以看我的视频讲解：
手把手教你用Flutter实现Web页面编写
一、环境要求 （1）Flutter 版本最低要求1.5.4（使用flutter doctor -v查看Flutter版本，如果版本太低，请使用flutter upgrade升级到最新版本）。关于Flutter的详细安装，请查看我的博客 Flutter开发前提准备之Flutter从配置安装到填坑指南详解
（2）安装webdev工具
使用命令行进行安装 flutter packages pub global activate webdev， 如果安装不了，请科学上网再试试看。
webdev命令会下载以下这些包：
args 1.5.1 async 2.2.0 browser_launcher 0.1.2 build_daemon 0.6.0 built_collection 4.2.1 built_value 6.5.0 charcode 1.1.2 codemirror 0.5.4+5.45.0 collection 1.14.11 convert 2.1.1 crypto 2.0.6 devtools 0.0.19 (0.1.0 available) devtools_server 0.1.2 dwds 0.3.2 fixnum 0.10.9 http 0.12.0+2 http_multi_server 2.0.6 http_parser 3.1.3 intl 0.15.8 io 0.3.3 js 0.6.1+1 json_annotation 2.3.0 logging 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c152536a254700abf760d6853c872ebd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47826f5f3cae3fee97dd4653a3d2426e/" rel="bookmark">
			odoo 恢复数据库前端报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Could not get content for……
jQuery is not defined
原因：数据库缓存
解决方法：
1 select id, create_date, store_fname, datas_fname from ir_attachment where datas_fname like '%.js%'; 删除数据库中查出来的web.assets_common.js、web.assets_frontend.js、web.assets_backend.js
转载于:https://www.cnblogs.com/ljwTiey/p/10837677.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6ab063180aa5accf1da585691a638b40/" rel="bookmark">
			[一日一技] VUE中el-dialog点击空白不消失
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 很简单, 加上下面的就可以了
el-dialog中加入:close-on-click-modal="false"可以让点击空白不取消 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1361ff9a6c36b720f577722278a8900/" rel="bookmark">
			CTF-z3简要介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍 Z3是微软研究院的一个定理验证器。它是由麻省理工学院授权的，常用来解一些方程组，在做一些CTF逆向题目的时候很有用，下面就简单介绍一下这个工具。
下载 官网：https://github.com/Z3Prover/z3
这里讲Linux下的安装，执行下面的命令即可，还有很多教程说去官网下载源码安装，没有试过感觉麻烦了些，实在安装不了就用docker
sudo pip install z3-solver 例子 (angr) angr@9fceed56f09e:~$ python Python 3.6.7 (default, Oct 22 2018, 11:32:17) [GCC 8.2.0] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; from z3 import* &gt;&gt;&gt; x,y,z=BitVecs('x y z',8) # 申明未知量 &gt;&gt;&gt; s=Solver() # 创建约束求解器 &gt;&gt;&gt; s.add(x^y&amp;z==12) # 添加约束条件 &gt;&gt;&gt; s.add(y&amp;x&gt;&gt;3==3) &gt;&gt;&gt; s.add(z^y==4) &gt;&gt;&gt; s.check() # 检查是否有解 sat &gt;&gt;&gt; s.model() # 显示结果 [z = 19, y = 23, x = 31] &gt;&gt;&gt; 常用的数据类型如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1361ff9a6c36b720f577722278a8900/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5a7181bf5c273d71d005548aa54c916/" rel="bookmark">
			ex18 函数概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 简单的函数
#这个类似于之前练习中的argv，两个参数,再进行解包使用 def print_two(*args): arg1,arg2 = args print("arg1:%r,arg2:%r" %(arg1,arg2)) #实际上*args并没有特别意义，上面的函数也可以写成如下 def print_two_again(arg1,arg2): #使用def定义一个函数，后面为函数名，括号里面是参数 print("arg1:%r,arg2:%r" %(arg1,arg2)) #使用相应参数，定义函数功能 #只添加一个参数 def print_one(arg1): print("arg1:%r" %(arg1)) #不添加参数 def print_none(): print("Got nothing.") #使用上面定义好的函数，赋予参数 print_two('Tom','Jerry') #函数对应了几个参数就要赋予对应个数的参数 print_two_again('aa','bb') print_one(888) print_none() 运行结果
arg1:‘Tom’,arg2:‘Jerry’
arg1:‘aa’,arg2:‘bb’
arg1:888
Got nothing.
注意 函数定义以def开头，后面跟函数名（可以是字符和下划线），函数名后面的括号是参数，之后要以冒号结束本行，并且下一行自动缩进“‘运行函数(run)’、 ‘调用函数(call)’、和 ‘使用函数(use)’是同一个意思” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28a9be3be196542a31f383a2f2e9077/" rel="bookmark">
			C语言float有效位数为7位？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扣扣技术交流群：460189483 首先我们应该明确一点：C语言中，％f表示保留7位有效数字7位有效数字： 是指 整数部分 和小数部分一共7位
谭浩强的c语言，里面讲float型变量只能接受7位有效数字，比如float a；a=12345.6789；a变量中只能存储12345.67，最后两位丢失。
单精度数的尾数用23位存储，加上默认的小数点前的1位1，2^(23+1) = 16777216。
因为 10^7 &lt; 16777216 &lt; 10^8，所以说单精度浮点数的有效位数是7位。 双精度的尾数用52位存储，2^(52+1) = 9007199254740992，
因为10^16 &lt; 9007199254740992 &lt; 10^17，所以双精度的有效位数是16位。
从运行结果上可以看出输出的结果中前七位是和原数据保持一致，从第八位开始就乱码了，有些人就会问了，这只是整数部分，那小数部分呢？不要着急，看下面。
结果中48965.94是和原数据的前七位是保持一致的，这样就可以证明上面所说的：C语言中，％f表示保留7位有效数字7位有效数字： 是指 整数部分 和小数部分一共7位，有些初学者还会把小数点也算进去，其实这是不对的。
2.在默认情况下以%f格式输出的情况下会输出6位小数，但并不能保证这6位小数有效，即：是否有效还要看整数位和小数位加在一起是否超过7位。
3.另外我们要知道：有效数字的位数与指定输出的小数位数（%.7f）是两码事。%.mf 格式是自己设置需要输出几位小数。
如：
and
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bbfa5477d92dd07c7497e9273735e9f4/" rel="bookmark">
			ex17 更多文件操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、将一个文件的内容复制到另外一个文件中
#这个脚本用于将一个文件的内容拷贝到另外一个文件中 from sys import argv from os.path import exists #exits将文件名字符串作为参数，如果文件存在的话，它将返回 True，否则将返回 False scripts,from_file,to_file = argv print("Coping from %s to %s." %(from_file,to_file)) # We could do this on one line input = open(from_file) #将初始文件from_file打开，内容赋给input变量 indata = input.read() #input变量使用read函数将其内容读取，并赋给新变量indata print("The input file is %d bytes long." %len(indata)) #使用len计算初始文件的字节长度 print("Does the output file exit? %r" %exists(to_file)) #使用exits判断目的文件to_file是否存在，要确保存在这个文件才能将内容写入 print("Ready? hit Enter to continue,hit Ctrl+C to abort.") output = open(to_file,'w') #打开目的文件to_file，并启用写入功能，文件的内容赋给变量output output.write(indata) #将indata的内容写入到output变量中 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bbfa5477d92dd07c7497e9273735e9f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1452bc90cd62df9ae29e7fe9b0505c4/" rel="bookmark">
			odoo12 样式相关库安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pip3 install libsass
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f915cdbb9e1f3196b359e7e27fcfb60/" rel="bookmark">
			Pycharm2018.3.4 永久激活以及解决报错！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		搞了一上午 pycharm的激活码就像个疯子一样，试了网上很多都不行，最后试出一个大神的激活码 ，表示感谢，特此进行转载》
1、下载pycharm 2018.3.4版本 以及 对应的破解码：
https://blog.csdn.net/qq_38752386/article/details/87119426
大神说他的4.2破解码对3.4版本也有效 可惜他给的破解包里面没有4.2版本；
给出对应的3.4破解码：（给出自己的百度云存货吧）
链接：https://pan.baidu.com/s/1OJk94NPJBZzkAgTAnokTKg 提取码：fk1u 复制这段内容后打开百度网盘手机App，操作更方便哦
2、当我搞好之后，重新进入pycharm，发现跳出一个页面显示：Server's certificate is no trusted
百度给出的解决方法也很是有用：https://jingyan.baidu.com/article/a3761b2b13f1871577f9aa41.html
3、所有的都搞好之后，竟然还是显示我的证书过期，只能用30分钟，我试试这个链接：
http://www.cnblogs.com/du-hong/p/9933722.html
去这个链接里找注册码：http://idea.lanyus.com/
我真的很无语，明明已经破解了 且使用期限搞到了2099年：
点击help----about 可以查看该日期；
所以每当进入pycharm时候 提示我什么证书已经过期 ，劳资直接×掉，也是可以用的 ，别被唬住了
PS：
好多激活码都不行，永久激活网上代码很多，这一个是我目前测试出来的，如果你的激活码像我一样怎么都激活不了，那你就关机重启，或者退出重新登录激活码的界面，没准就神奇的好了。
再次感谢博主
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/491d91890c02c866c9a3a9135a5b3c08/" rel="bookmark">
			六、向量的夹角公式及R3中平面的一般形式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 公式 中两个向量的夹角公式：
且规定，当 (向量共线)时:
当(向量垂直)时，
2. 推导过程 向量夹角公式由余弦定理：
推导出
下面为具体的推导：
等号左边又可以展开为：
将展开后的结果代入余弦定理公式：
因此：
推导完毕。
3. 垂直和正交的区别 假如
则 和 正交
如果 和 正交，且 和 都不等于 ，则 和 垂直
总结：所有垂直的向量都正交，正交的向量不一定垂直， 与任何向量（包括 ）正交
4. R3中平面的一般形式 法向量：垂直于平面的向量称为该平面的法向量(normal vector)
假设平面上的一个定点为，平面上的任何其它点为，平面的法向量为：
向量 位于平面上，且与法向量 垂直，因此：
R3中平面的一般形式即：
总结：法向量和平面上的一个定点，可以定义该平面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90297dbf431611b039c591db9db58de6/" rel="bookmark">
			laravel实现发送邮件(腾讯企业邮箱)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.首先你的有个服务器向上能跑的
2.其次就是有腾讯企业邮箱的管理员账号
3.好，确保以上都有就行
//修改laravel的.env文件 MAIL_DRIVER=smtp MAIL_HOST=smtp.exmail.qq.com MAIL_PORT=465 MAIL_USERNAME=cacos@cacov.cn MAIL_PASSWORD=密码 MAIL_ENCRYPTION=ssl //然后创建一个外网可访问的路由 function sendMail(){ Mail::raw('测下10', function ($m) { $m-&gt;from('cacos@cacov.cn', 'Cacos'); $m-&gt;to('123@qq.com')-&gt;subject('我就测一下看能成功不，不成功就选阿里了，你看着办吧'); }); } 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/427/">«</a>
	<span class="pagination__item pagination__item--current">428/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/429/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>