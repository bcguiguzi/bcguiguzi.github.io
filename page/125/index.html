<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04d8e808ef38876d742f61188d32a203/" rel="bookmark">
			JavaScript的json数组去重、删重
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript的json数组去重、删重 JavaScript两个json数组删重(使用map+filter)JavaScript一个json数组去重(使用filter)JavaScript一个json数组去重(使用reduce)JavaScript找出两个Json数组相同的属性和值(使用reduce)JavaScript对象变json数组 JavaScript两个json数组删重(使用map+filter) &lt;template&gt; &lt;div&gt;两个json数组删重&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { mounted() { this.testFn() }, methods: { testFn() { let arr1 = [ { "id": 1, "code": "name", }, { "id": 2, "code": "age" }, { "id": 3, "code": "addr" }, { "id": 4, "code": "other" } ] let arr2 = [ { "id": 1, "code": "name", }, { "id": 2, "code": "age" }, ]; // 调用封装的方法 this.delJson(arr1, arr2, "id"); }, /** * 两个json数组删重 * @param arr1 数组1 * @param arr2 数组2 * @param attrName 通过哪个属性删重 * @return 删重的结果 */ delJson(arr1, arr2, attrName) { let arr = arr2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/04d8e808ef38876d742f61188d32a203/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/261bf6564a18678d45efdfa54d7fe0c4/" rel="bookmark">
			netpate&#43;&#43;常用正则表达式(个人整理)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Notepad++中常用的正则表达式示例：
匹配数字：\d+
该正则表达式可以匹配一个或多个连续的数字。 匹配字母：[a-zA-Z]+
该正则表达式可以匹配一个或多个连续的字母，不区分大小写。 匹配单词：\b\w+\b
该正则表达式可以匹配一个完整的单词，包括字母、数字和下划线。 匹配邮箱地址：\w+@\w+.\w+
该正则表达式可以匹配一个简单的邮箱地址，如abc@example.com。 匹配手机号码：\d{11}
该正则表达式可以匹配一个11位的手机号码。 匹配IP地址：\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}
该正则表达式可以匹配一个IP地址，如192.168.0.1。 匹配日期：\d{4}-\d{2}-\d{2}
该正则表达式可以匹配一个日期，如2023-07-02。 匹配中文字符：[\u4e00-\u9fa5]
该正则表达式可以匹配一个中文字符。 当然还有：
匹配空白字符：\s+
该正则表达式可以匹配一个或多个连续的空白字符，包括空格、制表符、换行等。 匹配非空白字符：\S+
该正则表达式可以匹配一个或多个连续的非空白字符。 匹配任意字符：.
该正则表达式可以匹配任意单个字符，除了换行符。 匹配多个字符：{n}
该正则表达式可以匹配恰好n个连续的前一个字符。 匹配至少n个字符：{n,}
该正则表达式可以匹配至少n个连续的前一个字符。 匹配n到m个字符：{n,m}
该正则表达式可以匹配n到m个连续的前一个字符。 匹配单词边界：\b
该正则表达式可以匹配单词的边界，用于确保匹配整个单词而不是部分单词。 匹配非单词边界：\B
该正则表达式可以匹配非单词的边界。 匹配特定字符集：[xyz]
该正则表达式可以匹配字符集中的任意一个字符，例如[abc]可以匹配a、b或c。 匹配特定字符范围：[a-z]
该正则表达式可以匹配字符范围中的任意一个字符，例如[a-z]可以匹配小写字母。 匹配除特定字符外的任意字符：[^x]
该正则表达式可以匹配除x以外的任意字符。 这些是一些常用的正则表达式示例，可以帮助你在Notepad++中更方便地进行文本搜索和替换。在实际使用时，你可以根据具体需求和文本格式进一步调整和组合这些正则表达式。记得在使用正则表达式时，考虑到可能的边界情况，确保正确地匹配所需的文本内容。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1194eff17cf48501f51e89dd8e3e8543/" rel="bookmark">
			详细解析python视频选择--【思维导图知识范围】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C ,JAVA JAVAWEB ,微信小程序等 都有视频选择的分析。
语言视频选择收录专辑链接C张雪峰推荐选择了计算机专业之后-在大学期间卷起来-【大学生活篇】JAVA黑马B站视频JAVA部分的知识范围、学习步骤详解JAVAWEB黑马B站视频JAVAWEB部分的知识范围、学习步骤详解SpringBootSpringBoot知识范围-学习步骤【思维导图知识范围】微信小程序详细解析黑马微信小程序视频–【思维导图知识范围】python详细解析python视频选择–【思维导图知识范围】phpPHP要怎么学–【思维导图知识范围】 [python 环境与版本–python学习总目录–【万法归宗】]
看时间吧。有空就写主要是python方向也太杂，没理清思路怎么写
文章目录 本系列校训说明学习工具（编辑器）学习资源的选择备选视频备选1：备选2备选3备选4备选5备选6备选7备选8入选视频视频的相关资料 知识点思维导图学习装备续航前十的笔记本电脑 总结资料 本系列校训 用免费公开视频，卷飞培训班哈人！打死不报班，赚钱靠狠干！只要自己有电脑，前后项目都能搞！N年苦学无人问，一朝成名天下知！
说明 python从一个早期险些被废的语言，因为linux 脚本到游戏配置脚本，到爬虫，到图表，然后到目前最火的机器学习。甚至现在的机器学习也跟早期的机器学习也不太相同，现在最多的就是使用显卡的PyTorch。并非一些视频里讲到的numPy。所以，这就出来了一个问题，你不管推荐谁的，都可能被骂的很惨。
不过，也确实有很多的小白，不知道学习的时候怎么啥视频，也不知道怎么看，能跳的时候他也是劲劲的看，应该练的时候，他也是看一遍。有一种有力不知道如何用的感觉。想到这里，还是顶着挨骂的风险写一下吧。
学习工具（编辑器） VSCode
pycharm
下图是我平常使用的2018.2 的版本，主要是这个插件早期的免费版本只支持到2020，一个插件可以用在java,php, python 还是相当的爽的。
颜值插件参见《没有颜值插件的编辑器是没有灵魂的–【idea-theme插件】》
学习资源的选择 第一选择B站。这个没啥毛病了，就是一个字，稳。
曾几何时，大家发现python火了之后，然后，纷纷找python的视频（当时B站还不怎么火，至少我是不知道的），然后有一个人叫“小甲鱼” 的视频就这么传了开来。然后就是B站的各种什么一周会学爬虫。也没图表，更没有机器学习，最多的就是疯狂抓图，抓小说。当然也有人因为这个赚了一大笔，也有人因为这个被封。
现在再看看B站，啥视频没有呀？不过，更多的视频肯定就带来了更多的观众，也就是更多的卷！
python的视频与其它的不同，因为JAVA呀，C呀，这些都太成熟了。所以那肯定就得挑长的漂亮，声音温柔的，错了，重来！
肯定要选择声音标准，清晰，画面高清，看清代码，难度又适中的。
备选视频 备选1： ** 花了2万多买的Python教程全套，现在分享给大家，入门到精通(Python全栈开发教程)
https://www.bilibili.com/video/BV1wD4y1o7AS
有习题入门不错
备选2 **黑马程序员python教程，8天python从入门到精通，学python看这套就够了
https://www.bilibili.com/video/BV1qW4y1a7fU
有图表。pyecharts的。
备选3 黑马程序员Python教程_600集Python从入门到精通教程（懂中文就能学会）
https://www.bilibili.com/video/BV1ex411x7Em
口音不标准。集数太多。
备选4 ** 只要你敢学我就敢发！ 500集Python爬虫教程，从入门到入狱！全程干货无废话，学不会我退出IT界！
https://www.bilibili.com/video/BV1jM4y1j7rb
备选5 **【整整600集】顶级大学196小时讲完的Python教程（数据分析）全程干货无废话！学完变大佬！这还学不会，我退出IT圈！
https://www.bilibili.com/video/BV1rN4y1F7AU
备选6 千锋教育Python数据分析教程_700集零基础Python入门到精通教程（python爬虫+自动化办公+人工智能）
https://www.bilibili.com/video/BV1R7411F7JV
备选7 麻省理工大佬录制了整整一套80节的Python教程却无人问津|淹没在内卷中的隐藏大佬！【高清双语字幕】
https://www.bilibili.com/video/BV1zf4y1Z7zF
备选8 【整整600集】浙江大学196小时讲完的Python教程（数据分析）全程干货无废话！学完变大佬！这还学不会，我退出IT圈！
https://www.bilibili.com/video/BV1xu411L7V3
其它的视频系列，也看过一些。
入选视频 入选视频入选理由备选1：花了2万多买的Python教程全套，现在分享给大家，入门到精通(Python全栈开发教程)女声，讲解很细致，上面的题也不难，很适合基础较差的小白备选2 **黑马程序员python教程，8天python从入门到精通，学python看这套就够了有图表。pyecharts的，只这一点就够了备选5**【整整600集】顶级大学196小时讲完的Python教程（数据分析）全程干货无废话！声音有些小，不过是女生，而且封面女神很漂亮P131之后，有一些机器学习基础包。数据可视化。P160之后有python的数据可视化的部分。备选7 麻省理工大佬录制了整整一套80节的Python教程英语发音特别纯正。好吧，这是我装B说的，其实，我也看不下来。不过，好在有字幕。P63之后，讲算法，big(O) 后面就讲了算法复杂度的问题。P74 讲可视化的问题。后面也有一些专题，讲的也比较开放。很特别，对于想学习python机器学习，想发文章的人来说，这个视频其实是利器。 这个就是备选5的老师与学生，算5星推荐，不过份吧？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1194eff17cf48501f51e89dd8e3e8543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce95c5d8b771015a6b86e3023fd2b9e9/" rel="bookmark">
			等待已久，新品上市 | RevPi Connect 4系列：基于树莓派CM4计算模块的全新工业树莓派
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		新品来袭 势不可挡 备受期待的虹科工业树莓派第四代产品—RevPi Connect 4终于来啦！作为全球领先的工业自动化产品，RevPi Connect 4融合了工业树莓派多年技术积累与创新突破，以及现代物联网技术的结晶。无论您是行业领先者、工程师还是智能科技爱好者，RevPi Connect 4都将为您带来前所未有的惊喜。
RevPi Connect 4系列是虹科工业树莓派第一款基于树莓派计算模块 4 (CM4) 的产品。与之前的版本一样，RevPi Connect 4系列采用模块化设计，具有工业适用性。工业树莓派开源的设计理念结合其集成多功能接口的特点，让该设备适用于各类工业应用，可以作为纯工业 PC、工业控制器、边缘设备或 IIoT 网关。根据不同的应用场景，RevPi Connect 4系列还可以作为具有不同设备功能的多个产品变体。
全面升级 性能更强 相较于之前的系列，RevPi Connect 4系列在硬件和软件方面均做了全面升级，亮点如下：
处理器
使用性能更好的 Broadcom BCM2711 处理器，这是一款 64 位四核 ARM Cortex-A72 处理器RAM
运行内存最高支持8 GB，极大提高了工作性能。作为存储介质，eMMC 内存最高支持 32 GB以太网接口
升级为两个千兆以太网接口，可提高数据传输速度并减少网络延迟USB A接口
升级为两个 USB 3.2 Gen1 接口，支持高达 5 Gbit/s 的传输速度，可用于具有运动检测功能的摄像机等应用实时时钟（RTC）
RTC供电方式取消超级电容供电的方式，而是采用集成电池进行供电WiFi&amp;蓝牙
新增WiFi和蓝牙功能，可通过内置天线连接 WLAN 和蓝牙，或通过SMA 接口外置天线实现更好的接收HAT EEPROM
用于存储设备信息（如产品类型、序列号和MAC地址）扩展端口
可通过即插即用方式将 10 个 I/O 扩展模块连接到基础模块上，以往系列只可连接5个I/O扩展模块操作系统
首次提供并采用定制化 64 位 Raspberry Pi 操作系统，其中包括实时补丁和进程映像等 承袭经典 续写智能 除了以上提到的升级之外，考虑到老用户的使用习惯，RevPi Connect 4系列在设计过程中保留了优秀的功能应用：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ce95c5d8b771015a6b86e3023fd2b9e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/386bd4bf47d23844706443bf310dcbbe/" rel="bookmark">
			服务器运行python程序的使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器的使用与说明 文章目录 服务器的使用与说明1.登录2.Python的使用2.1 服务器已安装python32.2 往自己的用户目录安装python31.首先下载安装包2.解压缩3.编译与安装 2.3 新建环境变量2.4 测试 3 创建PBS作业并提交 1.登录 windows+r打开运行命令窗口，在运行框中输入cmd打开cmd窗口
然后输入命令：ssh 用户名@IP
例如：
ssh bob@200.289.130.11 用户名是登陆服务器的账号，IP是服务器的IP地址，随后根据提示输入账号密码登陆到服务器的用户目录.
2.Python的使用 一般服务器自带的Python版本为2.X版本，这大概率无法满足我们的正常需求。若服务器安装了python3，则在服务器上使用python有两种方法。如果你需要用到python不自带的python包，建议使用第二种方法（2.2）
2.1 服务器已安装python3 在登陆节点输入命令
source python3的目录 例如
source /public/software/python3 这取决于服务器安装python3的位置以及环境变量的放置位置.具体目录请咨询管理员.
若需要使用cuda或其他程序（前提是服务器已安装），以同样的方法使用即可.
2.2 往自己的用户目录安装python3 这个比较复杂，请一步一步慢慢来.
1.首先下载安装包 (在用户目录操作，无需权限)
wget https://www.python.org/ftp/python/3.10.6/Python-3.10.6.tgz 注意：关于python的版本请自行考虑，3.10.6是版本号
2.解压缩 tar -xvf Python-3.10.6.tgz 你的用户目录下此时多了两个东西，一个是Python-3.10.6.tgz，一个是Python-3.10.6。
请用命令查看
cd ~ #确保你的路径在用户目录 ls -a 3.编译与安装 进入Python-3.10.6，先创建编译环境，由于权限不够，我们将python安装在用户目录下.
新建文件夹python3，此后所用到的python包都会安装在此文件夹
mkdir python3 cd Python-3.10.6 ./configure --prefix=~/python3#若此代码报错请将其换成绝对路径 make &amp; make install 等着就好了，等它自己安装完成.
注意，编译中绝对路径的查看方式
cd ~ pwd 将屏幕显示的路径更换./configure --prefix= ~/python3中的 “~”
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/386bd4bf47d23844706443bf310dcbbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab122de9299447def540b9593a5545db/" rel="bookmark">
			【枚举&#43;结论】icpc2022 济南 A
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Problem - A - Codeforces
题意：
思路：
本来的思路是这样的
考虑最后会变成什么数，手摸了几个发现，都是2，不论本来的集合是不是包含2
然后就是猜测是不是直接变成2就好了
然后要去掉m个，直接考虑去掉最大的m个
这样是wa2的
然后考虑去枚举最后变成什么数，猜测最后会变成集合中本来有的数，也wa2了
首先第一个，最后变成的数，一定是集合中某个数/2之后的值，这点需要观察到
然后，需要把贡献算出来之后再去排序，去掉排序后的m个大的，这里也有点问题，应该把贡献算出来了之后再去排序
其实错误的思路都有个共同点，就是猜了结论之后没有去想为什么，在想为什么的过程其实就是pushup归纳的过程
Code：
#include &lt;bits/stdc++.h&gt; #define int long long using namespace std; const int mxn=3e3+10; const int mxe=5e5+10; int N,M; int a[mxn]; int calc(int u,int k){ //u变成k的最少操作次数 if(u&lt;=k) return k-u; else{ int tu=u; int cnt=0; while(tu/2&gt;=k){ cnt++; tu/=2; } int tmp=cnt+tu-k; if(tu&gt;0){ tu/=2; tmp=min(tmp,cnt+1+k-tu); } return tmp; } } void solve(){ cin&gt;&gt;N&gt;&gt;M; set&lt;int&gt; S; for(int i=1;i&lt;=N;i++){ cin&gt;&gt;a[i]; int x=a[i]; while(x){ S.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab122de9299447def540b9593a5545db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0036681302e3c97786ca9f705b7daf53/" rel="bookmark">
			【Java设计模式003】原型模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 原型模式解决的主要问题是如何快速的复制一个已经存在的对象，一个普遍的做法是构建一个属于相同类的对象，然后遍历原始对象的所有属性值并复制到新对象中。这样的做法有一些问题，不是每一个对象都可以通过这种方式进行复制，且这么做的编程代价过高，比方说：
class Main{ public static void main(String[] args) { Sheep sheep = new Sheep("tom", 1, "red"); new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor()); } } 这样做比较好理解，简单易于操作，但是复制对象的效率很低（现在只有三个参数需要处理）。而原型模式就可以解决这个问题，原型模式是用于创建重复的对象，同时又能保证性能的一种模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
原型模式的角色如下：
抽象原型类：规定了具体原型对象必须实现的 clone() 方法，一般也只有这么一个方法。具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。访问类：使用具体原型类中的 clone() 方法来复制新的对象。 原型模式的优点在于：
你可以克隆对象，而无需与它们所属的具体类相耦合；你可以克隆预生成原型，避免反复运行初始化代码；你可以更方便地生成复杂对象；你可以用继承以外的方式来处理复杂对象的不同配置； 原型模式的缺点在于：
克隆包含循环引用的复杂对象可能会非常麻烦。 实现 原型模式的克隆分为浅克隆和深克隆：
浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。
Java 中的 Object类提供了 clone() 方法，该方法实现了浅克隆，在 Java 中 Cloneable 接口就是原型模式中的抽象原型类，而任何实现了 Cloneable 接口的类就是具体原型类，代码如下：
public class Realizetype implements Cloneable { public Realizetype() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0036681302e3c97786ca9f705b7daf53/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/911fbb239e35afbb81469e5eae52d4d1/" rel="bookmark">
			手把手教你在云环境炼丹（部署Stable Diffusion WebUI）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天写了一篇《手把手教你在本机安装Stable Diffusion秋叶整合包》的文章，有些同学反映对硬件的要求太高，显卡太TM贵了。今天我再分享一个云服务器炼丹的方法，方便大家快速入门上手，这个云服务不需要特殊网络设置，能连接公网网盘，随开随用，有3090显卡，也有4090显卡，不过我经常使用的是A5000显卡。本文非广告推广，只分享使用方法，不喜跳过。
闲话不多说，下面就正式开始了。
注册登陆 注册方式一
手机号直接注册，打开这个链接：www.autodl.com/register，很简单就不多说了。
注册方式二
为什么还有两种方式？测试的时候发现验证码发不出去，官方说这两天验证码通道有点问题，有时发不出去。具体原因就不知道了，做个备选吧。
在它的登陆页面，点击“微信登陆”按钮，用微信扫一扫，在微信打开的页面中，点击“关注公众号”，关注成功后，AutoDL的网页会自动跳转，要求绑定手机号，这个验证码却能收到，感觉有点奇怪。
开服务器 注册成功之后，就可以登录了，登陆成功之后会进入一个管理界面。
之前听说注册用户还送10块钱，现在应该没有了，现在是会送30天的炼丹会员，单价上有些折扣，正常情况下这个折扣需要消费达到500元才会有。
没有钱就开不了服务器，所以我们要先充点钱进去。
充值 鼠标划到管理界面右上角的这个账户名称上，在弹出的窗口中点击“充值”。
在“充值”页面中，选择“其它金额”，我这里充值5块，你可以试试更小的金额能不能开机。每次少冲点也可以避免忘了关机导致被扣钱心疼的问题。
付款方式按照自己的情况选择就行了，具体支付流程大家都应该很熟练了，这里就不演示了。
租用实例 在管理界面的右上角点击“控制台”。
然后在左侧菜单中点击“容器实例”，在打开的页面中点击“租用新实例”。
在“创建实例”的页面，按照下图的顺序设置。
计费方式：一开始体验选择“按量计费”就可以了。选择地区：大家都推荐内蒙A区，据说网络比较稳定，我也一直用这个。GPU型号：A5000每小时 1.18，实测性能也可以。GPU数量：先选择1个，后边熟练了再根据实际情况来。选择主机：GPU型号和数量选择后，这里就会列出可用的主机，先随便选一个就行了。 下边还有一些设置。
数据盘：的免费容量是50G，如果不够需要花钱扩容，一般50G也够了。
镜像：首先选择“社区镜像”，然后在输入框中输入“yinghuoai”，会自动弹出一个镜像，选中它就行了。这个镜像是我专门修改过的，后续也会不断优化升级，大家有问题向我反馈就行。当然也可以用别的镜像，不过后边启动SD WebUI的步骤可能有些不同，建议先按照我这个步骤跑一遍再说。
最后点击“立即创建”。
启动 现在服务器实例已经启动起来了，我们还需要2步来启动 Stable Diffusion WebUI。
本机启动 点击“快捷工具”这一列中的“JupyterLab”，如下图所示：
上边的操作会在浏览器中打开一个新的页面，JupyterLab的页面。JupyterLab 是一个Web应用程序，可以管理文件、记点东西、运行程序，功能类似于VSCode。
参照下图，执行以下2个步骤：
在页面左侧的文件管理器中双击“启动器.ipynb”；在页面右侧打开的页签中点击红框中的启动按钮。 首次启动要下载一些模型，会有点慢，大概2-3分钟。后边再启动就会跳过这些下载步骤，达到秒级。
看到下图的“Running on local URL”和“Model loaded in” 就说明启动成功了。
其中的“http://127.0.0.1:6006”就是SD WebUI的访问地址，不过这个地址只能本机访问，而这个云服务器本质上只是个容器实例，没有桌面环境，也没有浏览器可以用。当然这个问题可以解决，请继续看下文。
映射到外网 回到容器实例列表，找到刚才启动的实例，在“快捷工具”中点击“自定义服务”，如下图所示：
如果第一次使用自定义服务，它会弹出一个身份认证的提示。因为AutoDL会把SD WebUI的本机访问地址映射到外网，大家可能都听说过网站备案这件事，这里AutoDL给大家提供的外网地址用的是AutoDL自己备案过的域名的子域名，所以AutoDL要承担一定的风险，出了问题的时候它得能找到人，所以需要身份认证。
按照提示操作就行了，这里我使用个人认证进行演示。
输入姓名和身份证号，注意一个身份证只能在AutoDL上认证一次，多个账号就得用不同的身份证号来认证。
只要姓名和身份证号能对上，上边的认证就通过了。
我们再次点击“自定义服务”，这时候会弹出一个警告，意思就是不要乱搞，乱搞必被罚。我们都是好人，勾选同意服务协议，然后点击“访问”。
然后AutoDL就会在浏览器中打开一个新的页签，稍等片刻，期待已久的 SD WebUI 页面就展示出来了。
出图 为了方便大家绘画，这个镜像自带两个大模型，一个二次元，一个真实视觉。
这里以二次元模型为例，演示如何生成图片。
1、选择大模型，这里是默认的二次元模型 AnythingV5。
2、提示词，先来个简单的：a girl。
3、反向提示词：EasyNegative，这是一个嵌入式模型的代号，揉合了一些常见的反向提示词。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/911fbb239e35afbb81469e5eae52d4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6b270d59cb832b5ee6e7ced6659da3e/" rel="bookmark">
			Vue3的runtime-core模块的原理讲解及功能解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vue3的runtime-core的原理讲解及功能解读 基本原理 runtime-core是Vue 3的运行时核心，负责实现组件渲染、虚拟节点管理、渲染函数、辅助函数和工具等功能。下面是对runtime-core的整体源代码进行详细的分析：
component组件 组件渲染和更新：，component在runtime-core中的核心功能是处理组件的渲染和更新。它定义了ComponentInternalInstance类，该类表示组件实例，包含了组件的状态、属性、生命周期钩子等。并提供了一些辅助函数和工具，如createComponentInstance，用于创建组件的实例对象，setupComponent，用于设置组件实例，初始化组件的状态和调用 setup 函数。还有renderComponentRoot函数用于渲染组件的根节点。
Vnode虚拟节点 虚拟节点：runtime-core实现了虚拟节点（VNode）的相关逻辑。VNode表示组件树中的一个节点，它具有类型、标记、子节点、属性等信息。其中vnode.ts 定义了 VNode 类，表示组件树中的一个节点，包含节点的类型、标记、子节点、属性等信息。createVNode函数提供了创建 VNode 的功能，用于创建虚拟节点。normalizeVNode函数包含了规范化虚拟节点功能，用于将不同类型的节点转换为规范的 VNode 对象。
rederer渲染机制 渲染函数：runtime-core模块中定义了用于渲染组件和生成VNode的渲染函数。这些渲染函数包括render和ssrRender，它们接收组件实例和上下文参数，并返回渲染后的VNode。renderer.ts 定义了 RendererOptions 接口，包含了渲染器的配置选项。rendererElement接口定义了渲染器的元素类型，如 DOM 元素、SVG 元素等。rendererNode接口定义了渲染器的节点类型，如 DOM 节点、文本节点等。rendererInternals接口定义了渲染器的内部函数和工具，如节点创建、插入、移除等操作。renderer.ts 定义了渲染函数 render 和 ssrRender的规范，接收组件实例和上下文参数，并返回渲染后的 VNode。
helpers辅助函数和工具 辅助函数和工具：runtime-core包含了许多辅助函数和工具，用于支持组件渲染和功能实现。这些函数包括处理插槽的createSlots、处理列表渲染的renderList、处理插槽渲染的renderSlot、解析资源的resolveAssets、处理事件的toHandlers等。
helpers 目录：包含一些辅助函数和工具的代码。其中，createSlots.ts 提供了处理插槽的辅助函数 createSlots，用于创建动态插槽对象。renderList.ts 提供了处理列表渲染的辅助函数 renderList，用于将数组、对象等转换为 VNode 数组。renderSlot.ts 提供了处理插槽渲染的辅助函数 renderSlot，用于渲染具名插槽。resolveAssets.ts 提供了解析组件、指令和过滤器等资源的辅助函数。toHandlers.ts 提供了将事件处理函数转换为处理器对象的辅助函数 toHandlers。useSsrContext.ts 提供了处理服务器渲染上下文的辅助函数 useSSRContext。
其他功能 其他功能：除了以上功能外，runtime-core还实现了一些其他功能，如处理指令、过滤器和服务器渲染等。它定义了处理指令的Directive类和相关函数，如resolveDirective。还定义了处理过滤器的函数resolveFilter。另外，runtime-core还提供了处理服务器渲染上下文的函数useSSRContext。directives.ts包含了处理指令的相关代码，如 v-model、v-show 等。warning.ts 提供了警告信息的打印函数 warn。
component的原理解读 component.ts 文件包含了与组件相关的源代码，定义了组件的创建、渲染、更新等功能。让我们深入了解 component.ts 的具体功能、原理、应用场景以及进行代码剖析。
功能： 提供了组件的创建方法，用于定义和注册组件，并生成组件的实例。实现了组件的渲染方法，将组件的模板转换为虚拟节点并进行渲染。实现了组件的更新机制，当组件的状态发生变化时，重新渲染组件并更新视图。定义了组件的生命周期钩子函数，用于在组件的不同生命周期阶段执行相应的逻辑。 原理： 组件的原理是将应用的用户界面拆分成独立的、可复用的模块，每个模块都有自己的状态和视图。在 Vue 中，组件是基于虚拟节点（VNode）的数据结构来构建和渲染的。组件的创建包括定义组件的选项和配置，并生成组件的实例。组件的渲染通过将组件的模板转换为虚拟节点，并通过渲染器将虚拟节点转换为真实 DOM 进行渲染。组件的更新通过比对新旧虚拟节点的差异，实现高效的视图更新。
应用场景： 组件是 Vue 应用的基本单元，用于构建复杂的用户界面。它具有以下应用场景：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d6b270d59cb832b5ee6e7ced6659da3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da300922913c4f12a7c52ef9ba02bfad/" rel="bookmark">
			Python&#43;OpenCV实现自动扫雷，挑战扫雷世界记录！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
准备
- 扫雷软件
实现思路
- 01 窗体截取
- 02 雷块分割
- 03 雷块识别
- 04 扫雷算法实现
福利：文末有Python全套资料哦 我们一起来玩扫雷吧。用Python+OpenCV实现了自动扫雷，突破世界记录，我们先来看一下效果吧。
中级 - 0.74秒 3BV/S=60.81
相信许多人很早就知道有扫雷这么一款经典的游（显卡测试）戏（软件），更是有不少人曾听说过中国雷圣，也是中国扫雷第一、世界综合排名第二的郭蔚嘉的顶顶大名。扫雷作为一款在Windows9x时代就已经诞生的经典游戏，从过去到现在依然都有着它独特的魅力：快节奏高精准的鼠标操作要求、快速的反应能力、刷新纪录的快感，这些都是扫雷给雷友们带来的、只属于扫雷的独一无二的兴奋点。
准备 准备动手制作一套扫雷自动化软件之前，你需要准备如下一些工具/软件/环境
- 开发环境
Python3 环境 - 推荐3.6或者以上 [更加推荐Anaconda3，以下很多依赖库无需安装]
numpy依赖库 [如有Anaconda则无需安装]
PIL依赖库 [如有Anaconda则无需安装]
opencv-python
win32gui、win32api依赖库
支持Python的IDE [可选，如果你能忍受用文本编辑器写程序也可以]
- 扫雷软件 · Minesweeper Arbiter 下载地址（必须使用MS-Arbiter来进行扫雷！）
好啦，那么我们的准备工作已经全部完成了！让我们开始吧~ 实现思路 在去做一件事情之前最重要的是什么？是将要做的这件事情在心中搭建一个步骤框架。只有这样，才能保证在去做这件事的过程中，尽可能的做到深思熟虑，使得最终有个好的结果。我们写程序也要尽可能做到在正式开始开发之前，在心中有个大致的思路。
对于本项目而言，大致的开发过程是这样的：
完成窗体内容截取部分
完成雷块分割部分
完成雷块类型识别部分
完成扫雷算法
好啦，既然我们有了个思路，那就撸起袖子大力干！
- 01 窗体截取 其实对于本项目而言，窗体截取是一个逻辑上简单，实现起来却相当麻烦的部分，而且还是必不可少的部分。我们通过Spy++得到了以下两点信息：
class_name = "TMain" title_name = "Minesweeper Arbiter " ms_arbiter.exe的主窗体类别为"TMain" ms_arbiter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da300922913c4f12a7c52ef9ba02bfad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3dc73f1405b3f3d6ea3b400969e663d6/" rel="bookmark">
			B树与B&#43;树的区别是什么？ InnoDB和MyISAM的区别是什么？ MySQL索引优化、索引失效？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、索引1、MySQL常见的四种索引类型：2、四种索引的特点比较：1）哈希索引2）B-Tree索引3）RTREE索引4）全文索引 3、为什么MySQL选择B+树做索引4、索引失效5、InnoDB和MyISAM是B+树，有什么区别？1）MyISAM索引结构（非聚集索引）2）InnoDB聚簇索引： 二、索引及索引优化 一、索引 使用索引是数据库性能优化的必备技能之一。
1、MySQL常见的四种索引类型： InnoDB和MyISAM是B-Tree索引，只有Memory/Heap引擎支持Hash索引。
索引InnoDB引擎MyISAM引擎Memory引擎B-Tree索引支持支持支持HASH索引不支持不支持支持R-Tree索引不支持支持不支持Full-text索引5.6版本后支持支持不支持 2、四种索引的特点比较： 1）哈希索引 哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。不可避免地，多个 key 值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。
优点：速度会很快，只需要往后追加。
缺点：
1）Hash 索引仅仅能满足"=",“IN"和”&lt;=&gt;"查询，不能使用范围查询，无法被用来避免数据的排序操作。
由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样，所以数据库无法利用索引的数据来避免任何排序运算； 也就是因为不是有序的，所以哈希索引做区间查询的速度是很慢的，比如 Memcached 及其他一些 NoSQL 引擎。
（3）Hash 索引不能利用部分索引键查询。
对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
（4）Hash 索引在任何时候都不能避免表扫描。
前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3dc73f1405b3f3d6ea3b400969e663d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e66ce45a45cc7e1222cbe18e2124486/" rel="bookmark">
			Python小红书旋转验证码识别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本周免费接了一个用户的需求，研究了一下小红书旋转验证码。刚开始小瞧了它，觉得它应该没有百度旋转验证码那么难，毕竟图像没有干扰，需要的训练样本就可以很少。然而事情并没有这么简单，所以记录一下。
首先看一下最终的效果：
验证码识别过程 1、利用爬虫采集图像 这里最好大小图都采集，刚开始我就只采集了小图，就踩了一个坑，因为只有小图很难通过小图旋转到正确位置。并不能通过眼睛等特征来确定是否选择正了，因为有很多图片本身头的歪的。所以就会导致最终识别结果偏差较大。
（1）采集大图 （2）采集小图 2、人工标记 为了保证旋转到正确的角度，我还专门开发了一个标记小工具如下图。
可以通过拖动滑块旋转小图到大概位置，再通过点击按钮进行微调，旋转到绝对正确的角度。
这样能保证我标记的图片角度100%正确，只有提升了标记数据的质量，才会让最终识别的效果达到最好。
3、训练模型 4、测试验证 我们将训练好的模型用100张图片来进行测试，发现只有4张图片旋转角度有问题，所以最终模型的实际正确率为96%。
如果再想提升正确率，可以再增加训练的数据量，就需要再投入大量人力，这个投入与提升产出比需要自己权衡。
5、实战测试 这里我就直接上代码，就是文章开通动图的演示效果。我也将模型封装成了免费的接口给感兴趣的小伙伴调用：得塔云
__author__ = 'Xin Yan Deng' import os import sys import time import requests import random import base64 from io import BytesIO from PIL import Image sys.path.append(os.path.abspath(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))) from selenium import webdriver from selenium.webdriver.support.wait import WebDriverWait from selenium.webdriver.common.action_chains import ActionChains # PIL图片保存为base64编码 def PIL_base64(img, coding='utf-8'): img_format = img.format if img_format == None: img_format = 'JPEG' format_str = 'JPEG' if 'png' == img_format.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e66ce45a45cc7e1222cbe18e2124486/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7689758d4052290d23562061f158b841/" rel="bookmark">
			Mybatis in 条件传参三种实现方法（直接$，List，[]）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种方法：in 条件为拼接好的字符串
如果直接传入拼接好的where in 条件， 比如（‘111’,‘222’,‘333’)，则需要使用${idlist}传参，即绝对引用，而不能使用#
, 如果使用#传参会被mybatis当成字符串再添加一层’'引号，导致错误.
优点：简单方便，高效，缺点：不能防止SQL注入
第二种方法：in 条件为List对象
in条件直接传入List对象，让mybatis再去拼接生成in条件，这个很麻烦,但是可以防止SQL注入
第三种方法：in 条件为String[] 数组
in条件直接传入[]数组对象，让mybatis再去拼接生成in条件，这个很麻烦,但是可以防止SQL注入
如果项目大，其实可以同时重载三种都实现，我一般都会这样，实现三种DAO接口，service层相同方法名，根据不同的模块不同的需求调用不同的实现层
Service:
int deleteMenuByIdList(String idlist,int delcount,int lastsort); int deleteMenuByIdList(List&lt;String&gt; idlist, int delcount,int lastsort); int deleteMenuByIdList(String[] idlist, int delcount,int lastsort); Dao:
//用这种写法方便，idlist直接拼接好，xml中用 in ${idlist}接受参数 int deleteMenuByIdList(@Param("idlist")String idlist, @Param("delcount")int delcount, @Param("lastsort")int lastsort); //用这种写法直接传List对象，xml中再写循环拼接，麻烦 int deleteMenuByIdList2(@Param("idlist")List&lt;String&gt; idlist, @Param("delcount")int delcount, @Param("lastsort")int lastsort); //用这种写法直接传String[]数组，xml中再写循环拼接，麻烦 int deleteMenuByIdList3(@Param("idlist")String[] idlist, @Param("delcount")int delcount, @Param("lastsort")int lastsort); （2，3）的xml文件中不需要做修改，只需要修改一下id对应到DAO的方法名即可。
mappper.xml
1， &lt;delete id="deleteMenuByIdList" &gt; delete from s_menu where menu_id in ${idlist}; update s_menu set sort=sort-#{delcount} where sort &gt;= #{lastsort} and menu_id not in ${idlist}; &lt;/delete&gt; 2， &lt;delete id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7689758d4052290d23562061f158b841/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6e06df78b68988e599408b0f19d499fa/" rel="bookmark">
			青龙面板教程(六)：本地动态网络代理搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 近段时间在青龙面板上使用代理，但网上代理商类型基本是数据中心型，效果跟本机直接请求没什么区别。手头正好有一部闲置的手机，因此尝试在手机上搭建一个代理服务器，这样网络请求的IP就由手机来决定了。
注：青龙面板APP已提供本地代理拓展模块，在移动端即可轻松配置动态代理。
二.正文 1.配置要求 一台公网服务器；一台闲置的手机； 2.原理介绍 从上图可以看出，应用通过设置代理发起网络请求，服务器将该网络请求转发给客户端，客户端再将网络请求转发给目标服务器，这样目标服务器收到网络请求的IP就成了客户端的IP，通过改变客户端的IP就可以实现动态IP代理的目的了，而改变手机的IP是一件非常容易的事情。
为了实现上述功能，需要用到内网穿透和代理搭建技术。公网服务器是无法直接连接到手机的，需要手机主动去连接服务器，而后服务器才能再将网络请求转发给手机，利用Frp和TinyProxy便可实现。当然你也可以使用其他工具也实现这两个功能，可自行查找相关资料。
3.服务端配置 如果你有相关的网络编程基础可以手动去下载Frp并配置启动，这里为了方便已经将Frp服务打包成docker容器，一键安装即可：
docker run -dit \ --name frps \ --hostname frps \ -p 10000:7000 \ -p 10001:7002 \ --restart unless-stopped \ wsfsp4/frps-amd64:v1 上面安装容器用到了2个端口映射，说明如下表： 主机端口容器端口备注100007000 客户端连接端口，可以按需修改主机端口，并在主机防火墙中将该端口开放
100017002代理服务端口，可以按需修改主机端口，建议不要将该端口对外开放 进入容器/frp目录，打开frps.ini文件 ，你可以按需修改token字段（客户端验证密钥），其他字段如果你不清楚其作用就不要修改：
[common] # 绑定地址 bind_addr = 0.0.0.0 # 绑定端口 bind_port = 7000 # 授权码 token = frp@123456 # 日志文件 log_file = ./frps.log # 日志等级:trace, debug, info, warn, error log_level = warn # 日志保留天数 log_max_days = 2 进入容器终端,执行以下命令启动服务端：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6e06df78b68988e599408b0f19d499fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81884a105552db39810da5ddf4c27301/" rel="bookmark">
			web自动化测试，定位不到元素的原因及解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.动态id定位不到元素
分析原因：每次打开页面，ID都会变化。用ID去找元素，每次刷新页面ID都会发生变化。
解决方案：推荐使用xpath的相对路径方法或者cssSelector查找到该元素。
2.iframe原因定位不到元素
分析原因：你要找的元素在某个框架（frame）里面
解决方案：跳转到该框架里，再查找元素。　driver.switchTo().frame("login_frame"); driver.switchTo().frame(driver.findElement(By.cssSelector("iframe[frameborder='0']"))); driver.switchTo().frame(driver.findElement(By.tagName("iframe")); 3.要返回到某frame外找元素
分析原因：当你进入某个框架，找到某元素。接下来又想找一个框架外的元素的时候，需要跳出该框架再找元素。
解决方案：执行下面这句代码，pareneFrame是父类，从当前框架跳转到父类的框架里。
driver.switchTo().parentFrame(); 4.不在同一个frame里边查找元素
分析原因：页面左边一栏属于left_frame，右侧属于right_frame的情况，此时如果当前处在left_frame，就无法通过id定位到right_frame的元素
解决方案：通过以下语句切换到默认的content：
driver.switchTo().defaultContent(); 5. xpath描述错误
分析原因：描述路径的时候没有按照xpath的规则来写 造成找不到元素的情况出现
解决方案：修改路径写法，或者用其他方式，个人最推荐css。
6.页面元素未加载完
分析原因：在找元素前，页面还没加载好，所以那些元素都不存在。
解决方案：等待时间。有三种方式(强制等待，隐式等待，智能等待）
Thread.sleep(5000); //强制等待5000毫秒
7.元素隐藏起来了
分析原因：窗口在不是最大化的情况下，前端页面元素只会显示局部，所以找不到啊。
解决方案：在找元素前，执行一句，浏览器最大化窗口，这样隐藏的元素就会全部出现了。最好写在beforetest里。
driver.manage().window().maximize(); 8.firefox安全性强，不允许跨域调用出现报错
分析原因：它的错误描述为uncaught exception: [Exception... "Component returned failure code: 0x80004005 (NS_ERROR_FAILURE) [nsIDOMNSHTMLDocument.execCommand]" nsresult: "0x80004005 (NS_ERROR_FAILURE)" location:
解决方案：Firefox 要取消XMLHttpRequest的跨域限制。
第一是从 about:config 里设置
signed.applets.codebase_principal_support = true； （地址栏输入about:config 即可进行firefox设置）
第二就是在open的代码函数前加入类似如下的代码：
try { netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead"); } catch (e) { alert("Permission UniversalBrowserRead denied."); } 总结： 感谢每一个认真阅读我文章的人！！！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81884a105552db39810da5ddf4c27301/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbf32fa6646abc367def1418e5f26531/" rel="bookmark">
			华为OD机试真题2022Q4 A &#43; 2023 B卷（Java）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是哪吒。
五月份之前，如果你参加华为OD机试，收到的应该是2022Q4或2023Q1，这两个都是A卷题。
5月10日之后，很多小伙伴收到的是B卷，那么恭喜你看到本文了，抓紧刷题吧。B卷新题库正在更新中。
华为机试有三道题，第一道和第二道属于简单题，分值为100分，第三道为困难题，分值为200分，总分400分，150分钟考试时间。
华为的考试平台是牛客网，大家可以提前去牛客网找到华为机考门槛进行练习，主要是熟悉平台操作练习一下怎么处理输入输出哈！后面我也分享了很多牛客网上的华为OD试题。
华为机考的分数是按照测试用例通过的比例来确定的，比如第一题满分100，如果你提交代码后显示测试用例通过率为80%，那么这道题你就只能得80分，所以其实成绩你在考试的时候就心知肚明了！
150分是华为统一的通过分数线。但各部门的要求又不一样，通常非目标院校的分数要求更高些。300+是高分，260+是较为安全的分数。总之分数越高越高，对后续的定级、综面、HR审批都有益处。
一般来说对接你的HR会问你啥时候可以笔试，你觉得准备的ok了就会发你一个机考链接，这个机考链接的有效期为7天，你在这七天时间内找个时间参加考试即可！华为OD机考会影响薪资的，300分以上和300分一下的价格是不一样的，所以我建议大家好好准备争取超过300分，能拿高分就拿高分。
机试没考过的话，会有半年的冷冻期。
为什么我说华为机考并不难，原因很简单，因为这个考试是有题库的！你在进入机考页面的时候网页上会显示正在组卷中，其实就是去题库里找两个简单题一道复杂题。既然这是一场有题库的考试，那我们最重要的当然是获取最全面的题库对吧，这个大家放心我已经帮大家整理好了，未来也会持续更新！
我觉得准备机考前的第一件事是选择一门合适的编程语言，华为机考对编程语言是没有限定的，你可以选择自己最喜欢的编程语言。考虑到大部分华为OD的应聘者都是技术基础较为薄弱甚至非科班的同学，我还是满建议大家使用Java来应付机考还有后面的手撕代码的，当然如果你会JS、Python、C++的话也可以用来考试。
如果基于我提供的题库开始认认真真刷题，不开玩笑的说遇到原题是肯定的，正常情况下遇到两道原题是不难的，很多同学是直接三题全部命中！因为华为题库三个月会更新一部分新题进来，所以大家尽量不要在新题刚刚更新的时候去做，建议在新题发布一个月后再考我感觉命中两道很正常的！
下面，哪吒将华为OD机试真题归归类，让大家一目而了然。
关于订阅华为OD机试真题的后续问题
订阅专栏后，专栏内的文章都可看，以后还会继续更新新题；每道题都包含题目、解题思路、代码详解（关键行包含详细注释）、代码运行截图（保证代码100%正确，通过率100%）；已经订阅的小伙伴，推荐新人订阅可享 8 折优惠，私信我即可； 在考试的时候，最好不要用CSDN专栏里的源码去答题，因为华为OD机试是有查重的，这个一定要注意！最好是改一改变量名称，加一加注释，改一改逻辑顺序，掌握答题思路才是关键，下面的题中我都加了详细的答题思路，代码中也有详细的注释说明，代码运行是100%正确无误的，每一题都有样例测试，全网独一份。
如果你刚刚参加完机试考试，欢迎提供真题到哪吒这里，直接红包转账收题。
很多考过的小伙伴，总结了宝贵的经验，多刷题，先易后难，前期积累自信，后期逐一突破，效果最佳。
下面从最新题开始分享、按时间倒序、按难以程度正序排序，做到刷题的循序渐进。
2023 5月 B卷 “新加题”（100分值） 1、华为OD机试真题 Java 实现【路灯照明问题】【2022Q4 100分】，感谢fly晨发现这个问题，并提供更优质的算法
2、华为OD机试真题 Java 实现【跳房子II】【2023 B卷 100分】，附详细解题思路
3、华为OD机试真题 Java 实现【二维伞的雨滴效应】【2023 B卷 100分】，附详细解题思路
4、华为OD机试真题 Java 实现【异常的打卡记录】【2023Q1 100分】
5、华为OD机试真题 Java 实现【文件目录大小】【2023 B卷 100分】，附详细解题思路
6、华为OD机试真题 Java 实现【数字游戏】【2023 B卷 100分】，附详细解题思路
7、华为OD机试真题 Java 实现【告警抑制】【2023 B卷 100分】，附详细解题思路
8、华为OD机试真题 Java 实现【最多获得的短信条数】【2023Q1 100分】，附详细解题思路
9、华为OD机试真题 Java 实现【数据分类】【2023 B卷 100分】，附详细解题思路
10、华为OD机试真题 Java 实现【字符串摘要】【2023 B卷 100分】，附详细解题思路
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbf32fa6646abc367def1418e5f26531/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7489b1ef986b17dbf66749743c7bc9e2/" rel="bookmark">
			Python数据分析入门笔记9——数据预处理案例综合练习（男篮女篮运动员）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 Python数据分析入门笔记1——学习前的准备
Python数据分析入门笔记2——pandas数据读取
Python数据分析入门笔记3——数据预处理之缺失值
Python数据分析入门笔记4——数据预处理之重复值
Python数据分析入门笔记5——数据预处理之异常值
Python数据分析入门笔记6——数据清理案例练习
Python数据分析入门笔记7——数据集成、变换与规约
Python数据分析入门笔记8——Pandas处理日期时间类型数据
Python数据分析入门笔记 系列文章目录前言预备知识： 一、任务说明1. 数据文件下载：2. 任务要求： 二、任务分析与预处理1. 数据分析流程2. 数据获取与初步处理（1）文件的读取——read_csv()和read_excel()（2）文件的合并——merge()（3）数据的筛选 3. 数据清理（1）检测与处理重复值——duplicated()和drop_duplicates()（2）处理缺失值，统一单位——fillna()（3）检测与处理异常值——3σ和箱型图 三、 任务执行：分析运动员数据1. 计算中国男篮、女篮运动员的平均身高与平均体重，保留一位小数2. 分析中国篮球运动员的年龄分布3. 计算中国篮球运动员的体质指数 总结 前言 前面学过了pandas数据清理、数据集成、数据变换和数据规约相关知识，今天用一个运动员基本信息的案例来练习删除重复值、填充缺失值、确认异常值、分组与聚合、轴向旋转和降采样等操作，以达到清理数据、整合数据、减少数据量、变换数据形式的目的。
预备知识： 一、任务说明 1. 数据文件下载： 运动员信息采集01.csv
运动员信息采集02.xlsx
运动员信息采集01.csv文件部分内容如下：
运动员信息采集02.xlsx
2. 任务要求： （1）计算中国男篮、女篮运动员的平均身高与平均体重。
（2）分析中国篮球运动员的年龄分布
（3）计算中国篮球运动员的体质指数
二、任务分析与预处理 1. 数据分析流程 在进行数据分析之前，必须事先对数据进行预处理。
2. 数据获取与初步处理 （1）文件的读取——read_csv()和read_excel() 首先读取这两个文件，由于文件中含有中文，因此读取csv文件时需要设置编码为‘gbk’。
代码如下：
import pandas as pd file_one=pd.read_csv('data/运动员信息采集01.csv',encoding='gbk') file_two=pd.read_excel('data/运动员信息采集02.xlsx') 报错说明——若读取csv的时候未设置中文编码，会报如下错误：
UnicodeDecodeError: ‘utf-8’ codec can’t decode byte 0xd6 in position 0: invalid continuation byte报错说明——若读取excel的时候，设置了encoding，会报如下错误：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7489b1ef986b17dbf66749743c7bc9e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6acd3be9d8e6001e3333460859e0768/" rel="bookmark">
			JAVA Date 类型的对象，只想保留 “yyyy-MM-dd“ 格式的部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Date 类型的对象，如果你只想保留 "yyyy-MM-dd" 格式的部分
1.创建一个 SimpleDateFormat 对象，并设置日期格式为 "yyyy-MM-dd"。
import java.text.SimpleDateFormat; import java.util.Date; Date date = new Date(); SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); 2.使用 SimpleDateFormat 对象的 format() 方法将 Date 对象格式化为字符串。
String formattedDate = dateFormat.format(date); 3.完整代码:
import java.text.SimpleDateFormat; import java.util.Date; public class Main { public static void main(String[] args) { Date date = new Date(); SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); String formattedDate = dateFormat.format(date); System.out.println("日期部分：" + formattedDate); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bfdc8d76b4fd77fa9864a8beebd7c395/" rel="bookmark">
			Dell最新BIOS配置界面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Boot option 启动选项
新版将boot option拉出来作为一个大项设置
enable uefi network stack设置移动到这个大项下：使计算机通过type-c口进行引导启动本机不支持lagacy引导，在NOTE标注中有说明
System configuration 系统配置
在第一个概览中我们发现移除了硬盘信息，将其放置在System configuration—Drive information中,对比如下图：
此外，在system configuration中，我们还可以配置以下信息：
Date/Time日期和时间设置Enable SMART Reporting（启用 SMART报告）：在计算机启动过程中启用或禁用 SMART（自我监测、分析和报告技术）以报告硬盘错误。Enable Audio（启用音频） Enable Microphone（启用麦克风） Enable Internal Speaker（启用内置扬声器）USB 配置 Enable Boot Support（启用引导支持） 启用或禁用从 USB 大容量存储设备（如外部硬盘、光驱和 USB 驱动器）引导的功能。Enable External USB Ports（启用外部 USB端口）启用或禁用 USB 端口在操作系统环境中正常工作。 SATA Operation（SATA 操作） DisableAhciRaid on 驱动器配置 启用或禁用各种板载驱动器。 Security安全设置
Enable Admin Setup Lockout（启用管理员设 置锁定） 启用或禁用在已设置管理员密码的情况下允许用户进入设置程序。 默认：OFF。 Password Bypass 在重新启动系统时略过系统（引导）密码和内置硬盘驱动器密码。 默认：Disabled（已禁用）。 Enable Non-Admin Password Changes（启用 非管理员密码更改） 启用或禁用用户在不使用管理员密码的情况下更改系统和硬盘密码。 默认：ON。Non-Admin Setup Changes 允许无线开关更改 启用或禁用在已设置管理员密码的情况下更改设置程序选项。 默认：OFF。 启用 UEFI 压缩固件更新 通过 UEFI 压缩更新软件包启用或禁用 BIOS 更新。Intel Platform Trust Technology On 启用或禁用平台信任技术 (PTT) 对操作系统的可见性。默认onIntel SGX（英特尔 SGX） 启用或禁用英特尔软件防护扩展 (SGX) 以便提供安全的环境来运行代码/存储敏感 信息。 默认：软件控制 SMM Security Mitigation 启用或禁用额外的 UEFI SMM 安全缓解保护功能。 默认：OFF。 注: 此功能可能会导致兼容性问题，或一些传统工具和应用程序的功能丢失。 Enable strong password（启用增强密码） 启用或禁用强密码。 默认：OFF。 Password Configuration 控制管理员密码和系统密码的最小和最大字符数。 Admin Password 设置、更改或删除管理员 (admin) 密码（有时称为“设置”密码）。 System Password 设置、更改或删除系统密码。 Enable Master Password Lockout（启用主密 码锁定） 启用或禁用主密码支持。 默认：OFF。 Performance性能设置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bfdc8d76b4fd77fa9864a8beebd7c395/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3764127ea317ef619a06944eac42d28/" rel="bookmark">
			Spark-hadoop集群中8020：Connection refused
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用CentOs7虚拟机运行spark案例报出8020端口出现错误 前提条件，使用standalone模式下的Spark，使用spark-shell运行example中的相关测试案例spark-examples_2.12-3.0.0.jar，来计算pi。当spark-shell 停止掉后，集群监控base:4040 页面就看不到历史任务的运行情况，所以需要配置历史服务器记录任务运行情况。
因此，在此基础上需要配置spark的历史服务器来记录任务运行情况，参考网上教程，进行了以下步骤进行配置。
# 1) 修改 spark-defaults.conf.template 文件名为 spark-defaults.conf mv spark-defaults.conf.template spark-defaults.conf # 2) 修改 spark-default.conf 文件，配置日志存储路径 spark.eventLog.enabled true spark.eventLog.dir hdfs://主机名:8020/directory # 注意：需要启动 hadoop 集群，HDFS 上的 directory 目录需要提前存在。 sbin/start-dfs.sh hadoop fs -mkdir /directory # 3) 修改 spark-env.sh 文件, 添加日志配置 export SPARK_HISTORY_OPTS=" -Dspark.history.ui.port=18080 -Dspark.history.fs.logDirectory=hdfs://主机名:8020/directory -Dspark.history.retainedApplications=30" # 4) 重新启动集群和历史服务 sbin/start-all.sh sbin/start-history-server.sh # 5) 重新执行任务 bin/spark-submit --class org.apache.spark.examples.SparkPi --master spark://linux1:7077 ./examples/jars/spark-examples_2.12-3.0.0.jar 10 ❗ 在执行第五步的时候出现了报错，部分报错内容如下：
23/07/28 15:19:58 INFO SparkContext: Successfully stopped SparkContext Exception in thread "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3764127ea317ef619a06944eac42d28/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/126/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>