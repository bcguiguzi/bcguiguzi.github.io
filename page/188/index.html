<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7152a8100e292900ddf1480715f334d9/" rel="bookmark">
			Three.js学习四——模型导入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 模型导入Three.js加载器3D模型文件获取与导入流程模型导入的操作 模型导入 通过Three.js的材质和几何体，我们可以很方便的创建基础3D模型，但涉及到复杂模型时，一般是由专业建模工具生成模型文件再导入的方式将模型引入到我们的3D场景中进行使用
Three.js加载器 Three.js提供多种加载器以支持市面上多种格式的3D文件导入操作
加载器支持文件格式3DMLoader.3dmDRACOLoader.drcFontLoader.jsonGLTFLoaderglTF（gl传输格式）是一种开放格式的规范 （open format specification）， 用于更高效地传输、加载3D内容。该类文件以JSON（.gltf）格式或二进制（.glb）格式提供， 外部文件存储贴图（.jpg、.png）和额外的二进制数据（.bin）KTX2Loader.ktx2LDrawLoaderLDraw资源（一个文本文件，通常扩展名为.ldr、.dat或.txt）可以只描述单个构造件或整个模型。MMDLoaderMMDLoader从MMD资源（例如PMD（.pmd）、PMX（.pmx）、VMD（,vmd）和VPD（.vpd）文件）中创建Three.js物体（对象）MTLLoader.mlt或.mlt与.obj的配套文件OBJLoader.objPCDLoader.pcdPDBLoader.pdbPRWMLoader.prwmSVGLoader.svgTGALoader.tga 3D模型文件获取与导入流程 模型获取：
通过建模工具或者模型素材网站获取，学习用的话官网的模型也是可以使用的，在官方示例文件夹中有很多模型文件目录：three.js-master\examples\models
模型导入：
模型导入的要素
1、模型文件
2、模型加载器
模型导入的流程
1、引入加载器并实例化
2、使用加载器导入模型文件
模型导入的操作 本文将以典型GLTF加载器（GLTFLoader）为例进行模型导入操作，模型使用的是官方示例中的Soldier模型，文件位置：three.js-master\examples\models\gltf\Soldier.glb
为了方便操作我们将文件拷出来放在static\3dmod\gltf文件夹下，static与three.js-master同级
代码基于文章《Three.js学习三——借助控制器操作相机》的基础上进行修改，文件结构如下
index.html
//1、引入加载器并实例化 import { GLTFLoader } from "./three.js-master/examples/jsm/loaders/GLTFLoader.js"; const gltfLoader = new GLTFLoader(); 加载器方法官方文档链接：https://threejs.org/docs/index.html?q=loader#examples/zh/loaders/GLTFLoader
这里用了一个Loader（实现加载器的基类）公有方法.setPath ( path : String ) : this设置资源基本路径，不用的话也可以直接在.load方法第一个url参数中写完整路径。加载器解析基于glTF的ArrayBuffer或JSON字符串，并在完成后触发onLoad回调。onLoad的参数将是一个包含有已加载部分的Object：.scene、 .scenes、 .cameras、 .animations 和 .asset。
.load ( url : String, onLoad : Function, onProgress : Function, onError : Function ) : undefined
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7152a8100e292900ddf1480715f334d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af92fc96c8d11ed0d67d2957c0acf283/" rel="bookmark">
			[vue] node / node-sass / sass-loader 版本对应
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		node / node-sass / sass-loader
这三样东西版本装不对就会报错，非常恶心，一定要装对应版本的
可能是我笨，暂时没找到版本对应关系，网上很多说的都是错的，踩了很多坑，记录一下
按以下版本安装，亲测可用
node：v16.14.0
less-loader@5.0.0
sass-loader@10.2.1
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a46a572d70f6f203e0c0bd86ef2ce44c/" rel="bookmark">
			[第十二届蓝桥杯/java/算法]F——时间显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🧑‍🎓个人介绍：大二软件生，现学JAVA、Linux、MySQL、算法 💻博客主页：渡过晚枫渡过晚枫
👓系列专栏：[编程神域 C语言]，[java/初学者]，[蓝桥杯]
📖阶段目标：备战2023蓝桥杯java个人赛
👻不能逃避，不能逃避，不能逃避，去成为更好的自己！👻
一、🍁题目描述： 小蓝要和朋友合作开发一个时间显示的网站。
在服务器上，朋友已经获取了当前的时间，用一个整数表示，值为从1970年1月1日00:00:00到当前时刻经过的毫秒数。
现在，小蓝要在客户端显示出这个时间。
小蓝不用显示出年月日，只需要显示出时分秒即可，毫秒也不用显示，直接舍去即可。
给定一个用整数表示的时间，请将这个时间对应的时分秒输出。
输入描述 输入一行包含一个整数，表示时间。
输出描述 输出时分秒表示的当前时间，格式形如 HH:MM:SS，其中
HH 表示时，值为 00​​​​ 到 2323​​​​，
MM 表示分，值为 00​​​​ 到 59​​​，
SS 表示秒，值为 00​​ 到 59​。
时、分、秒 不足两位时补前导 0。
二、🍁题目分析： 这题乍一看很复杂，但仔细就会发现其实很简单。
因为题目中说我们不需要考虑年月日和毫秒的影响，那不就等于说，我们可以把日期限定在一天嘛?
毫秒除以1000得到当前分钟的第几秒，
秒数除以60得到当前小时的第几分钟，
小时数除以24得到当前是这天中的第几个小时。
个人认为这题比较难得部分是我们该如何前导0，即当小时为7时，该如何在结果中输出07。
我们当然可以对结果进行判断，不满足条件的话，就在输出的时候加一个字符0。
但，这可行但不必要。
这时候，我想到了字符串的格式化——String.format()方法。
详情可见下面这篇文章：
JAVA字符串格式化-String.format()的使用http://t.csdn.cn/lT5v9在得到秒、分和时的具体数据后，我创建了一个字符串变量Date,然后利用format方法，并搭配转换符的标志"0"，这个标志的作用就是我们所需要的在数字前面补0。
例如：（"04d",12）的结果就是0012，("02d",9)的结果就是09。其中的4和2代表数字的位数，若相应位没有数字，则补0。
三、🍁解题代码： package JAVA_Lanqiao_2021; import java.util.Scanner; public class F { public static void main(String[] args) { Scanner scan=new Scanner(System.in); long Ms=scan.nextLong();//接收整数时间——毫秒,1ms=0.001s long S=Ms/1000;//得到有多少秒 long Minute=S/60; long Hour=Minute/60; String Date=String.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a46a572d70f6f203e0c0bd86ef2ce44c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd22c9c237f55ef24e6b80add85e563c/" rel="bookmark">
			使用MNM(Microsoft Network Monitor)抓包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提起抓包，很多人会先想到wireshark，好用功能强大。但是wireshark用的越久就发现一个问题，有的服务器装不上，服务器安装报错需要系统更新或者装.net，有的装上了却找不到网卡，需要重启等等问题。
我的目的只是想看看是否有流量到服务器，好把锅甩出去。wireshark安装报错就要-百度-配置-完成-重启服务器。这一套下来太费时间了，所以我就寻找有没有其他的抓包工具，结果发现微软也有自己的抓包工具就是这款MNM。
软件首页如下，要开始抓包就选择New Capture
这是抓包页面，可以直接点击start开始，也可以点击capture setting先配置过滤条件和选择抓包的网卡
抓到数据包后在display filter过滤出我们想要的数据
我个人常用的一般是address ipv4,tcp port 中间可以通过||（或OR）&amp;&amp;（与AND）组合条件
选择后他会自动输入，里面有注释有样板，修改参数就行了
下面的例子是访问qq.com抓的包，三次握手然后tls加密
个人感觉还是wireshark好用，可以看到哪些包是响应，可以追踪流等。奈何有些服务器因为系统版本或者系统补丁等原因装不上，不过MNM也能满足基本工作需求，大不了把MNM上抓的包导出来在拖到有wireshark的电脑上看。
这里附上下载链接
链接：https://pan.baidu.com/s/1GazWNBzHcG3N77acYsaLXQ?pwd=ewyu 提取码：ewyu
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e314c9b8bc4cc6b5b63ef748279638b/" rel="bookmark">
			Linux内核移植 | 开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在嵌入式产品中，操作系统充当硬件资源的管理员的角色，对下有硬件层采集信息或者执行功能，对上还需为应用程序提供适合的API接口以便调用。有着承上启下的重要作用。具体硬件产品用公司或者提供商设计，移植系统时，上层跑什么应用程序也不必操心，我们需要根据硬件定制一个平台。
应用程序不能直接去操作硬件（裸机开发不带操作系统），不然就太不安全了，也不方便管理。Linux内核的免费开源和可剪裁性以及开源稳定的特点使它在嵌入式领域的应用广泛。
初学嵌入式系统移植，先把系统在开发板中的大致流程了解一遍，将整个开发环境先搭建起来，为后面深入学习系统移植方面的知识开个头。后面再深究如何移植和剪裁内核等等。嵌入式开发环境通常是交叉开发环境，即让开发者在PC机上进行编辑和编译程序，程序又在嵌入式产品中运行。
所谓交叉开发是指先在一台通用PC上进行软件的编辑、编译与连接，然后下载到嵌入式设备中运行调试的开发过程。通用PC成为宿主机，嵌入式设备成为目标机。（百度百科）
开发工具 开发板 FS4412(华清远见的板子，基于Cortex-A9的处理器)PC机 Ubuntu系统 （Linux大家庭中一个发行版）网线 （速度较快，传输文件用）串口线（与开发板进行命令交互） 实验开发板启动流程 板子上电先从外存（SD卡）加载Bootloader引导程序，引导程序对硬件初始化的同时，通过tftp协议引导加载Linux内核。运行Linux内核，对硬件进行二次初始化，并nfs挂载网络根文件系统，在文件系统上运行hello.c程序，输出 hello world
流程：上电 --&gt; Bootloader --&gt; linux内核 --&gt; nfs根文件系统 --&gt; hello.c
搭建开发环境 PS:每个嵌入式产品由于硬件系统不同，移植的步骤也不一样。这里的过程也对我所学习的步骤做了简化，省略一些细节。你若是看到的话，领会其中思想即可。仅供参考哈~~~
配置开发主机 Ubuntu14.04 我这边开发主机是VMware运行的一个虚拟机，需要配置有
1.设置共享文件夹（方便与windows物理机传输软件包），这里直接使用VMware带的共享功能即可。也可以选择配置Samba服务，无所谓的。
虚拟机 -&gt; 设置 -&gt; 选项 -&gt; 共享文件夹 -&gt; 添加 -&gt; 选择需要共享的位置（如E盘）
2.交叉编译工具安装使用
$ tar xvf gcc-4.6.4.tar.xz $ sudo vim /etc/bash.bashrc //在末尾添加 注意路径要根据gcc-4.6.4的实际路径修改 export PATH=/home/linux/store/gcc-4.6.4/bin:$PATH $ source /etc/bash.bashrc //使配置文件生效 $ arm-n 然后按Tab键补全 //如果能补全为arm-none-linux-gnueabi- 表示安装交叉编译工具成功了 3.tftp服务安装与tftp服务配置
//----虚拟机上安装tftp服务 $ sudo dpkg -s tftpd-hpa //检查是否安装tftp server $ sudo apt-get install tftpd-hpa //如果未安装，安装 tftp-server $ sudo vi /etc/default/tftpd-hpa //修改tftp服务器配置文件为 TFTP_USERNAME="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e314c9b8bc4cc6b5b63ef748279638b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/061093daa8a0f75f530c0f9ca38a171c/" rel="bookmark">
			Node基础——认识Node
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是Node 首先JavaScript是一门编程语言，就像Java、Python、C#、GO一样，在Node出来之前，JavaScript主要运行于浏览器中，用来控制页面的展示逻辑，以及交互操作等。JavaScript之所以能够在浏览器中执行，是因为浏览器中都有JavaScript的解析引擎，不同的浏览器的解析引擎是不同的。
当然除了这些解析引擎外还有其他的解析引擎：比如说quickjs等。
那么JavaScript是如何和浏览器进行交互的，我们都知道，浏览器是用C++进行编写的，他会去解析Html，Css等进行渲染，因为这些都是规则（也就是约定，或者是接口）。对于JavaScript也一样，浏览器也会提供一些接口，然后，解析器将我们的JavaScript规则转换成调用浏览器接口的东西，这样就促成了JavaScript和浏览器的交互。
而Node就是建立的在V8解析引擎上面，将调用系统的功能进行了封装，而中间
Node的特点 对NodeJs其特点有以下几个方面:
Node是一个Javascript运行环境，依赖于Chrome V8引擎进行代码解释单进程，单线程（这里指主线程）非阻塞I/O异步事件驱动性能出众 接下来就意义介绍其上述的几个特点：
Node是一个JavaScript运行环境，依赖于Chrome V8引擎进行代码解释 简单来说，CPU并不认识我们的JavaScript代码，而不同的CPU只认识自己对应的指令集，JavaScript引擎将js代码编译成CPU认识的指令集，当然除了编译之外还要负责执行以及内存的管理。另外JavaScript是解释形语言，由引擎直接读取源码，一边编译一边执行，这样效率相对较低，而编译形语言（如c++）是把源码直接编译成可直接执行的代码执行效率更高。而V8引擎则是一种高效的JavaScript的引擎
V8引擎是一个JavaScript引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。V8使用C++开发，，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。
单进程，单线程（这里指主线程） 对于NodeJS来说，其中的JavaScript的执行是单线程的（这里的单线程是指主线程是单线程）。所有的任务都放在同一个任务执行队列里面去（当然任务会被分为基本任务，宏任务和微任务。只是不同的任务类型在任务队列里里面执行的方式不一样而已）。
非阻塞I/O I/O（输入/输出）：是在主存和外部设备（例如磁盘，终端和网络。这里的外部设备又被称之为I/O设备）之间复制数据的过程。输入操作是从外部设备复制数据到主存，输出操作则是从主存复制 数据到外部设备。阻塞：线程发起一个调用时, 在调用返回之前, 线程会被阻塞, 在这个状态下会交出当前CPU的使用权而暂停.也就是调用方会等待调用结果, 调用阻塞了调用方的线程, 线程不在运行处理中。非阻塞：线程发起一个调用时, 调用会立即返回, 避免线程被阻塞。但是, 返回的结果只是被调用方当前状态的值, 实际使用时, 调用方需要轮询, 直到返回结果符合预期(直到数据准备好)。 一个完整的IO请求的主要包括有两个阶段：
1、查看数据是否就绪；
2、进行数据拷贝（内核将数据拷贝到用户线程）。
阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，再查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。
非阻塞，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返回值的不同来反映函数的执行情况，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高。
异步事件驱动 这中间其实有三个概念，异步、事件和事件驱动。我们挨个介绍。
事件：就是两个物体之间产生了交互行为，就可以成为一个事件。比如说我们点击一个按钮，就称为次事件。事件驱动：就是两个之间产生了交互行为，驱使两个物体的一方，做出了相应的行为或动作。比如说我们单击一个按钮，弹出了一个弹框，那么这个弹框的这个行为，就是我们点击的驱动。异步：异步和同步是相对的，同步就是一件事一件事的执行。只有前一个任务执行完毕，才能执行后一个任务。而异步，是一个任务一个人的调用，而不用等待上一个任务执行完毕，直接开始第二次任务，当上一个任务执行完成后，会通知做后续的操作。我们打个比方，就是我们点击一个按钮，去请求数据，同时改变一下按钮的状态，如果我们等待请求结束后，再去修改按钮状态，这样给人的感受就会特别的奇怪。 在Node底层采用了Libuv这个库，Libuv是一个跨平台的的基于事件驱动的异步io库。但是他提供的功能不仅仅是io，包括进程、线程、信号、定时器、进程间通信等。
性能出众 底层选择用c++和v8来实现的，上面第一点讲到过，nodejs的事件驱动机制，这意味着面对大规模的http请求，nodejs是凭借事件驱动来完成的，性能部分是不用担心的，并且很出色。
Node的优势 1、Nodejs语法完全是js语法，只要你懂js基础就可以学会Nodejs后端开发
Node打破了过去JavaScript只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低开发成本。
NodeJs超强的高并发能力
NodeJs的首要目标是提供一种简单的、用于创建高性能服务器及可在该服务器中运行的各种应用程序的开发工具。
首先让我们来看一下现在的服务器端语言中存在着什么问题。在Java、PHP或者.NET等服务器语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让web应用程序支持更多的用户，就需要增加服务器的数量，而web应用程序的硬件成本当然就上升了。
NodeJs不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。
实现高性能服务器
严格地说，Node.js是一个用于开发各种web服务器的开发工具。在Node.js服务器中，运行的是高性能V8 JavaScript脚本语言，该语言是一种可以运行在服务器端的脚本语言。
那么，什么是V8 JavaScript脚本语言呢？该语言是一种被V8 JavaScript引擎所解析并执行的脚本语言。V8 JavaScript引擎是由Google公司使用C++语言开发的一种高性能JavaScript引擎，该引擎并不局限于在浏览器中运行。Node.js将其转用在了服务器中，并且为其提供了许多附加的具有各种不同用途的API。例如，在一个服务器中，经常需要处理各种二进制数据。在JavaScript脚本语言中，只具有非常有限的对二进制数据的处理能力，而Node.js所提供的Buffer类则提供了丰富的对二进制数据的处理能力。
另外，在V8 JavaScript引擎内部使用一种全新的编译技术。这意味着开发者编写的高端的 JavaScript 脚本代码与开发者编写的低端的C语言具有非常相近的执行效率，这也是Node.js服务器可以提供的一个重要特性。
开发周期短、开发成本低、学习成本低
Node.js自身哲学，是话最小的硬件成本，追求更高的并发，更高的处理性能。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/061093daa8a0f75f530c0f9ca38a171c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf07f7670feba6d05bca3bb96ddfb21d/" rel="bookmark">
			【java】Class类变量和实例变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、类变量和实例变量
二、static和final关键字
2.1 static关键字
2.2 final关键字
2.3 final与static的区别
一、类变量和实例变量 1.1 类变量 可以通过类名或对象名访问。类变量的关键字：static
在内存中只有一个地址，为类和所有对象所共享。
1.2 实例变量 只能通过对象名访问。
为每个对象独立开辟内存地址，对象之间互不影响。
package com; /* *用static定义的方法称为类方法，用static定义的变量称为类变量。 *类方法：可以通过类直接引用。该方法可以通过类名或对象名进行引用 ； *类变量：可以通过类直接引用。该变量可以通过类名或对象名进行引用 。 */ public class MyMath { static double x=10; //在内存中之创建一个地址，为类和所有对象所共享 double y=20; //为每个对象独立开辟地址空间，对象之间互不影响 public static int randInt() { return (int)(Math.random()*100) } public static void main(String args[]) { MyMath m1=new MyMath(); MyMath m2=new MyMath(); System.out.println(m1.randInt()); //通过对象进行引用 System.out.println(MyMath.randInt()); //通过类名直接引用 System.out.println(Math.PI); //public static final double PI：不可变的类变量 double k=MyMath.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf07f7670feba6d05bca3bb96ddfb21d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92e1ad51e5223554a4eb3c080ffd2894/" rel="bookmark">
			贪心算法及证明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		贪心算法及证明
1、贪心选择性
一个问题的整体最优解可以通过一系列局部最优选择来达到，每次的选择还会依赖于已经做过的选择，这就时贪心选择性
2、最优子结构
一个问题的最优解包含这个问题分解过后子问题的最优解，或一个问题的最优解可以由该问题的一个或多个子问题最优解得到，则该问题具有最优子结构，也可理解为整体最优则局部最优。
3、贪心证明
一个问题能否用贪心算法求解的证明重点就在看这个问题是否具有贪心选择性和最优子结构性，例如有如下问题：
有一批集装箱(6个)要装上一艘最大载重量为100吨的轮船。其中，集装箱的重量分别为40吨、24吨、30吨、14吨、16吨、20吨。请在装载体积不受限制的情况下，将数量尽可能多的集装箱装上轮船。
采用重量最轻者先装的贪心选择策略，可产生最优装载问题的其中一个最优解。
14吨+16吨+20吨+24吨=74吨，可装入4个集装箱。
在进行贪心证明时只需要不用贪心法构造出一个解，然后证明贪心法不会比这个解更差即可。
假设问题存在最优解U且U中的第一个装载箱编号是i。
若i = 1，结论直接成立。
若i &gt; 1，则设集合Y=U-{i}+{1}，由于w1&lt;=wk, 又因为U和Y集装箱个数相同，且U是最优的，则Y同样最优，因此第一个装载箱是可以存在于某个最优解中的。
则可证明此问题具有贪心选择性，贪心选择性确保了选择最轻的集装箱是对的
若0-1序列S=(x1,x2,...,xn)是最优装载问题装载量为T时的一个最优解，则S1=(x2,...,xn)一定是最优装载问题装载量为T-w1*x1的一个最优解。
则可证明此问题具有最优子结构，最优子结构性质确保了得到该问题每一步的最优解会得到整个问题的最优解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3c26553da34728e4d5e071fac0d4fb1/" rel="bookmark">
			【java&amp;eclipse】Class类的创建、定义、权限、特性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、类的创建
1.1 创建类包（Package）
1.2 创建类（Class）
二、类的定义
2.1 成员变量
2.2 构造方法
三、类的访问权限
四、类的三大特性
4.1 封装性
4.2 继承性
4.3 多态性
一、类的创建 1.1 创建类包（Package） （选做）为了更好地管理日后越来越多的类，首先新建类包（Package），相当于文件夹的作用。步骤如图：
1.2 创建类（Class） 右击类包，依次点击New-Class，输入类名，点击Finish完成创建
二、类的定义 2.1 成员变量 2.2 构造方法 以管理员类（Admin.java）为例，定义成员变量（属性）和构造方法：
package javaBean; public class Admin { //类是属性和功能的封装体 //属性（特征） private String id; private String name; private String psw; private String type; //功能（方法、函数） /* * 用户自定义构造方法，系统默认的构造方法就会被屏蔽， * 如果用户需要此默认构造方法，则必须显式定义出来 */ public Admin() {} public Admin(String id,String name,String psw,String type) { //方法名和类名同名、没有返回值类型，此方法称为构造方法， //作用：用类创建对象时进行初始化 this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3c26553da34728e4d5e071fac0d4fb1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88fb8de310908b220c261ab812c485b9/" rel="bookmark">
			Java&#43;mysql基于ssm的大学生求职招聘系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本求职招聘管理系统主要包括系统用户管理模块、企业新闻管理模块、招聘发布会管理、招聘信息管理、登录模块、和退出模块等多个模块。它帮助求职招聘管理实现了信息化、网络化,通过测试,实现了系统设计目标,相比传统的管理模式,本系统合理的利用了求职招聘管理数据资源,有效的减少了求职招聘管理的经济投入,大大提高了求职招聘管理的效率
本系统主要包含了等系统用户管理、招聘会管理、应聘信息信息管理、应聘信息信息管理多个功能模块。下面分别简单阐述一下这几个功能模块需求。
管理员的登录模块：管理员登录系统对本系统其他管理模块进行管理。
用户的登录模块：用户登录本系统,对个人的信息等进行查询,操作可使用的功能。
用户注册模块：游客用户可以进行用户注册,系统会反馈是否注册成功。
添加管理员模块：向本系统中添加更多的管理人员,管理员包括普通管理员和超级管理员。
招聘会管理模块：
招聘会列表：将数据库的招聘会表以列表的形式呈现给管理员。
添加招聘会：实现管理员添加招聘会。
修改招聘会：实现管理员修改招聘会。
招聘信息管理模块：
招聘信息列表：将数据库的招聘信息表以列表的形式呈现给管理员。
添加招聘信息：实现管理员添加招聘信息。
修改招聘信息：实现管理员修改招聘信息。
应聘信息信息管理模块：
应聘信息信息列表：显示系统的所有应聘信息信息,可以通过关键字查询。
应聘信息信息删除：对输入错误或过期的应聘信息信息删除。
简历管理模块：
简历列表：显示系统的所有简历,可以通过关键字查询。
简历删除：对输入错误或过期的简历删除。
用户模块：
资料管理：用户登录本系统。可以对自己的个人主页进行查看。
系统信息：用户可以查看自己的系统提示信息。
修改资料：用户可以修改自己的账号密码。
信息搜索：用户可以通过关键字搜索站内信息。
密码修改：用户可以修改个人登录密码。
系统管理模块：包括数据备份。
退出模块：
管理员退出：管理员用来退出系统。
用户退出：用户用来退出系统。
package com.controller;
import java.io.File;
import java.io.IOException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.PrintWriter;
import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;
import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.multipart.MultipartFile;
import com.entity.Allusers;
//import com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88fb8de310908b220c261ab812c485b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe5f9ccfba8807955e23ff4eb236e327/" rel="bookmark">
			【量化交易】QMT自动交易逆回购
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#encoding:gbk import pandas as pd import time from datetime import datetime accID = '00000001' asset_name = '204001.SH' # 上交所1天逆回购 def init(ContextInfo): global accID, asset_name ContextInfo.set_account(accID) ContextInfo.run_time("process_condition_order","1nDay","2022-12-01 15:03:00") #'3nSecond' '1nDay' print('已启动') def process_condition_order(ContextInfo): # 查可用资金 available_funds = get_trade_detail_data(accID, 'stock', 'account')[0].m_dAvailable volume = int(available_funds/1000)*10 print('可用余额：',available_funds) print('可交易逆回购数量：',volume) if volume &gt;= 1000: # 查逆回购价格 result=ContextInfo.get_market_data(['quoter'],stock_code=[asset_name],start_time='',end_time='',skip_paused=True,period='tick',dividend_type='none') buy5_price = result['bidPrice'][-1] last_price = result['lastPrice'] print('buy5_price',buy5_price) #下单方向、下单方式、账号、标的代码、价格类型、下单价格、下单数量、策略名称、是否立即促发下单、委托id、ContextInfo passorder(24,1101,accID,asset_name,11,buy5_price,volume, '', 2, '', ContextInfo) else: print('可用资金不足，不交易') def order_callback(ContextInfo, orderInfo): print(f'&gt;&gt;&gt; order_callback: {orderInfo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe5f9ccfba8807955e23ff4eb236e327/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/824d09a936b2407ad2afcaee18a7243a/" rel="bookmark">
			SpringBoot 学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SpringBoot 学习笔记 一、简介 1.1 什么是SpringBoot 一个javaweb的开发框架、简化开发、约定大于配置、集成大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用）
1.2 第一个SpringBoot程序 创建一个springboot程序有两种方式：
1.2.1 官网创建
①打开 https://start.spring.io/
②填写项目信息
③点击”Generate Project“按钮生成项目；下载此项目
④解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。
⑤如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。
1.2.2 项目创建方式二使用 IDEA 直接创建项目
①创建一个新项目
②选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现
③填写项目信息
④选择初始化的组件（初学勾选 Web 即可）
⑤填写项目路径
⑥等待项目构建成功
1.3 项目结构组成 1、程序的主启动类（程序的主入口）
2、一个 application.properties 配置文件（SpringBoot的核心配置文件）
3、一个 测试类
4、一个 pom.xml
1.4 自动装配源码剖析结论 @SpringBootApplication
作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用
@ComponentScan
这个注解在Spring中很重要 ,它对应XML配置中的元素。
作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中
@SpringBootConfiguration
作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；
@EnableAutoConfiguration ：开启自动配置功能
以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；
@AutoConfigurationPackage 翻译：自动配置包
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/824d09a936b2407ad2afcaee18a7243a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fda29b887fc2ea4a844e16494b0ed41f/" rel="bookmark">
			HTTP Status 500 - java.lang.NullPointerException错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在maven的web项目中出现HTTP Status 500 - java.lang.NullPointerException报错的时候，可能是存在依赖重复导入的情况。
例如，父项目和子项目的pom.xml中都导入了下面的依赖，则选择其一以来保存即可。例如我们去掉子项目中的依赖，只保留父项目中的依赖。
&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d74e23c8189afb51ac024158e2743a6/" rel="bookmark">
			一文搞懂Linux下并制作环形缓冲区
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环形缓冲区log_buf[]又是存在内核的哪个文件呢？
位于/proc/kmsg里,所以除了dmesg命令查看,也可以使用cat /proc/kmsg来查看
2.但是,dmesg命令和cat /proc/kmsg有所不同
2.1 dmesg命令
每次使用,都会打印出环形缓冲区的所有信息
2.2 cat /proc/kmsg
只会打印出每次新的环形缓冲区的信息
比如,第一次使用cat /proc/kmsg,会打印出内核启动的所有信息
第二次使用cat /proc/kmsg,就不会出现之前打印的信息,只打印继上次使用cat /proc/kmsg之后的新的信息,比如下图所示:
【文章福利】小编推荐自己的Linux内核技术交流群:【 865977150】整理了一些个人觉得比较好的学习书籍、视频资料共享在群文件里面，有需要的可以自行添加哦！！！前100名进群领取，额外赠送一份价值 699的内核资料包（含视频教程、电子书、实战项目及代码) 资料直通车：最新Linux内核源码资料文档+视频资料
学习直通车：Linux内核源码/内存调优/文件系统/进程管理/设备驱动/网络协议栈
3.接下来我们便进入内核,找/proc/kmsg文件在哪生成的
搜索"kmsg",找到位于fs\proc\proc_misc.c 文件的proc_misc_init()函数中,
该函数主要用来生成登记的设备文件,具体代码如下所示:
const struct file_operations proc_kmsg_operations = { .read = kmsg_read, //读函数 .poll = kmsg_poll, .open = kmsg_open, .release = kmsg_release, }; void __init proc_misc_init(void) { ... ... struct proc_dir_entry *entry; // 用来描述文件的结构体, entry = create_proc_entry("kmsg", S_IRUSR, &amp;proc_root); //使用create_proc_entry()创建文件 if (entry) entry-&gt;proc_fops = &amp;proc_kmsg_operations; //对创建的文件赋入file_ operations .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9d74e23c8189afb51ac024158e2743a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5eb65f09af2c57f36b2a0133764423e/" rel="bookmark">
			基于三维块匹配滤波的传统图像去噪中非局部自相似去噪算法—BM3D原理总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		传统图像降噪算法之BM3D原理详解_峡谷相对论的博客-CSDN博客_bm3d
BM3D算法「建议收藏」 - 腾讯云开发者社区-腾讯云
ISP模块之RAW DATA去噪（二）--BM3D算法 - 走看看
[1] Dabov K, Egiazarian K. Image Denoising by Sparse 3-D Transform-Domain Collaborative Filtering[J]. IEEE TRANSACTIONS ON IMAGE PROCESSING, 2007, 16(8).
[2]Danielyan A, Vehvilainen M, Foi A, et al. Cross-color BM3D filtering of noisy raw data[C]//2009 international workshop on local and non-local approximation in image processing. IEEE, 2009: 125-129.
相关阅读：VBM3D 与 VBM4D
[3]Ehret T, Arias P. Implementation of the vbm3d video denoising method and some variants[J].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5eb65f09af2c57f36b2a0133764423e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e81121343f5f881d89f4545e901da6b/" rel="bookmark">
			ModuleNotFoundError: No module named ‘tqdm.auto‘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		查看tqdm的版本，将tqdm版本调整到4.45.0即可。
pip list pip uninstall tqdm pip install tqdm==4.45.0 参考网址：ModuleNotFoundError: No module named 'tqdm.auto' · Issue #16 · swansonk14/p_tqdm · GitHub
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6908905a1641c45b946d3d933a40c4/" rel="bookmark">
			Python通过字典来替代if..else
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在应对多策略的场景下，大量使用if...else...不仅提高了后期的维护成本，还降低了运行效率。通过字典做映射就可以更好的优化代码。
比如这样一个模拟场景，根据用户的VIP等级，发放奖励。在大量使用if...else...时就会变成如下状态：
rank="VIP4" if rank=="VIP1": print(100) else: if rank=="VIP2": print(150) else: if rank=="VIP3": print(200) else: if rank=="VIP4": print(300) 在改用为字典后，代码如下：
rank="VIP4" message={ "VIP1":100, "VIP2":150, "VIP3":200, "VIP4":300, } a=message.get(rank,None) print(a) try: a=message[rank] except: a=None print(a) 打印结果：
这里，字典message拥有键(key)和值。可通过get(key,default=None)，setdefault(key, default=None)，以及message[key]来索引到值。
这三者的不同：
message.get(key,default=None):如果key不在字典中，则返回None
message.setdefault(key,default=None):如果key不在字典中，则返回None，并在字典中添加该key，其值为default的值。以本案例为例，若执行message.setdefault("VIP5",500)，字典message后就会增加一项"VIP5":500，并返回值500。
message[key]:如果key不在字典中,就会直接报错。因此案例中采用了try..except..的格式。
我们在实际应用中不仅仅只是key对值的简单映射，而是更多会遇到需要映射函数的情况。这样的场景比如根据不同生产指令，去执行不同运动等。回到本案例，代码如下：
def vip1(): return 100 def vip2(): return 150 rank="VIP1" message={ "VIP1":vip1, "VIP2":vip2, "VIP3":200, "VIP4":300, } a=message.get(rank,None) print(a) try: a=message[rank]() except: a=None print(a) 执行后结果如下：
我们可以看到第一个a返回的值不是100，这是因为第一个返回的是一个函数整体，即一个函数类，而不是return的值。而如果执行a=message[rank]，同样也是返回一个函数整体，而不会是return的值。只有在执行了a=message[rank]()后才会返回return的值。这里括号的作用就是执行函数的意思，同时括号里面还可以添加自定义函数需要的初始变量，最后这里a=message["VIP1"]()等价于a=vip1()，还等价于
b=message[rank] a=b() 如果当字典中key映射的值不为函数，而为具体一个值时，此时执行a=message[rank]()就会报错。故优化后的框架如下：
def vip1(): return 100 def vip2(): return 150 rank="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6908905a1641c45b946d3d933a40c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/985c3ab31ff84b9ea1a49d4cc1972c66/" rel="bookmark">
			A White Paper on Neural Network Quantization--阅读笔记1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A White Paper on Neural Network Quantization--阅读笔记1 一、模型量化的意义二、量化主要做什么三、目前量化主要分类四、量化基本知识介绍0、基本知识1、误差来源2、量化范围的设定 五、量化方法介绍1、均匀仿射量化(Uniform affine quantization)2、对称均匀量化(Symmetric uniform quantization)2.1 、对称和非对称量化(Symmetric vs. asymmetric quantization)3、二次幂量化(Power-of-two quantizer)4、量化粒度(Quantization granularity)5、量化模拟(Quantization simulation)6、其它层量化(Other layers and quantization)7、批量归一化的折叠(Batch normalization folding)8、激活函数融合(Activation function fusing) 一、模型量化的意义 我们希望把一些大型的网络应用到对功耗和计算有严格要求的边缘设备中，对此降低神经网络在推理过程中的能耗和延迟就非常关键。神经网络量化是实现这些需求最有效的方法之一。
二、量化主要做什么 对权重和激活都使用低位宽表示(这里的激活不是指激活函数，而是指输入/输出的特征图也就是常说的feature map)
三、目前量化主要分类 训练后量化(PTQ)Post-Training Quantization
量化感知训练(QAT) Quantization
Aware Training
PTQ不需要重新进行训练或者是不需要标签数据，因此这是一种轻量化的量化方法。在大多数情况下PTQ在使用8bit量化时就足以接近浮点模型的精度。QAT需要微调model和带标签的数据，但是可以在更低位宽时取得更有竞争力的结果。
四、量化基本知识介绍 0、基本知识 首先，需要了解硬件上是如何模型推理的。我们指导神经网络满足公式：， y = W x + b y=Wx+b y=Wx+b，以下Fig1展示了神经网络（neural network (NN)）加速器中计算矩阵-向量乘法的示意图。
Fig1：
这个结构一般是作为神经网络或者更大的矩阵-向量计算需求中的一个基本模块。这类硬件模块通过尽可能多的并行计算来提高NN的推理效率。这类NN加速器的两个基本组成部分是处理单元(PE) C n , m C_{n,m} Cn,m​和累积器(ACC) A n A_n An​，在Fig1的示例中，我们有16个处理单元(PE)和4个累加器(ACC)。计算过程为，累加器首先加载偏置值 b n b_n bn​，然后我们将权重值 W n , m W_{n,m} Wn,m​和输入值 X m X_m Xm​ 加载到数组中，并在单个循环中计算它们在各个处理元素 C n , m = W n , m X m C_{n,m}=W_{n,m}X_m Cn,m​=Wn,m​Xm​ 中的乘积，然后将他们的乘积和与累加器中的 b n b_n bn​进行累加，我们获得公式1：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/985c3ab31ff84b9ea1a49d4cc1972c66/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aacc3a40a875ceb1f0f68ce0c0edd27c/" rel="bookmark">
			云服务器被ddos五个解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你的网站或网络设备遭到了DDOS攻击，你可以采取以下步骤来解决这个问题：
1.首先，应尽快联系你的厂家ISP），告诉他们你正在遭受DDOS攻击。他们可能会帮助你拦截攻击流量，并提供其他帮助。
2.尝试使用拥有较大带宽的服务器或CDN（内容分发网络）来缓解攻击的影响。这些服务可以帮助你缓解流量的压力，并减少攻击对你的网站的影响。
3考虑使用防火墙或来阻止恶意流量。可以帮助你识别并阻止来自恶意源的流量。
4.尝试使用DDoS防护。这些可以帮助你检测和阻止DDOS攻击，并减少对你的网站的影响。
5.对你的网站进行容量规划。如果你的网站常常遭受DDOS攻击，那么你可能需要重新规划你的网站的容量，以便能够承受更大的流量。
希望这些建议能帮助大家解决DDOS攻击的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d076d47058e458703e991c8e7a9c76bd/" rel="bookmark">
			AttributeError: ‘list‘ object has no attribute ‘detach‘ | torchsta | stat(model, (3, 224, 224)) | 模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景： 用torchstat分析模型结构，当model中包含Concat时，调用stat(model, (3, 224, 224))函数，会报错
问题描述 完整报错内容
Traceback (most recent call last): File "/home/yangzhanshan/disk/temp/my-Pruning/models/mobilenet_v2.py", line 1008, in &lt;module&gt; stat(model_yaml, (3, 224, 224)) File "/home/yangzhanshan/disk/anaconda3/envs/yolov5/lib/python3.8/site-packages/torchstat/statistics.py", line 71, in stat ms.show_report() File "/home/yangzhanshan/disk/anaconda3/envs/yolov5/lib/python3.8/site-packages/torchstat/statistics.py", line 64, in show_report collected_nodes = self._analyze_model() File "/home/yangzhanshan/disk/anaconda3/envs/yolov5/lib/python3.8/site-packages/torchstat/statistics.py", line 57, in _analyze_model model_hook = ModelHook(self._model, self._input_size) File "/home/yangzhanshan/disk/anaconda3/envs/yolov5/lib/python3.8/site-packages/torchstat/model_hook.py", line 24, in __init__ self._model(x) File "/home/yangzhanshan/disk/anaconda3/envs/yolov5/lib/python3.8/site-packages/torch/nn/modules/module.py", line 1130, in _call_impl return forward_call(*input, **kwargs) File "/home/yangzhanshan/disk/temp/my-Pruning/models/mobilenet_v2.py", line 958, in forward return self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d076d47058e458703e991c8e7a9c76bd/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/187/">«</a>
	<span class="pagination__item pagination__item--current">188/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/189/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>