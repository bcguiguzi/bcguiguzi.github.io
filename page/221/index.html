<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65226d2d54614735373b446d2a52df80/" rel="bookmark">
			一台服务器安装2个mysql，以及mysql的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装步骤 1、下载压缩包 2、将压缩包解压放置在英文的文件夹中 3、添加环境变量 4、在mysql-5.7.19-winx64文件夹中创建my.ini文件 5、使用管理员权限打开cmd窗口，安装mysql服务等 123忽略，比较简单。
4.新建my.ini文件 在F:\mysql\mysql-5.7.19-winx64目录下新建my.ini文件
————————————————
[Client] #设置3306端口 port = 3306 # 设置mysql客户端默认字符集 default-character-set=utf8
[mysqld] # 设置mysql的安装目录 basedir=F:\hspmysql\mysql-5.7.19-winx64
# 设置mysql数据库的数据的存放目录 datadir=F:\hspmysql\mysql-5.7.19-winx64\data\
#设置3306端口 port = 3306 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 #跳过安全检查
skip-grant-tables
————————————————
以管理员身份打开命令行窗口 bin目录然后执行下面命令安装
mysqld -install
执行下面命令初始化
mysqld --initialize-insecure --user=mysql
net start mysql
剩下就是初始空密码进mysql了，设置下新密码然后剩余就是常规操作。这里如果是同一个机器安装第二个mysql则如下：
将my.ini文件中的内容修改为以下内容，注意修改其中的basedir 、datadir 、port 参数信息，端口号不可与当前已安装数据库端口号重复
然后注意安装时候指定服务名称与第一个不同：
mysqld install MySql2 --defaults-file=“D:\......\my.ini” 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a74b04c361c3440db4bf1d448e8b950f/" rel="bookmark">
			required a single bean, but 2 were found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Field roleService in com.lwluo.exam.framework.web.service.web.SysPermissionService required a single bean, but 2 were found: 启动报错
说 需要一个 bean，但找到了 2 个 ,但是我这里只有一个接口和一个实体类
解决
@MapperScan 扫描范围过大 指定要扫描的包
记录一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d34e60cd0b0f62263687243a205316b2/" rel="bookmark">
			SOL_SOCKET套接字选项SO_RCVBUF
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SOL_SOCKET套接字选项SO_RCVBUF 问题引入 最近一个跨平台项目SDK中配置SO_RCVBUF时发现在不同的平台上配置相同的值，但却产生了不同的结果，经过分析验证最终发现SO_RCVBUF的size最大值在不同OS上有着不同的限制，本文就此总结如下。
SO_RCVBUF最大值限制 windows windows环境中没有明确限制参数配置，因此setsockopt返回正常，运行时无内存异常抛出即可任意配置。《参考文献》
linux linux环境受系统内核参数net.core.rmem_max限制，使用以下命令查看
sysctl -n net.core.rmem_max 可以使用sysctl -w修改。
macOS macOS受系统内核参数kern.ipc.maxsockbuf限制，同时maxsockbuf受nmbclusters限制，使用以下命令查看。《参考文献》
sysctl -n kern.ipc.maxsockbuf sysctl -n kern.ipc.nmbclusters 如需修改首先要关闭System Integrity Protection (SIP)，然后修改ncl启动参数，之后通过sysctl -w进行修改。
nvram boot-args="ncl=131072" shutdown -r now 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e4cbad94a9b2489ed8da70d88000e9/" rel="bookmark">
			【开始刷题啦——Leetcode《初级算法》（Go语言）】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go-Leetcode《初级算法》 删除排序数组中的重复项买卖股票的最佳时机 II旋转数组存在重复元素只出现一次的数字两个数组的交集 II加1&lt;mark&gt;移动零&lt;mark&gt;两数之和有效的数独&lt;mark&gt;旋转图像&lt;mark&gt;反转字符串整数反转字符串中的第一个唯一字符有效的字母异位词验证回文串字符串转换整数 (atoi)&lt;mark&gt;实现 strStr()&lt;mark&gt; 持续更新中… 删除排序数组中的重复项 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致
思路： 采用双指针的方法 func removeDuplicates(nums []int) int { length := len(nums) if length == 0{ // 排除特殊情况 return 0 } // 双指针实现 low := 0 for high := 1;high &lt; length;high++{ if nums[low] != nums[high]{ low ++ nums[low] = nums[high] } } return low + 1 } 买卖股票的最佳时机 II 旋转数组 存在重复元素 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94e4cbad94a9b2489ed8da70d88000e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c41c516227592d80937e27053ac8e8d4/" rel="bookmark">
			recvfrom函数之“transport endpoint is not connected”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天敲的关于UDP代码编译通过了，执行的时候在recvfrom函数输出错误码，错误码对应的内容是“transport endpoint is not connected”，找了很久都找不到错误在哪里，后面我问了一下我的同学，她一眼就看出了我的错误。是在创建套接字的时候，socket()函数的参数套接字类型type写成了流式套接字tSOCK_STREAM。如果通信是基于UDP协议，套接字类型type应该使用的是SOCK_DGRAM。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/307530e25ae01b63bc93219e7d068833/" rel="bookmark">
			Docker的简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
1.1 为什么会有Docker出现？
1.2 Docker的理念
1.3 虚拟机与容器的比较
对比
1.1 为什么会有Docker出现？ 在开发人员开发一个项目的时候，正在开发的应用依赖于开发人员当前的配置且还要依赖于某些配置文件。此外，企业还拥有标准化的测试和生产环境，且具有自身的配置和一系列支持文件。希望尽可能多在本地模拟这些环境而不产生重新创建服务器环境的开销。另一方面在运维工程师进行运维调试的时候也可能因为环境不同而造成，安装和调试失败，那有没有什么办法能解决这个问题呢？
答案就是Docker，在开发人员将应用提测的时候，就将自己电脑的环境和配置文件一起打包给到运维人员和测试人员。Docker之所以发展如此迅速，也是因为它对此给出了一个标准化的解决方案：系统平滑移植，容器虚拟化技术。
传统上认为，软件编码开发/测试结束后，所产出的成果即是程序或是能够编译执行的二进制字节码等(java为例)。而为了让这些程序可以顺利执行，开发团队也得准备完整的部署文件，让维运团队得以部署应用程式，开发需要清楚的告诉运维部署团队，用的全部配置文件+所有软件环境。不过，即便如此，仍然常常发生部署失败的状况。Docker的出现得以打破过去「程序即应用」的观念。透过镜像(images)将作业系统核心除外，运作应用程式所需要的系统环境，由下而上打包，达到应用程式跨平台间的无缝接轨运作。
1.2 Docker的理念 docker是基于Go语言实现的云开源项目，Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次镜像，处处运行”。
Linux的容器技术的出现就解决了这样一个问题，而Docker就是在它的基础上发展过来的。将应用打成镜像，通过进项成为运行在Docker容器上面的实例，而Docker容器在任何操作系统上都是一致的，这就实现了跨平台、跨服务器。只需要配置一次环境，就可以切换到其他的环境运行。
总结：解决了运行环境和配置问题的软件容器，方便做持续集成并有助于整体发布的容器虚拟化技术。
1.3 虚拟机与容器的比较 虚拟机（Virtual machine）是待换机安装的一种解决方案。比如我们常见的用VMware Workstation，就是在Windows的操作环境中安装一个Linux的操作系统；虚拟机看上去和真实系统一模一样，而对底层的系统来说，虚拟机就是一个文件。这类虚拟机使得在一个系统中运行了另一个系统，试应用程序，操作系统和硬件三者之间的逻辑不变。
传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如∶VirtualBox和VMWare等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。虚拟机缺点也显而易见：资源占用多、冗余步骤多、启动慢。
容器技术：虚拟机存在某些缺点，Linux发展出了另一个虚拟化技术：Linux容器（Linux Containers，缩写LXC）Linux容器是与系统其他部分隔离开的一系列进程，从另一个镜像运行，并由镜像提供支持所需的所有文件。所以从开发到测试再到生产的整个过程中，他都具有可移植性和一致性。
Linux 容器不是模拟一个完整的操作系统而是对进程进行隔离。有了容器，就可以将软件运行所需的所有资源打包到一个隔离的容器中。容器与虚拟机不同，不需要捆绑一整套操作系统，只需要软件工作所需的库资源和设置。系统因此而变得高效轻量并保证部署在任何环境中的软件都能始终如一地运行。
Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。
对比 虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。 为什么Docker会比VM虚拟机快？
1、docker有着比虚拟机更少的抽象层
由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优
2、docker利用的是宿主机的内核,而不需要加载操作系统OS内核
当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟
Docker官网：http://www.docker.comDocker Hub官网:（仓库） https://hub.docker.com/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea40116295ff1eb88f6964d5ffcc05f/" rel="bookmark">
			如何实现 动态组件 component
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景：
1、父组件 father 、子组件 Left 、子组件 Right
2、在父组件 中分别引入 子组件 Left 和 Right 父组件 father：
&lt;component :is="componentName"&gt;&lt;/component&gt; // 首先通过 component 组件展位 通过 动态 绑定 is 属性值 来确认渲染哪个组件
&lt;button @click="componentName = 'Left"&gt;展示 Left 组件&lt;/button&gt; // 添加点击事件 控制 componentName 显示哪个组件
&lt;button @click="componentName = 'Right"&gt;展示 Left 组件&lt;/button&gt;
import Left from '@/component/Left.vue'
import Right from '@/component/Right .vue' // 引入组件
data() {
return {
componentName: 'Left' // 定义默认值
}
}
component: { Left,Right} // 注册组件
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27af7e91f6a93c71da751b929eb0af80/" rel="bookmark">
			docker错误集-CentOS环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题：WARNING: IPv4 forwarding is disabled. Networking will not work. 容器内无法访问外网，宿主机可以
原因：
“ default the ipv4 forwarding is not turned on in the image from docker to prevent any security vulnerabilities. ”
Docker处于安全考虑默认关闭该设置。
解决方案： 返回宿主机
echo 'net.ipv4.ip_forward=1' &gt;&gt; /etc/sysctl.conf
systemctl restart network &amp;&amp; systemctl restart docker
sysctl net.ipv4.ip_forward
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94e31ef38196b05a7a2b96c88defe33e/" rel="bookmark">
			单链表——指定结点的前插和后插
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后插 #define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct LNode {	//定义单链表结点类型 int data;	//每个节点存放一个数据元素 struct LNode* next;	//指针指向下一个节点 }LNode, * LinkList; //初始化一个单链表（带头结点） bool InitList(LinkList&amp; L) { L = (LNode*)malloc(sizeof(LNode));//分配一个头结点 if (L == NULL)//内存不足，分配失败 return false; L-&gt;next = NULL;//头结点之后暂时还没有结点 return true; } //在第i个位置插入元素e（带头结点） bool ListInsert(LinkList&amp; L, int i, int e) { if (i == 1) { LNode* s = (LNode*)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = L; L = s;	//头指针指向新节点 return true; } LNode* p;	//指针p指向当前扫描到的结点 int j = 1;	//当前p指向的是第几个结点 p = L;	//第1个结点 while (p !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94e31ef38196b05a7a2b96c88defe33e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b3da7b30ed7bd69e03f60d21dad569/" rel="bookmark">
			单链表的建立——带头结点和不带头结点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.带头结点
#define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef struct LNode {	//定义单链表结点类型 int data;	//每个节点存放一个数据元素 struct LNode* next;	//指针指向下一个节点 }LNode,*LinkList; bool InitList(LinkList&amp; L) { L = NULL; return true; } LinkList List_HeadInsert(LinkList&amp; L) { LNode* s; int x; L = (LinkList)malloc(sizeof(LNode));//创建头结点 L-&gt;next = NULL;//初始化为空链表 scanf("%d", &amp;x);//输入结点的值 while (x!=999) {//输入999表示结束 s = (LNode*)malloc(sizeof(LNode));//创建新结点 s-&gt;data = x; s-&gt;next = L-&gt;next; L-&gt;next = s;//将新节点插入表中，L为头指针 scanf("%d", &amp;x); } return L; } int main() { LinkList L; //InitList(L); //插入结点 List_HeadInsert(L); //打印结点 L = L-&gt;next; while (L !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01b3da7b30ed7bd69e03f60d21dad569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70db6ef415a8795ed478bba4701b09ed/" rel="bookmark">
			万无一失的OpenMV识别矩形、圆形、三角形方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、官网方法 直接使用find_circles()和find_rects()识别矩形和圆形，使用find_lines()函数寻找三条直线，利用三角形内角和180°来识别三角形。
find_circles()详解
find_rects()详解
find_lines()详解
认真看手册！认真看手册！认真看手册！重要问题说三遍！
给函数赋予的参数对最终识别效果影响非常大，一定一定要认真理解参数，然后耐心调参。
我在用这几个函数时，要么识别很多要么都识别不到，解决办法就是对图像进一步处理或者进行滤波。在背景杂乱的情况下，三角形用这个方法识别误差会很大。
二、使用识别色块 我的方法主要是识别色块，先识别颜色再识别形状，缩小判断范围。
官网手册find_blobs()详解
主要使用了函数blob.density()，返回色块的密度。这等于色块的像素数除以外框的区域。对于正视的矩形，该值应等于1，对于正视的圆形，该值应等于π/4；对于正视的三角形，则小于0.5。但实际情况是，摄像头不一定正视，再加其他因素的影响，使得这个值会上下浮动。最有效的调参方法是：先分别print矩形、圆形、三角形的density()，看大致范围后再决定参数。
代码如下：
def detect(max_blob):#输入的是寻找到色块中的最大色块 row_data=[-1,-1]#保存颜色和形状 print(max_blob.solidity()) if max_blob.density()&gt;0.84: row_data[0]=max_blob.code() img.draw_rectangle(max_blob.rect()) row_data[1]=1#表示矩形 elif max_blob.density()&gt;0.6: img.draw_circle((max_blob.cx(), max_blob.cy(),int((max_blob.w()+max_blob.h())/4))) row_data[0]=max_blob.code() row_data[1]=2#表示圆形 elif max_blob.density()&gt;0.4: row_data[0]=max_blob.code() row_data[1]=3#表示三角形 return row_data#返回的是两个值，颜色和形状 原本到这里已经结束了，但一直存在一个问题：矩形如果倾斜一个角度或者旋转过，计算出的density()值确实跟圆形很接近，有时候会识别成圆形，但再往下调又会将圆形识别成矩形。
经过一个同学指导，才知道有个函数max_blob.solidity()，星瞳科技里面没有提及。这个函数配合识别矩形。
最终代码：
def detect(max_blob):#输入的是寻找到色块中的最大色块 row_data=[-1,-1]#保存颜色和形状 print(max_blob.solidity()) if max_blob.solidity()&gt;0.9 or max_blob.density()&gt;0.84: row_data[0]=max_blob.code() img.draw_rectangle(max_blob.rect()) row_data[1]=1#表示矩形 elif max_blob.density()&gt;0.6: img.draw_circle((max_blob.cx(), max_blob.cy(),int((max_blob.w()+max_blob.h())/4))) row_data[0]=max_blob.code() row_data[1]=2#表示圆形 elif max_blob.density()&gt;0.4: row_data[0]=max_blob.code() row_data[1]=3#表示三角形 return row_data #返回的是两个值，颜色和形状 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3dbea5f928df8e23de5c0d6ef16edb7/" rel="bookmark">
			i.MX 6ULL 驱动开发 一：搭建开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、搭建编译环境 1、工具 工具版本开发板正点原子 imx6ull 开发板gccgcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihfubootuboot-imx-2016.03-2.1.0linuxlinux-imx-4.1.15 2、搭建 tftp 服务器 ubuntu20.04 搭建tftp服务器_lqonlylove的博客-CSDN博客_ubuntu配置tftp服务器
3、搭建 nfs 服务器 ubuntu20.04 搭建NFS服务器_lqonlylove的博客-CSDN博客
二、配置编译工具链 1、版本选择 2、解压 sudo tar -vxf gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz 解压后名字太长，更改 gcc 文件夹名：
onlylove@ubuntu:~/my/gcc$ ls gcc-linaro-4.9.4 gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf.tar.xz onlylove@ubuntu:~/my/gcc$ 3、配置 打开/etc/profile 以后，在最后面输入如下所示内容：
export PATH=$PATH:/home/onlylove/my/gcc/gcc-linaro-4.9.4/bin 配置完后，重启主机。
4、验证 onlylove@ubuntu:~$ ls Desktop Documents Downloads Music my Pictures Public Templates Videos onlylove@ubuntu:~$ arm-linux-gnueabihf-gcc -v Using built-in specs. COLLECT_GCC=arm-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER=/home/onlylove/my/gcc/gcc-linaro-4.9.4/bin/../libexec/gcc/arm-linux-gnueabihf/4.9.4/lto-wrapper Target: arm-linux-gnueabihf Configured with: /home/tcwg-buildslave/workspace/tcwg-make-release/label/docker-trusty-amd64-tcwg-build/target/arm-linux-gnueabihf/snapshots/gcc-linaro-4.9-2017.01/configure SHELL=/bin/bash --with-mpc=/home/tcwg-buildslave/workspace/tcwg-make-release/label/docker-trusty-amd64-tcwg-build/target/arm-linux-gnueabihf/_build/builds/destdir/x86_64-unknown-linux-gnu --with-mpfr=/home/tcwg-buildslave/workspace/tcwg-make-release/label/docker-trusty-amd64-tcwg-build/target/arm-linux-gnueabihf/_build/builds/destdir/x86_64-unknown-linux-gnu --with-gmp=/home/tcwg-buildslave/workspace/tcwg-make-release/label/docker-trusty-amd64-tcwg-build/target/arm-linux-gnueabihf/_build/builds/destdir/x86_64-unknown-linux-gnu --with-gnu-as --with-gnu-ld --disable-libmudflap --enable-lto --enable-objc-gc --enable-shared --without-included-gettext --enable-nls --disable-sjlj-exceptions --enable-gnu-unique-object --enable-linker-build-id --disable-libstdcxx-pch --enable-c99 --enable-clocale=gnu --enable-libstdcxx-debug --enable-long-long --with-cloog=no --with-ppl=no --with-isl=no --disable-multilib --with-float=hard --with-mode=thumb --with-tune=cortex-a9 --with-arch=armv7-a --with-fpu=vfpv3-d16 --enable-threads=posix --enable-multiarch --enable-libstdcxx-time=yes --with-build-sysroot=/home/tcwg-buildslave/workspace/tcwg-make-release/label/docker-trusty-amd64-tcwg-build/target/arm-linux-gnueabihf/_build/sysroots/arm-linux-gnueabihf --with-sysroot=/home/tcwg-buildslave/workspace/tcwg-make-release/label/docker-trusty-amd64-tcwg-build/target/arm-linux-gnueabihf/_build/builds/destdir/x86_64-unknown-linux-gnu/arm-linux-gnueabihf/libc --enable-checking=release --disable-bootstrap --enable-languages=c,c++,fortran,lto --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux-gnu --target=arm-linux-gnueabihf --prefix=/home/tcwg-buildslave/workspace/tcwg-make-release/label/docker-trusty-amd64-tcwg-build/target/arm-linux-gnueabihf/_build/builds/destdir/x86_64-unknown-linux-gnu Thread model: posix gcc version 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3dbea5f928df8e23de5c0d6ef16edb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/52c02cfa29d2e089adee2bd6c91fdf73/" rel="bookmark">
			springboot在idea中可以访问jsp页面打包之后访问不了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、经过查阅各种资料 都无效 打出包效果图如下
打出来的包路径 确实没问题
但是打成jar包启动的时候 就是访问不到jsp页面，大难题
最后花了很长时间找到了有效的资料
（1）、为什么springboot集成jsp，访问会404.在springboot版本1.5中集成jsp，打完包访问界面会报404错误，我当时仔细找了一下原因，是因为springboot1.5的打包插件不支持jsp。用1.4版本打的jar包是没有问题的，当然ide工具运行也是没有问题的，所以你想用springboot1.5版本，在spring-boot-maven-plugin指定版本为1.4就可以了。其他的东西都是一样的。
（2）、在这里如果你的pom文件继承了springboot的父pom是1.5.3版本的，这里很坑一点就是
spring-boot-maven-plugin 1.5.3版本的打包控件打出来的jar包是无法访问jsp的，直接404，即使你的jsp文件打包进去了。
spring-boot-maven-plugin 1.4.2版本就是可以的
2、而且低版本打包spring-boot-maven-plugin1.4.2 打包时启动类所在包根目录里面必须只能有一个main方法的类也就是springboot启动类 有其他测试类包含main函数的打包会报错
而spring-boot-maven-plugin 1.5.2以上把 则没有上面那个问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb905460cd71aedfef5d46af42722611/" rel="bookmark">
			ViLT视觉文本多模态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		内容来自b站论文精讲：
https://www.bilibili.com/video/BV14r4y1j74y?vd_source=aaa7d9b5dd88818076af6aa4b9ae0d74
一.Introduction 为了输入VLP模型，图像像素（变成语义性的，离散性的特征）最初需要与语言标记一起以密集形式嵌入。自从Krizhevsky等人的开创性工作以来。（2012），深度卷积网络被认为是这一视觉嵌入步骤的关键。大多数VLP模型采用在视觉基因组数据集（Krishna et al.，2017）上预先训练的对象检测器，该数据集注释有1，600个对象类和400个属性类，如Anderson et al.(2018).
要获得语义离散特征：之前选择用目标检测器，原因（1）天然的离散化过程，一个个bounding box，明确的语义信息；（2）下游任务都跟物体有非常强的依赖性，检测到物体对任务的完成很关键。所以选择目标检测系统作为多模态的一部分非常合理。
之前工作的缺陷和不足： 目前VLP模型大多数用了预训练好的目标检测器，这个目标检测器是在visual genome dataset（1600个目标类别+400个属性类别）上面预训练的。选用该数据集的原因是：类别多，能够更好地和文本这边匹配起来，文本能够用单词来表示的类别是极其丰富的。为了比较的公平性，大家都用keishna2017的目标检测器。
但是用目标检测器去抽特征，太贵，一些工作尝试去降低计算量，比如：pixcel bert，它用了在imagenet上预训练好的残差网络，直接把残差网络得到的特征图当成是一个离散的序列。这样就只有backbone，没有目标检测相关的操作了，速度变快不少。
作者认为，用目标检测器和残差网络抽特征都还是太贵了。现在的工作主要还是关注视觉编码器的提升，从而能提升最后的性能。学术界优先考虑的性能，性能刷不动了才是速度和效率。其实在训练的过程中，大家可以提前把目标检测的特征都抽好，然后存在本地的硬盘上，训练的时候直接用就行。所以抽特征的过程是在线下完成的，早就已经把特征抽好存在硬盘上了，训练是很轻量的。但是真实世界实际应用的时候，数据都是实时生成的新数据，对新数据也要抽特征，推理的时候时间无法忽略。
因此本文希望获得轻量化更简单的图像特征抽取的方法。基于vit这篇论文的想法，vit在多模态领域里的应用：把图像打成patch，然后用一个简单的linuear projection层 把patch变成embedding的方式，从而取消掉图像特征抽取的过程。
用patch embedding去替换之前繁琐的抽特征的过程。
模型 vilt模型很简单，图1，看出怎么做的。
1.目标检测方式抽特征
先特征提取，再获得一个个物体；文本也获得序列。文本和图像的两个序列，直接连接在一起变成一个序列，再扔到一个模型中训练；本文序列扔到一个模型，图片序列扔到另一个模型，两个单独模态的模型在某个时间点上再做融合，成为two stream，两通道结构。
缺点：太贵了，backbone75m，后面目标检测专有的nms等占到8210ms。
改进：把目标检测的操作去掉。
2.网格特征
图片扔到卷积神经网络，最后一层比如7*7拉直成序列，好处是直接用卷积神经网络的特征图就够了，不需要用目标检测相关的东西。运行时间锐减到45ms.
缺点：速度还是不够。
3.本文
本文认为vit的patch embedding工作的很好。其中，vit论文中作者也对比过，前面只用一个简单的linear projection层和使用resnet50去抽取图像像素级别特征，效果差不多，甚至可学习的linear projection层表现的更好。因此本文中直接照搬，把cnn backbone换成linear embedding层，这个时候图像和文本完全对应起来，图像打成patch通过一个linear embedding层获得图像初始的token，文本通过linear embedding得到word token，然后都可以直接扔给transformer。
从时间上看，patch linear embedding非常快速，只需要0.4ms，基本不花什么时间。性能上，在NLVR2 test-P Acc./F30K TR R@1/F30K IR R@1这3个数据集上做了一些测试，看出还是第一种基于目标检测的方法达到的效果最好，网格的方法性能下降明显，vilt做了比较好的取舍，速度快，性能下降少。
vilt做的贡献： （1）目前最简单的做vision-and-language的模型，因为只用transformer做了模态间的融合之外，没有再用其他的模型了，而不需要残差网络甚至一些额外的目标检测的网络结构在里面。这个设计带来了非常显著的运行时间和参数量的减少。
（2）减少计算复杂度的同时，保证了性能能不掉。在不是用区域特征或者这种残差网络特征（原文：deep convolutional visiual embedders）的情况下，达到和之前差不多的效果。算是第一个做到的给工作。
（3）训练的时候用到了更多的数据增强的方式，文本中用到了整个词mask掉的方式，图片这边尝试使用了redmog（？）。这两种数据增强的方式，之前在多模态领域都没有被用过。因为多模态学习总要考虑图像文本对之间匹配的问题，不论给图像还是文本这边做了增强，往往可能导致图像文本对就不匹配了，不是正确的对了。之前的多模态学习就没有考虑用过强的数据增强的方式，但是vilt巧妙地利用了数据增强的方式，稍微改了一带你，然后发现效果非常好。即使图像文本对有很多，用了数据增强之后，效果还是会更好。（对于当时的多模态领域也是第一次）
总体而言，vilt提出了一个非常简单而且强大的基线模型，得出了很多很有意思的结论、很多对训练有帮助的小技巧，然后再加上transformer在视觉领域的大杀四方，所以在多模态领域新工作也如雨后春笋一般冒出来了。
二、背景知识 写的像综述论文，现在vlp大概可以分为哪几类，当有了文本和图像的token之后怎么去做图像间的融合，因为文本抽特征都是一样的，就把图像怎么抽特征进行单独介绍（从一开始的目标检测的区域特征，到使用残差网络最终的特征图，到最新的vit出来，用一个简单的linear projection layer，完成对视觉特征的抽取）。
2.1 领域中对模型的划分 为了介绍好vilt突出其优势，煞费苦心。
先做了一个总结，对现在所有的vlp的模型做了一个分类，根据两点（1）怎么从各个模态上先抽一些特征、先做一些预处理：图像和文本表达力度是否平衡：参数量、计算量；（理论上应该差不多，不应该像现在大多数方法一样视觉比文本贵很多）（2）这两个模态怎么去融合。
根据这两点，把所有方法分成了四个类。
ve：怎么抽图像特征；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb905460cd71aedfef5d46af42722611/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6270e26f84dc57e3389428d682e5c2c2/" rel="bookmark">
			益智游戏日历拼图解法：搜索&#43;回溯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这个是某夕夕上最近很火的一款益智小游戏，版面设计看起来也很nice！那么类似这种游戏对于程序员的正确打开方式还是写个程序解决，并没有什么益智不益智，因为说实话拼这个东西还是太费力了。
那么怎么解决这个问题呢？很明显先把盘子还有各个小块的形状记录起来，盘子用一个全局数组，而小块则用一个结构体node，还要存储长宽，并且有旋转等函数，然后采用深度优先搜索算法（DFS，这是一个很基础的算法，还没了解的应该先了解），注意回溯，然后就能罗列所有的情况，这个（右边的）差不多是7*7大小的，并且总共有8个小块，那么每个小块大概有7*7*8种放置的方式（加上旋转和翻转，一开始没想到翻转搞多了很多时间），因此计算量（粗略的说法，放置一块的意思，包括判断、更新数组等等操作）就最多是(7*7*8)^8次（大概五万亿亿次，粗略算1亿次1秒，但是加上很多不可能的情况（判断一下就过了）还有剪枝（去掉了极多的情况），还有这个是最大估计，其实远小于五万亿秒，本人跑了半个多小时，虽说还是不少）。再加上适当判断，排序，存文件等等，我们就能愉快的完成任务了！话不多说，代码如下：
#include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;fstream&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; const int ma[12] = { 31,29,31,30,31,30,31,31,30,31,30,31 }; int day_num = 0; int pan[10][10]; struct node { node() { memset(arr, 0, sizeof arr); } int n, m; int c; bool st[2][4];//哪几次旋转是没用的 bool arr[10][10]; void rotate()//有些可能转了等于没转，所以要四种状态都存起来 { bool tmp[10][10]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { tmp[j][n - 1 - i] = arr[i][j]; } } memcpy(arr, tmp, sizeof arr); swap(n, m); } void flip() { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m / 2; j++)//要不然白换了 { swap(arr[i][j], arr[i][m - 1 - j]); } } } void judge() { memset(st, 0, sizeof st); bool tmp[8][10][10]; memset(tmp, 0, sizeof tmp); int cnt = 0; for (int t = 0; t &lt; 2; t++) { for (int i = 0; i &lt; 4; i++) { bool FLAG = 1; for (int j = 0; j &lt; cnt; j++) { bool flag = 0; for (int ii = 0; ii &lt; n; ii++) { for (int jj = 0; jj &lt; m; jj++) { if (tmp[j][ii][jj] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6270e26f84dc57e3389428d682e5c2c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96be1119a916fc060b72a8a51536fa83/" rel="bookmark">
			顺序表的查找----按位查找与按值查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		按位查找 #define _CRT_SECURE_NO_WARNINGS 1 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define InitSize 10 typedef struct { int* data; int MaxSize; int length; }SqList; //初始化表 void InitList(SqList&amp; L) { L.data = (int*)malloc(InitSize * sizeof(int)); L.length = 0; L.MaxSize = InitSize; } //按位查找 int GetElem(SqList&amp; L, int i) { return L.data[i - 1]; } int main() { SqList L; InitList(L); //插入元素 for (int i = 0; i &lt; 10; i++) { L.data[i] = i; L.length++; } //打印元素 for (int i = 0; i &lt; 10; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96be1119a916fc060b72a8a51536fa83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/093d1d9057d8988d3ff07887636426b6/" rel="bookmark">
			Vscode——注释快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		块注释：Ctrl + Shift + /单/多行注释：Ctrl + / 参考文章：vscode多行注释，自定义按键多行注释
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32cc35e312992eeec919a47fa8166056/" rel="bookmark">
			BroadcastReceiver 动态注册
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AlarmManger和BroadcastReciever执行定时任务，在连网时可正常运行，但无网络或wifi、移动数据同时开时，reciever接收不到信息。 添加 alarmReceiver.onReceive(context,intent); 后问题解决
执行定时任务 AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
IntentFilter filter = new IntentFilter();// 动态注册
filter.addAction("tPhoto");
registerReceiver(alarmReceiver, filter);//注册
Intent intent = new Intent();
intent.setAction("tPhoto");
nowInfo.setText(CONST.nowExe);
PendingIntent pi = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
am.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), 1000 * 60 * CONST.inVal, pi);// 马上开始，**分钟触发一次
alarmReceiver.onReceive(context,intent);//接收
接收 BroadcastReceiver alarmReceiver = new BroadcastReceiver() {
@Override
public void onReceive(Context context, Intent intent) {
if ("tPhoto".equals(intent.getAction())) {
nowInfo.setText("开始运行任务"); } else {//sysTime &gt;= stopTime nowInfo.setText("暂停等待");
}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32cc35e312992eeec919a47fa8166056/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de11b397ecb505de14352f46847dbca7/" rel="bookmark">
			UML类图六种连接方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UML常用箭头 理解
主要分三类/六种： 继承、实现 : 空心三角+ 实线/虚线
依赖、关联 角+实线/虚线
组合、聚合 实心/空心棱形+ 实线
参照UML图理解、记忆
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ee97e55ea4e0c103a2bd0516fb4f1c6/" rel="bookmark">
			微信小程序：module “miniprogram_npm/@vant/weapp/action-sheet/index.js“ is not defined报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 也可以试一下重新启动小程序，没准就好了。 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/220/">«</a>
	<span class="pagination__item pagination__item--current">221/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/222/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>