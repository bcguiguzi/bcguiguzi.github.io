<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30517c780b1bf45cd13c61098d6255b5/" rel="bookmark">
			java pfx 证书_Java将pfx证书转换为jks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		packagecom.yangangus.util;importjava.io.FileInputStream;importjava.io.FileOutputStream;importjava.io.IOException;importjava.security.Key;importjava.security.KeyStore;importjava.security.cert.Certificate;importjava.util.Enumeration;public classConventPFXToJKS {public static final String PKCS12 = "PKCS12";public static final String JKS = "JKS";public static final String PFX_KEYSTORE_FILE = "D:\\temp\\certs\\wildcard_test_com.pfx";//pfx文件位置
public static final String PFX_PASSWORD = "pfx_password";//导出为pfx文件的设的密码
public static final String JKS_KEYSTORE_FILE = "D:\\temp\\certs\\keystore.jks"; //jks文件位置
public static final String JKS_PASSWORD = "jks_password";//JKS的密码
public static voidcoverTokeyStore() {
FileInputStream fis= null;
FileOutputStream out= null;try{
KeyStore inputKeyStore= KeyStore.getInstance("PKCS12");
fis= newFileInputStream(PFX_KEYSTORE_FILE);char[] pfxPassword = null;if ((PFX_PASSWORD == null) || PFX_PASSWORD.trim().equals("")) {
pfxPassword= null;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30517c780b1bf45cd13c61098d6255b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df802a56d73e09d7d20a464765e16259/" rel="bookmark">
			java线程池用法_Java线程池的四种用法与使用场景
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、如下方式存在的问题
new Thread() {
@Override
publicvoid run() {
// 业务逻辑
}
}.start();
1、首先频繁的创建、销毁对象是一个很消耗性能的事情;2、如果用户量比较大，导致占用过多的资源，可能会导致我们的服务由于资源不足而宕机;3、综上所述，在实际的开发中，这种操作其实是不可取的一种方式。
二、使用线程池有什么优点
1、线程池中线程的使用率提升，减少对象的创建、销毁;2、线程池可以控制线程数，有效的提升服务器的使用资源，避免由于资源不足而发生宕机等问题;
三、线程池的四种使用方式
1、newCachedThreadPool
创建一个线程池，如果线程池中的线程数量过大，它可以有效的回收多余的线程，如果线程数不足，那么它可以创建新的线程。
publicstaticvoid method() throws Exception {
ExecutorService executor = Executors.newCachedThreadPool();
for(inti = 0; i final intindex= i;
Thread.sleep(1000);
executor.execute(new Runnable() {
@Override
publicvoid run() {
System.out.println(Thread.currentThread().getName() +" "+index);
}
});
}
}
执行结果
通过分析我看可以看到，至始至终都由一个线程执行，实现了线程的复用，并没有创建多余的线程。如果当我们的业务需要一定的时间进行处理，那么将会出现什么结果。我们来模拟一下。
可以明显的看出，现在就需要几条线程来交替执行。
不足：这种方式虽然可以根据业务场景自动的扩展线程数来处理我们的业务，但是最多需要多少个线程同时处理缺是我们无法控制的;
优点：如果当第二个任务开始，第一个任务已经执行结束，那么第二个任务会复用第一个任务创建的线程，并不会重新创建新的线程，提高了线程的复用率;
2、newFixedThreadPool
这种方式可以指定线程池中的线程数。举个栗子，如果一间澡堂子最大只能容纳20个人同时洗澡，那么后面来的人只能在外面排队等待。如果硬往里冲，那么只会出现一种情景，摩擦摩擦...
首先测试一下最大容量为一个线程，那么会不会是我们预测的结果。
publicstaticvoid method_01() throws InterruptedException {
ExecutorService executor = Executors.newFixedThreadPool(1);
for(inti = 0; i Thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df802a56d73e09d7d20a464765e16259/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d1c38d2ad60fe7ef13fcff98b76ed8e/" rel="bookmark">
			java获取项目名称_java获取访问路径、域名、项目名、请求入参
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说(这句不是废话吗&gt;&gt;)，直接提出可以运行的类，你放到一个web项目访问下就知道了。
//测试页面-跳转到输入数据的form表单
public String test1(){
ActionContext ctx = ActionContext.getContext();
HttpServletRequest request = (HttpServletRequest)ctx.get(ServletActionContext.HTTP_REQUEST);
HttpServletResponse response = (HttpServletResponse)ctx.get(ServletActionContext.HTTP_RESPONSE);
String url = request.getScheme()+"://"+ request.getServerName()+request.getRequestURI()+"?"+request.getQueryString();
System.out.println("获取全路径(协议类型：//域名/项目名/命名空间/action名称?其他参数)url="+url);
String url2=request.getScheme()+"://"+ request.getServerName();//+request.getRequestURI();
System.out.println("协议名：//域名="+url2);
System.out.println("获取项目名="+request.getContextPath());
System.out.println("获取参数="+request.getQueryString());
System.out.println("获取全路径="+request.getRequestURL());
return "success";
}
2016-05-05
补充：一般而言，端口默认为80的时候是不需要显性说明的，但是在端口不为80的时候是需要的，即使在存在域名的情况下，这样在测试的时候，我们应该把端口也加到路径中
request.getServerPort()
2018-08-21
logger.info("path="+path);// /webrecord
logger.info("RequestURI="+request.getRequestURI());// /webrecord/toindex
logger.info("RequestURL="+request.getRequestURL());// http://localhost:8085/webrecord/toindex
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a4e29eab15084eccf87278fbc51d4f0d/" rel="bookmark">
			java 解压文件_java实现解压zip文件，(亲测可用)！！！！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目结构：
Util.java内容：
package com.cfets.demo;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
public class Util {
public static void main(String[] args) {
// 文件存放位置
String zipPath = "download/资产支持证券信用评级_20180820.xml.zip";
File zipFile = new File(zipPath);
String descDir = "download/";
boolean flag = unZip(zipFile, descDir);
System.out.println("解压成功还是失败=" + flag);
}
/**
* 解压zip文件
*
* @param zipFile目标文件
* @param descDir解压后存放的位置
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a4e29eab15084eccf87278fbc51d4f0d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e8f116b6b0cc7f634421d66461d2e30/" rel="bookmark">
			ICPC 南昌现场赛 K：Tree（dsu on tree &#43; 动态开点线段树）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tree 让我们找满足一下五个条件的 ( x , y (x, y (x,y)点对有多少：
x ≠ y x \neq y x​=y x x x不是 y y y的祖先 y y y不是 x x x的祖先 d i s ( x , y ) ≤ k dis(x, y)\leq k dis(x,y)≤k z z z是 x , y x, y x,y的最近公共祖先， v a l u e x + v a l u e y = 2 v a l u e z value_x + value_y = 2value_z valuex​+valuey​=2valuez​。 读题目观察到每个节点的 v a l u e value value只有 [ 0 , 1 0 5 ] [0, 10 ^ 5] [0,105]（如果不是的话，也可离散化处理一下吧），所以我们可以建立 1 0 5 10 ^ 5 105棵线段树，每棵线段树里面记录的是点权为 i i i的节点的深度信息，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e8f116b6b0cc7f634421d66461d2e30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ccdcb6c1c9355095bf9e1c1f11ae50/" rel="bookmark">
			python opencv 锐化_opencv实现图片模糊和锐化操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文为大家分享了opencv图片模糊和锐化的具体实现代码，供大家参考，具体内容如下
一、模糊操作
#!/usr/bin/env python
# _*_ coding:utf-8 _*_
import cv2 as cv
import numpy as np
def blur_demo(image):
dst = cv.blur(image, (15, 1))
cv.imshow("blur_demo", dst)
src = cv.imread("F:\miao3.png")
cv.namedWindow("input image", cv.WINDOW_AUTOSIZE)
cv.imshow("input image", src)
blur_demo(src)
cv.waitKey(0)
cv.destroyAllWindows()
运行结果，如图：
二、锐化操作
#!/usr/bin/env python
# _*_ coding:utf-8 _*_
import cv2 as cv
import numpy as np
def custom_blur_demo(image):
kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]], np.float32) #锐化
dst = cv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ccdcb6c1c9355095bf9e1c1f11ae50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1cdf935d9b0443ef577153f8dbd7239/" rel="bookmark">
			C&#43;&#43;中10的N次方如何表示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		例如10的3次方
第一种方法：1e+3，10的-3次方则后面添上负号即1e-3，e前面必须要有数字。
第二种方法：利用函数pow(x,y);
即pow(10,3);注意要加上头文件cmath。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/553cb9e80ab7ce63494c0c6d6b75a68e/" rel="bookmark">
			mysql查看表字段_mysql如何查询表字所有字段？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mysql查询表字所有字段的方法：使用“SHOW FROM”语句配合FULL关键字来查询，语法“SHOW FULL COLUMNS FROM table_name”，可以显示指定数据表的所有字段信息。
mysql查询表字所有字段
1、查看所有表名：show tables [from db_name];
2、查看字段信息SHOW FULL COLUMNS FROM table_name
获取以下信息
Field ：字段名
Type：字段类型
Collation：字符集(mysql 5.0以上有)
Null ：是否可以为NULL
Key：索引(PRI,unique,index)
Default：缺省值
Extra：额外(是否 auto_increment)
Privileges：权限
Comment：备注(mysql 5.0以上有)mysql&gt; create table teacher # 创建teacher表
-&gt; (
-&gt; Id int (5) auto_increment not null primary key,
-&gt; name char(10) not null,
-&gt; address varchar(50) default 'No.1 Mid school',
-&gt; year date
-&gt; );
Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/553cb9e80ab7ce63494c0c6d6b75a68e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dabbd46fdaecf0abbd2eda434cfa3705/" rel="bookmark">
			MySQL数据库入门学习  #CSDN博文精选# #IT技术# #数据库# #MySQL#
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，小C将继续与你们见面，带来精选的CSDN博文~
又到周一啦，上周的系统化学习专栏已经结束，我们总共一起学习了20篇文章，这周将开启全新专栏《放假不停学，全栈工程师养成记》
在这里，你将收获：
将系统化学习理论运用于实践，系统学习IT技术学习内容涵盖数据库、软件测试、主流框架、领域驱动设计和第三方生态等，离全栈工程师更近一步精心整理的CSDN技术大咖博文，假期学习实现弯道超车 下面就进入这个专栏的第一天学习吧~
本文转自CSDN博主@数学家是我的理想
1. 前言 作者作为一名大二在校生，因为正在学习网页设计，考虑到后台问题，所以便自学了数据库，可能给大家总结的不是很全，但是一些必要的点肯定会讲到。现在市场上有很多图形化的数据库，没有什么可讲的，读者如果愿意，自行下载研究即可，本文章讲的全是在DOS环境下的一系列操作。
2. MySQL基础知识 MySQL经常和“数据库”连在一起读，这很容易对新手造成误解，认为MySQL就是一个数据库，其实不是这样，MySQL是数据库的集合，MySQL里面有很多数据库，那么数据是直接存在数据库里的吗？并不，数据库底下还有一个叫做数据表的存储单元，数据表里面才存储数据。打个比方，好比一座大图书馆，就是MySQL，图书馆里面分南库，北库，这就是数据库，每个库里面的书都是放在书架上的，书架就是数据表，而放在书架上的很多本书，就是数据。这么说，读者应该理解了吧，所以按大小顺序排个序就应该是，MySQL&gt;数据库&gt;数据表&gt;数据，所以我们接下来的内容也是按照这个顺序来展开。
3. 进入MySQL 工欲善其事必先利其器，如果连MySQL如何打开都不知道，那如何进行操作学习呢，所以接下来讲解的就是，如何在DOS环境下进入MySQL。
在这里，我们首先找到MySQL的安装路径，找到“bin”文件夹下的“mysql.exe”，记住这个路径，然后在DOS环境下输入你的路径“D:\BtSoft\WebSoft\mysql\MySQL5.7\bin\mysql -uroot -p”，这里解释一下后面加上“-uroot -p”的作用，因为进入MySQL是需要账号密码进行登陆的，账号密码默认都是“root”，所以当你输完路径之后，摁下回车，就会要求你输入密码。
既然讲到了账号密码，这里就给大家补充一点，如何免密码登陆
打开MySQL安装的文件夹，在里面找到一个名为“my.ini”的配置文件，通过记事本或者其他文本编辑的方式打开，在“[mysqld]”的下面加上一句话“skip-grant-tables”然后重启MySQL服务即可
再次进入MySQL的时候，出现“Enter password”要你输入密码，直接摁回车即可。然后会列出一系列MySQL的版本信息，不用管他，现在可以看到，底下出现了一个“mysql＞”接下来就可以对MySQL数据库进行操作了
**4.数据库的基本操作 ** 1. 查询数据库
show databases; 下面图片上展示的就是你当前有哪些数据库，这里因为作者之前创建过一些数据库，所以读者如果是第一次查询，可能我图片上的某些数据库你没有，这没有关系。这里要注意，因为数据库不止一个，即便是刚安装好的MySQL，里面默认存在的数据库也不止一个，所以是“databases”，千万别漏了“s”。
2. 创建数据库
create database XX(数据库名); 这里我创建了一个名为“hello”的数据库，显示“OK”，表示成功
在这里给大家补充一点，创建数据库的时候，默认的字符是”latin“，也就是拉丁文，现在读者可能体会不到有什么区别，等到数据表的操作的时候再讲。不过这里还是告诉大家，如何创建数据库的时候，自己定义为什么字符
create database XX(数据库名) charset = (字符编码，例如utf8); 我们平时学的中文的字符编码是“utf-8”，但是在MySQL里面，中文字符编码是“utf8”，这点希望读者注意。
创建数据库还有一些细节性的操作，这里也给读者提一下。
如果我们创建已存在的数据库，会发生什么事呢？下面我就创建一个已经存在的“test”数据库
果然，报错了，它告诉我，不能创建数据库“test”，因为这个数据库已经存在了，所以我们创建数据库的时候判断一下，如果不存在就创建
create database if not exists XX(数据库名); 这段代码的好处是显而易见的，在我们这里可能体现不出来，但如果是做项目的时候或者在企业中，数据库非常非常多，你用肉眼看都要看花了，到底哪些数据库已经存在了，名字被用过了？所以就可以用上面这句代码，下面我们用这段代码创建一下“test”数据库，看会发生什么事情
看到没，显示“OK”，没有报错了，但是有一个警告，这个警告就是告诉用户，”test“这个数据库存在。
还有个问题，有的人创建数据库起的名字和关键字相同，会发生什么呢？（关键字就是MySQL中有特定作用的词，比如说“show”、“create”）
这里英文太长了，有兴趣的读者可以自己去翻译一下，但是这里我们可以确实看到的是，名为“create”的这个数据库没有创建成功，报错了，那如果有的人说我就想创建一个名为“create”的数据库，怎么办呢？下面给出解决办法
create database `XX`(数据库名);(注意，这里``是反引号，在键盘tab上面) 3. 显示数据库信息
show create database XX(数据库名); 这里可以看到，我刚才创建的“test”数据库，默认的字符是拉丁的，我之前创建的数据库，我设定了它的字符是中文，所以显示是“utf8”
4. 更改数据库的字符编码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dabbd46fdaecf0abbd2eda434cfa3705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/00326c3dde03895946444e642574d1ac/" rel="bookmark">
			京东联盟高级API - 高并发京东联盟转链接口 京东客转链接口 京粉转链接口 京东联盟返利接口 京东返利接口，线报无广告接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		京东联盟高级API - 高并发京东联盟转链接口 京东客转链接口 京粉转链接口 京东联盟返利接口 京东返利接口，线报无广告接口
##共京荣开放平台
接口支持商品链接，活动链接，店铺链接转链，获取普通推广链接和优惠券二合一推广链接，转链后下单佣金归自己所有，结算后可以在京东联盟提现。
1、注册共京荣开放平台账号
注册地址: http://interface.mkstone.club/
2、获取接口秘钥apikey
登录个人中心 - 系统设置 - 接口管理 找到接秘钥apikey，apikey 接口秘钥是调用接口的唯一凭证，请妥善保管!
3、事先准备好京东联盟转链接口所需要的unionId参数，获取方式：打开并登录京东联盟（https://union.jd.com/index）＝》账户管理
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49f338e0f21b230474c214a95619ad10/" rel="bookmark">
			使用 XAML 格式化工具：XAML Styler
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. XAML 格式化主要的难题是下面几个： 如果所有属性都写在同一行，它太宽了很难看到后面的属性如果每个属性单独一行，它又太长了很难看清楚它的结构属性之间没有排序，重要属性的属性找起来很困难团队没有统一的标准，不小心格式化一下代码的话全部都会变，CodeReview 烦死个人 如果不想得过且过忍受上述这些问题的话，可以试试用 XAML Styler 这个工具，它正好解决了我最想解决的问题。
2. 安装 XAML Styler XAML Styler 是一个 VisualStudio插件（也可用于其它 IDE），这是它在 Github 上的地址：
https://github.com/Xavalon/XamlStyler
在这里你可以找到具体的文档，而这篇文章我只介绍我关心的其中几个属性，不一定满足到你。
在 VisualStudio 的管理扩展窗口中，输入 XamlStyle 搜索，点击“下载”然后关闭 VisualStudio 即可完成安装。
安装完成后重启 Visual Studio，可以在“选项”窗口中看到它的配置：
之后，每次在 XAML 编辑器中执行保存都会自动进行格式化操作。你也可以在 XAML 编辑器的右键菜单选择 Format XAML 或使用快捷键进行格式化。
3. 格式化 XAML 的格式主要有两种方式：所有属性放一行和每个属性单独一行。
如果选择所有属性放一行的时候，XAML 结构清晰，结构严谨，段落分明，而且文件也很短。
可是万一很多属性问题就出来了，一行 XAML 会变得很长。而且看看下面两个 ContentPresenter，同样都有 Margin 属性、HorizontalAlignment 属性，VerticalAlignment 属性，RecognizesAccessKey 属性，SnapsToDevicePixels 顺序ing，但你能看到第二个 ContentPresenter 后面偷偷塞了个 Margin 吗：
&lt;ContentPresenter Margin="{TemplateBinding Padding}" HorizontalAlignment="{TemplateBinding HorizontalContentAlignment}" VerticalAlignment="{TemplateBinding VerticalContentAlignment}" RecognizesAccessKey="True" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49f338e0f21b230474c214a95619ad10/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4235207f2b0cfca46a33d49b3473a60c/" rel="bookmark">
			mysql 数据仓库 元数据_002.hive数据仓库建模和元数据备份
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数据建模
装逼的解释：
是指 对现实世界各类数据的抽象组合，确定数据库需管辖的范围、数据的组织形式等直至转化成现实的数据库。
通俗的说：
1.概念建模阶段： 就是对业务的梳理和理解(1.客户交流 2.需求理解 3.形成实体)
2.逻辑建模阶段： 对实体进行细化，细化成具体的表，同时丰富表结构(表／列／索引／约束／视图／存储过程 等等)
3.物理建模阶段： 对逻辑建模建模阶段的各种数据库对象 生成 相应的SQL代码，运行来创建相应具体数据库对象。
2.多维数据模型的模式
这个的确需要很丰富的经验，对于我来说这个仅仅只是局限在大致了解。
1.星型
一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度，所以数据有一定的冗余。
￼ 2.雪花型
雪花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的 "层次 " 区域，这些被分解的表都连接到主维度表而不是事实表，通过最大限度地减少数据存储量以及联合较小的维表来改善查询性能。雪花型结构去除了数据冗余。
￼ 3.事实星座
又称星系模式，复杂的应用可能需要多个事实表共享维表。这种模式可以看作星形模式集。
￼ 3.元数据：MetaStore
1.相关概念
元数据服务组件，这个组件存储hive的元数据，hive的元数据存储在关系数据库里，hive支持的关系数据库有derby、mysql。元数据对于hive十分重要，因此hive支持把metastore服务独立出来，安装到远程的服务器集群里，从而解耦hive服务和metastore服务，保证hive运行的健壮性。
2.表介绍
￼ 其中主要涉及到的表如下：
表名
说明
关联键
TBLS
所有hive表的基本信息(表名，创建时间，所属者等)
TBL_ID,SD_ID
TABLE_PARAM
表级属性，(如是否外部表，表注释，最后修改时间等)
TBL_ID
COLUMNS
Hive表字段信息(字段注释，字段名，字段类型，字段序号)
SD_ID
SDS
所有hive表、表分区所对应的hdfs数据目录和数据格式
SD_ID,SERDE_ID
SERDE_PARAM
序列化反序列化信息，如行分隔符、列分隔符、NULL的表示字符等
SERDE_ID
PARTITIONS
Hive表分区信息(所属表，分区值)
PART_ID,SD_ID,TBL_ID
PARTITION_KEYS
Hive分区表分区键(即分区字段)
TBL_ID
PARTITION_KEY_VALS
Hive表分区名(键值)
PART_ID
3.Hive 将元数据存储在 RDBMS 中，有三种模式可以连接到数据库
1.Single User Mode： 此模式连接到一个 In-memory 的数据库 Derby，一般用于 Unit Test。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4235207f2b0cfca46a33d49b3473a60c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4574f12f6bea4eca823aaa431b4ab5b6/" rel="bookmark">
			JDK1.8中英文官方文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JDK1.8中文文档和英文文档，学习java必不可少的官方文档，帮助你更清晰的各个包的结构和相关API。
链接：https://pan.baidu.com/s/1LJj8e0p1qUrSE_GKLDgB4Q
提取码：qh56
中文界面展示
英文界面展示
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e32057c3af33024c0a2030b15e3ffb59/" rel="bookmark">
			使用WDF开发驱动程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 使用WDF开发驱动程序 Windows驱动程序框架（WDF）驱动程序由基于框架的驱动程序所使用的Windows驱动程序框架对象定义的DriverEntry 例程和一组事件回调函数组成。 创建WDF驱动程序时，执行操作： 使用框架驱动程序对象来表示驱动程序
驱动程序的DriverEntry 例程必须调用WdfDriverCreate以创建表示驱动程序的框架驱动程序对象。
WdfDriverCreate方法还会注册驱动程序的EvtDriverDeviceadd回调函数即插即用，该函数（PnP）管理器报告驱动程序支持的设备是否存在。
使用框架设备对象支持驱动程序中的PnP和电源管理
所有驱动程序都必须调用WdfDeviceCreate，以便为驱动程序支持的设备创建框架对象。
设备可以是插入到计算机中的一片硬件，也可以是仅限软件的设备。
框架设备对象支持PnP和电源管理操作，驱动程序可以注册事件回调函数，以便在设备进入或离开其工作状态时通知驱动程序。
使用框架队列对象和框架请求对象来支持驱动程序的i/o操作
从应用程序或其他驱动程序接收读取、写入或设备i/o控制请求的所有驱动程序都必须调用WdfIoQueueCreate，以创建表示i/o列队的框架列队对象。
驱动程序会为每个i/o队列注册一个或多个请求处理程序。
当i/o管理器向驱动程序发送i/o请求时，框架将为请求创建一个框架请求对象，将该请求对象放置在i/o队列中，并调用驱动程序的一个请求处理程序来通知驱动程序请求可用。
该驱动程序将获取i/o请求，并可以重新排队、完成、取消或转发该请求。
使用框架中断对象来处理设备中断
处理设备中断的驱动程序必须调用WdfInterruptCreate，以便为每个中断创建框架中断对象并注册回调函数。
这些回调函数启用和禁用中断，并充当中断服务例程（ISR），并为中断（DPC）延迟过程调用。
KMDF驱动程序可以使用框架的DMA启用码对象和DMA事务对象来处理设备（DMA）操作的直接内存访问
如果KMDF驱动程序的设备支持DMA操作，驱动程序应调用WdfDmaEnablerCreate来创建DMA启用程序对象，并使用WdfDmaTransactionCreate创建一个或多个DMA事务对象。
DMA transaction 对象定义于计划设备硬件执行DMA操作的EvtProgramDma回调函数。
使用框架的i/o目标对象将i/o请求发送到其他程序
若要将i/o请求传递到其他驱动程序（通常是驱动程序堆栈）中的下一个较低驱动程序，则驱动程序将请求发送到i/o目标对象。
KMDF驱动程序可以使用框架的wmi提供程序对象和wmi实例对象来支持（WMI）功能Windows Management Instrumentation
大多数KMDF驱动程序应支持WMI，并应调用WdfWmiInstanceCreate来注册发送或接收WMI数据的回调函数。
使用框架的同步功能
所有驱动程序都必须了解多处理器同步问题，并应使用框架提供的同步技术。
WDF体系结构 WDF为驱动程序提供了基于对象的接口，框架定义的对象接口包含：
对象方法
方法是驱动程序可以调用以对象执行操作或获取或设置对象属性的函数。
方法名为WdfObjectAction，其中对象描述对象，操作指示函数的作用。
例：WdfDeviceCreate创建设备对象。
对象事件回调函数
事件回调函数是驱动程序提供的函数。每个事件回调函数都与某个对象上可能发生的特定事件关联。当发生关联的事件时，框架将调用事件回调函数。
例：驱动程序将注册EvtDeviceD0Entry事件回调，以便在设备进入工作状态时收到通知。
对象属性
属性是存储在对象中的值，并且驱动程序可以获取并设置（即，更改）。在许多情况下，属性直接映射到相应的WDM对象中的字段。
不能失败的属性命名为WDF对象获取值和WDF对象集值，并且可能失败的属性被命名为WDF对象检索值和对象赋值。
对象描述对象，值标志函数设置或返回的数据。
例：WDfDeviceGetDriver返回与设备对象相关联的驱动程序对象的句柄。
对象句柄
基于框架的驱动程序绝不会直接访问框架对象。相反，驱动程序将接收对象句柄，该句柄可传递给对象的方法。
框架定义了基于框架的驱动程序使用的多种对象类型 框架驱动程序对象表示每个驱动程序。框架设备对象表示驱动程序支持的每个设备。框架队列对象代表接收设备i/o请求的i/o队列。Framework 请求对象表示每个i/o队列接收的i/o请求数。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae9e1bf53a1c7a42a87f6bb64306288d/" rel="bookmark">
			idea部署失败怎么解决_解决IDEA Java Web项目没问题，但部署时出错的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果确定代码没问题，那多半是项目中用到的库没有被Tomcat复制到部署位置的lib目录下。
点击调试/运行，看到控制台Tomcat在部署，但一直不弹出浏览器页面，Tomcat控制台报错如下：
是在Artifact部署期间出的错。Tomcat没有把项目所需的所有jar包复制到部署目录的lib下。
有2种可能：
(1)项目本身的所需的jar包没有添加全。开发者的问题。
(2)项目本身需要的jar添加全了，但部署时Tomcat没有复制到部署目录的lib下，Tomcat的问题。(可以打开部署目录的lib看，如果一个jar包都没有，说明是Tomcat的问题)
解决方式：
Project Structure -&gt; Project Settings
1、先看Modules中是否包含了所需的全部jar包
2、再看Artifacts
我们看到右下角有一个“Fix...”按钮，说明Artifacts存在问题，如果Artifacts是正常的，右下角是没有这个“Fix....”按钮的。
点击“Fix...”修复即可。
选第二个，添加所有缺失的依赖(jar包)。
说明：需要重启Tomcat才能生效，因为要重新部署项目，把项目所需的jar包都复制到部署目录的lib下。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b10e3c3e7d38bb81ac20adb4398a32b5/" rel="bookmark">
			arcgis 将栅格值提取到点_Arcgis中怎么把栅格数据中大于某值的区域提取出来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开全部
工具箱中spatial analyst tools \ extraction \ extract by attributes工具，e68a84e8a2ad62616964757a686964616f31333431373861用简单的SQL语句就能实现。
更新：update table1 set field1=value1 where 范围
查找：select * from table1 where field1 like ’%value1%’ (所有包含‘value1’这个模式的字符串)
排序：select * from table1 order by field1,field2 [desc]
求和：select sum(field1) as sumvalue from table1
平均：select avg(field1) as avgvalue from table1
扩展资料：
1、对象类(Object class)
在Geodatabase中对象类是一种特殊的类，它没有空间特征，是指存储非空间数据的表格(Table)。
2、要素类(Feature class)
同类空间要素的集合即为要素类。如：河流、道路、植被、用地、电缆等。要素类之间可以独立存在，也可具有某种关系。当不同的要素类之间存在关系时，我们将其组织到一个要素数据集(Feature dataset)中。
3、要素数据集(Feature dataset)
要素数据集由一组具有相同空间参考(Spatial Reference)的要素类组成。
将不同的要素类放到一个要素数据集下一般有三种情况：
专题归类表示——当不同的要素类属于同一范畴。
创建几何网络——在同一几何网络中充当连接点和边的各种要素类，须组织到同一要素数据集中。
4、考虑平面拓扑(Planar topologies)——共享公共几何特征的要素类。
存放了简单要素的要素类可以存放于要素集中，也可以作为单个要素类直接存放在Geodatabase的目录下。直接存放在Geodatabase目录下的要素类也称为独立要素类(standalone feature)。存储拓扑关系的要素类必须存放到要素集中，使用要素集的目的是确保这些要素类具有统一的空间参考，以利于维护拓扑。Geodatabase支持要素类之间的逻辑完整性，体现为对复杂网络(complex networks)、拓扑规则和关联类等的支持。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a95a7b7988d094fbb0fcc28bff776cd2/" rel="bookmark">
			基于点、线数据三维地质建模方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**
基于点、线数据三维地质建模方法 **
1.前言 作者本人计算机出身，近一年多负责公司地质建模项目项目工作，项目关联计算机、采矿行业相关技术。本文章主要介绍采矿行业地质建模及模型更新相关数字化自动更新技术，不专业之处，请谅解。下图为本人设计开发的地质建模整模块，后续将会详细讲解各模块功能。
2.简介 何为矿体建模？何为隐式建模？
矿体建模的对象是矿体结构模型。我们根据表达方式的不同将矿体建模方法分为两大类型：显式建模与隐式建模。显式建模方法采用网格模型来显式表达矿体的几何模型，首先确定剖面，并在剖面上绘制岩性、断层和矿脉，然后手工地绘制剖面连线来连接跨多个截面的曲面，这种方式建立地质模型既耗时又不灵活，因为当有更多数据可用时，很难更新模型。隐式建模方法则采用隐式函数来隐式表达任意复杂矿体的几何模型，隐式模型很容易跟上最新数据。新的钻孔数据可以快速集成，而不是花费数周或更长时间手动修改模型。这里的“隐式”有两重含义：一是指采用隐式函数来表示三维模型；另一个是指采用函数所表示的三维模型不能直接在三维视图中进行显示，需要通过曲面重构的方法转化为网格模型来显示。
隐式建模方法是一种非常适合于构造交互式约束条件的方法，其建立的模型动态更新较为方便。该方法将基于不同地质数据所构造的几何空间通过距离函数转换为隐式函数场，以数学函数的方式表达三维模型，所重构的曲面被表示为隐式函数的零水平集。由于创建模型所需的工作量较小，因此有更多的时间用于了解地质情况和研究更复杂的细节，如断层、地层序列、趋势和矿脉。这个模型可以发展成比以前更精确地反映现实。
矿体模型的隐式表达还具有以下优点：可以根据需要生成不同尺度的高质量三维模型；可以通过调整约束规则或获得一系列不同的建模结果；可以对多种不同类型的地质数据同时进行建模；可以融合多域模型且保证模型间较好的接触关系，其中一个很好的应用是模型直接的布尔运算变得非常容易；可以融合多种不同方法建模的结果，其中一个很好的应用是可以将显式建模的结果融合到隐式建模中；可以隐式存储表征矿体模型的插值函数而不是需要占用大量存储空间的网格模型。
3.行业优势 地质隐式建模对比于显式建模能够快速地得到地下要素信息的三维可视化表达，直观展示地下不规则分布的地质体几何结构，实现大量钻孔及剖面数据实时动态更新矿体模型。帮助地质工作者形象直观地分析地质特征并处理大量的野外测量和样品分析数据，有效地指导矿业生产，提高建模效率，降低建模成本。
4.基本流程 （1）采样数据
采样数据涉及的数据类型较为广泛，包括在地质勘探和生产勘探中获得的原始采样数据以及人工解译的轮廓线信息。其中涉及到勘探钻孔数据采用样品组合的方法根据工业指标对钻孔进行矿段组合，得到界定矿体边界的样段和非样段数据，而人工解释的数据可以转化为点、线数据作为原始数据处理。下图为实际应用中点、线数据可视化表达形式（必须承认有参考国际上较为先进的地质建模软件如LeapFrog等）。
（2）建模数据
建模数据主要分为三类：约束数据、插值数据和建模参数。约束数据由各种约束规则构造，例如模型生成外包、边界、各向异性趋势等。插值数据由可以直接用于计算生成模型的数据构成，如前文中的点、线数据。建模参数则包含一些地质规则参数，如基台、块金、漂移等。
（3）模型数据
目前根据初始地质数据的不同可以将矿体隐式建模方法分为两大类：基于钻孔数据的矿体隐式建模方法和基于人工解释点、线数据的矿体隐式建模方法。
适合于对具有几何边界约束直接基于钻孔数据的隐式建模方法建模流程具体步骤描述如下图：
基于人工解释点、线数据的隐式建模方法建模流程具体步骤描述如下图：
5.算法求解 矿体隐式建模方法使用满足各种地质规则约束的隐式函数来表示矿体模型。基于不同地质数据的矿体隐式建模方法的主要思路：首先，通过离散化的方式按一定的采样粒度将相应类型的地质数据转化为各种不同的插值约束；其次，通过求解插值约束所构造的插值方程来获得表征矿体模型的隐式函数；最后，利用等值面提取方法重构出表征矿体模型的隐式函数。基本原理如下图所示。
为了恢复任意复杂的矿体模型，通常可以在某个函数空间中寻找一组基函数来逼近表征矿体模型的未知连续函数。
在地质体数据不足的情况下，利用空间插值方法实现数据的网格化，推断并预测未知区域及研究较少区域的地质体信息的分布趋势，利用三维曲面重建算法及三维可视化技术相结合，能有效对不规则勘查数据自动实现地质要素的三维形态模拟。
采用空间插值算法，可以大幅提高建模自动化的程度，空间插值的过程是一个输入一些观察的数据点，输出反应这些数据规律的函数y=f(x)的过程。
目前应用于地质领域的空间插值与拟合方法有许多种，其中常用的主要有：距离反比插值法，改进谢别德法，克里金插值法，径向基函数法，最小曲率法，Voronoi图，最近邻点插值法，多元回归法，局部多项式法，线性插值法以及趋势面法等。
对于局部插值方法，如果某个子域内的约束不影响其他子域内的约束，则该子域内的求解结果与其他子域内的求解结果相互独立。由于该子域内的更新约束只能影响邻近的约束，意味着更新约束不会影响非邻近约束的权重，这些更新约束对子域外势场的插值也就不会变化。因此，在动态更新时，该子域内的约束可以单独进行求解。
对于全局插值方法，迭代求解的迭代过程一般要求指定初始解。如果选择的初始解不合适，则迭代过程可能不会收敛或收敛缓慢。通常选择零值的平凡向量作为初始解，以确保较小的相对误差。对于矿体的隐式建模，随着约束的逐步添加，RBF方程将被重复求解多次。在实验的过程中，我们发现只要新添加约束的数量足够小，当前的求解结果接近于上次的求解结果。因此，可以考虑通过已有解的结果来确定初始解，以提高矿体模型更新时的收敛速度。
常见的插值方法包括径向基函数插值方法，径向基插值函数𝑠(𝒙)具有以下形式。
其中𝑿={𝒙1,𝒙2,…,𝒙𝑁}是一组各不相同的插值中心，𝜔𝑖是待确定的权重系数。𝛷(𝒙,𝒙𝑗)是一种径向基核函数。𝑠 𝛷(𝒙)为核函数部分，𝑝(𝒙)为多项式部分，设{𝑝1,𝑝2,…,𝑝𝑄}为相应多项式空间中的一组基。
径向基插值函数𝑠 (𝒙)通常用于插值域约束。
其中𝑓𝑖为势场的函数值。
对于径向基类函数插值的方法，可以在任意采样位置通过插值约束来定义势场域值和势场方向类型的约束。一般的径向基函数插值所考虑的约束点信息中只包含函数值，而Hermite型的径向基函数插值（HRBF）方法则可以考虑约束点信息中包含函数导数值的情况。在HRBF插值方法中，最明显的改变是可以通过较强的法向约束代替较弱的离面约束，避免在局部产生二义性的离面约束，使得在不容易表达离面约束的地方具有较好的几何约束特征。而广义径向基函数插值方法则是更一般的插值方法，可以融合更多类型的插值约束，比如用于限制插值趋势的切向约束。
6.模型重构 尽管可以采用函数来隐式表达矿体模型，但这种模型表达方式是不可视的且一般不能直接应用于矿山开采设计中。因此，需要根据实际应用的需要对抽象的隐式函数进行曲面重构以得到网格化的隐式模型。在隐式函数求解的基础之上，可以根据曲面重构的方法获得多精度的矿体网格模型。为了高效地重构出隐式函数所表征的矿体模型，需要采用快速的隐式函数评估方法和曲面追踪方法。对于具有大规模约束的径向基函数插值问题，可以考虑将评估和重构过程结合起来加速隐式曲面的重构。
隐式曲面重构的基本思路是采用离散化的多边形（Polygon）来逼近连续的隐式函数。为了获得离散化的多边形，首先需要对模型所在的几何空间进行离散化采样，并利用求解的隐式函数评估采样点处的函数值，以便基于已有的采样点插值未知隐式曲面所在等值面上的近似点。然后采用多边形按一定的拓扑关系组合后形成的网格模型来近似表达连续的隐式曲面。基于以上分析，隐式曲面重构的过程主要分为三步：离散化采样、采样点评估和网格模型生成。
地质体三维曲面重构算法。基于三维空间规则数据场构建三维曲面的方法很多，典型的有采用三维等值面构建算法实现由网格离散点到三维等值面的模拟，实现三维曲面重建。以Marching Cubes算法是一种三维数据场等值面提取的经典算法，但在对复杂地质体建模时，其建模重构效率等方面还存在一些问题，因此，目前有许多学者在进行基于MC方法的重构优化方法研究。
隐式函数的函数值符号表征了地质域内矿体模型的内外关系。地质域中任一点的函数值定义为该点到隐式曲面𝑆上最近点的距离。我们约定隐式曲面外点的函数值为正，隐式曲面内点的函数值为负。隐式函数值和隐式表面之间的关系可以表示为
根据采样点构造的有符号距离场中，以有符号的隐式函数F§表示采样点与模型隐式曲面的最近距离，如图 7所示，其中位于隐式曲面内部的点为“负值”，外部点为“正值”，由零值点所确定的零水平点集即为模型的隐式曲面。也即对于三维空间中的任意点P，三维隐式曲面与隐式函数F§之间的关系可以表示为：
在三维空间中隐式曲面与函数值关系示意如下图。
各项术语示意图如下。
7.实际应用 隐式矿体建模实际效果展示如下图。
隐式脉状超薄矿体建模实际效果展示如下图。
8.总结 纵观全球地质建模软件的发展，行业龙头LeapFrog在20年前就着手研发，而Surpac、DataMine等也都集中团队力量在地质建模技术上开始着力。
国内地质建模软件基本还处于萌芽阶段，目前整个地质建模模块已进入生产试运行阶段，随着国内数字化和智能化建设的加快，以及投入的不断增加，国内的地质建模软件也会追随前人的脚步前进。毕竟很多事情我们都将“站在巨人的肩膀上”。
感谢一些同事尤其是中南大学采矿及地质同学大力支持。谢谢各位观看。
参考 [1] 钟德云. 地质规则约束下矿体隐式模型的快速重构与动态更新[D]. 长沙: 中南大学, 2020.
[2] 张炬,钟德云,王李管,王晋淼. 基于隐式函数的三维建模方法、装置、系统及存储介质[P]. 湖南省：CN110033519A,2019-07-19.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad58ef4dfa1247ea6984898d3a6850e2/" rel="bookmark">
			电路串联和并联图解_电路串联和并联的区别有哪些
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		电路安装是家装过程中至关重要的工程，但是电路安装时的工序较为复杂，一旦出现问题容易引发安全事故，因此电路必须严格按照相关规范进行安装，那么电路串联和并联的区别有哪些呢？如何判断串联电路和并联电路呢？下面就跟着小编一起来看看吧！
一、电路串联和并联的区别有哪些
串联电路及并联电路的电流通路不同，串联电路的电流通路仅有一条，但并联电路的电流通路至少有两条，且断电后产生的影响也不一样，串联电路中任何一处出现断电的情况，会导致整个电路无法进行工作，并联电路各个支路之间不互相干扰，某条支路断电后也不会对其它支路的工作造成任何影响。
二、如何判断串联电路和并联电路
1、对串联电路及并联电路进行判断时，可以观察电路内的全部元件是否依次相连，并与电路相接，如果是，说明该电路为串联电路，若电路内各个元件的两端分别相连，并与电路相接，那么该电路就为并联电路。
2、识别电路为串联电路还是并联电路的时候，可以让电流从电源正极通向电源负极，过程中如果电路未出现分流的情况，那么该电路就为串联电路，但若过程中电流分成两条甚至两条以上的支路，说明该电路为并联电路。
3、分辨串联电路及并联电路时，可以将任意一个用电器断开，如果用电器断开后出现其它用电器无法工作的情况，说明该电路为串联电路，但如果用电器断开后，其它用电器仍可以继续工作，说明该电路为并联电路。
总结：电路串联和并联的区别有哪些的相关内容就为大家介绍到这里了，在安装电路的时候，不能忽视了自己及家人的居住需求，以免因电路安装不当留下安全隐患。如果您想了解更多装修知识，可以关注齐家网相关资讯。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32cfd20edab93732e7e8994d8a8f7b06/" rel="bookmark">
			一篇文章带你搞懂动态规划问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 这篇博客主要是跟大家相互交流学习动态规划问题，下面记录的是一些我的学习心得。有不足的情况还望大家私聊交流指正。
我写这篇博客的思路大概是这样：首先解释下动态规划的关键概念，然后列出各种动态规划类型的题目，只要能够跟着我的博客完成之后的动态规划题目我觉得应该能够解决平时遇到的百分之90的动态规划的问题
一、动态规划的四大组成部分 1、确定状态 状态在动态规划中的作用至关重要。简单理解状态就是我们需要一个数组，数组中的每个元素就是代表状态。确定状态需要两个关键意识：最后一步和子问题。
（1）最后一步（可以直接根据问题来确定最后一步） 确定最后一步有两个关键点。这里我举个例子，例如常见的零钱兑换问题（你有三种硬币，分别是面值2元，5元，7元的，每种硬币足够多，买一本书需要27元，如何用最少的硬币组合正好付清）。我们不知道这个最优策略是啥，但是可以确定一定有最后的一枚硬币ak，除掉这枚硬币前面的币值加起来就是27-ak，我们不需要去关心前面的k-1枚硬币怎么拼出27-ak的，因为那就是我们的子问题。
（2）子问题 愿问题是用最少的硬币拼出27，而经过刚刚最后一步的确认，我们转化成了如何用最少的硬币拼出27-ak,这就是我们的子问题
确定好了最后一步和子问题，我们就可以开一个数组f[x]表示最少用多少枚硬币拼出X
2、转移方程 通过对最后一步和子问题的确认，我们了解到只需要用最少的硬币拼出27-ak，就可以用最少的硬币拼出27了。而针对ak的选择有三个：2，5，7。因此我们的专业方程就是：
3、初始条件和边界情况 这两个问题就根据字面意思去理解，针对不同的问题看情况而定。比如针对零钱兑换。
初始条件：x=0的时候应该是设置f[x]=多少，很明显f[0]=0
边界情况：x-2，x-5,x-7小于0和不能拼出X的时候该怎么设置，因为我们是求最小值，因此都设置为正无穷。
4、计算顺序 当我们计算f[x]的时候需要知道f[x-2],f[x-5],f[x-7]的值，因此我们计算顺序就是f[0]到f[x]
二、动态规划题目的特点 1、计数 一般技术类型的题目都可以用动态规划解决，例如下面两种类型
有多少种方式走到右下角有多少方式选出K个数使得和是Sum 2、求最大值最小值 这种动态规划中最常见的类型，例如
从左上角走到右下角路径的最大数字和最长上升子序列长度 3、求存在性 这种问题其实与上面两种类型相互对应，例如
取石子游戏，先手是否必胜能不能取出K个数使得和是Sum 三、动态规划题目类型 下面的题目全都来自leetcode或者lintcode，我只是列出了我做过的题目，网站上面还有很多其他动态规划的题目，大家就自行实践。
1、坐标型动态规划 该类型的动态规划是所有类型中最简单的类型。一般题目都是给定一个序列或者一个网格，需要你去找到序列或网格中的某条路径满足最大最小或者进行计数或者判断是否存在。
特点：该类型的题目的特点就是转移方程中的f[i]中的下表i表示以ai结尾的满足条件的子序列的性质。f[i][j]中的下标i，j表示以格子i,j结尾的满足条件的路径的性质。
初始条件：该类型动态规划初始条件f[0]就是以a0结尾的子序列的性质。
64、最小路径和
361、轰炸敌人
2、位操作型动态规划 该类型的题目主要就是指二进制的位操作，分为与，或，异或，非。下面举了个典型的例题
338、比特位计数
3、序列型动态规划 给定一个题目，动态规划方程中f[i]中的下标i表示前i个元素a[0]，a[1]……a[i-1]等的某种性质,注意与坐标类型的动态规划进行区别，其表示以a[i]结尾的某种性质。初始化的时候，f[0]表示空序列的性质。
序列类型的动态规划题目变种非常多，很多题目的代码实现可以完全使用坐标类型动态规划解决问题，所以我的部分题目的代码使用的是坐标类型实现，但是过程分析采用的是序列类型的动态规划思想，大家可以自己尝试实现部分序列类型方法实现的代码
62、不同路径
256、粉刷房子
198、打家劫舍
215、打家劫舍2
300、最长递增子序列
354、俄罗斯套娃信封问题
4、划分型动态规划 该类型的题目给定长度为N的序列或字符串，要求划分成若干段
– 段数不限，或指定K段
– 每一段满足一定的性质
做法
– 类似于序列型动态规划，但是通常要加上段数信息
– 一般用f[i][j]记录前i个元素(元素0~i-1)分成j段的性质，如最小代价
91、解码方法
132、分割回文串2
279、完全平方数
437、书籍复印
5、博弈型动态规划 394、硬币排成线
6、背包型动态规划 该类型的题目是你有一个背包，背包有最大承重，每个物品有重量和价值
目标：不撑爆背包的前提下
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32cfd20edab93732e7e8994d8a8f7b06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1255f7a82b68ff10bc8d5d31a6256f3e/" rel="bookmark">
			区间型动态规划——最长回文子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。
示例 1:
一个可能的最长回文子序列为 “bbbb”。
输入: "bbbab" 输出: 4 一个可能的最长回文子序列为 “bbbb”。
1、题目分析 这个题目可以划分为序列类型的动态规划，也可以划作为区间类型的动态规划。就我个人的思想而言，更接近区间类型的动态规划。
2、确定状态 最优策略产生最长的回文子串T，长度是M
• 情况1：回文串长度是1，即一个字母
• 情况2：回文串长度大于1，那么必定有T[0]=T[M-1]
设T[0]是S[i], T[M-1]是S[j] ，T剩下的部分T[1…M-2]仍然是一个回文串，而且是S[i+1…j-1]的最长回文子串
因此我们可以假设状态f[i][j]为S[i……j]的最长回文子串的长度。
3、转移方程 假设状态f[i][j]为S[i……j]的最长回文子串的长度
4、初始条件和边界情况 初始条件
– f[0][0] = f[1][1] = … = f[N-1][N-1] = 1
• 一个字母也是一个长度为1的回文串
– 如果S[i] == S[i+1], f[i][i+1] = 2
– 如果S[i] != S[i+1], f[i][i+1] = 1
5、计算顺序 这种类型的题目比较特殊，不能逐行去计算，需要按照j-i从小到大的顺序去计算
答案是f[0][N-1]。
时间复杂度O(N*N)，空间复杂度O(N*N)
6、代码实现 class Solution: def longestPalindromeSubseq(self, s: str) -&gt; int: if len(s) == 0: return 0 n = len(s) dp = [[0] * n for i in range(n)] for i in range(n): dp[i][i]=1 for i in range(n-1,-1,-1): for j in range(i+1,n): if s[i]==s[j]: dp[i][j] = max(dp[i][j], dp[i+1][j-1] + 2) else: dp[i][j]=max(dp[i+1][j],dp[i][j-1]) return dp[0][n - 1] 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/338/">«</a>
	<span class="pagination__item pagination__item--current">339/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/340/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>