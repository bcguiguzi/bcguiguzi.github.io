<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c3126cd284b6baa2b9b753f9bd9a246/" rel="bookmark">
			【CBY_231225】Kmeans聚类及LSTM时间序列预测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import random import string from datetime import datetime def generate_random_string(length=3): characters = string.ascii_uppercase return ''.join(random.choice(characters) for _ in range(length)) def generate_timestamped_string(separator='_'): timestamp = datetime.now().strftime('%y%m%d') # %H%M%S random_part = generate_random_string(length=3) return random_part+separator+timestamp timestamped_string = generate_timestamped_string() print('【{0}】'.format(timestamped_string)) 【Talk is cheap】
#!/usr/bin/env python # coding: utf-8 # Auth wechat: civilpy # In[2]: import warnings import numpy as np import pandas as pd import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] # 显示中文 plt.rcParams['axes.unicode_minus'] = False # 显示负号 warnings.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c3126cd284b6baa2b9b753f9bd9a246/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8af519fff8c9248cd576d2f0732d9efc/" rel="bookmark">
			【基础知识】时序特征融合（注意力机制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 基础知识：注意力机制 注意力机制的理解？
https://www.bilibili.com/video/BV1nL4y1j7hA/?spm_id_from=333.788&amp;vd_source=1add2a1cdc6ef25fe4c3eb2a25bf292a
这个up主对于注意力公式的讲解非常容易理解和记忆。基本公式如下：
注意力机制和自注意力机制的区别：
https://www.bilibili.com/video/BV1tL4y1j7pN/?spm_id_from=333.788&amp;vd_source=1add2a1cdc6ef25fe4c3eb2a25bf292a
注意力机制是一种机制，用于在输入序列中对不同位置的信息分配不同的权重。主要关注输入元素与外部/全局元素之间的关系。
自注意力机制是注意力机制的一种特殊形式，其中查询、键和值都来自于同一组输入序列。主要关注输入序列中不同元素之间的关系。
多头注意力机制
https://www.bilibili.com/video/BV1PP4y1T7Yu/?spm_id_from=pageDriver&amp;vd_source=1add2a1cdc6ef25fe4c3eb2a25bf292a
理解：相当于卷积神经网络中的多个kernel，多个kernel可以学习多种特征表达。
实现：在视频目标检测中，通过拆分通道来实现。比如：当前帧和参考帧的图像通道数是1024，假设8头的话（N=8），图像就会被拆成8个128通道的特征，并对每个特征分别进行注意力。
视频目标检测中的时序特征融合 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/50f5caf0a41df52d68fa014897157e75/" rel="bookmark">
			【算法】已知rand1() 生成rand5()，rand7()生成rand10()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		rand1() 生成rand5() rand1 可以随机返回0和1， 所以，想让其生成等概率的0-5的数字先需要让其生成等概率的一组数（0-n）然后再用这一组数来取模生成0-5 int rand1() { return rand() % 2; } //由于rand1 只能生成等概率的0-3之间的数， int rand3()	//所以先生成0-3 再由0-3生成0-5 { return rand1() * 2 + rand1(); } int rand5() { //根据0-3 可以生成等概率的0-15 int ret = (rand3() * 4 + rand3()); while (ret == 15) //当其等于15时，模5之后0的概率会变大，所以除去15这个值 ret = (rand3() * 4 + rand3()); return ret % 5; } int main() { int n = 100000; int n0 = 0, n1 = 0, n2 = 0, n3 = 0, n4 = 0; while (n--) { if (rand5() == 0) ++n0; if (rand5() == 1) ++n1;	if (rand5() == 2) ++n2; if (rand5() == 3) ++n3; if (rand5() == 4) ++n4; } std::cout &lt;&lt; n0 &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/50f5caf0a41df52d68fa014897157e75/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fdae85afcfcecc64685a0d816301da5/" rel="bookmark">
			143.【Nginx-02】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx-02 (五)、Nginx负载均衡1.负载均衡概述2.负载均衡的原理及处理流程(1).负载均衡的作用 3.负载均衡常用的处理方式(1).用户手动选择(2).DNS轮询方式(3).四/七层负载均衡(4).Nginx七层负载均衡指令 ⭐(5).Nginx七层负载均衡的实现流程 ⭐ 4.负载均衡状态(1).down (停用)(2).backup (哨兵服务器)(3).max_conns(4).max_fails和fail_timeout 5.负载均衡策略(1).轮询(2).weight (轮询)(3).ip_hash (哈希主机定位)(4).least_conn (最少连接)(5).url_hash (哈希路径定位)(6).fair (智能) 6.负载均衡案例_七层(1).对所有请求实现一般轮询规则的负载均衡(2).对所有请求实现加权轮询规则的负载均衡(3).对特定资源实现负载均衡(4).对不同域名实现负载均衡(5).实现带有URL重写的负载均衡 7.负载均衡_四层(1).添加stream模块的支持(2).Nginx四层负载均衡的指令(3).四层负载均衡的案例_需求分析 (六)、Nginx缓存集成1.缓存的概念2.Nginx的web缓存服务3.Nginx缓存设置的相关指令(1).proxy_cache_path(2).proxy_cache(3).proxy_cache_key(4).proxy_cache_valid(5).proxy_cache_min_uses(6).proxy_cache_methods 4. Nginx缓存设置案例(1).需求分析(2).步骤实现(3).完整配置 5.Nginx缓存的清除(1).方式一: 删除对应的缓存目录(2).方式二: 使用第三方扩展模块 6.Nginx设置资源不缓存(1). `$cookie_nocache`、`$arg_nocache`、`$arg_comment`(2).示列 (七)、Nginx实现服务器端集群搭建1.Nginx与Tomcat部署(1).环境准备(Tomcat)(2).环境准备(Nginx) 2.Nginx实现动静分离(1).需求分析(2).动静分离实现步骤 3.Nginx实现Tomcat集群搭建(1).环境准备：(2).配置信息(3).测试tomcat集群 4.Nginx高可用解决方案(1).Keepalived(2).VRRP介绍(3).环境搭建 ⭐(4).下载 Keepalived(5).Keepalived配置文件介绍(6).keppalived 自定义配置 ⭐⭐(7).自定义配置后访问测试 ⭐⭐⭐(8).keepalived之自动切换脚本 5.Nginx制作下载站点(1).autoindex:启用或禁用目录列表输出(2).autoindex_exact_size:对应HTLM格式，指定是否在目录列表展示文件的详细大小(3).autoindex_format：设置目录列表的格式(4).autoindex_localtime:对应HTML格式，是否在目录列表上显示时间。(4).测试 6.Nginx的用户认证模块(1).auth_basic:使用“ HTTP基本认证”协议启用用户名和密码的验证(2).auth_basic_user_file:指定用户名和密码所在文件 (八)、Lua1.基本介绍(1).Lua的基本概念(2).Lua的特性(3).应用场景 2.Lua的安装与编译(1).找到Lua官网(2).进行编译与安装 3.Lua的语法(1).Lua的两种交互方式(2).Lua的注释(3).标识符(4).关键字(5).运算符(6).全局变量&amp;局部变量 4.Lua数据类型(1).nil (空值)(2).boolean (布尔)(3).number (数值)(4).string (字符串)(5).table (表)(6).function (函数)(7).thread (线程)(8).userdata (用户数据) 5.Lua控制结构(1).if then elseif else(2).while循环 (先判断在执行)(3).repeat循环 (先执行在判断条件)(4).for循环 (九)、ngx_lua模块概念1.ngx_lua模块环境准备(1).方式一:lua-nginx-module(2).方式二: OpenRestry (推荐⭐) 2.ngx_lua的使用(1).init_by_lua*(2).init_worker_by_lua*(3).set_by_lua*(4).rewrite_by_lua*(5).access_by_lua*(6).content_by_lua*(7).header_filter_by_lua*(8).body_filter_by_lua*(9).log_by_lua*(10).balancer_by_lua*(11).ssl_certificate_by_* (五)、Nginx负载均衡 1.负载均衡概述 早期的网站流量和业务功能都比较简单，单台服务器足以满足基本的需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也跟着越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器进行性能的水平扩展及避免单点故障出现。那么如何将不同用户的请求流量分发到不同的服务器上呢？
2.负载均衡的原理及处理流程 系统的扩展可以分为纵向扩展和横向扩展。
纵向扩展是从单机的角度出发，通过增加系统的硬件处理能力来提升服务器的处理能力。横向扩展是通过添加机器来满足大型网站服务的处理能力。 这里面涉及到两个重要的角色分别是"应用集群"和"负载均衡器"。
应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理并返回响应的数据。负载均衡器: 将用户访问的请求根据对应的负载均衡算法，分发到集群中的一台服务器进行处理。 (1).负载均衡的作用 解决服务器的高并发压力，提高应用程序的处理性能。提供故障转移，实现高可用。通过添加或减少服务器数量，增强网站的可扩展性。在负载均衡器上进行过滤，可以提高系统的安全性。 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fdae85afcfcecc64685a0d816301da5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4294524beb257c30ed7d7462930c22b6/" rel="bookmark">
			霜雪满路——谨以此文纪念CSDN入住一年
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“呓语。” “没有路？那我自己造。”
“这一年，我连滚带爬，但我走过来了。”
“我致敬一切黑暗迷茫，或是简淡安好的岁月。”
“我表白我遇见的每一个可爱的人。”
“怀念那些低头匆匆赶路的日子。”
“是日大雪。” “晴朗的冬夜，屋子里有火炉，窗户上有月亮。”
“东北的雪夜，天空的云是紫红葡萄色的。”
“雪里没有月亮，但谢谢那些夜夜冬月，在我心中曾点燃过一只。”
“东北的雪天很冷，下雪过后的清晨，你可以踩着脚印走啦。”
“我的脚印踩得或虚或实，但你有迹可循。”
“那些黑暗里冒雪低头赶路，我寄人间雪满头。”
“本来只是想在大雪里留下一串脚印，回望时亦觉人间值得。”
“虽然脚印终将被下一场大雪覆盖，但至少我记得、它来过。”
“回眸。”
“不知不觉，身边和身后默默跟着陪着好多人。”
“你们和我一起玩雪呀！”
“写在最后。” “前方没有康庄路，我愿敬前驱者、协同行者、共为继来者修。”
“前途多舛，但我们身后即为坦途。”
“路将有千万条。我之星火，愿能燎原。”
“此心安处是吾乡。”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dceedff48d005c30dd0f9aee20c07a43/" rel="bookmark">
			算数平均数、调和平均数、几何平均数的计算方法与应用场合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 定义
1、算数平均数：又称均值，是统计学中最基本，最常用的一种平均指标，分为简单算术平均数、加权算术平均数。
2、调和平均数：又称倒数平均数，是总体各统计变量倒数的算数平均数的倒数。分为数学调和平均数（数值倒数的平均数的倒数）和统计调和平均数（计算结果与加权算术平均数完全相等）。
3、几何平均数：几何平均数是对各变量值的连乘积开项数次方根。根据所拿掌握资料的形式不同，其分为简单几何平均数和加权几何平均数两种形式。
二 计算方法
1、算数平均数：
设一组数据为X1,X2,...,Xn,简单地算术平均数的计算公式为：
加权算术平均：主要用于处理经分组整理数据。
设原始数据被分成K组，各组的组中值为X1,X2,...Xk，各组的频数分别为f1,f2,...fk，加权算术平均数的计算公式为：
2、调和平均数：
简单调和平均数是算术平均数的变形。
加权调和平均数：
例如：某工厂购进材料三批，每批价格及采购金额资料如下表：
价格（元/千克）（x）采购金额（元）（m)采购数量（千克）(m/x)第一批3510000286第二批4020000500第三批4515000330合计-450001116 3、几何平均数：
简单几何平均数：
加权几何平均数：
三 应用场合
1、算数平均数：适用于数值型数据，不适用于品质数据。根据表现形式的不同，算术平均数有不同的计算形式和计算公式。
简单算术平均数适用于未分组的原始数据。加权平均数用于分组的数据。
2、调和平均数：可以用于计算平均速度，例：计算4x100米接力赛中，运动员的总体速度。
3、几何平均数：
1、对比率、指数等进行平均；
2、计算平均发展速度；
3、复利下的平均年利率；
4、连续作业的车间产品的平均合格率；
计算总水平、总成果等所有阶段、所有环节水平、成果的连乘积总和时，求各阶段、各环节的一般水平、一般成果，要使用几何平均法计算几何平均数。
四 特点
算术平均值是一个良好的集中量数，具有反应灵敏、确定严密、简明易解、计算简单、适合进一步演算和较小抽样变化的影响等特点。但是极易受极端数据的影响，每个数据的或大或小的变化都会影响最终结果。
调和平均数具有以下几个主要特点：
1、调和平均数易受极端值的影响，且受极小值的影响比受极大值的影响更大。
2、只要有一个标志值为0，就不能计算调和平均数。
3、当组距数列有开口组时，其组中值即使按照相邻组距计算，假定性也很大。
4、调和平均数应用的范围较小。
三者的关系：
调和平均数 ≤ 几何平均数 ≤ 算术平均数 ≤ 平方平均数
几何平均数 geo·met·ric
[ˌdʒɪəˈmɛtrɪk]
ADJECTIVE
relating to geometry, or according to its methods.
characterized by or decorated with regular lines and shapes:
"a geometric pattern"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dceedff48d005c30dd0f9aee20c07a43/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2b86106b7735544e0a659a9b7d994c3/" rel="bookmark">
			计算机网络复习-OSI TCP/IP 物理层
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我膨胀了，挂我啊~ 作者简介： 每年都吐槽吉师网安奇怪的课程安排、全校正经学网络安全不超20人情景以及割韭菜企业合作的FW，今年是第一年。。
TCP/IP模型 先做两道题：
TCP/IP协议模型由高层到低层分为哪几层： 这题最开始看的时候有点懵，寻思TCP/IP五层，我特么直接选D，再仔细一看，不对劲
翻了下概念图，好好好，四五层都有是吧
既如此，这几个都得背呗
OSI七层简记为 用 表 会 传 络 连 理
TCP/IP五层记为 用 表 络 链 理
TCP/IP四层简记为 应 传 网 口
没啥逻辑，当个顺口溜记就得
那问题来了，那个网际层是个什么玩意
好好好，顶上不写是吧
这题翻篇
以下关于TCP/IP协议说法错误的是？ 最开始没审题，第一眼直接选D，报错。
仔细一看，好好好
不过网上的文章还真不如这里的
网络协议 网络协议为计算机网络中进行数据交换而建立的规则、标准或约定的集合。
意思就是 在网络中互相传输、交换数据的规矩。有点八股文了
TCP/IP协议 首先声明TCP/IP协议不为TCP或者IP协议。
它本质上是一个协议集合，TCP(传输控制协议)和IP(网际协议)只是其中最核心的协议
IP协议 这个协议的作用是规定网络地址，他所定义的地址就被称为IP地址
该协议主要实现两个功能：
寻址 分段
而该协议的主要作用有两个，一是为了每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网中
TCP协议 在说TCP之前，先说UDP，UDP诞生于TCP之前，特点是比较简单且容易实现，但同时它的可靠性也很差。
总说可靠性差，到底哪差了？
我发个包出去，对面接没接到我压根不知道啊
因此，TCP协议应运而生。
TCP协议能保证数据不会遗失，但缺点就是复杂繁琐且消耗资源。
那问题来了，TCP是咋保证数据不遗失的捏？
三次握手，握，狠狠地握！
IP协议是找到对方的详细地址,TCP协议是把安全的把数据传输给对方。
数据的封装与解封装 看图理解，来源水印
物理层 物理层作用：
屏蔽传输媒体和通信手段的差异，为数据链路层提供服务
数据通信系统：
数据通信系统包括三大部分法，分别是：源系统→传输系统→目的系统
信道交互信息的方式：(看图说话
单工通信：
半双工通信：
全双工通信：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2b86106b7735544e0a659a9b7d994c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7481ebc7ad7bff5ad1b033fd39e8324/" rel="bookmark">
			2021 ICPC 亚洲区域赛上海站VP题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 ICPC 亚洲区域赛上海站VP题解 2023赛季打完了，先把之前跟队友疯狂VP但没补的场次标一下，然后滚去准备期末考试，考完试再来好好研究
A（可补） B（容斥/NTT,有需要就补) C（可补） D 题目大意 给定 p q \frac {p}{q} qp​,找到两个正整数满足 p q = a b + b a \frac {p}{q}=\frac{a}{b}+\frac{b}{a} qp​=ba​+ab​
1 &lt; = p , q &lt; = 1 e 7 1&lt;=p,q&lt;=1e7 1&lt;=p,q&lt;=1e7
思路 非常简单的想法：直接设 t = a b t=\frac {a}{b} t=ba​
那么问题转化为 q t 2 − p t + q = 0 qt^2-pt+q=0 qt2−pt+q=0是否有有理数根的问题，判断判别式即可
另一种做法 代码如下
#include&lt;bits/stdc++.h&gt; #define int long long using namespace std; int gcd(int a,int b) { while(b) { int t=a%b; a=b; b=t; } return a; } void work() { int p,q; cin&gt;&gt;p&gt;&gt;q; int delta=p*p-4*q*q; int s_delta=sqrt(delta); if(s_delta*s_delta==delta) { int b=p+s_delta,a=2*q; int d=gcd(b,a); b/=d;a/=d; cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;'\n'; } else cout&lt;&lt;"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7481ebc7ad7bff5ad1b033fd39e8324/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e65e00a2bee66ff56d743d324030343b/" rel="bookmark">
			深入理解vue双向绑定原理，一文手把手带你用原生js实现vue双向绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、vue双向绑定简介 双向绑定简单来说，其实就是数据能影响视图，而视图也能反过来影响数据，例如当一个输入框和js对象的某个属性实现了双向绑定，那么属性值的变化会影响输入框中的值，输入框中的值变化也会影响属性的值，接下来，笔者将在此基础上，用原生js从零开始实现vue的双向绑定。 二、代码编写 1. 事前准备 我们先准备好这样一个简单html页面，写过vue的同学应该都不会陌生，当然这里并没有引入vue的js，而是我们待会需要实现的MyVue.js
&lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div&gt; &lt;input type="text" v-model="name"&gt; &lt;input type="text" v-model="msg.text" &lt;/div&gt; &lt;div&gt; &lt;div&gt;name: {{ name }}&lt;/div&gt; &lt;div&gt;msg: {{ msg.text }}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="MyVue.js"&gt;&lt;/script&gt; &lt;script&gt; const vue = new MyVue({ el: '#main', data: { name: 'jonny', msg: { text: 'hello' } } }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 下面就是页面最开始的样子，视图和数据之间没有任何联系
接下来我们开始编写MyVue.js的逻辑
2.MyVue.js中的MyVue类 MyVue类是MyVue.js中的主体部分，先创建一个MyVue.js文件，之后我们先编写MyVue类的构造方法，先把传入对象的el属性和data属性赋值给成员属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e65e00a2bee66ff56d743d324030343b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4e23c48bd2f62ee96e7757376fb3f229/" rel="bookmark">
			minicube搭建golang容器服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 最近在自己电脑上搭建一个小型k8s环境，以学习云原生相关内容。这里我主要分为三部分记录：
容器及容器编排理论环境安装相关rpcx服务实战 还在调试中，先总结整理下，这里后续补充上我的github工程链接。
一、容器及容器编排理论 容器技术中有三个核心概念：容器（Container）、镜像（Image），以及镜像仓库（Registry）
如何通过Docker File构建镜像？
=&gt; 首先编写Docker File文件, Docker build 命令构建镜像 ,Docker run 依照新编写好的镜像运行容器实例。
操作容器的常用命令有 docker ps、docker run、docker exec、docker stop 等；操作镜像的常用命令有 docker images、docker rmi、docker build、docker tag 等；操作镜像仓库的常用命令有 docker pull、docker push 等。
Kubernetes 就是一个生产级别的容器编排平台和集群管理系统，不仅能够创建、调度容器，还能够监控、管理服务器。
快速搭建 Kubernetes 环境的工具选择minikube， 最大特点就是“小而美”，可执行文件仅有不到 100MB，运行镜像也不过 1GB，但就在这么小的空间里却集成了 Kubernetes 的绝大多数功能特性，不仅有核心的容器编排功能，还有丰富的插件，例如 Dashboard、GPU、Ingress、Istio、Kong、Registry 等等，综合来看非常完善。
总结差异： 容器技术只解决了应用的打包、安装问题，面对复杂的生产环境就束手无策了，解决之道就是容器编排，它能够组织管理各个应用容器之间的关系，让它们顺利地协同运行。
Kubernetes 源自 Google 内部的 Borg 系统，也是当前容器编排领域的事实标准。minikube 可以在本机搭建 Kubernetes 环境，功能很完善，适合学习研究。操作 Kubernetes 需要使用命令行工具 kubectl，只有通过它才能与 Kubernetes 集群交互。kubectl 的用法与 docker 类似，也可以拉取镜像运行，但操作的不是简单的容器。
docker和k8s之间的区别，一个是容器技术，一个是容器编排技术，两者思考的维度是不一样的，就容器而言，容器解决的问题是隔离，是一次打包到处运行的问题，最大的价值就在于镜像的迁移。编排技术则是关注的是整个系统的问题，如果你只关注一个服务，迁移一个服务，那docker就够，但要迁移整个系统以及运维，那就需要编排，包括网络关系，负载均衡，回滚，监控，扩缩容问题则需要容器编排技术。
二、环境安装相关 我的电脑是mac m2，因此需要安装一些arm架构的软件。首先安装docker，主要使用的命令记录：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4e23c48bd2f62ee96e7757376fb3f229/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f0adb2fea9c0b4d4a34a6b9067bbe5f/" rel="bookmark">
			云服务器如何使用ubuntu图形桌面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		linux云服务器，在特定需求下，需要使用图形桌面。
为了达到这个目的，需要以下两个步骤：
1. 安装桌面环境
2. 远程连接桌面
以阿里云为例，启动ubuntu实例以后：
1. sudo apt update
2. sudo apt install ubuntu-desktop
中间配置过程，全部按照默认，不用改动。
3. 可选：使用轻量级桌面，降低资源消耗
sudo apt install lightdm
安装lightdm时，系统会要求我们选择默认的显示管理器，在列表中选择“lightdm”并单击“”。 sudo service lightdm start
4. 远程连接桌面，在服务器上面安装vncserver，在本地机上面安装vncviewer，配置好端口、安全组，并连接。
对于阿里云服务器，可以省略第4步，直接在阿里云控制台-&gt;远程连接，选择vnc连接就可以进入图形界面。
本文参考了：如何在 Ubuntu 服务器上安装桌面环境 (GUI) - 站长快讯 - 主机测评
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783e1eb635283b5e705ca8b01340a47c/" rel="bookmark">
			Git 常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 基础使用配置信息从仓库克隆查看git状态添加新文件查看修改过的内容提交文件到暂存区撤销一次 commit撤销一次 push查看暂存区提交描述/说明从仓库更新，合并提交到远程代码库 分支使用查看分支创建远程分支删除远程分支创建本地分支删除本地分支合并分支远程分支与本地分支关联 其他获取远程内容，覆盖本地获取暂存区内容，覆盖本地，删除未ad的文件恢复仓库版本查看远程git地址修改远程git地址删除没有被track的文件查看没有被track的文件 标签查看标签打标签 Git日志查看在线日志查看文件每行修改纪录查看某次提交修改内容 Git submodule添加submodule删除 submodule下载的工程带有submodule Git配置打开配置文件配置文件内容 基础使用 配置信息 # 生成秘钥 ssh-keygen -t rsa git config --global user.name 'webben' git config --global user.email webben@gmail.com #忽略权限 git config --global core.filemode false #window crlf编码 in:crlf out:lf git config --global core.autocrlf true # git清除密码 git config --system --unset credential.helper 查看全局变量
git config user.name #查看项目配置 git config --list #查看全局配置 git config --global -l 或者
vi ~/.gitconfig 从仓库克隆 git clone https://git@git.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783e1eb635283b5e705ca8b01340a47c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fda1b34a700d2c56cd9ecbb38838139/" rel="bookmark">
			AI学习很赞的学习贴（都附有源码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GitHub - labmlai/annotated_deep_learning_paper_implementations: 🧑‍🏫 59 Implementations/tutorials of deep learning papers with side-by-side notes 📝; including transformers (original, xl, switch, feedback, vit, ...), optimizers (adam, adabelief, ...), gans(cyclegan, stylegan2, ...), 🎮 reinforcement learning (ppo, dqn), capsnet, distillation, ... 🧠🧑‍🏫 59 Implementations/tutorials of deep learning papers with side-by-side notes 📝; including transformers (original, xl, switch, feedback, vit, ...), optimizers (adam, adabelief, ...), gans(cyclegan, stylegan2, ...), 🎮 reinforcement learning (ppo, dqn), capsnet, distillation, .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4fda1b34a700d2c56cd9ecbb38838139/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0efbe2ab3806491aada2f72ac021bc3/" rel="bookmark">
			376. 摆动序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
示例 1：
输入：nums = [1,7,4,9,2,5] 输出：6 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2：
输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0efbe2ab3806491aada2f72ac021bc3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b322f6bb0003c636c32d0fa0ee39fe7a/" rel="bookmark">
			37. 解数独
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 编写一个程序，通过填充空格来解决数独问题。
数独的解法需 遵循如下规则：
数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。
示例 1：
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]] 输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]] 解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 提示：
board.length == 9board[i].length == 9board[i][j] 是一位数字或者 '.'题目数据 保证 输入数独仅有一个解 解答 class Solution { public: void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) { // 将每行的每个位置都用1-9去尝试，回溯，类似于dfs的思路 // 满足条件是同行同列及所在3x3格子内都不出现 backtrack(board); } bool backtrack(vector&lt;vector&lt;char&gt;&gt;&amp; board) { // 按行搜索每一个位置的可能情况 for(int i = 0; i &lt; board.size(); i++) { for(int j = 0; j &lt; board[0].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b322f6bb0003c636c32d0fa0ee39fe7a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b75508f5986c1e5eab5bf4f2746040b3/" rel="bookmark">
			Java 多线程之自定义线程池（ThreadPool）使用方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、概述二、ThreadPoolExecutor 的作用三、自定义线程池工创建工厂四、自定义线程池拒绝策略五、线程池使用示例 一、概述 线程池是一种管理和复用线程的机制，它包含一组预先创建的线程，用于执行各种任务。线程池的主要作用是提高多线程应用程序的性能和效率，并提供对线程的生命周期和资源的管理，包括线程的创建、销毁和复用。
本文主要讨论线程池执行器（ThreadPoolExecutor）的用法，在观看本文之前建议先看线程池使用入门。
二、ThreadPoolExecutor 的作用 ThreadPoolExecutor 的作用是创建线程池。一般情况下，我们使用 Executors 来创建线程池，使用起来非常简单方便。但是他有一个问题，就是创建池时有很参数需要调整时他就不灵活了。Executors 创建线程池本质上也是使用 ThreadPoolExecutor ，所以我们需要了解 ThreadPoolExecutor ，因为他提供了更多和线程池管理控制功能。
下面是使用 ThreadPoolExecutor 创建线程池的示例：
ThreadPoolExecutor s = new ThreadPoolExecutor(2, 4, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(4), Executors.defaultThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy()); ThreadPoolExecutor 有7个构造函数，每个参数的用途如下：
int corePoolSize, 核心线程数量。线程池中的基本线程数，即在没有任务需要执行时线程池的大小。int maximumPoolSize, 最大线程数量。线程池中允许的最大线程数。long keepAliveTime, 线程生存时间。就是线程在多少时间没有执行任务，就释放线程相关资源。TimeUnit unit, 线程生存时间单位。指定 keepAliveTime 的时间单位。BlockingQueue workQueue, 任务队列。用于保存等待执行的任务的队列。ThreadFactory threadFactory, 线程产生的工厂。用于创建新线程的工厂。RejectedExecutionHandler handler 拒绝策略，就是所有线程都在执行且任务满以后的处理办法。 Abort 中止策略。是默认的拒绝策略。当任务无法被接受时，会抛出 RejectedExecutionException 异常Discard 丢弃策略。直接丢弃无法执行的任务，不抛出异常也不通知调用者，一般情况下是不能使用的。DiscardOld 丢弃最老的策略。会丢弃队列中等待时间最长的任务，然后尝试将新任务加入队列。CallerRuns 调用者运行策略。不会抛弃任务，而是将任务返回给调用者，由调用者所在的线程执行。 三、自定义线程池工创建工厂 通过实现 ThreadFactory 接口，实现自定义线池创建工厂。
如下，自定义线程创建工厂，在创建线程时设置线程名称。
private static void test2() { ThreadFactory threadFactory = new ThreadFactory(){ @Override public Thread newThread(Runnable r) { Thread thread = new Thread(r); thread.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b75508f5986c1e5eab5bf4f2746040b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d92c74d7ecf0e03f94e56c8dadcbe24/" rel="bookmark">
			IP网段去重复去包含
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		需求：内部资产盘点（漏洞）扫描
问题：公司大了，内网网段“剪不断理还乱”…，拿到上千个网段信息，在扫描前需要去重复和去包含关系，防止重复扫描和提升扫描效率
解决：python脚本，有个处理网段的库灰常好用IPy库实现。（自己尝试通过网络掩码位数写了写逻辑去重，也是不那么得手。（安装 pip install IPy）
处理脚本：
#去ip段的重叠、包含等 from IPy import IP file = 'hostnetmask.txt.py' #需要去重复的ip网段文件（按行） def ipuniq(): dlist = [] with open(file,'r') as ff: for x in ff.readlines(): x = x.strip() with open(file, 'r') as f: for i in f.readlines(): i = i.strip() if i != x: if IP(i) in IP(x): # 判断网段是否包含 print('{} &gt;&gt;&gt;&gt;&gt; {}'.format(i,x)) dlist.append(i) dlist.sort() data = [] print('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;去重复后的网段&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;') with open(file,'r') as df: for n in df.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d92c74d7ecf0e03f94e56c8dadcbe24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3c5819461d6c27ae2a7760ec703d848/" rel="bookmark">
			凯斯西储大学轴承数据解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、凯斯西储大学轴承数据基础知识？1.1 故障种类1.2 故障点尺寸（单点故障）1.3 载荷和转速 二、数据解读2.1 文件2.2 以12k Drive End Bearing Fault Data为例2.3 以（0.007''，inner race)为例。 3 Normal Baseline Data是12k原因3.1 部分代码（频谱分析代码）3.2 数据分析 总结 数据集官网
本文不做数据集的基本描述，只说明可能遇到的疑惑
关于数据集的具体解读参考链接：https://www.cnblogs.com/gshang/p/10712809.html
一、凯斯西储大学轴承数据基础知识？ 1.1 故障种类 内圈故障外圈故障滚动体故障 1.2 故障点尺寸（单点故障） 直径0.007英寸（SKF轴承）直径0.014英寸（SKF轴承）直径0.021英寸（SKF轴承）直径0.028英寸（NTN轴承，一般不用）直径0.040英寸（NTN轴承，一般不用） 1.3 载荷和转速 0马力-1797r/min1马力-1772r/min2马力-1750r/min3马力-1730r/min 二、数据解读 2.1 文件 Normal Baseline Data（12k）
12k Drive End Bearing Fault Data
48k Drive End Bearing Fault Data
Fan-End Bearing Fault Data(12k)
2.2 以12k Drive End Bearing Fault Data为例 12k Drive End Bearing Fault Data是驱动端轴承故障数据，它包含如下的数据，
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3c5819461d6c27ae2a7760ec703d848/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c28ab6d5587458eeb9f03168fd81231f/" rel="bookmark">
			前端FLV视频直播解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目背景： 1. 后台给出一个地址，持续不断的推送flv视频流。
2.前端需要接收视频流，并寻找合适的播放插件。
一开始： 其实用的是xgplayer（西瓜视频）。
官网地址：西瓜播放器
使用的是直播，flv的插件：西瓜播放器 | xgplayer-flv。
但是无法播放，现象就是一直loading；
后来，查了好多资料，发现一个issue：
流数据正常下载，xgplayer-flv无法播放 · Issue #604 · bytedance/xgplayer · GitHub。
和我情况一模一样，但是暂时没有什么解决方案。说明，此路不通。
柳暗花明： 找了很久，找到一个万能播放插件 —— Jessibuca。
官网地址：Jessibuca
如何使用： 前端如何使用？建议直接下载相关资源，静态引入。
需要下载三个资源，如下图：
怎么找到这三个资源？去官网的network里找找吧，不在多说。
vue中使用详情： 首先，上边的三个文件引入public。在index.html文件中只需要引入jessibuca.js。
&lt;!-- public下的index.html 直接引入js文件 --&gt; .... &lt;script src="&lt;%= BASE_URL %&gt;jessibuca.js"&gt;&lt;/script&gt; ..... 然后,创建视频播放组件 LiveVideoPlay.vue:
&lt;script&gt; export default { name: "LiveVideoPlay", props: { // 播放地址 playUrl: { type: String, required: true, }, // 目标domid id: { type: String, required: true, }, }, data() { return { player: null, }; }, methods: { // 初始化视频组件 initPlayer() { if (Jessibuca) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c28ab6d5587458eeb9f03168fd81231f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f91ba31f5300161ff45a40e0f69bda15/" rel="bookmark">
			2023 英特尔On技术创新大会直播让我感受到英特尔AI的强大
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、2023 英特尔On技术创新大会简单回顾 直播地址：英特尔On技术创新大会 (intel.cn)
· 英特尔明确表示其“四年五个制程节点”计划正在稳步推进当中，并展示了其首个基于通用芯粒高速互连开放规范(UCIe)的多芯粒封装。
· 英特尔公布了下一代英特尔®至强®可扩展处理器的全新细节，包括能效和性能方面的重大提升，以及288核能效核(E-core)处理器的最新披露。第五代英特尔®至强®可扩展处理器将于12月14日正式发布。
· AI PC将在于12月14日发布的英特尔®酷睿™Ultra处理器上得到展现。配备英特尔首款集成的神经网络处理器，酷睿Ultra将在PC上带来高能效的AI加速和本地推理体验。
· 一台大型AI超级计算机将采用英特尔至强处理器和英特尔® Gaudi®2 AI硬件加速器打造，Stability AI是其主要客户。
· 英特尔宣布英特尔®开发者云平台已全面上线，该平台用于测试和构建AI等高性能的应用程序，并分享了与客户实际使用相关的细节信息。
· 全新和即将推出的英特尔软件解决方案，包括英特尔®发行版OpenVINO™工具套件2023.1版，将帮助开发者解锁新的AI功能。
二、英特尔AI的强大魅力 1、非常全面的、易用的开发者资源 2、助理开发者创新、共拓数字经济机遇。 3、开放生态、让开发者赢在起跑线上 4、开放式加速计算 5、端到端AI软件组合、扩展边缘和终端优化，让每个人都可以成为AI开发者。 三、英特尔AI的总结 1、英特尔AIPC和全新应用提供动力
2、以性能提升推动AI无处不在
3、推出搭载英特尔酷睿Ultra强大的处理器的AI PC
4、让开发者成为芯经济的驱动者
5、引领AI新纪元，重构PC体验，让AI无处不在
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/84/">«</a>
	<span class="pagination__item pagination__item--current">85/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/86/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>