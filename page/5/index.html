<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a48c8c9e7946fe5e440a9a3319c8e5d7/" rel="bookmark">
			【go语言开发】性能分析工具pprof使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文主要介绍如何在项目中使用pprof工具。首先简要介绍pprof工具的作用；然后介绍pprof的应用场景，主要分为工具型应用和服务型应用。最后数据分析项目，先采集项目信息，再可视化查看
文章目录 前言应用场景工具型应用服务型应用 数据分析命令行查看采集数据查看数据topGraphFlame GraphSource 欢迎大家访问个人博客网址：https://www.maogeshuo.com，博主努力更新中…
前言 pprof是Go语言的一个性能分析库，它的名字源于**“Profile”（简称"prof"）**一词。该工具最早由Google开发并用于Go语言的性能分析，它可以帮助开发者找出程序中的性能瓶颈。pprof提供了CPU分析、内存分析、阻塞分析等多种性能分析功能。
CPU分析： pprof可以通过采样应用程序的运行状态来分析CPU的使用情况，找出哪些函数占用了大量的CPU时间。提供CPU使用率最高的函数列表和调用关系，帮助定位程序的CPU性能瓶颈。 内存分析： 支持对应用程序的内存分配和使用情况进行分析，帮助开发人员发现内存泄漏、高内存消耗的函数等问题。提供内存使用最多的函数列表和调用关系，帮助优化内存管理和减少不必要的内存分配。 阻塞分析： pprof可以分析应用程序中的阻塞情况，识别并发执行过程中可能存在的阻塞问题。提供阻塞最严重的代码段和调用关系，帮助优化并发执行的性能和减少阻塞时间。 goroutine分析： 支持对应用程序中goroutine的跟踪和分析，帮助理解并发执行情况。提供goroutine的数量、状态和调用关系等信息，帮助优化并发编程和避免goroutine泄漏。 堆分析： pprof可以生成堆内存分配和释放的时间序列图，帮助开发人员了解程序在运行过程中的内存分配情况。提供堆内存使用的趋势和波动情况，帮助优化内存管理和减少内存占用。 除了这些功能外，pprof还提供了对运行时调用图的可视化展示。pprof可以很容易地集成到任何Go程序中，只需在程序中导入net/http/pprof包，并启动一个HTTP服务器，就可以通过Web界面查看性能数据。
应用场景 pprof工具的应用场景主要分为两种：
服务型应用：web服务性能分析工具型应用：输入命令行应用等 工具型应用 如果你想在不使用HTTP服务的情况下对应用程序进行性能分析，可以直接使用 runtime/pprof 包中提供的函数来生成性能分析数据。
package main import ( "log" "os" "runtime" "runtime/pprof" "time" ) func main() { Analysis() } func Analysis() { // 创建 CPU 分析文件 cpuProfile, err := os.Create("./profile/cpu.prof") if err != nil { log.Fatal(err) } defer cpuProfile.Close() // 开始 CPU 分析 if err := pprof.StartCPUProfile(cpuProfile); err !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a48c8c9e7946fe5e440a9a3319c8e5d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/462ce08319170efc9efa5c427464570e/" rel="bookmark">
			数据结构/C&#43;&#43;：红黑树
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据结构/C++：红黑树 概念实现基本结构插入uncle为红色节点uncle为黑色节点 总代码展示 概念 红黑树是一种二叉搜索树，一般的二叉搜索会发生不平衡现象，导致搜索效率下降，于是学者们开始探索如何让二叉搜索树保持平衡，这种树叫做自平衡二叉搜索树。起初学者发明了AVL树，其通过一定算法保持了二叉搜索树的严格平衡，不久后Rudolf Bayer发明了红黑树，红黑树的平衡是较为宽泛的，为了保持平衡，红黑树付出的代价比AVL树更小。因此红黑树被更为广泛的使用，比如Java，C++，python中，使用的自平衡二叉搜索树都是红黑树，而不是AVL树。
如果想了解AVL树，可以看这篇博客：[数据结构/C++：AVL树]
红黑树的要求如下：
红黑树中，最长路径的长度不会超过最短路径的两倍
先解释一下路径的概念：从根走到nullptr。
有不少人认为路径是从根走到叶子节点，这是不正确的。
红黑树用了五条规则来限制一棵树，从而达到以上要求：
每个节点不是红色就是黑色根节点一定是黑色不可以出现连续的红色节点（黑色可以连续出现） 每一条路径都包含相同数目的黑色节点nullptr视为黑色节点 只要满足以上五个条件，那么这棵树就是一颗红黑树，而且满足最长路径的长度不会超过最短路径的两倍。为什么呢？
五条规则中，我标红了3，4两条规则：
不可以出现连续的红色节点（黑色可以连续出现） 每一条路径都包含相同数目的黑色节点 由于每一条路径都必须包含相同数目的黑色节点，现在我们假设一棵红黑树，所有路径的黑色节点数目都是x，那么最短的路径长度就是全为黑色节点，长度为x。
如果想让一条路径变长，那么就只能插入更多的红色节点（因为黑色节点数目相同），但是红色节点又不能连续出现，所以只能是黑红黑红黑红黑红黑红......这样排列，一个黑节点匹配一个红节点，因此最长路径的长度就是黑色节点的两倍2x。
可以发现，红黑树通过这两条核心规则，保证了二叉搜索树的平衡。
比如以下就是一颗红黑树：
其最短路径为最左侧的路径，长度为2，即两个黑节点。
其最长路径为最右侧的路径，长度为4，即一红一黑排列。
要注意的是：不是所有的红黑树都会出现以上的全黑路径，或者一红一黑路径的，这只是极端情况。
接下来我们通过实现红黑树，来了解红黑树是如何自平衡的：
实现 基本结构 首先我们要在节点中加入一个成员来表示节点的颜色，颜色有红黑和黑色两种状态，这里我使用枚举来区分两者：
enum Colour { RED, BLACK }; 在某些红黑树的实现中，使用bool值来表示红黑颜色，这也是可以的，但是本博客以枚举来表示颜色。
节点类：
template&lt;class K, class V&gt; struct RBTreeNode { RBTreeNode* _left; RBTreeNode* _right; RBTreeNode* _parent; pair&lt;K, V&gt; _kv; Colour _col; }; _left：左子树
_right：右子树
_parent：父节点
_kv：节点存储的值
_col：该节点的颜色
节点类还需要一个构造函数进行初始化，现在的问题就是：新的节点要初始化为什么颜色？
先来考虑一下：插入红色节点和插入黑色节点，谁对红黑树影响大？
对于一棵红黑树，其所有路径的黑色节点数目都相同，如果我们在某一条路径末尾插入了黑色节点，那么整棵树的所有其它路径都会少一个黑节点。而插入红色节点只影响当前路径，所以新节点应该是红色节点。
构造函数：
RBTreeNode(const pair&lt;K, V&gt;&amp; kv) : _left(nullptr) , _right(nullptr) , _parent(nullptr) , _kv(kv) , _col(RED)//初始化为红节点 {} 接着就是红黑树本体，类中只存储一个根节点_root：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/462ce08319170efc9efa5c427464570e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f39b0ce58311b8bbf116a0c199e234dc/" rel="bookmark">
			一套为中小电商企业构建的、开源的、简单实用的ERP系统需要接入的电商API接口以及实现的功能模块分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、项目简介 电商ERP系统为中小电商企业构建的一套简单实用的电商系统，本项目采用Java SpringBoot+Vue2前后端分离开发。
支持供应商一件代发和仓库发货两种发货方式，主体流程覆盖采购、网店订单处理、供应商一件代发、仓库发货、网店售后、仓库出入库、采购结算、代发结算、网店账单管理、市场洞察（数据收集、分析）等功能，基本上覆盖了电商日常业务。
二、接入的电商API商品采集接口
此API目前支持以下基本接口：
item_get 获得淘宝商品详情item_get_pro 获得淘宝商品详情高级版item_review 获得淘宝商品评论item_fee 获得淘宝商品快递费用item_password 获得淘口令真实urlitem_list_updown 批量获得淘宝商品上下架时间seller_info 获得淘宝店铺详情item_search 按关键字搜索淘宝商品item_search_tmall 按关键字搜索天猫商品item_search_pro 高级关键字搜索淘宝商品item_search_img 按图搜索淘宝商品（拍立淘）item_search_shop 获得店铺的所有商品item_search_seller 搜索店铺列表item_search_guang 爱逛街item_search_suggest 获得搜索词推荐item_search_jupage 天天特价item_search_coupon 优惠券查询cat_get 获得淘宝分类详情item_cat_get 获得淘宝商品类目item_search_samestyle 搜索同款的商品item_search_similar 搜索相似的商品item_sku 获取sku详细信息item_recommend 获取推荐商品列表brand_cat 获取品牌分类列表brand_cat_top 获取分类推荐品牌列表brand_cat_list 得到指定分类的品牌列表brand_keyword_list 得到指定关键词的品牌列表brand_info 得到品牌相关信息brand_product_list 得到指定品牌的产品custom 自定义API操作buyer_cart_add 添加到购物车buyer_cart_remove 删除购物车商品buyer_cart_clear 清空购物车buyer_cart_list 获取购物车的商品列表buyer_cart_order 将购物车商品保存为订单buyer_order_list 获取购买到的商品订单列表buyer_order_detail 获取购买到的商品订单详情buyer_order_express 获取购买到的商品订单物流buyer_order_message 获取购买到的订单买家留言buyer_address_list 收货地址列表buyer_address_clear 清除收货地址buyer_address_remove 删除收货地址buyer_address_modify 修改收货地址buyer_address_add 添加收货地址buyer_info 买家信息buyer_token 买家tokenseller_order_list 获取卖出的商品订单列表seller_order_detail 获取卖出的商品订单详情seller_order_close 卖家关闭一笔交易seller_order_message 获取或修改卖出去的订单备注seller_auction_list 商品可上下架商品列表seller_auction 商品上下架seller_item_add 商品上传upload_img 上传图片到淘宝img2text 图片识别商品接口tbk_order_query 淘宝客订单查询item_list_weight 批量获取商品信息item_history_price 获取商品历史价格信息item_get_app 获得淘宝app商品详情原数据 三、技术选型
1、技术栈
vue2 + elementUI
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f39b0ce58311b8bbf116a0c199e234dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4ce2d00254404f50f1fb5f77dd9dafa1/" rel="bookmark">
			Tiktok在线网页版和Tiktok安卓解锁版教程（Tiktok免登录国内直接看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TikTok和抖音作为众所周知的一对兄弟，所开创的市场前景不可估量。它们不仅颠覆了很多传统认知，也直接让更多人接受了这些新奇事物。然而，TikTok的版本受限于国外，需要特定网络环境，一旦识别为国内，将无法使用。那么，在国内是否有直接观看TikTok的方法呢？实际上是有的。
软件下载地址：https://pan.quark.cn/s/a1d0fbf6fe55
点赞收藏评论区留言“已关注 求 ”！获取加速器免费不限制时间的方法！+WX ITStudyClass 无偿 我建了一个群，都是玩海外的友友们，更多资源和后续更新会在群内免费分享
与国内版的抖音相似，TikTok也提供了短视频分享、社交网络、短视频竞赛和直播打赏等功能。拥有超过15亿月活跃用户，内容涵盖了世界各地的文化和风俗习惯。
但由于某些原因，它在国内的使用受到限制，打开时会显示无网络黑屏，甚至直接闪退。
这是因为软件一旦检测到你插入了国内运营商的SIM卡，即便顺利突破限制，也几乎无法访问。
现在主流方法是拔卡，但拔卡比较麻烦，很多人只是想单纯刷视频不想动脑。
今天分享tiktok免登录国内直接看教程。
网页版步骤如下：
1、下载安装谷歌浏览器，无需拔卡。
2、打开加速器（免费不限制时间）
3、打开谷歌浏览器，输入TikTok在线网址：tiktok.com 即可浏览。
4、可以选择手机号（国外手机号）、邮箱（国外邮箱）、第三方国外平台注册。推荐用谷歌邮箱注册。
5、如果你单纯想浏览海外风景，可以点击下方“以游客身份继续”选项。此选项只能浏览视频，无法点赞评论关注打赏，想要使用更多功能还需注册账号。
APP版步骤如下：
1、安装tiktok
2、安装TikTokPlugin
3、安装加速器（免费不限制时间）
去所有广告、去保存视频水印、解除国家/地区限制，无视区域封锁提供额外插件可设置全球国家区域,设置视频保存位置,等自定义设置解除视频下载限制，可存储任何视频无视权限；解除合拍/拼接限制给视频添加播放进度条显示；为下载视频文件的名称添加了作者标签修改GIF和视频默认保存位置重定向为Movies/TikTok目录文件夹存储；支持手机号码登陆；修正谷歌授权、Facebook授权、VK授权；移除了调试信息；禁用不必要活动控件、禁用所有类型分析、禁用统计分析、对齐优化、极限压缩；启用观看历史、优化电池消耗、禁用自动启动，隐藏的根权限，删除许多其他限制强制启用高画质视频、强制启用高品质音频、强制启用超清分辨率、并启用抗锯齿 备注：TikTok插件(TikTokPlugin)可以自定义设置，用于配合此修改版选择全球区域！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8b39cce4ee85a089e62902bb3ad208c/" rel="bookmark">
			分享一下自己总结的7万多字java面试笔记和一些面试视频，简历啥的，已大厂上岸
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一下自己总结的7万多字java面试笔记和一些面试视频，简历啥的，已大厂上岸
自己总结的面试简历资料：https://pan.quark.cn/s/8b602fe53b58
文章目录 SSMspring============================================spring 的优点？IoC和AOP的理解**Bean 的生命周期****列举一些重要的Spring模块？****Spring框架中用到了哪些设计模式****@Component和@Bean的区别是什么****Spring事务管理的方式有几种？****Spring事务中的隔离级别有哪几种？****Spring事务中有哪几种事务传播行为？**spring常用的注入方式有哪些？spring中的bean是线程安全的吗？ springmvc===================================SpringMVC的流程？JSP 九大内置对象和四大作用域spring mvc有哪些组件？@RequestMapping的作用是什么？@Autowired的作用是什么？@Autowired 与@Resource的区别Springmvc的优点:FactoryBean 与 BeanFactory 有什么区别？@Transactional 注解哪些情况下会失效？项目中如何用 Spring 和 Spring MVC 框架的？ mybatis=======================================MyBatis是什么？有什么作用？Mybaits 的优缺点#{} 和 ${} 的区别MyBatis 中实体类的属性名与表中的字段名不一致怎么处理？Mapper 接口如何与写 SQL 的 XML 文件进行绑定的？MyBatis 如何批量插入？MyBatis 是如何与 Spring 集成的？ springboot====================================**为什么要用 Spring Boot？****Spring Boot 的核心配置文件有哪几个？它们的区别是什么？****Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？**常用注解**开启 Spring Boot 特性有哪几种方式？****运行 Spring Boot 有哪几种方式？****Spring Boot 自动配置原理是什么？**SpringBoot 有几种读取配置文件的方式**你如何理解 Spring Boot 配置加载顺序？****Spring Boot 如何定义多套不同环境配置？****Spring Boot 可以兼容老 Spring 项目吗，如何做？** springCloud微服务架构====================什么是微服务架构Spring Cloud 是什么SpringCloud的优缺点SpringBoot和SpringCloud的区别？pringCloud由什么组成Spring Cloud 和dubbo区别?Eureka服务注册和发现是什么意思？Spring Cloud 如何实现？什么是EurekaEureka怎么实现高可用什么是Eureka的自我保护模式，DiscoveryClient的作用Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别 Zuul什么是网关?网关的作用是什么网关与过滤器有什么区别常用网关框架有那些？Zuul与Nginx有什么区别？既然Nginx可以实现网关？为什么还需要使用Zuul框架Zuul网关如何搭建集群 Ribbon负载平衡的意义什么？Ribbon是什么？Nginx与Ribbon的区别Ribbon底层实现原理@LoadBalanced注解的作用 Hystrix什么是断路器什么是 Hystrix？谈谈服务雪崩效应在微服务中，如何保护服务?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8b39cce4ee85a089e62902bb3ad208c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27e929bec693af9fe87ca7a5609a2831/" rel="bookmark">
			CSS:mix-blend-mode 颜色混合
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、属性 mix-blend-mode: normal; //正常
mix-blend-mode: multiply; //正片叠底
mix-blend-mode: screen; //滤色
mix-blend-mode: overlay; //叠加
mix-blend-mode: darken; //变暗
mix-blend-mode: lighten; //变亮
mix-blend-mode: color-dodge; //颜色减淡
mix-blend-mode: color-burn; //颜色加深
mix-blend-mode: hard-light; //强光
mix-blend-mode: soft-light; //柔光
mix-blend-mode: difference; //差值
mix-blend-mode: exclusion; //排除
mix-blend-mode: hue; //色相
mix-blend-mode: saturation; //饱和度
mix-blend-mode: color; //颜色
mix-blend-mode: luminosity; //亮度
mix-blend-mode: initial; //初始
mix-blend-mode: inherit; //继承
mix-blend-mode: unset; //复原
二、效果展示 三、测试地址 缓若江海凝清光
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2dac4a7109be667163cbd39db005ad29/" rel="bookmark">
			检索增强生成（RAG）应用的构建：LangChain与LlamaIndex的比较与选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于我要做RAG应用，我应该使用两者中的哪一个。或者说还是都使用？
在人工智能领域，检索增强生成（RAG）应用正变得越来越受欢迎，因为它们能够结合大型语言模型（LLMs）的自然语言处理能力和私有或专有数据源的丰富信息。在构建RAG应用时，开发者面临的一个重要选择是选择合适的工具或框架。本文将探讨两个流行的工具：LangChain和LlamaIndex，并提供决策指南。
LangChain：多功能的LLM应用开发框架 LangChain是一个全面的开发框架，专注于简化LLM应用的开发过程。它提供了一套工具、组件和接口，使得开发者能够轻松地构建复杂的应用程序。LangChain的核心优势在于其“可组合性”，允许开发者通过串联不同的LLMs和其他系统来创建强大的应用。
RAG应用：LangChain通过其chains和agents模块支持RAG应用的开发。这些模块使得开发者可以组织任务顺序、调用特定工具，并持久化内存状态，从而构建出能够记住以前交互的聊天机器人或智能助理。
社区和支持：LangChain拥有一个活跃的社区和开发者群体，这为开发者提供了丰富的资源和支持。
LlamaIndex：专注于数据层的RAG构建工具 LlamaIndex是一个专为构建RAG应用程序而设计的Python库，它专注于数据层，并提供了从基础到高级的检索策略，以帮助开发者在RAG流程中实现精准检索。
RAG应用：LlamaIndex通过其retrievers模块提供了一系列的检索策略，这些策略可以帮助开发者在构建RAG应用时实现高效的信息检索。此外，LlamaIndex支持多种存储后端，使得开发者可以灵活地处理和存储数据。
数据连接器：LlamaIndex的数据连接器（Reader）可以加载不同数据源的数据，并将数据格式化为Document对象，这些对象存储文本和元数据，为RAG应用提供了坚实的数据基础。
选择指南：LangChain还是LlamaIndex？ 在选择LangChain和LlamaIndex时，考虑以下因素：
项目复杂性：如果您的项目需要复杂的任务调度和多模型集成，LangChain可能是更好的选择。
数据管理需求：如果您的项目侧重于数据检索和索引，LlamaIndex可能更适合。
社区和支持：LangChain的活跃社区可能为您提供更多的帮助和资源。
技术栈兼容性：考虑您的技术栈和现有工具与LangChain或LlamaIndex的兼容性。
结合使用：双剑合璧 在某些情况下，结合使用LangChain和LlamaIndex可能是最佳策略。LangChain的高级应用开发能力和LlamaIndex的高效数据检索能力可以相辅相成，共同构建出一个功能强大、数据驱动的RAG应用。
结论 在构建RAG应用时，LangChain和LlamaIndex各有其独特的优势。选择哪个工具，或者是否结合使用，取决于您的项目需求、技术栈和资源。通过深入理解每个工具的特点，您可以做出最适合您项目的决策，并构建出一个成功的RAG应用。
在构建RAG应用时，没有一种“一刀切”的解决方案。根据您的具体需求和资源，您可以选择最适合您的工具，或者将两者的优势结合起来，打造出一个强大且高效的应用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f767080ecd00cc91ffe40baa8301940c/" rel="bookmark">
			pom.xml中的配置无法被yaml读取
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述 项目中指定了多个profiles, 但是application.yaml读取报错，报错信息如下
Standard Commons Logging discovery in action with spring-jcl: please remove commons-logging.jar from classpath in order to avoid potential conflicts 12:41:52.325 [main] ERROR org.springframework.boot.SpringApplication -- Application run failed org.yaml.snakeyaml.scanner.ScannerException: while scanning for the next token found character '@' that cannot start any token. (Do not use @ for indentation) in 'reader', line 3, column 13: active: @env@ ^ at org.yaml.snakeyaml.scanner.ScannerImpl.fetchMoreTokens(ScannerImpl.java:445) at org.yaml.snakeyaml.scanner.ScannerImpl.checkToken(ScannerImpl.java:238) at org.yaml.snakeyaml.parser.ParserImpl$ParseBlockMappingValue.produce(ParserImpl.java:669) at org.yaml.snakeyaml.parser.ParserImpl.peekEvent(ParserImpl.java:161) at org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f767080ecd00cc91ffe40baa8301940c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46a078ce080e4fde1477be77bcc777a4/" rel="bookmark">
			LeetCode 新的开始day1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LeetCode 新的开始day1 嗨嗨嗨。。。一个期末加春节，直接给我干颓废了，导致算法之旅被打乱，现在也是准备另起灶炉，好好学习一下了（虽然因为服务外包比赛这两个月挺消耗精力的，不够我还是打算抽点时间来算法这边散散心，然后也是有节奏的刷起来）
也是看到大佬提供的刷题路线，感觉很是适合咱，那有什么说的呢，干就完了，然后也打算每周六总结一次。
首先来到的是数学题路线（基础很重要好吧）
这里就说说今天遇到的两个重要的知识点
首先的话，就是辗转相除法求最大公因子
2427. 公因子的数目 给你两个正整数 a 和 b ，返回 a 和 b 的 公 因子的数目。
如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 公因子 。
示例 1：
输入：a = 12, b = 6 输出：4 解释：12 和 6 的公因子是 1、2、3、6 。 示例 2：
输入：a = 25, b = 30 输出：2 解释：25 和 30 的公因子是 1、5 。 class Solution { public int commonFactors(int a, int b) { int ant=0; int c=gcd(a,b); for(int i=1;i&lt;=c;i++){ if(a%i==0&amp;&amp;b%i==0) ant++; } return ant; } public int gcd(int a,int b){ while(b!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46a078ce080e4fde1477be77bcc777a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4913c28d9c3c76ab0589d7e72fa065b0/" rel="bookmark">
			Linux：时间指令 - cal &amp; date
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux：时间指令 - cal &amp; date date指令cal指令 date指令 date用于以指定格式显示时间
我们先看看直接输入date指令的效果：
[hxy@iZ2zehtehrgzt3wqccrpyfZ CSDN]$ date Tue Mar 12 21:38:01 CST 2024 直接输入date指令，得到了以 星期 月 日 时:分:秒 时区 年为格式的时间。
但是date指令可以按照自己制定的格式来输出时间
使用者可以设定格式，语法为一个 + 后接数个标记
常用标记如下：
标记含义%H小时%M分钟%s秒%X相当于 %H:%M:%S%d日%m月%Y年%F相当于%Y-%m-%d 示例：
[hxy@iZ2zehtehrgzt3wqccrpyfZ CSDN]$ date +%F_%X 2024-03-12_09:50:15 PM 以上示例中，+%F_%X这个整体就用于格式化输出，其以一个+开头。对照上方的标记表格，其实%F就对应了2024-03-12，%X就对应了09:50:15 PM，而他们的分隔符也是可以有我们自己穿插的：
[hxy@iZ2zehtehrgzt3wqccrpyfZ CSDN]$ date +%Y:%m-%d_%H 2024:03-12_21 这样每个标记都显示了自己代表的时间，而每个时间之间的符号完全由我们自己决定。
date指令还可以用于输出时间戳，先简单讲解一下时间戳的概念：
时间戳是从格林威治时间1970年01月01日00时00分00秒开始至今所经过的秒数
通过+%s来获取时间戳：
示例：
[hxy@iZ2zehtehrgzt3wqccrpyfZ CSDN]$ date +%s 1710251847 其中1710251847就是当前的时间戳。
通过-d @1710252008，把时间戳转化为时间：
示例：
[hxy@iZ2zehtehrgzt3wqccrpyfZ CSDN]$ date -d @1710252008 Tue Mar 12 22:00:08 CST 2024 可以看到，1710252008时间戳代表的就是2024年3月12日22:00:08，我们也可以按照制定格式输出刚刚的时间戳：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4913c28d9c3c76ab0589d7e72fa065b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/becd1c2c774a8cafc365673d71e5b553/" rel="bookmark">
			C语言之二分查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 简介
二 代码实现
三 时空复杂度
A.时间复杂度（Time Complexity）：
B.空间复杂度（Space Complexity）：
C.总结
一 简介 二分查找算法（Binary Search）在C语言中是一个用于有序数组查找特定元素的高效算法。其基本思想是通过不断将查找区间减半来逼近目标值，直到找到目标或确定目标不存在于数组中。
二 代码实现 以下是使用C语言实现二分查找算法的一个简单示例：
#include &lt;stdio.h&gt; // 二分查找函数 int binarySearch(int arr[], int left, int right, int target) { while (left &lt;= right) { // 当左边界小于等于右边界时继续循环 int mid = left + (right - left) / 2; // 计算中间位置的索引 if (arr[mid] == target) { // 如果中间元素就是目标值 return mid; // 返回目标值所在的位置 } else if (arr[mid] &lt; target) { // 如果中间元素小于目标值 left = mid + 1; // 在右半部分（包括中间点右侧）进行查找 } else { // 若中间元素大于目标值 right = mid - 1; // 在左半部分（包括中间点左侧）进行查找 } } // 若未找到目标值，则返回-1表示目标值不在数组中 return -1; } int main() { int sortedArray[] = {1, 3, 5, 7, 9, 11, 13, 15}; int n = sizeof(sortedArray) / sizeof(sortedArray[0]); int target = 7; int result = binarySearch(sortedArray, 0, n - 1, target); if (result !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/becd1c2c774a8cafc365673d71e5b553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13df059581333df7fcc19f1f8a4da5c/" rel="bookmark">
			C语言之判断浮点数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一 简介
二 代码实现
A.方法一
B.方法二
二 时空复杂度
A.方法一
B.方法二
一 简介 在C语言中，判断浮点数的算法通常涉及到比较两个浮点数是否相等或比较它们的大小。由于浮点数运算存在精度误差问题，直接使用 == 或 != 进行比较可能会导致不准确的结果。因此，一般采用近似比较方法来判断浮点数的相等性或大小关系。
二 代码实现 A.方法一 以下是一个简单的示例，用于判断一个浮点数是否接近于零：
#include &lt;stdio.h&gt; #include &lt;math.h&gt; // 需要包含这个头文件以使用fabs函数 bool isZero(double x, double epsilon) { return fabs(x) &lt; epsilon; } int main() { double num = 0.000001; double epsilon = 1e-6; // 定义一个足够小的阈值 if (isZero(num, epsilon)) { printf("%f 可以认为是近似为0的浮点数\n", num); } else { printf("%f 不是近似为0的浮点数\n", num); } return 0; } B.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13df059581333df7fcc19f1f8a4da5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b127055ab322923df040f6e953298678/" rel="bookmark">
			无线安全：WEP、WPA、WPA2 和 WPA3 说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
什么是无线安全?
无线安全如何工作?
无线安全协议的类型及其工作原理
如何保护您的 Wi-Fi 网络
底线：无线安全
什么是无线安全? 无线安全是指用于保护网络免受未经授权的访问、盗窃和其他敌对行为的技术和实践。 无线网络使用无线电波广播数据，网络范围内的任何人都可以拦截这些数据。 因此，无线网络很容易遭到窃听、非法访问和盗窃。 使用加密协议、访问控制规则和身份验证程序等安全措施可防止未经授权的访问并保护这些无线网络.
无线网络可以是蜂窝网络、无线局域网或其他传感器或通信网络，但 Wi-Fi 是人们通常最熟悉的无线网络协议.
WEP、WPA、WPA2 和 WPA 等无线安全协议通常用于保护无线网络。 最古老的协议 WEP 由于容易受到攻击而不再被认为是安全的。 另一方面，WPA 和 WPA2 是作为 WEP 的改进版本发布的.
无线PA2 是使用最广泛的协议，因为它使用 AES 加密技术来提高安全性。 WPA3 是最新的协议，提供更好的安全功能，例如更强的加密、防止字典攻击以及更轻松地设置 IoT 设备，但尚未广泛使用.
无论您选择什么，强大的安全协议对于保护无线网络和敏感数据至关重要.
无线安全如何工作? 无线网络中使用的主要安全措施包括加密、身份验证、访问控制以及入侵检测和预防。 这些措施旨在防止未经授权的访问，保证数据不被拦截，保护网络的安全性和可用性.
加密 是将数据转换为只能由具有适当密钥的授权用户读取的代码的过程。 有不同的加密协议（例如 WPA2 和 WPA3）用于保护无线网络.
验证 流程验证尝试连接到网络的个人和设备的身份。 例如，Wi-Fi 保护访问 (WPA) 要求用户提供密码或密码短语才能访问网络.
访问控制规则 定义哪些人或设备被允许连接到网络以及他们拥有什么程度或级别的访问权限。 可以根据用户的角色、设备类型和所需的安全级别来配置访问控制。 最多 网络访问控制（NAC) 除了有线网络之外，解决方案还支持无线网络，并且许多 无线路由器 包括访问控制，例如 列入允许名单或拒绝名单.
设备安全 也是无线的重要组成部分 网络安全. 您需要对连接到任何网络的设备具有合理的信任级别，因此您可以设置的任何策略都需要诸如 防病毒软件, 更新的操作系统和 VPN 将保护网络及其用户。 尽可能限制设备管理员帐户的使用，以实现更好的个人保护, 移动设备安全.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b127055ab322923df040f6e953298678/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562badbd53326dfec97b3ca3d513f86e/" rel="bookmark">
			分享几个ES6常用的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是ES6 ？
ESMAScript 6.0(以下简称ES6)是 JavaScript 语言的下一代标准，已在2015年6月正式发布。它的目标：是使JavaScript语言可以编写复杂且大型应用，成为企业级开发语言。ES6既是一个历史名词，也是一个泛指，泛指涵盖了ES2015、ES2016、ES2017等的下一代JavaScript语言标准。 标准委员会规定每年6月正式发布一次标准，作为当年的正式版本。
2.了解Babel转码器
Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5，从而在老版本的浏览器中执行。不过现在的开发当中几乎不会用到了；所以说：你可以使用ES6的方式编写程序，也不用担心现有的环境是否支持。
// 转码前 input.map(item =&gt; item + 1); // 转码后 input.map(function(item){ return item + 1; }) 上面的原始代码用了箭头函数，Babel将其转为普通函数，就能在不支持箭头函数的 JavaScript环境执行了。目前各大技术栈（React/Vue/Angular）的脚手架项目都在使用babel作为默认的语言标准转码工具，可以在.babelrc文件中进行更多的自定义配置。
我们也可以通过官方提供的REPL在线编译器来体验Babel转码。
3.变量的解构赋值
ES6允许按照一定模式，从不同类型数据中提取值，然后对变量进行赋值，并且快读从对象或者数组里面获取一些数据，这杯称为：解构赋值
3.1 数组的解构赋值
在之前；我们给变量赋值只能直接指定一个变量值
let a = 12; let b = 11; let c = 10; 在ES6之后，就可以写成这样的
let [a, b, c] = [1, 2, 3]; 上面的代码表示，可以从数组中提取数值，按照对应的位置，对变量赋值。本质上，这种写法属于"匹配模式"，只要等号两边的模式相同，左边的变量就会被赋予对应的值，而解构赋值允许指定的默认值。
3.2 对象的解构赋值
对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值：
语法：let {key1, key2, ...} = {键值对1, 键值对2, ...}
const JsonData = { name: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/562badbd53326dfec97b3ca3d513f86e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e215f44bc2d4001aacbc4e3d31d95d/" rel="bookmark">
			论文阅读：Face Deblurring using Dual Camera Fusion on Mobile Phones
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天介绍一篇发表在 ACM SIGGRAPH 上的文章，是用手机的双摄系统来做人脸去模糊的工作。这也是谷歌计算摄影研究组的工作。
快速运动物体的运动模糊在摄影中是一个一直以来的难题，在手机摄影中也是非常常见的问题，尤其在光照不足，需要延长曝光时间的场景。最近几年，我们也看到了图像去模糊领域的巨大进步，不过大多数的图像去模糊方法的算法开销很高，需要依赖很高的算力，同时在处理高分辨率图像时还存在局限于不足。为了实现更轻量，效果更好的图像去模糊算法，文章作者提出了一种新的人脸去模糊方法，这个算法基于手机的双摄系统。当检测到场景中有运动物体的时候，会触发其中一路的参考摄像头，比如超广角，拍摄一张短曝光的图像，同时主摄拍摄一张正常曝光的图像，这样的话，超广角拍摄的图像是清晰的，但是噪声较多（曝光时间端，信噪比低），同时主摄拍摄的图像噪声少，但是会有模糊（曝光时间长，信噪比高）。文章作者用机器学习的模型取对齐两路图像，同时进行融合，最终输出的图像清晰，没有运动模糊。文章开发的算法在谷歌 Pixel 6 上的运行时间开销在 463ms，算法效率很高。文章中的实验，也展示了该算法的优势与鲁棒性。文章作者声称，他们的工作是第一个可以在手机上稳定可靠地在不同运动及光照环境下运行的人脸运动去模糊算法。
文章提出的解决方案建立在下面两个基础之上：
需要有双摄的手机系统，目前主流的手机都有双摄，文章中用到的双摄系统是主摄 W \mathbf{W} W 和超广角 U W \mathbf{UW} UW能够同步曝光，同步自动白平衡，为了便于两路图像后续的对齐与融合 实际使用的时候，系统会同时拍摄一张正常曝光的主摄图像以及短曝光的超广角图像。这两组图像反映了不同的拍摄视角，不同的噪声水平以及颜色。文章训练一个 CNN 网络，对齐，融合这两路图像的 RAW 图中的人脸区域，得到一张干净清晰的 RAW 格式的人脸区域，融合后的 RAW 图会送入一个标准的图像 ISP 系统做后续的处理。文章作者声称比起同一路的长短曝融合的方法，双摄系统的方法可以做到时间上的对齐，进而可以得到更好的融合效果。
这篇文章使用的主摄 W \mathbf{W} W FOV 是 8 0 ∘ 80^{\circ} 80∘，超广角 U W \mathbf{UW} UW FOV 是 10 7 ∘ 107^{\circ} 107∘。主摄和超广角基本是平行并排放置，超广角基本覆盖了主摄的视野。两路图像的分辨率都是 12M，一般来说，超广角 U W \mathbf{UW} UW sensor 的噪声水平会比主摄 W \mathbf{W} W sensor 的噪声水平要高。文章的融合算法，将两路图像作为输入，主摄 W \mathbf{W} W 作为源图像，超广角 U W \mathbf{UW} UW 作为需要融合的图像。当场景中物体运动被检测到，会启动双摄拍摄两路 RAW 图，主摄 W \mathbf{W} W 一路的曝光时间由手机的自动曝光算法确定，超广角一路的曝光时间被设置为主摄一路的 1 / N 1/N 1/N，文章中 N = 2 , 4 N=2, 4 N=2,4。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e215f44bc2d4001aacbc4e3d31d95d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4022e5a1cbde0c1cf158855e2a1eb2e/" rel="bookmark">
			Python图片PIL对象转cv2对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中，如果你想使用PIL（Python Imaging Library，也被称为Pillow）打开一个图片，然后将其转换为OpenCV（cv2）对象，你可以使用以下步骤：
首先，确保你已经安装了Pillow和OpenCV库。如果还没有安装，可以使用pip进行安装：
pip install pillow opencv-python 然后，你可以使用以下代码将PIL图片对象转换为cv2对象：
from PIL import Image import cv2 import numpy as np # 使用PIL打开图片 pil_image = Image.open('path_to_your_image.jpg') # 将PIL图片对象转换为numpy数组 numpy_image = np.array(pil_image) # 转换numpy数组的颜色通道顺序（因为PIL和OpenCV使用不同的颜色通道顺序） # OpenCV使用BGR，而PIL使用RGB cv2_image = cv2.cvtColor(numpy_image, cv2.COLOR_RGB2BGR) # 现在cv2_image是一个OpenCV图片对象，你可以使用OpenCV的函数对其进行操作 在这段代码中，我们首先使用PIL的Image.open函数打开图片。然后，我们将PIL图片对象转换为numpy数组。最后，我们使用OpenCV的cvtColor函数将numpy数组的颜色通道顺序从RGB转换为BGR，因为OpenCV默认使用BGR颜色空间。现在，cv2_image是一个OpenCV图片对象，你可以使用OpenCV的函数对其进行操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/124de8d1c4b14a7110149a217c63351f/" rel="bookmark">
			辣椒采摘机器人的结构设计
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
1绪论 1
1.1课题研究的意义 1
1.2国内外辣椒采摘机器人发展状况 1
1.4研究的内容和方法 4
1.5预期目标 5
1.6重点研究的关键问题及解决思路 5
1.7工作条件及解决方法 5
2辣椒采摘机器人总体设计 6
2.1收获的典型方法及收获方案的选择 6
2.2辣椒采摘机器人机的结构 6
3采摘机器人的基本参数的确定及相关设计 7
3.1作业速度 7
3.2割幅 8
3.3喂入量 8
3.4割刀速度和机器前进速度的关系 9
3.5辣椒采摘机器人下刀盘托的直径，拔辣椒盘尺寸和收缩比 10
3.6轴距、轮距、接地压力和最小离地间隙联合采摘机器人的轴距 10
3.7割刀切割数据计算 11
4切割系统的设计 13
4.1采摘机器人的上、下刀设计 13
4.2切割器的确定 14
5 辣椒秸秆打捆装置设计 15
5.1 辣椒秸秆打捆机的主要技术参数 15
5.2 驱动方式与工作原理 16
6其他结构的确定 17
6.1轴、轴承的设计计算 17
6.2辣椒采摘机器人输送系统的设计 21
6.3总体结构尺寸 22
6.4外形结构尺寸确定和中心估算 22
总 结 23
致 谢 24
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/124de8d1c4b14a7110149a217c63351f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f37228c8d8ee87fcb6374a0d2700d777/" rel="bookmark">
			云渗透工具-0.0.2版本更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		0x01 云资产管理工具
工具定位是云安全相关工具，目前是两个模块 云存储工具、云服务工具、其他工具。
‍
0x02 实现功能
阿里云：接管控制台、取消接管、Oss增删改查、远程命令执行回显、历史命令记录查看、子用户列表、云数据库管理、告警管理
腾讯云：接管控制台、取消接管、Oss增删改查、远程命令执行回显、子用户列表
华为云：接管控制台、取消接管、子用户列表
ucloud：接管控制台、主机查询、子用户列表查看、主用户查看、订单查看
AWS：接管控制台、主机查询、子用户列表查看、策略列表、创建后门
0x03 功能实现图
0x04 开放功能
云服务工具：AWS相关功能
其他工具：钉钉工具
优化内部bug
0x05 开放功能
macArm下载地址：https://github.com/dark-kingA/cloudTools/releases/download/main-2024-03-14/2024-03-14-0.1.2-mac-arm64.dmg`` ``macx64下载地址：https://github.com/dark-kingA/cloudTools/releases/download/main-2024-03-14/2024-03-14-0.1.2-mac-x64.dmg`` ``winx64下载地址：https://github.com/dark-kingA/cloudTools/releases/download/main-2024-03-14/2024-03-14-0.1.2-win-x64.exe`` ``项目地址：https://github.com/dark-kingA/cloudTools 0x06 加入云资产工具群
`黑客&amp;网络安全如何学习
今天只要你给我的文章点赞，我私藏的网安学习资料一样免费共享给你们，来看看有哪些东西。
1.学习路线图 攻击和防守要学的东西也不少，具体要学的东西我都写在了上面的路线图，如果你能学完它们，你去就业和接私活完全没有问题。
2.视频教程 网上虽然也有很多的学习资源，但基本上都残缺不全的，这是我自己录的网安视频教程，上面路线图的每一个知识点，我都有配套的视频讲解。
内容涵盖了网络安全法学习、网络安全运营等保测评、渗透测试基础、漏洞详解、计算机基础知识等，都是网络安全入门必知必会的学习内容。
（都打包成一块的了，不能一一展开，总共300多集）
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
3.技术文档和电子书 技术文档也是我自己整理的，包括我参加大型网安行动、CTF和挖SRC漏洞的经验和技术要点，电子书也有200多本，由于内容的敏感性，我就不一一展示了。
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
4.工具包、面试题和源码 “工欲善其事必先利其器”我为大家总结出了最受欢迎的几十款款黑客工具。涉及范围主要集中在 信息收集、Android黑客工具、自动化工具、网络钓鱼等，感兴趣的同学不容错过。
还有我视频里讲的案例源码和对应的工具包，需要的话也可以拿走。
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
最后就是我这几年整理的网安方面的面试题，如果你是要找网安方面的工作，它们绝对能帮你大忙。
这些题目都是大家在面试深信服、奇安信、腾讯或者其它大厂面试时经常遇到的，如果大家有好的题目或者好的见解欢迎分享。
参考解析：深信服官网、奇安信官网、Freebuf、csdn等
内容特点：条理清晰，含图像化表示更加易懂。
内容概要：包括 内网、操作系统、协议、渗透测试、安服、漏洞、注入、XSS、CSRF、SSRF、文件上传、文件下载、文件包含、XXE、逻辑漏洞、工具、SQLmap、NMAP、BP、MSF…
因篇幅有限，仅展示部分资料，需要点击下方链接即可前往获取
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b48f1774dd9594cb1dec724143a54a2/" rel="bookmark">
			【云服务环境】含泪总结：我在云服务安装Python爬虫环境Playwright的踩坑实录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是同学小张，日常分享AI知识和实战案例欢迎 点赞 + 关注 👏，持续学习，持续干货输出。+v: jasper_8017 一起交流💬，一起进步💪。微信公众号也可搜【同学小张】 🙏 本站文章一览：
总是想在自己的微信公众号中开发点什么功能，于是我又开始来折腾服务端的环境了。
这次是希望能在服务端配置起爬虫的环境，于是想着装个 Playwright，但没想到遇到这么多坑…
文章目录 0. 背景1. Playwright 安装1.1 基本安装过程1.2 踩坑实录1.2.1 坑一：/lib64/libc.so.6: version `GLIBC_2.28’ not found1.2.2 坑二：These critical programs are missing or too old: make bison compiler1.2.3 坑三：bash: __vsc_prompt_cmd_original: command not found1.2.4 坑四：/lib64/libstdc++.so.6: version `GLIBCXX_3.4.20‘ not found 2. 参考 0. 背景 环境：腾讯云服务，CentOS 7，宝塔面板
之前对环境做过的一些配置（安装 Anaconda，打通 GitHub，远程可视化开发）：
【超详细！超多图！】Python微信公众号开发（1）【超详细！超多图！】【代码管理】Python微信公众号开发（3）- 服务器代码上传Github【新人必会】远程开发可视化 - VSCode篇 为什么想到要安装 Playwright ？因为我运行 LangChain 加载URL网页内容时报错了：
运行的代码是这样的：
urls = ["https://mp.weixin.qq.com/s/2m8MrsCxf5boiH4Dzpphrg"] from langchain_community.document_loaders import AsyncChromiumLoader from langchain_community.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b48f1774dd9594cb1dec724143a54a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/441ac34dbdf18e9c8a76346c8b288802/" rel="bookmark">
			已解决org.apache.zookeeper.KeeperException.InvalidACLException异常的正确解决方法，亲测有效！！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		已解决org.apache.zookeeper.KeeperException.InvalidACLException异常的正确解决方法，亲测有效！！！
目录
问题分析
报错原因
解决思路
解决方法
总结
博主v：XiaoMing_Java
在使用Apache ZooKeeper进行分布式服务管理时，可能会遇到org.apache.zookeeper.KeeperException.InvalidACLException。这是一个与权限控制相关的异常，通常发生在设置或修改节点访问控制列表（ACL）时。本文将逐步剖析该问题，提供详细的解决方案。
问题分析 InvalidACLException是KeeperException的一个子类异常，表示客户端试图对ZooKeeper节点进行设置或更改操作，但提供的ACL参数无效或不符合ZooKeeper的ACL策略。
报错原因 在ZooKeeper中，每个znode节点都可以有相应的ACL策略，以控制哪些客户端有权限执行读取、写入等操作。如果在创建节点、设置ACL时提供了格式错误或者非法的ACL规则，则ZooKeeper无法识别或应用这些规则，会抛出InvalidACLException异常。
解决思路 验证ACL规则的格式是否正确。检查当前客户端是否有足够的权限来设置指定节点的ACL。确保ACL规则与ZooKeeper系统支持的ACL策略相匹配。使用正确的方式重新设置ACL。 解决方法 下面是具体的解决步骤：
检查ACL规则格式：确保你所设定的ACL规则符合scheme:id:permission格式，其中scheme是认证方式，如world, auth, digest等；id代表授权对象的标识；permission是权限设置，可以是cdrwa（创建、删除、读取、写入、管理）中的组合。
// 示例ACL规则，允许所有人读取节点 List&lt;ACL&gt; acls = new ArrayList&lt;ACL&gt;(Arrays.asList( new ACL(ZooDefs.Perms.READ, new Id("world", "anyone")) )); 检查客户端权限：确保当前客户端有权更改目标节点的ACL。
// 示例代码连接到ZooKeeper服务器 ZooKeeper zk = new ZooKeeper("host:port", timeout, watcher); // 获取节点的当前ACL，并检查是否有权限变更 Stat stat = new Stat(); List&lt;ACL&gt; currentAcls = zk.getACL("/path/to/znode", stat); // 这里需要根据已有ACL和客户端认证信息判断是否具备权限 设置新的ACL规则：确保按照ZooKeeper的要求设定ACL，并使用ZooKeeper API更新节点的ACL。
// 设置新的ACL规则 zk.setACL("/path/to/znode", acls, stat.getVersion()); 处理异常：捕获并妥善处理InvalidACLException。
try { zk.setACL("/path/to/znode", acls, stat.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/441ac34dbdf18e9c8a76346c8b288802/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/4/">«</a>
	<span class="pagination__item pagination__item--current">5/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/6/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>