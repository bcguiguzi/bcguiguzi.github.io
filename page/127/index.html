<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b2e44e16932b8b39784bf749cad8e189/" rel="bookmark">
			踩坑之——navicat连接mysql报1130错误的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 错误信息 ERROR 1130: Host 192.168.3.100 is not allowed to connect to this MySQL server
猜想是无法给远程连接的用户权限问题。结果这样子操作mysql库，即可解决。在本机登入mysql后，更改“mysql”数据库里的 “user”表里的 “host”项，从“localhost”改称’%'。
解决方方法 mysql -u root -p mysql&gt;use mysql; #查看mysql库中的user表的host值（即可进行连接访问的主机/IP名称）。 mysql&gt;select 'host' from user where user='root'; #修改host值（以通配符%的内容增加主机/IP地址），当然也可以直接增加IP地址。 mysql&gt;update user set host = '%' where user ='root'; #刷新MySQL的系统权限相关表。 mysql&gt;flush privileges; mysql&gt;select 'host' from user where user='root'; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b7179d9f9c60cdd1efc9ff15629f787/" rel="bookmark">
			电能计量四象限的定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 切换模式 写文章 登录/注册 电能计量四象限的定义 头顶技术 14 人 赞同了该文章 根据《多功能电能表通信协议》DL/T645-2007的规定，我们将一个平面坐标系的横轴定义为有功功率，纵轴定义为无功功率，二个轴将一个平面划分为四个区域，右上角的为Ⅰ象限，顺时针依次为Ⅱ象限、Ⅲ象限和Ⅳ象限；Ⅰ象限和Ⅱ象限无功定义为正向无功，Ⅲ象限和Ⅳ象限无功定义为反向无功；
并相对于电压相量U具有相位角Φ。逆时针方向Φ角为正。四象限的示意图所示：
P—有功电能；Q—无功电能；QL—感性无功电能；QC—容性无功电能；S—视在功率
注：此图与《DL/T645-2007》标准中表示的方式不同，但内容是相同的。
正向有功：P=UICOSΦ，其中Φ的范围是±90°以内。
反向有功：P=UICOSΦ，其中Φ的范围是90°至270°
正向无功：P= UISINΦ，其中Φ的范围是0~180°以内（国标定义）
反向无功：P= UISINΦ，其中Φ的范围是180~360°以内（国标定义）
由于第I象限中电压超前电流90°以内，而在纯电感回路中，具有电压超前电流90°的现象，故当输入（正向）有功时，在第1象限中产生的无功称为感性无功；由于第IV象限中电压滞后电流90°以内，而在纯电容回路中，具有电压滞后电流90°的现象，故当输入有功时，在第IV象限中产生的无功称为容性无功。同理，当输出（反向）有功时，第III、II象限分别为感性无功和容性无功。
功率在四象限中表示含义：
1) 正向有功功率：即输入有功功率，是电网向用户送电，是用户用电功率；
2) 反向有功功率：即输出有功功率，是用户向电网送电，是用户发电功率；
3) 正向无功功率：即输入无功功率，是电网向用户送无功，是用户用无功功率；
4) 反向无功功率：即输出无功功率，是用户向电网送无功，是用户发无功功率；
无功在四象限中的表示含义：
1) Ⅰ象限无功：输入有功功率，输入无功功率，用户为感性（电流滞后电压）负载；
2) Ⅱ象限无功：输出有功功率，输入无功功率，用户负荷相当于一台欠励磁发电机；
3) Ⅲ象限无功：输出有功功率，输出无功功率，用户负荷相当于一台过励磁发电机；
4) Ⅳ象限无功：输入有功功率，输出无功功率，用户为容性（电流超前电压）负载；
容性无功、感性无功的表示含义：
1) Ⅰ象限：消耗有功功率，消耗感性无功功率。
2) Ⅱ象限：输出有功功率，输出容性无功功率。
3) Ⅲ象限：输出有功功率，输出感性无功功率。
4) Ⅳ象限：消耗有功功率，消耗容性无功功率。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d8e1980090b5e0fde469add7e646ed0/" rel="bookmark">
			【I2C】MPU6050介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MPU6050简介 MPU6050 是一个 6 轴姿态传感器，可以测量芯片自身 X 、 Y 、 Z 轴的加速度、角速度参数，通过数据融合，可进一步得到姿态角，常应用于平衡车、飞行器等需要检测自身姿态的场景 6 轴—— 3 轴加速度、 3 轴 角速度 9 轴—— 3 轴加速度、 3 轴 角速度、 3 轴磁场强度 10 轴—— 3 轴加速度、 3 轴 角速度、 3 轴磁场强度、1个气压强度 3 轴加速度计（ Accelerometer ）：测量 X 、 Y 、 Z 轴的加速度 3 轴陀螺仪传感器（ Gyroscope ）：测量 X 、 Y 、Z轴的角速度 二、MPU6050参数 16 位 ADC 采集传感器的模拟信号，量化范围： -32768~32767 加速度计满量程选择： ±2 、 ±4 、 ±8 、 ±16 （ g ） 陀螺仪满量程选择： ±250 、 ±500 、 ±1000 、 ±2000 （ °/sec ） 可配置的数字低通滤波器 可配置的时钟源 可配置的采样分频 I2C 从机地址： 110100 0 （ AD0=0 ） //AD0是板子引出来的一个引脚以调节I2C从机地址的最低位 110100 1（AD0=1） 在程序中有两种用十六进制表示的方式 方式一：把7位二进制数（110 1000）转换为十六进制 （0x68）作为从机地址 发送第一个字节时先把0x68左移一位以留出最低位填写读写为【R/W】——( 0x68 &lt;&lt; 1 ) | 1或者0 方式二：直接把0x68左移一位后的数据 （0xD0）作为从机地址（常用）【将读写位融入到从机地址当中】 发送第一个字节时——1）要写数据，直接把0xD0当作第一个字节 2）要读数据，把( 0xD0 | 0x01 )即0xD1当作第一个字节 三、硬件电路 MPU6050芯片的VDD供电是2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d8e1980090b5e0fde469add7e646ed0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62760993e1e45ba35dc75f83103e3852/" rel="bookmark">
			JAVA数组分段的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JAVA数组分段的两种方法 分隔数组 根据段数分段分隔数组 根据每段数量分段 /** * 分隔数组 根据段数分段 &lt;多出部分在最后一个数组&gt; * * @param data 被分隔的数组 * @param segments 需要分隔的段数 * * @return */ public static&lt;T&gt; List&lt;List&lt;T&gt;&gt; subListBySegment(List&lt;T&gt; data, int segments) { List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;&gt;(); int size = data.size();// 数据长度 if (size &gt; 0 &amp;&amp; segments &gt; 0) { int count = size / segments; List&lt;T&gt; cutList = null; for (int i = 0; i &lt; segments; i++) { if (i == segments - 1) { cutList = data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62760993e1e45ba35dc75f83103e3852/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a2b2608557ade685006485ce94077fd/" rel="bookmark">
			go语言工具(tool)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 go help命令参数go listgo buildgo build -ldflags="-s -w" go envgo fmtgo installgo docgo getgo modgo fixgo generate go help Go工具命令繁多，通过go help进行查看：
bug start a bug report 启动错误报告 build compile packages and dependencies 编译包和依赖项 clean remove object files and cached files 删除对象文件和缓存文件 doc show documentation for package or symbol 显示包或符号的文档 env print Go environment information 打印Go环境信息 fix update packages to use new APIs 更新包以使用新的API fmt gofmt (reformat) package sources gofmt（重新格式化）包源 generate generate Go files by processing source 按处理源生成生成Go文件 get add dependencies to current module and install them 将依赖项添加到当前模块并安装它们 install compile and install packages and dependencies	编译并安装软件包和依赖项 list list packages or modules	列出包或模块 mod module maintenance	模块维护 run compile and run Go program	编译并运行Go程序 test test packages	测试包 tool run specified go tool	运行指定的go工具 version print Go version	打印Go版本 vet report likely mistakes in packages	报告包装中可能出现的错误 详细内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a2b2608557ade685006485ce94077fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0bbec0a8818b0353cddc47b960a3f12/" rel="bookmark">
			(java毕业设计源码)基于java(ssm)校园办公室报修管理系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于java(ssm)校园办公室报修管理系统 项目获取请看文章最底下官网
校园办公室报修管理系统，是基于java编程语言，ssm框架，mysql数据库开发，本系统主要分为用户，教师，管理员，维修员四个角色，其中用户的功能是注册和登陆系统，在线申请报修，维修评价，意见反馈；教师也是可以申请报修，在线催单，维修评价；维修员可以对报修信息进行接单；管理员对教师，用户，公告，报修类型，报修申请，意见反馈等信息进行管理。本系统功能齐全，适合作为java毕业设计来参考和学习。
一.技术环境 jdk版本：1.8 及以上
ide工具：IDEA
数据库: mysql5.7 （必须5.7）
编程语言: Java
tomcat: 8.0 及以上
java框架：SSM
maven: 3.6.1
前端：layui
详细技术：HTML+CSS+JS+JSP+JAVA+SSM+MYSQL+JQUERY+MAVEN
二.项目文件（项目获取请看文末官网） 三.系统功能 四.代码示例 package com.lmu.controller; /** * 和登陆有关的都在这里 */ import com.opensymphony.xwork2.ActionContext; import com.opensymphony.xwork2.ActionSupport; import com.lmu.model.Role; import com.lmu.model.User; import com.lmu.service.RoleService; import com.lmu.service.UserService; import com.lmu.utils.JsonUtils; import com.lmu.utils.UserUtils; import org.apache.commons.collections.map.HashedMap; import org.apache.struts2.ServletActionContext; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Controller; import java.io.IOException; import java.util.HashMap; import java.util.Map; @Controller("loginController") @Scope("prototype") public class LoginController extends ActionSupport { @Autowired private UserService userService; @Autowired private RoleService roleService; private User user; private Map&lt;String, Object&gt; map = new HashMap(); public User getUser() { return user; } public void setUser(User user) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0bbec0a8818b0353cddc47b960a3f12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8916be6bda77ff968138a413d8850f1/" rel="bookmark">
			用于解决以下问题 OMP: Error #15: Initializing libiomp5md.dll, but found libiomp5md.dll already initializ
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import os os.environ["KMP_DUPLICATE_LIB_OK"] = "TRUE" 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fedd08b3c70f49786fe1e821c2ac5675/" rel="bookmark">
			FPGA-流水灯、呼吸灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目标：设计一个20Mhz,并且依次点亮4个LED灯的实验
一、流水灯 FPGA实现流水灯主要运用移位操作。想要实现流水灯，就需要使一开始亮的那盏灯进行移位，若其中的LED为共阴极，则当信号为1（高电平）时，LED灯点亮，为0（低电平）时，LED灯熄灭。若假设四个LED灯一开始的电平为 0001 则根据流水灯的设计思路，流水灯的逻辑应该为0001-&gt;0010-&gt;0100-&gt;1000-&gt;0001。
（1）50Mhz -&gt; 20Mhz （IP核的创建） 在50Mhz转20Mhz功能实现中，需要用到IP核中的PLL模块。首先打开左边中的IP核，选择FPGA FeaturesDesign，在空白中双击进入。
在进入之后会打开如下图的弹窗页面，然后将1处的名字改为PLL（可不改），并将2处的输入频率改为50Mhz,此处改为50Mhz相当于板子上的晶振为50Mhz
之后在Output Clocks菜单栏中，修改输出的频率，并且将输入的reset1取消掉，点击OK，既将IP核建立成功。详细如下图：
创建成功后需要调用IP核自动生成的函数，因此需要进行函数的查看。
双击PLL.veo
//----------- Begin Cut here for INSTANTIATION Template ---// INST_TAG PLL instance_name ( // Clock out ports .clk_out1(clk_out1), // output clk_out1 // Status and control signals .locked(locked), // output locked // Clock in ports .clk_in1(clk_in1)); // input clk_in1 // INST_TAG_END ------ End INSTANTIATION Template --------- 该函数为系统生成函数，在进行tb_PLL文件验证时，只需要将其进行复制，修改为自己设置的变量名称即可。下面附上tb_PLL代码块
`timescale 1ns / 1ps module tb_PLL( ); reg clk_in1; initial begin clk_in1=0; end always #10 clk_in1=~clk_in1; PLL inst_PLL( // Clock out ports .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fedd08b3c70f49786fe1e821c2ac5675/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c44933110d72ddf92de21906815a87c/" rel="bookmark">
			基于javaweb&#43;mysql的springboot超市进销存管理系统(java&#43;springboot&#43;html&#43;layui&#43;echarts&#43;mysql)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于javaweb+mysql的springboot超市进销存管理系统(java+springboot+html+layui+echarts+mysql)
运行环境
Java≥8、MySQL≥5.7
开发工具
eclipse/idea/myeclipse/sts等均可配置运行
适用
课程设计，大作业，毕业设计，项目练习，学习演示等
功能说明
基于javaweb+mysql的SpringBoot超市进销存管理系统(java+springboot+html+layui+echarts+mysql)
项目介绍
超市进销存管理系统,分为管理员与普通员工两种角色；
管理员主要功能包括：
员工管理：员工的添加、编辑、删除；
普通员工主要功能包括：
供应商管理：供应商的添加、删除、修改；
商品管理：商品种类管理、商品信息管理；
库存管理；
订单管理；
环境需要
1.运行环境：最好是java jdk 1.8，我们在这个平台上运行的。其他版本理论上也可以。 2.IDE环境：IDEA，Eclipse,Myeclipse都可以。推荐IDEA; 3.tomcat环境：Tomcat 7.x,8.x,9.x版本均可 4.硬件环境：windows 7/8/10 1G内存以上；或者 Mac OS； 5.是否Maven项目: 是；查看源码目录中是否包含pom.xml；若包含，则为maven项目，否则为非maven项目 6.数据库：MySql 5.7版本； 7.lombok 注：一定要安装，否则会有问题；
技术栈
后端：SpringBoot+Mybatis
前端：Html+jQuery+Layui+echarts
使用说明
使用Navicat或者其它工具，在mysql中创建对应名称的数据库，并导入项目的sql文件； 2.使用IDEA/Eclipse/MyEclipse导入项目，Eclipse/MyEclipse导入时，若为maven项目请选择maven;若为maven项目，导入成功后请执行maven clean;maven install命令，配置tomcat，然后运行；
将项目中application.yml配置文件中的数据库配置改为自己的配置;
管理员访问地址：http://localhost:8085/admin
员工访问地址：http://localhost:8085
employee.setLock(1); Employee emp = empServiceImpl.findEmpByCondition(employee); if (emp != null &amp;&amp; emp.getPassword().equals(Md5Tools.numberMd5(password))) { session.setAttribute("emp", emp); logger.info("【{}】登录成功，正在进行跳转······", emp.getName()); return GlobalConstant.SUCCESS; } return GlobalConstant.ERROR; } @PostMapping(value = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4c44933110d72ddf92de21906815a87c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ce25e4116814d6c82f793846a90db2c/" rel="bookmark">
			我真的想知道，AI框架跟计算图什么关系？PyTorch如何表达计算图？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目前主流的深度学习框架都选择使用计算图来抽象神经网络计算表达，通过通用的数据结构（张量）来理解、表达和执行神经网络模型，通过计算图可以把 AI 系统化的问题形象地表示出来。
本节将会以AI概念落地的时候，遇到的一些问题与挑战，因此引出了计算图的概念来对神经网络模型进行统一抽象。接着展开什么是计算，计算图的基本构成来深入了解诶计算图。最后简单地学习PyTorch如何表达计算图。
视频、文章、PPT都开源在：chenzomi12.github.io
AI系统化问题 遇到的挑战 在真正的 AI 工程化过程中，我们会遇到诸多问题。而为了高效地训练一个复杂神经网络，AI 框架需要解决许多问题，例如：
如何对复杂的神经网络模型实现自动微分？
如何利用编译期的分析 Pass 对神经网络的具体执行计算进行化简、合并、变换？
如何规划基本计算 Kernel 在计算加速硬件 GPU/TPU/NPU 上高效执行？
如何将基本处理单元派发（Dispatch）到特定的高效后端实现？
如何对通过神经网络的自动微分（反向传播实现）衍生的大量中间变量，进行内存预分配和管理？
为了使用用统一的方式，解决上述提到的挑战，驱使着 AI 框架的开发者和架构师思考如何为各类神经网络模型的计算提供统一的描述，从而使得在运行神经网络计算之前，能够对整个计算过程尽可能进行推断，在编译期间自动为深度学习的应用程序补全反向计算、规划执行、降低运行时开销、复用和节省内存。能够更好地对特定领域语言（DSL），这里特指深度学习和神经网络进行表示，并对使用 Python 编写的神经网络模型进行优化与执行。
因此派生出了目前主流的深度学习框架都选择使用计算图来抽象神经网络计算。
计算图的定义 我们会经常遇到有些 AI 框架把统一的图描述称为数据流图，有些称为计算图，这里可以统称为计算图。下面简单介绍为什么可以都统称为计算图的原因。
数据流图（Data Flow Diagram，DFD）：从数据传递和加工角度，以图形方式来表达系统的逻辑功能、数据在系统内部的逻辑流向和逻辑变换过程，是结构化系统分析方法的主要表达工具及用于表示软件模型的一种图示方法。在 AI 框架中数据流图表示对数据进行处理的单元，接收一定的数据输入，然后对其进行处理，再进行系统输出。
计算图（Computation Graph）：被定义为有向图，其中节点对应于数学运算，计算图是表达和评估数学表达式的一种方式。而在 AI 框架中，计算图就是一个表示运算的有向无环图（Directed Acyclic Graph，DAG）。
其两者都把神经网络模型统一表示为图的形式，而图则是由节点和边组成。其都是在描述数据在图中的节点传播的路径，是由固定的计算节点组合而成，数据在图中的传播过程，就是对数据进行加工计算的过程。下面以公式为例：
f ( x 1 , x 2 ) = l n ( x 1 ) + x 1 x 2 − s i n ( x 2 ) f(x1,x2)=ln(x1)+x1x2−sin(x2) f(x1,x2)=ln(x1)+x1x2−sin(x2)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3ce25e4116814d6c82f793846a90db2c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b52839b7560170d45159410bd2aa58a4/" rel="bookmark">
			【Python】pyecharts 模块 ⑤ ( 地图绘制 | pyecharts 地图绘制步骤 | 为地图进行全局配置 )
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、pyecharts 地图绘制1、pyecharts 地图绘制步骤2、代码示例 - pyecharts 地图绘制3、代码示例 - 为地图进行全局配置 pyecharts 画廊网站 : https://gallery.pyecharts.org/#/
在该网站可查看官方示例 一、pyecharts 地图绘制 1、pyecharts 地图绘制步骤 首先 , 导入 pyecharts 中的 Map 类 , 这是 地图绘制 的核心类 , 该类定义在 pyecharts.charts 中 ;
# 导入 pyecharts 模块中的 地图 Map 对象 from pyecharts.charts import Map 然后 , 创建 Map 类实例对象 , 该对象对应着一张地图 ;
# 创建地图对象 map = Map() 再后 , 准备要绘制的数据 , 数据类型是列表类型 , 列表元素是 元组 容器 , 元组中第一个元素是对应的 地图中的 地名 ;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b52839b7560170d45159410bd2aa58a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a92edde8c0cbdc0ec31a976388209df/" rel="bookmark">
			安装Python310和Git
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文写文时间2023年7月22日，可能在未来会不适合实际情况
但是在写文时，不管是跑AI模型还是编译V8引擎，Python310都是稳定可用的
安装Python310 1.下载 访问Python的下载页
https://www.python.org/downloads/
下载3.10.xx的安装包
注意到没有安装包，文中说3.10.11是最后一个有安装包的版本
所以说回主页下载3.10.11
滚动页面到最底下，下载64位安装包
如果不想去官网找，我也分享了一份Python和Git的安装包，放蓝奏云上
地址：https://wwzv.lanzoue.com/b03khs9dg
密码:git0
2.安装 如果你以前安装过，先去控制面板-&gt;程序与功能-&gt;卸载程序卸载旧版本
(主要是旧版本如果在Path环境变量可能会导致奇怪的问题)
右键安装包，选择以管理员身份运行
选择Customize installation：
这些选项全部勾上，然后点击Next
勾上Install for all users和Add Python to environment variables
其它的选项不要动，点击Install
提示安装成功，关闭窗口即可
然后我们进入C:\Program Files\Python310文件夹，找到python.exe，复制一份然后粘贴到原地，会发现多了一份python - 副本.exe
把python - 副本.exe重命名为python3.exe
至此，安装就完成了
为了防止奇奇怪怪的情况，最好重启一下
注意：关机再开机并不等于重启，只有关机的菜单里面选择重启才是真重启
安装Git 1.下载安装 访问Git的下载页
https://git-scm.com/download/win
下载针对Windows的安装包，或者到上面给出的网盘链接下载
右键安装包，选择以管理员身份运行
不需要看安装包里面的选项，全部默认，狂点Next即可，安装完成后关闭窗口即可
3.汉化Git Bash 随便右键桌面的一个空白地方，选择Open Git Bash here
点击左上角区域，选择Options
选择Window，然后在UI language的组合框选择zh_CN
点击Save保存设置，然后关闭Bash窗口
至此Git Bash的汉化就完成了
2.汉化Git GUI 访问汉化项目
https://github.com/stayor/git-gui-zh
把项目下载为ZIP压缩包
解压后新建一个叫msgs的文件夹，把zh_cn.msg移动进去
你也可以到上面给出的网盘链接下载Git汉化包，解压后直接就是msgs文件夹
然后我们进入C:\Program Files\Git\mingw64\share\git-gui\lib文件夹
把msgs文件夹拖进去，如果提示什么拒绝访问点继续即可
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2a92edde8c0cbdc0ec31a976388209df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce74cfd8fd854e34ee4dc4d81c2d563d/" rel="bookmark">
			AI 夏令营机器学习 day01 深度学习环境配置问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误：无法将“nvidia-smi”项识别为 cmdlet、函数、脚本文件或可运行程序的名称
解决方法：解决：nvidia-smi : 无法将“nvidia-smi”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。 - 知乎
查找路径 使用搜索很容易查找到nvidia-smi.exe的路径为：C:\Program Files\NVIDIA Corporation\NVSMI
2. 添加环境变量
如何添加新的环境变量？_百度知道
再重新打开cmd或者WindowsPowerShell，运行nvidia-smi，成功解决问题！
GPU之nvidia-smi命令详解_[山青花欲燃]的博客-CSDN博客
表格参数详解：
**GPU：**本机中的GPU编号（有多块显卡的时候，从0开始编号）图上GPU的编号是：0
**Fan：**风扇转速（0%-100%），N/A表示没有风扇,这个速度是计算机期望的风扇转速，实际情况下如果风扇堵转，可能打不到显示的转速。
**Name：**GPU类型，图上GPU的类型是：GeForce MX250/RTX 2080Ti
**Temp：**GPU的温度（GPU温度过高会导致GPU的频率下降）
**Perf：**GPU的性能状态，从P0（最大性能）到P12（最小性能），图上是：P0
**Persistence-M：**持续模式的状态，持续模式虽然耗能大，但是在新的GPU应用启动时花费的时间更少，图上显示的是：off
**Pwr：Usager/Cap：**能耗表示，Usage：用了多少，Cap总共多少
**Bus-Id：**GPU总线相关显示，domain：bus：device.function
**Disp.A：**Display Active ，表示GPU的显示是否初始化
**Memory-Usage：**显存使用率
**Volatile GPU-Util：**GPU使用率
**Uncorr. ECC：**关于ECC的东西，是否开启错误检查和纠正技术，0/disabled,1/enabled
**Compute M：**计算模式，0/DEFAULT,1/EXCLUSIVE_PROCESS,2/PROHIBITED
**Processes：**显示每个进程占用的显存使用率、进程号、占用的哪个GPU
**type：**进程类型。C 表示计算进程，G 表示图形进程，C+G 表示都有。
【动手学深度学习PyTorch版】11 使用GPU_torch调用gpu_水w的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f63774c61c43ea0c83d89fa299b32b/" rel="bookmark">
			分享SQL重复记录查询的几种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SQL重复记录查询的几种方法，需要的朋友可以参考一下
1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断
代码如下:
select * from people
where peopleId in (select peopleId from people group by peopleId having count
(peopleId) &gt; 1)
2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录
代码如下:
delete from people
where peopleId in (select peopleId from people group by peopleId having count
(peopleId) &gt; 1)
and rowid not in (select min(rowid) from people group by peopleId having count(peopleId
)&gt;1)
3、查找表中多余的重复记录（多个字段）
代码如下:
select * from vitae a
where (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/06f63774c61c43ea0c83d89fa299b32b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c404e12a8805f274d4bba09c3703eda/" rel="bookmark">
			C&#43;&#43;中的vector结构解读、迭代器失效问题以及模拟实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、vector的介绍 vector是一个容器，底层使用数组实现，那就意味着，可以使用下标对vector进行访问，和数组一样高效，但是又不像数组一样，他的大小是可以动态改变的，底层实现了扩容的逻辑，有的编译器也对缩容进行了实现。
本质讲，vector使用动态分配数组来存储它的元素。当新元素插入时候，这个数组需要被重新分配大小为了增加存储空间。其做法是，分配一个新的数组，然后将全部元素移到这个数组。就时间而言，这是一个相对代价高的任务，因为每当一个新的元素加入到容器的时候，vector并不会每次都重新分配大小。
vector分配空间策略：vector会分配一些额外的空间以适应可能的增长，因为存储空间比实际需要的存储空间更大。不同的库采用不同的策略权衡空间的使用和重新分配。但是无论如何，重新分配都应该是对数增长的间隔大小，以至于在末尾插入一个元素的时候是在常数时间的复杂度完成的。
因此，vector占用了更多的存储空间，为了获得管理存储空间的能力，并且以一种有效的方式动态增长。
与其它动态序列容器相比（deque, list and forward_list）， vector在访问元素的时候更加高效，在末尾添加和删除元素相对高效。对于其它不在末尾的删除和插入操作，效率更低。比起list和forward_list统一的迭代器和引用更好。
下面就介绍一个vector常用的一些操作函数
2、vector的定义 构造函数和赋值运算符的重载 (constructor)构造函数的声明接口说明vector()无参构造vector(size_type n,const value_type&amp; val = value_type())构造并初始化n和valvector(const vector&amp; x)拷贝构造vector(InputIterator first, InutInterator last)使用迭代器进行初始化vector&lt;T&gt;&amp; operator=(vector&lt;T&gt; v)赋值运算符的重载 构造函数和赋值操作和之前的string一样都涉及到了深度拷贝，如果自己对其进行实现的话，注意不能使用 memcpy() 和 memncpy() 对其进行拷贝，因为这样只是实现了一层深拷贝，如果构造的容器是一个多层容器嵌套，那么就会导致拷贝或者赋值前后的多个容器空间的底层指向同一块内存空间，那么在容器的声明周期结束的时候，析构函数就会对同一块空间进行过次析构，这样就会导致野指针访问，
#include &lt;vector&gt; using namespace std; void test() { vector&lt;vector&lt;int&gt;&gt; vvi1(10); while(auto v : vvi1) { v.resize(10,0); } vector&lt;vector&lt;int&gt;&gt; vvi2(v1); } vector的迭代器相关 在C++的STL中，底层用顺序存储结构实现的，那么他的迭代器底层就是一个原始指针，其他的容器的迭代器我会在之后的文章中去进行解释，所以不能说迭代器就是原始指针，要对应实际的应用场景使用的容器。先来看看vector的迭代器：
iterator的使用接口说明begin() 获取第一个数据的位置iterator/const_iterator
end()获取最后一个数据的下一个位置iterator/const_interatorrbegin() 获取最后一个数据的位置reverse_iterator
rend()获取第一个数据的前一个位置reverse_interator vector空间相关 容量空间接口说明size有效数据个数capacity容量空间大小empty是否为空resize改变vector的sizereserve改变vector的capacity vector增删改查相关
增删改查接口说明push_back尾插pop_back尾删find查找，(这个是算法模块实现的要包含头文件&lt;algorithm&gt;,不是成员接口)insertposition之前插入valueerase删除position位置的值swap交换两个vector的数据空间operator[]像数组一样访问 3、vector的迭代器失效问题 迭代器说白了就是给出一个概念，让使用者可以不用关心底层数据结构的实现。他的底层实际上就是一个封装过的指针。
如果说对一个满了的vector中添加数据，那就涉及到扩容的问题，C++中没有提供扩容的接口，所底层对于vector的扩容就是new一块大一点的空间，将原数据拷贝到新空间中，释放原空间，
那么在扩容后，我们拿到的迭代器还能用吗，
﻿int main() { vector&lt;int&gt; v; v.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c404e12a8805f274d4bba09c3703eda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0f2c63fccb68830e6aed68dae4c1687/" rel="bookmark">
			Postman传递对象参数(包含有集合对象)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		postman通常需要传递各式各样的参数，本文主要介绍了Postman传递对象参数(包含有集合对象)，具有一定的参考价值，感兴趣的小伙伴们可以参考一下
项目场景： postman通常需要传递各式各样的参数，这样的话，进行写参数比较头疼，不知怎么进行传参。
解决方案： 可以考虑将参数对象写成json字符串的样式，然后将将字符串转换成json对象
实体类：
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0f2c63fccb68830e6aed68dae4c1687/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef3016edb52d8757ae890f405f9970bc/" rel="bookmark">
			吃瓜教程day01 机器学习（周志华）Chapter1~2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一章 绪论 1.2 基本术语 数据集：某组记录的集合
特征向量：即一个示例，反映事件或对象在某方面的表现或性质的事项
训练数据：某个学习算法训练过程中使用的数据
训练样本：每个样本
学习任务种类：
根据预测值的种类是离散值还是连续值：“分类”或“回归”
根据训练数据是否拥有标记信息：监督学习和无监督学习
泛化能力：学得模型适用于新样本的能力
独立同分布iid：假设样本空间中全体样本服从一个未知“分布”D，则获得每个样本都是独立的
1.4 归纳偏好 概念：学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或“价值观”即引导算法确立正确偏好的原则
常见的有：奥卡姆剃刀原则
奥卡姆剃刀原则：“若有多个假设和观察一致，则选最简单那个”
没有免费的午餐定理（NFL定理）：前提是所有问题出现的机会等同、或者所有问题同等重要（假设f均匀分布），此定理寓意是：脱离具体问题而空泛谈论哪个算法更好是毫无意义的
第二章 模型估计与选择 2.1 经验误差与过度拟合 训练误差/经验误差：学习器在训练集上的误差
泛化误差：学习器在新样本上的误差
模型过度拟合：即树的规模变得太大，即使训练误差还在继续降低，但是检验误差开始增大。
好的模型必须具有低训练误差/再代入误差/表现误差和低泛化误差/检验误差。（相应内容的笔记见数据挖掘第四章）
数据挖掘导论 Chapter4 读书笔记_Aria_So的博客-CSDN博客数据挖掘导论 Chapter4 读书笔记
过度拟合成因：噪声导致、缺乏代表性样本、大量的侯选属性和少量的训练记录。
过度拟合是无法避免的，只能缓解或减小风险。
2.2 评估方法
4种方法：保持方法、随机二次抽样、交叉验证、自助法
留出/保持方法Holdout：按比例划分训练集和检验集。训练集过小而模型方差变大；验证集过小而准确率不可靠，置信区间较宽。
随机二次抽样Random Subsampling：多次重复保持方法求平均来改进性能估计。
交叉验证cross-validation：假设把数据分为相同大小的k个子集，选择一个子集作为验证集，其他子集作为训练集，该过程重复k次，使每份数据都用于检验恰好一次。则总误差是k次运行的误差之和。缺点是计算量大且性能估计的方差偏高。
自助法Bootstrap：有放回抽样地抽取训练记录（63.2%），没抽中的记录作为检验集的一部分，重复以上过程b次，得到b个自主样本。主要应用于在数据集较小、难以有效划分训练集测试集的时候有用；此外能从初始数据集中产生多个不同的数据集，对集成学习等方法有好处。但也改变了初始数据集的分布，引入估计偏差
总准确率计算方法有：0.632自助
调参与最终模型：机器学习常涉及两类参数：一类是算法参数（超参数），由人工设定多个参数候选值；另一类是模型参数，数目很多（如深度学习可以有上百亿个参数），通过学习来产生多个候选模型（如神经网络在不同的轮数停止训练）
2.3 性能度量 相关笔记见数据挖掘第四章笔记
数据挖掘导论 Chapter1~2读书笔记数据挖掘导论 Chapter4 读书笔记_Aria_So的博客-CSDN博客
补充知识：
精确度和召回率是一对矛盾的度量，一般来说精确度越高则召回率越低。精确度-召回率曲线即PR曲线，根据曲线下面积的大小来判断模型优劣（面积越大，模型越优）。平衡点BEP也可以作为比较模型的标准，BEP时的P与R越大则模型越优。
平衡点（Break-Even Point，BEP）是当精确度=召回率时取的值，即PR曲线和45°直线交点。
2.4 比较检验
由于数理统计知识较扎实，此处省略。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e0219697eb3adbacef0e628aacab8ec/" rel="bookmark">
			数据挖掘导论 Chapter4 读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		4.2 机器学习性能评估指标 1、分类
准确率Accuracy =1 - error rate = (TP+TN)/(TP+TN+FP+FN)
错误率Error Rate = (FP+FN)/(TP+TN+FP+FN)，与ACC是互斥事件。
精确率/精度Precision = TP/(TP+FP)，即被分为正例的示例中实际为正例的比例。
召回率Recall Rate/灵敏度Sensitive Rate = TP/P，表示的是所有正例中被分对的比例，衡量了分类器对正例的识别能力。
特效度Specificity = TN/N，表示的是所有负例中被分对的比例，衡量了分类器对负例的识别能力。
综合评价指标F-measure：Precision和Recall加权调和平均。
接收者操作特征曲线/ROC曲线：是以假正率（FP_rate）和假负率（TP_rate）为轴的曲线，如L1和L2。
PR Curve：即PR（Precision-Recall）曲线。在极度不平衡的数据下（Positive的样本较少），PR曲线可能比ROC曲线更实用。
AUC：曲线与FP_rate轴围成的面积（记作AUC）越大，说明性能越好
2、回归
MAE
MSE
RMSE
其他评价指标
计算速度：分类器训练和预测需要的时间
鲁棒性：处理缺失值和异常值的能力
可扩展性：处理大数据集的能力
可解释性
https://www.cnblogs.com/Zhi-Z/p/8728168.html
4.4 模型过度拟合 概念：即树的规模变得太大，即使训练误差还在继续降低，但是检验误差开始增大。
好的模型必须具有低训练误差/再代入误差/表现误差和低泛化误差/检验误差。
过度拟合成因：噪声导致、缺乏代表性样本、大量的侯选属性和少量的训练记录。
如何估计泛化误差？
再代入估计：将训练误差作为泛化误差的乐观估计，但效果很差结合模型复杂度：模型越复杂，出现过分拟合的几率越高 奥卡姆剃刀原则/节俭原则：给定两个具有相同泛化误差的模型，较简单的模型比较复杂的模型更可取。
泛化误差的2种估计方法：悲观误差评估和最小描述长度原则。（越小越好）
悲观误差评估：
最小描述长度原则（minimum description length，MDL）：待看
如何处理过分拟合？
2种策略：先剪枝和后剪枝。
先剪枝：当观察到不纯性度量的增益（或估计的泛化误差的改进）低于某个确定的阈值时就停止扩展叶节点。缺点是很难为提前终止选取正确的阈值。
后剪枝：按照自底向上的方法修剪完全增长的决策树，2种修剪方法：子树替换和子树提升
子树替换：用新的叶节点代替子树
子树提升：用子树中最常使用的分支代替子树，直到模型不再改进。
4.5 评估分类器性能 4种方法：保持方法、随机二次抽样、交叉验证、自助法
保持方法Holdout：按比例划分训练集和检验集。训练集过小而模型方差变大；验证集过小而准确率不可靠，置信区间较宽。
随机二次抽样Random Subsampling：多次重复保持方法求平均来改进性能估计。
交叉验证cross-validation：假设把数据分为相同大小的k个子集，选择一个子集作为验证集，其他子集作为训练集，该过程重复k次，使每份数据都用于检验恰好一次。则总误差是k次运行的误差之和。缺点是计算量大且性能估计的方差偏高。
自助法Bootstrap：有放回抽样地抽取训练记录（63.2%），没抽中的记录作为检验集的一部分，重复以上过程b次，得到b个自主样本。
总准确率计算方法有：0.632自助
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02db554b3c4bd9642febf0912b78676f/" rel="bookmark">
			数据挖掘导论 Chapter1~2读书笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 什么是数据挖掘 数据挖掘是数据库中知识发现的一部分。知识发现KDD是将未加工的数据转换为有用信息的整个过程，包括输入数据、数据预处理、数据挖掘、数据后处理、输出信息。
2.3数据预处理 数据预处理有哪些方法：聚集、抽样、维归约、特征子集选择、特征创建、离散化和二元化、变量变换
聚集：将两个或多个对象合并成单个对象
抽样：选择数据对象子集进行分析，抽样方法包括放回和不放回抽样、概率抽样或非概率抽样、自适应(adaptive)/渐进抽样（模型准确率的增加随着样本增加而趋于稳定，则在稳定点停止样本容量）
维归约：通过创建新属性，将旧属性合并在一起来降低数据集的维度。常用场景是维灾难，常用方法是线性代数技术，如PCA主成分分析与SVD奇异值分解。
特征子集选择：通过选择旧属性的子集来得到新属性。常用场景是为了删除冗余特征和不相关特征。
4步选择过程包括：子集评估度量、控制新的特征子集产生的搜索策略、停止搜索判断、验证过程。
3种标准的特征选择方法：嵌入embedded、过滤filter、包装wrapper。嵌入法根据算法得到的特征权重值系数来选择使用和忽略哪些属性；过滤和包装唯一不同是子集评估方法不同，包装法使用目标数据挖掘算法，通过子集评估函数来判断，过滤法则通过预测实际算法在给定属性集上的执行效果如何来评估。
特征选择方法概括—过滤法、嵌入法、包装法_特征选择过滤法_lihe2021的博客-CSDN博客
特征创建：包括特征提取、映射数据到新的空间、特征构造。
特征提取：由原始数据创建新的特征集。与维归约区别：不是运用线性代数技术。
映射数据到新的空间：如傅里叶变换、小波变换等。
离散化和二元化：离散化包括监督离散化和非监督离散化，区别在于使不使用类信息。非监督离散化一般以等分方式，或非监督聚类算法划分。监督离散化以极大化区间纯度的方式确定分割点，纯度以熵度量，熵越大越不纯。
变量变换：常用来将不具有正态分布的数据变换成具有正态分布的数据。包括简单函数变换与规范化或标准化。
2.4 相似度和相异度 邻近性度量：
1、二元数据的度量：简单匹配系数SMC和Jaccard系数：
2、余弦相似度：用于文档相似度
3、广义Jaccard系数EJ（Tanimoto系数）
4、相关性：相关系数和Bregman散度
Bregman散度是损失或失真函数，相异性函数。目的是度量用x近似y导致的失真或损失。一个函数与该函数的线性近似之间的差。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16e0df6e2006e7cc9d17a220e498ed83/" rel="bookmark">
			抓包导出的har格式解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用Chrome开发者工具即Charles等抓包后可以到处.har格式的网络请求包，例如：
打开Chrome浏览器打开开发者工具，切换到网络面板浏览器访问https://httpbin.org/get?a=1&amp;b=2在开发者工具，网络面包点击导出图标，如下图： 选择位置并保持，得到一个httpbin.org.har的文件。
这个文件实际上是一个基于JSON格式的纯文本文件，可以使用记事本等打开。例如使用VsCode打开后，显示如下：
选择位置并保持，得到一个httpbin.org.har的文件。
这个文件实际上是一个基于JSON格式的纯文本文件，可以使用记事本等打开。例如使用VsCode打开后，显示如下：
完整格式如下：
{ "log": { "version": "1.2", "creator": { "name": "WebInspector", "version": "537.36" }, "pages": [ { "startedDateTime": "2022-05-12T01:45:27.174Z", "id": "page_1", "title": "https://httpbin.org/get?a=1&amp;b=2", "pageTimings": { "onContentLoad": 1118.679000006523, "onLoad": 1379.2790000443347 } } ], "entries": [ { "_initiator": { "type": "other" }, "_priority": "VeryHigh", "_resourceType": "document", "cache": {}, "connection": "396", "pageref": "page_1", "request": { "method": "GET", "url": "https://httpbin.org/get?a=1&amp;b=2", "httpVersion": "http/2.0", "headers": [ { "name": ":authority", "value": "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16e0df6e2006e7cc9d17a220e498ed83/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/126/">«</a>
	<span class="pagination__item pagination__item--current">127/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/128/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>