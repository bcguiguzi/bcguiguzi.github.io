<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46b40f9618d565b9477b00defb2a026b/" rel="bookmark">
			【matplotlib】可视化解决方案——如何设置轴标签的透明度和大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 Axes 标签对于读者理解图表非常重要，它描述了图表中展现的数据内容。通过向 axes 对象添加标签，可以有效理解图表所表达的内容。首先来了解一下 matplotlib 是如何组织图表的。最上层是一个 Figure 实例，包含绘图中所有可见和不可见的内容。Figure 实例包含了一个 Axes 实例字段 Figure. Axes，该实例包含了所有绘图相关的东西，如所有的线、点、刻度和标签。举一个例子，调用 pyplot.plot()，就会向 【Axes. Lines】 列表中添加一个 Line2D 对象；调用 pyplot.plot() 方法就会向 【Axes. Patches】 列表中添加绘制的多个 patches 对象（patches 可以理解是一个用颜色填充的图形对象）。
Axes 实例也包含了 XAxis 和 YAxis 实例，分别对应 X 轴和 Y 轴，XAxis 和 YAxis 管理着坐标轴、标签、刻度、刻度标签定位器和格式器，在实际使用中不用使用 Axes.xaxis() 和 Axes.yaxis 调用坐标轴实例，matplotlib 提供了一个 helper 方法来控制这些标签，即 pyplot.xlabel() 和 plt.ylabel()。
示例 接下来我们以一个示例来演示一下，在下面的代码中我们做了以下事项：
添加标题和 axes 标签；添加标题和 axes 的阴影效果；设置透明度。 import matplotlib.pyplot as plt from matplotlib import patheffects import numpy as np # 初始化数据 data = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46b40f9618d565b9477b00defb2a026b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f85bf39fcdc6f85e3869ea86e068abc3/" rel="bookmark">
			vue谷歌浏览器cookie跨域问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题：
在vuex项目里搞iframe嵌套时，iframe里登录点击不跳转
原因：
问题发现是谷歌浏览器cookie跨域问题，不同域名嵌套会导致cookie无法访问，这里给自己记录一下
解决方案：
chrome浏览器默认的cookie的options的参数为：
sameSite：lax （当为lax的时候不允许跨域的cookie访问，不同端口无影响）
secure：false
解决方案：
在被嵌套配置页面使用
import Cookies from 'js-cookie'
const options = {
sameSite: 'none'，
secure: true,
}
Cookies.set(TokenKey, token, options)
这种方法使用时，接口需使用https
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dc3b92ea9284e518b28cc4c199ca2a0/" rel="bookmark">
			I.MX6ULL_Linux_系统篇(16) uboot分析-启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接：I.MX6ULL_系统篇(16) uboot分析-启动流程 – WSY Personal Blog (cpolar.cn)
前面我们详细的分析了 uboot 的顶层 Makefile，了解了 uboot 的编译流程。本章我们来详细的分析一下 uboot 的启动流程，理清 uboot 是如何启动的。通过对 uboot 启动流程的梳理，我们就可以掌握一些外设是在哪里被初始化的，这样当我们需要修改这些外设驱动的时候就会心里有数。另外，通过分析 uboot 的启动流程可以了解 Linux 内核是如何被启动的。
链接脚本 u-boot.lds
要分析 uboot 的启动流程，首先要找到“入口”，找到第一行程序在哪里。程序的链接是由链接脚本来决定的，所以通过链接脚本可以找到程序的入口。如果没有编译过 uboot 的话链接脚本为 arch/arm/cpu/u-boot.lds。但是这个不是最终使用的链接脚本，最终的链接脚本是在这个链接脚本的基础上生成的。编译一下 uboot，编译完成以后就会在 uboot 根目录下生成 u-boot.lds文件，如图所示：
OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm") OUTPUT_ARCH(arm) ENTRY(_start) #代码入口 SECTIONS { . = 0x00000000; . = ALIGN(4); .text : { *(.__image_copy_start) *(.vectors) arch/arm/cpu/armv7/start.o (.text*) *(.text*) } . = ALIGN(4); .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) } . = ALIGN(4); .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dc3b92ea9284e518b28cc4c199ca2a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/483cc619a468e02022d1c1d86e644f0c/" rel="bookmark">
			马氏距离与卡方分布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在看《Fundamentals of object tracking》，看到最近邻滤波时，碰到了题中的两个概念。以下内容基本来自wiki，读者有不懂的地方看wiki更清晰明了。
1.马氏距离 Mahalanobis distance
线性代数中的“距离”是一个非常有用的概念，以前我们讲“范数”，其实就是关于“距离”的概念。比如说“2-范数”就是“欧式距离”。
欧式距离很有用，可以度量两个“点”之间有多远。
但有时我们想研究一个样本点a距离一个分布有多远，已验证它是不是属于这个分布的。当这个分布是球形分布时（比如高斯分布N~(μ，σ)），我们自然会想到，如果|a-μ|&lt;σ，那么a属于这个分布的概率就很大。如果|a-μ|&gt;3σ，那么a基本不属于这个分布了。
这没有什么问题。但是当这个分布不是球形分布，而是诸如椭球型分布的时候，上面的做法就很有问题了，椭球分布在长短轴上的|σ并不一样，因此出现了σ的“尺度”问题。
这时“欧氏距离”不管用了，我们需要用到“马氏距离”。
其中，S是样本x的协方差矩阵。由于S逆的存在（当x维度为1时，S相当于1/σ，自行体会一下多维度的情况），使得马氏距离不敏感σ的“尺度”问题，通用性很好，所以在跟踪问题的贝叶斯框架下，一般都用马氏距离来量度某个观测值距离后验概率分布的均值有多远。
比如下式中，A和B到原点的距离都相同，所以他们的欧式距离是相同的，但是由于x轴方向的方差较大，因此B的马氏距离较近。（“在x轴上方差大”意味着数据在这个方向上“很可能”包含了样本B，“在y轴上方差小”意味着不太可能包含样本A）。
2. 卡方分布
在上述D的公式中，如果x是k维的高斯向量，那么D^2是属于卡方分布的：
“If Y is a k-dimensional Gaussian random vector with mean vector μ and rank k covariance matrix C, then X = (Y−μ)TC−1(Y − μ) is chi-squared distributed with k degrees of freedom.”
此时就可以用卡方分布来设定某个阈值，也就是跟踪问题中“波门”的概念。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/517e1c3f71ec80d8e7c045a01c2996e8/" rel="bookmark">
			华为eNSP配置QOS限速
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QOS 实验拓扑 基本配置 R1: int gi0/0/0 #进入接口gi0/0/0中 ip add 172.16.10.1 24 #配置IP地址和子网掩码 quit #退出接口配置 ​ R2: int gi0/0/0 #进入接口gi0/0/0中 ip add 172.16.10.2 24 #配置IP地址和子网掩码 quit #退出接口配置 int gi0/0/1 #进入接口gi0/0/1中 ip add 192.168.10.2 24 #配置IP地址和子网掩码 quit #退出接口配置模式 ​ PC1IP地址配置 配置QOS R2: [R2]acl number 2000 #创建acl访问控制列表，列表号为2000 [R2-acl-basic-2000]rule permit source 192.168.10.0 0.0.0.255 #允许PC1去访问 [R2-acl-basic-2000]quit #退出acl配置模式 [R2]traffic classifier CC #将流量进行分类 [R2-classifier-CC]if-match acl 2000 #绑定acl列表号 [R2-classifier-CC]quit #退出 [R2]traffic behavior CC #配置相关动作behavior [R2-behavior-CC]car cir 2000 #确保2M的带宽 [R2-behavior-CC]quit #退出 [R2]traffic policy CC #配置策略policy [R2-trafficpolicy-CC]classifier CC behavior CC #绑定分类流量和相关动作 [R2-trafficpolicy-CC]quit #退出 [R2]int gi0/0/0 #进入接口gi0/0/0中 [R2-GigabitEthernet0/0/0]traffic-policy CC outbound #应用到出接口上 [R2-GigabitEthernet0/0/0]quit #退出接口配置 配置静态路由 R1: ip route-static 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/517e1c3f71ec80d8e7c045a01c2996e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030db0b9ace9ac32bd9bee0932e48e35/" rel="bookmark">
			mongoDB，ID自增实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		counter.js
const mongoose = require('mongoose'); const Schema = mongoose.Schema; const counterSchema = new Schema({ _id: { type: String, required: true }, sequence_value: { type: Number, default: 1 }, }); counterSchema.statics.getNextSequenceValue = async function (sequenceName) { const sequenceDocument = await this.findOneAndUpdate( { _id: sequenceName }, { $inc: { sequence_value: 1 } }, { new: true, upsert: true } ); return sequenceDocument.sequence_value; }; module.exports = mongoose.model("Counter", counterSchema); $inc 操作符用于自增计数器集合中的 sequence_value 属性
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/030db0b9ace9ac32bd9bee0932e48e35/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1c0489211938a62c82a82231297954d/" rel="bookmark">
			什么是XSS？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是XSS呢 跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是[代码注入]的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。
XSS 分为三种：反射型，存储型和 DOM-based
如何攻击 XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。
例如通过 URL 获取某些参数
&lt;&lt;img src="http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --" style="margin: auto" /&gt; &lt;div&gt;{{name}}&lt;/div&gt; 上述 URL 输入可能会将 HTML 改为 &lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt; ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。
也有另一种场景，比如写了一篇包含攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。
如何防御 最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义
function escape(str) {str = str.replace(/&amp;/g, '&amp;amp;')str = str.replace(/&lt;/g, '&amp;lt;')str = str.replace(/&gt;/g, '&amp;gt;')str = str.replace(/"/g, '&amp;quto;')str = str.replace(/'/g, '&amp;#39;')str = str.replace(/`/g, '&amp;#96;')str = str.replace(/\//g, '&amp;#x2F;')return str } 通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1c0489211938a62c82a82231297954d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2db398f414341b983a66dd05eb0ee71e/" rel="bookmark">
			请告诉我一些常见的泰勒公式展开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的泰勒公式展开有：(1) 二项式展开：(x + y)^n = ΣnCkx^(n-k)y^k；(2) 三角形展开：(a + b + c)^2 = a^2 + b^2 + c^2 + 2ab + 2ac + 2bc；(3) 多项式展开：(x + y + z)^3 = x^3 + y^3 + z^3 + 3x^2y + 3x^2z + 3xy^2 + 3yz^2 + 3xz^2。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92e26f02848e0c78a55cf320d8e4896/" rel="bookmark">
			Python——程序的组织结构（顺序、选择、循环）以及Python重要语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python程序的组织结构 Python——程序的组织结构顺序结构选择结构对象的布尔值合理利用短路算法，可以避免一些异常的抛出条件表达式中不允许使用赋值运算符"="选择结构的类型 循环结构while语句for-in 语句break 和continueelse语句与循环结构 Python——程序的组织结构 顺序结构 即整体代码是按照从上至下，从左至右的顺序执行的
选择结构 对象的布尔值 布尔值即Ture 或者 False
每一个对象都有一个布尔值，使用内置函数bool（）来获取该值
Python中的条件表达式就是通过判断对象的布尔值来确定下一步的代码执行流程的
布尔值为False的对象 False整数0、浮点数0.0、复数0j空值None空字符串、空列表、空元组、空字典、空集合空range对象（一个可迭代对象，且不是迭代器对象）其他空迭代对象 验证
b = bool(False) print(b) b = bool(0) print(b) b = bool(0.0) print(b) b = bool(0j) print(b) b = bool(None) print(b) b = bool(str()) print(b) b = bool(list()) print(b) b = bool(tuple()) print(b) b = bool(dict()) print(b) b = bool(set()) print(b) b = bool(range(1, 0)) print(b) #输出结果： """ False False False False False False False False False False False "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f92e26f02848e0c78a55cf320d8e4896/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1d096f9b1bffc345608ae35e60eeeed4/" rel="bookmark">
			Qt 开发使用VSCode
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		配置环境变量 从Qt安装目录中找到对应的工具路径配置环境变量
配置cmake工具环境变量 D:\Qt\Tools\CMake_64\bin (cmake.exe 跨平台的编译配置工具,可以用简单的语句来描述所有平台的编译过程) 配置gcc编译器环境变量 D:\Qt\Tools\mingw810_64\bin (鼎鼎大名的gcc/g++，MinGW是指Minimalist GNU for Windows) msvc编译器在安装了vs即可直接使用，不用配置看情况缺少什么配什么。。。 插件 C/C++C/C++ Extension PackCMakeCMake ToolsQt ConfigureQt tools 新建Qt项目 配置Qt安装目录 &gt;QtConfigure:Set Qt Dir创建Qt项目 &gt;QtConfigure:New Project 新建项目名称、选择编译套件（msvc或mingw），选择构建工具（cmake或qmake），是否带ui文件 项目初始状态 使用了cmake会自动生成CMakeLists.txt配置文件，用于编译配置。
选择编译器编译 命令 &gt; CMake:select a kit（如果无选项可以使用Qt:Scan for Qt kit搜索，或重启vscode再搜索再选择）
每次重新编译前重新cmake select a kit 再F7，好像也不需要重新cmake select a kit！
如果选择编译套件mingw则用gcc
如果选择编译套件msvc则用msvc
F7编译、F5调试
直接运行exe
配置对应的编译套件环境变量，重新编译，即可直接打开exe运行程序。
D:\Qt\5.15.2\mingw81_64 D:\Qt\5.15.2\mingw81_64\binD:\Qt\5.15.2\msvc2019_64 D:\Qt\5.15.2\msvc2019_64\bin
vscode开发Qt的四种方案 vscode + mingw + cmakevscode + msvc + cmakevscode + mingw + qmakevscode + msvc + qmake 新增ui文件 打开Qt设计器新增ui文件 &gt; QtConfigure:Open Qt Designer ，牛逼的话可以不用Designer，直接手动写ui文件代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1d096f9b1bffc345608ae35e60eeeed4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/074fc9f4e0c3eb07a47a0569aedf6640/" rel="bookmark">
			apache seatunnel介绍，github star数量，使用的公司
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Seatunnel 是一个开源的WebSocket代理，它可以让你连接到Websocket服务器并且转发消息到其他服务器。Github 上的星星数量为 120。它被多家公司使用，比如：Google，IBM，微软，亚马逊，谷歌，英特尔等。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25aea8d400bfef31f8744bf9eefc0744/" rel="bookmark">
			Linux/Ubuntu安装部署Odoo15仓管系统，只需不到十步---史上最成功
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo apt-get update
sudo apt install postgresql -y
sudo apt-get -f install
sudo dpkg -i /home/ubuntu/odoo_15.0.latest_all.deb —报错再次执行上一条命令再执行 —安装包地址：http://nightly.odoo.com/15.0/nightly/deb/–翻到最下面
sudo apt-get install postgresql
sudo su postgres
psql
create user odoo superuser password ‘odoo15’ login
\q
Exit
chmod 777 /etc/odoo/odoo.conf
打开/etc/odoo/odoo.conf 把密码-dp_password=***改成前面设置的odoo15
sudo service odoo restart
部署完成！
打开: ip:8069
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/274733320c3496169345fd0377b6b559/" rel="bookmark">
			基于资源的约束委派攻击
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上两篇⽂章介绍了约束委派、⾮约束委派攻击的利⽤，这篇⽂章我们来看看基于资源的约束性委派攻击。通过利⽤基于资源的约束委派攻击，我们能够使普通域⽤户以域管理员身份访问远程计算机 CIFS 等服务，实现本地权限提升。
基于资源的约束性委派 基于资源的约束性委派：为了使⽤户/资源更加独⽴，微软在Windows Server 2012中引⼊了基于资源的约束性委派。基于资源的约束委派不需要域管理员权限去设置相关属性，⽽是将设置委派的权限交给了服务机器。服务机器在自己账户上配置msDS-AllowedToActOnBehalfOfOtherIdentity属性，就可以进行基于资源的约束委派。
配置了基于资源的约束委派的账户的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值为被允许基于资源约束性委派的账号的SID。如admin--pc的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值为test的sid值。2008 及以下的域控没有 msDS-AllowedToActOnBehalfOfOtherIdentity 这个属性，只有 Windows Server 2012 和 Windows Server 2012 R2 及以上的域控制器才有 msDS-AllowedToActOnBehalfOfOtherIdentity 这个属性
攻击前提 资源的约束委派不再需要域管理员权限设置委派，只需拥有在计算机对象上编辑 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的权限，谁拥有修改这个属性的权限了？在我们加入域的时候，会输入一个域账号进行验证，验证成功则加入域，而这个账号就拥有修改msDS-AllowedToActOnBehalfOfOtherIdentity 属性的权限
在⼤型内⽹域环境中，将机器加⼊到域环境中⼀般不会⽤域管权限，⽽是⽤⼀个专⻔用来加域的域⽤户去操作。那么当我们拿下加域的⽤户的账号密码时，就可以把通过该域⽤户加⼊
到域⾥的所有机器都拿下
环境配置 域：test.lab
域控：192.168.10.2 test\administrator主机：192.168.10.4 test\yu 机器名：win2008主机：192.168.10.5 test\yuwin7 机器名：ADMIN--PC 其中yu这个用户就是加域的用户，其将ADMIN--PC这台机器加入到了域环境中。假设我们获取了yu的账号和密码
1. 使用普通域用户yu将计算机加入到域环境中
默认情况下，并非只有域管理员才有将普通用户加入域的权限。域中每一个普通帐号都有将10台电脑加入域的权限。
新建一个加域的普通域用户 yu
将之前加入域的计算机退出域，然后再修改计算机名，再加入域，输入新建的域账号
加入成功
ps：决定普通域用户有权将计算机加入到域的属性如下
输入 adsiedit.msc ，在打开的ADSI编辑器右击-“连接到”-点击确定，右键 “DC=xxx DC="com" 单击“属性”，ms-DS-MachineAccountQuota属性值为10，说明了一个普通的域用户可以将10台主机加入到域
攻击利用 通过查看 “ net localgroup administrators ” 可知道yu并不在本都管理员组中，就可以通过yu域用户提权到administrator
在test.lab域中，yu域用户负责将ADMIN--PC加入到域内，那么当我们拿下yu这个域⽤户的权限后，就可以拿下域内 ADMIN--PC或者其他被他加入到域内的机器。以下所有的操作都在win2008机器上执行即yu这个账户上操作
1. 通过 ADfind 查询每个域机器是由哪个域⽤户添加进域的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/274733320c3496169345fd0377b6b559/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2e9a7aeecd7989e34b9291e260840ef/" rel="bookmark">
			Java线程池应用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池的学习 基本概念好处应用场景ThreadPoolExecutor实例理解：执行流程 自定义线程池4大核心参数测试demo输出结果：结论 ExecutorService常用方法思考获取ExecutorService代码示例总结 ScheduleExecutorService常用获取方式如下ScheduledExecutorService常用方法如下:代码示例：总结： FutureFuture的常用方法如下:代码示例 综合案例秒杀商品思路提示代码步骤:代码示例： ATM机取款思路提示:代码示例 线程池的五大使用步骤： 基本概念 线程池是多线程的一种处理方式，处理过程中将任务添加到队列中，线程创建完成后自动启动这些任务，任务就是实现了Runnable或Callable接口的实例对象
好处 可以根据系统需求和硬件环境灵活控制线程的数量，对线程进行统一管理
应用场景 1、网购秒杀
2、云盘上传和下载
3、12306网上购票
ThreadPoolExecutor public ThreadPoolExecutor (int corePoolSize,//核心线程数：当一个任务提交到线程池中，如果当前运行的线程数量小于核心线程数，会新开一个线程来执行任务 int maximumPoolSize,//最大线程数：当大于核心线程数时，可以设置一个最大线程数 long keepAliveTime,//最大空闲时间(存活时间)：当一个任务没有运行时候，task可以存活的时间 TimeUnit unit,//时间单位：枚举类型，可设置天、小时、时分秒等 BlockingQueue&lt;Runnable&gt; workQueue,//任务队列(临时缓冲区)：当任务达到核心线程数量时，再有task提交到线程池需要在任务队列先排队，当任务队列满了之后会根据最大线程数创建新线程 ThreadFactory threadFactory,//线程工厂：创建线程的工厂 RejectedExecutionHandler handler) {//饱和处理机制：当核心线程数、最大线程数贺任务队列都满了需要处理的事情	实例理解： 假设某银行营业部有两名正式工，一名临时工，一个空闲等待座位，当有a、b、c、d客户依次来办理业务，a、b由两名正式工接待工作，c客户由临时工接待，d客户在座位等待，如果营业部是线程池，核心线程数(两名正式工)就是2，最大线程数(外加临时工)为3，任务队列(座位缓冲区)为1，当此时来了客户e办理业务，银行只能按照饱和处理机制拒绝接待客户e，当营业部临时工空闲时间超过1个小时后，经理就会让临时工(线程销毁)下班，有一个allowCoreThreadTimeOut变量控制是否允许销毁核心线程，默认为false，即时正式工闲着也不得提前下班
执行流程 自定义线程池 4大核心参数 1、核心线程数
按照8020原则设计，例如：一个任务执行需要0.1秒，系统80%每秒产生100个任务，那么一秒钟处理完需要10个线程，核心线程数就是10
2、任务队列长度
核心线程数/单个任务执行时间*2即可，任务队列长度为200
3、最大线程数
最大线程数还需要参照每秒产生的最大任务数，例如：系统每秒产生的最大任务数为1000，最大线程数=(最大任务数-任务队列长度)*单个任务执行时间
即最大线程数=(1000-200)*0.1=80个
4、最大空闲时间
根据系统参数设定，没有固定的参考值
测试demo 1:编写任务类(MyTask),实现Runnable接口;
2:编写线程类(MyWorker),用于执行任务需要持有所有任务
3:编写线程池类(MyThreadPool),包含提交任务执行任务的能力:
4:编写测试类(MyTest),创建线程池对象提交多个任务测试
MyTask
/** * 包含任务编号，每个任务执行时间为0.2秒 */ public class MyTask implements Runnable { private int id; /** * 由于run方法是重写接口中的方法，id属性初始化必须使用构造方法完成 */ public MyTask(int id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2e9a7aeecd7989e34b9291e260840ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aac32efc08080a2c3ebb89589ad6bec7/" rel="bookmark">
			python3 pickle.load 读python2 文件报错， UnicodeDecodeError 和 TypeError
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pickle持久化文件用 python2.7 pickle.dump产生。
程序升级后用python3.6 读文件报错：UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 3: ordinal not in range(128)
按照网上找的方法，在python3的 pickle.load 调用增加参数 encoding：
pickle.load(f, encoding='latin1') #或者是 'ISO-8859-1'
出现新的错误：TypeError: an integer is required (got type str)
查看各种文档和文章，都不能解决。
后来考虑是不是python版本的问题，把pickle的持久化文件放到python3.7的环境
还是用 pickle.load(f, encoding='latin1')，就能完美解析。
最后解决方案：在python3.7 执行pickle.load(f, encoding='latin1')，然后pickle.dump持久化。
把持久化文件，放到python3.6的环境就能正常使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee15fefb75192a7717967af27458887c/" rel="bookmark">
			Pytorch-Mobile-Android（3） 部署自己模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、例子：
1.用torch.jit.script转torchscript，不要用torch.jit.trace
2.将图像的width和height用PIL改成符合的输入
3.套用pytorch-mobile官网的代码运行即可
4.Lite version update
一、例子： 1.用torch.jit.script转torchscript，不要用torch.jit.trace 理由见：【Pytorch部署】TorchScript - 知乎 (zhihu.com)https://zhuanlan.zhihu.com/p/135911580
import vision_transformer from torch.utils.mobile_optimizer import optimize_for_mobile import torch model_vit = vision_transformer._create_vision_transformer('vit_tiny_patch16_384') model_vit = model_vit.eval() example = torch.rand(1, 3, 384, 384) traced_script_module = torch.jit.script(model_vit, example) traced_script_module_optimized = optimize_for_mobile(traced_script_module) traced_script_module_optimized._save_for_lite_interpreter(r"D:\paper_code\02android-demo-app-master\HelloWorldApp\app\src\main\assets\vit2.pt") 会报错UserWarning: `optimize` is deprecated and has no effect. Use `with torch.jit.optimized_execution() instead
warnings.warn(
不清楚原因，但是不影响运行。
2.将图像的width和height用PIL改成符合的输入 from PIL import Image img = Image.open(r'D:\paper_code\02android-demo-app-master\HelloWorldApp\app\src\main\assets\image.jpg') # img = img.resize((384, 384), Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee15fefb75192a7717967af27458887c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c1a34b5a06bd482bd10656dfa57b319/" rel="bookmark">
			Pytorch-Mobile: FLOPs的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、定义 区分FLOPS和FLOPs：
• FLOPS 注意全部大写 是floating point of per second的缩写，意指每秒浮点运算次数。可以理解为计算速度，用来衡量硬件的性能。
• FLOPs 是floating point of operations的缩写，是浮点运算次数，理解为计算量，可以用来衡量算法/模型复杂度。（ps:FLOPs 是模型推理时间的一个参考量，但并不能百分百表示该模型推理时间的长短，因为乘法和加法计算不一样，乘法的时间一般是加法时间的四倍，但现在有很多优化卷积层的计算算法，可能把乘法计算时间缩为加法的两倍不等，所以FLOPs只是个估量的指标，不是决定推理时间长短的指标。即FLOPs越小并不代表着模型推理时间越短）
定义在这篇论文有：
二、CNNFLOPs计算包 import torch import torchvision from torch.utils.mobile_optimizer import optimize_for_mobile from thop import profile model = torchvision.models.GoogLeNet(init_weights=True) example = torch.rand(1, 3, 224, 224) flops, params = profile(model, inputs=(example,)) print(flops/1e9) # model.eval() # traced_script_module = torch.jit.trace(model, example) # traced_script_module_optimized = optimize_for_mobile(traced_script_module) # traced_script_module_optimized._save_for_lite_interpreter(r"D:\paper_code\01transformer\my_work\model\GoogleNet.pt") 三、常见CNN的FLOPs及其在pytorch mobile下的latency总结： FLOPs采用thop包计算
Latency是在Pixel 2 API 29下计算100次取平均
名称FLOPs(GFLOPs）Latency（ms）VGG1615.4838620161791.4resnet181.819066368190.82resnet343.671263232408.05resnet504.111514624445.56resnet15211.5588372481362.19GoogleNet1.504879712180.35 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db50a951a81c5bf6968eced2fd4558ce/" rel="bookmark">
			MacOS Pytorch 机器学习环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学习 Pytorch ，首先要搭建好环境，这里将采用 Anoconda + Pytorch + PyCharm 来一起构建 Pytorch 学习环境。
1. Anoconda 安装与环境创建
Anoconda 官方介绍：提供了在一台机器上执行 Python/R 数据科学和机器学习的最简单方法。
为什么最简单？主要有三点：
丰富的科学包与依赖项：它附带了 conda、Python 和 150 多个科学包及其依赖项，还有一大批常用数据科学包，可以立即开始数据处理；
管理包：它是在 conda（一个包管理器和环境管理器）发展起来的，可以方便的安装、卸载机器学习所要用到的第三方包；
管理环境：可创建环境适配不同包版本的项目，并可在不同环境中切换，防止出现版本兼容等不可预见的问题；
安装方式很简单，直接官网下载安装：https://www.anaconda.com/
安装完成后：
（1）创建一个独立的虚拟环境（避免与当前环境的一些包冲突），命令如下：
conda create -n pytorch python=3.9 numpy matplotlib pandas jupyter notebook pytorch：环境名，可以随便定义
numpy：是Python的一种开源的数值计算扩展
matplotlib：是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形
pandas：是基于NumPy 的一种工具，该工具是为解决数据分析任务而创建的
jupyter notebook：是一个交互式笔记本，支持运行 40 多种编程语言
（2）环境处理
激活环境：
conda activate pytorch 退出环境：
conda deactivate 2. Pytorch 安装
激活环境后，在这环境下，安装 pytorch，官网直接复制安装命令：https://pytorch.org/get-started/locally/，如下：
conda install pytorch torchvision torchaudio -c pytorch 这个时间可能会有点长，耐心等待安装完成即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db50a951a81c5bf6968eced2fd4558ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2afda906f78565453524b5872b1274ae/" rel="bookmark">
			Go string和int的相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GO String2Int package main import ( "fmt" "strconv") func main() { num, s := 12, "12" //string转int s2i, _ := strconv.Atoi(s) fmt.Printf("%t,%d\n", s2i, s2i) // string转int64 s2int64, _ := strconv.ParseInt(s, 10, 64) fmt.Printf("%t,%d\n", s2int64, s2int64) // int转string i2s := strconv.Itoa(num) fmt.Printf("%t,%s\n", i2s, i2s) // int64转string int642s := strconv.FormatInt(int64(num), 10) fmt.Printf("%t,%s\n", int642s, int642s) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/375b6f185e34948d86f2b50f8cfe6d3a/" rel="bookmark">
			怎么做三维点云深度学习模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要制作三维点云深度学习模型，您可以遵循以下步骤：
数据准备：收集和准备三维点云数据集。您可以使用各种传感器(例如激光雷达、结构光)来获取三维点云数据，然后对其进行预处理，例如去噪、点云配准等。
特征提取：选择合适的特征提取方法来从点云数据中提取特征。例如，您可以使用voxel-based方法将点云数据转换为体素网格，并使用卷积神经网络(CNN)对其进行处理。
模型构建：基于您选择的特征提取方法，构建深度学习模型。您可以选择传统的CNN、循环神经网络(RNN)、图神经网络(GNN)等方法来构建模型。
模型训练：使用训练数据集对深度学习模型进行训练。在训练过程中，您
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/175/">«</a>
	<span class="pagination__item pagination__item--current">176/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/177/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>