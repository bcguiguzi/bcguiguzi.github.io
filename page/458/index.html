<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ce7eed667a9a91249fc746256865c7d/" rel="bookmark">
			python中 and 和 or 操作的返回值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 假设变量 a 为 10, b为 20。
x and y： 布尔”与” ——如果 x 为 False，x and y 返回 False。否则它返回 y 的计算值。 (a and b) 返回 20。
x or y： 布尔”或” —— 如果 x 是 True，它返回 x 的值。否则它返回 y 的计算值。 (a or b) 返回 10。
&gt;&gt;&gt; a, b = 10, 20 &gt;&gt;&gt; a and b 20 &gt;&gt;&gt; a or b 10 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cbfb0d2c8d641ec7b8ee5219913e1cd/" rel="bookmark">
			MD5加密验签过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 import java.security.MessageDigest; public class StrMD5 { public static String MD5(String info) throws Exception { MessageDigest md5 = MessageDigest.getInstance("MD5"); md5.update(info.getBytes("UTF-8")); // digest()返回值16位长度的哈希值，由byte[]承接 byte[] md5Array = md5.digest(); StringBuilder strBuilder = new StringBuilder(); for (int i = 0; i &lt; md5Array.length; i++) { int temp = 0xff &amp; md5Array[i]; String hexString = Integer.toHexString(temp); if (hexString.length() == 1) {// 如果是十六进制的0f，默认只显示f，此时要补上0 strBuilder.append("0").append(hexString); } else { strBuilder.append(hexString); } } 转化为大写字符串，sign区分大小写 return strBuilder.toString().toUpperCase(); } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87c0f7b0fff591f6c0a98071d73c2699/" rel="bookmark">
			Type-C与Type-A、Type-B接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		日常工作中，经常会接触到手机的接口。目前，在我们雨滴科技的ITAB-01工业平板上，USB（Universal Serial Bus）使用的接口是Type-C。Type系列的接口除了Type-C，还有Type-A和Type-B。
手机经过的一段时间的迅猛发展，使得我们的生活已经离不开手机了，而手机又离不开充电，现在无线充电还未普及，绝大多数手机都是靠USB充电。USB线，很少有一种技术或者传输标准想通用串行总线（Universal Serial Bus）那样跟我们的生活息息相关，甚至到了没有不行的地步。 不管你认为它是多么渺小和不值钱，但它的作用的确是无法小视的，数据传输、供电都需要靠他，并且发展至今传输速度和电流负荷值也在不断的增加。我们今天说的是数据线、USB线的最新形态和理念产物——Type-C。在MacBook，也就是我们之前熟知的“小白”迭代之后，再次感叹苹果的做工之余，很多人的目光其实转移到了它的那根数据线上。没错，在MacBook身上不再是我们熟悉的那个磁力的电源接口，而是Type-C。
各种类型的USB接口 为啥就是Type-C火了？有没有Type-A和Type-B呢？其实是有的。看了之后就你就会发现，Type-A其实就是我们目前非常常见的USB插头，而Type-B对于有些人来说其实也并不陌生，许多打印机、显示器目前还在使用Type-B进行数据传输。两个日常生活中常见的插头其实都是有学名的，而Type-C只是初来乍到的新人，直接用学名示人，才让你觉得陌生罢了。三种不同的接口 其实在MacBook之后，就涌现出了一些敢于尝鲜追求新鲜事物的手机厂商开始去做Type-C接口的新机。如乐视、一加、诺基亚等。相信关注过发布会的你会发现，经常Type-C会和USB 3.1扯上关系。这其实是给广大人民群众传递了一个错误的信息，简单来说USB 3.1只是一个行业标准，同时也是目前USB 3.0标准的修订号。这只是技术标准，而不是物理值。所以，大家不要错意Type-C的接口就都是拥有USB 3.0传输速率的，因为目前乐视、一加等支持Type-C插头的手机依然是USB 2.0的标准，只有最新发布的ZUK Z1是USB 3.0的传输标准。Type-C最直观的优势就是让你彻底摆脱插线的烦恼，不用再出现错插或者失误之后导致的部件受损情况。 Type-C的特性 此外，在减少磨损、不受方向限制的情况下，由于技术革新的原因，Type-C可以占用更少的电路板空间，这对于产品之外的我们其实并没有什么太多实际的改变和意义，但对于硬件产品设计师而言，小小的改变可以为之后的内部布局带来更多的可能性和改变。Type-C线缆和接口 其实不管是USB 2.0还是USB 3.0的标准，就目前而言，并没有什么太多的帮助和改变，对于智能手机而言，数据线多数是被当做给设备充电的工具，离线电影、在线下载等帮助着我们在逐渐摆脱数据线传输时代，对于某些环境和需要来说，不可否认的是USB 3.0的传输速度确实会让你更加愉悦，都这年头了，对于2.0和3.0的速度区别就不必普及了吧，“时间”可以证明一切。
说到劣势，现阶段来看最主要的就是拥有Type-C接口的设备比较少。不过这是一个过程，在一个全新事物开始普及的阶段过程中，我们必须要经历的就是去适应它，并且在适应的过程中不断的等待它的队伍不断的壮大，这样一来才能做到真正的普及。
就像当时iPhone4S到iPhone5的转变一样，那时候我们还不是满办公室的去找有iPhone5手机并且带了Lightning数据线的小伙伴。Type-C亦是如此，身边拥有Type-C接口设备的朋友们，一定有过找不到Type-C数据线，没法给它们充电的苦恼。 所以对于想入手或目前已经拥有Type-C接口的设备的读者们，你在享受插拔无忧之后，还需要考虑是不是一根数据线真的够用，如果你出门在外，没有带数据线，那基本上设备属于绝对“阵亡”的边缘状态。并且，你拥有Type-C接口的设备之后，会使大量你之前积攒的备用USB数据线失去意义，这也是革新过程中一个必经之路。
总之，Type-C可以说是未来几年里，USB数据接口的一个新标准。在未来的普及程度相信会比现在更完善，并且速度一定是飞快的。从目前的趋势来看，今后将会有越来越多的设备支持Type-C接口。
我们雨滴科技的ITAB-01工业平板上的Type-C接口和Type-A接口 工业平板
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fb92f73dea18787f10c7af1b8086b62/" rel="bookmark">
			Dart的语法详解系列篇（1）---- 老司机用一篇博客带你快速熟悉Dart语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		声明：本文是作者AWeiLoveAndroid原创，版权归作者AWeiLoveAndroid所有，侵权必究。如若转发，请注明作者和来源地址！未经授权，严禁私自转载！
________________________________________________________________________________________________
【前言】Dart语言是使用flutter框架开发时候必备的语言，flutter是一个跨平台的框架，一套代码就可以完美实现安卓和ios两个平台，适配也很不错，Dart语言很友好，和java很类似，学习成本也是很低的。所以这也是我推荐学习Dart语言的一个原因。
从本篇文章开始讲解Dart语言的基本使用，我将会连续推出好几篇文章详解，希望帮助大家快速掌握Dart语言。
本文目录：
一、注释
二、关键字（56个）
三、变量和常量
四、特殊数据类型
五、运算符
六、控制流程语句
七、异常
本文代码同步发布在Github:
https://github.com/AweiLoveAndroid/Flutter-learning/tree/master/projects/dart_demo
怎么运行代码？
如果你使用IDEA或者Android Studio：
打开IDEA或者Android Studio，新建一个Flutter项目，然后在test目录运行我的代码；或者里面去写你自己的dart文件，然后右键run就可以运行了。（注意：需要连接手机或者模拟器）。
如果你使用vscode：
打开vscode，执行菜单栏运行，就可以了（确保只有一个dart文件，免得运行的文件不是你想要的，就很尴尬了，vscode也可以设置默认运行的文件是哪个，但是新手不建议去设置，很麻烦。因为你们想最快的运行效果，所有建议只有一个dart文件是最好的）。
一、注释 Dart的注释分为3种：单行注释、多行注释、文档注释。
1、单行注释以//开头。Dart编译器会忽略//和行尾之间的所有内容。
例如：// todo:待完成
2、多行注释以/*开头，以*/结尾。介于/*和 */两者之间的内容会被编译器忽略（除非该注释是一个文档注释）。多行注释可以嵌套。
例如：/* todo:待完成 */
3、文档注释以///或者/**开头。可以通过dartdoc命令导出文档。
文档注释的使用，例如：/// todo:待完成
文档的导出如图所示：
文档的导出 导出的结果在我的工程根路径的/doc/api/文件夹里面，如图所示：
导出的结果 然后浏览器打开index.html就可以看到文档了。如图所示：
本地的文档 二、关键字（60个） 5个上下文关键字（仅在特定位置具有含义。它们在任何地方都是有效的标识符） 关键字---asynchideonshowsync--- 其中内置标志符有：（20个） 关键字---abstractascovariantdefereddynamicexportexternalfactoryFunctiongetimplementsimportinterfacelibrarymixinoperatorpartsetstatictypedef Dart新增的，有限的保留字,支持异步功能的关键字有：（2个） 关键字---awaityield 33个保留字（不能使用保留字作为标识符） 关键字---assertbreakcasecatchclassconstcontinuedefaultdoelseenumextendsfalsefinalfinallyforifinisnewnullrethrowreturnsuperswitchthisthrowtruetryvarvoidwhilewith--- 跟java相比，Dart特有的关键字有：（27个） 关键字---asasyncawaitcovariantdeferreddynamicexportexternalfactoryFunctiongethideinislibrarymixinonoperatorpartrethrowsetshowsynctypedefvarwithyield 三、变量和常量 （一）变量的声明，可以使用 var、Object 或 dynamic 关键字。 创建变量并初始化变量实例：
var name = '张三' ; 变量存储引用。
使用Object或dynamic关键字 dynamic name = '张三'; 调用的变量name包含对String值为“张三” 的对象的引用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1fb92f73dea18787f10c7af1b8086b62/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df95b33f1b492472c181e0e9a253c4db/" rel="bookmark">
			2018湘潭邀请赛A题题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2018湘潭邀请赛A题题解 做题网址：点击打开链接
下面是原题题目：
A. Easy h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h.
Bobo has published many papers. Given a0, a1, a2, . . . , an which means Bobo has published ai papers with citations exactly i, find the h-index of Bobo.
Input The input consists of several test cases and is terminated by end-of-file.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df95b33f1b492472c181e0e9a253c4db/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfaeffd5e6b2c690b47fbf2f8340c63/" rel="bookmark">
			No module named yaml
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 pip install PyYAML 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02b2764d5b0bf94456de4c268986983/" rel="bookmark">
			类的非默认成员函数（普通函数、内联函数、友元函数）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、类的普通成员函数 普通成员函数本质上是一个包含指向具体对象this指针的普通函数，即c++类的普通成员函数都隐式包含一个指向当前对象的this指针。
class Person { public: Person() { _name = "LiMing"; _age = 20; } void Show() { cout &lt;&lt; this-&gt;_name &lt;&lt; endl;//this指针是隐含的，不写也可以调用类成员 cout &lt;&lt; this-&gt;_age &lt;&lt; endl; } private: char* _name; int _age; }; 二、内联函数 (1)内联函数是指用inline关键字修饰的函数。在类内定义的函数被默认成内联函数。编译时，会类似宏替换，嵌入调用处。 (2)用处：是为了消除函数调用时的时间开销，通常用于调用频繁，占用内存小的函数。 (3)注意： 递归函数不能定义为内联函数 内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。 内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。 对内联函数不能进行异常的接口声明。
class Class { public: Class() { a = 1; b = 2; } inline void Display() { cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; } int a; int b; }; void main() { Class c1; c1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c02b2764d5b0bf94456de4c268986983/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df2e563668915758100593f9dce0eac/" rel="bookmark">
			StringUtils 去除空白
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载地址：https://www.cnblogs.com/guiblog/p/7986410.html 1. StringUtils 中封装了部分方法来去除字符串中的空白符： trim(String str) trimToEmpty(String str) trimToNull(String str) strip(String str) stripToEmpty(String str) stripToNull(String str) deleteWhitespace(String str) 2(1):去除字符串首位的控制符（char &lt;= 32） a）trim(String str)：如果被去除的字符串的为null或""，则返回null和"": StringUtils.trim(null); // null StringUtils.trim(""); // "" StringUtils.trim(" ");// "" StringUtils.trim(" abc "); // abc StringUtils.trim(" a b c "); // "a b c" 注意此处字符串内部的控制符是不去除的 b）trimToEmpty(String str)： 如果被去除的字符串的为null或""，则都返回"" : StringUtils.trimToEmpty(null); // "" 此处返回的是"" StringUtils.trimToEmpty(""); // "" StringUtils.trimToEmpty(" ");// "" StringUtils.trimToEmpty(" abc "); // abc StringUtils.trimToEmpty(" a b c "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df2e563668915758100593f9dce0eac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb9613108a0bd517477dca7ecbd128b6/" rel="bookmark">
			InstallShield vs2015 的安装与激活
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当时看了网上一些关于激活的方法，各种麻烦，我一脸懵逼，后来自己试了试，完全不用啊，系统是win10 (10.0.16299),浏览器就是自带的edeg(Microsoft Edge 41.16299.402.0)。 首先，你需要准备 VS2015企业版以上版本 1.注册除邮箱外其他随意填 https://info.flexerasoftware.com/IS-EVAL-InstallShield-Limited-Edition-Visual-Studio 2、下载InstallShield 页面跳转到这里，记录下序列号后面激活就用这个就OK，另外在这里还可以下载 InstallShield 3.登录 邮箱收到注册信息，需要登录一下，不然后面激活会报错10662 4.进入vs2015 先安装 Install Shield 2015 Limited Edition ，进入VS2015安装与部署就能看到安装成功,点击进入 5.激活输入步骤2的序列号，激活成功 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c634271ae38021da357e858a96a648b/" rel="bookmark">
			江苏省程序设计大赛-A-Easy h-index
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		A. Easy h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has published many papers. Given a0, a1, a2, . . . , an which means Bobo has published ai papers with citations exactly i, find the h-index of Bobo. Input The input consists of several test cases and is terminated by end-of-file. The first line of each test case contains an integer n.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c634271ae38021da357e858a96a648b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff8dc4d45c5be8de63539bf3fbd897f7/" rel="bookmark">
			C&#43;&#43;初阶总结（详细）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、面向对象的思想 面向对象是一种以你办事我放心为理想构造出来的东西。这也是一个很好的鉴别一个面向对象的设计是否正确的方法。一个好的面向对象设计，会让你让他办事的时候，你不得不放心（也就是说，你不放心也没用，反正你什么都不知道）。
（1）面向对象程序设计 概念：(Object Oriented Programming，缩写：OOP）是一种程序设计范型，同时也是一种程序开发的方法。 对象指的是类的实例，将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。
（2）C++和面向对象 在面向对象的世界里，用类一个个的构造出对象来，在主程序里调用的是一个个对象的行为。
在C++程序里，数据和对数据的处理都被封装在了一个对象里。我们对对象进行修改，使用对象的数据。
二、C++的特性 1.封装： 将数据和对该数据进行合法操作的函数封装在一起作为一个类的定义，用类定义的变量去对类进行操作。
封装可以通过 访问限定符 对外提供访问方式。
(1)访问限定符： public（公有），protected（私有），private（私有）。
public成员可从类外部直接访问，private/protected成员不能从类外部直接访问。使用了private，成员只能在自己的类使用，而使用protected，出了自己的类可以使用，继承的类也可以使用。
2.每个限定符在类体中可使用多次，它的作用域是从该限定符出现开始到下一个限定符之前或类体结束前。
3. 类体中如果没有定义限定符，则默认为私有的。
4. 类的访问限定符体现了面向对象的封装性。 (2)封装好处： 将变化隔离。
便于使用。
提高重用性。
提高安全性。
2.继承： 继承是面向对象复用的重要手段。通过继承定义一个类，继承是类型之间的关系建模，共享公有的东西，实现各自本质不同的东西。
(1)基类成员在派生类的访问关系 基于public继承，赋值兼容规则 子类对象可以赋值给父类对象（切割/切片)
父类对象不能赋值给子类对象
父类的指针/引用可以指向子类对象
子类的指针/引用不能指向父类对象（可以通过强制类型转换完成)
(2)派生的默认成员函数 在继承关系里面，在派生类中如果没有显示定义这六个成员函数，编译系统则会默认合成这六个默认的成员函数:构造函数、拷贝构造函数、析构函数、赋值操作符重载、取地址操作符重载、const修饰的取地址符重载
(3)继承体系中的作用域 在继承体系中基类和派生类都有独立的作用域。
子类和父类中有同名成员，子类成员将屏蔽父类对成员的直接访问。（在子类成员函数中，可以使用基类::基类成员 访问）
注意在实际中在继承体系里面最好不要定义同名的成员。
(4)单继承和多继承 单继承: 一个子类只有一个直接父类时称这个继承关系为单继承
多继承: 一个子类有两个或以上直接父类时称这个继承关系为多继承
(5)多继承中的菱形继承 菱形继承造成Assistant类中有两份来自Person类的成员，这样造成了数据冗余（rǒng yú）和二义性。为此，我们引入虚继承。
(6)虚继承 在继承定义中包含了virtual关键字的继承关系
虚继承解决了在菱形继承体系里面子类对象包含多份父类对象的数据冗余&amp;浪费空间的问题。
虚继承体系看起来复杂，在实际应用我们通常不会定义如此复杂的继承体系。一般不到万不得已都不要定义菱形结构的虚继承体系结构，因为使用虚继承解决数据冗余问题也带来了性能上的损耗。
(7)虚函数和多态： ①虚函数 虚函数必须是基类的非静态成员函数，其访问权限可以是protected或public
在基类的类定义中定义虚函数的一般形式：virtual 函数返回值类型 虚函数名（形参表）　{ 函数体 }
②虚函数用法注意： 只有类的成员函数才能说明为虚函数；
静态成员函数不能是虚函数；
内联函数不能为虚函数；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff8dc4d45c5be8de63539bf3fbd897f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a9bb4ba11e3f822a9dcc2e2f5f9ea5b/" rel="bookmark">
			应用层之http协议 --- 为菜鸟写的
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		蒂姆伯纳斯-李，当年为了解决在www上传输信息的难题，进行了很久的思考，在某个黄昏，上帝触摸了他。于是他想出来了。由于这是一个复杂的问题，所以需要分而治之。
左边是浏览器，右边是服务器。客户端要拿到服务器中的信息。这里就涉及到几个最基本的问题：
客户端必须给出它想要的信息在服务器的什么地方 --- URL (统一资源定位符)
客户端和服务器之间怎样沟通，让彼此相互理解 --- http (超文本传输协议)
客户端得到它想要的信息后，该如何组织和呈现信息 --- html (超文本标记语言)
解决了这三个问题也就解决了蒂姆伯纳斯-李的难题。
客户端必须给出它想要的信息在服务器的什么地方 --- URL (统一资源定位符)
URL 的一般形式是&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;
为什么需要表明协议？因为在应用层，不仅仅有http协议，还可以使用ftp，smtp协议。所以必须注明，以示区分。不同的协议有不同的解析方式。
为什么需要主机ip地址？这是显而易见的，网络中存在无数的主机，你要访问的哪一台？怎么区分？唯有IP地址。
为什么需要端口号？还是为了区分的缘故。因为一台主机上运行着很多的进程，为了区分进程，端口就诞生了。一个进程对应一个端口。http默认的端口是8080。
为什么需要路径？还是为了区分资源。一台主机上的资源千千万，你不指定资源所在的路径，计算机怎么知道你想要什么资源。你可能会问？我怎么会知道你的资源放在服务器的什么地方，难不成我要看一张图片，还要记住这种图片完整的URL地址吗？这不是搞笑吗。其实开发人员已经将页面写好了，你只需要点击某个提示按钮就可以了，这个按钮已经通过某种机制和服务器端的资源相对应上了。
客户端和服务器之间怎样沟通，让彼此相互理解 --- http (超文本传输协议)
通过一个例子来理解，当你在地址栏输入http://baidu.com后发生了什么？如果你说的出来，那么说明，你大致了解了什么是http协议。
step1:所有人都知道，计算机只能够处理1和0，因为在计算机的世界里只有0和1，而你竟然希望通过输入http://baidu.com而让计算机理解你想要访问百度官网，如果没有辅助的因素，那你的请求是不会被计算机所理解的。可是计算机确实理解了你的意思。那说明什么？说明了有鬼。不错，这个鬼就是DNS，它俗姓域名系统。它的作用就是将你输入的网址转化成0和1的串。比如你输入www.baidu.com，实际呢？实际是119.75.217.109。
也许你会说，你刚才不是说计算机不是只认识0和1吗？这里怎么有非0和1以外的数。这是因为你看到的是十进制，而不是二进制。真实的ip是 01110111 01001011 11011001 01101101。拿到这个IP地址后再去发生发送请求。我实在是写不下去了，推荐一本书吧《图解HTTP》，比我说的详细多了，哎...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fffb35cda0c25b4ac2d7bb9a5bc764bf/" rel="bookmark">
			Ubuntu16.04安装Qt&#43;qwt&#43;fftw
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文参考网上诸多文章集合而成，重点有如下几篇，特此感谢。
Qt和qwt安装：
https://www.jianshu.com/p/afbc42ad2cfd
https://blog.csdn.net/lsjtsj/article/details/20313075
https://blog.csdn.net/ShoneX98/article/details/74012335（好）
FFTW库安装：
https://blog.csdn.net/whhxp/article/details/54375339
https://blog.csdn.net/wbgxx333/article/details/36625977
https://blog.csdn.net/eric88/article/details/17055325
https://blog.csdn.net/zwjzwj108108/article/details/24254067（好）
https://blog.csdn.net/congwulong/article/details/7576012（API）
http://blog.51cto.com/9291927/2084280
注：关于添加全局变量，有时候需要重启生效，笔者未自己研究，欢迎大家一起验证。
本次操作环境为： Ubuntu 16.04 x64
安装QT版本：
前提：执行以下命令，保证安装所需的库，主要原因是：
QT5系统缺少lGL图形链接库QT从5.8开始，编译工具就必须要支持C++11标准的才行，而GCC版本4.8以上才支持这个标准。 sudo apt-get install g++ sudo apt-get install build-essential sudo apt-get install libgl1-mesa-dev sudo apt-get install libglu1-mesa-dev freeglut3-dev 一、Qt安装 Qt版本选择的是：Qt 5.9.1 64位版本
在Linux环境下搭建Qt开发环境有两种方式：一种是图形界面的安装，另一种是源代码的安装。这里为了方便，快速开发，使用基于图形界面方式。
下载版本：
步骤：
在QT官网下载Qt安装包，这里下载qt-opensource-linux-x64-5.9.1.run，注意Qt5.9.1linux版本的只有64位，这是因为QT官方从Qt5.5以后不再支持32为版本。执行如下命令： sudo chmod +x qt-opensource-linux-x64-5.9.1.run 说明：该命令是为了给为Qt安装包赋予可执行的权限。
然后再执行如下命令： sudo ./qt-opensource-linux-x64-5.9.1.run 此时会弹出图形化的安装界面，之后的操作就跟Windows下安装软件相类似。
这里使用root权限安装是因为要安装在默认目录/opt下，当然也可以选择普通用户安装。 需要说明的是：qt-opensource-linux-x64-x.x.x.run包中包含了QtCreator可视化的开发工具，在安装完后，找到安装目录下的Tools/QtCreator/bin目录下发现有QtCreator可执行文件，该文件就是Qt可视化的开发工具。
最后，添加qt环境变量
qmake这个命令需要进行环境变量的配置才能找到并执行。具体做是在当前用户的主目录下面编辑对应的.bashrc文件。
执行如下命令： cd vim .bashrc 然后，在该文件末尾添加如下语句：
export PATH="/xxx/xxx//Qtx.x.x/x.x/gcc/bin":$PATH 中间的路径即为Qt中qmake的绝对路径。编辑完成后保存退出Vim(:wq)。然后再执行如下命令：
source .bashrc 设置即可生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fffb35cda0c25b4ac2d7bb9a5bc764bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5407fc043ced2244c54a41af4c023705/" rel="bookmark">
			让浏览器的时间基本不受系统时间影响
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做网页时钟，要想时间准确，就从服务器上拉时间数据。
客户机修改本地时间后，有的时钟就不准了，一般情况下不要一直从服务器上拉时间数据，服务器会累。
那么怎么办的？
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;TrueTime&lt;/title&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; var serTime = new Date(&lt;?php echo time();?&gt; * 1000); var locTime = new Date(); var deltaTime = locTime - serTime; var gon = 0; var gos = 0; var gonp; var gol = 400; function go(){ gon += 1; let now = new Date(); if (Math.abs(now.getTime() - locTime) &gt;= gol) { if(Math.floor(Math.abs(now.getTime() - locTime) / gol) == 1){ gos = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5407fc043ced2244c54a41af4c023705/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df412c67f020b3462fce497544698e4/" rel="bookmark">
			android init初始化流程介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android init 语法包括了5类声明：Actions，Services，Commands，Options，和Imports。
所有这些语法都是以行为解析单位，中间需要以空格为语法间隔，行首有#的将被认为是注释而不会被解析.
section是init.rc中的基本组成单位，section分为两种类型：Actions和Services，所有的commands或者options都属于section的内容。在第一个section之前的所有commands或者options都将被忽略。
Actions和Sevices都有唯一的命名，如果有第二个Action名字和前面的相同，那么这两个Actions的所有commands都将合并在一起。如果有第二个Sevice和前面的相同，那么它将被忽略并且会记录下来一个出错log。
所有init语法都是用.rc文件来配置的，一个系统中会在不同的目录中存在很多个.rc文件。/init.rc是主rc文件并且被init执行文件第一个解析,平台相关的主入口是/init.${ro.hardware}.rc。它负责整个system的initial setup。
当执行mount_all命令时，init进程会加载所有/{system,vendor,odm}/etc/init/目录中的所有.rc文件。我们可以通过在mount_all命令中来修改或者扩展我们需要加载的.rc文件所在的目录。
不同etc/init目录一般包含不同内容：
（1）/system/etc/init/ 是包含core系统项目，比如surfaceflinger，mediaservice，logcatd相关的.rc配置
（2）/vendor/etc/init/是包含了SOC级别的.rc配置的
（3）/odm/etc/init/是包含了终端OEM厂商的项目配置
所有的services要根据自己bin文件所在的位置防止.rc配置文件到对应的etc/init/目录中。有一个编译宏命令可以用来帮助开发者做这件事情，那就是LOCAL_INIT_RC.
举个例子：
logcated.rc和Android.mk存在于/system/core/logcat目录中，在编译过程中，Android.mk中的LOCAL_INIT_RC命令会把logcated.rc移动到/system/etc/init目录中。
这种做法把不同服务需要的init命令给区分开了，放置于不同文件和目录中，这样更加方便维护和merge代码。
使用在mount_all命令中，有两个options “early”和“late”，如果设置了“–early”，init会跳过对“latemount”修饰的目录的挂载。如果设置了“–late”，init会只挂载被“latemount”修饰的目录，但除了import的.rc文件。默认情况下，没有设置以上两种option的话，mount_all会挂载fstab中所有的目录。
Actions
格式如下： on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;] * &lt;command&gt; &lt;command&gt; &lt;command&gt; Services
服务是一种程序，它由init来启动的并且当它退出时init也会restart。 格式如下： service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; &lt;option&gt; Options
选项是service的一些配置，他们应决定什么时间以什么方式来启动service。下面将介绍一些比较常见和关键的options。 class &lt;name&gt; 为服务指定一个class名字，同一个class中的所有的services将被同时启动或者同时停止。如果service没有制定这个option，那么它会被默认属于“default” 类型。 user &lt;username&gt; 执行service之前设置它的username，当前默认是root用户 group &lt;groupname&gt; [ &lt;groupname&gt; ]* 在启动service之前改变它的groupname，当前默认是root组。 setenv &lt;name&gt; &lt;value&gt; 在启动service的进程环境中设置环境变量 disabled 加入此option的service将不会由class的调用而自动启动，它需要被指名来启动。 critical 这个选项意味着这是一个设备相关的service，如果这种service在4分钟时间内反复退出了4次，那么设备将会重启并且进入recovery模式。 oneshot 当服务退出时不要重新restart它。 onrestart 当服务restart重启时，执行一个command。 Triggers
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df412c67f020b3462fce497544698e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ca8bea43a0ccb44c60e3a71d39c980e/" rel="bookmark">
			js刷新页面location.reload()用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍了js刷新页面函数location.reload()的用法，有关js location.reload()函数的例子，有需要的朋友参考下。 在javascript编程中，多使用location.reload实现页面刷新。
例子：
复制代码代码示例: window.location.href=window.location.href; window.location.reload; 经测试,这两句在某些情况下可以代替location.reload(true);
而不会出现重试对话框达到刷新的效果
在js中实现刷新页面的方法有很多种，在js中有一个location.reload()函数，它就可以实现我们想要的功能。 window.location.reload(true) //浏览器重新从服务器请求资源,在http请求头中不会包含缓存标记。
例1，刷新当前页面
复制代码代码示例: &lt;script&gt; window.location.reload(); &lt;/script&gt; 例2，JS实现刷新iframe的方法 用iframe的name属性定位 复制代码代码示例: &lt;input type="button" name="Button" value="Button" οnclick="document.frames('ifrmname').location.reload()"&gt; 或 &lt;input type="button" name="Button" value="Button" οnclick="document.all.ifrmname.document.location.reload()"&gt; 例3，首先，定义一个iframe 复制代码代码示例: &lt;iframe method="post" id ="IFrameName" src="aa.htm" &gt;&lt;/iframe&gt; aa.htm页面的内容: 复制代码代码示例: &lt;input type ="button" value ="刷新" onclick ="aa()"/&gt; function aa() { （ jquery中文网 www.jquerycn.cn 编辑整理） //parent.location.replace(parent.location.href);//服务器端重新创建页面 parent.document.location.reload();//相当于F5 //window.location.href(parent.location.href);//iframe内容重定向 } 注意：
window.location.reload;
刷新时如果提交数据的动作，则会出现对话框！
解决办法：
复制代码代码示例: window.location.href=window.location.href; window.location.reload; 刷新父窗口：
复制代码代码示例: window.opener.location.href=window.opener.location.href; window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ca8bea43a0ccb44c60e3a71d39c980e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58d3ee93e327b48365a556a65121450c/" rel="bookmark">
			Android开发中dp,sp与px之间的转换工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在开发中， dp与px，sp与px 之间转换是必不可少的，写此博客以便记录，下次方便使用； 下面是通过DisplayMetrics类中属性density进行转换的；
import android.content.Context; /** * dp,sp 和 px 转换的辅助类 */ public class DisplayUtil { private DisplayUtil() { /* cannot be instantiated */ throw new UnsupportedOperationException("cannot be instantiated"); } /** * 将px值转换为dip或dp值，保证尺寸大小不变 * DisplayMetrics类中属性density */ public static int px2dip(Context context, float pxValue) { final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f); } /** * 将dip或dp值转换为px值，保证尺寸大小不变 * DisplayMetrics类中属性density */ public static int dip2px(Context context, float dipValue) { final float scale = context.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58d3ee93e327b48365a556a65121450c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6248dcdbe7a36f81553c6a76a69ef2d4/" rel="bookmark">
			location.href跳转页面时传递参数并且在新页面接收参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;span style="font-size:18px;"&gt;可以直接使用window.location.href进行页面跳转 window.location.href = "./punch/clock_frm.html" 问号传参： window.location.href = "./punch/clock_frm.html?modFlag="+modFlag+'&amp;role='+role; 那么我们在新页面接收参数， 并且将参数转为可用的json格式时， 可以用下面的方法： var url = location.search; //获取url中"?"符后的字串 ('?modFlag=business&amp;role=1') var theRequest = new Object(); if ( url.indexOf( "?" ) != -1 ) { var str = url.substr( 1 ); //substr()方法返回从参数值开始到结束的字符串； var strs = str.split( "&amp;" ); for ( var i = 0; i &lt; strs.length; i++ ) { theRequest[ strs[ i ].split( "=" )[ 0 ] ] = ( strs[ i ].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6248dcdbe7a36f81553c6a76a69ef2d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d27959e63b3150c9dd9b723db8030df/" rel="bookmark">
			机器学习算法思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.PCA主成分分析
参考网站：https://blog.csdn.net/hjimce/article/details/45000221
1）给定二维数据点集P(x,y)，找到散乱点重心坐标P0；
2）将散乱点所在坐标系改为重心P0为原点，即所有点做相应的平移，所有点减去P0坐标即可（或者叫做坐标系原点移至散乱点重心P0），并构建矩阵M=|P1-P0 P2-P0……Pn-P0|；
3）构建协方差矩阵A=1/n * (M*MT)；
4）求A的特征值，特征向量。找到特征值最大的特征向量(方差变化最快的方向)，另外找到垂直于最大特征值对应特征向量的特征向量；
5）将所有散乱点P(x,y)映射到4）中的特征向量方向上，即各点与4）中的特征向量点乘(P(x,y)*4)的特征向量*cos夹角)。
2.K-Means聚类
参考网站：https://blog.csdn.net/hjimce/article/details/45200985
1）从N个文档随机选取K个文档作为质心；
2）对剩余的每个文档测量其到每个质心的距离(欧式距离)，并把它归到最近的质心的类；
3）重新计算已经得到的各个类的质心；
4）迭代2～3步直至新的质心与原质心相等或小于指定阈值，算法结束。
3.线性回归
参考网站：
假设一条带参数的直线y=ax+b(二维)，最小化代价函数(每个点到直线的距离和)，用梯度下降法实现。
4.逻辑回归
参考网站：https://blog.csdn.net/chibangyuxun/article/details/53148005
1）找预测函数
2）构建损失函数
3）最小化损失函数
更新参数
附录：
1)算法实现时间(问题规模-时间复杂度)
2)计算机解决不同时间复杂度提升效果
此附录说明了：指数时间复杂度很难解决的原因-哪怕计算机计算速度提升1000倍，指数时间复杂度的算法也很难提升。
5.分类算法感悟
1）二分类
①一个感知神经元，2个输入变量，可以在平面上模拟一条分割直线，即可以实现线性可分的数据分类；
②多个感知神经元，两个输入变量，可以在平面上模拟多条线段（因为有取值范围限制，所以不是直线），可实现非线性分类。
2）多分类
可以把多个二分类中②结合使用，即可实现多分类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afe46510f90b312e4873fbd32497b435/" rel="bookmark">
			查看Docker容器的信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于运行在Docker环境的容器，有时我们想查询它们的一些基本信息，例如环境变量、hostname、ip地址等，接下来我们以一个tomcat容器为例，看看有哪些方式来取得这些信息；
原文地址：https://blog.csdn.net/boling_cavalry/article/details/80215214
创建tomcat容器 在docker环境下执行如下命令，即可创建一个名为tomcat001的tomcat容器：
docker run --name tomcat001 -idt tomcat 执行docker ps检查一下，容器创建成功：
root@maven:~# docker ps CONTAINER ID	IMAGE	COMMAND	CREATED	STATUS	PORTS	NAMES 98d119ed4c73	tomcat	"catalina.sh run"	10 minutes ago	Up 10 minutes	8080/tcp	tomcat001 获取信息常用的方式有如下三种：
进入容器内部获取信息；执行docker exec命令；执行docker inspect -f命令（推荐方式）； 第一种：进入容器内部获取信息 执行以下命令可进入容器内部：
docker exec -it tomcat001 /bin/bash 此时已进入容器内部，所以分别执行hostname、ip addr、env这三个命令可以获取相关信息，如下：
root@98d119ed4c73:/usr/local/tomcat# hostname 98d119ed4c73 root@98d119ed4c73:/usr/local/tomcat# ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afe46510f90b312e4873fbd32497b435/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/457/">«</a>
	<span class="pagination__item pagination__item--current">458/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/459/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>