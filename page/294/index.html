<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c3b09db12ffd77481ce0688b89108bd/" rel="bookmark">
			python如何实现剪贴板的操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导读本文主要介绍了python实现剪贴板的操作，通过输入一个命令行参数，实现将特定的一些文本复制到剪贴板的操作。感兴趣的可以了解一下 在回程的高铁上学习了这一节，由于对cmd命令行的相关知识所知甚少，只能自己一步步试验得出正确的方法，因此耗费了不少时间。这一篇博客也就当作是备忘吧。
首先说一下想要实现的功能：
通过输入一个命令行参数，实现将特定的一些文本复制到剪贴板的操作。（这个程序或许可以与其他的一些操作相结合，来实现自动回复，只是本人现阶段的能力还不足以实现这样的功能。）
再来看一下具体的步骤和几个需要注意的事项：
1.在python文件开头要加上‘#！ python3'，有关于#！的具体含义，详见文后链接。
2.创建批处理文件（.bat）的说明：
先创建一个文本文档（.txt），在其中写入如下内容：
@py.exe (有空格！)将要创建的文件的绝对路径，如E:\Python\clipboard_copy (又有空格！)%*
@pause
在使用任何命令行时，千万千万要注意空格！由于命令行中的参数是以空格来划分的，任何非必要的空格都可能引起系统的误解因此在文件路径中绝对不要出现空格，可统一用下划线来替换（平时编程时一定要养成良好的文件命名习惯啊），还有就是最好也不要在文件名中出现中文，具体是不是因为编码的原因我还没有测试过，不过既然会带来麻烦，那就还是用英文吧（正好提升一下英语水平）。
接下来将文本文件另存为.bat文件格式，详情见下图：
在文本文档界面选择另存为（ctrl+shift+S），注意不仅要将文件后缀改成.bat，还要在保存类型中选择“所有文件”类型 ；
保存好批处理文件之后，将其移动到C:\Windows目录下（或者是其他任何一个已经设置为环境变量的路径均可）。
3.python文件中具体代码：
#! python3 #TEXT中是你想要复制到剪贴板上的内容和访问他们的关键字组成的字典 TEXT = {'忙': "您好，您所拨打的用户正忙，如需对方回电，请留言：", 'busy': "Sorry, I'm busy now.", '社会主义核心价值观': "富强民主文明和谐\n自由平等公正法治\n爱国敬业诚信友善"} import sys, pyperclip if len(sys.argv) &lt; 2: #此时argv中除了文件名之外没有传入其他参数 print("Sorry, no input has been received yet…") sys.exit() keyphrase = sys.argv[1] if keyphrase in TEXT: pyperclip.copy(TEXT[keyphrase]) print("The text " + TEXT[keyphrase] + " is copied to the clipboard") else: print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c3b09db12ffd77481ce0688b89108bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c84a1b201e1dd95e2f245b1dec72cb6/" rel="bookmark">
			B&#43;树(5)myISAM简介 --mysql从入门到精通（十七)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上篇文章我们说了，联合索引会用两个以上列来创建索引，b+树是一颗，先用c2列排序，若结果相同，则用c3排序。innoDB的b+树特点是根节点保持不变，新表是先默认有聚簇索引，先有一个没有数据的根目录节点，放用户记录数据放入根几点中，当数据慢了，页分裂，会有多的节点，此刻根节点进化成根目录记录节点，数据存入底层节点。二级索引的内节点保证一致性，存入列值的时候加个主键。
B+树(4)联合索引 --mysql从入门到精通（十六)
myISAM简介 我们知道了innoDB搜索引擎的是索引即是数据，分为列表值索引树，和聚簇索引树，聚簇索引那颗b+树索引即是数据，所有的用户记录数都存在叶子节点。而myISAM虽然也是B+树，但索引和数据是分开的。
myISAM会吧用户记录数据全部放在一个文件里，称为数据文件，这个文件不会划分若干页，有多少记录就往里面塞，通过每一行对应的行号快速访问，因为随意塞入，不会按主键大小排序，不能用二分查找法查找。之后会吧索引信息存储到另一个索引文件里，myISAM会单独为表的主键创建索引，只不过在叶子节点存储的不是用户记录数据，而是主键+行号，意味着找到到对应行号之后，会用行号去数据文件里再次找全部数据。所以myISAM每次查询都是必须要回表的，相当于二级索引。(innoDB的聚簇索引是直接在根目录记录页根据主键找到对应的内节点，在找到对应的底层叶子节点上的全部数据)。有需要的话，也可以建立二级索引或者联合索引，只是叶子节点存放的是列值+行号。 创建索引和删除索引： 说了那么多理论知识，那如何实战呢？mysql中的innoDB和myISAM表会自动为主键或者申明的为unique的列创建聚簇索引，但如果需要给其他列创建二级索引，则需要在sql里显示指明。为啥不自动创建呢，别忘了越多的索引意味着越多的b+树，意味着插入和删除都需要巨大的内存来维护b+树，很耗费性能。
建表的时候可以创建索引，index 和 key关键字都可以使用，指定indx_tb_col表的c2列为idx_c2名称的索引：
create table index_tb_col( c1 int, c2 int, c3 char(1), index idx_c2 (c2) )row_format=Compact; 也可以在表创建完成之后，指定c3为idx_c3名称的索引：
mysql&gt; alter table index_tb_col add index idx_c3 (c3); Query OK, 0 rows affected (0.04 sec) 也可以添加联合索引和删除索引：
//复合索引 mysql&gt; create table index_tb_col( -&gt; c1 int, -&gt; c2 int, -&gt; c3 char(1), -&gt; primary key (c1), -&gt; index idx_c2_c3 (c2,c3) -&gt; )row_format=Compact; Query OK, 0 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c84a1b201e1dd95e2f245b1dec72cb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d69baabc4b735e5ab2df19e325ac8d21/" rel="bookmark">
			Mac电脑必装清单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 iTerm2DaisyDisk mac清理AutoMounter 自动加载分享的文件 smb nas自动挂载Alfred 帽子stats 任务监视器mounty ntfs移动硬盘文件复制MWeb 文档编写工具xScope 屏幕标尺/取色/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b93b6dc69f94134c6becde1038865ff/" rel="bookmark">
			荣耀秋招机试三道编程题（2021-08-14）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		恭喜发现宝藏！微信搜索公众号【TechGuide】关注更多新鲜好文和互联网大厂的笔经面经。
作者@TechGuide【全网同名】
点赞再看，养成习惯，您动动手指对原创作者意义非凡🤝
文章目录 提示第一道：将字母分为3个等级输出（100%）题目描述思路解析参考代码： 第二道： 推荐歌曲（100%）题目描述思路解析参考代码 第三道：切水果题目描述参考代码 提示 类似华为，甚至有出现过之前的原题。难度不大。 第一道：将字母分为3个等级输出（100%） 题目描述 将字母分为高中低三个等级，输入一个字符串，将三个等级的字母分开，然后排序。
思路解析 方法一：
三个按字典序排序的优先队列即可·
方法二：
用三个动态字符串StringBuilder分别存储三个等级的字符，然后通过Arrays.sort对每个等级的字符排序，所以需要提前将sb类型转为char数组，最后输出字符串。
对于这种排序问题可以使用优先队列，这个我平时不习惯用，但是看了一下人家的代码，似乎很好用。PriorityQueue是用的二叉树实现的小顶堆，可以通过add(t)添加一个节点，poll()删除堆顶元素，时间复杂度O(logN);peek()检索堆顶元素-不删除，复杂度O(1)；要生成大顶堆可以使用new PriorityQueue&lt;&gt;(Collections.reverseOrder())。
switch和if-else比较：二者根本区别是switch会生成一个“跳表”，跳表的索引号和case的值相同，直接通过访问跳表的索引号就可以直接定位到相应的分支，这是一种空间换时间的做法；而if-else是逐个判断，定位到相应分支的做法。相比之下，if-else结构更加灵活，适合处理非【常量】的判断条件；switch定位分支较快，一般用于判断数据不多，并且数据类型是char、int等类型比较适合。
参考代码： 方法一
import java.util.PriorityQueue; import java.util.Scanner; public class Main1 { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String s = scanner.next(); PriorityQueue&lt;Character&gt; q1 = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Character&gt; q2 = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Character&gt; q3 = new PriorityQueue&lt;&gt;(); for(int i=0;i&lt;s.length();i++){ switch (fun(s.charAt(i))){ case 1:q1.add(s.charAt(i));break; case 2:q2.add(s.charAt(i));break; case 3:q3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b93b6dc69f94134c6becde1038865ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4ad53c64d817985a68a1ceb5b853b1c/" rel="bookmark">
			sdcc对应stc51单片机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在国产stc51单片机性能上还是够用的了，软件工具选择sdcc是好的选择。别的付费软件就算了吧。 使用了一段时间的sdcc，汇编和c都试用了下，感觉还可以，命令行输入，错误列在命令下面，没有错误就是没有反应。文本编辑软件使用的是notepad++。
c语言下有个函数数组的调用出了问题，__code伪指令没有起到作用，只好转换成函数的一般调用的基本方式。
汇编还好，虽然是很少用到。混合asm和c也是简单，只是里面的io定义还不一样，汇编要按汇编的定义，c的要按c的定义。
c的头文件要注意，当然把所有函数写在一个c源文件里面可以避免这些麻烦，但是源文件就显得过大了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b22197f7f6cc341972e51f1d7cd5fb9/" rel="bookmark">
			flutter编写border的相关代码和clip剪切
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Container( width:deviceWidth, height: deviceHeight*0.318, decoration: BoxDecoration( color: Colors.amberAccent, border: Border.fromBorderSide(BorderSide( color: Colors.grey, width: 1.0, style: BorderStyle.solid )), borderRadius: BorderRadius.only( bottomLeft: Radius.circular(15), bottomRight: Radius.circular(15) ) ), child:Image( image: AssetImage("images/userbackgroud.png"), fit: BoxFit.fill, ), ) 如果使用的decoration对container进行包装的话，color必须写在decoration里边，写在外面是不起作用的。在我写了border后，虽然image是在container里边而且在下部设置了俩个圆角，但是任然不会对图片进行裁剪，这个因为它有个属性叫clipBehavior截切行为设置称了Clip.none 不进行裁剪
当我们使用了它的抗锯齿剪切属性后就会对图片裁剪了，为了美观我们把它的border去掉
Container( width:deviceWidth, height: deviceHeight*0.318, clipBehavior: Clip.antiAlias, decoration: BoxDecoration( borderRadius: BorderRadius.only( bottomLeft: Radius.circular(15), bottomRight: Radius.circular(15) ) ), child: Image( image: AssetImage("images/userbackgroud.png"), fit: BoxFit.fill, ), ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4856e689d27c9da567d7884647514621/" rel="bookmark">
			论文：Few-Shot Knowledge Graph Completion 个人翻译及理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 以前的KG补全方法 需要每个关系有大量的训练实例（头尾实体对）。现实的情况是，大多数的关系，只有少量的训练实例。基于小样本的知识图谱补全还没有被很好的研究，所以本文提出了一个新的小样本关系学习模型FSRL：旨在从少量样本中发现新的关系。有效地从异构图形结构中捕获知识，对小样本进行表征，为每个关系参考集匹配相似的实体对，在两个公共数据集上的大量实验表明，FSRL的表现出了出色的性能。
介绍 大规模的知识图，如YAGO (Suchanek, Kasneci, and Weikum 2007), NELL (Carlson et al. 2010), and Wikidata (Vrandeˇci´c and Kr¨otzsch 2014) 通常以头尾实体对（节点）以及他们的之间的关系（边）的形式表示fact。这种图结构化知识对于搜索、问答和语义网络等许多下游应用是必不可少的。然而，知识图谱以其不完整而闻名。 为了使KG能够实现自动补全，许多工作(Nickel, Tresp, and Kriegel 2011; Bordes et al. 2013; Socher et al. 2013; Yang et al. 2015; Trouillon et al. 2016; Schlichtkrull et al. 2018; Dettmers et al. 2018)已经被提出通过学习现有的关系来推断缺失的关系。比如：RESCAL (Nickel, Tresp, and Kriegel 2011)利用张量分解来捕获kg中多关系数据的内在结构。TransE (Bordes et al. 2013) 将关系解释为对实体的低维嵌入的翻译操作。,最近GCN (Schlichtkrull et al. 2018)利用图神经网络建立关系结构模型。
上述方法对每个关系都需要大量的实体对。然而，在实际数据集中，关系的频率分布往往有长尾。很大一部分关系在KG中只有很少的实体对。对只有少量实体对的关系进行嵌入是重要和具有挑战性的。
鉴于上述问题，Xiong et al. (2018)提出了一种引入局部邻居编码器来学习实体嵌入的Gmatching模型，它在单样本关系推理中取得了很好的性能，但仍有一定的局限性。首先，GMatching假设所有本地邻居对实体嵌入的贡献相等，然而异质邻居可能有不同的影响。因此，GMatching的邻域编码器学习到的图结构表示不足，损害了模型的性能。第二，GMatching是在单样本学习的设置下设计的。虽然它可以通过在参考集上添加一个池层来修改为小样本学习的设定，但这一操作忽略了少镜头参考实例之间的交互，限制了参考集的表示能力。为了解决上述不足之处，我们提出了一个小样本关系学习模型(FSRL)。为了学习一个匹配函数，该函数可以有效地推断出给定每个关系的一组小样本参考实体对集的真实实体对（即预测的可能存在该关系的实体对）。首先，我们提出了一种关系感知的异构邻居编码器来学习实体嵌入，它基于异构图形结构和注意机制，既能捕获到不同关系类型的信息又能捕获到本地邻居的不同影响。接下来，我们设计了一个循环自动编码器聚合网络来建模小样本实体对的交互。并为为每个关系进行累积编码。随着参考集的聚合嵌入，我们最终采用匹配网络来发现相似的关系实体对。采用基于元训练的梯度下降方法对模型参数进行优化。所学习的模型可以进一步应用于推断任何新关系的真实实体对，而不需要任何微调步骤。综上所述，我们的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4856e689d27c9da567d7884647514621/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcdfa615922bfb4c9102f95e06032e32/" rel="bookmark">
			线程池使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		private void multThreadDownloadPdf(List&lt;EleInvVo&gt; exportList, final ConcurrentLinkedQueue&lt;String&gt; queue, final CountDownLatch latch) { ExecutorService threadPool = Executors.newFixedThreadPool(5); for (final EleInvVo eleInvVo : exportList) { threadPool.execute(new Runnable() { @Override public void run() { try { if (!CheckUtil.isNull(eleInvVo.getPdfStorageKey())) { String pdfPath = WebUtil.getRelativeFilePath( eleInvVo.getOrderNo() + "_" + eleInvVo.getInvoiceNo() + "_" + RandomStringUtils.randomAlphanumeric(10) + ".pdf"); jCloudService.getStorageObject(eleInvVo.getPdfStorageKey()) .toFile(new File(pdfPath)); queue.offer(pdfPath); } } catch (Exception e) { logger.error("线程下载pdf异常，订单号【{}】，异常信息：{}",eleInvVo.getOrderNo(), e); } finally { latch.countDown(); } } }); } threadPool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcdfa615922bfb4c9102f95e06032e32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7e88f1e503a3cc538ce12fe52f5751/" rel="bookmark">
			【Python之numpy库】12.np.round() 对数组/一堆数保留n位小数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果解决了你的问题，点个赞再走嘛٩(๑❛ᴗ❛๑)۶
对一堆数保留指定小数，用numpy库非常方便。如果是列表的话，列表本身没有太好的方法，但是可以用np.array(a)转化为数组再操作也是很好的方法
两种等价方法，设保留n位小数，则：a.round(n)或np.round(a,n)
import numpy as np a = np.array([1.2347, 0.4214, 42.2374]).astype('float') print(a) print(a.round(2)) print(np.round(a, 2)) 结果：
[ 1.2347 0.4214 42.2374]
[ 1.23 0.42 42.24]
[ 1.23 0.42 42.24]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1025d1b23dbaf5b1fa5b689ef0ecaaa2/" rel="bookmark">
			OkHttp同步异步请求（get请求、post请求）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要想在安卓中使用okhttp先进行配置。
①在app的build.gradle中添加依赖：
implementation("com.squareup.okhttp3:okhttp:4.9.0") ②在AndroidManifest.xml中添加联网权限：
&lt;uses-permission android:name="android.permission.INTERNET"/&gt; get同步：
okHttpClient = new OkHttpClient(); //全局变量 public void getSync(View view) { new Thread(new Runnable() { @Override public void run() { Request request = new Request.Builder().url("https://www.httpbin.org/get?a=1&amp;b=2").build(); Call call = okHttpClient.newCall(request); try { Response response = call.execute(); Log.i("TAG", "getSync: " + response.body().string()); } catch (IOException e) { e.printStackTrace(); } } }).start(); } ①首先全局变量创建一个OkHttpClient实例。
②在安卓中，必须要求创建一个线程去执行服务器请求命令：依据所需的url创建一个Request，由该request获取其call。
接下来对call.execute获取回执，并且其中body就是连接服务器后获取的信息。
get异步：
okHttpClient = new OkHttpClient(); //全局变量 public void getAsync(View view) { Request request = new Request.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1025d1b23dbaf5b1fa5b689ef0ecaaa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d69b44b3b7006cd167e2f34db6f611f1/" rel="bookmark">
			关于PX4系统移植的新的硬件平台一些尝试总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近尝试将PX4的firmware-v1.11.0移植到某stm32h7的飞控平台上（该飞控硬件，适配ardupilot和betaflight的固件，但不支持PX4，跟厂家沟通过，据说是PX4用户少？所以他们就没支持），在网上找了好久也没找到像样的参考自己，自己也是摸索尝试了好久，在经历了无数次失败后，终于算是初步移植成功。
现在写篇帖子把相关思路总结一下，算是抛砖引玉，也给需要进行相关工作的朋友一个参考。
PX4中官网有关于系统移植的简要说明，可以参考：http://docs.px4.io/master/zh/hardware/porting_guide.html
一、移植的思路
由于我对飞控硬件这块不太了解，所以选择站在巨人的肩膀上。
即：在PX4的firmware官方支持的硬件库中寻找与需要进行固件移植的目标硬件所用的主控芯片相同或相近的硬件，在其配置好的代码中根据自己自己的硬件配置进行修改，适配。
比如我的目标硬件使用的主控芯片是stm32h7, 官方支持的硬件库中同样使用该芯片的硬件有: cuav的nora和x7pro，cubepilot的cubeorange，px4的v6x等。这些板子的配置文件在firmware/boards文件夹中。
需要根据目标硬件的晶振、串口进行修改。
二、要修改的文件
PX4系统的移植主要是针对其实时操作系统nuttx的移植。
1.boards文件夹中文件的修改
1.1 board.h
1.2 defconfig
1.3 default.cmake
2.rcS文件的修改
三、如何判断是否移植成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef574ecfbc5847fcef6752e075abfd6c/" rel="bookmark">
			Python-Numpy函数：np.round(),np.around(),np.floor(),np.ceil()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Python-Numpy函数：np.round(),np.around(),np.floor(),np.ceil()这几个函数均可以对numpy数组元素进行取整，区别以下。python
一 、np.round()函数的做用：对给定的数组进行四舍五入，能够指定精度，同np.around()
示例一：
around(array, decimals=0, out=None)
第一个参数指定数组
第二个参数指定保留的小数点位数，缺省值为0，即取整数web
a=np.array([1.23,2.31,31.23,66.23]) print(np.round(a)) print(np.around(a)) ''' result: [ 1. 2. 31. 66.] [ 1. 2. 31. 66.] ''' 二，np.floor()：对数组元素下取整
floor字面意思：地板
np.ceil():对数组元素上取整数组
a=np.array([1.22,-0.23,4.68,3.57]) print(np.floor(a)) #[1,-1,4,3] print(np.ceil(a)) #[2,-0,5,4] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07f89869a2334a0577bb4a6ee069fd3c/" rel="bookmark">
			Openvino Mac版部署踩坑记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天在Ubuntu上使用了openvino觉得速度还行，想着在自己的Mac上也装一个，来实现在家也能为社会主义做贡献的梦想（手动狗头），然后坑就来了，历经各种试错，终于找到解决方案，分享给后来之人。
首先奉上Intel Openvino的官方安装教程链接：https://docs.openvinotoolkit.org/2021.2/openvino_docs_install_guides_installing_openvino_macos.html
教程一定要从头到尾看，看一遍再装，坑就在细节里：
首先，硬件环境一定要符合要求，目前官方提供的完整安装包只支持Intel芯片，也就是X86架构，今年5月份开始计划逐步支持ARM架构，但还没有稳定的工具包，着急尝鲜的同学可以上github下载ARM架构Plugin，自己编译库，附上Github Pulgin下载链接
https://github.com/openvinotoolkit/openvino_contrib
接着就是软件环境，官方文档要求软件环境如下：
CMake 3.10 or higherPython 3.6 - 3.7Apple Xcode* Command Line Tools(Optional) Apple Xcode* IDE (not required for OpenVINO, but useful for development） 特别注意python环境目前只能是3.6-3.7版本，别装3.8，系统自带的2也是不行的，不然库文件对不上会一直报错。其他安装都没啥问题，要是缺了，系统会提醒你啥没装，安装就好。我就说一下python环境的配置，这一步没搞好，后面问题太多了。
python环境安装可以采用直接官网下载或者anaconda安装两种方式，都没有问题，我是用了官网下载python的方法，链接如下：
https://www.python.org/downloads/macos/
推荐下载3.7，安装完成后记着配置环境变量，方法如下：
vim ~/.bash_profile 输入‘i’，进入编辑模式，在文件最后一行加入一下环境变量，然后’esc‘，输入’：wq‘，保存即可。
alias python=/usr/local/bin/python3.7 最后
source ～/.bash_profile.sh 激活环境变量，在终端窗口输入python，如果版本为3.7，说明安装成功了。
最后，安装openvino，前面的环境要求配置好，这一步没什么难度，官网下载openvino，选择root权限或者admin权限安装，一直下一步就好，最后一步安装完成，会跳转到网页环境变量页面，标题设置如下：
Set the Environment Variables You need to update several environment variables before you can compile and run OpenVINO™ applications. Open the macOS Terminal* or a command-line interface shell you prefer and run the following script to temporarily set your environment variables:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07f89869a2334a0577bb4a6ee069fd3c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3fa5770be55883976b35b90aac7f9e8/" rel="bookmark">
			ubuntu 开机后黑屏dev/nvme0n1p4: clean, xxx/xxx files, xxx/xxxblocks
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开机后选择高级操作
选择revovery mode
选择network
然后选择root，输入root密码
命令行删除英伟达相关驱动
sudo apt-get purge nvidia*
然后重新装相关驱动
sudo ubuntu-drivers autoinstall
重新启动
reboot
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9e786fdf3329df3722dec7ff06497f6/" rel="bookmark">
			通过加密连接将敏感信息发送到服务器,计算机网络相关知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.OSI参考模型和TCP/IP模型
OSI参考模型是ISO组织指定的网络互联的一个参考模型，总共分为七层，分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
TCP/IP是现在通用的网络互联模型，总共五层，分别是：应用层(FTP、HTTP、DNS)、传输层(TCP、UDP)、网络层(ARP、ICMP)、数据链路层、物理层。
2.TCP和UDP，以及两者的区别
TCP：
TCP是面向连接的传输层协议，提供可靠交付。
UDP：
UDP是面向无连接的传输层协议，提供尽最大努力交付。
TCP和UDP的区别：
--TCP面向连接，UDP面向非连接
--TCP提供可靠交付(确认重传机制)，UDP是尽最大努力交付，不保证可靠交付
--TCP报文头复杂，冗余信息多，而UDP报文头简单，额外开销小
--TCP速度较慢，而UDP速度受限于数据生成速度，传输速度，速度较快
--TCP通过MTU对报文进行拆分合并，UDP不进行拆分合并
3.TCP三次握手和四次挥手
TCP通过三次握手来建立连接：
第一次握手：建立连接时，客户端发送SYN包(序列号seq=j)到服务器，并进入SYN_SEND状态，等待服务器确认
第二次握手：服务器收到syn包,必须确认客户的SYN(确认应答号ack=j+1),同时自己也发送一个SYN包(序列号seq=k),即SYN+ACK包,此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(确认应答号ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手.
为什么需要三次握手来建立连接：
为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值 的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。
TCP断开连接需要四次挥手：
客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。
TCP断开连接为什么需要四次挥手：
因为TCP是全双工的，连接的两端都可以发送/接收数据，所以关闭连接时两方需要FIN(请求断开)和ACK(确认)。
tcp挥手为什么等待2ms
TCP断开连接时，首先发起断开请求的一方在受到对方的FIN包，发送ACK包后需要等待一段时间，是为了保证对方收到ACK(超时可以重传)，以及避免新旧连接混淆。
1、防止客户端最后一次发给服务器的确认在网络中丢失以至于客户端关闭，而服务端并未关闭，导致资源的浪费。
2、等待最大的2msl可以让本次连接的所有的网络包在链路上消失，以防造成不必要的干扰。
4.HTTP和HTTPS
HTTP请求包和响应包：
HTTP请求报文：
方法 URL 协议版本
请求头部字段名：值
...
请求正文
HTTP响应报文：
协议版本 状态码 描述
响应头部字段名：值
...
响应正文
GET请求和POST请求的区别：
GET请求数据放在URL中(以？分割URL和传输的数据，参数之间以&amp;相连)，而POST请求则放在报文体中
GET请求提交的url中的数据最多只能是1024字节，这个限制是浏览器或者服务器给添加的，http协议并没有对url长度进行限制，目的是为了保证服务器和浏览器能够正常运行，防止有人恶意发送请求。
POST请求则没有大小限制。
GET请求符合幂等性和安全性，POST请求不符合
GET请求可以被缓存、存储，POST请求不可以
状态码和重定向 Http code 问：501到505解释下，403的每种情况呢？
1XX:接收的请求正在处理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9e786fdf3329df3722dec7ff06497f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58642ced0799a3378d341896b66ed140/" rel="bookmark">
			柯美服务器显示ff,柯尼卡美能达C故障代码解读.docx
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		柯尼卡美能达C故障代码解读.docx
柯尼卡美能达C250/252/300/352彩色复印机常见代码　C3451,定影加热辊预热故障?　C3452,定影压力辊加热故障?　C3851,加热辊异常低温?　C3852,压力辊异常低温?　C3751,加热辊异常高温?　C3752,压力辊异常高温?　C2551,青色TCR感应器检测到异常低的碳粉浓度?　C2552,青色TCR感应器检测到异常高的碳粉浓度?　C2553,红色TCR感应器检测到异常低的碳粉浓度?　C2554,红色TCR感应器检测到异常高的碳粉浓度?　C2555,黄色TCR感应器检测到异常低的碳粉浓度?　C2556,黄色TCR感应器检测到异常高的碳粉浓度?　C2557,黑色TCR感应器检测到异常低的碳粉浓度?　C2558,黑色TCR感应器检测到异常高的碳粉浓度?　C2559,青色TCR感应器调整故障?　C255A红色TCR感应器调整故障?　C255B黄色TCR感应器调整故障?　C255C黑色TCR感应器调整故障?　C2451,新转印清洁器复位故障?　C3461新定影部件复位故障?　C2651.青色成像部件EEPROM访问故障--建议更换硒鼓或EEPROM?　C2652,红色成像部件EEPROM访问故障--建议更换硒鼓或EEPROM?　C2653,黄色成像部件EEPROM访问故障--建议更换硒鼓或EEPROM?　C2654,黑色成像部件EEPROM访问故障--建议更换硒鼓或EEPROM?　C2A01.青色碳粉盒EEPROM访问故障--建议更换碳粉盒或EEPROM?　C2A02,红色碳粉盒EEPROM访问故障--建议更换碳粉盒或EEPROM?　C2A03,黄色碳粉盒EEPROM访问故障--建议更换碳粉盒或EEPROM?　C2A04,黑色碳粉盒EEPROM访问故障--建议更换碳粉盒或EEPROM?　二：柯尼卡美能达C350/450彩色复印机的一些常见故障代码 以下我将这些机器的常见故障代码列出来供大家参考?　C0200，青色PC感光鼓充电电晕故障--充电座需要维修更换?　C0202，红色PC感光鼓充电电晕故障--充电座需要维修更换?　C0204，黄色PC感光鼓充电电晕故障--充电座需要维修更换?　C0206，黑色PC感光鼓充电电晕故障--充电座需要维修更换?　C0208，PC感光鼓充电电晕故障--充电座需要维修更换?　C0500, 定影加热辊预热故障?　C0501, 定影压力辊加热故障?　C0510, 加热辊异常低温?　C0511, 压力辊异常低温?　C0520, 加热辊异常高温?　C0521, 压力辊异常高温?　C0F30, 青色ATDC感应器检测到异常低的碳粉浓度?　C0F31, 青色ATDC感应器检测到异常高的碳粉浓度?　C0F32, 红色ATDC感应器检测到异常低的碳粉浓度?　C0F33, 红色ATDC感应器检测到异常高的碳粉浓度?　C0F34, 黄色ATDC感应器检测到异常低的碳粉浓度?　C0F35, 黄色ATDC感应器检测到异常高的碳粉浓度?　C0F36, 黑色ATDC感应器检测到异常低的碳粉浓度?　C0F37, 黑色ATDC感应器检测到异常高的碳粉浓度?　C0F3A, 青色ATDC感应器调整故障?　C0F3B，红色ATDC感应器调整故障?　C0F3C，黄色ATDC感应器调整故障?　C0F3D，黑色ATDC感应器调整故障?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/58642ced0799a3378d341896b66ed140/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f6f8e4f2858f62d3eed1ccdf5f8f3db2/" rel="bookmark">
			百度之星初赛（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		初赛一 打疫苗去了，最后\(30min\)看了看题，打了一题还有一题没调出来。
自己的思路太慢以及打代码速度太慢，别人可以\(40min\)切\(5\)题啊。。。
初赛相对来说不算太难的。
\(T4,T8\)是简单的模拟题。
\(T6\)需要超级快读。感觉自己也需要背背这个板子。
\(T3\)是简单的\(DP\)。
初赛二 这次是准时(迟了\(10min\))开始打的。
从\(T1\)开始打的，是道简单小学数学题。
\(T2\)简单模拟，\(T7\)简单拓扑序，\(T4\)是简单数学题。
\(T3\)是超简单弱化版的欧拉回路(甚至不需要找回路)。
\(T5\)的题意和样例没看懂：
给一个排列，排列可能由两种方式生成：
初始为\(1,2,...,n\)，每次等概率随机交换两位，交换\(3n\)次。初始为\(1,2,...,n\)，每次等概率随机交换两位，交换\(7n\)次。 求这个排列是由哪种方式生成。\(50000\le n\le 100000\)
结果这题题解也来了个捉摸不透的解释：
交换 \(3n\) 次之后排列的环的个数或不动点个数会远大于交换 \(7n\) 次之后排列环的个数或不动点个数，直接判断大小即可。
看了看别人的代码，就是判断不动点个数是否大于\(10/50/20/2/...\)，感觉很神奇。。。
\(T6\)感觉并不难，考场有两种想法。
以每个叶子(且是直径一段)为根做一波，乘积之和。
想的是找重心然后看每个深度的个数，\(C(2,t[dep])\)的乘积，但是错了。
看来是我考虑不够周全。。。
正解和我的第一个想法其实很相似了，但是有些情况会算重：
就是刚好\(S\)中的点是一条直径的情况，这样直径两端都可以算到这种情况，需要特别减去这种情况即可。
而减去这个极其容易，只需要在\(dfs\)的时候顺便记录一下\(mxdep\)的个数，最后的\(ans\)减去\(sum/2\)即可。
初赛三 咕咕咕了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6d561a047bbf4527e00e3a412b4bc0c/" rel="bookmark">
			uoml文档交换服务器,文档处理系统和方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.一种文档处理方法，其特征在于，包括: 应用软件发送指令到平台软件，以对抽象非结构化信息进行操作； 平台软件接收到来自所述应用软件的指令，根据所述指令，对与所述抽象非结构化信息对应的存储数据执行所述操作； 其中，所述抽象非结构化信息与所述存储数据的数据方式无关;其中，所述抽象非结构化信息包括具有呈现效果的可视化信息，多维信息，和/或流媒体信息;所述抽象非结构化信息不具有存储。
2.如权利要求1所述的方法，其特征在于，通过发送命令串或调用函数来发送指令。
3.如权利要求1所述的方法，其特征在于，所述存储数据为一个或多个磁盘文件，部分磁盘文件，数据库的一个或多个字段，或磁盘分区的一个区域。
4.如权利要求1所述的方法，其特征在于，所述抽象非结构化信息包括多个页的可视化ί目息O
5.如权利要求1所述的方法，其特征在于，所述抽象非结构化信息符合预定义文档模型。
6.如权利要求5所述的方法，其特征在于，所述预定义文档模型为树形结构，并且包括至少文档对象、页对象以及用于描述版面的对象。
7.如权利要求6所述的方法，其特征在于，所述用于描述版面的对象可以是文字对象、图片对象和图形对象的任一项或任几项的组合。
8.如权利要求7所述的方法，其特征在于，所述用于描述版面的对象还可以是状态对象、文字对象、路径对象、渐变色对象、图像对象、流媒体对象、元数据对象、批注对象、语义信息对象、源文件对象、脚本对象、插件对象、二进制数据流对象、书签对象以及超链接对象中任一项或任几项的组合。
9.如权利要求6所述的方法，其特征在于，所述预定义文档模型进一步包括文档库对象，所述文档库对象包括至少一个文档对象;或者 所述预定义文档模型进一步包括文档库对象和文档集对象，其中所述文档库对象包括至少一个文档集对象，所述文档集对象包括至少一个文档对象和或至少一个文档集对象。
10.如权利要求6所述的方法，其特征在于，所述预定义文档模型进一步包括层对象，所述页对象包括至少一个层对象，所述层对象至少包括一个用于描述版面的对象。
11.如权利要求10所述的方法，其特征在于，所述预定义文档模型进一步包括对象组对象，所述层对象至少包括一个对象组对象，所述对象组对象包括至少一个用于描述版面的对象。
12.如权利要求5所述的方法，其特征在于，所述预定义文档模型进一步定义来角色对象以及角色的访问权限。
13.如权利要求12所述的方法，其特征在于，所述角色的访问权限包括所述角色针对所述抽象非结构化信息的至少一个对象的访问权限。
14.如权利要求1所述的方法，其特征在于，所述指令符合“操作动作+操作对象”的标准。
15.如权利要求14所述的方法，其特征在于，所述操作包括:获取信息、设置对象属性、插入对象、删除对象以及查询。
16.如权利要求14所述的方法，其特征在于，所述指令按预定义的格式生成。
17.如权利要求16所述的方法，其特征在于，所述指令包含描述操作动作和操作对象的字符串。
18.如权利要求17所述的方法，其特征在于，所述字符串用XML描述。
19.如权利要求17所述的方法，其特征在于，所述操作动作对应一个XML元素，所述操作动作通过句柄引用。
20.如权利要求14所述的方法，其特征在于，所述平台软件提供接口函数，每个接口函数定义来一个对象上的一个操作； 所述应用软件通过调用与所述操作动作和操作对象对应的接口函数，发送所述指令。
21.如权利要求14所述的方法，其特征在于，所述平台软件提供基于对象类的方法； 所述应用软件通过调用所述对象类的方法发送指令;其中所述对象类由所述操作对象封装而成，所述对象类的方法对应所述操作动作。
22.如权利要求1所述的方法，其特征在于，所述平台软件进一步为应用软件提供操作结果。
23.一种文档处理系统，其特征在于，包括: 用于应用软件发送指令到平台软件，以对抽象非结构化信息进行操作的装置； 用于平台软件接收到来自所述应用软件的指令，根据所述指令，对与所述抽象非结构化信息对应的存储数据执行所述操作的装置； 其中，所述抽象非结构化信息与所述存储数据的数据方式无关;其中，所述抽象非结构化信息包括具有呈现效果的可视化信息，多维信息，和/或流媒体信息;所述抽象非结构化信息不具有存储。
24.一种文档处理方法，其特征在于，包括: 第一应用软件发送第一指令到平台软件，以创建第一抽象文档； 所述平台软件接收所述第一指令，创建与所述第一抽象文档对应的存储数据； 第二应用软件发送第二指令到所述平台软件以打开所创建的存储数据； 所述平台软件接收所述第二指令，打开并解析所述存储数据，生成与所述存储数据对应的第二抽象文档； 其中所述第一指令与第二指令符合相同的接口标准；其中，所述第一抽象文档和所述第二抽象文档包括具有呈现效果的可视化信息，多维信息，和/或流媒体信息;所述第一抽象文档和所述第二抽象文档不具有存储。
25.一种文档处理系统，其特征在于，包括: 用于第一应用软件发送第一指令到平台软件，以创建第一抽象文档的装置； 用于所述平台软件接收所述第一指令，创建与所述第一抽象文档对应的存储数据的装置； 用于第二应用软件发送第二指令到平台软件以打开所创建的存储数据的装置； 用于所述平台软件，接收所述第二指令，打开并解析所述存储数据，生成与所述存储数据对应的第二抽象文档的装置； 其中所述第一指令与第二指令符合相同的接口标准；其中，所述抽象文档包括具有呈现效果的可视化信息，多维信息，和/或流媒体信息;所述第一抽象文档和所述第二抽象文档不具有存储。
26.一种文档处理方法，其特征在于，包括: 第一平台软件解析以第一数据格式存储的第一存储数据，生成与所述存储数据对应的第一抽象文档； 应用软件发送第一指令到所述第一平台软件，以获取所述第一抽象文档的所有信息；发送第二指令到第二平台软件，以创建与所述第一抽象文件相同或相似的第二抽象文档； 所述第二平台软件根据所述第二指令，创建与所述第二抽象文档对应并按第二数据格式存储的第二存储数据； 其中所述第一指令和第二指令符合相同的接口标准；其中，所述第一抽象文档和所述第二抽象文档包括具有呈现效果的可视化信息，多维信息，和/或流媒体信息;所述第一抽象文档和所述第二抽象文档不具有存储。
27.一种文档处理系统，其特征在于，包括: 用于第一平台软件解析以第一数据格式存储的第一存储数据，生成与所述第一存储数据对应的第一抽象文档的装置； 用于应用软件发送第一指令到所述第一平台软件，以获取所述第一抽象文档的所有信息;发送第二指令到第二平台软件，以创建与所述第一抽象文件相同或相似的第二抽象文档的装置； 用于所述第二平台软件根据所述第二指令，创建与所述第二抽象文档对应并按第二数据格式存储的第二存储数据的装置； 其中所述第一指令和第二指令符合相同的接口标准；其中，所述第一抽象文档和所述第二抽象文档包括具有呈现效果的可视化信息，多维信息，和/或流媒体信息;所述第一抽象文档和所述第二抽象文档不具有存储。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/566d5104fded186c84d0831b6a09e3ce/" rel="bookmark">
			服务器端和客户端均停用sslv3协议,客户端请求的协议的SSLv3未启用或不支持（IBM JDK 6.0SR10）...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		的异常时，客户端和服务器的SSL协议设置不匹配发生。
以下客户端的示例代码可与服务器侧配置支承TLSv1.2工作协议：
String response = "";
URL url = new URL("https://localhost:9043/myservlet);
final SSLContext ctx = SSLContext.getInstance("TLSv1.2");
ctx.init(null, null, null);
// final String protoccol = ctx.getProtocol();
HttpsURLConnection.setDefaultSSLSocketFactory(ctx.getSocketFactory());
final HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
conn.setReadTimeout(15000);
conn.setConnectTimeout(15000);
conn.setRequestMethod("POST");
conn.setDoInput(true);
conn.setDoOutput(true);
final OutputStream os = conn.getOutputStream();
final BufferedWriter writer =
new BufferedWriter(new OutputStreamWriter(os, "UTF-8"));
writer.write(......);
writer.flush();
writer.close();
os.close();
final int responseCode = conn.getResponseCode();
if (responseCode == HttpsURLConnection.HTTP_OK) {
String line;
final BufferedReader br =
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/566d5104fded186c84d0831b6a09e3ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92397c3259908dc8838486a7764812ce/" rel="bookmark">
			SM3算法原理解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SM3算法原理解析 (1)消息填充
首先将比特“1“ 添加到消息的末尾，再添加k个零，这里k是方程l+1+k = 448 mod 512的最小的非负解。然后再添加一个64比特长的块，其值等于消息M的长度l的二进制表示，使得填充后的消息的长度为512比特的倍数。
(2)迭代
消息分组和初始值进入MD结构进行迭代压缩,初始变量如下：
填充后的消息M’ = B(0)B(1)… B(n-1)，n=(k+l+65)/512,消息B(i)为512比特。
伪代码：
FOR i=O TO n-1
H(i+1) = CF(H(i), B(i))
ENDFOR
其中H(i+1)是链接变量，链接变量H(n)为hash值; CF(.,.)为压缩函数。
(3)消息编排
当消息填充完成后，将消息块B(i)分为16个32比特字W0, W1, … ,W15
伪代码：
FOR j=16 TO 67
Wj ← P1(Wj-16⊕Wj- 9⊕(Wj-3&lt;&lt;&lt; 15))⊕(Wj-18&lt;&lt;&lt; 7)⊕Wj-6
ENDFOR
FOR j=0 TO 63
W’j ← Wj⊕Wj+4
ENDFOR
(4)压缩函数
输入链接变量H(i)和消息字B(i)，A,B,C,D,E,F,G,H为字寄存器: A,B,C,D,E,E,G,H← H(i)
FOR t=0 TO 63
SS1 ← ((A &lt;&lt;&lt; 12) + E + (Tj &lt;&lt;&lt; (j mod 32))) &lt;&lt;&lt; 7
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92397c3259908dc8838486a7764812ce/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/293/">«</a>
	<span class="pagination__item pagination__item--current">294/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/295/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>