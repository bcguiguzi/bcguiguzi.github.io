<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/446b4379cde8016a6e4c91c99cb20b29/" rel="bookmark">
			论EI、SCI和ISTP检索论文的收录号和期刊号查询方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.scitsg.com/Article/134240802101541.aspx
需要申请博士后进站和国家自然科学基金的朋友都知道申请博士后进站和国家自然科学基金需要填写很多申请表格，其中就需要填写所发表的EI、SCI和ISTP论文的收录号和期刊号。怎么进行查询自己所发表的EI、SCI和ISTP论文的收录号和期刊号呢？这里就给出相应的查询方法。
EI收录号的方法是：
1、进入EI Compendex数据库
2、输入要检索的文章，检索文章
3、检索到文章后点击下面的Detailed，Accession number就是EI收录号。
SCI收录号的方法是：
1、进入Web of Science数据库
2、输入要检索的文章，检索文章
3、检索到文章后，点击文章标题进入，WOS:000283155600011就是SCI收录号。获取ISTP的方法与此完全相同。
期刊号就是ISSN。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a678ca9b1aa48ab53d46502543d5cd96/" rel="bookmark">
			SLAM入门精品
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://blog.csdn.net/akunainiannian/article/details/45363731
最近6个月开始做SLAM的项目,就一步步把资源的链接给共享出来。
项目内容：主要是从Andrew Davison中的MonoSLAM中起步，做Co-SLAM 推及 Swarm SLAM
下面都是我看过或者亲身实践过的，大家可以相互交流
项目途中，所以文章还是草稿，会实时的更新。
一，入门篇
1. Andrew Davison的课程： http://www.doc.ic.ac.uk/~ajd/Robotics/index.html
AD在在week 8里面推荐了slam的两个入门 Tutorial 1 和Tutorial 2
2. Tutorial的两篇文章文笔灰常秀丽，但是不操作还是云里雾里：
所以这里有一个瑞士苏黎世理工的学生练习
大家把excise 3：SLAM（EKF）做了，也就差不多了解些slam的原理了
关于练习3的答案，我过几天上传好, 答案
3. 对于我这个学渣来说，EKF其实还是比较难理解，所以推荐一本书，详见第三章，学霸无视
二、现有资源
1. OpenSLAM：https://openslam.org/
这个网站中含有很多slam方面的资料，编写的程序也各有不同，很权威
2. Kitti这个图库，大家可以下载做simulation：http://www.cvlibs.net/datasets/kitti/
3. 个人感觉exercise 3练习后，可以选择 Javier Civera 的程序进行试手，感觉灰常不错。注意对calibration的调整
http://webdiis.unizar.es/~jcivera/code/1p-ransac-ekf-monoslam.html
4. 对于JC的1p RANSAC-monoSLAM有一定了解了，可以试试用SURF去实现
这里有个南理工哥们的论文还不错，可以参考 http://cdmd.cnki.com.cn/Article/CDMD-10288-1012319519.htm
三、有用的书籍
1. Multiple View Geometry in Computer Vision Second Edition ，http://www.robots.ox.ac.uk/~vgg/hzbook/
计算机视觉方面大神级别的书，也有中文版，点此下载中英文双版
2. Robotics Vision and Control ， pdf下载：http://robotics.itee.uq.edu.au/~metr4202/tpl/Robotics%20Vision%20&amp;%20Control.pdf
通过MATLAB几乎把机器人学给贯穿了，里面每章节都有对应的Code，关于里面Matlab的codes，需要留言
澳大利亚昆士兰理工大学的Peter Corke是机器视觉领域的大牛人物，他所编写的Robotics, vision and control一书更是该领域的经典教材
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a678ca9b1aa48ab53d46502543d5cd96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/72a62f8dee76024e8ffd069141fb11d3/" rel="bookmark">
			Mysql 子查询效率优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、MySQL子查询的位置 当一个查询是另一个查询的子部分是，称之为子查询（查询语句中嵌套含有查询语句）。子查询也是使用频率比较高的一种查询类型。因此，优化子查询，对于整个系统的性能也有直接的影响。
从查询出现在SQL语句的位置来看，它可以出现在目标列中，也可以出现在from子句中，还可以出现在JOIN/ON子句、GROUPBY子句、HAVING子句、ORDERBY子句等位置。下面依次来看这几种形式的子查询，以及对他们进行优化的一些想法。
1、子查询出现在目标列位置
当子查询出现在目标列位置的时候，这种查询只能是标量子查询。也就是说子查询返回的结果只能是一个元组的一个属性。否则，数据库会返回错误信息。
下面为了实验上面这段话，我们来新建一些表，并插入一些数据。
1 2 3 create table t1 (k1 int primary key , c1 int ); create table t2 (k2 int primary key , c2 int ); insert into t2 values (1, 10), (2, 2), (3,30); a、此时若我们执行如下SQL语句的结果为：
1 2 mysql&gt; select t1.c1, ( select t2.c2 from t2) from t1, t2; Empty set (0.00sec) b、然后，我们往t1表中插入一些数据：
1 2 mysql&gt; insert into t1 values (1, 1), (2, 2), (3, 3); Query OK, 3 rows affected (0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/72a62f8dee76024e8ffd069141fb11d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89e13d8b906f8a73a099bab166d7dc1b/" rel="bookmark">
			git add用法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 git add命令主要用于把我们要提交的文件的信息添加到索引库中。当我们使用git commit时，git将依据索引库中的内容来进行文件的提交。 二、基本 git add &lt;path&gt;表示 add to index only files created or modified and not those deleted 我通常是通过git add &lt;path&gt;的形式把我们&lt;path&gt;添加到索引库中，&lt;path&gt;可以是文件也可以是目录。 git不仅能判断出&lt;path&gt;中，修改（不包括已删除）的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。 三、git add -u git add -u 表示 add to index only files modified or deleted and not those created git add -u [&lt;path&gt;]: 把&lt;path&gt;中所有tracked文件中被修改过或已删除文件的信息添加到索引库。它不会处理untracted的文件。 省略&lt;path&gt;表示.,即当前目录。 四、git add -A git add -A: [&lt;path&gt;]表示把&lt;path&gt;中所有tracked文件中被修改过或已删除文件和所有untracted的文件信息添加到索引库。 省略&lt;path&gt;表示.,即当前目录。 五、git add -i 我们可以通过git add -i [&lt;path&gt;]命令查看&lt;path&gt;中被所有修改过或已删除文件但没有提交的文件， 并通过其revert子命令可以查看&lt;path&gt;中所有untracted的文件，同时进入一个子命令系统。 比如： git add -i staged unstaged path 1: +0/-0 nothing branch/t.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89e13d8b906f8a73a099bab166d7dc1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34e615e797d761c64b3b8f44513e8dbc/" rel="bookmark">
			VS监视变量窗口显示“未定义标识符”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法：右键工程-&gt;属性-&gt;C/C++-&gt;优化-&gt;“已禁用/Od”
Od就是optimization disabled...
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c086989530fa9b6c42d52ef2dd1b707/" rel="bookmark">
			c语言中int什么意思以及什么是无符号和有符号整型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		int 是整数类型，用于定义变量的类型，有符号,unsigned int 是无符号的整数类型,直白点说有符号无符号整型就是能不能存放负数。
根据程序编译器的不同，整形定义的字节数不同。51类单片机的C语言中，int代表2个byte（16位）；如果是32位ARM处理器的C语言中，则int代表4个byte(32位)。（如32位XP）把int定义为4 byte(32位)。 注意一下取值范围。若在32位系统中，signed int a, 则a范围[-2^31 , 2^31 -1] 即 [-2147483648，2147483647]。
所以一个int定义需要注意几个方面，一个是类型，一个是存储数据的大小范围。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fc058b8c61e002b7487c315d468a5f0/" rel="bookmark">
			MobiCom 2016 --- 20160930-清华东门-Cihang Liu
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://www.sigmobile.org/mobicom/2016/program.php
Lasagna: Towards Deep Hierarchical Understanding and Searching over Mobile Sensing Data
Cihang Liu (Tsinghua University) Lan Zhang (Tsinghua University) Zongqian Liu (Tsinghua University) Kebin Liu (Tsinghua University)
Xiangyang Li (University of Science and Technology of China)
Yunhao Liu (Tsinghua University)
[1-min Video]
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec2147cfce06c1de8030c660791f2f59/" rel="bookmark">
			pfx与jks互转
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package import java.io.FileInputStream; import java.io.FileOutputStream; import java.security.Key; import java.security.KeyStore; import java.security.cert.Certificate; import java.util.Enumeration; public class ConventPFX { public static final String PKCS12 = "PKCS12"; public static final String JKS = "JKS"; public static final String PFX_KEYSTORE_FILE = "e:\\dss.pfx"; public static final String PFX_KEY_PASSWORD = "12345678"; public static final String KEYSTORE_PASSWORD = "12345678"; public static final String JKS_KEYSTORE_FILE = "E:\\home\\tomcat.keystore"; public static void coverTokeyStore() { try { KeyStore inputKeyStore = KeyStore.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec2147cfce06c1de8030c660791f2f59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f57dc9b71cad077a9b7ca88546497d9a/" rel="bookmark">
			checkbox 设置复选框的只读不让用户勾选
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.（无效）首先想到使用readonly属性，但是对于复选框来说，这个属性和期望得到的效果是有差别的。原因在于readonly属性关联的是页面元素的value属性（例如textbox，设置了readonly就不能修改输入框的文本内容），而复选框的勾选/取消并不改变其value属性，改变的只是一个checked状态。所以对于checkbox来说，设置了readonly，仍然是可以勾选/取消的。
2.（可以设置不能勾选，但也不能获取、修改其数据了）和readonly类似的，还有一个disabled属性，这个属性的作用是设置页面元素为不可用，即不可进行任何交互操作（包括不可修改value属性、不可修改checked状态等）。
3.（可行）&lt;input type="checkbox" name="ced" id="ced" οnclick="return false;" checked="checked" /&gt; js: $('#ced).click(function(){return false;}); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab4cbf86f8437472113eb443992002ef/" rel="bookmark">
			QDockWidget嵌套布局详解-实现Visual Studio布局
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 许多工程软件，如Qt Creator，VS，matlab等，都是使用dock布局窗口，这样用户可以自定义界面，自由组合窗口。 Qt的嵌套布局由QDockWidget完成，用Qt Creator拖界面得到的dock布置形式比较固定，不能得想要的任意组合形式，要得到如下图所示的效果，后续布局必须通过代码来完成。 ps:这是自己没事写的一个数据可视化软件 下面说说如何实现完全自由的界面布局效果：
QDockWidget在QMainWindow的布局函数 要在QMainWindow里对dock进行布局，需要用到如下几个函数：
添加dock函数 此函数用于给dock指定位置，同时也可以更改dock的位置，此函数命名为addDockWidget有点容易误导，因为不仅仅有add的功能，还有chang的功能 &lt;code class="language-C++ hljs lasso has-numbering"&gt;&lt;span class="hljs-literal"&gt;void&lt;/span&gt; QMainWindow&lt;span class="hljs-tag"&gt;::addDockWidget&lt;/span&gt;(Qt&lt;span class="hljs-tag"&gt;::DockWidgetArea&lt;/span&gt; area, QDockWidget &lt;span class="hljs-subst"&gt;*&lt;/span&gt; dockwidget) &lt;span class="hljs-literal"&gt;void&lt;/span&gt; QMainWindow&lt;span class="hljs-tag"&gt;::addDockWidget&lt;/span&gt;(Qt&lt;span class="hljs-tag"&gt;::DockWidgetArea&lt;/span&gt; area, QDockWidget &lt;span class="hljs-subst"&gt;*&lt;/span&gt; dockwidget, Qt&lt;span class="hljs-tag"&gt;::Orientation&lt;/span&gt; orientation)&lt;/code&gt;&lt;ul class="pre-numbering" style=""&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;/ul&gt; 分割dock窗口函数 此函数的功能是把两个dock进行左右或上下并排布置，做成一个类似QSplit的功能 &lt;code class="language-C++ hljs lasso has-numbering"&gt;&lt;span class="hljs-literal"&gt;void&lt;/span&gt; QMainWindow&lt;span class="hljs-tag"&gt;::splitDockWidget&lt;/span&gt;(QDockWidget &lt;span class="hljs-subst"&gt;*&lt;/span&gt; first, QDockWidget &lt;span class="hljs-subst"&gt;*&lt;/span&gt; second, Qt&lt;span class="hljs-tag"&gt;::Orientation&lt;/span&gt; orientation)&lt;/code&gt;&lt;ul class="pre-numbering" style=""&gt;&lt;li&gt;1&lt;/li&gt;&lt;/ul&gt; tab化窗口函数 此函数的功能是把多个dock变成一个tab形式的窗体 &lt;code class="language-C++ hljs livecodeserver has-numbering"&gt;void QMainWindow::tabifyDockWidget(QDockWidget * &lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab4cbf86f8437472113eb443992002ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8709b50d121f441e4e87911435697187/" rel="bookmark">
			JavaScript之$符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript之$符号 前些天不小心用到了$符号,所以这里就来解释一下。定义： $$()这个方法是在DOM中使用过于频繁的document.getElementById()方法的一个便利的简写,就像这个DOM方法一样,这个方法返回参数传入的id的那个参数。But比起DOM中的方法,青出于蓝而胜于蓝.你可以传入多个id作为参数然后$()返回一个带有所有要求的元素的一个Array对象. prototype.js框架 http://www.cnblogs.com/thinhunan/archive/2006/04/01/DeveloperNotesForPrototype.html
解释: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"/&gt; &lt;title&gt;JackDan9 and Page&lt;/title&gt; &lt;script type="text/javascript" src="js/base.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/demo.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="box"&gt;id&lt;/div&gt; &lt;input type="radio" name="sex" value="男" checked="checked"/&gt; &lt;p&gt;Blog&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; window.onload = function () { console.log(document.getElementById('box').innerHTML); console.log(document.getElementsByName('sex')[0].value); console.log(document.getElementsByTagName('p')[0].innerHTML) }; window.onload = function () { console.log($('box').innerHTML); console.log($('sex')[0].value) }; window.onload = function () { console.log(Base.$('box').innerHTML); console.log(Base.$$('sex')[0].value); console.log(Base.$$$('p')[0].innerHTML) }; window.onload = function () { console.log(Base.getId('box').innerHTML); console.log(Base.getName('sex')[0].value); console.log(Base.getTagName('p')[0].innerHTML) }; function $(id) { return document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8709b50d121f441e4e87911435697187/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/613287995462a89fdc16c01fc1c4f6e9/" rel="bookmark">
			jquery 对后来生成的js代码的click事件无效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用的jquery版本：jquery-3.1.1
直接写在页面里面的click事件有效：
&lt;a class="deleteCls" beanId="${bean.id }" href="javascript:void(0)"&gt;删除&lt;/a&gt;
$("a.deleteCls").click(function() {
alert("del");
});
但是在js里面生成的代码：
str += "&lt;td&gt;&lt;a class='deleteCls' beanId='" + item.id + "' href='javascript:void(0)'&gt;删除&lt;/a&gt;&lt;/td&gt;";
click就失效了，查了资料说是后来生成的代码，jquery没有绑定click事件，具体是没有做深入了解，
下面是解决方法：
将$("a.deleteCls").click(function() {
alert("del");
});
修改成（tableList是table表的id，生成的代码在table标签里面）：
$("#tableList").on("click","a.deleteCls",function(){
alert("del");
});
解决了，现在生成的代码的click事件也可以响应了！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12164afb9ea9b03bf2733dddf2678cf1/" rel="bookmark">
			asp.net repeater控件使用(自定义coulmn,分页)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		效果图:
aspx文件中的布局:
&lt;asp:Button ID="Button1" runat="server" Text="添加商品" OnClick="Button1_Click" /&gt; &lt;table border="1" style="border-collapse:collapse;width:100%;" &gt; &lt;asp:Repeater ID="Repeater1" runat="server" &gt; &lt;%--标题--%&gt; &lt;HeaderTemplate&gt; &lt;tr&gt; &lt;td colspan="6"&gt;&lt;b&gt;商品列表&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr style="background:#efefef"&gt; &lt;td style="width:80px;"&gt;&lt;b&gt;ID&lt;/b&gt;&lt;/td&gt; &lt;td style="width:80px;"&gt;&lt;b&gt;编号&lt;/b&gt;&lt;/td&gt; &lt;td style="width:80px;"&gt;&lt;b&gt;名称&lt;/b&gt;&lt;/td&gt; &lt;td style="width:80px;"&gt;&lt;b&gt;条码&lt;/b&gt;&lt;/td&gt; &lt;td style="width:80px;"&gt;&lt;b&gt;价格(元)&lt;/b&gt;&lt;/td&gt; &lt;td style="width:auto;"&gt;&lt;b&gt;说明&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/HeaderTemplate&gt; &lt;%--初始化每个repeater item的样式--%&gt; &lt;ItemTemplate&gt; &lt;tr&gt; &lt;td&gt;&lt;%# Eval("ID")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%# Eval("Name")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%# Eval("SerialNumber")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%# Eval("Price")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%# Eval("Specification")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%# Eval("Directions")%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/ItemTemplate&gt; &lt;%--每隔一组ItemTemplate后 模板的样式--%&gt; &lt;AlternatingItemTemplate&gt; &lt;tr style="background:#efefef" &gt; &lt;td&gt;&lt;%# Eval("ID")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%# Eval("Name")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%# Eval("SerialNumber")%&gt;&lt;/td&gt; &lt;td&gt;&lt;%# Eval("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12164afb9ea9b03bf2733dddf2678cf1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71e6874fdb784b9bf08b142c9cfee0d8/" rel="bookmark">
			用户空间的虚拟地址如何转换得到实际的物理地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		思路：
进程号是一个进程在用户空间的唯一标示，所以，根据pid可以从内核中得到一个进程的所有信息，
另外就是知道虚拟地址就可以通过内核物理地址映射到虚拟地址的逆运算就可以还原他的实际物理地址
以上便是虚拟地址转换成所对应的实际物理地址的思路。
大致的代码编写流程：
首先根据pid我们可以得到这个进程的task_struct，进而通过task_struct得到mm,通过mm得到pgd。 好了，现在我们有pgd和virtualaddress. 通过pgd和virtualaddress我们可以得到页表pte. 有了pte和virtualaddress,我们就可以计算物理地址了 phyaddress=(pte_val(pte)&amp;PAGE_MASK)|(virtualladdress&amp;~PAGE_MASK) 代码：
#include &lt;linux/sched.h&gt; #include &lt;linux/mm.h&gt; #include &lt;asm/pgtable.h&gt; #include &lt;asm/page.h&gt; static int v2p(int pid, unsigned long va) { unsigned long pa = 0; struct task_struct *pcb_tmp; pgd_t *pgd_tmp = NULL; pud_t *pud_tmp = NULL; pmd_t *pmd_tmp = NULL; pte_t *pte_tmp = NULL; printk(KERN_INFO"PAGE_OFFSET = 0x%lx\n",PAGE_OFFSET); printk(KERN_INFO"PGDIR_SHIFT = %d\n",PGDIR_SHIFT); printk(KERN_INFO"PUD_SHIFT = %d\n",PUD_SHIFT); printk(KERN_INFO"PMD_SHIFT = %d\n",PMD_SHIFT); printk(KERN_INFO"PAGE_SHIFT = %d\n",PAGE_SHIFT); printk(KERN_INFO"PTRS_PER_PGD = %d\n",PTRS_PER_PGD); printk(KERN_INFO"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71e6874fdb784b9bf08b142c9cfee0d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9aa6f72695344f13e36edd3248faef08/" rel="bookmark">
			RecyclerView使用static和不使用static的Viewholder内存消耗相差无几
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RecyclerView的onViewRecycled可以看到被回收的VIewHolder
RecyclerView实现接口RecyclerListener的onViewRecycled方法。
@Override public void onViewRecycled(ViewHolder holder) { } 可以看到，每一个被回收的ViewHolder都能在这里得到，那我们可以通过查看ViewHolder的内存地址来判断RecyclerView的回收。 首先使用不带static的Viewholder
class ViewHolder extends RecyclerView.ViewHolder 然后在ViewHolder里面写200个数据来看ViewHolder的回收。 在onViewRecycled方法中写一个Log.i("view","testtest="+holder);打印holder的内存地址。
这是第一个打印的地址：
testtest=ViewHolder{4a816788 position=0 id=-1, oldPos=-1, pLpos:-1 no parent}
可以看到内存地址为4a816788；
如果内存地址相同则为同一个对象
内存地址：
testtest=ViewHolder{4a816788 position=0 id=-1, oldPos=-1, pLpos:-1 no parent}
testtest=ViewHolder{4a829d58 position=1 id=-1, oldPos=-1, pLpos:-1 no parent}
testtest=ViewHolder{4a82c2fc position=2 id=-1, oldPos=-1, pLpos:-1 no parent}
testtest=ViewHolder{4a82e2b0 position=3 id=-1, oldPos=-1, pLpos:-1 no parent}
testtest=ViewHolder{4a81945c position=4 id=-1, oldPos=-1, pLpos:-1 no parent}
testtest=ViewHolder{4a82f5ac position=5 id=-1, oldPos=-1, pLpos:-1 no parent}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9aa6f72695344f13e36edd3248faef08/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/927f42ed31600fcf77500f5f73132349/" rel="bookmark">
			二叉树中的度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		度：二叉树中连接节点与节点的线就是度。有n个节点，就有n-1个度，节点数总是比度要多一个。结点所拥有的子树的个数成为该结点的度。
度为0的结点称为叶结点，度不为0的结点称为分支结点。
一棵树的结点除了叶结点外，其余的结点都是分支结点。
树的根结点的层数为1。
树的度：树中各结点度的最大值称为该树的度。
满二叉树：所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层。
度为0的节点数为度为2的节点数加1，即n0 = n2+1
推理方法如下：
k：总度数
k+1 总节点数
n0：度为0的节点
n1：度为1的节点
n2: 度为2的节点
根据度和节点的关系可得：
k = 2*n2 + n1；
k+1 = n0 + n1 + n2；
则得：n0 = n2 + 1；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81712925d5d3433b98901be60cf2eded/" rel="bookmark">
			Go语言实现抓图实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Go语言实现网页抓图功能。
package main import ( "bytes" "fmt" "io/ioutil" "net/http" "os" "regexp" "strconv" ) const ( PATH string = "~/meizi" //文件存储路径 STARTURL string = "http://www.mzitu.com/model" //妹子图模块列表页url CONCURRENCY int = 3 //并发下载数 ) var ( c1 chan string //通道：负责STARTURL,以后可以做成从命令参数里读取哦 c2 chan string //通道: 负责传输所有的模块url c3 chan []string //通道：负责传输imgUrl c4 chan int //通道: 负责传输每张图片的下载完成状态 c5 chan int //通道：负责传输当前下载数 ) func init() { c1 = make(chan string, 1) c2 = make(chan string, 100) c3 = make(chan []string, 1000) c4 = make(chan int, 3) c5 = make(chan int, 10) go CgetList() go Cdownload() } func main() { c1 &lt;- STARTURL go CgetModel() num := 0 for count := range c5 { num = num + count fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81712925d5d3433b98901be60cf2eded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a406eefdb13938d60c6ff2cfdcd012a/" rel="bookmark">
			智能寻迹小车的代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		/*------------------------------------------------------
-----------------------小车运行主程序-------------------
--------------------------------------------------------
简介：@模块组成：红外对管检测模块----五组对管，五个信号采集端口
直流电机驱动模块----驱动两个直流电机，另一个轮子用万向轮
单片机最小系统------用于烧写程序，控制智能小车运动
@功能简介：在白色地面或皮质上用黑色胶带粘贴出路线路径宽度微大于相邻检测管间距。
这样小车便可在其上循迹运行。
@补充说明：该程序采取“右优先”的原则：
即右边有黑线向右转，
若无，前方有黑线，向前走，
若无，左边有黑线，向左转，
若全无，从右方向后转。
程序开头定义的变量的取值是根据我的小车所调试选择好的，
如果采用本程序，请自行调试适合自己小车的合适参数值。
编者：陈尧，黄永刚（江苏大学电气学院二年级，三年级）
1.假定:IN1=1,IN3=1时电机正向转动,必须保证本条件
2.假定:遇到白线输出0，遇到黑线输出1;
如果实际电路是：遇到白线输出1，遇到黑线输出0，
这种情况下只需要将第四，第五句改成：
#define m0 1
#define m1 0
即可。
3.说明1：直行---------------速度full_speed_left,full_speed_right.
转弯,调头速度------correct_speed_left,correct_speed_right.
微小校正时---------高速轮full_speed_left,full_speed_right;
低速轮correct_speed. 可以通过调节第六，七，八，九，十条程序，改变各个状态
下的占空比（Duty cycle ）,以求达到合适的转弯，直行速度
4.lenth----------length检测到黑线到启动转动的时间间隔
5.width----------mid3在黑线上到脱离黑线的时间差
6.mid3-----------作为判断中心位置是否进入黑线的标志，由于运行的粗糙性和惯性，
常取其他对管的输出信号作为判断条件
7.check_right----若先检测到左边黑线，并且左边已出黑线，判断右端是否压黑线时间拖延
--------------------------------------------------------
--------------------------------------------------------*/
#include&lt;reg52.h&gt;
#define uchar unsigned char
#define uint unsigned int
#define m0 1//黑线m1,白线m0
#define m1 0
#define full_speed_left 40 //方便调节各个状态的占空比 ,可用参数组：（30,35,6,25,30,68000,27000,500）；
#define full_speed_right 45 // （40,45,6,25,30,68000,27000,500）；
#define correct_speed 6 //校正时的低速轮的占空比
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a406eefdb13938d60c6ff2cfdcd012a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/467fd107029151b57e1910fd76943f1c/" rel="bookmark">
			GoLang 获取两个时间相差多少小时
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 代码如下
如果调用 time .parse() 这个玩意相差 8小时。默认时区是utc package main import ( "fmt" "time" ) func main() { fmt.Println(getHourDiffer("2016-09-10 13:00:00", "2016-09-10 14:50:00")) } //获取相差时间 func getHourDiffer(start_time, end_time string) int64 { var hour int64 t1, err := time.ParseInLocation("2006-01-02 15:04:05", start_time, time.Local) t2, err := time.ParseInLocation("2006-01-02 15:04:05", end_time, time.Local) if err == nil &amp;&amp; t1.Before(t2) { diff := t2.Unix() - t1.Unix() // hour = diff / 3600 return hour } else { return hour } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/56f396c69412720ccea6d4a6bc6fd83b/" rel="bookmark">
			IDEA中自动生成get/set的方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在编辑框中右击，选择generator，可以拖选住你想要生成get、set方法的属性，点击完成即可自动生成get和set方法。
快捷键为：alt+insert
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/483/">«</a>
	<span class="pagination__item pagination__item--current">484/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/485/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>