<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9eef94cff7a0dd1375ed4d4ed6aa9f3/" rel="bookmark">
			在Linux中进行OpenSSH升级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于OpenSSH有严重漏洞，因此需要升级OpenSSH到最新版本。
OpenSSL和OpenSSH都要更新，OpenSSH依赖于OpenSSL。
第一步，查看当前的OpenSSH服务版本。
命令：ssh -V
第二步，安装、启动telnet，关闭安全文件，防止因卸载OpenSSH而导致无法登录主机。
# 安装、启动telnet
命令：yum -y install telnet
yum -y install telnet-server
systemctl enable telnet.socket
systemctl start telnet.socket
# 关闭安全文件
命令：mv /etc/security /etc/security.bak
第三步，安装升级OpenSSH需要的依赖包。
命令：yum -y install gcc keyutils-libs rpm-build krb5-devel libcom_err-devel libselinux-devel pam-* openssl-devel pkgconfig vsftpd zlib*
第四步，备份原有的SSH服务版本。
命令：mv /etc/ssh /etc/ssh.bak
mv /usr/bin/ssh /usr/bin/ssh.bak
mv /usr/sbin/sshd /usr/sbin/sshd.bak
第五步，下载OpenSSH。
登录网址：OpenSSH: Release Notes下载最新版本OpenSSH安装包，即openssh-9.7p1.tar.gz，然后使用WinSCP将安装包上传到/opt文件夹中。
第六步，卸载OpenSSH的rpm安装包。
命令：rpm -qa | grep openssl
rpm -qa | grep openssh
# 普通删除模式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9eef94cff7a0dd1375ed4d4ed6aa9f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e6bbe7e2ecc32579857c09d2cd8fa19/" rel="bookmark">
			社区居民医疗健康系统 微信小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设计原则
本社区健康医疗APP采用 Hbuildex技术，使用Java语言开发，充分保证了系统稳定性、完整性。 社区健康医疗APP的设计与实现的设计思想如下： （1）操作简单方便、系统界面安全良好、简单明了的页面布局、方便查询相关内容。
（2）即时可见：对社区健康医疗APP信息的处理将立马在对应地点可以查询到，从而实现“即时发布、即时见效”的系统功能。 前端开发框架:vue.js
框架支持:django/springboot/php/Ssm/flask/express均支持
语言：python+java+node.js+php均支持
数据库 mysql 版本不限
数据库工具：Navicat/SQLyog等都可以
运行软件:idea/eclipse/vscode/pycharm/wamp均支持
小程序Android端运行软件 微信开发者工具/hbuiderx
uni-app框架：使用Vue.js开发跨平台应用的前端框架，编写一套代码，可编译到Android、小程序等平台。1、关于社区健康医疗APP的基本要求
（1）主要功能科室管理、医生管理、医生预约、新冠接种、行程申报等功能模块。
（2）性能：在不同操作系统上均能无差错实现在不同类型的用户登入相应界面后能不出差错、方便地进行预期操作。
（3）安全与保密要求：用户都必须通过注册、登录才能进入系统。
（4）环境要求：支持Windows系列、Vista系统等多种操作系统使用。
2、开发目标
社区健康医疗APP的主要开发目标如下：
（1）实现管理系统信息关系的系统化、规范化和自动化；
（2）减少维护人员的工作量以及实现用户对信息的控制和管理；
（3）方便查询信息及管理信息等；
（4）通过网络操作，提高改善处理问题和操作人员工作的效率；
（5）考虑到用户多样性特点，要求界面和操作简便易懂。
3、
目 录
摘 要 I
ABSTRACT 1
目 录 1
第1章 绪论 1
1.1选题背景 2
1.2研究现状及发展趋势 3
1.3课题的研究意义 6
1.4研究内容 6
第2章 相关技术 7
2.1 java简介 7
2.2 Mysql数据库 7
2.3 HBuilder X的基本介绍 9
2.4 SpringBoot框架 9
第3章 系统分析 11
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e6bbe7e2ecc32579857c09d2cd8fa19/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d654c84bea2d65c16997bb12c61b18/" rel="bookmark">
			C&#43;&#43; Variable Types
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在C语言中，每一个变量都有两个属性：数据类型和存储类型。
数据类型即常说的字符型、整型、浮点型；存储类型则指变量在内存中的存储方式，它决定了变量的作用域和生存期。 变量的数据类型（Fundamental Type） 学了C然后C++，然后 Windows/MFC，然后是C#，其中数据类型很多，由基本类型衍生的typedef类型也N多。
熟知基本数据类型是我们正确表达实际问题中各种数据的前提，因此我分类总结了一下 C/C++/Windows /C# 基本数据类型，以便日后查阅。
参考 GNU 的 Data Type Measurements 和 MSDN 的 Fundamental Types (C++) &amp; Data Type Ranges &amp; C++ Type System (Modern C++) 相关文档。
C/C++ 基本数据类型 Type
Size
值域（limit）
无值型void
0 byte
无值域
布尔型bool
1 byte
true/false
有符号短整型 short [int] /signed short [int]
2 byte（__SIZEOF_SHORT__）
[SHRT_MIN,SHRT_MAX]
无符号短整型 unsigned short [int]
2 byte
[0,USHRT_MAX]
有符号整型 int /signed [int]
4 byte（__SIZEOF_INT__）
[INT_MIN,INT_MAX]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d654c84bea2d65c16997bb12c61b18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b279cfdfcb63bcdd73c459d573be236/" rel="bookmark">
			dhizuku@设备拥有者权限@android设备管理员权限@android替换默认软件安装器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 DhizukushizukuDhizuku设备权限相关资源和教程激活过程资源下载和查看 利用Dhizuku设备管理员权限授权第三方安装器NoteFAQ Dhizuku 在Android操作系统中，设备拥有者权限（Device Owner）和ROOT权限是两种不同的权限类型，它们各自有不同的应用场景和限制。(非root权限下的最高权限,仅次于root权限;尽管设备拥有者权限听起来和强大,但是仍然无法和root权限相提并论,但我们可以用它来做一些事情)设备拥有者权限: Android系统中的一个特殊权限，通常用于企业或教育环境中的设备管理。当一个应用被设置为设备拥有者时，它将获得对设备的广泛控制权，包括：配置和锁定屏幕：设备拥有者可以设置锁屏密码、安装应用、设置网络等。管理应用：设备拥有者可以决定哪些应用可以安装在设备上，也可以远程卸载应用。数据安全：设备拥有者可以设置数据加密、远程擦除数据等安全措施。
设备拥有者权限的主要优点是它提供了一种在不获取ROOT权限的情况下管理设备的方法。这对于需要严格控制设备使用情况的企业或教育机构来说非常有用。然而，设备拥有者权限通常只能在特定的Android版本和设备上设置，且设置过程较为复杂。 ROOT权限： ROOT权限是指完全控制Android设备的最高权限。获取ROOT权限后，用户可以访问和修改系统的任何部分，包括安装定制ROM、删除系统应用、访问受保护的系统文件等。
ROOT权限的主要优势是提供了最大程度的自由和控制权，允许用户进行深度定制和优化。然而，获取ROOT权限也存在一些风险和缺点：安全风险：ROOT权限可能使设备更容易受到恶意软件和病毒的攻击。稳定性问题：修改系统文件可能会导致系统不稳定甚至崩溃。保修问题：获取ROOT权限通常会违反设备的保修条款。
总结来说，设备拥有者权限和ROOT权限各有优势和限制。设备拥有者权限适用于需要集中管理设备的环境，而ROOT权限则适用于需要完全控制设备的用户。然而，无论是设备拥有者权限还是ROOT权限，都需要谨慎使用，以避免潜在的风险和问题。 shizuku Shizuku 是一款用于安卓设备的高级权限管理工具，它允许应用直接使用 ADB（Android Debug Bridge）权限，从而进行一些需要更高权限的操作。这个软件特别适用于那些没有解锁 Bootloader 或获取 ROOT 权限的安卓设备。Shizuku 提供了一种无需 ROOT 权限即可进行系统级操作的解决方案。
Shizuku 的工作原理是，在电脑上给 Shizuku 服务进程授予 ADB 权限后，它可以成为一个 ADB 权限管理器。通过这个管理器，Shizuku 可以给那些需要 ADB 权限来实现某些功能的应用进行授权。例如，可以用来冻结应用、管理后台进程、限制应用权限等。Shizuku 的优点在于，它简化了授权过程，省去了使用命令行的麻烦，并且避免了不同应用激活时需要多次授权的问题。
Shizuku 支持多种启动方式，包括通过 ROOT 启动、通过无线调试启动（适用于 Android 11 或以上版本），以及通过连接电脑启动（适用于未 ROOT 且运行 Android 10 及以下版本的设备）。通过无线调试启动的方式不需要连接电脑，但每次重启后都需要重新进行启动步骤。而通过连接电脑启动的方式则需要使用数据线将手机连接到电脑，并按照一系列步骤来激活 Shizuku。
Shizuku 的使用相对简单，对于已经支持 Shizuku 的软件，通常可以在软件中直接切换到 Shizuku 工作模式。目前支持 Shizuku 的软件包括各类系统优化工具、应用管理器、权限管理工具等。
Dhizuku 参考Shizuku的设计思想，分享 DeviceOwner (设备所有者) 权限给其余应用相对于shizuku是新出的权限类软件(api) 设备权限 设备所有者 (Device Owner) 相关资源和教程 这部分资源是Dhizuku仓库发布和产生的 如何激活Dhizuku · iamr0s/Dhizuku · Discussion #16 · GitHubGitHub - iamr0s/Dhizuku: A Android Application for share DeviceOwner 考虑到有些用户可能无法打开相关网页,可以到论坛里(酷安这类的论坛里)找帖子我这里记录一些操作过程中遇到的一些问题以及配置成功后将Dhizuku应用在哪里 激活过程 激活Dhizuku的大致步骤是
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b279cfdfcb63bcdd73c459d573be236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6e859f72dd5b07b1a457962fbb7ec54/" rel="bookmark">
			html--bug
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 html html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;老师&lt;/title&gt; &lt;style&gt; body { background-color: #008000; margin: 0px; cursor: none; overflow: hidden; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var imageWidthHalf, imageHeightHalf; var canvas = document.createElement('canvas'); canvas.width = window.innerWidth; canvas.height = window.innerHeight; canvas.style.display = 'block'; document.body.appendChild(canvas); var context = canvas.getContext('2d'); var image = document.createElement('img'); image.addEventListener('load', function () { imageWidthHalf = Math.floor(this.width / 2); imageHeightHalf = Math.floor(this.height / 2); document.addEventListener('mousemove', onMouseEvent, false); document.addEventListener('touchstart', onTouchEvent, false); document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a6e859f72dd5b07b1a457962fbb7ec54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7da70d814f6422e2680743ef13bc8c0/" rel="bookmark">
			解释multi_update_all函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import dgl import dgl.function as fn import torch # 实例化一个异构图 g = dgl.heterograph({ ('user', 'follows', 'user'): ([0, 1], [1, 1]), ('game', 'attracts', 'user'): ([0], [1]) }) g.nodes['user'].data['h'] = torch.tensor([[1.], [2.]]) g.nodes['game'].data['h'] = torch.tensor([[1.]]) # 更新所有节点 g.multi_update_all( {'follows': (fn.copy_u('h', 'm'), fn.sum('m', 'h')), 'attracts': (fn.copy_u('h', 'm'), fn.sum('m', 'h'))}, "sum") print(g.nodes['user'].data['h']) # 输出: tensor([[0.], [4.]]) # 用户定义的跨类型归约函数，等效于"sum" def cross_sum(flist): return torch.sum(torch.stack(flist, dim=0), dim=0) if len(flist) &gt; 1 else flist[0] # 使用用户定义的跨类型归约函数 g.multi_update_all( {'follows': (fn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7da70d814f6422e2680743ef13bc8c0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60ec868027868c8724e69036ff47e77d/" rel="bookmark">
			Java中的LinkedBlockingQueue：原理、应用与性能深入剖析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 心中有诗画，指尖舞代码，目光览世界，步履越千山，人间尽值得 ! 在当今这个多线程、高并发的时代，Java的并发编程显得尤为重要。而当我们提及Java的并发编程，不可不提的一个关键组件就是BlockingQueue接口及其实现类。其中，LinkedBlockingQueue作为BlockingQueue的一个经典实现，更是被广泛应用在各种场景中。
LinkedBlockingQueue，如其名，是一个基于链接节点的、线程安全的队列。它不仅可以作为生产者-消费者模式中的核心组件，帮助我们在多线程环境下安全地传递数据，还可以利用其阻塞特性，有效地协调生产和消费的速度，使得系统更为稳定、高效。
但LinkedBlockingQueue背后的原理、应用场景以及性能特性，你是否真正了解呢？
目录 一、引言二、LinkedBlockingQueue概述三、关键特性四、内部工作原理五、使用场景六、最佳实践6.1. 合理设置容量6.2. 避免在迭代过程中修改队列结构6.3.注意线程安全6.4. 考虑使用其他队列实现 七、LinkedBlockingQueue模拟生产者-消费者场景总结 一、引言 在Java的并发编程领域，LinkedBlockingQueue是一个非常重要的类，它提供了一种高效且线程安全的方式来处理队列中的元素。该类位于java.util.concurrent包中，是BlockingQueue接口的一个实现，专门设计用于处理多线程环境中的生产者-消费者问题。在本篇博客中，我们将深入探讨LinkedBlockingQueue的内部工作原理、关键特性以及最佳实践。
二、LinkedBlockingQueue概述 LinkedBlockingQueue是一个基于链表实现的阻塞队列。它使用高效的非阻塞算法进行内部的入队和出队操作，同时在队列为空时，获取元素的线程将会被阻塞，直到有元素可用；同样地，当队列已满时，尝试添加元素的线程也会被阻塞，直到队列中有空闲空间。
三、关键特性 容量可选：LinkedBlockingQueue可以在创建时指定一个最大容量。这个容量限制了队列中可以存储的元素数量。如果未指定容量，则默认使用Integer.MAX_VALUE作为容量，这实际上创建了一个几乎无界的队列（但仍受内存限制）。
线程安全：LinkedBlockingQueue是线程安全的，它内部使用了锁和条件变量来确保并发访问时的数据一致性。多个线程可以同时向队列中添加或移除元素，而不会产生竞态条件。
阻塞操作：当队列为空时，调用take()方法的线程会被阻塞，直到队列中有元素可用。类似地，当队列已满时，调用put()方法的线程会被阻塞，直到队列中有空闲空间。这种阻塞行为使得生产者-消费者模型中的线程能够高效地协作。
高效的并发性能：由于LinkedBlockingQueue基于链表实现，它在高并发环境下表现出色。链表结构使得元素的插入和删除操作可以在常数时间内完成，而不需要移动其他元素。
支持迭代：LinkedBlockingQueue实现了Iterable接口，因此可以使用for-each循环来遍历队列中的元素。但需要注意的是，迭代器并不保证元素的顺序，并且在迭代过程中如果修改了队列的结构（如添加或删除元素），可能会导致ConcurrentModificationException异常。
四、内部工作原理 LinkedBlockingQueue内部使用了一个基于链表的数据结构来存储元素。这个链表由一系列的节点组成，每个节点都包含了一个元素以及指向下一个节点的引用。队列的头部和尾部都维护了对这些节点的引用，以便进行高效的入队和出队操作。
在内部实现中，LinkedBlockingQueue使用了两个锁来分别保护队列的头部和尾部。这种分离锁的设计可以减少线程之间的竞争，从而提高并发性能。
当一个线程尝试从队列头部获取元素时，它只需要获取头部锁；同样地，当一个线程尝试向队列尾部添加元素时，它只需要获取尾部锁。这种细粒度的锁策略允许更高的并发性。
五、使用场景 生产者-消费者模式：LinkedBlockingQueue非常适合用于实现生产者-消费者模式。生产者线程可以将生产的数据放入队列中，而消费者线程可以从队列中取出数据进行处理。队列起到了缓冲和解耦的作用，使得生产者和消费者可以独立地运行在不同的线程中。
任务调度：在并发编程中，经常需要将任务提交给线程池进行处理。LinkedBlockingQueue可以用作任务队列，将待处理的任务存储在其中。线程池中的线程可以从队列中取出任务并执行它们。这种方式可以平滑地处理任务的提交和执行过程。
数据流处理：在数据流处理系统中，数据项通常从一个阶段流向另一个阶段进行处理。LinkedBlockingQueue可以用作这些阶段之间的连接点，确保数据项在阶段之间安全、有序地传递。每个阶段都可以独立地运行在不同的线程中，提高了系统的并发性能。
六、最佳实践 6.1. 合理设置容量 在使用LinkedBlockingQueue时，应根据实际需求合理设置队列的容量。过小的容量可能导致生产者线程频繁地被阻塞，而过大的容量可能浪费内存资源。通常情况下，可以根据系统的负载和响应时间等指标来调整队列的容量。
6.2. 避免在迭代过程中修改队列结构 虽然LinkedBlockingQueue支持迭代操作，但在迭代过程中修改队列的结构可能会导致不可预料的结果或异常。因此，在迭代过程中应尽量避免添加或删除元素。如果需要修改队列结构，可以考虑使用额外的数据结构来辅助操作。
6.3.注意线程安全 尽管LinkedBlockingQueue本身是线程安全的，但在使用它时仍需要注意线程安全的问题。例如，在将对象放入队列之前，应确保该对象的状态是正确且一致的；在从队列中取出对象后，应正确地处理该对象的状态变化。此外，还需要注意避免死锁和活锁等并发问题。
6.4. 考虑使用其他队列实现 虽然LinkedBlockingQueue在许多场景下都表现出色，但在某些特定场景下，其他队列实现可能更适合。例如，如果需要一个具有优先级功能的队列，可以考虑使用PriorityBlockingQueue；如果需要一个无界且线程安全的队列，可以考虑使用ConcurrentLinkedQueue。因此，在选择队列实现时，应根据具体需求进行评估和选择。
七、LinkedBlockingQueue模拟生产者-消费者场景 下面代码使用LinkedBlockingQueue模拟了一个生产者-消费者场景，其中生产者生成数据并将其放入队列，而消费者从队列中取出数据进行处理。代码中我们还将引入一些额外的逻辑，比如生产者的生产速度和消费者的消费速度是可配置的，以及当队列满或空时线程将适当地阻塞。
import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.TimeUnit; public class ProducerConsumerExample { // 定义产品类 static class Product { private final int id; public Product(int id) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60ec868027868c8724e69036ff47e77d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f115509df7b7a5c7cbef3fe137772937/" rel="bookmark">
			0基础学习VR全景平台篇第145篇：图层控件功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，欢迎观看蛙色VR官方——后台使用系列课程！这期，我们将为大家介绍如何使用图层控件功能。
一.如何使用图层控件功能？
进入作品编辑页面，点击左边的控件后就可以在右边进行相应设置。
二.图层控件有哪些功能？
（1）图层控件设计
1.标题与图片：如果不设置标题和图片则无法成功添加图层控件；
2.显示设置：可以选择只在桌面端或移动端显示，也可以选择同时显示，
控件的默认状态可以选择显示或者隐藏，可以设置显示控件时是否关闭背景音乐和背景解说，开启背景蒙版后就是为场景添加一层带颜色的遮罩层。
3.UI布局：控件的大小可以选择自适应大小或者固定大小，自适应大小是按照屏占比来控制控件大小的，而固定大小则是按像素控制控件大小，两种都可以自定义设置控件大小，
锁定状态下时，修改宽、高任意一边，另一边会自动缩放显示，
控件除了可以自由拖动外，点击也可以轻松设置控件位置，
位置偏移设置后，会以当前控件位置为起点向四周移动，设置偏移为负数时会向反方向移动。
注意：桌面端和移动端是两个UI布局，可以单独设置控件位置和大小。
（2）图层控件动画设置
1.动画类型：可以为控件选择相应动画，设置后控件会有对应动画效果，
2.动画效果：可以设置动画的时长，还可以选择循环播放或者按固定次数进行播放。
（3）图层控件交互设置
1.接入功能：这里的接入功能和热点一样，可以接入漫游，音图文，视频等热点，点击控件则可触发交互；
2.控件功能：控件功能可以控制其他控件的显示和隐藏，
添加目标控件后，可以设置点击原始控件多长时间后显示或者隐藏目标控件。
（4）控件列表设置
锁定：锁定相应控件后控件则无法自由移动变换位置；
隐藏：选择隐藏后相应控件会被隐藏，不会显示；
删除：点击后会删除相应控件；
控件列表的顺序可通过拖动进行自由排序。
批量操作：点击右上角即可进行批量操作，可以对多个控件进行锁定，解锁，隐藏，显示，删除等操作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce08101f4ed91cbc12c86d25538d11eb/" rel="bookmark">
			从零开始搭建医保购药APP：技术选择与开发流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		医保购药APP作为一种创新的医疗服务工具，为用户提供了便捷的医保购药流程，同时也为医疗机构提供了更高效的管理和服务方式。今天小编将为大家讲解如何从零开始搭建一款医保购药APP，包括技术选择和开发流程。
一、技术选择
在搭建医保购药APP时，首先需要选择合适的技术栈。以下是一些常用的技术选择：
1.移动开发框架：针对Android和iOS平台，可以选择ReactNative、Flutter或者原生开发（Java/KotlinforAndroid，SwiftforiOS）。ReactNative和Flutter具有跨平台开发的优势，可以同时在Android和iOS平台上开发应用，而原生开发可以更好地利用平台特性和性能。
2.后端开发：考虑到医疗领域对数据安全和可靠性的要求，可以选择成熟稳定的框架，并配合合适的数据库（如MySQL、MongoDB）进行数据管理。
3.数据存储与管理：医保购药APP需要管理大量的用户和药品数据，因此需要选择适合的数据库技术。关系型数据库（如MySQL、PostgreSQL）适用于结构化数据的存储和管理，而NoSQL数据库（如MongoDB）适用于非结构化或半结构化数据的存储。
二、开发流程
搭建医保购药APP的开发流程包括需求分析、原型设计、开发、测试和发布等阶段：
1.需求分析：制定详细的功能列表和开发计划，明确每个功能的优先级和实现方式。
2.原型设计：在开始开发之前，可以使用原型设计工具设计应用界面和交互流程。通过原型设计，可以更直观地展示应用的功能和用户体验，同时与团队和用户进行进一步的讨论和反馈。
3.开发：根据需求和设计，开始开发医保购药APP的前端和后端。前端开发主要负责用户界面和交互逻辑的实现，后端开发主要负责业务逻辑和数据管理的实现。在开发过程中，可以采用敏捷开发或迭代开发的方式，不断优化和完善应用功能。
4.测试：开发完成后，需要进行功能测试、性能测试和安全测试等，确保应用稳定可靠、符合用户需求和法律法规要求。同时，可以邀请内部测试用户或外部测试团队进行测试，并收集反馈意见进行修复和优化。
5.发布：经过测试验证后，可以将医保购药APP发布到应用商店（如AppStore），供用户下载和使用。在发布过程中，需要提供详细的应用描述、隐私政策和用户协议，以及定期更新和维护应用版本。
总结：
通过以上技术选择和开发流程，我们可以从零开始搭建一款医保购药APP，为用户提供便捷的医疗服务体验，同时为医疗机构提供更高效的管理和服务方式。在开发过程中，需要注重用户需求和体验，同时兼顾数据安全和隐私保护，以确保应用的质量和可靠性。希望本文能够为医疗应用开发者提供一些参考和指导，共同推动医疗健康科技的发展和进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3072b1048bf9a1a614d3ac3037f94ae6/" rel="bookmark">
			uniapp微信小程序_拍照从相册选择
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		userImg() { let that = this uni.chooseMedia({ count: 1, mediaType: ['image', 'video'], sourceType: ['album', 'camera'], maxDuration: 30, camera: 'back', success(res) { console.log(res.tempFiles[0].tempFilePath) that.imagUrl = res.tempFiles[0].tempFilePath } }) }, 直接调用api即可,注意的是要把值赋给你需要的,this指向需要注意一下
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/237c87699d791fabb954333f027f085c/" rel="bookmark">
			【ES6】let与const
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
let命令
作用域 无变量提升 不允许重复声明
暂时性死区
块级作用域 函数能否在块级作用域中声明 const命令
let命令 作用域 ES6 新增了let命令，用来声明变量。它的用法类似于var，但是作用域不同，let命令只在所在的代码块内有效。举个例子：
{ let a = 10 var b = 1 } console.log(a)//ReferenceError: a is not defined. console.log(b)//1 上面代码在代码块之中，分别用let和var声明了两个变量a和b。在代码块之外调用这两个变量，结果变量a报错，变量b返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。
所以for循环就很适合用let，而且for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。例：
for (let i = 0; i &lt; 3; i++) { let i = 'abc'; console.log(i); } // abc // abc // abc 上面代码正确运行，并且输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域（同一个作用域不可使用 let 重复声明同一个变量）。
无变量提升 var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。
而let所声明的变量一定要在声明后使用，否则报错。 例：
console.log(foo); // 输出undefined var foo = 2; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/237c87699d791fabb954333f027f085c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ea40acd51eb83ff3d31d381d9c40270/" rel="bookmark">
			动态规划法解最长公共子序列问题(附带dp数组打印)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		import java.util.Arrays; public class LCS2 { private void printDp(int[][] dp){ for(int i = 0; i &lt; dp.length; i++){ System.out.println(Arrays.toString(dp[i])); } System.out.println("--------------------------------"); } public int lcs(char[] arr1, char[] arr2, int m, int n){ int[][] dp = new int[m+1][n+1]; for(int i = 0; i &lt;= m; i++){ for(int j = 0; j &lt;= n; j++){ if(i == 0 || j == 0){ dp[i][j] = 0; } else if(arr1[i-1] == arr2[j-1]){ dp[i][j] = dp[i-1][j-1] + 1; } else{ dp[i][j] = Math.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ea40acd51eb83ff3d31d381d9c40270/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b50f8548b8ec1760f66184d8d69017c/" rel="bookmark">
			我们是否生活在一个超大型生物的大脑之中？——对多元宇宙观与生命存在形式的哲学探讨
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着科技和哲学思辨的深入，关于人类所处宇宙的本质及我们自身存在的真实性的讨论越发引人入胜。其中一种颇具科幻色彩的观点认为，我们可能生活在某个巨大生物的大脑之中，所有的物理规律、自然现象以及我们的感知体验，都可能是这个生物意识活动的表现。本文将围绕这一观点展开深入的讨论。
首先，这种观点受到多重理论的启发。在量子力学中，观察者效应揭示了观测行为对微观世界状态的影响，使得一些学者提出“全息宇宙”或“模拟宇宙”的假说，即我们所处的世界可能是一个高度复杂的虚拟现实，由某种高级文明或者超级智能体创建并操控。而这种超级智能体，某种程度上可以类比为一个具有无比强大思维能力的生物大脑。
其次，从认知科学的角度出发，人类对世界的理解和感知皆基于大脑神经元网络的信息处理过程。如果我们接受这种逻辑，那么理论上存在一个规模远超过人类大脑的生物神经系统，其内部生成的复杂信息流完全能够模拟出一个完整且看似真实的宇宙。
然而，这一假设目前尚缺乏实证支持。科学方法强调可验证性和可重复性，对于“生活在生物大脑中”的观点，既无法通过现有实验手段进行验证，也无法提供有力的间接证据。同时，该观点也面临诸多逻辑难题，如：如果我们的宇宙是生物大脑的产物，那么这个生物本身又存在于哪个更大的现实框架之中？这似乎陷入了一种无限递归的困境。
尽管“生活在生物大脑中”的观念富有想象力，能引发人们对自我认知、生命本质和宇宙奥秘的深刻思考，但作为科学理论，它还停留在纯粹的猜想阶段，未被主流科学界接纳。然而，这也并不妨碍我们在哲学层面对其进行探索，因为它挑战了我们对现实的理解，并鼓励我们继续追问那些有关存在、意识与宇宙终极真相的根本问题。
总结来说，我们或许并不生活在某个生物的大脑之中，但这样的探讨无疑拓宽了我们对生命可能性的认知边界，促使我们以更为开放和包容的心态去面对未知的宇宙与生命的多元形态。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4843fb8f927c16b08a27a759564cbfd6/" rel="bookmark">
			JavaScript中DOM增删改查:
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 DOM增删改1: &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="style/css.css" /&gt; &lt;script&gt; /* 参数： id 要绑定单击事件的按钮的id callback 事件的响应函数 */ function myClick(id, callback){ var btn = document.getElementById(id); btn.onclick = callback; } window.onload = function () { //创建广州节点 var gz = document.createElement('li'); var txt = document.createTextNode('广州'); gz.appendChild(txt); // 创建一个"广州"节点,添加到#city下 myClick('btn01',function () { // &lt;li&gt;广州&lt;/li&gt; // 创建一个li元素节点对象 // document.createElement() 用来根据标签名创建一个元素节点对象 // var gz = document.createElement('li'); // 创建一个"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4843fb8f927c16b08a27a759564cbfd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884af25901715a2c4ffbeec9d9b7d7b1/" rel="bookmark">
			pip安装报错：ERROR: Could not build wheels for psutil
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考：https://github.com/giampaolo/psutil/issues/1143
我这里ubuntu系统
解决方法：依据自己python版本安装，比如这里3.7版本
sudo apt install python3.7-dev pip3 install psutil 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/253f93967175a7722052bc000e8f26e2/" rel="bookmark">
			Solidity Uniswap V2 Router contract addLiquidity
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		router 合约是一种高级合约，是大多数用户应用程序的入口点。通过该合约，可以更轻松地创建交易对、添加和删除流动性、计算交换中的价格变化以及执行交换。Router 适用于通过工厂合约部署的所有交易对，是一种通用合约。
GitHub - XuHugo/solidityproject: DApp go go go ！！！
它也是一个非常大的合约，我们可能不会实现它的所有功能，因为其中大部分都是交换功能的变形。让我们看看路由器的构造函数：路由器可以部署pair，因此它需要知道工厂合约的地址。
contract ZuniswapV2Router { error InsufficientAAmount(); error InsufficientBAmount(); error SafeTransferFailed(); IZuniswapV2Factory factory; constructor(address factoryAddress) { factory = IZuniswapV2Factory(factoryAddress); } ... 今天，我们只实现流动性管理的一部分，让我们从 addLiquidity 开始：
function addLiquidity( address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to ) public returns ( uint256 amountA, uint256 amountB, uint256 liquidity ) ... 与pair合约中的mint函数相比，该函数有很多参数！
1、tokenA 和 tokenB 用于查找（或创建）我们希望增加流动性的货币对。
2、amountADesired 和 amountBDesired 是我们希望存入货币对的金额。这些是上限。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/253f93967175a7722052bc000e8f26e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/be05690e327c65815903fab4e829ad38/" rel="bookmark">
			Lucene查询语法，适用于 ELk Kibana 查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Lucene查询语法，适用于 ELk Kibana 查询 Elasticsearch 构建在 Lucene 之上，过滤器语法和 Lucene 相同。本语法可用于 Kibana 界面的检索和 Grafana 看板对接 ES 的检索规则。
Kibana 上的检索语法Grafana 上的检索语法 全文搜索 在搜索栏输入login，会返回所有字段值中包含 login 的文档
使用双引号包起来作为一个短语搜索 "like Gecko"
字段搜索 可以按页面左侧显示的字段搜索限定字段全文搜索：field:value精确搜索：关键字加上双引号 filed:"value"精确过滤不存在的：字段前加上减号，关键字加上双引号 -filed:"value"http.code:404 搜索 http 状态码为 404 的文档-traceId:null tranceId字段不为null字段本身是否存在
_exists_:http：返回结果中需要有 http 字段
_missing_:http：不能含有 http 字段判断某个字段不为空字符串
-corp.keyword:"" 通配符搜索 Lucene 支持单个术语内的单个和多个字符通配符搜索（不在短语查询中）。
? 匹配单个字符* 匹配0到多个字符kiba?a, el*search 注意：您不能使用_或？符号作为搜索的第一个字符。例如：?text _text
正则表达式搜索 Lucene 支持正向表达式搜索，性能较差
name:/joh?n(ath[oa]n)/ 模糊搜索 quikc~ brwn~ foks~~:在一个单词后面加上~启用模糊搜索，可以搜到一些拼写错误的单词first~ 这种也能匹配到 frist 还可以设置编辑距离（整数），指定需要多少相似度
cromm~1 会匹配到 from 和 chrome默认2，越大越接近搜索的原始值，设置为1基本能搜到80%拼写错误的单词 近似搜索 在短语后面加上~，可以搜到被隔开或顺序不同的单词，注意短语要使用双引号"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/be05690e327c65815903fab4e829ad38/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb8d10b304086e904325d97a7b73826f/" rel="bookmark">
			odoo中_name_search用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		_name_search是Odoo中一个重要的方法，用于实现模型记录的搜索逻辑。这个方法通常在后端被调用，以便在Odoo的各种视图中（如下拉列表选择框）搜索和筛选记录。_name_search是模型中的一个API方法，可以被重写以自定义搜索逻辑。
基本概念 在Odoo中，每个模型（model）都可以通过搜索名称来查找记录。默认情况下，这个搜索基于模型的name字段进行。但是，有时候你可能希望基于其他字段或复杂逻辑来搜索记录。在这种情况下，你就需要重写_name_search方法。
方法原型 _name_search的基本原型如下：
def _name_search(self, name='', args=None, operator='ilike', limit=100, name_get_uid=None): name: 搜索框中输入的文本。args: 附加搜索条件的列表，每个条件都是一个元组，比如[('field_name', 'operator', value)]。operator: 用于搜索的操作符，如'ilike'、'='等。limit: 返回结果的最大数量。name_get_uid: 用户的ID，用于安全性和记录规则检查。 自定义搜索逻辑 重写_name_search允许你基于自定义逻辑进行搜索。这里是一个简单的例子，展示如何根据一个不同于name字段的字段来进行搜索：
from odoo import models, fields, api class CustomModel(models.Model): _name = 'custom.model' _description = 'Custom Model' name = fields.Char('Name') description = fields.Char('Description') @api.model def _name_search(self, name='', args=None, operator='ilike', limit=100, name_get_uid=None): if not args: args = [] if name: args = ['|', ('name', operator, name), ('description', operator, name)] + args return super(CustomModel, self).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb8d10b304086e904325d97a7b73826f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/64b43309b94010fa250e89c80e2f8c12/" rel="bookmark">
			opencv编解码base64字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cpp-base64代码地址：
https://github.com/ReneNyffenegger/cpp-base64
下载仓库，并将base64.h，Base64.cpp 加入代码中，
将Mat对象编码为base64字符串
Mat img= imread("xxx.png"); std::vector&lt;uchar&gt; buf; cv::imencode(".png", img, buf); auto *data_ptr = reinterpret_cast&lt;unsigned char*&gt;(buf.data()); std::string encode_str = base64_encode(data_ptr, buf.size()); std::cout &lt;&lt;"base64: " encode_str &lt;&lt; std::endl; 将base64解码为Mat对象
string dec_str = base64_decode(encode_str); std::vector&lt;uchar&gt; data(dec_str.begin(), dec_str.end()); cv::Mat image = cv::imdecode(cv::Mat(data), 1); 参考：
https://renenyffenegger.ch/notes/development/Base64/Encoding-and-decoding-base-64-with-cpp/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54787e64d5299abe615a0b7830508b10/" rel="bookmark">
			宝塔 mongodb6.0及以上（7.0）使用mongo启动“-bash: mongo: command not found”解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MongoDB6.0版本后没有mongo文件。
到这里下载linux版本的mongodb
https://downloads.mongodb.com/compass/mongosh-1.6.0-linux-x64.tgz 下载完是这个样子的
打开bin文件
把这两个文件放入到你的mongodb/bin文件夹下
他本来就有一个mongosh，直接覆盖就行
不知道自己mongodb放在哪里的可以这样找
打开这个页面就可以查看到了
然后在终端输入
1.cd /www/server/mongodb/bin //进入到mongodb的bin文件夹
2.mongosh //启动mongosh
这样，我们就进来了mongodb数据库，可以根据自己的需要对数据库进行操作了
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/23/">«</a>
	<span class="pagination__item pagination__item--current">24/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/25/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>