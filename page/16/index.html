<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae14426ffaf9e0bb1e65fd23853ba689/" rel="bookmark">
			http的body格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		body数据都通常放在 HTTP 请求的 body 部分。
在 HTTP 请求中，Content-Type 头用于指示 body 中的数据格式。例如，对于 x-www-form-urlencoded 格式的数据，通常会设置 Content-Type: application/x-www-form-urlencoded，而对于 form-data 格式的数据，通常会设置 Content-Type: multipart/form-data。
Content-Type: application/x-www-form-urlencoded 这种格式将数据编码成键值对的形式，然后将键值对连接成一个字符串，并使用 &amp; 符号作为分隔符。键和值都进行了 URL 编码。
POST /submit-form HTTP/1.1 Host: example.com Content-Type: application/x-www-form-urlencoded Content-Length: 45 name=John+Doe&amp;age=30&amp;city=New+York Content-Type:application/json 这种格式常用于上传文件或者包含二进制数据的场景。它将每个字段和对应的值以及文件数据分别作为一个独立的部分，每个部分都有自己的 Content-Disposition 标头。
设置 Content-Type: application/json 头来指示请求体中的数据是 JSON 格式的。
POST /api/data HTTP/1.1 Host: example.com Content-Type: application/json { "name": "John Doe", "age": 30, "city": "New York" } Content-Type:multipart/form-data 这种格式常用于上传文件或者包含二进制数据的场景。它将每个字段和对应的值以及文件数据分别作为一个独立的部分，每个部分都有自己的 Content-Disposition 标头。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9a726e059f5fef22255ebb62facd0ac0/" rel="bookmark">
			Tomcat的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows安装Tomcat Windows中有两种方式安装：
方式1：使用集成环境xampp，里面是有带Tomcat的，新手或者怕麻烦的可以使用。
这是集成环境xampp的界面，可以看到包含了Tomcat、mysql、apache等环境，可以集中管理，非常方便，直接点击Start即可启动。tomcat的安装目录就在xampp的安装目录下的tomcat中。
官方地址：https://www.apachefriends.org/zh_cn/index.html
点击即可开始下载，安装没什么需要注意的，直接一路next即可。
注意安装位置！
如果tomcat启动报错，可以看下一篇专门解决启动问题。
方式2：常规安装
tomcat官网：https://tomcat.apache.org/
选择这儿的Download中的对应的版本，然后选择自己系统对应的压缩包进行下载：
然后解压即可。解压之后到bin文件夹下：
双击startup.bat即可启动；如果有报错请看下一篇。
如果启动成功，访问：http://localhost:8080可以看到tomcat的界面：
Linux安装Tomcat Tomcat官网：https://tomcat.apache.org/
选择此连接包含的地址：https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.87/bin/apache-tomcat-9.0.87.tar.gz
然后切换到你要安装的位置，下载此压缩包，命令：
wget https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.87/bin/apache-tomcat-9.0.87.tar.gz 然后执行解压：tar -zxvf apache-tomcat-9.0.87.tar.gz 然后进入到bin目录下，执行：sh startup.sh
这样就启动成功了，然后访问：http://localhost:8080即可看到tomcat首页。安装完成。
注意防火墙！注意端口是否有冲突！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e86f8abe77ceac5713f6b34c4ed5d93/" rel="bookmark">
			java毕业设计-基于springboot开发的会员制医疗预约服务管理信息系统-毕业论文&#43;答辩PPT（附源代码&#43;演示视频）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、毕设成果演示（源代码在文末）二、毕设摘要展示1、开发说明2、需求分析3、系统功能结构 三、系统实现展示1、系统功能模块2、管理员功能模块3、医生功能模块3、会员功能模块 四、毕设内容和源代码获取总结 java毕业设计-基于springboot开发的会员制医疗预约服务管理信息系统-毕业论文+答辩PPT（附源代码+演示视频） 如需其他项目或毕设源码，可进主页看下往期的毕设资源分享哦，希望对您有帮助！
逃逸的卡路里
–
前言 随着信息技术的飞速发展，Java语言作为一种成熟、稳定且功能强大的编程语言，已经广泛应用于企业级应用、移动开发、大数据处理等多个领域。作为本科大学生，我们在学习Java编程语言的过程中，不仅掌握了其语法规则和编程技巧，更重要的是学会了如何利用Java解决实际问题，实现软件系统的设计与开发。
本次毕业设计旨在通过实际项目的开发，将我们在大学期间所学的Java编程语言知识与实践相结合，进一步加深对Java语言的理解和应用。毕业设计的宗旨在于培养我们的独立思考能力、团队协作精神和创新能力，提升我们解决实际问题的能力，为未来的职业发展打下坚实的基础。
在毕业设计中，我们将综合运用Java编程语言、数据库技术、前端开发技术等，设计并实现一个具有实际应用价值的软件系统。通过需求分析、系统设计、编码实现、测试维护等阶段的实践，我们将全面提升自己的软件开发能力，为未来的学习和工作积累宝贵的经验。
一、毕设成果演示（源代码在文末） 二、毕设摘要展示 1、开发说明 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql 5.7（一定要5.7版本）
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
浏览器：谷歌浏览器
2、需求分析 针对会员制医疗预约服务行业的管理现状，本会员制医疗预约服务管理信息系统主要实现以下几个目标：
1.系统界面简洁，操作简便。
2.拥有精准，高效的查询功能。
3.使管理人员能够及时的获得精确的报表。
4.对数据内容的管理安全，稳定，易维护。
5.对信息全面跟踪，方便管理人员进行管理。
6.提供用户登录和修改密码等服务，加强系统安全。
7.提供用户管理和数据备份，确保信息的安全性和可靠性。
3、系统功能结构 三、系统实现展示 1、系统功能模块 会员制医疗预约服务管理信息系统，在系统首页可以查看首页，医院信息，坐诊信息，核酸检测，疾控通知，健康资讯，就诊引导，个人中心，后台管理等内容，并进行详细操作；
医院信息，在医院信息页面可以查看医院名称，医院地址，院长，成立时间，联系电话，医院简介，医院详情等内容，并进行收藏操作，
坐诊信息，在坐诊信息页面可以查看医生姓名，工号，性别，医院名称，医院地址，科室名称，科室地址，挂号费，医生简介等内容，并进行预约，咨询和收藏操作
会员注册，在会员注册页面通过填写账号、密码、确认密码、姓名、身份证、手机号码等信息进行会员注册操作。
个人中心，在个人中心页面通过填写账号、密码、姓名、性别、身份证、手机号码、上传图片等内容进行更新信息，并对我的收藏进行操作
2、管理员功能模块 管理员登录，管理员进入系统前在登录页面根据要求填写用户名和密码，选择角色等信息，点击登录进行登录操作。
管理员登录系统后，可以对首页、个人中心、会员管理、医生管理、医院信息管理、科室信息管理、坐诊信息管理、核酸检测管理、挂号预约管理、药品信息管理、诊断信息管理、处方信息管理、住院信息管理、在线咨询管理、咨询回复管理、核酸预约管理、疾控通知管理、健康资讯管理、健康档案管理、系统管理等功能进行相应的操作管理
会员管理，在会员管理页面可以对索引，账号，密码，姓名，性别，身份证，手机号码，相片等内容进行详情，修改和删除等操作，
医生管理，在医生管理页面可以对索引，工号，医生姓名，性别，身份证，手机号码，相片，医院名称，医院地址，科室名称，科室地址等内容进行详情，修改和删除等操作。
医院信息管理，在医院信息管理页面可以对索引，医院名称，医院地址，医院图片，院长，成立时间，联系电话等内容进行详情，修改和删除等操作。
科室信息管理，在科室信息管理页面可以对索引，科室名称，科室地址内容进行详情，修改和删除等操作。
坐诊信息管理，在坐诊信息管理页面可以对索引，工号，医生姓名，性别，医院名称，医院地址，科室名称，科室地址，相片，挂号费，审核回复，审核状态，审核等内容进行详情，修改和删除等操作。
核酸检测管理，在核酸检测管理页面可以对索引，检测名称，检测封面，检测地点，检测类型，费用，发布时间等内容进行详情，修改和删除等操作。
药品信息管理，在药品信息管理页面可以对索引，药品名称，药品图片，药品功效，服用方式，单价，生产商内容进行详情，修改和删除等操作。
处方信息管理，在处方信息管理页面可以对索引，工号，医生姓名，医院名称，科室名称，处分名称，药品名称，单价，数量，金额，账号，姓名，操作日期，是否支付等内容进行详情和删除等操作。
在线咨询管理，在在线咨询管理页面可以对索引，工号，医生姓名，咨询内容，账号，姓名，咨询日期等内容进行详情和删除等操作。
疾控通知管理，在疾控通知管理页面可以对索引，标题，封面，注意事项，工号，医生姓名，发布日期内容进行详情和删除等操作。
健康资讯管理，在健康资讯管理页面可以对索引，资讯标题，资讯封面，资讯类型，工号，医生姓名，发布时间等内容进行详情和删除等操作。
3、医生功能模块 医生登录系统后，可以对首页、个人中心、坐诊信息管理、挂号预约管理、药品信息管理、诊断信息管理、处方信息管理、住院信息管理、在线咨询管理、咨询回复管理、疾控通知管理、健康资讯管理等功能进行相应的操作管理。
坐诊信息管理，在坐诊信息管理页面可以对索引，工号，医生姓名，性别，医院名称，医院地址，科室名称，科室地址，相片，挂号费，审核回复，审核状态等内容进行详情，修改和删除等操作。
药品信息管理，在药品信息管理页面可以对索引，药品名称，药品图片，药品功效，服用方式，单价，生产商内容进行详情等操作；
疾控通知管理，在疾控通知管理页面可以对索引，标题，封面，注意事项，工号，医生姓名，发布日期内容进行详情，修改和删除等操作
3、会员功能模块 会员登录系统后，可以对首页、个人中心、挂号预约管理、诊断信息管理、处方信息管理、住院信息管理、在线咨询管理、咨询回复管理、核酸预约管理、健康档案管理、我的收藏管理等功能进行相应的操作管理
个人中心，在个人信息页面通过填写账号、姓名、性别、身份证、手机号码、相片等信息进行修改操作
在线咨询管理，在在线咨询管理页面可以对索引，工号，医生姓名，咨询内容，账号，姓名，咨询日期等内容进行详情，修改和删除等操作。
四、毕设内容和源代码获取 java毕业设计-基于springboot开发的会员制医疗预约服务管理信息系统-毕业论文+答辩PPT（附源代码+演示视频）：https://download.csdn.net/download/u014740628/88860062
如需其他项目或毕设源码，可进主页看下往期的毕设资源分享哦，希望对您有帮助！
逃逸的卡路里
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e86f8abe77ceac5713f6b34c4ed5d93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29ed223e9d6a0eed18971410e4000041/" rel="bookmark">
			数据结构之链式二叉树续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.获取叶节点个数 获取叶子结点个数，我们这里也用递归的方法
利用分治思想去解决这个问题
●代码思想：
1. 当遇到空树或者遇到空的节点时，也就是说这是的叶子为NULL，这是我们返回0
2. 当遇到左节点或者右节点为空，当节点不为空时，此时已经到达了叶子结点，所以返回1
3. 当遇到的不是叶节点时，我们需要到递归左节点的个数和右节点的个数，并进行递归返回
●代码思想：
对于整棵树来说，当我们遇到空树或者遇到节点为空的时候，这时的叶子结点为空，我们这时返回0，当不是上中情况的时候，我们从根往下去搜索，先搜索左节点，当左节点不为空，并且左节点的左子树和右子树都是空的时候，这时候就可以确定它是叶子了，也就是返回1，当搜索完左子树就可以搜索右子树，右子树也同理 2.获取树的高度 获取树的高度，我们也是利用分治的思想去实现这个代码
首先就是当我们要想返回高度的时候，我们需要调用到左右子树的高度
然后比较左右子树的高度，比较出最大的一个并返回
然后加1（因为我们递归的是左右子树的高度，我们需要整个树的高度，所以还需要加上根，也就是加一）
●代码思想：
1.当我们遇到空树或者遇到的节点为NULL，这时返回0
2.然后接下来去递归左子树和右子树
3.返回时，如果左子树大于右子树，那么就是左子树高度+1，否则右子树高度+1
//获取树的高度 int TreeHeight(BTNode* root) { if (root == NULL) { return 0; } TreeHeight(root-&gt;left); TreeHeight(root-&gt;right); return (TreeHeight(root-&gt;left) &gt; TreeHeight(root-&gt;right) ? TreeHeight(root-&gt;left) : TreeHeight(root-&gt;right)) + 1; } 但这个代码有一定的缺陷
我们可以看到，这个代码我们调用了两次TreeHeight(root-&gt;left)和TreeHeight(root-&gt;right)
在这一树中，我们调用多次函数，大大增加了计算的难度，在一棵小树中可能不明显，可当树更大时，这时候弊端就先显示出来了
所以我们可以改进一下代码，定义两个变量去接受返回值
然后比较两个返回值
//改进代码 int TreeHeight(BTNode* root) { if (root == NULL) { return 0; } /*TreeHeight(root-&gt;left); TreeHeight(root-&gt;right); return (TreeHeight(root-&gt;left) &gt; TreeHeight(root-&gt;right) ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29ed223e9d6a0eed18971410e4000041/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/704a9e0059b8ecb66396e4f536cfde73/" rel="bookmark">
			Spring Boot集成mapstruct快速入门指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.mapstruct介绍 在项目中经常会用到DO,BO,DTO,VO等对象的相互转化，这就需要一个高效通用的转化工具，毕竟每个字段get/set方法会很麻烦。MapStruct 就是这样的一个属性映射工具，只需要定义一个 Mapper 接口，MapStruct就会自动实现这个映射接口，避免了复杂繁琐的映射实现。
2.代码工程 pom.xml &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;groupId&gt;com.et&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;1.3.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;1.3.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;2.0.40&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; 配置文件 server: port: 8088 启动类 package com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/704a9e0059b8ecb66396e4f536cfde73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5edb648e45d15334a85140d2e3a13f5/" rel="bookmark">
			MongoDB实战面试指南：常见问题一网打尽
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		码到三十五 ： 个人主页 心中有诗画，指尖舞代码，目光览世界，步履越千山，人间尽值得 ! MongoDB是一款流行的非关系型数据库，以其高效、可扩展的特性受到开发者的青睐。了解MongoDB的架构、存储引擎和数据结构，对于构建高性能、可靠的数据库解决方案至关重要。以下的问题将测试你对MongoDB基础知识的掌握，以及在实际应用中处理数据一致性和事务的能力。无论你是新手还是资深大佬，这些问题都将帮助你深化对MongoDB的理解。
目录 1. 问题：MongoDB是什么？它与关系型数据库有何不同？2. 问题：MongoDB中的索引是什么？它们的作用是什么？3. 问题：如何在MongoDB中执行聚合操作？4. 问题：MongoDB的复制集是什么？它有哪些优点？5. 问题：MongoDB的分片是什么？它如何工作？6. 问题：在MongoDB中如何处理事务？7. 问题：MongoDB中的`$lookup`是什么？如何使用它？8. 问题：如何优化MongoDB的查询性能？9. 问题：MongoDB中的`$set`和`$setOnInsert`操作符有什么区别？10. 问题：MongoDB中的地理空间索引是什么？如何使用它们进行地理空间查询？11. 问题：MongoDB中的文本索引是什么？如何使用它们进行全文搜索？12. 问题：MongoDB中的`$group`聚合操作符有什么作用？如何使用它进行分组操作？13. 问题：在MongoDB中如何执行原子性操作？14. 问题：MongoDB中的投影是什么？如何使用它？15. 问题：MongoDB中的`$elemMatch`操作符有什么作用？如何使用它？16. 问题：MongoDB中的更新操作符有哪些？它们的作用是什么？17. 问题：MongoDB中的分片（Sharding）是什么？它如何帮助扩展数据库？18. 问题：MongoDB中的复制集（Replica Set）是什么？它如何提供高可用性？19. 问题：MongoDB中的索引类型有哪些？它们各自适用于什么场景？20. 问题：MongoDB的存储引擎是什么？它有哪些特点？21. 问题：MongoDB的架构是怎样的？它如何支持高并发和可扩展性？22. 问题：MongoDB中的数据结构是怎样的？它支持哪些数据类型？23. 问题：MongoDB中的集合（Collection）和文档（Document）是什么？它们之间有什么关系？24. 问题：MongoDB中的索引是如何工作的？索引对查询性能有什么影响？25. 问题：MongoDB如何处理数据一致性和事务？26. 问题：MongoDB的写关注（Write Concern）是什么？它如何影响数据持久性？27. 问题：MongoDB的读偏好（Read Preference）是什么？它如何影响查询性能和数据一致性？28. 问题：请描述MongoDB中的聚合（Aggregation）操作，并给出一个简单的例子。 1. 问题：MongoDB是什么？它与关系型数据库有何不同？ 答案：MongoDB是一个基于文档的NoSQL数据库，它使用BSON（一种类似JSON的二进制格式）来存储数据。与关系型数据库相比，MongoDB没有固定的数据模式，支持非结构化数据的存储，且水平扩展性强。MongoDB更适合于需要快速迭代开发、数据模型经常变动的应用场景。
2. 问题：MongoDB中的索引是什么？它们的作用是什么？ 答案：MongoDB中的索引是一种数据结构，它允许数据库系统不必扫描整个集合，而是直接定位到满足查询条件的文档。索引可以大大提高查询性能。MongoDB支持多种类型的索引，如单字段索引、复合索引、多键索引等。
3. 问题：如何在MongoDB中执行聚合操作？ 答案：MongoDB提供了聚合管道（aggregation pipeline）来执行聚合操作。聚合管道是一系列的数据处理阶段，每个阶段都会对输入的数据集进行某种处理，然后输出到下一个阶段。常见的聚合操作包括分组、过滤、排序、投影和计算等。
4. 问题：MongoDB的复制集是什么？它有哪些优点？ 答案：MongoDB的复制集是一组维护相同数据集的mongod服务实例。复制集提供了数据冗余和高可用性，当主节点发生故障时，可以自动切换到其他可用的节点上。此外，复制集还可以提高读取性能，因为客户端可以从多个节点上并行读取数据。
5. 问题：MongoDB的分片是什么？它如何工作？ 答案：MongoDB的分片是将数据集分布在多个MongoDB实例上的过程。分片可以提高系统的可伸缩性和性能，因为数据可以分布在多个服务器上，每个服务器只处理部分数据。MongoDB使用分片键来确定如何将文档分配给特定的分片。当执行查询时，MongoDB会根据分片键将查询路由到相应的分片上。
6. 问题：在MongoDB中如何处理事务？ 答案：MongoDB从4.0版本开始支持多文档事务。事务是一组必须全部成功或全部失败的操作。MongoDB使用两阶段提交协议来处理事务，确保数据的完整性和一致性。在MongoDB中，可以使用session对象来管理事务的边界，并使用startTransaction、commitTransaction和abortTransaction方法来控制事务的开始、提交和中止。
7. 问题：MongoDB中的$lookup是什么？如何使用它？ 答案：$lookup是MongoDB聚合管道中的一个阶段，它用于执行左外连接操作。$lookup可以从另一个集合中获取与输入文档相关联的文档，并将它们合并到输出文档中。使用$lookup时，需要指定要连接的集合、连接条件和输出字段等参数。例如，可以使用$lookup将订单集合中的订单与库存集合中的商品进行关联查询。
8. 问题：如何优化MongoDB的查询性能？ 答案：优化MongoDB的查询性能可以从多个方面入手。首先，确保为常用的查询字段创建适当的索引以提高查询速度。其次，避免使用全表扫描和不必要的投影操作来减少数据传输量。此外，可以使用查询分析器（如explain()方法）来分析查询计划并找出性能瓶颈。最后，定期清理和压缩数据库以释放存储空间并提高读写性能。
9. 问题：MongoDB中的$set和$setOnInsert操作符有什么区别？ 答案：在MongoDB中，$set操作符用于更新文档中的字段。如果字段不存在，$set将创建该字段并将其值设置为指定的值。如果字段已存在，$set将更新该字段的值。而$setOnInsert操作符仅在upsert操作为true且导致插入新文档时才有效。如果新文档被插入，$setOnInsert将设置字段的值；如果现有文档与查询条件匹配，则不会进行任何更改。
10. 问题：MongoDB中的地理空间索引是什么？如何使用它们进行地理空间查询？ 答案：MongoDB支持地理空间索引，允许用户高效地执行地理空间查询，如查找点、线和多边形之间的空间关系。MongoDB提供了2dsphere、2d和geoHaystack等类型的地理空间索引。其中，2dsphere索引用于地球表面的地理空间数据，支持经纬度坐标和GeoJSON格式。使用地理空间索引时，可以使用$near、$geoWithin和$geoIntersects等操作符来执行地理空间查询。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5edb648e45d15334a85140d2e3a13f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a58afba005e316b7bef412d80acfd3/" rel="bookmark">
			Java毕业设计-基于springboot开发的广场舞团系统-毕业论文&#43;答辩PPT（附源代码&#43;演示视频）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、毕设成果演示（源代码在文末）二、毕设摘要展示1、开发说明2、需求分析3、系统功能结构 三、系统实现展示1、系统功能模块2、后台登录模块2.1管理员功能模块2.2社团功能模块2.3用户功能模块 四、毕设内容和源代码获取总结 Java毕业设计-基于springboot开发的广场舞团系统-毕业论文+答辩PPT（附源代码+演示视频） 如需其他项目或毕设源码，可进主页看下往期的毕设资源分享哦，希望对您有帮助！
逃逸的卡路里
–
前言 随着信息技术的飞速发展，Java语言作为一种成熟、稳定且功能强大的编程语言，已经广泛应用于企业级应用、移动开发、大数据处理等多个领域。作为本科大学生，我们在学习Java编程语言的过程中，不仅掌握了其语法规则和编程技巧，更重要的是学会了如何利用Java解决实际问题，实现软件系统的设计与开发。
本次毕业设计旨在通过实际项目的开发，将我们在大学期间所学的Java编程语言知识与实践相结合，进一步加深对Java语言的理解和应用。毕业设计的宗旨在于培养我们的独立思考能力、团队协作精神和创新能力，提升我们解决实际问题的能力，为未来的职业发展打下坚实的基础。
在毕业设计中，我们将综合运用Java编程语言、数据库技术、前端开发技术等，设计并实现一个具有实际应用价值的软件系统。通过需求分析、系统设计、编码实现、测试维护等阶段的实践，我们将全面提升自己的软件开发能力，为未来的学习和工作积累宝贵的经验。
一、毕设成果演示（源代码在文末） 二、毕设摘要展示 1、开发说明 开发语言：Java
框架：springboot
JDK版本：JDK1.8
服务器：tomcat7
数据库：mysql 5.7（一定要5.7版本）
数据库工具：Navicat11
开发软件：eclipse/myeclipse/idea
Maven包：Maven3.3.9
浏览器：谷歌浏览器
2、需求分析 本课题要求实现一套广场舞团管理系统，系统主要包括管理员模块，社团模块和用户模块等功能模块。
（1）管理员用例图如下所示：
（2）用户用例图如下所示：
（3）社团用例图如下所示：
3、系统功能结构 三、系统实现展示 1、系统功能模块 广场舞团，在系统首页可以查看首页，社团，社团活动，交流中心，公告资讯，个人中心，后台管理等功能并进行详细操作
社团，在社团页面可以查看社团编号，地区，社团名称，舞团类型等功能并进行搜索等操作
社团活动，在社团活动页面可以查看活动名称，活动类型等功能并进行搜索等操作
2、后台登录模块 登录，用户通过填写注册时输入的用户名、密码、选择角色等信息进行登录操作
2.1管理员功能模块 管理员登陆系统后，可以查看首页，个人中心，地区管理，舞团类型管理，社团管理，用户管理，成员信息管理，社团活动管理，交流中心，系统管理等功能等功能，还能对每个功能逐一进行相应操作
地区管理；在地区管理页面中可以对索引、地区、等内容进行查看，修改和删除操作；
舞团类型管理；在舞团类型管理页面中可以对索引、舞团类型等内容进行查看，修改和删除操作
社团管理；在社团管理页面中可以对索引、社团编号、地区、社团名称、社团图片、社团类型、负责人、联系电话等内容进行查看，修改和删除操作。
用户管理；在用户管理页面中可以对索引、用户名、姓名性别、头像、手机等内容进行查看，修改和删除操作。
社团活动管理；在社团活动管理页面中可以对索引、活动名称、活动流程、活动图片、舞蹈曲目、视频内容、发布日期、社团编号、社团名称等内容进行查看，修改和删除操作
交流中心；在交流中心页面中可以对索引、帖子标题、用户名、状态、等内容进行修改和删除操作；
2.2社团功能模块 社团登录系统后可以查看首页、个人中心、成员信息管理、社团活动管理等功能并进行详细的操作；
成员信息管理；在成员信息管理页面中可以对索引、社团编号、社团名称、申请内容、申请日期、用户名、手机、审核回复、审核状态、审核等内容进行查看，修改和删除操作；
社团活动管理；在社团活动管理页面中可以对索引、活动名称、活动类型、活动图片、舞蹈曲目、视频内容、发布日期、社团编号、社团名称等内容进行查看，修改和删除操作；
2.3用户功能模块 用户登录系统后可以查看首页、个人中心、成员信息管理、我的收藏管理等功能并进行详细的操作
成员信息管理；在成员信息管理页面中可以对索引、社团编号、社团名称、申请内容、申请日期、用户名、手机、审核回复、审核状态、等内容进行查看，修改和删除操作
我的收藏管理；在我的收藏管理页面中可以查看索引、收藏名称、收藏图片、推荐类型等内容，并进行查看详情和删除操作；
四、毕设内容和源代码获取 Java毕业设计-基于springboot开发的广场舞团系统-毕业论文+答辩PPT（附源代码+演示视频）：https://download.csdn.net/download/u014740628/88860054
如需其他项目或毕设源码，可进主页看下往期的毕设资源分享哦，希望对您有帮助！
逃逸的卡路里
总结 通过本次毕业设计，我们不仅巩固了所学的Java编程语言知识，还学会了如何将理论知识应用于实际项目中。我们设计的软件系统具有一定的实际应用价值，这让我们对自己的能力充满了信心，也为未来的职业发展打下了坚实的基础。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a3dff045f3365b12e7248d4784b175af/" rel="bookmark">
			Microsoft VBA Excel 规律的Text文件转工作表Sheet
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题场景 简述：
在Excel的.xlsm文件中，有一个"RunControl"的sheet用来操控转换Text到指定的sheet中，需要在这个sheet上增加一个按钮，并在按钮上链接一个VBA程序，实现指定的功能。
以下是"RunControl"内的控制表格，五个标题名称以及另一名称（“FileName”）都已经通过名称管理器定义了各自的单元格。
ItemFolderNameIndicatorFilePathTime1ROEC:\User\Path12PEYC:\User\Path23PBC:\User\Path3 需要循环"Item"这一列数据，从被定义为"Item"的单元格开始直到取不到数据为止，这是主循环是否结束的判断；接着在每一次循环中先判断对应的"Indicator"是否是"Y"，如果是"Y"则执行两个操作：①新建一个sheet（名称是对应的"FolderName"），②需要组合读取对应的"FilePath"和"FolderName"和另一个独立的单元格"FileName"，这样就可以打开对应位置的文件执行后续的操作。
举个例子，现在主循环是"Item"为"2"的这一行，“Indicator"是"Y”，所以需要完成两个操作：①新建sheet命名为"PE"，②把对应的"FilePath"和"FolderName"和独立的"FileName"组合变成地址"C:\User\Path2\PE\Information.text"，通过地址打开"Information.text"这个文件。
文件打开后每一行的格式是这样的：“S=1234|T=ABCD|N=Sample|Location=\Path”，需要按分隔符"|“切分每一列，使得全部数据都保存到对应的sheet（名称是对应的"FolderName”）中。每一行只需要直接根据每一行的分隔符判断是放入对应sheet的哪一列即可，无视连续的多个分隔符"|"。并且在切分完成后加入一个判断：如果切分结果中有某一行结果和其他行不一致，给出警告弹窗。完成以上操作后，记录操作的时间放入对应的"Time"中。
代码描述 Sub Run_Text() Dim wsRun As Worksheet Set wsRun = ThisWorkbook.Sheets("RunControl") Dim cell As Range Dim folderName As String, filePath As String, fileName As String Dim fullFilePath As String Dim newWs As Worksheet Dim lastRow As Long ' Turn off screen updating to reduce memory pressure Application.ScreenUpdating = False ' Get the value of the FileName named range fileName = ThisWorkbook.Names("FileName").RefersToRange.Value ' Get the last row of the Item named range lastRow = wsRun.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a3dff045f3365b12e7248d4784b175af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b0913d0bdc4751977479ce5c0790db1/" rel="bookmark">
			Python keyword-only参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		keyword-only 参数是Python 3中引入的一种新的参数语法。它允许您在定义函数时强制要求某些参数必须以关键字参数的形式传递。这种机制有助于提高代码的可读性和可维护性。
以下是 keyword-only 参数的语法:
def function_name(arg1, arg2, *, kwarg1, kwarg2=value): # 函数体 pass 在上面的示例中，*是一个特殊的分隔符,它的作用是将位置参数和关键字参数分开。在*之后的参数(kwarg1和kwarg2)被称为keyword-only参数。它们只能通过关键字参数的形式传递,而不能作为位置参数传递。
例如:
def print_info(name, age, *, city="Beijing", job): print(f"Name: {name}, Age: {age}, City: {city}, Job: {job}") # 正确的调用方式 print_info("Alice", 25, job="Engineer") print_info("Bob", 30, job="Teacher", city="Shanghai") # 错误的调用方式 print_info("Alice", 25, "Engineer") # 错误,job必须使用关键字参数 使用 keyword-only 参数的好处包括:
增强代码可读性: 通过强制要求某些参数以关键字参数的形式传递,可以使代码更加清晰,更容易理解参数的含义。提高代码维护性: 如果在将来需要添加新的参数,那么 keyword-only 参数可以确保不会破坏现有的调用代码。防止意外的参数位置混淆: 在使用大量参数的函数中,很容易将位置参数的顺序搞混。使用 keyword-only 参数可以避免这种情况发生。 总之,keyword-only 参数是Python 3中的一个有用特性,它可以帮助您编写更加清晰、可维护的代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f912981ed3c68751e15d4d0183b090f/" rel="bookmark">
			每日OJ题_简单多问题dp③_力扣740. 删除并获得点数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
力扣740. 删除并获得点数
解析代码
力扣740. 删除并获得点数 740. 删除并获得点数
难度 中等
给你一个整数数组 nums ，你可以对它进行一些操作。
每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。
开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。
示例 1：
输入：nums = [3,4,2] 输出：6 解释： 删除 4 获得 4 个点数，因此 3 也被删除。 之后，删除 2 获得 2 个点数。总共获得 6 个点数。 示例 2：
输入：nums = [2,2,3,3,3,4] 输出：9 解释： 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。 之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。 总共获得 9 个点数。 提示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f912981ed3c68751e15d4d0183b090f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3b35ef3f397c52bb789f2c58020207c/" rel="bookmark">
			kali wpscan 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WPScan是一款强大的WordPress安全扫描工具，能够检测WordPress网站中的多种安全漏洞，包括WordPress本身、插件以及主题的漏洞。以下是关于WPScan操作的更详细的介绍：
安装WPScan： 如果你的系统中已经安装了Ruby和Gem，你可以通过Gem来安装WPScan。打开终端，输入gem install wpscan命令，然后按回车键进行安装。更新WPScan： 为了确保你使用的是最新版本的WPScan，可以定期更新它。在终端中输入gem update wpscan命令，然后按回车键进行更新。基本扫描操作： 使用wpscan --url [目标网站URL]命令对目标WordPress网站进行基本的安全扫描。WPScan会自动检测并报告网站可能存在的安全漏洞。扫描插件和主题： WPScan可以针对WordPress网站中的插件和主题进行详细的扫描。使用wpscan --url [目标网站URL] --enumerate p命令可以扫描插件，而使用wpscan --url [目标网站URL] --enumerate t命令可以扫描主题。这些扫描将帮助你发现插件和主题中可能存在的安全漏洞。枚举用户信息： WPScan还可以用来枚举WordPress网站的用户信息。使用wpscan --url [目标网站URL] --enumerate u命令，WPScan会尝试列出网站上的用户账户。输出结果： WPScan默认将扫描结果输出到终端。如果你希望将结果保存到文件中，可以使用--output参数。例如，wpscan --url [目标网站URL] --output results.txt会将结果保存到名为results.txt的文件中。使用代理进行扫描： 如果你需要通过代理服务器进行扫描，可以使用--proxy参数，并指定代理服务器的地址和端口。高级选项和自定义扫描： WPScan提供了许多高级选项和自定义扫描功能，可以根据你的需求进行更深入的扫描。你可以通过查看WPScan的官方文档或帮助页面来了解更多关于这些高级功能的信息。 以下是关于使用wpscan命令的选项的解释： --url URL：要扫描的博客的URL，允许的协议包括http和https。如果未提供，默认使用http协议。此选项是强制性的，除非提供update、help、hh或version选项。 -h, --help：显示简单的帮助并退出。 --hh：显示完整的帮助并退出。 --version：显示版本并退出。 -v, --verbose：详细模式，提供更多输出信息。 --[no-]banner：是否显示横幅，默认为true。 -o, --output FILE：将输出保存到指定文件。 -f, --format FORMAT：以指定格式输出结果，可用选项包括cli-no-colour、cli-no-color、json和cli。 --detection-mode MODE：设置检测模式，默认为mixed，可选的模式有passive和aggressive。 --user-agent, --ua VALUE：设置用户代理。 --random-user-agent, --rua：对每次扫描使用随机用户代理。 --http-auth login:password：使用HTTP身份验证。 -t, --max-threads VALUE：设置使用的最大线程数，默认为5。 --throttle MilliSeconds：在执行另一个网络请求之前等待的毫秒数。如果使用该选项，最大线程数将被设置为1。 --request-timeout SECONDS：设置请求超时时间（秒），默认为60。 --connect-timeout SECONDS：设置连接超时时间（秒），默认为30。 --disable-tls-checks：禁用SSL/TLS证书验证，并降级到TLS 1.0+（需要cURL 7.66）。 --proxy protocol://IP:port：设置代理服务器。 --proxy-auth login:password：设置代理服务器的身份验证。 --cookie-string COOKIE：设置请求中使用的Cookie字符串，格式为cookie1=value1[; cookie2=value2]。 --cookie-jar FILE-PATH：设置读取和写入Cookie的文件路径，默认为/tmp/wpscan/cookie_jar.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3b35ef3f397c52bb789f2c58020207c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59e1d1a10aa3b5605570744a968dbaa8/" rel="bookmark">
			基于单片机的智能台灯设计1.42
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘 要 社会在发展，时代在进步，人们对生活质量需求更加膨胀，是否拥有高科技技术也最终决定着产品是否可以满足人们的欲望，只有性价比更高，才可以得到更好的青睐。现在的电子产品愈来愈多，龙蛇混杂，只有更加智能化、性价比更高的电子产品才能取得竞争的优势。普通的家电与利用了单片机的智能家电相较而言，更能方便的使用，有更强的功能，更高的安全性，还有关键的是更能节省电能，这样家电的品质就大大提升了。 智能台灯的基础是热释电红外传感器功用是感知人体的红外辐射，处理电路的信号是BISS0001，处理方法是利用单片机处理，目的为了达成控制的便利性。当台灯附近有人且房间比较暗的时候，智能就会自动发光，就不用到处找不到开关，检测到没人的时候，等就会关闭。离桌子太近，则会自动报警，调整坐姿。
关键词： 单片机 台灯 性价比 智能
Title： Design of intelligent desk lamp based on single chip microcomputer
Abstract
Along with the social steady, human beings can not stop the pursuit of new things, continuous change of the market demand, whether to have high-tech technology makes the final decision on the prospects for the development of the product and competitive advantage, whether to have intelligence Accompanied by electronic products rapidly, intelligent home appliances are also more common, in practical applications have smart refrigerator, intelligent water heater, intelligent washing machines and other, in the enumeration of smart home has a similar feature, their central control unit is the monolithic machine.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59e1d1a10aa3b5605570744a968dbaa8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/badc7ad5b2ac1e49c480e6558d74e236/" rel="bookmark">
			小程序学习2 自定义组件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		组件 | 微信开放文档 miniprogram_npm/tdesign-miniprogram/swiper/swiper 小程序中miniprogram_npm是什么 在小程序中，miniprogram_npm是一个用于管理和引用npm包的机制。它允许开发者在小程序中直接使用npm包，而无需手动下载和引入。通过miniprogram_npm，开发者可以方便地使用第三方库和工具来增强小程序的功能。
使用miniprogram_npm的步骤如下：
在小程序项目的根目录下执行npm init命令，生成package.json文件，用于管理项目的依赖。使用npm install命令安装需要的npm包，安装后的包会被保存在项目的miniprogram_npm目录下。在小程序代码中使用require()函数引入需要的npm包，然后就可以使用该包提供的功能了。 需要注意的是，引入的npm包需要进行适配，以使其能够在小程序环境中正常运行。有些npm包可能需要进行一些额外的配置或修改才能在小程序中使用。
快速开始 | Lin UI
....
微信开发者工具中安装TDesign组件库_tdesign-miniprogram-CSDN博客 TDesign 出现上图所示的结果后，可以看到小程序IDE工具的目录结构里多出了一个文件夹 miniprogram_npm（之后所有通过 npm 引入的组件和 js 库都会出现在这里），打开后可以看到 lin-ui 文件夹，也就是我们所需要的组件。
【微信小程序】组件的生命周期及自定义组件_小程序组件的生命周期-CSDN博客
ESLint ESLint是一个用于静态代码分析的工具，它可以帮助开发者在编写JavaScript代码时发现并修复常见的错误和潜在的问题。ESLint可以根据预定义的规则或自定义的规则对代码进行检查，并提供了丰富的插件和配置选项，以满足不同项目的需求。
ESLint的主要功能包括：
语法检查：ESLint可以检查代码是否符合JavaScript语法规范，例如缺少分号、括号不匹配等。代码风格检查：ESLint可以根据预定义的代码风格规则（如Airbnb、Google等）或自定义的规则检查代码的风格是否一致，例如缩进、命名规范等。潜在问题检查：ESLint可以检查代码中可能存在的潜在问题，例如未使用的变量、未定义的变量等。提示和建议：ESLint可以提供一些提示和建议，帮助开发者编写更好的代码，例如优化建议、最佳实践等。 使用ESLint可以提高代码质量和可维护性，减少潜在的bug和错误。它可以与各种编辑器、构建工具和持续集成工具集成，方便开发者在开发过程中实时检查代码。
mock Mock是一种在软件开发中常用的测试技术，它用于模拟或替代真实的对象，以便进行单元测试。通过使用Mock对象，我们可以模拟外部依赖或者不可控的环境，使得测试更加可控和可靠。
Mock对象通常是通过使用特定的框架或库来创建和管理的。在创建Mock对象时，我们可以定义它的行为和返回值，以模拟真实对象的行为。通过这种方式，我们可以在测试中隔离被测对象与外部依赖的交互，使得测试更加独立和可重复。
Mock对象可以用于各种测试场景，例如：
模拟网络请求或数据库操作，以避免对真实资源的依赖和影响。模拟外部服务或组件，以确保被测系统在与其交互时的正确性。模拟异常情况或边界条件，以验证被测系统的健壮性和容错性。 使用Mock的好处包括：
提高测试效率：通过模拟外部依赖，可以减少测试所需的时间和资源。提高测试覆盖率：可以更容易地模拟各种场景和边界条件，从而增加测试覆盖率。提高测试可靠性：通过隔离外部依赖，可以更好地控制测试环境，减少测试结果的不确定性。 swiper.wxml &lt;wxs src="./index.wxs" module="this" /&gt; &lt;wxs src="../common/utils.wxs" module="_" /&gt; &lt;import src="../common/template/image.wxml" /&gt; &lt;view class="class {{prefix}}-class {{classPrefix}}" style="{{_._style([style, customStyle])}}"&gt; &lt;swiper class="{{classPrefix}}-host" autoplay="{{autoplay}}" current="{{current}}" interval="{{interval}}" duration="{{duration}}" circular="{{loop}}" vertical="{{direction == 'vertical'}}" easing-function="{{easingFunction}}" previous-margin="{{previousMargin}}" next-margin="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/badc7ad5b2ac1e49c480e6558d74e236/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2753d2e13b06f953bf7d34464284c22e/" rel="bookmark">
			深度剖析：数字经济下人工智能水平的新测算模型数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据来源：企业年报
时间跨度：1991-2022年
数据范围：各企业
数据指标：
年份
股票代码
公司名称
总词频
词频加1取对数
人工智能
计算机视觉
图像识别
知识图谱
智能教育
增强现实
智能政务
特征提取
商业智能
智能养老
支持向量机（SVM）
知识表示
模式识别
物联网
人机对话
AI产品
人机交互
数据挖掘
智慧银行
智能客服
虚拟现实
自动驾驶
无人驾驶
智慧金融
大数据营销
长短期记忆（LSTM）
智能芯片
边缘计算
云计算
深度神经网络
AI芯片
深度学习
特征识别
智能保险
智能零售
智能医疗
智能运输
智能家居
循环神经网络
大数据风控
机器人流程自动化
可穿戴产品
大数据平台
增强智能
大数据运营
机器翻译
神经网络
语音合成
人机协同
智能农业
智能音箱
卷积神经网络
问答系统
强化学习
大数据分析
自然语言处理
大数据管理
智能计算
语音交互
机器学习
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2753d2e13b06f953bf7d34464284c22e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fa0233a99ea8dac1d44f8358daf5200/" rel="bookmark">
			hbuild 的uniapp项目打包到 h5 部署到服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、uniapp项目 （一般改3 个地方） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3e07361285e71348e12a4bbf71cc613/" rel="bookmark">
			React利用Context API解决属性钻取问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 大家好，今天我们深入探讨了属性钻取的问题，了解到在复杂的React应用中，如何因为多层级组件之间的props传递而导致的开发和维护的困难。属性钻取不仅使得代码难以维护，还可能引起不必要的组件重渲染，影响应用性能。但幸运的是，React为我们提供了强大的解决方案来优化这一问题——Context API。
在这篇文章中，深入探讨如何利用Context API有效解决React中的属性钻取问题。通过Context API，我们可以在组件树中直接传递状态，无需通过每一层手动传递props，从而简化组件间的通信，减轻开发者的负担。我们将通过具体的代码示例来演示Context API的使用方法，帮助你更好地理解和掌握这一技术，让你的React应用架构更加清晰，代码更加简洁。
二、利用Context API解决React中的属性钻取问题 利用Context API解决React中的属性钻取问题，是一种有效的数据管理策略，尤其适用于在多层嵌套的组件树中传递数据的场景。Context API通过创建一个全局的数据层，使得我们可以跨组件共享状态，而不必显式地通过每一层组件传递props。下面我们将通过一个具体的例子，深入了解如何使用Context API来简化组件间的数据传递。
1. 创建Context 首先，我们需要创建一个Context对象。这通过createContext方法实现，该方法来自于React库。创建的Context对象将用于提供和消费状态。
import { createContext } from 'react'; // 创建一个context const UserContext = createContext(); 2. 提供Context 在应用的顶层组件中，我们使用UserContext.Provider来包裹需要访问Context中数据的组件树。通过value属性，我们可以将需要共享的数据传递给所有的子组件。
function App() { return ( &lt;div&gt; &lt;Navbar /&gt; &lt;UserContext.Provider value={{ user: 'Aegon' }}&gt; &lt;MainPage /&gt; &lt;/UserContext.Provider&gt; &lt;/div&gt; ); } 在上述代码中，UserContext.Provider包裹了MainPage组件，因此MainPage以及它的所有子组件都能够访问到UserContext中的数据。
3. 消费Context 在需要访问Context中数据的组件内部，我们使用useContext Hook来消费Context。这个Hook接收一个Context对象（我们之前创建的UserContext）作为参数，并返回该Context的当前值。
import { useContext } from 'react'; function Message() { // 使用useContext Hook访问UserContext中的状态 const { user } = useContext(UserContext); return &lt;p&gt;Welcome {user} :)&lt;/p&gt;; } 在Message组件中，我们通过useContext获取到了UserContext提供的user状态，并将其渲染到了组件中。这样，我们就避免了需要通过多层组件传递user属性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3e07361285e71348e12a4bbf71cc613/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946e76cd09d397fcc4f1953b7a87e6ab/" rel="bookmark">
			Android开发之Room数据库深入分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 Room是Android Jetpack组件的一部分，由Google推出，它是一个抽象层位于SQLite之上，用于更方便地访问和操作本地数据库。Room提供了编译时的检查来避免常见的运行时错误，并简化了数据库的迁移过程。通过使用Room, 开发者可以以更加直观和简洁的方式定义数据库模式和执行数据库操作。
二、原理 Room的核心原理是在应用程序和底层SQLite数据库之间提供一个中间层。这一层不仅处理对象到表的映射，还负责将查询转换为适当的SQL命令。Room在编译时生成这些转换后的代码，这样可以减少运行时的性能开销，并提供编译时的类型安全性检查。
2.1、工作流程 Room的工作流程大致如下：
2.1.1、定义数据模型 通过标注@Entity来定义数据表结构。
2.1.2、定义DAO接口 通过创建带有@Dao注解的接口来定义CRUD操作。
2.1.3、创建RoomDatabase实例 通过抽象类并继承RoomDatabase来创建数据库实例。
2.1.4、执行数据库操作 通过调用DAO接口的方法来执行实际的数据库操作。
三、优劣分析 3.1、优点 3.1.1、类型安全 Room利用Java/Kotlin的类型系统，避免了常见类型的错误，如语法错误或类型转换错误。
3.1.2、编译时检查 编译时会进行语法检查，减少运行时异常。
3.1.3、简化操作 相比于直接使用SQLite，Room提供了更高级的API，减少了样板代码。
3.1.4、生命周期感知 Room支持Android的生命周期，它允许开发者根据当前的生命周期状态来执行数据库操作。
3.1.5、LiveData集成 Room支持与LiveData结合使用，可以在数据改变时自动更新UI组件。
3.1.6、自动迁移 支持数据库版本管理和自动迁移，简化了应用升级过程中的数据库更改。
3.1.7、良好的社区支持 作为官方推荐的数据库方案，有大量的文档和社区资源可供参考。
3.2、缺点 3.2.1、学习曲线 对于新手来说，需要了解Room的注解和概念，有一定的学习成本。
3.2.2、性能考虑 虽然Room进行了优化，但在某些高性能需求场景下，直接使用SQLite可能更高效。
3.2.3、灵活性限制 对于复杂的查询和自定义SQL语句，Room可能不如直接使用SQLite灵活。
3.2.4、复杂性 对于简单的数据库操作，使用Room可能会显得有些过度复杂。
四、优化方案 4.1、合理使用Entity 尽量使Entity简单明了，避免包含过多的字段和方法。
4.2、优化Dao 尽量避免在Dao中进行复杂的计算和处理，而是将这些操作放在业务逻辑层进行。
4.3、使用批处理 对于大量的插入和更新操作，可以使用批处理来提高性能。
4.4、使用LiveData或Flow 观察数据变化并响应UI更新，保证数据的实时性。
4.5、异步操作 确保数据库操作在后台线程中执行，避免阻塞主线程。
4.6、合理设计实体和关系 根据业务需求合理设计表结构和关系，避免不必要的复杂查询。
4.7、利用Room的缓存策略 合理配置和使用查询缓存，提高查询效率。
4.8、代码分割 对于大型项目，可以将数据库操作代码分割到不同的模块，以提高项目可维护性。
4.9、合理使用事务 保证多个操作的原子性，提升数据库操作效率。
4.10、索引优化 在频繁查询的字段上添加索引，提高查询速度。
五、应用场景 5.1、本地数据存储 适用于需要存储用户数据、配置信息等本地数据的应用。
5.2、离线应用 对于需要在没有网络连接时仍然能够工作的应用，Room是一个很好的选择。
5.3、数据同步 可以配合网络请求，将远程数据同步到本地数据库中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946e76cd09d397fcc4f1953b7a87e6ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aa15b736f63cbc4fb1a21c14870e8f1/" rel="bookmark">
			Go 优雅判断 interface 是否为 nil
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 问题就在于下面这句话，文章也是有列出的：
即使接口持有的值为 nil，也不意味着接口本身为 nil。
但是在执行以下语句的时候，是有可能报 panic 的：
return reflect.ValueOf(x).IsNil() 而输出也是非常明显的指出错误：
panic: reflect: call of reflect.Value.IsNil on int Value 因为不可 nil 的 interface 是不能使用 reflect.Value.IsNil 方法。
那么问题就很好解决了。
解决方式 我们在执行 reflect.Value.IsNil 方法之前，进行一次判断是否为指针即可:
func IsNil(x interface{}) bool { if x == nil { return true } rv := reflect.ValueOf(x) return rv.Kind() == reflect.Ptr &amp;&amp; rv.IsNil() } 重点在于 rv.Kind() == reflect.Ptr &amp;&amp; rv.IsNil() 这段代码。
这段代码的作用：
判断 x 的类型是否为指针。
判断 x 的值是否真的为 nil。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2aa15b736f63cbc4fb1a21c14870e8f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32e84a398a455d9a2c6e2c62b4cb0e9e/" rel="bookmark">
			如何零基础入门Prometheus
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本公众号的精品教程《玩转Prometheus监控》是一套零基础的入门教程，基于多年实战经验编写而成，内容完整覆盖了产品的核心技术要点，适合想入门和进阶技术的朋友学习。
整个系列总共24篇课程，由基础知识开始，逐步进阶学习，到最终掌握高级用法，手把手教你玩转Prometheus。
目前，教程已得到了不少购买读者的正向反馈，这也从侧面验证了教程的内容质量，毕竟说再多也没有读者的口碑来得实在。
在教程的置顶文章页，我提供了售后支持的微信号。如果在学习过程中有遇到问题，可以找我进行一对一的答疑解惑。这是我为购买读者提供的额外福利，在市场上没有上千元的课程都难有这种待遇，因为我相信这样能够帮助到你更好地学好课程。
专栏原价128元，限时优惠价49.9元。如果有需要的朋友可以尽快入手，别错过优惠了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea27402cd8413bda2f664f3b2016735/" rel="bookmark">
			【数据结构】串的模式匹配（KMP&#43;朴素模式匹配）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2.串的模式匹配 什么是字符串的模式匹配？
在主串中找到与模式串相同的子串，并返回其所在位置。
模式串：要匹配的一串。注：子串是主串的一部分，一定在主串中存在，但模式串不一定在主串中找得到。 2.1 朴素模式匹配算法 思路
暴力求解，一个字符一个字符对比下去。
代码思路
1.给主串一个指针 i，模式串指针 j，两个指针都指向第一个字符；
2.若 i 和 j 所指字符相等，i+1，j+1；
3.若 i 和 j 所指字符不相同，j 回到模式串第一个字符，i 指向下一个子串起始位置；
4.若 j 超过模式串的长度，则匹配成功。
int Index(SString S,SString T){ int i=1,j=1; //分别扫描主串和模式串 while(i&lt;S.length &amp;&amp; j&lt;=T.length){ if(S.ch[i]==T.ch[j]){ i++;j++; //继续比较后继字符 } else{ i=i-j+2; //到下一个子串的起始位置 j=1; } } if(j&gt;T.length) return i-T.length; else return 0; } 时间复杂度
最坏情况：每个子串都要对比m个字符，共n-m+1个子串，复杂度= O ( ( n − m + 1 ) m ) = O ( n m ) O((n-m+1)m)=O(nm) O((n−m+1)m)=O(nm)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dea27402cd8413bda2f664f3b2016735/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/15/">«</a>
	<span class="pagination__item pagination__item--current">16/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/17/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>