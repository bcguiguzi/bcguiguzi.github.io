<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f13daf09ed3df76bee19d068ce854571/" rel="bookmark">
			Python练习代码-第十一章-字典练习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11.4.1 字符串转字典 正则,快速分割字符串为列表
map/eval 字符串转换
for循环条件简写
# 10.6.2/11.4.1 面包牛奶 import re # 字典创建 dict = {} str1 = "牛奶,面包,可乐,饼干,糖果,水果" str2 = "65,15,39,45,24,35.8" # 1.字符串分割成列表 正则法 list1 = re.findall("[^,]+", str1) list2 = re.findall("[^,]+", str2) # 2.eval转换为数据的实际类型 list21 = list(map(eval, list2)) # print(list1,list21) # 3. 字典赋值 for i, j in zip(list1, list21): dict[i] = j # 4. 字典修改 dict["可乐"] = 60 # 4. 字典值求和 sum = sum(x for x in dict.values()) print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f13daf09ed3df76bee19d068ce854571/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8341f5e238bab023fb9abe6d95246245/" rel="bookmark">
			Java基础知识笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、数据类型 1.基本数据类型 1.整数类型
byte
short
int
long 建议使用大写L
2.浮点类型
float
有限、离散、舍入误差、大约、接近但不等于
double
避免用浮点类型比较数值
BigDecimal 数学工具类
3.字符类型
char占2个字节 对应Unicode码
转义字符
4.布尔类型
boolean
只占一位，而且只有两个值true和false，常用语判断
5.类型转换
低--------------&gt;高
byte, short, char--&gt;int--&gt;long--&gt;float--&gt;double
运算中，不同类型的数据先转化为同一类型，然后进行运算。
1.强制类型转换 高 --&gt;低
int i = 128;
byte b = (byte) i;//导致内存溢出
2.自动类型转换 低 --&gt;高
int i = 128;
double d = i;
不能对布尔值进行转换。
不能把对象类型转换为不相干的类型。
在把高容量转换到低容量的时候，强制转换。
转换的时候可能存在内存溢出，或者精度问题。
2.变量类型 Java时一种强类型语言，每个变量都必须声明其类型。
Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域。
注意事项
每个变量都有类型，类型可以是基本类型，也可以是引用类型。
变量名必须是合法的标识符。
变量声明是一条完整的语句，因此每一个声明都必须以分号结束。
变量作用域
类变量 1.加关键字static；2.从属于类，随着类存在或消亡
实例变量 1.从属于对象；2.未初始化值，会给默认值(0、0.0、null、false)
局部变量 1.必须声明和初始化值；2.作用域在方法里面
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8341f5e238bab023fb9abe6d95246245/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62d1289ca847af079be3d80938c90b37/" rel="bookmark">
			负载均衡SLB介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概念 负载均衡SLB（Server Load Balancer）是一种对流量进行按需分发的服务，通过将流量分发到不同的后段服务器来扩展应用系统的吞吐能力，并且可以清楚系统中的单点故障，提升系统可用性 。
负载均衡的三种类型 根据不同场景，slb可分为：
1）专为面向7层（http/https）的应用型负载均衡ALB
alb具备处理复杂业务路由能力，与云原生服务深度集成，是云厂商提供的云原生ingress网关，支持http/https/http2/grpc等协议，单实例支持高达100万qps的处理能力。
2）专门基于4层（tcp/udp）的网络型负载均衡NLB
支持tcp、udp和tcpssl协议，单实例可达到1亿并发连接。
3）兼顾4层和7层的传统性负载均衡CLB
传统型（原负载均衡SLB）是将访问流量根据转发策略分发到后段多台云服务器的流量分发服务。通过设置虚拟服务地址，将添加的同一地域的多台云服务器虚拟成一个高性能和高可靠的后段服务池，并根据转发规则，将来自客户端的请求分发到后端服务池中的ecs上。
传统型负载均衡CLB 基础架构 实现原理：入网流量 实现原理：出网流量 CLB实例组成 公网型CLB和私网型CLB
CLB高可用实例 会话保持机制：
监控检测机制：
CLB监听转发/HTTPS重定向
CLB虚拟服务器组
CLB主备服务器组
CLB的SSL证书管理
针对https协议，提供证书管理。证书无需上传到后端ECS，解密处理在负载均衡上处理，降低后端ECS CPU开销。
CLB日志管理：
应用型负载均衡ALB 面向应用的负载均衡场景，具备复杂业务路由处理能力，与云原生服务深度集成，云原生ingress网关。
跨可用区负载均衡 ALB将流量跨可用区分发，可用区间建立实时业务容灾，某个可用区故障不影响其他可用区的流量转发。
网络型负载均衡NLB NLB单实例达到1亿并发连接。
SLB调度算法 SLB应用实践 云原生网络应用场景 跨地域网络应用场景 零售、金融弹性高可靠场景 集成DDOS、WAF，为业务安全提供保障。
音视频/游戏等大并发流量场景 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31469d76f2f0597e1063c1dac59f3c83/" rel="bookmark">
			通过 Systemd Journal 收集日志
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载：https://blog.csdn.net/weixin_30883271/article/details/97302209 随着 systemd 成了主流的 init 系统，systemd 的功能也在不断的增加，比如对系统日志的管理。Systemd 设计的日志系统好处多多，这里笔者就不再赘述了，本文笔者主要介绍 systemd journal 收集日志的三种方式：
程序使用 libc 库中的 syslog() 函数输出的日志使用 printf() 函数打印的日志任何服务进程输出到 STDOUT/STDERR 的所有内容 说明：本文的演示环境为 ubuntu 16.04。
syslog() 该函数的声明如下：
#include &lt;syslog.h&gt; void syslog(int priority, const char *message, ... /* argument */); 创建下面的 C 语言代码，并保存到文件 clog.c 文件中：
#include &lt;syslog.h&gt; int main(int argc, char *argv[]) { syslog(LOG_NOTICE, “C Hello World”); return 0; } 用下面的命令编译程序：
$ gcc -Wall clog.c -o clog 然后执行编译好的 clog 程序，就可以从 journal -f的输出中看到对应的日志：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31469d76f2f0597e1063c1dac59f3c83/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1aec20c57057c7261fd5c7718253079/" rel="bookmark">
			树莓派之交叉编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是交叉编译？ 答：交叉编译是指在一个平台上生成另一个平台上的可执行代码。
例子1：我们在windows上编写的c51代码，并编译成可执行代码，如xx.hex文件，是在c51上运行的，不是在windows运行的。
例子2：我们在ubuntu上面编写树莓派的代码，并编译成可执行代码，如a.out，是在树莓派上面运行的，不是在ubuntu linux上面运行的。
编译：在一个平台是生成该平台上的可执行代码。 c51交叉编译发送在keil(集成环境上面) 二、为什么要交叉编译？ 平台是不允许或不能够安装我们所需要的编译器比如C51
因为目的平台上的资源贫乏，无法运行我们所需要的编译器
树莓派是不是就不需要交叉编译？
答：错误。
树莓派有时又因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。操作系统也是代码，也要编译。
平台运行至少需要两样东西：BootLoader（启动引导代码）以及操作系统核心。
3.那么什么是宿主机(host)和目标机(target)呢？
答：宿主机：编辑和编译程序的平台，一般是基于X86的PC机。
目标机：用户开发的系统，通常都是非X86平台，宿主机编译得到的可执行的代码在目标机上运行。
三、交叉编译需要用到什么工具？ 交叉编译器、交叉编译工具链。
四、树莓派交叉编译工具链的安装 1.安装地址
2.压缩包下载好了后用共享文件夹的方式复制到linux下的虚拟机，FileZilla进行文件的传输也是可以的。
3.解压指令unzip
4.解压完进入到交叉编译工具链所在的路径
我们看到很多可执行文件（绿色），和软链接（蓝色），红框内的那个软链接就是我们要用到的。
5.在获得了交叉编译工具链的软链接之后，接下来就是环境变量的配置，它有两种方式进行配置，一是临时的环境变量的配置，二是永久有效的环境变量的配置。
6.echo $PATH查看环境变量。
无论环境变量多长只要到game:就好了。
export指令加入环境变量。复制第6点查看的环境变量到game:后面接入pwd当前的路径。
这样就完成了临时环境变量的配置，这样有点不好的就是，这只是仅限这个终端窗口而已，在另一个终端这个环境变量就失效了。
7.永久有效的环境变量的配置：
首先修改工作目录下的隐藏文件.bashrc
vi /home/my(这里的my是代表你的用户名)/.bashrc 进入该隐藏文件之后，在文件的末尾添加
export PATH=/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/my/lessonPI/tools-master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin
然后保存把并退出文件
如何加载配置文件：
使用 source /home/my(这里的my是代表你的用户名)/.bashrc 命令加载配置文件，马上生效配置。
五、交叉工具编译链的使用 对比gcc和arm-linux-gnueabihf-gcc编译后的不同，由图可知gcc可以编译后只能在电脑X86-64运行，而另一个方式编译可以在ARM下运行，并且它们都是可执行文件。
补充：file是用来查看文件属性。
检查交叉编译工具对不对：
arm-linux-gnueabihf-gcc -v
版本4.8.3
如何把编译生成的可执行文件下载到开发板：
scp clinentPi pi@192.168.1.78:/home/pi 指令 文件名 开发板用户名@开发板地址：开发板绝对路径 这样就完成了test_2的传输。
我们来运行一下，
运行也是ok的。
六、如何用带wiringpi库进行交叉编译 a.首先我们要明白在虚拟机上本来是没有wiringPi库的，所以当我们要在虚拟机上使用这个库的时候，我们要对这个库进行安装。
wiringPi库提取
提取码：2j5k
b.下载完把它安装在虚拟机里，在虚拟机解压。
我的共享文件夹名字在D盘的5G所以文件在/mnt/hgfs/5G目录底下
-rf:强制递归复制 -r:若给出的源文件是一个目录文件，此时将复制该目录底下所有的子目录和文件 -f:覆盖已经存在的目标文件而不给出提示 没有则错误提示cp: omitting directory（删除目录） c.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f1aec20c57057c7261fd5c7718253079/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1119754b647ef363686e4c15593d2e3/" rel="bookmark">
			关于 ChatGPT 必看论文推荐【附论文链接】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于 ChatGPT 必看论文推荐 2022年11月，OpenAI推出人工智能聊天原型 ChatGPT，再次赚足眼球，为AI界引发了类似AIGC让艺术家失业的大讨论。
ChatGPT 是一种专注于对话生成的语言模型。它能够根据用户的文本输入，产生相应的智能回答。这个回答可以是简短的词语，也可以是长篇大论。其中 GPT 是 Generative Pre-trained Transformer（生成型预训练模型）的缩写。
1 Transformer ChatGPT 使用的预训练模型 GPT，是在 Transformer 中的 decoder 基础上进行改造的。
Title：Attention Is All You Need
Abstract：The dominant sequence transduction models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder. The best performing models also connect the encoder and decoder through an attention mechanism. We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1119754b647ef363686e4c15593d2e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1f50b7ecb362df45b387b371e7cf3d3/" rel="bookmark">
			【C语言】产生一个随机数的方法的详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
rand()函数 RAND_MAX的解释
srand函数
time函数
time_t解析
小结：
具体实现代码：
在我们的日常敲代码的时候，偶尔会需要使用到产生一个随机数。
但是我们应该如何去生成一个随机数呢？
********在文章最后有随机数生成的具体代码，一个猜数字游戏。
rand()函数 其实，C的库函数中已经定义好了一个取随机数的函数。
那就是 int rand(void) 这个函数。
下面就是官方的解释：
我们从上往下看。
发现右上角有一个&lt;cstdlib&gt;这个符号，其实，这个就是在使用这个函数时需要引用的头文件。
不过这个是C++使用时的语法，在C中，引用的头文件为&lt;stdlib.h&gt;就行。
接下来，我们呢就看到了这一段。
RAND_MAX的解释 那么RAND_MAX是什么呢？
这里我们可以看到，其实RAND_MAX也就是一个数字，不过它是库函数中定义好了的一个常量
也就是32767，并且在使用它的时候也需要调用&lt;cstdlib&gt;这个头文件。
噢，那我们就知道了，那生成一个随机数还确实蛮方便，只要引用下头文件，然后使用rand函数就行了。真的是这样的么？
但我们还没看完这个解释。
我们接着往下看，就可以看到这一句话了。
srand函数 没想到了，我们在使用rand函数之前还必须得先使用srand这个函数。
那好吧，我们接着来看看srand这个函数了。
从文档中我们可以知道，srand函数的声明是：
void srand(unsigned int seed )
说明这个函数是没有返回值的，调用就行，它的参数是一个无符号整形。
并且在它的右上角也有一个&lt;cstdlib&gt;，那么它和rand函数一样，也需要引用&lt;stdlib.h&gt;这个头文件了
关键，就是下面这一句让人摸不着头脑了。
就是这句话：
其实看起来这么长的一段话，大概意思就是：
你想使用我这个srand函数，得先在我的参数里传一个随机数进来。
我们最原本就是想要产生一个随机数，到了你这里你却找我要随机数。
那我调用你干什么？
time函数 这里，又得使用到库函数中当中的另一个函数了，也就是time函数。
其实也就是一个时间戳，它就是一个一直在变化的数字。
时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。
这个函数的类型是time_t类型的，并且它的右上角有个&lt;ctime&gt;
在C中它需要引用的头文件也就是&lt;time.h&gt;这个头文件了。
它的返回值time_t也就是上面说到的时间戳了。
接着，我们看到这一段话：
具体意思就是：
这个函数将会返回一个时间戳。而且它里面的参数你可以也传一个时间戳函数进去，也可以啥都不传，只需要传一个NULL空指针就行。
注：最后，因为传回来的是一个时间戳，一般是一个很大的数字，如果你想产生一个指定范围内的数，可以利用 '%' 符号来实现。
如下：
小结： 在上面说了这么多，我们来简单总结一下，如何来使用rand函数来产生随机数。
需要使用到的函数：srand函数和time函数
需要引用的头文件：&lt;stdlib.h&gt;和&lt;time.h&gt;
最后，具体代码的实现： #define _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt; #include &lt;stdlib.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d1f50b7ecb362df45b387b371e7cf3d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7c08c7e5dc4775d378d14fef942758e/" rel="bookmark">
			2023荣耀校招机试（java&amp;python&amp;C&#43;&#43;）饭店楼层公共子序列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目描述 华华酒店因许多重复的饭店同时出现在一响装修美观，现需对1.2层的饭店进行管理。需找到两层之间都出现过，且出现顺序都一致的饭馆的个数。 例管理规则每一层用一个字符串表示。每间饭店用 (a-z”) 任意个字母表示，同层饭店的字母可能重复出现，不同层字母顺序不一致。现需找到两层之间都出现过，且出现顺序都一致的饭店的个数。例如:第一层拥有的饭店为“abcbdab”，为7间饭店，第二层拥有的饭店为“bcdbda”，为6间饭店。找到的结果应该为“bcbda”5间饭店。
输入描述 两个字符串，字符串长度均小于等于20
输出描述 最长的共有饭店的个数
用例 输入 abcbdab
bcdbda 输出5 思路 这是一个求解最长公共子序列（LCS）的问题，可以使用动态规划求解。
我们设 dp[i][j] 表示第一个字符串前 i 个字符和第二个字符串前 j 个字符的最长公共子序列长度，则有以下状态转移方程：
其中 s1和 s2 分别为两个字符串。
最终的答案即为 dp[m][n]，其中 m 和 n 分别为两个字符串的长度。
时间复杂度为 O(mn)，空间复杂度为 O(mn)。
题解代码 python s1 = input().strip() s2 = input().strip() m, n = len(s1), len(s2) dp = [[0] * (n+1) for _ in range(m+1)] for i in range(1, m+1): for j in range(1, n+1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) print(dp[m][n]) # abcbdab # bcdbda C++ #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int main() { // 读入两个字符串 string s1, s2; getline(cin, s1); getline(cin, s2); // 计算两个字符串的长度 int m = s1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7c08c7e5dc4775d378d14fef942758e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ace1073a4341d6484ec48ff53786db4/" rel="bookmark">
			C&#43;&#43;中String类find函数与string::npos的含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++中String类find函数与string::npos的含义 前言string::npos参数：find函数： 前言 问题：有两个字符串a、b, 现想判断a字符串是否包含b字符串，该如何设计程序？思路：此处需要用到string库中的find函数与npos参数。 string::npos参数： npos 是一个常数，用来表示不存在的位置，类型一般是std::container_type::size_type 许多容器都提供这个东西。
取值由实现决定，一般是-1，这样做，就不会存在移植的问题了。
find函数： find函数的返回值是整数，假如字符串存在包含关系，其返回值必定不等于npos，但如果字符串不存在包含关系，
那么返回值就一定是npos。所以不难想到用if判断语句来实现！
简单而言：如果存在包含关系find函数返回的就是主串与子串相匹配的下标，如果不存在包含关系就返回npos(一个常数，表示不存在)（s.find("abcdefg")==string::npos）
#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; int main() { vector&lt;string&gt; s; string temp; /*出现逗号 int count = 0;*/ while(cin&gt;&gt;temp){ /*出现逗号 if(temp.find(',') != string::npos) count++;*/ s.push_back(temp); if(cin.get() == '\n') break; } cout &lt;&lt; s.size(); /*出现逗号 cout &lt;&lt; s.size()+count;*/ return 0; } string s = "asdafsacfsaf"; cout &lt;&lt; string::npos &lt;&lt; endl; cout &lt;&lt; s.find('b'); 18446744073709551615 18446744073709551615 string s = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ace1073a4341d6484ec48ff53786db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6da158f9a60ec401a6b3e4211adc7aaa/" rel="bookmark">
			Mybatis源码解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mybatis源码解析 Mybatis源码解析 Mybatis源码编译测试案例源码分析 创建SqlSessionFactory创建SqlSession获取Mapper接口的实现类对象调用mapper接口的方法时的处理 Spring整合Mybatis 配置文件SqlSessionFactoryBean创建SqlSessionFactoryMapper的创建和管理 Mybatis源码解析 Mybatis源码编译 先要下载mybatis的源码包，从github下clone或者下载zip包，需要下载两个，分别是mybatis和mybatis-parent，下载mybatis-parent时要先看看mybatis指定的parent包的版本。先导入mybatis-parent，利用IDEA的MAVEN插件进行构建。然后在导入mybatis，同理。其实就像平常从git上clone一些maven项目下来一样，没什么不同。
最后如图：
测试案例 在mybatis-master包下新建一个module，然后pom.xml中引入依赖
&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;version&gt;3.3.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;span class="token tag"&gt;&lt;span class="token tag"&gt;&lt;span class="token punctuation"&gt;&amp;lt;&lt;/span&gt;artifactId&lt;/span&gt;&lt;span class="token punctuation"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;mybatis-test&lt;span class="token tag"&gt;&lt;span class="token tag"&gt;&lt;span class="token punctuation"&gt;&amp;lt;/&lt;/span&gt;artifactId&lt;/span&gt;&lt;span class="token punctuation"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span class="token tag"&gt;&lt;span class="token tag"&gt;&lt;span class="token punctuation"&gt;&amp;lt;&lt;/span&gt;dependencies&lt;/span&gt;&lt;span class="token punctuation"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span class="token tag"&gt;&lt;span class="token tag"&gt;&lt;span class="token punctuation"&gt;&amp;lt;&lt;/span&gt;dependency&lt;/span&gt;&lt;span class="token punctuation"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span class="token tag"&gt;&lt;span class="token tag"&gt;&lt;span class="token punctuation"&gt;&amp;lt;&lt;/span&gt;groupId&lt;/span&gt;&lt;span class="token punctuation"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6da158f9a60ec401a6b3e4211adc7aaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7679632a86e2359211b0d8db5445d8f7/" rel="bookmark">
			unity3D基础操作之01--unity3d窗口界面介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 最常使用5种窗口1、Scene场景编辑窗口2、Game游戏运行窗口需要注意的是 3、Hierarchy场景物体列表窗口4、Project项目资源列表窗口需要注意的是 5、Inspector属性编辑列表窗口6、其他常调节窗口 最常使用5种窗口 1、Scene场景编辑窗口；
2、Game游戏运行窗口；
3、Hierarchy场景物体列表窗口；
4、Project项目资源列表窗口；
5、Inspector属性编辑列表窗口；
6、其他常调节窗口
1、Scene场景编辑窗口 在屏幕左上方为场景编辑窗口Scene，在场景编辑窗口中，我们可以自由地漫游整个场景并选择物体对其进行编辑，此时如果按QWER四个键的时候可以看到画面的做上方选择菜单发生了变化，第一个手部图标代表可以拖动屏幕使屏幕进行移动；
第二个指针图标代表可以移动选择到的物体的位移；
第三个代表相对旋转；第四个代表改变物体的尺寸大小；
此时摁住鼠标右键滑动鼠标可以对镜头进行自由的旋转，同时摁ws可以对视频进行前后位移，AD可以对镜头进行左右位移，QE可以对视频进行上下位移；
2、Game游戏运行窗口 Game窗口可以理解为玩家所要看到的画面，也就是游戏运行时所呈现的画面，播放按钮是游戏播放，暂停按钮游戏暂停，再右边那个按钮代表播放游戏下一帧索要呈现的画面，再次单机播放按钮可以结束本次游戏运行；
需要注意的是 如果在游戏运行当中，我们最游戏中对游戏内元素进行修改，此次修改将不会存盘，也就是说此次修改只会在游戏运行当中所展现，游戏关闭时，所有物体属性将回归原始属性；
在游戏窗口的左上角可以调节游戏运行屏幕的长宽比freeaspect代表全屏显示，standalone代表所要发布版本的长宽比；
右边maximizeonplay代表游戏下一次运行时将全屏播放；
stats控制是否显示游戏运行时的各项参数，gizmos控制控制游戏是否显示游戏的各种标记，诸如光源、粒子效果的位置标记等。
3、Hierarchy场景物体列表窗口 在unity中所有场景内的物体都由列表方式展现在hierachy场景物体列表窗口当中，双击某个物体镜头将移动到某个物体处，我们可以里有搜索菜单来搜索关键字相应的物体，所有非所选物体将以灰色物体显示，在hierarchy中三角符号代表物体的父子关系；
4、Project项目资源列表窗口 在unity中所有项目资源都可以通过project项目资源窗口进行查看，它与文件夹显示内容是一致的，有所区别的是在文件夹中，unity会自动生成每个文件相对应的.meta文件；
需要注意的是 由于meta文件由unity自动生成，如果你想移动项目内的资源时请不要在窗口中移动而是在unity内部移动否则会报错；
上方favorites菜单可以用来查找特定类型的资源，我们也可以自己标记需要的资源点击星星可以创建一个自己的类型；
5、Inspector属性编辑列表窗口 unity中任何场景内的物体以及项目资源都可以在右侧inspector中进行相应的编辑不同属性的项目资源会有不同属性的编辑内容
6、其他常调节窗口 在unity右上角可以看到两个下拉菜单，左侧layers代表在在scene编辑窗口中可视的图层，右侧defaut下拉菜单则表示改变窗口显示的模式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c9eff3a794f9e88ad6d5cf02cdc00bf/" rel="bookmark">
			2022.4Kali数据源的更新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		sudo vim /etc/apt/sources.list（打开sources.list 文件）
官方源
deb http://http.kali.org/kali kali-rolling main non-free contrib
deb-src http://http.kali.org/kali kali-rolling main non-free contrib
中科大源
deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib
阿里云源
deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib
清华大学源
deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free
deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free
浙大源
deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free
deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0c9eff3a794f9e88ad6d5cf02cdc00bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/986ea2a39d979cbf214b30275e0344f7/" rel="bookmark">
			Logstash 配置文件中各种组件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记主要源自#雪山飞胡#
文章目录 Logstash 前言Input PluginStdinFileHTTPTCPBeats Codec PluginPlainJson&amp;Json_linesMultiline Filter PluginDateGrok自定义grok pattern DissectMutateJsonGeoip Output PluginStdoutFileElasticsearch 补充 Logstash 前言 Logstash主要由三部分组成：input、filter、output。而filter就是过滤器插件，这个组件可以不要，但是这样子就不能体现出logtash的强大过滤功能了。
input{ 输入插件 } filter{ 过滤器插件 } outer{ 输出插件 } Input Plugin Stdin 交互式输入数据
stdin{}从控制台输入 ：
input{ stdin{ codec=&gt;"plain" tags=&gt;["test"] type=&gt;"std" add_field=&gt;{"key"=&gt;"value"} } } output{ stdout{ codec=&gt;"rubydebug" } } codec类型为codec （请看下面Codec Plugin详解）type类型为string ,自定义该事件的类型,可用于后续判断tags类型为array ,自定义该事件的tag ,可用于后续判断add_field类型为hash ,为该事件添加字段 File 例 ：
input { file { path =&gt; ["文件路径"] start_position =&gt; "beginning" sincedb_path =&gt; "/dev/null" ignore_older =&gt; 0 } } 可选配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/986ea2a39d979cbf214b30275e0344f7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdb7c9a47fe0d7565dc4a9929e4cc5cd/" rel="bookmark">
			KALI的MSF使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先打开msf后，输入show evasion
使用use evasion/windows/process_herpaderping
打开如下图
打开后，输入show options进行参数的配置
可以看到 中间的LHOST本机IP地址的参数需要填写
可以新打开一个终端输入ifconfig进行本机IP地址的查看
完成！！！
如果想要放到服务器上，，就需要打开apache
将桌面的文件copy到apache即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae8af963b1e7a531db39af395284ac9/" rel="bookmark">
			Java使用Aop实现用户操作日志记录(新手入门)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		导入打印日志，aop，hutool，的依赖，Hutool是一个Java工具包，里面封装了大量的常用工具类，到时候咱们就通过这个工具包中有一个工具类可以用来获取客户端IP地址。 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.6.3&lt;/version&gt; &lt;/dependency&gt; 自定义操作类型枚举类 因为基本是增删改查四个方法 /** * 操作类型枚举类 * @author lichuan */ public enum OperationTypeEnum { /** * 新增操作 */ INSERT("新增"), /** * 修改操作 */ UPDATE("修改"), /** * 删除操作 */ DELETE("删除"), /** * 查询操作 */ QUERY("查询"), /** * 其它 */ OTHER("其它"); private String operationType; OperationTypeEnum(String operationType) { this.operationType = operationType; } public String getOperationType() { return operationType; } } 自定义用来记录用户操作日志的注解 @Target(ElementType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aae8af963b1e7a531db39af395284ac9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01500ad20bced6061c11bd36dff0cdfc/" rel="bookmark">
			java.lang.IllegalArgumentException: Invalid character found in method name [0x160x030x010x000xe10x01
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建出来的springboot项目出现java.lang.IllegalArgumentException报错，修改端口号启动还是默认的端口8080
我创建的是springboot 2.7.6版本,找了很长时间原来是 创建项目之后 原来application.properties我直接修改的后缀改成了yml，之前好像也直接修改过没有出现问题。可能跟创建版本有关，直接删除后又重新创建已解决。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18f48eb55fc5b75a35800bdf08b0f538/" rel="bookmark">
			关于Spring事件监听器是发布者线程调用（同步）还是线程池调用（异步）的探究
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、源码分析 Spring5.3.2 1、先看一哈发布事件demo主要类 //main启动类 public class Main { public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext("com.leon"); System.out.println(Thread.currentThread().getName() + "发布了TestEvent事件"); //发布TestEvent事件 context.publishEvent(new TestEvent(new TestView())); } } //自定义事件类 public class TestEvent extends ApplicationEvent { public TestEvent(Object source) { super(source); } } //一个数据视图类 @Data public class TestView { private String name = "leon"; private Integer age = 24; } //事件监听者 @Component public class Subscriber implements ApplicationListener&lt;TestEvent&gt; { @Override public void onApplicationEvent(TestEvent event) { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18f48eb55fc5b75a35800bdf08b0f538/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8796cf8575d5172c4cfb85fbb14b0ab1/" rel="bookmark">
			驱动程序开发：FTP服务器和OpenSSH的移植与搭建、以及一些笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、FTP服务器移植与搭建1、在ubuntu下安装vsftpd2、在window下安装FileZilla3、移植vsftpd到开发板上4、Filezilla 连接测试5、`注意点` 二、开发板 OpenSSH 移植与使用1、移植 zlib 库2、移植 openssl 库3、移植 openssh 库4、openssh 使用测试 三、关于u-boot上的操作及根文件系统下的脚本文件知识点1、bdinfo - 查看开发板的相关信息2、pri – 查看环境变量3、version – 查看uboot版本信息4、setenv name xxx； saveenv – 设置环境变量，并保存5、dhcp 用于从路由器获取 IP 地址6、uboot中的nfs命令格式如下所示：7、uboot中的tftp命令格式如下所示：8、查看当前开发板一共有几个 MMC 设备9、切换当前 MMC 设备10、查看 EMMC 的分区情况11、mmc write 命令烧写数据到SD设备或者EMMC中12、查询指定 MMC 设备分区的文件系统信息13、查询 FAT 格式设备的目录和文件信息14、查看 MMC 设备某个分区的文件系统格式16、fatwrite 命令17、通过tftp方式下载Linux镜像和设备树，然后通过bootz启动Linux系统18、使用命令 fatload 将 zImage 和 imx6ull-14x14-emmc-7-1024x600-c.dtb 从EMMC 的分区 1 中拷贝到 DRAM 中，启动 Linux 系统19、bootm命令20、 环境变量 bootargs21、USB WIFI启动22、开发板Linux启动方式23、关于根文件系统中/etc/init.d/rcS、 /etc/fstab、 /etc/inittab文件的知识点 一、FTP服务器移植与搭建 将 ALPHA 开发板作为一个小型的 FTP 服务器，这样我们就可以通过 FileZilla 软件直接在开发板和 windows 之间通过网络进行文件互传。而在开发板上搭建 FTP 服务器很简单，就是 vsftpd 的移植。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8796cf8575d5172c4cfb85fbb14b0ab1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/030555ffd57a1d06c92f5b6f7c7c6b49/" rel="bookmark">
			【无标题】LAS点云数据转DEM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		las数据转DEM,arcmap和pro都是可以转的，流程也是一样的，以arcmap举例来说：
第一步，创建LAS数据集，
直接在新建的数据集右键属性，将点云数据导入，
arcmap加载点云数据只有在一定比例尺下才可以展示出来，要不就是一个红框，
换比例尺下展示：
第二步，工具箱“LAS数据集转栅格”，可以设置要转的栅格的一些设置：
需要先在LAS工具集工具条上，有个过滤器上选择“地面”
只选择地面的点，
贴一张在pro加载点云数据的展示：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b05c4ebae7b585145f09fd4315894427/" rel="bookmark">
			Flutter热点问题修复
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Flutter热点问题修复 1、Exception: Unsupported Android Plugin version: 7.1.2. Flutter Android Studio 解决办法1 app/src/build.gradle
productFlavors { app_dev { dimension "version" applicationIdSuffix ".dev" } app_stg { signingConfig signingConfigs.debug dimension "version" applicationIdSuffix ".stg" } app_prod { signingConfig signingConfigs.release dimension "version" } } If it does have something like that, then you need to go to Run -&gt; Edit Configuration -&gt; Pick your main.dart on left side -&gt; Inside ‘Build flavor’ put “app_dev” inside the textbox (The string can be anything and it depends on what’s inside your productFlavors { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b05c4ebae7b585145f09fd4315894427/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/169/">«</a>
	<span class="pagination__item pagination__item--current">170/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/171/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>