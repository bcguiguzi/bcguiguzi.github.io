<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73997782d373c223f45fe97b5e7aeaac/" rel="bookmark">
			常用正则表达式大全！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		匹配中文字符的正则表达式： [u4e00-u9fa5] 评注：匹配中文还真是个头疼的事，有了这个表达式就好办了
匹配双字节字符(包括汉字在内)：[^x00-xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
匹配空白行的正则表达式：ns*r
评注：可以用来删除空白行
匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt;
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
匹配首尾空白字符的正则表达式：^s*|s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
评注：表单验证时很实用
匹配网址URL的正则表达式：[a-zA-z]+://[^s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用
匹配国内电话号码：d{3}-d{8}|d{4}-d{7}
评注：匹配形式如 0511-4405222 或 021-87888822
匹配腾讯QQ号：[1-9][0-9]{4,}
评注：腾讯QQ号从10000开始
匹配中国邮政编码：[1-9]d{5}(?!d)
评注：中国邮政编码为6位数字
匹配身份证：d{15}|d{18}
评注：中国的身份证为15位或18位
匹配ip地址：d+.d+.d+.d+
评注：提取ip地址时有用
匹配特定数字：
^[1-9]d*$　//匹配正整数
^-[1-9]d*$ //匹配负整数
^-?[1-9]d*$　//匹配整数
^[1-9]d*|0$　//匹配非负整数（正整数 + 0）
^-[1-9]d*|0$　//匹配非正整数（负整数 + 0）
^[1-9]d*.d*|0.d*[1-9]d*$　//匹配正浮点数
^-([1-9]d*.d*|0.d*[1-9]d*)$　//匹配负浮点数
^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　//匹配浮点数
^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　//匹配非负浮点数（正浮点数 + 0）
^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　//匹配非正浮点数（负浮点数 + 0）
评注：处理大量数据时有用，具体应用时注意修正
匹配特定字符串：
^[A-Za-z]+$　//匹配由26个英文字母组成的字符串
^[A-Z]+$　//匹配由26个英文字母的大写组成的字符串
^[a-z]+$　//匹配由26个英文字母的小写组成的字符串
^[A-Za-z0-9]+$　//匹配由数字和26个英文字母组成的字符串
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/73997782d373c223f45fe97b5e7aeaac/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1cb5e0b2fc2254bc62095cab359acff/" rel="bookmark">
			解决 ArrayList 的并发问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 场景复现1.1 数据不一致问题示例代码1.2 ConcurrentModificationException 问题示例代码 2. 解决并发的三种方法2.1 使用 Collections.synchronizedList2.2 使用 CopyOnWriteArrayList（推荐使用）2.3 使用显式的同步控制 3. 总结 ArrayList是java.util包中的一个类，它不是线程安全的。如果多个线程同时对同一个ArrayList进行操作，可能会导致并发问题，如数据不一致或ConcurrentModificationException异常。
1. 场景复现 1.1 数据不一致问题示例代码 import java.util.ArrayList; import java.util.List; public class ArrayListConcurrencyExample { public static void main(String[] args) { List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); // 创建并启动多个线程，同时向ArrayList添加元素 Runnable addTask = () -&gt; { for (int i = 0; i &lt; 1000; i++) { arrayList.add(i); } }; Thread thread1 = new Thread(addTask); Thread thread2 = new Thread(addTask); thread1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1cb5e0b2fc2254bc62095cab359acff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9b425338b1125ebf532ed07ccb8c1e/" rel="bookmark">
			小程序学习3 goods-card
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		pages/home/home home.wxml &lt;goods-list wr-class="goods-list-container" goodsList="{{goodsList}}" bind:click="goodListClickHandle" bind:addcart="goodListAddCartHandle" /&gt; &lt;goods-list&gt;是一个自定义组件，它具有以下属性和事件：
属性：
wr-class：用于设置组件容器的样式类名。goodsList：用于传递商品列表数据给组件。 事件：
click：当用户点击商品列表中的某个商品时触发该事件，可以通过绑定该事件来执行相应的处理函数。addcart：当用户点击商品列表中的添加购物车按钮时触发该事件，可以通过绑定该事件来执行相应的处理函数。 可以根据需要设置wr-class属性来自定义组件的样式，同时通过goodsList属性传递商品列表数据给组件。另外，你还可以绑定click事件和addcart事件来处理用户的点击操作。
home.json "usingComponents": { "goods-list": "/components/goods-list/index", } home.js import { fetchHome } from '../../services/home/home'; import { fetchGoodsList } from '../../services/good/fetchGoods'; import Toast from 'tdesign-miniprogram/toast/index'; Page({ data: { imgSrcs: [], tabList: [], goodsList: [], goodsListLoadStatus: 0, pageLoading: false, current: 1, autoplay: true, duration: '500', interval: 5000, navigation: { type: 'dots' }, swiperImageProps: { mode: 'scaleToFill' }, }, goodListPagination: { index: 0, num: 10, }, privateData: { tabIndex: 0, }, onShow() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c9b425338b1125ebf532ed07ccb8c1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796cdacea0f5d50f1fd4f78c6cc6b53a/" rel="bookmark">
			ElasticSearch之通过update_by_query和_reindex重建索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		写在前面 当我们索引的mapping，setting发生变更时，我们需要重建索引来使得这些变更生效。es提供了两种方式来完成重建索引的操作：
1:update by query,在本索引重建 2：reindex，在新索引上重建 我们通过具体实例来分别看下。
1：增加子字段 核心点，如果不执行update_by_query，修改mapping前将会无法查询到。执行update_by_query的方式如下：
POST {索引名称}/_update_by_query { } 具体实例(从上往下看即可):
# 1：创建索引，指定mapping DELETE blogs PUT blogs { "mappings": { "properties": { "content": { "type": "text" }, "keyword": { "type": "text" } } } } # 2：修改mapping前插入一条数据 PUT blogs/_doc/1 { "content": "Hadoop is coll", "keyword": "Hadoop" } # 3：修改mapping，增加子字段english PUT blogs/_mapping { "properties": { "content": { "type": "text", "fields": { "english": { "type": "text", "analyzer": "english" } } }, "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/796cdacea0f5d50f1fd4f78c6cc6b53a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e71892bbd19d5f2b30a7021e1f0b77a/" rel="bookmark">
			Java基础入门day14
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		day14 内容回顾 冒泡排序 public class BubbleSort{ ​ public static void main(String[] args){ int nums[] = {12, 33, 111, 35, 1}; ​ for(int i = 0; i &lt; nums.length -1; i++){ for(int j = 0; j &lt; nums.length - 1 - i; j++){ int te; if(nums[j] &gt; nums[j + 1]){ te = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = te; } } } ​ System.out.println("排序后："); ​ for(int i = 0; i &lt; nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e71892bbd19d5f2b30a7021e1f0b77a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d36c18abbf23fd8000f36dbfd42e600/" rel="bookmark">
			深入理解JavaScript中的JavaScript解释器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		JavaScript作为一种广泛应用的脚本语言，其内部的JavaScript解释器是其核心组成部分之一。理解JavaScript中的JavaScript解释器对于深入学习和使用JavaScript至关重要。本文将深入探讨JavaScript中的JavaScript解释器，包括其工作原理、优化技巧以及常见问题的解决方法。
一、JavaScript解释器是什么？ JavaScript解释器是一个能够解释和执行JavaScript代码的程序。它接收JavaScript代码作为输入，然后按照特定的规则执行这些代码，最终产生出相应的结果。JavaScript解释器通常分为两种类型：基于文本的解释器和基于字节码的解释器。基于文本的解释器直接解释并执行JavaScript源代码，而基于字节码的解释器会先将JavaScript源代码编译成字节码，再执行字节码。
二、JavaScript解释器的工作原理 JavaScript解释器通常分为词法分析器、语法分析器、解释器和执行器四个主要组成部分。首先，词法分析器会将JavaScript代码分割成一个个token，然后语法分析器会根据这些token生成抽象语法树（AST）。接着，解释器会遍历AST并执行其中的每个节点，最终得到执行结果。
三、JavaScript解释器的优化技巧 JIT编译：JavaScript解释器可以通过即时编译（Just-In-Time compilation）来提高性能。JIT编译器可以将频繁执行的JavaScript代码编译成机器码，从而减少解释器的开销。
内联缓存：内联缓存是一种优化技术，可用于加速属性访问和函数调用。通过记录已经访问过的属性和函数，避免重复查找，从而提高性能。
垃圾回收与内存管理：JavaScript解释器需要负责管理内存空间和进行垃圾回收，合理的内存管理对于提升性能和减少内存泄漏非常重要。
四、常见问题与解决方法 循环引用导致内存泄漏：当两个对象相互引用时，可能导致内存泄漏。解决方法是使用弱引用或手动解除引用。
缓慢的性能：可以通过优化算法、减少不必要的计算和使用更高效的数据结构来提高JavaScript代码的性能。
五、总结 JavaScript解释器在JavaScript开发中扮演着至关重要的角色，深入理解JavaScript解释器的工作原理和优化技巧可以帮助我们更好地利用JavaScript语言进行开发。通过不断学习和实践，我们可以有效解决JavaScript开发中遇到的各种问题，提高代码的性能和质量。
希望本文能够帮助读者更深入地了解JavaScript中的JavaScript解释器，为他们在日常开发中更好地应用JavaScript提供一些帮助和启发。感谢阅读！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9740070db76b1295d3e28d2b11de0b05/" rel="bookmark">
			如何查看CentOS系统是多少位?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS，中文意思是社区企业操作系统，是Linux发行版之一，是免费的、开源的、可以重新分发的开源操作系统。那么如何查看CentOS系统是多少位?以下是具体内容介绍。
uname命令用于显示系统信息。
uname可显示电脑以及操作系统的相关信息。
语法：uname [-amnrsv][--help][--version]
参数说明：
-a或-all 显示全部的信息
-m或--machine 显示电脑类型
-n或--nodename 显示在网络上的主机名称
-r或--release 显示操作系统的发行编号
-s或--sysname 显示操作系统名称
-V 显示操作系统的版本
--help 显示帮助
--version 显示版本信息
示例如下：
[rrot@localhost~]# uname -m
x86_64
[root@localhost ~] #
如果是x86_64那就是64位，如果i386那么就是32位。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0b6b9cb07605c8c6b9aec223073c01b4/" rel="bookmark">
			JavaScript作用域解释教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在JavaScript中，作用域是指变量在代码中可访问的范围。了解JavaScript作用域是非常重要的，因为它能帮助我们避免变量命名冲突、提高代码清晰度、优化性能等。
1. 全局作用域 全局作用域是指在所有函数外部定义的变量拥有的作用域。这些变量可以被任何函数访问，也可以在任何地方修改。如下示例：
var globalVar = 'I am a global variable'; function foo() { console.log(globalVar); // 输出：I am a global variable } foo(); 2. 函数作用域 函数作用域是指在函数内部定义的变量拥有的作用域。这些变量只能在函数内部进行访问，而外部无法直接访问。如下示例：
function bar() { var localVar = 'I am a local variable'; console.log(localVar); // 输出：I am a local variable } bar(); console.log(localVar); // Uncaught ReferenceError: localVar is not defined 3. 块级作用域 ES6引入了let和const关键字，使得JavaScript也支持块级作用域。在块级作用域中定义的变量只在当前块内有效。如下示例：
if (true) { let blockVar = 'I am a block-scoped variable'; console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0b6b9cb07605c8c6b9aec223073c01b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61a26aacd014f0db26c7592ab55e763b/" rel="bookmark">
			CTFWeb-BUUCTF竞赛真题WriteUp(1）_ctf no0b
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 BUUCTF （北京联合大学CTF）平台拥有大量免费的 CTF 比赛真题环境：
此处记录下部分 Web 题目练习过程。
No.1 极客挑战-Sql注入万能密码 1、先看看题目连接：
2、访问题目地址是个高大上的登录页面：
3、输入账号密码 admin/123456 提示账号密码错误：
4、输入账号密码 admin'/123456 报错，判断存在SQL注入：
5、尝试使用万能密码 admin' or 1=1#（用户名）+ 任意密码，成功拿到 flag：
【注意】此处在用户名处尝试使用万能密码时，仅有上述admin' or 1=1#格式有效，对于admin';--+、admin' or 1=1--+等格式均不好使，测试过程中应多尝试！
No.2 极客挑战-PHP伪协议利用 前面在 Bugku 也做了类似题目：CTF解题-Bugku_Web_WriteUp (上） 第16 题，回顾下核心知识点 ：
1、来看看题目：
2、访问题目地址：
3、查看网页源码，获得提示路径 ./Archive_room.php：
4、访问上述路径，新的页面有，个SELECT 按钮，可触发./action.php：
5、点击SELECT 按钮，啥也没，但发现 URL 是 end.php 而非预期的action.php ：
6、结合网页提示，返回上一页面，重新点击 SELECT 按钮并抓包观察，发现惊喜：
7、访问secr3t.php 获得 PHP 审计源码：
源码如下：
&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset="UTF-8"&gt; &lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data")){ echo "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/61a26aacd014f0db26c7592ab55e763b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab1ebdfd3bc409281e3d55ffac0f7a6/" rel="bookmark">
			android 怎么自定义view
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先了解view的绘制流程： 所以onmeasure ---测量view onlayout---确定view大小----》所以继承ViewGroup必须要重写onlayout，确定子view
而onDraw----是继承view时候需要操作的。
所以：自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件。
自定义View，一般是没有现成的view
序列化，大概有这个意思，不一定对。
自定义序列化： IOT
协议比如：物联网：蓝牙：传递的数据 串口 协议：
onmeasure的测量 是先从子布局开始还是先从父布局开始的？ ----根据算法来控制的，比如view pageer就是父布局开始
MeasureSpec是什么 public static class MeasureSpec { private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; /** @hide */ @IntDef({UNSPECIFIED, EXACTLY, AT_MOST}) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode {} ----是view里面的一个类---我们知道int 是32位
------上面代码里的30，就是高两位是00，后面30位---》所以这组成里MeasureSpec
-------高两位表示UNSPECIFIED，EXACTLY，AT_MOST
关于getChildMeasureSpec(int spec, int padding, int childDimension)算法 第一个参数，父亲给的，
第二个参数，父亲的
第三个参数，孩子需要的
-----》根据UNSPECIFIED，EXACTLY，AT_MOST来计算
public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab1ebdfd3bc409281e3d55ffac0f7a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/46c060ee84d6ddcbae27be13e76f4a09/" rel="bookmark">
			【数据结构】 Map和Set万字总结（搜索树&#43;哈希桶&#43;使用方法&#43;实现方法）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 Map和Set一、搜索树1.二叉搜索树的查找（search）2.二叉搜索树的插入3.二叉搜索树的删除4.性能分析 二、搜索方法1.概念 三、Map的使用1.概念：2.Map的常用方法：1.V put(K Key ,V Value )2.V get(Object key)3.V getOrDefault(Object key, V defaultValue)4.V remove(Object key)5.Set&lt;K&gt; keySet()6.Collection&lt;V&gt; values()7.Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()8.boolean containsKey(Object key)9.boolean containsValue(Object value) 3.Map的注意事项 四、Set的使用1.Set的常用方法：1.boolean add(E e)2.void clear()3.boolean contains(Object o)4.boolean remove(Object o)5.int size()6.boolean isEmpty()7.Object[] toArray()8.boolean containsAll(Collection&lt;?&gt; c)9.boolean addAll(Collection&lt;? extends E&gt; c)10.Iterator&lt;E&gt; iterator() 2.Set的注意事项： 五、哈希表1.概念2.哈希函数1.设计哈希函数：2.常见的哈希函数1.直接定址法（常用）：2.除留余数法（常用） 3.负载因子4.解决冲突1.闭散列法（开放地址法）1.线性探测法：冲突的时候，放到下一个空的位置2.二次探测： 2.开散列法（哈希桶） 5.HashBunk（哈希桶的实现）6.HashCode方法HashBunk(K,V)实现 3.TreeMap 和 HashMap 的区别：4.TreeSet 和 HashSet 的区别： Map和Set HashMap和HashSet的底层是一个哈希表
TreeMap 和TreeSet的底层是一棵搜索树（红黑树）
涉及到一些搜索查找的场景可以调用Map和Set接口
一、搜索树 二叉搜素树 （ 二叉排序树 )
1.要么是空树
2.如果左子树不为空，则左子树上所有节点的值都小于根节点的值
3.如果右子树不为空，则右子树上所有节点的值都大于根节点的值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/46c060ee84d6ddcbae27be13e76f4a09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca08a850927566bb9385c3710e460ea1/" rel="bookmark">
			牛客网 MYSQL进阶挑战 详细知识点总结（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言：
一 . 索引的创建删除 1.1创建索引：
图1-1
1.2查询索引：
图1-2 1.3删除索引 ：
1.4MySQL支持的索引类型及其对应的SQL语句：
二 . 聚合函数 2.1基本聚合函数：
2.2分组聚合函数：
2.3 过滤聚合函数：
三.分组查询 3.1group by 致谢:
前言： SQL 是结构化查询语言（Structured Query Language）的缩写，是用于管理和操作关系型数据库的标准语言。在现代的数据驱动世界中，掌握 SQL 进阶知识对于从事数据分析、数据工程、软件开发等领域的专业人士来说至关重要。SQL 进阶挑战可以帮助读者深入了解和掌握更高级的 SQL 技巧和功能。
掌握 SQL 进阶知识需要持续的学习和实践。读者应该保持耐心和坚持，在学习和实践过程中积累经验，并不断尝试解决各种数据处理问题。只有通过不断地学习和实践，才能真正掌握 SQL 进阶知识，并在实际工作中灵活运用。
一 . 索引的创建删除 1.1创建索引： create index index_name on table_name（column_name）;
如图1-1所示 图1-1 1.2查询索引： show index from table_name ;
如图1-2所示
图1-2 1.3删除索引 ： drop index from table_name;
如图1-3所示
图1-3
1.4MySQL支持的索引类型及其对应的SQL语句： B-Tree 索引：
创建索引：CREATE INDEX index_name ON table_name(column_name);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca08a850927566bb9385c3710e460ea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/58f1b5c39dbe567765fc7bd44e37e666/" rel="bookmark">
			【前言】神经网络与深度学习简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果您已经了解过神经网络与深度学习，请直接跳转到第一章学习
概念： 神经网络，一种基于生物启发式编程范式，它使计算机能够从观测数据中学习
深度学习，一套用于神经网络学习的强大技术集合
简介 神经网络和深度学习目前为图像识别、语音识别和自然语言处理等许多问题提供了最佳解决方案。这本书将教你许多神经网络和深度学习背后的核心概念。
神经网络是有史以来最漂亮的编程范式之一。在传统的编程方法中，我们告诉计算机该做什么，将大问题分解成许多小的、定义明确的任务，这些任务计算机可以轻松执行。相比之下，在神经网络中，我们不告诉计算机如何解决我们的问题。相反，它通过观察数据来学习，自己找出解决手头问题的方法。
从数据中自动学习听起来很有前景。然而，直到2006年我们才知道如何训练神经网络以超越更传统的方法，除了一些特殊问题之外。2006年发生的变化是发现了在所谓的深度神经网络中学习的技术。这些技术现在被称为深度学习。它们已进一步发展，如今深度神经网络和深度学习在许多计算机视觉、语音识别和自然语言处理等重要问题上取得了杰出的表现。像谷歌、微软和Facebook这样的公司正在大规模部署它们。
本系列教程的目的是帮助你掌握神经网络的核心概念，包括深度学习的现代技术。通过学习这个系列教程，你将编写使用神经网络和深度学习解决复杂模式识别问题的代码。并且你将有基础使用神经网络和深度学习来解决你自己设计的问题。
学习方法 这个教程的一个观点是，获得对神经网络和深度学习核心原理的扎实理解，比对过多的概念清单有模糊的认识要好。如果你很好地理解了核心思想，你就能迅速理解其他新材料。用编程语言来说，就像是掌握了一门新语言的核心语法、库和数据结构。你可能仍然只“知道”该语言的一小部分——许多语言都有庞大的标准库——但新的库和数据结构可以快速而容易地被理解。
这意味着这个教程绝不是教你如何使用某个特定神经网络库的教程。如果你主要想了解一个库，请不要看这个教程！找到你想学习的库，并通过官方的教程和文档进行学习。但要注意，虽然这具有立竿见影的解决问题的效果，如果你想真正理解神经网络中发生的事情，如果你希望你的知识在未来几年仍然有用，那么仅仅学习一些热门库是不够的。你需要理解关于神经网络工作方式的持久、长久的见解。技术来了又去，但洞察力永存。
动手实践的方法 我们将通过解决一个具体问题来学习神经网络和深度学习的核心原则：教计算机识别手写数字的问题。使用传统编程方法极难解决这个问题。然而，我们将看到，使用一个简单的神经网络，仅几十行代码，无需特殊库，就可以相当好地解决这个问题。更重要的是，我们将通过多次迭代改进程序，逐步融入越来越多关于神经网络和深度学习的核心思想。
这种动手实践的方法意味着你需要一些编程经验来阅读这本书。但你不需要是专业程序员。我用Python编写代码，即使你不用Python编程，只需一点努力也应该能够理解。在整本书的过程中，我们将开发一个小型的神经网络库，你可以使用它来进行实验和构建理解。所有的代码都将开源。一旦你读完这个教程，你就可以轻松地学习更完整的、用于生产的神经网络库。
此外，阅读这本书的数学要求是适度的。大多数章节都包含一些数学内容，但通常只是基本代数和函数图表，我期望大多数读者都能应付。偶尔我会使用更高级的数学，但我已经安排好材料，即使你无法理解一些数学细节也能跟上。唯一广泛使用较重数学的是第二章，需要一点多变量微积分和线性代数。如果这些对你不熟悉，我在第二章开始时讨论了如何应对这些数学内容。如果你发现真的很难理解，你可以直接跳到章节主要结果的总结。无论如何，一开始不需要担心这个。
很少有书籍同时追求原理导向和动手实践。但我相信，如果我们构建神经网络的基本思想，你将获得最佳学习效果。我们将开发活生生的代码，而不仅仅是抽象理论，你可以探索和扩展这些代码。这样，你将理解基础知识，无论是理论上还是实践上，并为进一步增加你的知识做好准备。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/367f1cb3bd8b8c11c93737b9da777036/" rel="bookmark">
			Python如何求1到n的和?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python语言中，提供了多种方法来计算1到n的和，其中包括循环求和、数学公式、递归求和等多种，接下来通过这篇文章为大家介绍一下各种方法的使用，快来学习吧!
1、循环求和
循环求和即通过for循环语句计算1到n之间的所有数字的和，如下所示：
sum=0
for i in rnage(1,n+1):
sum += i
print(sum)
2、使用数学公式
可以直接使用数学公式求出1到n的和，即n(n+1)/2，如下所示：
sum = n*(n+1)/2
print(int(sum))
3、递归求和
递归求和即通过自己调用函数本身来实现计算1到n之间的所有数字的和，如下所示：
def sum(n):
if n==1:
return 1
return n +sum(n-1)
print(sum(n))
4、Python内置函数
Python内置函数sum可以计算列表或元组中所有数字的和，因此可以通过创建一个包含1到n的数字列表，然后使用sum函数来求和，如下所示：
numbers =[i for i in range(1,n+1)]
print(sum(numbers))
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b2d0445e325a3d7bff4745be09ce1fb/" rel="bookmark">
			嵌入式自学多久可以找工作？应届生找嵌入式工作难吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&amp;nbsp;嵌入式自学多久可以找工作？应届生找嵌入式工作难吗？ 嵌入式不好学，但学好了很值钱。
基本要求：数字电路、模拟电路、C语言，这三门学好算是及格；需要掌握1-2种主流的MCU应用，如STM32；需要有动手能力，做过两个完整的项目。
在开始前我有一些资料，是我根据网友给的问题精心整理了一份「 嵌入式的资料从专业入门到高级教程」，
点个关注在评论区回复“888”之后私信回复“888”，全部无偿共享给大家！！！说实话，应届生应聘这个岗位，我会非常谨慎。如果在校期间没有做个几个像样的项目，基本上不会录用。即便如此，刚工作的新手，也不可能把重要任务交给他。嵌入式产品的原理实现，一般不太复杂，但是经验非常重要，大部分的硬件电路和软件程序是保障产品可靠性的，这些知识学校里学不到。
讲个故事，希望能对你有帮助：
我录用过一个同事，他的专业是医学护理，正常情况下，他毕业后是男护士。大一结束开始自学嵌入式，大概大二大三的时候，就可以给一些企业打零工了，经验还不错。大四在我这兼职，本来毕业就能入职，结果他研究生录取了；读研期间又兼职了三年，我们很想留住他，去年小伙读博士去了。
绝对的零基础，他就是真喜欢，爱钻研、很勤奋。大四的时候，与工作三五年的工程师水平不相上下。特别喜欢他，也特别怀念他。
不要被什么门槛吓到，如果你真喜欢，就没有问题。我自己就是兴趣驱动，参加工作的前两年，也是干些边边角角的工作，边工作边学习，争着抢着给老员工打下手，慢慢就有机会了。
总之，先确定自己喜欢不喜欢，兴趣、信心、做好吃苦的准备，其它都不是问题了。
以上，希望对你能有所帮助。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d549c1b9cb17143681dcbdbdcdd3e4ed/" rel="bookmark">
			idea找不到或无法加载主类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		博主希望能得到各位看官的支持！
一键三连
两块四块不嫌少，二十五十会更好，一键三连好人一生平安！
如何支持？ 前言 今天在运行项目的时候突然出了这样一个错误：IDEA 错误 找不到或无法加载主类,相信只要是用过IDEA的朋友都
遇到过它吧，但是每次遇到都是一顿焦头烂额、抓耳挠腮、急赤白咧！咋整呢？听我给你吹~
瞧我这张嘴~
问题报错 找不到或无法加载主类
问题截图 CSDN 有大佬是这样解决的：
错误：找不到或无法加载主类
猜测：
1，未能成功编译；
尝试：菜单—》Build—》Rebuild Prodject
结果：启动服务仍然报同样的错误
2，缓存问题；
尝试：菜单—》File—》Invalidate Caches/Restart 选择Invalidate and Restart 或者 只是Invalidate，清除掉缓存，然后 &gt;Rebuild Project
结果：启动成功，问题解决
虽然在网上找到很多相关的解决办法，但是问题的根本原因好像并没有被挖掘到，治标不治本，下次在遇到一样是
慌乱手脚,今天就给他来个追根溯源，刨根问底，永绝后患hiha
解决方案 一、file—&gt;Project Structure
二、点击Project Settings中的Moudles—&gt;点击减号将所有的Moudle删除
三、点击+号重新引入Moudle
四、找到项目的父文件夹中的pom文件—&gt;OK
五、Rebuild Project
完美解决
写在最后 导致此问题的原因可能不止于此，希望有不同意见的小伙伴在评论区讨（si）论（bi）！
原文链接：https://blog.csdn.net/l_mloveforever/article/details/112725753
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65fc29af70a2ee459b8dc5c7f6559581/" rel="bookmark">
			如何做好服务器安全防御？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		服务器安全是将服务器的软件和硬件保护起来,以防止黑客对服务器构架和数据进行未经授权的访问及操作。而且对于每个互联网公司而言，保护服务器安全都是非常重要的环节，因为服务器一旦遭受攻击将带来不可挽回的损失。那么服务器安全防御需要注意哪些方面?一起来看看吧。
1、部署网络防火墙：防止未经授权的访问和网络攻击。
2、部署入侵检测系统：检测并报告可能的入侵事件。
3、部署入侵防御系统：防止入侵攻击和保护系统免受攻击。
4、做好数据备份和恢复：保护数据不丢失，及时恢复数据。
5、部署加密技术：用于加密和解密敏感数据和通信。
6、设置访问控制：限制对系统和数据的访问。
7、设置身份验证和授权：确保只有授权用户才能访问系统和数据。
8、部署安全审计和监控：监视和记录系统和网络活动，以便识别异常行为。
9、漏洞管理：定期检查系统漏洞并进行修复。
10、病毒和恶意软件检测和清除：检测和清除病毒和恶意软件，以保护系统免受病毒和恶意软件攻击。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5c80e04c853ea0f887accc3e61b0fcb/" rel="bookmark">
			Python实现HTTP隧道穿透防火墙的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在网络安全领域，防火墙作为一种重要的安全设备，能够有效地阻止未经授权的访问和数据传输。然而，在某些情况下，我们可能需要穿透防火墙，实现内外网之间的通信。这时，HTTP隧道技术就派上了用场。Python作为一种功能强大的编程语言，非常适合用来实现HTTP隧道穿透防火墙。
HTTP隧道穿透防火墙的基本原理是利用HTTP协议的普遍性，将非HTTP数据封装在HTTP请求和响应中进行传输。由于大多数防火墙都允许HTTP流量通过，因此这种技术可以有效地绕过防火墙的限制。
在Python中，实现HTTP隧道穿透防火墙的步骤如下：
一、创建HTTP隧道服务器
首先，我们需要在内网中创建一个HTTP隧道服务器。这个服务器将负责监听特定的端口，接收来自外网的HTTP请求，并将请求中的数据转发给内网中的目标主机。同时，服务器还需要将目标主机的响应封装成HTTP响应，发送回外网。
二、创建HTTP隧道客户端
在外网中，我们需要创建一个HTTP隧道客户端。这个客户端将负责与目标服务器建立HTTP连接，并将需要发送给内网的数据封装成HTTP请求的格式发送给服务器。同时，客户端还需要接收服务器转发来的内网主机的响应。
三、数据封装与解析
在HTTP隧道中，数据的封装与解析是关键步骤。我们需要设计一种合理的协议，将原始数据转换为HTTP请求和响应可以携带的格式。这通常涉及到数据的编码、加密和压缩等操作，以确保数据的完整性和安全性。
四、处理连接与并发
为了提高通信效率，我们需要合理地处理连接和并发。这包括连接的管理和复用、并发请求的处理以及错误处理和重试机制等。
通过以上步骤，我们就可以利用Python实现HTTP隧道穿透防火墙。这种技术在实际应用中具有广泛的用途，如远程办公、内网穿透、数据备份等。然而，需要注意的是，穿透防火墙可能涉及到法律和道德问题，因此在使用该技术时应遵守相关法律法规和道德规范。
总之，Python实现HTTP隧道穿透防火墙是一种有效且实用的方法。通过合理利用Python的网络编程能力和HTTP隧道技术，我们可以轻松地实现内外网之间的通信，解决防火墙带来的限制问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab25f5eef3ada35e89b75e53f4fc9e31/" rel="bookmark">
			Python中的HTTP隧道技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python编程中，HTTP隧道技术是一种非常实用的网络通信手段，尤其在处理特殊网络环境下的数据传输问题时显得尤为重要。HTTP隧道技术的核心在于通过HTTP协议传输非HTTP数据，这样即使在网络限制较多或者网络环境不稳定的情况下，也可以确保数据的可靠传输。
HTTP隧道技术的实现主要依赖于Python强大的网络编程能力。Python提供了socket、http.client、urllib等丰富的网络编程库，这些库为构建HTTP隧道提供了强有力的支持。
在Python中构建HTTP隧道，通常涉及到两个主要部分：隧道服务器和隧道客户端。隧道服务器负责监听特定的端口，接收来自客户端的连接请求，并将客户端发送的数据封装成HTTP请求发送给目标服务器。隧道客户端则负责与目标服务器建立连接，将需要传输的数据发送给隧道服务器，并接收隧道服务器转发的来自目标服务器的响应。
在构建HTTP隧道时，数据的封装和解析是关键步骤。隧道服务器需要将客户端发送的原始数据转换为HTTP请求的格式，以便在网络中传输。同样地，隧道服务器还需要将接收到的HTTP响应解析回原始数据，然后发送给客户端。这个过程需要精确控制数据的格式和编码，以确保数据的完整性和准确性。
HTTP隧道技术的应用场景非常广泛。例如，在一些企业网络中，由于安全策略的限制，直接传输某些类型的数据可能会被阻止。通过搭建HTTP隧道，我们可以绕过这些限制，实现数据的可靠传输。此外，HTTP隧道还可以用于实现远程访问和控制，例如通过HTTP隧道访问内网资源或远程控制设备等。
当然，在使用HTTP隧道技术时，我们也需要注意一些安全问题。由于HTTP隧道允许传输任意类型的数据，因此可能会成为攻击者利用的漏洞。为了保障通信的安全性，我们需要采取一系列的安全措施，如数据加密、身份验证等。
总的来说，Python中的HTTP隧道技术是一种非常实用的网络通信手段。通过合理利用Python的网络编程库和HTTP隧道技术，我们可以解决各种复杂网络环境下的数据传输问题，实现数据的可靠和安全传输。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25944a0cc849760369917b9f9bff24e3/" rel="bookmark">
			Python网络编程：HTTP隧道技术详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python网络编程领域，HTTP隧道技术是一项非常重要的技术，它允许我们通过HTTP协议来传输非HTTP数据，从而绕过网络限制或增强数据传输的安全性。下面，我们将详细解析HTTP隧道技术的原理及其在Python中的实现。
一、HTTP隧道技术原理
HTTP隧道技术的核心思想是将非HTTP协议的数据封装在HTTP请求和响应中，通过HTTP代理服务器进行传输。这样，即使在网络环境对TCP流量进行严格限制或监控的情况下，我们也能实现数据的可靠传输。
HTTP隧道技术利用了HTTP协议的普遍性和灵活性。HTTP协议是一种基于请求-响应模型的协议，它允许在请求和响应中携带任意类型的数据。因此，我们可以将非HTTP协议的数据转换为HTTP请求和响应的格式，从而实现数据的传输。
二、Python实现HTTP隧道
在Python中，实现HTTP隧道需要用到socket编程和HTTP协议的相关知识。下面是一个简单的示例，展示了如何使用Python来创建一个基本的HTTP隧道。
首先，我们需要创建一个服务器，监听特定的端口，等待客户端的连接。当客户端连接后，服务器会创建一个新的socket连接，与目标服务器进行通信。然后，服务器会将客户端发送的数据封装成HTTP请求，发送给目标服务器；同时，服务器也会将目标服务器返回的HTTP响应解析成原始数据，发送给客户端。
在Python中，我们可以使用socket库来创建和管理socket连接，使用http.client库来发送和接收HTTP请求和响应。此外，我们还可以使用多线程或多进程来处理多个客户端的连接请求，提高服务器的并发性能。
三、注意事项
在使用HTTP隧道技术时，需要注意以下几点：
数据封装和解析的准确性：确保数据能够正确地被封装成HTTP请求和响应，并且能够准确地从HTTP请求和响应中解析出来。连接管理和复用：合理地管理和复用连接，避免频繁地建立和断开连接，以提高通信效率。错误处理和重试机制：在网络通信中，错误和异常是难以避免的。因此，我们需要实现一套完善的错误处理和重试机制，以确保数据传输的可靠性。 通过以上对HTTP隧道技术的详解，相信大家对这项技术有了更深入的了解。在Python网络编程中，掌握HTTP隧道技术将为我们提供更大的灵活性和便利性，帮助我们更好地应对各种网络环境和需求。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/14/">«</a>
	<span class="pagination__item pagination__item--current">15/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/16/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>