<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38449228a87b07958a47682629d30c12/" rel="bookmark">
			SqlAlchemy使用教程(五) ORM API 编程入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SqlAlchemy使用教程(一) 原理与环境搭建SqlAlchemy使用教程(二) 入门示例及编程步骤SqlAlchemy使用教程(三) CoreAPI访问与操作数据库详解SqlAlchemy使用教程(四) MetaData 与 SQL Express Language 的使用SqlAlchemy使用教程(五) ORM API 编程入门 前一章用SQL表达式(SQL Express)语法操作数据库时，仍然侧重于从Core API的角度来看 SQL表达式语言，主要目的是通过封装的SQL表达式来实现跨不同数据库目的。
本章主要介绍ORM API 基础知识、实现ORM CRUD 基础操作。我尽可能使用简洁的语言，配合实例代码，帮助你尽快上手。下一章将深入学习ORM API的主要方法、使用方式，以及较复杂需求的编程实现。
1、ORM 原理 在第1章介绍过ORM原理时。 Python类对象通过ORM与数据库Table进行映射，通过Python类对象的方式来操作数据库。开发人员无须再使用各类数据库的接口API，以及SQL语法。
注： ORM的理想很丰满，现实却是这样的：用好ORM还是需要扎实的SQL基础才能用好。
ORM如何实现从Python对象到数据库的映射呢?
这种映射结构可分为如下几层 Python Table类： 将 Database 的表结构 =&gt; 表示为 Python Metadata, 数据库字段 =&gt; Python Table类的属性(Column对象) Python Table 对象：数据的每行记录相当于1个Python类的实例对象(object)，多行用 `object 列表` 表示。数据库操作的ORM实现 插入1行数据，就相当于: 新建1个Python类实例对象，通过ORM插入数据库 通过ORM查询数据库，返回值为Python对象列表 2、ORM基础编程步骤 2.1 ORM API的使用步骤： 预备知识：
metadata:
上一章已详细介绍过，用于保存表结构, 通常1个应用定义1个全局metadata对象, 集中保存表结构。
declarative Table 声明式Table类
将数据库的表、字段，定义成Python类与属性的结构，这种结构称为声明式映射(Declarative Mapping)。Sqlalchemy2以后。table 类必须继承自 DeclarativeBase。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38449228a87b07958a47682629d30c12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20e9432b5b6b68e1cfd458d8dae8be24/" rel="bookmark">
			Transformer——位置编码（Positional embding）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		位置编码 为什么需要位置编码 Attention机制相较于RNN 以及LSTM 解决了以下两个问题：
长序列依赖问题并行计算问题 但是由于并行计算，原有的词向量失去了其在原有语句中的位置信息。为了解决这个问题，故提出了位置编码这个方案。
位置编码机制 位置编码机制的核心就是将位置信息添加到原有词向量之中！
那我们来看下位置编码是怎么将位置信息添加到词向量之中的：
原先无位置编码的做法是对输入Je 进行self-attention运算，得到N维词向量 x 1 x_1 x1​。引入位置编码之后，我们对位置信息也计算出一个N维位置词向量 t 1 t_1 t1​，输入词向量 x 1 x_1 x1​与位置词向量 t 1 t_1 t1​进行叠加，我们便能得到蕴含位置信息的词向量 X 1 X_1 X1​。
位置编码运算 公式：
P E ( p o s , 2 i ) = s i n ( p o s / 1000 0 2 i / d m o d e l ) PE(pos,2i)=sin(pos/10000^{2i/d_{model}}) PE(pos,2i)=sin(pos/100002i/dmodel​)
P E ( p o s , 2 i + 1 ) = c o s ( p o s / 1000 0 2 i / d m o d e l ) PE(pos,2i+1)=cos(pos/10000^{2i/d_{model}}) PE(pos,2i+1)=cos(pos/100002i/dmodel​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/20e9432b5b6b68e1cfd458d8dae8be24/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cf62ed3abb368ac4f89d4a998d1b3a8/" rel="bookmark">
			el-form-item使用自定义验证规则
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我这边逻辑是弹窗用户增加的分区容量总和不能超过仓库容量，具体逻辑根据项目调整
关键代码：
*1000 /1000
是为了避免 0.1+0.2!=0.3的问题
也有更好的解决方法，这里不是最优的 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c5bd510287d83836374f50cac894750/" rel="bookmark">
			注册函数回调函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、函数指针 函数指针：指向存放函数空间首地址的指针变量。
函数指针的定义方式为：
函数返回值类型 (* 指针变量名) (函数参数列表); 一般为了方便使用，我们会选择
typedef 函数返回值类型 (* 指针变量名) (函数参数列表); typedef的功能是定义新的类型。
// 函数指针 type int (*ptrFunc)(int,int); 第一句就是定义了一种 ptrFunc 的类型，并定义这种类型为指向某种函数的指针，这种函数以两个int为参数并返回int类型。后面就可以像使用int,char等变量类型名一样使用 ptrFunc 了。
二、回调函数和注册函数 简单来说，注册函数就是父函数，注册函数就是子函数。父函数可以指定某个子函数去执行。看代码如下：
这里我们写了4个回调函数，它们的函数签名跟我们之前定义的函数指针一致，但是完成的是不同的功能。下面写一个注册函数，函数的参数分别是ptrFunc类型的函数指针，以及两个int型的参数。通过这个函数指针，我们就可以将同一函数签名的4个回调函数交给注册函数使用，而后面两个int型参数，刚好给回调函数使用。
所以在main函数中有：
注册函数调用4种回调函数，输出结果如下：
三、c语言通过回调函数实现多态
同样是刚才的例子，我们要想完成这个输出的功能，直接在main函数中调用这4个计算函数不就好了吗？类似：
add(a, b); sub(a, b); ... 这样代码还少，还好理解，用注册函数register来调用那4个回调函数(add, sub, mul, div)似乎显得多次一举。
为了实现多态，我们可以把register的参数封装进结构体。修改如下：
首先在函数指针下创建一个结构体，结构体中的数据包括两个int和一个函数指针。这个函数指针，我们把它叫做函数管理器。
注册函数我们现在传入的不再是3个参数，而是打包了这三个参数的结构体：
当我们在主函数中调用的时候：
可以发现，虽然Register函数参数没变过，都是my_data：
Register(my_data);
但是通过改变函数管理器中的值，就可以改变 Register(my_data) 的输出。
这就实现了c语言的多态。
面向对象的多态的实现原理是一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f89496cc331f9b17f76f9cf234db386/" rel="bookmark">
			代码随想录算法训练营第十天|239. 滑动窗口最大值、347.前 K 个高频元素
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		239. 滑动窗口最大值 （一刷至少需要理解思路） 之前讲的都是栈的应用，这次该是队列的应用了。本题算比较有难度的，需要自己去构造单调队列，建议先看视频来理解。 题目链接/文章讲解/视频讲解：代码随想录
这道题的整体思路是建立一个自己的特殊队列，要求这个队列保证单调不增。这样每次求最大值的时候直接取队列的front元素就行。要注意一点，可能成为最大值的除了当前的最大值还有之后的值，故而当前窗口涉及的值中，如果后面的值更大，就不需要存储前面的值，反之却还是要存储后面的值的，因为前面的值更早会被pop掉，之后要从后面的值中考虑，在一个窗口中不是最大，要考虑可能在下一个窗口中成为最大，却不用考虑在当前窗口最大值之前的值，因为无论如何都不可能成为接下来的最大值了。具体要实现三个函数：pop()、push()、getvalue()。
首先要说明的是这道题使用的是deque来实现队列，而deque也是默认的队列实现方式，它是双向队列，可以在两头进行插入和删除。
pop函数要做的就是判断一下要pop的数值大小，如果比最大值（也就是队列的前端）小，那就证明已经在最大值入队的时候就已经被pop掉了，如果等于最大值才要真正地执行pop操作。
push函数要做的就是，将要push的值从队列尾部（最小值）依次比较，一直把比（要push的值）小的值全部pop掉，才会正式push进去。这样就保证留下的全是可能成为最大值的值。
这里整体主函数我只用了一次for循环，是使用if语句来实现为头一个窗口的队列初始化的。
class Solution { private: deque&lt;int&gt; que; void pop(int value){ if(que.size()&amp;&amp;value==que.front()) que.pop_front(); } void push(int value){ while(que.size()&amp;&amp;value&gt;que.back()) que.pop_back(); que.push_back(value); } int getvalue(){ return que.front(); } public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; res; for(int i=0;i&lt;nums.size();i++){ this-&gt;push(nums[i]); if(i-k&gt;=0) this-&gt;pop(nums[i-k]); if(i&gt;k-2) res.push_back(this-&gt;getvalue()); } return res; } }; 347.前 K 个高频元素 （一刷至少需要理解思路） 大/小顶堆的应用， 在C++中就是优先级队列。本题是 大数据中取前k值 的经典思路，了解想法之后，不算难。
题目链接/文章讲解/视频讲解：代码随想录
当然能想到哈希表来做，但是还是看文章有什么更好的做法。文章首先用map来储存次数，使用优先级队列来达到排序的效果，保证队列里面只保存当前遍历到的键值对中最大的k个，如果超过，就立马pop掉最小的那一个，因为pop掉的是队列头部元素，也就是堆顶，所以要使用最小堆来保证每次pop掉的一定是最小的。
值得一提的是，这里对运算符()进行重载，使用的最小堆，但是判断规则是左边的大于右边的值为true，文章里面提到了但没有细究，只推断是定义有关。
特别注意这几行代码：
// 小顶堆 class mycomparison { public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) { return lhs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f89496cc331f9b17f76f9cf234db386/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10c0d97bb9476a3b85378ddbe5a28795/" rel="bookmark">
			Unity之Cinemachine教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 Cinemachine是Unity引擎的一个高级相机系统，旨在简化和改善游戏中的相机管理。Cinemachine提供了一组强大而灵活的工具，可用于创建令人印象深刻的视觉效果，使开发人员能够更轻松地掌控游戏中的摄像机行为。
主要功能和特性包括：
1.虚拟摄像机系统： Cinemachine引入了虚拟摄像机的概念，允许开发人员使用相机组件的虚拟实例，而不必直接操作实际摄像机。
2.目标跟踪： Cinemachine能够自动跟踪和对焦游戏中的目标，使相机的运动更加平滑和自然。
3.多摄像机管理： Cinemachine能够管理多个摄像机，并根据优先级和条件自动切换它们，以实现更流畅的镜头过渡。
4.镜头切换： Cinemachine支持创建切换镜头的区域，以便在游戏中实现不同的视角和效果。
5.轨道系统： Cinemachine引入了轨道的概念，允许开发人员在3D空间中定义相机的运动路径，实现更复杂的镜头动画。
6.渐变效果： 提供了通过Impulse Listener实现相机渐变效果的功能，使相机对游戏中的事件有更生动的响应。
7.Timeline集成： Cinemachine与Unity的Timeline集成，使开发人员能够在时间轴上控制和调整相机动画。
8.高级功能： 提供了一系列高级功能，如自定义Rig Logic和State Driven Camera，使相机行为更加可定制。
使用Cinemachine，开发人员能够更容易地实现专业水准的相机工作，而不必亲自处理许多繁琐的细节。这使得游戏开发者能够专注于创造更引人入胜的游戏体验。
一.VirtualCamera Cinemachine为我们提供了VirtualCamera组件，让我们方便的控制相机。
我们场景中一般只需要一个MainCamera主相机，但是可以存在多个Virutal Camera，便于我们随时切换不同模块的相机状态。
1.CinemachineBrain 当我们创建了一个Virtual Camera后，我们会发现原来的MainCamera上多了一个组件CinemachineBrain，
Cinemachine Brain是Camera上的一个组件，相当于"大脑"，可以在每一帧来监控并计算场景中所有活动的Virtual Cameras的状态（位置，方向等），同步选择其他具有相同优先级的Virtual Cameras中或切换具有更高优先级的Virtual Camera甚至进行Virtual Cameras之间的混合（切换）
Brain的作用就是监听VirualCamera的梳理结果，然后实际控制Camera进行拍摄操作 。
2. Virtual Camera Solo：一种控制方式，用于在同一时间只激活一个轨道，而不是同时激活多个
Game Window Guides：Game窗口会显示辅助线
Save During Play：如果选中，运行中的虚拟相机属性可以被保存下来，退出Play状态不会被重置。
Priority：优先级，调整该虚拟相机的优先级。CinemachineBrain会根据这一项来选择LiveCamera同步到UnityCamera中。在Timeline中不生效该选项。
Follow： 设置虚拟相机想要跟随的目标（Body Target）
Look At：设置虚拟相机想要关注的目标（Aim Target）
Standby Update：当虚拟相机处于Standby状态时的更新方式。Never方式为不更新，Always方式为每一帧都更新，Round Robin为循环更新，将所有待命的虚拟相机按照优先级大小来进行每一帧的循环更新
Lens：设置该虚拟相机的Lens属性
Transitions：相机混合时的设置。
Body：配合Follow使用的参数设置
Aim：配合LookAt使用的参数设置
Noise：可以实现模拟相机抖动效果
二.其他相机 1.FreeLook Camer：适用于第三人称摄像机体验。允许玩家在三个不同的轴上自由旋转视角，提供了一种灵活的方式来调整和控制相机的行为。
2.BlendListCamera： 允许你在多个不同的虚拟摄像机之间进行平滑的混合。可以根据权重在不同的摄像机之间过渡，创造出无缝的过渡效果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10c0d97bb9476a3b85378ddbe5a28795/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47ede10921b8b27ec2efc68b8c5f12b9/" rel="bookmark">
			ubuntu 20.04 aarch64 平台交叉编译 libffi 库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于打算交叉编译 python，但是依赖 libffi 库，也就是 libffi 库也需要交叉编译
环境： ubuntu 20.04
交叉编译工具链：这里使用 musl libc 的 gcc 交叉编译工具链，aarch64-linux-musleabi-gcc，gcc 版本 gcc version 12.2.0
下载 libffi 库 这里直接通过 github 下载当前最新的 libffi 库
git clone https://github.com/libffi/libffi.git
下载后，进入 libffi，默认源码中没有 configure 脚本，可以直接运行 libffi 源码中的 autogen.sh 脚本，自动生成 configure 配置脚本
另外创建一个 libffi 库的 build 目录，可以放在 libffi 源码目录的外部，这样编译不会影响到 libffi 源码目录
这里在 libffi 目录外部创建一个新目录：build_libffi，然后进入 build_libffi，创建一个 编译 libffi 库的脚本 build_aarch64.sh
注意设置的 交叉编译工具链路径，交叉编译工具链的各个工具
#!/bin/bash cross_tool_path=/home/zhangsz/smart/gnu_tools/aarch64-linux-musleabi_for_x86_64-pc-linux-gnu/bin ../libffi/configure \ CC=${cross_tool_path}/aarch64-linux-musleabi-gcc \ CXX=${cross_tool_path}/aarch64-linux-musleabi-g++ \ AR=${cross_tool_path}/aarch64-linux-musleabi-ar \ LD=${cross_tool_path}/aarch64-linux-musleabi-ld \ READELF=${cross_tool_path}/aarch64-linux-musleabi-readelf \ --prefix=$PWD/_build\ --build=aarch64-linux-musleabi \ --host=aarch64-linux \ --target=aarch64-linux \ --enable-shared \ make make install 设置执行 权限 chmod 777 build_aarch64.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47ede10921b8b27ec2efc68b8c5f12b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb949c3bdde0913f91b851a527e43dde/" rel="bookmark">
			ubuntu 20.04 更新 autoconf 版本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 由于最近打算交叉编译 python，依赖 libffi 库，而交叉编译 libffi 库，由于使用的是 github 上的 libffi，又提示 autoconf 版本太低了，所以，先更新 autoconf 的版本
当前 ubuntu 20.04 上安装的 autuconf 版本号是： autoconf (GNU Autoconf) 2.69
zhangsz@zhangsz:~$ autoconf --version autoconf (GNU Autoconf) 2.69 Copyright (C) 2012 Free Software Foundation, Inc. License GPLv3+/Autoconf: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;, &lt;http://gnu.org/licenses/exceptions.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb949c3bdde0913f91b851a527e43dde/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cce13fd3904a69ae9bffcbc31e4651f/" rel="bookmark">
			Windows物理主机迁移至VMware ESXI服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 物理主机迁移至VMware ESXI服务器一、迁移环境二、迁移步骤１、主机A准备工作１、关闭主机A的防火墙２、主机A需要设置管理员密码３、主机A需要设置允许共享访问 ２、主机B操作步骤1、安装**VMware vCenter Convertaer Standalone**2、确保网络互通３、开启VMware vCenter Converter Standalone４、选择转换系统５、给主机A安装Agent代理６、填写VMware ESXI 服务器信息７、选择Ignore，忽略证书8、自定义服务器名称(建议使用英文命名) 三、报错解决１、agent安装报错解决步骤 物理主机迁移至VMware ESXI服务器 一、迁移环境 迁移环境需求：通过主机B将主机A迁移到 服务器C
二、迁移步骤 １、主机A准备工作 １、关闭主机A的防火墙 打开Windows安全中心→防火墙和网络保护→关闭防火墙
２、主机A需要设置管理员密码 打开计算机管理→本地用户和组→设置管理员账户的密码
３、主机A需要设置允许共享访问 打开控制面板→网络和 Internet→网络连接→选择已连接的网络
２、主机B操作步骤 1、安装VMware vCenter Convertaer Standalone ​ 下载地址:vCenter Converter: P2V Virtual Machine Converter | VMware | CN
​ 转换物理主机时，VMware vCenter Convertaer Standalone 会使用克隆和系统重新配置步骤创建和配置目标虚拟机，以便目标虚拟机能够在VMware vCenter ESXI环境中正常工作。由于该迁移过程对源而言为无损操作，此因，转换完成后可继续使用原始源计算机。也称为热克隆。
VMware Converter Standalone 组件只能安装在Window操作系统上，VMware Converter Standalone支持将Windows和Linux操作系统迁移到VMware vCenter ESXI服务器。
进行安装时，一直点击下一步即可
2、确保网络互通 主机B能否ping通主机A与服务器C，win键+R键输入cmd，打开命令行
ping 主机A-IP ping 服务器C-IP ３、开启VMware vCenter Converter Standalone 点击Conver gachine。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8cce13fd3904a69ae9bffcbc31e4651f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebeefeac6e4671fa5cd83ae282635350/" rel="bookmark">
			MongoDB集群搭建（三节点副本集）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		软件包安装 0、主机规划 IP地址访问端口10.0.0.2012701710.0.0.2022701810.0.0.20327019 1、MongoDB安装包下载 下载地址：https://www.mongodb.com/try/download/community
版本根据需求选择，Mongodb6.0及以上的版本没有mongo命令
2、上传至服务器，并添加环境变量 将下载的安装包mongodb-linux-x86_64-rhel70-6.0.5.tgz分别上传到三台服务器/root目录下 解压安装包到指定目录，在三台服务器分别执行该命令 tar xvf mongodb-linux-x86_64-rhel70-6.0.5.tgz -C /usr/local 修改文件夹名称，在三台服务器分别执行该命令 mv /usr/local/mongodb-linux-x86_64-rhel70-6.0.5 /usr/local/mongodb-6.0.5 添加环境变量，在三台服务器分别执行该命令 echo "export PATH=$PATH:/usr/local/mongodb-6.0.5/bin" &gt;&gt; /etc/profile 使环境变量生效，在三台服务器分别执行该命令 source /etc/profile 3、安装MongoDB依赖包 在三台服务器分别执行该命令
yum install -y libcurl openssl xz-libs 4、创建目录，创建各节点配置文件 创建目录，根据需求分别在三台服务器上创建目录 节点服务器1
mkdir -p /data/mongodb/node1/{data,log,config} 节点服务器2
mkdir -p /data/mongodb/node2/{data,log,config} 节点服务器3
mkdir -p /data/mongodb/node3/{data,log,config} 修改配置文件 节点服务器1
vi /data/mongodb/node1/config/node1.conf dbpath=/data/mongodb/node1/data #数据存放目录 logpath=/data/mongodb/node1/log/mongodb_node1.log #日志存放目录 pidfilepath=/data/mongodb/node1/data/node1.pid #指定文件保存mongod进程的进程ID fork=true #后台运行 logappend=true #以追加的方式记录日志 bind_ip=10.0.0.201 #绑定本机 ip port=27017 #mongodb端口 replSet=rs0 #副本集名称，同一个副本集，名称必须一致　节点服务器2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebeefeac6e4671fa5cd83ae282635350/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3011d4f160717db2f8718b27dc01d2e1/" rel="bookmark">
			PyG - torch_geometric官方文档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PyG Documentation — pytorch_geometric documentation (pytorch-geometric.readthedocs.io)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c31ab79f8beeed570e7c348776cf97d/" rel="bookmark">
			yakit：漏洞批量扫描神器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 以前想要批量扫描漏洞，基本都需要编写poc。虽然poc一般也不会很难写，但是也很耽误时间，并且编写poc也需要一定的技术门槛，对新手小白并不友好，这时使用yakit就会显得特别方便。
二、yakit使用 yakit在我看来是一个类似Burpsuite的工具，在某些方面甚至做的比Burpsuite还要更好。
1、Web Fuzzer这个模块很简单，类似于Burpsuite的Repeater功能。
2、在我们将POC放在Web Fuzzer中后，就可以右键插入临时字典，将想要批量的网站地址写入其中，它就会进行一个批量化的测试。
3、响应包处也会返回响应时间、状态、响应大小等一系列信息，帮助你判断是否存在漏洞，也可以进行查找或者正则匹配，非常好用。（注意：建议yakit使用管理员权限打开使用，我感觉不使用管理员权限会出现一些莫名其妙的问题）
4、同理，可以替换url进行目录扫描之类的工作也是可以的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02515042df3202ac595529ace6dc11fa/" rel="bookmark">
			vue生成二维码qrcodejs2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、安装
npm install qrcodejs2 2、页面使用
&lt;div id="qrCode" ref="qrCodeDiv"/&gt; &lt;script&gt; import QRCode from 'qrcodejs2' export default { data() { return { qrcode: null } }, methods: { // 生成二维码 creatQrcode(item) { if (this.qrcode) { this.qrcode.clear() } this.qrcode = new QRCode('qrcode', { text:item.code, // 二维码的内容 width: 128, height: 128, colorDark: 'transparent', colorLight:'#000'， correctLevel: QRCode.CorrectLevel.M // 容错级别 容错级别有：（1）QRCode.CorrectLevel.L （2）QRCode.CorrectLevel.M （3）QRCode.CorrectLevel.Q （4）QRCode.CorrectLevel.H }) this.qrcode._el.title = '' // 鼠标移入二维码会展示原生title，如果不需要就可以将title置为空 } } } &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0b621c0ab6b76f1b4d6f9c80133804/" rel="bookmark">
			el-input回车刷新页面问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 当el-input获取焦点后按到回车按钮会刷新当前页面
解决：
在`el-form`标签增加表单事件@submit.native.prevent,防止搜索框回车键刷新整个页面
&lt;!-- 搜索 --&gt; &lt;el-form v-show="showSearch" ref="queryForm" :model="dialogParams" :inline="true" label-width="100px" @submit.native.prevent style="margin-bottom: -20px"&gt; &lt;el-form-item label="标签码：" label-width="100px"&gt; &lt;el-input v-model="dialogParams.code" placeholder="请输入标签码" clearable size="small"/&gt; &lt;/el-form-item&gt; &lt;el-form-item style="float: right"&gt; &lt;el-button type="primary" icon="el-icon-search" size="mini" @click="handleQuery2"&gt;搜索&lt;/el-button&gt; &lt;el-button icon="el-icon-refresh" size="mini" @click="resetQuery2"&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3d02b3d568fe096d35fc0a6c7ba8404/" rel="bookmark">
			c&#43;&#43;中STL的vector简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 vector构造函数 vector()拷贝构造 vector()析构函数 ~vector()iterator 的定义begin()与const版本end()与const版本增删改查尾插push_back()尾删pop_back()指定位置插入insert()指定位置删除 erase() operator[]与const版本容量增容reserve()设置容量 resize() 成员函数swap()size()capacity()empty()clear()front()back() 迭代器失效问题 vector 构造函数 vector() 因为给了缺省值所以这里拷贝构造为空
iterator 是迭代器
vector() { } private: iterator _str = nullptr;//首个元素的地址 iterator _size = nullptr;//尾元素的地址 iterator _capacity = nullptr;//容量 拷贝构造 vector() 三种拷贝构造
1、正常的拷贝构造
2、拷贝一个区间
3、简结写法
vector(int n, const T&amp; val = T())//正常的拷贝构造 :_str(nullptr) , _size(nullptr) , _capacity(nullptr) { reserve(n); for (size_t i = 0; i &lt; n; i++) { push_back(val); } } template &lt;class InputIterator&gt; vector(InputIterator str, InputIterator size)//拷贝区间 { while (str !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3d02b3d568fe096d35fc0a6c7ba8404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db6abc3649867c2567f4b0bed4ce5f6d/" rel="bookmark">
			Python 调用STK接口的常用操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		和Python如何调用STK接口编程-CSDN博客这里说的一样，STK Help文档里面其实有讲，但也有不少坑。所以这边整理了一些对Satellite, Target, Aircraft等对象的基本操作：
生成STK场景：
import pymysql import win32com from win32com.client import GetActiveObject import comtypes from comtypes.client import CreateObject from comtypes.gen import STKUtil from comtypes.gen import STKObjects from comtypes.gen import AgSTKGraphicsLib from comtypes.gen import AgSTKVgtLib from comtypes.gen import AgUiApplicationLib from comtypes.gen import AgUiCoreLib from comtypes.gen import stdole from comtypes.gen import STKObjects class STKWindow: def __init__(self,flag=False): if flag==True: self.uiApplication = win32com.client.Dispatch('STK11.Application') self.uiApplication.Visible = True self.uiApplication = CreateObject('STK11.Application') self.uiApplication.Visible = True # Get our IAgStkObjectRoot interface self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db6abc3649867c2567f4b0bed4ce5f6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f61a674175c0b1b41bd85801107fa2/" rel="bookmark">
			Windows 11 version 23H2 中文版、英文版 (x64、ARM64) 下载 (updated Jan 2024)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows 11 version 23H2 中文版、英文版 (x64、ARM64) 下载 (updated Jan 2024)
Windows 11, version 23H2，2024 年 1 月更新
请访问原文链接：https://sysin.org/blog/windows-11/，查看最新版。原创作品，转载请保留出处。
作者主页：sysin.org
Windows 11 目前版本
所有的日期都按照 ISO 8601 格式列出：YYYY-MM-DD)
服务频道
版本服务选项上市日期最后修订日期最新版本服务终止：家庭版、专业版、专业教育版和专业工作站版服务终止：企业、教育、IoT 企业版和企业多会话23H2正式发布频道2023-10-312023-10-3122631.xxxx2025-11-112026-11-1022H2正式发布频道2022-09-202023-10-2622621.xxxx2024-10-082025-10-1421H2正式发布频道2021-10-042023-10-1022000.2538服务终止2024-10-08 全新推出 Windows 11 全新 Windows 体验，让您与热爱的人和事物离得更近。
获得全新视角 Windows 11 提供一个让人平静而富有创意的空间，全新体验引导您全力追逐热爱。从焕然一新的开始菜单，到与您关心的人、关注的消息、游戏和内容建立连接的新方式 (sysin)，Windows 11 提供了一个场所，让您得以自由地思索、表达和创造。
最大化生产力 利用贴靠布局等工具、桌面以及更为直观的全新体验轻松访问所有应用以及进行多任务处理。
新的连接方式 使用 Microsoft Teams，直接从桌面即可立即连接到您想要联系的人。免费通话或聊天 — 无论对方使用什么设备。
您的内容，您来组织 借助 Microsoft Edge 和可选择使用的众多小组件，您可以快速及时地了解您最关心的资讯、信息和娱乐内容。在新版 Microsoft Store 中轻松找到您所需的应用和爱看的节目。
游戏时间，随时随地 全新 Windows 提供出色的游戏体验，可畅玩众多游戏大作。
不一定适合每个人的电脑 全新 Windows 可在相当广泛的设备上运行 (sysin)，同时我们的合作伙伴也在致力于在触控功能、触控笔和语音等方面为您带来创新技术，让您轻松找到对您而言理想而又经济实惠的设备。
找到适合您的电脑
现在需要新电脑？这里是当 Windows 11 推出时可以免费升级的一些 Windows 10 电脑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f61a674175c0b1b41bd85801107fa2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb817788df335b9b393049a8835056c3/" rel="bookmark">
			Tomcat靶机渗透
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Apache Tomcat，是世界上最广泛使用的Java Web服务器之一。带有默认配置的Tomcat服务器非常容易发现。发现暴露Web应用管理器的服务器也非常容易，它是一个应用，允许管理员启动、停止、添加和删除服务器中的应用。
信息搜集 第一步：启动主机并进行
1、查看tomcat靶机IP地址、扫描地址所开放端口
arp-scan -l
192.168.245.248
nmap -T4 -A -v 192.168.245.248
得到，此网站应用的是Apache Tomcat/9.0.31
普及：
Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。
Tomcat的目录结构
/bin #二进制文件
startup.bat #启动tomcat服务
shutdown.bat #关闭tomcat服务
/conf #配置文件
sever.xml #定义了tomcat启动时涉及的组件属性
tomcat-users.xml #tomcat的用户密码和权限
web.xml #定义servlet
/lib #存放全局的jar包
/logs #日志
/temp #临时文件
/webapps #存放JAVA的WEB项目
/manager #后台登录界面
/ROOT #根目录
/work #存放jsp编译后产生的class文件
2、根据网页进行web爬行后台登陆界面
dirb http://192.168.245.248:8080/
3、访问管理登陆界面
查询资料可知，tomcat默认管理员用户名为tomcat
4、通过burp suite进行抓包破解密码
选择爆破的方式为Sniper并将Basic后面那串base64加密的账号密码Add$：
这串内容了解到是base64加密：BASE64加密解密
这里为突破口
Payloads设定为选择：Custom iterator
Custom iterator这里是指相当于把一条爆破语句拆成三个部分：账号:密码
第一部分加载用户字典，第二部分输入英文符号: ,第三部分加载密码字典
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb817788df335b9b393049a8835056c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97a7ce0fe08dabc5e25f877abbb4f7af/" rel="bookmark">
			Java语言第七篇网络编程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网络编程 网络编程IP地址端口协议UDP通信程序TCP通信程序服务器端优化NIO 网络编程 网络编程:在网络通信协议下，不同计算机上运行的程序，可以进行数据传输
网络编程三要素
IP地址:设备在网络中的地址，是唯一的标识。是分配给上网设备的数字标签。
端口:应用程序在设备中唯一的标识。
协议:数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。
IP地址 常用命令：
⚫ ipconfig：查看本机IP地址
⚫ ping IP地址：检查网络是否连通
特殊IP地址：
⚫ 127.0.0.1：是回送地址也称本地回环地址，可以代表本机的IP地址，一般用来测试使用
加一个ipv4的分类,需要讲A-E,IP组成为:网络号 + 主机号广域网 城域网 局域网最大的广域网是因特网
添加组播地址,广播地址
InetAddress 的使用:此类表示Internet协议（IP）地址
static InetAddress getByName(String host) 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 String getHostName() 获取此IP地址的主机名 String getHostAddress() 返回文本显示中的IP地址字符串 端口 端口：应用程序在设备中唯一的标识。
端口号：用两个字节表示的整数，它的取值范围是065535。其中01023之间的端口号用于一些知名的网络服务或者应用。我们自己使用1024以上的端口号就可以了。注意：一个端口号只能被一个应用程序使用。
协议 协议：计算机网络中，连接和通信的规则被称为网络通信协议
UDP协议
⚫ 用户数据报协议(User Datagram Protocol)
⚫ UDP是面向无连接通信协议。速度快，有大小限制一次最多发送64K，数据不安全，易丢失数据。
TCP协议
⚫ 传输控制协议 (Transmission Control Protocol)
⚫ TCP协议是面向连接的通信协议。速度慢，没有大小限制，数据安全。
UDP通信程序 UDP发送数据
创建发送端的DatagramSocket对象创建数据，并把数据打包(DatagramPacket)调用DatagramSocket对象的方法发送数据释放资源 UDP接收数据
创建接收端的DatagramSocket对象创建一个箱子，用于接收数据调用DatagramSocket的方法接收数据并将数据放入箱子中解析数据包，并把数据在控制台显示释放资源 UDP的三种通信方式
⚫ 单播
⚫ 组播
⚫ 广播
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97a7ce0fe08dabc5e25f877abbb4f7af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afc309e1d01e27807efb1e6a87054793/" rel="bookmark">
			odoo17基础培训1-odoo开发基础知识准备以及odoo17开发环境安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		odoo17基础培训 一、odoo开发基础知识准备以及odoo17开发环境安装 1、odoo是什么？ 当我介绍客户使用odoo系统作为业务管理平台时，有时会被问到Odoo是什么？
简单点，可以这么说： Odoo是一套完整的系统，是一个开源框架，针对 ERP 的需求发展而来，适合定制出符合客户各种需求的ERP系统、电子商务系统、CMS、或者是网站。
由于 Odoo 的底层结构很强大，所有模块都可以根据需要进行安装和御载，所以客户能够像搭积木一样建构自己期望的系统。即使完全不安装与ERP相关的模块，仅利用 Odoo 自身的底层框架，也能构建出适合各种用途的系统，纯 B/S 架构。而这一切都是免费的，并且不受限于源代码，也不受于用户数。
Odoo 是一系列开源商业应用程序套装，此套装可以满足公司的绝大部分应用需求，例如，基本的进销存管理、采购、销售、MRP生产制造、质量管理、HR、休假管理、用车管理、IM通讯、CRM客户关系管理、电子商务、网站，财务会计、资产管理、WMS仓库管理、POS连锁、项目管理、条码、PLM等等。
https://zhuanlan.zhihu.com/p/388748782
2、学习odoo需要的基础知识 2.1、后端：python 编程语言排行榜：https://hellogithub.com/report/tiobe/
python特点：
1、语法简单,容易上手
2、第三方库众多
人生苦短、我用python
官网： https://www.python.org/
学习资料：https://www.runoob.com/python/python-tutorial.html
2.2、前端：html、css、JavaScript 学习资料推荐： 菜鸟教程https://www.runoob.com/
B站视频：pink老师的视频 https://www.bilibili.com/video/BV14J4114768/?spm_id_from=333.337.search-card.all.click&amp;vd_source=42b07826977d09765ec11b9fa06715e5
建议： 先掌握概念和框架，不要太过于重视细节，对编程而言，思路更重要。
切忌： 买大块头书，深入去研究。 等到用的时候，又忘了。
好读书，不求甚解，等到真正用的时候再去深入学习。
边学边做，边做边学，这是掌握一门技术最快的方法。
3、开发工具 下面这两款都是非常优秀的集成开发工具，选择任何一个都可以。
pycharm： 专业的python开发工具，社区版够用了。缺点是本身用java开发的，比较费资源。如果机器性能不好，可能运行比较慢。
vscode： 微软开发的轻量的集成开发工具，通过插件可以支持多钟语言开发，前端开发利器。 也有很多人用来做odoo开发。相对pycharm占用资源较少。
4、开发环境搭建 4.1 下载并安装postgres数据库 下载地址：https://www.enterprisedb.com/downloads/postgres-postgresql-downloads
一般下载次新版， 我们选择15.5的版本。
安装过程中需要设置postgres用户密码，这是pg的超级用户，跟sqlserver的sa类似。
odoo不允许用超级用户postgres连接数据库，所有我们需要创建一个新的数据库账户odoo。
打开pgadmin4， 新建用户，
输入用户名
输入密码
赋予权限，注意要给superuser权限，因为需要使用odoo这个账户创建数据库。
也可以通过命令行来创建
create user odoo with password 'odoo'; alter role odoo with superuser; 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/afc309e1d01e27807efb1e6a87054793/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/71/">«</a>
	<span class="pagination__item pagination__item--current">72/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/73/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>