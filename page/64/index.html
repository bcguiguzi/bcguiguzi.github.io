<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6fdb612a6ca02fbcd233843a411cf78/" rel="bookmark">
			快速搞懂时间序列数据平稳检验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在对时间序列数据进行分析预测时，平稳时间序列数据预测效果更好。所以首先要检测数据是否平稳，没有趋势的时间序列数据，我们称为平稳的，即随着时间的推移，表现出恒定的方差，具有恒定的自相关结构。本文介绍如何检测数据集是否平稳的方法，并给出实战过程代码。常用的检测方法有KPSS，Phillips–Perron,
和 Augmented Dickey-Fuller，本文主要介绍ADF检测。
单位根检验 在时间序列分析中，单位根检验是检验时间序列是否不平稳，是否由单位根组成。时间序列中单位根的存在定义了零假设，备择假设定义了时间序列是平稳的。单位根检验的数学公式可表示为：
y t = D t + z t + ɛ t y_t = D_t + z_t + ɛ_t yt​=Dt​+zt​+ɛt​
D t D_t Dt​ 是决定性成分 Z t Z_t Zt​ 是随机成分 ɛ t ɛ_t ɛt​ 是平稳的误差处理 单位根检验的基本概念是确定 z t z_t zt​(随机分量)是否由单位根组成。
ADF检验简要说明 ADF(Augmented Dickey-Fuller) 检验是一种检验时间序列数据是否平稳的方法。ADF是统计显著性检验，包括零假设和备择假设分别为：
H0
时间序列不是平稳的，换句话说，它有一些随时间变化的结构，随时间推移没有恒定的方差。
H1
时间序列是平稳的。
如果测试的P值小于显著性水平（假设为 .α = .05)，那么我们能拒绝零假设，得出结论时间序列是平稳的。下面通过示例进行说明。
Python实现ADF检验 假设我们有下面测试数据：
data = [3, 4, 4, 5, 6, 7, 6, 6, 7, 8, 9, 12, 10] 在检验之前，我们先对数据进行可视化，展示数据的分布情况。下面代码可视化数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6fdb612a6ca02fbcd233843a411cf78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df7b8a9b7c2743a5c87d29b669137686/" rel="bookmark">
			win7安装anaconda3实现yolov5环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：下载并安装 anaconda3 因为win7下的python版本最高支持到3.8.10，所以要下载对应版本，不能高于这个。
参考博主：
解决win7 anaconda 安装 Failed to create menus-CSDN博客
下载源：
Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror
下载这个版本
Anaconda3-2021.11-Windows-x86_64.exe
安装参考博主：《软件安装与使用教程》— Windows操作系统快速安装Anaconda搭建Python开发环境_anaconda3-2019.07-CSDN博客​​​​​​​​​​​​​​​​​​​​​a
安装时根据上面博主的图文安装，我的是默认勾选python3.8环境 第二步：建立yolov5环境 #打开 Anaconda Prompt 命令行输入
#这是建立一个虚拟环境，python版本是3.8 , 其中yolo5是你的虚拟环境的名字
conda create -n yolov5 python=3.8
#创建一个新环境，并激活进入环境。
这时候系统提示下载安装包
# 激活名叫yolov5的环境,并进入
activate yolov5 ，如下图进入yolov5环境 ------------------------------------------------------------------------------------
第三步：安装yolov5依赖 进入下载的yolov5工程路径，安装依赖
安装之前打开requirements.txt，解除屏蔽 tensorboard&gt;=2.4.1
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
等待下载安装完成
------------------------------------------------------------------------------------
第四步：验证ptyhon环境 在yolov5环境下键入如下验证版本
python
#输入库
import torch
#查看版本
print(torch.__version__)
第五步：运行detect.py文件 cmd到yolov5环境中，执行python detect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df7b8a9b7c2743a5c87d29b669137686/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34d991576227fa74681749ff8c0df9c5/" rel="bookmark">
			ChatGLM3-6B本地部署及微调-部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、购买算力服务器
AutoDL:https://www.autodl.com/ 该云服务器还是很适合我这种穷人的，很多配置（如CUDA）都帮你装好了，不需要你自己去花费很多时间安装，4090两块多一小时
2、先无卡模式登录安装配置环境
3、配置环境
① 安装git lfs
命令：curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
② 设置学术加速 | 下载东西更快
命令：source /etc/network_turbo
③ 拉取chatGLM3-6B代码仓
命令：git clone https://github.com/THUDM/ChatGLM3
④ 进入ChatGLM3目录安装 requirements.txt 内的库（安装前最好先升级一下pip)
升级pip命令：python -m pip install --upgrade pip
然后使用 pip 安装依赖：pip install -r requirements.txt
4、克隆Hugging Face代码仓
① 安装git-lfs：curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
② 检查lfs是否安装：命令：git lfs install
③ 下载本地模型 Hugging Face：https://huggingface.co/THUDM/chatglm3-6b
命令：git clone https://huggingface.co/THUDM/chatglm3-6b （网速慢的话可以参考官方其他方法下载）
④ 如果下载报错443需要再设置学术加速（设置代理）：source /etc/network_turbo
⑤ 访问huggingface.co连接超时：更换实例地区，推荐芜湖
5、有卡模式重写启动服务器，最终呈现：
提示：整个过程中会用到两个代码仓github与huggingface，github上的仓库是存放chatglm3-6b的运行代码的，而huggingface的代码仓中是存放运行所需的模型及模型相关配置文件的。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/34d991576227fa74681749ff8c0df9c5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0ff031d9644c161006e90fa4a6b3e76/" rel="bookmark">
			unreal engine5.1中设置convex decomposition凸包分解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 UE5系列文章目录 文章目录 UE5系列文章目录前言一、convex decomposition是什么？二、convex decomposition属性设置 前言 今天使用ue5根据网上教程制作可操控直升机，找属性convex decomposition凸包分解，默认的碰撞如下图
如果想使用精细化的碰撞检测就要收到设置convex decomposition属性。如下图
默认属性面板是不显示convex decomposition属性的。
一、convex decomposition是什么？ UE5官方文档
官方文档居然没搜到单独讲解convex decomposition
二、convex decomposition属性设置 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1148029c476adff8c9cea34e597723a/" rel="bookmark">
			【AI大模型应用开发】0.2 智谱AI API接入详细步骤和简单应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是【同学小张】。持续学习，持续干货输出，关注我，跟我一起学AI大模型技能。
最近我的OpenAI的API key由于调用次数太多被封了… 不知道下个月能不能解封。而为了尽可能地不花钱，先来看下国内的大模型API怎么用。
本文是智谱AI API的使用。
0. 环境 （1）注册并登录智谱AI开发者平台：https://www.zhipuai.cn/
原来注册的时候赠送了18块钱的使用额度，不知道现在注册还有没有。
（2）获取API key
（3）安装智谱AI API的Python包
pip install --upgrade zhipuai 1. 调用接口 （1）将你的API Key添加到环境变量中
ZHIPU_AI_API_KEY = "7c470xxxxxXwe" （2）调用对话接口
import requests import json import os # 加载 .env 到环境变量 from dotenv import load_dotenv, find_dotenv _ = load_dotenv(find_dotenv()) zhipu_api_key = os.getenv('ZHIPU_AI_API_KEY') # 设置百度千帆AK from zhipuai import ZhipuAI client = ZhipuAI(api_key=zhipu_api_key) # 填写您自己的APIKey response = client.chat.completions.create( model="glm-4", # 填写需要调用的模型名称 messages=[ {"role": "user", "content": "作为一名营销专家，请为我的产品创作一个吸引人的slogan"}, {"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1148029c476adff8c9cea34e597723a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fa1fbf22eb89e48237540cbf36e44bc8/" rel="bookmark">
			蒙特卡罗模拟 python Monte Carlo Simulation
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 蒙特卡罗模拟 与普通预测模型不同，蒙特卡罗模拟根据估计值范围与一组固定输入值来预测一组结果。换句话说，蒙特卡洛模拟通过利用概率分布（例如均匀分布或正态分布），为任何具有固有不确定性的变量构建可能结果的模型。然后，它一遍又一遍地重新计算结果，每次都使用最小值和最大值之间的一组不同的随机数。在典型的蒙特卡罗实验中，可以重复此练习数千次以产生大量可能的结果。
由于其准确性，蒙特卡罗模拟也可用于长期预测。随着输入数量的增加，预测数量也会增加，使您能够更准确地预测更远的时间结果。当蒙特卡罗模拟完成时，它会产生一系列可能的结果以及每个结果发生的概率。
蒙特卡洛模拟的一个简单示例是考虑计算掷出两个标准骰子的概率。骰子有 36 种组合。基于此，您可以手动计算特定结果的概率。使用蒙特卡罗模拟，您可以模拟掷骰子 10,000 次（或更多），以实现更准确的预测。
无论您使用什么工具，蒙特卡罗技术都涉及三个基本步骤：
设置预测模型，确定要预测的因变量和驱动预测的自变量（也称为输入、风险或预测变量）。指定自变量的概率分布。使用历史数据和/或分析师的主观判断来定义可能值的范围并为每个值分配概率权重。重复运行模拟，生成自变量的随机值。这样做，直到收集到足够的结果来构成近乎无限数量的可能组合的代表性样本。 您可以通过修改用于模拟数据的基础参数来运行任意数量的蒙特卡罗模拟。但是，您还需要通过计算方差和标准差（这是常用的散布度量）来计算样本内的变异范围。给定变量的方差是变量与其期望值之间的平方差的期望值。标准差是方差的平方根。通常，方差越小越好。
2. Python 蒙特卡罗模拟计算 π \pi π # import libraries import numpy as np # initialize variables n_simulations = 100000 n_points_circle = 0 n_points_square = 0 # create lists to store x and y values l_xs = [] l_ys = [] # loop n_simulations times for _ in range(n_simulations): # x is randomly drawn from a continuous uniform distritbuion x = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fa1fbf22eb89e48237540cbf36e44bc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c339dfce9c8c7eeacdcf934d11f9026c/" rel="bookmark">
			Linux内核-时间子系统（时钟中断）专题汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要一、专题汇总1.1、优秀系列博文1.2、时间子系统1.3、高精度定时器hrtimer1.4、RTC硬件芯片驱动 概要 中断机制是计算机系统的重要组成部分，在Linux中也不例外，中断按照来源分为硬中断和软中断，而硬中断根据硬件范围分为外中断和内中断。时钟中断就是内中断的一种。
之所以要提到时钟中断，是因为时钟是操作系统进行调度工作的重要工具，如维护系统的绝对日期和时间、让分时进程按时间片轮转、让实时进程定时发送换接收控制信号、系统定时唤醒或阻塞进程、对用户进程记账、测量系统性能等，利用定时器能够确保操作系统在必要的时候获得控制权，陷入死循环的进程最终会因时间片耗尽而被迫让出CPU。
Linux下的时钟中断也称为时间子系统，其架构示意图如下：
可见Linux下的时间由硬件时钟芯片和软件时钟框架共同作用实现。
Linux 2.6.16之前，内核只支持低精度时钟，内核定时器的工作方式：
系统启动后，会读取时钟源设备(RTC, HPET，PIT…),初始化当前系统时间；内核会根据HZ(系统定时器频率，节拍率)参数值，设置时钟事件设备，启动tick(节拍)中断。HZ表示1秒种产生多少个时钟硬件中断，tick就表示连续两个中断的间隔时间。在我电脑上，HZ=250， 一个tick = 1/HZ, 所以默认一个tick为4ms。设置时钟事件设备后，时钟事件设备会定时产生一个tick中断，触发时钟中断处理函数，更新系统时钟,并检测timer wheel，进行超时事件的处理。
在上面工作方式下，Linux 2.6.16 之前，内核软件定时器采用timer wheel多级时间轮的机制，维护操作系统的所有定时事件。timer wheel的触发是基于系统tick的周期性中断。
所以说在这之前，Linux只能支持ms级别的时钟，随着时钟源硬件设备的精度提高和软件高精度计时的需求，有了高精度时钟高精度时钟的内核设计。从Linux 2.6.16开始 ，内核支持了高精度的时钟，即新的定时器hrtimer，其实现逻辑和Linux 2.6.16 之前定时器逻辑区别： 采用红黑树进行高精度定时器的管理，而不是时间轮；高精度时钟定时器不在依赖系统的tick中断，而是基于事件触发。 旧内核的定时器实现依赖于系统定时器硬件定期的tick，基于该tick，内核会扫描timer wheel进而处理超时事件，更新jiffies，wall time(墙上时间），real time（现实时间)，process的使用时间等等工作。
新的内核不再会直接支持周期性的tick，新内核定时器框架采用了基于事件触发，而不是以前的周期性触发。新内核实现了hrtimer(high resolution timer)，hrtimer的设计目的，就是为了解决旧定时器的缺点：
低精度，旧定时器只能支持ms级别的精度，hrtimer可以支持ns级别；旧定时器与内核其它模块的高耦合； 新内核的hrtimer的触发和设置不像之前在定期的tick中断中进行，而是动态调整的，即基于事件触发，hrtimer的工作原理：
通过将高精度时钟硬件的下次中断触发时间设置为红黑树中最早到期的 Timer 的时间，时钟到期后从红黑树中得到下一个 Timer 的到期时间，并设置硬件，如此循环反复。
在高精度时钟模式下，操作系统内核仍然需要周期性的tick中断，以便刷新内核的一些任务。前面可以知道，hrtimer是基于事件的，不会周期性出发tick中断，所以为了实现周期性的tick中断(dynamic tick)：系统创建了一个模拟 tick 时钟的特殊 hrtimer，将其超时时间设置为一个tick时长，在超时回来后，完成对应的工作，然后再次设置下一个tick的超时时间，以此达到周期性tick中断的需求。引入了dynamic tick,是为了能够在使用高精度时钟的同时节约能源,，这样会产生tickless 情况下，会跳过一些 tick。这里只是简单介绍，有兴趣可以读kernel源码。
新内核对相关的时间硬件设备进行了统一的封装，定义了主要有下面两个结构：
时钟源设备(closk source device)：抽象那些能够提供计时功能的系统硬件，比如 RTC(Real Time Clock)、TSC(Time Stamp Counter)，HPET，ACPI PM-Timer，PIT等。不同时钟源提供的精度不一样，现在pc大都是支持高精度模式(high-resolution mode)也支持低精度模式(low-resolution mode）。时钟事件设备(clock event device)：系统中可以触发 one-shot（单次）或者周期性中断的设备都可以作为时钟事件设备。 当前内核同时存在旧timer wheel 和新hrtimer两套timer的实现，内核启动后会进行从低精度模式到高精度时钟模式的切换，hrtimer模拟的tick中断将驱动传统的低精度定时器系统（基于时间轮）和内核进程调度。
一、专题汇总 主要是汇总个人觉得精彩的Linux时间子系统相关的博文。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c339dfce9c8c7eeacdcf934d11f9026c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c60d1a8de7f1c8abef141d60654a09d/" rel="bookmark">
			学生宿舍管理小程序|基于微信小程序的学生宿舍管理系统设计与实现(源码&#43;数据库&#43;文档)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		学生宿舍管理小程序目录
目录
基于微信小程序的学生宿舍管理系统设计与实现
一、前言
二、系统功能设计
三、系统实现
1、管理员模块的实现
（1）学生信息管理
（2）公告信息管理
（3）宿舍信息管理
（4）晚归登记管理
2、小程序学生模块的实现
（1）学生注册
（2）小程序首页
（3）离宿申请
（4）我的
四、数据库设计
1、实体ER图
五、核心代码
六、论文参考
七、最新计算机毕设选题推荐
八、源码获取： 博主介绍：✌️大家好！我是Coder-coco，一名专注以理论为基础、实战为主的技术博主，本人在Java毕业设计领域有多年的经验，陆续会更新更多优质的Java实战项目，希望你能有所收获，少走一些弯路。✌️
主要项目：小程序、SpringBoot、SSM、Vue、Html、Jsp、Nodejs等设计与开发。
🍅文末获取源码联系🍅
基于微信小程序的学生宿舍管理系统设计与实现 一、前言 本文介绍了宿舍管理系统小程序的开发全过程。通过分析宿舍管理系统小程序管理的不足，创建了一个计算机管理宿舍管理系统小程序的方案。文章介绍了宿舍管理系统小程序的系统分析部分，包括可行性分析等，系统设计部分主要介绍了系统功能设计和数据库设计。
本宿舍管理系统小程序有管理员和学生两个角色。管理员功能有个人中心，公告信息管理，班级管理，学生管理，宿舍信息管理，宿舍安排管理，离宿申请管理，宿舍评分管理，晚归登记管理，报修信息管理，报修处理管理，系统管理等。学生功能有注册登录，查看公告信息，宿舍信息，查看宿舍安排，离宿申请，宿舍评分，晚归登记，报修信息，报修处理，我的收藏等。因而具有一定的实用性。
本站后台采用Java的SSM框架进行后台管理开发，可以在浏览器上登录进行后台数据方面的管理，MySQL作为本地数据库，微信小程序用到了微信开发者工具，充分保证系统的稳定性。系统具有界面清晰、操作简单，功能齐全的特点，使得宿舍管理系统小程序管理工作系统化、规范化。
关键词：宿舍管理系统小程序；SSM框架；MYSQL数据库
二、系统功能设计 设计的管理员功能结构图如下图所示：
图4-2管理员功能结构图
设计的学生功能结构图如下图所示：
图4-2学生功能结构图
三、系统实现 1、管理员模块的实现 （1）学生信息管理 管理员可以管理学生信息，可以对通过微信小程序端注册的学生信息修改删除。具体界面的展示如图5.1所示。
图5.1 学生信息管理界面
（2）公告信息管理 管理员可以对公告信息进行添加，修改删除查询操作。具体界面如图5.2所示。
图5.2 公告信息管理界面
（3）宿舍信息管理 系统管理员可以查看宿舍信息，并且可以对宿舍信息进行添加修改删除操作。界面如下图所示：
图5.3 宿舍信息管理界面
（4）晚归登记管理 系统管理员可以查看晚归登记，并且可以对晚归登记的信息进行修改删除操作。界面如下图所示：
图5.4 晚归登记管理界面
2、小程序学生模块的实现 （1）学生注册 小程序学生是需要注册才可以进行登录的。界面如下图所示：
图5.5 注册界面
（2）小程序首页 小程序首页会显示公告信息，宿舍信息还有其他信息，通过下滑就可以获取到。界面如下图所示：
图5.6 小程序首页
（3）离宿申请 学生可以提交离宿申请。界面如下图所示：
图5.6 离宿申请
（4）我的 小程序最下面是导航模块，点击我的，可以出现关于我的相关功能。界面如下图所示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c60d1a8de7f1c8abef141d60654a09d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0457fe1aa3ded65b3a07a0624acb497/" rel="bookmark">
			select、poll和epoll的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要一、多路复用I/O模型的诞生1.1 多线程或进程方式1.2 通过数组，链表等方式保存socket fd，不断轮询 二、select三、poll四、epoll五、小结六、参考 概要 在Unix五种I/O模型一文中，提到了I/O多路复用模型，其在Linux下有3种实现方式：select、poll、epoll，本文主要深入介绍下它们各自特点。
事先说明：I/O多路复用模型，select和poll核心就是【轮询+内核I/O事件就绪通知】,epoll的核心是内核I/O事件就绪通知。
多路：多个socket连接（即多个客户端连接）
复用：允许内核监听多个socket描述符，一旦发现进程指定的一个或多个scoket的I/O事件就绪（TCP三次握手成功[accept]、可读[read]，可写[write]等），就通知该进程
要想更好的了解，最好根据代码来说，下面是代码的基本框架：
void main(int argc, char **argv) { int listenfd, connfd; struct sockaddr_in srv_addr; //创建socket套接字 if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { printf("create socket error: %s(errno: %d)\n", strerror(errno), errno); return; } //设置绑定地址的内容 memset(&amp;srv_addr, 0, sizeof(srv_addr)); srv_addr.sin_family = AF_INET; //ipv4 srv_addr.sin_addr.s_addr = htonl(INADDR_ANY);//ip 0.0.0.0 srv_addr.sin_port = htons(8888); //端口 //绑定地址 if (bind(listenfd, (struct sockaddr *)&amp;srv_addr, sizeof(srv_addr)) == -1) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0457fe1aa3ded65b3a07a0624acb497/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c7d1b7a062c62aeba920ea7fc0cb519/" rel="bookmark">
			C语言程序设计详细教程（完整版）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一. 程序设计基础知识
1.1 计算机语言
1.2 程序
1.3 算法
1.3.1 流程图
1.3.2 伪代码
1.4 结构化程序设计方法
1.4.1 三种基本结构
1.4.2 注释的要求
二、C语言的数据类型与运算规则
2.0 标识符的规范
2.1 数据与数据类型
2.1.1 整型数据
2.1.2 实数型数据（浮点型）
2.1.3 字符型数据
2.2 运算符与表达式
2.2.1 基本运算符
2.2.2 运算符优先级
2.2.3 表达式与语句
2.2.4 类型转换
三、顺序结构程序设计
3.1 格式化屏幕输出函数 printf()
3.2 格式化键盘输入函数 scanf()
3.3 字符输入输出函数
3.3.1 getchar() 函数
3.3.2 putchar() 函数
四、选择结构程序设计
4.0 逻辑运算符的短路特性
4.1 if 语句
4.1.1 单分支 if 语句
4.1.2 双分支 if 语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c7d1b7a062c62aeba920ea7fc0cb519/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/998c60c35e0b8b1f3a11d7315ebc3a42/" rel="bookmark">
			Linux 运维必备的 13 款实用工具，赶紧收藏~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文介绍几款Linux运维比较实用的工具，希望对Linux管理员有所帮助。
1、查看进程占用带宽情况-Nethogs Nethogs 是一个终端下的网络流量监控工具可以直观的显示每个进程占用的带宽。
下载：http://sourceforge.net/projects/nethogs/files/nethogs/0.8/nethogs-0.8.0.tar.gz/download
[root@localhost ~]#yum-y install libpcap-develncurses-devel [root@localhost ~]# tar zxvf nethogs-0.8.0.tar.gz [root@localhost ~]# cd nethogs [root@localhost nethogs]# make &amp;&amp; make install [root@localhost nethogs]# nethogs eth0
2、硬盘读取性能测试-IOZone IOZone是一款Linux文件系统性能测试工具 可以测试不同的操作系统中文件系统的读写性能。
下载：http://www.iozone.org/src/current/
[root@localhost current]# tar xvf iozone3_420.tar [root@localhost ~]# cd iozone3_420/src/current/ [root@localhost current]# make linux [root@localhost current]# ./iozone -a -n 512m -g 16g -i 0 -i 1 -i 5 -f /mnt/iozone -Rb ./iozone.xls
-a使用全自动模式
-n为自动模式设置最小文件大小(Kbytes)。
-g设置自动模式可使用的最大文件大小Kbytes。
-i用来指定运行哪个测试。
-f指定测试文件的名字完成后自动删除
-R产生Excel到标准输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/998c60c35e0b8b1f3a11d7315ebc3a42/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95d0f307409697df379b51af36fc426c/" rel="bookmark">
			python Flask与微信小程序 统计管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		common/models/stat/StatDailyMember.py DROP TABLE IF EXISTS `stat_daily_member`; CREATE TABLE `stat_daily_member` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `date` date NOT NULL COMMENT '日期', `member_id` int(11) NOT NULL DEFAULT '0' COMMENT '会员id', `total_shared_count` int(11) NOT NULL DEFAULT '0' COMMENT '当日分享总次数', `total_pay_money` decimal(10,2) NOT NULL DEFAULT '0.00' COMMENT '当日付款总金额', `updated_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间', `created_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '插入时间', PRIMARY KEY (`id`), KEY `idx_date_member_id` (`date`,`member_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='会员日统计'; flask-sqlacodegen 'mysql://root:root@127.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95d0f307409697df379b51af36fc426c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1515b08c1d0630af40f41cf66e864da/" rel="bookmark">
			Linux内核-I/O多路复用[select]和I/O事件就绪通知源码分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概要一、了解 Linux1.1、Linux下OSI五层模型1.2、Linux的进程状态转换模型1.3、Linux下的中断之时钟中断 二、select源码解析2.1、select使用案例2.2、select源码2.2.1、相关结构体2.2.2、core_sys_select2.2.3、do_select 三、I/O事件就绪通知源码解析3.1、相关结构体3.2、tcp与socket关联源码分析3.3、TCP收到数据时回调唤醒进程 四、socket等待队列4.1、虚拟文件系统sockfs4.2、socket等待队列初始化 五、select超时源码解析六、参考 概要 在select、poll和epoll的区别一文中不断地提到Linux内核I/O事件就绪通知相关字眼，可以说其是多路复用I/O模型的绝对核心，是比阻塞I/O,非阻塞I/O模型高性能的一大关键点。
本文就基于select源码一探究竟，在I/O事件就绪通知源码上poll和epoll是适用的。
PS:基于linux内核V6.7。
一、了解 Linux 1.1、Linux下OSI五层模型 如图所示，当我们创建一个TCP socket后，然后通过select API阻塞进程，此时有个客户端要建立连接，数据包通往网络抵达当前服务器，就会：
先到网卡，网卡收到的数据是光信号或电信号，然后将其还原成数字信息(由1和0组成)，数据通过过滤校验后，会通过DMA的方式写入到指定的内存地址（这块地址也叫网卡缓冲区，是操作系统启动时，加载网卡驱动代码的时候，网卡驱动代码申请的），最后给CPU发送中断信号，这一阶段不需要CPU参与；CPU收到中断信号，就调用网卡对应的网卡驱动代码（网卡驱动程序每个网卡制造商都要集成到Linux内核中，如华为以太网驱动），驱动代码会将网卡缓冲区的数据包转换成Linux内核网络模块能识别的skb格式(网卡缓冲区的数据包格式只有网卡驱动知道)，然后调用IP 层的入口函数上传给Linux内核网络模块的IP层;IP 层的入口函数是 ip_rcv函数，将skb格式的数据包进行校验处理，继续调TCP层入口函数，上传给Linux内核网络模块的TCP层;TCP层的入口函数是tcp_v4_rcv 函数，将skb格式的数据包进行校验处理，放进 socket 的 receive queue中，通过 socket 唤醒进程;进程被唤醒后，就通过Glibc scoket API进行I/O操作，即可通过accept API与客户端建立连接。 1.2、Linux的进程状态转换模型 通过Linux任务状态常量可以看到进程状态有很多：
/* Used in tsk-&gt;__state: */ #define TASK_RUNNING	0x00000000 #define TASK_INTERRUPTIBLE	0x00000001 #define TASK_UNINTERRUPTIBLE	0x00000002 #define __TASK_STOPPED	0x00000004 #define __TASK_TRACED	0x00000008 /* Used in tsk-&gt;exit_state: */ #define EXIT_DEAD	0x00000010 #define EXIT_ZOMBIE	0x00000020 #define EXIT_TRACE	(EXIT_ZOMBIE | EXIT_DEAD) /* Used in tsk-&gt;__state again: */ #define TASK_PARKED	0x00000040 #define TASK_DEAD	0x00000080 #define TASK_WAKEKILL	0x00000100 #define TASK_WAKING	0x00000200 #define TASK_NOLOAD	0x00000400 #define TASK_NEW	0x00000800 #define TASK_RTLOCK_WAIT	0x00001000 #define TASK_FREEZABLE	0x00002000 #define __TASK_FREEZABLE_UNSAFE	(0x00004000 * IS_ENABLED(CONFIG_LOCKDEP)) #define TASK_FROZEN	0x00008000 #define TASK_STATE_MAX	0x00010000 #define TASK_ANY	(TASK_STATE_MAX-1) /* * DO NOT ADD ANY NEW USERS !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1515b08c1d0630af40f41cf66e864da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01b2bb2d044442ef17ec22c178c06582/" rel="bookmark">
			一个外国软件，让你的手机成为扩展屏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.前言 大家好，如果你外出办公可能需要扩展屏，那么有一款外国软件肯定适合你，这个软件就是spacedesk，它可以让你的手机或平板成为你的扩展屏，现在就献上安装方法
二.安装 首先我们要获取到安装包，可以到官网下载，但是小编试了一下，显示无法进入，但是大家可以 使用小编提前准备好的安装包，大家可以根据自己的系统来选择安装包,文件链接在下方，需要的自取（提示：本文件用的是迅雷云盘，下载的话需要提前下载好迅雷app）
迅雷云盘迅雷云盘https://pan.xunlei.com/s/VNqVRntscQG66RCQOZKSk40fA1?pwd=fsxg#选择好之后运行安装包点next，协议那里点上小圆圈在点next，后面都是点next，这样就安装好了
三.开始使用 提前在手机安装好后打开spacedesk，选择on旁边的小圆圈，再选择自己电脑的IP地址，再到手机端点加号，输入IP地址即可（确保手机和电脑连接统一网络）（手机可能会自己找到）。
四.结尾 本文章用的是wifi连接，还有USB连接，这里暂时不说。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/389888834e45aad2e41d1dcc9d3e1cf4/" rel="bookmark">
			重学Java 13.面向对象.1.static关键字和可变参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在熟悉的事物中循环
新年快乐！学习继续~
2024年加油！
——24.2.12
一、static关键字 1.static关键字的介绍以及基本使用 1.概述：static是一个静态关键字
2.使用：
a.修饰一个成员变量：
static 数据类型 变量名
b.修饰一个方法：
修饰符 static 返回值类型 方法名（形参）{
方法体
return 结果
}
3.调用静态成员
类名直接调用（不用new对象）
4.静态成员特点：
a.静态成员属于类成员，不属于对象成员（非静态的成员属于对象成员）
b.静态成员会随着类的加载而加载
c.静态成员优先于非静态成员存在在内存中
d.凡是根据静态成员所在的类创建出来的对象，都可以共享这个静态成员
2.static关键字的使用 public class Demo84S09ObjectOriented01Static { public static void main(String[] args) { //先给静态成员赋值 Demo85S09ObjectStudent.classRoom = "111"; Demo85S09ObjectStudent s1 = new Demo85S09ObjectStudent(); s1.name = "郭靖"; s1.age = 21; //教师更改classRoom就需要重新赋值，不可以用对象.可以用类名. //s1.classRoom = "308"; System.out.println(s1.name+","+s1.age+","+s1.classRoom); Demo85S09ObjectStudent s2 = new Demo85S09ObjectStudent(); s2.name = "黄蓉"; s2.age = 26; //s2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/389888834e45aad2e41d1dcc9d3e1cf4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0278488a18bf584d2585fef04c15dca9/" rel="bookmark">
			idea:如何连接数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在idea中打开database: 2、点击 ‘+’ ---&gt; Data Source ---&gt; MySQL 3、输入自己的账号和密码其他空白处可以不填，用户和密码可以在自己的mysql数据库中查看 4、最后选择自己需要用的数据库，点击运用ok，等待刷新即可 最后： 使用这种方法的前提是已经安装了mysql数据库服务器的前提，如果没有安装masql服务器的话可以看这个视频安装操作：
数据库：安装MySQL服务器_哔哩哔哩_bilibili
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6179c5d5f466d9e5c6a4588f5c79df8e/" rel="bookmark">
			【环境搭建】ubuntu 阿里源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		具体如下:
sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak sudo vim /etc/apt/sources.list # 20.04阿里源 deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6179c5d5f466d9e5c6a4588f5c79df8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70ca78eb00d0b7d12f339e575579f2d7/" rel="bookmark">
			【知识】策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 为应对未来激烈的竞争，需要具备以下要素：
主动选择。每个人都有主动选择的权利，既然做出选择，应对其产生的结果而负责。反逆向思维。梳理过程，分析因果，优化决策。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adf2038ad65b06a29d6c6f1a96ba51df/" rel="bookmark">
			从黎曼到康托尔，微积分历经一个世纪才演变为我们今天的大学学科！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在 19 世纪, 数学在根本层面上发生了改变. 在它变得更深刻、更广阔的同时, 对数学洞察能力的要求也越来越高. 而且, 数学催生了一种职业. 大学和技术研究所大量涌现, 需要能够讲授高级课题的职员. 数学教师, 曾经是没有经济保证的职业选择, 此时则成了铁饭碗.
数学的研究越来越聚焦于精确的定义和严格的证明. 欧拉挥洒自如的风格已经让位于柯西的详尽分析. 微积分演变为我们今天所称的分析学科. 贯穿这个世纪的一条分析主线, 是围绕傅里叶级数展开的种种问题. 本章将探究这方面的一些成果, 以黎曼对积分的定义与相关工作为起点, 以对实数本质的惊人洞察为高潮. 这只不过是一个简短的体验, 让你品味一下微积分在这个变革的世纪中发生了什么.
来源 | 《微积分溯源：伟大思想的历程》
作者 | [美] 戴维·M. 布雷苏（David M. Bressoud）
译者：陈见柯 林开亮 叶卢庆
摘自 | 《分析》一章
1
黎曼积分 伯恩哈德·黎曼 (Bernhard Riemann, 1826—1866) 曾受教于卡尔·弗里德里希·高斯和古斯塔夫·狄利克雷, 也许是 19 世纪最有才能的数学家, 他完全革新了几何学与分析学, 而且只用一篇文章就奠定了素数定理的证明基础. 这一工作表明, 复平面上的微积分可以用来证明, 不超过 的素数个数渐近等于 . 1854 年, 为取得在德国大学担任教授的资格 (Habilitation), 黎曼需要提交一篇更高级的论文, 他选择了建立任意一个函数可以展开成傅里叶级数的充要条件.
所成的论文《用三角级数来表示函数》以对这个问题的历史综述开始. 黎曼接下来建立了一个函数可积的充要条件. 关键在于, 对于任意事先指定的上界 , 变差大于 的地方必须要在一些区间之内, 所有这些区间的长度之和可以任意小.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adf2038ad65b06a29d6c6f1a96ba51df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24ae9fc7df6aa83315ea7288117156a1/" rel="bookmark">
			使用 Kestrel 自托管https 并作为 Windows 服务启动 Blazor 提示: 无法配置 HTTPS 端点。未指定服务器证书，找不到默认的开发者证书解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文链接 https://stackoverflow.com/questions/53300480/unable-to-configure-https-endpoint-no-server-certificate-was-specified-and-the/71026252#71026252
使用 Kestrel 自托管并作为 Windows 服务启动 Blazor 提示
Unable to configure HTTPS endpoint. No server certificate was specified, and the default developer certificate could not be found or is out of date. To generate a developer certificate run 'dotnet dev-certs https'. To trust the certificate (Windows and macOS only) run 'dotnet dev-certs https --trust'. For more information on configuring HTTPS see https://go.microsoft.com/fwlink/?linkid=848054. at Microsoft.AspNetCore.Hosting.ListenOptionsHttpsExtensions.UseHttps(ListenOptions listenOptions, Action`1 configureOptions) 搜遍了互联网终于找到一个可行办法
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24ae9fc7df6aa83315ea7288117156a1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/63/">«</a>
	<span class="pagination__item pagination__item--current">64/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/65/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>