<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7809cbc11d6531ab5a8f0574e2d8db03/" rel="bookmark">
			大型c&#43;&#43;项目在linux下如何调试?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大型c++项目在linux下如何调试? 在开始前我有一些资料，是我根据网友给的问题精心整理了一份「Linux 的资料从专业入门到高级教程」，
点个关注在评论区回复“888”之后私信回复“888”，全部无偿共享给大家！！！
首先要分客户端还是服务端，或者说程序运行在本地还是在服务器上。
本地运行的程序，如果项目本身是在IDE里开发的，那自然可以用IDE调试。Linux桌面环境里也有各种图形界面IDE，和Windows上的Visual Studio, macOS上的Xcode一样方便。
如果不是用IDE开发的程序，比如Chromium, 可以接入(attach) gdb/lldb. 值得一提的是gdb其实是有一个TUI的，虽然比较丑，但也勉强能用。
如果是在服务器上运行的程序，那么SSH连上去用gdb/lldb, 方法是差不多的。另外，VS Code的远程开发插件也支持调试的，配置妥当的话效果不错。
其次要分调试业务逻辑还是调试系统层面的问题。
业务逻辑是指程序本身的算法和数据，如果问题不复杂的话，其实二分法print还是挺好用的。唯一的缺点是如果文件比较大，编译会很费时间。
系统层面的问题那就要用这张图里的工具了，细节不展开讲，每个工具都有特定的适用场景。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6f94b5ea59f28bcc41426a4164d0fbd/" rel="bookmark">
			C#编程技巧--2
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.使用泛型: 泛型允许你编写更加灵活和可重用的代码，同时提高类型安全性。
C# 中的泛型功能允许你编写更加灵活和可重用的代码，并且可以增加类型安全性。通过使用泛型，你可以编写适用于不同类型的代码，而无需为每种类型单独重写代码。
以下是一个简单的示例，展示了如何使用泛型来创建一个通用的集合类：
using System; using System.Collections.Generic; class Program { static void Main(string[] args) { List&lt;int&gt; numbers = new List&lt;int&gt;(); numbers.Add(1); numbers.Add(2); numbers.Add(3); List&lt;string&gt; names = new List&lt;string&gt;(); names.Add("John"); names.Add("Jane"); names.Add("Alice"); PrintList(numbers); PrintList(names); } static void PrintList&lt;T&gt;(List&lt;T&gt; list) { foreach (T item in list) { Console.WriteLine(item); } } } 在这个示例中，我们定义了一个泛型方法 PrintList&lt;T&gt;。这个方法接受一个泛型列表作为参数，并遍历打印出列表中的每个元素。我们首先创建了一个 List&lt;int&gt;，然后创建一个 List&lt;string&gt;，并分别调用了 PrintList 方法来打印它们的内容。
通过使用泛型，我们可以将方法 PrintList 应用于不同类型的列表，而无需为每个类型编写单独的方法。这使得代码更加灵活和可重用，同时保持类型安全。
除了泛型方法外，C# 还支持泛型类和泛型接口，允许你在其他方面使用泛型来提高代码的灵活性和可重用性。使用泛型可以减少类型转换的需要，并提供了更好的代码组织和类型安全的保证。
2.异常处理: 有效的异常处理是编写健壮软件的关键。学会处理异常并进行适当的日志记录和错误处理。
有效的异常处理对于编写健壮的软件至关重要。异常处理可以帮助我们识别和处理程序中出现的错误，并采取适当的措施来解决问题或提供错误反馈。
以下是一些关于异常处理的最佳实践：
（1）对异常进行适当处理：在可能引发异常的代码块中使用 try-catch 块来捕获异常。这样可以防止异常的传播，并允许你在异常出现时执行特定的处理逻辑。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6f94b5ea59f28bcc41426a4164d0fbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b5a5bdc17c6da84c15a3f39b0bf50b4/" rel="bookmark">
			第九届多媒体系统和信号处理国际会议（ICMSSP 2024）即将召开！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2024年第九届多媒体系统和信号处理国际会议（ICMSSP 2024）将在5月24-26日在泰国曼谷举行。ICMSSP 2024旨在展示多媒体系统和信号处理等相关主题的最新研究和成果，为不同领域的专家代表提供了面对面交流新想法以及应用经验的机会，建立业务或研究关系，对科学领域的前沿发展做出重大贡献。
ICMSSP 2024 | Multimedia Systems and Signal Processinghttps://www.icmssp.org/
组织单位： 征稿主题： 多媒体和通信
• MPEG 标准及相关问题
• 数字音视频广播
• 结构与协议
• 互动多媒体： 游戏与数字电视
多媒体信号处理
• 多维信号处理
• 多模态信号处理
• 生物统计与模式识别
• 信号处理教育
多媒体系统与应用
• 认证与水印
• 分布式多媒体系统
• 音视频质量评估
• 多媒体数据库、索引、识别和检索
更多信息，请访问：http://www.icmssp.org/cfp.html
会议出版及检索： 所有录用和发表的文章将由ACM出版为ICMSSP2024会议论文集 (ISBN: 979-8-4007-1691-1)，并提交给Ei Compendex和Scopus进行检索。
出版历史：
ICMSSP 2023 会议论文集 | ISBN: 979-8-4007-0060-6 | ACM 数字图书馆 | EI COMPENDEX | SCOPUS
ICMSSP 2022 会议论文集 | ISBN: 978-1-4503-9642-4 | ACM 数字图书馆 | EI COMPENDEX | SCOPUS
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b5a5bdc17c6da84c15a3f39b0bf50b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f9412af7de4e8dcfbed24ad9a8d56e7/" rel="bookmark">
			mysql的语法学习总结1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		创建数据库 CREATE DATABASE database_name; 使用数据库： USE database_name; 删除数据库： DROP DATABASE database_name; 数据类型： mysql支持的数据类型主要分为4类，即字符串类型、数值类型、日期和时间类型，以及布尔类型。
1、字符串类型： 常用的字符类型是CHAR、VARCHAR类型。
CHAR：描述定长的字符串，说明格式为CHAR（L），其中L为字符串长度，取值范围为（1~255）。比L大的值将被截断，比L小的值将用空格填补。
VARCHAR：描述变长的字符串，说明格式为VARCHAR（L），其中L为字符串长度，取值范围为1~255.比L的值将被截断，比L小的值不会用空格填补
2、数值类型： 常用的数值类型是INT、DECIMAL类型
INT：用于表示整数，存储长度默认为4个字节。说明格式为INT
DECIMAL： 可以用来表示所有的数值数据，说明格式为DECIMAL（ p , s ）,其中p表示数据的最大长度，s表示数值数据中小数点后的数字位数，p、s在定义时可以省略，例如DECIMAL(5)、DECIMAL等。
3、日期和时间类型： 常用的日期和时间类型是DATE、TIME、DATETIME类型。
DATE:用来保护固定长度的日期数据，说明格式为DATE
TIME：用来保护固定长度的时间数据，说明格式为TIME
DATETIME: 用来保存固定长度的日期时间数据，说明格式为DATETIME。日期值格式为‘YYYY-MM-DD’；时间值格式为‘HH：MM:SS’；日期时间值格式为'YYYY-MM-DD HH:MM:SS'
4、布尔类型 布尔类型为BOOLEAN类型，它只有两个值————TRUE和FALSE，即真值和假值。
创建表： 每个 MySQL 表都应该有一个主键，用于唯一标识该表中的每一行数据。一个表的主键不仅需要唯一，而且还需要不为空，这样才能被用作其他表中的外键。
在 MySQL 中，使用 AUTO_INCREMENT 关键字可以创建一个自增字段，用于分配唯一的 ID 值，而使用 PRIMARY KEY 关键字可以将该字段设置为表的主键。这样，就可以创建一个自增主键，每次插入一行新数据时，该主键将自动递增，确保每次插入的数据有唯一的标识符，并且满足作为关系型数据库的基本特性。
创建表并为列设置约束和默认值： 例如，创建一个名为 products 的表，包含 id（自增主键，在默认情况下，自增类型字段的值从1开始，步长为1）、name、price 和 stock 列，并为 price 设置一个默认值为 0，stock 设置一个默认值为 100，并为 name 设置一个唯一约束
唯一约束是一种数据库约束，确保在列中的所有值都是唯一的，不允许重复。在MySQL中，使用UNIQUE关键字或在创建表时指定UNIQUE约束来实现。唯一约束通常用于确保表中的特定列没有重复的数值，例如，可以在用户名列上应用唯一约束，以确保每个用户都有一个唯一的用户名。
利用子查询来创建表 从已建立的表中提取部分记录来创建新表。例如：
根据dept表生成新表。
CREATE TABLE newtable SELECT * FROM dept 利用SELECT语句来查询表中数据。 SELECT * FROM dept_c 修改表的结构 使用 ALTER TABLE 语句，这允许你添加，修改或删除表的列，以及应用约束等。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f9412af7de4e8dcfbed24ad9a8d56e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbac72877d3a94b8f43c328e0f776ed1/" rel="bookmark">
			【数据结构】栈和队列的应用——括号匹配 &#43; 表达式求值 &#43; 表达式转换 &#43;栈的递归应用&#43;队列在计算机系统中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 3.栈的应用3.1 括号匹配问题3.2 表达式求值3.2.1 三种算术表达式3.2.2 后缀表达式A.中缀转后缀B.后缀表达式的计算 3.2.3 前缀表达式A.中缀转前缀B.前缀表达式的计算 3.2.4 中缀表达式的求值 3.3 递归中栈的应用 4.队列的应用 栈基础知识：【数据结构】栈 顺序栈 链栈（共享栈 创建 进栈 出栈 读取）完整代码+解析
队列基础知识：【数据结构】队列 循环队列 双端队列——顺序队列+链式队列完整代码
3.栈的应用 3.1 括号匹配问题 问题阐述
判断一组有()[]{}这些括号的字符串，判断左右括号是否匹配。
括号需要从里向外一层层匹配，符合栈后进先出的特点，所以用栈解决括号匹配问题。 匹配流程：
算法流程：
1.创建空栈，顺序遍历括号；
2.若是左括号，压入栈中，继续扫描；
3.若是右括号，弹出栈顶元素，判断两个括号类型是否匹配；
4.遍历完后判断栈是否空。
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define ElemType char #define MaxSize 9 typedef struct { ElemType data[MaxSize]; int top; }SqStack; void InitStack(SqStack&amp; Q) { Q.top = -1; } bool isEmpty(SqStack&amp; Q) { if (Q.top == -1) return true; else return false; } bool Push(SqStack&amp; Q, ElemType x) { if (Q.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbac72877d3a94b8f43c328e0f776ed1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3494a6172a30fec8fbd2644f6563a77b/" rel="bookmark">
			leetcode：反转链表II，用C&#43;&#43; 实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		反转链表 II 问题描述 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。
C++ 实现 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(ListNode *x) : val(x-&gt;val), next(x-&gt;next) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int left, int right) { if (head == nullptr || left == right) { return head; } ListNode dummy(0); // 创建一个虚拟头节点，简化边界条件处理 dummy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3494a6172a30fec8fbd2644f6563a77b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c37325b0bbcdf09962c68eaa4256c38d/" rel="bookmark">
			数组插入元素到选择元素的后面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 /** * 复制题目 * @param data * @param index */ copyQuestion (data, index) { const newData = JSON.parse(JSON.stringify(data)) newData.uid = `${newData.componentType}-${Math.floor(Math.random() * 1000000)}` this.questionList.splice(index + 1, 0, newData) for (const item of this.questionList) { item.active = item.uid === newData.uid } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/70fe763084aeb609058ebb1cee6c1a29/" rel="bookmark">
			SSM伊犁旅游攻略网站-计算机毕业设计源码15961
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目 录
摘要 1 绪论 1.1 开发背景 1.2开发意义 1.3ssm框架 1.4论文结构与章节安排 2
2 伊犁旅游攻略网站系统分析 2.1 可行性分析 2.2 系统流程分析 2.2.1 数据增加流程 2.2.2 数据修改流程 2.2.3数据删除流程 2.3 系统功能分析 2.3.1功能性分析 2.3.2非功能性分析 2.4 系统用例分析 2.5本章小结 3 伊犁旅游攻略网站总体设计 3.1 系统架构设计 3.2 系统功能模块设计 3.2.1整体功能模块设计 3.2.2用户模块设计 3.2.3 评论管理模块设计 3.3 数据库设计 3.3.1 数据库概念结构设计 3.3.2 数据库逻辑结构设计 3.4本章小结 4 伊犁旅游攻略网站详细设计与实现 4.1用户功能模块 4.1.1 前台首页界面 4.1.2 用户注册界面 4.1.3 用户登录界面 22
4.1.4旅游资讯界面 4.1.5 攻略介绍详情界面 4.1.6 旅游景点详情界面 4.2管理员功能模块 4.2.1 资源管理界面 4.2.2 系统用户管理界面 4.2.3 交流管理界面 4.2.4订票信息管理界面 5系统测试 31
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/70fe763084aeb609058ebb1cee6c1a29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b97539af024b91efd30ada704cc5321/" rel="bookmark">
			论文翻译 - Visual Adversarial Examples Jailbreak Large Language Models
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文链接：https://arxiv.org/pdf/2306.13213.pdf
项目代码：https://github.com/Unispac/Visual-Adversarial-Examples-Jailbreak-Large-Language-Models
Visual Adversarial Examples Jailbreak Aligned Large Language Models Abstract1 Introduction2 Related Work3 Adversarial Examples as Jailbreakers3.1 Setup3.2 Our Attack3.3 Implementations of Attackers 4 Evaluating Our Attacks4.1 Models4.2 A Human Evaluation on Harmful Scenarios4.3 A Benchmark Evaluation on RealToxicityPrompts4.4 Comparing with The Text Attack Counterpart4.5 Attacks on Other Models and The Transferability 5 Analyzing Defenses6 Discussions7 Conclusion Abstract 最近，人们对将视觉集成到大型语言模型 (LLM) 中的兴趣激增，例如 Flaminggo 和 GPT-4 等视觉语言模型 (VLM)。本文阐明了这一趋势的安全性和安全性影响。首先，我们强调视觉输入的连续和高维的性质使其成为对对抗性攻击的薄弱环节，这意味着视觉集成的LLM有更大可能被攻击。其次，我们强调LLM的多功能性也为视觉攻击者提供了更多的可实现对抗目标，这扩大了安全问题的影响，不再仅仅是分类错误。为了说明这一点，我们提出了一个案例研究，在该案例研究中，我们利用视觉对抗样本来规避集成了视觉的对齐LLM的安全护栏。有趣的是，我们发现单个视觉对抗样本可以普遍地破坏一个对齐的 LLM，这迫使它注意到更多的有害指令（正常情况下不会这样），并生成了有害内容，它的范围超过了最初用于优化对抗样本的“few-shot”的贬义语料库的狭窄范围。我们的研究强调了因为追求多模态而越来越高的对抗性风险。我们的研究还将神经网络的长期研究对抗性漏洞与人工智能对齐的新兴领域联系起来。我们的攻击为 AI 对齐提出了一个基本的对抗性挑战，尤其是当下，对前沿基础模型多模态研究有了越来越多的新兴趋势。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b97539af024b91efd30ada704cc5321/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0fadebe32b16ae4f69df9685688de73/" rel="bookmark">
			Iris搭建路由模块controller&#43;审计中间件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Iris搭建路由模块controller+审计中间件 封装NewControllerRoute方法：iris_demo/route/route.go封住NewSignRoute方法，添加自定义中间件：iris_demo/util/route_util.go自定义中间件：iris_demo/middleware/audittrail_middleware.go、iris_demo/middleware/signature_middleware.go定义通用返回值：iris_demo/response/response.go封装baseController，通用controller方法：iris_demo/controller/base_controller.go定义业务controller：iris_demo/controller/user_controller.gomain方法中初始化controllers：initControllers 完整代码：
https://github.com/ziyifast/ziyifast-code_instruction/tree/main/iris_demo
项目整体结构：
1 定义route/route.go：NewControllerRoute iris_demo/route/route.go
package route import ( "github.com/kataras/iris/v12/context" ) var ControllerList = make([]*ControllerRoute, 0) type ControllerRoute struct { RouteName string ControllerObj interface{} ServiceSlice []interface{} MiddlewareSlice []context.Handler DoneHandleSlice []context.Handler } func NewControllerRoute(routeName string, controller interface{}, middlewares []context.Handler, doneHandle []context.Handler) { route := &amp;ControllerRoute{ RouteName: routeName, ControllerObj: controller, MiddlewareSlice: middlewares, DoneHandleSlice: doneHandle, } ControllerList = append(ControllerList, route) } 2 定义util/route_util.go：NewSignRoute 定义签名路由：iris_demo/util/route_util.go
package util import ( "github.com/kataras/iris/v12/context" "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0fadebe32b16ae4f69df9685688de73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5eb1d88e513ee05ae0c8c6c60bfe1a60/" rel="bookmark">
			【数据结构】图解二叉搜索树的新增、搜索、删除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念 二叉搜索树（Binary Search Tree，简称BST）也称为二叉查找树或二叉排序树，是一种具有特殊性质的二叉树数据结构。
定义和性质： 二叉搜索树中的每个节点包含一个键值，习惯上我们说左子树上所有节点的键值均小于其根节点的键值，右子树上所有节点的键值均大于其根节点的键值。二叉搜索树的左右子树也都是二叉搜索树。它能够以 O(\log n) 的时间复杂度进行插入、删除和查找操作。 基本操作： 插入：将一个新值按照二叉搜索树的性质插入到适当的位置。删除：从树中移除一个值，同时保证二叉搜索树的性质不被破坏。查找：检查树中是否存在某个特定的值。查询排名：查找比给定值小的数的个数加一（即该值在有序序列中的位置）。查询指定排名的元素：找到有序序列中特定位置的元素。求前驱和后继：分别找到小于某值的最大数和大于某值的最小数。 优势： 相比于数组，二叉搜索树提供了更快的插入和删除操作，因为数组的插入和删除操作需要移动大量元素来维护有序性，时间复杂度为O(n)；而链表虽然可以快速插入和删除，但是查找等其他操作的时间复杂度不够优秀。二叉搜索树结合了两者的优点，对于上述每个操作都拥有较好的时间复杂度。 综上所述，二叉搜索树是计算机科学中一种非常重要的数据结构，它不仅提供了高效的数据检索功能，还允许数据的动态插入和删除，因此在数据库索引、内存管理等领域得到了广泛的应用。
二、图解 1.查找 有如下这样一颗二叉树，我们需要查询9所在节点
这时根节点值为7比目标值小，所以我们一应该去右子树中寻找
当前cur节点的值依旧比目标值9要小，于是我们又去他的右子树中寻找
此时cur节点值比目标值大，我们就可以去他的左边去寻找
此时相等结束寻找
2.插入 首先我们分别将21、1、15、10分别插入这颗二叉搜索树
首先我们需要找到合适的位置，定义一个指针从根节点开始寻找，先模拟插入1
此时值比待插入节点值大，于是去遍历左子树寻找合适的位置
还是比待插入节点大，再次往左走
依旧往左发现往左为空，于是我们就可以将1插入到此处，但是要想插入到这里，我们需要记录父亲节点，所以在遍历的时候我们需要记录父亲节点位置
重复上述步骤插入10
我们发现每次插入都落在了叶子节点上
所以我们只需要找到插入位置的父亲节点即可
3.删除 二叉搜索树的删除操作主要涉及以下几种情况：
删除叶子节点：如果待删除的节点是叶子节点，即没有子节点，可以直接删除该节点。删除只有左子树的节点：如果待删除的节点只有一个左子节点，可以用其左子节点替代待删除节点的位置。删除只有右子树的节点：如果待删除的节点只有一个右子节点，可以用其右子节点替代待删除节点的位置。删除左右子树均不空的节点：这种情况最为复杂。通常的做法是找到该节点的右子树中的最小节点（或者左子树中的最大节点），用这个节点的值替换待删除节点的值，然后删除那个最小（或最大）节点。 具体步骤如下：
查找节点：首先需要找到要删除的节点。这通常是通过递归搜索完成的，比较待删除值与当前节点值的大小，然后决定是向左子树还是右子树继续搜索。替换节点：一旦找到了要删除的节点，根据上述情况采取相应的替换策略。如果是第四种情况，需要找到合适的替换节点并进行值的交换。维护BST性质：在删除节点后，需要确保树仍然保持二叉搜索树的性质，即任何节点的值都大于其左子树中的所有值，小于其右子树中的所有值。处理替换节点的子树：如果替换节点有子节点，需要将其子节点接到被替换节点的相应位置，以保持树的结构完整性。 总的来说，二叉搜索树的删除操作是一个相对复杂的过程，需要根据不同的情况采取不同的策略，并且在整个过程中保持树的平衡和有序性。
下面将图解上述三种情况：
一、首先是待删除的节点没有左节点：
没有左节点将会分为以下三种情况：下图中节点值未按照二叉搜索树规则，注意节点位置即可其中值可忽略
1.待删除节点是根节点
只需要让根节点root指向root.right即可
2.待删除节点是父亲节点的左孩子
我们只需让parent.left=cur.right。
3.待删除节点是父亲节点右孩子
只需要让parent.right=cur.right
二、待删除节点没有右节点
1.待删除节点是根节点：
这个时候只需让root = root.left即可
2.待删除节点是父亲节点的左孩子
这个时候只需要让parent.left=cur.left
3.待删节点是父亲节点的右孩子
只需要让parent.right=cur.left
三、待删除节点有两个孩子
这种情况最为复杂。通常的做法是找到该节点的右子树中的最小节点（或者左子树中的最大节点），用这个节点的值替换待删除节点的值，然后删除那个最小（或最大）节点。
首先我们可以在待删除节点位置开始去他的左子树中寻找最大值（左子树中都比当前节点值小）然后进行替换，或者去右子树中寻找最小值进行替换
我们只需要在左子树中寻找到最大值，然后进行替换将左子树中最大值删掉即可
三、代码实现 import java.util.LinkedList; import java.util.Queue; public class BinaryTree extends 余胜军{ static class TreeNode extends 余胜军 { int val; TreeNode left; TreeNode right; public TreeNode(int val) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5eb1d88e513ee05ae0c8c6c60bfe1a60/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff2f804fdfecd4826ab47b08df328425/" rel="bookmark">
			c&#43;&#43;中list的简单实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 list介绍节点类(listNode)__list__iterator(迭代器类)operator-&gt; list的成员函数empty_init() 初始化节点list(list&lt;T&gt;&amp; lt) 拷贝构造clear() 清除链表~list() 析构insert() 插入erase() 删除push_back() 尾插push_front() 头插pop_back() 尾删pop_front() 头删begin() 头节点end() 尾节点 总结 list 介绍 list:
是数据结构中的链表，存储方式是在内存中每一个节点取一段空间用特定的方式链接起来，这样子就不会有浪费的空间
我们用的是带头循环双向链表
节点类(listNode) 因为一个节点中要包含其他信息所以单独弄成一个类
template&lt;class T&gt; //链表节点类 struct listNode { listNode&lt;T&gt;* _next;//指向下一个节点 listNode&lt;T&gt;* _prev;//指向上一个节点 T date;//内容 listNode(const T&amp; x = T()) :_next(nullptr) ,_prev(nullptr) ,date(x) {} }; __list__iterator(迭代器类) 为什么要有迭代器类呢?
因为我们要封装一下这个迭代器，让迭代器该有的操作在list也可以用出来。
如果在list内部弄迭代器会很不好弄。
//正向迭代器类 //Ref 来区别const和普通 template&lt;class T,class Ref,class Ptr&gt; struct __list__iterator { typedef listNode&lt;T&gt; Node;//减少代码 typedef __list__iterator&lt;T,Ref&gt; self;//来控制他的类别 Node* _node;//节点 __list__iterator(Node* node) :_node(node) {} //++it self&amp; operator++() { _node = _node-&gt;_next; return *this; } //it++ self&amp; operator++(int) { self tmp(*this); _node = _node-&gt;_next; return tmp; } self&amp; operator--() { _node= _node-&gt;_prev; return *this; } self&amp; operator--(int) { self tmp(*this); _node = _node-&gt;_prev; return tmp; } Ref operator*() { return _node-&gt;date; } bool operator!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ff2f804fdfecd4826ab47b08df328425/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5009e75d4cdb534c0bfd308a96a4663/" rel="bookmark">
			先登杯·14天创作挑战营·第三期，正式开营！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		​
​
文章目录 ⭐️ 活动介绍⭐️ 活动详情⭐️ 活动奖品⭐️ 活动流程​⭐️ 评审规则⭐️ 报名&amp;投稿注意事项⭐️ 活动组织 活动报名入口：https://bbs.csdn.net/topics/618159754 本次活动与官方活动及其他博主的创作型活动并不不冲突！ ​
​
⭐️ 活动介绍 亲爱的小伙伴们，先登杯·14天创作挑战营·第三期又要开始了哦。我们诚挚邀请你们参加 为期14天的创作挑战赛 ！这是一个以写作博客为目的的创作活动，旨在鼓励 大学生博主 们挖掘自己的创作潜能，展现自己的写作才华。
如果你是一位热爱写作的、想要展现自己创作才华的小伙伴，那么，快来参加吧！我们一起发掘写作的魅力，书写出属于我们的故事。
⭐️ 活动详情 1、挑战时间：本次活动将持续14天，从 2024年3月11日 开始 ，至 2024年3月24日 结束；
2、参赛要求：参赛者必须是 在校大学生，通过 学校认证 或 码龄小于等于4年 ；
3、创作主题：内容题材不限，发布的博文需与计算机领域相关 ，VIP、付费专栏文章均不纳入统计；
4、创作形式：自由选择创作形式，单篇要求500字以上（不含代码串），且配有图片、代码等为佳；
5、提交要求：原创公开首发至CSDN，且自发文满3个工作日后，方可发布至其他平台；
6、评审规则：根据创作质量、创新性和表达能力等方面评选；（详见下方「评审规则」）
7、精彩互动：将建立专属社群，参赛者可以在群内进行交流、分享创作心得，互相鼓励与支持；
8、活动总结：活动结束后，将邀请优秀博主分享创作心得和经验，提供交流与互动的机会。
⭐️ 活动奖品 ​
⭐️ 活动流程​ ⭐️ 评审规则 1、文章必须原创公开首发至CSDN，且自发文满3个工作日后，方可发布至其他平台；2、发布的博文需与赛道领域相关，非技术文、VIP、付费专栏文章均不纳入统计；3、单篇文字字数要求500字以上（不含代码串），且配有图片、视频、代码、流程图为佳；4、内容专业有深度，可读性高，能引起共鸣、互动等；5、标题党、黑稿、通稿、包含违法违规、未被许可的商业推广、外站链接等内容不予奖励；6、涉及抄袭、刷量等行为停止一切奖项发放，收回用户已领取的奖励，保留追究用户责任的权利。 1、在活动期间需完成最少完成 2 篇创作，博文质量分≥80，否则视为参与资格无效。（此为完成任务门槛）2、刷算法题文章、打靶场类、商务合作类、宣发类文章，不计入有效文章统计，不参与活动积分累计。3、本次活动采取积分制，每完成一篇文章创作积 2 分，上热榜积 5分，热榜期间进入 Top3 积 10 分。4、相同周期内，单篇文章积分不累计。同一篇文章进入热榜、进入Top3，取最高分值 8 分。 ⭐️ 报名&amp;投稿注意事项 1、请参加活动的 小伙伴，在活动贴评论区回复 “我要报名 「14天创作挑战营」” 。2、得到明确回复 -「确认报名」后，为报名成功；报名时间为：3月4日 ~ 3月10日。3、投稿期间，请添加下方微信，进入活动交流群方为有效活动参与资质，否则视为无效。 ⭐️ 活动组织 ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5009e75d4cdb534c0bfd308a96a4663/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c91453fb1655bf58293747c070dd8934/" rel="bookmark">
			linux 错误编号使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#define MAX_ERRNO	4095 #define	EINVAL	22	/* Invalid argument */ #define IS_ERR_VALUE(x) unlikely((x) &gt;= (unsigned long)-MAX_ERRNO) static inline bool __must_check IS_ERR(__force const void *ptr) { return IS_ERR_VALUE((unsigned long)ptr); } static inline void * __must_check ERR_PTR(long error) { return (void *) error; } //函数返回值使用 return ERR_PTR(-EINVAL); //判断函数返回值 if (!IS_ERR(p)) { ... } 1. 在 Linux 内核编程中，__must_check 是一个被广泛使用的标志，它被用于告诉编译器和程序员，某个函数的返回值必须被检查。
__must_check 是一个宏，定义在 include/linux/compiler.h 文件中，它的定义如下：
#define __must_check	__attribute__((warn_unused_result)) __attribute__((warn_unused_result)) 是 GCC 扩展的属性，其意义是如果函数的返回值没有被使用，那么编译器在编译时会发出警告。 在实际的 Linux 内核编程中，我们通常在那些 failure-prone 的系统调用函数 (比如 malloc()) 的定义上面标注 __must_check。这样做的目的是为了提醒使用这些函数的开发者注意检查这些函数的返回值，因为它们可能会失败，如果忽视了这些函数的返回值，可能会导致严重的结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c91453fb1655bf58293747c070dd8934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9342658d57c8ea2eea26d0c8f399f56/" rel="bookmark">
			Three.js--》探寻Cannon.js构建震撼的3D物理交互体验（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们用three.js可以绘制出各种酷炫的画面，但是当我们想要一个更加真实的物理效果的话，这个时候我们就需要一个物理的库，接下来我们就讲解一下今天要学习的canon，它可以给我们提供一个更加真实的物理效果，像物体的张力、摩擦力、拉伸、反弹等等各种真实的物理效果。该库都能够有一个非常好的模拟。
PS：目前博主在一家互联网公司工作，该公司的编码风格是vue+tsx，所以接下来的项目以该编码风格进行举例，详细了解参考我之前的文章：地址 。
目录
碰撞与碰撞事件
休眠与休眠事件
物体形状组合
物体施加作用力
碰撞与碰撞事件 在上一篇文章我们讲解到了碰撞的一些基本概念：地址 ，接下来我们开始学习如何监听和获取碰撞的事件和信息，如下：
得到的结果如下所示：
我们可以点击监听信息e查看一下，有如下重要的信息：
我们点击contact进入到里面，可以找到一个函数来查看当前物体碰撞的碰撞速度：
接下来通过函数来对当前物体的碰撞速度度进行一个监听：
// 监听立方体 boxBody.addEventListener("collide", (e) =&gt; { console.log("碰撞了", e) let impactStrength = e.contact.getImpactVelocityAlongNormal() console.log("当前的碰撞速度：", impactStrength) }) 可以看到，随着时间的流逝，碰撞的高度逐渐减小，物体相互之间的碰撞速度也在逐渐减少：
休眠与休眠事件 物体的休眠指的是当物体在物理世界中没有发生运动时，会进入休眠状态以减少计算负担。当物体处于休眠状态时，物理引擎会暂停对该物体的碰撞检测和运动模拟，从而节省计算资源。只有在物体被外力唤醒（如碰撞或施加力）时，物体才会从休眠状态中唤醒，重新参与物理模拟。休眠状态有助于提高物理引擎的性能并减少不必要的计算开销。
我们在开始的时候允许物理世界的物体可以进入休眠状态：
然后我们可以设置立方体可以进入休眠状态，以及进入休眠状态的一些条件：
如下可以看到我们已经实现了立方体休眠的效果：
当然如果想监听休眠事件的话可以通过如下的方式进行：
在最后的那一刻物体进入到了休眠的状态：
物体形状组合 接下来我们通过设置物体的位置，让物体之间相互组合在一起，如下：
// 创建由两个球加一个圆柱体组成的胶囊体 const capsuleBody = new CANNON.Body({ mass: 1, position: new CANNON.Vec3(0, 5, 0), material: boxMaterialCon, }) // 创建一个球的几何体 const sphereShape = new CANNON.Sphere(0.5) // 创建一个圆柱体几何体 const cylinderShape = new CANNON.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f9342658d57c8ea2eea26d0c8f399f56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35cdf985e81c1d3bfde4eec5d5907e63/" rel="bookmark">
			ARM如何利用PMU（Performance Monitor Unit）量化L3 cache的cache eviction（估算cache eviction的概率）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文将介绍如何利用DSU（DynamIQ™ Shared Unit）中的PMU，来监控L3 cache的 一些事件，通过对事件的分析，估算出L3 cache中的cache line conflict（eviction）概率。
一，PMU 都位于哪里 ？ 在一个 DynamIQ™ cluster 里，集成了一个甚至多个core，以及一个DSU。如下图所示，为一个标准的DynamIQ微架构，里面实现了四个小核以及两个大核，每个核里实现了L1和L2两级cache。并且它们共用一个DSU，DSU里有L3 cache、SCU、内存接口、Debug接口、ACP以及外设接口等等。
回到我们的主题，PMU位于哪里？从下图可以看出，每个Core有自己独立的PMU，可以用于监控每个core私有的L1以及L2 cache的事件。
不仅如此，在DSU内部，也有一个PMU，可以用来监控L3 cache以及cluster内存操作的相关事件。
下面我将介绍一些与L3 cache相关的PMU event。
二，PMU events- 0x0029，L3D_CACHE_ALLOCATE L3D_CACHE_ALLOCATE事件的event number为0x29，它会把除了L3D_CACHE_REFILL事件以外的，所有写入一整个cache line到L3 cache的事件发生的次数记录下来。它不会记录从L3 cache 以外的地方（下一级内存）拿数据写入L3的操作，比如，L3D_CACHE_ALLOCATE事件包括如下操作：
从L2 cache 将整个cache line 写回到L3 cache的动作。从write buffer对整个cache line写入到L3 cache。使用 DC ZVA操作对L3 cache 清零的操作。 三，PMU events-0x002A， L3D_CACHE_REFILL L3D_CACHE_REFILL事件主要包括cache line 填充事件，不管是填充的L1 cache 、L2 cache还是L3 cache，只要发生了从这些cache 外部获取数据，填充到cache line中，就包含在L3D_CACHE_REFILL事件中。
换句话说，只要从L1、L2以及L3以外的地方拿数据，并发生了cache line的填充，就算该数据没有被分配到L3cache 中，也属于L3D_CACHE_REFILL事件。
比如从cache外部获取的数据直接被放在了buffer中，而不是被分配到cache中，就算buffer里的数据随即被丢弃，这也算在L3D_CACHE_REFILL事件中，因为处理器里的各种buffer也被PMU当作是cache的一部分。
再举些例子，以下操作都算在L3D_CACHE_REFILL事件中：
访问L3 cache数据时，该操作导致从外部内存、下一级cache或者其他处理器的L3中获取数据进行cache line填充。由于对L1或者L2cache的填充或者由L1、L2写回到L3的操作，导致发生了从当前处理器的L1、L2或者L3 之外的地方获取数据，填充到当前处理器的cache。访问L3 cache的数据时，导致了L2 cache的cache 填充，该数据来自当前处理器L1、L2以及L3之外的地方，就算没有填充到L3，也会被记录。 四，PMU events- 0x002C，L3D_CACHE_WB L3D_CACHE_WB事件主要就是L3 cache上的数据写回到下一级内存中的事件。比如：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35cdf985e81c1d3bfde4eec5d5907e63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6df346685a50000cc65d35707c3f009f/" rel="bookmark">
			6.2 指标的应用与设计（12%）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、指标的作用 用简约的汇总数据量化业务强弱。
2、指标的理解 特点：
（1）指标是游离态的，无法单独实现数据统计 eg：总销售额、总销售量
（2）需与统计维度结合，明确统计指标的对象， eg：产品时间维度下，x年所有产品的总销售额
（3）指标间可自由组合形成新指标，灵活适应多变的业务环境
3、基本指标 1、求和类 库存、银行存款等，本身就有累积属性，不需要再进行累计。
2、计数类 对度量计数得到的指标，需注意数据的唯一性。
3、比较类-差异百分比 A.均比 B.定基比 C.同比、环比 上月为啥空值？ 说明可能是新业务上线，1月恰好是统计初期；
4、常用场景指标 1、流量相关指标 1、常用计费方式： CPM：Pcost per mille 按每千次曝光收费 （展示了一千次，则收取一千次费用）CPS：cost per sales 按实际销售收费 （从大平台到小平台的用户且发生了购买，来折算费用）CPC：cost per click 按点击次数收费 （流量在大平台点击了对应的广告） 例如：平台间流量的流转
引申：
2.相关名词 评估数据有效性，从2个方面考虑：
1、【量】
UV——访客数；访问对应维度的非重复用户数
PV——浏览量；维度下浏览页面的总次数
visits——访问次数；统计会话数，一个会话内用户可访问多个页面
新访客数——新进访客数
2、【质】
平均访问深度：浏览量/访问次数 跳失率：跳出次数/访问次数 体现的用户的兴趣；点击后啥也没干直接关闭；
新访客占比：新访客数/访客数 示例：
访客数(UV) =1
浏览量(PV)=5 （上午2个；下午3个）
访问次数= 2
平均访问深度= 2.5 (浏览量/访问次数)
跳失率= 0 无跳失行为
2、转化相关指标 转化率：根据业务流程观测阶段间流转后的留存比率，用以辅助决策者了解阶段间衔接的流畅性。
公式： 当前阶段/初始阶段（或上一个阶段）*100% eg：有4个阶段，分别统计出对应的用户数
3、营运、销售相关指标 GMV：实际完成的订单金额；用户的购买需求。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6df346685a50000cc65d35707c3f009f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/410e63139c0692af1001df03124d611f/" rel="bookmark">
			107. sort( )方法-排序列表元素（上）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		107. sort( )方法-排序列表元素（上） 【目录】
文章目录 107. sort( )方法-排序列表元素（上）1. 作用2. 语法3. 数值列表排序4. key = str.lower 排序时不区分字母大小写5. 如何理解区分大小写6. key = len 按照元素的长度进行排序7. 总结 【正文】 1. 作用 sort [sɔːt]：整理、排序。
sort的中文意思是排序。
sort是列表对象的一个方法。
【功能】对列表进行排序操作。
sort的作用是对原列表中的元素进行排序。
排序后原列表中的元素顺序发生改变。
2. 语法 【语法】
listname.sort(key=None, reverse=False) 【语法解析】
listname要进行排序的列表对象名。.英文小圆点。sort方法名。( )英文圆括号。参数key：可选参数。 用于指定排序的依据。可以是一个函数或lambda表达式。用于生成排序的键值。默认为None，表示按照元素的原始值进行排序。 参数reverse：可选参数。 用于指定排序的顺序。默认为False，表示按照升序排序。设置为True时，表示按照降序排序。 【参数key】
key = 函数
Key = lambda表达式
【功能】生成排序的键值。
【参数reverse】
reverse[rɪˈvɜːs]反转；颠倒。
reverse = False — 升序
reverse = True — 降序
3. 数值列表排序 reverse = False — 升序reverse = True — 降序 【代码示例】
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/410e63139c0692af1001df03124d611f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a34cd27008fc845da5d79ca8c891ce52/" rel="bookmark">
			ffmpeg 转码过程中参数含义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ffmpeg 转码过程中参数含义
frame= 649 fps= 73 q=28.0 size= 3072kB time=00:00:25.88 bitrate= 972.4kbits/ frame= 694 fps= 74 q=28.0 size= 3328kB time=00:00:27.68 bitrate= 984.9kbits/ frame= 732 fps= 74 q=28.0 size= 3584kB time=00:00:29.20 bitrate=1005.5kbits/ frame= 771 fps= 74 q=28.0 size= 3840kB time=00:00:30.76 bitrate=1022.7kbits/ frame= 812 fps= 74 q=28.0 size= 3840kB time=00:00:32.40 bitrate= 970.9kbits/ frame= 852 fps= 74 q=28.0 size= 4096kB time=00:00:34.00 bitrate= 986.9kbits/ frame= 889 fps= 74 q=28.0 size= 4352kB time=00:00:35.48 bitrate=1004.8kbits/ frame= 926 fps= 74 q=28.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a34cd27008fc845da5d79ca8c891ce52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad3b7893b727de4811e8ab0df8914c3/" rel="bookmark">
			【p3128、LQB14I砍树】树上差分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 差分树上差分p3128LQB14I砍树题目解题步骤代码样例 差分 差分数组求法：
设原始数组是arr，差分数组是b
b[0] = arr[0];b[i] = arr[i] - arr[i-1]; 如果我们要对图中2-4区间的数每个都加上3，就可以在差分数组2的位置加上3，在差分数组4的后一个元素即5的位置减去一个3（目的是消除3对后面区间的影响），再对差分数组前缀和即可完成。
树上差分 多次对树上路径做加法操作，然后询问对某个点操作后的值，适用树上差分。
差分数组求法：
叶子节点的差分值是叶子节点的权重其他节点的差分值是权-子权和 权 = 差分值 + 子权和 p3128 LQB14I砍树 题目 题目信息：
给定一棵由 n 个结点组成的树以及 m 个不重复的无序数对 (a1, b1), (a2, b2),
. . . , (am, bm)，其中 ai 互不相同，bi 互不相同，ai ≠ bj(1 ≤ i, j ≤ m)。
小明想知道是否能够选择一条树上的边砍断，使得对于每个 (ai , bi) 满足 ai和 bi 不连通，如果可以则输出应该断掉的边的编号（编号按输入顺序从 1 开始），否则输出 -1.
输入输出：
输入共 n + m 行，第一行为两个正整数 n，m。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dad3b7893b727de4811e8ab0df8914c3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/49/">«</a>
	<span class="pagination__item pagination__item--current">50/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/51/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>