<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b65219cf78176da80820823048f97b9/" rel="bookmark">
			git回退的四种操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610af63ce7e9ce561836befdc5c49cd7/" rel="bookmark">
			一文彻底读懂【极大似然估计】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		极大似然估计（Maximum Likelihood Estimate） 一、背景知识二、从概率模型理解极大似然估计三、极大似然估计的理论原理四、应用场景 一、背景知识 1822年首先由德国数学家高斯（C. F. Gauss）在处理正态分布时首次提出；1921年，英国统计学家罗纳德·费希尔（R. A. Fisher）证明其相关性质，得到广泛应用，数学史将其归功于费希尔。研究问题本质背后的深刻原因在于，现实世界本身就是不确定的，人类的观察能力是有局限性的，就是利用已知的样本信息，反向推导最有可能（即最大概率）导致这些样本结果出现的模型参数值。极大似然估计，提供了一种给定观察数据来评估模型参数的方法。也就是似然函数的直观意义是刻画参数 与样本数据的匹配程度。 二、从概率模型理解极大似然估计 离散型统计模型：
连续型统计模型：
从一个直观的例子理解极大似然估计，比如：在一个未知的袋子里摸球，现有的认知告诉我们是袋子里面的球要么是红色，要么是蓝色。于是我们可以知道从该袋子中摸球颜色的概率服从二项分布如下： X红色蓝色Pθ1-θ 由于不知道袋子中究竟有多少个球以及每个颜色的球有多少个，所以无法对参数θ进行计算，也不能计算出摸到哪种颜色的球的概率是多少？于是，假设有一个测试人员对袋内球进行有放回的抽取，进行了100次随机测验之后，统计得出：有30次摸到的是红球，有70次摸到的是蓝球。从现有的测试结果出发，我们有理由相信袋子中球的比例大概是红色 : 蓝色=3 : 7（也就是背后的理论支撑）。所以进而求出概率以及参数 θ=0.3 。也就是用抽样时球的颜色出现的频率近似等于概率。
注意的是，极大似然估计中采样需满足一个重要的假设，就是所有的采样都是独立同分布的。 如何理解这个公式呢？由于抽样的结果是确定的，而每次抽样的积事件组成了现在已知的既定事件，所以“独立同分布”且属于二项分布。而现在我们的求解目的转为：使似然函数最大化，因为事件已经确定发生了，我们根据观测的结果出发，则使其“积事件”的概率无限接近于1（因为已经发生了嘛）也就是说最大化。
这样就从理论化的角度描述了“状态1”发生的概率与直观一致，为了使总体参数尽可能与现有观测值相匹配，所以要让似然函数达到最大值。
三、极大似然估计的理论原理 上面的描述为了直观和简洁，忽视了逻辑上和表示上的严谨性。下面从纯理论化的语言进行严格描述。不过在使用极大似然估计时，始终要记住的是：独立同分布。
涉及太多公式，造成阅读不便还请谅解！
注意这里的 是一个向量，因为往往求解的模型参数不止一个。然后根据所求的偏导数利用梯度下降法逐步更新参数，以取得近似最优解。
为了便于理解计算的过程，这里通过正态分布的样本随机变量进行模拟求解，正态分布的公式如下：
四、应用场景 极大似然估计在机器学习的理论算法研究中应用广泛，尤其是涉及到机器学习损失函数最小化时，往往会在似然函数中添加负号，以达到最小化的目的。先研究线性回归时，不仅可以根据MSE建立最小误差函数，也可以从正态分布和极大似然估计的角度进行推导。机器学习算法中使用极大似然估计的算法有朴素贝叶斯、EM算法等。
另外极大似然函数特别擅长于处理与概率相关的问题，因为模型的求解往往就是参数的求解，根据批量的随机样本最大化近似或者模拟现实世界，在应用中使用得比较频繁的往往还是离散型随机变量的似然函数求解，而连续型以正态分布函数较为常见。利用极大似然估计建立的损失函数模型，需要进一步借助梯度下降法来不断的更新迭代参数，来对参数进行求解。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05d2c1359ab35533ade706a57fa5d7b2/" rel="bookmark">
			pycharm重装还能使用之前的库吗？pycharm安全卸载、重装、学生认证、使用之前的第三方库---一气呵成！简单易懂！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.之前的库包2.删除3.重新安装4.认证免费5.导入之前的第三方库6.成功 因为之前的pycharm是社区版的，有些功能不全，所以需要重装专业版
重装pycharm最大的顾虑就是之前的库能否保留以及能否删除干净
1.之前的库包 卸载之前找到我之前的库包所用编译器，记下路径就行
注意：因为python跟pycharm是单独存在的，所以删除的pycharm并没有影响python里安装的库包
2.删除 正版软件删除是最简单的，找到文件所在位置，直接卸载就行
这里注意两个红色箭头要全选，然后等待卸载结束就行。
3.重新安装 下载链接：http://www.jetbrains.com/pycharm/download/#section=windows
Pycharm有两个版本，专业版和社区版，其中社区版是免费的
这里选择专业版下载，安装的时候自己设置安装路径（别放在c盘就行），一路默认就行
4.认证免费 使用学生邮箱可以免费使用pycharm，所以这里先在pycharm官网注册，然后使用学生邮箱认证即可
直接参考如下博客：
https://blog.csdn.net/qq_36667170/article/details/79905198
认证好了就在pycharm里登陆账号就行
5.导入之前的第三方库 打开一个项目，在编译器这里加入之前的编译器就行
然后加入之前的编译器，选择existing environment就行，这里使用之前记下的路径加入即可
点击ok，等待加载完成
还不清楚的话参考这个博客：
https://blog.csdn.net/qq_31638535/article/details/80574513
6.成功 运行一个之前的项目，可以看到成功使用之前的库
都看到这里了不妨点一个赞哦~
另：之前写的安装python、pycharm、第三方库安装等教程，感兴趣的可以看看哦~
深度学习入门安装一步到位，亲测！又快又方便 | Python，pycharm，tensorflow，keras 等安装笔记
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/033f0626b449a291aa2d1ebe8bddd20e/" rel="bookmark">
			豆瓣9.6分！再一次被BBC的纪录片震惊！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		英国广播公司BBC的纪录片素来就是高质量的代名词，推出的《地球无限》(Planet Earth)、《地球的力量》(Earth The Power of the Planet)、《冷血生命》(Life In Cold Blood)等片不仅在英国播放时获得极高收视，还获得艾美奖等多个国际奖项的肯定，是对地球生命的礼赞。
BBC最新重磅推出的《南太平洋》(South Pacific)是一部围绕南太平洋生态发展变迁的故事，在海洋的神奇影响下，这里的自然生态和人文环境怒放出非同一般的生命力，洋溢着南太平洋地区独特的魅力。
那么今天小编就给大家带来这一部BBC于2009年拍摄的顶级纪录片—《南太平洋》
South Pacific 这部由BBC拍摄的纪录片，在豆瓣评分高达9.6分。向我们展示了南太平洋独有的文化历史和一系列令人赞叹的自然景观。
同时也展现了海洋中星罗棋布的岛屿的野生生态！这里是无尽的蓝色，美到让人窒息，脆弱到让人动容。
BBC摄制队于不同岛屿发现了南太平洋一系列令人赞叹的自然景观，包括难得一见的海底火山爆发、壮丽的宝石珊瑚礁、虎鲨猎获信天翁的一刻以及能撕开椰子的陆上巨蟹……
在一些被隔离的孤岛上，更发现了特别进化的食肉毛虫、有耐寒能力的吸血虫、交配时会发出像牛蛙一样叫声的怪叫鹦鹉、及尾巴像猴子尾的小蜥蜴。
南太平洋的土著是地球上最僻远的人类社会，他们会为大家细说祖先们是如何由千里多外迁徙到岛上定居。时至今日，当地居民仍依赖庄稼和捕猎为生，他们拥有独特生存技巧及保留了一些奇异的风俗仪式。
第一集 海洋岛屿
在南太平洋一些被隔离的孤岛上，发现了特别进化的食肉毛虫、有耐寒能力的吸血虫、交配时会发出像牛蛙一样叫声的怪叫鹦鹉、及尾巴像猴子尾的小蜥蜴。
第二集：漂流者
在南太平洋并没有荒岛这一回事。它们也许是地球上最偏僻，但2万余个岛屿个个都被开拓了，从新几内亚，天堂鸟的家园，部落野蛮的成人仪式将年轻的战士变成鳄鱼人，到斐济，法属玻利尼西和夏威夷。
第三集：蔚蓝大海
有人说，蔚蓝无边的南太平洋是海洋沙漠。其中生活着许多动物：有鲨鱼，鲸鱼和海龟，不得不行进异常的距离去生存。亦或是虎鲨航行数百里去享用刚会飞翔的信天翁幼雏的盛宴，每年，抹香鲸从南太平洋的一边旅行另一边去觅食和交配。它们的旅行总以悲剧为结局。
第四集：海洋火山
南太平洋升起的陆地同样为一些非常陌生的动物带来生命，从能在热带冰雪中兴旺发达的吸血虫，依靠火山泉孵蛋的塚雉，到被珊瑚山截留的大群水母群。
第五集：奇异的岛屿
在南太平洋的孤岛上有着无战斗力的鹦鹉，翻地觅食的蝙蝠，大石龙子和在树上的袋鼠。野生动物以奇怪的方式演化。在岛上生存可能要付出高代价，对于新来的物种，全都想挣脱这地狱。这里展现出一个难题：为什么动物能完美的适应了岛屿生活，轻易地放弃了灵魂？
第六集：脆弱的天堂
南太平洋仍相对健康，鱼群丰富，但这是个脆弱的天堂。国际捕鱼渔船为鲨鱼，信天翁和金枪鱼敲响了严重的警钟，对这片美丽的大海还有其它的暗藏危险。这一集注视怎么来维护海洋及其野生动物。
想要“这部高分纪录片”的资源吗？
扫描下方二维码，关注视频号“少年数学家”，在后台聊天窗口回复“太平洋”，领取。
（关注视频号少年数学家，进入私信页面，回复“太平洋”，我们将会在48小时内发送给你）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e9d60cdae205e8c11d593628180466e9/" rel="bookmark">
			时间序列（二）：时间序列平稳性检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		时间序列系列文章： 时间序列（一）：时间序列数据与时间序列预测模型
时间序列（二）：时间序列平稳性检测
时间序列（三）：ARIMA模型实战
在上一篇文章时间序列（一）：时间序列数据与时间序列预测模型中我们介绍了时间序列及一些时间序列预测模型。我们可以看到在进行预测时有一些模型表现较好，而另一些模型的预测结果却不尽人意。这是因为不同的时间序列模型对原始数据的要求是不同的，例如之前提到的ARIMA模型，要求时间序列数据平稳，否则得出的预测结果就会相差较大。本篇文章我们介绍时间序列的平稳性、随机性检验及相关时间序列数据处理方法。
时间序列的平稳性、随机性检验 在拿到时间序列数据后，首先要对数据的随机性和平稳性进行检测， 这两个检测是时间序列预测的重要部分。根据不同检测结果需要采取不同的分析方法。
为什么时间序列要求平稳性呢？平稳性就是要求由样本拟合出的曲线在未来一段时间内仍然能够以现有的形态和趋势发展下去，这样预测结果才会有意义。
对于平稳声序列， 它的均值和方差是常数， 现已有一套非常成熟的平稳序列的建模方法。 通常是建立一个线性模型来拟合该序列的发展 借此提取该序列的有用信息。
对于非平稳序列， 由于它的均值和方差不稳定， 处理方法一般是将其转变为平稳序列，这样就可以应用有关平稳时间序列的分析方法， 如建立 ARIMA模型来进行相应的研究，或者分解趋势与季节性等并根据情况应用指数平滑模型等。
对于纯随机序列， 又称为白噪声序列， 序列的各项之间没有任何相关关系， 序列在进行完全无序的随机波动， 可以终止对该序列的分析。 白噪声序列是没有信息可提取的平稳序列。
在讲解平稳性和随机性的定义之前，我们先介绍一下时间序列中常用的几个特征统计量。
时间序列的特征统计量 对于一个时间序列任意时刻的序列值 { X t , t ∈ T } \left\{ X _ { t } , t \in T \right\} {Xt​,t∈T}，任意时刻的序列值 X t X _ { t } Xt​都是一个随机变量，记其分布函数为 F t ( x ) F _ { t } ( x ) Ft​(x),则其特征统计量均值、方差、自协方差函数、自相关系数的定义分别如下:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e9d60cdae205e8c11d593628180466e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bab094ae31ddaeb4c058da7b14851c8/" rel="bookmark">
			maven私库nexus2.14.1迁移到nexus3.1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		maven私库nexus2.14.1迁移到nexus3.1（含安装教程），亲测可用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f7395a76657d1b3a92f9c3812db73cd/" rel="bookmark">
			解决docker push/pull 报错unauthorized: access to the requested resource is not authorized
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 不管是harbor、nexus、registry管理docker镜像，如果没有登录，在执行docker push或docker pull的时候会报这个错
解决 执行docker login ip:5000，进行登录操作
此时执行push 或 pull发现可以执行成功了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53e1958e6b606eba6439c68657b08461/" rel="bookmark">
			Abaqus后处理 - 常用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文转自：Abaqus中的后处理（Visualization）功能图文讲解
目录
1. 显示最大、最小应力
2 后处理图例,版本号,坐标系等
3 后处理中显示边界条件
4 在模型上只显示云图,不显示网格
5 调整变形放大系数(Deformation Scal Factor)
6 如何保存结果处理后的odb结果
7 如何查看job monitor里面提示的警告或错误在模型哪个位置
8 如何在XY data中绘制非以时间为横轴(如横轴为位移,纵轴为载荷)的曲线
9 如何在visualization模块里得到图形中某一节点的位移时间图
10 abaqus的多图层绘图
11 ABAQUS透明度显示操作
之前发了一个关于ABAQUS中Mesh的帖子(Abaqus中的Mesh—如何将一个圆柱体划分成如图(封面图)的网格),通过具体实例来讲解在ABAQUS中如何划分网格,后续会持续更新。
这个帖子讲解一下Abaqus中的后处理(Visualization)功能,后续也会持续更新~
1. 显示最大、最小应力 上述方法只能在legend上显示最大最小值
这种方法还能在云图里面显示最大最小值的位置
2 后处理图例,版本号,坐标系等 3 后处理中显示边界条件 4 在模型上只显示云图,不显示网格 5 调整变形放大系数(Deformation Scal Factor) 非线性问题,这个默认为是1(也就是不放大)。
6 如何保存结果处理后的odb结果 从visualization打开odb文件,并取消勾选read only,对已有的XY-data作copy to odb操作。
7 如何查看job monitor里面提示的警告或错误在模型哪个位置 job步提交运算后警告信息出现setwarning 或者nodewarning,(类似这样的语句:
....have been identified in element set
ErrElemVolSmallNegZero
.... identified in element set
ErrElemDistorted
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53e1958e6b606eba6439c68657b08461/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12c2a3014ba05f13ee5667fd921bc90c/" rel="bookmark">
			Pandas学习笔记（三）处理丢失数据&amp;导入导出数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、处理丢失数据1.导入库&amp;建含有NaN数据表2.删除有NaN数据的行&amp;列3.替换NaN的值4.判断NaN数据 二、使用步骤1.引入库2.导入数据5.查看数据1）info()方法 查看详细信息2）head()方法 前几个数据3）tail()方法 后几个数据 4.导出数据 前言 这一节主要介绍如何处理丢失数据以及导入导出数据的方法
一、处理丢失数据 1.导入库&amp;建含有NaN数据表 import numpy as np import pandas as pd dates = pd.date_range("20210124", periods=6) df = pd.DataFrame(np.arange(24).reshape((6, 4)), index=dates, columns=["A", "B", "C", "D"]) df.iloc[0, 1] = np.nan df.iloc[1, 2] = np.nan print(df) 结果显示：
2.删除有NaN数据的行&amp;列 1）存在NaN就删除行
print(df.dropna( axis=0, # 0对行进行操作 1对列进行操作 how='any' # 'any':只要存在NaN就丢掉(默认方法)；'all':必须全部是NaN才drop )) 结果显示：
2）存在NaN就删除列
print(df.dropna(axis=1, how="any")) 结果显示：
3）全为NaN才删除
print(df.dropna(axis=0, how="all")) 结果显示：
3.替换NaN的值 print(df.fillna(value=0)) # 替换NaN值为0 结果显示：
4.判断NaN数据 1）判断表中各值
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/12c2a3014ba05f13ee5667fd921bc90c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/309a4ed54224e8be3121b8399f3cc037/" rel="bookmark">
			Android中R.java文件详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		R.java文件有两种，两种文件作用一样都是获取资源的引用，区别在于一个存放着我们写的项目中资源的引用，另一个存放着系统定义好的一些资源
1.1 项目的R.java文件 先说第一种是项目编译出来的R.java文件，我们平常所用的R.layout、R.id等，都是存储在这个文件中。
在以前使用eclipse开发时，这个文件的位置在
现在这个gen目录已经没有了，使用as进行开发时，该文件的位置在
这个文件是一个jar包，为了看看它的内容，我添加到项目中，才可以查看源码。
右侧的源码面板就是这个jar包的内容
1.2 SDK中的R.java 这个类呢并不是项目中的文件，而是SDK提供的类
可以使用Ctrl + N快捷键来搜索
1.3 R.java内容详解 刚才分别介绍了一下两个R类的位置与查看方法，现在给大家看一下内容吧。
第一种项目生成的R.jar文件是我们常用的，基本用法是R.资源类型.资源名称
资源名称是我们自己定义好的资源文件xml的命名资源类型是资源所对应的存储文件夹的名字，但在R类中的形式是以内部类的形式来存在的，其中的每个资源都定义为了int类型的常量，指向对应的文件
我在资源中定义的布局文件也可以在其中找到定义。
第二种SDK提供的R类，其模式与上面的一样，使用方式是android.R.资源类型.资源名称；
这里面的使用不太多，经常使用android.R.layout.simple_list_item1和ListView+ArrayAdapter搭配使用，显示简单的文本列表框
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d1b6cab8b1bf09b2f2c2516d05fb0537/" rel="bookmark">
			node图片转base64
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 var data = 'https://isv.alibabausercontent.com/00000000/imgextra/i1/2634283647/O1CN01wtk46L1coN6mnZbbK_!!2634283647-2-isvtu-00000000.png'　//Buffer.concat将chunks数组中的缓冲数据拼接起来，返回一个新的Buffer对象赋值给data var base64Img =Buffer.from(data).toString('base64');　//将Buffer对象转换为字符串并以base64编码格式显示 console.log(base64Img,"????????????????"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7de22ddc63fc4fe6c61c53c036930e/" rel="bookmark">
			降低数据库压力的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.合理增加索引
表索引可以加快对表中数据的检索速度，但是会降低表中数据的更新速度，所以增加表的索引一定控制在合理范围内，过多的索引不但不会降低数据库的压力，反而可能增大数据库的压力，表索引的建立一般要从具体业务场景出发，对于读多写少的场景，可以通过适当的增加索引来提高效率，对表的那些列建立索引？建立单独索引还是建立复合索引？要根据具体的业务场景来决定，建立索引之后可以针对索引对业务逻辑中使用的SQL进行优化，建立索引是最基础的手段，这里不错过多的介绍。
2.数据截转
一般情况下，业务中所处理的数据的都具有一定的时间间隔，所以可以通过对业务进行梳理，将当前时间间隔之外的数据进行截转，截转到历史数据库中，通过对业务进行拆分，当需要历史数据时，可以转到历史数据库中进行查询，或者修改，通过减少当前数据库的数据量，来减轻当前业务数据的压力。数据截转一般情况下是按照时间来进行，所以在业务员数据库设计的时候就要考虑到时间这个因素。
数据截转可以进行间隔一段时间做一次手工的数据截转，也可以启动一个定时器，每个一段时间进行一次数据截转，推荐的方式是准实时截转，及每天在业务量较小的时间，启动任务实时截转。
数据截转需要注意的几个问题：（1）外键关联关系（特别是有主键ID的关联的）注意在截转的历史数据库中的关联关系是否正确。(2)保证生产库和历史库的业务关联关系，从而避免历史库的数据需要关联生产库中的数据。
3.增加缓存
缓存是降低数据压力一个强有力的手段，基本是所有系统大型web系统中都会使用到，所以现代的大型web系统的架构一般如图。
现代web架构
请求1到达webserver之后，首先执行2访问缓存，如果hit则返回，miss则执行3访问数据库，在执行4同步到缓存中，再返回。但是不是缓存并不是万能的，缓存也有其使用的业务场景，一般在读多写少，数据重复查询比较集中的场景下，缓存可以大大提高性能，缓存操作顺序非常重要，不合理的操作顺序，在并发场景下常常会导致数据的不一致，缓存的具体操作可以参考缓存架构设计细节二三事这边文章。
4.生成宽表，冗余数据
有些业务例如报表、数据汇总等需要数据量较多，此时可能需要进行多表联合查询，联合查询操作非常消耗数据库的性能，所以在这种业务场景下为了避免过大的性能消耗，往往需要将查询时的多个表按照关联条件进行关联，生成一张含有冗余信息的包含所有表的多个字段的大宽表，这样在进行查询时，只在一张表中进行查询，性能明显得到提升。大宽表的生成是在业务流程中生成还是通过异步化任务来生成，根据具体的业务逻辑来定。
5.修改关系型数据库为非关系性数据库
非关系型数据库，也就是我们通常说的NoSQL数据，最常见就是key/value类型的数据库，这类数据库不强调表的关系，但是查询速度非常快，所在某些具体场景下，我们应该优先选择NoSQL数据库，例如字典信息表的查询。
6.读写分离
如果采用单点数据数据库，就算对数据进行上述的相关优化，但是由于其本身的单点性，所以随着流量的激增，数据库仍然会成为系统的瓶颈，如何对数据进行拆分来解决这个问题了，读写分离就是最常用的方法，读写分离的原理如下图。
读写分离
读写分离技术现在已经应用的很成熟，通过将数据拆分为两个实例，读写分离操作改善了数据单点的瓶颈，分摊了数据库压力，而且当主数据库宕机之后可以迅速的切换到从库，而不会导致业务不可用，同时也起到数据备份的作用，由于存在两个数据实例，所以数据怎么由主库同步到从库、主从之间延迟引发的数据不一致问题，以及怎么来分离业务中读和写操作成为要解决的问题成为要解决的问题。主从同步可以参考Mysql主从架构的复制原理及配置这篇文章，从主数据一致可以参考DB主从一致性的几种解决方法这篇文章。
7.数据库拆分
采用读写分离之后，数据库已经变为两份实例，数据库的压力已经得到分摊，如果数据库的压力还是过大时，这是就要从业务方面着手，将具体业务细分，将业务对应的表分拆到不同的数据库当中，如下图。
拆库
业务变动较大，同时要对系统内部之间的相互调用提供接口，调用方式可以选用RPC、Restful、JMQ消息等方式。一般情况下，数据库垂直拆分做的足够细分的话，加上读写分离技术，加上适当的数据截转就可以满足一般的大型业务系统对性能的需求。
8.表的垂直拆分
数据库可以进行垂直拆分，当然也可以对数据库中的表进行垂直拆分，对表进行拆分就是对数据拆分的再拆分，如图。种解决方法只适用于一些特定的场景，例如对表进行垂直拆分，通过异步化调用将所有任务异步化，前提是总的任务可以进行分布的异步化操作，在实际应用比较少，因为设计的表只要复合三范式的要求，一般是很难在进行拆分的，应用较多是对表进行水平拆分。
9.表的水平拆分
如果已经做了数据库拆分，并且进行了读写分离，数据压力还是过大，主要原因就是数据库表中的记录太多，或者对数据进行了截转，但是对历史数据的操作还是比较频繁的，且随着截转的历史数据越来越多，历史数据库的压力也边的也变的越来越大，这时有两种解决方案：第一种方案就是对数据库中的表进行垂直拆分，从而不用在截转数据，通过不断对表进行水平拆分，保证数据数据库中单表的记录数保持在一个高性能合理的范围之类，通过扩容将不同分配到不同的数据中（分库分表）来保证数据库的压力，应用在访问时，通过分库分表的条件进行路由，就可以取到数据。第二种就是仍旧对数据进行截转，当历史数据信息过多从而导致数据库压力过大时，采用搜索引擎的方式来解决。相比于第一种操作第二种方案适用于读操作上，对与写操作，具有一定的局限性，第一种方案具有一定的通用性。对表进行水平拆分的过程如图所示。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70f861cd83d58e6c306a710a2526ddd/" rel="bookmark">
			强制修改分辨率软件_Win7系统电脑屏幕分辨率无法调节更改的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一般重装完系统时，我们都会调整屏幕的分辨率，但是有用户反映，自己的Win7系统电脑却无法修改屏幕分辨率这是怎么回事呢?Win7系统电脑屏幕显示模糊却无法修改分辨率该如何解决?下面请看Win7系统电脑屏幕分辨率不能修改的解决方法。
一：查看电脑分辨率模式是否支持
1、首先要查看屏幕的分辨率模式是不是支持。查看方法，先在桌面空白处右键，选择菜单中的“屏幕分辨率”。
2、进入更改显示器外观界面后，点击右侧的“高级设置”，在通用即插即用监视器窗口，选择“适配器”，在其下，点击“列出所有模式”按钮，看一看所有模式列表中，是否支持你设置的分辨率，如果没有，就表示不支持。
3、还有一种不支持，即采用了外接显示器，外接显示器采用了复制模式，因为在复制模式下，分辨率只能设置为最大分辨率，是外接设备与内置显示器最大分辨率，例如，电脑内置的分辨率为1366X768，而外置的为1280X768，那么，在复制模式下，最大分辨率只能设置为1280X768，如果要调整到1366X768就不允许了，调整不了。
二：显卡的驱动程序损坏
1、最常见的情况，就是显卡驱动损坏，可以用驱动精灵更新或手动更新，手动更新是在桌面“计算机”图标上右键，选择“管理”。
2、在计算机管理窗口，先在左侧目录中，找到并选择“设置管理器”这一项。
3、当显示右侧窗口后，找到“显示适配器”，然后打开，看看其下的设备上，是否有一个黄色的警示标志，如果有，则表示显卡驱动程序损坏，就需要更新了，在更新之前，最好卸载一下旧的驱动程序。
4、在卸载时，不要只简单卸载，最好把原驱动程序给删掉，免得被系统再次重装，勾选“删除此设备的驱动程序软件”，按“确定”。如果卸载后，仍安装不上驱动程序，可以启用驱动程序签名，再安装驱动程序。
5、旧驱动卸载后，就可以更新显卡驱动了，方法，在显卡上右键，选择“更新驱动程序”这一项。
6、进入更新向导窗口，先选择“浏览计算机以查找驱动程序软件”这一项。
7、进入下一个窗口后，填写要更新的驱动程序存储路径(需要在之前，备份了显卡的驱动程序才行，有驱动光盘也可)，如果不记得路径，点“浏览”。
8、打开浏览文件夹窗口，找到之前备份的驱动程序，注意，路径只能选择有驱动程序的文件夹，不能选择单个文件，选好后，确定。
9、路径加载好后，勾选其下“包含子文件夹”，然后按确定，就可以更新显卡驱动程序了。如果在更新驱动程序时，提示驱动程序没有数字签名，这种情况一般为Win7 64位以上系统，只要在安全模式下，禁用数字驱动签名强制即可。
10、如果之前没有备份，也没有驱动光盘，就只能到网上下载相应的驱动，但是，并不是所有人都懂得如何手动更新，以及如何在网上找到合适的驱动，这时，最好用软件来帮忙。如驱动精灵，从网上下载，并安装到电脑，启动软件后，按“立即检测”。
11、检测完后， 会有很多更新或修复项目，这里只要更新驱动，所以点击“查看所有驱动程序”。
提示：因为驱动精灵版本不同，其选项会有一些不同，根据自已版本来查找与选择。
12、在所有可升级或更新的驱动程序中，勾选“显卡”这一项，然后点一键安装，驱动精灵就会自动从网上下载与电脑相应的驱动程序，再点击“安装”即可。
三：硬件损坏
1、如果不是模式问题，也不是驱动程序问题，那就只能是硬件的问题，最常见为显示器数据线没插好，或者数据线有断线。先重新连结一次数据线，如果不行，用新数据连接试试。
2、还可能是显卡的问题，常见为显卡松动，可重新拔插一次试试。
注意事项：
1、若因为内置屏幕与外接显示器最大分辨率不同，可通过“扩展”显示的方式，对两个显示器的分辨率进行单独设置。
2、如果是硬件有问题，在有条件的情况下，用其它好的数据线，显示器，显卡，分别替换试试。
本文来自 010dh.com&gt;&gt; 创作不易，转载请注明出处。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7cb3441dc1ee1a23e5e19190bdf702f/" rel="bookmark">
			mysql myisam 存储结构_【MySQL】MySQL中MyISAM与InnoDB中都是使用什么数据结构存储表数据，有什么区别呢？...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以先给出答案，两种存储引擎都是基于B+树数据结构存储表数据的，但是区别在于InnoDB存储引擎中的B+树即存储了索引又存储了所有数据，而MyISAM中的B+树中只存储了索引的Key值地址，实际的数据存储在其他地方。
我们分别创建两张表，一张user表使用InnoDB存储引擎，一张配置表config使用MyISAM存储引擎，我们会发现两张表的存储文件格式不一样，user表有两个文件，对应如下：user.frm：表结构文件
user.ibd：索引和数据文件(InnoDB Data)
而config表有三个文件，对应如下：config.frm：表结构文件
config.MYD：数据文件(MyISAM Data)
config.MYI：索引文件(MyISAM Index)
通过以上文件，我们可以获知，InnoDB存储引擎的索引和数据都存储在一个文件中，而MyISAM存储引擎的索引和数据存储是分开的。
MyISAM
我们先来看看MyISAM存储引擎是如何使用B+树存储索引以及数据的。MyISAM引擎使用B+树作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：
在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下 图所示：
InnoDB
虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。InnoDB的数据文件本身就是索引文件，表的主键索引这棵树的非叶子节点存储的是主键的key值，而叶节点data域保存了完整的数据记录：
InnoDB的辅助索引与主键的聚集索引类似，但是data域存储相应记录主键的值而不是地址。例如，下图为定义在Col2上的一个辅助索引：
小结
总结以上，MyISAM和InnoDB都是以B+树数据结构存储数据的，但MyISAM的数据文件和索引文件是分开的，InnoDB的数据文件就是索引文件。
MyISAM主索引中的B+树中，叶节点的data域存放的是数据记录的地址，而InnoDB中的叶子节点叶节点data域保存了完整的数据记录。
MyISAM辅助索引中的B+树中，叶节点的data域存放的是数据记录的地址，而InnoDB中的叶子节点叶节点data域保存的是主键的值。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1c43896176c373a93f3fb3c6ad797b0b/" rel="bookmark">
			window.location.Reload()和window.location.href 区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		window.location.Reload()和window.location.href 区别 https://www.cnblogs.com/linsx/p/6802382.html
window.location.Reload()应该是刷新.【相当于 按页面刷新按钮】
(如果有数据提交的话，会提示是否提交的(是和否选项))
window.location.href=window.location.href;
是定向url提交数据
他们最大区别是 是否有数据提交：
前者提交数据的刷新 后者没有提交的刷新
首先介绍两个方法的语法：
reload 方法，该方法强迫浏览器刷新当前页面。
语法：location.reload([bForceGet])参数： bForceGet， 可选参数， 默认为 false，从客户端缓存里取当前页。 true, 则以GET 方式，从服务端取最新的页面, 相当于客户端点击 F5("刷新")
replace 方法，该方法通过指定URL替换当前缓存在历史里（客户端）的项目，因此当使用replace方法之后，你不能通过“前进”和“后退”来访问已经被替换的URL。
语法：location.replace(URL) 参数： URL
在实际应用的时候，重新刷新页面的时候，我们通常使用： location.reload() 或者是 history.go(0) 来做。因为这种做法就像是客户端点F5刷新页面，所以页面的method="post"的时候，会出现“网页过期”的提示。那是因为Session的安全保护机制。可以想到： 当调用 location.reload() 方法的时候， aspx页面此时在服务端内存里已经存在， 因此必定是 IsPostback 的。如果有这种应用： 我们需要重新加载该页面，也就是说我们期望页面能够在服务端重新被创建， 我们期望是 Not IsPostback 的。这里，location.replace() 就可以完成此任务。被replace的页面每次都在服务端重新生成。你可以这么写： location.replace(location.href)
=======================================================
&lt;a οnclick="javascript:window.location.href=window.location.href;"&gt;
&lt;a οnclick="javascript:window.location.reload();"&gt;
测试效果一样。表单没有提交。
&lt;input type="submit" οnclick="javascript:window.location.reload();" value="单击" id="btnVCode" /&gt;
&lt;input type="submit" οnclick="javascript:window.location.href=window.location.href;" value="单击" id="btnVCode" /&gt;
都提交数据
window.location.Reload()应该是刷新.(如果有数据提交的话，会提示是否提交的(是和否选项))
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1c43896176c373a93f3fb3c6ad797b0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74170184a361b1b8f9cb2eb6946a3917/" rel="bookmark">
			官方win10dll文件修复工具_dll系统文件修复工具DirectX Repair
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Hello，小伙伴们大扎好啊！相信大家在日常生活或者工作中使用电脑时遇到过提示系统丢失某个.dll文件导致程序无法正常使用，甚至无法发被正常安装。碰到这种情况真的是很让人感到难受的。而且这类问题一般情况下它还不容易出现经常是在安装某些游戏或者专业软件的时候出现，总是在这种关键的时候掉链子。遇到这样情况，通常我们会去网上搜索相关的.dll文件，然后再按照方法把它们放到合适的位置，最后安装。
总结下来还是比较麻烦的，今天我就来为大家介绍个一个这样的工具，你看在运行它之后，它就会检测你系统中.dll文件的状态，然后下载并进行修复。
如上图，它不仅可以检测修复.dll，还可以对c++进行更新。
工具操作也很简单，点击检测并修复，它就会自动开始执行。
最后就会出来一个结果的反馈。
同时工具的菜单栏中还提供了一些其他的功能以及更高级的强力修复模式。
这个工具的作者是来自于CSDN的Zhang Yue，有兴趣的小伙伴可以在这个工具的帮助--关于中查看他的相关信息，当然你如果你觉得这工具挺好也可以向他捐赠的。
好的小伙伴们，以上就是本篇的全部内容了。如果你对我的内容有什么看法欢迎留言评论，如果你觉得我的内容对你有所启发或者帮助，欢迎关注、点赞、转发，拜拜。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/61e5223d2094d3feb5c7f23f644417c0/" rel="bookmark">
			图解GC（垃圾回收）引用计数法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引用计数法（Reference Counting） 由1960年GeorgeE.Collins提出。引用计数法为每个对象引入技术器，当对象被引用（被其他对象指向）时技术器+1，当技术器为0时表示对象不可达则被视为垃圾处理。优点：与不同标记-清除算法，标记-清除算法由系统没有剩余空间分配时明确促发启动，而引用计数法当计数为0时即可回收垃圾从而减少最大暂停时间并且减少沿着指针搜索查找的时间。缺点：1，计数器增减运算繁重，代码实现复杂，实现复制就意味着容易产生BUG。2，典型的引用计数器需要占更多bit。3，循环指向却无根指针则无法回收问题。
生产新对象时的算法一目了然，再此不在赘述： 更新操作： 更新操作如图，对象B首先将即将指向的对象A 计数+1，再对对象C计数-1。这里此刻C计数为0则被清除并且搜索C所指向的对象计数器-1。注意：这里分别对两对象加减顺便不能反，因为若是加减都是同一个对象则会产生BUG，比如对象B先取消指向C，再再次指向C，由于第一次取消指向C后C计数为0被清除则第二部再次指向C就会失效。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/73723de5b18d984930f6e8aaaa27ad8a/" rel="bookmark">
			谷歌浏览器去掉访问痕迹
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 chrome_options.add_argument("disable-blink-features=AutomationControlled") # 就是这一行告诉chrome去掉了webdriver痕迹 """初始化工作 """ path = r'D:\soft-tools\001\chromedriver' # 创建一个参数对象，用来控制chrome以无界面模式打开 chrome_options = webdriver.ChromeOptions() chrome_options.add_experimental_option( "excludeSwitches", ["enable-automation"]) chrome_options.add_experimental_option('useAutomationExtension', False) chrome_options.add_argument('lang=zh-CN,zh,zh-TW,en-US,en') chrome_options.add_argument( 'user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36') chrome_options.add_argument("disable-blink-features=AutomationControlled") # 就是这一行告诉chrome去掉了webdriver痕迹 driver = webdriver.Chrome(executable_path=path, chrome_options=chrome_options, ) # 设置隐性等待时间最长是30秒钟 driver.implicitly_wait(10) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f2190d52e458510cba46ccb2d8c173b/" rel="bookmark">
			ocx控件不运作_速达软件打开报表提示“ttf16.ocx”错误应该怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 下午一客户在win10系统下使用速达软件，打开自定义报表时提示“Access violation at address 0DD39ACA in module ttf16.ocx Read ofaddress 1609F07B”然后再去操作软件其它地方也会报其它错误， 那么遇见这种错误提示应该怎么处理呢?今天我们就来具体了解下处理方法。 错误提示如下图： ttf16.ocx是一种报表打印控件，可以按照你的设想将查询结果表格化，缺少它可能会造成部分软件和游戏无法正常使用。当你的电脑弹出提示“ttf16.ocx加载失败”或“ttf16.ocx不存在或无效” 解决方法：一、下载 “ ttf16.ocx ”控件。 因功能限制无法直接上传文件，不知如何下载可关注公众号联系管理员。 二、复制文件“ttf16.ocx”到粘贴系统目录下。系统目录一般为C:WINNTSystem32 64位系统为C:\Windows\SysWOW64。 注意：这里32位操作系统和64位操作系统位置不一样！三、 最后①：右键开始菜单--&gt;运行--&gt;输入regsvr32 ttf16.ocx后，回车即可解决错误提示。 ②双击运行Register64.bat或Register32.bat即可解决问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/871885a2dcaaf5c4ba870ff39a28b81e/" rel="bookmark">
			mysql mha  keepalived_Mysql MHA 主从配置&#43;Keepalived测试使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Mysql MHA使用说明
一、 MHA 简介
MHA，即Master High Availability Manager and Tools for MySQL，是日本的一位MySQL专家采用Perl语言编写的一个脚本管理工具，该工具仅适用于MySQL Replication(二层)环境，目的在于维持Master主库的高可用性。
MHA(Master High Availability)是自动的master故障转移和Slave提升的软件包.它是基于标准的MySQL复制(异步/半同步).
MHA有两部分组成:MHA Manager(管理节点)和MHA Node(数据节点).
MHA Manager可以单独部署在一台独立机器上管理多个master-slave集群,也可以部署在一台slave上.MHA Manager探测集群的node节点,当发现master出现故障的时候,它可以自动将具有最新数据的slave提升为新的master,然后将所有其 它的slave导向新的master上.整个故障转移过程对应用程序是透明的。
MHA node运行在每台MySQL服务器上(master/slave/manager),它通过监控具备解析和清理logs功能的脚本来加快故障转移的。
二、 本次试验环境
192.168.2.136(MHA Manager ) CentOS6.6+MySql5.6.24
192.168.2.137 (Master) CentOS6.6+MySql5.6.24
192.168.2.138(Slave1) CentOS6.6+MySql5.6.24
192.168.2.139(Slave2) CentOS6.6+MySql5.6.24
说明：本次试验是在一主二从的拓扑下测试，136为管理节点和配置虚拟IP，137为主机，138为主备，139为从机，当137发生异常，若自动将138设为主机，139复制正常，此部分操作对通过136虚拟IP访问的外部用户透明并且不会影响增删改操作，则测试成功，也是此次测试的目的。
三、 本次试验前提
本次试验前提环境是137，138，139均安装好Mysql数据库复制正常，三个数据库都允许外部IP访问。
(测试环境中的三个数据库用户名和密码均为root,137和138的复制用户和密码分别为repl和123456)。
ps:设置复制命令
change master to master_host='192.168.2.xxx',master_user='repl',master_password='123456',master_port=3306,master_log_file='mysql-bin.000003',master_log_pos=120,master_connect_retry=10;
四、 生成ssh密钥
分别在136，137，138，139四台机器上运行以下三条命令
cd /root/.ssh;
ssh-keygen -t dsa -P '' -f id_dsa;
cat id_dsa.pub &gt;&gt; authorized_keys;
在136上运行以下命令将137，138，139上的id_dsa.pub文件拷贝到当前机器的当前路径下并在名称后加上ip加以区分。拷贝期间要输入137，138，139的root用户密码。
scp 192.168.2.137:/root/.ssh/id_dsa.pub ./id_dsa.pub.137
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/871885a2dcaaf5c4ba870ff39a28b81e/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/340/">«</a>
	<span class="pagination__item pagination__item--current">341/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/342/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>