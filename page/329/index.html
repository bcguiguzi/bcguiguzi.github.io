<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dca115faba4b72371596fecf672573c/" rel="bookmark">
			LeetCode 74.搜索二维矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：37.7 MB, 在所有 Java 提交中击败了81.10%的用户
public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length; int n = matrix[0].length; for(int i = 0; i &lt; m; i++){ if(matrix[0][0] &gt; target || matrix[m-1][n-1] &lt; target){ return false; }else if(i == m-1 &amp;&amp; matrix[i][0] &lt;= target){ for(int j = 0; j &lt; n; j++){ if(target == matrix[i][j]){ return true; } } break; }else if(matrix[i][0] &lt;= target &amp;&amp; matrix[i+1][0] &gt; target){ for(int j = 0; j &lt; n; j++){ if(target == matrix[i][j]){ return true; } } break; } } return false; } 继续努力，加油，奥利给！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946afb22fcdc18c9d4072c24ebf03aed/" rel="bookmark">
			秒杀场景下如何保证数据一致性？就这个问题我给出了最详细的方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		什么是秒杀？ 从字面意思理解，所谓秒杀，就是在极短时间内，大量的请求涌入，处理不当时容易出现服务崩溃或数据不一致等问题的高并发场景。
常见的秒杀场景有淘宝双十一、网约车司机抢单、12306抢票等等。
高并发场景下秒杀超卖Bug复现 在这里准备了一个商品秒杀的小案例，
1.按照正常的逻辑编写代码，请求进来先查库存，库存大于0时扣减库存，然后执行其他订单逻辑业务代码；
/** * 商品秒杀 */ @Service public class GoodsOrderServiceImpl implements OrderService { @Autowired private GoodsDao goodsDao; @Autowired private OrderDao orderDao; /** * 下单 * * @param goodsId 商品ID * @param userId 用户ID * @return */ @Override public boolean grab(int goodsId, int userId) { // 查询库存 int stock = goodsDao.selectStock(goodsId); try { // 这里睡2秒是为了模拟等并发都来到这，模拟真实大量请求涌入 Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } // 库存大于0，扣件库存，保存订单 if (stock &gt; 0) { goodsDao.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/946afb22fcdc18c9d4072c24ebf03aed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c674c9b9adb868262b9d302bdf3240/" rel="bookmark">
			Keil5编程之Error: L6200E: Symbol xxx multiply defined (by xxx.o and xxx.o）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题分析 出现重定义，在使用了全局变量时有可能出现。
错误代码 //main.c int a=0； //test.c extern int a=0； 两个文件中都给变量赋初值时，会出现错误。
Error: L6200E: Symbol xxx multiply defined (by xxx.o and xxx.o）
解决方法 //main.c int a=0； //test.c extern int a；	//此处不要赋初值 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5144b17d607d047cc8a0dfc4c26d322/" rel="bookmark">
			ArcGIS Engine基础（8）之栅格计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实现类似arctoolbox中的 空间分析工具-》地图代数-》栅格计算器功能，对于需要使用表达式进行栅格计算时非常有效果。
如：实现两个栅格相加，并且将NODATA值设置为0，这样NODATA也可以参与计算。
string expression = string.Format("Con(IsNull([{0}]),0,[{0}])+ Con(IsNull([{1}]),0,[{1}])", rasterSymbol1, rasterSymbol2);
2、要保证输出范围与最大栅格范围一致时，需预先设置栅格分析环境
//设置所有图层中的最大范围作为栅格计算器的处理范围。
pEnv.SetExtent(esriRasterEnvSettingEnum.esriRasterEnvMaxOf);
3、在进行栅格计算保存到地理数据库时，如果工作空间saveWorkspace内容发生变化，注意工作空间一定要获取最新的，否则会保存失败。
public static void UsingRasterMapAlgebra(IRasterLayer rasterLayer,string rasterSymbol, string expression, string saveFileName, IWorkspace saveWorkspace,string format="FGDBR") { IRasterDataset pRasterDataset =RasterLayerWrapper.GetRasterDataset(rasterLayer); IMapAlgebraOp pMapAlgebraOp; pMapAlgebraOp = new RasterMapAlgebraOpClass(); IRasterAnalysisEnvironment pEnv = default(IRasterAnalysisEnvironment); pEnv = (IRasterAnalysisEnvironment)pMapAlgebraOp; //设置所有图层中的最大范围作为栅格计算器的处理范围。 pEnv.SetExtent(esriRasterEnvSettingEnum.esriRasterEnvMaxOf); pMapAlgebraOp.BindRaster((IGeoDataset)pRasterDataset, rasterSymbol); string sOut = expression; IGeoDataset rasOut = (IGeoDataset)pMapAlgebraOp.Execute(sOut); ISaveAs2 pSaveAs = (ISaveAs2)rasOut; //默认保存到文件地理库中,如果工作空间saveWorkspace内容发生变化，注意工作空间一定要获取最新的。 pSaveAs.SaveAs(saveFileName, saveWorkspace, format); // 释放IDataset对象 Marshal.ReleaseComObject(rasOut); pMapAlgebraOp.UnbindRaster(rasterSymbol); } public static void UsingRasterMapAlgebraWithMoreLayers(Dictionary&lt;IRasterLayer,string&gt; rasterLayerSymbolDic, string expression,string saveFileName, IWorkspace saveWorkspace, string format = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5144b17d607d047cc8a0dfc4c26d322/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baf94f9829cc98a823495a9741bdd336/" rel="bookmark">
			分布式事务的几种实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		两阶段提交（2PC） 两阶段提交协议是协调所有分布式原子事务参与者，并决定提交或取消（回滚）的分布式算法。
（1）协议参与者
在两阶段提交协议中，系统一般包含两类机器（或节点）：一类为协调者（coordinator），通常一个系统中只有一个；另一类为事务参与者（participants，cohorts或workers），一般包含多个，在数据存储系统中可以理解为数据副本的个数。协议中假设每个节点都会记录写前日志（write-ahead log）并持久性存储，即使节点发生故障日志也不会丢失。协议中同时假设节点不会发生永久性故障而且任意两个节点都可以互相通信。
（2）两个阶段的执行
1.请求阶段（commit-request phase，或称表决阶段，voting phase）
在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。
在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。
2.提交阶段（commit phase）
在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。
当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。
参与者在接收到协调者发来的消息后将执行响应的操作。
（3）两阶段提交的缺点
1.同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。
当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
2.单点故障。由于协调者的重要性，一旦协调者发生故障。
参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
3.数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。
而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。
（4）两阶段提交无法解决的问题
当协调者出错，同时参与者也出错时，两阶段无法保证事务执行的完整性。
考虑协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。
那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。
三阶段提交（3PC） 三阶段提交协议可以理解为两阶段提交协议的改良版，是在协调者和参与者中都引入超时机制，并且把两阶段提交协议的第一个阶段分成了两步: 询问，然后再锁资源，最后真正提交。
两阶段提交协议最早是分布式事务的专家Jim Gray在1978年的一篇文章Notes on Database Operating Systems中提及。两阶段提交协议可以保证数据的强一致性，即保证了分布式事务的原子性：所有结点要么全做要么全不做。许多分布式关系型数据管理系统采用此协议来完成分布式事务。它是协调所有分布式原子事务参与者，并决定提交或取消（回滚）的分布式算法。同时也是解决一致性问题的算法。该算法能够解决很多的临时性系统故障（包括进程、网络节点、通信等故障），被广泛地使用。但是，它并不能够通过配置来解决所有的故障，在某些情况下它还需要人为的参与才能解决问题。两阶段提交协议存在的问题是,协调者在某些时刻如果失败了, 整个事务就会阻塞。于是Skeen发布了"NonBlocking Commit Protocols" （1981）这篇论文，论文指出在一个分布式的事务里面, 需要一个三阶段的提交协议来避免在两阶段提交中存在的阻塞问题。
顾名思义，三阶段提交分为以下三个阶段：
CanCommitPreCommitDoCommit 在三阶段提交协议中，系统一般包含两类角色：
协调者（Coordinator），通常一个系统中只有一个；参与者（Participant），一般包含多个，在数据存储系统中可以理解为数据副本的个数。 CanCommit 在CanCommit阶段，协调者协议流程如下：
写本地日志“BEGIN_COMMIT”，并进入WAIT状态；向所有参与者发送“VOTE_REQUEST”消息；等待并接收参与者发送的对“VOTE_REQUEST”的响应。参与者响应“VOTE_ABORT”或“VOTE_COMMIT”消息给协调者。 该流程与两阶段提交协议类似。
PreCommit 在PreCommit阶段，，协调者将通知事务参与者准备提交或取消事务，写本地的redo和undo日志，但不提交。
协调者协议流程如下：
若收到任何一个参与者发送的“VOTE_ABORT”消息； 写本地“GLOBAL_ABORT”日志，进入ABORT状态；向所有的参与者发送“GLOBAL_ABORT”消息； 若收到所有参与者发送的“VOTE_COMMIT”消息； 写本地“PREPARE_COMMIT”日志，进入PRECOMMIT状态；向所有的参与者发送“PREPARE _COMMIT”消息； 等待并接收参与者发送的对“GLOBAL_ABORT”消息或“PREPARE_COMMIT”消息的确认响应消息。一旦收到所有参与者的“GLOBAL_ABORT”确认消息或者超时没有收到，写本地“END_TRANSACTION”日志流程结束，则不再进入DoCommit阶段。如果收到所有参与者的“PREPARE_COMMIT”确认消息，则进入DoCommit阶段。 该流程与两阶段提交协议相比，多了一个PRECOMMIT状态。
DoCommit 在该阶段，
协调者协议流程如下：
向所有参与者发送的“GLOBAL _COMMIT”消息；等待并接收参与者发送的对 “GLOBAL_COMMIT”消息的确认响应消息，一旦收到所有参与者的确认消息，写本地“END_TRANSACTION”日志流程结束。 在DoCommit阶段，如果参与者无法及时接收到来自协调者的GLOBAL_COMMIT请求时，会在等待超时之后，会继续进行事务的提交。
2PC与3PC的区别 相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况
了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baf94f9829cc98a823495a9741bdd336/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59bf9de1c7d62b28f78308270e5c8365/" rel="bookmark">
			C&#43;&#43; rand
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 C++ rand rand() 产生随机数 伪随机数 周期是65535（猜测周期应该与RAND_MAX 有关）。即每次利用一个随机种子生成的随机数的周期是65535，当你取得65535个随机数后它们又重复出现了。 rand() 返回值非负整数，范围为[0, RAND_MAX]。由RAND_MAX决定。不同操作系统或编译器值会不同。 在VS中为“ #define RAND_MAX 0x7fff”，即为 32767。 centos7中为“#define RAND_MAX 0x7fff ffff”,即 2147483647。 srand 设置随机数种子 若不设置随机数种子，rand() 产生的随机数在每次运行的时候都是与上一次相同的。 若要不同, 用函数 srand() 初始化它。可以利用 srand((unsigned int)(time(NULL)) 的方法，产生不同的随机数种子，因为每一次运行程序的时间是不同的。 生成指定范围内随机数的公式： [a,a+n]的随机数，a + rand() % n；a 是起始值，n 是范围。 [a,b) 的随机整数，使用 (rand() % (b-a))+ a; [a,b] 的随机整数，使用 (rand() % (b-a+1))+ a; (a,b] 的随机整数，使用 (rand() % (b-a))+ a + 1; 0～1 之间的浮点数，使用 rand() / double(RAND_MAX)。 注意： rand返回的是整数，如果直接使用 rand()/32768，得到的结果始终为0。需要改为rand()/ (double)32768，才能得到想要的效果。（网上有许多滥用“rand()/32768”的代码，需要注意） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d3b1a67d53e643095e16a31213870be/" rel="bookmark">
			给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		c++实现给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和 要求：
num1 和num2 的长度都小于 5100
num1 和num2 都只包含数字 0-9
num1 和num2 都不包含任何前导零
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式
链接：https://leetcode-cn.com/problems/add-strings
求和，我们需要从字符串中分离开这些数字，并且吧这些数字从个位到高位依次相加，并将和+=到一个字符串中，最后将字符串逆置即可
画图理解一下：
代码如下：
class Solution { public: string addStrings(string num1, string num2) { int end1=num1.size()-1; int end2=num2.size()-1; int value1=0,value2=0,next=0; string addret; while(end1&gt;=0||end2&gt;=0) { if(end1&gt;=0) { value1=num1[end1--]-'0'; } else { value1=0; } if(end2&gt;=0) { value2=num2[end2--]-'0'; } else { value2=0; } int valueret=value1+value2+next; if(valueret&gt;9) { next=1; valueret-=10; } else { next=0; } addret+=(valueret+'0'); } if(next==1) { addret+='1'; next=0; } reverse(addret.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d3b1a67d53e643095e16a31213870be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fae28056989a9221533d58613931bc45/" rel="bookmark">
			Spring 注解 通过@Resource获得的是空指针
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CommonReadMapper commonReadMapper = (CommonReadMapper) getApplicationContext().getBean("commonReadMapper"); org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'CommonReadMapper' getBean里面的bean id写错了，小写commonReadMapper
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c59572db8d0d8822a61c7c7910d55345/" rel="bookmark">
			Flutter&#43;FishRedux高仿网易云音乐
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		flutter_netease_cloud_music 采用FishRedux框架与开源网易云音乐api开发的高仿网易云音乐APP，技术栈主要是：Flutter+FishRedux,目前主要是偏重APP端的UI展示，主要也是借此项目强化下Flutter和FishRedux的结合使用，打造一个最佳实践项目。通过这个项目也可以帮助你快速使用Flutter+FishRedux开发一个属于你自己的跨平台的APP，此项目会持续更新，欢迎watch和star～
项目简介 本项目主要目的是学习Flutter利用FishRedux进行状态管理，并实现了IOS和Android一套代码跨平台使用。采用FishRedux，实现了业务代码和UI展示的分离。
快速开始 1、配置Flutter开发环境
在真正开发之前，需要配置Flutter开发环境，本身主要是使用Mac开发的，所以如果你也是Mac的话，可以参考Mac配置Flutter开发环2、掌握Dart基本语法3、掌握FishRedux的基本使用4、配置接口服务
本项目主要是实现网易云音乐部分功能，接口API采用网上开源网易云音乐API，所以需要APP运行之前需要了配置接口服务。 启动后端接口服务
git clone https://github.com/Binaryify/NeteaseCloudMusicApi.git cd NeteaseCloudMusicApi npm i npm run start 成功运行，效果如下：
功能列表 用户登陆 退出登陆 我的动态列表 最近播放列表 我的电台 我的收藏 今日推荐 我创建的歌单列表 我收藏的歌单列表 共用的歌单详情列表 歌曲播放页面 歌词滚动 歌曲切换播放模式（随机播放/单曲循环/顺序播放） 切换上一首/下一首 喜欢/取消喜欢某首歌曲 评论列表 视频播放 热搜列表 搜索（包含单曲/歌单/视频/歌手/专辑/电台/用户） 统一的播放组件，方便进行切换页面后可以随时进入到播放页面 项目结构 效果图 1、登陆
2 发现
3、我的
4、动态
5 每日推荐
有待完善部分 将列表中每个公共部分封装成独立的widget，以adapter的形式引用 播放器需要抽离出来做成全局使用 其他等等
还有一些功能点以及细节都还有待进一步完善，目前先把大致主要的功能进行了下实现，当然如果发现什么问题，欢迎能够提交issues,发现之后我会及时进行更正。 项目代码地址 欢迎 star 和 fork，感谢大家支持 🙏。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f262c6fe847a76cb867c7a84ccd1d67/" rel="bookmark">
			数据结构：常见排序算法(1) -- 插入排序（直接插入排序、希尔排序）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（1）直接插入排序 ①原理： 整个区间被分为：
1.有序区间
2.无序区间
每次选择无序区间的第一个元素，在有序区间内选择合适的位置插入
②代码实现： public class insertSort { public static void main(String[] args) { int[] array={1,5,78,6,4,8,45,12,0,88}; System.out.println(Arrays.toString(array)); inSort(array); System.out.println(Arrays.toString(array)); } // 直接插入排序，稳定的排序，时间复杂度：O(n^2),空间复杂度：O(1) //越有序，越快 public static void inSort(int[] array){ for(int i=1;i&lt;array.length;i++){ int tmp=array[i]; for(int j=i-1;j&gt;=0;j--){ if(array[j]&gt;tmp){ array[j+1]=array[j]; }else{ break; } array[j]=tmp; } } } } 运行截图：
③性能分析 稳定性： 稳定
插入排序，初始数据越接近有序，时间效率越高。
（2）希尔排序 ①原理： 希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有记录分成个组，所有 距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重复上述分组和排序的工作。当到达=1时， 所有记录在统一组内排好序。
1.希尔排序是对直接插入排序的优化。
2.当gap &gt; 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。
②代码实现： public class insertSort { public static void main(String[] args) { int[] array={1,5,78,6,88,4,8,45,12,0}; System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f262c6fe847a76cb867c7a84ccd1d67/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98491659c02bd362e27450633083839d/" rel="bookmark">
			【每日一题】74. 搜索二维矩阵 &#43; 【剑指offer】10- I. 斐波那契数列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每日一题 搜索二维矩阵，前几天做过，这次独立写出来了。
class Solution { public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { int i = 0,j = size(matrix[0]) - 1; int flag = matrix[i][j]; //printf("%d",size(matrix)); while(i &lt; size(matrix) &amp;&amp; j &gt;= 0){ flag = matrix[i][j]; if(flag &lt; target){ i++; } else if(flag &gt; target){ j--; } else{ return true; } } return false; } }; 剑指10-1 递归 斐波那契数列典型用递归来处理。但是这样会超出时间限制。
class Solution { public: int fib(int n) { if(n == 0){ return 0; } else if(n == 1){ return 1; } else{ return fib(n - 1) + fib(n - 2); } } }; 动态规划 存下来前面的所有的数。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98491659c02bd362e27450633083839d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1dd5f74a8a27b81b8aa070cdbcd0397b/" rel="bookmark">
			javascript中的toString（）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本介绍 javascript中的toString方法是我们在写前端时经常要用的一个函数，也就是将我们的变量转换成字符串的方法。
javascript中各种类型的toString方法 javascript中定义了7种数据类型，其中包含了6种原始的数据类型：Boolean Null Undefined Number String Symbol(ECMAScript 6 新定义)和 Object，在这7中数据类型中，除了undefined和null类型之外，都有toString方法。
Boolean 类型的toString() 对于Boolean对象或值，内置的 toString 方法返回字符串 "true" 或 "false"，具体返回哪个取决于布尔对象的值。
Number类型的toString() Number对象的toString方法返回指定 Number 对象的字符串表示形式。其toString方法可以传递一个参数radix，这个参数的值得取值范围为（2到36）表示进行toString时候所选用的进制，默认情况下选用10进制，如果radix的值不在2到36之间的话，则会抛出一个异常。
如果Number对象的toString方法的进制大于10的话，则会用字母代替，这就是为什么最大值为36了，其实就是0到9这十个数字再加上26个英文字母。如果对象为负数则保留负号。
var count = 10; console.log(count.toString()); // 输出 '10' console.log((17).toString()); // 输出 '17' console.log((17.2).toString()); // 输出 '17.2' var x = 6; console.log(x.toString(2)); // 输出 '110' console.log((254).toString(16)); // 输出 'fe' console.log((35).toString(36)); // 输出 'z' console.log((-10).toString(2)); // 输出 '-1010' console.log((-0xff).toString(2)); // 输出 '-11111111' console.log((-12.111).toString(16)) // 输出 '-c.1c6a7ef9db23' 针对于数字的toString,其实还有一些坑需要爬：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1dd5f74a8a27b81b8aa070cdbcd0397b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2d6991c45e31250645d4a812bb84a6b/" rel="bookmark">
			flutter异常：unsupport operation:Platform._operatingSystem问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		unsupport operation:Platform._operatingSystem
不支持的操作：操作系统？
应该是Platform._operatingSystem获取到一个系统的值，在代码里不识别该值了。
我是尝试在web上调试适用于android/IOS的框架出现这个问题的
既然稳定版都出来，就应该不是flutter自身package的问题，使用的三方package问题。
1.找到报错的按个包，升到最新版试一试吧，也许新版已经支持这个东西了呢！
2.还有可能已经支持web了，只是需要特殊的写法，这就得去看package的官方文档了。
现在是2021年3月底，百度能搜到flutter有关的unsupport operation:Platform.xxx问题只有几条，官方出过类似bug，早已经解决了，现成的吃不上了，自己多研究吧
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5086c825c7f605817a10730caad5cd27/" rel="bookmark">
			Vuex、Flux、Redux、Redux-saga、Dva、MobX
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		不管是Vue，还是 React，都需要管理状态（state），比如组件之间都有共享状态的需要。什么是共享状态？比如一个组件需要使用另一个组件的状态，或者一个组件需要改变另一个组件的状态，都是共享状态。
父子组件之间，兄弟组件之间共享状态，往往需要写很多没有必要的代码，比如把状态提升到父组件里，或者给兄弟组件写一个父组件，听听就觉得挺啰嗦。
如果不对状态进行有效的管理，状态在什么时候，由于什么原因，如何变化就会不受控制，就很难跟踪和测试了。如果没有经历过这方面的困扰，可以简单理解为会搞得很乱就对了。
在软件开发里，有些通用的思想，比如隔离变化，约定优于配置等，隔离变化就是说做好抽象，把一些容易变化的地方找到共性，隔离出来，不要去影响其他的代码。约定优于配置就是很多东西我们不一定要写一大堆的配置，比如我们几个人约定，view 文件夹里只能放视图，不能放过滤器，过滤器必须放到 filter 文件夹里，那这就是一种约定，约定好之后，我们就不用写一大堆配置文件了，我们要找所有的视图，直接从 view 文件夹里找就行。
根据这些思想，对于状态管理的解决思路就是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。根据这个思路，产生了很多的模式和库，我们来挨个聊聊。
Store 模式 最简单的处理就是把状态存到一个外部变量里面，比如：this.$root.$data，当然也可以是一个全局变量。但是这样有一个问题，就是数据改变后，不会留下变更过的记录，这样不利于调试。
所以我们稍微搞得复杂一点，用一个简单的 Store 模式：
var store = { state: { message: 'Hello!' }, setMessageAction (newValue) { // 发生改变记录点日志啥的 this.state.message = newValue }, clearMessageAction () { this.state.message = '' } } store 的 state 来存数据，store 里面有一堆的 action，这些 action 来控制 state 的改变，也就是不直接去对 state 做改变，而是通过 action 来改变，因为都走 action，我们就可以知道到底改变（mutation）是如何被触发的，出现错误，也可以记录记录日志啥的。
不过这里没有限制组件里面不能修改 store 里面的 state，万一组件瞎胡修改，不通过 action，那我们也没法跟踪这些修改是怎么发生的。所以就需要规定一下，组件不允许直接修改属于 store 实例的 state，组件必须通过 action 来改变 state，也就是说，组件里面应该执行 action 来分发 (dispatch) 事件通知 store 去改变。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5086c825c7f605817a10730caad5cd27/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6a0e48186ecb7075cc7db5ce25884d0/" rel="bookmark">
			4.SpringBoot[Spring Boot Configuration Annotation Processor not found in classpath]解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 使用Spring Boot开发的过程中，写读取Properties配置文件的配置类时提示Spring Boot configuration annotation processor not found in classpath,如下图所示
问题分析 出现spring boot Configuration Annotation Proessor not found in classpath的提示是在用了@ConfigurationProperties这个注解时，所以问题出现在ConfigurationProperties注解
根据提示的not found in classpath,查询此注解的使用关于怎么指定classpath,进而查询location，spring boot1.5以上版本@ConfigurationProperties取消location注解
解决方案 官方解决方案，Maven引入依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6f0fcd58f2000e81e1296b11331f91de/" rel="bookmark">
			疫情数据处理与可视化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		去年的这个时候是疫情的高发期，相信大家每天都会查阅疫情的发展情况。
下面这个网址是百度提供的疫情实时大数据报告
https://voice.baidu.com/act/newpneumonia/newpneumonia/?from=osari_pc_3
这节课，通过疫情数据案例，带大家体验一下数据可视化的过程。
1.获取数据 回忆一下获取数据步骤：
确定爬虫网址用requests.get()方法获取网页全部信息解析数据获取我们想要的信息输出保存数据 以下代码为爬取疫情数据的代码，将疫情数据生成json文件。
需要注意的是这里使用了html.xpath()方法解析数据，也就是根据数据的路径来定位具体数据的位置。
import requests from lxml import etree import json #爬虫 url="https://voice.baidu.com/act/newpneumonia/newpneumonia/?from=osari_aladin_banner" res=requests.get(url) html=etree.HTML(res.text) result=html.xpath('//script[@type="application/json"]/text()') result=result[0] result=json.loads(result) result_in=result['component'][0]['caseList'] result_in=json.dumps(result_in) #生成json数据 with open('china_data.json','w') as file: file.write(result_in) 用记事本打开json文件，复制全部，用json解析器解析数据。
https://www.json.cn/
任务1：
解析json数据，对比原网页，了解字典中的键代表着什么意思。
我们尝试着用Python读取json数据，代码如下所示：
import json filename='china_data.json' with open(filename) as f: result_in=json.load(f) 这段代码将json数据读取到result_in变量中，该变量为列表类型。
任务2：
尝试着用循环语句输出result_in列表中的每个元素，也就是国内疫情的数据。
任务3:
通过观察发现，result_in列表中包含着大量的字典元素，每一个字典元素代表着一个省、自治区直辖市的疫情信息。请输出每个省市的已确诊人数
2.写入excel 现在我们要将json数据中的信息写入excel表中。这里使用了openpyxl第三方库。请同学们安装一下这个库。
步骤为：键盘win+R——输入cmd——在管理员界面输入：pip install openpyxl
下面是创建excel表的过程：
wb=openpyxl.Workbook() #新建一个excel文件 ws=wb.active #新建一个sheet文件 ws.title="国内疫情" #sheet名字为“国内疫情” ws.append(['省份','累计确诊','死亡','治愈','现有确诊']) #导航栏名称 wb.save('./data_test.xlsx') #保存 接下来我们需要将json数据导入。用到的是ws.append()方法。意思是将数据依次写入到单元格中。
需要注意的是数据需要与列表头对应。
for i in result_in: ws.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6f0fcd58f2000e81e1296b11331f91de/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04948e10c4a6e176e9440b2697e87710/" rel="bookmark">
			php while循环 sleep,shell命令while循环中使用sleep命令代码示例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文继续练习while循环语句，这里要介绍一个sleep的命令。如果写过自动化脚本，特别是selenium的同学，肯定很熟悉这个sleep。没错，sleep就是暂停的意思，例如sleep 1,表示暂停一秒，看下面练习。
1. 从1到10，每隔一秒打印一个数字
#! /bin/bash
# while loops
n=1
while (( $n &lt;= 10 ))
do
echo $n
(( n++ ))
sleep 1
done
自己运行下，看下效果。
2. 实现一秒开一个终端
我们先要获取终端的程序名称，例如一般在终端输入firefox就可以启动火狐浏览器，同样的道理，在终端输入终端对应的名称，也可以新开一个终端。
点击帮助-&gt;关于,得到名称是xfce4-terminal
相关shell脚本如下
#! /bin/bash
# while loops
n=1
while (( $n &lt;= 3 ))
do
echo $n
(( n++ ))
xfce4-terminal &amp;
sleep 1
done
同样自己运行下，是不是一秒打开一个终端的效果，这里打开了3个。
总结
以上就是本文关于shell命令while循环中使用sleep命令代码示例的全部内容，希望对大家有所帮助。感兴趣的朋友可以继续参阅本站其他相关专题，如有不足之处，欢迎留言指出。感谢朋友们对本站的支持！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/651b904c026b06ae6c80ca241972fb9b/" rel="bookmark">
			tcping : ping ip地址&#43;端口号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		起因:windows下cmd ping命令无法ping某一个端口。
对策:使用tcping工具了，Windows没有自带这个小工具，需要自己下载下来，放到 C:\Windows\System32 下。
tcping工具下载地址https://elifulkerson.com/projects/tcping.php 之后将 tcping.exe 放到 C:\Windows\System32 下。
使用 tcping ip/域名 port
常用的命令：
-4/-6 （优先使用IPv4/IPv6地址）
-d （发送命令的时间）
-t （-t是让命令持续运行，知道使用ctrl + c指令退出）
-h （使用http模式）
-u （与-h命令连用，输出目标的url）
-n （发送命令的次数，默认4次）
-i （发送命令的间隔时间，默认1s，可以为小数）
-w ( 等待响应的间隔时间，默认2s，可以为小数）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8d77cc8cb1233a38edc568f0c82d1588/" rel="bookmark">
			RedisBloom 插件布隆过滤器，布谷鸟过滤器，Count-Min Sketch，TOPK使用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、如何安装二、布隆过滤器1. 使用介绍2. 命令详解 三、布谷鸟过滤器1. 使用介绍2. 命令详解 三、Count-Min Sketch1. 使用介绍2. 命令详解 四、TopK1. 使用介绍2. 命令详解 总结 前言 RedisBloom 是一款由 RedisLabs 提供的 redis 插件，提供了布隆过滤器、布谷鸟过滤器、Count-Min Sketch、TopK功能实现。通过 BitMap 这样的数据结构，以牺牲部分精度换取更高的内存效率和读写效率，适用于海量数据场景。该博客以下将对 RedisBloom 各个功能以及命令做详解。首先，先简单介绍这些功能的作用：布隆过滤器和布谷鸟过滤器主要用于判断海量元素是否存在的情况，通常可用于防止缓存击穿导致的雪崩问题；Count-Min Sketch 主要用于元素的使用计数，可用于 ip 限流，元素流量查询等场景；TopK 可以帮助我们对元素进行计数，与 Count-Min Sketch 相比，它提供了在O(n)复杂度下查询排名前 n 个元素的命令，可用于海量元素的排名（但在实际测试中，并不能达到预计效果）。以下内容均基于 RedisBloom 2.1.0 版本。 一、如何安装 这里仅介绍 docker 下的安装步骤，同样的分享了官网的安装介绍。
docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest 官网各环节安装介绍：地址
二、布隆过滤器 1. 使用介绍 该模块主要用于判断某个元素是否存在，利用 BitMap 这样的数据结构，在牺牲可接受范围的精度下极大提高了内存使用率和性能，查询复杂度约为 O(hash fun number)，和 redis 原有的 set 结构（非 zip set int）相比，内存仅占用其 1/10 甚至不到。以下为 redis 中和 set 的测试内存结果对比：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8d77cc8cb1233a38edc568f0c82d1588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91c5d32485b6081cae725f602b07ac40/" rel="bookmark">
			线段覆盖 java,南邮 OJ 1407 线段覆盖
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线段覆盖
时间限制(普通/Java) :
1000 MS/ 3000 MS 运行内存限制 : 65536 KByte
总提交 : 219 测试通过 : 60
比赛描述
给出数轴上N条线段，每条线段用两个数表示A,B(-10^9&lt;=A
现在请你求出它们覆盖数轴上的多长距离。
输入
第一行：N
以后N行，每行给出一条线段，即两个用空格隔开的整数：Ai和Bi
输出
一个数，表示覆盖长度
样例输入
3 2 8 -1 1 5 10
样例输出
10
提示
题目来源
JSOI2010
#include
#include
using namespace std;
struct point{
int x;
bool isLeft;
};
bool operator
return p1.x
}
int main(){
int N,i,count=0,begin,sum=0;
bool findBegin = 0;
point *points;
cin&gt;&gt;N;
N *= 2;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91c5d32485b6081cae725f602b07ac40/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/328/">«</a>
	<span class="pagination__item pagination__item--current">329/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/330/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>