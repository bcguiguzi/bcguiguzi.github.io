<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea4c36f1fcb1648f8df7f58aa3fb4897/" rel="bookmark">
			深度学习(15):kitti数据集转rosbag包工具kitti2bag使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 安装 使用pip安装即可
pip install kitti2bag 其中kitti2bag的github链接：https://github.com/tomas789/kitti2bag
如果因为proxy代理的原因，一直pip install不了，可以试试换台电脑转换数据(这或许更有用）
2.下载并解压数据数据 到网页：The KITTI Vision Benchmark Suite下载数据（可能需要注册）；这里下载一个“数据栏”下的scnced+rectified data与calibration文件到同一个目录
​
完成后如下所示： （同时创建一个change文件夹）
下面两步手动解压就是为了将两个压缩包的2011_10_03进行合并
手动解压2011_10_03_drive_0047_sync.zip到change目录，操作如下：
手动解压2011_10_03_calib.zip里面的标定文件到change/2011_10_03目录（2011_10_03位上一步解压得到的目录），操作如下（注意：需要选中全部的txt文件，而不是文件夹）
解压后目录如下：
[meng@meng /media/meng/5418189112144B70/kitti/road/2022_10_03_drive_0047/change]$ tree -L 4 . └── 2011_10_03 ├── 2011_10_03_drive_0047_sync │ ├── image_00 │ │ ├── data │ │ └── timestamps.txt │ ├── image_01 │ │ ├── data │ │ └── timestamps.txt │ ├── image_02 │ │ ├── data │ │ └── timestamps.txt │ ├── image_03 │ │ ├── data │ │ └── timestamps.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea4c36f1fcb1648f8df7f58aa3fb4897/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8491c67ecc40260ed7a28f587de8d57/" rel="bookmark">
			Opencv简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.机器视觉 机器视觉（Machine Vision）一般指计算机视觉（Computer Vision），简单来说就是研究如何让机器看懂东西。指用摄像机或者电脑代替人眼对物体目标进行识别等机器视觉，进一步做图像处理，能够让电脑处理成为更适合人眼观察或传送给仪器检测的图像
总而言之，就是让计器像人一样看懂物体
现在，计算机视觉和机器视觉已经不区分了
2.机器视觉的应用 物体识别：人脸识别、车辆检测 识别图像中的文字（OCR：Optical Character Recognition，光学字符识别）：扫描银行卡号、QQ识别提取文字等等图像拼接，修复，背景替换等等 将两张图，拼接成一幅图片：
3.Opencv介绍 CV：Computer Vision计算机视觉
python中安装opencv： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8227efad9c5e82993d043358b8f32fa6/" rel="bookmark">
			【计算机网络】TCP四次挥手过程详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【TCP四次挥手过程】
1.第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入fin_wait_1状态
2.第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接受
3.第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态
4.第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手
【为什么TCP挥手需要4次】
主要原因是当服务端收到客户端的FIN数据包后，服务端可能还有数据没发完，不会立即close
所以服务端先将ACK发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将FIN包发送给客户端表示现在可以断了。之后客户端需要收到FIN包后发送ACK确认断开信息给服务端
【为什么四次挥手释放连接时需要等待2MSL】
MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e8eef485a1d438d23b77a11f6a5754c/" rel="bookmark">
			你真的了解Cookie吗？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先要了解到的是：像cookie、localStorage、书签等等浏览器提供的功能，数据都是存储在用户电脑本机中。 Cookie是什么？ HTTP Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的HTTP协议记录稳定的状态信息成为了可能。
cookie是服务端发送给用户浏览器保存到本地的一小块数据，创建之初的目的就是服务端写入到浏览器，后由浏览器发送请求时，携带到服务端进行验证。
cookie的设计之初，是由服务端通过Set-Cookie设置到浏览器中，后续由浏览器进行维护，既然是通过响应头中的Set-Cookie来设置，每条cookie的属性众多，所以设置的形式如下：
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; httpOnly; Cookie 主要用于以下三个方面：
会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）个性化设置（如用户自定义设置、主题等）浏览器行为跟踪（如跟踪分析用户行为等） Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB 。
cookie的缺点：http请求每次都会携带cookie，导致性能开销大；（跨域，cookie的域名 会影响是否携带cookie）
每条Cookie的属性值和意义 name和value name由下划线和字母组成，区分大小写；value的类型是字符串。设置方式如下：
Set-Cookie: id=a3fWa;
通常情况下，设置每条cookie的value值size都比较小，大约十几个字节或几十个字节，超过100字节的比较少见。
expires/Max-Age expires参数是 Netscape 烘焙的原始 cookie 的一部分。在 HTTP 版本 1.1 中，expires它已被弃用，取而代之的是使用max-age，无需指定日期，您只需说出 cookie 可以存活多长时间。通过设置其中任何一个，cookie 将持续存在直到过期，否则——如果你都没有设置——cookie 将持续到你关闭浏览器（“Session cookie”）。
设置cookie的过期时间，如果是Session，表明浏览器关闭后，该cookie失效；如果是具体的日期时间，表示到这个日期后，该cookie失效。如下：
expires和Max-Age的区别是什么呢？
Expires设置删除 cookie 的到期日期Max-age设置删除 cookie 的时间（以秒为单位），即当cookie设置成功后，多少秒以后失效。Internet Explorer（ie6、ie7 和 ie8）不支持“max-age”，而（大部分）所有浏览器都支 expires 那么我们又该怎么设置呢？
var d = new Date(); d.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e8eef485a1d438d23b77a11f6a5754c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e0dd02c77ce3bf7911d1909ae483c45/" rel="bookmark">
			数据结构-单链表的基本实现（C语言，简单易懂，含全部代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表的概念和结构 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的 。
结构：实际中链表的结构非常多样，以下情况组合起来就有8种链表结构。
（1）单向、双向
（2）带头、不带头
（3）循环、非循环
本篇主要详解单链表，结构如图：
无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结
构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
链表的实现 首先在头文件中定义结构体和提供接口：
#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef int SLTDataType; typedef struct SListNode//定义结构体 { SLTDataType data; struct SListNode* next; }SLTNode; //单向+不带头+非循环 //凡是要改变指针内容plist的值时，就用二级指针接收 void SListPrint(SLTNode* plist);//打印 void SListPushBack(SLTNode** plist, SLTDataType x);//尾插 void SListPushFront(SLTNode** plist, SLTDataType x);//头插 void SListPopBack(SLTNode** pplist);//尾删 void SListPopForint(SLTNode** pplist);//头删 SLTNode* SListFind(SLTNode* plist, SLTDataType x);//查找 void SListInsertAfter(SLTNode* pos, SLTDataType x);//pos位置后插入x void SListInsertBefore(SLTNode* plist, SLTNode* pos, SLTDataType x);//pos位置前插入x(很麻烦 不适合) void SListEraseAfter(SLTNode* pos);//删除pos后的数据 其次在源文件中实现接口功能：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e0dd02c77ce3bf7911d1909ae483c45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c35c2242ac3e60107739102168d243/" rel="bookmark">
			SQLyog 安装和配置教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 SQLyog 安装和配置教程 软件下载 SQLyog下载地址：https://sqlyog.en.softonic.com/ 安装步骤 说明：SQLyog安装非常简单，基本上是傻瓜式安装。
下载后会得到SQLyog-13.1.6-0.x64Community.exe 安装文件使用管理员身份安装这里我安装到 D:\program\SQLyog Community 目录下 【根据自己的情况来指定目录】双击运行, 配置连接
输入正确的密码即可登录MySQL 提示：一定要保证MySQL 服务是运行的状态 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/942d7087395ace9cb405eae27859fb2a/" rel="bookmark">
			Vue响应式系统中的computed和watch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、computed1. 基本使用2. 重新计算3. 缓存4. 计算结果与重新渲染5. 注意命名冲突6. 使用场景7. 总结 二、watch1. 基本使用2. options3. 动态添加watch4. 使用场景5. 与computed的区别6. 源码分析 三、Vue3中的变化computedwatch新增watchEffect() 前面写了两篇文章，分别是Vue双向绑定的原理和实现。里面只是分析了data的响应式原理，但Vue的响应式系统中还有其他的属性。所以本篇讨论一下另外两个常用属性：computed 和 watch。可以查看前面的博客，对Vue的响应式系统有一定的了解后，再看本篇： Vue双向绑定：原理篇（详细）
Vue双向绑定：实现篇
一、computed Vue官方文档—计算属性
1. 基本使用 &lt;template&gt; &lt;div&gt;{{b}}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data: { a: 10 }, computed: { b: function() { return this.a * 2 // a发生变化时，重新计算，得到b值 }, c() { // 也可以这样写 return this.a * 2 } } } &lt;/script&gt; 2. 重新计算 计算属性会通过Watcher来观察它所用到的所有属性的变化，当这些属性发生变化时，计算属性会将自身的Watcher的dirty属性设置为true，进行重新计算，计算完成后将dirty属性设置为false。 3. 缓存 计算属性的特点是有缓存。计算属性函数所依赖的数据在没有发生变化的情况下，反复读取计算属性，而计算属性函数并不会反复执行。 4. 计算结果与重新渲染 旧版，不对比计算结果
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/942d7087395ace9cb405eae27859fb2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7660e90b1b9fe4fcfc0776a3327c6b76/" rel="bookmark">
			购买的腾讯云服务器一直被ddos恶意攻击怎么解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近小蚁君发了很多关于阿里云服务器被攻击的文章，有不少客户来问，小蚁小蚁那腾讯云服务器被攻击了怎么办呢？其实所有服务器被攻击都是万变不离其宗！今天小蚁君给大家说道说道腾讯云服务器被攻击了怎么办？
处理 ddos 攻击的最少成本是防止 ，不要等到攻击到来再防御 ，首先成本远超攻击前的防御 ，因此 当ddos 攻击开始时防御 ，不但会造成 高额成本 ，如果有把柄在黑客手中 ，就更加 麻烦了，所以事前防御才是上上策 。
想避免 DDOS 攻击 ，务必先搞清楚 ，当今销售市场 99 %的DDOS攻击是对于 IP 以百G攻击流量导致网络服务器瘫患，以便做到攻击目地 ，因而 你务必防止服务器ip泄漏并掩藏 源ip ，那样黑客就无法找到源服务器ip ，也没法使用ddos有效地攻击你。
根据隐藏源服务器 IP 的思路 ，我们可以给业务做一个高防CDN，既可加速 ，又可以预防 被DDOS 攻击 。高防CDN能够做到掩藏源服务器目地 。当查询 IP 时只能查询 高防cdn的节点 ，而CDN 节点这般之多。 即便他人想攻击你，也必须得一个个的IP 去打，这样造成的攻击成本自然就提高 ，对他们来说完全不划算 ，而且还未必能找到 。当然不仅要做到 源IP不暴露 在防御上也是就近机房清洗 ，回源速度快 ，丝毫不影响用户体验 ，不过值得一提的是不要把域名直接解析到源站IP ，也不要用源服务器 IP 直接进行访问 。
许多网站管理员都等网址被攻击了才上高防cdn ，因此沒用，由于另一方早已记住了你的ip ，直接绕过高防CND节点 。根据源ip攻击你，怎样防御 ？所以在接入防护之前一定要确定源IP 是干净的，否者就要申请更换公网IP
因此，避免腾讯云服务器遭受ddos攻击的最好是方式就是说 把高防CDN布置在好，不能让另一方 了解 你的源服务器ip ，即便 高防cdn 其中一个节点被打死 ，还可以立即切换到其他备用节点上。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6684b7bb20b5ead447a05fe87600a8/" rel="bookmark">
			备忘录设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		备忘录设计模式 一、备忘录设计模式 1、介绍 备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将对象恢复到原先保存状态
备忘录对象主要用来记录一个对象的某种状态或者某些数据，当要回退时，可以从备忘录对象离获取原来的数据进行恢复操作
备忘录模式属于行为型模式
2、UML Orginator：对象（需要保存状态的对象）
Memento：备忘录对象，负责保存Orginator内部状态的
Caretaker：守护者对象，负责保存多个备忘录对象，使用集合管理，提高效率
3、备忘录模式的注意事项和细节 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态实现了信息的封装，使得用户不必关心状态的保存细节如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存适用场景：后悔药、游戏存档、windows中的撤回（ctri+z）、浏览器中的后退、数据库的事务管理为了节约内存，备忘录模式可以和原型模式配合使用 二、案例1 1、介绍 使用备忘录模式，备忘对象Originator的属性state，可通过备忘录对象恢复
2、UML 3、代码 /** * @description: 源 * @author: dashu * @create: 14:09 */ public class Originator { /** * 状态 */ private String state; /** * 获取状态 * @return */ public String getState() { return state; } /** * 状态赋值 * @param state 状态 */ public void setState(String state) { this.state = state; } /** * 保存状态到备忘录 * @return */ public Memento saveStateMemento(){ return new Memento(state); } /** * 通过备忘录恢复状态 * @param memento */ public void getSateFromMemento(Memento memento){ state = memento.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b6684b7bb20b5ead447a05fe87600a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbbd0afea9cdbcb02968e82eeaa11f3f/" rel="bookmark">
			中介者设计模式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		中介者设计模式 一、中介者设计模式 1、介绍 中介者模式：用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互
中介者模式属于行为型模式，使代码易于维护
比如MVC模式，C（controller控制器）是M（Model模型）和V（View视图）的中介者，在前后端交互起到中间人的作用
2、UML Mediator：抽象中介者，定义了同事对象到中介者对象的接口
ConcreteMediator：具体的中介者对象，实现了抽象方法，它需要知道所有的具体的同事类，即以一个集合来管理HashMap，并接收某个同事对象消息，完成相应的任务
Collague：抽象同事类
ConcreteCollague：具体的同事类，会有很多，每个同时类只知道自己的行为，而不了解其他同事类的行为，但他们都依赖中介者对象
3、中介者模式注意事项和细节 多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离为星型结构，进行解耦减少类之间的依赖，降低耦合，符合迪米特原则中介者承担了较多的责任，一旦中介者出现问题，整个系统都会受到影响中介者本身过于复杂 二、案例 1、介绍 ​ 智能家庭设备：闹钟、咖啡机、电视机、窗帘
​ 各个设备协同工作，自动完成看电视的准备工作和后续工作：
​ 闹钟响起-&gt;启动咖啡机开始做咖啡-&gt;降下窗帘-&gt;电视机开始播放—&gt;关闭咖啡机喝咖啡-&gt;电视机关闭-&gt;窗帘拉起
2、UML 3、代码 /** * @description: 同事抽象类 * @author: dashu * @create: 10:02 */ public abstract class Colleague { /** * 中介者 */ private Mediator mediator; /** * 名称 */ public String name; /** * 构造方法 * @param mediator 中介者 * @param name 名称 */ public Colleague(Mediator mediator,String name){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbbd0afea9cdbcb02968e82eeaa11f3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90b7cbb1ec174b71d16a0c4506f580bd/" rel="bookmark">
			数据同步：MySQL到Elasticsearch
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 背景1、基于应用程序多写2、基于binlog订阅2.1：canal简介工作原理 2.2、Databus2.3、Maxwell2.4、Flink CDC2.5、DTS（阿里云）2.6、CloudCanal 3、基于SQL抽取基于Logstash同步数据 4、总结 背景 随着平台的业务日益增多，基于数据库的全文搜索查询速度较慢，已经无法满足需求。所以，决定基于Elasticsearch 做一个全文搜索平台，支持业务相关的搜索需求。那么第一个问题就是：如何从MySQL同步数据Elasticsearch？
1、基于应用程序多写 直接通过应用程序数据双写到MySQL和ES
**记录删除机制：**直接删除
一致性： 需要自行处理，需要对失败错误做好日志记录，做好异常告警并人工补偿
优点： 直接明了，能够灵活控制数据写入，延迟最低
缺点： 与业务耦合严重，逻辑要写在业务系统中
应用双写（同步）
直接通过ES API将数据写入到ES集群中，也就是写入数据库的同时调用ES API写入到ES中，这个过程是同步的
应用双写（MQ异步解耦）
对 应用双写（同步）的改进，引入MQ中间件。
把同步变为异步，做了解耦。
同时引入MQ后双写性能提高，解决数据一致性问题。
缺点是会增加延迟性，业务系统增加mq代码，而且多一个MQ中间件要维护
2、基于binlog订阅 binlog订阅的原理很简单，模拟一个MySQL slave 订阅binlog日志，从而实现CDC（change data capture）
CDC,变更数据获取的简称，使用CDC我们可以从数据库中获取已提交的更改并将这些更改发送到下游，供下游使用。这些变更可以包括INSERT,DELETE,UPDATE等。
**记录删除机制：**直接删除
一致性： 最终一致性
优点： 对业务系统无任何侵入
缺点： 需要维护额外增加的一套数据同步平台；有分钟级的延迟
2.1：canal https://github.com/alibaba/canal/
阿里巴巴 MySQL binlog 增量订阅&amp;消费组件
简介 canal [kə’næl]，译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费
早期阿里巴巴因为杭州和美国双机房部署，存在跨机房同步的业务需求，实现方式主要是基于业务 trigger 获取增量变更。从 2010 年开始，业务逐步尝试数据库日志解析获取增量变更进行同步，由此衍生出了大量的数据库增量订阅和消费业务。
基于日志增量订阅和消费的业务包括：
数据库镜像数据库实时备份索引构建和实时维护(拆分异构索引、倒排索引等)业务 cache 刷新带业务逻辑的增量数据处理 当前的 canal 支持源端 MySQL 版本包括 5.1.x , 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90b7cbb1ec174b71d16a0c4506f580bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a413321d724aa3d60d500c500a59991/" rel="bookmark">
			【Appium踩坑】Proxy error:Could not proxy command to remote server.Original error:Error: socket hang up
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		设备：vivo z5x + Android 9 / OPPO R17 + Android 10
工具： Appium desktop 1.15.1
一、原因-&gt;解决 原因：
uiautomator2 被 系统程序杀掉了
Force stopping io.appium.uiautomator2.server appid=10271 user=0: stop by com.xx.xx(系统程序) 解决：
*oppo 手机 设置-电池，把 appium 相关的 APP 关闭
*vivo 手机 设置 -&gt; 电池 -&gt; 后台高耗电， 把 appium 相关的app都开启
*小米 手机 应用管理 - appium相关的APP全部停止运行
二、详细报错信息 1-&gt;
Encountered internal error running command: Error: Could not proxy. Proxy error:Could not proxy command to remote server.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a413321d724aa3d60d500c500a59991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81003655c654aad2c0ed52e8f6a584f6/" rel="bookmark">
			5大步骤&#43;10个案例，堪称SQL优化万能公式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：https://www.cnblogs.com/powercto/p/14410128.html
前言 在应用开发的早期，数据量少，开发人员开发功能时更重视功能上的实现，随着生产数据的增长，很多SQL语句开始暴露出性能问题，对生产的影响也越来越大，有时可能这些有问题的SQL就是整个系统性能的瓶颈。
SQL优化一般步骤 1、通过慢查日志等定位那些执行效率较低的SQL语句 2、explain 分析SQL的执行计划 需要重点关注type、rows、filtered、extra。
type由上至下，效率越来越高
ALL 全表扫描
index 索引全扫描
range 索引范围扫描，常用语&lt;,&lt;=,&gt;=,between,in等操作
ref 使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中
eq_ref 类似ref，区别在于使用的是唯一索引，使用主键的关联查询
const/system 单条记录，系统会把匹配行中的其他列作为常数处理，如主键或唯一索引查询
null MySQL不访问任何表或索引，直接返回结果 虽然上至下，效率越来越高，但是根据cost模型，假设有两个索引idx1(a, b, c),idx2(a, c)，SQL为"select * from t where a = 1 and b in (1, 2) order by c";如果走idx1，那么是type为range，如果走idx2，那么type是ref；当需要扫描的行数，使用idx2大约是idx1的5倍以上时，会用idx1，否则会用idx2
Extra
Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。
Using temporary：使用了临时表保存中间结果，性能特别差，需要重点优化
Using index：表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现 using where，意味着无法直接通过索引查找来查询到符合条件的数据。
Using index condition：MySQL5.6之后新增的ICP，using index condtion就是使用了ICP（索引下推），在存储引擎层进行数据过滤，而不是在服务层过滤，利用索引现有的数据减少回表的数据。
3、show profile 分析 了解SQL执行的线程的状态及消耗的时间。默认是关闭的，开启语句“set profiling = 1;”
SHOW PROFILES ; SHOW PROFILE FOR QUERY #{id}; 4、trace trace分析优化器如何选择执行计划，通过trace文件能够进一步了解为什么优惠券选择A执行计划而不选择B执行计划。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81003655c654aad2c0ed52e8f6a584f6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3383d854b5ebcb04b9c6b107c2c4b698/" rel="bookmark">
			less中引入背景图片的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 注意点:记得加~号,只使用@会报错
background-image: url("~@/assets/imgs/tableSelect.png"); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/580ca56c286be5b7b799ac596bdfb0d2/" rel="bookmark">
			java异常使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.异常的输出流程 第一行：输出 错误类型 + 错误内容2-N行：输出 错误堆栈 信息 1.常见异常例子： package com.ztd.question.err; /** * java 异常打印流程 * @author ztd */ public class Demo01SimpleError { public static void main(String[] args) { new Demo01SimpleError().m1(); } public void m1() { m2(); } public void m2() { try { throw new Exception("出问题了"); } catch (Exception e) { e.printStackTrace(); } } } java打印的结果如下：
java.lang.Exception: 出问题了 at com.ztd.question.err.Demo01SimpleError.m2(Demo01SimpleError.java:16) at com.ztd.question.err.Demo01SimpleError.m1(Demo01SimpleError.java:12) at com.ztd.question.err.Demo01SimpleError.main(Demo01SimpleError.java:9) 2.异常为什么会这么输出？ 这就需要查看一下 e.printStackTrace() 这个方法的实现了，这个方法是Throwable类里面的一个方法，这个方法在控制台里面输出的内容之所以是红色，是因为它使用的是System.err 这个 PrintStream 输出的，我们通常输出内容使用的是 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/580ca56c286be5b7b799ac596bdfb0d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/242da963e561f6b3d653236e5638b8d8/" rel="bookmark">
			C&#43;&#43;实现哈希表创建、查找、显示、计算ALS（详细）（数据结构）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题引入 针对某个数值序列，设计一个哈希表，完成相应的建表和查表顺序。哈希函数用除留余数法构造，用线性探测再散列的方法处理哈希地址冲突。
针对给定的数列：{23,5,17,12,26,31,13,4,6}，完成哈希表的构造。具体哈希函数采用除留余数法，并用线性探测再散列的方法处理哈希地址冲突。具体为：表长为13，哈希函数为：H(key)= key MOD 13，要求：
1）能根据给定值进行查询，判断该值在哈希表中是否存在？如果存在，输出相应的地址；否则，输出不存在。
2）能输出哈希表中的全部内容，相应地址存储的元素为空，则不输出。
3）能输出该表的平均查找长度ASL（假定每个元素被查找的概率都是相等的）。
代码实现 #include&lt;iostream&gt; #include&lt;malloc.h&gt; #define HashLength 13 //定义哈希表表长 #define NULLKEY 0 //空哈希表元素值为0 using namespace std; //定义哈希表属性、结构 typedef struct{ int key; //元素的值 int compareTimes; //查找到该元素需要比较的次数 int flag; //用来标识该位置是否已经存有别的数据 }Elem; typedef struct{ Elem *base; //表示生成的空间的首地址 int count; //元素个数 int length; //表长 }HashList; //除留余数法 int Hash(int data){ return data%HashLength; } //初始化哈希表 void InitHash(HashList &amp;H) { int i; H.base= (Elem *)malloc(HashLength*sizeof(Elem)); //分配存储空间 H.length=HashLength; //表长 for (i=0;i&lt;HashLength; i++) { H.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/242da963e561f6b3d653236e5638b8d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/755857f58fd57f1a532de8fb00115320/" rel="bookmark">
			modelsim se 10.5安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		modelsim se 10.5安装教程 简介 modelsim10.5是由mentor graphics公司推出的一款具备强大的仿真性能与调试能力的HDL设计验证环境，也是唯一的单内核支持VHDL和Verilog混合仿真的仿真器，提供最友好的调试环境，采用直接优化的编译技术、Tcl/Tk技术、和单一内核仿真，并且具有个性化的图形界面和用户接口，能够为用户加快调试提供强有力的手段。而且软件全面支持VHDL和Verilog语言的IEEE 标准，以及IEEE VITAL 1076.4－95 标准，与C语言功能调用，C的模型，以及SWIFT的SmartModel逻辑模型和硬件模型，还集成了性能分析、波形比较、代码覆盖、数据流ChaseX、Signal Spy、虚拟对象Virtual Object等众多调试功能。此外，无论你是新手或老手，modelsim10.5能够很好的帮助你改正错误，有效的解决问题，节省大量时间，提高工作效率，是作FPGA、ASIC设计的RTL级和门级电路仿真的首选。ps：小编此次带来的是modelsim se 10.5破解版，附带的破解补丁可完美激活软件，从而免费使用所有功能，但破解过程较为复杂，用户们可参考下文奉上的详细安装提问教程，希望对有需要的小伙伴们有所帮助。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-0e08jDnE-1650293599807)(https://www.xitongxia.net/d/file/20211103/202012111056395227.jpg)]
功能亮点 一、高级代码覆盖率ModelSim高级代码覆盖功能为系统验证提供了有价值的指标。所有覆盖信息都存储在统一覆盖数据库（UCDB）中，该数据库用于收集和管理高效数据库中的所有覆盖信息。二、混合HDL仿真全面支持Verilog，SystemVerilog for Design，VHDL和SystemC为单语言和多语言设计验证环境提供了坚实的基础。ModelSim易于使用且统一的调试和仿真环境为当今的FPGA设计人员提供了他们不断增长的高级功能以及使他们的工作高效的环境。三、有效的调试环境ModelSim调试环境为Verilog，VHDL和SystemC提供了广泛的直观功能，使其成为ASIC和FPGA设计的首选。ModelSim通过智能设计的调试环境简化了发现设计缺陷的过程。ModelSim调试环境有效地显示设计数据，以便分析和调试所有语言。
主要特点 -采用直接编译结构，编译仿真速度最快-单一内核无缝地进行VHDL和Verilog混合仿真-与机器和版本无关，便于数据移植和库维护-与机器无关的编译代码编于保护和利用IP-简单易用和丰富的图形用户界面，快速全面调试-Tcl/Tk用户可定制仿真器-完全支持VHDL/Verilog国际标准,完全支持Verilog 2001-支持众多的ASIC和FPGA厂家库-集成的Performance analyzer帮助分析性能瓶颈，加速仿真-灵活的执行模式，Debug模式可以进行高效的调试，效率模式大幅度提高仿真速度-加强的代码覆盖率功能Code coverage，能报告出statement 、branch、condiTIon- expression、toggle、fsm等多种覆盖率情况，进一步提高了测试的完整性-同一波形窗口可以显示多组波形，并且能进行多种模式的波形比较（Wave Compare）-先进的Signal Spy功能，可以方便地访问VHDL 或者 VHDL 和Verilog 混合设计中的下层模块的信号，便于设计调试-支持加密IP-集成的 C调试器，支持 用C 语言完成测试平台和模块；支持64位的OS。
modelsim10.5安装教程： 1、下载解压，得到modelsim se 10.5原程序和Crack破解文件夹；
声明：此Crack文件仅用于学习使用，如果工作中使用请购买正版软件；特此声明；
2、首先双击运行"modelsim-win64-10.5-se.exe"程序，进入软件安装向导；
3、点击下一步，按默认目录进行安装；
4、同意软件许可协议，依提示进行下一步；
5、软件正在安装中，请用户耐心等待一小会；
6、弹出窗口点击YES，创建桌面快捷方式；
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-y9mxiRLt-1650293599811)(https://www.xitongxia.net/d/file/20211103/202012111059225512.jpg)]
7、直到软件安装完成，如下图所示，先不要运行软件，点击否并退出安装向导；
8、在C盘根目录下新建一个flexlm文件夹，如下图所示：
9、将Crack破解文件夹中的MentorKG.exe和patch64_dll.bat两个文件复制到软件安装目录下；默认目录【C:\modeltech64_10.5\win64】
10、然后双击运行刚才复制过来的patch64_dll.bat程序；
11、等待patch64_dll.bat程序完成之后，会弹出一个以LICENSE.TXT文件命名的记事本文件；
12、将LICENSE.TXT文件保存到C:\flexlm文件夹中，如下图所示：
13、然后右击此电脑点击属性，进入高级系统设置；
14、打开系统“环境变量”选项，点击“新建”选项，在变量名中输入：LM_LICENSE_FILE，在变量值中输入：C:\flexlm\license.txt；
15、打开软件，即可软件已经成功激活啦，可以免费使用所有功能；
16、ok，以上就是modelsim se 10.5破解版详细安装教程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3df68d7db2d840d100ab6687a2d67261/" rel="bookmark">
			【Python】基础篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1 输出与输入
2 输出格式控制
3 关系运算符和逻辑运算符
4 算术表达式
5 基本要素与字符串 6 字符串和数的转换
7 条件分支语句
8 列表
9 全局变量与局部变量
10 一些函数 1 输出与输入 print(1,2,3,end="") # 以空格分隔，不换行 print("ok") # 1 2 3ok s=input("请输入你的名字：") # 相当于c++中 cout&lt;&lt;"请输入你的名字："; cin&gt;&gt;s; print(s+"，你好！") a=int(input()) # 每次输入一行 b=int(input()) # 输入的 字符串 整型化 print(a+b) 2 输出格式控制 h = 1.746 print("My name is %s, I am %.2fm tall." % ("tom",h)) #My name is tom(%s), I am 1.75(%.2f 保留小数点后两位)m tall.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3df68d7db2d840d100ab6687a2d67261/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f864c3788e980d94e8fdc09fce74553/" rel="bookmark">
			8 种最坑的SQL错误用法，你有没有踩过？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：yq.aliyun.com/articles/72501
1、LIMIT 语句
2、隐式转换
3、关联更新、删除
4、混合排序
5、EXISTS语句
6、条件下推
7、提前缩小范围
8、中间结果集下推
总结
sql语句的执行顺序：
FROM &lt;left_table&gt; ON &lt;join_condition&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; WHERE &lt;where_condition&gt; GROUP BY &lt;group_by_list&gt; HAVING &lt;having_condition&gt; SELECT DISTINCT &lt;select_list&gt; ORDER BY &lt;order_by_condition&gt; LIMIT &lt;limit_number&gt; 1、LIMIT 语句 分页查询是最常用的场景之一，但也通常也是最容易出问题的地方。比如对于下面简单的语句，一般 DBA 想到的办法是在 type, name, create_time 字段上加组合索引。这样条件排序都能有效的利用到索引，性能迅速提升。
SELECT * FROM operation WHERE type = 'SQLStats' AND name = 'SlowLog' ORDER BY create_time LIMIT 1000, 10; 好吧，可能90%以上的 DBA 解决该问题就到此为止。但当 LIMIT 子句变成 “LIMIT 1000000,10” 时，程序员仍然会抱怨：我只取10条记录为什么还是慢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3f864c3788e980d94e8fdc09fce74553/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b3c413f78380c8a4eebc5d72e7737a0/" rel="bookmark">
			SpringCloud 优雅下线&#43;灰度发布
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：https://blog.csdn.net/qq_35246620/article
/details/109166722
文章目录 前言
优雅下线
常见的下线方式
优雅的下线方式
灰度发布
蓝绿部署
滚动部署
金丝雀部署
前言 在生产环境中，如何保证在服务升级的时候，不影响用户的体验，这个是一个非常重要的问题。如果在我们升级服务的时候，会造成一段时间内的服务不可用，这就是不够优雅的。那什么是优雅的呢？主要就是指在服务升级的时候，不中断整个服务，让用户无感知，进而不会影响用户的体验，这就是优雅的。
实际上，优雅下线是目标，而不是手段，它是一个相对的概念，例如kill PID和kill -9 PID都是暴力杀死服务，相对于kill -9 PID来说，kill PID就是优雅的。但如果单独拿kill PID出来说，我们能说它是优雅的下线策略吗？肯定不是啊，就是这个道理。
因此，本文讲述的优雅下线仅能称之为“相对的优雅下线”，但相对于暴力的杀死服务，已经足够优雅了。常见的优雅解决方案，主要包括优雅下线和灰度发布。而实际上，灰度发布的范围就已经包含优雅下线了。
最后，在本文中，我们主要讲述基于 Spring Cloud 和 Euraka 的优雅下线以及灰度发布。
优雅下线 常见的下线方式 方式一：kill PID 使用方式：kill java进程ID
该方式借助的是 Spring Boot 应用的 Shutdown hook，应用本身的下线也是优雅的，但如果你的服务发现组件使用的是 Eureka，那么默认最长会有 90 秒的延迟，其他应用才会感知到该服务下线，这意味着：该实例下线后的 90 秒内，其他服务仍然可能调用到这个已下线的实例。因此，该方式是不够优雅的。
方式二：/shutdown端点 Spring Boot 提供了/shutdown端点，可以借助它实现优雅停机。
使用方式：在想下线应用的application.yml中添加如下配置，从而启用并暴露/shutdown端点：
management: endpoint: shutdown: enabled: true endpoints: web: exposure: include: shutdown 发送 POST 请求到/shutdown端点
curl -X http://你想停止的服务地址/actuator/shutdown 该方式本质和方式一是一样的，也是借助 Spring Boot 应用的 Shutdown hook 去实现的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b3c413f78380c8a4eebc5d72e7737a0/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/246/">«</a>
	<span class="pagination__item pagination__item--current">247/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/248/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>