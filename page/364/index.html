<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621ca411e93999e5da1b0c706ddc38a0/" rel="bookmark">
			TypeScript配置文件tsconfig.json
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生成tsconfig.json 这个文件是通过tsc --init命令生成的，在桌面上新建一个文件夹TsDemo,然后打开VSCode，把文件托到编辑器中，然后打开终端Terminal,输入tsc --init。
输入完成后，就会出现tsconfig.json文件，你可以打开简单的看一下，不过此时你可能看不懂。
其实它就是用来配置如何对ts文件进行编译的，我们都叫它 typescript 的编译配置文件。
如果此时你的tsc执行不了，很有可能是你没有全局安装 TypeScript,可以全局安装一下。
让tsconfig.json 文件生效 你现在可以在文件夹跟目录建立一个demo.ts文件，然后编写一些最简单的代码，代码如下:
const person:string = 'Riven'; 这时候我们不在使用ts-node直接执行了，需要用tsc demo.ts进行编译，编译后会得到demo.js文件。 生成的代码如下:
var person = 'Riven'; 这时候好像一切都是正常的，但是我要告诉你的真相是tsconfig.json这个编译配置文件并没有生效。
此时我们打开tsconfig.json文件，找到complilerOptions属性下的removeComments:true选项，把注释去掉。
这个配置项的意思是，编译时不显示注释，也就是编译出来的js文件不显示注释内容。
现在你在文件中加入一些注释，比如：
// I love Riven const person:string = 'Riven'; 这时候再运行编译代码tsc demo.ts，编译后打开demo.js文件，你会发现注释依然存在，说明tsconfig.json文件没有起作用。
如果要想编译配置文件起作用，我们可以直接运行tsc命令，这时候tsconfig.json才起作用，可以看到生成的js文件已经不带注释了。
include，exclude，和files 那现在又出现问题了，如果我们的跟目录下有多个ts文件，我们却只想编译其中的一个文件时，如何作？
我们在项目根目录，新建一个文件demo2.ts文件，然后也写一段最简单的 ts 代码。
const person2:string = '翠花'; 如果这时候我们在终端里运行tsc,虽然tsconfig.json生效了，但是两个文件都被我们编译了。这不是你想要的结果，我们可以用三种办法解决这个问题。
第一种：使用 include 配置 include属性是用来指定要编译的文件的，比如现在我们只编译demo.ts文件，而不编译demo2.ts文件，就可以这样写。
写配置文件时有个坑需要注意，就是配置文件不支持单引号，所以里边都要使用双引号。
{ "include":["demo.ts"], "compilerOptions": { //any something //........ } } 这时候再编译，就只编译demo.ts文件了。
第二种：使用 exclude 配置 include是包含的意思，exclude是不包含，除什么文件之外，意思是写再这个属性之外的而文件才进行编译。比如你还是要编译demo.ts文件，这时候的写法就应该是这样了。
{ "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621ca411e93999e5da1b0c706ddc38a0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/621b8aee3ef41300a049d611dac1522d/" rel="bookmark">
			uniapp DES加解密
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、打开HBuilderX的视图-&gt;显示终端
cd 切换到你项目的根目录
执行命令 npm install crypto-js
安装成功后你的项目根目录会生成node_modules文件夹，里面有crypto-js就说明成功了
2、封装一个des.js
import CryptoJS from '../node_modules/crypto-js/crypto-js.js'
// DES加密
export const encryptDes = (message, key) =&gt; {
const keyHex = CryptoJS.enc.Utf8.parse(key);
const encrypted = CryptoJS.DES.encrypt(message, keyHex, {
mode: CryptoJS.mode.ECB,
padding: CryptoJS.pad.Pkcs7
});
return encrypted.toString();
}
// DES解密
export const decryptDes = (ciphertext, key) =&gt; {
const keyHex = CryptoJS.enc.Utf8.parse(key);
// direct decrypt ciphertext
const decrypted = CryptoJS.DES.decrypt({
ciphertext: CryptoJS.enc.Base64.parse(ciphertext)
}, keyHex, {
mode: CryptoJS.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/621b8aee3ef41300a049d611dac1522d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24fd88760b4ea086a7c762a491213d4c/" rel="bookmark">
			【pygame安装】尝试了网上所有方法，最后还是安装失败的进来！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【pygame安装心得】如果你排查了网络上所有可能出现的问题仍旧不能成功安装，那么或许你可以看看这种解决方案
排查可能出现问题的原因 1.是否成功安装了pip
可以通过python -m pip --version检查
2.你安装的pygame是否与你安装的Python版本对应
可以通过python检查版本。版本低了，通过指令升级（网络上很多升级方式，不详述）。如果升级始终不成功，可以尝试后面连接的方法，我就是这么成功的。添加链接描述
3.Python是win64，还是win32
可以通过python检查版本。
如果以上方法你还不能成功，那么你可以这样！ 将文件pygame-1.9.6-cp38-cp38-win32.whl中加粗的cp38改写成none。然后使用指令安装，就可以成功。因为原本下载下来的文件格式在安装过程中不合适，需要改成系统可以识别的格式。
E:\alien_invasion&gt;pip install pygame-1.9.6-cp38-none-win32.whl
Processing e:\alien_invasion\pygame-1.9.6-cp38-none-win32.whl
Installing collected packages: pygame
Successfully installed pygame-1.9.6
这是最后成功安装的样子！
最后附pygame安装连接：添加链接描述
重点关注，版本、什么系统！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7112bc639a250dda1ebc84bc60a4aa2/" rel="bookmark">
			C语言strstr()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 strstr()用法 在C语言&lt;string.h&gt;标准库中包含char *strstr(const char *haystack, const char *needle) 函数
参数 char *haystack：被检索的字符串
const char *needle：需要检索的字符串
含义 查找haystack中第一次出现needle字符串的位置，返回该字串，若没有返回null;
实现 # include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { const char c[7] = "Heello"; const char check[6] = "lo"; //const char a = 'e'; const char* test; //const char* test1; //检索c中第一次出现check字符串的位置 test = strstr(c, check); //test1 = strrchr(c, a); printf("子串为:%s\n", test); //printf("子串为:%s", test1); return 0; } 结果 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a364b27dda5781fd271a7229a2fe844d/" rel="bookmark">
			查看当前计算机CPU架构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在安装软件的时候，windows上会有 32bit, 64bit 的区别，但是Linux系统下则还需要知道CPU架构，比如 amd64, i386, arm64, x86_64, aarch64 等等。
1、cat /proc/version Linux version 3.10.0-1127.10.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) ) #1 SMP Wed Jun 3 14:28:03 UTC 2020 2、uname -a Linux localhost.localdomain 3.10.0-1127.10.1.el7.x86_64 #1 SMP Wed Jun 3 14:28:03 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 3、file /bin/bash /bin/bash: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs) , for GNU/Linux 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a364b27dda5781fd271a7229a2fe844d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0c9644f410fbdcf503a048f62b83407/" rel="bookmark">
			实战篇--常见的Shell脚本编写案例（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的Shell脚本编写案例（三） 1.21 FTP下载文件1.22 输入五个100数之内的字符，统计和、最小和最大1.23 将结果分别赋值给变量1.24 批量修改文件名1.25 统计当前目录中以.html结尾的文件总大小1.26 扫描主机端口状态1.27 Expect实现SSH免交互执行命令1.28 批量修改服务器用户密码1.29 打印乘法口诀1.30 getopts工具完善脚本命令行参数 1.21 FTP下载文件 #!/bin/bash if [ $# -ne 1 ]; then echo "Usage: $0 filename" fi dir=$(dirname $1) file=$(basename $1) ftp -n -v &lt;&lt; EOF # -n 自动登录 open 192.168.1.10 user admin adminpass binary # 设置ftp传输模式为二进制，避免MD5值不同或.tar.gz压缩包格式错误 cd $dir get "$file" EOF 1.22 输入五个100数之内的字符，统计和、最小和最大 COUNT=1 SUM=0 MIN=0 MAX=100 while [ $COUNT -le 5 ]; do read -p "请输入1-10个整数：" INT if [[ !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0c9644f410fbdcf503a048f62b83407/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b08791187f62372c1799b1961f35e00c/" rel="bookmark">
			实战篇--常见的Shell脚本编写（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的Shell脚本编写（二） 1.11 屏蔽网站访问频繁的IP1.12 判断输入是否为IP1.13 判断输入是否为数字1.15 监控目录，将新创建的文件名追加到日志中1.17 查看网卡实时流量1.18 MySQL数据库备份1.19 Nginx启动脚本1.20 选择SSH连接主机 1.11 屏蔽网站访问频繁的IP 1）屏蔽每分钟访问超过200的IP
方法1：以Nginx日志作为测试
DATE=$(date +%d/%b/%Y:%H:%M) ABNORMAL_IP=$(tail -n5000 access.log |grep $DATE |awk '{a[$1]++}END{for(i in a)if(a[i]&gt;100)print i}') #先tail防止文件过大，读取慢，数字可调整每分钟最大的访问量。awk不能直接过滤日志，因为包含特殊字符。 for IP in $ABNORMAL_IP; do if [ $(iptables -vnL |grep -c "$IP") -eq 0 ]; then iptables -I INPUT -s $IP -j DROP fi done 方法2：通过建立连接数
ABNORMAL_IP=$(netstat -an |awk '$4~/:80$/ &amp;&amp; $6~/ESTABLISHED/{gsub(/:[0-9]+/,"",$5);{a[$5]++}}END{for(i in a)if(a[i]&gt;100)print i}') #gsub是将第五列（客户端IP）的冒号和端口去掉 for IP in $ABNORMAL_IP; do if [ $(iptables -vnL |grep -c "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b08791187f62372c1799b1961f35e00c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/efaf279204deb2985ee6365aa3fd8384/" rel="bookmark">
			实战篇--常见的Shell脚本编写案例（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的 Shell脚本编写案例(一) 注意事项
1）开头加解释器：#!/bin/bash
2）语法缩进，使用四个空格；多加注释说明。
3）命名建议规则：变量名大写、局部变量小写，函数名小写，名字体现出实际作用。
4）默认变量是全局的，在函数中变量local指定为局部变量，避免污染其他作用域。
5）有两个命令能帮助我调试脚本：set -e 遇到执行非0时退出脚本，set-x 打印执行过程。
6）写脚本一定先测试再到生产上。
文章目录 常见的 Shell脚本编写案例(一)1.1 获取随机字符串或数字1.2 定义一个颜色输出字符串函数1.3 批量创建用户1.4 检查软件包是否安装1.5 检查服务状态1.6 检查主机存活状态1.7 监控CPU、内存和硬盘利用率1.8 批量主机磁盘利用率监控1.9 检查网站可用性1.10 检查MySQL主从同步状态 1.1 获取随机字符串或数字 获取随机8位字符串：
方法1： # echo $RANDOM |md5sum |cut -c 1-8 471b94f2 方法2： # openssl rand -base64 4 vg3BEg== 方法3： # cat /proc/sys/kernel/random/uuid |cut -c 1-8 ed9e032c 获取随机8位数字：
方法1： # echo $RANDOM |cksum |cut -c 1-8 23648321 方法2： # openssl rand -base64 4 |cksum |cut -c 1-8 38571131 方法3： # date +%N |cut -c 1-8 69024815 cksum：打印CRC效验和统计字节
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/efaf279204deb2985ee6365aa3fd8384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3fe741b6da569db46b064cf870b85ba2/" rel="bookmark">
			[vue-router] Named Route ‘Layout‘ has a default child route. When navigating to this named route (:t
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vue项目中使用了vue-router,然后在运行项目的时候,给出了这样的警告:
[vue-router] Named Route 'Layout' has a default child route. When navigating to this named route (:to="{name: 'Layout'"), the default child route will not be rendered. Remove the name from this route and use the name of the default child route for named links instead. 项目中的代码是这样的:
routes: [ { path: '/', name: 'Layout', component: Layout, meta: { title: "首页", requireAuth: true }, children: [ User ] }, …… ] 警告的原因,是在vue-router中,当有子路由的时候,父级路由需要一个默认的路由,所以这个时候不能给父级路由设置name属性,所以我们把父级路由中的name属性Layout去掉就不会再有警告了.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3fe741b6da569db46b064cf870b85ba2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6ebe00712dc6cde0447a975a3c5635c/" rel="bookmark">
			vue中使用腾讯地图 获取相关位置信息跨域 处理方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装 vue-jsonp npm install vue-jsonp -S;
在main.js 中 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/572690968f358707d3e217663b3ff4df/" rel="bookmark">
			java | c结构体转java实体类 字节 --- 绝版彩蛋
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 在与c通讯时，因语言只有结构体的概念，在与java进行socket通信时，java往往需要把接收到的字节流在处理成需要的数据，这一步我看网络上大部分都没有一个好用东东，因此分享出来。
注意：c的结构体自己了解去，这里不再叙述，同时c常用类型占几字节也务必清楚，这里不再叙述。
主要思想：根据c结构体的类型占位，自定义注解标注占位数，之后通过java反射直接生成对象。这里面主要基础基础就是反射、注解、字节进制这些东东，这些理解了可以根据自己业务去封装自己需要的。
还有 博主比较佛系，有些问题可能不会回复
二、自定义注解 里面有一些根据业务自定义一些业务逻辑，根据自己需要去修改。
StructRecv 结构报文 --- 与 c结构体对应。 import java.lang.annotation.*; /** * 结构报文 --- 与 c结构体对应 * 标记在类上 * &lt;p&gt; * 默认支持 * 请求 类型映射 byte[] -&gt; int、long、String、LocalDateTime、class、boolean(0.false 1.true) * 响应 类型映射 int、long、LocalDateTime、String、class、boolean -&gt; byte[] * &lt;/p&gt; * &lt;p&gt; * 支持继承（有父类情况下，优先解析父类的） * 实体类对象必须要有无参构造 * 如果 字段为 class 不可 继承 * 如果有子类，那么对应 value 用 0 表示 ,会 动态计算出子类的大小 class、list * &lt;/p&gt; * * @author wbw * @date 2020年8月1日09:16:53 */ @Target(ElementType.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/572690968f358707d3e217663b3ff4df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c11c79eb2dc948022db94de9505604a6/" rel="bookmark">
			C 语言的泛型实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：C语言实现泛型编程
很多语言内置了对泛型的支持（例如 C++，通过同名不同参数的函数支持泛型）。C 语言中需要借助空指针 void * 实现泛型。
非泛型编程 需要针对所有可能类型实现函数。
void swapInt(int *a, int *b) { int tmp = *a; *a = *b; *b = tmp; } void swapDouble(double *a, double *b) { double tmp = *a; *a = *b; *b = tmp; } 泛型编程 函数具有通用性，支持多种数据类型。
要想实现泛型的函数，需要在调用的地方传入相关要交换的对象的地址空间大小 size，同时利用在头文件 string.h 中定义的 memcpy() 函数来实现。
void swap(void *a, void *b, int size) { char buffer[size]; // C99 及更高版本 memcpy(buffer, a, size); memcpy(a, b, size); memcpy(b, buffer, size); } 完整实例 #include &lt;stdio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c11c79eb2dc948022db94de9505604a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d956f09a7ed9476ca43641140a374a79/" rel="bookmark">
			NEMU PA1实验思路
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		NEMU PA1实验思路 版权归zzy所有，不许外传！
本文主要是提供PA1思路，为了避免踩了一堆坑而浪费时间。若想copy代码请移步他处，本文仅供学习交流用，谢谢！
阅读前请确保仔细阅读了PA1实验指导书的有关内容！
必做任务1 实现正确的寄存器结构体 需要了解结构体和联合体的概念，保证gpr[i]对应第i个寄存器即可。
NEMU/nemu/include/cpu/reg.h修改如下
typedef struct { union { union { uint32_t _32; uint16_t _16; uint8_t _8[2]; } gpr[8]; struct { uint32_t eax, ecx, edx, ebx, esp, ebp, esi, edi; }; }; swaddr_t eip; } CPU_state; 必做任务 2：实现单步执行、打印寄存器、扫描内存 首先模仿给的几个指令把这三个指令填入cmd_table中，关于args参数转成int的方法，手册中有写。注意有些后面需要参数的指令需要判断参数是否输入完整。
单步执行si 阅读cmd_c，可知程序运行在cpu_exec()函数中，-1转成无符号数即为最大能表示的数，所以程序会全部执行完。我们只需要把-1改成si后面的参数即可。（si后面的参数默认不能大于等于10）
static int cmd_si(char *args) { int step; if (args == NULL) step = 1; else sscanf(args, "%d", &amp;step); cpu_exec(step); return 0; } 打印寄存器 前面实现的寄存器如何打印出来呢？一种方法是直接打印gpr数组，另一种方式是利用enum数组，在NEMU/nemu/include/cpu/reg.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d956f09a7ed9476ca43641140a374a79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60aec228f26d3e9b9198dcb2d428edcb/" rel="bookmark">
			查看gcc/g&#43;&#43;默认编译标准
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 gcc/g++使用-std参数指定编译标准，例如g++ -std=c11 main.cpp表示用C++11标准编译main.cpp使用info gcc或info g++查看gcc/g++可以使用的编译标准及默认标准： -std=下列出了所有可以指定的编译标准在其中搜索"default"，可以找到默认的C/C++编译标准。例如笔者的ubuntu18.04的g++ 7.5.0的默认C代码编译标准为gun1x，默认C++代码编译标准为gnu++1y 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77a2255ee044e61453074af62449c6f5/" rel="bookmark">
			使用O(1)空间，O(n)时间复杂度 去除有序数组中的重复数字 C&#43;&#43;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 int removeDuplicates(vector&lt;int&gt; &amp;nums) { int len = sizeof(nums) / sizeof(int); if (len == 0) return 0; int slow = 0, fast = 0; while (fast &lt; len) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow+1; } 测试代码
int nums1[5] = { 1,2,2,4,4 }; vector&lt;int&gt; nums; for (int i = 0; i &lt; 5; i++) nums.push_back(nums1[i]); int a = removeDuplicates(nums); cout &lt;&lt; a &lt;&lt; endl; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef4b943fd57db3a33049d63d08730384/" rel="bookmark">
			c&#43;&#43; 刷题 字符串相乘
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
string multiply(const string &amp; num1, const string &amp; num2) { if (num1 == "0" or num2 == "0") { return "0"; } int len1 = num1.length(); int len2 = num2.length(); cout &lt;&lt; len1 &lt;&lt; endl; cout &lt;&lt; len2 &lt;&lt; endl; vector&lt;int&gt; num(len1 + len2, 0); for (int i = len1 - 1; i &gt;= 0; i--) { int t = num1[i] - '0'; for (int j = len2 - 1; j &gt;= 0; j--) { int p = num2[j] - '0'; int sum = t * p; num[i + j + 1] += sum % 10; num[i + j] += (num[i + j + 1] / 10 + sum / 10); num[i + j + 1] %= 10; } } string a = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef4b943fd57db3a33049d63d08730384/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e21fcc331087f158f9045139089d2d0/" rel="bookmark">
			RTKLIB 之 rtknavi
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.rtknavi.exe
实时定位工具,两种定位方式:
(1)标准定位
输入原始观测量,输出标准定位,水平精度CEP50 2.5m
(2)高精度定位
输入原始观测量和RTK差分数据,输出高精度定位,水平精度分米甚至厘米
An real-time positioning AP RTKNAVI inputs raw observation data of GPS/GNSS receivers and execute navigation processing in real-time. By setting the positioning mode to Kinematic and configuring the rover and the base station receiver data inputs, RTK-GPS/GNSS is enabled with OTF (on-the-fly) integer ambiguity resolution.
2.how to use rtknavi.exe 2.1高精度定位
refer to http://www.rtklib.com/rtklib_tutorial.htm
(1) Download RTKLIB_2.4.1 package and install it to &lt;RTKLIB_install_dir&gt; according to RTKLIB manual.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3e21fcc331087f158f9045139089d2d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8d6ac7c5217b2f440552ade7ffc937d/" rel="bookmark">
			图解NCHW与NHWC数据格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		田海立@CSDN 2020-10-12
流行的深度学习框架中有不同的数据格式，典型的有NCHW和NHWC格式。本文从逻辑表达和物理存储角度用图的方式来理解这两种数据格式，最后以RGB图像为例来加深NHWC和NCHW数据存储格式的理解。
一、基本概念 深度学习框架中，数据一般是4D，用NCHW或NHWC表达，其中：
N - BatchC - ChannelH - HeightW - Width 二、逻辑表达 假定N = 2，C = 16，H = 5，W = 4，那么这个4D数据，看起来是这样的：
人类比较直接的理解方式是3D，上图中从三个方向上理解，C方向/H方向/W方向。然后是N方向上，就是4D。
上图中红色标准的数值是这个数据里每个元素的数值。
三、物理存储 无论逻辑表达上是几维的数据，在计算机中存储时都是按照1D来存储的。NCHW和NHWC格式数据的存储形式如下图所示：
3.1 NCHW NCHW是先取W方向数据；然后H方向；再C方向；最后N方向。
所以，序列化出1D数据：
000 (W方向) 001 002 003，(H方向) 004 005 ... 019，(C方向) 020 ... 318 319，(N方向) 320 321 ...
3.2 NHWC NHWC是先取C方向数据；然后W方向；再H方向；最后N方向。
所以，序列化出1D数据：
000 (C方向) 020 ... 300，(W方向) 001 021 ... 303，(H方向) 004 ... 319，(N方向) 320 340 ...
四、RGB图像数据举例 表达RGB彩色图像时，一个像素的RGB值用3个数值表示，对应Channel为3。易于理解这里假定N=1，那么NCHW和NHWC数据格式可以很直接的这样表达：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8d6ac7c5217b2f440552ade7ffc937d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e627e6b6cb8744812278aad251807e9/" rel="bookmark">
			Python实现爬虫程序，付费歌曲一样可以免费下载~
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文的文字及图片来源于网络,仅供学习、交流使用,不具有任何商业用途,如有问题请及时联系我们以作处理。
PS：如有需要Python学习资料的小伙伴可以加点击下方链接自行获取
python免费学习资料以及群交流解答点击即可加入
今天在网上闲逛的时候发一下比较好的音乐下载网址，输入歌手名字有歌手全部的音乐，还可以下载无损音质的音乐
作为爬虫的爱好者，对此不得给安排一下？
打开F12 开发者工具，不管三七二十一，先来一顿瞎分析~
哦豁~ 这里面居然有数据接口，还是post请求，那这样的话就咱们就看它的data参数，那里有变化
多尝试几次之后，发现data参数，是动态变化且没有规律~
其中涉及了JS动态数据加载，这样的话，JS解密…emmmmmmmmmm
我不会呀~ 凉凉了？
怎么可以就这样放弃了~ 不会JS 那咱们就用另外一种方法~ selenium
selenium Selenium 是一个 Web 的自动化测试工具，最初是为网站自动化测试而开发的，就像玩游戏用的按键精灵，可以按指定的命令自动操作。
Selenium 测试工具直接操控浏览器中，就像真正的用户在操作一样。Selenium 可以根据的指令，让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生等。
模块安装
pip install selenium 谷歌驱动下载地址：
https://npm.taobao.org/mirrors/chromedriver/ http://chromedriver.storage.googleapis.com/index.html 配置浏览器驱动：
将下载好的浏览器驱动解压，将解压出的 exe 文件放到Python的安装目录下，也就是和python.exe同目录即可。
或者
把驱动和代码放在同一个路径里面~
实现代码 import time import requests from selenium import webdriver from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument('--headless') driver = webdriver.Chrome(executable_path='chromedriver.exe', options=chrome_options) driver.implicitly_wait(10) driver.get('http://tool.liumingye.cn/music/?page=searchPage') driver.find_element_by_css_selector('#input').send_keys('张杰') driver.find_element_by_css_selector('#search button:nth-child(2) i').click() """保存歌曲数据""" def download(name, url): filename = '音乐\\' + name + '.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e627e6b6cb8744812278aad251807e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e62d1127ad68fa838c71017207e6eb4c/" rel="bookmark">
			但是什么是模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		The term model gets thrown around a lot. The word is ubiquitous to the point of lost meaning. The Wikipedia page alone shows the variety of usage of the word model, including statistics, astronomy, biology, product design, art, as well as conceptual models.
术语模型引起了很多争议。 这个词到处都是意义不清的地方。 仅Wikipedia页面就显示了单词模型的各种用法，包括统计，天文学，生物学，产品设计，艺术以及概念模型。
The etymology of model is interesting as well, stemming through French and Italian back to the Latin modus, for ‘measure, rhythm, or way’.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e62d1127ad68fa838c71017207e6eb4c/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/363/">«</a>
	<span class="pagination__item pagination__item--current">364/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/365/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>