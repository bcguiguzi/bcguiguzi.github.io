<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20b17e08ab94667a65161b72c3ffbddb/" rel="bookmark">
			apt-get update
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		apt-get update更新签名报错
W: GPG 错误：http://archive.xxos.cn/xx/xx-ALL 10.1 InRelease: 由于没有公钥，无法验证下列签名： NO_PUBKEY F49EC40DDCE76770 E: 仓库 “http://archive.xxos.cn/xx/xx-ALL 10.1 InRelease” 没有数字签名。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt-secure(8) 手册以了解仓库创建和用户配置方面的细节。 解决：
执行以下命令，把F49EC40DDCE76770换成提示的字符串。
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F49EC40DDCE76770
然后再执行apt-get update
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e367de689895b674cdc68553a2b524a/" rel="bookmark">
			python编写的德汉互译小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考文章链接：https://blog.csdn.net/dushine2008/article/details/85335307
在他的基础上做了点小小小改动，dict1.txt放德语，dict2.txt放中文，然后实现了互译，而不是只能外文对中文的单向翻译。
全部代码如下：
import tkinter # 读取内容并执行搜索的方法 def search(word): # 读取字典内所有内容 dict1放德语 dict2放中文 file1 = open("dict1.txt", encoding='utf-8') file2 = open("dict2.txt", encoding='utf-8') dict_list1 = file1.readlines() dict_list2 = file2.readlines() # print(dict_list1) global i,j i =0 # 这个循环输入德语,翻译结果 # 遍历读取的内容，查看用户输入的英文是否存在 for dict00 in dict_list1: # 不区分大小写查询，查询到就输出英文和中文 if word.upper() == dict00.upper().split('\n')[0]: # 把查询的内容返回并结束循环 return "%s: %s" % (dict_list1[i].split('\n')[0], dict_list2[i]) i += 1 # 这个循环输入中文,翻译结果 j = 0 for dict01 in dict_list2: if word == dict01.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e367de689895b674cdc68553a2b524a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a1e1145099ebb35dd31ece54e0ca9898/" rel="bookmark">
			Fragment简单使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、Fragment使用场景二、Fragment主要特点三、Fragment与Activity通信四、Demo所涉及的部分代码 前言 简单记录一下Fragment的使用
提示：以下是本篇文章正文内容，下面案例可供参考
一、Fragment使用场景 Android运行在各种各样的设备中，有小屏幕的手机，还有大屏幕的平板，电视等。同样的界面在手机上显示可能很好看，在大屏幕的平板上就未必了，手机的界面放在平板上可能会有过分被拉长、控件间距过大等情况。针对屏幕尺寸的差距，Fragment的出现能做到一个App可以同时适应手机和平板。这就是为什么要有Fragment的原因。
二、Fragment主要特点 Fragment是一种可以嵌入在Activity当中的UI片段。
用来组建Activity界面的局部模块, 也可以说一个Actiivty界面可以由多个Fragment组成。
其行为与Activity很相似, 有自己对应的布局(包含具体的View), 它有自己的生命周期，接收自己的输入事件，并且可以从运行中的activity中添加或移除。
一个fragment必须总是嵌入在一个activity中，同时fragment的生命周期受activity的影响。
优势：
模块化：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。
可重用：多个Activity可以重用一个Fragment。
可适配：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。
三、Fragment与Activity通信 Activity–&gt;Fragment: 在Activity中创建Bundle数据包，并调用Fragment的setArguments(Bundle bundle)方法Fragment–&gt;Activity:需要在Fragment中定义一个内部回调接口，再让包含该Fragment的Activity实现该回调接口。这样Fragment可调用该回调方法将数据传递给Activity 四、Demo所涉及的部分代码 1.MainActivity的布局文件
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/change_btn" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="change" /&gt; &lt;Button android:id="@+id/replace_btn" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="replace" /&gt; &lt;FrameLayout android:id="@+id/framelayout" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/cardview_light_background"&gt;&lt;/FrameLayout&gt; &lt;/LinearLayout&gt; 2.fragment_blank1的布局文件
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".BlankFragment1"&gt; &lt;!-- TODO: Update blank fragment layout --&gt; &lt;TextView android:layout_width="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a1e1145099ebb35dd31ece54e0ca9898/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b0ac7e15d5208e09615f627e1b4b9ce/" rel="bookmark">
			指标研究与多周期
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		哪些地方会用到指标 ？
回顾一下 Backtrader 的主要功能模块和回测流程（见：Backtrader 来了！）可以发现，只有在编写策略Strategy 时才会涉及到指标的计算和使用，而且是 Strategy 中的 __init__() 和 next() 方法涉及的最多。
建议在 __init__() 中提前计算指标
Strategy 中的 __init__() 函数在回测过程中只会在最开始的时候调用一次，
而 next() 会每个交易日依次循环调用多次，所以为了提高回测效率，建议先在 __init__() 中一次性计算好指标（甚至是交易信号），
然后在 next() 中调用已经算好的指标，这样能有效避免指标的重复计算，提高回测运行速度。建议遵循“__init__() 负责指标计算，next() 负责指标调用”的原则。
import backtrader.indicators as btind # 导入策略分析模块 class MyStrategy(bt.Strategy): # 先在 __init__ 中提前算好指标 def __init__(self): sma1 = btind.SimpleMovingAverage(self.data) ema1 = btind.ExponentialMovingAverage() close_over_sma = self.data.close &gt; sma1 close_over_ema = self.data.close &gt; ema1 sma_ema_diff = sma1 - ema1 # 生成交易信号 buy_sig = bt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b0ac7e15d5208e09615f627e1b4b9ce/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7581daa45f3c4b3c29a00c494d116bdd/" rel="bookmark">
			VGA图像显示总结（彩条显示、方块移动、字符显示、基于ROM的图片显示）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VGA显示器成像原理
图像显示的时候，是采用逐行扫描的方式，从左到右，从上到下，每次扫描一个点的时候发送一个数据，然后那个像素点就会把这个数据对应的颜色发送到屏幕上，在每一次回扫的过程中，不能影响屏幕上既有图像的颜色，所以就是消隐信号（BLK）存在的意义，在每次回扫时，消隐信号启动，此时屏幕上没有新的数据输入，也就不会影响原本的颜色，消隐分为场扫描和行扫描。
VGA时序 行扫描：根据上图进行分析，首先需要一个行同步信号，根据这个行同步信号用来指导消隐信号的变化，以及数据的传输，行同步信号（HSYC）的一个周期包含的时间有行同步时间（Sync Pulse）、Back Porch（回扫时间）、Left Border(显示器左侧黑边的扫描的时间）、Visible area(数据传输的有效时间）、Right Border(显示器右侧黑边的扫描的时间）、Front Porch(产生消隐信号用的时间）
场扫描：根据上图进行分析，首先需要一个场同步信号，根据这个场同步信号用来指导消隐信号的变化，以及数据的传输，场同步信号（VSYC）的一个周期包含的时间有场同步时间（Sync Pulse）、Back Porch（回扫时间）、Left Border(显示器左侧黑边的扫描的时间）、Visible area(数据传输的有效时间）、Right Border(显示器右侧黑边的扫描的时间）、Front Porch(产生消隐信号用的时间）
行扫描和场扫描类似，相关点在于每次扫描一行，场即竖直方向上扫描一个点，所以说场扫描时的那个时间其实根据行扫描来变化的。
根据时序来看，其实也就只有在Visible area这个区域是有效的数据传输时间，其他位置数据都不传输，可以直接让消隐信号启动，不输入数据就完事了。
然后对模块的端口分析一下
VGA_HS：就是行同步信号，根据上面所述的时间周期来控制VGA_HS的变化
VGA_VS：就是场同步信号，根据上面所述的时间周期来控制VGA_VS的变化
R/G/B：就是输入的数据（在数据传输的有效时间输入）
CLOCK：VGA模块的驱动时钟，根据不同的像素和刷新频率而不同，具体为多少要查询相关手册
VGA_BLK：消隐信号、根据上面所述的时间周期来控制VGA_HS的变化
上面所述的时间具体为多少呢？也是根据不同的像素而不同，具体为多少要查询相关手册
一、GM7123芯片
在VGA图像显示时，采用的是GM7123芯片
在驱动GM7123时有多种数据传输方式
我采用的是RGB888格式的数据传输。
下面就是VGA驱动模块的程序部分啦，我采用的是1920*1080像素的显示模式，根据下图中参数进行编写
当0时刻时 ，行同步信号为下降沿开始，当44时，行同步信号拉高，当44（行同步信号脉冲时间）+148（H_Back_Porch）+0(H_Left_Border)=192是开始发送有效数据，当192+1920（有效数据时间）=2112时有效数据发送完成，2112+0（H_Right_Borde）+88(H_Front_Porch)=2200时，一个周期结束。只有在有效数据发送时，才不会启动消隐信号，其余时间不发送数据，可以让消隐信号始终有效。
场同步信号和行同步信号类似，但是要注意，只有扫描完一行时，场同步信号才会+1。
module VGA_CTRL(
clk,
Rst_n,
data_in,
Hcounter,
Vcounter,
VGA_HS,
VGA_VS,
VGA_BLK,
VGA_RGB ); input clk;
input Rst_n;
input [23:0] data_in;
output [11:0] Hcounter;
output [10:0] Vcounter;
output reg VGA_HS;
output reg VGA_VS;
output reg VGA_BLK;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7581daa45f3c4b3c29a00c494d116bdd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adbd99970dceb454724e51bdc4d0fe78/" rel="bookmark">
			backtrader数据基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cerebro = bt.Cerebro() cerebro.addstrategy(TestStrategy2) codes=['600862.SH','300326.SZ','300394.SZ'] #加载最近两日交易数据 for code in codes: feed = Addmoredata(dataname = get_data(code,'20200506'),name=code) cerebro.adddata(feed) cerebro.run() 数据查看：
class TestStrategy(bt.Strategy): def __init__(self): # 打印数据集和数据集对应的名称 print("-------------self.datas-------------") print(self.datas) print("-------------self.data-------------") print(self.data._name, self.data) # 返回第一个导入的数据表格，缩写形式 print("-------------self.data0-------------") print(self.data0._name, self.data0) # 返回第一个导入的数据表格，缩写形式 print("-------------self.datas[0]-------------") print(self.datas[0]._name, self.datas[0]) # 返回第一个导入的数据表格，常规形式 print("-------------self.datas[1]-------------") print(self.datas[1]._name, self.datas[1]) # 返回第二个导入的数据表格，常规形式 print("-------------self.datas[-1]-------------") print(self.datas[-1]._name, self.datas[-1]) # 返回最后一个导入的数据表格 print("-------------self.datas[-2]-------------") print(self.datas[-2]._name, self.datas[-2]) # 返回倒数第二个导入的数据表格 data1 = pd.read_csv('111.csv') cerebro = bt.Cerebro() st_date = datetime.datetime(2019,1,2) ed_date = datetime.datetime(2021,1,28) # 添加 600466.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/adbd99970dceb454724e51bdc4d0fe78/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9b505006558a75b0059f53f613ba39d/" rel="bookmark">
			win10计算机出现位置不可用desktop不可用，桌面只有此电脑几个图标，其它桌面图标都没有了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境： 2019AD域 用户
win10 专业版1909
问题描述： 出现位置不可用desktop不可用，桌面只有此电脑几个图标，其它桌面图标都没有了
原因分析： 注册表Desktop键值出问题
解决方案： 1.、打开注册表编辑器
2、在注册表编辑器窗口，依次展开并定位至HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders在右侧双击打开名称为Desktop的字符串值，在编辑字符串窗口，复制数值数据;
3、接下来依次展开：HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders，在右侧窗口找到并双击名称为Desktop的字符串值，删除原来的数值数据，将之前复制的数值数据粘贴进入，然后点击“确定”退出注册表编辑器;
4、完成操作后，重启Win10系统，即可解决问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2700388e7bd0c3613ffe4f29b2c54d3e/" rel="bookmark">
			公共子串计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;h1&gt;公共子串计算&lt;/h1&gt; &lt;script type="text/javascript"&gt; let [a, b] = ["asdfas", "werasdfaswer"]; // 6 let [alen, blen] = [a.length, b.length]; let res = 0; for (let i = 0; i &lt; alen; i++) { for (let j = 0; j &lt; blen; j++) { let [x, y] = [i, j]; let count = 0; while (x &lt; alen &amp;&amp; y &lt; blen &amp;&amp; a[x] === b[y]) { x++; y++; count++; } if (res &lt; count) { res = count; } } } console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2700388e7bd0c3613ffe4f29b2c54d3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/765bda4358b30badd7988f85a78bdd28/" rel="bookmark">
			AcWing 1945. 奶牛棒球
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AcWing 1945. 奶牛棒球 农夫约翰的 N 头奶牛排成一排，每头奶牛都位于数轴中的不同位置上。
它们正在练习投掷棒球。
农夫约翰观看时，观察到一组三头牛(X,Y,Z)完成了两次成功的投掷。
牛 XX 把球扔给她右边的牛 Y，然后牛 Y把球扔给她右边的牛 Z。
约翰指出，第二次投掷的距离不少于第一次投掷的距离，也不超过第一次投掷的距离的两倍。
请计算共有多少组牛 (X,Y,Z)可能是约翰所看到的。
输入格式 第一行包含整数 N。
接下来 N行，每行描述一头牛的位置。
输出格式 输出奶牛三元组 (X,Y,Z)的数量。
(X,Y,Z) 需满足，Y 在 X 的右边，Z 在 Y 的右边，并且从 Y到 Z 的距离在 XY 之间，其中 XY 表示从 X 到 Y 的距离。
数据范围 3≤N≤1000
输入样例： 5 3 1 10 7 4 输出样例： 4 样例解释 四个可能的奶牛三元组为：1−3−7,1−4−7,4−7−10,1−4−10。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ccf15da2b5810f9a0f394492cbc699cd/" rel="bookmark">
			(已解决)错误：Plugin [id: ‘org.springframework.boot‘, version: ‘2.3.3.RELEASE‘] was not found
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上我参考了有很多方案，但是都没有成功，比如：(已解决)错误：Plugin [id: 'org.springframework.boot', version: '2.1.4.RELEASE'] was not found_苦行僧爱吃荞麦面的博客-CSDN博客_org.springframework.boot version
原来最终的原因是我打开了这个，把这个关闭就行了：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fd8cc5440a35dc92e3f48f5a7094941f/" rel="bookmark">
			C语言 翁凯老师 数据结构 链表学习（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		链表的建立
linked-list.c
#include"node.h" #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; // typedef struct _node // { // int value; // struct _node *next; // } Node; int main() { Node * head = NULL;//初始化 int number; do{ scanf("%d",&amp;number); if(number != 1){ //add to linked-list Node *p = (Node*)malloc(sizeof(Node)); p-&gt;value = number; p-&gt;next = NULL; //find the last Node *last = head; if(last){ while (last-&gt;next){//遍历到last-&gt;next=NULL为止，保证数据存储在链表的最后一位 last = last-&gt;next; } //attach last-&gt;next = p; }else{ head = p; } } }while (number !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fd8cc5440a35dc92e3f48f5a7094941f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9454954aba3efe80e284c14af9d8daf5/" rel="bookmark">
			win10 VS2015&#43;OpenCV4.1.2一劳永逸的永久性配置方式及不同OpenCV版本之间的无缝切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		win10 VS2015+OpenCV4.1.2 完整详细一劳永逸的永久性配置方式 OpenCV官网：Releases - OpenCV，下载OpenCV后直接解压就可以了。 一、环境变量配置
1、用户变量设置
添加用户变量：OpenCV_PATHhj（自己定名字，我的是OpenCV_PATHhj）
用户变量值：
D:\Program Files\OpenCV\opencv4.1.2\opencv\build
D:\Program Files\OpenCV\opencv4.1.2\opencv\build\x64\vc15\bin
（用哪个版本的OpenCV就配置哪个版本，也可以配置多个，版本间无缝切换）
将添加的用户变量应用到PATH下；%OpenCV_PATHhj%
也可以直接在PATH后添加下面的变量值：
D:\Program Files\OpenCV\opencv4.1.2\opencv\build
D:\Program Files\OpenCV\opencv4.1.2\opencv\build\x64\vc15\bin
注：vc10表示VS是2010，vc11对应VS2012，vc12对应VS2013，vc14对应VS2015 ,vc15对应VS2017
2、系统变量设置【不配置用户变量，只配置系统变量好像也是可以的】
添加系统变量：
（1）可以直接在PATH后添加下面的变量值，以英文 ; 隔开：
D:\Program Files\OpenCV\opencv4.1.2\opencv\build\x64\vc15\bin
（2）如果要添加的变量值较多，也可以添加变量-值对，再将变量名添加到系统变量的Path中。（我采用的是第二种）
新建系统变量，输入变量名：OpenCV_PATHhj（自己定名字，我的是OpenCV_PATHhj）
输入变量值：D:\Program Files\OpenCV\opencv4.1.2\opencv\build\x64\vc15\bin
在系统变量Path后添加：%OpenCV_PATHhj%
做完上面的配置后，OpenCV的环境变量就配置完。（有说要重启才生效，但我没重启，发现也是可以的）
二、配置属性表 系统的默认属性表一般是位于：C:\Users\用户名\AppData\Local\Microsoft\MSBuild\v4.0
我的是位于：C:\Users\lenovo\AppData\Local\Microsoft\MSBuild\v4.0
属性表名称：Microsoft.Cpp.Win32.user.props（x86属性表）
Microsoft.Cpp.x64.user.props（x64属性表）
更改属性表之前建议先备份一份（以防万一改错了）。
以记事本方式打开属性表文件，将以下内容添加到：Microsoft.Cpp.x64.user.props中
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt; &lt;PropertyGroup&gt; &lt;IncludePath&gt;D:\Program Files\OpenCV\opencv4.1.2\opencv\build\include\opencv2;D:\Program Files\OpenCV\opencv4.1.2\opencv\build\include;$(IncludePath)&lt;/IncludePath&gt; &lt;LibraryPath&gt;D:\Program Files\OpenCV\opencv4.1.2\opencv\build\x64\vc14\lib;D:\Program Files\OpenCV\opencv4.1.2\opencv\build\x64\vc15\lib;$(LibraryPath)&lt;/LibraryPath&gt; &lt;/PropertyGroup&gt; &lt;ItemDefinitionGroup&gt; &lt;Link&gt; &lt;AdditionalDependencies&gt;opencv_world412.lib;%(AdditionalDependencies)&lt;/AdditionalDependencies&gt; &lt;/Link&gt; &lt;/ItemDefinitionGroup&gt; &lt;/Project&gt; 三、验证是否配置成功 1、新建win32控制台工程
下一步--&gt;下一步--&gt;完成
在项目名称上右键--&gt;属性--&gt;配置属性--&gt;VC++目录
包含目录中有以下内容：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9454954aba3efe80e284c14af9d8daf5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0a18cb574112e1322772d04f4412d58/" rel="bookmark">
			穷举DFS算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 1.篮球赛，10人，每个人有一个战斗力n1-n10 分成两组（人数相等），战斗力差值最小 &lt;/h1&gt; &lt;script type="text/javascript"&gt; //输入:10 9 8 7 6 5 4 3 2 1 // 输出:1 let arr = "10 9 8 7 6 5 4 3 2 1 8 2".split(" "); let total = arr.reduce((acc, item) =&gt; { return acc + +item; }, 0); let res = total; function dfs(doArr, used, arr) { if (doArr.length === arr.length / 2) { let tmpTotal = doArr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0a18cb574112e1322772d04f4412d58/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cad8135c984f4e152e7f40a2ab279e59/" rel="bookmark">
			Go语言实现多态
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多态是什么 相信学过Java这种面向对象语言的同学对于多态来说都不陌生，在代码执行的时候，能够根据子类的类型去执行子类当中的方法。多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。
Go语言多态举例 有这样一个场景，我们在应用开发中涉及到很多通知事件，通知的类型可以是通过微信、QQ、Email等，那么我们可以抽象出一个接口，定义一个通知的接口，然后微信通知类、QQ通知类、Email通知类分别实现对应的通知方法。
定义一个通知类型：notifier // 通知者接口 type Notifier interface { // 通知方法，可以由具体的类进行实现 notify() } 定义微信类型、QQ类型、Email类型，并实现notify方法，以指针类型作为方法的接收者 type WechatNotifier struct { Name string Message string } func (w *WechatNotifier) notify() { fmt.Printf("%v notify %v \n", w.Name, w.Message) } type QQNotifier struct { Name string Message string } func (q *QQNotifier) notify() { fmt.Printf("%v notify %v \n", q.Name, q.Message) } type EmailNotifier struct { Name string Message string } func (e *EmailNotifier) notify() { fmt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cad8135c984f4e152e7f40a2ab279e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/562d5957eb81f4bfa3cd2595d88891c4/" rel="bookmark">
			蓝桥杯——Sticks (C&#43;&#43;)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目来源：蓝桥杯算法训练 知识点：搜索 问题描述
George took sticks of the same length and cut them randomly until all parts became at most 50 units long. Now he wants to return sticks to the original state, but he forgot how many sticks he had originally and how long they were originally. Please help him and design a program which computes the smallest possible original length of those sticks. All lengths expressed in units are integers greater than zero.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/562d5957eb81f4bfa3cd2595d88891c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1bb7085520ba9018caa584ed7790aee/" rel="bookmark">
			蓝桥杯—时间显示—Java
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、问题描述 2、输入输出格式 3、使用Java中的API完成 import java.sql.Date; import java.text.SimpleDateFormat; import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); long time = scanner.nextLong(); //这里剪去8个小时的时间是因为这里的Date是以1970-01-01 08:00:00开始的 //比题目中要求的时间早8个小时，所以要剪去。下面这行代码可以验证 //System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date(0))); time -= 8 * 60 * 60 * 1000; //格式化输出 System.out.println(new SimpleDateFormat("HH:mm:ss").format(new Date(time))); } } 4、不使用Java中的API完成 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); long time = scanner.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e1bb7085520ba9018caa584ed7790aee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/143440a61cff798da77bf4a0847cd433/" rel="bookmark">
			表单标签知识点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表单标签: 表单使用场景最多使用的还是注册页面
为什么需要表单? 使用表单的目的是为了收集用户信息
表单是如何组成的? 在HTML中,一个完整的表单通常是由表单域,表单控件(也称为表单元素)和提示信息 3个部分构成
什么是表单域? 表单域是一个包含表单元素的区域
表单域有什么作用呢? 在HTML标签中,&lt;form&gt;标签用于定义表单域,以实现用户信息的收集和传递
&lt;form&gt;标签会把它范围内的表单元素信息提交给服务器
表单域中需要注意的要点:
1.在外面写表单元素之前,应该有个表单域把他们进行包含
2.表单域就是form标签
表单控件(表单元素)
在表单域中可以定义各种表单元素,
什么是表单元素? 这些表单元素就是允许用户在表单中输入或者选择的内容空间
比如:
input输入表单元素
select下拉表单元素
textarea文本域元素
表单都应该写到 &lt;form&gt;&lt;/form&gt;标签之间
1.&lt;input&gt;表单元素 &lt;input&gt;标签用于收集用户信息
在&lt;input&gt;标签中的type属性,可以通过不同的属性值,控制输入字段的形式(比如文本字段,复选框,掩码后的文本控件,单选按钮,按钮等)
截至目前:
单标签: &lt;br /&gt; &lt;input /&gt;都为单标签
type属性不同的属性值来指定不同的控件类型
属性值: text 是文本框 type 的其他属性:
input之间要有相同的 name="名字" 就可以实现多选一 就会避免两个都选的尴尬!!!
value 是直接在表单上显示出来的
checked 是在单选按钮和复选框中的 默认已经选中
maxlength 规定了可输入的长度 maxlength="长度"
当页面中的表单元素很多,如何区别不同的表单元素? 通过 name属性 name的主要作用就是用于区别不同的表单
如何让页面一打开其中的单选按钮或者多选框就已经出于选中状态?
需要添加 checked="checked"
&lt;lable&gt;标签 (增大用户可以操作的区域)
&lt;label&gt;标签用于绑定一个表单元素,当点击&lt;label&gt;标签内的文本时,浏览器就会自动将焦点转到对应的表单元素上,用来增加用户体验 label标签一般适合 input标签搭配使用的 2.select下拉表单元素(当有较多选项时 使用) 注意点:
1.&lt;select&gt;标签之间至少包含一对&lt;option&gt;
2.在&lt;option&gt;中定义 selected = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/143440a61cff798da77bf4a0847cd433/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/21f9aef6063e1942af9f3f0aa60b73e9/" rel="bookmark">
			【ACM刷题记录】线段树杂题其一
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		title : 线段树杂题
date : 2021-11-14
tags : ACM,数据结构
author : Linno
区间子段和 每 次 询 问 在 序 列 的 [ x 1 , y 1 ] 中 选 L , [ x 2 , y 2 ] 中 选 R ， 使 得 子 段 和 [ L , R ] 最 大 每次询问在序列的[x1,y1]中选L,[x2,y2]中选R，使得子段和[L,R]最大 每次询问在序列的[x1,y1]中选L,[x2,y2]中选R，使得子段和[L,R]最大
SP2916 GSS5 - Can you answer these queries V #include&lt;iostream&gt; #define inf 0x3f3f3f3f #define int long long using namespace std; const int N=1e4+7; const int mod=1e9+7; int t,n,m,x1,x2,y1,y2,a[N],s[N]; #define lc p&lt;&lt;1 #define rc p&lt;&lt;1|1 struct T{ int l,r; int ls,rs,sum,ans,mx,mi; }tr[N&lt;&lt;2]; T pushup(T L,T R){ T res; res.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/21f9aef6063e1942af9f3f0aa60b73e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a831b2c06758e96274f9dd804d5aeced/" rel="bookmark">
			DSP2837x ECAP调试（BLDC霍尔）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECAP捕捉霍尔信号 前言一、ECAP的作用二、ECAP初始化及配置1.初始化1）mian（）2）引脚配置3）ECAP配置 2.中断 总结 前言 DSP28377D 的ECAP调试。
提示：以下是本篇文章正文内容，下面案例可供参考
一、ECAP的作用 ECAP可以根据位置传感器脉冲来测量位置、计算脉冲周期等等。
此处我们使用ECAP来捕捉霍尔的信号，类似于STM32的定时器捕捉霍尔功能，本质上ECAP也是通过计数器计算周期。
二、ECAP初始化及配置 1.初始化 1）mian（） 主函数代码部分如下（示例）：
EALLOW; PieVectTable. ECAP1_INT = &amp;ECAP1_ISR; PieVectTable. ECAP2_INT = &amp;ECAP2_ISR; PieVectTable. ECAP3_INT = &amp;ECAP3_ISR; EDIS; //Enable eCAP1\2\3 interrupts PieCtrlRegs.PIEIER4.bit.INTx1 = 1; PieCtrlRegs.PIEIER4.bit.INTx2 = 1; PieCtrlRegs.PIEIER4.bit.INTx3 = 1; IER |= M_INT4; //CAP InitECap1(); InitECap2(); InitECap3(); 2）引脚配置 28377和28335的ECAP有不同，2837x里的ECAP属于x-bar范围，分别是INTPUT 7 、8、9，
简单来说就是将引脚配置成普通GPIO然后再用x-bar的input7映射到引脚即可 。
InputXbarRegs.INPUT7SELECT = 58;
//Set ECAP1 source to GPIO-pin58
代码如下（示例）：
void InitECap1(void) { EALLOW; InputXbarRegs.INPUT7SELECT = 58; //Set ECAP1 source to GPIO-pin GpioCtrlRegs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a831b2c06758e96274f9dd804d5aeced/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a00be4b704598dd461852604f4e9a3a2/" rel="bookmark">
			【虹科案例】智能工控屏eX707在水下遥控机器人中的应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 背景 虹科 · 智能工控屏eX707在水下遥控机器人中的应用
随着我国经济与科学技术的发展壮大，作为“蓝色粮仓”的海洋能源开采建设逐渐成为一项重要的事业。深海作业装备则成为海洋能源开采的必备和关键工具，其性能和可靠性须得以保障。
也因此，开发性能表现更佳、安全可靠、坚固耐用的海洋工程装备成为深海作业装备制造行业亟待解决的问题。
上海中车艾森迪海洋装备有限公司（SMD上海公司）是一家专注于海洋工程项目装备的大型企业，基于SMD英国公司强大的深海技术支撑，以及其母公司--中国中车在电气控制领域深厚的技术底蕴，使其在深海机器人电气控制、布放回收系统、水下系统集成具有行业竞争优势。
考虑到海洋装备使用对工作温度、湿度、防护等级以及抗腐蚀性能等的严苛要求，该公司推出的水下遥控机器人最终决定采用虹科EXOR eX707工控屏实现通信及控制，本文将为大家分享这一设备的应用作为参考。
2 应用 具体使用场景分享
SMD上海公司使用eX707工控屏及配套的JMobile Studio软件，实现船舶设备的数据通信及控制，保障船舶甲板布放及机器人下水过程。
为方便现场操作，eX707被安装位于设备旁侧的控制机柜中，其主要作用是控制整套甲板设备，保障水下遥控机器人从甲板布放到海面以及下水过程的安全实施，即实现整机布放回收系统控制。
在控制机柜中，操作手柄、按钮等连接至PLC，直接送达控制命令至设备机体，工控屏经由以太网与PLC进行通信，保障部分命令功能可通过HMI组态界面中的软按钮实现，通过在JMobile Studio中对标签进行设置，HMI警报界面及指示灯可负责设备运行、警报等状态的显示，便于工作人员掌握设备状态。
为什么选择虹科的智能工控屏？
在与SMD技术交流过程中，我们的工程师了解到，对方提及的功能除常用的标签定义、警报触发、配方转储与还原、用户组权限定义、双语设置等之外，还比较关注如截屏、蜂鸣器等软按钮添加。
由于船舶行业户外光照原因，现场人员直拍屏幕会出现强反光，因而会需要截屏功能，而蜂鸣器软按钮则是为了方便用户在警报触发时控制其是否关闭示警。
此外，用户方的工程师也对虹科及时、快速的技术支持服务响应表示很认可。
3 产品方案 虹科智能工控屏eX707的与众不同
与普通的HMI相比，虹科提供的EXOR工控屏具有高防护、更宽温、多认证（DNV-GL、ATEX、IECEx等）、海量通信支持等诸多特点，质保期长达5年，可见其出色性能表现。
强大的HMI开发软件JMobile Studio含丰富控件，操作简单便捷，可实现项目工程数据趋势查看、警报通知、用户权限管理等，满足行业用户功能需求；多语言支持也为国内外工程师提供了便利；其高度可调的屏幕亮度（100%背光调节）符合船舶行业在强光及夜晚环境中的操作需求，且拥有专业的船舶认证、防爆认证等。
在中国，虹科与EXOR有着深度合作，致力于将旗舰eX700系列、精简eSMART系列、以及食品/医药行业专用FB系列、户外恶劣环境专用G系列等工控屏引入更适配的应用场景，为广大用户带来更大价值。
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/263/">«</a>
	<span class="pagination__item pagination__item--current">264/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/265/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>