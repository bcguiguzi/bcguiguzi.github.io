<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b489c827a2972952fce4c5338c63d94/" rel="bookmark">
			Http 请求状态码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 HTTP状态码是服务器用于告知客户端网页或资源的请求状态的三位数字代码。这些状态码分为五个类别，每个类别有不同的用途：
1xx - 信息性状态码 100 Continue：客户端应继续其请求101 Switching Protocols：请求者已要求服务器切换协议，服务器已确认并准备切换102 Processing（WebDAV）：服务器已接受请求，但尚未处理完成 2xx - 成功状态码 200 OK：请求成功。常用于GET与POST请求201 Created：请求成功并且服务器创建了新的资源202 Accepted：服务器已接受请求，但尚未处理203 Non-Authoritative Information：服务器是一个转换代理服务器，所以服务器返回的信息可能来自另一来源204 No Content：服务器成功处理了请求，但没有返回任何内容205 Reset Content：服务器成功处理了请求，但没有返回任何内容，并且要求请求者重置文档视图206 Partial Content：服务器成功处理了部分GET请求 3xx - 重定向 300 Multiple Choices：针对请求，服务器可执行多种操作301 Moved Permanently：请求的网页已永久移动到新位置302 Found：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行将来的请求303 See Other：请求者应当对不同的资源使用GET方法进行请求304 Not Modified：自从上次请求后，请求的网页未修改过307 Temporary Redirect：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行将来的请求308 Permanent Redirect：请求的资源现在永久位于另一个URI 4xx - 客户端错误 400 Bad Request：服务器不理解请求的语法401 Unauthorized：请求要求身份验证403 Forbidden：服务器拒绝请求404 Not Found：服务器找不到请求的网页405 Method Not Allowed：禁用请求中指定的方法406 Not Acceptable：无法使用请求的内容特性响应请求的网页407 Proxy Authentication Required：此状态码与401（Unauthorized）类似，但指定请求者应当授权使用代理408 Request Timeout：服务器等候请求时发生超时409 Conflict：请求与服务器的当前状态冲突410 Gone：请求的资源已被永久删除411 Length Required：服务器不接受不含有效内容长度头字段的请求412 Precondition Failed：服务器未满足请求者在请求中设置的其中一个前提条件413 Payload Too Large：请求实体过大414 URI Too Long：请求的URI过长415 Unsupported Media Type：请求的格式不受请求页面的支持416 Range Not Satisfiable：客户端请求的范围无效417 Expectation Failed：服务器无法满足Expect请求头字段指示的期望值 5xx - 服务器错误 500 Internal Server Error：服务器遇到错误，无法完成请求501 Not Implemented：服务器不具备完成请求的功能502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应503 Service Unavailable：服务器目前无法使用（由于超载或停机维护）504 Gateway Timeout：服务器作为网关或代理，但是没有及时从上游服务器收到请求505 HTTP Version Not Supported：服务器不支持请求中所用的HTTP协议版本506 Variant Also Negotiates（透明内容协商）：服务器有一个内部配置错误507 Insufficient Storage（WebDAV）：服务器无法存储完成请求所必须的内容508 Loop Detected（WebDAV）：服务器在处理请求时检测到无限循环510 Not Extended：获取资源所需要的扩展未被服务器满足511 Network Authentication Required：客户端需要进行身份验证才能获得网络访问权限 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4133a85e49cf68407675682daed4b00/" rel="bookmark">
			Spark的数据结构——RDD
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RDD 的 5 个特征 下面来说一下 RDD 这东西，它是 Resilient Distributed Datasets 的简写。
咱们来看看 RDD 在源码的解释。
A list of partitions: 在大数据领域，大数据都是分割成若干个部分，放到多个服务器上，这样就能做到多线程的处理数据，这对处理大数据量是非常重要的。分区意味着，可以使用多个线程了处理。A function for computing each split：作用在每个分区里面的函数，当我们读取数据之后，当然是要对其加工的，加工的定义就是我们编写的函数，这些函数主要包含转化算子、控制算子、行动算子。A list of dependencies on other RDDs。一个 Spark Application 下面可以有多个 Job ，一个 action 算子就可以分出一个 job ，一个 job 里面又可以分出若干个 stage ， 一个 stage 中又有多个 RDD ，RDD 之间是用上下游关系的，就像流水线的工序，公休之间也会有先后之分的，例如，手机装壳之后才能上螺丝，这种上下游关系，使用依赖描述的，依赖又分为窄依赖和宽依赖。 那两个 RDD 为例，rdd2 依赖于 rdd1 ，Optionally, a Partitioner for key-value RDDs (e.g. to say that the RDD is hash-partitioned)Optionally, a list of preferred locations to compute each split on (e.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4133a85e49cf68407675682daed4b00/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6c140c1caa74b06d10315f34fa8f060e/" rel="bookmark">
			数学建模——蒙特卡洛法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1.介绍2.可以做的题型3.实战3.1求pi的值3.2求定积分x^2 的值 参加了大大小小很多场比赛了，但是都是混子，但还是打算记录一下吧，系统认真过一遍。后续功力深厚，会拓展写的文章，目前是干货，一些背景啥的还都未介绍。
1.介绍 随机抽样，求取近似解。
当无法求得精确解时，进行随机抽样，根据统计试验求近似解，
我的理解就是从一个样本抽取一些数据，进而估计整体的解，由于是抽取的样本数据，因此是近似解。
样本越大，越接近真实值，也就是数学统计值，
！！！注意：蒙特卡洛法是个思路，不是算法，具体问题具体分析。
2.可以做的题型 概率模型：蒙特卡洛算法可以用于模拟复杂的概率模型。例如，在金融领域中，可以使用蒙特卡洛方法来模拟股票价格的随机演化，并进行风险估计和投资组合优化。
最优化问题：蒙特卡洛算法可以用于求解最优化问题。例如，在运筹学中，可以使用蒙特卡洛方法来求解旅行商问题、装箱问题等。
数值计算：蒙特卡洛算法在数值计算中很有用。例如，在微分方程的数值求解中，可以使用蒙特卡洛方法来模拟随机扰动，从而获得系统的稳定解。
随机模型：蒙特卡洛算法可以用于研究随机模型的性质和行为。例如，在生物学中，可以使用蒙特卡洛方法来模拟基因演化和遗传算法。
不确定性分析：蒙特卡洛算法可以用于分析模型的不确定性。例如，在环境科学中，可以使用蒙特卡洛方法来进行不确定性分析和灾害模拟。
等等。
3.实战 3.1求pi的值 import random #导入random生成随机数 #d定义一个估计pi的函数，传入形参num_saamples def estimate_pi(num_samples): # 定义变量 inside_circle = 0 #园内点数 total = 0 #总点数 #定义for循环，下划线表示在循环中未使用这个变量的值 #正常for应该是for 变量 in xxx（范围）： for _ in range(num_samples): #定义xy坐标，正方形面积为2*2=4 x = random.uniform(-1, 1) #random随机函数 y = random.uniform(-1, 1) #求距离 distance = x ** 2 + y ** 2 #判断 if distance &lt;= 1: #园内点 inside_circle += 1 #园内加一 total += 1 #循环一次，总点数加一 pi_estimate = 4 * inside_circle / total #pi的估计值 return pi_estimate #这个函数返回的是pi的估计值 num_samples = 100000 #定义循环次数 pi = estimate_pi(num_samples) #求pi的估计值 print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6c140c1caa74b06d10315f34fa8f060e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3232a7f2e069af92f0b4dcc6df25781e/" rel="bookmark">
			MySQL教程-入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 数据库 数据库(Database)是按照数据结构来组织、存储和管理数据的仓库。(也可将数据存储在文件中，但其读写速度相对较慢)
每个数据库都有一个或多个不同的API用于创建、访问、管理、搜索和复制所保存的数据。
使用 关系型数据库管理系统(RDBMS：Relational Database Management System) 用来存储和管理大数据量。所有关系型数据库是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。
RDBMS术语 数据库 存储数据的仓库，数据是有组织的存储
数据库管理系统 操作和管理数据库的软件
数据表 数据的矩阵。表在数据库中看起来像一张表格
列 包含了相同类型的数据
行 一组相关的数据
冗余 存储了多余数据。冗余降低了性能，但提高了数据的安全性
主键 唯一标识数据中列，可一列或多列。
外键 用于表示表的关系
复合键 将多列作为一个整体
索引 对数据库中一列或多列的值进行排序的一种结构
参照完整性 要求关系中不允许引用不存在的实体。
SQL 操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准
RDBMS特点 数据以表格的形式出现每行为各种记录名称每列为记录名称所对应的数据域许多的行和列组成一张表单若干的表组成数据库 MySQL MySQL是最流行的关系型数据库管理系统之一。其由瑞典MySQL AB公司开发，目前隶属 Oracle 公司。
MySQL特点
开源且可定制支持大型的数据库，可处理拥有上千万条记录的大型数据库使用标准的SQL数据语言形式可应用于多种操作系统上，并且支持多种语言 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/489c043c5e826b858bac435b99544e5b/" rel="bookmark">
			Python学习笔记1：Pycharm首次安装环境搭建汉化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pycharm首次安装环境搭建汉化笔记
1.下载网址 首先下载专业版的pycharm，这里建议下载专业版是因为功能更全面，社区版的往往没有远程调控等实践功能。 网址贴在下方：
https://www.jetbrains.com/pycharm/download/?section=windows
•Professional，是专业版，收费且功能非常完善
•Community，是社区版，免费但是只有部分功能
这里我们可以看到它提示仅有30天免费使用权限，我是准备淘宝购买低价解锁密钥了······
2.首次启动配置： 1.初始设置： 首次启动需要我们 进行一些初始的设置，这里如下图选择就行：
看到Welcome to Pycharm页面，就代表首次启动好了。首次会要求我们填写licenses，这个自己想办法，网上有破解或者自己购买就好了。
2.新建项目文件： 然后点击New Project来新建一个项目文件
3.下载解释器： 要是没有解释器的话他还会自己帮你下载解释器，可在上一项自己选择哪个版本的解释器进行下载
4.汉化： 首先点击file，点击Settings进行设置：
安照圈出步骤搜索到中文支持插件并下载即可，一般安装完了会要求重启:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4437ce442b46f5137da8f51eb8ab570c/" rel="bookmark">
			如何在电脑桌面上做精美的日程安排表？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名职场人士，我深知在忙碌的工作中，一个清晰明了的日程安排表对于提升效率的重要性。如果能在电脑桌面上直接查看日程安排，不仅方便我对即将进行的工作任务一目了然，从而更好地掌控工作节奏，而且能大大提高我的工作便捷性。
那么，如何在电脑桌面上制作精美的日程安排表呢？好看好用的日程管理软件有哪些？在寻找答案的过程中，我发现了一款备受上班族推崇的日程管理软件——敬业签。这款日程管理软件不仅外观精美，更以其实用的功能赢得了广泛好评。
使用它，我可以轻松创建多个待办日程分类，将工作、生活、学习等不同领域的日程安排得井井有条。在添加每条日程时，智能系统会根据待办中记录的时间信息，自动设置好相应的提醒时间。此外，它的日历月视图和提醒列表功能，让我可以按照时间顺序统一查看每天的待办日程，工作安排一目了然。
值得一提的是，这款待办软件支持在Windows电脑桌面上一直悬挂显示，这意味着我无需打开软件界面，就能随时查看日程安排。而且，我还可以为它设置透明皮肤，使其与桌面壁纸完美融合，既美观又实用。
更令我惊喜的是，敬业签不仅可以在Windows和Mac电脑端使用，还支持在安卓、苹果、华为手机端使用，且内容实现多端实时云同步。这意味着无论我身处何地，都能随时查看和编辑日程安排，工作生活更加便捷。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c4ff254675b09d03f5ec08e036d5588/" rel="bookmark">
			springboot&#43;django&#43;php班级同学录网站系统 微信小程序32xkb
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。
班级相册 (自动编号、教师工号、创建时间、赞、发布日期、教师姓名、入学年份、班级、相册封面、相册名称、班级名称、点击次数、踩、相册内容)；
配置文件 (自动编号、配置参数名称、配置参数值)；
班级相册评论表 (自动编号、创建时间、回复内容、用户名、关联表id、用户id、评论内容)；
班级论坛 (自动编号、用户id、父节点id、用户名、创建时间、帖子标题、帖子内容、状态)；
教师 (自动编号、创建时间、密码、教师工号、教师姓名、电话、照片、班级、性别)；
收藏表 (自动编号、收藏图片、收藏名称、类型(1:收藏,21:赞,22:踩)、用户id、创建时间、收藏id、推荐类型、表名)；
用户表 (自动编号、用户名、密码、新增时间、角色)；
本系统的设计与实现共包含9个表:分别是班级活动信息表，班级相册信息表，配置文件信息表，班级相册评论表信息表，班级论坛信息表，教师信息表，收藏表信息表，用户表信息表，学生信息表，班级活动 (自动编号、封面图片、创建时间、教师工号、活动标题、结束时间、开始时间、班级、教师姓名、活动内容)；
框架支持:django/springboot/php/Ssm/flask/express均支持
前端开发:vue
语言：python+java+node.js+php均支持
运行软件:idea/eclipse/vscode/pycharm/wamp均支持
数据库 mysql
数据库工具：Navicat等
小程序端运行软件 微信开发者工具/hbuiderx
uni-app框架：使用Vue.js开发跨平台应用的前端框架，编写一套代码，可编译到Android、小程序等平台。
系统具有良好的集成性，提供标准接口，以实现与其他相关系统的功能和数据集成。开放性好，便于系统的升级维护、以及与各种信息系统进行集成。功能定位充分考虑平台服务对象的需求。
一个微信小程序由.js、.json、.wxml、.wxss四种文件构成：
.js：js脚本逻辑文件，跟我们以前写的js一样。
.json：json配置文件，以json格式存储一些配置。
.wxml：wxml模板文件，跟HTML类似。
.wxss：wxss样式文件，对比css，用来调整页面样式。
JSON配置
一个基本的程序包含app.json、project.config.json、logs.json三个json文件，它们分别有不同的用途：
app.json：对当前小程序的全局配置，包括小程序的所有页面路径、界面表现、网络超时时间、底部tab等。（详细内容参考小程序的app.json）
project.config.json：通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当换了另外一台电脑重新安装工具的时候，还要重新配置。
考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，我们在工具上做的任何配置都会写入到这个文件，当重新安装工具或者换电脑工作时，只要载入同一个项目的代码包，开发者工具就自动会帮恢复到当时开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。
page.json：这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。
学生 (自动编号、密码、教师工号、头像、教师姓名、学号、班级、手机、创建时间、姓名、性别)；
目 录
摘 要 I
Pick to II
1绪论 1
1.1项目研究的背景 1
1.2开发意义 1
1.3项目研究现状及内容 1
1.4论文结构 2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c4ff254675b09d03f5ec08e036d5588/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6256aced2e4b443f4c19020799e2bac0/" rel="bookmark">
			微信小程序 PHP-python小区物业报修维修系统k3jfv
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		微信小程序的开发框架是微信所独有的一套框架，分为View视图层和App Service逻辑层两部分。框架提供了一种类似于Web中html语言的wxml语言，作为视图层的标签语言，用于构造页面的布局。另外提供了一种类似Web中css语言的WXSS语言，作为视图层的标签样式语言，用于表述页面的显示。而在逻辑层的框架，则同样使用了JS语言。微信小程序为了使开发者专注在代码的逻辑层面和数据处理上，还专门提供了两种解决方案，一种是事件，一种是数据的传输。这两种方案都位于小程序框架的视图层和逻辑层之间。业主在视图层进行交互之后，传递到逻辑层对数据进行处理，并返回数据到视图层向业主反馈。对于微信小程序视图层的开发设计，小程序官方提供了一系列的组件，这些基本组件可以极大的帮助开发者完成视图层的开发。同时，对于逻辑层的开发，小程序官方提供了一系列API来方便开发者请求一些额外功能。
开发语言：php
后端框架：Thinkphp
前端框架：vue.js
服务器：apache
数据库：mysql
运行环境:phpstudy/wamp/xammp等
主要对首页、个人中心、维修员管理、业主管理、缴费信息管理、车位信息管理、车位购买管理、业主报修管理、报修工单管理、工单评价管理、工单投诉管理、工单完成管理、小区信息管理、楼栋信息管理、房产信息管理、社区活动管理、系统管理的实现。
本系统开发选择 php语言 ，它被研究的目的就是在于能够为网页创建等可以看到的信息。随着移动互联网技术的不断发展和创新，php俨然已成为下一代互联网的Web标准。所以后台设计选择使用Mysql,数据库主要用来的建立和维护信息。对于微信端开发要求应具备功能完善、易于操作等优点，服务端数据库的要求则是能够建立和维护数据信息的统一性和完整性。以thinkphp为开发框架，微信小程序与php语言相结合、B/S架构、Mysql数据库设计并实现了社区物业管理小程序。系统主要包括维修员、业主、缴费信息、车位信息、车位购买、业主报修等功能模块。
目 录
第一章 概述 1
1.1 研究背景 1
1.2开发意义 1
1.3 研究现状 1
1.4 研究内容 2
1.5论文结构 2
第二章 开发技术介绍 3
2.1 系统开发平台 3
2.2 平台开发相关技术 3
2.2.1 php语言 3
2.2.2 Mysql数据库介绍 3
2.2.3 B/S架构 3
2.2.4 thinkphp框架 4
2.2.5 微信小程序框架 4
第三章 系统分析 5
3.1 可行性分析 5
3.1.1 技术可行性 5
3.1.2 操作可行性 5
3.1.3经济可行性 6
3.2性能需求分析 6
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6256aced2e4b443f4c19020799e2bac0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b58af0ae9e2bb8accd8c04ceadf81a08/" rel="bookmark">
			论文阅读——ViTAE
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ViTAE: Vision Transformer Advanced by Exploring Intrinsic Inductive Bias
ViTAE旨在将细胞神经网络中固有的IB引入视觉转换器。如图2所示，ViTAE由两种类型的细胞组成，即RC和NC。RC负责将多尺度上下文和局部信息嵌入到令牌中，NC用于进一步对令牌中的局部性和长程依赖性进行建模。以图像x∈RH×W×C为输入，使用三个RC分别将x逐步下采样4×、2×和2×。因此，RC的输出令牌的大小为[H/16，W/16，D]，其中D是令牌维度（在我们的实验中为64）。然后，RC的输出标记被平坦化为RHW/256×D，与类标记连接，并通过正弦位置编码相加。接下来，令牌被馈送到以下NC中，这些NC保持令牌的长度。最后，使用来自最后一个NC的类标记上的线性分类层来获得预测概率。
ViTAE（Vision Transformers Advanced by Exploring Intrinsic Inductive Bias），通过从卷积中探索内在IB而得到改进。从技术上讲，ViTAE有几个空间金字塔缩减模块，通过使用不同膨胀率的多个卷积，对输入图像进行下采样，并将其嵌入到具有丰富多尺度上下文的令牌中。通过这种方式，它获得了固有的尺度不变性IB，并且能够学习各种尺度下对象的鲁棒特征表示。此外，在每个转换器层中，ViTAE都有一个与多头自注意模块并行的卷积块，其特征被融合并馈送到前馈网络中。因此，它具有固有的局部性IB，能够协同学习局部特征和全局依赖性
ViT在建模局部视觉结构（例如边和角）和处理卷积等各种尺度的对象时缺乏固有的归纳偏差（IB）。或者，ViT必须从大规模数据中隐含地学习这种IB。
与视觉转换器不同，卷积神经网络（CNNs）自然具有尺度不变性和局部性的内在IB，并且仍然是视觉任务中的主要骨干[26，70，62，8，96]。细胞神经网络的成功激励我们在视觉转换器中探索内在的IB。我们首先分析了细胞神经网络的上述两个IB，即局部不变性和尺度不变性。卷积计算相邻像素之间的局部相关性，擅长提取边缘和角点等局部特征。因此，细胞神经网络可以在浅层提供丰富的低级别特征[94]，然后通过大量的顺序卷积将其逐渐聚合为高级别特征[32，68，71]。此外，细胞神经网络具有层次结构，可以提取不同层的多尺度特征[68，38，26]。此外，层内卷积还可以通过改变其内核大小和膨胀率来学习不同尺度的特征[25，70，8，45，96]。因此，可以通过层内或层间特征融合来获得尺度不变的特征表示。然而，细胞神经网络不太适合对长期依赖性进行建模2，这是变压器的关键优势。一个有趣的问题出现了：我们能利用细胞神经网络的良好特性来改进视觉转换器吗？最近，DeiT[76]探索了从细胞神经网络到变压器提取知识的想法，以促进培训并提高性能。然而，它需要现成的CNN模型作为教师，并消耗额外的培训成本。
与DeiT不同的是，本文通过重新设计网络结构，将固有IB明确引入到视觉变换器中。当前的视觉转换器总是获得具有单尺度上下文的标记[19，93，80，86，47，69，77]，并从数据中学习适应不同尺度的对象。例如，T2T-ViT[93]通过以软分割方式精细地生成令牌来改进ViT。具体而言，它使用一系列令牌到令牌转换层来聚合单尺度的相邻上下文信息，并将图像逐步结构化为令牌。受细胞神经网络在处理尺度方差方面的成功启发，我们在转换器中探索了一种类似的设计，即具有不同感受野的层内卷积[70，91]，以将多尺度上下文嵌入到令牌中。这样的设计允许标记在各种尺度上携带对象的有用特征，从而自然地具有固有的尺度不变性IB，并明确地促进变换器从数据中更有效地学习尺度不变特征。另一方面，低级局部特征是生成高级判别特征的基本要素。尽管变换器也可以从数据中学习浅层的这些特征，但它们在设计上并不擅长卷积。最近，[89，43，21]依次堆叠卷积和注意力层，并证明局部性是全局依赖性的合理补偿。然而，这种串行结构在局部建模过程中忽略了全局上下文（反之亦然）。为了避免这种困境，我们遵循“分而治之”的思想，提出并行地对局部依赖和长程依赖进行建模，然后融合特征来兼顾两者。通过这种方式，我们使转换器能够更有效地学习每个块中的局部和远程特征。从技术上讲，我们提出了一种通过探索固有电感偏置（ViTAE）先进的新型视觉转换器，它是两种基本单元的组合，即还原单元（RC）和正常单元（NC）。RC用于对输入图像进行下采样并将其嵌入到具有丰富多尺度上下文的令牌中，而NC旨在对令牌序列中的局部和全局依赖性进行联合建模。此外，这两种类型的细胞共享一个简单的基本结构，即并行注意力模块和卷积层，然后是前馈网络（FFN）。值得注意的是，RC有一个额外的金字塔缩减模块，该模块具有不同膨胀率的atrous卷积，以将多尺度上下文嵌入到令牌中。根据[93]中的设置，我们堆叠三个归约单元以将空间分辨率降低1/16，并堆叠一系列NC以从数据中学习判别特征。ViTAE在数据效率和训练效率（见图1）以及下游任务的分类精度和泛化能力方面优于具有代表性的视觉转换器。
我们的贡献有三方面。首先，我们探索了变换器中的两种固有IB，即尺度不变性和局部性，并证明了这种思想在提高变换器的特征学习能力方面的有效性。其次，我们基于两个新的归约和正常单元设计了一个新的变压器架构，命名为ViTAE，以本质上结合上述两个IB。所提出的ViTAE将多尺度上下文嵌入到令牌中，并有效地学习局部和远程特征。第三，ViTAE在分类精度、数据效率、训练效率和下游任务的泛化方面优于具有代表性的视觉转换器。ViTAE在ImageNet上分别以4.8M和23.6M的参数实现了75.3%和82.0%的第一精度。
ViTAEv2
ViTAEv2: Vision Transformer Advanced by Exploring Inductive Bias for Image Recognition and Beyond
除了分类之外，其他下游任务，包括对象检测、语义分割和姿态估计，也是通用主干网应该适应的非常重要的任务。这些下游任务通常需要从主干网中提取多层次特征，以处理不同尺度的对象。为此，我们将普通的ViTAE模型扩展到多阶段设计，即ViTAE-v2。ViTAE-v2设计的一个自然选择是通过重新组织RC和NC来重新构建模型。如图3所示，ViTAE-v2有四个阶段，其中使用四个相应的RC分别对特征进行4×、2×、2倍和2×的逐步下采样。在每个阶段，多个Ni正常电池在第i个RC之后顺序堆叠。请注意，一系列NC仅在各向同性设计的最粗略阶段使用。正常细胞（即Ni）的数量控制着模型的深度和大小。通过这样做，ViTAE-v2可以从不同阶段提取特征金字塔，其可以由专门为各种下游任务设计的解码器使用。
剩下的一个问题是，transformer中的普通注意力操作具有二次计算复杂性，因此需要大的内存占用和计算成本，尤其是对于具有大分辨率的特征图。与普通ViTAE设计中的快速分辨率降低相比，我们在多阶段设计中采用了慢速分辨率降低策略，例如，第一阶段的特征图的分辨率仅为原始图像大小的1/4，从而导致更多的计算成本，尤其是当下游任务中的图像具有高分辨率时。为了缓解这一问题，我们进一步探讨了RC和NC模块中的另一种归纳偏差，即（Liu et al，2021）中引入的局部窗口注意力。具体来说，窗口注意力将整个特征图拆分为几个不重叠的局部窗口，并在每个窗口内进行多头自注意力，即同一窗口内的每个查询令牌共享相同的键值集。由于所提出的两个单元中的并行卷积分支可以对位置信息进行编码并实现窗口间信息交换，因此可以省略（Liu et al，2021）中的相对位置编码和窗口移位机制等特殊设计。我们实证发现，在早期阶段用局部窗口注意力取代完全注意力可以在计算成本和性能之间实现良好的权衡。因此，在前两个阶段，我们只在RC和NC模块中使用局部窗口注意力。因此，我们的ViTAEv2模型可以为各种视觉任务提供卓越的性能，包括图像分类、对象检测、语义分割和姿态估计，同时保持快速的推理速度和合理的内存占用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c4a54ba8acafadca686ea056c652f6de/" rel="bookmark">
			c/c&#43;&#43;| 常规 |sizeof 、strlen
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结来说 ，sizeof 查看内存给对象分配的空间大小，不仅仅是普通的内置变量，还包括用户自定义变量、结构体、类对象
然后strlen 是查看字符串的实际长度大小，注意它不会计算那个结束符’\0’
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6797872e5c27712097dbb1989b0b895d/" rel="bookmark">
			使用Axios网络请求（三）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.引入 首先，你需要引入 Axios。这里有两种方式将 Axios 引入你的项目。
第一种，你可以使用 npm 进行安装:
npm install axios --save
然后你需要引入它: import axios from 'axios'
第二种，你可以使用 CDN 来引入 axios： &lt;script src="https://unpkg.com/axios/dist/axios.min.js"&gt;&lt;/script&gt;
2.介绍 axios（ajax i/o system）不是一种新技术，本质上也是对原生XHR（XMLHttpReques）的封装，只不过它是基于Promise的，是Promise的实现版本，符合最新的ES规范。
axios有以下特性： 从浏览器创建 XMLHttpRequests
从 node.js 创建 http 请求
支持 Promise API
拦截请求和响应
转换请求和响应数据
取消请求
自动转换JSON数据
客户端支持防御XSRF
axios可以请求的方法： get：获取数据，请求指定的信息，返回实体对象
post：向指定资源提交数据（例如表单提交或文件上传）
put：更新数据，从客户端向服务器传送的数据取代指定的文档的内容
patch：更新数据，是对put方法的补充，用来对已知资源进行局部更新
delete：请求服务器删除指定的数据
head：获取报文首部
请求方法别名 为了方便起见，axios为所有支持的请求方法提供了别名:
axios(config)
axios.request(config)
axios.get(url [,config])
axios.post(url [,data [,config]])
axios.put(url [,data [,config]])
axios.delete(url [,config])
axios.patch(url [,data [,config]])
axios.head(url [,config])
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6797872e5c27712097dbb1989b0b895d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caf024385f22be888cf1a145f5faec3f/" rel="bookmark">
			【论文阅读】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 4. Analysis of Large-Scale Multi-Tenant GPU Clusters for DNN Training Workloads 出处：2019 USENIX-TAC 大规模多租户GPU集群对DNN训练工作负载的分析
主要工作：描述了Microsoft中一个多租户GPU集群两个月的工作负载特征，研究影响多租户集群上DNN训练工作负载的集群利用率的三个问题：
队列调度和局部性约束对队列的影响。局部性对GPU利用率的影响。训练期间的故障问题。 介绍GPU集群Philly：
① 传入作业和排队：用户可指定GPU数量，调度器跟踪集群中所有空闲GPU，调度时首先考虑机架，然后考虑机架中可用GPU最多的服务器。
②作业放置和利用：将小作业打包到更少的服务器中来避免资源碎片。一旦作业被安排运行，它的GPU就不会与其他作业共享。
③训练进度和完成情况：有三种可能情况：passed：已完成；killed：被用户终止；unsuccessful：不成功。
工具：Apache-Yarn， 是一种新的Hadoop资源管理器，是一个通用资源管理系统 和调度平台，可以为上层应用提供统一的资源管理和调度。展望： 局部性优先：缺乏局部性会影响利用率和作业运行时间。等待有限的时间来查看是否可以实现局部性，如果不能，则使用局部性宽松的可用资源来调度作业( 从而减少用户的排队时间)。减轻干扰：将不同小作业放在专用服务器上，而不是打包到单个服务器，从而减少这些作业之间的干扰，但会增加碎片化。所以要支持作业迁移以对集群进行碎片整理。改进故障处理：大量作业失败是由于代码或配置中的用户错误造成，语法检查可以放置许多错误，并且可以通过运行训练的第一次迭代来捕获一些运行时错误。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fbbf8df4162ee4831dd2962ecfaf18c/" rel="bookmark">
			PYTHON 自动化办公：更改图片后缀
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 在之前的文章中，介绍了图片的压缩技术，这里讲解如何利用python批量将图片改为指定后缀的格式。当然，也可以为深度学习批量更改文件后缀，例如在分割中，可能需要img和mask的图片名称完全一致等等
PYTHON 自动化办公：压缩图片（PIL）_image save quality图像压缩-CSDN博客https://blog.csdn.net/qq_44886601/article/details/136413689
文中使用的库函数是python的PIL库函数（pillow），安装如下
pip install pillow Tips ：
image_format = ['.jpg','.jpeg','.png','.gif','.bmp','.tiff','.ai','.cdr','.eps'] # 常见的图片后缀名 代码中会有一个常见图片后缀的列表，为了后面的使用，如果使用的图片后缀不在里面，可以自行添加
2、更改单张图片的后缀 代码如下：
因为有的图片名称很长，甚至中途还会将后缀出现，例如 sda1233pngddwsa.png
但无论怎样风骚的文件名，不可能出现带 . + 后缀 的字符串，因为会直接报错。所以这里image_format 列表文件名都加了 . 方便遍历
from PIL import Image def main(img_path,img_fm): image_format = ['.jpg','.jpeg','.png','.gif','.bmp','.tiff','.ai','.cdr','.eps'] # 常见的图片后缀名 for i in image_format: if i in img_path: ret_path = img_path.split(i)[0] # 文件名 ret_path = ret_path + '.' + img_fm # 返回的图片名 img = Image.open(img_path).convert('RGB') img.save(ret_path) if __name__ == '__main__': root = 'test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fbbf8df4162ee4831dd2962ecfaf18c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05752b0e9710e4d2ed6351d86a7f0ab9/" rel="bookmark">
			如何把网站的http改成https？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		想把网站从不安全的HTTP换成安全的HTTPS？来瞧瞧下面几步操作： 1.挑个SSL证书：
- 根据你的网站情况（比如就一个域名、多个域名还是啥域名都得管），找一款适合的SSL证书，有免费的DV（验证域名所有权）证书，也有付费的OV（验证公司信息）和EV（高级验证，地址栏有公司名）证书。
- 去信得过的证书机构像是JoySSL买或者申请免费的证书。
2.制作CSR（证书签名请求）：
- CSR就是一个包含你网站信息和公钥的小文件，是用来跟证书颁发机构要证书的“敲门砖”。
- 在你的服务器上用相关工具或者控制面板创建这个CSR文件。
3.装上SSL证书：
- CA核对完信息并发证书给你之后，你就拿到SSL证书啦。
- 把得到的SSL证书文件（包括主要证书和可能有的中间证书）上传到你的服务器上去。
- 不同服务器软件（像Apache、Nginx、IIS等）有不同的安装方式，一般是把证书放对位置，设置好私钥文件，然后更新服务器配置文件让它认出这些证书。
4.让服务器支持HTTPS：
- 调整服务器配置文件，使得所有HTTP请求都自动转到HTTPS去。
- HTTPS一般用的是443端口，记得在服务器配置里开启这个端口监听。
- 如果可以的话，开启HSTS（严格传输安全策略），让浏览器记住你的网站只能用HTTPS访问，这样能防止被偷偷改回HTTP。
5.试试效果，检查一下：
- 测试新配置好的HTTPS网站，看看是否能正常打开，同时留意页面上的图片、样式表、JavaScript文件是不是也都走HTTPS了，别有“混合内容”的问题。
- 上网找个在线工具确认下SSL证书安得好不好，有没有什么安全隐患。
6.内外链接全换HTTPS：
- 网站内部所有的链接都检查一遍，改掉那些还指向HTTP的，全换成HTTPS链接。
- 如果别的地方也有提到你网站URL的地方（比如API接口、和其他平台的合作），也一并更新成HTTPS链接。
永久免费SSL证书_永久免费https证书_永久免费ssl证书申请-JoySSL真正完全且永久免费！不用您花一分钱，SSL证书免费使用90天，并且还支持连续签发。JoySSL携手全球权威可信顶级根，自研新一代SSL证书，全系列支持90天免费使用。在这里，你可以申请到免费单域名证书、免费多域名证书以及免费通配符证书。部署于国内的验签服务器3-5分钟极速签发，而且只需要简单的域名解析验证，即可让您的网站开启https安全协议。https://www.joyssl.com/certificate/select/free.html?nid=7
照着这些建议一步步来，你的网站就能妥妥地从HTTP升级到HTTPS，这样一来，不仅数据传输加密了，用户的隐私和网站的安全性也能大大提升。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5cb9f24105881d892bf4c27fca754a1f/" rel="bookmark">
			【嵌入式——QT】QPainter基本绘图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【嵌入式——QT】QPainter基本绘图 QPainter与QPaintDevicepaintEvent事件和绘图区QPainter主要属性QPen主要功能QBrush主要功能QPainter绘制基本图形方法图示代码示例 QPainter与QPaintDevice QPainter是用来进行绘图操作的类，QPaintDevice是一个可以使用QPainter进行绘图的抽象的二维界面，QPaintEngine给QPainter提供在不同设备上绘图的接口，QPaintEngine类由QPainter和QPaintDevice内部使用，应用程序一般无需和QPaintEngine打交道，除非要创建自己的设备类型。
paintEvent事件和绘图区 QWidget类及其子类是最常用的绘图设备，从QWidget类继承的类都有paintEvent事件，要在设备上绘图，只需重定义此事件并编写相应代码。
QPainter主要属性 pen属性：是一个QPen对象，用于控制线条的颜色、宽度、线型等；brush属性：是一个QBrush对象，用于设置一个区域的填充特性，可以设置填充颜色、填充方式、渐变特性；font属性：是一个QFont对象，用于绘制文字时，设置文字的字体样式、大小等属性； QPen主要功能 setColor(const QColor &amp;color)：设置画笔颜色，即线条颜色；setWidth(int width)：设置线条宽度；setStyle(Qt::PenStyle style)：设置线条样式；setCapStyle(Qt::PenCapStyle style)：设置线条端点样式；setJoinStyle(Qt::PenJoinStyle style)：设置连接方式； QBrush主要功能 setColor(const QColor &amp;color)：设置画刷颜色；setStyle(Qt::BrushStyle style)：设置画刷样式；setTexture(const QPixmap &amp;pixmap)：设置一个QPixmap类型的图片作为画刷的图片；setTextureImage(const QImage &amp;image)：设置一个QImage类型的图片作为画刷的图片； QPainter绘制基本图形方法 drawArc()：画弧线；drawChord()：画一段弦；drawConvexPolygon()：画凸多边形；drawEllipse：画椭圆；drawImage()：绘制图片；drawLine(const QLineF &amp;line)：画直线；drawLines(const QLineF *lines, int lineCount)：画一批直线；drawPath(const QPainterPath &amp;path)：绘制由QPainterPath对象定义的路线；drawPie(const QRectF &amp;rectangle, int startAngle, int spanAngle)：绘制扇形；drawPixmap(int x, int y, const QPixmap &amp;pixmap)：绘制QPixmap类型图片；drawPoint(int x, int y)：绘制一个点；drawPoints：绘制一批点；drawPolygon：绘制多边形，最后一个点和第一个点闭合；drawPolyline：绘制多点连接的线，最后一个点不会和第一个点连接；drawRect(int x, int y, int width, int height)：画矩形；drawRoundedRect：绘制圆角矩形；drawText(int x, int y, const QString &amp;text)：绘制文本，只能绘制单行文字；fillRect(int x, int y, int width, int height, const QBrush &amp;brush)：填充一个矩形，无边框线；eraseRect：擦除某个矩形区域；fillPath：填充某个QPainterPath定义的绘图路径 但是轮廓线不显示；fillRect：填充一个矩形，无边框线； 图示 随便截了两张图片，代码中均有实现，不一一列举图片了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5cb9f24105881d892bf4c27fca754a1f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a020366b48e124716473e7704909e25f/" rel="bookmark">
			电商按关键字搜索temu商品 API
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		公共参数
名称类型必须描述keyString是免费申请调用key密钥（必须以GET方式拼接在URL中）secretString是调用密钥api_nameString是API接口名称（包括在请求地址中）[item_search,item_get,item_search_shop等]cacheString否[yes,no]默认yes，将调用缓存的数据，速度比较快result_typeString否[json,jsonu,xml,serialize,var_export]返回数据格式，默认为json，jsonu输出的内容中文可以直接阅读langString否[cn,en,ru]翻译语言，默认cn简体中文versionString否API版本 请求参数
请求参数：q=shoe&amp;start_price=&amp;end_price=&amp;page=&amp;list_id=&amp;cat=&amp;discount_only=&amp;sort=&amp;page_size=&amp;seller_info=&amp;nick=&amp;ppath=
参数说明：q:搜索关键字
cat:分类ID
start_price:开始价格
end_price:结束价格
list_id:列表id
sort:排序[bid,_bid,bid2,_bid2,_sale,_credit]
(bid:总价,bid2:商品价格,sale:销量,credit信用,加_前缀为从大到小排序)
page:
返回数据：
{ "items": { "page": 1, "page_size": 120, "has_more": true, "data_from": "app", "item": [ { "title": "2022 Minimalist Mens Fashion Ultra Thin Watches Simple Men Business Stainless Steel Mesh Belt Quartz Watch", "pic_url": "https:\/\/img.kwcdn.com\/product\/Fancyalgo\/VirtualModelMatting\/c7ef2fecd0a44b17857a152b674969fb.jpg", "price": "2.09", "orginal_price": "2.09", "sales": "90K+", "num_iid": 601099512645657, "detail_url": "https:\/\/www.temu.com\/2022-minimalist-mens-fashion-ultra-thin-watches-simple-men-business-stainless-steel-mesh-belt-quartz-watch-g-601099512645657.html?&amp;top_gallery_url=https%3A%2F%2Fimg.kwcdn.com%2Fproduct%2FFancyalgo%2FVirtualModelMatting%2Fc7ef2fecd0a44b17857a152b674969fb.jpg&amp;spec_gallery_id=7257449&amp;refer_page_sn=10009&amp;refer_source=0&amp;freesia_scene=2&amp;_oak_freesia_scene=2&amp;_oak_rec_ext_1=MjA5", "list_id": "896ae23b45bdb231845f7d33fb5eaadc_1708653658747" }, { "title": "POEDAGAR Waterproof Luminous Calendar Mens Quartz Watch Stainless Steel Wrist Watch, Ideal choice for Gifts"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a020366b48e124716473e7704909e25f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/473cc52f95c4b6ad1e82ee87c58667f0/" rel="bookmark">
			Doccano的标注结果转换为BIO格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 实现了Doccano导出格式到BIO命名实体识别格式的转换
项目完整可运行的代码：https://github.com/JieShenAI/csdn/tree/main/KnowledgeGraph/data_convert/doccano2BIO
演示 Doccano的导出格式:
{"id":161,"text":"“十四五”时期是我省全面建成小康社会之后，乘势而上开启全面建设社会主义现代化国家新征程的第一个五年，也是谱写新时代湖北高质量发展新篇章的关键五年","entities":[],"relations":[],"Comments":[]} {"id":162,"text":"进入新发展阶段，发展不平衡不充分仍然是我省最大的实际，抓发展仍然是第一要务，必须坚持以xxx新时代中国特色社会主义思想为指导，深入贯彻落实xxxxxx考察湖北、参加湖北代表团审议时的重要讲话精神，胸怀“两个大局”，贯彻新发展理念，服务构建新发展格局，加快“建成支点、走在前列、谱写新篇”进程，以疫后重振和高质量发展的实际成效体现湖北担当、展现湖北作为","entities":[{"id":1106,"label":"基本遵循","start_offset":43,"end_offset":59},{"id":1107,"label":"基本遵循","start_offset":100,"end_offset":106},{"id":1108,"label":"主要任务","start_offset":128,"end_offset":142},{"id":1109,"label":"主要任务","start_offset":147,"end_offset":151},{"id":1110,"label":"主要任务","start_offset":152,"end_offset":157}],"relations":[],"Comments":[]} 转换后的BIO格式
(由于换行符很多，下述只展示一部分转换后的格式)
以 O x B-基本遵循 x I-基本遵循 x I-基本遵循 新 I-基本遵循 时 I-基本遵循 代 I-基本遵循 中 I-基本遵循 国 I-基本遵循 特 I-基本遵循 色 I-基本遵循 社 I-基本遵循 会 I-基本遵循 主 I-基本遵循 义 I-基本遵循 思 I-基本遵循 想 I-基本遵循 为 O 代码实现 import json def load_jsonl(file_path): with open(file_path, 'r', encoding='utf-8') as file: for line in file: yield json.loads(line) def doccano2BIO(file_name, output_file='out.txt'): def _get_pair(): data = load_jsonl(file_name) for line in data: text = line['text'] labels = ['O'] * len(text) for ent in line['entities']: label, start_offset, end_offset = ent['label'], ent['start_offset'], ent['end_offset'] labels[start_offset] = 'B-' + label labels[start_offset+1: end_offset] = ['I-' + label] * (end_offset - start_offset - 1) yield text, labels with open(output_file, 'w+') as f: content = [] for text, labels in _get_pair(): s = [] item = zip(list(text), labels) for line in item: s.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/473cc52f95c4b6ad1e82ee87c58667f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/706adf5dc49ecef8e6e968d93161bc6c/" rel="bookmark">
			程序人生——Java中类、对象及方法的建议（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 引出类、对象及方法建议41：让多重继承成为现实建议42：让工具类不可实例化建议43：避免对象的浅拷贝 建议44：推荐使用序列化实现对象的拷贝建议45：覆写equals方法时不要识别不出自己建议46：equals应该考虑null值情景 建议47：在equals中使用getClass进行类型判断建议48：覆写equals方法必须覆写hashCode方法建议49：推荐覆写toString方法 建议50：使用package-info类为包服务建议51：不要主动进行垃圾回收 深入认识JVMJVM内存分配，类加载创建对象的4种方法总结垃圾回收GCJVM调优，Arthas使用 认识多线程创建多线程方法+了解线程池多线程下-1非原子性问题即解决再论线程，创建、生命周期 总结 引出 程序人生——Java中类、对象及方法的建议（2）
类、对象及方法 建议41：让多重继承成为现实 Java中一个类可以多种实现，但不能多重继承。使用成员内部类实现多重继承。内部类一个重要特性：内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，多重继承才会成为可能 建议42：让工具类不可实例化 工具类的方法和属性都是静态的，不需要实例即可访问。**实现方式：**将构造函数设置为private，并且在构造函数中抛出Error错误异常 建议43：避免对象的浅拷贝 浅拷贝存在对象属性拷贝不彻底的问题。对于只包含基本数据类型的类可以使用浅拷贝；而包含有对象变量的类需要使用序列化与反序列化机制实现深拷贝 建议44：推荐使用序列化实现对象的拷贝 通过序列化方式来处理，在内存中通过字节流的拷贝来实现深拷贝。使用此方法进行对象拷贝时需注意两点：1、对象的内部属性都是可序列化的；2、注意方法和属性的特殊修饰符，比如final、static、transient变量的序列化问题都会影响拷贝效果。一个简单办法，使用Apache下的commons工具包中的SerializationUtils类，直接使用更加简洁方便 建议45：覆写equals方法时不要识别不出自己 需要满足p.equals§返回为真，自反性 建议46：equals应该考虑null值情景 覆写equals方法时需要判一下null，否则可能产生NullPointerException异常 建议47：在equals中使用getClass进行类型判断 使用getClass方法来代替instanceof进行类型判断 建议48：覆写equals方法必须覆写hashCode方法 需要两个相同对象的hashCode方法返回值相同，所以需要覆写hashCode方法，如果不覆写，两个不同对象的hashCode肯定不一样，简单实现hashCode方法，调用org.apache.commons.lang.builder包下的Hash码生成工具HashCodeBuilder 建议49：推荐覆写toString方法 原始toString方法显示不人性化 建议50：使用package-info类为包服务 package-info类是专门为本包服务的，是一个特殊性主要体现在3个方面：1、它不能随便被创建；2、它服务的对象很特殊；3、package-info类不能有实现代码；package-info类的作用：1、声明友好类和包内访问常量；2、为在包上标注注解提供便利；3、提供包的整体注释说明 建议51：不要主动进行垃圾回收 主动进行垃圾回收是一个非常危险的动作，因为System.gc要停止所有的响应（Stop 天河world），才能检查内存中是否有可回收的对象，所有的请求都会暂停 深入认识JVM JVM内存分配，类加载 Java进阶（1）——JVM的内存分配 &amp; 反射Class类的类对象 &amp; 创建对象的几种方式 &amp; 类加载（何时进入内存JVM）&amp; 注解 &amp; 反射+注解的案例
创建对象的4种方法总结 Java进阶（4）——结合类加载JVM的过程理解创建对象的几种方式：new，反射Class，克隆clone（拷贝），序列化反序列化
垃圾回收GC Java进阶（垃圾回收GC）——理论篇：JVM内存模型 &amp; 垃圾回收定位清除算法 &amp; JVM中的垃圾回收器
简介：本篇博客介绍JVM的内存模型，对比了1.7和1.8的内存模型的变化；介绍了垃圾回收的语言发展；阐述了定位垃圾的方法，引用计数法和可达性分析发以及垃圾清除算法；然后介绍了Java中的垃圾回收器，由串行、到并行再到并发，最后到G1的演变；最后给出了垃圾回收器的对比和使用指引。
JVM调优，Arthas使用 Java进阶（JVM调优）——阿里云的Arthas的使用 &amp; 安装和使用 &amp; 死锁查找案例，重新加载案例，慢调用分析Java进阶（JVM调优）——JVM调优参数 &amp; JDK自带工具使用 &amp; 内存溢出和死锁问题案例 &amp; GC垃圾回收 认识多线程 创建多线程方法+了解线程池 Java进阶（5）——创建多线程的方法extends Thread和implements Runnable的对比 &amp; 线程池及常用的线程池
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/706adf5dc49ecef8e6e968d93161bc6c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a645cbfd760ae68afe23b71bb1da174f/" rel="bookmark">
			Copilot如何将word文稿一键转为PPT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景
很多小伙伴平时经常会遇到的一个场景是，如何将word文稿图文转为PPT。
这个过程是既复杂而又无趣的。
现在，有了copilot，你可以一键搞定！
使用copilot Pro来实现
比如我们想要做一个关于copilot studio的PPT展示，不论是在个人家庭版的copilot Pro里还是商业版的copilot for Microsoft365中，都是可以直接通过给出prompt（提示词）的方式让其生成：
“创建演示文稿 关于copilot studio”
一共生成了6页PPT，效果其实也差强人意。
这是因为我们并没有提供给copilot足够多的提示条件，他只能自己从互联网上进行相关的搜索，并给出一个简单的说明。
如果我们给出更加明确的提示词要求，让其针对每一个部分都充分展开说明，那么它会给出更加丰富的内容。
prompt提示词：
“创建演示文稿 关于copilot studio，从以下几个方面展开说明：什么是 Copilot Studio，外挂数据，定义流程，简单部署，分析迭代，通过 Copilot Studio 创建插件，通过 Copilot Studio 扩展微软所有的 Copilot，每个页面都展示3条以上说明，并对整个文档进行总结”
它会给出更加详细的说明，并且在每一页面上都添加了额外的备注供您参考：
使用copilot for Microsoft365一键将word稿件转为PPT
如果您已经有相关的文字稿和对应的配图，理论上您肯定对“将该稿件直接生成PPT”抱有幻想，现在，就是圆梦的时刻！
针对“copilot studio介绍”这一主题，我们从知乎上找几篇文章放在word文档中：
新建一个演示文稿，点击“copilot”按钮，选择“通过文件创建文稿”，下方手动选择刚才存放在onedrive中的文件：
选中后，点击生成：
copilot会首先根据文章内容生成大纲：
大约30秒后，copilot为我们生成了20页PPT，并且准确地从文章中提取了配图：
这个效果略加调整，基本上就可以当做正式的演讲稿了！
总结
以上介绍了如果通过输入prompt提示词让copilot生成PPT和如何通过Word文稿生成PPT，对比了两者的使用方法和各自的优势。
从Word文稿创建PPT这个功能只有尊贵的商业版office+copilot订阅用户才可以使用，个人家庭版的copilot Pro无法享用。
官网定价：
office商业标准版（90/月）+copilot（30刀/月）=310/月
学谦订阅价格：180/月
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47d9e6ec3bb0cd2b3932c93f630a930b/" rel="bookmark">
			Linux系统---Haproxy高性能负载均衡软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、Haproxy介绍
1.Haproxy定义
2.Haproxy主要特性
3.Haproxy调度算法原理
3.1RR（Round Robin）
3.2LC（Least Connections）
3.3SH（Source Hashing）
二、安装Haproxy
1.yum安装
2.第三方rpm包安装
3.编译安装
3.1解决Lua环境
3.2编译安装Haproxy
三、配置文件详解
1.状态页
2.日志管理
2.1定义日志到其他主机站点
3.指定进程线程个数
4.cpu亲缘性
5.多进程和线程
四、Proxies配置
1.Proxies配置——defaults
2.Proxies配置——listen
2.1举例——默认无后端健康性检测
2.2加入健康性检测——Check
3.Proxies配置——frontend
3.1配置参数
3.2举例
4.Proxies配置——backend
4.1server配置 五、实际操作
1.搭建实验环境
2.配置haproxy
3.前后端配置
一、Haproxy介绍 四层代理
LVS：Linux Virtual ServerNginxHAProxy：High Availability Proxy 七层代理
HAProxyNginx 硬件
F5 https://f5.com/zhNetscaler https://www.citrix.com.cn/products/citrix-adc/Array https://www.arraynetworks.com.cn/深信服 http://www.sangfor.com.cn/北京灵州 http://www.lingzhou.com.cn/cpzx/llfzjh/ 1.Haproxy定义 HAProxy是法国开发者威利塔罗(Willy Tarreau)在2000年使用C语言开发的一个开源软件，是一款具备高并发(一万以上)、高性能的TCP和HTTP负载均衡器，支持基于cookie的持久性，自动故障切换，支持正则表达式及web状态统计，目前最新TLS版本为2.2。
HAProxy是可提供高可用性、负载均衡以及基于TcP和HTTP应用的代理，是免费、快速并且可靠的一种解决方案。HProxy非常适用于并发大(并发达1w以上) web站点，这些站点通常又需要会话保持或七层处理。HAProxy的运行模式使得它可以很简单安全的整合至当前的架构中，同时可以保护web服务器不被暴露到网络上。
支持功能
TCP 和 HTTP反向代理SSL/TSL服务器可以针对HTTP请求添加cookie，进行路由后端服务器可平衡负载至后端服务器，并支持持久连接支持所有主服务器故障切换至备用服务器 keepalive支持专用端口实现监控服务支持停止接受新连接请求，而不影响现有连接可以在双向添加，修改或删除HTTP报文首部字段响应报文压缩支持基于pattern实现连接请求的访问控制通过特定的URI（url）为授权用户提供详细的状态信息 2.Haproxy主要特性 可靠性和稳定性非常好，可以与硬件级的F5负载均衡设备相媲美;最高可以同时维护40000-50000个并发连接，单位时间内处理的最大请求数为20000个，最大处理能力可达10Git/s;支持多达8种负载均衡算法,同时也支持会话保持;支持虚拟机主机功能，从而实现web负载均衡更加灵活;支持连接拒绝、全透明代理等独特的功能;拥有强大的ACL支持,用于访问控制; sendfile其独特的弹性二x树数据结构，使数据结构的复杂性上升到了0(1)，即数据的查寻速度不会随着数据条日的增加而速度有所下降;·支持客户端的keepalive功能，减少客户端与haproxy的多次三次握手导致资源浪费，让多个请求在一个tcp连接中完成;支持TCP加速,零复制功能,类似于mmap机制;支持响应池(response buffering) ;支持RDP协议;基于源的粘性，类似nginx的ip hash功能，把来自同一客户端的请求在一定时间内始终调度到上游的同一服务器;·更好统计数据接口，其web接口显示后端集群中各个服务器的接收、发送、拒绝、错误等数据的统计信息;详细的健康状态检测，web接口中有关于对上游服务器的健康检测状态，并提供了一定的管理功能;基于流量的健康评估机制;基于http认证;基于命令行的管理接口;日志分析器,可对日志进行分析 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47d9e6ec3bb0cd2b3932c93f630a930b/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/29/">«</a>
	<span class="pagination__item pagination__item--current">30/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/31/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>