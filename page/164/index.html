<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1ab3fce2027720f550b155f3fda26db6/" rel="bookmark">
			idea将一个分支的某些提交记录提交到另一个分支上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Idea将某个分支的某些提交记录提交到另一分支
（1） 切换到需要合并的目标分支，如：本地为dev分支，需要切换 到目标分支master，
（2） 找到dev分支和需要合并的dev分支记录
（3）选中需要合并的dev分支提交记录记录后，点击 “Cherry-Pick”图标，
（4）在目标分支master中(当前就是目标分支)，点击push提交代码，完成合并
ps：合并要确保分支代码最新，可以更新代码
补充：如需合并多次提交记录，可以选择需要的几个提交记录，
逐一点击cherry-pick，最后一起提交push代码。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e199d4d41a804c928c4e8419513ddcf1/" rel="bookmark">
			vue安装element-ui插件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.在vue项目根文件下cmd后，执行命令： npm i element-ui -S
2.在main.js中引入以下：
// 引入element-ul import ElementUI from 'element-ui' import 'element-ui/lib/theme-chalk/index.css' Vue.use(ElementUI) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06f5206ea1a48e6cb4659b4a8ceede89/" rel="bookmark">
			Vue.2.0安装环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：创建一个文件夹
第二步：打开你创建的文件夹，在上面输入cmd
第三步：注意！
要先切换淘宝镜像：npm install -g cnpm --registry=https://registry.npm.taobao.org
写完按回撤键！以下也是每写一步回撤，等待！选项是按空格键选完之后回撤
第四步：npm install -g @vue/cli
第五步：vue create myobj
后面的myobj你可以改成你要写的项目名称
以下按我选的来，选完一步回撤
输入n回撤
最后把这两个都配置都配置一下，项目就配置完成了
然后复制一个在网址打开就ok了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/99d8fef2761b227587bd4f5307792967/" rel="bookmark">
			数据结构实验：设计算法并讨论其时间复杂度（Python实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验目的 通过设计算法直观感知其时间复杂度，从而进一步理解算法的时间复杂度的概念，并能够计算出对应的时间复杂度。
实验内容 编写程序，在其中设计多个操作（包括无循环、单重循环和双重循环），体会算法的时间复杂度这一概念。通过以下步骤完成本实验。
1．实现无循环的方法
（1）简单地编写一个输出自己姓名和学号的语句。
（2）计算该方法的时间复杂度。
2．实现单重循环的方法
（1）利用单重循环求解正整数 1～n 的和。
（2）计算该方法的时间复杂度。
3．实现双重循环的方法
（1）利用双重循环输出九九乘法表。
（2）计算该方法的时间复杂度。
实验代码 class LoopCom(object): ################################ #实现无循环的方法 ################################ def NoLoop(self): name="张三" id="20230113" print("\n1.实现无循环的方法") print("（1）简单地编写一个输出自己姓名和学号的语句。") print(" 姓名为{0:}，学号为{1:}".format(name,id)) print("（2）该算法的时间复杂度为O(1)。") ################################ #实现单重循环的方法 ################################ def OneLoop(self): sum=0 n=10 for i in range(1,n+1): sum=sum+i print("\n2.实现单重循环的方法") print("（1）利用单循环求解正整数1~10的和。") print(" 1-10的和为{0:}".format(sum)) print("（2）该算法的时间复杂度为O(n)。") ################################ #实现双重循环的方法 ################################ def DoubleLoop(self): print("\n3.实现双重循环的方法") print("（1）利用双重循环输出九九乘法表。") for i in range(1,10): for j in range(1,i+1): print("{0:}*{1:}={2:} ".format(i,j,i*j),end="") print() print("（2）该算法的时间复杂度为O(n^2)。") ################################ #输出函数 ################################ def PrintOut(self): self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/99d8fef2761b227587bd4f5307792967/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/392a560916862476d65594627aa53e19/" rel="bookmark">
			搭建域控和添加本域辅域控，加入域（下）（精准扶小白）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 欢迎来到下篇，这里我们趁热打铁，搭建辅助域控 安装环境：Windows2012 首先，我们登入我们昨天已经加入域的用户(即和之前一样，用（已加入的域名）+（用户名）)登入主机（和主域控所在的主机不一样，我这里是登入已加入域的主机）
然后我们继续选择添加角色与功能
同样，我们在这里选择“Active Directory 域服务”，然后点击添加功能
一直下一步，来到这里点击安装
熟悉的步骤，点击🚩，点击提升为域控
然后，又来到这熟悉的问题，这三个要选哪个呢？大家想想，好，如果看过我的这个系列的第一篇博客——搭建域控和添加本域辅域控，加入域（上）的人，我相信应该想得出来，这里我们是不是已经加入了一个域，那么我要这域控成为辅域控，我们是不是要这个域控和之前的主域控处在同一个域中呀！所以这里我们选添加到现有域，而不是添加啥新林。然后我们可以注意到，下面有一个
提供此操作所需的凭证，直接默认管理员就可以。然后下一步。
一直下一步来到安装，直接点击安装，中间有个啥还原密钥我们不用管，随便填就好
安装完后会重启，重启完后，老样子，我们用管理员登入辅助域控（和之前一样，这里就不多说了）
然后，我们在主域控上的正向解析域中新建一个主机，看辅助域控上是否有同样的记录，这个新建的IP要和域控同网段
我们发现只有主域控上有记录，辅助域控没有，那么这是为什么呢？
那是因为我们没有开启数据主辅之间的数据传递，我们在主辅域控上都要开启允许区域内数据传递，我们在这里只展示主域控上的数据传递开启步骤，辅域控就如法炮制就好，右键起始授权机构（SOA），点击属性。
选择区域传递，然后开启允许传递，然后确定，就可以了（辅助域控也是一样）
然后，我们再来看看辅助域控的正向解析域，有没有我们在主域控上创建的主机的数据，对比上面主域控的正向解析域的数据，我们发现新建的主机数据（shijian）被同步过来了。这就表明我们搭建辅助域控成功了。
就此，我们搭建辅助域控的实验就完成了。
遗留的问题：注意，我这里的这台主机在上一个篇博客中已经加入了域，所以就不用改主机的IP，如果你还没有加入你可以参考一下这篇文章http://t.csdn.cn/A37HT，这里面讲了在没有加入域之前，该如何去搭建域控。但我建议是按照我的流程来较为稳妥，因为他的环境和我的不一样，他的好像是Windows2008.
总结 到这里，搭建域控和添加本域辅域控，加入域（精准扶小白）系列就算完结了，花了三天去写，人都熬瘦了。如果这一系列博客对你有帮助的话，还请支持一下博主，点一个免费的赞，万分感谢。
我们下篇博客再见？bye！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e772977e1e6d963776bdda8ee2ade72/" rel="bookmark">
			Linux——管理SElinux安全性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、selinux概念：
1、什么是selinux？为什么要使用selinux？包括哪些模式？
（1）Selinux是用于确定进程可以访问那些文件、目录和端口的一组安全规则，主要目标是防止已遭泄露的系统服务访问用户数据。
（2）Selinux主要用于保护系统资源，使用特定方式特定用户操作和访问文件，防止系统资料被其他方式打开和修改。
（3）包括强制（enforcing）、许可（permissive）、禁用（disabled）三种模式。
2、什么是selinux上下文？selinux有哪些标签？
（1）selinux上下文：每个文件、进程、目录和端口都具有的专门的安全标签，标签代表了与安全有关的信息。selinux策略使用它来确定某个进程能否访问文件、目录或端口。
（2）selinux标签：用户、角色、类型（通常以_t结尾）和敏感度。
3、类型上下文（通常以t结尾）：
httpd_t # web服务器 http_port_t # web服务器端口： httpd_sys_content_t # /var/www/html中的目录和文件 tmp_t # /var/tmp和/tmp中的目录和文件 httpd_t # Apache /var/www/html # Apache用户和组队该文档根目录具有读取权限 mysqld_t # MariaDB mysqld_db_t # /data/mysql中的文件 注意：许多处理文件的命令都使用 -Z 选项和ps、ls、cp、mkdir命令组合，可以显示或设置selinux上下文。
4、更改当前的selinux模式：
getenforce # 确定当前的selinux值 # enforcing=1表示强制模式，enforcing=0表示许可模式，selinux=0表示禁用selinux setenforce # 将selinux设置为其他模式 5、设置默认selinux模式：
编辑/etc/selinux/config文件来设置默认selinux
二、控制selinux文件上下文：
新文件通常会从父目录继承selinux上下文，确保他们有适当的上下文。
1、移动或复制设置了selinux上下文的文件：
移动（mv） # selinux上下文为创建它时所在目录的selinux上下文，保留了原始标签，不是目标目录的 复制（cp） # selinux上下文为继承父目录的标签 ls -Z #显示文件的selinux上下文 ls -Zd #显示目录的selinux上下文 注意：/var/www/html/index.html与父目录/var/www/html/具有相同的标签。
2、更改文件的selinux上下文：
semanage fcontext # 更改文件selinux上下文，包括文件的默认标签 restorecon # 将上下文应用于文件（添加-v选择显示运行的详细信息，可结合-R选项递归使用） # -v 选项显示运行的详细过程 chcon #更改selinux上下文，设置存储在文件系统中的文件安全上下文，对于测试和实验很有用，但是不会将上下文更改保存到selinux上下文数据库中 3、semanage fcontext规则：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e772977e1e6d963776bdda8ee2ade72/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f542015a0522e7ea5828b6714af54c/" rel="bookmark">
			排序 冒泡排序_51&#43;选择排序_52
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		冒泡排序
【因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样】
一共n个数，比较n-1趟，每一趟都少比较一个数，因为最大的已经在上一趟选出来了，每一趟比较就是前后相邻的数进行比较，按照顺序交换前后数据
算法时间复杂度
最坏情况：O(n^2)
最好情况：O(n)
平均情况：O(n^2)
空间复杂度：S(n)=O(1)
稳定性：稳定排序
题目描述
对输入的n个数进行排序并输出。
输入格式
输入的第一行包括一个整数n(1&lt;=n&lt;=100)。 接下来的一行包括n个整数。
输出格式
可能有多组测试数据，对于每组数据，将排序后的n个整数输出，每个数后面都有一个空格。
每组测试数据的结果占一行。
样例输入
5
5 4 3 1 2
样例输出
1 2 3 4 5
#include&lt;bits/stdc++.h&gt; using namespace std; //冒泡排序 int a[100]; int main(){ int n; while(cin&gt;&gt;n){ int temp=n-1; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } //一共是n-1趟比较 //冒泡排序把最大的挪到最后 for(int i=0;i&lt;temp;i++){ for(int j=0;j&lt;temp-i;j++){ if(a[j]&gt;a[j+1]){ swap(a[j],a[j+1]); } } } for(int i=0;i&lt;n;i++){ cout&lt;&lt;a[i]&lt;&lt;" "; } cout&lt;&lt;endl;	} return 0; } 选择排序
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7f542015a0522e7ea5828b6714af54c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/821da42c2a6ee65359586bd199885991/" rel="bookmark">
			设计hive数据仓库进行数据分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、设计hive数据仓库
1.创建数据仓库
2.创建事实表
3.加载数据到事实表
4.查询数据
5.创建明细表ods_jobdata_detail 用户细化薪资字段的数据
6.加教数据到明细表
7.对薪资进行扁平化处理,.将处理结果存储到临时中间表t_ods_tmp_salary
8.对临时中间表t_ods_tmp_salary中的每一条数据进行泛化处理，将处理结果存储到中间表t_ods_tmp_salary_dist中
9.对福利标签字段内容进行扁平化处理，将处理的结果储存到临时中间t_ods_tmp_company
10.对技能标签字段内容进行扁平化处理，将处理的结果储存到临时中间表t_ods_tmp_kill
11.创建维度表t_ods_company ,t_ods_company，t_ods_kill ,t_ods _city用于存储福利标签.薪资分布..技能标签.城市统计的结果
二、分析数据
1.职位区域分析
2.倒叙查询职位区域的信息
3.职位薪资分析
4.查看维度表t_ods_salary 中的分析结果...使用sort by参数对表虫的count列进行倒叙排序
5.平均值
6.众数
7.中位数
8.各城市平均薪资待遇
9.公司福利分析
10.查询维度表中的分析结果,倒叙,查询前10个 11.职位技能要求分析
12.查看技能维度表中的分析结果,倒叙,查看前3个
一、设计hive数据仓库 1.创建数据仓库 [root@hadoop1 ~]# systemctl start mariadb
[root@hadoop1 ~]# hive
create database jobdata; hive&gt; use jobdata; 2.创建事实表 CREATE TABLE ods_jobdata_origin( city string COMMENT '城市', salary array&lt;String&gt;COMMENT '薪资', company array&lt;String&gt;COMMENT '福利', kill array&lt;String&gt;COMMENT '技能') COMMENT '原始职位数据表' ROW FORMAT DELIMITED FIELDS TERMINATED BY ',' COLLECTION ITEMS TERMINATED BY '-' STORED AS TEXTFILE; 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/821da42c2a6ee65359586bd199885991/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/122cda41b291d8aed2d868bcf14211b7/" rel="bookmark">
			什么是Vue，Vue简介，并且对Vue中常用指令全部进行使用和测试，做后端开发会用即可....
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		后端之Vue前端进个门 Vue1.1 概述1.2 Vue使用1.2.1 插值表达式获取数据1.2.2 插值表达式获取数组1.2.3 插值表达式获取对象中的属性1.2.4 插值表达式调用方法 1.3 Vue事件绑定1.3.1 v-on的普通使用方式1.3.2 @事件绑定执行方法1.3.3 通过时间绑定实现实时显示坐标 1.4 v-text指令和v-html指令1.4.1 v-text指令1.4.2 v-html指令 1.5 v-bind指令1.6 Vue绑定 JSON 数据限制选择器1.7 Vue绑定多个Class属性1.8 Vue绑定HTML样式1.9 Vue分支结构1.10 V-for Vue 1.1 概述 Vue是一套前端的框架，简化JS中的DOM操作，不用写可多可多的DOM操作。非常的nice
Vue框架的数据处理模式采用的是MVVM：
MVVM M Model 数据 V View 视图 VM ViewModel 视图和数据的【中间件】 Vue 框架设计的模式 ==&gt; 观察者模式 1.2 Vue使用 1.引入方式
​ 【第一种】：官网下载Vue.js本地操作使用
​ 【第二种】：cdn内容分发节点，【推荐】降低带宽需求
2.HTML页面定义HTML标签，并且引入id属性
3.实例化Vue对象，对HTML标签进行数据操作和影响
1.2.1 插值表达式获取数据 &lt;!DOCTYPE html&gt; &lt;html lang="en" xmlns:v-model="http://www.w3.org/1999/xhtml"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;zpd&lt;/title&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/122cda41b291d8aed2d868bcf14211b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19eb7338e322b2be73e7ed97a9d96743/" rel="bookmark">
			python及go笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		input()接收数据后类型将变成string类型
三元运算符：变量 = 值1 if 条件 else 值2
format,字符串
eval()用于字符串 脱去外壳
输入"123"字符串，eval("123")结果为123 ，type为int
类型转换：
str -&gt;int int(a)
str -&gt; float float(a)
int -&gt; str str(a)
float -&gt; str str(a)
int -&gt; float float(a)
float -&gt; int int(a)
逻辑运算优先级not&gt; and &gt;or
几种最常用的输出方式：
print("%s跟%s是同一个人" % (name1, name2)) print(f"您的金币数是{coins}个,您共玩了{count}局") print("您的金币数是{}个,您共玩了{}局".float(coins, count)) ​ 精确到小数点后一位： print("num1的值是：%.1f" % num1) 随机生成一个1-6之间的数字（1-6，左右都是闭区间） shu1 = random.randint(1, 6) 序列值：
range(9)表示0-8
range(1,9)表示1-8
range(1,9,2)表示1，3，5，7 (start, end,sep)左闭右开
字符串切割：
s[start: end: step]同上，是左闭右开，切出来的是列表
if step是正数 从左向右
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/19eb7338e322b2be73e7ed97a9d96743/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a86a1dbb6fb3e46ce02eb68189b32a6f/" rel="bookmark">
			TFTP服务器与客户端的安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TFTP TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。
软件包括客户端和服务器两部分.
应用场合: 1/交叉开发环境下,uboot 下载uImage的时候,用的就是tftp
uboot端已经实现了tftpclient 所以只需要在主机端实现tftpserver就可以了.
工具的安装 1/、 安装tftp客户端和服务器 sudo apt-get install tftp-hpa//安装客户端 sudo apt-get install tftpd-hpa//安装服务器端 2/ 修改tftpd-hpa配置文件 sudo vi /etc/default/tftpd-hpa 修改”–secure” 为 ” –l –c -s”
-c是可以上传文件的参数？ -s是指定tftpd-hpa服务目录 -l呢？
3/如果你想修改服务器的下载目录(可以不修改,原来为/var/lib/tftpboot),则 修改/var/lib/tftpboot为/tftpboot
sudo mkdir /tftpboot sudo chmod 777 /tftpboot 4/重启tftpd-hpa服务 sudo systemctl restart tftpd-hpa.service 或 sudo service tftpd-hpa restart 5/测试 在终端执行命令:
tftp 对方ip地址
下载文件：get 文件名
上传文件：put 文件名
退出：quit
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5fa0e6764b68b11ed778bce8cdc5beda/" rel="bookmark">
			python金融数据分析和可视化--04利用Baostock获取股票数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		04利用Baostock获取股票数据 1. Baostock平台介绍 Baostock是一个免费、开源的证券数据平台（无需注册）。
提供大量准确、完整的证券历史行情数据、上市公司财务数据等。
通过python API获取证券数据信息，满足量化交易投资者、数量金融爱好者、计量经济从业者数据需求。
返回的数据格式：pandas DataFrame类型，以便于用pandas/NumPy/Matplotlib进行数据分析和可视化。
支持语言：目前版本BaoStock.com目前只支持Python3.5及以上(暂不支持python 2.x)。
2. 下载安装 使用国内源安装：
pip install baostock -i https://pypi.tuna.tsinghua.edu.cn/simple/ --trusted-host pypi.tuna.tsinghua.edu.cn 3. 获取股票数据 import baostock as bs import pandas as pd #### 登陆系统 #### lg = bs.login() # 显示登陆返回信息 print('login respond error_code:'+lg.error_code) print('login respond error_msg:'+lg.error_msg) #### 获取沪深A股历史K线数据 #### # 详细指标参数，参见“历史行情指标参数”章节；“分钟线”参数与“日线”参数不同。“分钟线”不包含指数。 # 分钟线指标：date,time,code,open,high,low,close,volume,amount,adjustflag # 周月线指标：date,code,open,high,low,close,volume,amount,adjustflag,turn,pctChg rs = bs.query_history_k_data_plus("sh.600000", "date,code,open,high,low,close,preclose,volume,amount,adjustflag,turn,tradestatus,pctChg,isST", start_date='2017-07-01', end_date='2017-12-31', frequency="d", adjustflag="3") print('query_history_k_data_plus respond error_code:'+rs.error_code) print('query_history_k_data_plus respond error_msg:'+rs.error_msg) #### 打印结果集 #### data_list = [] while (rs.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5fa0e6764b68b11ed778bce8cdc5beda/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3696af515a2c6f83b2394f18f0da0d6/" rel="bookmark">
			Linux服务器开发（基础篇）：聊天服务器1.0版本实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		引言 在上篇文章中，笔者讲解了与socket编程相关的一系列常用函数的功能与参数，在本节中，我们一起来实现一个简单的聊天服务器，来加深对socket编程的理解。
各部分封装代码及其讲解 common.h中的函数及其功能
#ifndef _COMMON_H_ #define _COMMON_H_ #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; #include&lt;unistd.h&gt; #include&lt;ctype.h&gt; #include&lt;arpa/inet.h&gt; #include&lt;errno.h&gt; #include&lt;stdlib.h&gt; #define ERROR_LOG 0 //端口号 #define SERVER_PORT 6666 //单条信息最大字节数 #define MESSAGE_MAX_LEN 256 //打印出错信息 可考虑log4cpp输出生成日志 void Error(); //函数指针数组 错误处理 待拓展 typedef void (*ErrorHandle[])() ; ErrorHandle handle = {Error}; //以下函数均对错误进行处理 //创建socket int Socket(int domain=AF_INET,int type=SOCK_STREAM); //绑定 void Bind(int sockfd,struct sockaddr_in*addr); //监听 默认最大待处理请求数为128 void Listen(int sockfd,int backlog=128); //服务器接受连接 int Accept(int sockfd,struct sockaddr_in*addr); //客户端连接服务器 void Connect(int sockfd,struct sockaddr_in*addr); void Error(){ fprintf(stderr,"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3696af515a2c6f83b2394f18f0da0d6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26636d8a616abb3333c212c574c405d0/" rel="bookmark">
			FPGA——1位全加器和4位全加器的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、认识全加器1、半加器2、1位全加器3、4位全加器 二、使用原理图实现1位加法器1、原理图实现半加器2、半加器元件实现全加器 三、使用原理图实现4位加法器四、Verilog HDL实现1位加法器和四位加法器五、烧录及实验效果六、总结七、参考链接 一、认识全加器 1、半加器 半加器是实现两个一位二进制数加法运算的器件。它具有两个输入端(被加数A和加数B)及输出端Y。
是数据输入被加数A、加数B，数据输出S和数(半加和)、进位C。
A和B是相加的两个数，S是半加和数，C是进位数。
所谓半加就是不考虑进位的加法，它的真值表如下 (见表)：
逻辑表达式：
2、1位全加器 全加器英语名称为full-adder，是用门电路实现两个二进制数相加并求出和的组合线路，称为一位全加器。一位全加器可以处理低位进位，并输出本位加法进位。多个一位全加器进行级联可以得到多位全加器。常用二进制四位全加器74LS283。
一位全加器的真值表如下图，其中Ai为被加数，Bi为加数，相邻低位来的进位数为Ci-1，输出本位和为Si。向相邻高位进位数为Ci
3、4位全加器 四位全加器，是指能实现四位二进制数全加的数字电路模块。
2个四位输入以及1个一位进位，输出位一个四位数字加上1个一位进位。
二、使用原理图实现1位加法器 1、原理图实现半加器 创建工程这里就不再赘述了，可以参考这篇博客：
https://blog.csdn.net/chenyu128/article/details/127835128
注意选择对所用的芯片型号：
首先选择File-&gt;New，进入后选择Block Diagram/Schematic File
选择元件：两个输入，两个输出，一个与门，一个异或门
保存文件，并编译
通过tool-&gt;Netlist Viewers-&gt;RTL Viewer,查看电路图
仿真波形图
2、半加器元件实现全加器 将设计项目设置为可调用的元件
在打开半加器原理图文件half_adder.bdf的情况下，选择菜中File中的Create/Update→CreateSymbolFilesforCurrentFile项，即可将当前文件h_adder.bdf变成一个元件符号存盘，以待在高层次设计中调用
首先
选择File-&gt;New，进入后选择Block Diagram/Schematic File
选择元件：选择之前设置的半加器元件，三个输入，两个输出，再加上个或门
最终实现的效果图如下：
保存文件，并编译
通过tool-&gt;Netlist Viewers-&gt;RTL Viewer,查看电路图
仿真实现
创建一个向量波形文件，选择菜单项 File→New-&gt;VWF
添加信号
随便设置输入信号的波形，然后点击功能仿真。
功能仿真结果
三、使用原理图实现4位加法器 四、Verilog HDL实现1位加法器和四位加法器 1、重新创建个项目文件，创建verilog HDL 文件
2、1位加法器代码
3、4位加法器代码
4、编译文件无错误并保存
5、可以查看电路图
一位加法器的电路原理图：
4位加法器的电路原理图：
6、波形仿真
1位加法器的波形仿真图，高电平代表1，低电平代表0，可以看到，加法器正常工作无错误波形输出。
这是四位加法器的仿真波形图，这里使用4位的二进制数字来代表4位的输入信号和输出信号。
五、烧录及实验效果 1、
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26636d8a616abb3333c212c574c405d0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f660947a619bb2a6e3ea04925d8a25e/" rel="bookmark">
			【angular-gojs使用笔记】gojs-angular的基本使用。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近需要用到gojs与angular进行一些需求的开发。
根据官网https://gojs.net/latest/intro/angular.html的这篇GoJS with Angular使用说明，除了gojs库本身外，还需安装gojs-angular这个库，使用以下命令完成安装：
npm install gojs gojs-angular gojs-angular提供了三个angular组件，分别是gojs-diagram、gojs-palette和gojs-overview。
gojs-diagram提供以下API：
参数说明类型[initDiagram]图表初始化方法，需要返回一个go.Diagram实例（不能在方法中初始化数据模型）() =&gt; go.Diagram[nodeDataArray]node数据Array&lt;go.ObjectData&gt;[linkDataArray]link数据（可选）Array&lt;go.ObjectData&gt;[modelData]model数据（可选）go.ObjectData[divClassName]图表div的类名，通过此类名可以控制图表的样式string[skipsDiagramUpdate]是否合并app数据和model数据boolean(modelChange)图表Model改变时触发EventEmitter&lt;go.IncrementalData&gt; gojs-palette提供以下API：
参数说明类型(initPalette)调色板初始化方法() =&gt; go.Palette(nodeDataArray)node数据Array&lt;go.ObjectData&gt;(linkDataArray)link数据（可选Array&lt;go.ObjectData&gt;(modelData)model数据（可选）go.ObjectData(divClassName)调色板div的类名，通过此类名可以控制图表的样式boolean[modelChange]Model改变时触发EventEmitter&lt;go.IncrementalData&gt; 复制示例的代码进项目中，需要注意在@Component中将encapsulation属性设置为ViewEncapsulation.ShadowDom或ViewEncapsulation.None，不然通过divClassName属性设置的样式无法起到作用。
// app.component.ts import { Component, ViewEncapsulation } from '@angular/core'; import * as go from 'gojs'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.less'], encapsulation: ViewEncapsulation.ShadowDom, }) export class AppComponent { title = 'GoJs-angular'; // Big object that holds app-level state data // As of gojs-angular 2.0, immutability is required of state for change detection state = { // Diagram state props diagramNodeData: [ { id: 'Alpha', text: 'Alpha', color: 'lightblue' }, { id: 'Beta', text: 'Beta', color: 'orange' }, ], diagramLinkData: [{ key: -1, from: 'Alpha', to: 'Beta' }], diagramModelData: { prop: 'value' }, skipsDiagramUpdate: false, // Palette state props paletteNodeData: [ { key: 'PaletteNode1', color: 'firebrick' }, { key: 'PaletteNode2', color: 'blueviolet' }, ], }; // end state object diagramDivClassName: string = 'myDiagramDiv'; paletteDivClassName = 'myPaletteDiv'; // initialize diagram / templates initDiagram(): go.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f660947a619bb2a6e3ea04925d8a25e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9e28a758bbefa812155e1e6382e31178/" rel="bookmark">
			QT 添加带有滚动条的窗口，并使之滚动起来
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		QT ui designer中提供了一个叫做QScrollBar的控件，但这导致了人们的一个误区，就是必须要使用这个控件，才能使窗口滚动起来
虽然可以通过这个控件来达到目的，但是需要自己去绑定和窗口滚动的一些信号和槽函数，非常麻烦。
因此，我们通常选择另一种方案来实现窗口滚动：QScrollArea控件。
这个控件自带了滚动条，我们只需要在使用前设置好这个控件的一些参数即可。
这个控件自带了一个子控件：QWidget:scrollAreaWidget。 我们需要对这个控件的一些参数进行设置。
要想看到滚动条的一个必要条件就是scrollAreaWidget的尺寸大于scrollArea。
这里我们可以看到，两个控件尺寸都相同，此时运行程序，是不会看到右边有垂直滚动条的
我们修改scrollAreaWidget的尺寸高度为1000
再次运行程序
结果还是没有垂直滚动条，这是什么原因呢？ 因为QScrollArea在Qt designer中有一个属性：WidgetResizable。 它的默认属性为true(勾选)，false(未勾选)
我们需要取消这个钩，将其属性设置为false,之后再次运行程序
这是就可以看到右边出现了滚动条，此时出现的滚动条已经可以通过鼠标滚轮，鼠标左键拖拽，点击来控制显示区域了，都不需要自己去实现什么函数。
和QScrollBar相比，简直不要太方便。
但是，再界面上需要动态添加控件的时候，给scrollAreaWidget设置一个固定的尺寸就不合适了，因为当控件的坐标超出scrollAreaWidget的尺寸时，依然无法显示
此时，就需要在动态生成控件的时候添加一个判断，判断控件的位置+尺寸是否超出了scrollAreaWidget的显示范围，如果超出，则需要使用函数
ui-&gt;scrollAreaWidget-&gt;setGeometry(0, 0, 340, ui-&gt;scrollAreaWidget-&gt;height()+30); 动态的设置scrollAreaWidget的尺寸大小，这样就能保证无论生成多少动态控件，始终都在scrollAreaWidget范围内，而且可以通过滚动条滚动来显示不同区域的控件
补充使用代码添加滚动区域的方法
首先在界面上随便放置一个容器，我们这里放置了一个groupbox
然后在头文件中添加如下代码
QHBoxLayout *layout; QScrollArea *scrollarea; QWidget *scrollareacontent; 然后在构造函数中添加如下代码
Widget::Widget(QWidget *parent) :QWidget(parent),ui(new Ui::Widget) { ui-&gt;setupUi(this); scrollarea = new QScrollArea(ui-&gt;groupBox); scrollarea-&gt;setWidgetResizable(true); scrollarea-&gt;setGeometry(0,0,ui-&gt;groupBox-&gt;width(),ui-&gt;groupBox-&gt;height()); layout = new QHBoxLayout(ui-&gt;groupBox); scrollareacontent = new QWidget(ui-&gt;groupBox); scrollareacontent-&gt;setLayout(layout); scrollarea-&gt;setWidget(scrollareacontent); } 注意，这里设置的父对象是ui-&gt;groupbox，就是我们前面添加在主界面上的groupbox控件
然后添加按钮槽函数，实现点击一个按钮就在groupbox中添加一个新按钮的功能，准确的说，应该是在scrollareacontent中添加新的按钮
void Widget::on_pushButton_clicked() { QPushButton *btn = new QPushButton(scrollareacontent); btn-&gt;setMinimumSize(btn-&gt;size()); layout-&gt;addWidget(btn); } 新建按钮的时候，它的父对象是scrollareacontent，如果是别的父对象，滚动条将不会生效。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9e28a758bbefa812155e1e6382e31178/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461ea249918867d6a938ba7e4e71c2f3/" rel="bookmark">
			Qt | 鼠标事件和滚轮事件 QMouseEvent、QWheelEvent
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言：
程序中经常用到鼠标事件，根据不同的鼠标事件实现不同的功能。在Qt中，QMouseEvent类表示鼠标事件。通常通过重定义部件的鼠标事件处理函数的方式来进行一些自定义的操作。QWheelEvent类来表示鼠标滚轮事件，主要用来获取滚轮滚动的方向和距离。
鼠标事件：
我们通常使用的鼠标事件有：
void mousePressEvent(QMouseEvent *event); //鼠标按键按下void mouseReleaseEvent(QMouseEvent *event); //鼠标按键抬起void mouseDoubleClickedEvent(QMouseEvent *event); //鼠标按键双击void mouseMouveEvent(QMouseEvent *event); //鼠标移动void wheelEvent(QWheelEvent *event); //鼠标滚轮滚动 在QWidget中的定义如图：
image.png
鼠标移动事件：
鼠标的移动事件mouseMouveEvent()默认是在鼠标按键按下时移动鼠标的时候才会产生；如果不想按下鼠标也可以获取到鼠标移动事件的话，就需要在构造函数中添加：
setMouseTracking(true);//设置鼠标跟踪 设置鼠标形状：
1.设置鼠标为系统提供的形状：
QCursor cursor; cursor.setShape(Qt::OpenHandCursor);//小手掌形状 setCursor(cursor); //或者使用：QApplication::setOverriedCursor(cursor);//使鼠标指针暂时改变形状 复制代码
Qt中提供了常用的鼠标指针的形状，可以在帮助中通过Qt::CursorShape关键字查看。
2.设置鼠标为自定义形状：
QCursor cursor("./image/logo.png"); setCursor(cursor); //或者使用：QApplication::setOverrideCursor(cursor);//使鼠标指针暂时改变形状 复制代码
如果使用了QApplication::setOverriedCursor(cursor);来暂时改变鼠标指针的形状，那么就需要在恢复鼠标形状时使用QApplication::restoreOverrideCursor();
Q_UNUSED():
如果在函数中没有用到函数传进来的参数的话，比如说在void mousePressEvent(QMouseEvent *event)函数体中，我们没有使用到event这个参数，这样在编译程序的时候会出现警告，但是这不会影响程序的编译运行，如果不想出现这样的警告信息，就可以在函数内第一句加上Q_UNUSED(xxx);xxx表示不使用的参数。这样就不会出现警告了。
滚轮事件：
QWheelEvent()类的delta()函数返回了滚轮移动的距离。每当滚轮转动一下，默认是15度，这时调用QWheelEvent()::delta()返回的值就是15*8=120。转动方向为向外，返回正值；转动方向为向内，返回负值。所以可以通过这个函数的返回值的正负来判断滚轮的方向。 实现鼠标拖动窗口移动：
void Widget::mousePressEvent(QMouseEvent *event) { if(event-&gt;button() == Qt::LeftButton) // 鼠标左键 { m_isMouseLeftDown = true; m_dragPos = event-&gt;globalPos() - pos(); //获取指针位置和窗口位置的差值 } } void Widget::mouseMoveEvent(QMouseEvent *event) { if(event-&gt;buttons() &amp; Qt::LeftButton)//见注： { move(event-&gt;globalPos() - m_dragPos); event-&gt;accept(); //事件处理函数“接收”了这个事件，不要再向父部件传递； } } 注：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/461ea249918867d6a938ba7e4e71c2f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e8f319e5ce80eb0cee63510f44b9d5b4/" rel="bookmark">
			a-tree-select 基本使用，下拉框高度和宽度设置、回显时滚动条定位解决。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、基本使用1. 界面效果2. 代码实现3. 问题1：下拉框占满整个屏幕4. 问题4：菜单内容过长时，下拉菜单宽度无限变宽。 二、数据回显、滚动条定位1. 界面效果2. 代码实现2.1 获取默认展开节点2.1.1 代码实现2.1.2 说明 2.2 设置滚动条定位2.2.1 注意：找到选中后的样式名，见下图。2.2.2 代码实现 三、完整代码 一、基本使用 1. 界面效果 2. 代码实现 &lt;template&gt; &lt;div&gt; &lt;div class="box"&gt; &lt;a-tree-select v-model="name" :replaceFields="replaceFields" :tree-data="treeData" class="tree-select" &gt; &lt;/a-tree-select&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { getPkProperty } from '@/api/process-cfg/process-cfg.js' export default { data() { return { replaceFields: { children: 'subclasses', title: 'dsp_class_name', key: 'class_name', value: 'class_name' }, treeData: [], name: '' } }, created() { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e8f319e5ce80eb0cee63510f44b9d5b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03b5350e0ea840718eb2cab787a4e569/" rel="bookmark">
			ssh远程连接@远程文件传输scp@sftp@Linux查看ip地址的若干种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 远程文件传输scp@sftpGUI方案VNC Viewer CLI通用方案 OpenSSHssh连接👌🎈vscode sshCLI sshssh链接局域网主机@本地虚拟机查询登录目标信息(IP地址@用户名@主机名) ssh连接过程可能的意外情况@config权限 scp传输协议基本使用方式powershell中主机变量名引用变量的方式 sftp传输协议sftp相关工具(mobaXterm) 对比SCP和SFTP 附查看linux的ip地址方法 远程文件传输scp@sftp GUI方案 有VNC Viewer,mobaXterm等 VNC Viewer VNC Viewer:Download VNC Viewer | VNC® Connect (realvnc.com) RealVNC Help Center VNC Viewer是一款远程桌面客户端软件，它可以连接到运行了VNC Server的计算机，从而实现远程桌面控制。VNC（Virtual Network Computing）是一种远程桌面协议，它可以让用户在本地计算机上通过网络连接远程计算机的桌面环境，从而实现远程控制。VNC Viewer是VNC协议的客户端实现，它可以在Windows、Linux、macOS等操作系统上运行。使用VNC Viewer，用户可以在本地计算机上查看并控制远程计算机的桌面环境，就好像自己坐在远程计算机前一样。 CLI通用方案 详见后文 OpenSSH OpenSSH官方文档：https://www.openssh.com/manual.html ssh连接👌🎈 ssh方式连接到主机很有用,特别是远程主机没有安装图形界面的时候(节约云服务器的资源占用) vscode ssh 可以通过vscode提供的 remote-ssh插件,来利用本地可视化编辑器(其他IDE可能也有其自己的远程编程支持)来编辑远程代码
这不是必须的,但是有时可以提供便利
Connect over SSH with Visual Studio Code
CLI ssh ssh(1) - OpenBSD manual pages
SSH（Secure Shell）是一种安全的远程登录协议，可以在本地计算机和远程计算机之间建立加密的通信连接。SSH协议支持多种功能，包括远程登录、文件传输、远程命令执行等。以下是SSH命令的语法简介：
ssh [options] [user@]hostname [command]
其中，“ssh”是SSH命令，options是可选的参数，user是远程计算机的用户名，hostname是远程计算机的IP地址或主机名，command是要在远程计算机上执行的命令。如果没有指定命令，SSH会默认打开一个远程登录会话，让用户可以在远程计算机上执行命令和操作。
常用的SSH命令选项包括：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03b5350e0ea840718eb2cab787a4e569/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ceeb2c3fbbacd1923d81ef3d576ed357/" rel="bookmark">
			UE4如何调用打开系统消息对话窗口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏开发过程中，有时需要明显的提示游戏运行时出现的问题，比如配置错误等信息，不仅需要输出错误到日记文件，还需要明显的显示错误信息给到非程序人员看到。那么打开系统窗口提示就是一个非常好的选择。
案例1： 在UE4中，你可以使用 FMessageDialog::Open 函数来打开一个自定义的消息对话框。以下是一个简单的示例：
#include "Runtime/Engine/Public/Slate/Dialogs/MessageDialog.h" void AMyTestActor::TestFMessageDialog() { FText Title = FText::FromString("My Dialog"); FText Message = FText::FromString("This is a message.The UE invokes the interface and displays the Windows window.Display this information."); EAppMsgType::Type Type = EAppMsgType::OkCancel; const EAppReturnType::Type Response = FMessageDialog::Open(Type, Message, &amp;Title); if (Response == EAppReturnType::Ok) { UE_LOG(LogTemp, Log, TEXT("User clicked OK.")); // 处理用户确认... } else if (Response == EAppReturnType::Cancel) { UE_LOG(LogTemp, Log, TEXT("User clicked Cancel.")); // 处理用户取消.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ceeb2c3fbbacd1923d81ef3d576ed357/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/163/">«</a>
	<span class="pagination__item pagination__item--current">164/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/165/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>