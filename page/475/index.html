<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b74742f325b37a59fe8fce27041e612/" rel="bookmark">
			shell 数组 循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#!/bin/bash array=(1 2 3 4 5) #以括号括起为数组 中间是空格 for num in "${array[@]}" #以这种for打印数组 do echo $num done xxx[0]='a' #第二种定义数组的方法 xxx[1]='b' xxx[2]='c' for ((i=0; i&lt;${#xxx[@]};i++)); do # ${#xxx[@]} 返回数组的大小 echo ${xxx[i]} #${xxx[$i]} ${xxx[${i}]} 这两种都可以 通过下标打印数组 数组从0开始 done #对目录处理的一些技巧 xxx=(`ls`) # ``这里可以包含一些shell命令(~这个键) 这个配合管道命令是很强大的 grep sed for file in "${xxx[@]}" #用第二种for循环也是可以的 do echo $file done #sh相加字符串是非常方便的 直接放到后面就可以了 #单引号和双引号是有区别的 单引号只能放字符串 双引号里面可以解释变量 initPath='/a' secPath='/b' thrPath='c' path=${initPath}'/' path=${initPath}${secPath}'/'${thrPath} #对数字的支持可能就比较烦了 xxx=2 xx=${xxx}-1 echo $xx #输出：2-1 echo $(($xxx-1)) #如果是数字运算 外面加上 $(( )) 才会得到正确的结果 let "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6b74742f325b37a59fe8fce27041e612/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6778715e07883886487a72a7ee59ba06/" rel="bookmark">
			第十四天（继承）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. （继承、this 和 super 关键字）有以下代码 class Super{ public Super(){ System.out.println("Super()"); } public Super(String str){ System.out.println("Super(String)"); } } class Sub extends Super{ public Sub(){ System.out.println("Sub()"); } public Sub(int i){ this(); System.out.println("Sub(int)"); } public Sub(String str){ super(str); System.out.println("Sub(String)"); } } public class TestSuperSub{ public static void main(String args[]){ Sub s1 = new Sub(); Sub s2 = new Sub(10); Sub s3 = new Sub("hello"); } } 写出该程序运行的结果。
输出结果： Super() Sub() Super() Sub() Sub(int) Super(String) Sub(String) 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6778715e07883886487a72a7ee59ba06/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfba873270bed0c021ef08dd4be4bffe/" rel="bookmark">
			js数组中去除重复对象及去除空对象的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 js数组中去除重复对象及去除空对象的方法 (function(){//去除数组中重复对象 var unique = {}; arr.forEach(function(a){ unique[ JSON.stringify(a) ] = 1 }); arr= Object.keys(unique).map(function(u){return JSON.parse(u) }); return arr })(arr) let newArr=[];//去除空对象 for(let j in arr){ for(let prop in arr[j]){ if(prop!=''||arr[j][prop]!=''){ newArr.push(arr[j]); } } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6641a7b8f59206ac7b4a3360e28dffb0/" rel="bookmark">
			odoo中运用ir.actions.client实现自定义HTML页面开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、背景
odoo的页面展示包含多种类型，由于odoo本身的渲染机制比较复杂，速度也比较慢，所以想开发普通的html页面，随心所欲。
二、开发过程
利用ir.actions.client 类型的动作。官方文档介绍如下：
客户端动作 (ir.actions.client) 触发完全在客户端中实现的动作。
tag 客户端动作的标识符，客户端应知道如何响应任意的字符串 params (选填) 发送给客户端附加数据的Python字典，以及客户端动作标签 target (选填) 客户端动作应在内容区域(current)， 或在全局模式下 (fullscreen) 对话框/弹出窗口 (new)中打开。使用 main 而不是 current 清除面包屑。默认为 current. { "type": "ir.actions.client", "tag": "pos.ui" } 告诉客户端启动Point of Sale接口，服务器是不知道POS接口是如何工作的。
三、最终实现效果
四、源码
百度云：http://pan.baidu.com/s/1mhEVaD6
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ef90f14435e66aa2d6107d22df7422e/" rel="bookmark">
			实例详解不同VLAN间通信（转发过程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、交换机端口的两种工作模式 交换机端口有三种工作模式：Access端口、trunk端口、hybrid端口。 在交换机中收发数据包时： Access端口：只收发本Vlan不带tag的帧。 Trunk接口：只收发本接口允许VLAN列表的数据帧，本接口的Native Vlan不带tag，其他所有Vlan都带tag。 hybrid端口：： 1、判断该VLAN在本端口的属性 2、如果是untag则剥离VLAN信息，再发送，如果是tag则比较端口的PVID和将要发送报文的VLAN信息， 如果两者相等则剥离VLAN信息，再发送， 否则报文将携带原有的VLAN标记进行转发 Hybrid端口和trunk端口的区别： Hybrid端口和Trunk端口在接收数据时，处理方法是一样的， 唯一不同之处在于发送数据时：Hybrid端口可以允许多个VLAN 报文发送时不打标签，而Trunk端口只允许缺省VLAN的报文 发送时不打标签。 实例详解Access端口和trunk 端口的区别： 如下图：跨交换的同个VLAN之间的通信 数据包从电脑发出的时候，本身是没有VLAN TAG的，当数据包进入交换机的ACCESS口后，交换机会打上 VLAN TAG（交换机内部），然后从ACCESS口发出就剥离掉VLAN TAG了，然后发送到目的电脑上面。下面这个图就是很好的解释，如果你在方案一中间的线路上面去捕捉数据包，捕捉到的数据包是没有802.1Q的封装的，也就是没有VLAN TAG，但是在交换机内部处理从F0/1端口发送到F0/24端口的时候会有TAG标记的，你捕捉不到而已。然后方案二，在中间的TRUNK线路中传输的数据包，你是可以捕捉到带有VLAN TAG的数据包的。
二、实例详解VALN转发过程 如下图：处于不同VALN的PC1访问PC4 步骤1：PC1访问PC4的时候，因为2台PC不在同一个网段内，所以PC1查询自己的路由表以后会将数据包发给PC1的网关192.168.10.1,此时从PC1网卡发出的数据包内容是SIP:192.168.10.10 DIP:192.168.11.20 SMAC:PC1 DMAC:RT5 VLAN:空
步骤2：上面的数据包从PC1的网卡发出后先到达SW3的F0/10端口，此端口是ACCESS口，于是给数据包打上VLAN 10的标记，随后查询自己的ARP表，因为目的MAC是RT5，所以讲数据包从F0/1口发出，而F0/1是TRUNK口，所以此时数据包在TRUNK线路上的数据包内容是：SIP:192.168.10.10 DIP:192.168.11.20 SMAC:PC1 DMAC:RT5
步骤3：数据包到达RT5 E0/0.10子接口以后，路由器查询自己的路由表，发现去往目的地址192.168.11.20网段的路由是在E0/0.11下面的直连网段，所以路由会讲数据包从E0/0.10传输到E0/0.11子接口下面，在这传输的过程中就会讲VLAN10的标记剥离掉重新打上VLAN11的标记，然后从E0/0.11口发出，E0/0是TRUNK口，此时数据包的内容是SIP:192.168.10.10 DIP:192.168.11.20 SMAC:RT5 DMAC:PC4
步骤4：数据包从RT5发送到SW3，然后SW3通过TRUNK线路又发送到SW4，SW4查询自己的ARP表，发现PC4在F0/11端口下面
步骤5：因为F0/11是ACCESS口，所以SW4将数据包从F0/11口发出的时候会剥离掉VLAN11标记，最终数据包达到PC4。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89c6dbce2ae6a42894424e3a0552d5d5/" rel="bookmark">
			java 从服务器下载文件并保存到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		昨天在做一个项目时，用到了从服务器上下载文件并保存到本地的知识，以前也没有接触过，昨天搞了一天，这个小功能实现了，下面就简单的说一下实现过程；
1.基础知识 当我们想要下载网站上的某个资源时，我们会获取一个url，它是服务器定位资源的一个描述，下载的过程有如下几步： （1）客户端发起一个url请求，获取连接对象。 （2）服务器解析url，并且将指定的资源返回一个输入流给客户。 （3）建立存储的目录以及保存的文件名。 （4）输出了写数据。 （5）关闭输入流和输出流。 2.实现代码的方法 /** * @功能 下载临时素材接口 * @param filePath 文件将要保存的目录 * @param method 请求方法，包括POST和GET * @param url 请求的路径 * @return */ public static File saveUrlAs(String url,String filePath,String method){ //System.out.println("fileName----&gt;"+filePath); //创建不同的文件夹目录 File file=new File(filePath); //判断文件夹是否存在 if (!file.exists()) { //如果文件夹不存在，则创建新的的文件夹 file.mkdirs(); } FileOutputStream fileOut = null; HttpURLConnection conn = null; InputStream inputStream = null; try { // 建立链接 URL httpUrl=new URL(url); conn=(HttpURLConnection) httpUrl.openConnection(); //以Post方式提交表单，默认get方式 conn.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/89c6dbce2ae6a42894424e3a0552d5d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b70dd7ba5a6e8086a017f679af0a85f/" rel="bookmark">
			【Wayland】初识Wayland（X、Mir）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【声明】下图copy自wikipedia，如有侵权请告知。
在介绍Wayland之前，先熟悉一下X与Mir，简单来说，同样作为显示服务，X是一个老派的庞然大物，Wayland是一颗节节高的芝麻，Mir是一个颇受争议的新秀，其它的显示服务还包括Android的SurfaceFlinger，MacOS家族的Quartz Compositor等。
1、Mir 【参考ubuntu-wiki】https://wiki.ubuntu.com/Mir 【参考wikipedia】https://en.wikipedia.org/wiki/Mir_(software)
Mir是一种计算机显示服务，用于Linux操作系统，由Canonical开发，2013年3月4日公开，计划替代Ubuntu上的X窗口系统，开发Unity 8，不过随着Ubuntu 18.04 LTS的发行，Canonical宣称Unity 8将不再支持GNOME，Mir与其竞争者Wayland各行其道，主要投资于IoT项目，其它应用还包括SDL、GTK+、Qt5等，另外，Mir争议颇多，如其License为GPLv3。在架构方面，Mir像Wayland一样，基于EGL，并且使用了一些始于Wayland的基础套件，如Mesa的EGL实现、Jolla的libhybris，以及兼容于X的基于XWayland的XMir，此外，Mir还有一些基础套件延用自Android，如input框架、Protocol Buffer等等。下图是Mir的基本组成及架构。
2、X 【参考x.org-wiki】https://www.x.org/wiki/ 【参考wikipedia】https://en.wikipedia.org/wiki/X_Window_System
X即X11、X Window System，是用于在类UNIX的操作系统上的位图显示的窗口系统，提供了GUI环境的基本框架，可以在显示设备上绘制、移动窗口，通过鼠标、键盘、触摸屏与用户交互。X由X.Org Foundation维护，遵守MIT协议，当前参考实现为X.Org Server。在架构方面，X使用了C/S模型，客户端和服务器可以在同一个机器上，也可以在不同的机器上，X作为Server为应用程序这个Client提供显示和I/O服务，基本结构如下图所示。
上面提到的X.Org Server是X显示服务的一种开源实现，对应的客户端实现为Xlib或XCB，XCB旨在取代Xlib。
3、Wayland 【参考wayland】https://wayland.freedesktop.org/ 【参考wikipedia】https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)
Wayland是一个显示服务协议，服务端为Wayland Compositor，把X的X Server和Compositor合二为一，旨在替换X，作为类Unix操作系统上更现代、简介的窗口系统，遵守MIT协议，提供了Wayland Compositor的参考C语言实现Weston。下面是Wayland官网文档给出的架构简图，与上面的X架构简图对比，少了两个传输步骤。
近些年，Linux桌面图形渲染接口移植到了Linux内核组件，如DRI、DRM，目的是提供一个更加灵活、高性能的图形系统。Wayland由一个协议和参考实现Weston组成，GTK+和Qt使用了Wayland取代X，其它的许多应用程序也期望得到Wayland的支持。Wayland目前还不像X一样是网络透明的，将来将会支持这个特性，实现手段可能是像VNC一样的pixel-scraping，或者像RDP、SPICE、X一样发送一个rendering command stream，或者使用Wayland Server代理来发送压缩的图片给真正的Compositor。Wayland发起人解释了为什么不扩展X而是创建Wayland，X已非常臃肿，许多模块已都移植到了Linux内核，剩下的还有许多功能也都不常用。下面是使用了Wayland的一个图形系统简图。
Wayland协议为Client-Server模式，客户端为图形应用程序，请求屏幕上像素缓冲区的显示，服务器为Compositor，控制这些缓冲区的显示。Wayland参考实现Weston包括两层协议，一个为low-level或wire协议，基于消息，主要就是IPC，如Linux Domain Socket，这层协议为手动写的C语言实现；另一个是high-level协议，处理客户端和Compositor需要交换的消息，以实现窗口系统的基本功能，这层协议是基于对象的异步协议，包括全局对象和非全局对象，从规定格式的XML文件中自动生成，可以灵活地动态扩展或者用于错误验证。Wayland参考实现包括两部分，libwayland-client和libwayland-server，其架构简图如下所示。
Wayland协议在其源码protocol/wayland.xml中定义，下面列出了一部分。
除了Wayland的核心协议外，还有一些扩展协议，如管理Compositor中Surface的XDG-shell协议，车载娱乐系统IVI-shell协议。
Wayland协议不包括渲染API，而是使用DRM，这需要客户端在同Compositor共享的缓冲区中渲染窗口，在这种情况下，客户端有更多选择，如图形渲染库Cario和OpenGL，或者是支持Wayland的高级图形库GTK+和Qt，以及Freetype字体渲染引擎等等。渲染缓冲区结果存放在wl_buffer对象中，这个对象与具体的实现相关，但必须是客户端和Compositor共享的。如果客户端使用软描画（CPU），结果存储在系统内存中，客户端和Compositor可以使用共享内存传递缓冲区数据而不需要额外的拷贝工作，接口为wl_shm、wl_shm_pool，这种方法的缺陷是拷贝数据到GPU以进行显示，造成图形描画性能下降。所以，最常见的做法是使用硬件（GPU）加速API直接渲染到video memory，这些API如OpenGL、OpenGL ES、Vulkan，客户端和Compositor可以使用特殊的句柄共享这块GPU缓冲区，这样就避免了拷贝数据到GPU的耗时工作，而且Compositor还可以使用同一个API对屏幕上将显示的最终场景进行合成优化。渲染完成并且缓冲区共享之后，Wayland客户端通知Compositor显示缓冲区的渲染结果，这需要客户端绑定缓冲区，缓冲区存放了Surface对象的渲染结果，然后发送commit请求给这个Surface，把对相应缓冲区的有效操作传递给Compositor。下面是包括了渲染API的结构图。
Weston是Wayland显示服务的参考实现，只支持Linux，因为依赖于Linux内核的一些模块，如KMS、GBM、udev等，input处理依赖于evdev，buffer处理依赖于GBM，从上图中可以看出，还有一些其他实现，如Clayland等。
下面是Wayland与libinput的结构图。
现在，许多软、硬件都支持Wayland，Wayland的流程程度越来越广。
最后，Wayland与X的区别可参照https://en.wikipedia.org/wiki/Wayland_(display_server_protocol)。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8f6785f1ae9fa93fd1b63aca0c09d14/" rel="bookmark">
			Linux Journald日志系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		By Toradex 胡珊逢
1). 简介
长久以来 syslog 是每一个 Unix 系统中的重要部件。在漫长的历史中在各种 Linux 发行版中都有不同的实现去完成类似的工作，它们采取的是逻辑相近，并使用基本相同的文件格式。但是 syslog 也存在诸多的问题，随着新设备的出现以及对安全的重视，这些缺点越发显得突出，例如日志消息内容无法验证、数据格式松散、日志检索低效、有限的元数据保存、无法记录二进制数据等。
Journald是针对以上需求的解决方案。受udev事件启发，Journal 条目与环境组块相似。一个键值域，按照换行符分开，使用大写的变量名。除了支持ASCII 格式的字符串外，还能够支持二进制数据，如 ATA SMART 健康信息、SCSI 数据。应用程序和服务可以通过将项目域传递给systemd journald服务来生成项目。该服务可以为项目增加一定数量的元数据。这些受信任域的值由 Journal 服务来决定且无法由客户端来伪造。在Journald中，可以把日志数据导出，在异地读取，并不受处理器架构的影响。这对嵌入式设备是很有用的功能，方便维护人员分析设备运行状况。
Toradex从V2.0 Linux BSP 开始，使用Journald作为默认的日志管理系统。下面将基于Toradex Colibri iMX6DL ARM嵌入式平台介绍Journald的基本使用方法，这个平台是基于NXP iMX6系列ARM处理器，支持双核心Cortex-A9。
2. 配置
a). 在使用日志之前，我们需要设置好系统的时间，便于后面按时间查找。Toradex默认 BSP 使用 UTC 时区，通过下面命令设置中国时区。因为 BSP 编译的时候并没有将时区数据添加进来，所以需要把模块联网，在线安装。
root@colibri-imx6:~# opgk update
root@colibri-imx6:~# root@colibri-imx6:~# opkg install tzdata-asia
root@colibri-imx6:~# timedatectl set-timezone Asia/Shanghai
root@colibri-imx6:~# timedatectl
Local time: Sat 2017-05-27 10:34:59 CST
Universal time: Sat 2017-05-27 02:34:59 UTC
RTC time: Sat 2017-05-27 02:34:59
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c8f6785f1ae9fa93fd1b63aca0c09d14/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/12abfe4938c8f4af78fe25365d7f297c/" rel="bookmark">
			jvm：gc算法——复制、标记清除
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1、复制算法：
年轻代使用这种算法进行gc 。将可用的内存按容量划分为大小相等的两块（from，to），每次只是用其中一块（总有一块是空的【to区域】）。当这一苦熬的内存用完了，就将还存活着的对象复制到另外一块上面，然后把已使用过的内存空间一次清理完。 HotSpot虚拟机默认Eden和Survivor大小的比例是8:1，也就是每次新生代中可用的内存空间为整个新生代容量的90%，只有10%的内存时被浪费的。 通常情况下新生代中对象生命周期很短，大部分对象都要被回收，从而 GC吞吐量要求很高，所以新生代适合使用复制算法来进行GC，这样保证复制的数据的量较小，效率最好。 缺点：浪费内存空间，如果对象存活率较高时要执行较多的复制操作，效率降低。 图解：有一块内存区域是空的，一般是to区域。保留区域每次回收后都因为复制的时候让他们变为连续的地址空间，所有不产生内存碎片。 2、标记-清除算法： 老年代通常使用这种算法。 先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 对象在年老代的存活时间比较长，如果进行使用复制算法来进行GC，需要移动大量的对象，导致效率很低。所以，年老代适合使用标记-清除算法（或者标记-清除-整理），需要被GC的对象很少，那么标记的对象就很少，在对标记的对象进行回收，效率就会很高。
缺点：回收了被标记的对象后，由于未经过整理，所以导致很多内存碎片 图解：绿色是被标记为可回收的，当回收后，未使用的内存空间非常零碎，产生内存碎片 3、标记-整理算法： 标记整理算法的“标记”过程和标记-清除算法一致，只是后面并不是直接对可回收对象进行整理，而是让所有存活的对象都向一段移动，然后直接清理掉端边界意外的内存。 图解：由于标记后继续整理，可以很明显的看出未使用的地址空间都是连续的，不会产生内存碎片。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98cde5d71d67bf290e83b0a884e8e2ae/" rel="bookmark">
			第一阶段第十二天（面向对象 对象方法调用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2、熟悉类的结构体，类变量和成员变量区别 结构体： * 修饰符 class 类名{ * 属性:变量 * 局部变量：在方法中定义变量 * 全局变量：类变量 * 成员变量：非静态变量 * 方法： * main方法：主方法 入口文件 * * 普通方法：普通函数 功能独立的代码段 * 修饰符 返回值类型 方法名(参数列表){ * * } * 构造方法：实例化类对象 * 如果在类中不创建，系统会默认给我们创建一个不带参数的构造函数 * } 类变量：在类中定义，又称之为全局变量 ，static 修饰的变量信息 成员变量：在类中直接定义的变量信息,非静态变量 3、写一个学生类 有姓名 、年龄、性别属性 学习 打球 游泳方法 要求： 1、通过主函数调用相关属性和方法，并输出打印 2、创建三个对象，然后赋值调用 package day12; /** * * 写一个学生类, 有姓名 、年龄、性别属性,学习 打球 游泳方法 * 要求： * 1、通过主函数调用相关属性和方法，并输出打印 * 2、创建三个对象，然后赋值调用 * */ public class Demo12_1 { public static void main(String[] args) { //姓名：张三 ， 年龄：20，性别：男 Student stu=new Student(); stu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98cde5d71d67bf290e83b0a884e8e2ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffaec9a2df9692d816e6ed1ac2ec481a/" rel="bookmark">
			linux面试常问命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示? 切换目录用什么命令？
绝对路径： 如/etc/init.d
当前目录和上层目录： ./ ../
主目录： ~/
切换目录： cd
2. 怎么查看当前进程？怎么执行退出？怎么查看当前路径？
查看当前进程： ps
执行退出： exit
查看当前路径： pwd
3. 怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用
什么命令？
清屏： clear
退出当前命令： ctrl+c 彻底退出
执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台
查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分
组及用户名
查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser --help 这个告
诉你一些常用参数； info adduesr；
4. Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？
ls 执行的功能： 列出指定目录中的目录，以及文件
哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写
可执行的权限等
5. 建立软链接(快捷方式)，以及硬链接的命令。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ffaec9a2df9692d816e6ed1ac2ec481a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebf4add96f22fc3eec4d5ebd441a940f/" rel="bookmark">
			论文查重原理及实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		论文查重原理及实现 原理: 在知网上的论文检测为整篇的进行上传但是本人却是提交自己的正式论文部分上去的(paperpass), 上传的文章格式对检测结果可能会造成影响(在paperpass上存在两种类型(分别为.doc, .docx), 但有的还可以是.txt文件), 此影响为几十个字的小段可能检测不出. 但为什么不可以是pdf或者其他的文档文本格式了?(页面的前端业务逻辑判断就会进行处理). 首先来解释一下pdf格式文本与doc/txt/docx等可以直接查重的文本文档进行比较的结果. pdf : pdf是由Adobe公司开发的. 一般情况下pdf是不支持修改的.doc : doc是由微软公司开发的. 一般情况下doc都是支持修改的.对于数据量过于繁琐的论文比如5万字以上的论文文章, 以上问题造成的影响就可以忽略不计的. 对比数据的来源:
对比数据库的存在: 中国学术期刊网络出版总库, 中国博士学位论文全文数据库/中国优秀硕士学位论文全文数据库, 国内重要论文全文数据库, 中国重要报纸全文数据库, 中国专利全文数据库, 个人对比库, 其他对比库. 部分书籍不在知网知网数据库里, 所以检测不到.
上传论文之后发生的事:
上传论文后, 系统会自动检测文章的目录结构也就是章节信息, 如果有自动生成的目录信息, 那么系统会将文章按章节分段检测, 否则会自动分段检测 package Test; import java.io.BufferedReader; import java.io.File; import java.io.FileReader; import java.io.IOException; import java.util.ArrayList; import java.util.Iterator; /** * Created by JackDan9 on 2017/5/23. */ public class GetParagraph { public static void main(String[] args) throws IOException { ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;(); //段落的切分 StringBuilder sb = new StringBuilder(); // 拼接读取的内容 String temp1 = null; // 临时变量, 存储sb没有去除标点符号的内容(只是去除空格) String temp = null; // 临时变量, 存储sb去除空格的内容并且取出标点符号的内容 BufferedReader reader = new BufferedReader(new FileReader(new File("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ebf4add96f22fc3eec4d5ebd441a940f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97d54b5251fadeb26d37330630216016/" rel="bookmark">
			Retrofit2.0的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Retrofit2.0 一、添加依赖 compile 'com.squareup.retrofit2:retrofit:2.2.0' 二、简单使用 RetroFit使用步骤:
1.定义一个接口(封装url地址和数据请求) 2.实例化retrofit 3.调用retrofit实例创建接口服务对象 4.调用接口中的方法获取Call对象 5.call对象请求(异步\同步请求) 2.1 定义接口 首先，需要定义baseUrl，定义接口时通过@GET/@POST标记发起get/post请求，@GET/@POST中填写baseUrl后的路径，访问的网络地址由baseUrl和@GET/@POST注解后的路径拼接组成，baseUrl在构造retrofit对象时给出。
下面是几种案例：
2.1.1 @Get 直接拼接地址 1.标记为Get请求2.拼接地址，url里的参数为常量3.指定返回值为泛型类型是String的Call对象。因为Retrofit单独使用时，使用Call对象发起网络请求，所以这里指定返回值为Call对象。泛型值指定的是你希望的请求回调里response.body()的值。若为Call &lt; ResponseBody &gt;：ResponseBody responseBody = response.body()；若为Call &lt; String &gt;：String str = response.body(); 注意：泛型类型需Retrofit添加转化器支持。具体参见：四、为Retrofit添加转化器支持（泛型类型）。4.请求方法名 2.1.2 @Get url里的包含变量，使用{type}占位 1.使用{}标记这里是变量，userId为形参名2.指定Url里的形参变量3.指定传入参数类型为String4.指定传入参数的变量名 多个参数使用相同格式，并用“，”相隔。例如：
2.1.3 @Get 请求参数为一个键值对 1.使用@Query标记为键值对2.键名3.传入的值名已经类型 备注：拼接的Url写到“？”前。
2.1.4 @Get 请求参数为多个键值对 1.使用@QueryMap标记为多个键值对2.指定传入参数值 2.1.5 @Get 多种方式组合 2.1.6 @Get 下载图片 2.1.7 @Post 提交表单 2.1.8 @Post 上传单个文件 2.1.9 @Get 上传表单中的所有数据(表单数据+附件) 2.2 实例化retrofit 可以构造以下参数：
2.3 创建接口服务对象 IRetrofitView为2.1中定义Retrofit接口的类。
2.4 调用接口中的方法获取Call对象 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97d54b5251fadeb26d37330630216016/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62982aa6b896ff6e3e7ff929202f2af3/" rel="bookmark">
			Ngrok内网穿透配置详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在做一个互联网车险的一个项目，中间需要接收服务器的回调通知，这就不可避免的需要提供外网地址，代码部署到服务器上会无法实时调试，后来一个朋友告诉我ngrok可以实现内网穿透，即可以将内外的web服务器映射成外网ip，供远端调用,果断注册了ngrok帐号,地址是https://ngrok.com/,注册帐号可以看到这个页面，实际上这里说的很明白了，
第一步 需要启动ngrok，需下载对应的客户端，并解压大本地目录
第二步 需要配置授权token，下面的这个是我申请的token
第三步 创建本地转向服务器端口，我的服务器端口是8080，所以我会改成 ngrok http 8080
第四步 访问本地http://localhost:4000(如果配置了多个，会有所不同，端口号会是4001\40002……以此类推
第五步 访问第四步的地址后会出现两个url，一个是http的，一个是https的地址，一级域名是ngrok.com,二级域名是随机生成的，将此地址发布出去，其他客户端就可访问到本地的服务器了。
可能也会有看不明白的，下面我会简单介绍一下我的操作。
我本地的操作，下载一个客户端，我这边开发环境是window，所以下载了window版本的客户端，解压到本地目录，比如D:\ngrok，直接双击运行ngrok.exe，出现下面这个命令行窗口,首先是配置我的token，
如果token合法，会提示如下信息
接下来就可以映射本地服务器端口，我的服务器端口是8080,
敲回车后出现下面的页面就说明是没有问题的
浏览器中敲入:http://localhost:4040就可以查看映射的地址了：
如果还有不明白的，可以给我留言。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c1b35995953feb388f8db32dbbfeeff9/" rel="bookmark">
			音频相关参数的记录（MCLK、BCLK、256fs等等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、 拿512fs说话： 看图知道采样的位深是32bit（位），左右声道各占了8*32BCLK，那一个完整的LRCLK一共8*32*2=512BCLK。 其实xxxfs就是这么算出来的，也是固定的，当你定了几个channel，多少位深，就几乎可以确认是多少fs了。从主观的角度来看，fs的数值越大，那么一个完整的LRCLK越多，那承载的数据量就越大，随之的就是音质就会更加好。
上图是32位的采样，2channel，xxxfs的选择有： 128fs、256fs、512fs
如果是16bit的采样，2channel呢？ 16*2（channel）*2（每个LR有几个16BCLK组成） = 64fs 按照倍数的增加，会有如下的选择： 64fs、128fs、256fs、512fs
如果是24bit的采样，2channel呢？ 24*2（channel）*2（每个LR有几个16BCLK组成） = 96fs 按照倍数的增加，会有如下的选择： 96fs、192fs、384fs、768fs（这个级别的估计一般的ADC很难）
二、 那BCLK是怎么算的？ 例在Android系统中，播放的音频文件格式： sample_rate=44.1Khz，sample_length=16，channel=2时， 那么BCLK应该为2×44.1Khz×16=32xsample_rate=1.4112Mhz
MCLK存在着关系，这个一般要看芯片。如果存在这4倍的关系，那么： MCLK = 4*BCLK=5.6448Mhz 至于MCLK的选择还要看外部的晶振。
鉴于如上的，那它是xxxfs？ 正常是fs=MCLK/ sample_rate=5.6448*1000/44.1=128fs
fs=16*2*（LRCLK各几个16 BCLK组）=128fs，一共是4个。
如果现在你要对外部晶振进行选型了，现在是sample_rate=48Khz，sample_length=16，channel=2，我们选择512fs，那外部晶振MCLK要选择多大？ MCLK=fs*sample_rate=512*48=24.576Mhz
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2730fab193c46956ef9353d5e7f2fea1/" rel="bookmark">
			RxJava-入门就是那么简单
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 第一次接触RxJava是在学习Retrofit的时候,那个时候经常看到别人都是Retrofit+RxJava一起使用的,于是后来自己也上网研究了一下,经过一段时间的学习总算是把RxJava给弄懂了,在这里就分享一下我的使用心得,给想入门的同学引一引路.
概述 RxJava是什么 对于RxJava,官方给的说法是一个使用Java虚拟机观察序列异步和基于事件的程序库;绕过这些官方语言,以我自己的话来说,它就是一个用观察者模式对程序进行异步控制的这么一个库.
观察者模式 既然提到了RxJava的核心是观察者模式,那么这里就简单的说说什么是观察者模式.观察者模式完美的将观察者和被观察的对象分离开,在这种模式中有两个对象:观察者(Observer)和被观察者(Observerable),他们两个通过订阅(Subscribe)的方式产生联系,当两者建立起联系以后,那么当被观察者作出一些变化之后,观察者能够立即获知到,并根据被观察者作出的变化作出相应的反应. 举个例子:护士和病人即观察者和被观察者,当病人不舒服的时候就按铃,护士听到铃声以后赶来照顾病人,它们之间通过铃作为纽带把它们联系到一起,这样一来护士就不需要时时刻刻盯着病人
RxJava的优点 说了那么多,那到底RxJava有啥好处呢,异步和简洁应该是它最大的优点,它可以随时随地的切换线程,同时又能保证代码的清晰简明.至于它是怎么做到的,后面我会一点一点的来分析.
入门 环境搭建 1.RxJava的GitHub地址:https://github.com/ReactiveX/RxJava 2.RxAndroid的GitHub地址:https://github.com/ReactiveX/RxAndroid 3.导入Jar包
compile ‘io.reactivex.rxjava2:rxandroid:2.0.1’ compile ‘io.reactivex.rxjava2:rxjava:2.1.0’ compile ‘com.squareup.retrofit2:adapter-rxjava2:latest.version’
rxandroid是一个对rxjava的扩展库,这个库里包含了一些和Android有关的内容,下面我会具体介绍到 入门案例 实现RxJava的步骤分三步 第一步:创建被观察者(Observable) 第二步:创建观察者(Observer) 第三步:订阅(Subscribe),即让观察者和被观察者产生联系 基于以上理论,下面我们用代码来演示一下 1.创建Observable
Observable&lt;String&gt; observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() { @Override public void subscribe(@NonNull ObservableEmitter&lt;String&gt; e) throws Exception { e.onNext("123"); e.onComplete(); } }); 2.创建Observer
Observer&lt;String&gt; observer = new Observer&lt;String&gt;() { @Override public void onSubscribe(@NonNull Disposable d) { Log.i(TAG,"onSubscribe"); } @Override public void onNext(@NonNull String s) { Log.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2730fab193c46956ef9353d5e7f2fea1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a8cc9e8269a132572218b1a073fd988/" rel="bookmark">
			Word 2013 设置多级列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在写毕业论文，由于Word 2013 带有自动编号的功能，因此我一直没有自己动手设置多级列表，直到出现了下面的情况： 第一章 章标题 1.1 一级节标题 1.1.1 二级节标题 1.1.2 二级节标题 1.2 一级节标题 1.2.1 二级节标题 1.2.2 二级节标题 第二章 1.3 一级节标题 1.3.1 二级节标题 1.3.2 二级节标题 1.4 一级节标题 1.4.1 二级节标题 1.4.2 二级节标题
设置方法参看：Word2010 中多级列表的设置与使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a27966a9e0d6ba146624d937ddf5d02/" rel="bookmark">
			喜欢的书籍列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 算法导论 数学之美 C++ Primer java编程思想 javascript语言精粹 Go语言编程 深入浅出Nodejs MongoDB权威指南 Redis设计与实现 Docker源码分析 ECMAScript 6 入门廖雪峰的官方网站图说设计模式Docker — 从入门到实践Elasticsearch: 权威指南Git Book码农·Just Go!
http://www.cplusplus.com/reference/
https://d3js.org/ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e717132e17c4fb23e47eba4b1839e8f7/" rel="bookmark">
			HTML友情链接代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;div align="center"&gt; &lt;table width="980" height="35" border="0" align="center"&gt; &lt;tr&gt; &lt;td&gt; 友情链接：&amp;nbsp;&amp;nbsp; &lt;a target="_blank" href=" #"&gt;One&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href=" #"&gt;Two&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href="# "&gt;Three&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href=" # "&gt;Four&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href=" #"&gt;Five&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href="#"&gt;Six&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href="#"&gt;Seven&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href="#"&gt;Eight&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href="#"&gt;Nine&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href="#"&gt;Ten&lt;/a&gt; &amp;nbsp;|&amp;nbsp; &lt;a target="_blank" href="#"&gt;Eleven&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; HTML友情链接代码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84ac4ae81657bae36098fdd46958edea/" rel="bookmark">
			SSH连不上虚拟机的问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这几天工作任务不重，今早上班打算在liunx下运行下python脚本。打开VM，SSH突然连不上虚拟机了。网上试了很多方法都不行，最后花费2个小时解决了这一问题。
结合我的实际情况，问题解决如下：
1、开启SSH服务：service sshd start 2、关闭liunx防火墙：chkconfig iptables off
3、重启liunx:reboot
4、SSH连接虚拟机，输入地址、账号、密码，连接成功！
转载于:https://www.cnblogs.com/yinze/p/6860180.html
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/474/">«</a>
	<span class="pagination__item pagination__item--current">475/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/476/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>