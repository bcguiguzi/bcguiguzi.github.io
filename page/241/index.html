<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3ddc1005f6dcd45e9632e70ef740fc0/" rel="bookmark">
			Appium报错解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、Appium启动会话报错 使用手机OPPO Andorid 11的版本
An unknown server-side error occurred while processing the command. Original error: Error executing adbExec. Original error: 'Command ''D:\\Program Files (x86)\\android-sdk-windows\\platform-tools\\adb.exe' -P 5037 -s 3654ae33 shell pm clear com.android.settings' exited with code 255'; Stderr: 'Exception occurred while executing 'clear': java.lang.SecurityException: adb clearing user data is forbidden. at com.android.server.pm.ColorClearDataProtectManager.interceptClearUserDataIfNeeded(ColorClearDataProtectManager.java:87) at com.android.server.pm.OppoBasePackageManagerService$OppoPackageManagerInternalImpl.interceptClearUserDataIfNeeded(OppoBasePackageManagerService.java:481) at com.android.server.am.ActivityManagerService.clearApplicationUserData(ActivityManagerService.java:4659) at com.android.server.pm.PackageManagerShellCommand.runClear(PackageManagerShellCommand.java:2154) at com.android.server.pm.PackageManagerShellCommand.onCommand(PackageManagerShellCommand.java:239) at android.os.BasicShellCommandHandler.exec(BasicShellCommandHandler.java:98) at android.os.ShellCommand.exec(ShellCommand.java:44) at com.android.server.pm.PackageManagerService.onShellCommand(PackageManagerService.java:23384) at android.os.Binder.shellCommand(Binder.java:936) at android.os.Binder.onTransact(Binder.java:820) at android.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f3ddc1005f6dcd45e9632e70ef740fc0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c71d0759c69d6748d6e753366898ac5/" rel="bookmark">
			CentOS8部署（Vue &#43; Django）前后端分离项目详细版
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 CentOS8部署（Vue + Django）前后端分离项目详细版遇到的问题跨域解决的方法工具 1. 基本环境部署安装相关的依赖包安装Python 3.9.10安装Node环境安装nginx安装MySQL在CentOS8远程链接里新建poes数据库 2. 前后端项目搭建（Vue + Django），Nginx解决跨域失效问题修改Django配置文件，确保能够正常连接MySQL数据库安装Django依赖包Django 数据库迁移将已备份好的数据导入到MySQL数据库安装Vue脚手架依赖解释Vue项目打包遇到的种种问题前端Vue项目打包 3. 部分项目功能展示具体页面显示（以学生管理页面为例）添加对话框修改对话框删除对话框详情对话框分页功能分数可视化（折线图）分数可视化（饼状图）分数可视化（柱状图） 4. 总结前端框架后端框架结语参考资料 CentOS8部署（Vue + Django）前后端分离项目详细版 遇到的问题 将前端Vue项目打包：npm run build。Vue项目打包后跨域失效。 跨域解决的方法 前端通过Node解决跨域后端通过Django解决跨域通过nginx反向代理解决跨域（本次实验使用的方法） 工具 CentOS 8.5Python 3.9.10node v16.14.0npm 8.3.1Navicat Premium 15 这里已经默认你按照好CentOS8了，并且已经配置好网络等基本信息。
1. 基本环境部署 安装相关的依赖包 CentOS 8没有安装epel源的问题。安装epel源后可以问题解决
yum install epel-release 这里会出错，显示不能正常安装
上网搜到原因解释： CentOS Linux 8在2022年12月31日来到生命周期终点（End of Life，EoL）。即CentOS Linux 8操作系统版本结束了生命周期（EOL），Linux社区已不再维护该操作系统版本。所以原来的CentOS Linux 8的yum源也都失效了！最终导致此问题的产生。
所以我们更换CentOS Linux 8的yum源：
# 备份原生CentOS 8源操作 cd /etc/yum.repos.d/ mkdir bak mv CentOS-Linux-* bak # 下载安装CentOS 8源 wget -O /etc/yum.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c71d0759c69d6748d6e753366898ac5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6458521e5ebeae884468f50a83c907b6/" rel="bookmark">
			SpringDoc使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1.SpringDoc简介2.SpringDoc基础使用 1.SpringDoc简介 SpringDoc是一款可以结合SpringBoot使用的API文档生成工具
2.SpringDoc基础使用 POM文件
&lt;dependency&gt; &lt;groupId&gt;org.springdoc&lt;/groupId&gt; &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt; &lt;/dependency&gt; 创建OpenApiConfig配置类
配置类加上注解
@Configuration public class OpenApiConfig { @Bean public OpenAPI springShopOpenAPI() { //鉴权组件(随便起名的) SecurityScheme securityScheme = new SecurityScheme() .type(SecurityScheme.Type.HTTP) .scheme("bearer")//固定写法 .bearerFormat("JWT") .in(SecurityScheme.In.HEADER) .name("Authorization"); Components components = new Components() .addSecuritySchemes("bearer-jwt", securityScheme); //鉴权限制要求(随便起名的) SecurityRequirement securityRequirement = new SecurityRequirement() .addList("bearer-jwt", Arrays.asList("read", "write")); return new OpenAPI() .info(new Info().title("医院管理系统 API") .description("Spring HIS application") .version("v0.0.1")) .components(components) .addSecurityItem(securityRequirement) ; } } Controller的代码
@Tag(name = "床位表管理模块") @RestController @RequestMapping("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6458521e5ebeae884468f50a83c907b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1f529259a198a5ea5b9be46074f05fe5/" rel="bookmark">
			Android：分包配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、前言 如标题锁说，本篇文字主要总结Android分包的配置，不需要理解或深入，用的时候直接配置即可。通过splits配置gradle，使打包更区别化。
二、splits 的结构简析 1、splits 的存在位置 Splits 会映射为 com.android.build.gradle.internal.dsl.Splits 类，没有继承任何类。
2、如何运行 splits 主要是用于打包时的拆包，所以我们需要的是进行apk的打包编译。
// app:clean 为了先清空之前的文件 // app:aR 进行编译 release 包 // mac 使用 ./gradlew // window 使用 gradlew ./gradlew app:clean app:aR 三、splits 的属性 1、abi 类型：AbiSplitOptions描述：对 abi 进行分包处理，具体我们看下面 AbiSplitOptions 讲解。 2、AbiSplitOptions 类型 2.1 enable 描述：是否开启 abi 分包，默认不开启使用： splits { abi { enable true } } 效果图：
2.2 exclude 描述：排除不需要的架构。
使用：
abi { // 是否开启 enable true // 排除不必要的架构 exclude 'x86','arm64-v8a' } 效果图：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1f529259a198a5ea5b9be46074f05fe5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/461867ff5b95266b05fd97bc12dd6078/" rel="bookmark">
			vue不使用脚手架，基础写法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 说起来也搞笑，一直都是用脚手架，实际有个h5老项目，不用脚手架，一下子写不来了，所以记录下。
&lt;body&gt; &lt;div id="app"&gt; 内容 &lt;/div&gt; &lt;/body&gt; &lt;script src="../../resources/lib/vue.min.js"&gt;&lt;/script&gt; //引入vue文件 &lt;script&gt; var vm= new Vue({ el:"#app", data(){ reteurn:{} } }) &lt;/script&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9da3d39d04be99a6677630faaa87a0e9/" rel="bookmark">
			Nginx 配置旧域名重定向到新域名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx 里的 rewrite 模块是专门负责静态重写的。
该模块允许使用正则表达式改变 URI，并且根据变量来重定向以及选择配置。
基本用法是：rewrite patten replace flag。patten 是正则表达式，与 patten 匹配的 URL 会被改写为 replace，而 flag 是可选的，可以有如下标志：
last – 完成 rewrite，然后搜索相应的 URI 和位置 break – 中止 rewirte，不再匹配后面的规则 redirect – 返回 code 为 302 的临时重定向 permanent – 返回 code 为 301 的永久重定向 例如，要将旧域名重定向到新域名上：
server { listen 443 ssl; # ... server_name old.com; rewrite .* https://new.com; } 如果是跳转到新域名上时要保留路径，那么：
server { listen 443 ssl; server_name old.domain.com; # ... rewrite ^/(.*)$ https://new.domain.com/$1; } 还有一种方式，如果域名不是 www.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9da3d39d04be99a6677630faaa87a0e9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/359a65f63813e6684da9bf005ece3bba/" rel="bookmark">
			Visual Studio安装教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Visual Studio安装教程 前言：近来在学习《opencv3编程入门》，因为这本书里面都是由c++实现的，所以就下载了visual studio以备使用。
一、官网下载 官网下载地址：
https://visualstudio.microsoft.com/zh-hans/downloads/
因为是个人学习用途，所以我这里下载的是社区版本。
下载下来的是一个.exe文件
双击打开后，会加载一些东西。最后出现下面的界面
二、安装visual studio （一）更改安装路径 首先，我们要设置一下安装路径。因为visual studio占用的空间十分大，我们千万千万不要把它一股脑地安装在C盘，这会让我们本来就贫乏的C盘空间，雪上加霜。
在这里，切换到安装位置，将下述三项的路径改成D盘或其他非系统盘，这里图片是我已经改完了的。
（二）自定义安装组件 这时我们就可以自定义选择组件进行下载
因为我是需要使用C++，所以这里选择了使用C++的桌面开发和visual studio扩展开发
下面会显示下载所占的空间，供参考（我这里因为已经下载过了）
大家可以根据具体需求，选择自己需要下载的组件
选择好后，在右下角选择安装，就会出现下载界面，等下载完毕后如图所示，点击启动就可以使用啦~
最后汇总一下，visual studio安装中使用的内存情况：
D盘占用6.8G
C盘占用1.G
三、开始使用 进入visual studio开发界面，点击创建新项目。
这里我选择了新建一个c++的空项目
在这里定义你的项目名字，以及项目的存储位置（建议放在除C盘外的空间内）
最后点击创建就可以了
（四）创建第一个程序 进入项目界面后，选择右侧的源文件，右键添加—新建项
修改一下c++项的名称，然后点击添加
这样就创建好了
（五）万能的HelloWorld 在界面输入hello world代码
#include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; "Hello World" &lt;&lt; endl; return 0; } 点击上方的执行按钮
等待一会就会调出控制台，显示执行结果。
看到这里，你就可以正式开始接下来的学习啦~
结束语：简单说一下，作者也是初使用visual studio，也会和大家一起学习进步。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86d60701ca0e9a8e27c6d923a2554d61/" rel="bookmark">
			「NodeJs进阶」超全面的 Node.js 性能优化相关知识梳理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信对于前端同学而言，我们去开发一个自己的简单后端程序可以借助很多的nodeJs的框架去进行快速搭建，但是从前端面向后端之后，我们会在很多方面会稍显的有些陌生，比如「性能分析」，「性能测试」，「内存管理」，「内存查看」，「使用C++插件」，「子进程」，「多线程」，「Cluster模块」，「进程守护管理」等等NodeJs后端的知识，在这里为大家来分析一下这些场景与具体实现。
搭建基础服务 首先我们先来实现一个简单的Http服务器,为了演示方便这里我们使用express，代码如下：
const fs = require('fs') const express = require('express') const app = express() app.get('/', (req, res) =&gt; { res.end('hello world') }) app.get('/index', (req, res) =&gt; { const file = fs.readFileSync(__dirname + '/index.html', 'utf-8') /* return buffer */ res.end(file) /* return stream */ // fs.createReadStream(__dirname + '/index.html').pipe(res) }) app.listen(3000) 正常情况我们大部分的后端服务是联合db最终返回一些列的接口信息的，但是为了后面的一些测试，这里我们返回了一个文件，因为大一点的返回信息可以直观的感受我们的服务性能与瓶颈。
额外一点，在上面可以看到我们在注释的地方也使用了一个stream流的形式进行了返回，如果我们返回的是文件，第一种的同步读取其实相对更耗时，如果是个大的文件，会在内存空间先去存储，拿到全部的文件之后才会一次返回，这样的性能包括内存占用在文件较大的时候更为明显。所以如果我们做的是ssr或者文件下载之类的东西我们都可以以这样流的形式去做更加高效，至此，我们已经有了一个简单的http服务了，接下来我们对齐进行扩展。
性能测试、压测 首先我们需要借助测试工具模拟在高并发情况下的状态，这里我推荐两种压测工具。
ab 官方文档
webbench
autocannon
本次我们使用ab压测工具来进行接下来的操作，所以这里为大家介绍一下ab。那么ab呢是apache公司的一款工具，mac系统是自带这个工具的，安装教程呢大家就自行去查看，当然mac自带的ab是有并发限制的。
然后我们先随便来一条简单的命令再为大家分析一下具体的参数
ab -c200 -n1600 http://127.0.0.1:3000/index
上面这条命令的意思呢就是测试接口地址http://127.0.0.1:3000/index对齐每秒200个请求，并请求总数1600次这样的一个压测，然后我们看看这个工具的其他参数吧
上面的东西呢其实已经很直观了，最开头的部分就是每秒请求成功了多少个，其次就是请求地址、端口、路径、大小、这些其实不是很重要，我们在浏览器中自己也可以看到，我们主要需要注意的性能指标是下面这些参数：
Complete requests: 1600 # 请求完成成功数 这里判断的依据是返回码为200代表成功 Failed requests: 0 # 请求完成失败数 Total transferred: 8142400 bytes # 本次测试传输的总数据 HTML transferred: 7985600 bytes Requests per second: 2188.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86d60701ca0e9a8e27c6d923a2554d61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35e5ccf5f120ffc758b74e556e53fd4f/" rel="bookmark">
			C语言经典面试题10道（二）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		11.数组和链表的区别？ 答案：
数组：数据顺序存储，固定大小；
链表：数据可以随机存储，大小可动态改变。
12. void main()
{
char aa[10];
printf(“%d”,strlen(aa));
} 会出现什么问题？打印结果是是多少？
答案：sizeof()和初不初始化没有关系，strlen()和初始化有关，打印结果值未知。
13.给定结构 struct A
{
char t:4;
char k:4;
unsigned short i:8;
unsigned long m;
}; 问sizeof(A) = ?
答案：8
详解：char t:4;是代表使用位域结构，表示使用char的其中四位，char k:4;刚好可以把剩下四位用掉（假如不够则要重新使用一个char），所以一共是char(1)+short(2)+long(4)=7,字节对齐（char和short占一个字节，long占一个字节）后为8。
14. struct name1
{
char str;
short x;
int num;
} ;求sizeof(name1)?
答案：8
详解：char(1)+short(2)+int(4)=7，字节对齐（char和short占一个字节，int占一个字节）后为8。
15. struct name2
{
char str;
int num;
short x;
}; 求sizeof(name2)？
答案：12
详解：char(1)占第一个字节中的1，第一个字节剩下3不够int(4)，所以为了对齐，重新用一个字节，int(4)刚好占满这第二个字节，所以short(2)又要重新用一个字节（其实只用了前2），一共是4+4+4=12。
16.程序哪里有错误？ wap( int *p1,int *p2 )
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35e5ccf5f120ffc758b74e556e53fd4f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f01d0bf21d6c9b85baee97d2735de2f2/" rel="bookmark">
			win7下cuda8.0安装跑gpu版tensorflow
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要用深度学习做目标检测，先尝试了caffe，这会又要熟悉tensorflow了，简单写下配置过程吧，挺简单的：
0.win7 X64系统
1.安装vs2013
2.安装Anaconda3(需要里面的python环境）
3.下载CUDA8.0(https://developer.nvidia.com/cuda-downloads),下面两个exe文件都下载
补充说明：我电脑里原来是cuda7.5,故需要先卸载干净，我是这么做的，有需要的可以借鉴：
(1)把下图中的前5项用电脑管家全部卸载干净(图形驱动程序不需要卸载）
(2)删除C:\Program Files\NVIDIA GPU Computing Toolkit 文件夹
删除 C:\ProgramData\NVIDIA GPU Computing Toolkit 文件夹
删除C:\ProgramData\NVIDIA Corporation\CUDA Samples 文件夹
4.运行exe（注，若电脑上已经有了最新的显卡驱动程序，可以不用去装图形显卡驱动程序）
默认下一步到最后
5.再运行exe
默认下一步到最后
6.下载cuddn5.1(如果想要了解cuddn和cuda的区别可以看该博客http://blog.csdn.net/fangjin_kl/article/details/53906874
7.解压cuddn5.1，把如下的三个文件夹替换到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0夹下（该目录是我的cuda8.0的安装目录）
这里需要在系统变量里设置下面几个变量：
CUDA_PATH： C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0
CUDA_BIN_PATH： C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\bin
CUDA_LIB_PATH： C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\lib\x64
CUDA_PATH_V8_0： C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0
CUDA_SDK_BIN_PATH： C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0\bin\win64
CUDA_SDK_LIB_PATH： C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.0\common\lib\x64
CUDA_SDK_PATH： C:\ProgramData\NVIDIA Corporation\CUDA Samples\v8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f01d0bf21d6c9b85baee97d2735de2f2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/665c65b1d5a121587a9655603d0527f1/" rel="bookmark">
			Linux虚拟机网卡bond配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 前言一、bond概述1、bond概念2、bond优点 二、bond模式1、mode=0 (round-robin)2、mode=1 (active-backup)3、mode=2（XOR）4、mode=3（broadcast）5、mode=4（802.3ad）6、mode=5（balance-tlb）7、mode=6（balance-alb） 三、案例操作1、添加网卡2、修改网卡的配置文件3、添加配置文件4、关闭NetworkManager服务5、重启网络6、获取状态7、开启httpd服务访问网页8、关闭网卡查询数据流向关闭ens33关闭ens37 前言 我们日常访问网络的时候可能会出现信号不佳、网络丢失等问题，所以一张网卡访问网络的时候可能会出现问题。就像手机的双卡双待模式，虚拟机的网卡也可以使用多张网卡，一般常见的服务器都有2~4张网卡来进行网络服务的运行。
一、bond概述 1、bond概念 bond是将多块物理网卡虚拟为一块逻辑网卡，使多块网卡看起来像一块网卡，通过主从的配置来讲进行网络的运行维护
2、bond优点 linux系统下配置bond，通过网卡绑定可增加服务器可靠性，同时可增加网络带宽，提供稳定的网络服务
二、bond模式 网卡bonding模式共有0、1、2、3、4、5、6共7种，其中mode1、5、6不需要要交换机设置，mode0、2、3、4需要交换机设置
1、mode=0 (round-robin) 轮询策略，数据包在每个slave网卡上都进行数据传输，以逐包形式在两个物理网卡上转发数据。这种模式提供了数据的负载均衡和容错能力。
2、mode=1 (active-backup) 主备策略，只有一个slave被激活，只有当active的slave的接口down时，才会激活其它slave接口。主备模式下发生一次故障切换，在新激活的slave接口上会发送一个或者多个gratuitous ARP。主salve接口上以及配置在接口上的所有VLAN接口都会发送gratuitous ARP，需要在这些接口上配置了至少一个IP地址。VLAN接口上发送的的gratuitous ARP将会附上适当的VLAN id。本模式提供容错能力。
3、mode=2（XOR） 基于所选择的hash策略，本模式也提供负载均衡和容错能力
4、mode=3（broadcast） 广播策略，向所有的slave接口发送数据包，本模式提供容错能力
5、mode=4（802.3ad） 动态链路聚合，根据802.3ad标准利用所有的slave建立聚合链路。slave接口的出口取决于传输的hash策略，默认策略是简单的XOR策略，而hash策略则可以通xmit_hash_policy选项配置。
前提：每个slave网卡支持ethtool获取速率和双工状态
6、mode=5（balance-tlb） 自适应传输负载均衡：根据每个slave的负载(相对速度)决定从哪个接口发送数据包，从当前接口接收数据包。如果接收的slave接口故障，其它slave接口将接管它的mac地址继续接收。
前提：每个slave网卡支持ethtool获取速率。
7、mode=6（balance-alb） 自适应负载均衡：
前提：每个slave网卡支持ethtool获取速率
每个slave网卡支持启用时重新设置硬件地址 三、案例操作 将两张网卡绑定配置成一张虚拟网卡
1、添加网卡 2、修改网卡的配置文件 3、添加配置文件 4、关闭NetworkManager服务 5、重启网络 6、获取状态 7、开启httpd服务访问网页 使用ab命令来进行压力测试，模拟有多个IP登录并访问网页
8、关闭网卡查询数据流向 可以通过sar命令进行数据流向的查询
关闭ens33 关闭ens37 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37f26a25d61bc8f900b3effba4d030d1/" rel="bookmark">
			Vmware安装配置CentOS完整过程--linux环境配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是KookNut39，在CSDN写文，分享一些自己认为在学习过程中比较重要的东西，致力于帮助初学者入门，希望可以帮助你进步。兄弟们，好久不见！！！最近太太太忙了(其实是太懒)，所以没更新。
之前没有在虚拟机里面装个linux的虚拟机，今天装centOS，想装一个没界面的，感觉没界面的比较装逼，有界面的有windows玩了，谁成想，误打误撞装了个有界面的，，，顺便记录一下，目前我还没有做过多的测试，只是单纯的安装了一下，如果在装C/C++编译环境的过程中出现问题的话，我会在博客更新。
1.下载iso镜像，直接在Google搜索centOS，然后最上面出现的搜索结果，点击DownLoad。
2.DownLoad页面就是这样，我选择了CentOS8，然后点击x86_64这个选项。
3.然后点进来我人就懵了，我英语不太好，一时间不知道该如何选择，我抱着试一试的态度，点了第一个。
4.然后我选择了里面最大的那个iso去下载，我猜它可能是带了界面，或者它内容比较全，所以比较大？还好网速不错，一会就下好了
5.接着打开我早已下载好的Vmware16，大家如果没下载这个，可以自己去网上找一下，很简单的。然后接下点击创建新的虚拟机。
6.选择自定义，下一步。
7.这里应该都是默认好的，点击下一步即可。
8.选择稍后安装操作系统，点击下一步。
9.选择linux，然后选择版本，因为我下载的是CentOS 8，所以选择这个版本，然后点击下一步。
10.给虚拟机起个名字，随便起，自己喜欢啥就叫啥，然后点击浏览，确定自己想要安装的虚拟机位置，我这里选了自己专门存放的工具盘，点击下一步。
11.linux虚拟机，一般处理器数量就1就行了，直接下一步。后续如果想要修改也是可以的，这个没啥难度
12.内存选择，我这里选择了2GB，这也是可以自己决定，根据自己的主机内存，其实没必要太大，这个您可以先设置一个数，后面根据使用体验可以调整的。
13.我扫了一下这几个选项，感觉NAT还挺靠谱的，不管咋说先选上，不行了再改呗。。。
14.有推荐的选项，那直接无脑点击推荐的这个LSI Logic，然后下一步。
15.好家伙，有一个推荐，那这不得继续安排，选择SCSI，下一步。
16.选择创建新虚拟磁盘，下一步。
17.磁盘大小可以随机设置，根据自己需求，我这里就选择了这个建议大小，然后选择将虚拟磁盘拆分成多个文件，然后点击下一步。
18.直接下一步。
19.点击自定义硬件。
20.点击新CD/DVD，点击使用ISO映像文件，把自己刚刚下好的那个镜像文件选择上。
21.点击完成。
22.到这个界面之后，点击开启此虚拟机。
23.等待吧，无尽的等待。。。
24.我英语水平不行，但是直接English，毕竟英语比较装逼，单词不认识可以查嘛！
25.点击Root Password配置下密码，然后点击Done
26.点击Installation 这个选项。
27.人懒，点进来发现直接是默认配置好的，那就直接done
28.然后又是无尽的等待。。。
29.整好了，直接点击重启系统。
30.发现这里还是有一个什么东西像是警告，那就点进去看看。
31.好家伙，这英文直接不认识，反正无脑 I accept ，直接躺平就行了。
32.然后点击User Creation可以创建一个用户。
33.创建好之后就点击save
34.我勾选上了这个让当前账号具有管理用权限，然后点击done。
35.右下角点击登录
36.点击用户头像。
37.输入密码，点击蓝色按钮！！！
38.进来了，果然是有界面的，其实从登录界面就能看出来，这是我还是想装个纯命令行的。。。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cc5c15adac2acb7bd7beff1f9b766ba/" rel="bookmark">
			clickvisual技术学习与总结待续
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		clickvisual技术学习与总结待续
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d001cdfa8701b3c3d2c712ea1f7f6b3d/" rel="bookmark">
			Backtrader量化&amp;回测5——交易情况跟踪&amp;生成策略每日交易报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这一部分的API可以参考官网：https://www.backtrader.com/docu/strategy/
Backtrader的策略中有四个常用的函数：
notify_order(order)：订单状态变化时会触发这个函数notify_trade(trade)：交易状态变化时会触发这个函数notify_cashvalue(cash, value)：每过一个next()都会触发notify_fund(cash, value, fundvalue, shares)：每过一个next()都会触发 其中：notify_order(order)与notify_trade(trade)是需要触发订单和交易触发才可以执行，可以跟踪订单和交易情况
剩余的函数执行顺序是：next()-&gt;notify_cashvalue(cash, value)-&gt;notify_fund(cash, value, fundvalue, shares)，可以做每日报告
示例代码 from datetime import datetime import backtrader from loguru import logger import matplotlib.pyplot as plt from utils import get_k_data class MyStrategy1(backtrader.Strategy): # 策略 def __init__(self): # 初始化交易指令、买卖价格和手续费 self.close_price = self.datas[0].close # 这里加一个数据引用，方便后续操作 self.sma = backtrader.indicators.SimpleMovingAverage(self.datas[0], period=5) # 借用这个策略，计算5日的均线 def notify_order(self, order): # 当订单状态变化时触发 # 通知订单状态 if order.status in [order.Submitted, order.Accepted]: # 接受订单交易，正常情况 return if order.status in [order.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d001cdfa8701b3c3d2c712ea1f7f6b3d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9fa17dc1cb030a61ba9607e6a30980e1/" rel="bookmark">
			SQL语句对表中数据进行增删改操作[DML]
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 前言一、SQL添加数据语句二、SQL修改数据语句三、SQL删除数据语句总结 前言 整理一下SQL语句中增删改查操作的语句用法。先说一下简单的增删改操作，查询的话分类比较多，分开写。。。这也是为学习后端打基础，对数据库操作不会SQL语言是不行滴。重点把每个操作的第一个方法记住。
一、SQL添加数据语句 在进行添加时，首先要建一个表，这里我的表如下：
1.给指定列添加数据 INSERT INTO 表明（列名1，列名2...） VALUES(值1，值2...);
-- 给指定列添加数据 INSERT INTO 表明（列名1，列名2...） VALUES(值1，值2...); INSERT INTO stu ( id, NAME, age, sex, address, math, english, hire_date ) VALUES ( 7, '慢羊羊', 55, '男', '羊村', 34.32, 24.13, '2001-03-02' ); 添加结果：表中多了一行慢羊羊的数据
2.给所有列添加数据(列名可省略[可读性差]) 因为不知道每个数据的含义
-- 给所有列添加数据(列名可省略[可读性差]) INSERT INTO stu VALUES ( 8, '慢羊羊', 55, '男', '羊村', 34.32, 24.13, '2001-03-02' ); 3.批量添加 中间用‘逗号’隔开
-- 批量添加 INSERT INTO stu VALUES ( 9, '慢羊羊', 55, '男', '羊村', 34.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9fa17dc1cb030a61ba9607e6a30980e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de5b871a22162807b468577f203a0cfc/" rel="bookmark">
			对于一个字符串添加一个字符是否可以构成回文字符串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于一个字符串对其添加一个字符可以构成回文字符串吗 方法一：逆思维思考 对于添加一个字符可以构成回文字符串的话，那么删除一个字符也就可以构成回文字符串了，所以就可以对于这个字符串的每一个字符进行删除，然后在判断是不是回文字符串，如果是的话，那就可以，否则不可以
代码实现：
#include &lt;iostream&gt; #include &lt;string&gt; ​ //判断一个字符串是不是回文字符串 bool Check(const std::string&amp; str) { int len = str.size(); for (size_t i = 0; i &lt; len / 2; i++) { if (str[i] != str[len - i - 1]) { return false; } } ​ return true; } ​ int main() { std::string str; //char str1[1000]; //std::cin &gt;&gt; str1; //str = str1; bool flag; while (std::cin &gt;&gt; str) { for (size_t i = 0; i &lt; str.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de5b871a22162807b468577f203a0cfc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a16f45fd6c1b8e3cc530cd41ae9acc37/" rel="bookmark">
			基类指针与派生类指针的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结论：
①声明为指向基类对象的指针可以指向它的公有派生的对象，但是不允许指向它的私有派生的对象。（只适用于公有继承的情况）
②可以将一个声明为指向基类的指针指向其公有派生类的对象，但是不能将一个声明为指向派生各类对象的指针指向其基类的一个对象。（只适用于基类指针指向派生类对象，不能反过来操作）
结论①的代码示例:
结论②的代码示例:
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ac30e5abe4a405a588dde9fc759efe/" rel="bookmark">
			线程池七大参数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		线程池七大参数分别是corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler
(1)corePoolSize：线程池中常驻核心线程数
(2)maximumPoolSize：线程池能够容纳同时执行的最大线程数
(3)keepAliveTime：多余的空闲线程存活时间
(4)unit：keepAliveTime的时间单位
(5)workQueue：任务队列，被提交但尚未执行的任务
(6)threadFactory：表示生成线程池中的工作线程的线程工厂
(7)handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数(maximumPoolSize)时如何拒绝。
从源码中可以看出，线程池的构造函数有7个参数，分别是corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler。下面会对这7个参数一一解释。
一、corePoolSize 线程池核心线程大小
线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。任务提交到线程池后，首先会检查当前线程数是否达到了corePoolSize，如果没有达到的话，则会创建一个新线程来处理这个任务。
二、maximumPoolSize 线程池最大线程数量
当前线程数达到corePoolSize后，如果继续有任务被提交到线程池，会将任务缓存到工作队列（后面会介绍）中。如果队列也已满，则会去创建一个新线程来出来这个处理。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。
三、keepAliveTime 空闲线程存活时间
一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定
四、unit 空闲线程存活时间单位
keepAliveTime的计量单位
五、workQueue 工作队列
新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：
①ArrayBlockingQueue
基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。
②LinkedBlockingQuene
基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而基本不会去创建新线程直到maxPoolSize（很难达到Interger.MAX这个数），因此使用该工作队列时，参数maxPoolSize其实是不起作用的。
③SynchronousQuene
一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。
④PriorityBlockingQueue
具有优先级的无界阻塞队列，优先级通过参数Comparator实现。
六、threadFactory 线程工厂
创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等
七、handler 拒绝策略
当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：
①CallerRunsPolicy
该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务。
②AbortPolicy
该策略下，直接丢弃任务，并抛出RejectedExecutionException异常。
③DiscardPolicy
该策略下，直接丢弃任务，什么都不做。
④DiscardOldestPolicy
该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/958078bcfeba6c2b0bfee9d0d870bc50/" rel="bookmark">
			Android中从一个Activity返回上一个Activity数据刷新
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 在Android Studio中使用Listview显示数据，并点击item后跳转到另一个Activity进行数据的修改编辑，点击返回键后返回到上一个Activity，同时数据进行更新显示。
问题描述 在进行修改后，返回上一个Activity之后，数据没有更新，还是原来未修改的数据，需要返回再次返回后重新进入该Activity之后，数据才可以更新显示。
原因分析： 在修改界面修改数据之后，在点击返回时，程序只是通过finish()结束了当前的activity，对于上一个activity来说，数据并没有进行更新，还是之前未修改过的数据。
解决方案： 第一个Activity中原本的代码如下：
public class ManageActivity extends BaseActivity { @BindView(R.id.rl_back) RelativeLayout rlBack; @BindView(R.id.tv_title) TextView tvTitle; @BindView(R.id.lv_data)//listview ListView lvData; DengjiAdapter dengjiAdapter;//适配器 Dengji dengji; @Override protected int getLayoutId() { return R.layout.tab_guihua; } @Override protected void init() { dengji = (Dengji) getIntent().getSerializableExtra("detail"); tvTitle.setText("查询物品"); rlBack.setOnClickListener(new View.OnClickListener() {//返回首页 @Override public void onClick(View v) { finish(); } }); try { List&lt;Dengji&gt; dengjiList = App.dbManager.findAll(Dengji.class); List&lt;Dengji&gt; dengj = new ArrayList&lt;&gt;(); if (dengjiList !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/958078bcfeba6c2b0bfee9d0d870bc50/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48dbe28bc7a6f4afd144bba8f51d5661/" rel="bookmark">
			AndroidStudio开发APP和ESP8266进行联网传输数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android Studio开发APP篇 一、准备工作二、安卓APP开发三、进行联网测试源码下载链接 最近在用ESP8266做一个联网开发，准备做两个版本的来吧，一个是手机APP版本的，另一个是基于OneNET云的版本的来吧，具体的要用来实现什么项目还没有决定，应该做一些经典的项目吧，比如智能家居之类的吧，有这方面项目的可以在评论区和我说说哈，我准备自己搞搞练练手来。 这次的话就准备先做个APP版本，APP的难点主要在于手机APP怎么去实现联网的功能，这个功能可能对于一些软开的同学来说比较简单吧，毕竟上课就是学这个的，但是我电子类出身的人，做这个确实有一问三不知的感觉，做了几天看了很多书籍视频和还有一些大牛的博客，自己搞了一套出来，并且测试成功了，心理有点激动，写篇博客记录一下，下一步的话就准备写个ESP8266的测试用例来了，再再下一步就是搞个项目来试试了。
一、准备工作 准备工作其实不多就两个软件下载安装一下，一个是Android Studio，一个是网络调试助手我用的是NetAssist，只要是能调试网络就都行。
我的思路是这样的，将ESP8266作为服务器，手机APP根据ESP8266的IP地址和端口号去进行连接，连接成功后传输数据，下发指令和接收单片机采集的数据。
安装包在这里：
Android Studio安装包
链接：https://pan.baidu.com/s/1nE4Z4kjhaHiN5lKFfvvE6g
提取码：duol
NetAssist：
链接：https://pan.baidu.com/s/1jvtaYG_eibdvkJasalq2pw
提取码：03bj
失效了可以去在这个资源里面去下载
https://download.csdn.net/download/qq_45488746/85355880
安装的方式大家可以参考这个：https://blog.csdn.net/tao_789456/article/details/118093106
这里主要做联网测试也不多强调这些东西哈。有疑问大家评论区一起相互交流学习哈。
二、安卓APP开发 我这里主要是分为两个类，一个就是MainActivity这个就是主程序执行的入口了
还有一个就是TCP_Test类，里面写了关于连接服务器IP和端口，传输数据等方法。
还有一个就是网络权限要开放出来
&lt;uses-permission android:name="android.permission.INTERNET"/&gt; 将网络权限放到AndroidManifest.xml中去
MainActivity类，主要是做一些控件管理和执行TCP连接
MainActivity的一些属性
public class MainActivity extends AppCompatActivity { private EditText edit_port; private EditText edit_ip; private Button btn_connect; private Button btn_open; private Button btn_close; private TCP_Test tcp_client; 具体实现
TCP连接测试代码大家可以根据自己的需求去替换即可主要都是用到啥发送和接收数据这些东西
@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //获取控件 setContentView(R.layout.activity_main); btn_close = findViewById(R.id.btn_close); btn_connect = findViewById(R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/48dbe28bc7a6f4afd144bba8f51d5661/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/240/">«</a>
	<span class="pagination__item pagination__item--current">241/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/242/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>