<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e8d1d772bdbb5a5f42d9f14ec781e7/" rel="bookmark">
			数字设计之取整
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		向上取整（ceil） 无论正负数，向着数值更大的方向取整
例如
ceil (0.5) = 1
ceil (0.1) = 1
ceil (-0.1) = 0
ceil (-0.5) = 0
类似于加1，去掉小数部分
向下取整（floor） 与向上取整方向相反，无论正负数，向着数值更小的方向取整
类似于减1，然后去掉小数部分
floor(0.5) = 0
floor(0.1) = 0
floor(-0.1) = -1
floor(-0.5) = -1
向0取整 也称为去尾取整
int(0.5) = 0
int(0.1) = 0
int(-0.1) = 0
int(-0.5) = 0
四舍五入取整 round(0.5) = 1
round(0.1) = 0
round(-0.1) = 0
round(-0.5) = -1
重点 在数字设计中
向上取整：a + 1，再截位
向下取整：a-1，再截位
四舍五入：a+0.5，再截位
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/80e8d1d772bdbb5a5f42d9f14ec781e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9dff6299b14c6f6a6ee9934bc736aba1/" rel="bookmark">
			C&#43;&#43;类模板实例化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++类模板实例化 文章目录 C++类模板实例化1. 简介 2. 类模板实例化2.1 隐式实例化（Implicit instantiation）2.2 显示实例化（Explicit instantiation）2.3 类模板中的静态成员 1. 简介 该文章主要总结C++类模板实例化的方法。类模板的实例化包含两种：
隐式实例化（Implicit instantiation）显示实例化（Explicit instantiation） 2. 类模板实例化 类模板本身不是类型、对象或任何其他实体。仅包含模板定义的源文件不会生成任何代码。为了出现任何代码，必须实例化模板：必须提供模板参数，以便编译器可以生成实际的类（或函数，来自函数模板）。
类模板必须实例化才能作为一个类来声明和定义类对象，类模板实例化成为模板类，同一个类模板不同的实例之间相互独立。
2.1 隐式实例化（Implicit instantiation） C++代码中发生类模板隐式实例化的条件：
当代码使用类模板定义对象时，需要在上下文中引用完全定义类型。（例如，当构造此类型的对象时，而不是在构造指向此类型的指针时。 ）当类型的完整性影响代码时，并且该特定类型尚未显式实例化时，就会发生隐式实例化。 此外针对类模板成员适用以下准则：
除非该成员在程序中使用，否则它不会被实例化，也不需要定义。 下面举例进行说明隐式实例化
template&lt;class T&gt; struct Z // 模板定义 { void f() {} void g(); // 不会被定义 }; template struct Z&lt;double&gt;; // 显示实例化 Z&lt;double&gt; Z&lt;int&gt; a; // 隐式实例化 Z&lt;int&gt; Z&lt;char&gt;* p; // 无任何实例化生成 p-&gt;f(); // 隐式实例化 Z&lt;char&gt; and Z&lt;char&gt;::f(). // Z&lt;char&gt;::g() 不会被声明和定义 错误的实例化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9dff6299b14c6f6a6ee9934bc736aba1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f46f8ce668c34092bb3e6da61f6615b2/" rel="bookmark">
			史上最全股票指标图文详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1、成交量（VOL）指标：
2、成交额指标：
3、MACD指标（指数平滑异动平均数）：
4、资金博弈：
5、资金趋势：
7、DDX：
8、DDY：
9、DDZ：
10、KDJ：
11、RSI：
12、BIAS：
13、CCI：
14、WR：
15、BOLL：
16、EXPMA：
17、TRIX：
18、VR：
19、DMI：
20、DPO：
21、DMA：
22、ENE：
1、成交量（VOL）指标： 定义：股市中的成交量，是指股票或者大盘当日成交量的总手数。成交量指标一般是用柱状图来表示。左面的坐标值与柱子的横向对应处，就是当日当时的成交总手。如当天收盘价高于当天开盘价，成交柱呈红色；反之，成交柱呈绿色。
计算公式：Vi ＝ Value ／／Value为当日成交量总手数。
1'、均量线(VOL)指标：
定义：均量线(VOL)将一定时期内的成交量相加后平均，在成交量的柱条图中形成较为平滑的曲线，是反映一定时期内市场平均成交情况的技术指标。
描述：累加N天成交量，除以N天，即得均线指标。因指标数组的前N－1天不够计算均线指标，所以置为0.
计算公式：VOL=∑nVi/N ／／Vi:i日成交量手数。
／／ N=选定的时间参数,如10或30；
2、成交额指标： 定义、公式，几乎与成交量一模一样，这里不做阐述。
3、MACD指标（指数平滑异动平均数）： 定义：MACD（Moving Average Convergence and Divergence)是Geral Appel 于1970年提出的，利用收盘价的短期（常用为12日）指数移动平均线与长期（常用为26日）指数移动平均线之间的聚合与分离状况，对买进、卖出时机作出研判的技术指标。
描述：MACD称为指数平滑异动移动平均线，是从双指数移动平均线发展而来的，由快的指数移动平均线（EMA12）减去慢的指数移动平均线（EMA26）得到快线DIF，再用2×（快线DIF-DIF的9日加权移动均线DEA）得到MACD柱。MACD的意义和双移动平均线基本相同，即由快、慢均线的离散、聚合表征当前的多空状态和股价可能的发展变化趋势，但阅读起来更方便。当MACD从负数转向正数，是买的信号。当MACD从正数转向负数，是卖的信号。当MACD以大角度变化，表示快的移动平均线和慢的移动平均线的差距非常迅速的拉开，代表了一个市场大趋势的转变。MACD指标是由两线一柱组合起来的，DIF为快速线，DEA为慢速线。柱状图为MACD
公式：
12日EMA的计算：
EMA（12） = 前一日EMA（12） X 11/13 + 今日收盘价 X 2/13
26日EMA的计算：
EMA（26） = 前一日EMA（26） X 25/27 + 今日收盘价 X 2/27
差离值（DIF）的计算：
快速线：DIF = EMA（12） - EMA（26） 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f46f8ce668c34092bb3e6da61f6615b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6fa98f93319a78f28806d3ea1c3d329d/" rel="bookmark">
			航测无人机las点云数据生成DEM
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “
做航测的同僚都知道，Pix4D或者CC（ContextCapture）都可以生成DSM，往往高程点提取以及土方计算都需要用到DEM，PhotoScan软件可以提出地面点并只应用地面点连接三角网，然而分类效果差，生成的DEM不管是平整度还是精度，都不理想。而传统等高线生DEM需要耗费较长时间，以下提供一种参考方法，供大家探讨。
”
1
点云数据
航测类软件大多可以生成点云数据，如Pix4D，PhotoScan，CC等，此次点云数据为citymapper2相片基于CC生产的Las点云。
2
筛选地面点
筛选地面点主要是基于点云处理软件，常见的有Lidar360.CLOUDcompare，terrasolid等，由于目的为只删选地面点，因此我们选择浏览方便，操作更为简单compare软件。
1.打开点云
2.过滤点云
此选项提供了三种算法，陡坡，丘陵地，平地，以及附加选项，如梯田等阶梯状地貌，建议勾选附加选项。
3.提取结果
提取结果只显示两类，一类为地面点，一类为非地面点。
以下为提取效果（依次为地面点与非地面点）
保存地面点
3
点云编辑
1.筛选结果往往有遗漏，如较小的土丘，茂密的灌木丛等。因此往往需要编辑。
编辑点云我们选择inpho的DTmaster模块
如要求较高，在主模块中导入DOM可以作为参考。打开点云如下：
2. 打开高程显示与地貌渲染
3.新建断裂线图层
4.以下标记出来的工具从左往右依次是创建线（断裂线描绘）工具，点云重新插值（快捷键为ctrl+alt+t），围栏选择，漏洞填补，与断裂线选择工具。
DTmaster中可以进行填补漏洞，重新插值等编辑，对于较陡峭的地方，需要用到断裂线辅助编辑。以下为编辑实例：
大体平整后，输出编辑好的Las点云。
双击路径选择新路径，或者覆盖源文件。
4
DEM生产
点云生DEM一般是基于点云生成三角网，也可以生成等高线，再转换成三角网，这里选择第一种方法，用Global Mapper20.1.0软件生成三角网，并输出所需要的的格式。点开后如下图
由于我们的点云为过滤之后的点云，因此会存在大量由于缺失非地面点而形成的空洞，在无数据差值选项中拖拽至Loose，则在三角网生成过程中，软件会自动调补空洞。可以根据要求生成不同格网间距。
格网类型一般选择高程属性，或应用点云的RGB信息。
可以生成等高线，或导入矢量数据在3d视角中观察生成的mesh是否平整以及套和情况。
输出所需格式即可。
END- 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44367e56f24ce668fb7f7768e07207f/" rel="bookmark">
			快速解决vscode突然无法打开问题（应用程序无法启动）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vscode突然打不开，如下：
解决方案
进入c:\Users#YourUserName#\AppData\Roaming\中删除Code文件夹即可。#YourUserName#是你的电脑用户名或Administrator。（出现这种情况，一般是在locale.json中设置语言时出现错误所导致的。卸载及重装vscode不会影响这个文件夹，因此不能解决问题。）进入ananconda navigator，重装vscode即可（点install，下图是已经install过后的），重装后点击launch就可以进入了~~~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/796cb34297de5126701ad31a1e9f43d3/" rel="bookmark">
			你了解红黑树么？告诉你一个不一样的红黑树，说点有意思的吧！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先看如下两个问题： 问题1、红黑树的键值可以重复么？
问题2、红黑树必须有键值么？
关于红黑树的介绍网上非常多，红黑树的应用也非常广泛。问一下度娘，她会告诉你各种各样的实现方法，C和C++版本都有，linux内核使用的版本也有。代码都大同小异，就是插入或删除时如何修正，如何搞平衡。很多文章图文并茂、写实而生动，当你在脑海里试图左旋一把，右旋一把搞平衡时，基本也到了精神崩溃的边缘。
如何维护祖孙三代父、祖父、叔叔以及兄弟间的平衡，如何搞好家庭关系，是个头疼的问题。如果把红黑树比作一个族谱的话，可能开始你是高祖，下个节点插进去后就变成了太宗，随着族系的繁衍最后你可能变成个哀帝。开始A是B爸爸，过会B又变成A爸爸，甚至是爷爷，叔叔、兄弟，你说乱不乱，烧脑烧脑，气人不气人。
套用郭德纲在相声中对于谦说的话：到了咱们这个年纪，谁是谁爸爸都无所谓了。台上无大小，台下立规矩，送给台上的各种二叉树。
这里先介绍一个朴实无华的网站：可视化的数据结构和算法教学，非常不错，里面有经典数据结构的动态展现，可以将你从各种旋转中解救出来。如下图：
说了这么多回到本文开头的两个问题： 问题1：红黑树的键值可以重复么？
大部分人可能认为不可以重复，因为重复的键值会冲突或没有现实意义。其实是可以重复的。为了表达对二叉树的敬意，这里连续插入多个2。使用上面安利的网站，建立了一个很2的红黑树。如下图：
上面的红黑树键值都相等，非常不可思议，但它确实是棵红黑树。
那么这颗很2的红黑树的现实意义是什么，能应用到什么地方？当然有，而且很广泛，这个地方就是定时器，对于大部分服务器程序，基本都要实现自己的定时器，从而完成一些特殊的重复性工作，比如nodejs的引擎libuv库中的定时器，nginx中的定时器、以及redis的键值有效期判断等。。。。
当管理多个定时器时就会存在键值相等的节点，也就是到期时间相等的节点。这时候如何判断谁先执行呢？
下面是libuv定时器实现的部分关键代码：
// libuv定时器使用回调函数来比较key的大小，这里的key就是到期时间timeout static int timer_less_than(const struct heap_node* ha, const struct heap_node* hb) { const uv_timer_t* a; const uv_timer_t* b; a = container_of(ha, uv_timer_t, heap_node); b = container_of(hb, uv_timer_t, heap_node); if (a-&gt;timeout &lt; b-&gt;timeout) return 1; if (b-&gt;timeout &lt; a-&gt;timeout) return 0; /* Compare start_id when both have the same timeout. start_id is * allocated with loop-&gt;timer_counter in uv_timer_start().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/796cb34297de5126701ad31a1e9f43d3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68ce9c1e34c06491c393b47ca0cd2e39/" rel="bookmark">
			pandas 数据透视表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		**我们可以使用df.pivot_table() ，来实现同样的功能，参数如下
index：行索引，传入原始数据的列名columns：列索引，传入原始数据的列名values: 要做聚合操作的列名aggfunc：聚合函数** 数据透视表 学习目标 知道什么是透视表掌握Pandas透视表（pivot_table）的使用方法 1 Pandas 透视表概述 透视表是一种可以对数据动态排布并且分类汇总的表格格式。或许大多数人都在Excel使用过数据透视表，也体会到它的强大功能，而在pandas中它被称作pivot_table。
数据透视表（Pivot Table）是一种交互式的表，可以进行某些计算，如求和与计数等。所进行的计算与数据，和数据透视表中的排列有关。之所以称为数据透视表，是因为可以动态地改变它们的版面布置，以便按照不同方式分析数据，也可以重新安排行号、列标和页字段。每一次改变版面布置时，数据透视表会立即按照新的布置重新计算数据。另外，如果原始数据发生更改，则可以更新数据透视表。在使用Excel做数据分析时，透视表是很常用的功能，Pandas也提供了透视表功能，对应的API为pivot_tablePandas pivot_table函数介绍：pandas有两个pivot_table函数 pandas.pivot_tablepandas.DataFrame.pivot_tablepandas.pivot_table 比 pandas.DataFrame.pivot_table 多了一个参数data，data就是一个dataframe，实际上这两个函数相同 pivot_table参数中最重要的四个参数 values,index,columns,aggfunc，下面通过案例介绍pivot_tabe的使用 2 零售会员数据分析案例 2.1 案例业务介绍 业务背景介绍
某女鞋连锁零售企业，当前业务以线下门店为主，线上销售为辅
通过对会员的注册数据以及的分析，监控会员运营情况，为后续会员运营提供决策依据
会员等级说明
① 白银: 注册(0)
② 黄金: 下单(1~3888)
③ 铂金: 3888~6888
④ 钻石: 6888以上
数据分析要达成的目标
描述性数据分析使用业务数据，分析出会员运营的基本情况 案例中用到的数据
① 会员信息查询.xlsx
② 会员消费报表.xlsx
③ 门店信息表.xlsx
④ 全国销售订单数量表.xlsx
分析会员运营的基本情况
从量的角度分析会员运营情况：
① 整体会员运营情况（存量，增量）
② 不同渠道（线上，线下）的会员运营情况
③ 线下业务，拆解到不同的地区、门店会员运营情况
从质的角度分析会员运营情况：
① 会销比
② 连带率
2.2 会员存量、增量分析 每月会员数量的存量和增量是最基本的指标，通过会员数量考察会员运营情况
加载数据：会员信息查询.xlsx，加载时间较久，耐心等待 import pandas as pd custom_info = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68ce9c1e34c06491c393b47ca0cd2e39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/22cc9aad3028ea0631c13d6cf1e44581/" rel="bookmark">
			WGS84地理坐标系和CGCS2000坐标相互转换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.以下位代码直接调用就可以，中央子午线需要查看网址经纬度中央子午线对照表。需要geotools和opengis和kotlin需要的jar包。下载链接：https://pan.baidu.com/s/1AZnt3YHk9CyofYdvgLRaHQ 提取码：ak47 /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package org.fh.controller.fhoa; import cn.hutool.core.lang.Tuple; import org.apache.shiro.authz.annotation.RequiresPermissions; import org.geotools.geometry.jts.JTS; import org.geotools.referencing.CRS; import org.geotools.referencing.crs.DefaultGeographicCRS; import org.junit.Test; import org.opengis.geometry.MismatchedDimensionException; import org.opengis.referencing.FactoryException; import org.opengis.referencing.crs.CoordinateReferenceSystem; import org.opengis.referencing.operation.MathTransform; import org.opengis.referencing.operation.TransformException; import kotlin.jvm.internal.Intrinsics; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; import javax.validation.constraints.NotNull; import java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/22cc9aad3028ea0631c13d6cf1e44581/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ce1d565fbb545d3462ffec7a12e7e0e6/" rel="bookmark">
			VsCode 常用拓展
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Better Comments
Bookmarks
Chinese(Simlified)Language
Go
PHP Debug
PHP intelephense
PHP intelliSense
Pylance
Python
Vim
GitLens
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ea34c0318f76138057040f722c4891d/" rel="bookmark">
			Springboot 配置文件读取顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springboot 配置文件读取顺序： 如果在不同的目录中存在多个配置文件，它的读取顺序是： 1、config/application.properties（项目根目录中config目录下）
2、config/application.yml
3、application.properties（项目根目录下）
4、application.yml
5、resources/config/application.properties（项目resources目录中config目录下）
6、resources/config/application.yml
7、resources/application.properties（项目的resources目录下）
8、resources/application.yml
注：
1、如果同一个目录下，有application.yml也有application.properties，默认先读取application.properties。
2、如果同一个配置属性，在多个配置文件都配置了，默认使用第1个读取到的，后面读取的不覆盖前面读取到的。
3、创建SpringBoot项目时，一般的配置文件放置在“项目的resources目录下”
4、app启动时，项目会先从application-dev.properties加载配置， 再从application.properties配置文件加载配置，如果有重复的配置， 则会以application.properties的配置为准。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f41783a110e18c0e9475894025fad6c4/" rel="bookmark">
			Golang 图片缩略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		https://github.com/nfnt/resize
图片裁剪 func ImageResize() { file, err := os.Open("test-1.png") if err != nil { log.Fatal(err) } // decode jpeg into image.Image img, _, err := image.Decode(file) if err != nil { log.Fatal(err) } file.Close() // resize to width 1000 using Lanczos resampling // and preserve aspect ratio kuan := img.Bounds().Dx() // gao := img.Bounds().Dy() // fmt.Println(kuan) fmt.Println(gao) m := resize.Resize(200, 0, img, resize.Lanczos3) //m := resize.Resize(1000, 0, img, resize.Lanczos3) out, err := os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f41783a110e18c0e9475894025fad6c4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e7df9d51cd0c07c89f41953b70ed5324/" rel="bookmark">
			如何解决VSCode中编写c&#43;&#43;时出现includepath的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方法一：编写c_cpp_propertise.json文件 ”CTRL+SHIFT+P“打开command palettee
搜索C/C++并点击Edit Configuration(JSON)
在includePath下填写需要包含的路径
这种方法的弊端：这种包含路径的方法是一种局部方法，也就是只对当前工作区的文件有效，每次写工程都要重新编写
解决方法二：编写setting.json文件 “CTRL+，”打开设置项
搜索setting.json，随便点击一个Edit in setting.json
此时会跳到setting.json文件，先删除跳转过来自动添加的属性(因为我们是通过点击Edit in setting.json进入的，系统默认你要添加某些属性)
然后按住”CTRL+SPACE“查找C_Cpp.default.includePath属性，并编辑。
这种方法是在全局进行includePath进行设置，设置以后编写任何C++程序都会自动在c_cpp_propertise.json文件中包含默认includePath。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db4b4ca2ca82487caad78d2b12a2714a/" rel="bookmark">
			pandas 数据类型及相互转化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Pandas 数据类型 学习目标 了解Numpy的特点应用Pandas 数据类型转换掌握Pandas 分类数据类型使用方法 1 Pandas数据类型简介 1.1 Numpy 介绍 Numpy（Numerical Python）是一个开源的Python科学计算库，用于快速处理任意维度的数组。
Numpy支持常见的数组和矩阵操作。对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。
Numpy使用ndarray对象来处理多维数组，该对象是一个快速而灵活的大数据容器。
比如我们现在对下面表格中的数据用numpy的ndarray类型来存储
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OGRcglgZ-1630413601843)(img\score.png)]
import numpy as np # 创建ndarray score = np.array([ [80, 89, 86, 67, 79], [78, 97, 89, 67, 81], [90, 94, 78, 67, 74], [91, 91, 90, 67, 69], [76, 87, 75, 67, 86], [70, 79, 84, 67, 84], [94, 92, 93, 67, 64], [86, 85, 83, 67, 80] ]) print(score) print(type(score)) # 输出结果如下 [[80 89 86 67 79] [78 97 89 67 81] [90 94 78 67 74] [91 91 90 67 69] [76 87 75 67 86] [70 79 84 67 84] [94 92 93 67 64] [86 85 83 67 80]] &lt;class 'numpy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db4b4ca2ca82487caad78d2b12a2714a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7815fb44c20f51ea3175912cfa4e9c3f/" rel="bookmark">
			【c&#43;&#43;】Opencv Mat类详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. Mat类常用成员函数和成员变量 由于 Mat 类使用的非常广泛，使用的形式也非常之多，这里只对较为常用的成员函数和成员变量做出了整理；
1.1 构造函数 （1）默认构造函数 cv::Mat::Mat() 默认构造函数：生成一个矩阵并由OpenCV提供的函数(一般是Mat::create() 和 cv::imread() )来分配储存空间。
Mat类可以分为两个部分：矩阵头和指向像素数据的矩阵指针
矩阵头：包括数字图像的矩阵尺寸、存储方法、存储地址和引用次数等，矩阵头的大小是一个常数，不会随着图像的大小而改变，但是保存图像像素数据的矩阵则会随着图像的大小而改变，通常数据量会很大，比矩阵头大几个数量级。这样，在图像复制和传递过程中，主要的开销是由存放图像像素的矩阵而引起的。因此，OpenCV使用了引用次数，当进行图像复制和传递时，不再复制整个Mat数据，而只是复制矩阵头和指向像素矩阵的指针，例如：
cv::Mat a ; //默认构造函数，创建矩阵头 a = cv::imread("test.jpg"); //读入图像，矩阵指针指向该像素数据 cv::Mat b = a ; //复制　上面的a，b有各自的矩阵头，但是其矩阵指针指向同一个矩阵，也就是其中任何一个改变了矩阵数据都会影响另外一个。那么，多个Mat共用一个矩阵数据，最后谁来释放矩阵数据呢？
这就是引用计数的作用，当Mat对象每被复制一次时，就会将引用计数加1，而每销毁一个Mat对象（共用同一个矩阵数据）时引用计数会被减1，当引用计数为0时，矩阵数据会被清理。
（2）常用构造函数——1 cv::Mat::Mat(int rows,int cols,int type) 重载的构造函数，这也是常用构造函数之一，在创建对象同时，提供矩阵的大小（rows，行数；cols ，列数），以及存储类型（type）
该类型表示矩阵中每一个元素在计算机内存的存储类型，如CV_8UC3，具体含义为“3通道8位无符号数”。
eg：
Mat src(10,10,CV_32FC3); //表示src是一个10*10的矩阵，且矩阵元素以32位float型存储 类似，OpenCV还提供了一种Size() 数据结构来构造Mat对象
（3）常用构造函数——2 cv::Mat::Mat(Size size,int type ) Size类等效于一个成对数据，size::Size(cols,rows)，特别注意 cols和rows的位置
eg：
Mat src1(3, 4, CV_32FC3); Mat src2(Size(3, 4), CV_32FC3); cout &lt;&lt; "src1.rows=" &lt;&lt; src1.rows &lt;&lt; " src1.cols=" &lt;&lt; src1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7815fb44c20f51ea3175912cfa4e9c3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38450a1ce82eeda64b449b620ba8fa32/" rel="bookmark">
			【正点原子Linux连载】第四十章 字符设备驱动开发 -摘自【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1）实验平台：正点原子阿尔法Linux开发板
2）平台购买地址：https://item.taobao.com/item.htm?id=603672744434
2）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-300792-1-1.html
3）对正点原子Linux感兴趣的同学可以加群讨论：935446741
4）关注正点原子公众号，获取最新资料更新
第四十章 字符设备驱动开发
本章我们从Linux驱动开发中最基础的字符设备驱动开始，重点学习Linux下字符设备驱动开发框架。本章会以一个虚拟的设备为例，讲解如何进行字符设备驱动开发，以及如何编写测试APP来测试驱动工作是否正常，为以后的学习打下坚实的基础。 40.1 字符设备驱动简介
字符设备是Linux驱动中最基本的一类设备驱动，字符设备就是一个一个字节，按照字节流进行读写操作的设备，读写数据是分先后顺序的。比如我们最常见的点灯、按键、IIC、SPI，LCD等等都是字符设备，这些设备的驱动就叫做字符设备驱动。
在详细的学习字符设备驱动架构之前，我们先来简单的了解一下Linux下的应用程序是如何调用驱动程序的，Linux应用程序对驱动程序的调用如图40.1.1所示：
图40.1.1 Linux应用程序对驱动程序的调用流程
在Linux中一切皆为文件，驱动加载成功以后会在“/dev”目录下生成一个相应的文件，应用程序通过对这个名为“/dev/xxx”(xxx是具体的驱动文件名字)的文件进行相应的操作即可实现对硬件的操作。比如现在有个叫做/dev/led的驱动文件，此文件是led灯的驱动文件。应用程序使用open函数来打开文件/dev/led，使用完成以后使用close函数关闭/dev/led这个文件。open和close就是打开和关闭led驱动的函数，如果要点亮或关闭led，那么就使用write函数来操作，也就是向此驱动写入数据，这个数据就是要关闭还是要打开led的控制参数。如果要获取led灯的状态，就用read函数从驱动中读取相应的状态。
应用程序运行在用户空间，而Linux驱动属于内核的一部分，因此驱动运行于内核空间。当我们在用户空间想要实现对内核的操作，比如使用open函数打开/dev/led这个驱动，因为用户空间不能直接对内核进行操作，因此必须使用一个叫做“系统调用”的方法来实现从用户空间“陷入”到内核空间，这样才能实现对底层驱动的操作。open、close、write和read等这些函数是由C库提供的，在Linux系统中，系统调用作为C库的一部分。当我们调用open函数的时候流程如图40.1.2所示：
图40.1.2 open函数调用流程
其中关于C库以及如何通过系统调用“陷入”到内核空间这个我们不用去管，我们重点关注的是应用程序和具体的驱动，应用程序使用到的函数在具体驱动程序中都有与之对应的函数，比如应用程序中调用了open这个函数，那么在驱动程序中也得有一个名为open的函数。每一个系统调用，在驱动中都有与之对应的一个驱动函数，在Linux内核文件 include/linux/fs.h中有个叫做file_operations的结构体，此结构体就是Linux内核驱动操作函数集合，内容如下所示：
示例代码40.1.1 file_operations结构体
1588 struct file_operations { 1589 struct module *owner; 1590 loff_t (*llseek) (struct file *, loff_t, int); 1591 ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); 1592 ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); 1593 ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); 1594 ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); 1595 int (*iterate) (struct file *, struct dir_context *); 1596 unsigned int (*poll) (struct file *, struct poll_table_struct *); 1597 long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); 1598 long (*compat_ioctl) (struct file *, unsigned int, unsigned long); 1599 int (*mmap) (struct file *, struct vm_area_struct *); 1600 int (*mremap)(struct file *, struct vm_area_struct *); 1601 int (*open) (struct inode *, struct file *); 1602 int (*flush) (struct file *, fl_owner_t id); 1603 int (*release) (struct inode *, struct file *); 1604 int (*fsync) (struct file *, loff_t, loff_t, int datasync); 1605 int (*aio_fsync) (struct kiocb *, int datasync); 1606 int (*fasync) (int, struct file *, int); 1607 int (*lock) (struct file *, int, struct file_lock *); 1608 ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); 1609 unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); 1610 int (*check_flags)(int); 1611 int (*flock) (struct file *, int, struct file_lock *); 1612 ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); 1613 ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); 1614 int (*setlease)(struct file *, long, struct file_lock **, void **); 1615 long (*fallocate)(struct file *file, int mode, loff_t offset, 1616 loff_t len); 1617 void (*show_fdinfo)(struct seq_file *m, struct file *f); 1618 #ifndef CONFIG_MMU 1619 unsigned (*mmap_capabilities)(struct file *); 1620 #endif 1621 }; 简单介绍一下file_operation结构体中比较重要的、常用的函数： 第1589行，owner拥有该结构体的模块的指针，一般设置为THIS_MODULE。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/38450a1ce82eeda64b449b620ba8fa32/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7b3c1e4662fd71cd51f881ba0bd77e31/" rel="bookmark">
			网络地址转换协议——NAT（恐怕是最全的版本）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前天我说第二天要跟大家讲一下NAT的，结果放假有些懒，所以就放在今天更新，希望大家不要凶我，哈哈哈。
目录
一、什么是NAT
1.NAT简介
2.NAT作用
3.NAT内网地址的范围
4.主要应用方向:
5.NAT的优点：
二、NAT的几种类型
三、NAT类型的对应实验
1.静态NAT
代码
PC机设置 ​
ping测试
​ 2.动态NAT--PAT
代码
PC机设置
ping测试
三.Easyip
代码
PC机设置
ping通测试
四.静态PAT
代码
服务器设置
​​ PC机设置
FTP上传测试
总结：
一、什么是NAT 1.NAT简介 NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。
这种方法需要在专用网（私网IP）连接到因特网（公网IP）的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址（公网IP地址）。这样，所有使用本地地址（私网IP地址）的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。
另外，这种通过使用少量的全球IP地址（公网IP地址）代表较多的私有IP地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC 2663中有对NAT的说明。
2.NAT作用 将内部（私有）地址转换成外部（共有）地址
3.NAT内网地址的范围 A:10.0.0.0-10.255.255.255
B:172.16.0.0-172.31.255.255
C:192.168.0.0-192.168.255.255
4.主要应用方向: 1.没有足够的公网P连接到Internet
2.当更换ISP需要重新编址
3.合并两个使用重叠地址空间的内部网络
4.使用单个IP地址支持基本的负载分担
5.NAT的优点： 1.节省了公网IP地址
2.能够处理编址方案重叠的情况
3.网络发生改变时不需要重新编址
4.隐藏了真正的IP地址
二、NAT的几种类型 类型特指静态NAT一个内网地址对一个公网地址动态NAT——PAT多个内网地址对多个公网地址easyip多个内网地址对一个接口静态PAT一对一，但是外网映射内网的服务 三、NAT类型的对应实验 出口路由器上需要配置默认路由
iproute0.0.0.0 0.0.0.0指向运营商对接的路由器IP
1.静态NAT 代码 R1： [001]int g0/0/0//进入接口 [001-GigabitEthernet0/0/0]ip add 192.168.1.1 24//配置ip和子网掩码长度 [001-GigabitEthernet0/0/0]un shu//开启接口 [001-GigabitEthernet0/0/0]int g0/0/1//进入接口 [001-GigabitEthernet0/0/1]ip add 202.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7b3c1e4662fd71cd51f881ba0bd77e31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7712875e5a23ec29955076cdeb7dc4ff/" rel="bookmark">
			ArcMap出图小技巧分享（附练习数据）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ArcMap一个重要的功能是出图！！！！！
因为图片对于一些文字描述来说更为直观，所以掌握一些出图技巧也是极为重要的，不仅能让我们在数据处理过程快速得到我们想要的图层，也可以让图层看起更加精美好看哦。
当我们进入ArcMap界面时映入眼帘的首先是这个默认白白的显示背景，我想更改成护眼的绿色或者我想改变背景颜色，这样在布局视图时背景颜色可以和图层颜色互相配合，给人以更好的视觉效果！！！！怎么操作呢？
在图层空白处右键点击数据框属性。
点击框架属性卡下面的背景中间上面那个按钮打开背景选择器，选择中间喜欢的颜色哦。
小编选择护眼的绿色，效果如下：
但是当打开另外一个地图文档时这个背景颜色还是会变成默认的白色。
下面以广西省年降水量空间插值出图作为例子进行其他出图设置（插值方法我选择的是普通克里金）。
如图是广西省每个地级市的点位置数据（已经根据公共字段空间连接具有了年降水量字段）
直接使用工具箱插值分析的克里格插值后生成的图像如下所示：
这个图像的处理结果范围是这些点的四至范围的矩形，很明显不是我们想要的广西省范围插值，我们其实想要的是下面这个插值范围。
这时候我们可以点击菜单栏上面的地理处理下的环境选项。
点击处理范围，选择范围图层为与图层“广西省”相同。
这时候我们进行空间插值得到的是下面这样的结果：
这个设置的意思就是处理范围是“广西省”图层的四至范围，这个分析结果不是不可以用，而是这样的话我们还要进行按掩膜提取这一道工序才能得到我们想要的插值范围，麻烦死了…所以这个也不是我们想要的插值范围，那怎么办，不急，环境设置下面还要很多设置选项哦。
我们在环境设置继续往下拉，找到栅格分析，在掩膜选项下选择“广西省”，这样系统在插值结束后会自动帮我们进行按掩膜提取哦，插值结果如下图：
只要我们在环境设置里面设置这两个范围，我们插值结果直接就可以出来了，是不是方便了很多。但是乍一看结果图觉得颜色不是很好看，并且分级数量太多了，这些都是小问题，直接右键插值结果属性，选择符号系统下面的分类，设置分类标准和分类数量，最后再选择一种自己喜欢的颜色就行啦。
这是我自己的审美哦（不喜勿喷，重要的是技巧分享哦~）
END - 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93def0633dffe07f282cc75238aae831/" rel="bookmark">
			pip is configured with locations that require TLS/SSL
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我这儿是出现在 centos6.8 上安装 python3.7 以后，pip 无法正常 install 安装依赖模块。
[root@centos68 insight-tool]# pip3 --version pip 10.0.1 from /usr/local/python3.7/lib/python3.7/site-packages/pip (python 3.7) [root@centos68 insight-tool]# pip3 install -r requirement.txt pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available. Collecting pygrok==1.0.0 (from -r requirement.txt (line 1)) Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'SSLError("Can't connect to HTTPS URL because the SSL module is not available.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93def0633dffe07f282cc75238aae831/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcc502c9f5c9b83bf8718bc6ff1f11ad/" rel="bookmark">
			PAT乙级练习题1019 数字黑洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目： 给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。
例如，我们从6767开始，将得到
7766 – 6677 = 1089
9810 – 0189 = 9621
9621 – 1269 = 8352
8532 – 2358 = 6174
7641 – 1467 = 6174
… …
现给定任意4位正整数，请编写程序演示到达黑洞的过程。
输入格式： 输入给出一个(0, 104)区间内的正整数N。
输出格式： 如果N的4位数字全相等，则在一行内输出“N – N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。
输入样例1： 6767 输出样例1： 7766 – 6677 = 1089 9810 – 0189 = 9621 9621 – 1269 = 8352 8532 – 2358 = 6174 输入样例2： 2222 输出样例2： 2222 – 2222 = 0000 思路： 用字符串接收数据，排序后转换为数字做运算，再转换回字符串输出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fcc502c9f5c9b83bf8718bc6ff1f11ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b75c30d42ebef814ae5baff35f76ace/" rel="bookmark">
			Fragment的基本用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Fragment简介 碎片是一种可以嵌在Activity中的UI片段，是一个小型的Activity，又称Activity片段。Fragment并不能单独使用，需要嵌套在Activity中使用。尽管它拥有自己的生命周期，但是还是会受到宿主Activity的生命周期的影响。 二、创建一个Fragment 1.静态加载Fragment （1）创建Fragment布局文件
left_fragment.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;Button android:id="@+id/button" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:text="Button"/&gt; &lt;/LinearLayout&gt; right_fragment.xml
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:background="#B9D6E3"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_gravity="center" android:textSize="25sp" android:text="This is right Fragment"/&gt; &lt;/LinearLayout&gt; （2）自定义一个Fragment类,继承Fragment或者他的子类,重写onCreateView()方法 在该方法中调用:inflater.inflate()方法加载Fragment的布局文件,接着返回加载的view对象
public class LeftFragment extends Fragment { @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { //加载布局 View view = inflater.inflate(R.layout.left_fragment, container, false); return view; } } public class RightFragment extends Fragment { @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b75c30d42ebef814ae5baff35f76ace/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/291/">«</a>
	<span class="pagination__item pagination__item--current">292/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/293/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>