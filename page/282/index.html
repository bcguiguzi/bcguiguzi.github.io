<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cf64b1b1b5f72fa493d357e5e9e6cea/" rel="bookmark">
			Ubuntu 20.04/21.04 不能检测到外部HDMI显示器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有段时间没进Ubuntu系统了，今天接上外部显示器的时候，显示没有检测到信号。以前是好的，很奇怪怎么突然就不行了，重新拔插，换显示器也没有用。而Windows系统下是好的。刚开始以为是内核版本的问题，换回老5.4.0-8x内核，20.04版本也不行。升级到21.04也不行。
网上有说要换成Nvidia驱动，换成495，试了不行。更老的435版本好像没有了，最老的是460版本，后来看到有说把BIOS 中的secure boot关闭，心想怎么会和这个有关系。抱着一线希望试了下，把secure boot关闭后，还真可以了。重启后，把secure boot再打开，外部显示器还是能检测到的。奇怪了。
Ubuntu用xwayland不能用xrandr设置分辨率，看来还是只能用xorg。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1586af680c55f2eb80519dccf0356a31/" rel="bookmark">
			Windows Server 2016 安装.NET Framework 3.5 错误处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Windows Server 2016 安装.NET Framework 3.5 错误 WinServer2016默认安装.net 3.5会出现以下错误。
安装错误选择离线安装
Windows Server 2016离线安装.NET Framework 3.5方式有多种下面介绍2种：
一。从微软官网下载安装文件进行安装
https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=25150
二。通过 NetFx3.cab 文件安装
NetFx3.cab下载链接：https://pan.baidu.com/s/1O24nLgXhehHveae25p9SLg 密码：amgu
安装方法：下载NetFx3.cab后将其放于C盘WINDOWS文件夹下（C:\Windows）
点击“开始”找到“Windows PowerShell”右击“以管理员身份运行”，输入如下命令：
dism.exe /online /add-package /packagepath:C:\WINDOWS\netfx3.caB
等待安装完成即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ce51b282bcb03e3b53a71bd6e57640d/" rel="bookmark">
			typescript&#43;sequelize&#43;mysql基础查询实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		涉及到的库:
sequelize我们都知道它是一个orm持久层框架,所以就是基于面向对象的操作方式,本文讲解的就是入门的单表操作,sequelize在初始化的时候需要做的除了链接数据库之外,还要代理所有的实体类,在所有实体类上加上自己的crud方法,这样我们要操作时只需要导入对应的实体类即可,下面上我封装的数据库链接管理对象:
import { Options } from 'sequelize'; import { Sequelize } from 'sequelize-typescript' import MyError from '../utils/myError'; import logger from '../utils/logger'; export class DatabaseManager { private static manager?: DatabaseManager = null; private dbInstance?: Sequelize = null; private dbInstanceMap?: Map&lt;string, Sequelize&gt; = new Map&lt;string, Sequelize&gt;(); private dbConfig?: Options = null; private dbConfigs?: Options[] = []; private constructor(dbConfig: Options); private constructor(dbConfigs: Options[]); private constructor(arg: Options &amp; Options[]) { if (Array.isArray(arg)) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ce51b282bcb03e3b53a71bd6e57640d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4665c2ed840736272334c582e07223da/" rel="bookmark">
			约瑟夫环问题求解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		约瑟夫问题 提示：写完文章后，目录可以自动生成，如何生成可参考右边的帮助文档 文章目录 约瑟夫问题一、问题描述需求分析 二、解决方法1.使用静态循环链表2.所有代码 单向循环链表实现结构体实现全部代码 总结 一、问题描述 约瑟夫问题的一种描述是：编号为1,2,…,n的n个人按顺时针方向围坐一圈，每人持有一个密码(正整数)。一开始任选一个正整数作为报数上限值m，从第一个人开始。按顺时针方向自1开始顺序报数，报到m时停止报数。报m的人出列，将他的密码作为新的m值，从他在顺时针方向上的下一个人开始重新从1报数，如此下去，直至所有人全部出列为止。试设计程序求出出列顺序
需求分析 1.创建一个存储结构储存相关数据（单向循环列表与顺序结构）。
2.要求输入一个正整数作为报数上限值M。
3.每个人都有一个密码，如果某人被选中，则该人的密码将成为新的M值继续下一轮游戏，直至全部选完。
4.选中的人将会被从存储结构中删除。
5.最终按选出的顺序将每个人的编号打印出来。
二、解决方法 1.使用静态循环链表 结构体定义
#define MaxSize 100 //定义一个结构体，存放人的编号和密码 typedef struct node{ int data;	//存放数据 int pass;	//密码 int link;	//下一人的索引 }StaticNode; //定义一个结构体数组，即静态链表 typedef struct { StaticNode Nodes[MaxSize]; int newptr; }StaticLinkList; 2.所有代码 判断该人是否会被击杀，击杀需要从该链表去除掉
代码如下（示例）：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define MaxSize 100 //定义一个结构体，存放人的编号和密码 typedef struct node{ int data; int pass; int link; }StaticNode; //定义一个结构体数组，即静态链表 typedef struct { StaticNode Nodes[MaxSize]; int newptr; }StaticLinkList; int List_Insert(StaticLinkList *Space,int Slink,int i,int x,int ); void InitSpace(StaticLinkList *Space); void InitList(StaticLinkList *Space,int Slink); void init_data(StaticLinkList *Space,int Slink,int people,int *all_pass); void Show_list(StaticLinkList *Space); int print_Slist(StaticLinkList *Space,int Slink,int people,int *result,int max); int main(){ int people = 0; //总人数 int max = 0; //第一个密码 printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4665c2ed840736272334c582e07223da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0cac60d87f2f9da893ad7ab992624238/" rel="bookmark">
			node&#43;koa&#43;jsonwebtoken鉴权jwt实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		涉及到的库: 如果对jwt不熟悉的话可以去了解一下前置知识:node实现jwt
主要是依靠jsonwebtoken的两个api:
生成token: sign()
校验token: verify()
这是我封装后的jwtUtils:
import jwt from 'jsonwebtoken'; import { sha256 } from "./cryptoUtils"; import { Context } from "koa"; import logger from './logger'; import emitter from './emitter'; import { HttpStatus } from '../middlewares/responseHandler'; export interface JwtOptions { secret: string; expiresIn: number; excludePath: Array&lt;RegExp&gt;; } export enum TokenErrorType { TOKEN_EXPIRED_ERROR = 'TokenExpiredError', JSON_WEB_TOKEN_ERROR = 'JsonWebTokenError' } class JwtUtils { public secret: string; public expiresIn: number; public excludePath: Array&lt;RegExp&gt;; private static instance: JwtUtils = null; public constructor(options: JwtOptions) { const { secret, expiresIn, excludePath } = options; logger.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0cac60d87f2f9da893ad7ab992624238/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fbe321feb56512932746d70d39c82db/" rel="bookmark">
			购物系统-网上书店 javaweb jsp&#43;Servelt&#43;JDBC连接数据库(源码分享)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、实现的功能
二、运行出来的结果
1、首先是一个登录页面
2、进入主界面
3、前台系统（浏览图书功能）
4、后台系统（书架维护功能）
三、实现讲解
四、代码分享
购物系统都大差不差，添加商品到购物车，购物车结算，本文是一个网上书店项目，如果需要购买的是其他商品，也可以来看看，思路什么的都是一样的，只要修改表中的属性和内容就行。
一、实现的功能 使用idea编写，运用了sqlyog操作数据库。
实现了添加商品到购物车，以及购物车结算功能
通过JDBC连接数据库，实现了数据库的增删改查
二、运行出来的结果 1、首先是一个登录页面 根据用户名和密码（从数据库中获取比对）登录
2、进入主界面 左边相当于导航栏，把用户端（前台系统）和商家（后台系统）的操作放在了一个页面
3、前台系统（浏览图书功能） 图书书单页：这里主要是点击书号进去可以添加该商品到购物车中或查看购物车
商品详情页：选择放入购物车中，跳转到购物车页面
购物车页面：点击继续购物返回到图书书单，点击结账按钮
结账页面：填写信息（保存至数据库中）
4、后台系统（书架维护功能） 书架维护详情页：此部分就是对数据库中的数据进行增删改查
添加图书页（增） ：添加语文这本书
修改图书页：在图书书架页面点击书号，直接跳转修改页面
删除直接点击要删除图书的后面删除按钮即可。
三、实现讲解 三层架构
表示层（JSP） ：用户界面，向业务逻辑层发送请求。
业务逻辑层（Servlet）：接收用户指令，进行逻辑处理，将需要连接数据库的业务交给数据库进行处理，同时也将逻辑层的处理结果传递给表示层，显示给用户。
数据访问层（DAO）：对数据库进行增删改查操作。
src下面的bean文件夹中：
src下的servlet文件夹：
web文件夹下的jspye页面：
四、代码分享 百度网盘（里面book.sql是数据库中的内容，Demo3是用idea写的）
链接：https://pan.baidu.com/s/1DPNGB2tr6gQex2_UqQFkrQ 提取码：c7r4
或者后台私信我~
注：本项目是跟着中国大学上的Java Web 开发技术 南通大学 王春明老师的视频写出来的，老师在视频中是以将课本内容的形式，融汇贯通写出了一个网上书店项目，有想要系统学习的小伙伴可以去学一学。还有就是老师也教了添加图书的照片，但是我没弄好，就没有添加图片这一项。
如果还有什么问题欢迎私信交流探讨！
如果觉得文章不错，点个赞鼓励鼓励我呀
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a5f6d7dcd7966e3cffe09ddbcb895536/" rel="bookmark">
			量化投资之工具篇一：Backtrader从入门到精通（2）-重要概念以及平台的使用技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一篇文章从总体上介绍了backtrader的功能和使用方法，这篇文章将从局部进行更加细致的讨论，为后续我们使用backtrader打下更加坚实的基础。
目录
一些重要概念
数据源（data feed）
数据源的传递
数据源的快捷访问
数据源的缺省访问
万物皆为数据源
参数
Lines
Lines声明
如何访问数据源中的Lines
Line的长度
Lines和参数的继承
索引0和-1
切片
延迟索引
Lines的耦合（coupling）
操作符
平台的使用
Line迭代器
Indicators的额外方法
最小周期（Minimum Period）
启动和运行
数据源（data Feed）
继承的strategy类
Cerebro
总结
一些重要概念 数据源（data feed） backtrader策略运行的重要基础上数据源，如果没有数据，策略也就没有执行的逻辑基础。
数据源的传递 在backtrader中，数据源是以数组的形式或者对数组的快捷访问的方式提供给strategy（策略）作为成员变量使用的。这句话怎么理解呢？翻译一下，就是：
1、strategy这个类里面有个成员变量datas是个数组，用于存储数据源。数据源按照加入的先后顺序保存在datas中。策略在执行过程，会使用这些数据。上一篇文章中我们测试的策略中都会使用数据源中的close价格作为策略判断的依据。
2、访问数据源可以通过访问数组的方式，或者对数组的快捷方式访问。比如：
def __init__(self): # Keep a reference to the "close" line in the data[0] dataseries self.dataclose = self.datas[0].close self.dataclosetest = self.data0.close 其中datas[0].close就是数组访问方式，self.data0.close就是快捷访问方式，两者保存的数据完全一样，如下：
array('d', [4869.459, 4869.411, 4843.062, 4933.726, 4992.829, 4972.132, 4970.013, 5013.522, 4991.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a5f6d7dcd7966e3cffe09ddbcb895536/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0c669183ccebe234561dba0f1b351a0/" rel="bookmark">
			【2021-11-16】Struts 2 &#43; Tomcat，总是报错 一个或多个加载器启动失败 java.lang.NoClassDefFoundError: javax/servlet/Filter
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tomcat 从 10.x 版本开始，使用最新 Servlet API 5.0（2020-09-07 发布）版本，后者是 Jakarta EE 9 的一部分。引用的原
javax.* 包，全部重命名为
jakarta.* 降级到 Tomcat 9.x（9.x 的最高版本在截至本文修订前为 9.0.55）即可正确通过编译。
温馨提醒 目前，Struts 2 框架已经较少使用。若是为了维护老项目或应付考试，可以简单学习，无需过于深入。
当然，并不是说学习这些框架就完全没有意义。它们背后的一些重要思想，在日后的学习与工作中，也许可以借鉴。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae0b743d434382784a2971ee436faadf/" rel="bookmark">
			powershell_字体颜色高亮配置(by official doc(PSReadLineModule))/多种颜色值参考表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 refenrence link`Color`Set color values for multiple types The valid keys include: 颜色值表达推荐颜色表参考 配置效果 refenrence link Set-PSReadLineOption (PSReadLine) - PowerShell | Microsoft Docs PSReadLineOption可以配置的选项包括:
Set-PSReadLineOption [-EditMode &lt;EditMode&gt;] [-ContinuationPrompt &lt;String&gt;] [-HistoryNoDuplicates] [-AddToHistoryHandler &lt;System.Func`2[System.String,System.Object]&gt;] [-CommandValidationHandler &lt;System.Action`1[System.Management.Automation.Language.CommandAst]&gt;] [-HistorySearchCursorMovesToEnd] [-MaximumHistoryCount &lt;Int32&gt;] [-MaximumKillRingCount &lt;Int32&gt;] [-ShowToolTips] [-ExtraPromptLineCount &lt;Int32&gt;] [-DingTone &lt;Int32&gt;] [-DingDuration &lt;Int32&gt;] [-BellStyle &lt;BellStyle&gt;] [-CompletionQueryItems &lt;Int32&gt;] [-WordDelimiters &lt;String&gt;] [-HistorySearchCaseSensitive] [-HistorySaveStyle &lt;HistorySaveStyle&gt;] [-HistorySavePath &lt;String&gt;] [-AnsiEscapeTimeout &lt;Int32&gt;] [-PromptText &lt;String[]&gt;] [-ViModeIndicator &lt;ViModeStyle&gt;] [-ViModeChangeHandler &lt;ScriptBlock&gt;] [-PredictionSource &lt;PredictionSource&gt;] [-PredictionViewStyle &lt;PredictionViewStyle&gt;] [-Colors &lt;Hashtable&gt;] [&lt;CommonParameters&gt;] Color 如果要配置颜色,则是选择-Colors选项
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae0b743d434382784a2971ee436faadf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41da02ae01c315e9b13c6903eb90a1c3/" rel="bookmark">
			微信小程序中可以使用calc 函数用于动态计算长度值。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；任何长度值都可以使用calc()函数进行计算；calc()函数支持 "+", "-", "*", "/" 运算；calc()函数使用标准的数学运算优先级规则 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/930e2baa1dc7db8b2c88c3502cfac84c/" rel="bookmark">
			利用循环队列模拟舞伴配对问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用循环队列模拟舞伴配对问题：
1、利用循环队列模拟舞伴配对问题。在舞会上，男、女各自排成一队。舞会开始时。依次从男队和女队的队头各出一人配成舞伴。如果两队初始人数不等，则较长的那一队中未配对者等待下一轮舞曲。
2、假设初始男、女人数及性别已经固定，舞会的轮数从键盘输入。
试模拟解决上述舞伴配对问题。
3、从屏幕输出每一轮舞伴配对名单，如果在该轮有未配对的，能够从屏幕显示下一轮第一个出场的未配对者的姓名。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct Queue{ int Front; int Rear; char elem[100][100]; int Queuesize; }Queue; void Creat_Queue(Queue &amp;Q) {//建立一个队列 int n,i; Q.Front=Q.Rear=0; printf("请输入跳舞人数:"); scanf("%d",&amp;n); Q.Queuesize=n+1; printf("请输入各跳舞人名："); for(i=0;i&lt;n;i++) scanf("%s",&amp;Q.elem[i]); Q.Rear=n; } int QueueEmpty(Queue Q) {//判断队列是否为空 if(Q.Front==Q.Rear) return 1; else return 0; } void DeQueue(Queue &amp;Q,char *str) {//删除队头元素 strcpy(str,Q.elem[Q.Front]); Q.Front=(Q.Front+1)%Q.Queuesize; } void GetQueue(Queue Q,char *str) {//取队首元素，队头指针不改变 strcpy(str,Q.elem[Q.Front]); } void Judge_Queue(Queue &amp;M,Queue &amp;W) {//舞伴配对 int n; char str1[100],str2[100]; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/930e2baa1dc7db8b2c88c3502cfac84c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a02e540672c5d1775d055522ea6510d/" rel="bookmark">
			python2.7 下安装scikit-image
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 python2.7 默认的pip版本为8.1.1，这个版本太老。
2 下载pip-10.0.1-py2.py3-none-any.whl
3 pip pip-10.0.1-py2.py3-none-any.whl
4. 此时查看pip版本：pip --version
有错误：
5. sudo gedit /usr/bin/pip
6. from pip import main
修改为：
from pip._internal import main
7. sudo pip install scikit-image
注意加sudo , 否则权限不够
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/84551eb1af0be15c541669b33a525c07/" rel="bookmark">
			QT 在Linux下面编写一个串口同步通信的demo(QserialPort)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： QT 编写串口同步通信(使用QserialPort)。
主要代码： 由于我这边的设备使用的485通信，有多个从站，使用异步通讯的时候处理数据不是很方便。
#include "testcompro.h" #include "ui_testcompro.h" TestComPro::TestComPro(QWidget *parent) : QMainWindow(parent), ui(new Ui::TestComPro) { ui-&gt;setupUi(this); m_serialPort = new QSerialPort(); //初始化UI initUI(); //获取设备上的串口 m_portNameList = getPortNameList(); //把串口添加到combox ui-&gt;cb_comlist-&gt;addItems(m_portNameList); connect(ui-&gt;btn_Open,&amp;QPushButton::clicked,this,&amp;TestComPro::BtnOpenPort); connect(ui-&gt;m_BtnSendData,&amp;QPushButton::clicked,this,&amp;TestComPro::BtnWriteCurVolData); connect(ui-&gt;m_BtnReadCurVal,&amp;QPushButton::clicked,this,&amp;TestComPro::BtnReadCurValData); //std::thread tprocess(&amp;TestComPro::Display,this); //tprocess.detach(); } TestComPro::~TestComPro() { if (m_serialPort-&gt;isOpen()) { m_serialPort-&gt;close(); } delete m_serialPort; delete ui; } void TestComPro::initUI() { ui-&gt;m_BtnSendData-&gt;setText("Send"); ui-&gt;Ch1_data-&gt;setText("ch1:0.00v 0.00A"); ui-&gt;Ch2_data-&gt;setText("ch2:0.00v 0.00A"); this-&gt;setWindowTitle("Test QSerialPortDemo"); QStringList m_ChName; m_ChName.append("CH1"); m_ChName.append("CH2"); m_ChName.append("CH3"); m_ChName.append("CH4"); ui-&gt;Cbb_CH-&gt;addItems(m_ChName); } //获取设备上所有的串口 QStringList TestComPro::getPortNameList() { QStringList m_serialPortName; foreach(const QSerialPortInfo &amp;info,QSerialPortInfo::availablePorts()) { m_serialPortName &lt;&lt; info.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/84551eb1af0be15c541669b33a525c07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3c3837b9926df54cab9e83853daba5ae/" rel="bookmark">
			重构代码的 5 个 Xcode 技巧
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		作为一名开发人员，有时重构代码比写代码的时间都要多，所以知道如何重构一段代码是开发者需要掌握的一项非常重要的技能之一。它还有很多的好处，例如：
有了重构思维，我们从一开始就能有意识的去编写更简洁、更安全的代码提高代码的可测试性可以更好的进行 code review 另外，还有专门的书籍和网站去介绍如何进行代码重构。
所以，今天就来分享使用 Xcode 去重构代码的 5 个小技巧。
1. 批量重命名 给属性、参数、方法、类取个好名字不仅可以一看到名字就知道是干什么的，还有利于后期的维护和交接，想想如果变量名都是 test1、test2 之类的，当需求变更，再回头看代码，是有多么的糟心。
那如果想给它们更名，但是调用的地方又比较多，需要怎么重命名呢？有同学说全局替换，emmm… 不够优雅，而且容易替换错。
有两种重命名的场景：
rename 适合全局替换的场景。比如，某个方法被多个类调用。就可以使用 Xcode 自带的 rename 特性。只需要右键重命名的对象，即可调出 rename 特性。
点及 rename 后，Xcode 会搜索所有需要重命名的地方，搜索完成后会高亮显示。编辑高亮部分，点击右上角 rename 就重命名成功啦。
Edit All in Scope 适合重命名的对象只在当前文件中被使用。这种情况下，Xcode 只会搜索当前文件内需要重命名的地方，然后高亮显示。修改好后，回车即可重命名成功。
2. Generate Memberwise Initializer 特别是处理模块、sdk和一些库的时候，不能完全依赖于初始化程序的自动合成。很多时候，我们需要创建自己的公共初始化器，不过就需要复制粘贴各个属性，比较麻烦。还好，Xcode 有一个方便的特性，可以自动创建按成员变量顺序的初始化器。
右键需要 init 的类型，选择 Refactor，然后再选择 Generate Memberwise Initializer。
Xcode 使用 internal 关键字在类型声明的正下方创建初始化器。我们可以将关键字更改为 public (或者我们需要的值) ，然后在需要的地方剪切和粘贴。
3. Add Missing Switch Cases 有时我们定义的枚举的 cases 太多，如果对其遍历，手动写每个 case 势必会很浪费时间。那么有什么方法可以自动填充所有 case 呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3c3837b9926df54cab9e83853daba5ae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ca1337a805ac00f8b0b34f24aa8e508/" rel="bookmark">
			时间序列分析（2）| ARMA模型的（偏）自相关函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自相关函数和偏自相关函数是判断ARMA模型平稳性和阶数的有效工具。
1 自相关函数 根据平稳性的定义，与的方差相同，协方差仅与时间间隔有关，那么二者之间的相关系数也就仅与有关了。因为与对应的是同一个变量，所以它们之间的相关系数称为自相关系数。
1.1 AR(1)过程 AR(1)过程的形式如下：
可以计算出它的方差，协方差，从而自相关系数。
也是AR(1)的特征方程的根，由平稳性条件可知，须有。
因此，呈指数型衰减。
基础包stats中的acf()函数可以画出时间序列数据自相关函数（autocorrelation function, ACF）的图象。
acf(x, lag.max = NULL, type = c("correlation", "covariance", "partial"), plot = TRUE, na.action = na.fail, demean = TRUE, ...) x：时间序列数据；
lag.max：时间间隔的最大值；
type：绘制的图形类型；correlation表示绘制自相关函数图，covariance表示绘制自协方差函数图，partial表示绘制偏自相关函数图。
如下，分别构造和时的AR(1)过程（截距不影响自相关系数，假设其为0.2）：
set.seed(123) epsilon = rnorm(200) y1 = y2 = rep(0,200) for(i in c(2:200)){ y1[i] = 0.2 + 0.9*y1[i-1] + epsilon[i] y2[i] = 0.2 - 0.9*y2[i-1] + epsilon[i] } y1 = y1[51:200] y2 = y2[51:200] par(mfrow = c(2,1), plt = c(0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ca1337a805ac00f8b0b34f24aa8e508/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1256b007b543469e3e80a859217403a1/" rel="bookmark">
			云原生技术解读系列1-什么是云原生？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 9 月初给 BG 的新人开了一门课，专门来讲云原生技术，云原生技术从出现到现在按最早的时间出现来说也是有 10 多年了。尤其是这几年火热的不得了，但是 cloud native 这个外文词翻译成中文 “云原生” 就更加的不好理解，再加上本身这个词的定义在发展中又有多次的变化，导致很多学习这块技术的同学都感觉是云里雾里，不知所谓。
所以根据我对这门技术的认识，我开了这门课，一方面我认为我的认识还算比较到位，另一方面我认为目前的新人必须要学习和了解云原生技术，这是目前底层技术发展的大趋势。非常有必要学习和了解，而且我在内部也是致力于推动云原生技术的落地。在推动的过程中也很费劲，很多人看不到这场技术变革的意义和价值，这是非常让人感慨的。
软件部署模式 这里我先不直接说什么云原生技术，我们先来看看软件部署模式在云原生下的方式，先直观感受一下云上技术带来的变化。如果没有直观的感觉，大家都不好理解云上技术带来的便利。
案例 以我内部一个平台系统的简化架构为例：特点：
系统稍微复杂一点，相关模块较多。
开发人员也较多，根据不同的技术栈分了多个人开发。 传统的部署方式 下面是我们传统的部署方式，可以看到就是直接申请机器，并且做高可用互备的部署，大概需要3台到7台机器不等。遇到机器坏了也是要申请机器进行替换，再从新部署和更新路由等信息。 云上的部署方式
下面是云上的部署方式，因为是一个内部系统，访问人数一天也就是几百人，qps并没有多大，也并不怎么消耗资源，测试环境每个模块部署只分配 0.1 核的资源，线上环境 0.1～0.5 核左右。内存就不用说了，需要的更少。CPU 的需要总共下来这么多模块也就不到 1 核资源搞定，而且不用我做备份。云平台帮我搞定，我只需要申请使用我真是需要的资源就好了。 案例总结 从这里大家可以看出云上方式和传统方式的一点区别了吧。
总结一下：案例中我们真实需要的是什么？我们只是需要 CPU，内存和网络这些必要的资源，让我们的服务能运行起来，并且可以通过网络进行访问。
我们真实需要机器吗？扪心自问，我认为我们可以不要机器，或者说我们不关心机器，我们需要的是计算和网络资源。如果有地方可以提供高可用的计算和网络资源，我就不需要关心什么机器了。人总是这样，要解决一个问题，就需要找另外的工具和资源，又会想到能提供这种工具和资源的东西是什么，再去找，这样不断的寻找解决办法，最终可能就会形成思维定势，而忘记了最直接的解决方式。
所以在计算这块，云提供了最纯粹的解决方式，要 CPU 就给 CPU，要内存就给内存，要网络就给网络，给你你真正想要的。
云原生 云原生是一个组合词，英文 “Cloud Native”。Cloud 是指云平台，是一堆资源的组合，进行抽象的表示，在最上层提供了抽象接口可以让用户无需关心底层就可以使用这堆资源。在上面的案例就是说的这种使用方式。
Native 表示应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳姿势运行，充分利用和发挥云平台的弹性+分布式优势。通过这种设计让应用可以使用好云计算基础设施，使云计算发挥最大能力。
这里也要多啰嗦一下，再好的技术和平台，使用的姿势不对也难以很好的发挥价值，甚至会带来损失和更大的灾难。
所以这里也可以说云原生(Cloud Native)是一种能充分利用云计算优势对应用程序进行设计、实现、部署、交付和操作的应用架构方法。，是一套技术体系和方法论。使用方法和姿势不对，再好的云原生也不能解决你的问题。
云原生计算加速了应用与基础设施资源之间的解耦，通过定义开放标准，向下封装资源，将复杂性下沉到基础设施层；向上支撑应用，让开发者更关注业务价值。
云原生的历史 云原生技术一直在不断地变化和发展，关于云原生的定义也在不断地迭代和更新，不同的社区组织或公司对云原生也有自己的理解和定义。
早期定义 早在 2013 年，来自 Pivotal 公司的 Matt Stine 编写了《迁移到云原生架构》，就提出了云原生应用架构应该具备的几个主要特征
符合12-Factor应用(Twelve-Factor Applications)
面向微服务架构(Microservices)
自服务敏捷基础设施(Self-Service Agile Infrastructure)
基于API的协作(API-Based Collaboration)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1256b007b543469e3e80a859217403a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b571ea1502688d96834e710ce8acc6e8/" rel="bookmark">
			明明的随机数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		明明的随机数 描述
明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N 个 1 到 1000 之间的随机整数（ N≤1000 ），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)。
注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。
当没有新的输入时，说明输入结束。
数据范围： ，输入的数字大小满足
输入描述：
注意：输入可能有多组数据(用于不同的调查)。每组数据都包括多行，第一行先输入随机整数的个数 N ，接下来的 N 行再输入相应个数的整数。具体格式请看下面的"示例"。
输出描述：
返回多行，处理后的结果
示例1
输入：
3
2
2
1
11
10
20
40
32
67
40
20
89
300
400
15
复制
输出：
1
2
10
15
20
32
40
67
89
300
400
复制
说明：
示例1包含了两个小样例！！
输入解释：
第一个数字是3，也即这个小样例的N=3，说明用计算机生成了3个1到1000之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：
2
1
1
所以第一个小样例的输出为：
1
2
第二个小样例的第一个数字为11，也即…(类似上面的解释)…
所以第二个小样例的输出为：
10
15
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b571ea1502688d96834e710ce8acc6e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a371b1e8ced953496f9e4bdd2d5c500f/" rel="bookmark">
			写while True(循环)的一点建议
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 写 w h i l e T r u e ( 循 环 ) 的 一 点 建 议 写while True(循环)的一点建议 写whileTrue(循环)的一点建议 在实际生产的while(true)循环中，最好加入Thread.Sleep(1)的睡眠操作，可以大大降低CPU的负担
while(true) { // 工作代码 Thread.Sleep(1) } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/975fe7d665dfc7fa16226da83eee87d7/" rel="bookmark">
			HTTP请求错误400、401、402、403、404、405、406、407、412、414、500、501、502解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		HTTP 错误 400 400 请求出错 由于语法格式有误，服务器无法理解此请求。不作修改，客户程序就无法重复此请求。 HTTP 错误 401 401.1 未授权：登录失败 此错误表明传输给服务器的证书与登录服务器所需的证书不匹配。 请与 Web 服务器的管理员联系，以确认您是否具有访问所请求资源的权限。 401.2 未授权：服务器的配置导致登录失败 此错误表明传输给服务器的证书与登录服务器所需的证书不匹配。此错误通常由未发送正确的 WWW 验证表头字段所致。 请与 Web 服务器的管理员联系，以确认您是否具有访问所请求资源的权限。 401.3 未授权：由于资源中的 ACL 而未授权 此错误表明客户所传输的证书没有对服务器中特定资源的访问权限。此资源可能是客户机中的地址行所列出的网页或文件，也可能是处理客户机中的地址行所列出的文件所需服务器上的其他文件。 请记录试图访问的完整地址，并与 Web 服务器的管理员联系以确认您是否具有访问所请求资源的权限。 401.4 未授权：授权服务被筛选程序拒绝 此错误表明 Web 服务器已经安装了筛选程序，用以验证连接到服务器的用户。此筛选程序拒绝连接到此服务器的真品证书的访问。 请记录试图访问的完整地址，并与 Web 服务器的管理员联系以确认您是否具有访问所请求资源的权限。 401.5 未授权：ISAPI/CGI 应用程序的授权失败 此错误表明试图使用的 Web服务器中的地址已经安装了 ISAPI 或 CGI程序，在继续之前用以验证用户的证书。此程序拒绝用来连接到服务器的真品证书的访问。 请记录试图访问的完整地址，并与 Web服务器的管理员联系以确认您是否具有访问所请求资源的权限 HTTP 错误 403 403.1 禁止：禁止执行访问 如果从并不允许执行程序的目录中执行 CGI、ISAPI或其他执行程序就可能引起此错误。 如果问题依然存在，请与 Web 服务器的管理员联系。 403.2 禁止：禁止读取访问 如果没有可用的默认网页或未启用此目录的目录浏览，或者试图显示驻留在只标记为执行或脚本权限的目录中的HTML 页时就会导致此错误。 如果问题依然存在，请与 Web 服务器的管理员联系。 403.3 禁止：禁止写访问 如果试图上载或修改不允许写访问的目录中的文件，就会导致此问题。 如果问题依然存在，请与 Web服务器的管理员联系。 403.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/975fe7d665dfc7fa16226da83eee87d7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9ec2c4a660241c5986afb4f43a6a212/" rel="bookmark">
			Flutter 手势GestureDetector解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于移动端的开发者来说，手势是一个非常重要的模块，基本上做任何App都会遇到各种各样的手势问题，而手势也是移动的一个不算小的模块吧，要彻底搞得还是得费一些时间的，如果之前对Android或者IOS的手势或者说点击事件的原理有所了解的，那么了解其它语言的手势原理相对来说帮助还是挺大的。
好了，切入正题。在Flutter中，对于Flutter有一定了解的人都知道，可以通过GestureDetector来给不具有点击事件或者手势回调的Widget添加手势回调。然后为了点击水波纹的点击效果，大多数开发者可能会使用InkWell widget来包装一个需要添加点击事件的控件。
前戏部分： InkWell 和 GestureDetector的区别 对Flutter有一一些深入了解的人可能知道，InkWell就是对GestureDetector的一个封装。看图：
InkWell是继承于InkResponse，InkResponse是集成于StatelessWidget类，在onBuild中返回了_InkResponseStateWidget 由于以上这部分代码没有什么逻辑，为了减少篇幅我就不贴源码了。
_InkResponseStateWidget中的核心代码如下：
return _ParentInkResponseProvider( state: this, child: Actions( actions: _actionMap, child: Focus( focusNode: widget.focusNode, canRequestFocus: _canRequestFocus, onFocusChange: _handleFocusUpdate, autofocus: widget.autofocus, child: MouseRegion( cursor: effectiveMouseCursor, onEnter: _handleMouseEnter, onExit: _handleMouseExit, child: Semantics( onTap: widget.excludeFromSemantics || widget.onTap == null ? null : _simulateTap, onLongPress: widget.excludeFromSemantics || widget.onLongPress == null ? null : _simulateLongPress, child: GestureDetector(//InkWell手势的来源 onTapDown: enabled ? _handleTapDown : null, onTap: enabled ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d9ec2c4a660241c5986afb4f43a6a212/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/281/">«</a>
	<span class="pagination__item pagination__item--current">282/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/283/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>