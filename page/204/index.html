<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15a58cdf92039dd3d8b6a8b046162524/" rel="bookmark">
			Android连载43-Netd相关学习笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、NetlinkManager关键类图 1.netd接受kernal相关消息 Netlink_kobject_ueventNetlink_routeNetlink_nflog 2.NetlinikHandler工作流程 3.CommandListener主要是接受NMS来的指令 4.CL的工作流程 5.DnsProxyListener分析 两个关键函数getaddrinfo\getnameinfo 6.DnsProxyListener命令分析 7.MDnsSdListener分析 MDnsSd是Multicast DNS Service Discovery的简称 二、Bonjour背景 使用了三个接口，该接口是第三方提供的，这里的是指apple公司当年开源的工程
1.在Android上的运行机制 在Netd中有MdnsSdListener对象，通过socket与上层对象通信，通过Bonjour API 和mdnsd进行通信下面是类图 三、源码 gitee路径：https://gitee.com/dongqianrui/AndroidStudioProject/tree/master/Test1CSDN：https://blog.csdn.net/weixin_44630050 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0358e0956b71f2c6c99379515936c765/" rel="bookmark">
			Spring Boot 基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SpringBoot介绍创建方式POM.xml任务异步任务邮件任务配置文件发送邮件 定时执行任务 打包war 包jar 包区别 注解总结创建对象@Controller@RestController@Service@Repository@Component 赋值@Value@Autowired@Resource 其他@Configuration@ImportResoure@PropertyResource@ComponentScan@RequestBody@ControllerAdvice@Transcational@SpringBootApplication@Mapper@Param SpringBoot 介绍 SpringBoot 相当于不需要配置文件的 Spring + Spring MVC
常用的三方框架已经配置好，可以直接使用SpringBoot 开发效率较高 SpringBoot 简化 Spring 和 SpringMVC 的使用
例：Spring 中使用 Mybatis 需要配置 SelSessionFactory、Dao 代理对象 SpringBoot 中添加 mybatis-spring-boot-start 依赖即可，已经有默认配置可以直接使用 核心还是 IoC 容器
特点
创建 Spring 应用内嵌 Tomcat，jetty，Undertow提供了 starter 起步依赖，简化应用配置自动配置：尽可能自动配置了 Spring 和 三方库 第三方库中对象都创建好放到容器中 提供健康检查、统计、外部化配置等功能无需生成代码，不用使用 xml 做配置 创建方式 使用 SpringBoot 的初始化器
以向导方式完成 SpringBoot 项目创建，使用方便 必须联网创建 初始化器 使用 默认地址 地址下载创建国外官方地址，容易失败 使用自定义地址 使用 Spirng Boot 中文社区 地址创建国内地址，服务器假设在香港，成功率 可以直接在浏览器使用地址创建项目 创建完成后生成压缩包结构下载 使用 Maven 创建项目
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0358e0956b71f2c6c99379515936c765/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89510d46faf405f9c9fefd3bb69b5630/" rel="bookmark">
			【Win11】重装系统教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一. 所需工具下载二. 制作U盘PE三. 安装系统 为了通过审核，本文有些地方语句可能不通顺，非常抱歉。
一. 所需工具下载 链接：https://pan.baidu.com/s/1sfLwc_wTrLhCITvQgB4Kpg
提取码：jbj1
二. 制作U盘PE 在电脑上插入一个U盘（U盘的内存不小于8G），鼠标右击插入U盘选择格式化
这里我的U盘是以前做的启动盘，名字请忽略
文件系统选择NTFS，点击开始。
进行格式化
打开下载的文件，解压，以管理员身份运行 5. 安装PE到U盘
这里要确认名称是否一致
6. 制作完成，此时会看到U盘为空，并多了一个EFI的磁盘。
三. 安装系统 将下载下来的win11镜像及工具复制到已制作好的PE系统盘里。
重启电脑，选择电脑从U盘启动 我是神舟笔记本，这里解决方法仅针对神舟笔记本，其他品牌的启动键可以去网上搜索
神舟看网上一堆说F12的，按了没反应，最后才发现我的电脑是实际是F7，神舟笔记本若F12/F12+Fn/F7/F7+Fn都不起作用的话可以按F2进入bios界面，看boot设置中uefi是否为enable
选择UEFI:后面一般为自己U盘牌子的英文名称，按Enter键。
第一行是神舟的系统恢复，不用管
进入PE系统后，格式化系统盘(一般是C盘)
这里可以使用分区助手进行重新分区，根据自己的需求来，我是将C盘D盘合并了，没有分区需求的可以直接格式化系统盘再安装系统。
到这里系统盘格式化完毕，接下来进行系统的安装。
4.双击windows安装器
操作如上图所示
第一栏：点击搜索选择U盘文件夹内的windows11.iso文件，点击打开。
第二栏：根据磁盘类型选择引导驱动器的磁盘，我是默认,一般情况下系统会自动选择，保持默认即可。当图中的灯不出现红灯（绿灯和黄灯均为正常）说明驱动器磁盘选择正确；若亮红灯请重新选择引导驱动器磁盘，直到不出现红灯方可进行下一步。
第三栏：在选择安装驱动器的位置处点击搜索选择C盘
最后选择自己要安装的系统版本，点击安装。
点击确定 （注：这里要拔掉U盘）
5. 重启电脑
此时win11系统已安装完毕，重启电脑后进入win11设置界面，按需求设置就好。
插上U盘，安装上winRAR，后续按图操作。
最后，不要忘记去自己电脑品牌的官网下载对应型号的电脑驱动，否则电脑的某些功能可能无法正常使用
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daff2625cf07e435ecb23d5a4039ca13/" rel="bookmark">
			Winform和ASP.NET、Web API详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Winform和ASP.NET、Web API 一、winform基础 1.1 基础学习 1、 winform应用程序是一种智能客户端技术，我们可以使用winform应用程序帮助我们获得信息或者传输信息等。
2、属性
Name:在后台要获得前台的控件对象，需要使用Name属性。
visible:指示一个控件是否可见。
Enabled:指示一个控件是否可用。
3、
事件:发生一件事情。
注册事件:双击控件注册的都是控件默认被选中的那个事件。
触发事件:
4、
在Main函数当中创建的窗体对象，我们称之为这个窗体应用程序的主窗体。
也就意味着，当你将主窗体关闭后，整个应用程序都关闭了。
5、TextBox控件
Wordwrap:指示文本框是否换行。
Passwordchar:让文本框显示一个单一的字符
scollBars:是否显示滚动条
事件:Textchanged当文本框中的内容发生改变的时候触发这个事件。
6、跑马灯练习
abcde
bcdea
cdeab
private void timer1_Tick(object sender, EventArgs e) { //abcde label1.Text = label1.Text.Substring(1) + label1.Text.Substring(0, 1); } 7、Timer
在指定的时间间隔内做一件指定的事情
8、单选和多选
RadioButton
CheckBox
默认情况下，在一个窗体中，所有的单选按钮只允许选中一个，可以使用groupbox进行分组
9、MDI窗体的设计：MDI(Multiple Document Interface)多文档界面，与此对应就有单文档界面 (SDI)
首先确定一个父窗体，将IsMdiContainer设置为true创建子窗体，并且设置他们的父窗体 private void 显示子窗体ToolStripMenuItem_Click(object sender, EventArgs e) { //显示子窗体 Form2 form2 = new Form2(); form2.MdiParent = this; form2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daff2625cf07e435ecb23d5a4039ca13/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/271a0ae5ee5c4ae6d731c8e1b05ab69f/" rel="bookmark">
			什么是 CDP 和 LLDP？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CDP 和 LLDP 都是可以在 IEEE 802 环境（以太网）中运行的邻居发现协议。两种协议几乎完全相同地做同样的事情，主要区别在于供应商。CDP 是 Cisco 专有协议，而 LLDP 是开放标准协议。事实上，CDP 代表思科发现协议，而 LLDP 代表链路层发现协议。同样，两者的工作方式完全相同。
邻居发现协议使用一个简单而强大的概念。设备会发布有关自身的信息并侦听来自其他设备的信息。这些协议是完全无状态的，因此我们没有任何会话建立或丢失数据包的重传。相反，每个设备总是周期性地发送相同的信息。如果您错过了它们，我们将不得不等待下一个。设备将其主机名、管理 IP 地址（在 CDP 中）、功能（它是路由器、交换机还是其他什么？）及其软件版本通知其他设备。
有趣的是，邻居发现消息不会被转发——不在第 2 层或第 3 层。这意味着接收 CDP 消息的交换机不会将其发送给其他任何人，而是会为自己保留。这是由于这些协议的目的：找出直接连接的邻居。因此，任何通过 CDP 或 LLDP 发现的邻居都直接连接到我们的设备，中间没有中间设备。请注意，这不包括无源设备，例如集线器或接线板。设备会将它们收到的消息存储在它们的 CDP/LLDP 表中。
除了被网络管理员用来发现拓扑之外，CDP 和 LLDP 还有另一个用途。IP 电话利用这两种协议找出为 VoIP 和其他信息保留的 VLAN。
Cisco 设备上的 CDP 和 LLDP
世界上几乎所有 Cisco 设备都将原生支持CDP。在这些设备中，CDP 已经在全局启用，并将在所有设备的接口上发送和侦听消息。大多数 Cisco 设备还将支持 LLDP，因为这允许它们与其他供应商进行互操作。但是，在这些设备中，默认情况下 LLDP 处于关闭状态。与 CDP 相比，LLDP 是一个非常强大的工具，因为您可以指定要发送到其他设备的信息片段。这超出了本文的范围，甚至在 Packet Tracer 中也不支持。尽管如此，我们可以（并且将会）单独打开接口上消息的传输和接收。这对于 CDP 来说是不可能的，其中传输和接收被视为同一项目。
上表显示了我们将在此配置中使用的命令。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcf1469d26c4804112ae6fb666a7709e/" rel="bookmark">
			Python-statannotations库绘制显著性标注并自己设置标识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		statannotations库的具体用法可以参考如下连接
https://github.com/trevismd/statannotations
下载安装包后即可绘图
但该包里面默认的显著性分为了5挡
可以通过改变包内的设定修改为我们常用的三档显著性，或者修改为自己想用的标识符
找到你安装python包的位置
在statannotations下找到 PValueFormat.py文件并打开
找到下面这个函数，你可以通过修改这个函数添加自己想要的标识效果
例如我们将显著性标识改为三档
然后绘图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f539f35efe970c7372217d939446411/" rel="bookmark">
			异步函数（async/await）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 异步函数asyncawait 异步函数策略实现sleep()利用平行执行串行执行期约栈追踪与内存管理 小结 异步函数 异步函数，也称为"async/await" (语法关键字)，是ES6 期约模式在ECMAScript 函数中的应用。async/await 是ES8 规范新增的。为了解决利用异步结构组织代码的问题。
async async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上：
async function foo() {} let bar = async function() {}; let baz = async() =&gt; {}; class Qux { async qux() {} } 异步函数如果使用return 返回了值（没有return 则会返回undefined）,这个值会被Promise.resolve() 包装成一个期约对象。
async function foo(){ console.log(1) } console.log(foo()); //promise {&lt;fulfilled&gt;:undefined} foo().then(console.log) //undefined console.log(2) //1 //2 //undefined await await 关键字可以暂停异步函数代码的执行，等待期约解决。await 会暂停执行异步函数后面的代码，让出JS 运行时的执行线程。这个行为与生成器函数中的yield 关键字是一样的。await 关键字同样是尝试 “解包” 对象的值，然后将这个值传给表达式，再异步恢复异步函数的执行。
await 关键字必须在异步函数中使用；异步函数的特质不会扩展到嵌套函数。否则会抛出SyntaxError;
async function foo(){ await Promise.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f539f35efe970c7372217d939446411/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39a77edfacfaf87d6b25ea786f2c03e3/" rel="bookmark">
			vue 借助插件js-table2excel 实现导出excel，并导出图片到excel。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、界面展示二、excel展示三、工具：table2excel 一、界面展示 二、excel展示 三、工具：table2excel 安装插件 yarn add js-table2excel 2.代码实现
&lt;template&gt; &lt;div class="box"&gt; &lt;a-button @click="exportFn"&gt;导出&lt;/a-button&gt; &lt;vxe-table :data="tableData"&gt; &lt;vxe-column type="seq"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="date" title="日期"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="num" title="数量"&gt;&lt;/vxe-column&gt; &lt;vxe-column field="photo" title="头像" &gt; &lt;template #default="{ row }"&gt; &lt;img :src="row.photo" alt="" style="height:50px"&gt; &lt;/template&gt; &lt;/vxe-column&gt; &lt;/vxe-table&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; const originData = [ { date: '2022年10月1日', num: 2, photo:'此处为base64格式图片,字符长度大不展示。' }, { date: '2022年10月2日', num: 6, photo:'此处为base64格式图片,字符长度大不展示。' }, { date: '2022年10月3日', num: 4, photo:'此处为base64格式图片,字符长度大不展示。' } ] import table2excel from 'js-table2excel' export default { data() { return { tableData: originData, } }, methods: { exportFn() { let temp = [ { title: '日期', key: 'date', type: 'text' }, { title: '数量', key: 'num', type: 'text' }, { title: '头像', // 输出 excel 列名 key: 'photo', // 表格对应列字段名 type: 'image' // 列类型 } ] let datas = this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39a77edfacfaf87d6b25ea786f2c03e3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdfdb37f421e75359fd11645d439c6fa/" rel="bookmark">
			[Unity3D]矢量数学：向量的点乘（内积）和叉乘（外积）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity使用左手坐标系：拇指X轴，食指Y轴，中指Z轴。
计算公式： 设 A(Ax，Ay，Az) B(Bx，By，Bz)，则
1.向量的模：
2.向量加法：
3.向量点积：
4.向量叉积：
物理（几何）意义： 1.模：就是向量的长度。
2.加减：是位移，遵循三角形法则。
3.点积：结果是一个标量（数值，有大小无方向），满足交换律。
是一条边向另一条边的投影乘以另一条边的长度。
点积为0则两向量垂直，大于0是锐角（越大角度越小），小于0是钝角（越小角度越大）。
点积为0：平飞。 点积大于0：爬升。正值增大，抬头。 点积小于0：俯冲。负值增大，低头。 点乘结果描述了两个向量的“相似”程度，点乘结果越大，两向量越相近。
因为a•b = |a||b|cosθ
所以如果a和b都是单位向量，那么点乘的结果就是其夹角的cos值。
a•b = cosθ
由于cos在0~π上单调调减，因此可以比较cos值来达到比较夹角的效果。
4.叉积：结果是一个新的向量。
原向量是大拇指X和食指Y，新向量是中指Z（左手）。
叉积不满足交换律，即a×b≠b×a。实际上，叉积是满足反交换律的，即a×b=-(b×a)。而且叉积也不满足结合律，即 (a×b) ×c≠a×(b×c)
|a×b|=|a||b|sinθ，这和平行四边形的面积计算公式是一样的：
在Unity中： 1.计算向量的模：Vector3.magnitude
2.计算向量点积：Vector3.Dot(VectorA, VectorB)
3.计算向量叉积：Vector3.Cross(VectorA, VectorB)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0249dc3600dbb406e2980c372788d369/" rel="bookmark">
			Centos 7 配置阿里云yum源
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Centos 7 配置阿里云yum源
原因：有的时候服务器需要下载一些软件，是本地yum源没有的，这时候需要配置网络yum源（阿里云yum源）
1、通过远程工具Xshell连接Linux
2、进入目录 cd /etc/yum.repos.d/
3、备份原镜像文件，以免出错后可以恢复
4、下载新的CentOS-Base.repo 到/etc/yum.repos.d/
命令：wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
下载成功
打开CentOS-Base.repo，可看到该文件中已经配有阿里云yum源地址
如果该命令报如下错误，说明你还未安装wget，需要安装wget（未报错跳过）
通过命令 yum install wget 下载安装wget（为报错跳过）
如果通过yum安装wget安装失败的话，说明你还未配本地yum，配置本地yum，详细步骤请点击下方链接前去学习配置
配置本地yum源
5、清除原有yum缓存 yum clean all
6、生成缓存yum makecache
成功
————————————————
版权声明：本文为CSDN博主「大树下躲雨」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43521890/article/details/104888916
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66e73359b676946a984f64a5183420a6/" rel="bookmark">
			Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection；
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		报错内容如下：
Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure
SpringBoot 项目的 application.yml 如下：
spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8 username: root password: xxx 原因分析：
由于我使用的 Mysql 的版本是 5.7，而在配置 数据库的 url 的时候，没有设置 useSSL=false，所以报了 Communications link failure (通信链路错误)，获取不到 JDBC 连接的错误。根据MySQL 5.5.45+、5.6.26+和5.7.6+的要求，如果不设置显式选项，则必须建立默认的SSL连接。所以需要通过设置 useSSL=false 来显式禁用SSL，或者设置 useSSL=true 并为服务器证书验证提供信任存储。 解决：修改一下 url 即可
spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: xxx 连接Mysql数据库时在 url 后面加上 useSSL=false 的作用
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66e73359b676946a984f64a5183420a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b76c2bb473d9e4993be188e97697695f/" rel="bookmark">
			Ubuntu 18.04 Docker安装指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
Docker是一个非常方便的应用容器的引擎，相当于把应用的相关运行环境都打包成盒，直接部署，开箱即用，几乎无需再进行配置，懒人必备。
这次我们选择Docker部署，那么首先就需要安装并配置Docker在我们的Ubuntu上。这次安装的是Docker Communtiy也就是一般说的Docker CE（即社区免费版）。
安装准备工作
1.1 确认当前系统版本
1.2 卸载旧版Docker
正式安装
2.1 使用Repository安装
安装后的相关配置
3.1 令docker无需root权限
3.2 令docker服务开机自动启动
4.1 参考
注：本文主要参考自Docker官方文档，英语好的可以直接看这个。
1. 安装准在备工作 1.1 确认当前系统版本
需要安装Docker的话，你需要确认你的Ubuntu是64位的，并且是以下4个版本号其中之一：
Disco 19.04Cosmic 18.10Bionic 18.04(LTS)Xenial 16.04(LTS) 如果你不知道自己的版本号，可以输入：
lsb_release -c 通过上面的指令来查看Ubuntu的codename，看一下是否是上面4个版本号其中之一。
另外，Docker支持x86-64(amd64),armhf, arm64, s390x(IBM Z), ppc64le(IBM Power)硬件架构。通常我们遇到比较多都是X86芯片的机器。
1.2 卸载旧版Docker
旧版的Docker有很多叫法，有docker, docker.io, 或是docker-engine。为了确保安装顺利，我们应该先把这些老旧的docker卸载，输入以下指令：
sudo apt-get remove docker docker-engine docker.io containerd runc 如果顺利，那么会输出none of these packages are installed。
2. 正式安装 2.1 使用Repository安装
第一种安装方法是通过Repository安装。我们需要先设置一个Repository软件仓库，然后我们从这样一个仓库来安装或更新。（在官方文档中另有两种安装方式：从.deb包文件安装；从官方简易脚本安装，这里不做详细介绍）
首先更新apt包管理器的源：
sudo apt-get update 然后通过设置apt来允许通过https传输的一个仓库：（这里输入了 \后，直接按下回车，会出现一个&gt;符号，可以继续进行下一行的输入）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b76c2bb473d9e4993be188e97697695f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6cf93faa1d0dda7d06382c5283a19da/" rel="bookmark">
			tinyMediaManager 无法使用？2022.10.26
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.下载tMM工具并安装 tinyMediaManager下载
下载完无脑安装即可，配置待会再说
2. 剧集也是相同的配置
3.重点 如果刮削报错，在hosts中添加下面的IP
C:\Windows\System32\drivers\etc
13.249.134.9 api.themoviedb.org 13.249.134.27 api.themoviedb.org 13.249.134.43 api.themoviedb.org 13.249.134.90 api.themoviedb.org 2600:9000:212f:3800:c:174a:c400:93a1 api.themoviedb.org 2600:9000:212f:4200:c:174a:c400:93a1 api.themoviedb.org 2600:9000:212f:7c00:c:174a:c400:93a1 api.themoviedb.org 2600:9000:212f:8e00:c:174a:c400:93a1 api.themoviedb.org 2600:9000:212f:b400:c:174a:c400:93a1 api.themoviedb.org 2600:9000:212f:be00:c:174a:c400:93a1 api.themoviedb.org 2600:9000:212f:d800:c:174a:c400:93a1 api.themoviedb.org 2600:9000:212f:f400:c:174a:c400:93a1 api.themoviedb.org 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47e75865dc6b61a7cb70843e082f2a6b/" rel="bookmark">
			2.9CSS table属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表格边框 指定CSS表格边框，使用border属性。
下面的例子指定了一个表格的Th和TD元素的黑色边框：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt; table, th, td { border: 1px solid black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Peter&lt;/td&gt; &lt;td&gt;Griffin&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Lois&lt;/td&gt; &lt;td&gt;Griffin&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 这个表格有双边框，是因为th和td有独立的边界
为了显示一个表的单个边框，使用border-collapse属性
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt; table { border-collapse: collapse; } table, td, th { border: 1px solid black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Peter&lt;/td&gt; &lt;td&gt;Griffin&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Lois&lt;/td&gt; &lt;td&gt;Griffin&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt;&lt;b&gt;注意：&lt;/b&gt; 如果没有指定 !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47e75865dc6b61a7cb70843e082f2a6b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba7bd82e7ed1562d358a4991909fa32a/" rel="bookmark">
			Mysql数据库之事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、事务的概念
二、事务的ACID特点
1.原子性（Atomicity）
2.一致性（Consistency）
3.隔离性（lsolation）
4.持久性（Durability)
三、并发访问表的一致性问题和事务的隔离级别
1.并发访问表的一致性问题
（1）脏读
（2）不可重复读
（3）幻读
（4）丢失更新
2.事务的隔离级别
（1）未提交读（Read Uncommitted (RU)）
（2）提交读（Read Committed (RC)）
（3）可重复读（Repeatable Read (RR))
（4）串行读（serializable）
3.数据库默认隔离级别
4.事务隔离级别的范围和查看方式
（1）范围分类
（2）查看全局事务隔离级别
（3）查看会话事务隔离级别
（4）修改全局事务隔离级别
四、事务控制语句
1.显式地开启一个事务
2. 提交事务，并使已对数据库进行的所有修改变为永久性的
3.回滚会结束用户的事务，并撤销正在进行的所有未提交的修改 4. 在事务中创建一个回滚点
5. 把事务回滚到标记点
五、修改自动提交参数
1.数据库中临时修改
2.永久修改
一、事务的概念 是一种机制、一个操作序列，包含了一组数据库操作命令，并且把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行。
是一个不可分割的工作逻辑单元，在数据库系统上执行并发操作时，事务是最小的控制单元。
适用于多用户同时操作的数据库系统的场景，如银行、保险公司及证券交易系统等等。
通过事务的整体性以保证数据的一致性。
二、事务的ACID特点 1.原子性（Atomicity） 指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。
事务是一个完整的操作，事务的各元素是不可分割的；事务中的所有元素必须作为一个整体提交或回滚；如果事务中的任何元素失败，则整个事务将失败。 2.一致性（Consistency） 指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
在事务开始前，数据库中存储的数据处于一致状态；当事务完成后，数据也必须处于一致状态。 3.隔离性（lsolation） 指在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。
对数据进行修改的所有并发事务是彼此隔离的，表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务；修改数据的事务可在另一个使用相同数据的事务开始之前访问这些数据，或者在另一个使用相同数据的事务结束之后访问这些数据，即并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。 4.持久性（Durability) 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。指不管系统是否发生故障，事务处理的结果都是永久的。一旦事务被提交，事务的效果会被永久地保留在数据库中。
总结：在事务管理中，原子性是基础，隔离性是手段，一致性是目的，持久性是结果。
三、并发访问表的一致性问题和事务的隔离级别 1.并发访问表的一致性问题 （1）脏读 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。（即一个事务能看到另一个事务未提交的数据）
（2）不可重复读 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即由于一个事务中途修改使另一个事务多次读取不能读到相同的数据内容)
（3）幻读 一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，另一个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，操作前一个事务的用户会发现表中还有没有修改的数据行，就好像发生了幻觉一样。（即一个事务明明修改了多行数据记录，但由于另一个数据的影响，却导致发现有数据记录未被修改）
（4）丢失更新 两个事务同时读取同一条记录，A先修改记录，B也修改记录（B不知道A修改过)，B提交数据后B的修改结果覆盖了A的修改结果。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba7bd82e7ed1562d358a4991909fa32a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35b46559ded64515db9fe41615705646/" rel="bookmark">
			面试汇总（持续更新）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 2022.10.25 项目组面试 MySQL事务Mysql特性Linux 简单命令JDK和JRE区别final解决过生产事故吗？怎么解决的？怎么看日志？spring注解autowired和resource的区别重写和重载的区别where和&lt; where &gt;&lt;/ where&gt;的区别staticselect语句的优化string、stringbuilder、stringbuffer区别arraylist和linklisted区别git的使用 2021.09.17 亚信科技 抽象类和接口的区别spring boot 注解finalget和post区别 2021.09.14 面试 小组合作项目介绍，遇到的难点，前端后端怎么写的？前后端分离，在交互时，有歧义，是在前端修改还是在后端修改？ 2021.09.14 中科软面试题 你认识数据库哪些东西比较重要？数据库优化数据库E-R图数据库范式项目问题：①权限登录的实现②你认为最难的一点是什么？③运行项目，讲解流程键盘输入求递归的阶乘。输入999得到的结果是0，为什么？int的范围是什么？怎么解决内存溢出？怎么在int范围内得到阶乘的最大数？递归的极限是几？系统思维：运动会期间，如果有一个运动员得了新冠疾病，怎么防控？运动会还进行么？你的防控方案是什么？ 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/216afa5ea91da1d2044209b3a724fa7f/" rel="bookmark">
			vue 相关面试题（路由）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.浅谈对路由的理解 什么是路由？根据不同的url地址展示不同的页面内容 或者数据
路由分为前端路由和后端路由
前端路由：
1、前端路由 多用于单页面开发，也就是SPA。
2、前端路由是不涉及到服务器的，是前端利用hash或者JavaScript的historyApi来实现的，一般用于不同的内容展示和切换。
2.路由跳转的方式有哪几种？ 1、a标签进行跳转。
2、router-link进行跳转。
3、编程式路由。例如：this.$router.push()
3.路由传值的方式 有哪几种？ 1、path路径属性传值。接收的时候通过this.$route.params
2、query传值。因为在url中？后面的参数不会被解析，所以我们可以通过query进行传值。接受的时候通过this.$route.query
3、路由解耦。在配置路由的时候添加props属性为true，在需要接收参数页面通过props进行接收
4、编程式导航 this.$router.push({path:"/home",query:{}})
4.请说出路由配置项常用的属性及作用 路由配置参数：
path：路由路径
component：路由相对于的组件
name：命名路由
children：子组件的路由配置项（嵌套路由）
props：路由解耦
redirect：重定向路由
5.编程式导航的使用方法以及常用的方法 1、路由跳转：this.$router.push()
2、路由替换：this.$router.replace()
3、后退：this.$router.back()
4、前进：this.$router.forward()
6.如何重定向路由 通过路由配置项中的redirect进行重定向
7.如何实现路由解耦？ 在路由配置项中设置props：true 在需要接收组件的内部通过props进行接收
8.如何检测路由参数的变化 通过属性监听来实现和beforeRouteUpdate()
9.什么是路由守卫？路由的钩子函数有哪些？分别说出使用的场景、及用法 1、什么是路由守卫？：路由跳转前后的一些验证
2、路由常见的钩子函数：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave
3、使用的场景：
beforeRouteEnter：当路由进入之前：登录之前。
beforeRouteUpdate：当路由进行更新的时候。如果当前路由发生了变化，但是不需要组件的创建销毁的过程的时候，就需要用到这个钩子函数
beforeRouteLeave：当路由离开的时候。当用户没有支付离开的时候，当用户填完信息没有保存的时候。
10.什么是全局守卫？ beforeEach：全局守卫。验证用户是否登录
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89f071be5b0e95c33a046f08315e211/" rel="bookmark">
			Python-Python错误“SyntaxWarning: “is“ with a literal. Did you mean “==“?”
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Python 3.8（或更高）下：
出现报错
SyntaxWarning: "is" with a literal. Did you mean "=="?
1
解决方法：
将对应语句中is/is not用== 和 != 代替
原因：
从 python 3.8 开始，使用 is 和 is not 运算符时，会抛出 SyntaxWarning 语句警告信息
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e441838d586f26c853fa51cc9658542/" rel="bookmark">
			【数据结构】TrieTree（字典树、前缀树）—— C&#43;&#43;实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 TrieTree（字典树、前缀树、单词查找树）
字典树，看名字好像和字符串相关。
如果你能看到这一篇文章，那么肯定学过字符串串匹配算法，即BF和KMP的模式匹配。
字典树并不是来解决字符串匹配问题，而是用于以下场景：
大量的单词（串），实现单词的排序功能、快速检索功能、前缀搜索功能…
文章目录 前言基本性质一、TrieTree节点的设计二、添加单词串——add()三、查询单词——query()add()和query()的测试 四、前序遍历字典树前序遍历测试 五、前缀搜索功能——prefix()前缀搜索的测试 六、删除单词——remove()析构函数删除代码解析删除代码测试 应用场景字典树的常用优化（待补充。。）TrieTree完整代码 基本性质 根节点不包含字符，除根节点外每一个节点都只包含一个字符；从根节点到某一结点，路径上经过的字符连接起来，为该节点对应的字符串；每个节点的所有子节点包含的字符都不相同。 适用范围：
单词检索统计和排序字符串字符串前缀检索 算法核心
利用字符串的公共前缀来减少查询时间，最大限度的减少无畏的字符串比较。
时间复杂度
字典树查找效率很高，时间复杂度是O(m)，m是要查找的单词中包含的字母的个数。
图示：pool、prize、preview、prepare、produce、progress
在一些代码实现中，会在单词的结尾处设置一个类似于isend的标记。例如：hello和hel。
但是这样存储携带的信息太少，这样只知道树中有这个单词，但不知道该单词出现过几次，所以一般会在单词的最后一个字符节点，添加一个freqs标记，记录该单词出现过几次。
一、TrieTree节点的设计 需要的成员为：
存储字符的变量；存储单词频率的变量；存储孩子节点字符数据和节点指针的对应关系；因为要实现一个自动排序的前缀树，所以这里采用的是STL中的红黑树map&lt;&gt;。 #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; class TrieTree { private: struct TrieNode { TrieNode(char ch, int freqs) : ch_(ch) , freqs_(freqs) {} // 节点存储的字符数据 char ch_; // 单词的末尾字符存储单词的数量（频率） int freqs_; // 存储孩子节点字符数据和节点指针的对应关系 map&lt;char, TrieNode*&gt; nodeMap_; }; private: TrieNode* root_;	// 根节点 }; 因为TrieTree的根节点不存放任何字符，所以这里实现一个构造函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e441838d586f26c853fa51cc9658542/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/929305a09969c9e2bc0df5442359e2e3/" rel="bookmark">
			Java中日志的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是日志 日志文件是用于记录系统操作事件的文件集合，可分为事件日志和消息日志（网上的解释）。
二、使用日志的好处 1、可以异步打印数据
2、可以追踪项目运行
3、可以记录错误日志
4、可以日志动态归档
5、可以打印信息的动态的关闭
6、可以通过第三方提供插件还能将微服务日志直接记录到 ELK中
三、常见的日志框架 JUL：（Java util logging）
JCL:Jakatra commons logging (Spring框架的内部默认使用)
JBOSS-Logging：这个是为了特定的框架编写的日志框架
log4j、logback、SLF4J、log4j2
我们以后在开发中经常选用的一个日志组合是 SLF4J（规范）+Logback（实现产品）。
四、SLF4J的基本使用 1、创建maven项目
2.写测试代码（如果不会写的话，可以借鉴官网文档）
https://www.slf4j.org/manual.html
public class T0 { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(T0.class); logger.trace("---------Trace----------"); logger.debug("-----------debug--------"); logger.info("-----------info----------"); logger.warn("-----------warn----------"); logger.error("-----------error----------"); } } 3.导包
&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; 那这样的运行结果就是
上面已近说了，SLF4J是个规范，相对于一个接口，不可能直接面向接口编程，官网有个图片就解释了，光有SLF4J是没用的，无法打印
五、SLF4J整合logback 从官网提供的图片中就可以知道整合logback只需要再导入需要的两个包就行。
&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; 效果 ：那为什么打印四句呢？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/929305a09969c9e2bc0df5442359e2e3/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/203/">«</a>
	<span class="pagination__item pagination__item--current">204/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/205/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>