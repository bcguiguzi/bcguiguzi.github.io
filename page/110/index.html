<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4a58130920fc3bd52102acb53419699/" rel="bookmark">
			解决matplatlib不能显示中文的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用Matplotlib绘图时，如果需要显示中文，需要进行以下设置：
安装中文字体 首先需要将中文字体安装到系统中。可以将字体文件(.ttf或.otf格式)下载到本地，然后在操作系统(Windows, MacOS, Linux等)中将其安装。也可以使用第三方工具安装字体，如在Ubuntu系统中可以使用以下命令安装中文字体:
sudo apt-get install fonts-wqy-zenhei 设置Matplotlib的字体 在代码中通过以下方式设置Matplotlib的字体：
import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] # 指定中文宋体字体 plt.rcParams['axes.unicode_minus'] = False # 解决负号显示问题 其中，['SimHei']可以替换成其他已安装的中文字体，如微软雅黑(['Microsoft YaHei'])、黑体(['SimHei'])等。
在图形中使用中文 在绘图代码中，可以使用中文字符串，例如：
plt.plot(x, y, label='曲线') plt.xlabel('横轴', fontproperties='SimHei') plt.ylabel('纵轴', fontproperties='SimHei') plt.title('标题', fontproperties='SimHei') plt.legend(prop={'family':'SimHei'}) 其中，fontproperties='SimHei'指定使用中文宋体字体。如果图例中也需要显示中文，可以使用prop={'family':'SimHei'}指定字体。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/703e58f20d72dc3a39b737394bde15bc/" rel="bookmark">
			UNet网络模型：数据集制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNet网络模型：数据集制作 一般语义分割的原始图片和标记图片在以下目录下：
SegmentationClass：标记图片。
JPEGImages：原始图片。
数据集往往都是很多的图片等信息，对于数据集类来说，一个类里有所有数据的信息，并且可以用下标进行访问，就像访问数组一样。
在pytorch中有Dataset类，用于创建自定义数据集类。我们可以用继承Dataset类来实现数据集类。在一个数据集类中，需要确定数据集所在的位置，也要用__getitem__实现下标访问，用__len__实现数据集大小。
对于标记图片和原始图片可能大小或者格式不同，需要将这两个图片的格式统一。
代码参考UNet数据集制作及代码实现_哔哩哔哩_bilibili，根据该UP主的代码，加上我的个人整理和理解。（这个UP主的代码感觉很好，很规范
目录的树形结构：
data/ (path) | | |------- SegmentationClass/ | | | |-- 标记图像 | |-- ... | |-- 标记图像 | | | | |------- JPEGImages/ | |-- 原始图像 |-- ... |-- 原始图像 原始图像和标记图像处理 from PIL import Image # 用于读取和处理图像 # 用于加载图像并保存图像大小一致 # path表示图像文件的路径，size表示需要调整的目标大小，默认为(256, 256)。 def keep_image_size_open(path, size = (256, 256)): # 通过Image.open(path)方法打开path路径的图像，并将返回的图像对象保存在变量img中。 img = Image.open(path) # 获取输入图像的最大边长 tmp = max(img.size) # 创建一个新的空白图像对象mask，大小为(tmp, tmp)，颜色为(0, 0, 0)，即黑色。 mask = Image.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/703e58f20d72dc3a39b737394bde15bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db61d88c36b0298a56fedd7573f84a9d/" rel="bookmark">
			UNet简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		UNet简单介绍 语义分割（Semantic Segmentation）是计算机视觉领域的一项基础任务，旨在将图像中的每个像素分配到特定的语义类别中，即对图像中的每个像素进行分类，从而实现对图像像素级别的理解和分析。与图像分类任务不同的是，语义分割需要对图像中的每个像素进行分类，因此其输出的信息量更加丰富，能够为后续的高级任务如目标检测、图像分割、姿态估计等提供更加精细的信息支持。
任务：将图像按照物体的类别分割成不同的区域
等价于：对每个像素进行分类
早期思路：基于先验，按照颜色进行分割（先验知识不完全准确
现在思路：基于卷积神经网络
卷积神经网络被大规模的应用在分类任务中，输出的结果是整个图像的类标签。但是UNet是像素级分类，输出的则是每个像素点的类别，且不同类别的像素会显示不同颜色，UNet常常用在生物医学图像上，而该任务中图片数据往往较少。
Unet 是一种经典的深度学习网络模型，用于图像分割任务。它的结构特点是编码器-解码器架构，并且包含了跳跃连接（Skip Connection）的设计。
Unet 的整体结构可以分为两部分：编码器（Encoder）和解码器（Decoder）。编码器负责逐步提取输入图像的特征，将图像分辨率降低，而解码器则负责逐步恢复分辨率并生成最终的分割结果。
Unet 的编码器部分由多个下采样（Downsampling）层组成，每个下采样层包含一个卷积层和一个池化层，用于逐步缩小图像尺寸和提取特征。这样做的目的是为了引入不同尺度的上下文信息。
Unet 的解码器部分由多个上采样（Upsampling）层和对应的跳跃连接组成。上采样层用于逐步增加图像尺寸，而跳跃连接用于将编码器中的特征图与解码器中相应的特征图进行连接，以保留更多的空间细节和语义信息。每个上采样层也有一个对应的卷积层，用于进一步处理特征。
最后，Unet 的最后一层通常是一个 1x1 的卷积层，用于将特征图映射到指定的类别数，并生成最终的分割结果。
UNet论文：U-Net: Convolutional Networks for Biomedical Image Segmentation (arxiv.org)
在这个模型中，左半部分是：两次卷积 -&gt; 池化 -&gt; 两次卷积 -&gt; 池化 …
右半部分是：上采样 -&gt; 与左半部分对应层进行拼接 …
UNet数据集制作 UNet 浅析_酿久诗的博客-CSDN博客
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d479778b811b156bd160c19d6e16c2ad/" rel="bookmark">
			mysql explain学习记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考了公司内相关博客，实践并记录下，为后面分析并优化索引做准备。
MySQL explain命令是查看MySQL查询优化器如何执行查询的主要方法，可以很好的分析SQL语句的执行情况。
每当遇到执行慢（在业务角度）的SQL，都可以使用explain检查SQL的执行情况，并根据explain的结果相应的去调优SQL等。
github链接： mysql explain学习
一、准备表 # 建表 CREATE TABLE single_table ( id INT NOT NULL AUTO_INCREMENT, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY idx_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3) ) Engine=InnoDB CHARSET=utf8; CREATE TABLE tmp ( id INT NOT NULL AUTO_INCREMENT, key1 VARCHAR(100), key2 INT, key3 VARCHAR(100), key_part1 VARCHAR(100), key_part2 VARCHAR(100), key_part3 VARCHAR(100), common_field VARCHAR(100), PRIMARY KEY (id), KEY idx_key1 (key1), UNIQUE KEY idx_key2 (key2), KEY idx_key3 (key3), KEY idx_key_part(key_part1, key_part2, key_part3) ) Engine=InnoDB CHARSET=utf8; # 生成一些数据 # 定义存储过程 DROP PROCEDURE IF EXISTS proc_initData; DELIMITER $ CREATE PROCEDURE proc_initData() BEGIN DECLARE i INT DEFAULT 1; WHILE i&lt;=10000 DO insert into single_table(key1,key2,key3,key_part1,key_part2,key_part3,common_field) VALUES(substring(md5(rand()),1,15),floor(10000000 * rand()),substring(md5(rand()),1,15),substring(md5(rand()),1,15),substring(md5(rand()),1,15),substring(md5(rand()),1,15),substring(md5(rand()),1,15)); SET i = i+1; END WHILE; END $ delimiter ; # 上面定义存储过程后,可能会有key冲突,可以多执行几次，生成较多测试数据 CALL proc_initData(); 二、测试 mysql&gt; EXPLAIN SELECT * FROM single_table\G; *************************** 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d479778b811b156bd160c19d6e16c2ad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8065bac38ad94d95077de6dcf30d16c7/" rel="bookmark">
			QNX启动流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IFS(startup header + image) 操作系统映像(OS Image) 是包含操作系统、您的可执行文件以及可能与您的程序相关的任何数据文件的文件。操作系统映像包括操作系统(procnto)、启动代码、启动和运行操作系统所需的库(libc.so)，以及访问基本硬件所需的任何驱动程序或其他代码和文件。
通常，小型嵌入式系统只有一个（可引导的）操作系统映像。在QNX系统中，这包括以下组件：
启动代码：startup-*操作系统内核和进程管理器：procnto驱动程序和管理器（例如，io-pkt、devnp-ncm.so、devc-ser8250、devb-eide、esh（嵌入式shell）、ksh）应用程序数据文件 启动后，QNX操作系统映像的内容作为文件系统显示在：/proc/boot。事实上，理解操作系统映像的一个好方法是将其视为一个小型文件系统。
在QNX语言中，操作系统映像通常简称为IFS，即图像文件系统。这个IFS有一个小的目录结构和一些文件。该目录告诉操作系统内核和进程管理器procnto操作系统映像中文件的名称和位置。当QNX嵌入式系统运行时，即使操作系统映像位于/proc/boot，也可以像访问任何其他只读文件系统一样访问它。
启动过程 1. BootRom做最少的硬件初始化，跳至IPL其余的由IPL完成，有些芯片无bootrom。 a. BootRom + IPL/uboot，热启动（BootRom已经初始化过了hw/cpu一些配置）b. Ubootc. IPL，冷启动（hw/cpu一些配置全由初始化） 2. IPL启动【ipl比uboot更快，IPL的主要职责就是进行最小的硬件配置以启动Startup程序】 IPL源码分析link文件，启动头分析（启动头一个结构体在startup.h）
手册翻译
- src\hardware\ipl\boards\xzynq-frgen21\xzynq-frgen21.lnk的链接来看第一个执行
-src\hardware\ipl\boards\xzynq-frgen21\_start.S
a. 初始化内核可运行的基本硬件 配置芯片选择和PCI控制器、时钟和内存控制器通过I2C设置电源管理IC（PMIC（Power Management IC）电压轨）设置一些GPIO管脚来控制复位管脚配置一个定时器来精确测量延迟 实际上，就配置了cache，然后就jump2c
b. 运行start.s程序 为C语言环境设置堆栈。堆栈允许运行main.c程序。
-src\hardware\ipl\boards\xzynq-frgen21\main.c
a. IPL 的第一部分中未完成初始化的硬件（内核可运行的基本硬件） b. 将操作系统映像加载到RAM中 ifs（image filesystem）组成：IFS(startup header + qnx image)应该是包括startup+os+buildfile+驱动，app，二进制执行文件。Image storage镜像存储介质及存储方式（是否压缩）对IPL设计影响 线性ROM（例如，NOR FLASH），可直接寻址（线性映射设备可以直接映射到处理器的地址空间） 压缩，将整个IFS（包括启动代码）cp到临时RAM中非压缩，XIP（就地执行启动代码）或者只需要将startup程序拷贝到RAM(sdmmc_load_file())或者将整个IFS cp到最终RAM 非线性ROM（例如 eMMC、SD 卡或 SPI NOR 设备），不能直接寻址 压缩，将整个IFS cp到临时RAM中非压缩，将整个IFS cp到最终RAM c.当操作系统映像位于可以执行的位置（RAM或XIP的线性映射存储）时， 扫描内存查找并验证IFS并返回addr【addr=image_scan_2()】 d. 调用image_setup()来检查启动标头结构，然后使用IFS已复制到RAM中的地址修补其startup_vaddr成员。当image_setup()返回时，启动代码应位于RAM（可以执行的位置）中，并且操作系统映像的地址应位于startup_header结构的startup_vaddr成员中。（image_setup_2(addr)） IPL使用启动头文件(startup.h)将信息传递给启动程序
e. 跳转到加载好的IFS执行startup代码将控制权交给启动代码（image_start_2(addr)） 注意：IPL的两个部分都存储在引导设备上的相同位置。第一部分，由BootRom激活，是用汇编语言编写的，通常是常规的_start[ab]。第二部分是用C写的，完成第一部分未完成的初始化任务[abc]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8065bac38ad94d95077de6dcf30d16c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b785c37956c146093830c0c34fa70e36/" rel="bookmark">
			cmd基础命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cmd基础命令 常用规则 @echo off：关闭所有回显包括本身，不然每一行都会显示在cmd包括注释，去掉可用作调查；@表示后面的命令不显示。
-
echo.：换行。
exit /b 1：
exit：退出当前cmd窗口实例。exit 0：退出当前cmd窗口实例，并将过程退出代码设置为0（0表示成功，非0表示失败）。exit /B 1：退出当前bat脚本，并将ERRORLEVEL系统变量设置为1。 pause：不加执行完会直接推出cmd窗口，加了最后会提醒出入回车关闭窗口。
参数：
%~dp0：%~d0取驱动盘名，%~p0取路径名，不含驱动盘名；扩充到当前目录。%CD%：扩展到当前目录。%~1：代表传给脚本的第一个参数，当参数以引号开头时，%~1会自动将引号删除。 %errorlevel%：DOS程序在运行结束后会返回一个数字值用来表示程序运行的结果（或者状态），0表示成功，&gt;0表示失败。
SET变量相关 set var=string：给变量赋值字符串，“string”的话显示值也会带引号。
set var：显示值。
set var=：删除该变量。
set /p var=：var值为输入字符串。
%VAR:str1=str2%：字符替换，把把变量名中的str1字符串替换成str2，没有就不换；"%VAR:R=%"，去掉R。
%VAR:~0,24%：字符串截取，把变量从第1个字符开始（包括）截取24个字符，0第一个char，-1最后一个，-2倒数第二。
使用环境变量：
-
set BUILD_SUPPORT=C:\Users\Z0178023\myPrj\FRGen21_Tools %FRGen21_BuildSupport% 我们没有定义，但是环境变量有与上面会先消息一致。
setlocal：局部变量。setlocal到endlocal之间给变量赋值，仅在这区间有效；或者没有endlocal；一般set只会在下一条语句生效，加上setlocal。
if相关语句 基本规则：if和执行的命令，if和else，要在同一行，不然是错的。例如：if exist filename( echo yes! )ELSE( echo NO1 echo NO2 ) If not exist或exist，一般是不存在那个目录或文件。equ/==：等于，neq：不等于，lss：小于，leq：小于等于，gtr：大于，geq：大于等于。注意：空格，空格不加会报语法错误。if "%ALGORITHMRAW_NAME_NEW%"=="" ( for语句必看 for %%i in (*.*) do echo %%i：无参数。in在某些文件中，for %%i对于其中的某个文件，do做下面处理。for %%i in (A，B，C) do echo %%i：无参数，处理字符串序列。/l是重要的参数之一，用来指定数值变量的步进循环模式。 for /l %%i in (5,3,16) do echo %%i：从5开始到16为止每次递增3作为变量%%i的值，5 8 11 14，do做下面处理。 /f对指定范围内的文字进行循环，可以是一个文件里的文字，可以是一个字符串，也可以是一条命令的输出结果： 将命令返回结果用作处理，用单引号：for %I in ('command') do command。兼容usebackq： 路劲兼容，用双引号：for %I in ("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b785c37956c146093830c0c34fa70e36/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f296e546d6526a0b2f2bd1049215f9b8/" rel="bookmark">
			CMakelist专题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 参考文献内置变量常用API构建子cmakelist引入第三方库 参考文献 参考1
参考2
参考3官网qnx交叉编译
内置变量 CMAKE_CURRENT_LIST_FILE: 当前处理的 CMakeLists.txt 文件的完整路径。CMAKE_CURRENT_LIST_DIR: 当前处理的 CMakeLists.txt 文件所在的目录路径。CMAKE_CURRENT_FUNCTION: 当前调用的函数名。PROJECT_NAME: 项目名称，由 project() 命令设置。CMAKE_MODULE_PATH: 模块查找路径，由 set(CMAKE_MODULE_PATH ...) 命令设置。CMAKE_PREFIX_PATH: 前缀路径，由 set(CMAKE_PREFIX_PATH ...) 命令设置，指定项目依赖库的安装路径。CMAKE_BUILD_TYPE: 构建类型，可选项为 Debug 或 Release，由 set(CMAKE_BUILD_TYPE ...) 命令设置。CMAKE_INSTALL_PREFIX: 安装路径，由 set(CMAKE_INSTALL_PREFIX ...) 命令设置，指定项目安装路径。 常用API set 设置参数，包含一般/缓存/环境变量。 PARENT_SCOPE
【不加：子目录修改父目录变量效果只能作用域子目录，父目录读取该变量值不变；父目录读不到子目录的变量值】 list 针对列表操作，比如针对文件列表/参数列表/编译列表的增加删除这些。file 针对文件操作，如收集文件列表，读写文件等。string 针对字符串的操作，如大小写，查找，正则表达式匹配等。message 打印消息,可以跟踪测试修改。message(“${aa}”)mark_as_advanced(COMPILER_BIN_PATH) 没有$变量!!标记已命名的缓冲变量为advanced，advanced变量不会在cmake图形界面中显示除非advanced选项开启foreach 循环target_compile_options()：指定目标的编译选项target_link_libraries：将已知库链接到一个目标上(add_executable()或add_library()之类的命令创建)target_include_directories：指定目标包含的头文件路径。 上面3个带有PUBLIC，PRIVATE，INTERFACEPRIVATE：私有的，ab为2个a库，a私有依赖b；prj【a(私有b)】project看不到b的h文件，b只给aPUBLIC：就是指定搜索头文件路径是可见的，这意味着对于调用这个库的prj只需要 include_directories: 添加包含头文件路径。全局包含，向下传递；即如果某个目录的 CMakeLists.txt 中使用了该指令，当前cmakelist及其下所有子cmakelist的目标默认也包含了该目录。add_library：添加h和c文件，生成（静态/动态）库so或者.a文件，默认a库。如果只添加c文件，那么也会添加当前文件夹下的h文件。
动态库libhello.so：add_library( hello SHARED ${libhello_src})
静态库libhello_static.a：ADD_LIBRARY (hello_static STATIC ${LIBHELLO_SRC}
注意： target不能重复，但如果静态库也想是libhello.a，那么就要设置属性get_target_property()；已有同名库时（比如生成静态库libhello.a发现有同名动态库libhello.so那么会删除先前的同名库，可以同上设置属性来避免） add_executable：生成执行文件。add_subdirectory：添加一个子目录并构建该子目录，用于多个Cmakelist构建；aux_source_directory：查找指定目录下的所有源文件(只能找到c)，然后将结果存进指定变量名get_filename_component：获取完整文件名路径的特定部分。add_dependencies：被依赖的项目总是最先构建，这样就不会出现找不到库而报错；add_custom_command ：用户自定义命令target_sources：新的构建子cmakelist方式，更优秀。
编译器相关设置set_source_files_properties：指定源文件一些具体编辑器里的属性，给源文件设置一些属性。set_target_properties：给可执行文件或者库，不能是虚构的变量等设置属性。使用get_property()或get_target_property()命令提取它。结合add_library看例子 希望 “hello_static” 在输出时，不是"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f296e546d6526a0b2f2bd1049215f9b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbab7bdf44bc47b19450fad7ef0e5873/" rel="bookmark">
			QNX交叉编译
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 QNX交叉编译 参考文献QNX交叉编译环境寻找qcc.exe编译器 编译环境 参考文献 参考1
参考2
参考3指定gcc540
参考4手册
QNX交叉编译环境 host，PC主机
target，装有QNX的目标
寻找qcc.exe编译器 在windows下的交叉编译工具CMAKE_C_COMPILER在路径${COMPILER_BIN_PATH}
= = &gt;${QNX_HOST}/usr/bin/qcc.exe【编译器指定为qcc】
交叉编译手册建议用qcc调用gcc（功能qcc &gt; q++，当然直接用gcc也行），那么就是设置c编译器目标为arch【gcc/5.4.0,gcc_ntoaarch64le有看文章这么写的，应该只是为了找到conf文件，配置qcc实际调用的编译器】
即在arch这个目录下，找目标配置文件；编译器是从目标推断出来的。
= = &gt;${QNX_HOST}/etc/qcc/gcc/5.4.0/gcc_ntoaarch64le.conf打开conf文件：
ar=$(QNX_HOST)/usr/bin/aarch64-unknown-nto-qnx7.0.0-ar
as=$(QNX_HOST)/usr/bin/aarch64-unknown-nto-qnx7.0.0-as
ld=$(QNX_HOST)/usr/bin/aarch64-unknown-nto-qnx7.0.0-ld
lto_cc=$(QNX_HOST)/usr/bin/aarch64-unknown-nto-qnx7.0.0-gcc-5.4.0
其中lto_cc为使用的gcc编译器
${QNX_TARGET}这个路径里面都是一些文件，我们这里就是为了添加一些文件
编译环境 一般用make，下载个mingw，再export一下make编译器环境就可以了
设置编译器编译模式：
set( CMAKE_BUILD_TYPE “Debug”)设置编译器
两句会拼接在一起
set(CMAKE_C_FLAGS_INIT “-Wall -march=armv8-a+crc -D_GLIBCXX_USE_C99=1”)
set(CMAKE_C_FLAGS_RELEASE “-O3 -ffast-math -D_GLIBCXX_USE_C99=1”)编译参数，如图为sh脚本配置的cmake规则
cmake规则设置有两种，一种是cmakeliset，一种是脚本里给cmake编译器添加规则.camke 编译设置覆盖规则：顶层cmakelist &gt; sh脚本给cmake添加的 .cmake设置 &gt; 子cmakelistcmake -D 传参给.cmake已经export到环境变量后，就不需要-D做cmake编译选项了 问题
使用cmake时 什么时候删掉整个build，什么时候只需要make clean 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c02d2c0ae41464d249fd95410423d94d/" rel="bookmark">
			VMware安装CentOS Stream 8以及JDK和Docker
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、下载镜像源 地址：https://developer.aliyun.com/mirror/?spm=a2c6h.25603864.0.0.285b32d48O2G8Y
二、安装配置 配置项 一共有以下这些，其中软件、软件选择 、安装目的地、网络主机名需要讲一下，其他都简单，自行设置即可。
说明：
时间和日期中的中，网络时间开启需要先配置网络和主机名，不然开不了。
安装源：http://mirrors.aliyun.com/centos/8-stream/BaseOS/x86_64/os
然后进行简单配置一直下一步就可以了。
详细步骤请参考本人另外的文章：https://blog.csdn.net/qq_42971035/article/details/122245460
三、修改镜像源 具体修改 文章，参见：https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.4afd1b11brozIm
因为如果不修改的话，很多东西下载不了或者很慢 ，因为centOS8在 Linux 社区已经停止维护了。
就是检查一下可安装的jdk就需要等半天。
3.1 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/ 使用root用户执行以下命令，如果是普通用户请切换到root用户，命令如下：
# 切换 root 用户 su root # 输入root 用户密码 wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo 下载后会保存到这个目录：
/etc/yum.repos.d/CentOS-Base.repo
3.2 重新建立缓存 执行如下命令：
yum makecache 3.3 全部命令切换源 # 备份，如果没有老的就不需要执行这一步 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup # 下载最新 的 wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo # 清理缓存 重建缓存 yum clean all &amp;&amp; yum makecache 四、安装JDK 安装JDK的文章网上很多 ，有安装包安装的 ，也有YUM源安装的。我们这里 为了方便 就是用yum源安装 。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c02d2c0ae41464d249fd95410423d94d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5ae6418ff8c2462cea937d22b88b180/" rel="bookmark">
			利用Cython发布python项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有个python项目要发布，遇到了两个问题，一是项目在windows下运行有点慢，二是python都是脚本直接运行，没法保护代码安全。查了一下，有人说可以利用Cython，把python代码编译成为C++来调用。即能提高运行性能，又能实现对代码加密。我尝试做了一遍，果然成功的解决了上面两个问题，所以把过程记录下来。我是在windows 11的环境下操作的。
1、先安装Cython。直接执行命令pip install Cython就可以了。我安装的是0.29.20版本；
2、然后安装VS，可以直接去官网下载。我是从“软件管家”下载的2019版本，安装的时候只需要安装“C++生成工具”（注意：不同版本这个名字不太一样，只要包含后面两项就可以）下面的“MSVCv142 - VS2019 C++ x64/x86生成工具(v14...”和“Windows 10 SDK(10.0.17763.0)”这两项就行了；
3、新建一个目录，要处理的py文件放在里面。我这里创建了一个目录叫“TestPath”，然后放进去了一个我的python文件，名字叫做Demp.py。下面就是py文件的全部内容：
def Doing(content): ConArr = content.split(',') for c in ConArr: print(c) if __name__ == "__main__": Doing('A,B,C,A,A,A') 执行之后效果如下：
A B C A A A 4、接下来在新创建的目录下新建一个pyx文件，把Demo.py文件里面的方法放进去。我这里创建的pyx文件名是fib.pyx，下面是pyx文件的全部内容：
def Doing(content): ConArr = content.split(',') for c in ConArr: print(c) 【注意】这里的fib.pyx文件一定要使用UTF-8编码，这是个坑，我今天没注意，折腾了一上午。如果不是UTF-8编码保存的（我一开始是ANSI），就会报错如下：
fatal error C1189: #error: Do not use this file, it is the result of a failed Cython compilation. error: command 'C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b5ae6418ff8c2462cea937d22b88b180/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13417264ed2d5fdf2458342555889f6f/" rel="bookmark">
			Docker注入环境变量且设置多个环境变量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 方式一 运行docker命令修改 在运行docker时，直接使用-e或–env，输入需要改变的变量
例如：springboot配置文件如下,可注入环境变量启动端口SERVER_PORT，以及启动配置文件NODE_ENV:dev
server: port: ${SERVER_PORT:8400} spring: application: name: @project.artifactId@ profiles: active: - ${NODE_ENV:dev} redis: database: 2 启动命令注入如下：
docker run -it
-e SERVER_PORT=9080 -d 容器id
替换多个如下：
docker run -it
-e SERVER_PORT=9080
-e NODE_ENV=prod
-d 容器id
方式二 在你的Dockerfile中直接写入环境变量 # default env ENV NODE_ENV dev ENV SERVER_PORT 8400 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/534a5d0545cea9f5a9ce9924055b4e45/" rel="bookmark">
			ORA-03113：通信通道的文件结尾-完美解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle 文档中对这个错误这样解释： ORA-03113 错误就是说连接到数据库的网络中断了。有些错误由于频繁出现、原因复杂而被 Oracle DBA 们戏称之为"经典的错误"。
完美解决方案：
1、查看系统表空间用量： SELECT a.tablespace_name, a.bytes total, b.bytes used, c.bytes free, ( b.bytes * 100 ) / a.bytes "% USED ", ( c.bytes * 100 ) / a.bytes "% FREE " FROM sys.sm$ts_avail a, sys.sm$ts_used b, sys.sm$ts_free c WHERE a.tablespace_name = b.tablespace_name AND a.tablespace_name = c.tablespace_name; 2、分析ORA-03113主要原因 从图中主要分析SYSTEM、SYSAUX表空间用量，原因有两点：
1）、SYSTEM中审计表aud$在数据库编程过程中，对SQL语句的编译过程，资源占用会较大，因此在sys账户下查看，
select count(*) sum from AUD$; 会得知，该数值会非常大。
2）、SYSAUX则进行的是AWR快照，也会进行占用较多的空间。
因此，出现ORA-03113，一般以上两个空间会出现严重不足情况。
3、完美解决方式 用sys账户dba登录，两个原因一一解决：
1）、清理AUD$审计表记录；
Truncate table AUD$; 清理AUD$审计表一条命令即可。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/534a5d0545cea9f5a9ce9924055b4e45/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb3389c4a7ced92ae11356feda93d3cb/" rel="bookmark">
			c&#43;&#43;八股文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		游戏客户端开发常见八股文 c++篇
文章目录 游戏客户端开发常见八股文前言一、C++内存管理常考察点1. C++的构造函数，复制构造函数，和析构函数2. 什么是深复制和浅复制3.构造函数和析构函数哪个能写成虚函数，为什么4.C++数组，链表，二叉树的内存排列是什么样的5.结构体占多大内存如何计算，类占用多大空间如何计算，空类的空间是多少，为什么5.虚函数和虚表的原理是什么（重点）6.内存泄漏出现的时机和原因，如何避免7.指针的工作原理8.函数的传值和传址9.new和delete使用解释一下，和malloc和free的区别10.C++内存区域划如何分说一下（栈，堆那些） 二、C++11 新特性1.常见的c++11新特性有哪些2.智能指针用过吗，有哪些，他们的区别和各自的优缺点3.auto关键字知道吗，如果全部都用auto声明变量行不行4.lambda表达式会用吗5.override关键字必须吗6.右值引用 总结 前言 看到了一些关于游戏开发c++笔试、面试题，但是有题目没有答案，作为一个只会一点点c++的小菜鸡就记录一下，以下问题答案都是chatGPT回答以及百度答案
面试问题来源：游戏开发岗面试总结
一、C++内存管理常考察点 1. C++的构造函数，复制构造函数，和析构函数 构造函数（Constructor）：C++中的构造函数用于初始化对象的数据成员。构造函数的名称与类名相同，没有返回类型，包括参数列表和函数体。构造函数在创建对象时自动调用，并且可以重载，即可以有多个构造函数。
复制构造函数（Copy Constructor）：复制构造函数用于通过已有对象创建一个新对象。复制构造函数的参数是一个同类的对象引用，它用于初始化新对象的数据成员。如果没有显式定义复制构造函数，C++会自动生成一个默认的复制构造函数。复制构造函数通常使用深拷贝（deep copy）来避免浅拷贝（shallow copy）带来的问题。
析构函数（Destructor）：析构函数用于在对象销毁时释放资源和做一些清理工作。析构函数的名称与类名相同，前面加上一个波浪号(~)作为前缀。析构函数没有返回类型，没有参数。当对象超出作用域、被删除或程序结束时，析构函数会被自动调用。如果没有显式定义析构函数，C++会自动生成一个默认的析构函数。
代码如下（示例）：
#include &lt;iostream&gt; class MyClass { public: // 默认构造函数 MyClass() { std::cout &lt;&lt; "Default constructor called" &lt;&lt; std::endl; } // 带参数的构造函数 MyClass(int value) { std::cout &lt;&lt; "Parameterized constructor called with value: " &lt;&lt; value &lt;&lt; std::endl; } // 复制构造函数 MyClass(const MyClass&amp; other) { std::cout &lt;&lt; "Copy constructor called" &lt;&lt; std::endl; } // 析构函数 ~MyClass() { std::cout &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cb3389c4a7ced92ae11356feda93d3cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38a801c58db4ac2515654ead21eea07d/" rel="bookmark">
			如何批量为文件夹命名
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你想要命名一些这样名字具有规律性的文件夹，当文件的数量增多，一个一个命名是非常耗费时间的。很容易想到，如果使用EXCEL，只需往下拉，就能很轻松的拉出1到5。那么，我们如何利用EXCEL来对文件夹进行快速的批量命名呢？
以上图为例子，人名可能是我们已知的，可以从表格直接复制过来。而客户名1到客户名5，我们可以直接使用下拉的方式快速得到。
那么，使用公式 =A1&amp;B1就可以合并他们得出我们想要批量输入的文件夹名。但因为，这里是包含公式的，我们需要重新粘贴，将他们保存为值。
保存为值后，我们需要再次复制，然后点击选择性粘贴，勾选转置，然后确定。我们就可以得到横向排列的我们所需要的数据。这样可以便于我们稍后粘贴到我们的代码中。
完成上述操作后，我们要在我们需要放置的文件夹中，新建一个文本文档，打开后，输入md 后面粘贴上我们刚刚预处理好的值。然后点击另存为。
注：DOS命令中，md是创建文件夹的意思
在另存为中，我们需要把文件后缀改为.bat，即批处理文件类型。编码方式改为ANSI。点击保存并关闭后。我们可以看到一个.bat后缀的可执行文件。双击它后，我们就可以看到文章开头的效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53a9aed27b9f1a14fb00b1bac9dad6fd/" rel="bookmark">
			python学习之【with语句】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一篇文章 ​ ​python学习之【文件读写】​​​ 中我们学习了python当中的文件读写，这篇文章接着学习python中文件读写的with语句。
了解with语句 在很多场景中，通过使用with语句可以让我们可以更好地来管理资源和简化代码，它可以看做是对
try…finally模式的简化。
with语句的语法格式
with open(文件名，打开方式，编码格式) as 别名:
with语句体
with语句可以自动管理上下文资源，不论是什么原因跳出with块都能确保文件可以正确的关闭 ，以此来达到释放资源的目的。
举几个例子：
如果是利用以前的知识来进行文件读取的操作，流程就是打开文件——》读取文件——》关闭文件。
例如：
# 比如我们要读取一个文件，如果不用with语句实现的话： #打开文件 file_a=open('a.txt','r') #读取文件 print(file_a.read()) #关闭文件，释放资源 file_a.close() 但是假如在读取文件的过程中出现异常的话，会对我们后续的关闭文件操作产生影响，从而导致资源无法释放。那应该怎样实现在读取文件时无论有没有产生异常都让打开了的文件及时关闭呢？我们可能会想到用try…except去完成
try: # 打开文件 reader=open('a.txt','r') # 操作文件 content=reader.read() print(content) except Exception: #有异常打印出异常，避免程序性报错 print(Exception) finally: #关闭文件 reader.close() try…except 的确会当对文件操作时发生异常不让程序发生报错，但是try…except是一种固定的格式，如果我们需要读取的文件有十几二十个呢，是不是需要按照try…except 的语法格式写很多条关闭操作的固定代码呀，这时候就出现了with语句来简化我们繁琐的代码：
#用with语句写 执行完毕with语句体之后会自动调用open中的__exit__方法对文件关闭， #我们就不需要再写close()操作了 with open('a.txt','r') as file: print(file.read()) 我们看只需要两行代码就能实现文件的读写；下面这个例子会更直观的看出with语句的妙处:
# 不使用with语句复制图片 file_src=open('befor.png','rb') file_tgt=open('after.png','wb') file_tgt.write(file_src.read()) file_src.close() file_tgt.close() # 使用with语句复制图片 with open('befor.png','rb') as src_file: with open('copy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53a9aed27b9f1a14fb00b1bac9dad6fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9de7667299cf64206898d5e430bc778/" rel="bookmark">
			统信UOS如何设置IP地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、查询ip地址 用nmtui进入手动设置经常显示无法保存。
命令：
ip a
这里我们发现ens2f1状态是up，其他是down，所以我们准备把ens2f1的ip地址改为我们的目标IP地址，假设为10.168.1.143，网关为10.168.1.255。
2、修改ip地址 命令行
sudo vi /etc/network/interfaces
打开interfaces文件
按i进入编辑模式
auto ens2f1:0 iface ens2f1:0 inet static
address 10.168.1.143
netmask 255.255.255.0
gateway 10.168.1.255
配置好后用以下语句实现网卡重启,如果未生效，可重启电脑。
sudo ifconfig ens2f1 down
sudo ifconfig ens2f1 up
重启电脑才生效
成功！ 若需要增加多个ip地址，参考下面代码：
auto ens2f1:0 iface ens2f1:0 inet static
address 10.168.1.143
netmask 255.255.255.0
gateway 10.168.1.255
auto ens2f1:1
iface ens2f1:1 inet static
address 192.168.6.229
netmask 255.255.255.0
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd967b1d72e7238f68dcc898e9c90ec9/" rel="bookmark">
			PCI/PCIe转串口Linux驱动使用说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		PCIe转串口芯片CH382/CH384以及PCI转串口芯片CH351/CH352/CH353/CH355/CH356/CH357/CH358/CH359以及使用如上芯片外加CH432/CH438的组合串口转接方案均支持Windows和Linux操作系统，在系统下会生成多个独立的串口，各虚拟串口分别对应一个硬件串口。各串口独立工作，互不影响。本文主要介绍Linux操作系统如何为设备加载厂商串口驱动。
厂商驱动下载链接： CH38XDRV.ZIP - 南京沁恒微电子股份有限公司
厂商驱动Github链接：https://github.com/WCHSoftGroup/ch35_38x_linux
步骤一：解绑系统内置串口驱动 1、使能root权限 因如下各操作均需要root权限，可以在终端下通过"sudo su"或“sudo -i”命令开启该权限。当然也可以在后续操作时每条命令前单独加上sudo关键字。
2、确定串口卡状态 Linux内核中，系统启动时会自动加载内置的8250_pci驱动。该驱动包含各厂家PCI/PCIe产品，可以通过lspci命令确认当前硬件的工作状态以及驱动匹配情况。CH35x和CH38x芯片使用的VID有2种：0x1C00和0x4348，命令为：
lspci -vd 1c00:* lspci -vd 4348:* 运行如上命令后，若设备存在，则会显示如下设备信息：
07:00.0 Serial controller: Device 1c00:3470 (rev 10) (prog-if 05 [16850]) Subsystem: Device 1c00:3470 Flags: fast devsel, IRQ 41 I/O ports at 1000 [size=256] Memory at 58700000 (32-bit, prefetchable) [size=32K] I/O ports at 1100 [size=4] Expansion ROM at 58700000 [size=32K] Capabilities: [60] Power Management version 3 Capabilities: [68] MSI: Enable- Count=1/32 Maskable+ 64bit+ Capabilities: [80] Express Legacy Endpoint, MSI 00 Capabilities: [100] Advanced Error Reporting Kernel driver in use: serial Kernel modules: 8250_pci 如上所示，在“Kernel modules”信息中会显示当前已经为该设备加载的驱动。注：系统内置的可以满足设备基础串口通信的需求，该驱动为串口卡创建的设备名称为：/dev/ttySn，也可以通过dmesg | grep ttyS 通过对比ttyS的IO地址和lspci的地址来确定具体的ttyS通道。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cd967b1d72e7238f68dcc898e9c90ec9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49bc1201fbe8d607dfc764abe97e56d4/" rel="bookmark">
			python学习之【文件读写】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 上一篇文章​ ​ python学习——【第十四弹】 ​​​中学习了python中的包与内置模块，这篇文章接着学习python中的文件读写。
编码方式 在学习文件读写之前，我们先了解下python当中的编码方式:
字节(Byte)是计量单位，表示数据量多少，是计算机信息技术用于计量存储容量的一种计量单位，通常情况下一字节等于八位。 字符(Character)计算机中使用的字母、数字、字和符号，比如'A'、'B'、'$'、'&amp;'等。 一般在英文状态下一个字母或字符占用一个字节，一个汉字用两个字节表示。 ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。 UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。 Unicode 编码中，一个英文为一个字节，一个中文为两个字节。 符号：英文标点为一个字节，中文标点为两个字节。例如：英文句号 . 占1个字节的大小，中文句号 。占2个字节的大小。 UTF-16 编码中，一个英文字母字符或一个汉字字符存储都需要 2 个字节（Unicode 扩展区的一些汉字存储需要 4 个字节）。 UTF-32 编码中，世界上任何字符的存储都需要 4 个字节。 python的解释器使用的Unicode（内存），python文件（.py）在磁盘上使用的是UTF-8（外存）。
python3中默认使用的是UTF-8的编码；
我们可以使用sys模块中的getdefaultencoding()获取默认的编码格式
import sys print(sys.getdefaultencoding()) # utf-8 在计算机内存中，统一使用的是Unicode编码，当需要保存在硬盘或者是需要传输的时候，就会转换为UTF-8编码：
当我们用记事本进行编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里；编辑完成后进行保存，会再将Unicode转换为UTF-8保存到文件中。
我们看用python文件用记事本打开，然后另存时默认的编码类型：
而记事本的保存的默认编码格式是ANSI，（准确说，并不存在哪种具体的编码方式叫做ANSI，它只是一个Windows操作系统上的别称而已。在中文简体Windows操作系统上，ANSI就是GBK），如果我们直接用python去新建一个txt文本文档的文件，由于编码格式的不兼容，因此会发生乱码：
为了避免编码格式不兼容的问题，我们可以在代码中进行修改写入数据的编码格式为UTF-8：
f = open("编码.txt", "w",encoding='UTF-8')#将输入数据的编码格式改为UTF-8 f.write("你好！世界！") f.close() 想要对编码格式多加了解的伙伴，可以参考这篇文章：​ ​点击查看​​​。​
常见的文件打开模式 按照文件数据的组织形式，文件分为以下两个大类：
文本文件：存储的是普通“字符”文本，默认为Unicode字符集，可以使用记事本程序打开 二进制文件： 把数据内容用“字节”进行存储，无法用记事本打开，必须使用专用的软件打开，如图片文件（.png .jpeg等）以及 .doc文档等。 常见的打开模式： r 以只读的模式打开文件，文件的指针将会放在文件的开头 w 以只写的模式打开文件 如果文件不存在就创建，如果文件存在就覆盖文件的原有内容，文件指针在文件的开头 a 以追加的模式打开文件，如果文件不存在就创建，文件指针在文件开头；如果文件存在，则在文件末尾追加内容，文件指针在源文件末尾 b 以二进制的方式打开文件 不能单独使用，需要与共它模式一起使用 如 rb（只读的方式打开二进制文件）或者wb（只写的方式打开二进制文件） + 以读写的方式打开文件，不能单独使用，需要和其他模式一起使用 比如 a+ 需要注意的是：我们在进行对文件的读写操作时，代码最后要对文件进行close()关闭操作：close()操作把缓冲区的内容写入文件，同时关闭文件，释放文件对象相关资源。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/49bc1201fbe8d607dfc764abe97e56d4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40fbe7cbfd80d80ad9fc1452d5b1840e/" rel="bookmark">
			【笔试真题记录】2023华为9.20机试第二题（DFS和BFS）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
班级组织传球活动，男女同学随机排成m行n列队伍，第一列中的任意一个男同学都可以作为传球的起点，要求最终将球传到最后一列的任意一个男同学手里，求所有能够完成任务的传球路线中的最优路线(传球次数最少的路线)的传球次数。
传球规则：
1.男同学只能将球传给男同学，不能传给女同学。
2.球只能传给身边前后左右相邻的同学。
3.如果游戏不能完成，返回-1。
说明：
1.传球次数最少的路线为最优路线。
2.最优路线可能不唯一，不同最优路线都为最少传球次数。
解答要求：
时间限制:C/C++100ms其他语言: 200ms内存限制: C/C++256MB,其他语言: 512MB
输入：
班级同学随机排成的m行n列队伍，1代表男同学，0代表女同学。
输入第一行包含两个用空格分开的整数m[1,30]和n [1,30]，表示m行n列的队伍;
接下来是m行每行包含n个用空格分开的整数1或0。
输出：
最优路线的传球次数（最少传球次数）
样例
输入：
4 4
1 1 1 0
1 1 1 0
0 0 1 0
0 1 1 1
输出：
5
//DFS import java.util.Scanner; public class Huawei { private static int minPasses = Integer.MAX_VALUE; private static int[] dx = {-1, 1, 0, 0}; private static int[] dy = {0, 0, -1, 1}; public static void main(String[] args) { Scanner scanner = new Scanner(System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40fbe7cbfd80d80ad9fc1452d5b1840e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd9c3cabf101829989c55d76a6556f50/" rel="bookmark">
			COCO标签转VOC
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转换的代码
''' 把coco数据集合的所有标注转换到voc格式，不改变图片命名方式， 注意，原来有一些图片是黑白照片，检测出不是 RGB 图像，这样的图像不会被放到新的文件夹中 ''' from pycocotools.coco import COCO import os, cv2, shutil from lxml import etree, objectify from tqdm import tqdm from PIL import Image # 生成图片保存的路径 CKimg_dir = './dataset/voc/images' # 生成标注文件保存的路径 CKanno_dir = './dataset/voc/annotations' # 若模型保存文件夹不存在，创建模型保存文件夹，若存在，删除重建 def mkr(path): if os.path.exists(path): shutil.rmtree(path) os.mkdir(path) else: os.mkdir(path) def save_annotations(filename, objs, filepath): annopath = CKanno_dir + "/" + filename[:-3] + "xml" # 生成的xml文件保存路径 dst_path = CKimg_dir + "/" + filename img_path = filepath img = cv2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd9c3cabf101829989c55d76a6556f50/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/109/">«</a>
	<span class="pagination__item pagination__item--current">110/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/111/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>