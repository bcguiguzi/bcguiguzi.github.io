<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta name="generator" content="Hugo 0.122.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>编程鬼谷子的博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="编程鬼谷子的博客">
		<meta property="og:title" content="编程鬼谷子的博客" />
<meta property="og:description" content="编程鬼谷子的博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://bcguiguzi.github.io/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="编程鬼谷子的博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="编程鬼谷子的博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">编程鬼谷子的博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/189134b12a78c87e947f794289611a51/" rel="bookmark">
			仿网页列表的实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		序言实现思路代码实现效果展现总结 序言 最近遇到了一项需求，用Android实现网页中的列表效果；首先我便想到了用ListView的方式来实现，由于网页的表格数据通常都是以一行的形式展现的，因此，我把需要展现的数据放在了一行，可是需要展示的数据有很多，一行是无法显示完的，为了能够显示超出的那部分，我便想到了在ListView的外面嵌套了一层水平滚动条(HorizontalScrollView)来实现ListView能够水平移动的效果，虽然效果是初步实现了，可是ListView却无法实现上下对其的效果，虽然可以对ListView的Item设置固定的文本的长度，但是总觉得这不是一个好方法，PS:毕竟数据长度是不可控的嘛；在网上翻阅了各种资料后，发现了一个满足我这个需求的大神博客，但他写的太复杂了，于是最终决定自己来实现。
实现思路 下面来说说我的思路；首先我们要用到TableLayout这个布局，其次就是以代码的方式不断的往这个布局里塞TableRow，最后在TableLayout的外面套上HorizontalScrollView和ScrollView即可
代码实现 &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;ScrollView android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;HorizontalScrollView android:layout_width="wrap_content" android:layout_height="wrap_content" android:scrollbars="none"&gt; &lt;TableLayout android:id="@+id/tl_device_list_content" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;/HorizontalScrollView&gt; &lt;/ScrollView&gt; &lt;/LinearLayout&gt; 向TableLayout中添加TableRow
public class MainActivity extends Activity { private TableLayout tlContent; private List&lt;TextView&gt; tvList = new ArrayList&lt;TextView&gt;(); private static final int WC = ViewGroup.LayoutParams.WRAP_CONTENT; private static final int MP = ViewGroup.LayoutParams.MATCH_PARENT; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_devicequery_list); tlContent = (TableLayout) findViewById(R.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/189134b12a78c87e947f794289611a51/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/27c3f890fbc2ef08adea78a61084fda4/" rel="bookmark">
			如何将Eclipse中的项目迁移到Android Studio 中
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自http://www.android-studio.org/index.php/docs/guide/129-eclipse-to-androidstdio
如果你之前有用Eclipse做过安卓开发，现在想要把Eclipse中的项目导入到Android Studio的环境中，那么首先要做的是生成Build Gradle的文件。因为Android Studio 是用Gradle来管理项目的，具体操作步骤如下：
从Eclipse中导出
1.将你的ADT插件版本升级到22.0以上。 2.在Eclipse中，选择File--&gt;Export。 3.在弹出的导出窗口中，打开Android的文件夹，选择“Generate Gradle Build Files”。 4.选中你想要导入到Android Studio中的项目，Finish。 PS:导出的项目将会和原来的项目在同一目录，覆盖原来的同时，会新增一个叫build.gradle的文件，导入Android Studio时将首先读取这个文件。 导入到Android Studio 1.在Android Studio 中，首先关掉你当前的打开的项目。 2.在欢迎界面，点击Import Project（注：也是可以直接在菜单选择Import project的） 3.选中你在Eclipse中导出的项目，展开目录，点击build.gradle文件，然后OK 4.在之后的弹出对话框中，会要求你选择Gradle的配置，选中Use gradle wrapper.(注：也可以自定义你本机装的Gradle) PS：如果没有Grade build文件，也是可以将普通的安卓项目导入到Android Studio中，它会用现有的Ant build.但为了更好地使用之后的功能和充分使用构建变量，还是强烈地建议先从ADT插件中生成Gradle文件再导入Android Studio
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0d307b6a25c0600e9d994f9c862944f4/" rel="bookmark">
			CentOS 7 设置 svn 开机启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 安装好 svn 服务后，默认是没有随系统启动自动启动的， CentOS 7 的 /etc/rc.d/rc.local 是没有执行权限的， 系统建议创建 systemd service 启动服务
于是查看 systemd 里 svn 的配置文件 /lib/systemd/system/svnserve.service
[Unit] Description=Subversion protocol daemon After=syslog.target network.target [Service] Type=forking EnvironmentFile=/etc/sysconfig/svnserve ExecStart=/usr/bin/svnserve --daemon --pid-file=/run/svnserve/svnserve.pid $OPTIONS [Install] WantedBy=multi-user.target 找到 svn 的 service 配置文件 /etc/sysconfig/svnserve 编辑配置文件 vi /etc/sysconfig/svnserve 将 OPTIONS="-r /var/svn" 改为 svn 版本库存放的目录，:wq 保存退出 在提示符下输入
systemctl enable svnserve.service 重启服务器，输入
ps -aux | grep 'svn' 看 svn 服务启动了没有 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92702f29eb4a0788c274492d78eb6bb/" rel="bookmark">
			this关键字和super关键字
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		this关键字 this关键字在Java中经常使用，它主要有以下作用： 1，使用this调用本类中的属性。 2，使用this调用构造方法。 3，表示当前对象
1_使用this调用本类中的属性。 在一个类的方法或构造方法内部，当成员变量被局部变量隐藏时，想使用成员变量的话，可以使用“this.成员变量名”这样的格式来引用成员变量名
class Person { private String name; private int age; public Person() { // TODO Auto-generated constructor stub } public Person(String n,int a) { this.name=n; this.age=a; } } 2_使用this调用构造方法 Java中构造方法的名称必须与类名一致，实际中需要对构造方法进行重载来形成多个构造方法，在调用构造方法时可以用this。使用this关键字调用构造方法时，this（）必须放在构造方法的首行。
class Person { private String name; private int age; private String sex; public Person() { // TODO Auto-generated constructor stub this.age=18; } public Person(String n) { this(); this.name=n; } public Person(String n,String s) { this(n); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a92702f29eb4a0788c274492d78eb6bb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e1add6b280e9abc722834aa366f389f4/" rel="bookmark">
			Linux下修改配置文件导致系统无法启动问题解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于使用SSH Secure Shell Client访问LINUX系统时中文无法正常显示，通过度娘找到一篇文章，说是通过修改/etc/default/locale文件的字符集问中文即可。按照此种方式修改，重启后发现Linux无法正常启动，急死宝宝了，总不至于为了这点问题重做系统，冷静了一下，发现重启时有个菜单， 猜测第二个应该是恢复模式，直接选中，进入恢复引导模式
通过逐个尝试，发现root方式，输入root用户口令能够进入到系统文件目录，心里一阵激动，心想既然能进入文件系统，十有八九就可以通过vi命令修改坏掉的locale文件
，果然不出山人所料，通过cd /etc/default/跳转到locale文件所在目录，使用sudo vi locale 进入编辑界面，修改为原来的编码格式，如图
编辑好之后连按SHIT+Z两次 ，保存并退出编辑模式，敲入reboot重启，发现linux能够正常启动了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/38b66a3a34a12e1e31204be854d7ec29/" rel="bookmark">
			移动火柴问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 基础版 14-1+1=3 将加号的一横，竖放置于前面 ⇒ 114-111=3； 2. 提高版 3. 乱入版 1- 701 = 2（移动）
1 加 1 = 2244=18 （加一根火柴）
24H=1日 3. 总结 2 ⇒ 3+ ⇒ 1,1 / 1, - / - - 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90417523d75921523b1ae8b3df3a2f5e/" rel="bookmark">
			String类的concat()方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		String类的concat()方法：
1 public class MyClass 2 { 3 public static void main(String[] args) 4 { 5 String str1="str1"; 6 String str2="str2"; 7 String str3="str3"; 8 str1.concat(str2); 9 System.out.print(str3.concat(str1)); //str3str1 10 } 11 } 转载于:https://www.cnblogs.com/wangfeihu/p/5813164.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a7ac630c22ee42546a37efbb93b59e2/" rel="bookmark">
			关于RANSAC的理解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先说最小二乘。
ok，你手头有一堆数据，比如这些蓝点：
那么我们假设它符合一个直线模型：y=ax+b，用最小二乘就可以很容易求解出未知参数a和b。最小二乘大法确实好哇，毕竟高斯用它来估计谷神星的轨道（https://math.berkeley.edu/~mgu/MA221/Ceres_Presentation.pdf；http://www.cnblogs.com/washa/p/3164212.html）。
但是，当你的数据充满了噪声时，比如下面图中的黑点，很明显中间有一条妥妥的直线，但是你也用最小二乘去解它，于是悲剧了：
很显然最小二乘失效了，这时候我们就要用RANSAC去解决它。
RANSAC的使用条件是：
1.输入是一组带污染的观测数据，其中的可信数据占了大多数；
2.有一个可以解释可信观测数据的参数化模型
RANSAC的思想是（引自wiki，汉化部分有修改）：
Select a random subset of the original data. Call this subset the hypothetical inliers. 从观测数据中随机选择一个子集，称之为hypothetical inliers。A model is fitted to the set of hypothetical inliers.估计出适合于这些个hypothetical inliers的模型 All other data are then tested against the fitted model. Those points that fit the estimated model well, according to some model-specific loss function, are considered as part of the consensus set. 用这个模型测试其他的数据，根据损失函数，得到符合这个模型的点，称为一致性集合：consensus set。 The estimated model is reasonably good if sufficiently many points have been classified as part of the consensus set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a7ac630c22ee42546a37efbb93b59e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7ddff49d121909511413385855eb2fc/" rel="bookmark">
			ajax循环输出数据通常用的2种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 $.each 和 for循环
记得引入 jquery目录要对
1.html 页面
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="alert"&gt;&lt;/div&gt; &lt;ul class="list"&gt; &lt;/ul&gt; &lt;input type="button" id="btn" value="请求数据"&gt; &lt;input type="button" id="clear" value="清除数据"&gt; &lt;script type="text/javascript" src="../public/js/jquery-2.0.3.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function(){ $("#btn").click(function(){ $.ajax({ type:"get", dataType:"json", url:"data.json", //	data:{}, success:function(res){ $(".alert").html("请求成功") var html=''; //第一次方式 //	$.each(res,function(i,v){ //	html+="&lt;li data-id="+v.id+"&gt;"+v.name+"&lt;/li&gt;" //	}) //第二次方式 for(var i=0;i&lt;res.length;i++){ html+="&lt;li data-id="+res[i].id+"&gt;"+res[i].name+"&lt;/li&gt;" } $(".list").html(html) }, error:function(){ $(".alert").html("请求失败") } }) }) $("#clear").click(function(){ $(".list").html("") $(".alert").html("") }) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac33831404dc91e38f38a53b34356bcc/" rel="bookmark">
			linux中init.d文件夹的说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、简单说明
/etc/init.d 是 /etc/rc.d/init.d 的软链接(soft link)。可以通过 ll 命令查看。
ls -ld /etc/init.d lrwxrwxrwx. 1 root root 11 Aug 30 2015 /etc/init.d -&gt; rc.d/init.d 都是用来放服务脚本的，当Linux启动时，会寻找这些目录中的服务脚本，并根据脚本的run level确定不同的启动级别。
在制作服务脚本的过程中，使用了Linux的两个版本，CentOS和Ubuntu，需要在两个版本中都可以开机启动服务。但Ubuntu没有 /etc/rc.d/init.d这个目录，所以，为了保持同一种服务在CentOS和Ubuntu使用的统一性，将服务脚本（注：服务脚本在两个不同版本中是不同的）都放在 /etc/init.d 目录下，最终达到的效果是相同的。
需要说明的是：在CentOS和Ubuntu两个版本中，除了服务脚本放置的目录是相同的，服务脚本的编写及服务配置都是不同的。比如CentOS使用Chkconfig进行配置，而Ubuntu使用sysv-rc-conf进行配置。
2 系统启动过程
1）BIOS自检 ，BIOS的功能由两部分组成，分别是POST码和Runtime服务。POST阶段完成后它将从存储器中被清除，而Runtime服务会被一直保留，用于目标操作系统的启动。BIOS两个阶段所做的详细工作如下：
步骤1：上电自检POST(Power-on self test)，主要负责检测系统外围关键设备（如：CPU、内存、显卡、I/O、键盘鼠标等）是否正常。例如，最常见的是内存松动的情况，BIOS自检阶段会报错，系统就无法启动起来；
步骤2：步骤1成功后，便会执行一段小程序用来枚举本地设备并对其初始化。这一步主要是根据我们在BIOS中设置的系统启动顺序来搜索用于启动系统的驱动器，如硬盘、光盘、U盘、软盘和网络等。我们以硬盘启动为例，BIOS此时去读取硬盘驱动器的第一个扇区(MBR，512字节)，然后执行里面的代码。实际上这里BIOS并不关心启动设备第一个扇区中是什么内容，它只是负责读取该扇区内容、并执行。
至此，BIOS的任务就完成了，此后将系统启动的控制权移交到MBR部分的代码。
2）系统引导，通常情况下，诸如lilo、grub这些常见的引导程序都直接安装在MBR中。详细过程，请自行google
3）启动内核，它首先会去解析grub的配置文件/boot/grub/grub.conf，然后加载内核镜像到内存中，并将控制权转交给内核。而内核会立即初始化系统中各设备并做相关的配置工作，其中包括CPU、I/O、存储设备等。
关于Linux的设备驱动程序的加载，有一部分驱动程序直接被编译进内核镜像中，另一部分驱动程序则是以模块的形式放在initrd(ramdisk)中。
Linux内核需要适应多种不同的硬件架构，但是将所有的硬件驱动编入内核又是不实际的，而且内核也不可能每新出一种硬件结构，就将该硬件的设备驱动写入内核。实际上Linux的内核镜像仅是包含了基本的硬件驱动，在系统安装过程中会检测系统硬件信息，根据安装信息和系统硬件信息将一部分设备驱动写入 initrd 。这样在以后启动系统时，一部分设备驱动就放在initrd中来加载。这里有必要给大家再多介绍一下initrd这个东东：
initrd 的英文含义是 bootloader initialized RAM disk，就是由 boot loader 初始化的内存盘。在 linu2.6内核启动前，boot loader 会将存储介质中的 initrd 文件加载到内存，内核启动时会在访问真正的根文件系统前先访问该内存中的 initrd 文件系统。在 boot loader 配置了 initrd 的情况下，内核启动被分成了两个阶段，第一阶段先执行 initrd 文件系统中的init，完成加载驱动模块等任务，第二阶段才会执行真正的根文件系统中的 /sbin/init 进程。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ac33831404dc91e38f38a53b34356bcc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2585a3553c7d9adaf22505992fbe810f/" rel="bookmark">
			汇编 - ORG指令详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ORG指令 ORG是Origin的缩写：起始地址，源。在汇编语言源程序的开始通常都用一条ORG伪指令来实现规定程序的起始地址。如果不用ORG规定则汇编得到的目标程序将从0000H开始。例如：
ORG 2000H START：MOV AX，#00H 汇编语言源程序中若没有ORG伪指令，则程序执行时，指令代码被放到自由内存空间的CS:0处；若有ORG伪指令，编译器则把其后的指令代码放到ORG伪指令指定的偏移地址。两个ORG伪指令之间，除了指令代码，若有自由空间，则用0填充。 预处理--&gt;编译--&gt;汇编--&gt;链接，这是高级语言的编译全过程。对于纯汇编，就只有汇编和链接两个步骤。 org指令是链接时使用的，不是汇编那一步使用的。即不是cpu的一条指令，而是给编译器看的伪指令。 在51单片机、x86 dos、win32 exe中实现都有差异。 以最简单的51单片机为例，编译器最终链接生成HEX文件，再烧录到51的rom中去。单片机很简单，没有x86的分段、分页，启动就是从rom的0x0的位置开始执行。同时0x30H位置开始存放中断向量， 所以单片机程序一般开头就是： ORG 0000H AJMP MAIN ORG 0030H 这里的ORG 0000H指令，使得程序链接成HEX文件时，AJMP MAIN这条指令的机器码就在HEX文件的0x0位置。这是链接器的工作。 至于x86 dos和win32 exe，ORG的实现就复杂了，ORG不再是绝对定位，只能在一个段里相对定位。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12c653d081e3cd4174835a92462428c/" rel="bookmark">
			android-studio 签名文件使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在项目中接触到了android-studio的系统文件签名，未免自己忘记了，就来占坑，这部分在今后应用发布时也需要管理。
让Android Studio集成系统签名，需要用到一个工具keytool-importkeypair，详见下文。
keytool-importkeypair
keytool-importkeypair – A shell script to import key/certificate pairs into an existing Java keystore
这个工具的作用是将系统签名的相关信息导入到已有的签名文件里。
工具的使用方法可以通过–help或README.textile来寻求帮助，或参考使用keytool工具 这篇文章。
相关文件platform.x509.pem、platform.pk8、keytool-importkeypair、demo.jks、signature.sh我的做法是在App根目录新建Signature文件夹专门存放签名相关文件。
步骤1、生成demo.jks签名文件
2、编写签名脚本signature.sh，内容如下：
#!/bin/sh # 转换系统签名命令 ./keytool-importkeypair -k demo.jks -p 123456 -pk8 platform.pk8 -cert platform.x509.pem -alias demo # demo.jks : 签名文件 # 123456 : 签名文件密码 # platform.pk8、platform.x509.pem : 系统签名文件 # demo : 签名文件别名 为脚本文件添加可执行权限：
$ sudo chmod a+x signature.sh 执行脚本：
$ ./signature.sh ./signature.sh执行脚本动作一定要执行，执行后会提示是否存在.jks签名文件，默认为[no]，如果像前述一样新建demo，则可以输入yes。执行成功系统会提示
Import command completed: 1 entries successfully improted, 0 entries failed or cancelled.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a12c653d081e3cd4174835a92462428c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/070835cf97027ab47beca3ea58921e4e/" rel="bookmark">
			MediaRecorder录音,解决stop,start错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Recorder { private static final int MAX_LENGTH=1000*60*3;//3分钟 private MediaRecorder recorderl; public Recorder() { initial(); } private void initial() { recorderl=new MediaRecorder(); String path= Environment.getExternalStorageDirectory().getAbsolutePath()+"/test.amr"; recorderl.setAudioSource(MediaRecorder.AudioSource.MIC); recorderl.setOutputFormat(MediaRecorder.OutputFormat.RAW_AMR); recorderl.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB); recorderl.setMaxDuration(MAX_LENGTH); recorderl.setOutputFile(path); } public void startRecorder() { initial(); try { recorderl.prepare(); } catch (IOException e) { e.printStackTrace(); } recorderl.start(); } public void stopRecorder() { if(recorderl!=null) { recorderl.stop(); recorderl.release(); } recorderl=null; } public void startRecorderVoice() { handler.postDelayed(run,200); } public void stopRecorderVoice() { handler.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/070835cf97027ab47beca3ea58921e4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fdd86eabdeaadee22ec750973b6b875a/" rel="bookmark">
			颜色代码大全 - RGB颜色查询对照表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在学习android开发时发现需要配置颜色时却不知道每种颜色对应的代码是什么，所以从网上查阅了相关资料，将每种颜色对应的代码列举如下：
其中：AA 指定透明度。 00 是完全透明。 FF 是完全不透明。超出取值范围的值将被恢复为默认值。
ffff00
ffff33ffff66ffff99ffffccffffffffcc00ffcc33ffcc66ffcc99ffccccffccffff9900ff9933ff9966ff9999ff99ccff99ffff6600ff6633ff6666ff6699ff66ccff66ffff3300ff3333ff3366ff3399ff33ccff33ffff0000ff0033ff0066ff0099ff00ccff00ffccff00ccff33ccff66ccff99ccffccccffffcccc00cccc33cccc66cccc99ccccccccccffcc9900cc9933cc9966cc9999cc99cccc99ffcc6600cc6633cc6666cc6699cc66cccc66ffcc3300cc3333cc3366cc3399cc33cccc33ffcc0000cc0033cc0066cc0099cc00cccc00ff99ff0099ff3399ff6699ff9999ffcc99ffff99cc0099cc3399cc6699cc9999cccc99ccff9999009999339999669999999999cc9999ff9966009966339966669966999966cc9966ff9933009933339933669933999933cc9933ff9900009900339900669900999900cc9900ff66ff0066ff3366ff6666ff9966ffcc66ffff66cc0066cc3366cc6666cc9966cccc66ccff6699006699336699666699996699cc6699ff6666006666336666666666996666cc6666ff6633006633336633666633996633cc6633ff6600006600336600666600996600cc6600ff33ff0033ff3333ff6633ff9933ffcc33ffff33cc0033cc3333cc6633cc9933cccc33ccff3399003399333399663399993399cc3399ff3366003366333366663366993366cc3366ff3333003333333333663333993333cc3333ff3300003300333300663300993300cc3300ff00ff0000ff3300ff6600ff9900ffcc00ffff00cc0000cc3300cc6600cc9900cccc00ccff0099000099330099660099990099cc0099ff0066000066330066660066990066cc0066ff0033000033330033660033990033cc0033ff0000000000330000660000990000cc0000ff #FFFFFF
#FFFFF0
#FFFFE0
#FFFF00
#FFFAFA
#FFFAF0
#FFFACD
#FFF8DC
#FFF68F
#FFF5EE
#FFF0F5
#FFEFDB
#FFEFD5
#FFEC8B
#FFEBCD
#FFE7BA
#FFE4E1
#FFE4C4
#FFE4B5
#FFE1FF
#FFDEAD
#FFDAB9
#FFD700
#FFD39B
#FFC1C1
#FFC125
#FFC0CB
#FFBBFF
#FFB90F
#FFB6C1
#FFB5C5
#FFAEB9
#FFA54F
#FFA500
#FFA07A
#FF8C69
#FF8C00
#FF83FA
#FF82AB
#FF8247
#FF7F50
#FF7F24
#FF7F00
#FF7256
#FF6EB4
#FF6A6A
#FF69B4
#FF6347
#FF4500
#FF4040
#FF3E96
#FF34B3
#FF3030
#FF1493
#FF00FF
#FF0000
#FDF5E6
#FCFCFC
#FAFAFA
#FAFAD2
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fdd86eabdeaadee22ec750973b6b875a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b9f3b3d907c08beea0ad974a2b041758/" rel="bookmark">
			android框架之Retrofit的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Retrofit:Square提供的开源产品，为Android平台的应用提供一个类型安全的REST客户端。 REST客户端：REST指一组架构约束条件和原则，满足约束条件和原则的应用程序设计。 架构，软件体系结构分为三部分：构建，用于描述计算机；连接器，用于描述构建的链接部分；配置将构建和连接器组成有机整体。 web基本技术： URI（统一资源标示符）HTTP（超文本传输协议）（post、get、put、delete） Hypertext。 1、每个资源都应该有唯一的一个标识 2、使用标准的方法更改资源的状态 3、request和response的自描述 4、资源多重表述 5、无状态服务 下面开始将如何使用Retrofit框架来请求网络数据。 首先，需要导入两个包： 方法：在build.gradle文件中加入如下
compile 'com.squareup.retrofit2:retrofit:2.1.0' compile 'com.squareup.retrofit2:converter-gson:2.1.0' 然后编写接口代码，用于解决请求网络地址问题： 以http://m2.qiushibaike.com/article/list/text?page=1 为例。
public interface NetConfig { String BASE_URL = "http://m2.qiushibaike.com"; String URL = "http://www.shougongke.com/index.php?m=Mobq_data&amp;a=topic&amp;versions=1.2.1&amp;page=1"; /* 本地内网的地址 */ String POST_URL = "http://10.0.168.230:8080/zhangzhang/login"; } 然后采用Gson解析，得到modle. 接着就要在Activity中编写代码了。
1，声明两个私有变量
private Retrofit mRetrofit; private NetInterFace netInterFace; //初始化Retrofit mRetrofit = new Retrofit.Builder().baseUrl(NetConfig.BASE_URL).addConverterFactory(GsonConverterFactory.create()).build(); netInterFace = mRetrofit.create(NetInterFace.class); Call&lt;ResponseBody&gt; netData = netInterFace.getNetData(); netData.enqueue(new Callback&lt;ResponseBody&gt;() { @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) { if(response.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b9f3b3d907c08beea0ad974a2b041758/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/adab066b6bcca43ee003305243ca153c/" rel="bookmark">
			idea 如何在新窗口中打开项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以前一直再用eclipse，可以同时打开好几个项目，idea中同样支持打开多个项目，只是会弹出窗口让用户确认，一般选择使用new window打开就可以新开一个工作区，由于不小心操作成了使用同一个窗口打开项目，并点中了以后都是用改设置，结果悲剧了。好在可以通过设置再更改回来，具体方法如下：
点击file/setting,打开设置页面，依次选中Appearance &amp; Behavior--System Settings菜单，使用open projcect in new window即可。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/afaf16a5065f62cad0bce9b97f63f48b/" rel="bookmark">
			ActivityManager(4)—isLowRamDevice ()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 ActivityManager：isLowRamDevice () 1.作用 返回值是boolean值，用于判断设备是否是一个低内存的设备，如果返回为true则建议开发者减少一些消耗内存的操作。Android规定运行内存小于512M的设备为低内存设备。 2.源码 public boolean isLowRamDevice() { return isLowRamDeviceStatic(); } public static boolean isLowRamDeviceStatic() { return "true".equals(SystemProperties.get("ro.config.low_ram", "false")); } 3.分析及说明 代码比较简单，这里不对代码进行过多的分析。 我们来了解一下ro.config.low_ram，这个ro.config.low_ram是Android系统对小内存设备的优化的判断。 系统规定内存小于512M的设备被定义为小内存设备，并要求移动应用对小内存设备进行相应的优化。 这个ro.config.low_ram的值是可以修改的，在/system/build.prop里进行修改， ro.config.low_ram=true（小内存设备）； ro.config.low_ram=false（非小内存设备）； 但是不建议修改，以免影响一些优质应用对小内存设备的优化效果。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f42a9e68f72cf12b4b847bcb06aa9b0f/" rel="bookmark">
			ActivityManager(3)—clearApplicationUserData()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ActivityManager：clearApplicationUserData() 1.作用 用于应用清除用户数据，相当于在设置中清除应用数据，但是不卸载该应用。 2.源码 public boolean clearApplicationUserData() { return clearApplicationUserData(mContext.getPackageName(), null); } public boolean clearApplicationUserData(String packageName, IPackageDataObserver observer) { try { return ActivityManagerNative.getDefault().clearApplicationUserData(packageName, observer, UserHandle.myUserId()); } catch (RemoteException e) { return false; } } 3.分析及说明 我们来关注一下核心的代码 return ActivityManagerNative.getDefault().clearApplicationUserData(packageName,observer, UserHandle.myUserId()); 阅读过Android源码的同学肯定知道ActivityManager的大多数功能都是调用了ActivityManagerNative类接口来完成的，因此，我们寻迹来看ActivityManagerNative的代码，查看clearApplicationUserData（）方法的实现。 public boolean clearApplicationUserData(final String packageName, final IPackageDataObserver observer, final int userId) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeString(packageName); data.writeStrongBinder((observer != null) ? observer.asBinder() : null); data.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f42a9e68f72cf12b4b847bcb06aa9b0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25f6fe5c249ce936d18c83e8c2d36b82/" rel="bookmark">
			ActivityManager(2)—getMemoryClass()及getLargeMemoryClass()
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ActivityManager：getMemoryClass()及getLargeMemoryClass() 1.作用：用于获取应用可以使用的最大内存。 2.源码： public int getMemoryClass() { return staticGetMemoryClass(); } /** @hide */不对外暴露的方法 static public int staticGetMemoryClass() { String vmHeapSize = SystemProperties.get("dalvik.vm.heapgrowthlimit", ""); if (vmHeapSize != null &amp;&amp; !"".equals(vmHeapSize)) { return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length()-1)); } return staticGetLargeMemoryClass(); } public int getLargeMemoryClass() { return staticGetLargeMemoryClass(); } /** @hide */ static public int staticGetLargeMemoryClass() { String vmHeapSize = SystemProperties.get("dalvik.vm.heapsize", "16m"); return Integer.parseInt(vmHeapSize.substring(0, vmHeapSize.length() - 1)); } 3.分析及说明 两个方法共同的功能是返回当前设备的每个应用程序使用内存的近似值。提供一个内存限制的界限，方便开发者可以再规定的内存限制内让应用运行的更好。 返回值以兆为单位；基线Android内存是16（这恰好是这些设备的java堆内存限制）；更有些设备可能返回24或更高的数字。 两者区别在于：getMemoryClass()是系统为应用分配的内存，并没有额外的扩充； 而getLargeMemoryClass()是开发者通过设置manifest文件中的&lt;application&gt;标签中largeHeap属性的值为"true"，获得应用可使用的最大内存； 但是作为开发者，建议不要配置manifest获取最大内存，这使得应用在扩展性方面有很大限制，建议优化内存已达到节省内存的目的。 SystemProperties： String vmHeapSize = SystemProperties.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25f6fe5c249ce936d18c83e8c2d36b82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60a338f845811361915d4f58d74f01f4/" rel="bookmark">
			ActivityManager(1)—ActivityManager总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ActivityManager总结列表 1.公共方法 （1）getMemoryClass() 通过以兆为单位获取当前应用可用的内存大小。 （2）getLargeMemoryClass() 当开发者在 manifest 文件中的 &lt;application&gt; 标签中设置 largeHeap 属性的值为 "true"时, 当前应用就可以获取到系统分配的最大堆内存. 如果你设置了该值, 可以通过 ActivityManager 的 getLargeMemoryClass() 函数获取最大的堆内存. （3）isLowRamDevice () 返回值是boolean值，用于判断设备是否是一个低内存的设备，如果返回为true则建议开发者减少一些消耗内存的操作。 Android规定运行内存小于512M的设备为低内存设备。 （4）addAppTask (Activity activity, Intent intent, ActivityManager.TaskDescription description, Bitmap thumbnail) 为应用创建一个新的任务，并放在任务栈的栈顶。 参数：activity ：需要被添加的Activity，用于确定进入任务栈的入口 intent ：用于启动Activity的Intent description：携带的信息描述 thumbnail ：缩略图资源 （5）clearApplicationUserData() 用于应用清除用户数据，相当于在设置中清除应用数据，但是不卸载该应用。 （6）dumpPackageState(FileDescriptor fd, String packageName) 用于获取相应包名对应的apk的各种状态信息。 （7）getDeviceConfigurationInfo () 用于获取设备的信息，返回值是ConfigurationInfo。 （9）getLauncherLargeIconSize () 用于获取Lancher启动器的图标大小，返回值是int类型。 （10）getMemoryInfo (ActivityManager.MemoryInfo outInfo) 用于获取当前系统的内存情况。 （11）getAppTasks() 用于获取与应用相关的任务列表，返回类型List&lt;ActivityManager.AppTask&gt;。 （12）getAppTaskThumbnailSize() 用于返回Activity中缩略图的合适尺寸。 （13）getProcessMemoryInfo（） 返回一个或者多个进程使用内存的情况，返回值是一个内存信息的数组MemoryInfo[]。 （14）getProcessesInErrorState() 返回一个或多个错误进程的信息。 （15）getRunningAppProcesses() 返回在设备上运行的应用程序进程列表，返回List&lt;ActivityManager.RunningAppProcessInfo&gt; 。 （16）getRunningServiceControlPanel() 返回一个PendingIntent，该PendingIntent会启动一个控制面板，里面会显示当前系统运行的一系列服务。 （17）getRunningServices(int maxNum) 返回当前正在运行的服务的列表，返回值List&lt;ActivityManager.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60a338f845811361915d4f58d74f01f4/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/page/484/">«</a>
	<span class="pagination__item pagination__item--current">485/516</span>
	<a class="pagination__item pagination__item--next btn" href="/page/486/">»</a>
</div>

			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 编程鬼谷子的博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://www.w3counter.com/tracker.js?id=151347"></script>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>